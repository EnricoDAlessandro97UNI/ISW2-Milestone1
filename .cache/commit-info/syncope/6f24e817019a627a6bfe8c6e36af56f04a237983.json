{"sha":"6f24e817019a627a6bfe8c6e36af56f04a237983","node_id":"MDY6Q29tbWl0NjM2ODc5MDYyOjZmMjRlODE3MDE5YTYyN2E2YmZlOGM2ZTM2YWY1NmYwNGEyMzc5ODM=","commit":{"author":{"name":"Francesco Chicchiriccò","email":"ilgrosso@apache.org","date":"2015-01-26T16:27:27Z"},"committer":{"name":"Francesco Chicchiriccò","email":"ilgrosso@apache.org","date":"2015-01-26T16:27:27Z"},"message":"[SYNCOPE-620] Simplifying Activiti init + splitting task IT cases","tree":{"sha":"42b41e528ac8c8889be40dce0a0865c4f4e26b7f","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/git/trees/42b41e528ac8c8889be40dce0a0865c4f4e26b7f"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/git/commits/6f24e817019a627a6bfe8c6e36af56f04a237983","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/6f24e817019a627a6bfe8c6e36af56f04a237983","html_url":"https://github.com/EnricoDAlessandro97UNI/syncope/commit/6f24e817019a627a6bfe8c6e36af56f04a237983","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/6f24e817019a627a6bfe8c6e36af56f04a237983/comments","author":{"login":"ilgrosso","id":1064664,"node_id":"MDQ6VXNlcjEwNjQ2NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/1064664?v=4","gravatar_id":"","url":"https://api.github.com/users/ilgrosso","html_url":"https://github.com/ilgrosso","followers_url":"https://api.github.com/users/ilgrosso/followers","following_url":"https://api.github.com/users/ilgrosso/following{/other_user}","gists_url":"https://api.github.com/users/ilgrosso/gists{/gist_id}","starred_url":"https://api.github.com/users/ilgrosso/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ilgrosso/subscriptions","organizations_url":"https://api.github.com/users/ilgrosso/orgs","repos_url":"https://api.github.com/users/ilgrosso/repos","events_url":"https://api.github.com/users/ilgrosso/events{/privacy}","received_events_url":"https://api.github.com/users/ilgrosso/received_events","type":"User","site_admin":false},"committer":{"login":"ilgrosso","id":1064664,"node_id":"MDQ6VXNlcjEwNjQ2NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/1064664?v=4","gravatar_id":"","url":"https://api.github.com/users/ilgrosso","html_url":"https://github.com/ilgrosso","followers_url":"https://api.github.com/users/ilgrosso/followers","following_url":"https://api.github.com/users/ilgrosso/following{/other_user}","gists_url":"https://api.github.com/users/ilgrosso/gists{/gist_id}","starred_url":"https://api.github.com/users/ilgrosso/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ilgrosso/subscriptions","organizations_url":"https://api.github.com/users/ilgrosso/orgs","repos_url":"https://api.github.com/users/ilgrosso/repos","events_url":"https://api.github.com/users/ilgrosso/events{/privacy}","received_events_url":"https://api.github.com/users/ilgrosso/received_events","type":"User","site_admin":false},"parents":[{"sha":"16984bdafb8572f7dd552a50d88e25f82e1f2e99","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/16984bdafb8572f7dd552a50d88e25f82e1f2e99","html_url":"https://github.com/EnricoDAlessandro97UNI/syncope/commit/16984bdafb8572f7dd552a50d88e25f82e1f2e99"}],"stats":{"total":1909,"additions":1000,"deletions":909},"files":[{"sha":"afc97529a458280e4981af4d0879b437685f2ef7","filename":"syncope620/fit/reference/src/test/java/org/apache/syncope/fit/server/reference/AbstractTaskITCase.java","status":"added","additions":138,"deletions":0,"changes":138,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/6f24e817019a627a6bfe8c6e36af56f04a237983/syncope620%2Ffit%2Freference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fserver%2Freference%2FAbstractTaskITCase.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/6f24e817019a627a6bfe8c6e36af56f04a237983/syncope620%2Ffit%2Freference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fserver%2Freference%2FAbstractTaskITCase.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Ffit%2Freference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fserver%2Freference%2FAbstractTaskITCase.java?ref=6f24e817019a627a6bfe8c6e36af56f04a237983","patch":"@@ -0,0 +1,138 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.fit.server.reference;\n+\n+import static org.apache.syncope.fit.server.reference.AbstractITCase.taskService;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.fail;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.syncope.common.lib.to.AbstractTaskTO;\n+import org.apache.syncope.common.lib.to.TaskExecTO;\n+import org.apache.syncope.common.lib.to.UserTO;\n+\n+public abstract class AbstractTaskITCase extends AbstractITCase {\n+\n+    protected static final Long SYNC_TASK_ID = 4L;\n+\n+    protected static final Long SCHED_TASK_ID = 5L;\n+\n+    protected static class ThreadExec implements Callable<TaskExecTO> {\n+\n+        private final AbstractTaskITCase test;\n+\n+        private final Long taskKey;\n+\n+        private final int maxWaitSeconds;\n+\n+        private final boolean dryRun;\n+\n+        public ThreadExec(AbstractTaskITCase test, Long taskKey, int maxWaitSeconds, boolean dryRun) {\n+            this.test = test;\n+            this.taskKey = taskKey;\n+            this.maxWaitSeconds = maxWaitSeconds;\n+            this.dryRun = dryRun;\n+        }\n+\n+        @Override\n+        public TaskExecTO call() throws Exception {\n+            return test.execSyncTask(taskKey, maxWaitSeconds, dryRun);\n+        }\n+    }\n+\n+    /**\n+     * Remove initial and synchronized users to make test re-runnable.\n+     */\n+    protected void removeTestUsers() {\n+        for (int i = 0; i < 10; i++) {\n+            String cUserName = \"test\" + i;\n+            try {\n+                UserTO cUserTO = readUser(cUserName);\n+                userService.delete(cUserTO.getKey());\n+            } catch (Exception e) {\n+                // Ignore\n+            }\n+        }\n+    }\n+\n+    protected TaskExecTO execSyncTask(final Long taskKey, final int maxWaitSeconds, final boolean dryRun) {\n+        AbstractTaskTO taskTO = taskService.read(taskKey);\n+        assertNotNull(taskTO);\n+        assertNotNull(taskTO.getExecutions());\n+\n+        int preSyncSize = taskTO.getExecutions().size();\n+        TaskExecTO execution = taskService.execute(taskTO.getKey(), dryRun);\n+        assertEquals(\"JOB_FIRED\", execution.getStatus());\n+\n+        int i = 0;\n+        int maxit = maxWaitSeconds;\n+\n+        // wait for sync completion (executions incremented)\n+        do {\n+            try {\n+                Thread.sleep(1000);\n+            } catch (InterruptedException e) {\n+            }\n+\n+            taskTO = taskService.read(taskTO.getKey());\n+\n+            assertNotNull(taskTO);\n+            assertNotNull(taskTO.getExecutions());\n+\n+            i++;\n+        } while (preSyncSize == taskTO.getExecutions().size() && i < maxit);\n+        if (i == maxit) {\n+            fail(\"Timeout when executing task \" + taskKey);\n+        }\n+        return taskTO.getExecutions().get(taskTO.getExecutions().size() - 1);\n+    }\n+\n+    protected Map<Long, TaskExecTO> execSyncTasks(\n+            final Set<Long> taskKeys, final int maxWaitSeconds, final boolean dryRun) throws Exception {\n+\n+        final ExecutorService service = Executors.newFixedThreadPool(taskKeys.size());\n+        final List<Future<TaskExecTO>> futures = new ArrayList<>();\n+\n+        for (Long key : taskKeys) {\n+            futures.add(service.submit(new ThreadExec(this, key, maxWaitSeconds, dryRun)));\n+        }\n+\n+        final Map<Long, TaskExecTO> res = new HashMap<>();\n+\n+        for (Future<TaskExecTO> future : futures) {\n+            TaskExecTO taskExecTO = future.get(100, TimeUnit.SECONDS);\n+            res.put(taskExecTO.getTask(), taskExecTO);\n+        }\n+\n+        service.shutdownNow();\n+\n+        return res;\n+    }\n+\n+}"},{"sha":"4cd302b39ae64074b6746dee595540170f1a39a4","filename":"syncope620/fit/reference/src/test/java/org/apache/syncope/fit/server/reference/NotificationTaskITCase.java","status":"added","additions":156,"deletions":0,"changes":156,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/6f24e817019a627a6bfe8c6e36af56f04a237983/syncope620%2Ffit%2Freference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fserver%2Freference%2FNotificationTaskITCase.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/6f24e817019a627a6bfe8c6e36af56f04a237983/syncope620%2Ffit%2Freference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fserver%2Freference%2FNotificationTaskITCase.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Ffit%2Freference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fserver%2Freference%2FNotificationTaskITCase.java?ref=6f24e817019a627a6bfe8c6e36af56f04a237983","patch":"@@ -0,0 +1,156 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.fit.server.reference;\n+\n+import static org.apache.syncope.fit.server.reference.AbstractITCase.taskService;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import javax.ws.rs.core.Response;\n+import org.apache.syncope.client.lib.SyncopeClient;\n+import org.apache.syncope.common.lib.to.MembershipTO;\n+import org.apache.syncope.common.lib.to.NotificationTO;\n+import org.apache.syncope.common.lib.to.NotificationTaskTO;\n+import org.apache.syncope.common.lib.to.PagedResult;\n+import org.apache.syncope.common.lib.to.TaskExecTO;\n+import org.apache.syncope.common.lib.to.UserTO;\n+import org.apache.syncope.common.lib.types.IntMappingType;\n+import org.apache.syncope.common.lib.types.TaskType;\n+import org.apache.syncope.common.lib.types.TraceLevel;\n+import org.apache.syncope.common.rest.api.service.NotificationService;\n+import org.junit.FixMethodOrder;\n+import org.junit.Test;\n+import org.junit.runners.MethodSorters;\n+\n+@FixMethodOrder(MethodSorters.JVM)\n+public class NotificationTaskITCase extends AbstractTaskITCase {\n+\n+    @Test\n+    public void issueSYNCOPE81() {\n+        String sender = \"syncope81@syncope.apache.org\";\n+        createNotificationTask(sender);\n+        NotificationTaskTO taskTO = findNotificationTaskBySender(sender);\n+        assertNotNull(taskTO);\n+\n+        assertTrue(taskTO.getExecutions().isEmpty());\n+\n+        // generate an execution in order to verify the deletion of a notification task with one or more executions\n+        TaskExecTO execution = taskService.execute(taskTO.getKey(), false);\n+        assertEquals(\"NOT_SENT\", execution.getStatus());\n+\n+        int i = 0;\n+        int maxit = 50;\n+        int executions = 0;\n+\n+        // wait for task exec completion (executions incremented)\n+        do {\n+            try {\n+                Thread.sleep(1000);\n+            } catch (InterruptedException e) {\n+            }\n+\n+            taskTO = taskService.read(taskTO.getKey());\n+\n+            assertNotNull(taskTO);\n+            assertNotNull(taskTO.getExecutions());\n+\n+            i++;\n+        } while (executions == taskTO.getExecutions().size() && i < maxit);\n+\n+        assertFalse(taskTO.getExecutions().isEmpty());\n+\n+        taskService.delete(taskTO.getKey());\n+    }\n+\n+    @Test\n+    public void issueSYNCOPE86() {\n+        // 1. create notification task\n+        String sender = \"syncope86@syncope.apache.org\";\n+        createNotificationTask(sender);\n+\n+        // 2. get NotificationTaskTO for user just created\n+        NotificationTaskTO taskTO = findNotificationTaskBySender(sender);\n+        assertNotNull(taskTO);\n+        assertTrue(taskTO.getExecutions().isEmpty());\n+\n+        try {\n+            // 3. execute the generated NotificationTask\n+            TaskExecTO execution = taskService.execute(taskTO.getKey(), false);\n+            assertNotNull(execution);\n+\n+            // 4. verify\n+            taskTO = taskService.read(taskTO.getKey());\n+            assertNotNull(taskTO);\n+            assertEquals(1, taskTO.getExecutions().size());\n+        } finally {\n+            // Remove execution to make test re-runnable\n+            taskService.deleteExecution(taskTO.getExecutions().get(0).getKey());\n+        }\n+    }\n+\n+    private NotificationTaskTO findNotificationTaskBySender(final String sender) {\n+        PagedResult<NotificationTaskTO> tasks = taskService.list(TaskType.NOTIFICATION);\n+        assertNotNull(tasks);\n+        assertFalse(tasks.getResult().isEmpty());\n+        NotificationTaskTO taskTO = null;\n+        for (NotificationTaskTO task : tasks.getResult()) {\n+            if (sender.equals(task.getSender())) {\n+                taskTO = task;\n+            }\n+        }\n+        return taskTO;\n+    }\n+\n+    private void createNotificationTask(final String sender) {\n+        // 1. Create notification\n+        NotificationTO notification = new NotificationTO();\n+        notification.setTraceLevel(TraceLevel.FAILURES);\n+        notification.getEvents().add(\"[REST]:[UserLogic]:[]:[create]:[SUCCESS]\");\n+\n+        notification.setUserAbout(SyncopeClient.getUserSearchConditionBuilder().hasRoles(7L).query());\n+\n+        notification.setRecipients(SyncopeClient.getUserSearchConditionBuilder().hasRoles(8L).query());\n+        notification.setSelfAsRecipient(true);\n+\n+        notification.setRecipientAttrName(\"email\");\n+        notification.setRecipientAttrType(IntMappingType.UserPlainSchema);\n+\n+        notification.setSender(sender);\n+        String subject = \"Test notification\";\n+        notification.setSubject(subject);\n+        notification.setTemplate(\"optin\");\n+        notification.setActive(true);\n+\n+        Response response = notificationService.create(notification);\n+        notification = getObject(response.getLocation(), NotificationService.class, NotificationTO.class);\n+        assertNotNull(notification);\n+\n+        // 2. create user\n+        UserTO userTO = UserITCase.getUniqueSampleTO(\"syncope@syncope.apache.org\");\n+        MembershipTO membershipTO = new MembershipTO();\n+        membershipTO.setRoleId(7);\n+        userTO.getMemberships().add(membershipTO);\n+\n+        userTO = createUser(userTO);\n+        assertNotNull(userTO);\n+    }\n+\n+}"},{"sha":"a79e1d8912b453488fea2d20c4598f905e59d370","filename":"syncope620/fit/reference/src/test/java/org/apache/syncope/fit/server/reference/PropagationTaskITCase.java","status":"added","additions":150,"deletions":0,"changes":150,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/6f24e817019a627a6bfe8c6e36af56f04a237983/syncope620%2Ffit%2Freference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fserver%2Freference%2FPropagationTaskITCase.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/6f24e817019a627a6bfe8c6e36af56f04a237983/syncope620%2Ffit%2Freference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fserver%2Freference%2FPropagationTaskITCase.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Ffit%2Freference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fserver%2Freference%2FPropagationTaskITCase.java?ref=6f24e817019a627a6bfe8c6e36af56f04a237983","patch":"@@ -0,0 +1,150 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.fit.server.reference;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.ws.rs.core.Response;\n+import org.apache.syncope.common.lib.SyncopeClientException;\n+import org.apache.syncope.common.lib.to.AbstractTaskTO;\n+import org.apache.syncope.common.lib.to.BulkAction;\n+import org.apache.syncope.common.lib.to.PagedResult;\n+import org.apache.syncope.common.lib.to.PropagationTaskTO;\n+import org.apache.syncope.common.lib.to.ReportExecTO;\n+import org.apache.syncope.common.lib.to.TaskExecTO;\n+import org.apache.syncope.common.lib.to.UserTO;\n+import org.apache.syncope.common.lib.types.PropagationTaskExecStatus;\n+import org.apache.syncope.common.lib.types.TaskType;\n+import org.junit.FixMethodOrder;\n+import org.junit.Test;\n+import org.junit.runners.MethodSorters;\n+\n+@FixMethodOrder(MethodSorters.JVM)\n+public class PropagationTaskITCase extends AbstractTaskITCase {\n+\n+    @Test\n+    public void paginatedList() {\n+        PagedResult<PropagationTaskTO> tasks = taskService.list(TaskType.PROPAGATION, 1, 2);\n+\n+        assertNotNull(tasks);\n+        assertFalse(tasks.getResult().isEmpty());\n+        assertEquals(2, tasks.getResult().size());\n+\n+        for (AbstractTaskTO task : tasks.getResult()) {\n+            assertNotNull(task);\n+        }\n+\n+        tasks = taskService.list(TaskType.PROPAGATION, 2, 2);\n+\n+        assertNotNull(tasks);\n+        assertFalse(tasks.getResult().isEmpty());\n+\n+        for (AbstractTaskTO task : tasks.getResult()) {\n+            assertNotNull(task);\n+        }\n+\n+        tasks = taskService.list(TaskType.PROPAGATION, 1000, 2);\n+\n+        assertNotNull(tasks);\n+        assertTrue(tasks.getResult().isEmpty());\n+    }\n+\n+    @Test\n+    public void read() {\n+        final PropagationTaskTO taskTO = taskService.read(3L);\n+        assertNotNull(taskTO);\n+        assertNotNull(taskTO.getExecutions());\n+        assertTrue(taskTO.getExecutions().isEmpty());\n+    }\n+\n+    @Test\n+    public void readExecution() {\n+        TaskExecTO taskTO = taskService.readExecution(6L);\n+        assertNotNull(taskTO);\n+    }\n+\n+    @Test\n+    public void deal() {\n+        // Currently test is not re-runnable.\n+        // To successfully run test second time it is necessary to restart cargo\n+        try {\n+            taskService.delete(0L);\n+        } catch (SyncopeClientException e) {\n+            assertEquals(Response.Status.NOT_FOUND, e.getType().getResponseStatus());\n+        }\n+        TaskExecTO exec = taskService.execute(1L, false);\n+        assertEquals(PropagationTaskExecStatus.SUBMITTED.name(), exec.getStatus());\n+\n+        ReportExecTO report = new ReportExecTO();\n+        report.setStatus(PropagationTaskExecStatus.SUCCESS.name());\n+        report.setMessage(\"OK\");\n+        taskService.report(exec.getKey(), report);\n+        exec = taskService.readExecution(exec.getKey());\n+        assertEquals(PropagationTaskExecStatus.SUCCESS.name(), exec.getStatus());\n+        assertEquals(\"OK\", exec.getMessage());\n+\n+        taskService.delete(1L);\n+        try {\n+            taskService.readExecution(exec.getKey());\n+        } catch (SyncopeClientException e) {\n+            assertEquals(Response.Status.NOT_FOUND, e.getType().getResponseStatus());\n+        }\n+    }\n+\n+    @Test\n+    public void issue196() {\n+        TaskExecTO exec = taskService.execute(6L, false);\n+        assertNotNull(exec);\n+        assertEquals(0, exec.getKey());\n+        assertNotNull(exec.getTask());\n+    }\n+\n+    @Test\n+    public void bulkAction() {\n+        final PagedResult<PropagationTaskTO> before = taskService.list(TaskType.PROPAGATION);\n+\n+        // create user with testdb resource\n+        final UserTO userTO = UserITCase.getUniqueSampleTO(\"taskBulk@apache.org\");\n+        userTO.getResources().add(RESOURCE_NAME_TESTDB);\n+        createUser(userTO);\n+\n+        final List<PropagationTaskTO> after = new ArrayList<>(\n+                taskService.<PropagationTaskTO>list(TaskType.PROPAGATION).getResult());\n+\n+        after.removeAll(before.getResult());\n+\n+        assertFalse(after.isEmpty());\n+\n+        final BulkAction bulkAction = new BulkAction();\n+        bulkAction.setOperation(BulkAction.Type.DELETE);\n+\n+        for (AbstractTaskTO taskTO : after) {\n+            bulkAction.getTargets().add(String.valueOf(taskTO.getKey()));\n+        }\n+\n+        taskService.bulk(bulkAction);\n+\n+        assertFalse(taskService.list(TaskType.PROPAGATION).getResult().containsAll(after));\n+    }\n+}"},{"sha":"f845997fb3043fed59bf3cff3b79769ef5a18808","filename":"syncope620/fit/reference/src/test/java/org/apache/syncope/fit/server/reference/PushTaskITCase.java","status":"added","additions":354,"deletions":0,"changes":354,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/6f24e817019a627a6bfe8c6e36af56f04a237983/syncope620%2Ffit%2Freference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fserver%2Freference%2FPushTaskITCase.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/6f24e817019a627a6bfe8c6e36af56f04a237983/syncope620%2Ffit%2Freference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fserver%2Freference%2FPushTaskITCase.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Ffit%2Freference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fserver%2Freference%2FPushTaskITCase.java?ref=6f24e817019a627a6bfe8c6e36af56f04a237983","patch":"@@ -0,0 +1,354 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.fit.server.reference;\n+\n+import static org.apache.syncope.fit.server.reference.AbstractITCase.taskService;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import javax.ws.rs.core.Response;\n+import org.apache.syncope.client.lib.SyncopeClient;\n+import org.apache.syncope.common.lib.to.AbstractTaskTO;\n+import org.apache.syncope.common.lib.to.MappingItemTO;\n+import org.apache.syncope.common.lib.to.MappingTO;\n+import org.apache.syncope.common.lib.to.PagedResult;\n+import org.apache.syncope.common.lib.to.PlainSchemaTO;\n+import org.apache.syncope.common.lib.to.PushTaskTO;\n+import org.apache.syncope.common.lib.to.ResourceTO;\n+import org.apache.syncope.common.lib.to.RoleTO;\n+import org.apache.syncope.common.lib.to.TaskExecTO;\n+import org.apache.syncope.common.lib.types.AttrSchemaType;\n+import org.apache.syncope.common.lib.types.AttributableType;\n+import org.apache.syncope.common.lib.types.IntMappingType;\n+import org.apache.syncope.common.lib.types.MappingPurpose;\n+import org.apache.syncope.common.lib.types.MatchingRule;\n+import org.apache.syncope.common.lib.types.PropagationTaskExecStatus;\n+import org.apache.syncope.common.lib.types.SchemaType;\n+import org.apache.syncope.common.lib.types.SubjectType;\n+import org.apache.syncope.common.lib.types.TaskType;\n+import org.apache.syncope.common.lib.types.UnmatchingRule;\n+import org.apache.syncope.common.rest.api.service.ResourceService;\n+import org.apache.syncope.common.rest.api.service.TaskService;\n+import org.junit.FixMethodOrder;\n+import org.junit.Test;\n+import org.junit.runners.MethodSorters;\n+import org.springframework.jdbc.core.JdbcTemplate;\n+\n+@FixMethodOrder(MethodSorters.JVM)\n+public class PushTaskITCase extends AbstractTaskITCase {\n+\n+    @Test\n+    public void getPushActionsClasses() {\n+        List<String> actions = syncopeService.info().getPushActions();\n+        assertNotNull(actions);\n+    }\n+\n+    @Test\n+    public void read() {\n+        PushTaskTO pushTaskTO = taskService.<PushTaskTO>read(17L);\n+        assertEquals(UnmatchingRule.ASSIGN, pushTaskTO.getUnmatchingRule());\n+        assertEquals(MatchingRule.UPDATE, pushTaskTO.getMatchingRule());\n+    }\n+\n+    @Test\n+    public void list() {\n+        final PagedResult<PushTaskTO> tasks = taskService.list(TaskType.PUSH);\n+        assertFalse(tasks.getResult().isEmpty());\n+        for (AbstractTaskTO task : tasks.getResult()) {\n+            if (!(task instanceof PushTaskTO)) {\n+                fail();\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void createPushTask() {\n+        PushTaskTO task = new PushTaskTO();\n+        task.setName(\"Test create Push\");\n+        task.setResource(RESOURCE_NAME_WS2);\n+        task.setUserFilter(\n+                SyncopeClient.getUserSearchConditionBuilder().hasNotResources(RESOURCE_NAME_TESTDB2).query());\n+        task.setRoleFilter(\n+                SyncopeClient.getRoleSearchConditionBuilder().isNotNull(\"cool\").query());\n+        task.setMatchingRule(MatchingRule.LINK);\n+\n+        final Response response = taskService.create(task);\n+        final PushTaskTO actual = getObject(response.getLocation(), TaskService.class, PushTaskTO.class);\n+        assertNotNull(actual);\n+\n+        task = taskService.read(actual.getKey());\n+        assertNotNull(task);\n+        assertEquals(task.getKey(), actual.getKey());\n+        assertEquals(task.getJobClassName(), actual.getJobClassName());\n+        assertEquals(task.getUserFilter(), actual.getUserFilter());\n+        assertEquals(task.getRoleFilter(), actual.getRoleFilter());\n+        assertEquals(UnmatchingRule.ASSIGN, actual.getUnmatchingRule());\n+        assertEquals(MatchingRule.LINK, actual.getMatchingRule());\n+    }\n+\n+    @Test\n+    public void pushMatchingUnmatchingRoles() {\n+        assertFalse(roleService.read(3L).getResources().contains(RESOURCE_NAME_LDAP));\n+\n+        execSyncTask(23L, 50, false);\n+\n+        assertNotNull(resourceService.getConnectorObject(RESOURCE_NAME_LDAP, SubjectType.ROLE, 3L));\n+        assertTrue(roleService.read(3L).getResources().contains(RESOURCE_NAME_LDAP));\n+\n+        execSyncTask(23L, 50, false);\n+\n+        assertNotNull(resourceService.getConnectorObject(RESOURCE_NAME_LDAP, SubjectType.ROLE, 3L));\n+        assertFalse(roleService.read(3L).getResources().contains(RESOURCE_NAME_LDAP));\n+    }\n+\n+    @Test\n+    public void pushUnmatchingUsers() throws Exception {\n+        assertFalse(userService.read(2L).getResources().contains(RESOURCE_NAME_TESTDB2));\n+        assertFalse(userService.read(3L).getResources().contains(RESOURCE_NAME_TESTDB2));\n+        assertFalse(userService.read(4L).getResources().contains(RESOURCE_NAME_TESTDB2));\n+        assertTrue(userService.read(5L).getResources().contains(RESOURCE_NAME_TESTDB2));\n+\n+        final JdbcTemplate jdbcTemplate = new JdbcTemplate(testDataSource);\n+        assertEquals(0, jdbcTemplate.queryForList(\"SELECT ID FROM test2 WHERE ID='puccini'\").size());\n+\n+        // ------------------------------------------\n+        // Unmatching --> Assign --> dryRuyn\n+        // ------------------------------------------\n+        execSyncTask(13L, 50, true);\n+        assertEquals(0, jdbcTemplate.queryForList(\"SELECT ID FROM test2 WHERE ID='vivaldi'\").size());\n+        assertFalse(userService.read(3L).getResources().contains(RESOURCE_NAME_TESTDB2));\n+        // ------------------------------------------\n+\n+        final Set<Long> pushTaskIds = new HashSet<>();\n+        pushTaskIds.add(13L);\n+        pushTaskIds.add(14L);\n+        pushTaskIds.add(15L);\n+        pushTaskIds.add(16L);\n+        execSyncTasks(pushTaskIds, 50, false);\n+\n+        // ------------------------------------------\n+        // Unatching --> Ignore\n+        // ------------------------------------------\n+        assertEquals(1, jdbcTemplate.queryForList(\"SELECT ID FROM test2 WHERE ID='verdi'\").size());\n+        assertFalse(userService.read(2L).getResources().contains(RESOURCE_NAME_TESTDB2));\n+        // ------------------------------------------\n+\n+        // ------------------------------------------\n+        // Unmatching --> Assign\n+        // ------------------------------------------\n+        assertEquals(1, jdbcTemplate.queryForList(\"SELECT ID FROM test2 WHERE ID='vivaldi'\").size());\n+        assertTrue(userService.read(3L).getResources().contains(RESOURCE_NAME_TESTDB2));\n+        jdbcTemplate.execute(\"DELETE FROM test2 WHERE ID='vivaldi'\");\n+        // ------------------------------------------\n+\n+        // ------------------------------------------\n+        // Unmatching --> Provision\n+        // ------------------------------------------\n+        assertEquals(1, jdbcTemplate.queryForList(\"SELECT ID FROM test2 WHERE ID='bellini'\").size());\n+        assertFalse(userService.read(4L).getResources().contains(RESOURCE_NAME_TESTDB2));\n+        jdbcTemplate.execute(\"DELETE FROM test2 WHERE ID='bellini'\");\n+        // ------------------------------------------\n+\n+        // ------------------------------------------\n+        // Unmatching --> Unlink\n+        // ------------------------------------------\n+        assertEquals(0, jdbcTemplate.queryForList(\"SELECT ID FROM test2 WHERE ID='puccini'\").size());\n+        assertFalse(userService.read(5L).getResources().contains(RESOURCE_NAME_TESTDB2));\n+        // ------------------------------------------\n+    }\n+\n+    @Test\n+    public void pushMatchingUser() throws Exception {\n+        assertTrue(userService.read(1L).getResources().contains(RESOURCE_NAME_TESTDB2));\n+        assertFalse(userService.read(2L).getResources().contains(RESOURCE_NAME_TESTDB2));\n+\n+        final JdbcTemplate jdbcTemplate = new JdbcTemplate(testDataSource);\n+        assertEquals(1, jdbcTemplate.queryForList(\"SELECT ID FROM test2 WHERE ID='verdi'\").size());\n+        assertEquals(1, jdbcTemplate.queryForList(\"SELECT ID FROM test2 WHERE ID='rossini'\").size());\n+\n+        // ------------------------------------------\n+        // Matching --> Deprovision --> dryRuyn\n+        // ------------------------------------------\n+        execSyncTask(19L, 50, true);\n+        assertTrue(userService.read(1L).getResources().contains(RESOURCE_NAME_TESTDB2));\n+        assertEquals(1, jdbcTemplate.queryForList(\"SELECT ID FROM test2 WHERE ID='rossini'\").size());\n+        // ------------------------------------------\n+\n+        final Set<Long> pushTaskIds = new HashSet<>();\n+        pushTaskIds.add(18L);\n+        pushTaskIds.add(19L);\n+        pushTaskIds.add(16L);\n+\n+        execSyncTasks(pushTaskIds, 50, false);\n+\n+        // ------------------------------------------\n+        // Matching --> Deprovision && Ignore\n+        // ------------------------------------------\n+        assertFalse(userService.read(2L).getResources().contains(RESOURCE_NAME_TESTDB2));\n+        // DELETE Capability not available ....\n+        assertEquals(1, jdbcTemplate.queryForList(\"SELECT ID FROM test2 WHERE ID='verdi'\").size());\n+        // ------------------------------------------\n+\n+        // ------------------------------------------\n+        // Matching --> Unassign\n+        // ------------------------------------------\n+        assertFalse(userService.read(1L).getResources().contains(RESOURCE_NAME_TESTDB2));\n+        // DELETE Capability not available ....\n+        assertEquals(1, jdbcTemplate.queryForList(\"SELECT ID FROM test2 WHERE ID='rossini'\").size());\n+        // ------------------------------------------\n+\n+        // ------------------------------------------\n+        // Matching --> Link\n+        // ------------------------------------------\n+        execSyncTask(20L, 50, false);\n+        assertTrue(userService.read(2L).getResources().contains(RESOURCE_NAME_TESTDB2));\n+        assertEquals(1, jdbcTemplate.queryForList(\"SELECT ID FROM test2 WHERE ID='verdi'\").size());\n+        // ------------------------------------------\n+\n+        pushTaskIds.clear();\n+        pushTaskIds.add(21L);\n+        pushTaskIds.add(22L);\n+\n+        execSyncTasks(pushTaskIds, 50, false);\n+\n+        // ------------------------------------------\n+        // Matching --> Unlink && Update\n+        // ------------------------------------------\n+        assertFalse(userService.read(2L).getResources().contains(RESOURCE_NAME_TESTDB2));\n+        assertEquals(1, jdbcTemplate.queryForList(\"SELECT ID FROM test2 WHERE ID='verdi'\").size());\n+        // ------------------------------------------\n+    }\n+\n+    @Test\n+    public void issueSYNCOPE598() {\n+        // create a new role schema\n+        final PlainSchemaTO schemaTO = new PlainSchemaTO();\n+        schemaTO.setKey(\"LDAPGroupName\" + getUUIDString());\n+        schemaTO.setType(AttrSchemaType.String);\n+        schemaTO.setMandatoryCondition(\"true\");\n+\n+        final PlainSchemaTO newPlainSchemaTO = createSchema(AttributableType.ROLE, SchemaType.PLAIN, schemaTO);\n+        assertEquals(schemaTO, newPlainSchemaTO);\n+\n+        // create a new sample role\n+        RoleTO roleTO = new RoleTO();\n+        roleTO.setName(\"all\" + getUUIDString());\n+        roleTO.setParent(8L);\n+\n+        roleTO.getRAttrTemplates().add(newPlainSchemaTO.getKey());\n+        roleTO.getPlainAttrs().add(attrTO(newPlainSchemaTO.getKey(), \"all\"));\n+\n+        roleTO = createRole(roleTO);\n+        assertNotNull(roleTO);\n+\n+        String resourceName = \"resource-ldap-roleonly\";\n+        ResourceTO newResourceTO = null;\n+\n+        try {\n+            // Create resource ad-hoc\n+            ResourceTO resourceTO = new ResourceTO();\n+            resourceTO.setKey(resourceName);\n+            resourceTO.setConnectorId(105L);\n+\n+            final MappingTO umapping = new MappingTO();\n+            MappingItemTO item = new MappingItemTO();\n+            item.setIntMappingType(IntMappingType.Username);\n+            item.setExtAttrName(\"cn\");\n+            item.setAccountid(true);\n+            item.setPurpose(MappingPurpose.PROPAGATION);\n+            item.setMandatoryCondition(\"true\");\n+            umapping.setAccountIdItem(item);\n+\n+            item = new MappingItemTO();\n+            item.setIntMappingType(IntMappingType.UserPlainSchema);\n+            item.setExtAttrName(\"surname\");\n+            item.setIntAttrName(\"sn\");\n+            item.setPurpose(MappingPurpose.BOTH);\n+            umapping.addItem(item);\n+\n+            item = new MappingItemTO();\n+            item.setIntMappingType(IntMappingType.UserPlainSchema);\n+            item.setExtAttrName(\"email\");\n+            item.setIntAttrName(\"mail\");\n+            item.setPurpose(MappingPurpose.BOTH);\n+            umapping.addItem(item);\n+\n+            item = new MappingItemTO();\n+            item.setIntMappingType(IntMappingType.Password);\n+            item.setPassword(true);\n+            item.setPurpose(MappingPurpose.BOTH);\n+            item.setMandatoryCondition(\"true\");\n+            umapping.addItem(item);\n+\n+            umapping.setAccountLink(\"'cn=' + username + ',ou=people,o=isp'\");\n+\n+            final MappingTO rmapping = new MappingTO();\n+\n+            item = new MappingItemTO();\n+            item.setIntMappingType(IntMappingType.RolePlainSchema);\n+            item.setExtAttrName(\"cn\");\n+            item.setIntAttrName(newPlainSchemaTO.getKey());\n+            item.setAccountid(true);\n+            item.setPurpose(MappingPurpose.BOTH);\n+            rmapping.setAccountIdItem(item);\n+\n+            rmapping.setAccountLink(\"'cn=' + \" + newPlainSchemaTO.getKey() + \" + ',ou=groups,o=isp'\");\n+\n+            resourceTO.setRmapping(rmapping);\n+\n+            Response response = resourceService.create(resourceTO);\n+            newResourceTO = getObject(response.getLocation(), ResourceService.class, ResourceTO.class);\n+\n+            assertNotNull(newResourceTO);\n+            assertNull(newResourceTO.getUmapping());\n+            assertNotNull(newResourceTO.getRmapping());\n+\n+            // create push task ad-hoc\n+            final PushTaskTO task = new PushTaskTO();\n+            task.setName(\"issueSYNCOPE598\");\n+            task.setResource(resourceName);\n+            task.setPerformCreate(true);\n+            task.setPerformDelete(true);\n+            task.setPerformUpdate(true);\n+            task.setUnmatchingRule(UnmatchingRule.ASSIGN);\n+            task.setMatchingRule(MatchingRule.UPDATE);\n+\n+            response = taskService.create(task);\n+            final PushTaskTO push = getObject(response.getLocation(), TaskService.class, PushTaskTO.class);\n+\n+            assertNotNull(push);\n+\n+            // execute the new task\n+            final TaskExecTO pushExec = execSyncTask(push.getKey(), 50, false);\n+            assertTrue(PropagationTaskExecStatus.valueOf(pushExec.getStatus()).isSuccessful());\n+        } finally {\n+            roleService.delete(roleTO.getKey());\n+            if (newResourceTO != null) {\n+                resourceService.delete(resourceName);\n+            }\n+        }\n+    }\n+}"},{"sha":"424ca08cdf1e0335ecebca2942776e161d4567c7","filename":"syncope620/fit/reference/src/test/java/org/apache/syncope/fit/server/reference/SchedTaskITCase.java","status":"added","additions":107,"deletions":0,"changes":107,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/6f24e817019a627a6bfe8c6e36af56f04a237983/syncope620%2Ffit%2Freference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fserver%2Freference%2FSchedTaskITCase.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/6f24e817019a627a6bfe8c6e36af56f04a237983/syncope620%2Ffit%2Freference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fserver%2Freference%2FSchedTaskITCase.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Ffit%2Freference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fserver%2Freference%2FSchedTaskITCase.java?ref=6f24e817019a627a6bfe8c6e36af56f04a237983","patch":"@@ -0,0 +1,107 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.fit.server.reference;\n+\n+import static org.apache.syncope.fit.server.reference.AbstractITCase.taskService;\n+import static org.apache.syncope.fit.server.reference.AbstractTaskITCase.SCHED_TASK_ID;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.fail;\n+\n+import java.util.List;\n+import javax.ws.rs.core.Response;\n+import org.apache.syncope.common.lib.to.AbstractTaskTO;\n+import org.apache.syncope.common.lib.to.PagedResult;\n+import org.apache.syncope.common.lib.to.PushTaskTO;\n+import org.apache.syncope.common.lib.to.SchedTaskTO;\n+import org.apache.syncope.common.lib.to.SyncTaskTO;\n+import org.apache.syncope.common.lib.types.TaskType;\n+import org.apache.syncope.common.rest.api.service.TaskService;\n+import org.apache.syncope.server.provisioning.api.job.SyncJob;\n+import org.junit.FixMethodOrder;\n+import org.junit.Test;\n+import org.junit.runners.MethodSorters;\n+\n+@FixMethodOrder(MethodSorters.JVM)\n+public class SchedTaskITCase extends AbstractTaskITCase {\n+\n+    @Test\n+    public void getJobClasses() {\n+        List<String> jobClasses = syncopeService.info().getTaskJobs();\n+        assertNotNull(jobClasses);\n+        assertFalse(jobClasses.isEmpty());\n+    }\n+\n+    @Test\n+    public void list() {\n+        final PagedResult<SchedTaskTO> tasks = taskService.list(TaskType.SCHEDULED);\n+        assertFalse(tasks.getResult().isEmpty());\n+        for (AbstractTaskTO task : tasks.getResult()) {\n+            if (!(task instanceof SchedTaskTO) || task instanceof SyncTaskTO || task instanceof PushTaskTO) {\n+                fail();\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void update() {\n+        SchedTaskTO task = taskService.read(SCHED_TASK_ID);\n+        assertNotNull(task);\n+\n+        final SchedTaskTO taskMod = new SchedTaskTO();\n+        taskMod.setKey(5);\n+        taskMod.setCronExpression(null);\n+\n+        taskService.update(taskMod.getKey(), taskMod);\n+        SchedTaskTO actual = taskService.read(taskMod.getKey());\n+        assertNotNull(actual);\n+        assertEquals(task.getKey(), actual.getKey());\n+        assertNull(actual.getCronExpression());\n+    }\n+\n+    @Test\n+    public void issueSYNCOPE144() {\n+        SchedTaskTO task = new SchedTaskTO();\n+        task.setName(\"issueSYNCOPE144\");\n+        task.setDescription(\"issueSYNCOPE144 Description\");\n+        task.setJobClassName(SyncJob.class.getName());\n+\n+        Response response = taskService.create(task);\n+        SchedTaskTO actual = getObject(response.getLocation(), TaskService.class, SchedTaskTO.class);\n+        assertNotNull(actual);\n+        assertEquals(\"issueSYNCOPE144\", actual.getName());\n+        assertEquals(\"issueSYNCOPE144 Description\", actual.getDescription());\n+\n+        task = taskService.read(actual.getKey());\n+        assertNotNull(task);\n+        assertEquals(\"issueSYNCOPE144\", task.getName());\n+        assertEquals(\"issueSYNCOPE144 Description\", task.getDescription());\n+\n+        task.setName(\"issueSYNCOPE144_2\");\n+        task.setDescription(\"issueSYNCOPE144 Description_2\");\n+\n+        response = taskService.create(task);\n+        actual = getObject(response.getLocation(), TaskService.class, SchedTaskTO.class);\n+        assertNotNull(actual);\n+        assertEquals(\"issueSYNCOPE144_2\", actual.getName());\n+        assertEquals(\"issueSYNCOPE144 Description_2\", actual.getDescription());\n+    }\n+}"},{"sha":"7b66d264ab6debb6af48f1e701edb88040585fea","filename":"syncope620/fit/reference/src/test/java/org/apache/syncope/fit/server/reference/SyncTaskITCase.java","status":"renamed","additions":49,"deletions":738,"changes":787,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/6f24e817019a627a6bfe8c6e36af56f04a237983/syncope620%2Ffit%2Freference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fserver%2Freference%2FSyncTaskITCase.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/6f24e817019a627a6bfe8c6e36af56f04a237983/syncope620%2Ffit%2Freference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fserver%2Freference%2FSyncTaskITCase.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Ffit%2Freference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fserver%2Freference%2FSyncTaskITCase.java?ref=6f24e817019a627a6bfe8c6e36af56f04a237983","patch":"@@ -18,72 +18,46 @@\n  */\n package org.apache.syncope.fit.server.reference;\n \n+import static org.apache.syncope.fit.server.reference.AbstractITCase.RESOURCE_NAME_TESTDB;\n+import static org.apache.syncope.fit.server.reference.AbstractITCase.RESOURCE_NAME_WS2;\n+import static org.apache.syncope.fit.server.reference.AbstractITCase.roleService;\n+import static org.apache.syncope.fit.server.reference.AbstractITCase.taskService;\n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertFalse;\n import static org.junit.Assert.assertNotNull;\n import static org.junit.Assert.assertNull;\n import static org.junit.Assert.assertTrue;\n import static org.junit.Assert.fail;\n \n-import java.util.ArrayList;\n-import java.util.HashMap;\n import java.util.HashSet;\n import java.util.List;\n-import java.util.Map;\n import java.util.Set;\n-import java.util.concurrent.Callable;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.Future;\n-import java.util.concurrent.TimeUnit;\n import javax.ws.rs.core.Response;\n import org.apache.syncope.client.lib.SyncopeClient;\n-import org.apache.syncope.common.lib.SyncopeClientException;\n import org.apache.syncope.common.lib.mod.StatusMod;\n import org.apache.syncope.common.lib.mod.UserMod;\n import org.apache.syncope.common.lib.to.AbstractTaskTO;\n import org.apache.syncope.common.lib.to.AttrTO;\n-import org.apache.syncope.common.lib.to.BulkAction;\n import org.apache.syncope.common.lib.to.ConnInstanceTO;\n import org.apache.syncope.common.lib.to.ConnObjectTO;\n-import org.apache.syncope.common.lib.to.MappingItemTO;\n-import org.apache.syncope.common.lib.to.MappingTO;\n import org.apache.syncope.common.lib.to.MembershipTO;\n-import org.apache.syncope.common.lib.to.NotificationTO;\n-import org.apache.syncope.common.lib.to.NotificationTaskTO;\n import org.apache.syncope.common.lib.to.PagedResult;\n-import org.apache.syncope.common.lib.to.PlainSchemaTO;\n-import org.apache.syncope.common.lib.to.PropagationTaskTO;\n-import org.apache.syncope.common.lib.to.PushTaskTO;\n-import org.apache.syncope.common.lib.to.ReportExecTO;\n import org.apache.syncope.common.lib.to.ResourceTO;\n import org.apache.syncope.common.lib.to.RoleTO;\n-import org.apache.syncope.common.lib.to.SchedTaskTO;\n import org.apache.syncope.common.lib.to.SyncPolicyTO;\n import org.apache.syncope.common.lib.to.SyncTaskTO;\n import org.apache.syncope.common.lib.to.TaskExecTO;\n import org.apache.syncope.common.lib.to.UserTO;\n-import org.apache.syncope.common.lib.types.AttrSchemaType;\n-import org.apache.syncope.common.lib.types.AttributableType;\n import org.apache.syncope.common.lib.types.CipherAlgorithm;\n import org.apache.syncope.common.lib.types.ConnConfProperty;\n-import org.apache.syncope.common.lib.types.IntMappingType;\n-import org.apache.syncope.common.lib.types.MappingPurpose;\n-import org.apache.syncope.common.lib.types.MatchingRule;\n import org.apache.syncope.common.lib.types.PropagationTaskExecStatus;\n import org.apache.syncope.common.lib.types.ResourceDeassociationActionType;\n-import org.apache.syncope.common.lib.types.SchemaType;\n import org.apache.syncope.common.lib.types.SubjectType;\n import org.apache.syncope.common.lib.types.TaskType;\n-import org.apache.syncope.common.lib.types.TraceLevel;\n-import org.apache.syncope.common.lib.types.UnmatchingRule;\n import org.apache.syncope.common.lib.wrap.ResourceName;\n import org.apache.syncope.common.rest.api.CollectionWrapper;\n-import org.apache.syncope.common.rest.api.service.NotificationService;\n-import org.apache.syncope.common.rest.api.service.ResourceService;\n import org.apache.syncope.common.rest.api.service.TaskService;\n import org.apache.syncope.server.misc.security.Encryptor;\n-import org.apache.syncope.server.provisioning.api.job.SyncJob;\n import org.apache.syncope.server.provisioning.java.sync.DBPasswordSyncActions;\n import org.apache.syncope.server.provisioning.java.sync.LDAPPasswordSyncActions;\n import org.identityconnectors.framework.common.objects.Name;\n@@ -95,34 +69,7 @@\n import org.springframework.jdbc.core.JdbcTemplate;\n \n @FixMethodOrder(MethodSorters.JVM)\n-public class TaskITCase extends AbstractITCase {\n-\n-    private static final Long SCHED_TASK_ID = 5L;\n-\n-    private static final Long SYNC_TASK_ID = 4L;\n-\n-    private static class ThreadExec implements Callable<TaskExecTO> {\n-\n-        private final TaskITCase test;\n-\n-        private final Long taskKey;\n-\n-        private final int maxWaitSeconds;\n-\n-        private final boolean dryRun;\n-\n-        public ThreadExec(TaskITCase test, Long taskKey, int maxWaitSeconds, boolean dryRun) {\n-            this.test = test;\n-            this.taskKey = taskKey;\n-            this.maxWaitSeconds = maxWaitSeconds;\n-            this.dryRun = dryRun;\n-        }\n-\n-        @Override\n-        public TaskExecTO call() throws Exception {\n-            return test.execSyncTask(taskKey, maxWaitSeconds, dryRun);\n-        }\n-    }\n+public class SyncTaskITCase extends AbstractTaskITCase {\n \n     @BeforeClass\n     public static void testSyncActionsSetup() {\n@@ -131,28 +78,6 @@ public static void testSyncActionsSetup() {\n         taskService.update(SYNC_TASK_ID, syncTask);\n     }\n \n-    /**\n-     * Remove initial and synchronized users to make test re-runnable.\n-     */\n-    private void removeTestUsers() {\n-        for (int i = 0; i < 10; i++) {\n-            String cUserName = \"test\" + i;\n-            try {\n-                UserTO cUserTO = readUser(cUserName);\n-                userService.delete(cUserTO.getKey());\n-            } catch (Exception e) {\n-                // Ignore\n-            }\n-        }\n-    }\n-\n-    @Test\n-    public void getJobClasses() {\n-        List<String> jobClasses = syncopeService.info().getTaskJobs();\n-        assertNotNull(jobClasses);\n-        assertFalse(jobClasses.isEmpty());\n-    }\n-\n     @Test\n     public void getSyncActionsClasses() {\n         List<String> actions = syncopeService.info().getSyncActions();\n@@ -161,13 +86,18 @@ public void getSyncActionsClasses() {\n     }\n \n     @Test\n-    public void getPushActionsClasses() {\n-        List<String> actions = syncopeService.info().getPushActions();\n-        assertNotNull(actions);\n+    public void list() {\n+        final PagedResult<SyncTaskTO> tasks = taskService.list(TaskType.SYNCHRONIZATION);\n+        assertFalse(tasks.getResult().isEmpty());\n+        for (AbstractTaskTO task : tasks.getResult()) {\n+            if (!(task instanceof SyncTaskTO)) {\n+                fail();\n+            }\n+        }\n     }\n \n     @Test\n-    public void createSyncTask() {\n+    public void create() {\n         SyncTaskTO task = new SyncTaskTO();\n         task.setName(\"Test create Sync\");\n         task.setResource(RESOURCE_NAME_WS2);\n@@ -196,154 +126,6 @@ public void createSyncTask() {\n         assertEquals(roleTemplate, task.getRoleTemplate());\n     }\n \n-    @Test\n-    public void createPushTask() {\n-        PushTaskTO task = new PushTaskTO();\n-        task.setName(\"Test create Push\");\n-        task.setResource(RESOURCE_NAME_WS2);\n-        task.setUserFilter(\n-                SyncopeClient.getUserSearchConditionBuilder().hasNotResources(RESOURCE_NAME_TESTDB2).query());\n-        task.setRoleFilter(\n-                SyncopeClient.getRoleSearchConditionBuilder().isNotNull(\"cool\").query());\n-        task.setMatchingRule(MatchingRule.LINK);\n-\n-        final Response response = taskService.create(task);\n-        final PushTaskTO actual = getObject(response.getLocation(), TaskService.class, PushTaskTO.class);\n-        assertNotNull(actual);\n-\n-        task = taskService.read(actual.getKey());\n-        assertNotNull(task);\n-        assertEquals(task.getKey(), actual.getKey());\n-        assertEquals(task.getJobClassName(), actual.getJobClassName());\n-        assertEquals(task.getUserFilter(), actual.getUserFilter());\n-        assertEquals(task.getRoleFilter(), actual.getRoleFilter());\n-        assertEquals(UnmatchingRule.ASSIGN, actual.getUnmatchingRule());\n-        assertEquals(MatchingRule.LINK, actual.getMatchingRule());\n-    }\n-\n-    @Test\n-    public void update() {\n-        SchedTaskTO task = taskService.read(SCHED_TASK_ID);\n-        assertNotNull(task);\n-\n-        final SchedTaskTO taskMod = new SchedTaskTO();\n-        taskMod.setKey(5);\n-        taskMod.setCronExpression(null);\n-\n-        taskService.update(taskMod.getKey(), taskMod);\n-        SchedTaskTO actual = taskService.read(taskMod.getKey());\n-        assertNotNull(actual);\n-        assertEquals(task.getKey(), actual.getKey());\n-        assertNull(actual.getCronExpression());\n-    }\n-\n-    @Test\n-    public void listSchedTask() {\n-        final PagedResult<SchedTaskTO> tasks = taskService.list(TaskType.SCHEDULED);\n-        assertFalse(tasks.getResult().isEmpty());\n-        for (AbstractTaskTO task : tasks.getResult()) {\n-            if (!(task instanceof SchedTaskTO) || task instanceof SyncTaskTO || task instanceof PushTaskTO) {\n-                fail();\n-            }\n-        }\n-    }\n-\n-    @Test\n-    public void listSyncTask() {\n-        final PagedResult<SyncTaskTO> tasks = taskService.list(TaskType.SYNCHRONIZATION);\n-        assertFalse(tasks.getResult().isEmpty());\n-        for (AbstractTaskTO task : tasks.getResult()) {\n-            if (!(task instanceof SyncTaskTO)) {\n-                fail();\n-            }\n-        }\n-    }\n-\n-    @Test\n-    public void list() {\n-        final PagedResult<PushTaskTO> tasks = taskService.list(TaskType.PUSH);\n-        assertFalse(tasks.getResult().isEmpty());\n-        for (AbstractTaskTO task : tasks.getResult()) {\n-            if (!(task instanceof PushTaskTO)) {\n-                fail();\n-            }\n-        }\n-    }\n-\n-    @Test\n-    public void paginatedList() {\n-        PagedResult<PropagationTaskTO> tasks = taskService.list(TaskType.PROPAGATION, 1, 2);\n-\n-        assertNotNull(tasks);\n-        assertFalse(tasks.getResult().isEmpty());\n-        assertEquals(2, tasks.getResult().size());\n-\n-        for (AbstractTaskTO task : tasks.getResult()) {\n-            assertNotNull(task);\n-        }\n-\n-        tasks = taskService.list(TaskType.PROPAGATION, 2, 2);\n-\n-        assertNotNull(tasks);\n-        assertFalse(tasks.getResult().isEmpty());\n-\n-        for (AbstractTaskTO task : tasks.getResult()) {\n-            assertNotNull(task);\n-        }\n-\n-        tasks = taskService.list(TaskType.PROPAGATION, 1000, 2);\n-\n-        assertNotNull(tasks);\n-        assertTrue(tasks.getResult().isEmpty());\n-    }\n-\n-    @Test\n-    public void read() {\n-        final PropagationTaskTO taskTO = taskService.read(3L);\n-\n-        assertNotNull(taskTO);\n-        assertNotNull(taskTO.getExecutions());\n-        assertTrue(taskTO.getExecutions().isEmpty());\n-\n-        final PushTaskTO pushTaskTO = taskService.<PushTaskTO>read(17L);\n-        assertEquals(UnmatchingRule.ASSIGN, pushTaskTO.getUnmatchingRule());\n-        assertEquals(MatchingRule.UPDATE, pushTaskTO.getMatchingRule());\n-    }\n-\n-    @Test\n-    public void readExecution() {\n-        TaskExecTO taskTO = taskService.readExecution(6L);\n-        assertNotNull(taskTO);\n-    }\n-\n-    @Test\n-    // Currently test is not re-runnable.\n-    // To successfully run test second time it is necessary to restart cargo.\n-    public void deal() {\n-        try {\n-            taskService.delete(0L);\n-        } catch (SyncopeClientException e) {\n-            assertEquals(Response.Status.NOT_FOUND, e.getType().getResponseStatus());\n-        }\n-        TaskExecTO exec = taskService.execute(1L, false);\n-        assertEquals(PropagationTaskExecStatus.SUBMITTED.name(), exec.getStatus());\n-\n-        ReportExecTO report = new ReportExecTO();\n-        report.setStatus(PropagationTaskExecStatus.SUCCESS.name());\n-        report.setMessage(\"OK\");\n-        taskService.report(exec.getKey(), report);\n-        exec = taskService.readExecution(exec.getKey());\n-        assertEquals(PropagationTaskExecStatus.SUCCESS.name(), exec.getStatus());\n-        assertEquals(\"OK\", exec.getMessage());\n-\n-        taskService.delete(1L);\n-        try {\n-            taskService.readExecution(exec.getKey());\n-        } catch (SyncopeClientException e) {\n-            assertEquals(Response.Status.NOT_FOUND, e.getType().getResponseStatus());\n-        }\n-    }\n-\n     @Test\n     public void sync() throws Exception {\n         removeTestUsers();\n@@ -426,7 +208,7 @@ public void sync() throws Exception {\n             // SYNCOPE-317\n             execSyncTask(SYNC_TASK_ID, 50, false);\n \n-            final Set<Long> pushTaskIds = new HashSet<Long>();\n+            final Set<Long> pushTaskIds = new HashSet<>();\n             pushTaskIds.add(25L);\n             pushTaskIds.add(26L);\n \n@@ -439,6 +221,13 @@ public void sync() throws Exception {\n         }\n     }\n \n+    @Test\n+    public void dryRun() {\n+        TaskExecTO execution = execSyncTask(SYNC_TASK_ID, 50, true);\n+        assertEquals(\"Execution of task \" + execution.getTask() + \" failed with message \" + execution.getMessage(),\n+                \"SUCCESS\", execution.getStatus());\n+    }\n+\n     @Test\n     public void reconcileFromDB() {\n         // update sync task\n@@ -538,131 +327,6 @@ public void reconcileFromLDAP() {\n         assertEquals(1, members.getResult().size());\n     }\n \n-    @Test\n-    public void issue196() {\n-        TaskExecTO exec = taskService.execute(6L, false);\n-        assertNotNull(exec);\n-        assertEquals(0, exec.getKey());\n-        assertNotNull(exec.getTask());\n-    }\n-\n-    @Test\n-    public void dryRun() {\n-        TaskExecTO execution = execSyncTask(SYNC_TASK_ID, 50, true);\n-        assertEquals(\"Execution of task \" + execution.getTask() + \" failed with message \" + execution.getMessage(),\n-                \"SUCCESS\", execution.getStatus());\n-    }\n-\n-    @Test\n-    public void issueSYNCOPE81() {\n-        String sender = \"syncope81@syncope.apache.org\";\n-        createNotificationTask(sender);\n-        NotificationTaskTO taskTO = findNotificationTaskBySender(sender);\n-        assertNotNull(taskTO);\n-\n-        assertTrue(taskTO.getExecutions().isEmpty());\n-\n-        // generate an execution in order to verify the deletion of a notification task with one or more executions\n-        TaskExecTO execution = taskService.execute(taskTO.getKey(), false);\n-        assertEquals(\"NOT_SENT\", execution.getStatus());\n-\n-        int i = 0;\n-        int maxit = 50;\n-        int executions = 0;\n-\n-        // wait for task exec completion (executions incremented)\n-        do {\n-            try {\n-                Thread.sleep(1000);\n-            } catch (InterruptedException e) {\n-            }\n-\n-            taskTO = taskService.read(taskTO.getKey());\n-\n-            assertNotNull(taskTO);\n-            assertNotNull(taskTO.getExecutions());\n-\n-            i++;\n-        } while (executions == taskTO.getExecutions().size() && i < maxit);\n-\n-        assertFalse(taskTO.getExecutions().isEmpty());\n-\n-        taskService.delete(taskTO.getKey());\n-    }\n-\n-    @Test\n-    public void issueSYNCOPE86() {\n-        // 1. create notification task\n-        String sender = \"syncope86@syncope.apache.org\";\n-        createNotificationTask(sender);\n-\n-        // 2. get NotificationTaskTO for user just created\n-        NotificationTaskTO taskTO = findNotificationTaskBySender(sender);\n-        assertNotNull(taskTO);\n-        assertTrue(taskTO.getExecutions().isEmpty());\n-\n-        try {\n-            // 3. execute the generated NotificationTask\n-            TaskExecTO execution = taskService.execute(taskTO.getKey(), false);\n-            assertNotNull(execution);\n-\n-            // 4. verify\n-            taskTO = taskService.read(taskTO.getKey());\n-            assertNotNull(taskTO);\n-            assertEquals(1, taskTO.getExecutions().size());\n-        } finally {\n-            // Remove execution to make test re-runnable\n-            taskService.deleteExecution(taskTO.getExecutions().get(0).getKey());\n-        }\n-    }\n-\n-    private NotificationTaskTO findNotificationTaskBySender(final String sender) {\n-        PagedResult<NotificationTaskTO> tasks = taskService.list(TaskType.NOTIFICATION);\n-        assertNotNull(tasks);\n-        assertFalse(tasks.getResult().isEmpty());\n-        NotificationTaskTO taskTO = null;\n-        for (NotificationTaskTO task : tasks.getResult()) {\n-            if (sender.equals(task.getSender())) {\n-                taskTO = task;\n-            }\n-        }\n-        return taskTO;\n-    }\n-\n-    private void createNotificationTask(final String sender) {\n-        // 1. Create notification\n-        NotificationTO notification = new NotificationTO();\n-        notification.setTraceLevel(TraceLevel.FAILURES);\n-        notification.getEvents().add(\"[REST]:[UserLogic]:[]:[create]:[SUCCESS]\");\n-\n-        notification.setUserAbout(SyncopeClient.getUserSearchConditionBuilder().hasRoles(7L).query());\n-\n-        notification.setRecipients(SyncopeClient.getUserSearchConditionBuilder().hasRoles(8L).query());\n-        notification.setSelfAsRecipient(true);\n-\n-        notification.setRecipientAttrName(\"email\");\n-        notification.setRecipientAttrType(IntMappingType.UserPlainSchema);\n-\n-        notification.setSender(sender);\n-        String subject = \"Test notification\";\n-        notification.setSubject(subject);\n-        notification.setTemplate(\"optin\");\n-        notification.setActive(true);\n-\n-        Response response = notificationService.create(notification);\n-        notification = getObject(response.getLocation(), NotificationService.class, NotificationTO.class);\n-        assertNotNull(notification);\n-\n-        // 2. create user\n-        UserTO userTO = UserITCase.getUniqueSampleTO(\"syncope@syncope.apache.org\");\n-        MembershipTO membershipTO = new MembershipTO();\n-        membershipTO.setRoleId(7);\n-        userTO.getMemberships().add(membershipTO);\n-\n-        userTO = createUser(userTO);\n-        assertNotNull(userTO);\n-    }\n-\n     @Test\n     public void issueSYNCOPE68() {\n         //-----------------------------\n@@ -737,34 +401,6 @@ public void issueSYNCOPE68() {\n         }\n     }\n \n-    @Test\n-    public void issueSYNCOPE144() {\n-        SchedTaskTO task = new SchedTaskTO();\n-        task.setName(\"issueSYNCOPE144\");\n-        task.setDescription(\"issueSYNCOPE144 Description\");\n-        task.setJobClassName(SyncJob.class.getName());\n-\n-        Response response = taskService.create(task);\n-        SchedTaskTO actual = getObject(response.getLocation(), TaskService.class, SchedTaskTO.class);\n-        assertNotNull(actual);\n-        assertEquals(\"issueSYNCOPE144\", actual.getName());\n-        assertEquals(\"issueSYNCOPE144 Description\", actual.getDescription());\n-\n-        task = taskService.read(actual.getKey());\n-        assertNotNull(task);\n-        assertEquals(\"issueSYNCOPE144\", task.getName());\n-        assertEquals(\"issueSYNCOPE144 Description\", task.getDescription());\n-\n-        task.setName(\"issueSYNCOPE144_2\");\n-        task.setDescription(\"issueSYNCOPE144 Description_2\");\n-\n-        response = taskService.create(task);\n-        actual = getObject(response.getLocation(), TaskService.class, SchedTaskTO.class);\n-        assertNotNull(actual);\n-        assertEquals(\"issueSYNCOPE144_2\", actual.getName());\n-        assertEquals(\"issueSYNCOPE144 Description_2\", actual.getDescription());\n-    }\n-\n     @Test\n     public void issueSYNCOPE230() {\n         // 1. read SyncTask for resource-db-sync (table TESTSYNC on external H2)\n@@ -791,87 +427,6 @@ public void issueSYNCOPE230() {\n         assertEquals(\"updatedSYNCOPE230@syncope.apache.org\", email);\n     }\n \n-    private TaskExecTO execSyncTask(final Long taskKey, final int maxWaitSeconds, final boolean dryRun) {\n-        AbstractTaskTO taskTO = taskService.read(taskKey);\n-        assertNotNull(taskTO);\n-        assertNotNull(taskTO.getExecutions());\n-\n-        int preSyncSize = taskTO.getExecutions().size();\n-        TaskExecTO execution = taskService.execute(taskTO.getKey(), dryRun);\n-        assertEquals(\"JOB_FIRED\", execution.getStatus());\n-\n-        int i = 0;\n-        int maxit = maxWaitSeconds;\n-\n-        // wait for sync completion (executions incremented)\n-        do {\n-            try {\n-                Thread.sleep(1000);\n-            } catch (InterruptedException e) {\n-            }\n-\n-            taskTO = taskService.read(taskTO.getKey());\n-\n-            assertNotNull(taskTO);\n-            assertNotNull(taskTO.getExecutions());\n-\n-            i++;\n-        } while (preSyncSize == taskTO.getExecutions().size() && i < maxit);\n-        if (i == maxit) {\n-            fail(\"Timeout when executing task \" + taskKey);\n-        }\n-        return taskTO.getExecutions().get(taskTO.getExecutions().size() - 1);\n-    }\n-\n-    private Map<Long, TaskExecTO> execSyncTasks(\n-            final Set<Long> taskKeys, final int maxWaitSeconds, final boolean dryRun) throws Exception {\n-\n-        final ExecutorService service = Executors.newFixedThreadPool(taskKeys.size());\n-        final List<Future<TaskExecTO>> futures = new ArrayList<>();\n-\n-        for (final Long id : taskKeys) {\n-            futures.add(service.submit(new ThreadExec(this, id, maxWaitSeconds, dryRun)));\n-        }\n-\n-        final Map<Long, TaskExecTO> res = new HashMap<>();\n-\n-        for (Future<TaskExecTO> f : futures) {\n-            TaskExecTO taskExecTO = f.get(100, TimeUnit.SECONDS);\n-            res.put(taskExecTO.getTask(), taskExecTO);\n-        }\n-\n-        service.shutdownNow();\n-\n-        return res;\n-    }\n-\n-    @Test\n-    public void issueSYNCOPE272() {\n-        removeTestUsers();\n-\n-        // create user with testdb resource\n-        UserTO userTO = UserITCase.getUniqueSampleTO(\"syncope272@syncope.apache.org\");\n-        userTO.getResources().add(RESOURCE_NAME_TESTDB);\n-\n-        userTO = createUser(userTO);\n-        try {\n-            assertNotNull(userTO);\n-            assertEquals(1, userTO.getPropagationStatusTOs().size());\n-            assertTrue(userTO.getPropagationStatusTOs().get(0).getStatus().isSuccessful());\n-\n-            TaskExecTO taskExecTO = execSyncTask(24L, 50, false);\n-\n-            assertNotNull(taskExecTO.getStatus());\n-            assertTrue(PropagationTaskExecStatus.valueOf(taskExecTO.getStatus()).isSuccessful());\n-\n-            userTO = userService.read(userTO.getKey());\n-            assertNotNull(userTO);\n-            assertNotNull(userTO.getPlainAttrMap().get(\"firstname\").getValues().get(0));\n-        } finally {\n-            removeTestUsers();\n-        }\n-    }\n-\n     @Test\n     public void issueSYNCOPE258() {\n         // -----------------------------\n@@ -925,6 +480,33 @@ public void issueSYNCOPE258() {\n                 executed.getExecutions().get(0).getMessage().contains(\"[updated/failures]: 1/0\"));\n     }\n \n+    @Test\n+    public void issueSYNCOPE272() {\n+        removeTestUsers();\n+\n+        // create user with testdb resource\n+        UserTO userTO = UserITCase.getUniqueSampleTO(\"syncope272@syncope.apache.org\");\n+        userTO.getResources().add(RESOURCE_NAME_TESTDB);\n+\n+        userTO = createUser(userTO);\n+        try {\n+            assertNotNull(userTO);\n+            assertEquals(1, userTO.getPropagationStatusTOs().size());\n+            assertTrue(userTO.getPropagationStatusTOs().get(0).getStatus().isSuccessful());\n+\n+            TaskExecTO taskExecTO = execSyncTask(24L, 50, false);\n+\n+            assertNotNull(taskExecTO.getStatus());\n+            assertTrue(PropagationTaskExecStatus.valueOf(taskExecTO.getStatus()).isSuccessful());\n+\n+            userTO = userService.read(userTO.getKey());\n+            assertNotNull(userTO);\n+            assertNotNull(userTO.getPlainAttrMap().get(\"firstname\").getValues().get(0));\n+        } finally {\n+            removeTestUsers();\n+        }\n+    }\n+\n     @Test\n     public void issueSYNCOPE307() {\n         UserTO userTO = UserITCase.getUniqueSampleTO(\"s307@apache.org\");\n@@ -977,167 +559,6 @@ public void issueSYNCOPE307() {\n         }\n     }\n \n-    @Test\n-    public void bulkAction() {\n-        final PagedResult<PropagationTaskTO> before = taskService.list(TaskType.PROPAGATION);\n-\n-        // create user with testdb resource\n-        final UserTO userTO = UserITCase.getUniqueSampleTO(\"taskBulk@apache.org\");\n-        userTO.getResources().add(RESOURCE_NAME_TESTDB);\n-        createUser(userTO);\n-\n-        final List<PropagationTaskTO> after = new ArrayList<PropagationTaskTO>(\n-                taskService.<PropagationTaskTO>list(TaskType.PROPAGATION).getResult());\n-\n-        after.removeAll(before.getResult());\n-\n-        assertFalse(after.isEmpty());\n-\n-        final BulkAction bulkAction = new BulkAction();\n-        bulkAction.setOperation(BulkAction.Type.DELETE);\n-\n-        for (AbstractTaskTO taskTO : after) {\n-            bulkAction.getTargets().add(String.valueOf(taskTO.getKey()));\n-        }\n-\n-        taskService.bulk(bulkAction);\n-\n-        assertFalse(taskService.list(TaskType.PROPAGATION).getResult().containsAll(after));\n-    }\n-\n-    @Test\n-    public void pushMatchingUnmatchingRoles() {\n-        assertFalse(roleService.read(3L).getResources().contains(RESOURCE_NAME_LDAP));\n-\n-        execSyncTask(23L, 50, false);\n-\n-        assertNotNull(resourceService.getConnectorObject(RESOURCE_NAME_LDAP, SubjectType.ROLE, 3L));\n-        assertTrue(roleService.read(3L).getResources().contains(RESOURCE_NAME_LDAP));\n-\n-        execSyncTask(23L, 50, false);\n-\n-        assertNotNull(resourceService.getConnectorObject(RESOURCE_NAME_LDAP, SubjectType.ROLE, 3L));\n-        assertFalse(roleService.read(3L).getResources().contains(RESOURCE_NAME_LDAP));\n-    }\n-\n-    @Test\n-    public void pushUnmatchingUsers() throws Exception {\n-        assertFalse(userService.read(2L).getResources().contains(RESOURCE_NAME_TESTDB2));\n-        assertFalse(userService.read(3L).getResources().contains(RESOURCE_NAME_TESTDB2));\n-        assertFalse(userService.read(4L).getResources().contains(RESOURCE_NAME_TESTDB2));\n-        assertTrue(userService.read(5L).getResources().contains(RESOURCE_NAME_TESTDB2));\n-\n-        final JdbcTemplate jdbcTemplate = new JdbcTemplate(testDataSource);\n-        assertEquals(0, jdbcTemplate.queryForList(\"SELECT ID FROM test2 WHERE ID='puccini'\").size());\n-\n-        // ------------------------------------------\n-        // Unmatching --> Assign --> dryRuyn\n-        // ------------------------------------------\n-        execSyncTask(13L, 50, true);\n-        assertEquals(0, jdbcTemplate.queryForList(\"SELECT ID FROM test2 WHERE ID='vivaldi'\").size());\n-        assertFalse(userService.read(3L).getResources().contains(RESOURCE_NAME_TESTDB2));\n-        // ------------------------------------------\n-\n-        final Set<Long> pushTaskIds = new HashSet<>();\n-        pushTaskIds.add(13L);\n-        pushTaskIds.add(14L);\n-        pushTaskIds.add(15L);\n-        pushTaskIds.add(16L);\n-        execSyncTasks(pushTaskIds, 50, false);\n-\n-        // ------------------------------------------\n-        // Unatching --> Ignore\n-        // ------------------------------------------\n-        assertEquals(1, jdbcTemplate.queryForList(\"SELECT ID FROM test2 WHERE ID='verdi'\").size());\n-        assertFalse(userService.read(2L).getResources().contains(RESOURCE_NAME_TESTDB2));\n-        // ------------------------------------------\n-\n-        // ------------------------------------------\n-        // Unmatching --> Assign\n-        // ------------------------------------------\n-        assertEquals(1, jdbcTemplate.queryForList(\"SELECT ID FROM test2 WHERE ID='vivaldi'\").size());\n-        assertTrue(userService.read(3L).getResources().contains(RESOURCE_NAME_TESTDB2));\n-        jdbcTemplate.execute(\"DELETE FROM test2 WHERE ID='vivaldi'\");\n-        // ------------------------------------------\n-\n-        // ------------------------------------------\n-        // Unmatching --> Provision\n-        // ------------------------------------------\n-        assertEquals(1, jdbcTemplate.queryForList(\"SELECT ID FROM test2 WHERE ID='bellini'\").size());\n-        assertFalse(userService.read(4L).getResources().contains(RESOURCE_NAME_TESTDB2));\n-        jdbcTemplate.execute(\"DELETE FROM test2 WHERE ID='bellini'\");\n-        // ------------------------------------------\n-\n-        // ------------------------------------------\n-        // Unmatching --> Unlink\n-        // ------------------------------------------\n-        assertEquals(0, jdbcTemplate.queryForList(\"SELECT ID FROM test2 WHERE ID='puccini'\").size());\n-        assertFalse(userService.read(5L).getResources().contains(RESOURCE_NAME_TESTDB2));\n-        // ------------------------------------------\n-    }\n-\n-    @Test\n-    public void pushMatchingUser() throws Exception {\n-        assertTrue(userService.read(1L).getResources().contains(RESOURCE_NAME_TESTDB2));\n-        assertFalse(userService.read(2L).getResources().contains(RESOURCE_NAME_TESTDB2));\n-\n-        final JdbcTemplate jdbcTemplate = new JdbcTemplate(testDataSource);\n-        assertEquals(1, jdbcTemplate.queryForList(\"SELECT ID FROM test2 WHERE ID='verdi'\").size());\n-        assertEquals(1, jdbcTemplate.queryForList(\"SELECT ID FROM test2 WHERE ID='rossini'\").size());\n-\n-        // ------------------------------------------\n-        // Matching --> Deprovision --> dryRuyn\n-        // ------------------------------------------\n-        execSyncTask(19L, 50, true);\n-        assertTrue(userService.read(1L).getResources().contains(RESOURCE_NAME_TESTDB2));\n-        assertEquals(1, jdbcTemplate.queryForList(\"SELECT ID FROM test2 WHERE ID='rossini'\").size());\n-        // ------------------------------------------\n-\n-        final Set<Long> pushTaskIds = new HashSet<>();\n-        pushTaskIds.add(18L);\n-        pushTaskIds.add(19L);\n-        pushTaskIds.add(16L);\n-\n-        execSyncTasks(pushTaskIds, 50, false);\n-\n-        // ------------------------------------------\n-        // Matching --> Deprovision && Ignore\n-        // ------------------------------------------\n-        assertFalse(userService.read(2L).getResources().contains(RESOURCE_NAME_TESTDB2));\n-        // DELETE Capability not available ....\n-        assertEquals(1, jdbcTemplate.queryForList(\"SELECT ID FROM test2 WHERE ID='verdi'\").size());\n-        // ------------------------------------------\n-\n-        // ------------------------------------------\n-        // Matching --> Unassign\n-        // ------------------------------------------\n-        assertFalse(userService.read(1L).getResources().contains(RESOURCE_NAME_TESTDB2));\n-        // DELETE Capability not available ....\n-        assertEquals(1, jdbcTemplate.queryForList(\"SELECT ID FROM test2 WHERE ID='rossini'\").size());\n-        // ------------------------------------------\n-\n-        // ------------------------------------------\n-        // Matching --> Link\n-        // ------------------------------------------\n-        execSyncTask(20L, 50, false);\n-        assertTrue(userService.read(2L).getResources().contains(RESOURCE_NAME_TESTDB2));\n-        assertEquals(1, jdbcTemplate.queryForList(\"SELECT ID FROM test2 WHERE ID='verdi'\").size());\n-        // ------------------------------------------\n-\n-        pushTaskIds.clear();\n-        pushTaskIds.add(21L);\n-        pushTaskIds.add(22L);\n-\n-        execSyncTasks(pushTaskIds, 50, false);\n-\n-        // ------------------------------------------\n-        // Matching --> Unlink && Update\n-        // ------------------------------------------\n-        assertFalse(userService.read(2L).getResources().contains(RESOURCE_NAME_TESTDB2));\n-        assertEquals(1, jdbcTemplate.queryForList(\"SELECT ID FROM test2 WHERE ID='verdi'\").size());\n-        // ------------------------------------------\n-    }\n-\n     @Test\n     public void issueSYNCOPE313DB() throws Exception {\n         // 1. create user in DB\n@@ -1270,114 +691,4 @@ public void issueSYNCOPE313LDAP() throws Exception {\n         connectorService.update(ldapResource.getConnectorId(), resourceConnector);\n         deleteUser(updatedUser.getKey());\n     }\n-\n-    @Test\n-    public void issueSYNCOPE598() {\n-        // create a new role schema\n-        final PlainSchemaTO schemaTO = new PlainSchemaTO();\n-        schemaTO.setKey(\"LDAPGroupName\" + getUUIDString());\n-        schemaTO.setType(AttrSchemaType.String);\n-        schemaTO.setMandatoryCondition(\"true\");\n-\n-        final PlainSchemaTO newPlainSchemaTO = createSchema(AttributableType.ROLE, SchemaType.PLAIN, schemaTO);\n-        assertEquals(schemaTO, newPlainSchemaTO);\n-\n-        // create a new sample role\n-        RoleTO roleTO = new RoleTO();\n-        roleTO.setName(\"all\" + getUUIDString());\n-        roleTO.setParent(8L);\n-\n-        roleTO.getRAttrTemplates().add(newPlainSchemaTO.getKey());\n-        roleTO.getPlainAttrs().add(attrTO(newPlainSchemaTO.getKey(), \"all\"));\n-\n-        roleTO = createRole(roleTO);\n-        assertNotNull(roleTO);\n-\n-        String resourceName = \"resource-ldap-roleonly\";\n-        ResourceTO newResourceTO = null;\n-\n-        try {\n-            // Create resource ad-hoc\n-            ResourceTO resourceTO = new ResourceTO();\n-            resourceTO.setKey(resourceName);\n-            resourceTO.setConnectorId(105L);\n-\n-            final MappingTO umapping = new MappingTO();\n-            MappingItemTO item = new MappingItemTO();\n-            item.setIntMappingType(IntMappingType.Username);\n-            item.setExtAttrName(\"cn\");\n-            item.setAccountid(true);\n-            item.setPurpose(MappingPurpose.PROPAGATION);\n-            item.setMandatoryCondition(\"true\");\n-            umapping.setAccountIdItem(item);\n-\n-            item = new MappingItemTO();\n-            item.setIntMappingType(IntMappingType.UserPlainSchema);\n-            item.setExtAttrName(\"surname\");\n-            item.setIntAttrName(\"sn\");\n-            item.setPurpose(MappingPurpose.BOTH);\n-            umapping.addItem(item);\n-\n-            item = new MappingItemTO();\n-            item.setIntMappingType(IntMappingType.UserPlainSchema);\n-            item.setExtAttrName(\"email\");\n-            item.setIntAttrName(\"mail\");\n-            item.setPurpose(MappingPurpose.BOTH);\n-            umapping.addItem(item);\n-\n-            item = new MappingItemTO();\n-            item.setIntMappingType(IntMappingType.Password);\n-            item.setPassword(true);\n-            item.setPurpose(MappingPurpose.BOTH);\n-            item.setMandatoryCondition(\"true\");\n-            umapping.addItem(item);\n-\n-            umapping.setAccountLink(\"'cn=' + username + ',ou=people,o=isp'\");\n-\n-            final MappingTO rmapping = new MappingTO();\n-\n-            item = new MappingItemTO();\n-            item.setIntMappingType(IntMappingType.RolePlainSchema);\n-            item.setExtAttrName(\"cn\");\n-            item.setIntAttrName(newPlainSchemaTO.getKey());\n-            item.setAccountid(true);\n-            item.setPurpose(MappingPurpose.BOTH);\n-            rmapping.setAccountIdItem(item);\n-\n-            rmapping.setAccountLink(\"'cn=' + \" + newPlainSchemaTO.getKey() + \" + ',ou=groups,o=isp'\");\n-\n-            resourceTO.setRmapping(rmapping);\n-\n-            Response response = resourceService.create(resourceTO);\n-            newResourceTO = getObject(response.getLocation(), ResourceService.class, ResourceTO.class);\n-\n-            assertNotNull(newResourceTO);\n-            assertNull(newResourceTO.getUmapping());\n-            assertNotNull(newResourceTO.getRmapping());\n-\n-            // create push task ad-hoc\n-            final PushTaskTO task = new PushTaskTO();\n-            task.setName(\"issueSYNCOPE598\");\n-            task.setResource(resourceName);\n-            task.setPerformCreate(true);\n-            task.setPerformDelete(true);\n-            task.setPerformUpdate(true);\n-            task.setUnmatchingRule(UnmatchingRule.ASSIGN);\n-            task.setMatchingRule(MatchingRule.UPDATE);\n-\n-            response = taskService.create(task);\n-            final PushTaskTO push = getObject(response.getLocation(), TaskService.class, PushTaskTO.class);\n-\n-            assertNotNull(push);\n-\n-            // execute the new task\n-            final TaskExecTO pushExec = execSyncTask(push.getKey(), 50, false);\n-            assertTrue(PropagationTaskExecStatus.valueOf(pushExec.getStatus()).isSuccessful());\n-        } finally {\n-            roleService.delete(roleTO.getKey());\n-            if (newResourceTO != null) {\n-                resourceService.delete(resourceName);\n-            }\n-        }\n-    }\n }","previous_filename":"syncope620/fit/reference/src/test/java/org/apache/syncope/fit/server/reference/TaskITCase.java"},{"sha":"72b9eab6859162d537b5006f039c50eab6dce184","filename":"syncope620/server/logic/src/main/java/org/apache/syncope/server/logic/ConfigurationLogic.java","status":"modified","additions":7,"deletions":3,"changes":10,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/6f24e817019a627a6bfe8c6e36af56f04a237983/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2FConfigurationLogic.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/6f24e817019a627a6bfe8c6e36af56f04a237983/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2FConfigurationLogic.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2FConfigurationLogic.java?ref=6f24e817019a627a6bfe8c6e36af56f04a237983","patch":"@@ -29,7 +29,8 @@\n import org.apache.syncope.server.persistence.api.entity.conf.CPlainAttr;\n import org.apache.syncope.server.persistence.api.entity.conf.CPlainSchema;\n import org.apache.syncope.server.provisioning.api.data.ConfigurationDataBinder;\n-import org.apache.syncope.server.logic.init.WorkflowAdapterLoader;\n+import org.apache.syncope.server.workflow.api.RoleWorkflowAdapter;\n+import org.apache.syncope.server.workflow.api.UserWorkflowAdapter;\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.security.access.prepost.PreAuthorize;\n import org.springframework.stereotype.Component;\n@@ -51,7 +52,10 @@ public class ConfigurationLogic extends AbstractTransactionalLogic<ConfTO> {\n     private ContentExporter exporter;\n \n     @Autowired\n-    private WorkflowAdapterLoader wfAdapterLoader;\n+    private UserWorkflowAdapter uwfAdapter;\n+\n+    @Autowired\n+    private RoleWorkflowAdapter rwfAdapter;\n \n     @PreAuthorize(\"hasRole('CONFIGURATION_DELETE')\")\n     public void delete(final String key) {\n@@ -92,7 +96,7 @@ public void set(final AttrTO value) {\n     @Transactional(readOnly = true)\n     public void export(final OutputStream os) {\n         try {\n-            exporter.export(os, wfAdapterLoader.getPrefix());\n+            exporter.export(os, uwfAdapter.getPrefix(), rwfAdapter.getPrefix());\n             LOG.debug(\"Database content successfully exported\");\n         } catch (Exception e) {\n             LOG.error(\"While exporting database content\", e);"},{"sha":"e988def2363315441dd6407ce47e857b6326fa0a","filename":"syncope620/server/logic/src/main/java/org/apache/syncope/server/logic/init/LogicInitializer.java","status":"modified","additions":14,"deletions":15,"changes":29,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/6f24e817019a627a6bfe8c6e36af56f04a237983/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Finit%2FLogicInitializer.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/6f24e817019a627a6bfe8c6e36af56f04a237983/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Finit%2FLogicInitializer.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Finit%2FLogicInitializer.java?ref=6f24e817019a627a6bfe8c6e36af56f04a237983","patch":"@@ -24,11 +24,13 @@\n import java.util.List;\n import java.util.Map;\n import org.apache.syncope.server.persistence.api.SyncopeLoader;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.aop.support.AopUtils;\n import org.springframework.beans.BeansException;\n import org.springframework.beans.factory.BeanFactory;\n import org.springframework.beans.factory.BeanFactoryAware;\n import org.springframework.beans.factory.InitializingBean;\n-import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.beans.factory.support.DefaultListableBeanFactory;\n import org.springframework.stereotype.Component;\n \n@@ -38,8 +40,7 @@\n @Component\n public class LogicInitializer implements InitializingBean, BeanFactoryAware {\n \n-    @Autowired\n-    private WorkflowAdapterLoader workflowAdapterLoader;\n+    private static final Logger LOG = LoggerFactory.getLogger(LogicInitializer.class);\n \n     private DefaultListableBeanFactory beanFactory;\n \n@@ -53,21 +54,19 @@ public void afterPropertiesSet() throws Exception {\n         Map<String, SyncopeLoader> loaderMap = beanFactory.getBeansOfType(SyncopeLoader.class);\n \n         List<SyncopeLoader> loaders = new ArrayList<>(loaderMap.values());\n-        Collections.sort(loaders, new PriorityComparator());\n+        Collections.sort(loaders, new Comparator<SyncopeLoader>() {\n \n+            @Override\n+            public int compare(final SyncopeLoader o1, final SyncopeLoader o2) {\n+                return o1.getPriority().compareTo(o2.getPriority());\n+            }\n+        });\n+\n+        LOG.debug(\"Starting initialization...\");\n         for (SyncopeLoader loader : loaders) {\n+            LOG.debug(\"Invoking {} with priority {}\", AopUtils.getTargetClass(loader).getName(), loader.getPriority());\n             loader.load();\n         }\n-\n-        workflowAdapterLoader.init();\n-    }\n-\n-    private static class PriorityComparator implements Comparator<SyncopeLoader> {\n-\n-        @Override\n-        public int compare(final SyncopeLoader o1, final SyncopeLoader o2) {\n-            return o1.getPriority().compareTo(o2.getPriority());\n-        }\n-\n+        LOG.debug(\"Initialization completed\");\n     }\n }"},{"sha":"fb9cbe789b4c83287bd42e2faa1f76164d2ee6df","filename":"syncope620/server/logic/src/main/java/org/apache/syncope/server/logic/init/WorkflowAdapterLoader.java","status":"removed","additions":0,"deletions":95,"changes":95,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/16984bdafb8572f7dd552a50d88e25f82e1f2e99/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Finit%2FWorkflowAdapterLoader.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/16984bdafb8572f7dd552a50d88e25f82e1f2e99/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Finit%2FWorkflowAdapterLoader.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Finit%2FWorkflowAdapterLoader.java?ref=16984bdafb8572f7dd552a50d88e25f82e1f2e99","patch":"@@ -1,95 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-package org.apache.syncope.server.logic.init;\n-\n-import org.apache.syncope.server.persistence.api.SyncopeLoader;\n-import org.apache.syncope.server.workflow.api.RoleWorkflowAdapter;\n-import org.apache.syncope.server.workflow.api.UserWorkflowAdapter;\n-import org.apache.syncope.server.workflow.api.WorkflowDefinitionLoader;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-import org.springframework.beans.BeansException;\n-import org.springframework.beans.factory.BeanFactory;\n-import org.springframework.beans.factory.BeanFactoryAware;\n-import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.beans.factory.support.AbstractBeanDefinition;\n-import org.springframework.beans.factory.support.DefaultListableBeanFactory;\n-import org.springframework.stereotype.Component;\n-\n-@Component\n-public class WorkflowAdapterLoader implements BeanFactoryAware, SyncopeLoader {\n-\n-    private static final Logger LOG = LoggerFactory.getLogger(WorkflowAdapterLoader.class);\n-\n-    @Autowired\n-    private UserWorkflowAdapter uwfAdapter;\n-\n-    @Autowired\n-    private RoleWorkflowAdapter rwfAdapter;\n-\n-    private DefaultListableBeanFactory beanFactory;\n-\n-    private WorkflowDefinitionLoader wfLoader;\n-\n-    @Override\n-    public void setBeanFactory(final BeanFactory beanFactory) throws BeansException {\n-        this.beanFactory = (DefaultListableBeanFactory) beanFactory;\n-    }\n-\n-    private void lazyInit() {\n-        if (wfLoader == null) {\n-            if (uwfAdapter.getDefinitionLoaderClass() != null) {\n-                wfLoader = (WorkflowDefinitionLoader) beanFactory.createBean(\n-                        uwfAdapter.getDefinitionLoaderClass(), AbstractBeanDefinition.AUTOWIRE_BY_TYPE, false);\n-            }\n-            if (rwfAdapter.getDefinitionLoaderClass() != null) {\n-                wfLoader = (WorkflowDefinitionLoader) beanFactory.createBean(\n-                        rwfAdapter.getDefinitionLoaderClass(), AbstractBeanDefinition.AUTOWIRE_BY_TYPE, false);\n-            }\n-        }\n-    }\n-\n-    public String getPrefix() {\n-        lazyInit();\n-        return wfLoader == null ? null : wfLoader.getPrefix();\n-    }\n-\n-    public void init() {\n-        lazyInit();\n-        if (wfLoader != null) {\n-            wfLoader.init();\n-        }\n-    }\n-\n-    @Override\n-    public Integer getPriority() {\n-        return Integer.MIN_VALUE;\n-    }\n-\n-    @Override\n-    public void load() {\n-        lazyInit();\n-        if (wfLoader == null) {\n-            LOG.debug(\"The configured workflow adapter does not need loading\");\n-        } else {\n-            LOG.debug(\"Loading workflow adapter by {}\", wfLoader.getClass().getName());\n-            wfLoader.load();\n-        }\n-    }\n-}"},{"sha":"76534e179269bf3ee177bb8482355f4f68e368fe","filename":"syncope620/server/persistence-api/src/main/java/org/apache/syncope/server/persistence/api/content/ContentExporter.java","status":"modified","additions":2,"deletions":1,"changes":3,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/6f24e817019a627a6bfe8c6e36af56f04a237983/syncope620%2Fserver%2Fpersistence-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Fpersistence%2Fapi%2Fcontent%2FContentExporter.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/6f24e817019a627a6bfe8c6e36af56f04a237983/syncope620%2Fserver%2Fpersistence-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Fpersistence%2Fapi%2Fcontent%2FContentExporter.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Fpersistence-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Fpersistence%2Fapi%2Fcontent%2FContentExporter.java?ref=6f24e817019a627a6bfe8c6e36af56f04a237983","patch":"@@ -24,5 +24,6 @@\n \n public interface ContentExporter {\n \n-    void export(OutputStream output, String wfTablePrefix) throws SAXException, TransformerConfigurationException;\n+    void export(OutputStream output, String uwfPrefix, String rwfPrefix) \n+            throws SAXException, TransformerConfigurationException;\n }"},{"sha":"8a87df18278d5dab08bd9b56d6132c54373f8fb2","filename":"syncope620/server/persistence-jpa/src/main/java/org/apache/syncope/server/persistence/jpa/content/XMLContentExporter.java","status":"modified","additions":6,"deletions":3,"changes":9,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/6f24e817019a627a6bfe8c6e36af56f04a237983/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Fpersistence%2Fjpa%2Fcontent%2FXMLContentExporter.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/6f24e817019a627a6bfe8c6e36af56f04a237983/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Fpersistence%2Fjpa%2Fcontent%2FXMLContentExporter.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Fpersistence%2Fjpa%2Fcontent%2FXMLContentExporter.java?ref=6f24e817019a627a6bfe8c6e36af56f04a237983","patch":"@@ -320,11 +320,14 @@ private void doExportTable(final TransformerHandler handler, final Connection co\n     }\n \n     @Override\n-    public void export(final OutputStream os, final String wfTablePrefix)\n+    public void export(final OutputStream os, final String uwfPrefix, String rwfPrefix)\n             throws SAXException, TransformerConfigurationException {\n \n-        if (StringUtils.isNotBlank(wfTablePrefix)) {\n-            TABLE_PREFIXES_TO_BE_EXCLUDED.add(wfTablePrefix);\n+        if (StringUtils.isNotBlank(uwfPrefix)) {\n+            TABLE_PREFIXES_TO_BE_EXCLUDED.add(uwfPrefix);\n+        }\n+        if (StringUtils.isNotBlank(rwfPrefix)) {\n+            TABLE_PREFIXES_TO_BE_EXCLUDED.add(rwfPrefix);\n         }\n \n         StreamResult streamResult = new StreamResult(os);"},{"sha":"4d81a4e969d838ac27c8ecb836fe8325837a401e","filename":"syncope620/server/workflow-activiti/src/main/java/org/apache/syncope/server/workflow/activiti/ActivitiDefinitionLoader.java","status":"modified","additions":11,"deletions":12,"changes":23,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/6f24e817019a627a6bfe8c6e36af56f04a237983/syncope620%2Fserver%2Fworkflow-activiti%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Fworkflow%2Factiviti%2FActivitiDefinitionLoader.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/6f24e817019a627a6bfe8c6e36af56f04a237983/syncope620%2Fserver%2Fworkflow-activiti%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Fworkflow%2Factiviti%2FActivitiDefinitionLoader.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Fworkflow-activiti%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Fworkflow%2Factiviti%2FActivitiDefinitionLoader.java?ref=6f24e817019a627a6bfe8c6e36af56f04a237983","patch":"@@ -32,12 +32,14 @@\n import org.activiti.spring.SpringProcessEngineConfiguration;\n import org.apache.commons.io.IOUtils;\n import org.apache.syncope.server.misc.spring.ResourceWithFallbackLoader;\n-import org.apache.syncope.server.workflow.api.WorkflowDefinitionLoader;\n+import org.apache.syncope.server.persistence.api.SyncopeLoader;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Component;\n \n-public class ActivitiDefinitionLoader implements WorkflowDefinitionLoader {\n+@Component\n+public class ActivitiDefinitionLoader implements SyncopeLoader {\n \n     private static final Logger LOG = LoggerFactory.getLogger(ActivitiDefinitionLoader.class);\n \n@@ -54,16 +56,8 @@ public class ActivitiDefinitionLoader implements WorkflowDefinitionLoader {\n     private ActivitiImportUtils importUtils;\n \n     @Override\n-    public String getPrefix() {\n-        return \"ACT_\";\n-    }\n-\n-    @Override\n-    public void init() {\n-        // jump to the next ID block\n-        for (int i = 0; i < conf.getIdBlockSize(); i++) {\n-            conf.getIdGenerator().getNextId();\n-        }\n+    public Integer getPriority() {\n+        return Integer.MIN_VALUE;\n     }\n \n     @Override\n@@ -100,5 +94,10 @@ public void load() {\n                 IOUtils.closeQuietly(wfIn);\n             }\n         }\n+\n+        // jump to the next ID block\n+        for (int i = 0; i < conf.getIdBlockSize(); i++) {\n+            conf.getIdGenerator().getNextId();\n+        }\n     }\n }"},{"sha":"90dc106738f0dac5890b7976e262e7eb32b72667","filename":"syncope620/server/workflow-activiti/src/main/java/org/apache/syncope/server/workflow/activiti/ActivitiUserWorkflowAdapter.java","status":"modified","additions":2,"deletions":3,"changes":5,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/6f24e817019a627a6bfe8c6e36af56f04a237983/syncope620%2Fserver%2Fworkflow-activiti%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Fworkflow%2Factiviti%2FActivitiUserWorkflowAdapter.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/6f24e817019a627a6bfe8c6e36af56f04a237983/syncope620%2Fserver%2Fworkflow-activiti%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Fworkflow%2Factiviti%2FActivitiUserWorkflowAdapter.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Fworkflow-activiti%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Fworkflow%2Factiviti%2FActivitiUserWorkflowAdapter.java?ref=6f24e817019a627a6bfe8c6e36af56f04a237983","patch":"@@ -76,7 +76,6 @@\n import org.apache.syncope.server.provisioning.api.data.UserDataBinder;\n import org.apache.syncope.server.workflow.api.WorkflowDefinitionFormat;\n import org.apache.syncope.server.workflow.api.WorkflowException;\n-import org.apache.syncope.server.workflow.api.WorkflowDefinitionLoader;\n import org.apache.syncope.server.workflow.java.AbstractUserWorkflowAdapter;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -160,8 +159,8 @@ public class ActivitiUserWorkflowAdapter extends AbstractUserWorkflowAdapter {\n     private UserDataBinder userDataBinder;\n \n     @Override\n-    public Class<? extends WorkflowDefinitionLoader> getDefinitionLoaderClass() {\n-        return ActivitiDefinitionLoader.class;\n+    public String getPrefix() {\n+        return \"ACT_\";\n     }\n \n     private void throwException(final ActivitiException e, final String defaultMessage) {"},{"sha":"33888307d4ab516d070d7934b504668b9a8f5ba2","filename":"syncope620/server/workflow-api/src/main/java/org/apache/syncope/server/workflow/api/WorkflowAdapter.java","status":"modified","additions":2,"deletions":6,"changes":8,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/6f24e817019a627a6bfe8c6e36af56f04a237983/syncope620%2Fserver%2Fworkflow-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Fworkflow%2Fapi%2FWorkflowAdapter.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/6f24e817019a627a6bfe8c6e36af56f04a237983/syncope620%2Fserver%2Fworkflow-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Fworkflow%2Fapi%2FWorkflowAdapter.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Fworkflow-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Fworkflow%2Fapi%2FWorkflowAdapter.java?ref=6f24e817019a627a6bfe8c6e36af56f04a237983","patch":"@@ -28,13 +28,9 @@\n public interface WorkflowAdapter {\n \n     /**\n-     * Give the class to be instantiated and invoked by SpringContextInitializer for loading anything needed by this\n-     * adapter.\n-     *\n-     * @return null if no init is needed or the WorkflowLoader class for handling initialization\n-     * @see org.apache.syncope.core.init.SpringContextInitializer\n+     * @return any string that might be interpreted as &quot;prefix&quote; (say table prefix in SQL environments)\n      */\n-    Class<? extends WorkflowDefinitionLoader> getDefinitionLoaderClass();\n+    String getPrefix();\n \n     /**\n      * Export workflow definition."},{"sha":"5a3d7f452e0b860f033cabd9d878d8cb07b6ce1a","filename":"syncope620/server/workflow-api/src/main/java/org/apache/syncope/server/workflow/api/WorkflowDefinitionLoader.java","status":"removed","additions":0,"deletions":29,"changes":29,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/16984bdafb8572f7dd552a50d88e25f82e1f2e99/syncope620%2Fserver%2Fworkflow-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Fworkflow%2Fapi%2FWorkflowDefinitionLoader.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/16984bdafb8572f7dd552a50d88e25f82e1f2e99/syncope620%2Fserver%2Fworkflow-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Fworkflow%2Fapi%2FWorkflowDefinitionLoader.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Fworkflow-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Fworkflow%2Fapi%2FWorkflowDefinitionLoader.java?ref=16984bdafb8572f7dd552a50d88e25f82e1f2e99","patch":"@@ -1,29 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-package org.apache.syncope.server.workflow.api;\n-\n-public interface WorkflowDefinitionLoader {\n-\n-    void load();\n-\n-    void init();\n-\n-    String getPrefix();\n-\n-}"},{"sha":"9c496e384e9f75ec9649a41c8c52133917d41519","filename":"syncope620/server/workflow-java/src/main/java/org/apache/syncope/server/workflow/java/AbstractRoleWorkflowAdapter.java","status":"modified","additions":1,"deletions":2,"changes":3,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/6f24e817019a627a6bfe8c6e36af56f04a237983/syncope620%2Fserver%2Fworkflow-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Fworkflow%2Fjava%2FAbstractRoleWorkflowAdapter.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/6f24e817019a627a6bfe8c6e36af56f04a237983/syncope620%2Fserver%2Fworkflow-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Fworkflow%2Fjava%2FAbstractRoleWorkflowAdapter.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Fworkflow-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Fworkflow%2Fjava%2FAbstractRoleWorkflowAdapter.java?ref=6f24e817019a627a6bfe8c6e36af56f04a237983","patch":"@@ -27,7 +27,6 @@\n import org.apache.syncope.server.provisioning.api.data.RoleDataBinder;\n import org.apache.syncope.server.workflow.api.RoleWorkflowAdapter;\n import org.apache.syncope.server.workflow.api.WorkflowException;\n-import org.apache.syncope.server.workflow.api.WorkflowDefinitionLoader;\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.transaction.annotation.Transactional;\n \n@@ -44,7 +43,7 @@ public abstract class AbstractRoleWorkflowAdapter implements RoleWorkflowAdapter\n     protected EntityFactory entityFactory;\n \n     @Override\n-    public Class<? extends WorkflowDefinitionLoader> getDefinitionLoaderClass() {\n+    public String getPrefix() {\n         return null;\n     }\n "},{"sha":"94b1a674b30b32d60abe14f5206433884125783c","filename":"syncope620/server/workflow-java/src/main/java/org/apache/syncope/server/workflow/java/AbstractUserWorkflowAdapter.java","status":"modified","additions":1,"deletions":2,"changes":3,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/6f24e817019a627a6bfe8c6e36af56f04a237983/syncope620%2Fserver%2Fworkflow-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Fworkflow%2Fjava%2FAbstractUserWorkflowAdapter.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/6f24e817019a627a6bfe8c6e36af56f04a237983/syncope620%2Fserver%2Fworkflow-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Fworkflow%2Fjava%2FAbstractUserWorkflowAdapter.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Fworkflow-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Fworkflow%2Fjava%2FAbstractUserWorkflowAdapter.java?ref=6f24e817019a627a6bfe8c6e36af56f04a237983","patch":"@@ -27,7 +27,6 @@\n import org.apache.syncope.server.provisioning.api.data.UserDataBinder;\n import org.apache.syncope.server.workflow.api.UserWorkflowAdapter;\n import org.apache.syncope.server.workflow.api.WorkflowException;\n-import org.apache.syncope.server.workflow.api.WorkflowDefinitionLoader;\n import org.identityconnectors.common.Base64;\n import org.identityconnectors.common.security.EncryptorFactory;\n import org.springframework.beans.factory.annotation.Autowired;\n@@ -56,7 +55,7 @@ public static String decrypt(final String crypted) {\n     }\n \n     @Override\n-    public Class<? extends WorkflowDefinitionLoader> getDefinitionLoaderClass() {\n+    public String getPrefix() {\n         return null;\n     }\n "}]}