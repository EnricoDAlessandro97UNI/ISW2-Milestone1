{"sha":"761399c46b69b5e27e5ff0e47a7ed5ddb6489f3b","node_id":"MDY6Q29tbWl0NjM2ODc5MDYyOjc2MTM5OWM0NmI2OWI1ZTI3ZTVmZjBlNDdhN2VkNWRkYjY0ODlmM2I=","commit":{"author":{"name":"Francesco Chicchiriccò","email":"ilgrosso@apache.org","date":"2018-04-26T12:06:28Z"},"committer":{"name":"Francesco Chicchiriccò","email":"ilgrosso@apache.org","date":"2018-04-26T12:13:06Z"},"message":"[SYNCOPE-1307] Forcing tree visit for Realms to ensure correct order","tree":{"sha":"87a9fd897d1a2417c31d1319f5e4e3d833e6cc18","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/git/trees/87a9fd897d1a2417c31d1319f5e4e3d833e6cc18"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/git/commits/761399c46b69b5e27e5ff0e47a7ed5ddb6489f3b","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/761399c46b69b5e27e5ff0e47a7ed5ddb6489f3b","html_url":"https://github.com/EnricoDAlessandro97UNI/syncope/commit/761399c46b69b5e27e5ff0e47a7ed5ddb6489f3b","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/761399c46b69b5e27e5ff0e47a7ed5ddb6489f3b/comments","author":{"login":"ilgrosso","id":1064664,"node_id":"MDQ6VXNlcjEwNjQ2NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/1064664?v=4","gravatar_id":"","url":"https://api.github.com/users/ilgrosso","html_url":"https://github.com/ilgrosso","followers_url":"https://api.github.com/users/ilgrosso/followers","following_url":"https://api.github.com/users/ilgrosso/following{/other_user}","gists_url":"https://api.github.com/users/ilgrosso/gists{/gist_id}","starred_url":"https://api.github.com/users/ilgrosso/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ilgrosso/subscriptions","organizations_url":"https://api.github.com/users/ilgrosso/orgs","repos_url":"https://api.github.com/users/ilgrosso/repos","events_url":"https://api.github.com/users/ilgrosso/events{/privacy}","received_events_url":"https://api.github.com/users/ilgrosso/received_events","type":"User","site_admin":false},"committer":{"login":"ilgrosso","id":1064664,"node_id":"MDQ6VXNlcjEwNjQ2NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/1064664?v=4","gravatar_id":"","url":"https://api.github.com/users/ilgrosso","html_url":"https://github.com/ilgrosso","followers_url":"https://api.github.com/users/ilgrosso/followers","following_url":"https://api.github.com/users/ilgrosso/following{/other_user}","gists_url":"https://api.github.com/users/ilgrosso/gists{/gist_id}","starred_url":"https://api.github.com/users/ilgrosso/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ilgrosso/subscriptions","organizations_url":"https://api.github.com/users/ilgrosso/orgs","repos_url":"https://api.github.com/users/ilgrosso/repos","events_url":"https://api.github.com/users/ilgrosso/events{/privacy}","received_events_url":"https://api.github.com/users/ilgrosso/received_events","type":"User","site_admin":false},"parents":[{"sha":"c0e2aedef5360101a78fb0932c7ea16fc2ae3c8b","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/c0e2aedef5360101a78fb0932c7ea16fc2ae3c8b","html_url":"https://github.com/EnricoDAlessandro97UNI/syncope/commit/c0e2aedef5360101a78fb0932c7ea16fc2ae3c8b"}],"stats":{"total":109,"additions":55,"deletions":54},"files":[{"sha":"232e22a483161d129977731fc4e486d077acbe15","filename":"core/persistence-jpa/src/main/java/org/apache/syncope/core/persistence/jpa/content/MultiParentNode.java","status":"modified","additions":1,"deletions":2,"changes":3,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/761399c46b69b5e27e5ff0e47a7ed5ddb6489f3b/core%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fjpa%2Fcontent%2FMultiParentNode.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/761399c46b69b5e27e5ff0e47a7ed5ddb6489f3b/core%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fjpa%2Fcontent%2FMultiParentNode.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fjpa%2Fcontent%2FMultiParentNode.java?ref=761399c46b69b5e27e5ff0e47a7ed5ddb6489f3b","patch":"@@ -27,15 +27,14 @@\n \n     private final T object;\n \n-    private Set<MultiParentNode<T>> children;\n+    private final Set<MultiParentNode<T>> children = new HashSet<>();\n \n     private int level;\n \n     private boolean exploited = false;\n \n     MultiParentNode(final T object) {\n         this.object = object;\n-        children = new HashSet<>();\n     }\n \n     public int getLevel() {"},{"sha":"44f14110517ba4df11b6196a1d4af84ad5e2117e","filename":"core/persistence-jpa/src/main/java/org/apache/syncope/core/persistence/jpa/content/XMLContentExporter.java","status":"modified","additions":46,"deletions":49,"changes":95,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/761399c46b69b5e27e5ff0e47a7ed5ddb6489f3b/core%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fjpa%2Fcontent%2FXMLContentExporter.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/761399c46b69b5e27e5ff0e47a7ed5ddb6489f3b/core%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fjpa%2Fcontent%2FXMLContentExporter.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fjpa%2Fcontent%2FXMLContentExporter.java?ref=761399c46b69b5e27e5ff0e47a7ed5ddb6489f3b","patch":"@@ -35,6 +35,7 @@\n import java.util.Arrays;\n import java.util.Collections;\n import java.util.Date;\n+import java.util.HashMap;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n@@ -55,7 +56,9 @@\n import org.apache.syncope.core.provisioning.api.utils.FormatUtils;\n import org.apache.syncope.core.spring.ApplicationContextProvider;\n import org.apache.syncope.core.persistence.api.content.ContentExporter;\n+import org.apache.syncope.core.persistence.api.dao.RealmDAO;\n import org.apache.syncope.core.persistence.jpa.entity.JPAAccessToken;\n+import org.apache.syncope.core.persistence.jpa.entity.JPARealm;\n import org.apache.syncope.core.persistence.jpa.entity.JPAReportExec;\n import org.apache.syncope.core.persistence.jpa.entity.anyobject.JPAAMembership;\n import org.apache.syncope.core.persistence.jpa.entity.anyobject.JPAAPlainAttr;\n@@ -70,6 +73,7 @@\n import org.apache.syncope.core.persistence.jpa.entity.user.JPAUPlainAttrValue;\n import org.apache.syncope.core.persistence.jpa.entity.user.JPAURelationship;\n import org.apache.syncope.core.persistence.jpa.entity.user.JPAUser;\n+import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.jdbc.datasource.DataSourceUtils;\n import org.springframework.stereotype.Component;\n import org.xml.sax.SAXException;\n@@ -95,6 +99,9 @@ public class XMLContentExporter extends AbstractContentDealer implements Content\n     protected static final Map<String, Set<String>> COLUMNS_TO_BE_NULLIFIED =\n             Collections.singletonMap(\"SYNCOPEGROUP\", Collections.singleton(\"USEROWNER_ID\"));\n \n+    @Autowired\n+    private RealmDAO realmDAO;\n+\n     private boolean isTableAllowed(final String tableName) {\n         return TABLE_PREFIXES_TO_BE_EXCLUDED.stream().\n                 allMatch(prefix -> !tableName.toUpperCase().startsWith(prefix.toUpperCase()));\n@@ -105,10 +112,10 @@ private List<String> sortByForeignKeys(final String dbSchema, final Connection c\n \n         Set<MultiParentNode<String>> roots = new HashSet<>();\n \n-        final DatabaseMetaData meta = conn.getMetaData();\n+        DatabaseMetaData meta = conn.getMetaData();\n \n-        final Map<String, MultiParentNode<String>> exploited = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);\n-        final Set<String> pkTableNames = new HashSet<>();\n+        Map<String, MultiParentNode<String>> exploited = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);\n+        Set<String> pkTableNames = new HashSet<>();\n \n         for (String tableName : tableNames) {\n             MultiParentNode<String> node = exploited.get(tableName);\n@@ -156,7 +163,7 @@ private List<String> sortByForeignKeys(final String dbSchema, final Connection c\n             }\n         }\n \n-        final List<String> sortedTableNames = new ArrayList<>(tableNames.size());\n+        List<String> sortedTableNames = new ArrayList<>(tableNames.size());\n         MultiParentNodeOp.traverseTree(roots, sortedTableNames);\n \n         // remove from sortedTableNames any table possibly added during lookup \n@@ -221,52 +228,23 @@ private String getValues(final ResultSet rs, final String columnName, final Inte\n         return res;\n     }\n \n-    private void doExportTable(\n+    private void exportTable(\n             final TransformerHandler handler,\n-            final String dbSchema,\n             final Connection conn,\n             final String tableName,\n             final String whereClause) throws SQLException, SAXException {\n \n         LOG.debug(\"Export table {}\", tableName);\n \n-        AttributesImpl attrs = new AttributesImpl();\n-\n         PreparedStatement stmt = null;\n         ResultSet rs = null;\n         try {\n             StringBuilder orderBy = new StringBuilder();\n \n             DatabaseMetaData meta = conn.getMetaData();\n \n-            // ------------------------------------\n-            // retrieve foreign keys (linked to the same table) to perform an ordered select\n-            ResultSet pkeyRS = null;\n-            try {\n-                pkeyRS = meta.getImportedKeys(conn.getCatalog(), dbSchema, tableName);\n-                while (pkeyRS.next()) {\n-                    if (tableName.equals(pkeyRS.getString(\"PKTABLE_NAME\"))) {\n-                        String columnName = pkeyRS.getString(\"FKCOLUMN_NAME\");\n-                        if (columnName != null) {\n-                            if (orderBy.length() > 0) {\n-                                orderBy.append(\",\");\n-                            }\n-\n-                            orderBy.append(columnName);\n-                        }\n-                    }\n-                }\n-            } finally {\n-                if (pkeyRS != null) {\n-                    try {\n-                        pkeyRS.close();\n-                    } catch (SQLException e) {\n-                        LOG.error(\"While closing result set\", e);\n-                    }\n-                }\n-            }\n-\n             // retrieve primary keys to perform an ordered select\n+            ResultSet pkeyRS = null;\n             try {\n                 pkeyRS = meta.getPrimaryKeys(null, null, tableName);\n                 while (pkeyRS.next()) {\n@@ -300,28 +278,49 @@ private void doExportTable(\n             }\n             stmt = conn.prepareStatement(query.toString());\n \n+            List<Map<String, String>> rows = new ArrayList<>();\n+\n             rs = stmt.executeQuery();\n             while (rs.next()) {\n-                attrs.clear();\n+                Map<String, String> row = new HashMap<>();\n+                rows.add(row);\n \n-                final ResultSetMetaData rsMeta = rs.getMetaData();\n+                ResultSetMetaData rsMeta = rs.getMetaData();\n                 for (int i = 0; i < rsMeta.getColumnCount(); i++) {\n-                    final String columnName = rsMeta.getColumnName(i + 1);\n-                    final Integer columnType = rsMeta.getColumnType(i + 1);\n+                    String columnName = rsMeta.getColumnName(i + 1);\n+                    Integer columnType = rsMeta.getColumnType(i + 1);\n \n                     // Retrieve value taking care of binary values.\n                     String value = getValues(rs, columnName, columnType);\n                     if (value != null && (!COLUMNS_TO_BE_NULLIFIED.containsKey(tableName)\n                             || !COLUMNS_TO_BE_NULLIFIED.get(tableName).contains(columnName))) {\n \n-                        attrs.addAttribute(\"\", \"\", columnName, \"CDATA\", value);\n+                        row.put(columnName, value);\n+                        LOG.debug(\"Add for table {}: {}=\\\"{}\\\"\", tableName, columnName, value);\n                     }\n                 }\n+            }\n+\n+            if (tableName.equalsIgnoreCase(JPARealm.TABLE)) {\n+                List<Map<String, String>> realmRows = new ArrayList<>(rows);\n+                rows.clear();\n+                realmDAO.findAll().forEach(realm -> {\n+                    realmRows.stream().filter(row -> {\n+                        String id = row.get(\"ID\");\n+                        if (id == null) {\n+                            id = row.get(\"id\");\n+                        }\n+                        return realm.getKey().equals(id);\n+                    }).findFirst().ifPresent(row -> rows.add(row));\n+                });\n+            }\n+\n+            for (Map<String, String> row : rows) {\n+                AttributesImpl attrs = new AttributesImpl();\n+                row.forEach((key, value) -> attrs.addAttribute(\"\", \"\", key, \"CDATA\", value));\n \n                 handler.startElement(\"\", \"\", tableName, attrs);\n                 handler.endElement(\"\", \"\", tableName);\n-\n-                LOG.debug(\"Add record {}\", attrs);\n             }\n         } finally {\n             if (rs != null) {\n@@ -335,7 +334,7 @@ private void doExportTable(\n                 try {\n                     stmt.close();\n                 } catch (SQLException e) {\n-                    LOG.error(\"While closing result set\", e);\n+                    LOG.error(\"While closing statement\", e);\n                 }\n             }\n         }\n@@ -377,16 +376,15 @@ public void export(\n             throw new IllegalArgumentException(\"Could not find DataSource for domain \" + domain);\n         }\n \n-        String dbSchema = ApplicationContextProvider.getBeanFactory().getBean(domain + \"DatabaseSchema\",\n-                String.class);\n+        String schema = ApplicationContextProvider.getBeanFactory().getBean(domain + \"DatabaseSchema\", String.class);\n \n         Connection conn = null;\n         ResultSet rs = null;\n         try {\n             conn = DataSourceUtils.getConnection(dataSource);\n             final DatabaseMetaData meta = conn.getMetaData();\n \n-            rs = meta.getTables(null, StringUtils.isBlank(dbSchema) ? null : dbSchema, null,\n+            rs = meta.getTables(null, StringUtils.isBlank(schema) ? null : schema, null,\n                     new String[] { \"TABLE\" });\n \n             final Set<String> tableNames = new TreeSet<>(String.CASE_INSENSITIVE_ORDER);\n@@ -402,10 +400,9 @@ public void export(\n             LOG.debug(\"Tables to be exported {}\", tableNames);\n \n             // then sort tables based on foreign keys and dump\n-            for (String tableName : sortByForeignKeys(dbSchema, conn, tableNames)) {\n+            for (String tableName : sortByForeignKeys(schema, conn, tableNames)) {\n                 try {\n-                    doExportTable(\n-                            handler, dbSchema, conn, tableName, TABLES_TO_BE_FILTERED.get(tableName.toUpperCase()));\n+                    exportTable(handler, conn, tableName, TABLES_TO_BE_FILTERED.get(tableName.toUpperCase()));\n                 } catch (Exception e) {\n                     LOG.error(\"Failure exporting table {}\", tableName, e);\n                 }"},{"sha":"03a53138001104467c459738a330b80113513be5","filename":"core/persistence-jpa/src/test/java/org/apache/syncope/core/persistence/jpa/outer/XMLContentExporterTest.java","status":"modified","additions":8,"deletions":3,"changes":11,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/761399c46b69b5e27e5ff0e47a7ed5ddb6489f3b/core%2Fpersistence-jpa%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fjpa%2Fouter%2FXMLContentExporterTest.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/761399c46b69b5e27e5ff0e47a7ed5ddb6489f3b/core%2Fpersistence-jpa%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fjpa%2Fouter%2FXMLContentExporterTest.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fpersistence-jpa%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fjpa%2Fouter%2FXMLContentExporterTest.java?ref=761399c46b69b5e27e5ff0e47a7ed5ddb6489f3b","patch":"@@ -39,6 +39,11 @@ public class XMLContentExporterTest extends AbstractTest {\n     @Autowired\n     private ContentExporter exporter;\n \n+    /**\n+     * Also checks for SYNCOPE-1307.\n+     *\n+     * @throws Exception\n+     */\n     @Test\n     public void issueSYNCOPE1128() throws Exception {\n         ByteArrayOutputStream baos = new ByteArrayOutputStream();\n@@ -53,9 +58,9 @@ public void issueSYNCOPE1128() throws Exception {\n                 filter(row -> row.startsWith(\"<REALM\")).collect(Collectors.toList());\n         assertEquals(4, realms.size());\n         assertTrue(realms.get(0).contains(\"NAME=\\\"/\\\"\"));\n-        assertTrue(realms.get(1).contains(\"NAME=\\\"two\\\"\"));\n-        assertTrue(realms.get(2).contains(\"NAME=\\\"odd\\\"\"));\n-        assertTrue(realms.get(3).contains(\"NAME=\\\"even\\\"\"));\n+        assertTrue(realms.get(1).contains(\"NAME=\\\"odd\\\"\"));\n+        assertTrue(realms.get(2).contains(\"NAME=\\\"even\\\"\"));\n+        assertTrue(realms.get(3).contains(\"NAME=\\\"two\\\"\"));\n     }\n \n }"}]}