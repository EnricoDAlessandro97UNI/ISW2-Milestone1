{"sha":"842a0fb9d8a1c8f5a1dd4e5259b56dc8af3cf7a3","node_id":"MDY6Q29tbWl0NjM2ODc5MDYyOjg0MmEwZmI5ZDhhMWM4ZjVhMWRkNGU1MjU5YjU2ZGM4YWYzY2Y3YTM=","commit":{"author":{"name":"Francesco Chicchiriccò","email":"ilgrosso@apache.org","date":"2018-08-16T10:55:12Z"},"committer":{"name":"Francesco Chicchiriccò","email":"ilgrosso@apache.org","date":"2018-08-16T11:26:39Z"},"message":"[SYNCOPE-1356] Enhancing LDAPMembershipPullActions / SetUMembershipsJob with capabilites from 1_2_X","tree":{"sha":"7c5de6b2ff0a97cfeda89c1f8592e92da7c63849","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/git/trees/7c5de6b2ff0a97cfeda89c1f8592e92da7c63849"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/git/commits/842a0fb9d8a1c8f5a1dd4e5259b56dc8af3cf7a3","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/842a0fb9d8a1c8f5a1dd4e5259b56dc8af3cf7a3","html_url":"https://github.com/EnricoDAlessandro97UNI/syncope/commit/842a0fb9d8a1c8f5a1dd4e5259b56dc8af3cf7a3","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/842a0fb9d8a1c8f5a1dd4e5259b56dc8af3cf7a3/comments","author":{"login":"ilgrosso","id":1064664,"node_id":"MDQ6VXNlcjEwNjQ2NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/1064664?v=4","gravatar_id":"","url":"https://api.github.com/users/ilgrosso","html_url":"https://github.com/ilgrosso","followers_url":"https://api.github.com/users/ilgrosso/followers","following_url":"https://api.github.com/users/ilgrosso/following{/other_user}","gists_url":"https://api.github.com/users/ilgrosso/gists{/gist_id}","starred_url":"https://api.github.com/users/ilgrosso/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ilgrosso/subscriptions","organizations_url":"https://api.github.com/users/ilgrosso/orgs","repos_url":"https://api.github.com/users/ilgrosso/repos","events_url":"https://api.github.com/users/ilgrosso/events{/privacy}","received_events_url":"https://api.github.com/users/ilgrosso/received_events","type":"User","site_admin":false},"committer":{"login":"ilgrosso","id":1064664,"node_id":"MDQ6VXNlcjEwNjQ2NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/1064664?v=4","gravatar_id":"","url":"https://api.github.com/users/ilgrosso","html_url":"https://github.com/ilgrosso","followers_url":"https://api.github.com/users/ilgrosso/followers","following_url":"https://api.github.com/users/ilgrosso/following{/other_user}","gists_url":"https://api.github.com/users/ilgrosso/gists{/gist_id}","starred_url":"https://api.github.com/users/ilgrosso/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ilgrosso/subscriptions","organizations_url":"https://api.github.com/users/ilgrosso/orgs","repos_url":"https://api.github.com/users/ilgrosso/repos","events_url":"https://api.github.com/users/ilgrosso/events{/privacy}","received_events_url":"https://api.github.com/users/ilgrosso/received_events","type":"User","site_admin":false},"parents":[{"sha":"ea6054a89245ebbe6c26e4ffbf2744800166e977","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/ea6054a89245ebbe6c26e4ffbf2744800166e977","html_url":"https://github.com/EnricoDAlessandro97UNI/syncope/commit/ea6054a89245ebbe6c26e4ffbf2744800166e977"}],"stats":{"total":187,"additions":132,"deletions":55},"files":[{"sha":"4db06dc596e8efeb66b7cbe8cdf0b9a2d8a0655a","filename":"core/persistence-api/src/main/java/org/apache/syncope/core/persistence/api/dao/GroupDAO.java","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/842a0fb9d8a1c8f5a1dd4e5259b56dc8af3cf7a3/core%2Fpersistence-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fapi%2Fdao%2FGroupDAO.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/842a0fb9d8a1c8f5a1dd4e5259b56dc8af3cf7a3/core%2Fpersistence-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fapi%2Fdao%2FGroupDAO.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fpersistence-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fapi%2Fdao%2FGroupDAO.java?ref=842a0fb9d8a1c8f5a1dd4e5259b56dc8af3cf7a3","patch":"@@ -57,6 +57,7 @@ public interface GroupDAO extends AnyDAO<Group> {\n \n     int countUDynMembers(Group group);\n \n+    @Override\n     Collection<String> findAllResourceKeys(final String key);\n \n     void clearADynMembers(Group group);"},{"sha":"993c99900fef1cbdbe997b03a2c3d229286a7b8a","filename":"core/provisioning-java/src/main/java/org/apache/syncope/core/provisioning/java/job/SetUMembershipsJob.java","status":"modified","additions":51,"deletions":16,"changes":67,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/842a0fb9d8a1c8f5a1dd4e5259b56dc8af3cf7a3/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fjob%2FSetUMembershipsJob.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/842a0fb9d8a1c8f5a1dd4e5259b56dc8af3cf7a3/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fjob%2FSetUMembershipsJob.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fjob%2FSetUMembershipsJob.java?ref=842a0fb9d8a1c8f5a1dd4e5259b56dc8af3cf7a3","patch":"@@ -18,6 +18,8 @@\n  */\n package org.apache.syncope.core.provisioning.java.job;\n \n+import java.util.ArrayList;\n+import java.util.List;\n import java.util.Map;\n import java.util.Set;\n import org.apache.syncope.common.lib.patch.MembershipPatch;\n@@ -40,39 +42,72 @@ public class SetUMembershipsJob extends AbstractInterruptableJob {\n \n     private static final Logger LOG = LoggerFactory.getLogger(SetUMembershipsJob.class);\n \n-    public static final String MEMBERSHIPS_KEY = \"memberships\";\n+    public static final String MEMBERSHIPS_BEFORE_KEY = \"membershipsBefore\";\n+\n+    public static final String MEMBERSHIPS_AFTER_KEY = \"membershipsAfter\";\n \n     @Autowired\n     private UserProvisioningManager userProvisioningManager;\n \n     @Override\n     public void execute(final JobExecutionContext context) throws JobExecutionException {\n         try {\n-            AuthContextUtils.execWithAuthContext(\n-                    context.getMergedJobDataMap().getString(JobManager.DOMAIN_KEY), () -> {\n+            AuthContextUtils.execWithAuthContext(context.getMergedJobDataMap().getString(JobManager.DOMAIN_KEY), () -> {\n+\n+                @SuppressWarnings(\"unchecked\")\n+                Map<String, Set<String>> membershipsBefore =\n+                        (Map<String, Set<String>>) context.getMergedJobDataMap().get(MEMBERSHIPS_BEFORE_KEY);\n+                LOG.debug(\"Memberships before pull (User -> Groups) {}\", membershipsBefore);\n \n                 @SuppressWarnings(\"unchecked\")\n-                Map<String, Set<String>> memberships =\n-                        (Map<String, Set<String>>) context.getMergedJobDataMap().get(MEMBERSHIPS_KEY);\n+                Map<String, Set<String>> membershipsAfter =\n+                        (Map<String, Set<String>>) context.getMergedJobDataMap().get(MEMBERSHIPS_AFTER_KEY);\n+                LOG.debug(\"Memberships after pull (User -> Groups) {}\", membershipsAfter);\n \n-                LOG.debug(\"About to set memberships (User -> Groups) {}\", memberships);\n+                List<UserPatch> patches = new ArrayList<>();\n \n-                memberships.forEach((user, groups) -> {\n+                membershipsAfter.forEach((user, groups) -> {\n                     UserPatch userPatch = new UserPatch();\n                     userPatch.setKey(user);\n+                    patches.add(userPatch);\n \n                     groups.forEach(group -> {\n-                        userPatch.getMemberships().add(\n-                                new MembershipPatch.Builder().\n-                                        operation(PatchOperation.ADD_REPLACE).\n-                                        group(group).\n-                                        build());\n+                        Set<String> before = membershipsBefore.get(user);\n+                        if (before == null || !before.contains(group)) {\n+                            userPatch.getMemberships().add(\n+                                    new MembershipPatch.Builder().\n+                                            operation(PatchOperation.ADD_REPLACE).\n+                                            group(group).\n+                                            build());\n+                        }\n                     });\n+                });\n+\n+                membershipsBefore.forEach((user, groups) -> {\n+                    UserPatch userPatch = patches.stream().\n+                            filter(patch -> user.equals(patch.getKey())).findFirst().\n+                            orElseGet(() -> {\n+                                UserPatch patch = new UserPatch();\n+                                patch.setKey(user);\n+                                patches.add(patch);\n+                                return patch;\n+                            });\n+\n+                    groups.forEach(group -> {\n+                        Set<String> after = membershipsAfter.get(user);\n+                        if (after == null || !after.contains(group)) {\n+                            userPatch.getMemberships().add(\n+                                    new MembershipPatch.Builder().\n+                                            operation(PatchOperation.DELETE).\n+                                            group(group).\n+                                            build());\n+                        }\n+                    });\n+                });\n \n-                    if (!userPatch.isEmpty()) {\n-                        LOG.debug(\"About to update User {}\", userPatch.getKey());\n-                        userProvisioningManager.update(userPatch, true);\n-                    }\n+                patches.stream().filter(patch -> !patch.isEmpty()).forEach(patch -> {\n+                    LOG.debug(\"About to update User {}\", patch);\n+                    userProvisioningManager.update(patch, true);\n                 });\n \n                 return null;"},{"sha":"cdb5e1e4b6cf115742c42d23e23d4f6eac4db52e","filename":"core/provisioning-java/src/main/java/org/apache/syncope/core/provisioning/java/pushpull/LDAPMembershipPullActions.java","status":"modified","additions":43,"deletions":31,"changes":74,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/842a0fb9d8a1c8f5a1dd4e5259b56dc8af3cf7a3/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FLDAPMembershipPullActions.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/842a0fb9d8a1c8f5a1dd4e5259b56dc8af3cf7a3/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FLDAPMembershipPullActions.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FLDAPMembershipPullActions.java?ref=842a0fb9d8a1c8f5a1dd4e5259b56dc8af3cf7a3","patch":"@@ -25,6 +25,7 @@\n import java.util.Map;\n import java.util.Optional;\n import java.util.Set;\n+import org.apache.syncope.common.lib.patch.AnyPatch;\n import org.apache.syncope.common.lib.to.EntityTO;\n import org.apache.syncope.common.lib.to.GroupTO;\n import org.apache.syncope.common.lib.types.ConnConfProperty;\n@@ -33,7 +34,6 @@\n import org.apache.syncope.core.provisioning.api.pushpull.ProvisioningProfile;\n import org.apache.syncope.core.provisioning.api.pushpull.ProvisioningReport;\n import org.apache.syncope.core.persistence.api.dao.AnyTypeDAO;\n-import org.apache.syncope.core.persistence.api.dao.UserDAO;\n import org.apache.syncope.core.persistence.api.entity.resource.Provision;\n import org.identityconnectors.framework.common.objects.Attribute;\n import org.identityconnectors.framework.common.objects.ConnectorObject;\n@@ -45,6 +45,7 @@\n import org.slf4j.LoggerFactory;\n import org.springframework.beans.factory.annotation.Autowired;\n import org.apache.syncope.core.provisioning.java.job.SetUMembershipsJob;\n+import org.springframework.transaction.annotation.Transactional;\n \n /**\n  * Simple action for pulling LDAP groups memberships to Syncope group memberships, when the same resource is\n@@ -59,16 +60,15 @@ public class LDAPMembershipPullActions extends SchedulingPullActions {\n     @Autowired\n     protected AnyTypeDAO anyTypeDAO;\n \n-    @Autowired\n-    protected UserDAO userDAO;\n-\n     @Autowired\n     protected GroupDAO groupDAO;\n \n     @Autowired\n     private PullUtils pullUtils;\n \n-    protected final Map<String, Set<String>> memberships = new HashMap<>();\n+    protected final Map<String, Set<String>> membershipsBefore = new HashMap<>();\n+\n+    protected final Map<String, Set<String>> membershipsAfter = new HashMap<>();\n \n     /**\n      * Allows easy subclassing for the ConnId AD connector bundle.\n@@ -118,29 +118,39 @@ protected List<Object> getMembAttrValues(final SyncDelta delta, final Connector\n     }\n \n     /**\n-     * Pull Syncope memberships with the situation read on the external resource's group.\n+     * Keep track of members of the group being updated before actual update takes place.\n+     * This is not needed on\n+     * <ul>\n+     * <li>{@link #beforeProvision} because the pulling group does not exist yet on Syncope</li>\n+     * <li>{@link #beforeDelete} because group delete cascades as membership removal for all users involved</li>\n+     * </ul>\n      *\n-     * @param profile pull profile\n-     * @param delta representing the pullong group\n-     * @param groupTO group after modification performed by the handler\n-     * @throws JobExecutionException if anything goes wrong\n+     * {@inheritDoc}\n      */\n-    protected void populateMemberships(\n-            final ProvisioningProfile<?, ?> profile, final SyncDelta delta, final GroupTO groupTO)\n-            throws JobExecutionException {\n+    @Transactional(readOnly = true)\n+    @Override\n+    public <P extends AnyPatch> void beforeUpdate(\n+            final ProvisioningProfile<?, ?> profile,\n+            final SyncDelta delta,\n+            final EntityTO entity,\n+            final P anyPatch) throws JobExecutionException {\n \n-        getMembAttrValues(delta, profile.getConnector()).forEach(membValue -> {\n-            Set<String> memb = memberships.get(membValue.toString());\n+        if (!(entity instanceof GroupTO)) {\n+            super.beforeUpdate(profile, delta, entity, anyPatch);\n+        }\n+\n+        groupDAO.findUMemberships(groupDAO.find(entity.getKey())).forEach(uMembership -> {\n+            Set<String> memb = membershipsBefore.get(uMembership.getLeftEnd().getKey());\n             if (memb == null) {\n                 memb = new HashSet<>();\n-                memberships.put(membValue.toString(), memb);\n+                membershipsBefore.put(uMembership.getLeftEnd().getKey(), memb);\n             }\n-            memb.add(groupTO.getKey());\n+            memb.add(entity.getKey());\n         });\n     }\n \n     /**\n-     * Pull membership at group pull time (because PullJob first pulls users then groups).\n+     * Keep track of members of the group being updated after actual update took place.\n      * {@inheritDoc}\n      */\n     @Override\n@@ -156,33 +166,35 @@ public void after(\n \n         Optional<? extends Provision> provision = profile.getTask().getResource().getProvision(anyTypeDAO.findUser()).\n                 filter(p -> p.getMapping() != null);\n-        if (provision.isPresent()) {\n-            populateMemberships(profile, delta, (GroupTO) entity);\n-        } else {\n+        if (!provision.isPresent()) {\n             super.after(profile, delta, entity, result);\n         }\n-    }\n-\n-    @Override\n-    public void afterAll(final ProvisioningProfile<?, ?> profile) throws JobExecutionException {\n-        Map<String, Set<String>> resolvedMemberships = new HashMap<>();\n \n-        memberships.forEach((name, memb) -> {\n+        getMembAttrValues(delta, profile.getConnector()).forEach(membValue -> {\n             Optional<String> userKey = pullUtils.match(\n                     anyTypeDAO.findUser(),\n-                    name,\n+                    membValue.toString(),\n                     profile.getTask().getResource(),\n                     profile.getConnector(),\n                     false);\n             if (userKey.isPresent()) {\n-                resolvedMemberships.put(userKey.get(), memb);\n+                Set<String> memb = membershipsAfter.get(userKey.get());\n+                if (memb == null) {\n+                    memb = new HashSet<>();\n+                    membershipsAfter.put(userKey.get(), memb);\n+                }\n+                memb.add(entity.getKey());\n             } else {\n-                LOG.warn(\"Could not find matching user for {}\", name);\n+                LOG.warn(\"Could not find matching user for {}\", membValue);\n             }\n         });\n+    }\n \n+    @Override\n+    public void afterAll(final ProvisioningProfile<?, ?> profile) throws JobExecutionException {\n         Map<String, Object> jobMap = new HashMap<>();\n-        jobMap.put(SetUMembershipsJob.MEMBERSHIPS_KEY, resolvedMemberships);\n+        jobMap.put(SetUMembershipsJob.MEMBERSHIPS_BEFORE_KEY, membershipsBefore);\n+        jobMap.put(SetUMembershipsJob.MEMBERSHIPS_AFTER_KEY, membershipsAfter);\n         schedule(SetUMembershipsJob.class, jobMap);\n     }\n }"},{"sha":"2dc671beb787711d77a4aa26a28167e5b38c8e06","filename":"fit/core-reference/src/test/java/org/apache/syncope/fit/core/PullTaskITCase.java","status":"modified","additions":37,"deletions":8,"changes":45,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/842a0fb9d8a1c8f5a1dd4e5259b56dc8af3cf7a3/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FPullTaskITCase.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/842a0fb9d8a1c8f5a1dd4e5259b56dc8af3cf7a3/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FPullTaskITCase.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FPullTaskITCase.java?ref=842a0fb9d8a1c8f5a1dd4e5259b56dc8af3cf7a3","patch":"@@ -406,19 +406,18 @@ public void reconcileFromLDAP() {\n         assertEquals(matchingUsers.getResult().iterator().next().getKey(), groupTO.getUserOwner());\n         assertNull(groupTO.getGroupOwner());\n         // SYNCOPE-1343, set value title to null on LDAP\n-        ConnObjectTO connObject =\n-                resourceService.readConnObject(RESOURCE_NAME_LDAP, AnyTypeKind.USER.name(),\n-                        matchingUsers.getResult().get(0).getKey());\n-        assertNotNull(connObject);\n-        assertEquals(\"odd\", connObject.getAttr(\"title\").get().getValues().get(0));\n-        AttrTO userDn = connObject.getAttr(Name.NAME).get();\n+        ConnObjectTO userConnObject = resourceService.readConnObject(\n+                RESOURCE_NAME_LDAP, AnyTypeKind.USER.name(), matchingUsers.getResult().get(0).getKey());\n+        assertNotNull(userConnObject);\n+        assertEquals(\"odd\", userConnObject.getAttr(\"title\").get().getValues().get(0));\n+        AttrTO userDn = userConnObject.getAttr(Name.NAME).get();\n         updateLdapRemoteObject(RESOURCE_LDAP_ADMIN_DN, RESOURCE_LDAP_ADMIN_PWD,\n                 userDn.getValues().get(0), Collections.singletonMap(\"title\", (String) null));\n \n         // SYNCOPE-317\n         execProvisioningTask(taskService, TaskType.PULL, \"1e419ca4-ea81-4493-a14f-28b90113686d\", 50, false);\n \n-        // 4. verify that LDAP group membership is propagated as Syncope membership\n+        // 4. verify that LDAP group membership is pulled as Syncope membership\n         int i = 0;\n         int maxit = 50;\n         PagedResult<UserTO> members;\n@@ -440,13 +439,43 @@ public void reconcileFromLDAP() {\n         }\n         assertEquals(1, members.getResult().size());\n \n-        // SYNCOPE-1343, verify that the title attribte has been reset\n+        // SYNCOPE-1343, verify that the title attribute has been reset\n         matchingUsers = userService.search(\n                 new AnyQuery.Builder().realm(SyncopeConstants.ROOT_REALM).\n                         fiql(SyncopeClient.getUserSearchConditionBuilder().is(\"username\").equalTo(\"pullFromLDAP\").\n                                 query()).\n                         build());\n         assertNull(matchingUsers.getResult().get(0).getPlainAttr(\"title\").orElse(null));\n+        \n+        // SYNCOPE-1356 remove group membership from LDAP, pull and check in Syncope\n+        ConnObjectTO groupConnObject = resourceService.readConnObject(\n+                RESOURCE_NAME_LDAP, AnyTypeKind.GROUP.name(), matchingGroups.getResult().get(0).getKey());\n+        assertNotNull(groupConnObject);\n+        AttrTO groupDn = groupConnObject.getAttr(Name.NAME).get();\n+        updateLdapRemoteObject(RESOURCE_LDAP_ADMIN_DN, RESOURCE_LDAP_ADMIN_PWD,\n+                groupDn.getValues().get(0), Collections.singletonMap(\"uniquemember\", \"uid=admin,ou=system\"));\n+\n+        execProvisioningTask(taskService, TaskType.PULL, \"1e419ca4-ea81-4493-a14f-28b90113686d\", 50, false);\n+\n+        i = 0;\n+        maxit = 50;\n+        do {\n+            try {\n+                Thread.sleep(1000);\n+            } catch (InterruptedException e) {\n+            }\n+\n+            members = userService.search(new AnyQuery.Builder().realm(SyncopeConstants.ROOT_REALM).\n+                    fiql(SyncopeClient.getUserSearchConditionBuilder().inGroups(groupTO.getKey()).query()).\n+                    build());\n+            assertNotNull(members);\n+\n+            i++;\n+        } while (!members.getResult().isEmpty() && i < maxit);\n+        if (i == maxit) {\n+            fail(\"Timeout while checking for memberships of \" + groupTO.getName());\n+        }\n+        assertEquals(0, members.getResult().size());\n     }\n \n     @Test"}]}