{"sha":"0651c1715d30aff0f189567e6be6b6670cc6918c","node_id":"MDY6Q29tbWl0NjM2ODc5MDYyOjA2NTFjMTcxNWQzMGFmZjBmMTg5NTY3ZTZiZTZiNjY3MGNjNjkxOGM=","commit":{"author":{"name":"Unknown","email":"unknown@apache.org","date":"2011-11-28T16:04:36Z"},"committer":{"name":"Unknown","email":"unknown@apache.org","date":"2011-11-28T16:04:36Z"},"message":"Updating Quartz approach as per http://blog.tirasa.net/blogs/index.php/ilgrosso/finally-spring-quartz-and-jpa\n\ngit-svn-id: https://svn.apache.org/repos/asf/incubator/syncope/trunk@1247219 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"48e968495b7bb83b70ab40971d37142824f4635e","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/git/trees/48e968495b7bb83b70ab40971d37142824f4635e"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/git/commits/0651c1715d30aff0f189567e6be6b6670cc6918c","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/0651c1715d30aff0f189567e6be6b6670cc6918c","html_url":"https://github.com/EnricoDAlessandro97UNI/syncope/commit/0651c1715d30aff0f189567e6be6b6670cc6918c","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/0651c1715d30aff0f189567e6be6b6670cc6918c/comments","author":null,"committer":null,"parents":[{"sha":"83072f7a86c92fcaa1a28642c5b5a792493e1003","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/83072f7a86c92fcaa1a28642c5b5a792493e1003","html_url":"https://github.com/EnricoDAlessandro97UNI/syncope/commit/83072f7a86c92fcaa1a28642c5b5a792493e1003"}],"stats":{"total":771,"additions":271,"deletions":500},"files":[{"sha":"cb7980ac51f4d215c425a51c76eb90affec8abc7","filename":"core/src/main/java/org/syncope/core/init/JobInstanceLoader.java","status":"modified","additions":29,"deletions":66,"changes":95,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/0651c1715d30aff0f189567e6be6b6670cc6918c/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Finit%2FJobInstanceLoader.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/0651c1715d30aff0f189567e6be6b6670cc6918c/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Finit%2FJobInstanceLoader.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Finit%2FJobInstanceLoader.java?ref=0651c1715d30aff0f189567e6be6b6670cc6918c","patch":"@@ -15,30 +15,27 @@\n \n import java.util.List;\n import org.apache.commons.lang.StringUtils;\n+import org.quartz.Job;\n import org.quartz.JobDetail;\n import org.quartz.Scheduler;\n import org.quartz.SchedulerException;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n-import org.springframework.aop.framework.ProxyFactoryBean;\n-import org.springframework.beans.MutablePropertyValues;\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.beans.factory.support.AbstractBeanDefinition;\n-import org.springframework.beans.factory.support.GenericBeanDefinition;\n-import org.springframework.context.ConfigurableApplicationContext;\n import org.springframework.scheduling.quartz.CronTriggerBean;\n+import org.springframework.scheduling.quartz.JobDetailBean;\n import org.springframework.scheduling.quartz.SchedulerFactoryBean;\n import org.springframework.stereotype.Component;\n import org.springframework.transaction.annotation.Transactional;\n import org.syncope.core.persistence.beans.SchedTask;\n import org.syncope.core.persistence.beans.SyncTask;\n import org.syncope.core.persistence.dao.TaskDAO;\n-import org.syncope.core.scheduling.AppContextMethodInvokingJobDetailFactoryBean;\n+import org.syncope.core.scheduling.AbstractJob;\n import org.syncope.core.scheduling.DefaultSyncJobActions;\n-import org.syncope.core.scheduling.Job;\n import org.syncope.core.scheduling.NotificationJob;\n import org.syncope.core.scheduling.SyncJob;\n-import org.syncope.core.util.ApplicationContextManager;\n+import org.syncope.core.scheduling.SyncJobActions;\n \n @Component\n public class JobInstanceLoader extends AbstractLoader {\n@@ -56,32 +53,25 @@ public static String getJobName(final Long taskId) {\n         return \"job\" + taskId;\n     }\n \n-    public static String getJobProxyName(final Long taskId) {\n-        return \"jobProxy\" + taskId;\n-    }\n-\n-    public static String getJobDetailName(final Long taskId) {\n-        return \"jobDetail\" + taskId;\n-    }\n-\n     public static String getTriggerName(final Long taskId) {\n-        return \"Trigger_\" + getJobDetailName(taskId);\n+        return \"Trigger_\" + getJobName(taskId);\n     }\n \n     public void registerJob(final Long taskId, final String jobClassName,\n             final String cronExpression)\n             throws Exception {\n \n+        // 0. unregister job\n         unregisterJob(taskId);\n \n-        ConfigurableApplicationContext ctx =\n-                ApplicationContextManager.getApplicationContext();\n-\n-        MutablePropertyValues mpv = new MutablePropertyValues();\n-        if (!NotificationJob.class.getName().equals(jobClassName)) {\n-            mpv.add(\"taskId\", taskId);\n+        // 1. Job bean\n+        Class jobClass = Class.forName(jobClassName);\n+        Job jobInstance = (Job) getBeanFactory().autowire(jobClass,\n+                AbstractBeanDefinition.AUTOWIRE_BY_TYPE, false);\n+        if (jobInstance instanceof AbstractJob) {\n+            ((AbstractJob) jobInstance).setTaskId(taskId);\n         }\n-        if (SyncJob.class.getName().equals(jobClassName)) {\n+        if (jobInstance instanceof SyncJob) {\n             String jobActionsClassName =\n                     ((SyncTask) taskDAO.find(taskId)).getJobActionsClassName();\n             Class syncJobActionsClass = DefaultSyncJobActions.class;\n@@ -94,42 +84,22 @@ public void registerJob(final Long taskId, final String jobClassName,\n                                 syncJobActionsClass.getName(), t});\n                 }\n             }\n-            Object syncJobActions = getBeanFactory().autowire(\n+            SyncJobActions syncJobActions =\n+                    (SyncJobActions) getBeanFactory().autowire(\n                     syncJobActionsClass,\n                     AbstractBeanDefinition.AUTOWIRE_BY_TYPE, true);\n-            mpv.add(\"actions\", syncJobActions);\n+\n+            ((SyncJob) jobInstance).setActions(syncJobActions);\n         }\n-        GenericBeanDefinition bd = new GenericBeanDefinition();\n-        bd.setBeanClassName(jobClassName);\n-        bd.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE);\n-        bd.setPropertyValues(mpv);\n-        getBeanFactory().registerBeanDefinition(getJobName(taskId), bd);\n-\n-        mpv = new MutablePropertyValues();\n-        mpv.add(\"target\", ctx.getBean(getJobName(taskId)));\n-        mpv.add(\"proxyInterfaces\", Job.class.getName());\n-        mpv.add(\"interceptorNames\", \"jpaInterceptor\");\n-        bd = new GenericBeanDefinition();\n-        bd.setBeanClass(ProxyFactoryBean.class);\n-        bd.setPropertyValues(mpv);\n-        getBeanFactory().registerBeanDefinition(\n-                getJobProxyName(taskId), bd);\n-\n-        AppContextMethodInvokingJobDetailFactoryBean jobDetailFactory =\n-                (AppContextMethodInvokingJobDetailFactoryBean) getBeanFactory().\n-                autowire(AppContextMethodInvokingJobDetailFactoryBean.class,\n-                AbstractBeanDefinition.AUTOWIRE_BY_TYPE, true);\n-        jobDetailFactory.setTargetBeanName(getJobProxyName(taskId));\n-        jobDetailFactory.setTargetMethod(\"execute\");\n-        jobDetailFactory.afterPropertiesSet();\n-        getBeanFactory().registerSingleton(getJobDetailName(taskId),\n-                jobDetailFactory);\n-\n-        JobDetail jobDetail = (JobDetail) ctx.getBean(\n-                getJobDetailName(taskId));\n-        jobDetail.setName(getJobDetailName(taskId));\n+        getBeanFactory().registerSingleton(getJobName(taskId), jobInstance);\n+\n+        // 2. JobDetail bean\n+        JobDetail jobDetail = new JobDetailBean();\n+        jobDetail.setName(getJobName(taskId));\n         jobDetail.setGroup(Scheduler.DEFAULT_GROUP);\n+        jobDetail.setJobClass(jobClass);\n \n+        // 3. Trigger\n         if (cronExpression == null) {\n             scheduler.getScheduler().addJob(jobDetail, true);\n         } else {\n@@ -144,22 +114,15 @@ public void registerJob(final Long taskId, final String jobClassName,\n     public void unregisterJob(final Long taskId) {\n         try {\n             scheduler.getScheduler().unscheduleJob(\n-                    getJobDetailName(taskId), Scheduler.DEFAULT_GROUP);\n+                    getJobName(taskId), Scheduler.DEFAULT_GROUP);\n             scheduler.getScheduler().deleteJob(\n-                    getJobDetailName(taskId), Scheduler.DEFAULT_GROUP);\n+                    getJobName(taskId), Scheduler.DEFAULT_GROUP);\n         } catch (SchedulerException e) {\n-            LOG.error(\"Could not remove job \" + getJobDetailName(taskId), e);\n+            LOG.error(\"Could not remove job \" + getJobName(taskId), e);\n         }\n \n-        if (getBeanFactory().containsSingleton(getJobDetailName(taskId))) {\n-            getBeanFactory().destroySingleton(getJobDetailName(taskId));\n-        }\n-        if (getBeanFactory().containsBeanDefinition(getJobProxyName(taskId))) {\n-\n-            getBeanFactory().removeBeanDefinition(getJobProxyName(taskId));\n-        }\n-        if (getBeanFactory().containsBeanDefinition(getJobName(taskId))) {\n-            getBeanFactory().removeBeanDefinition(getJobName(taskId));\n+        if (getBeanFactory().containsSingleton(getJobName(taskId))) {\n+            getBeanFactory().destroySingleton(getJobName(taskId));\n         }\n     }\n "},{"sha":"00e0dace04b3ed604b1d33bdde3d8c49acfc9e45","filename":"core/src/main/java/org/syncope/core/persistence/beans/ExternalResource.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/0651c1715d30aff0f189567e6be6b6670cc6918c/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Fpersistence%2Fbeans%2FExternalResource.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/0651c1715d30aff0f189567e6be6b6670cc6918c/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Fpersistence%2Fbeans%2FExternalResource.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Fpersistence%2Fbeans%2FExternalResource.java?ref=0651c1715d30aff0f189567e6be6b6670cc6918c","patch":"@@ -93,8 +93,8 @@ public class ExternalResource extends AbstractBaseBean {\n     /**\n      * Attribute mappings.\n      */\n-    @OneToMany(cascade = CascadeType.MERGE, orphanRemoval = true,\n-    mappedBy = \"resource\")\n+    @OneToMany(cascade = {CascadeType.MERGE, CascadeType.REMOVE},\n+    orphanRemoval = true, fetch = FetchType.EAGER, mappedBy = \"resource\")\n     @Valid\n     private List<SchemaMapping> mappings;\n "},{"sha":"b63286716322264758530aff64a56086a2511e4a","filename":"core/src/main/java/org/syncope/core/persistence/dao/ResourceDAO.java","status":"modified","additions":0,"deletions":2,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/0651c1715d30aff0f189567e6be6b6670cc6918c/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2FResourceDAO.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/0651c1715d30aff0f189567e6be6b6670cc6918c/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2FResourceDAO.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2FResourceDAO.java?ref=0651c1715d30aff0f189567e6be6b6670cc6918c","patch":"@@ -37,7 +37,5 @@ ExternalResource save(ExternalResource resource)\n \n     void deleteMappings(String schemaName, IntMappingType intMappingType);\n \n-    void deleteAllMappings(ExternalResource resource);\n-\n     void delete(String name);\n }"},{"sha":"b911eae1a9451be174fba71e24cb69243147de17","filename":"core/src/main/java/org/syncope/core/persistence/dao/impl/ResourceDAOImpl.java","status":"modified","additions":0,"deletions":19,"changes":19,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/0651c1715d30aff0f189567e6be6b6670cc6918c/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2Fimpl%2FResourceDAOImpl.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/0651c1715d30aff0f189567e6be6b6670cc6918c/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2Fimpl%2FResourceDAOImpl.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2Fimpl%2FResourceDAOImpl.java?ref=0651c1715d30aff0f189567e6be6b6670cc6918c","patch":"@@ -135,32 +135,13 @@ public void deleteMappings(final String intAttrName,\n                 evict(SchemaMapping.class);\n     }\n \n-    @Override\n-    public void deleteAllMappings(final ExternalResource resource) {\n-        Query query = entityManager.createQuery(\"DELETE FROM \"\n-                + SchemaMapping.class.getSimpleName()\n-                + \" m WHERE m.resource=:resource\");\n-        query.setParameter(\"resource\", resource);\n-\n-        int items = query.executeUpdate();\n-        LOG.debug(\"Removed {} schema mappings\", items);\n-\n-        resource.getMappings().clear();\n-\n-        // Make empty SchemaMapping query cache\n-        entityManager.getEntityManagerFactory().getCache().\n-                evict(SchemaMapping.class);\n-    }\n-\n     @Override\n     public void delete(final String name) {\n         ExternalResource resource = find(name);\n         if (resource == null) {\n             return;\n         }\n \n-        deleteAllMappings(resource);\n-\n         taskDAO.deleteAll(resource, PropagationTask.class);\n         taskDAO.deleteAll(resource, SyncTask.class);\n "},{"sha":"e53de9662f4d3e0bef394929ca7d0745af32c1b8","filename":"core/src/main/java/org/syncope/core/rest/controller/ResourceController.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/0651c1715d30aff0f189567e6be6b6670cc6918c/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Frest%2Fcontroller%2FResourceController.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/0651c1715d30aff0f189567e6be6b6670cc6918c/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Frest%2Fcontroller%2FResourceController.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Frest%2Fcontroller%2FResourceController.java?ref=0651c1715d30aff0f189567e6be6b6670cc6918c","patch":"@@ -127,7 +127,7 @@ public ResourceTO update(final HttpServletResponse response,\n \n         LOG.debug(\"Removing old mappings ..\");\n         // remove old mappings\n-        resourceDAO.deleteAllMappings(resource);\n+        resource.getMappings().clear();\n \n         resource = binder.getResource(resource, resourceTO);\n         if (resource == null) {"},{"sha":"e3fe542a051ddf668a7649ba87e55237d673ac38","filename":"core/src/main/java/org/syncope/core/rest/controller/TaskController.java","status":"modified","additions":15,"deletions":13,"changes":28,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/0651c1715d30aff0f189567e6be6b6670cc6918c/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Frest%2Fcontroller%2FTaskController.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/0651c1715d30aff0f189567e6be6b6670cc6918c/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Frest%2Fcontroller%2FTaskController.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Frest%2Fcontroller%2FTaskController.java?ref=0651c1715d30aff0f189567e6be6b6670cc6918c","patch":"@@ -22,10 +22,9 @@\n import java.util.Set;\n import javassist.NotFoundException;\n import javax.servlet.http.HttpServletResponse;\n+import org.quartz.Job;\n import org.quartz.JobDataMap;\n-import org.quartz.JobDetail;\n import org.quartz.Scheduler;\n-import org.quartz.SchedulerException;\n import org.reflections.Reflections;\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.http.HttpStatus;\n@@ -55,13 +54,12 @@\n import org.syncope.core.persistence.dao.TaskExecDAO;\n import org.syncope.core.propagation.PropagationManager;\n import org.syncope.core.rest.data.TaskDataBinder;\n-import org.syncope.core.scheduling.Job;\n import org.syncope.core.scheduling.NotificationJob;\n import org.syncope.core.scheduling.SyncJob;\n-import org.syncope.core.util.ApplicationContextManager;\n import org.syncope.core.util.TaskUtil;\n import org.syncope.types.PropagationMode;\n import org.syncope.core.propagation.PropagationTaskExecStatus;\n+import org.syncope.core.scheduling.AbstractJob;\n import org.syncope.core.scheduling.SyncJobActions;\n import org.syncope.types.SyncopeClientExceptionType;\n \n@@ -347,19 +345,17 @@ public TaskExecTO execute(@PathVariable(\"taskId\") final Long taskId,\n \n             case SCHED:\n             case SYNC:\n-                JobDetail jobDetail = (JobDetail) ApplicationContextManager.\n-                        getApplicationContext().getBean(\n-                        JobInstanceLoader.getJobDetailName(task.getId()));\n-                jobDetail.setName(\n-                        JobInstanceLoader.getJobDetailName(task.getId()));\n-                jobDetail.setGroup(Scheduler.DEFAULT_GROUP);\n                 try {\n+                    jobInstanceLoader.registerJob(task.getId(),\n+                            ((SchedTask) task).getJobClassName(),\n+                            ((SchedTask) task).getCronExpression());\n+\n                     JobDataMap map = new JobDataMap();\n-                    map.put(Job.DRY_RUN_JOBDETAIL_KEY, dryRun);\n+                    map.put(AbstractJob.DRY_RUN_JOBDETAIL_KEY, dryRun);\n                     scheduler.getScheduler().triggerJob(\n-                            JobInstanceLoader.getJobDetailName(task.getId()),\n+                            JobInstanceLoader.getJobName(task.getId()),\n                             Scheduler.DEFAULT_GROUP, map);\n-                } catch (SchedulerException e) {\n+                } catch (Exception e) {\n                     LOG.error(\"While executing task {}\", task, e);\n \n                     SyncopeClientCompositeErrorException scce =\n@@ -457,6 +453,12 @@ public void delete(@PathVariable(\"taskId\") Long taskId)\n             throw new NotFoundException(\"Task \" + taskId);\n         }\n \n+        if (TaskUtil.SCHED == getTaskUtil(task)\n+                || TaskUtil.SYNC == getTaskUtil(task)) {\n+\n+            jobInstanceLoader.unregisterJob(taskId);\n+        }\n+\n         taskDAO.delete(task);\n     }\n "},{"sha":"e73f2a546bbe3d66c2f02e3135431f73d7a14d21","filename":"core/src/main/java/org/syncope/core/rest/controller/UserController.java","status":"modified","additions":2,"deletions":7,"changes":9,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/0651c1715d30aff0f189567e6be6b6670cc6918c/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Frest%2Fcontroller%2FUserController.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/0651c1715d30aff0f189567e6be6b6670cc6918c/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Frest%2Fcontroller%2FUserController.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Frest%2Fcontroller%2FUserController.java?ref=0651c1715d30aff0f189567e6be6b6670cc6918c","patch":"@@ -95,13 +95,8 @@ public ModelAndView verifyPassword(@PathVariable(\"userId\") Long userId,\n             @RequestParam(\"password\") final String password)\n             throws NotFoundException, UnauthorizedRoleException {\n \n-        SyncopeUser user = dataBinder.getUserFromId(userId);\n-\n-        SyncopeUser passwordUser = new SyncopeUser();\n-        passwordUser.setPassword(password, user.getCipherAlgoritm(), 0);\n-\n-        return new ModelAndView().addObject(user.getPassword().\n-                equalsIgnoreCase(passwordUser.getPassword()));\n+        return new ModelAndView().addObject(\n+                dataBinder.verifyPassword(userId, password));\n     }\n \n     @PreAuthorize(\"hasRole('USER_LIST')\")"},{"sha":"cec3c311382983b50067cd55d1f179e9f0123dbc","filename":"core/src/main/java/org/syncope/core/rest/data/UserDataBinder.java","status":"modified","additions":13,"deletions":0,"changes":13,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/0651c1715d30aff0f189567e6be6b6670cc6918c/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Frest%2Fdata%2FUserDataBinder.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/0651c1715d30aff0f189567e6be6b6670cc6918c/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Frest%2Fdata%2FUserDataBinder.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Frest%2Fdata%2FUserDataBinder.java?ref=0651c1715d30aff0f189567e6be6b6670cc6918c","patch":"@@ -86,6 +86,19 @@ public SyncopeUser getUserFromId(final Long userId)\n         return user;\n     }\n \n+    @Transactional(readOnly = true)\n+    public boolean verifyPassword(final Long userId, final String password)\n+            throws NotFoundException, UnauthorizedRoleException {\n+\n+        SyncopeUser user = getUserFromId(userId);\n+\n+        SyncopeUser passwordUser = new SyncopeUser();\n+        passwordUser.setPassword(password, user.getCipherAlgoritm(), 0);\n+\n+        return user.getPassword().\n+                equalsIgnoreCase(passwordUser.getPassword());\n+    }\n+\n     @Transactional(readOnly = true)\n     public SyncopeUser getUserFromUsername(final String username)\n             throws NotFoundException, UnauthorizedRoleException {"},{"sha":"f05b9c37f92802a39d8755a719ea58edd09a46c5","filename":"core/src/main/java/org/syncope/core/scheduling/AbstractJob.java","status":"modified","additions":5,"deletions":2,"changes":7,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/0651c1715d30aff0f189567e6be6b6670cc6918c/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Fscheduling%2FAbstractJob.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/0651c1715d30aff0f189567e6be6b6670cc6918c/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Fscheduling%2FAbstractJob.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Fscheduling%2FAbstractJob.java?ref=0651c1715d30aff0f189567e6be6b6670cc6918c","patch":"@@ -18,6 +18,7 @@\n import java.util.Date;\n import org.quartz.JobExecutionContext;\n import org.quartz.JobExecutionException;\n+import org.quartz.StatefulJob;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.springframework.beans.factory.annotation.Autowired;\n@@ -31,7 +32,9 @@\n  * job execution and provides some background settings (like as the\n  * corresponding Task, for example).\n  */\n-public abstract class AbstractJob implements Job {\n+public abstract class AbstractJob implements StatefulJob {\n+\n+    public static final String DRY_RUN_JOBDETAIL_KEY = \"dryRun\";\n \n     /**\n      * Task execution status.\n@@ -96,7 +99,7 @@ public final void execute(final JobExecutionContext context)\n         try {\n             execution.setMessage(doExecute(\n                     context.getMergedJobDataMap().\n-                    getBoolean(Job.DRY_RUN_JOBDETAIL_KEY)));\n+                    getBoolean(DRY_RUN_JOBDETAIL_KEY)));\n \n             execution.setStatus(Status.SUCCESS.name());\n         } catch (JobExecutionException e) {"},{"sha":"b0d95cdfdfc913d1253c620edaee9068287c10bb","filename":"core/src/main/java/org/syncope/core/scheduling/AppContextMethodInvokingJobDetailFactoryBean.java","status":"removed","additions":0,"deletions":259,"changes":259,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/83072f7a86c92fcaa1a28642c5b5a792493e1003/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Fscheduling%2FAppContextMethodInvokingJobDetailFactoryBean.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/83072f7a86c92fcaa1a28642c5b5a792493e1003/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Fscheduling%2FAppContextMethodInvokingJobDetailFactoryBean.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Fscheduling%2FAppContextMethodInvokingJobDetailFactoryBean.java?ref=83072f7a86c92fcaa1a28642c5b5a792493e1003","patch":"@@ -1,259 +0,0 @@\n-/*\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.syncope.core.scheduling;\n-\n-import java.io.Serializable;\n-import java.lang.reflect.InvocationTargetException;\n-import java.util.Calendar;\n-import org.apache.commons.lang.StringUtils;\n-import org.quartz.JobDetail;\n-import org.quartz.JobExecutionContext;\n-import org.quartz.JobExecutionException;\n-import org.quartz.Scheduler;\n-import org.quartz.StatefulJob;\n-import org.springframework.beans.factory.BeanClassLoaderAware;\n-import org.springframework.beans.factory.BeanFactory;\n-import org.springframework.beans.factory.BeanFactoryAware;\n-import org.springframework.beans.factory.BeanNameAware;\n-import org.springframework.beans.factory.FactoryBean;\n-import org.springframework.beans.factory.InitializingBean;\n-import org.springframework.context.ConfigurableApplicationContext;\n-import org.springframework.scheduling.quartz.JobMethodInvocationFailedException;\n-import org.springframework.scheduling.quartz.QuartzJobBean;\n-import org.springframework.util.MethodInvoker;\n-import org.syncope.core.util.ApplicationContextManager;\n-\n-/**\n- * Inspired by Spring's MethodInvokingJobDetailFactoryBean: the main difference\n- * is about the MethodInvoker instance that is created at each execution of the\n- * JobDetail.\n- *\n- * @see org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean\n- */\n-public class AppContextMethodInvokingJobDetailFactoryBean\n-        implements FactoryBean<JobDetail>, BeanNameAware, BeanClassLoaderAware,\n-        BeanFactoryAware, InitializingBean, Serializable {\n-\n-    /**\n-     * Serial version UID.\n-     */\n-    private static final long serialVersionUID = -9164669094205867738L;\n-\n-    /**\n-     * Scheduler group name (defaults to org.quartz.Scheduler#DEFAULT_GROUP).\n-     */\n-    private String group = Scheduler.DEFAULT_GROUP;\n-\n-    /**\n-     * Bean name.\n-     */\n-    private String beanName;\n-\n-    /**\n-     * Job listener names.\n-     */\n-    private String[] jobListenerNames;\n-\n-    /**\n-     * Job detail.\n-     */\n-    private JobDetail jobDetail;\n-\n-    /**\n-     * Target bean name.\n-     */\n-    private String targetBeanName;\n-\n-    /**\n-     * Target method name.\n-     */\n-    private String targetMethod;\n-\n-    /**\n-     * Set the group of the job.\n-     * Default is the default group of the Scheduler.\n-     *\n-     * @param group to be set\n-     * @see org.quartz.JobDetail#setGroup\n-     * @see org.quartz.Scheduler#DEFAULT_GROUP\n-     */\n-    public void setGroup(final String group) {\n-        this.group = group;\n-    }\n-\n-    @Override\n-    public JobDetail getObject()\n-            throws Exception {\n-\n-        return jobDetail;\n-    }\n-\n-    @Override\n-    public Class<?> getObjectType() {\n-        return JobDetail.class;\n-    }\n-\n-    @Override\n-    public boolean isSingleton() {\n-        return true;\n-    }\n-\n-    /**\n-     * Set a list of JobListener names for this job, referring to\n-     * non-global JobListeners registered with the Scheduler.\n-     * <p>A JobListener name always refers to the name returned\n-     * by the JobListener implementation.</p>\n-     *\n-     * @param names to be set\n-     * @see org.springframework.scheduling.quartz.SchedulerFactoryBean#setJobListeners\n-     * @see org.quartz.JobListener#getName\n-     */\n-    public void setJobListenerNames(final String[] names) {\n-        if (names != null) {\n-            this.jobListenerNames = names.clone();\n-        }\n-    }\n-\n-    @Override\n-    public void setBeanName(final String beanName) {\n-        this.beanName = beanName;\n-    }\n-\n-    @Override\n-    public void setBeanClassLoader(final ClassLoader classLoader) {\n-    }\n-\n-    @Override\n-    public void setBeanFactory(final BeanFactory beanFactory) {\n-    }\n-\n-    /**\n-     * Set target bean name.\n-     *\n-     * @param targetBeanName to be set\n-     */\n-    public void setTargetBeanName(final String targetBeanName) {\n-        this.targetBeanName = targetBeanName;\n-    }\n-\n-    /**\n-     * Set target method name.\n-     *\n-     * @param targetMethod to be set\n-     */\n-    public void setTargetMethod(final String targetMethod) {\n-        this.targetMethod = targetMethod;\n-    }\n-\n-    @Override\n-    public void afterPropertiesSet()\n-            throws Exception {\n-\n-        if (StringUtils.isBlank(targetBeanName)\n-                || StringUtils.isBlank(targetMethod)) {\n-\n-            throw new IllegalArgumentException(\n-                    \"Blank targetBeanName and / or targetMethod\");\n-        }\n-\n-        String name = this.beanName + \"_\"\n-                + Calendar.getInstance().getTimeInMillis();\n-\n-        // Build JobDetail instance.\n-        this.jobDetail = new JobDetail(name, this.group,\n-                MethodInvokingJob.class);\n-        this.jobDetail.getJobDataMap().put(\"targetBeanName\", targetBeanName);\n-        this.jobDetail.getJobDataMap().put(\"targetMethod\", targetMethod);\n-        this.jobDetail.setVolatility(false);\n-        this.jobDetail.setDurability(true);\n-\n-        // Register job listener names.\n-        if (this.jobListenerNames != null) {\n-            for (String jobListenerName : this.jobListenerNames) {\n-                this.jobDetail.addJobListener(jobListenerName);\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Spring's QuartzJobBean implementation delegating actual operations to\n-     * a bean fetched from application context.<br/>\n-     * Being a StatefulJob, no concurrent executions are allowed.\n-     *\n-     * @see QuartzJobBean\n-     * @see StatefulJob\n-     */\n-    public static class MethodInvokingJob extends QuartzJobBean\n-            implements StatefulJob {\n-\n-        /**\n-         * Target bean name.\n-         */\n-        private String targetBeanName;\n-\n-        /**\n-         * Target method name.\n-         */\n-        private String targetMethod;\n-\n-        /**\n-         * Target bean name setter.\n-         *\n-         * @param targetBeanName to be set\n-         */\n-        public void setTargetBeanName(final String targetBeanName) {\n-            this.targetBeanName = targetBeanName;\n-        }\n-\n-        /**\n-         * Target method setter.\n-         *\n-         * @param targetMethod to be set\n-         */\n-        public void setTargetMethod(final String targetMethod) {\n-            this.targetMethod = targetMethod;\n-        }\n-\n-        @Override\n-        protected void executeInternal(final JobExecutionContext context)\n-                throws JobExecutionException {\n-\n-            ConfigurableApplicationContext appContext =\n-                    ApplicationContextManager.getApplicationContext();\n-            Object instance = appContext.getBean(targetBeanName);\n-\n-            MethodInvoker methodInvoker = new MethodInvoker();\n-            methodInvoker.setTargetObject(instance);\n-            methodInvoker.setTargetMethod(targetMethod);\n-            methodInvoker.setArguments(new Object[]{context});\n-\n-            try {\n-                methodInvoker.prepare();\n-                context.setResult(methodInvoker.invoke());\n-            } catch (InvocationTargetException e) {\n-                if (e.getTargetException() instanceof JobExecutionException) {\n-                    // JobExecutionException, to be logged by Quartz\n-                    throw (JobExecutionException) e.getTargetException();\n-                } else {\n-                    // \"unhandled exception\", to be logged by Quartz\n-                    throw new JobMethodInvocationFailedException(methodInvoker,\n-                            e.getTargetException());\n-                }\n-            } catch (Exception e) {\n-                // \"unhandled exception\", to be logged at error level by Quartz\n-                throw new JobMethodInvocationFailedException(methodInvoker, e);\n-            }\n-        }\n-    }\n-}"},{"sha":"b38ba906bae2cabd92d907e5c025a78376e1b8fc","filename":"core/src/main/java/org/syncope/core/scheduling/Job.java","status":"removed","additions":0,"deletions":34,"changes":34,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/83072f7a86c92fcaa1a28642c5b5a792493e1003/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Fscheduling%2FJob.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/83072f7a86c92fcaa1a28642c5b5a792493e1003/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Fscheduling%2FJob.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Fscheduling%2FJob.java?ref=83072f7a86c92fcaa1a28642c5b5a792493e1003","patch":"@@ -1,34 +0,0 @@\n-/*\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.syncope.core.scheduling;\n-\n-import org.quartz.JobExecutionContext;\n-import org.quartz.JobExecutionException;\n-\n-/**\n- * Interface for jobs to be executed within Syncope, by empowering\n- * Spring and Quartz.\n- */\n-public interface Job {\n-\n-    public static final String DRY_RUN_JOBDETAIL_KEY = \"dryRun\";\n-\n-    /**\n-     * The actual execution.\n-     * @param context job execution context\n-     * @throws JobExecutionException \n-     */\n-    void execute(JobExecutionContext context)\n-            throws JobExecutionException;\n-}"},{"sha":"e39aa16352c1b53ececf91ab8602344143ff25b3","filename":"core/src/main/java/org/syncope/core/scheduling/NotificationJob.java","status":"modified","additions":2,"deletions":1,"changes":3,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/0651c1715d30aff0f189567e6be6b6670cc6918c/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Fscheduling%2FNotificationJob.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/0651c1715d30aff0f189567e6be6b6670cc6918c/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Fscheduling%2FNotificationJob.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Fscheduling%2FNotificationJob.java?ref=0651c1715d30aff0f189567e6be6b6670cc6918c","patch":"@@ -20,6 +20,7 @@\n import org.apache.commons.lang.StringUtils;\n import org.quartz.JobExecutionContext;\n import org.quartz.JobExecutionException;\n+import org.quartz.StatefulJob;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.springframework.beans.factory.annotation.Autowired;\n@@ -37,7 +38,7 @@\n  *\n  * @see NotificationTask\n  */\n-public class NotificationJob implements Job {\n+public class NotificationJob implements StatefulJob {\n \n     enum Status {\n "},{"sha":"20de789115c6a2c47a39b2c9081fb9e2bb091034","filename":"core/src/main/java/org/syncope/core/scheduling/SpringBeanJobFactory.java","status":"added","additions":83,"deletions":0,"changes":83,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/0651c1715d30aff0f189567e6be6b6670cc6918c/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Fscheduling%2FSpringBeanJobFactory.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/0651c1715d30aff0f189567e6be6b6670cc6918c/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Fscheduling%2FSpringBeanJobFactory.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Fscheduling%2FSpringBeanJobFactory.java?ref=0651c1715d30aff0f189567e6be6b6670cc6918c","patch":"@@ -0,0 +1,83 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.syncope.core.scheduling;\n+\n+import org.quartz.SchedulerContext;\n+import org.quartz.spi.TriggerFiredBundle;\n+import org.springframework.beans.BeanWrapper;\n+import org.springframework.beans.MutablePropertyValues;\n+import org.springframework.beans.PropertyAccessorFactory;\n+import org.springframework.context.ApplicationContext;\n+import org.springframework.context.ConfigurableApplicationContext;\n+\n+public class SpringBeanJobFactory\n+        extends org.springframework.scheduling.quartz.SpringBeanJobFactory {\n+\n+    private String[] ignoredUnknownProperties;\n+\n+    private SchedulerContext schedulerContext;\n+\n+    @Override\n+    public void setIgnoredUnknownProperties(\n+            final String[] ignoredUnknownProperties) {\n+\n+        super.setIgnoredUnknownProperties(ignoredUnknownProperties);\n+        this.ignoredUnknownProperties = ignoredUnknownProperties;\n+    }\n+\n+    @Override\n+    public void setSchedulerContext(final SchedulerContext schedulerContext) {\n+        super.setSchedulerContext(schedulerContext);\n+        this.schedulerContext = schedulerContext;\n+    }\n+\n+    /**\n+     * An implementation of SpringBeanJobFactory that retrieves the bean from\n+     * the Spring context so that autowiring and transactions work.\n+     *\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    protected Object createJobInstance(final TriggerFiredBundle bundle)\n+            throws Exception {\n+\n+        final ApplicationContext ctx =\n+                ((ConfigurableApplicationContext) schedulerContext.get(\n+                \"applicationContext\"));\n+        final Object job = ctx.getBean(bundle.getJobDetail().getName());\n+        final BeanWrapper wrapper =\n+                PropertyAccessorFactory.forBeanPropertyAccess(job);\n+        if (isEligibleForPropertyPopulation(wrapper.getWrappedInstance())) {\n+            final MutablePropertyValues pvs = new MutablePropertyValues();\n+            if (this.schedulerContext != null) {\n+                pvs.addPropertyValues(this.schedulerContext);\n+            }\n+            pvs.addPropertyValues(bundle.getJobDetail().getJobDataMap());\n+            pvs.addPropertyValues(bundle.getTrigger().getJobDataMap());\n+            if (this.ignoredUnknownProperties == null) {\n+                wrapper.setPropertyValues(pvs, true);\n+            } else {\n+                for (String propName : this.ignoredUnknownProperties) {\n+                    if (pvs.contains(propName)\n+                            && !wrapper.isWritableProperty(propName)) {\n+\n+                        pvs.removePropertyValue(propName);\n+                    }\n+                }\n+                wrapper.setPropertyValues(pvs);\n+            }\n+        }\n+        return job;\n+    }\n+}"},{"sha":"8155050f90be120b8b89f4bd19dcc078cc07cd8f","filename":"core/src/main/java/org/syncope/core/scheduling/SyncJob.java","status":"modified","additions":114,"deletions":88,"changes":202,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/0651c1715d30aff0f189567e6be6b6670cc6918c/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Fscheduling%2FSyncJob.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/0651c1715d30aff0f189567e6be6b6670cc6918c/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Fscheduling%2FSyncJob.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Fscheduling%2FSyncJob.java?ref=0651c1715d30aff0f189567e6be6b6670cc6918c","patch":"@@ -18,6 +18,7 @@\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n+import javassist.NotFoundException;\n import org.apache.commons.lang.RandomStringUtils;\n import org.apache.commons.lang.StringUtils;\n import org.identityconnectors.common.security.GuardedByteArray;\n@@ -63,6 +64,7 @@\n import org.syncope.core.propagation.PropagationException;\n import org.syncope.core.propagation.PropagationManager;\n import org.syncope.core.rest.controller.InvalidSearchConditionException;\n+import org.syncope.core.rest.controller.UnauthorizedRoleException;\n import org.syncope.core.rest.data.UserDataBinder;\n import org.syncope.core.scheduling.SyncResult.Operation;\n import org.syncope.core.util.EntitlementUtil;\n@@ -353,13 +355,13 @@ private UserTO getUserTO(final ConnectorObject obj) {\n      * @param obj connector object\n      * @return UserMod for the user to be updated\n      */\n-    private UserMod getUserMod(final SyncopeUser user,\n+    private UserMod getUserMod(final Long userId,\n             final ConnectorObject obj) {\n \n         final SyncTask syncTask = (SyncTask) this.task;\n \n         final UserMod userMod = new UserMod();\n-        userMod.setId(user.getId());\n+        userMod.setId(userId);\n \n         for (SchemaMapping mapping : syncTask.getResource().getMappings()) {\n             Attribute attribute = obj.getAttributeByName(\n@@ -381,16 +383,18 @@ private UserMod getUserMod(final SyncopeUser user,\n \n                         String password =\n                                 getPassword(attribute.getValue().get(0));\n-                        SyncopeUser passwordUser = new SyncopeUser();\n-                        passwordUser.setPassword(\n-                                password, user.getCipherAlgoritm(), 0);\n-\n                         // update password if and only if password has really \n                         // changed\n-                        if (!user.getPassword().equals(\n-                                passwordUser.getPassword())) {\n-\n-                            userMod.setPassword(password);\n+                        try {\n+                            if (!userDataBinder.verifyPassword(userId,\n+                                    password)) {\n+\n+                                userMod.setPassword(password);\n+                            }\n+                        } catch (NotFoundException e) {\n+                            LOG.error(\"Could not find user {}\", userId, e);\n+                        } catch (UnauthorizedRoleException e) {\n+                            LOG.error(\"Not allowed to read user {}\", userId, e);\n                         }\n                     }\n                     break;\n@@ -443,7 +447,7 @@ private UserMod getUserMod(final SyncopeUser user,\n      * @param delta sync delta\n      * @return list of matching users\n      */\n-    private List<SyncopeUser> findExistingUsers(final SyncDelta delta) {\n+    private List<Long> findExistingUsers(final SyncDelta delta) {\n         final SyncTask syncTask = (SyncTask) this.task;\n \n         final String uid = delta.getPreviousUid() == null\n@@ -459,7 +463,7 @@ private List<SyncopeUser> findExistingUsers(final SyncDelta delta) {\n                 ? (SyncPolicySpec) policy.getSpecification() : null;\n         // ---------------------------------\n \n-        final List<SyncopeUser> result = new ArrayList<SyncopeUser>();\n+        final List<Long> result = new ArrayList<Long>();\n \n         if (policySpec != null\n                 && !policySpec.getAlternativeSearchAttrs().isEmpty()) {\n@@ -542,40 +546,50 @@ private List<SyncopeUser> findExistingUsers(final SyncDelta delta) {\n                         : nodeCond;\n             }\n \n-            result.addAll(userSearchDAO.search(\n+            List<SyncopeUser> users = userSearchDAO.search(\n                     EntitlementUtil.getRoleIds(entitlementDAO.findAll()),\n-                    searchCondition));\n+                    searchCondition);\n+            for (SyncopeUser user : users) {\n+                result.add(user.getId());\n+            }\n         } else {\n-            final SyncopeUser user;\n+            final SyncopeUser found;\n+            List<SyncopeUser> users;\n \n             final SchemaMapping accountIdMap =\n                     syncTask.getResource().getAccountIdMapping();\n             switch (accountIdMap.getIntMappingType()) {\n                 case Username:\n-                    user = userDAO.find(uid);\n-                    if (user != null) {\n-                        result.add(user);\n+                    found = userDAO.find(uid);\n+                    if (found != null) {\n+                        result.add(found.getId());\n                     }\n                     break;\n \n                 case SyncopeUserId:\n-                    user = userDAO.find(Long.parseLong(uid));\n-                    if (user != null) {\n-                        result.add(user);\n+                    found = userDAO.find(Long.parseLong(uid));\n+                    if (found != null) {\n+                        result.add(found.getId());\n                     }\n                     break;\n \n                 case UserSchema:\n                     final UAttrValue value = new UAttrValue();\n                     value.setStringValue(uid);\n-                    result.addAll(userDAO.findByAttrValue(\n-                            accountIdMap.getIntAttrName(), value));\n+                    users = userDAO.findByAttrValue(\n+                            accountIdMap.getIntAttrName(), value);\n+                    for (SyncopeUser user : users) {\n+                        result.add(user.getId());\n+                    }\n                     break;\n \n                 case UserDerivedSchema:\n                     try {\n-                        result.addAll(userDAO.findByDerAttrValue(\n-                                accountIdMap.getIntAttrName(), uid));\n+                        users = userDAO.findByDerAttrValue(\n+                                accountIdMap.getIntAttrName(), uid);\n+                        for (SyncopeUser user : users) {\n+                            result.add(user.getId());\n+                        }\n                     } catch (InvalidSearchConditionException e) {\n                         LOG.error(\"Could not search for matching users\", e);\n                     }\n@@ -637,7 +651,7 @@ private SyncResult createUser(final SyncDelta delta, final boolean dryRun)\n     }\n \n     private void updateUsers(final SyncDelta delta,\n-            final List<SyncopeUser> users, final boolean dryRun,\n+            final List<Long> users, final boolean dryRun,\n             final List<SyncResult> results)\n             throws JobExecutionException {\n \n@@ -648,49 +662,58 @@ private void updateUsers(final SyncDelta delta,\n \n         LOG.debug(\"About to update {}\", users);\n \n-        for (SyncopeUser user : users) {\n+        for (Long userId : users) {\n             final SyncResult result = new SyncResult();\n             result.setOperation(Operation.UPDATE);\n \n-            UserTO userTO = userDataBinder.getUserTO(user);\n             try {\n-                final UserMod userMod = getUserMod(user, delta.getObject());\n-                actions.beforeUpdate(delta, userTO, userMod);\n-\n-                result.setStatus(SyncResult.Status.SUCCESS);\n-                result.setUserId(userMod.getId());\n-                result.setUsername(userMod.getUsername());\n-\n-                if (!dryRun) {\n-                    WorkflowResult<Map.Entry<Long, PropagationByResource>> upd =\n-                            wfAdapter.update(userMod);\n-                    List<PropagationTask> tasks =\n-                            propagationManager.getUpdateTaskIds(\n-                            upd.getResult().getKey(), userMod.getPassword(),\n-                            null, null, null, upd.getResult().getValue(),\n-                            ((SyncTask) this.task).getResource().getName());\n-                    propagationManager.execute(tasks);\n-\n-                    userTO = userDataBinder.getUserTO(\n-                            upd.getResult().getKey());\n+                UserTO userTO = userDataBinder.getUserTO(userId);\n+                try {\n+                    final UserMod userMod =\n+                            getUserMod(userId, delta.getObject());\n+                    actions.beforeUpdate(delta, userTO, userMod);\n+\n+                    result.setStatus(SyncResult.Status.SUCCESS);\n+                    result.setUserId(userMod.getId());\n+                    result.setUsername(userMod.getUsername());\n+\n+                    if (!dryRun) {\n+                        WorkflowResult<Map.Entry<Long, PropagationByResource>> updated =\n+                                wfAdapter.update(userMod);\n+                        List<PropagationTask> tasks =\n+                                propagationManager.getUpdateTaskIds(\n+                                updated.getResult().getKey(),\n+                                userMod.getPassword(),\n+                                null, null, null,\n+                                updated.getResult().getValue(),\n+                                ((SyncTask) this.task).getResource().getName());\n+                        propagationManager.execute(tasks);\n+\n+                        userTO = userDataBinder.getUserTO(\n+                                updated.getResult().getKey());\n+                    }\n+                } catch (PropagationException e) {\n+                    LOG.error(\"Could not propagate user \"\n+                            + delta.getUid().getUidValue(), e);\n+                } catch (Throwable t) {\n+                    result.setStatus(SyncResult.Status.FAILURE);\n+                    result.setMessage(t.getMessage());\n+                    LOG.error(\"Could not update user \"\n+                            + delta.getUid().getUidValue(), t);\n                 }\n-            } catch (PropagationException e) {\n-                LOG.error(\"Could not propagate user \"\n-                        + delta.getUid().getUidValue(), e);\n-            } catch (Throwable t) {\n-                result.setStatus(SyncResult.Status.FAILURE);\n-                result.setMessage(t.getMessage());\n-                LOG.error(\"Could not update user \"\n-                        + delta.getUid().getUidValue(), t);\n-            }\n \n-            actions.after(delta, userTO, result);\n-            results.add(result);\n+                actions.after(delta, userTO, result);\n+                results.add(result);\n+            } catch (NotFoundException e) {\n+                LOG.error(\"Could not find user {}\", userId, e);\n+            } catch (UnauthorizedRoleException e) {\n+                LOG.error(\"Not allowed to read user {}\", userId, e);\n+            }\n         }\n     }\n \n     private void deleteUsers(final SyncDelta delta,\n-            final List<SyncopeUser> users, final boolean dryRun,\n+            final List<Long> users, final boolean dryRun,\n             final List<SyncResult> results)\n             throws JobExecutionException {\n \n@@ -701,40 +724,43 @@ private void deleteUsers(final SyncDelta delta,\n \n         LOG.debug(\"About to delete {}\", users);\n \n-        for (SyncopeUser user : users) {\n-            Long userId = user.getId();\n+        for (Long userId : users) {\n+            try {\n+                UserTO userTO = userDataBinder.getUserTO(userId);\n+                actions.beforeDelete(delta, userTO);\n \n-            UserTO userTO = userDataBinder.getUserTO(user);\n-            actions.beforeDelete(delta, userTO);\n+                final SyncResult result = new SyncResult();\n+                result.setUserId(userId);\n+                result.setUsername(userTO.getUsername());\n+                result.setOperation(Operation.DELETE);\n+                result.setStatus(SyncResult.Status.SUCCESS);\n \n-            final SyncResult result = new SyncResult();\n-            result.setUserId(userId);\n-            result.setUsername(user.getUsername());\n-            result.setOperation(Operation.DELETE);\n-            result.setStatus(SyncResult.Status.SUCCESS);\n+                if (!dryRun) {\n+                    try {\n+                        List<PropagationTask> tasks =\n+                                propagationManager.getDeleteTaskIds(userId,\n+                                ((SyncTask) this.task).getResource().getName());\n+                        propagationManager.execute(tasks);\n+                    } catch (Exception e) {\n+                        LOG.error(\"Could not propagate user \" + userId, e);\n+                    }\n \n-            if (!dryRun) {\n-                try {\n-                    List<PropagationTask> tasks =\n-                            propagationManager.getDeleteTaskIds(userId,\n-                            ((SyncTask) this.task).getResource().getName());\n-                    propagationManager.execute(tasks);\n-                } catch (Exception e) {\n-                    LOG.error(\"Could not propagate user \" + userId, e);\n+                    try {\n+                        wfAdapter.delete(userId);\n+                    } catch (Throwable t) {\n+                        result.setStatus(SyncResult.Status.FAILURE);\n+                        result.setMessage(t.getMessage());\n+                        LOG.error(\"Could not delete user \" + userId, t);\n+                    }\n                 }\n \n-                try {\n-                    wfAdapter.delete(userId);\n-                } catch (Throwable t) {\n-                    result.setStatus(SyncResult.Status.FAILURE);\n-                    result.setMessage(t.getMessage());\n-                    LOG.error(\"Could not delete user \" + userId, t);\n-                }\n+                actions.after(delta, userTO, result);\n+                results.add(result);\n+            } catch (NotFoundException e) {\n+                LOG.error(\"Could not find user {}\", userId, e);\n+            } catch (UnauthorizedRoleException e) {\n+                LOG.error(\"Not allowed to read user {}\", userId, e);\n             }\n-\n-            actions.after(delta, userTO, result);\n-            results.add(result);\n-\n         }\n     }\n \n@@ -933,7 +959,7 @@ protected String doExecute(final boolean dryRun)\n         actions.beforeAll(deltas);\n \n         for (SyncDelta delta : deltas) {\n-            List<SyncopeUser> users = findExistingUsers(delta);\n+            List<Long> users = findExistingUsers(delta);\n \n             switch (delta.getDeltaType()) {\n                 case CREATE_OR_UPDATE:"},{"sha":"7d7d2259b4c912665cbb0581c1e651ce04ca62df","filename":"core/src/main/resources/schedulingContext.xml","status":"modified","additions":5,"deletions":6,"changes":11,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/0651c1715d30aff0f189567e6be6b6670cc6918c/core%2Fsrc%2Fmain%2Fresources%2FschedulingContext.xml","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/0651c1715d30aff0f189567e6be6b6670cc6918c/core%2Fsrc%2Fmain%2Fresources%2FschedulingContext.xml","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fresources%2FschedulingContext.xml?ref=0651c1715d30aff0f189567e6be6b6670cc6918c","patch":"@@ -35,12 +35,6 @@\n             </bean>\n         </property>\n     </bean>\n-\n-    <bean id=\"jpaInterceptor\" class=\"org.springframework.orm.jpa.JpaInterceptor\">\n-        <property name=\"entityManagerFactory\" ref=\"entityManagerFactory\"/>\n-    </bean>\n-\n-    <bean id=\"notificationJob\" class=\"org.syncope.core.scheduling.NotificationJob\"/>\n     \n     <bean id=\"scheduler\"\n \t  class=\"org.springframework.scheduling.quartz.SchedulerFactoryBean\"\n@@ -51,6 +45,9 @@\n         <property name=\"overwriteExistingJobs\" value=\"true\"/>\n         <property name=\"dataSource\" ref=\"dataSource\"/>\n         <property name=\"transactionManager\" ref=\"transactionManager\"/>\n+        <property name=\"jobFactory\">\n+            <bean class=\"org.syncope.core.scheduling.SpringBeanJobFactory\"/>\n+        </property>\n         <property name=\"quartzProperties\">\n             <props>\n \t\t<!-- Job store -->\n@@ -66,4 +63,6 @@\n             </props>\n         </property>\n     </bean>\n+    \n+    <bean id=\"notificationJob\" class=\"org.syncope.core.scheduling.NotificationJob\"/>\n </beans>"}]}