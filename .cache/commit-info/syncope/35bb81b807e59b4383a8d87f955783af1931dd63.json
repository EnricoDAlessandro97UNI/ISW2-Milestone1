{"sha":"35bb81b807e59b4383a8d87f955783af1931dd63","node_id":"MDY6Q29tbWl0NjM2ODc5MDYyOjM1YmI4MWI4MDdlNTliNDM4M2E4ZDg3Zjk1NTc4M2FmMTkzMWRkNjM=","commit":{"author":{"name":"Unknown","email":"unknown@apache.org","date":"2012-02-13T15:56:24Z"},"committer":{"name":"Unknown","email":"unknown@apache.org","date":"2012-02-13T15:56:24Z"},"message":"Update issue 217\nProvided mechanism to manage propagation info.\nTODO: info must be shown via console as result of a user create, edit or delete.\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/incubator/syncope/trunk@1247402 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"b3cedb14fb6473f9a187592c4a8d0f469efb0bc9","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/git/trees/b3cedb14fb6473f9a187592c4a8d0f469efb0bc9"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/git/commits/35bb81b807e59b4383a8d87f955783af1931dd63","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/35bb81b807e59b4383a8d87f955783af1931dd63","html_url":"https://github.com/EnricoDAlessandro97UNI/syncope/commit/35bb81b807e59b4383a8d87f955783af1931dd63","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/35bb81b807e59b4383a8d87f955783af1931dd63/comments","author":null,"committer":null,"parents":[{"sha":"ff061d4a08f05d35a0e90e3999b7d628666cb3b9","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/ff061d4a08f05d35a0e90e3999b7d628666cb3b9","html_url":"https://github.com/EnricoDAlessandro97UNI/syncope/commit/ff061d4a08f05d35a0e90e3999b7d628666cb3b9"}],"stats":{"total":1091,"additions":739,"deletions":352},"files":[{"sha":"d39f18c8d2b31d010b501d6476b138a5ffed5808","filename":"client/src/main/java/org/syncope/client/to/PropagationTO.java","status":"added","additions":121,"deletions":0,"changes":121,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/35bb81b807e59b4383a8d87f955783af1931dd63/client%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fclient%2Fto%2FPropagationTO.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/35bb81b807e59b4383a8d87f955783af1931dd63/client%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fclient%2Fto%2FPropagationTO.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/client%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fclient%2Fto%2FPropagationTO.java?ref=35bb81b807e59b4383a8d87f955783af1931dd63","patch":"@@ -0,0 +1,121 @@\n+/*\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *  under the License.\n+ */\n+package org.syncope.client.to;\n+\n+import org.syncope.client.AbstractBaseBean;\n+import org.syncope.types.PropagationTaskExecStatus;\n+\n+/**\n+ * Single propagation status.\n+ */\n+public class PropagationTO extends AbstractBaseBean {\n+\n+    /**\n+     * Serial version ID.\n+     */\n+    private static final long serialVersionUID = 3921498450222857690L;\n+\n+    /**\n+     * Object before propagation.\n+     */\n+    private ConnObjectTO before;\n+\n+    /**\n+     * Object after propagation.\n+     */\n+    private ConnObjectTO after;\n+\n+    /**\n+     * Propagated resource name.\n+     */\n+    private String resourceName;\n+\n+    /**\n+     * Propagation task excution status.\n+     */\n+    private PropagationTaskExecStatus status;\n+\n+    /**\n+     * After object getter.\n+     *\n+     * @return after object.\n+     */\n+    public ConnObjectTO getAfter() {\n+        return after;\n+    }\n+\n+    /**\n+     * After object setter.\n+     *\n+     * @param after object.\n+     */\n+    public void setAfter(final ConnObjectTO after) {\n+        this.after = after;\n+    }\n+\n+    /**\n+     * Before object getter.\n+     *\n+     * @return before object.\n+     */\n+    public ConnObjectTO getBefore() {\n+        return before;\n+    }\n+\n+    /**\n+     * Before object setter.\n+     *\n+     * @param before object.\n+     */\n+    public void setBefore(final ConnObjectTO before) {\n+        this.before = before;\n+    }\n+\n+    /**\n+     * resource name getter.\n+     *\n+     * @return resource name.\n+     */\n+    public String getResourceName() {\n+        return resourceName;\n+    }\n+\n+    /**\n+     * Resource name setter.\n+     *\n+     * @param resourceName resource name.\n+     */\n+    public void setResourceName(final String resourceName) {\n+        this.resourceName = resourceName;\n+    }\n+\n+    /**\n+     * Propagation execution status getter.\n+     *\n+     * @return status.\n+     */\n+    public PropagationTaskExecStatus getStatus() {\n+        return status;\n+    }\n+\n+    /**\n+     * Propagation execution status setter.\n+     *\n+     * @param status propagation execution status.\n+     */\n+    public void setStatus(final PropagationTaskExecStatus status) {\n+        this.status = status;\n+    }\n+}"},{"sha":"fe6675237fe8c7cf2f60f9e07567f48f9e0a54d0","filename":"client/src/main/java/org/syncope/client/to/UserTO.java","status":"modified","additions":21,"deletions":26,"changes":47,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/35bb81b807e59b4383a8d87f955783af1931dd63/client%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fclient%2Fto%2FUserTO.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/35bb81b807e59b4383a8d87f955783af1931dd63/client%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fclient%2Fto%2FUserTO.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/client%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fclient%2Fto%2FUserTO.java?ref=35bb81b807e59b4383a8d87f955783af1931dd63","patch":"@@ -23,7 +23,6 @@\n import org.apache.commons.lang.builder.ReflectionToStringBuilder;\n import org.apache.commons.lang.builder.ToStringStyle;\n import org.codehaus.jackson.annotate.JsonIgnore;\n-import org.syncope.types.PropagationTaskExecStatus;\n \n public class UserTO extends AbstractAttributableTO {\n \n@@ -33,7 +32,7 @@ public class UserTO extends AbstractAttributableTO {\n \n     private List<MembershipTO> memberships;\n \n-    private List<ConnObjectTO> connObjectTOs;\n+    List<PropagationTO> propagationTOs;\n \n     private String status;\n \n@@ -51,14 +50,11 @@ public class UserTO extends AbstractAttributableTO {\n \n     private Integer failedLogins;\n \n-    private Map<String, PropagationTaskExecStatus> propagationStatusMap;\n-\n     public UserTO() {\n         super();\n \n         memberships = new ArrayList<MembershipTO>();\n-        connObjectTOs = new ArrayList<ConnObjectTO>();\n-        propagationStatusMap = new HashMap<String, PropagationTaskExecStatus>();\n+        propagationTOs = new ArrayList<PropagationTO>();\n     }\n \n     public String getPassword() {\n@@ -164,36 +160,35 @@ public void setLastLoginDate(Date lastLoginDate) {\n         this.lastLoginDate = lastLoginDate;\n     }\n \n-    public void addPropagationStatus(String resource,\n-            PropagationTaskExecStatus status) {\n-\n-        propagationStatusMap.put(resource, status);\n+    public void addPropagationTO(final PropagationTO status) {\n+        propagationTOs.add(status);\n     }\n \n-    public void removePropagationStatus(String resource) {\n+    public void removePropagationTO(final String resource) {\n+        if (resource != null && getPropagationTOs().isEmpty()) {\n \n-        propagationStatusMap.remove(resource);\n-    }\n+            final List<PropagationTO> toBeRemoved =\n+                    new ArrayList<PropagationTO>();\n \n-    public Map<String, PropagationTaskExecStatus> getPropagationStatusMap() {\n-        return propagationStatusMap;\n-    }\n-\n-    public void setPropagationStatusMap(\n-            Map<String, PropagationTaskExecStatus> propagationStatusMap) {\n+            for (PropagationTO propagationTO : getPropagationTOs()) {\n+                if (resource.equals(propagationTO.getResourceName())) {\n+                    toBeRemoved.add(propagationTO);\n+                }\n+            }\n \n-        this.propagationStatusMap.clear();\n-        if (propagationStatusMap != null && !propagationStatusMap.isEmpty()) {\n-            this.propagationStatusMap.putAll(propagationStatusMap);\n+            propagationTOs.removeAll(toBeRemoved);\n         }\n     }\n \n-    public List<ConnObjectTO> getConnObjectTOs() {\n-        return connObjectTOs;\n+    public List<PropagationTO> getPropagationTOs() {\n+        return propagationTOs;\n     }\n \n-    public void setConnObjectTOs(final List<ConnObjectTO> connObjectTOs) {\n-        this.connObjectTOs = connObjectTOs;\n+    public void setPropagationTOs(\n+            final List<PropagationTO> propagationTOs) {\n+\n+        this.propagationTOs.clear();\n+        this.propagationTOs.addAll(propagationTOs);\n     }\n \n     @Override"},{"sha":"152cf3042259ee65451af48a57778152755a3f03","filename":"console/src/main/java/org/syncope/console/pages/panels/UserModalPageResult.java","status":"modified","additions":22,"deletions":21,"changes":43,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/35bb81b807e59b4383a8d87f955783af1931dd63/console%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fconsole%2Fpages%2Fpanels%2FUserModalPageResult.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/35bb81b807e59b4383a8d87f955783af1931dd63/console%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fconsole%2Fpages%2Fpanels%2FUserModalPageResult.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/console%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fconsole%2Fpages%2Fpanels%2FUserModalPageResult.java?ref=35bb81b807e59b4383a8d87f955783af1931dd63","patch":"@@ -18,7 +18,6 @@\n \n import java.util.ArrayList;\n import java.util.List;\n-import java.util.Map;\n import org.apache.wicket.ajax.AjaxRequestTarget;\n import org.apache.wicket.ajax.markup.html.AjaxLink;\n import org.apache.wicket.ajax.markup.html.navigation.paging.AjaxPagingNavigator;\n@@ -34,6 +33,7 @@\n import org.apache.wicket.request.resource.ContextRelativeResource;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n+import org.syncope.client.to.PropagationTO;\n import org.syncope.client.to.UserTO;\n import org.syncope.console.pages.UserModalPage;\n import org.syncope.types.PropagationTaskExecStatus;\n@@ -52,7 +52,7 @@ public class UserModalPageResult extends Panel {\n \n     public UserModalPageResult(\n             final String id,\n-            final ModalWindow window, \n+            final ModalWindow window,\n             final UserModalPage.Mode mode,\n             final UserTO userTO) {\n \n@@ -70,43 +70,44 @@ public UserModalPageResult(\n         container.add(fragment);\n \n         if (mode == UserModalPage.Mode.ADMIN) {\n-            final Map<String, PropagationTaskExecStatus> propagationMap =\n-                    userTO.getPropagationStatusMap();\n-\n-            final List<String> resourceListKey =\n-                    new ArrayList<String>(propagationMap.keySet());\n \n             // add Syncope propagation status\n-            resourceListKey.add(0, \"Syncope\");\n-            propagationMap.put(\"Syncope\", PropagationTaskExecStatus.SUCCESS);\n+            PropagationTO syncope = new PropagationTO();\n+            syncope.setResourceName(\"Syncope\");\n+            syncope.setStatus(PropagationTaskExecStatus.SUCCESS);\n+\n+            List<PropagationTO> propagations = new ArrayList<PropagationTO>();\n+            propagations.add(syncope);\n+            propagations.addAll(userTO.getPropagationTOs());\n \n             fragment.add(new Label(\"userInfo\", userTO.getUsername()));\n \n-            final PageableListView<String> propagationStatus =\n-                    new PageableListView<String>(\n+            final PageableListView<PropagationTO> propagationStatus =\n+                    new PageableListView<PropagationTO>(\n                     \"propagationResults\",\n-                    resourceListKey,\n+                    propagations,\n                     PROPAGATION_RESULT_PAGINATOR_ROWS) {\n \n                         private static final long serialVersionUID =\n                                 -1020475259727720708L;\n \n                         @Override\n-                        protected void populateItem(final ListItem item) {\n-                            final String resourceItem =\n-                                    (String) item.getDefaultModelObject();\n+                        protected void populateItem(\n+                                final ListItem item) {\n+                            final PropagationTO propagation =\n+                                    (PropagationTO) item.getDefaultModelObject();\n \n-                            item.add(new Label(\"resourceName\", resourceItem));\n+                            item.add(new Label(\"resourceName\",\n+                                    propagation.getResourceName()));\n \n                             item.add(new Label(\"propagation\",\n-                                    propagationMap.get(resourceItem) != null\n-                                    ? propagationMap.get(resourceItem).name()\n+                                    propagation.getStatus() != null\n+                                    ? propagation.getStatus().toString()\n                                     : \"UNDEFINED\"));\n \n                             item.add(new Image(\"status\",\n-                                    propagationMap.get(resourceItem) != null\n-                                    && propagationMap.get(resourceItem).\n-                                    isSuccessful()\n+                                    propagation.getStatus() != null\n+                                    && propagation.getStatus().isSuccessful()\n                                     ? new ContextRelativeResource(\n                                     \"img/success.png\")\n                                     : new ContextRelativeResource("},{"sha":"3c719701bcdfd53105dffe51e366acba598322a7","filename":"console/src/main/java/org/syncope/console/rest/UserRestClient.java","status":"modified","additions":5,"deletions":2,"changes":7,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/35bb81b807e59b4383a8d87f955783af1931dd63/console%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fconsole%2Frest%2FUserRestClient.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/35bb81b807e59b4383a8d87f955783af1931dd63/console%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fconsole%2Frest%2FUserRestClient.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/console%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fconsole%2Frest%2FUserRestClient.java?ref=35bb81b807e59b4383a8d87f955783af1931dd63","patch":"@@ -74,8 +74,11 @@ public UserTO update(UserMod userModTO)\n                 userModTO, UserTO.class);\n     }\n \n-    public void delete(Long id) {\n-        restTemplate.delete(baseURL + \"user/delete/{userId}\", id);\n+    public UserTO delete(Long id)\n+            throws SyncopeClientCompositeErrorException {\n+        \n+        return restTemplate.getForObject(\n+                baseURL + \"user/delete/{userId}\", UserTO.class, id);\n     }\n \n     public UserTO read(Long id) {"},{"sha":"aed7ea368b5fb95f2b82db08206587d36bd11ceb","filename":"core/src/main/java/org/syncope/core/propagation/ConnectorFacadeProxy.java","status":"modified","additions":9,"deletions":24,"changes":33,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/35bb81b807e59b4383a8d87f955783af1931dd63/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Fpropagation%2FConnectorFacadeProxy.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/35bb81b807e59b4383a8d87f955783af1931dd63/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Fpropagation%2FConnectorFacadeProxy.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Fpropagation%2FConnectorFacadeProxy.java?ref=35bb81b807e59b4383a8d87f955783af1931dd63","patch":"@@ -16,7 +16,6 @@\n \n import java.io.File;\n import java.net.URI;\n-import java.util.ArrayList;\n import java.util.Collection;\n import java.util.HashSet;\n import java.util.List;\n@@ -40,7 +39,6 @@\n import org.identityconnectors.framework.common.objects.OperationalAttributes;\n import org.identityconnectors.framework.common.objects.ResultsHandler;\n import org.identityconnectors.framework.common.objects.Schema;\n-import org.identityconnectors.framework.common.objects.SyncDelta;\n import org.identityconnectors.framework.common.objects.SyncDeltaBuilder;\n import org.identityconnectors.framework.common.objects.SyncDeltaType;\n import org.identityconnectors.framework.common.objects.SyncResultsHandler;\n@@ -364,27 +362,17 @@ public void delete(final PropagationMode propagationMode,\n      * Sync users from a connector instance.\n      *\n      * @param token to be passed to the underlying connector\n-     * @return list of sync operations to be performed\n+     * @param handler to be used to handle deltas.\n      */\n-    public List<SyncDelta> sync(final SyncToken token) {\n-        final List<SyncDelta> result = new ArrayList<SyncDelta>();\n+    public void sync(final SyncToken token, final SyncResultsHandler handler) {\n \n         if (capabitilies.contains(ConnectorCapability.SYNC)) {\n-            connector.sync(ObjectClass.ACCOUNT, token,\n-                    new SyncResultsHandler() {\n-\n-                        @Override\n-                        public boolean handle(final SyncDelta delta) {\n-                            return result.add(delta);\n-                        }\n-                    }, null);\n+            connector.sync(ObjectClass.ACCOUNT, token, handler, null);\n         } else {\n             LOG.info(\"Sync was attempted, although the \"\n                     + \"connector only has these capabilities: {}. No action.\",\n                     capabitilies);\n         }\n-\n-        return result;\n     }\n \n     /**\n@@ -488,16 +476,15 @@ public ConnectorObject getObject(\n      * Get remote object used by the propagation manager in order to choose for\n      * a create (object doesn't exist) or an update (object exists).\n      *\n-     * @param objectClass ConnId's object class\n-     * @param options ConnId's OperationOptions\n-     * @return ConnId's connector object for given uid\n+     * @param objectClass ConnId's object class.\n+     * @param handler to be used to handle deltas.\n+     * @param options ConnId's OperationOptions.\n      */\n-    public List<SyncDelta> getAllObjects(\n+    public void getAllObjects(\n             final ObjectClass objectClass,\n+            final SyncResultsHandler handler,\n             final OperationOptions options) {\n \n-        final List<SyncDelta> result = new ArrayList<SyncDelta>();\n-\n         if (capabitilies.contains(ConnectorCapability.SEARCH)) {\n             connector.search(objectClass, null,\n                     new ResultsHandler() {\n@@ -510,7 +497,7 @@ public boolean handle(final ConnectorObject obj) {\n                             bld.setDeltaType(SyncDeltaType.CREATE_OR_UPDATE);\n                             bld.setToken(new SyncToken(\"\"));\n \n-                            return result.add(bld.build());\n+                            return handler.handle(bld.build());\n                         }\n                     }, options);\n \n@@ -519,8 +506,6 @@ public boolean handle(final ConnectorObject obj) {\n                     + \"connector only has these capabilities: {}. No action.\",\n                     capabitilies);\n         }\n-\n-        return result;\n     }\n \n     /**"},{"sha":"410332a58254fd896b9827a0331c4760326b6626","filename":"core/src/main/java/org/syncope/core/propagation/PropagationHandler.java","status":"added","additions":38,"deletions":0,"changes":38,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/35bb81b807e59b4383a8d87f955783af1931dd63/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Fpropagation%2FPropagationHandler.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/35bb81b807e59b4383a8d87f955783af1931dd63/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Fpropagation%2FPropagationHandler.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Fpropagation%2FPropagationHandler.java?ref=35bb81b807e59b4383a8d87f955783af1931dd63","patch":"@@ -0,0 +1,38 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.syncope.core.propagation;\n+\n+import org.identityconnectors.framework.common.objects.ConnectorObject;\n+import org.syncope.types.PropagationTaskExecStatus;\n+\n+/**\n+ * Handle propagation executions.\n+ */\n+public abstract class PropagationHandler {\n+\n+    /**\n+     *\n+     * Handle propagation executions.\n+     *\n+     * @param resourceName resource name.\n+     * @param executionStatus propagation execution status.\n+     * @param before retrieved connector object before operation execution.\n+     * @param after retrieved connector object after operation execution.\n+     */\n+    public abstract void handle(\n+            final String resourceName,\n+            final PropagationTaskExecStatus executionStatus,\n+            final ConnectorObject before,\n+            final ConnectorObject after);\n+}"},{"sha":"41863b98d8c6cfc0d33d411f80d3e88d8732723f","filename":"core/src/main/java/org/syncope/core/propagation/PropagationManager.java","status":"modified","additions":152,"deletions":98,"changes":250,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/35bb81b807e59b4383a8d87f955783af1931dd63/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Fpropagation%2FPropagationManager.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/35bb81b807e59b4383a8d87f955783af1931dd63/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Fpropagation%2FPropagationManager.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Fpropagation%2FPropagationManager.java?ref=35bb81b807e59b4383a8d87f955783af1931dd63","patch":"@@ -14,7 +14,6 @@\n  */\n package org.syncope.core.propagation;\n \n-import org.syncope.types.PropagationTaskExecStatus;\n import java.io.PrintWriter;\n import java.io.StringWriter;\n import java.util.ArrayList;\n@@ -48,8 +47,8 @@\n import org.syncope.core.persistence.beans.AbstractSchema;\n import org.syncope.core.persistence.beans.ConnInstance;\n import org.syncope.core.persistence.beans.ExternalResource;\n-import org.syncope.core.persistence.beans.SchemaMapping;\n import org.syncope.core.persistence.beans.PropagationTask;\n+import org.syncope.core.persistence.beans.SchemaMapping;\n import org.syncope.core.persistence.beans.TaskExec;\n import org.syncope.core.persistence.beans.user.SyncopeUser;\n import org.syncope.core.persistence.beans.user.UAttr;\n@@ -68,9 +67,10 @@\n import org.syncope.core.util.AttributableUtil;\n import org.syncope.core.util.JexlUtil;\n import org.syncope.core.workflow.WorkflowResult;\n+import org.syncope.types.IntMappingType;\n import org.syncope.types.PropagationMode;\n import org.syncope.types.PropagationOperation;\n-import org.syncope.types.IntMappingType;\n+import org.syncope.types.PropagationTaskExecStatus;\n import org.syncope.types.SchemaType;\n import org.syncope.types.TraceLevel;\n \n@@ -743,6 +743,11 @@ protected List<PropagationTask> provision(\n         return tasks;\n     }\n \n+    public void execute(final List<PropagationTask> tasks)\n+            throws PropagationException {\n+        execute(tasks, null);\n+    }\n+\n     /**\n      * Execute a list of PropagationTask, in given order.\n      *\n@@ -751,13 +756,15 @@ protected List<PropagationTask> provision(\n      * interrupted as soon as the result of the communication with a primary\n      * resource is in error\n      */\n-    public void execute(final List<PropagationTask> tasks)\n+    public void execute(\n+            final List<PropagationTask> tasks,\n+            final PropagationHandler handler)\n             throws PropagationException {\n \n         for (PropagationTask task : tasks) {\n             LOG.debug(\"Execution started for {}\", task);\n \n-            TaskExec execution = execute(task);\n+            TaskExec execution = execute(task, handler);\n \n             LOG.debug(\"Execution finished for {}, {}\", task, execution);\n \n@@ -836,6 +843,18 @@ private boolean hasToBeregistered(final PropagationTask task,\n      * @return TaskExecution\n      */\n     public TaskExec execute(final PropagationTask task) {\n+        return execute(task, null);\n+    }\n+\n+    /**\n+     * Execute a propagation task.\n+     *\n+     * @param task to execute.\n+     * @param handler propagation handler.\n+     * @return TaskExecution.\n+     */\n+    public TaskExec execute(\n+            final PropagationTask task, final PropagationHandler handler) {\n         final Date startDate = new Date();\n \n         TaskExec execution = new TaskExec();\n@@ -846,6 +865,9 @@ public TaskExec execute(final PropagationTask task) {\n         // Flag to state wether any propagation has been attempted\n         Set<String> propagationAttempted = new HashSet<String>();\n \n+        ConnectorObject before = null;\n+        ConnectorObject after = null;\n+\n         try {\n             final ConnInstance connInstance =\n                     task.getResource().getConnector();\n@@ -863,114 +885,111 @@ public TaskExec execute(final PropagationTask task) {\n             }\n \n             // Try to read user BEFORE any actual operation\n-            ConnectorObject remoteObject = null;\n+            before = getRemoteObject(connector, task, false);\n+\n             try {\n-                remoteObject = connector.getObject(\n-                        task.getPropagationMode(),\n-                        task.getPropagationOperation(),\n-                        ObjectClass.ACCOUNT,\n-                        new Uid(task.getOldAccountId() == null\n-                        ? task.getAccountId()\n-                        : task.getOldAccountId()),\n-                        null);\n-            } catch (RuntimeException ignore) {\n-                LOG.debug(\"To be ignored, when resolving \"\n-                        + \"username on connector\", ignore);\n-            }\n+                switch (task.getPropagationOperation()) {\n+                    case CREATE:\n+                    case UPDATE:\n+                        // set of attributes to be propagated\n+                        final Set<Attribute> attributes =\n+                                new HashSet<Attribute>(task.getAttributes());\n \n-            switch (task.getPropagationOperation()) {\n-                case CREATE:\n-                case UPDATE:\n-                    // set of attributes to be propagated\n-                    final Set<Attribute> attributes =\n-                            new HashSet<Attribute>(task.getAttributes());\n+                        if (before != null) {\n \n-                    if (remoteObject != null) {\n+                            // 1. check if rename is really required\n+                            final Name newName = (Name) AttributeUtil.find(\n+                                    Name.NAME, attributes);\n \n-                        // 1. check if rename is really required\n-                        final Name newName = (Name) AttributeUtil.find(\n-                                Name.NAME, attributes);\n+                            LOG.debug(\"Rename required with value {}\", newName);\n \n-                        LOG.debug(\"Rename required with value {}\", newName);\n+                            if (newName != null\n+                                    && newName.equals(before.getName())\n+                                    && !before.getUid().getUidValue().equals(\n+                                    newName.getNameValue())) {\n \n-                        if (newName != null\n-                                && newName.equals(remoteObject.getName())\n-                                && !remoteObject.getUid().getUidValue().equals(\n-                                newName.getNameValue())) {\n+                                LOG.debug(\"Remote object name unchanged\");\n+                                attributes.remove(newName);\n+                            }\n \n-                            LOG.debug(\"Remote object name unchanged\");\n-                            attributes.remove(newName);\n+                            LOG.debug(\"Attributes to be replaced {}\", attributes);\n+\n+                            // 2. update with a new \"normalized\" attribute set\n+                            connector.update(\n+                                    task.getPropagationMode(),\n+                                    ObjectClass.ACCOUNT,\n+                                    before.getUid(),\n+                                    attributes,\n+                                    null,\n+                                    propagationAttempted);\n+                        } else {\n+                            // 1. get accountId\n+                            final String accountId = task.getAccountId();\n+\n+                            // 2. get name\n+                            final Name name = (Name) AttributeUtil.find(\n+                                    Name.NAME, attributes);\n+\n+                            // 3. check if:\n+                            //      * accountId is not blank;\n+                            //      * accountId is not equal to Name.\n+                            if (StringUtils.hasText(accountId)\n+                                    && (name == null\n+                                    || !accountId.equals(name.getNameValue()))) {\n+\n+                                // 3.a retrieve uid\n+                                final Uid uid = (Uid) AttributeUtil.find(\n+                                        Uid.NAME, attributes);\n+\n+                                // 3.b add Uid if not provided\n+                                if (uid == null) {\n+                                    attributes.add(AttributeBuilder.build(\n+                                            Uid.NAME,\n+                                            Collections.singleton(accountId)));\n+                                }\n+                            }\n+\n+                            // 4. provision entry\n+                            connector.create(\n+                                    task.getPropagationMode(),\n+                                    ObjectClass.ACCOUNT,\n+                                    attributes,\n+                                    null,\n+                                    propagationAttempted);\n+                        }\n+                        break;\n+\n+                    case DELETE:\n+                        if (before == null) {\n+                            LOG.debug(\"{} not found on external resource:\"\n+                                    + \" ignoring delete\", task.getAccountId());\n+                        } else {\n+                            connector.delete(task.getPropagationMode(),\n+                                    ObjectClass.ACCOUNT,\n+                                    before.getUid(),\n+                                    null,\n+                                    propagationAttempted);\n                         }\n+                        break;\n \n-                        LOG.debug(\"Attributes to be replaced {}\", attributes);\n+                    default:\n+                }\n \n-                        // 2. update with a new \"normalized\" attribute set\n-                        connector.update(\n-                                task.getPropagationMode(),\n-                                ObjectClass.ACCOUNT,\n-                                remoteObject.getUid(),\n-                                attributes,\n-                                null,\n-                                propagationAttempted);\n-                    } else {\n-                        // 1. get accountId\n-                        final String accountId = task.getAccountId();\n-\n-                        // 2. get name\n-                        final Name name = (Name) AttributeUtil.find(\n-                                Name.NAME, attributes);\n-\n-                        // 3. check if accountId is not blank and is not equal\n-                        // to Name\n-                        if (StringUtils.hasText(accountId)\n-                                && (name == null\n-                                || !accountId.equals(name.getNameValue()))) {\n-\n-                            // 3.a retrieve uid\n-                            final Uid uid = (Uid) AttributeUtil.find(\n-                                    Uid.NAME, attributes);\n-\n-                            // 3.b add Uid if not provided\n-                            if (uid == null) {\n-                                attributes.add(AttributeBuilder.build(\n-                                        Uid.NAME,\n-                                        Collections.singleton(accountId)));\n-                            }\n-                        }\n+                execution.setStatus(\n+                        task.getPropagationMode() == PropagationMode.ONE_PHASE\n+                        ? PropagationTaskExecStatus.SUCCESS.name()\n+                        : PropagationTaskExecStatus.SUBMITTED.name());\n \n-                        // 4. provision entry\n-                        connector.create(\n-                                task.getPropagationMode(),\n-                                ObjectClass.ACCOUNT,\n-                                attributes,\n-                                null,\n-                                propagationAttempted);\n-                    }\n-                    break;\n+                LOG.debug(\"Successfully propagated to {}\", task.getResource());\n \n-                case DELETE:\n-                    if (remoteObject == null) {\n-                        LOG.debug(\"{} not found on external resource:\"\n-                                + \" ignoring delete\", task.getAccountId());\n-                    } else {\n-                        connector.delete(task.getPropagationMode(),\n-                                ObjectClass.ACCOUNT,\n-                                remoteObject.getUid(),\n-                                null,\n-                                propagationAttempted);\n-                    }\n-                    break;\n+                // Try to read user AFTER any actual operation\n+                after = getRemoteObject(connector, task, true);\n \n-                default:\n+            } catch (Exception e) {\n+                after = getRemoteObject(connector, task, false);\n+                throw e;\n             }\n \n-            execution.setStatus(\n-                    task.getPropagationMode() == PropagationMode.ONE_PHASE\n-                    ? PropagationTaskExecStatus.SUCCESS.name()\n-                    : PropagationTaskExecStatus.SUBMITTED.name());\n-\n-            LOG.debug(\"Successfully propagated to resource {}\",\n-                    task.getResource());\n         } catch (Throwable t) {\n             LOG.error(\"Exception during provision on resource \"\n                     + task.getResource().getName(), t);\n@@ -1016,6 +1035,41 @@ public TaskExec execute(final PropagationTask task) {\n             }\n         }\n \n+        if (handler != null) {\n+            handler.handle(\n+                    task.getResource().getName(),\n+                    PropagationTaskExecStatus.valueOf(execution.getStatus()),\n+                    before,\n+                    after);\n+        }\n+\n         return execution;\n     }\n+\n+    /**\n+     * Get remote object.\n+     *\n+     * @param connector connector facade proxy.\n+     * @param task current propagation task.\n+     * @param latest 'FALSE' to retrieve object using old accountId if not null.\n+     * @return remote connector object.\n+     */\n+    private ConnectorObject getRemoteObject(\n+            final ConnectorFacadeProxy connector,\n+            final PropagationTask task,\n+            final boolean latest) {\n+        try {\n+            return connector.getObject(\n+                    task.getPropagationMode(),\n+                    task.getPropagationOperation(),\n+                    ObjectClass.ACCOUNT,\n+                    new Uid(latest || task.getOldAccountId() == null\n+                    ? task.getAccountId()\n+                    : task.getOldAccountId()),\n+                    null);\n+        } catch (RuntimeException ignore) {\n+            LOG.debug(\"Resolving username\", ignore);\n+            return null;\n+        }\n+    }\n }"},{"sha":"3453571e09a56d047d855e5463e7f162362f864d","filename":"core/src/main/java/org/syncope/core/rest/controller/ResourceController.java","status":"modified","additions":5,"deletions":17,"changes":22,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/35bb81b807e59b4383a8d87f955783af1931dd63/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Frest%2Fcontroller%2FResourceController.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/35bb81b807e59b4383a8d87f955783af1931dd63/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Frest%2Fcontroller%2FResourceController.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Frest%2Fcontroller%2FResourceController.java?ref=35bb81b807e59b4383a8d87f955783af1931dd63","patch":"@@ -34,7 +34,6 @@\n import org.springframework.web.bind.annotation.RequestBody;\n import org.springframework.web.bind.annotation.RequestMapping;\n import org.springframework.web.bind.annotation.RequestMethod;\n-import org.syncope.client.to.AttributeTO;\n import org.syncope.client.to.ConnObjectTO;\n import org.syncope.client.to.ResourceTO;\n import org.syncope.client.to.SchemaMappingTO;\n@@ -46,6 +45,7 @@\n import org.syncope.core.persistence.dao.ResourceDAO;\n import org.syncope.core.persistence.dao.RoleDAO;\n import org.syncope.core.propagation.ConnectorFacadeProxy;\n+import org.syncope.core.rest.data.ConnInstanceDataBinder;\n import org.syncope.core.rest.data.ResourceDataBinder;\n import org.syncope.types.SyncopeClientExceptionType;\n \n@@ -62,6 +62,9 @@ public class ResourceController extends AbstractController {\n     @Autowired\n     private ResourceDataBinder binder;\n \n+    @Autowired\n+    private ConnInstanceDataBinder connInstanceDataBinder;\n+\n     @Autowired\n     private ConnInstanceLoader connLoader;\n \n@@ -278,21 +281,6 @@ public ConnObjectTO getObject(final HttpServletResponse response,\n             attributes.add(connectorObject.getName());\n         }\n \n-        final ConnObjectTO connObjectTO = new ConnObjectTO();\n-\n-        for (Attribute attr : attributes) {\n-            AttributeTO attrTO = new AttributeTO();\n-            attrTO.setSchema(attr.getName());\n-\n-            if (attr.getValue() != null) {\n-                for (Object value : attr.getValue()) {\n-                    attrTO.addValue(value.toString());\n-                }\n-            }\n-\n-            connObjectTO.addAttribute(attrTO);\n-        }\n-\n-        return connObjectTO;\n+        return connInstanceDataBinder.getConnObjectTO(connectorObject);\n     }\n }"},{"sha":"0e7ff2054c4286196d93401a8eeb78122a71cb05","filename":"core/src/main/java/org/syncope/core/rest/controller/UserController.java","status":"modified","additions":119,"deletions":20,"changes":139,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/35bb81b807e59b4383a8d87f955783af1931dd63/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Frest%2Fcontroller%2FUserController.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/35bb81b807e59b4383a8d87f955783af1931dd63/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Frest%2Fcontroller%2FUserController.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Frest%2Fcontroller%2FUserController.java?ref=35bb81b807e59b4383a8d87f955783af1931dd63","patch":"@@ -32,6 +32,7 @@\n import java.util.Set;\n import javassist.NotFoundException;\n import javax.servlet.http.HttpServletResponse;\n+import org.identityconnectors.framework.common.objects.ConnectorObject;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.springframework.security.access.prepost.PreAuthorize;\n@@ -41,19 +42,23 @@\n import org.syncope.client.mod.UserMod;\n import org.syncope.client.search.NodeCond;\n import org.syncope.client.to.MembershipTO;\n+import org.syncope.client.to.PropagationTO;\n import org.syncope.client.to.UserTO;\n import org.syncope.client.to.WorkflowFormTO;\n import org.syncope.core.notification.NotificationManager;\n import org.syncope.core.persistence.beans.PropagationTask;\n import org.syncope.core.persistence.dao.UserSearchDAO;\n+import org.syncope.core.propagation.PropagationHandler;\n import org.syncope.core.propagation.PropagationManager;\n+import org.syncope.core.rest.data.ConnInstanceDataBinder;\n import org.syncope.core.util.EntitlementUtil;\n import org.syncope.core.workflow.UserWorkflowAdapter;\n import org.syncope.core.workflow.WorkflowException;\n import org.syncope.core.workflow.WorkflowResult;\n+import org.syncope.types.PropagationTaskExecStatus;\n \n /**\n- * Note that this controller does not extend AbstractController, hence does not \n+ * Note that this controller does not extend AbstractController, hence does not\n  * provide any Spring's @Transactional logic at class level.\n  *\n  * @see AbstractController\n@@ -75,7 +80,10 @@ public class UserController {\n     private UserSearchDAO searchDAO;\n \n     @Autowired\n-    private UserDataBinder dataBinder;\n+    private UserDataBinder userDataBinder;\n+\n+    @Autowired\n+    private ConnInstanceDataBinder connInstanceDataBinder;\n \n     @Autowired\n     private UserWorkflowAdapter wfAdapter;\n@@ -95,7 +103,7 @@ public ModelAndView verifyPassword(@PathVariable(\"userId\") Long userId,\n             throws NotFoundException, UnauthorizedRoleException {\n \n         return new ModelAndView().addObject(\n-                dataBinder.verifyPassword(userId, password));\n+                userDataBinder.verifyPassword(userId, password));\n     }\n \n     @PreAuthorize(\"hasRole('USER_LIST')\")\n@@ -137,7 +145,7 @@ public List<UserTO> list() {\n                 EntitlementUtil.getOwnedEntitlementNames()));\n         List<UserTO> userTOs = new ArrayList<UserTO>(users.size());\n         for (SyncopeUser user : users) {\n-            userTOs.add(dataBinder.getUserTO(user));\n+            userTOs.add(userDataBinder.getUserTO(user));\n         }\n \n         return userTOs;\n@@ -157,7 +165,7 @@ public List<UserTO> list(\n         List<SyncopeUser> users = userDAO.findAll(adminRoleIds, page, size);\n         List<UserTO> userTOs = new ArrayList<UserTO>(users.size());\n         for (SyncopeUser user : users) {\n-            userTOs.add(dataBinder.getUserTO(user));\n+            userTOs.add(userDataBinder.getUserTO(user));\n         }\n \n         return userTOs;\n@@ -170,7 +178,7 @@ public List<UserTO> list(\n     public UserTO read(@PathVariable(\"userId\") final Long userId)\n             throws NotFoundException, UnauthorizedRoleException {\n \n-        return dataBinder.getUserTO(userId);\n+        return userDataBinder.getUserTO(userId);\n     }\n \n     @PreAuthorize(\"hasRole('USER_READ')\")\n@@ -180,7 +188,7 @@ public UserTO read(@PathVariable(\"userId\") final Long userId)\n     public UserTO read(@RequestParam(\"username\") final String username)\n             throws NotFoundException, UnauthorizedRoleException {\n \n-        return dataBinder.getUserTO(username);\n+        return userDataBinder.getUserTO(username);\n     }\n \n     @PreAuthorize(\"hasRole('USER_READ')\")\n@@ -202,7 +210,7 @@ public List<UserTO> search(@RequestBody final NodeCond searchCondition)\n                 getOwnedEntitlementNames()), searchCondition);\n         List<UserTO> result = new ArrayList<UserTO>(matchingUsers.size());\n         for (SyncopeUser user : matchingUsers) {\n-            result.add(dataBinder.getUserTO(user));\n+            result.add(userDataBinder.getUserTO(user));\n         }\n \n         return result;\n@@ -232,7 +240,7 @@ public List<UserTO> search(\n \n         final List<UserTO> result = new ArrayList<UserTO>(matchingUsers.size());\n         for (SyncopeUser user : matchingUsers) {\n-            result.add(dataBinder.getUserTO(user));\n+            result.add(userDataBinder.getUserTO(user));\n         }\n \n         return result;\n@@ -265,16 +273,46 @@ public UserTO create(final HttpServletResponse response,\n \n         List<PropagationTask> tasks = propagationManager.getCreateTaskIds(\n                 created, userTO.getPassword(), userTO.getVirtualAttributes());\n-        propagationManager.execute(tasks);\n+\n+        final List<PropagationTO> propagations = new ArrayList<PropagationTO>();\n+\n+        propagationManager.execute(tasks, new PropagationHandler() {\n+\n+            @Override\n+            public void handle(\n+                    final String resourceName,\n+                    final PropagationTaskExecStatus executionStatus,\n+                    final ConnectorObject before,\n+                    final ConnectorObject after) {\n+\n+                final PropagationTO propagation = new PropagationTO();\n+                propagation.setResourceName(resourceName);\n+                propagation.setStatus(executionStatus);\n+\n+                if (before != null) {\n+                    propagation.setBefore(\n+                            connInstanceDataBinder.getConnObjectTO(before));\n+                }\n+\n+                if (after != null) {\n+                    propagation.setBefore(\n+                            connInstanceDataBinder.getConnObjectTO(after));\n+                }\n+\n+                propagations.add(propagation);\n+            }\n+        });\n \n         notificationManager.createTasks(new WorkflowResult<Long>(\n                 created.getResult().getKey(),\n                 created.getPropByRes(),\n                 created.getPerformedTasks()));\n \n-        final UserTO savedTO = dataBinder.getUserTO(\n+        final UserTO savedTO = userDataBinder.getUserTO(\n                 created.getResult().getKey());\n \n+        savedTO.setPropagationTOs(propagations);\n+\n         LOG.debug(\"About to return created user\\n{}\", savedTO);\n \n         response.setStatus(HttpServletResponse.SC_CREATED);\n@@ -296,12 +334,42 @@ public UserTO update(@RequestBody final UserMod userMod)\n                 updated, userMod.getPassword(),\n                 userMod.getVirtualAttributesToBeRemoved(),\n                 userMod.getVirtualAttributesToBeUpdated(), null);\n-        propagationManager.execute(tasks);\n+\n+        final List<PropagationTO> propagations = new ArrayList<PropagationTO>();\n+\n+        propagationManager.execute(tasks, new PropagationHandler() {\n+\n+            @Override\n+            public void handle(\n+                    final String resourceName,\n+                    final PropagationTaskExecStatus executionStatus,\n+                    final ConnectorObject before,\n+                    final ConnectorObject after) {\n+\n+                final PropagationTO propagation = new PropagationTO();\n+                propagation.setResourceName(resourceName);\n+                propagation.setStatus(executionStatus);\n+\n+                if (before != null) {\n+                    propagation.setBefore(\n+                            connInstanceDataBinder.getConnObjectTO(before));\n+                }\n+\n+                if (after != null) {\n+                    propagation.setBefore(\n+                            connInstanceDataBinder.getConnObjectTO(after));\n+                }\n+\n+                propagations.add(propagation);\n+            }\n+        });\n \n         notificationManager.createTasks(updated);\n \n         final UserTO updatedTO =\n-                dataBinder.getUserTO(updated.getResult());\n+                userDataBinder.getUserTO(updated.getResult());\n+\n+        updatedTO.setPropagationTOs(propagations);\n \n         LOG.debug(\"About to return updated user\\n{}\", updatedTO);\n \n@@ -400,9 +468,9 @@ public UserTO reactivate(final @PathVariable(\"userId\") Long userId,\n     }\n \n     @PreAuthorize(\"hasRole('USER_DELETE')\")\n-    @RequestMapping(method = RequestMethod.DELETE,\n+    @RequestMapping(method = RequestMethod.GET,\n     value = \"/delete/{userId}\")\n-    public void delete(@PathVariable(\"userId\") final Long userId)\n+    public UserTO delete(@PathVariable(\"userId\") final Long userId)\n             throws NotFoundException, WorkflowException, PropagationException,\n             UnauthorizedRoleException {\n \n@@ -418,11 +486,42 @@ public void delete(@PathVariable(\"userId\") final Long userId)\n \n         List<PropagationTask> tasks =\n                 propagationManager.getDeleteTaskIds(userId);\n-        propagationManager.execute(tasks);\n+\n+        final UserTO userTO = new UserTO();\n+        userTO.setId(userId);\n+\n+        propagationManager.execute(tasks, new PropagationHandler() {\n+\n+            @Override\n+            public void handle(\n+                    final String resourceName,\n+                    final PropagationTaskExecStatus executionStatus,\n+                    final ConnectorObject before,\n+                    final ConnectorObject after) {\n+\n+                final PropagationTO propagation = new PropagationTO();\n+                propagation.setResourceName(resourceName);\n+                propagation.setStatus(executionStatus);\n+\n+                if (before != null) {\n+                    propagation.setBefore(\n+                            connInstanceDataBinder.getConnObjectTO(before));\n+                }\n+\n+                if (after != null) {\n+                    propagation.setBefore(\n+                            connInstanceDataBinder.getConnObjectTO(after));\n+                }\n+\n+                userTO.addPropagationTO(propagation);\n+            }\n+        });\n \n         wfAdapter.delete(userId);\n \n         LOG.debug(\"User successfully deleted: {}\", userId);\n+\n+        return userTO;\n     }\n \n     @PreAuthorize(\"hasRole('USER_UPDATE')\")\n@@ -445,7 +544,7 @@ public UserTO executeWorkflow(\n \n         notificationManager.createTasks(updated);\n \n-        final UserTO savedTO = dataBinder.getUserTO(updated.getResult());\n+        final UserTO savedTO = userDataBinder.getUserTO(updated.getResult());\n \n         LOG.debug(\"About to return updated user\\n{}\", savedTO);\n \n@@ -469,7 +568,7 @@ public WorkflowFormTO getFormForUser(\n             throws UnauthorizedRoleException, NotFoundException,\n             WorkflowException {\n \n-        SyncopeUser user = dataBinder.getUserFromId(userId);\n+        SyncopeUser user = userDataBinder.getUserFromId(userId);\n         return wfAdapter.getForm(user.getWorkflowId());\n     }\n \n@@ -505,7 +604,7 @@ public UserTO submitForm(@RequestBody final WorkflowFormTO form)\n                 updated.getResult().getValue(), null, null, Boolean.TRUE);\n         propagationManager.execute(tasks);\n \n-        final UserTO savedTO = dataBinder.getUserTO(\n+        final UserTO savedTO = userDataBinder.getUserTO(\n                 updated.getResult().getKey());\n \n         LOG.debug(\"About to return user after form processing\\n{}\", savedTO);\n@@ -559,7 +658,7 @@ private UserTO setStatus(\n         propagationManager.execute(tasks);\n         notificationManager.createTasks(updated);\n \n-        final UserTO savedTO = dataBinder.getUserTO(updated.getResult());\n+        final UserTO savedTO = userDataBinder.getUserTO(updated.getResult());\n \n         LOG.debug(\"About to return suspended user\\n{}\", savedTO);\n "},{"sha":"b3f9ed30b0c0c69bce6415b54f73c744ead69db5","filename":"core/src/main/java/org/syncope/core/rest/data/ConnInstanceDataBinder.java","status":"modified","additions":31,"deletions":0,"changes":31,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/35bb81b807e59b4383a8d87f955783af1931dd63/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Frest%2Fdata%2FConnInstanceDataBinder.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/35bb81b807e59b4383a8d87f955783af1931dd63/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Frest%2Fdata%2FConnInstanceDataBinder.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Frest%2Fdata%2FConnInstanceDataBinder.java?ref=35bb81b807e59b4383a8d87f955783af1931dd63","patch":"@@ -18,11 +18,15 @@\n import javassist.NotFoundException;\n import org.identityconnectors.framework.api.ConfigurationProperties;\n import org.identityconnectors.framework.api.ConfigurationProperty;\n+import org.identityconnectors.framework.common.objects.Attribute;\n+import org.identityconnectors.framework.common.objects.ConnectorObject;\n import org.springframework.beans.BeanUtils;\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.http.HttpStatus;\n import org.springframework.stereotype.Component;\n+import org.syncope.client.to.AttributeTO;\n import org.syncope.client.to.ConnInstanceTO;\n+import org.syncope.client.to.ConnObjectTO;\n import org.syncope.client.validation.SyncopeClientCompositeErrorException;\n import org.syncope.client.validation.SyncopeClientException;\n import org.syncope.core.persistence.beans.ConnInstance;\n@@ -197,4 +201,31 @@ public ConnInstanceTO getConnInstanceTO(final ConnInstance connInstance)\n         }\n         return connInstanceTO;\n     }\n+\n+    /**\n+     * Get connector object TO from a connector object.\n+     *\n+     * @param connObject connector object.\n+     * @return connector object TO.\n+     */\n+    public ConnObjectTO getConnObjectTO(final ConnectorObject connObject) {\n+        final ConnObjectTO connObjectTO = new ConnObjectTO();\n+\n+        for (Attribute attr : connObject.getAttributes()) {\n+            AttributeTO attrTO = new AttributeTO();\n+            attrTO.setSchema(attr.getName());\n+\n+            if (attr.getValue() != null) {\n+                for (Object value : attr.getValue()) {\n+                    if (value != null) {\n+                        attrTO.addValue(value.toString());\n+                    }\n+                }\n+            }\n+\n+            connObjectTO.addAttribute(attrTO);\n+        }\n+\n+        return connObjectTO;\n+    }\n }"},{"sha":"6bdb939933255b1b0828b9171dd40501c9144e2b","filename":"core/src/main/java/org/syncope/core/rest/data/UserDataBinder.java","status":"modified","additions":0,"deletions":9,"changes":9,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/35bb81b807e59b4383a8d87f955783af1931dd63/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Frest%2Fdata%2FUserDataBinder.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/35bb81b807e59b4383a8d87f955783af1931dd63/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Frest%2Fdata%2FUserDataBinder.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Frest%2Fdata%2FUserDataBinder.java?ref=35bb81b807e59b4383a8d87f955783af1931dd63","patch":"@@ -425,15 +425,6 @@ public UserTO getUserTO(final SyncopeUser user) {\n             userTO.addMembership(membershipTO);\n         }\n \n-        for (ExternalResource resource : user.getResources()) {\n-            for (PropagationTask task : taskDAO.findAll(resource, user)) {\n-                TaskExec exec = taskExecDAO.findLatestStarted(task);\n-                userTO.addPropagationStatus(resource.getName(),\n-                        exec == null ? null\n-                        : PropagationTaskExecStatus.valueOf(exec.getStatus()));\n-            }\n-        }\n-\n         return userTO;\n     }\n "},{"sha":"d6c48983ca6fc5f0aa8e98b3be909e57ea7cdd21","filename":"core/src/main/java/org/syncope/core/scheduling/DefaultSyncJobActions.java","status":"modified","additions":5,"deletions":2,"changes":7,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/35bb81b807e59b4383a8d87f955783af1931dd63/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Fscheduling%2FDefaultSyncJobActions.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/35bb81b807e59b4383a8d87f955783af1931dd63/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Fscheduling%2FDefaultSyncJobActions.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Fscheduling%2FDefaultSyncJobActions.java?ref=35bb81b807e59b4383a8d87f955783af1931dd63","patch":"@@ -18,15 +18,17 @@\n import org.quartz.JobExecutionException;\n import org.syncope.client.mod.UserMod;\n import org.syncope.client.to.UserTO;\n+import org.syncope.core.persistence.beans.SyncTask;\n \n /**\n  * Default (empty) implementation of SyncJobActions.\n+ *\n  * @see SyncJobActions\n  */\n public class DefaultSyncJobActions implements SyncJobActions {\n \n     @Override\n-    public void beforeAll(final List<SyncDelta> deltas)\n+    public void beforeAll(final SyncTask task)\n             throws JobExecutionException {\n     }\n \n@@ -52,7 +54,8 @@ public void after(final SyncDelta delta, final UserTO user,\n     }\n \n     @Override\n-    public void afterAll(final List<SyncDelta> deltas,\n+    public void afterAll(\n+            final SyncTask task,\n             final List<SyncResult> results)\n             throws JobExecutionException {\n     }"},{"sha":"9aab6f2c1d3190ed2e4a8e9e42722365066b21db","filename":"core/src/main/java/org/syncope/core/scheduling/SyncJob.java","status":"modified","additions":156,"deletions":97,"changes":253,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/35bb81b807e59b4383a8d87f955783af1931dd63/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Fscheduling%2FSyncJob.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/35bb81b807e59b4383a8d87f955783af1931dd63/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Fscheduling%2FSyncJob.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Fscheduling%2FSyncJob.java?ref=35bb81b807e59b4383a8d87f955783af1931dd63","patch":"@@ -29,6 +29,7 @@\n import org.identityconnectors.framework.common.objects.ObjectClass;\n import org.identityconnectors.framework.common.objects.OperationalAttributes;\n import org.identityconnectors.framework.common.objects.SyncDelta;\n+import org.identityconnectors.framework.common.objects.SyncResultsHandler;\n import org.identityconnectors.framework.common.objects.Uid;\n import org.quartz.JobExecutionException;\n import org.springframework.beans.factory.annotation.Autowired;\n@@ -618,7 +619,7 @@ private SyncResult createUser(final SyncDelta delta, final boolean dryRun)\n         result.setOperation(Operation.CREATE);\n \n         UserTO userTO = getUserTO(delta.getObject());\n-        \n+\n         actions.beforeCreate(delta, userTO);\n \n         if (dryRun) {\n@@ -699,7 +700,7 @@ private void updateUsers(final SyncDelta delta,\n \n                     final UserMod userMod =\n                             getUserMod(userId, delta.getObject());\n-                    \n+\n                     actions.beforeUpdate(delta, userTO, userMod);\n \n                     result.setStatus(Status.SUCCESS);\n@@ -962,16 +963,76 @@ protected String doExecute(final boolean dryRun)\n             throw new JobExecutionException(msg, e);\n         }\n \n+        final SchemaMapping accountIdMap =\n+                syncTask.getResource().getAccountIdMapping();\n+\n+        if (accountIdMap == null) {\n+            throw new JobExecutionException(\n+                    \"Invalid account id mapping for resource \"\n+                    + syncTask.getResource());\n+        }\n+\n         LOG.debug(\"Execute synchronization with token {}\",\n                 syncTask.getResource().getSyncToken() != null\n                 ? syncTask.getResource().getSyncToken().getValue() : null);\n \n-        final List<SyncDelta> deltas;\n+        final List<SyncResult> results = new ArrayList<SyncResult>();\n+\n+        actions.beforeAll(syncTask);\n+\n         try {\n+            final SyncPolicy syncPolicy =\n+                    syncTask.getResource().getSyncPolicy();\n+\n+            final ConflictResolutionAction conflictResolutionAction =\n+                    syncPolicy != null && syncPolicy.getSpecification() != null\n+                    ? ((SyncPolicySpec) syncPolicy.getSpecification()).\n+                    getConflictResolutionAction()\n+                    : ConflictResolutionAction.IGNORE;\n+\n             if (syncTask.isFullReconciliation()) {\n-                deltas = connector.getAllObjects(ObjectClass.ACCOUNT, null);\n+                connector.getAllObjects(\n+                        ObjectClass.ACCOUNT,\n+                        new SyncResultsHandler() {\n+\n+                            @Override\n+                            public boolean handle(final SyncDelta delta) {\n+                                try {\n+\n+                                    return results.addAll(handleDelta(\n+                                            syncTask,\n+                                            delta,\n+                                            conflictResolutionAction,\n+                                            dryRun));\n+\n+                                } catch (JobExecutionException e) {\n+                                    LOG.error(\"Reconciliation failed\", e);\n+                                    return false;\n+                                }\n+                            }\n+                        },\n+                        null);\n             } else {\n-                deltas = connector.sync(syncTask.getResource().getSyncToken());\n+                connector.sync(\n+                        syncTask.getResource().getSyncToken(),\n+                        new SyncResultsHandler() {\n+\n+                            @Override\n+                            public boolean handle(final SyncDelta delta) {\n+                                try {\n+\n+                                    return results.addAll(handleDelta(\n+                                            syncTask,\n+                                            delta,\n+                                            conflictResolutionAction,\n+                                            dryRun));\n+\n+                                } catch (JobExecutionException e) {\n+                                    LOG.error(\"Synchronization failed\", e);\n+                                    return false;\n+                                }\n+                            }\n+                        });\n             }\n \n             if (!dryRun && !syncTask.isFullReconciliation()) {\n@@ -991,114 +1052,112 @@ protected String doExecute(final boolean dryRun)\n             throw new JobExecutionException(\"While syncing on connector\", t);\n         }\n \n-        LOG.debug(\"Retrieved {} changes to synchronize\", deltas.size());\n+        actions.afterAll(syncTask, results);\n \n-        final SchemaMapping accountIdMap =\n-                syncTask.getResource().getAccountIdMapping();\n+        final String result = createReport(\n+                results, syncTask.getResource().getSyncTraceLevel(), dryRun);\n \n-        if (accountIdMap == null) {\n-            throw new JobExecutionException(\n-                    \"Invalid account id mapping for resource \"\n-                    + syncTask.getResource());\n-        }\n+        LOG.debug(\"Sync result: {}\", result);\n \n-        final SyncPolicy syncPolicy = syncTask.getResource().getSyncPolicy();\n-        final ConflictResolutionAction conflictResolutionAction =\n-                syncPolicy != null && syncPolicy.getSpecification() != null\n-                ? ((SyncPolicySpec) syncPolicy.getSpecification()).\n-                getConflictResolutionAction()\n-                : ConflictResolutionAction.IGNORE;\n+        return result.toString();\n+    }\n+\n+    /**\n+     * Handle delatas.\n+     *\n+     * @param syncTask sync task.\n+     * @param delta delta.\n+     * @param conflictResolutionAction conflict resolution action.\n+     * @param dryRun dry run.\n+     * @return list of synchronization results.\n+     * @throws JobExecutionException in case of synchronization failure.\n+     */\n+    protected final List<SyncResult> handleDelta(\n+            final SyncTask syncTask,\n+            final SyncDelta delta,\n+            final ConflictResolutionAction conflictResolutionAction,\n+            final boolean dryRun)\n+            throws JobExecutionException {\n \n         final List<SyncResult> results = new ArrayList<SyncResult>();\n \n-        actions.beforeAll(deltas);\n-\n-        for (SyncDelta delta : deltas) {\n-            LOG.debug(\"Process '{}' for '{}'\",\n-                    delta.getDeltaType(), delta.getUid().getUidValue());\n-\n-            List<Long> users = findExistingUsers(delta);\n-            \n-            switch (delta.getDeltaType()) {\n-                case CREATE_OR_UPDATE:\n-                    if (users.isEmpty()) {\n-                        if (syncTask.isPerformCreate()) {\n-                            results.add(createUser(delta, dryRun));\n-                        } else {\n-                            LOG.debug(\"SyncTask not configured for create\");\n-                        }\n-                    } else if (users.size() == 1) {\n-                        updateUsers(delta, users.subList(0, 1),\n-                                dryRun, results);\n+        LOG.debug(\"Process '{}' for '{}'\",\n+                delta.getDeltaType(), delta.getUid().getUidValue());\n+\n+        final List<Long> users = findExistingUsers(delta);\n+\n+        switch (delta.getDeltaType()) {\n+            case CREATE_OR_UPDATE:\n+                if (users.isEmpty()) {\n+                    if (syncTask.isPerformCreate()) {\n+                        results.add(createUser(delta, dryRun));\n                     } else {\n-                        switch (conflictResolutionAction) {\n-                            case IGNORE:\n-                                LOG.error(\"More than one match {}\", users);\n-                                break;\n-\n-                            case FIRSTMATCH:\n-                                updateUsers(delta, users.subList(0, 1),\n-                                        dryRun, results);\n-                                break;\n-\n-                            case LASTMATCH:\n-                                updateUsers(delta, users.subList(users.size()\n-                                        - 1, users.size()), dryRun, results);\n-                                break;\n-\n-                            case ALL:\n-                                updateUsers(delta, users, dryRun, results);\n-                                break;\n-\n-                            default:\n-                        }\n+                        LOG.debug(\"SyncTask not configured for create\");\n                     }\n-                    break;\n+                } else if (users.size() == 1) {\n+                    updateUsers(delta, users.subList(0, 1),\n+                            dryRun, results);\n+                } else {\n+                    switch (conflictResolutionAction) {\n+                        case IGNORE:\n+                            LOG.error(\"More than one match {}\", users);\n+                            break;\n \n-                case DELETE:\n-                    if (users.isEmpty()) {\n-                        LOG.debug(\"No match found for deletion\");\n-                    } else if (users.size() == 1) {\n-                        deleteUsers(delta, users, dryRun, results);\n-                    } else {\n-                        switch (conflictResolutionAction) {\n-                            case IGNORE:\n-                                LOG.error(\"More than one match {}\", users);\n-                                break;\n-\n-                            case FIRSTMATCH:\n-                                deleteUsers(delta, users.subList(0, 1),\n-                                        dryRun, results);\n-                                break;\n-\n-                            case LASTMATCH:\n-                                deleteUsers(delta, users.subList(\n-                                        users.size() - 1, users.size()),\n-                                        dryRun, results);\n-                                break;\n-\n-                            case ALL:\n-                                deleteUsers(delta, users, dryRun, results);\n-                                break;\n-\n-                            default:\n-                        }\n+                        case FIRSTMATCH:\n+                            updateUsers(delta, users.subList(0, 1),\n+                                    dryRun, results);\n+                            break;\n+\n+                        case LASTMATCH:\n+                            updateUsers(delta, users.subList(users.size()\n+                                    - 1, users.size()), dryRun, results);\n+                            break;\n+\n+                        case ALL:\n+                            updateUsers(delta, users, dryRun, results);\n+                            break;\n+\n+                        default:\n                     }\n+                }\n+                break;\n \n-                    break;\n+            case DELETE:\n+                if (users.isEmpty()) {\n+                    LOG.debug(\"No match found for deletion\");\n+                } else if (users.size() == 1) {\n+                    deleteUsers(delta, users, dryRun, results);\n+                } else {\n+                    switch (conflictResolutionAction) {\n+                        case IGNORE:\n+                            LOG.error(\"More than one match {}\", users);\n+                            break;\n \n-                default:\n-            }\n-        }\n+                        case FIRSTMATCH:\n+                            deleteUsers(delta, users.subList(0, 1),\n+                                    dryRun, results);\n+                            break;\n \n-        actions.afterAll(deltas, results);\n+                        case LASTMATCH:\n+                            deleteUsers(delta, users.subList(\n+                                    users.size() - 1, users.size()),\n+                                    dryRun, results);\n+                            break;\n \n-        final String result = createReport(\n-                results, syncTask.getResource().getSyncTraceLevel(), dryRun);\n+                        case ALL:\n+                            deleteUsers(delta, users, dryRun, results);\n+                            break;\n \n-        LOG.debug(\"Sync result: {}\", result);\n+                        default:\n+                    }\n+                }\n \n-        return result.toString();\n+                break;\n+\n+            default:\n+        }\n+\n+        return results;\n     }\n \n     /**"},{"sha":"2d91095bd8f308b465c57fa1dd65d518572b4f69","filename":"core/src/main/java/org/syncope/core/scheduling/SyncJobActions.java","status":"modified","additions":3,"deletions":2,"changes":5,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/35bb81b807e59b4383a8d87f955783af1931dd63/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Fscheduling%2FSyncJobActions.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/35bb81b807e59b4383a8d87f955783af1931dd63/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Fscheduling%2FSyncJobActions.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Fscheduling%2FSyncJobActions.java?ref=35bb81b807e59b4383a8d87f955783af1931dd63","patch":"@@ -18,13 +18,14 @@\n import org.quartz.JobExecutionException;\n import org.syncope.client.mod.UserMod;\n import org.syncope.client.to.UserTO;\n+import org.syncope.core.persistence.beans.SyncTask;\n \n /**\n  * Interface for actions to be performed during SyncJob execution.\n  */\n public interface SyncJobActions {\n \n-    void beforeAll(List<SyncDelta> deltas)\n+    void beforeAll(SyncTask task)\n             throws JobExecutionException;\n \n     void beforeCreate(SyncDelta delta, UserTO user)\n@@ -39,6 +40,6 @@ void beforeDelete(SyncDelta delta, UserTO user)\n     void after(SyncDelta delta, UserTO user, SyncResult result)\n             throws JobExecutionException;\n \n-    void afterAll(List<SyncDelta> deltas, List<SyncResult> results)\n+    void afterAll(SyncTask task, List<SyncResult> results)\n             throws JobExecutionException;\n }"},{"sha":"313317642204afcededa9befeb045450c698e0d5","filename":"core/src/test/java/org/syncope/core/rest/UserRequestTestITCase.java","status":"modified","additions":2,"deletions":3,"changes":5,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/35bb81b807e59b4383a8d87f955783af1931dd63/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fsyncope%2Fcore%2Frest%2FUserRequestTestITCase.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/35bb81b807e59b4383a8d87f955783af1931dd63/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fsyncope%2Fcore%2Frest%2FUserRequestTestITCase.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fsyncope%2Fcore%2Frest%2FUserRequestTestITCase.java?ref=35bb81b807e59b4383a8d87f955783af1931dd63","patch":"@@ -13,12 +13,10 @@\n  */\n package org.syncope.core.rest;\n \n-import java.security.Principal;\n import static org.junit.Assert.*;\n \n import java.util.Arrays;\n import java.util.List;\n-import org.apache.http.auth.Credentials;\n import org.apache.http.auth.UsernamePasswordCredentials;\n import org.apache.http.impl.client.DefaultHttpClient;\n import org.junit.Test;\n@@ -233,7 +231,8 @@ public void delete() {\n         assertNotNull(actual);\n \n         // 7. actually delete user\n-        restTemplate.delete(BASE_URL + \"user/delete/{userId}\", userTO.getId());\n+        restTemplate.getForObject(BASE_URL + \"user/delete/{userId}\",\n+                UserTO.class, userTO.getId());\n \n         // 8. user does not exist any more\n         try {"},{"sha":"01bc2b8fbaaa5c328d94e4f6dedc82088e3666c2","filename":"core/src/test/java/org/syncope/core/rest/UserTestITCase.java","status":"modified","additions":50,"deletions":31,"changes":81,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/35bb81b807e59b4383a8d87f955783af1931dd63/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fsyncope%2Fcore%2Frest%2FUserTestITCase.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/35bb81b807e59b4383a8d87f955783af1931dd63/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fsyncope%2Fcore%2Frest%2FUserTestITCase.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fsyncope%2Fcore%2Frest%2FUserTestITCase.java?ref=35bb81b807e59b4383a8d87f955783af1931dd63","patch":"@@ -46,6 +46,7 @@\n import org.syncope.client.to.ConnObjectTO;\n import org.syncope.client.to.PasswordPolicyTO;\n import org.syncope.client.to.PolicyTO;\n+import org.syncope.client.to.PropagationTO;\n import org.syncope.client.to.PropagationTaskTO;\n import org.syncope.client.to.ResourceTO;\n import org.syncope.client.to.UserTO;\n@@ -382,9 +383,9 @@ public void createUserWithDbPropagation() {\n         userTO = restTemplate.postForObject(BASE_URL + \"user/create\",\n                 userTO, UserTO.class);\n         assertNotNull(userTO);\n-        assertEquals(1, userTO.getPropagationStatusMap().size());\n-        assertEquals(PropagationTaskExecStatus.SUCCESS,\n-                userTO.getPropagationStatusMap().get(\"resource-testdb\"));\n+        assertEquals(1, userTO.getPropagationTOs().size());\n+        assertTrue(\n+                userTO.getPropagationTOs().get(0).getStatus().isSuccessful());\n     }\n \n     @Test(expected = SyncopeClientCompositeErrorException.class)\n@@ -736,7 +737,9 @@ public void createWithApproval() {\n         assertEquals(\"createApproval\", userTO.getStatus());\n         assertEquals(Collections.singleton(\"resource-testdb\"),\n                 userTO.getResources());\n-        assertTrue(userTO.getPropagationStatusMap().isEmpty());\n+\n+        assertTrue(userTO.getPropagationTOs().isEmpty());\n+\n         Exception exception = null;\n         try {\n             jdbcTemplate.queryForInt(\n@@ -767,13 +770,12 @@ public void createWithApproval() {\n         props.get(\"approve\").setValue(Boolean.TRUE.toString());\n         form.setProperties(props.values());\n         userTO = restTemplate.postForObject(\n-                BASE_URL + \"user/workflow/form/submit\",\n-                form, UserTO.class);\n+                BASE_URL + \"user/workflow/form/submit\", form, UserTO.class);\n         assertNotNull(userTO);\n         assertEquals(\"active\", userTO.getStatus());\n         assertEquals(Collections.singleton(\"resource-testdb\"),\n                 userTO.getResources());\n-        assertFalse(userTO.getPropagationStatusMap().isEmpty());\n+\n         exception = null;\n         try {\n             String username = jdbcTemplate.queryForObject(\n@@ -799,17 +801,34 @@ public void createWithApproval() {\n     @Test\n     public void delete() {\n         try {\n-            restTemplate.delete(BASE_URL + \"user/delete/{userId}\", 0);\n+            restTemplate.getForObject(\n+                    BASE_URL + \"user/delete/{userId}\", UserTO.class, 0);\n         } catch (HttpStatusCodeException e) {\n             assertEquals(HttpStatus.NOT_FOUND, e.getStatusCode());\n         }\n \n         UserTO userTO = getSampleTO(\"qqgf.z@nn.com\");\n \n-        userTO = restTemplate.postForObject(BASE_URL + \"user/create\",\n-                userTO, UserTO.class);\n+        // specify a propagation\n+        userTO.addResource(\"resource-testdb\");\n+\n+        userTO = restTemplate.postForObject(\n+                BASE_URL + \"user/create\", userTO, UserTO.class);\n+\n+        long id = userTO.getId();\n+\n+        userTO = restTemplate.getForObject(\n+                BASE_URL + \"user/delete/{userId}\", UserTO.class, id);\n+\n+        assertNotNull(userTO);\n+        assertEquals(id, userTO.getId());\n+        assertTrue(userTO.getAttributes().isEmpty());\n+\n+        // check for propagation result\n+        assertFalse(userTO.getPropagationTOs().isEmpty());\n+        assertTrue(\n+                userTO.getPropagationTOs().get(0).getStatus().isSuccessful());\n \n-        restTemplate.delete(BASE_URL + \"user/delete/{userId}\", userTO.getId());\n         try {\n             restTemplate.getForObject(BASE_URL + \"user/read/{userId}.json\",\n                     UserTO.class, userTO.getId());\n@@ -1310,8 +1329,8 @@ public void verifyTaskRegistration() {\n         // --------------------------------------\n         // Delete operation\n         // --------------------------------------\n-        restTemplate.delete(\n-                BASE_URL + \"user/delete/{userId}\", userTO.getId());\n+        restTemplate.getForObject(BASE_URL + \"user/delete/{userId}\",\n+                UserTO.class, userTO.getId());\n \n         // get the new task list\n         tasks = Arrays.asList(\n@@ -1574,18 +1593,18 @@ public final void issue280() {\n                 BASE_URL + \"user/update\", userMod, UserTO.class);\n         assertNotNull(userTO);\n \n-        final Map<String, PropagationTaskExecStatus> statuses =\n-                userTO.getPropagationStatusMap();\n+        final List<PropagationTO> propagations = userTO.getPropagationTOs();\n \n-        assertNotNull(statuses);\n-        assertEquals(1, statuses.size());\n+        assertNotNull(propagations);\n+        assertEquals(1, propagations.size());\n \n-        final PropagationTaskExecStatus exec =\n-                statuses.values().iterator().next();\n+        final PropagationTaskExecStatus status =\n+                propagations.get(0).getStatus();\n+        final String resource = propagations.get(0).getResourceName();\n \n-        assertNotNull(exec);\n-        assertEquals(\"resource-testdb\", statuses.keySet().iterator().next());\n-        assertTrue(exec.isSuccessful());\n+        assertNotNull(status);\n+        assertEquals(\"resource-testdb\", resource);\n+        assertTrue(status.isSuccessful());\n     }\n \n     @Test\n@@ -1600,18 +1619,18 @@ public void issue281() {\n                 BASE_URL + \"user/create\", userTO, UserTO.class);\n         assertNotNull(userTO);\n \n-        final Map<String, PropagationTaskExecStatus> statuses =\n-                userTO.getPropagationStatusMap();\n+        final List<PropagationTO> propagations = userTO.getPropagationTOs();\n \n-        assertNotNull(statuses);\n-        assertEquals(1, statuses.size());\n+        assertNotNull(propagations);\n+        assertEquals(1, propagations.size());\n \n-        final PropagationTaskExecStatus exec =\n-                statuses.values().iterator().next();\n+        final PropagationTaskExecStatus status =\n+                propagations.get(0).getStatus();\n+        final String resource = propagations.get(0).getResourceName();\n \n-        assertNotNull(exec);\n-        assertEquals(\"resource-csv\", statuses.keySet().iterator().next());\n-        assertFalse(exec.isSuccessful());\n+        assertNotNull(status);\n+        assertEquals(\"resource-csv\", resource);\n+        assertFalse(status.isSuccessful());\n     }\n \n     @Test"}]}