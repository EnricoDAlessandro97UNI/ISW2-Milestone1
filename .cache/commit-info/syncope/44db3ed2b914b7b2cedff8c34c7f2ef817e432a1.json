{"sha":"44db3ed2b914b7b2cedff8c34c7f2ef817e432a1","node_id":"MDY6Q29tbWl0NjM2ODc5MDYyOjQ0ZGIzZWQyYjkxNGI3YjJjZWRmZjhjMzRjN2YyZWY4MTdlNDMyYTE=","commit":{"author":{"name":"Francesco Chicchiriccò","email":"ilgrosso@apache.org","date":"2020-12-01T17:05:05Z"},"committer":{"name":"Francesco Chicchiriccò","email":"ilgrosso@apache.org","date":"2020-12-02T08:24:19Z"},"message":"[SYNCOPE-1605] Refactoring PropagationByResource (which drives Propagation) generation","tree":{"sha":"7468843b7b68b60094581a9f74bd6f3eb6bf4d10","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/git/trees/7468843b7b68b60094581a9f74bd6f3eb6bf4d10"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/git/commits/44db3ed2b914b7b2cedff8c34c7f2ef817e432a1","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/44db3ed2b914b7b2cedff8c34c7f2ef817e432a1","html_url":"https://github.com/EnricoDAlessandro97UNI/syncope/commit/44db3ed2b914b7b2cedff8c34c7f2ef817e432a1","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/44db3ed2b914b7b2cedff8c34c7f2ef817e432a1/comments","author":{"login":"ilgrosso","id":1064664,"node_id":"MDQ6VXNlcjEwNjQ2NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/1064664?v=4","gravatar_id":"","url":"https://api.github.com/users/ilgrosso","html_url":"https://github.com/ilgrosso","followers_url":"https://api.github.com/users/ilgrosso/followers","following_url":"https://api.github.com/users/ilgrosso/following{/other_user}","gists_url":"https://api.github.com/users/ilgrosso/gists{/gist_id}","starred_url":"https://api.github.com/users/ilgrosso/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ilgrosso/subscriptions","organizations_url":"https://api.github.com/users/ilgrosso/orgs","repos_url":"https://api.github.com/users/ilgrosso/repos","events_url":"https://api.github.com/users/ilgrosso/events{/privacy}","received_events_url":"https://api.github.com/users/ilgrosso/received_events","type":"User","site_admin":false},"committer":{"login":"ilgrosso","id":1064664,"node_id":"MDQ6VXNlcjEwNjQ2NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/1064664?v=4","gravatar_id":"","url":"https://api.github.com/users/ilgrosso","html_url":"https://github.com/ilgrosso","followers_url":"https://api.github.com/users/ilgrosso/followers","following_url":"https://api.github.com/users/ilgrosso/following{/other_user}","gists_url":"https://api.github.com/users/ilgrosso/gists{/gist_id}","starred_url":"https://api.github.com/users/ilgrosso/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ilgrosso/subscriptions","organizations_url":"https://api.github.com/users/ilgrosso/orgs","repos_url":"https://api.github.com/users/ilgrosso/repos","events_url":"https://api.github.com/users/ilgrosso/events{/privacy}","received_events_url":"https://api.github.com/users/ilgrosso/received_events","type":"User","site_admin":false},"parents":[{"sha":"95885170678584e1fbde4de995861393a579ec08","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/95885170678584e1fbde4de995861393a579ec08","html_url":"https://github.com/EnricoDAlessandro97UNI/syncope/commit/95885170678584e1fbde4de995861393a579ec08"}],"stats":{"total":474,"additions":209,"deletions":265},"files":[{"sha":"ed17e680150b2438c750be9acd29928bef220401","filename":"core/provisioning-java/src/main/java/org/apache/syncope/core/provisioning/java/data/AbstractAnyDataBinder.java","status":"modified","additions":59,"deletions":45,"changes":104,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/44db3ed2b914b7b2cedff8c34c7f2ef817e432a1/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fdata%2FAbstractAnyDataBinder.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/44db3ed2b914b7b2cedff8c34c7f2ef817e432a1/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fdata%2FAbstractAnyDataBinder.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fdata%2FAbstractAnyDataBinder.java?ref=44db3ed2b914b7b2cedff8c34c7f2ef817e432a1","patch":"@@ -28,6 +28,7 @@\n import org.apache.syncope.common.lib.request.AttrPatch;\n import org.apache.syncope.common.lib.request.StringPatchItem;\n import org.apache.syncope.common.lib.to.AnyTO;\n+import org.apache.syncope.common.lib.to.ConnObjectTO;\n import org.apache.syncope.common.lib.to.MembershipTO;\n import org.apache.syncope.common.lib.to.RelationshipTO;\n import org.apache.syncope.common.lib.types.AttrSchemaType;\n@@ -40,7 +41,6 @@\n import org.apache.syncope.core.persistence.api.dao.AnyTypeClassDAO;\n import org.apache.syncope.core.persistence.api.dao.ExternalResourceDAO;\n import org.apache.syncope.core.persistence.api.dao.GroupDAO;\n-import org.apache.syncope.core.persistence.api.dao.NotFoundException;\n import org.apache.syncope.core.persistence.api.dao.PlainAttrDAO;\n import org.apache.syncope.core.persistence.api.dao.PlainAttrValueDAO;\n import org.apache.syncope.core.persistence.api.dao.PlainSchemaDAO;\n@@ -64,18 +64,20 @@\n import org.apache.syncope.core.persistence.api.entity.VirSchema;\n import org.apache.syncope.core.persistence.api.entity.anyobject.AnyObject;\n import org.apache.syncope.core.persistence.api.entity.resource.ExternalResource;\n-import org.apache.syncope.core.persistence.api.entity.resource.MappingItem;\n import org.apache.syncope.core.persistence.api.entity.resource.Provision;\n import org.apache.syncope.core.provisioning.api.AccountGetter;\n import org.apache.syncope.core.provisioning.api.DerAttrHandler;\n import org.apache.syncope.core.provisioning.api.IntAttrName;\n import org.apache.syncope.core.provisioning.api.MappingManager;\n import org.apache.syncope.core.provisioning.api.PlainAttrGetter;\n-import org.apache.syncope.core.provisioning.api.PropagationByResource;\n import org.apache.syncope.core.provisioning.api.VirAttrHandler;\n import org.apache.syncope.core.provisioning.api.IntAttrNameParser;\n+import org.apache.syncope.core.provisioning.api.PropagationByResource;\n import org.apache.syncope.core.provisioning.api.jexl.JexlUtils;\n+import org.apache.syncope.core.provisioning.java.utils.ConnObjectUtils;\n import org.apache.syncope.core.provisioning.java.utils.MappingUtils;\n+import org.identityconnectors.framework.common.objects.Attribute;\n+import org.identityconnectors.framework.common.objects.Uid;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.springframework.beans.factory.annotation.Autowired;\n@@ -153,6 +155,32 @@ protected void setRealm(final Any<?> any, final AnyUR anyUR) {\n         }\n     }\n \n+    protected Map<String, ConnObjectTO> onResources(\n+            final Any<?> any,\n+            final Collection<String> resources,\n+            final String password,\n+            final boolean changePwd) {\n+\n+        Map<String, ConnObjectTO> onResources = new HashMap<>();\n+\n+        resources.stream().map(resourceDAO::find).map(resource -> resource.getProvision(any.getType())).\n+                filter(Optional::isPresent).map(Optional::get).\n+                forEach(provision -> MappingUtils.getConnObjectKeyItem(provision).ifPresent(connObjectKeyItem -> {\n+\n+            Pair<String, Set<Attribute>> prepared = mappingManager.prepareAttrsFromAny(\n+                    any, password, changePwd, true, provision);\n+\n+            ConnObjectTO connObjectTO = ConnObjectUtils.getConnObjectTO(prepared.getRight());\n+            connObjectTO.getAttrs().add(\n+                    new Attr.Builder(connObjectKeyItem.getExtAttrName()).value(prepared.getLeft()).build());\n+            connObjectTO.getAttrs().add(new Attr.Builder(Uid.NAME).value(prepared.getLeft()).build());\n+\n+            onResources.put(provision.getResource().getKey(), connObjectTO);\n+        }));\n+\n+        return onResources;\n+    }\n+\n     protected PlainSchema getPlainSchema(final String schemaName) {\n         PlainSchema schema = null;\n         if (StringUtils.isNotBlank(schemaName)) {\n@@ -218,7 +246,8 @@ private List<String> evaluateMandatoryCondition(final Provision provision, final\n                         ? ((PlainSchema) intAttrName.getSchema()).getType()\n                         : AttrSchemaType.String;\n \n-                Pair<AttrSchemaType, List<PlainAttrValue>> intValues = mappingManager.getIntValues(provision,\n+                Pair<AttrSchemaType, List<PlainAttrValue>> intValues = mappingManager.getIntValues(\n+                        provision,\n                         mapItem,\n                         intAttrName,\n                         schemaType,\n@@ -300,8 +329,6 @@ protected void processAttrPatch(\n             final PlainSchema schema,\n             final PlainAttr<?> attr,\n             final AnyUtils anyUtils,\n-            final Collection<ExternalResource> resources,\n-            final PropagationByResource<String> propByRes,\n             final SyncopeClientException invalidValues) {\n \n         switch (patch.getOperation()) {\n@@ -338,31 +365,15 @@ protected void processAttrPatch(\n                 any.remove(attr);\n                 plainAttrDAO.delete(attr);\n         }\n-\n-        resources.stream().\n-                filter(resource -> resource.getProvision(any.getType()).isPresent()\n-                && resource.getProvision(any.getType()).get().getMapping() != null).\n-                forEach(resource -> MappingUtils.getPropagationItems(\n-                resource.getProvision(any.getType()).get().getMapping().getItems().stream()).\n-                filter(item -> (schema.getKey().equals(item.getIntAttrName()))).\n-                forEach(item -> {\n-                    propByRes.add(ResourceOperation.UPDATE, resource.getKey());\n-\n-                    if (item.isConnObjectKey() && !attr.getValuesAsStrings().isEmpty()) {\n-                        propByRes.addOldConnObjectKey(resource.getKey(), attr.getValuesAsStrings().get(0));\n-                    }\n-                }));\n     }\n \n     @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n-    protected PropagationByResource<String> fill(\n+    protected void fill(\n             final Any any,\n             final AnyUR anyUR,\n             final AnyUtils anyUtils,\n             final SyncopeClientCompositeException scce) {\n \n-        PropagationByResource<String> propByRes = new PropagationByResource<>();\n-\n         // 1. anyTypeClasses\n         for (StringPatchItem patch : anyUR.getAuxClasses()) {\n             AnyTypeClass auxClass = anyTypeClassDAO.find(patch.getValue());\n@@ -389,13 +400,11 @@ protected PropagationByResource<String> fill(\n             } else {\n                 switch (patch.getOperation()) {\n                     case ADD_REPLACE:\n-                        propByRes.add(ResourceOperation.CREATE, resource.getKey());\n                         any.add(resource);\n                         break;\n \n                     case DELETE:\n                     default:\n-                        propByRes.add(ResourceOperation.DELETE, resource.getKey());\n                         any.getResources().remove(resource);\n                 }\n             }\n@@ -424,7 +433,7 @@ protected PropagationByResource<String> fill(\n                     }\n                 }\n                 if (attr != null) {\n-                    processAttrPatch(any, patch, schema, attr, anyUtils, resources, propByRes, invalidValues);\n+                    processAttrPatch(any, patch, schema, attr, anyUtils, invalidValues);\n                 }\n             }\n         });\n@@ -440,6 +449,30 @@ protected PropagationByResource<String> fill(\n         if (!requiredValuesMissing.isEmpty()) {\n             scce.addException(requiredValuesMissing);\n         }\n+    }\n+\n+    protected PropagationByResource<String> propByRes(\n+            final Map<String, ConnObjectTO> before,\n+            final Map<String, ConnObjectTO> after) {\n+\n+        PropagationByResource<String> propByRes = new PropagationByResource<>();\n+\n+        after.forEach((resource, connObject) -> {\n+            if (before.containsKey(resource)) {\n+                ConnObjectTO beforeObject = before.get(resource);\n+                if (!beforeObject.equals(connObject)) {\n+                    propByRes.add(ResourceOperation.UPDATE, resource);\n+\n+                    beforeObject.getAttr(Uid.NAME).map(attr -> attr.getValues().get(0)).\n+                            ifPresent(value -> propByRes.addOldConnObjectKey(resource, value));\n+                }\n+            } else {\n+                propByRes.add(ResourceOperation.CREATE, resource);\n+            }\n+        });\n+        propByRes.addAll(\n+                ResourceOperation.DELETE,\n+                before.keySet().stream().filter(resource -> !after.containsKey(resource)).collect(Collectors.toSet()));\n \n         return propByRes;\n     }\n@@ -607,23 +640,4 @@ protected static MembershipTO getMembershipTO(\n \n         return membershipTO;\n     }\n-\n-    protected Map<String, String> getConnObjectKeys(final Any<?> any, final AnyUtils anyUtils) {\n-        Map<String, String> connObjectKeys = new HashMap<>();\n-\n-        anyUtils.getAllResources(any).\n-                forEach(resource -> resource.getProvision(any.getType()).\n-                filter(provision -> provision.getMapping() != null).\n-                ifPresent(provision -> {\n-                    MappingItem connObjectKeyItem = MappingUtils.getConnObjectKeyItem(provision).\n-                            orElseThrow(() -> new NotFoundException(\n-                            \"ConnObjectKey mapping for \" + any.getType().getKey() + ' ' + any.getKey()\n-                            + \" on resource '\" + resource.getKey() + '\\''));\n-\n-                    mappingManager.getConnObjectKeyValue(any, provision).\n-                            ifPresent(value -> connObjectKeys.put(resource.getKey(), value));\n-                }));\n-\n-        return connObjectKeys;\n-    }\n }"},{"sha":"6201586ff3e50c407ef074f044c619bafab9db3a","filename":"core/provisioning-java/src/main/java/org/apache/syncope/core/provisioning/java/data/AnyObjectDataBinderImpl.java","status":"modified","additions":15,"deletions":90,"changes":105,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/44db3ed2b914b7b2cedff8c34c7f2ef817e432a1/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fdata%2FAnyObjectDataBinderImpl.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/44db3ed2b914b7b2cedff8c34c7f2ef817e432a1/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fdata%2FAnyObjectDataBinderImpl.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fdata%2FAnyObjectDataBinderImpl.java?ref=44db3ed2b914b7b2cedff8c34c7f2ef817e432a1","patch":"@@ -18,9 +18,7 @@\n  */\n package org.apache.syncope.core.provisioning.java.data;\n \n-import java.util.Collection;\n import java.util.Collections;\n-import java.util.HashMap;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n@@ -35,12 +33,13 @@\n import org.apache.syncope.common.lib.request.AnyObjectUR;\n import org.apache.syncope.common.lib.request.AttrPatch;\n import org.apache.syncope.common.lib.to.AnyObjectTO;\n+import org.apache.syncope.common.lib.to.ConnObjectTO;\n import org.apache.syncope.common.lib.to.MembershipTO;\n import org.apache.syncope.common.lib.types.AnyTypeKind;\n import org.apache.syncope.common.lib.types.ClientExceptionType;\n import org.apache.syncope.common.lib.types.PatchOperation;\n-import org.apache.syncope.core.provisioning.api.PropagationByResource;\n import org.apache.syncope.common.lib.types.ResourceOperation;\n+import org.apache.syncope.core.provisioning.api.PropagationByResource;\n import org.apache.syncope.core.persistence.api.dao.AnyTypeDAO;\n import org.apache.syncope.core.persistence.api.entity.AnyType;\n import org.apache.syncope.core.persistence.api.entity.AnyUtils;\n@@ -53,7 +52,6 @@\n import org.apache.syncope.core.persistence.api.entity.anyobject.ARelationship;\n import org.apache.syncope.core.persistence.api.entity.anyobject.AnyObject;\n import org.apache.syncope.core.persistence.api.entity.group.Group;\n-import org.apache.syncope.core.persistence.api.entity.resource.ExternalResource;\n import org.apache.syncope.core.provisioning.api.data.AnyObjectDataBinder;\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.stereotype.Component;\n@@ -266,27 +264,24 @@ public PropagationByResource<String> update(final AnyObject toBeUpdated, final A\n \n         PropagationByResource<String> propByRes = new PropagationByResource<>();\n \n+        // Save projection on Resources (before update)\n+        Map<String, ConnObjectTO> beforeOnResources =\n+                onResources(anyObject, anyObjectDAO.findAllResourceKeys(anyObject.getKey()), null, false);\n+\n         SyncopeClientCompositeException scce = SyncopeClientException.buildComposite();\n \n         AnyUtils anyUtils = anyUtilsFactory.getInstance(AnyTypeKind.ANY_OBJECT);\n \n-        Collection<String> currentResources = anyObjectDAO.findAllResourceKeys(anyObject.getKey());\n-\n-        // fetch connObjectKeys before update\n-        Map<String, String> oldConnObjectKeys = getConnObjectKeys(anyObject, anyUtils);\n-\n         // realm\n         setRealm(anyObject, anyObjectUR);\n \n         // name\n         if (anyObjectUR.getName() != null && StringUtils.isNotBlank(anyObjectUR.getName().getValue())) {\n-            propByRes.addAll(ResourceOperation.UPDATE, anyObjectDAO.findAllResourceKeys(anyObject.getKey()));\n-\n             anyObject.setName(anyObjectUR.getName().getValue());\n         }\n \n         // attributes and resources\n-        propByRes.merge(fill(anyObject, anyObjectUR, anyUtils, scce));\n+        fill(anyObject, anyObjectUR, anyUtils, scce);\n \n         // relationships\n         Set<Pair<String, String>> relationships = new HashSet<>();\n@@ -352,23 +347,6 @@ public PropagationByResource<String> update(final AnyObject toBeUpdated, final A\n             }\n         });\n \n-        // prepare for membership-related resource management\n-        Collection<ExternalResource> resources = anyObjectDAO.findAllResources(anyObject);\n-\n-        Map<String, Set<String>> reasons = new HashMap<>();\n-        anyObject.getResources().forEach(\n-                resource -> reasons.put(resource.getKey(), new HashSet<>(Set.of(anyObject.getKey()))));\n-        anyObjectDAO.findAllGroupKeys(anyObject).forEach(\n-                group -> groupDAO.findAllResourceKeys(group).forEach(resource -> {\n-                    if (!reasons.containsKey(resource)) {\n-                        reasons.put(resource, new HashSet<>());\n-                    }\n-                    reasons.get(resource).add(group);\n-                }));\n-\n-        Set<String> toBeDeprovisioned = new HashSet<>();\n-        Set<String> toBeProvisioned = new HashSet<>();\n-\n         SyncopeClientException invalidValues = SyncopeClientException.build(ClientExceptionType.InvalidValues);\n \n         // memberships\n@@ -385,12 +363,9 @@ public PropagationByResource<String> update(final AnyObject toBeUpdated, final A\n                 });\n \n                 if (patch.getOperation() == PatchOperation.DELETE) {\n-                    groupDAO.findAllResourceKeys(membership.getRightEnd().getKey()).stream().\n-                            filter(reasons::containsKey).\n-                            forEach(resource -> {\n-                                reasons.get(resource).remove(membership.getRightEnd().getKey());\n-                                toBeProvisioned.add(resource);\n-                            });\n+                    propByRes.addAll(\n+                            ResourceOperation.UPDATE,\n+                            groupDAO.findAllResourceKeys((membership.getRightEnd().getKey())));\n                 }\n             });\n             if (patch.getOperation() == PatchOperation.ADD_REPLACE) {\n@@ -437,8 +412,6 @@ public PropagationByResource<String> update(final AnyObject toBeUpdated, final A\n                                         schema,\n                                         newAttr,\n                                         anyUtils,\n-                                        resources,\n-                                        propByRes,\n                                         invalidValues);\n                             }\n                         }\n@@ -447,7 +420,7 @@ public PropagationByResource<String> update(final AnyObject toBeUpdated, final A\n                         scce.addException(invalidValues);\n                     }\n \n-                    toBeProvisioned.addAll(groupDAO.findAllResourceKeys(group.getKey()));\n+                    propByRes.addAll(ResourceOperation.UPDATE, groupDAO.findAllResourceKeys(group.getKey()));\n                 } else {\n                     LOG.error(\"{} cannot be assigned to {}\", group, anyObject);\n \n@@ -459,50 +432,6 @@ public PropagationByResource<String> update(final AnyObject toBeUpdated, final A\n             }\n         });\n \n-        // finalize resource management\n-        reasons.entrySet().stream().\n-                filter(entry -> entry.getValue().isEmpty()).\n-                forEach(entry -> toBeDeprovisioned.add(entry.getKey()));\n-\n-        propByRes.addAll(ResourceOperation.DELETE, toBeDeprovisioned);\n-        propByRes.addAll(ResourceOperation.UPDATE, toBeProvisioned);\n-\n-        // in case of new memberships all current resources need to be updated in order to propagate new group\n-        // attribute values.\n-        if (!toBeDeprovisioned.isEmpty() || !toBeProvisioned.isEmpty()) {\n-            currentResources.removeAll(toBeDeprovisioned);\n-            propByRes.addAll(ResourceOperation.UPDATE, currentResources);\n-        }\n-\n-        // check if some connObjectKey was changed by the update above\n-        Map<String, String> newConnObjectKeys = getConnObjectKeys(anyObject, anyUtils);\n-        oldConnObjectKeys.entrySet().stream().\n-                filter(entry -> newConnObjectKeys.containsKey(entry.getKey())\n-                && !entry.getValue().equals(newConnObjectKeys.get(entry.getKey()))).\n-                forEach(entry -> {\n-                    propByRes.addOldConnObjectKey(entry.getKey(), entry.getValue());\n-                    propByRes.add(ResourceOperation.UPDATE, entry.getKey());\n-                });\n-\n-        Pair<Set<String>, Set<String>> dynGroupMembs = anyObjectDAO.saveAndGetDynGroupMembs(anyObject);\n-\n-        // finally check if any resource assignment is to be processed due to dynamic group membership change\n-        dynGroupMembs.getLeft().stream().\n-                filter(group -> !dynGroupMembs.getRight().contains(group)).\n-                forEach(delete -> groupDAO.find(delete).getResources().stream().\n-                filter(resource -> !propByRes.contains(resource.getKey())).\n-                forEach(resource -> propByRes.add(ResourceOperation.DELETE, resource.getKey())));\n-        dynGroupMembs.getLeft().stream().\n-                filter(group -> dynGroupMembs.getRight().contains(group)).\n-                forEach(update -> groupDAO.find(update).getResources().stream().\n-                filter(resource -> !propByRes.contains(resource.getKey())).\n-                forEach(resource -> propByRes.add(ResourceOperation.UPDATE, resource.getKey())));\n-        dynGroupMembs.getRight().stream().\n-                filter(group -> !dynGroupMembs.getLeft().contains(group)).\n-                forEach(create -> groupDAO.find(create).getResources().stream().\n-                filter(resource -> !propByRes.contains(resource.getKey())).\n-                forEach(resource -> propByRes.add(ResourceOperation.CREATE, resource.getKey())));\n-\n         // Throw composite exception if there is at least one element set in the composing exceptions\n         if (scce.hasExceptions()) {\n             throw scce;\n@@ -511,14 +440,10 @@ public PropagationByResource<String> update(final AnyObject toBeUpdated, final A\n         // Re-merge any pending change from above\n         AnyObject saved = anyObjectDAO.save(anyObject);\n \n-        // ensure not to DELETE on External Resources that remain assigned\n-        Set<String> assigned = saved.getResources().stream().\n-                map(ExternalResource::getKey).collect(Collectors.toCollection(HashSet::new));\n-        assigned.addAll(saved.getMemberships().stream().\n-                flatMap(m -> m.getRightEnd().getResources().stream()).map(ExternalResource::getKey).\n-                collect(Collectors.toSet()));\n-        propByRes.removeAll(ResourceOperation.DELETE, assigned);\n-\n+        // Build final information for next stage (propagation)\n+        propByRes.merge(propByRes(\n+                beforeOnResources,\n+                onResources(saved, anyObjectDAO.findAllResourceKeys(anyObject.getKey()), null, false)));\n         return propByRes;\n     }\n }"},{"sha":"cdca128aac11e4f76cada2334c998e408b64e1b0","filename":"core/provisioning-java/src/main/java/org/apache/syncope/core/provisioning/java/data/GroupDataBinderImpl.java","status":"modified","additions":10,"deletions":22,"changes":32,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/44db3ed2b914b7b2cedff8c34c7f2ef817e432a1/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fdata%2FGroupDataBinderImpl.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/44db3ed2b914b7b2cedff8c34c7f2ef817e432a1/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fdata%2FGroupDataBinderImpl.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fdata%2FGroupDataBinderImpl.java?ref=44db3ed2b914b7b2cedff8c34c7f2ef817e432a1","patch":"@@ -29,6 +29,7 @@\n import org.apache.syncope.common.lib.SyncopeClientException;\n import org.apache.syncope.common.lib.request.GroupCR;\n import org.apache.syncope.common.lib.request.GroupUR;\n+import org.apache.syncope.common.lib.to.ConnObjectTO;\n import org.apache.syncope.common.lib.to.GroupTO;\n import org.apache.syncope.common.lib.to.TypeExtensionTO;\n import org.apache.syncope.common.lib.types.AnyTypeKind;\n@@ -44,7 +45,6 @@\n import org.apache.syncope.core.persistence.api.entity.Any;\n import org.apache.syncope.core.persistence.api.entity.AnyType;\n import org.apache.syncope.core.persistence.api.entity.AnyTypeClass;\n-import org.apache.syncope.core.persistence.api.entity.AnyUtils;\n import org.apache.syncope.core.persistence.api.entity.DerSchema;\n import org.apache.syncope.core.persistence.api.entity.DynGroupMembership;\n import org.apache.syncope.core.persistence.api.entity.Entity;\n@@ -194,22 +194,17 @@ public PropagationByResource<String> update(final Group toBeUpdated, final Group\n         // Re-merge any pending change from workflow tasks\n         Group group = groupDAO.save(toBeUpdated);\n \n-        PropagationByResource<String> propByRes = new PropagationByResource<>();\n+        // Save projection on Resources (before update)\n+        Map<String, ConnObjectTO> beforeOnResources =\n+                onResources(group, groupDAO.findAllResourceKeys(group.getKey()), null, false);\n \n         SyncopeClientCompositeException scce = SyncopeClientException.buildComposite();\n \n-        AnyUtils anyUtils = anyUtilsFactory.getInstance(AnyTypeKind.GROUP);\n-\n-        // fetch connObjectKeys before update\n-        Map<String, String> oldConnObjectKeys = getConnObjectKeys(group, anyUtils);\n-\n         // realm\n         setRealm(group, groupUR);\n \n         // name\n         if (groupUR.getName() != null && StringUtils.isNotBlank(groupUR.getName().getValue())) {\n-            propByRes.addAll(ResourceOperation.UPDATE, groupDAO.findAllResourceKeys(group.getKey()));\n-\n             group.setName(groupUR.getName().getValue());\n         }\n \n@@ -226,17 +221,7 @@ public PropagationByResource<String> update(final Group toBeUpdated, final Group\n         }\n \n         // attributes and resources\n-        propByRes.merge(fill(group, groupUR, anyUtils, scce));\n-\n-        // check if some connObjectKey was changed by the update above\n-        Map<String, String> newConnObjectKeys = getConnObjectKeys(group, anyUtils);\n-        oldConnObjectKeys.entrySet().stream().\n-                filter(entry -> newConnObjectKeys.containsKey(entry.getKey())\n-                && !entry.getValue().equals(newConnObjectKeys.get(entry.getKey()))).\n-                forEach(entry -> {\n-                    propByRes.addOldConnObjectKey(entry.getKey(), entry.getValue());\n-                    propByRes.add(ResourceOperation.UPDATE, entry.getKey());\n-                });\n+        fill(group, groupUR, anyUtilsFactory.getInstance(AnyTypeKind.GROUP), scce);\n \n         group = groupDAO.save(group);\n \n@@ -311,8 +296,11 @@ public PropagationByResource<String> update(final Group toBeUpdated, final Group\n         }\n \n         // Re-merge any pending change from above\n-        groupDAO.save(group);\n-        return propByRes;\n+        group = groupDAO.save(group);\n+\n+        // Build final information for next stage (propagation)\n+        return propByRes(\n+                beforeOnResources, onResources(group, groupDAO.findAllResourceKeys(group.getKey()), null, false));\n     }\n \n     @Override"},{"sha":"31a605dd163401e927ba0a4c8d31a9262a4e2ab5","filename":"core/provisioning-java/src/main/java/org/apache/syncope/core/provisioning/java/data/UserDataBinderImpl.java","status":"modified","additions":36,"deletions":100,"changes":136,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/44db3ed2b914b7b2cedff8c34c7f2ef817e432a1/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fdata%2FUserDataBinderImpl.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/44db3ed2b914b7b2cedff8c34c7f2ef817e432a1/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fdata%2FUserDataBinderImpl.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fdata%2FUserDataBinderImpl.java?ref=44db3ed2b914b7b2cedff8c34c7f2ef817e432a1","patch":"@@ -18,9 +18,7 @@\n  */\n package org.apache.syncope.core.provisioning.java.data;\n \n-import java.util.Collection;\n import java.util.Date;\n-import java.util.HashMap;\n import java.util.HashSet;\n import java.util.Map;\n import java.util.Optional;\n@@ -40,6 +38,7 @@\n import org.apache.syncope.common.lib.request.UserUR;\n import org.apache.syncope.common.lib.request.AttrPatch;\n import org.apache.syncope.common.lib.request.PasswordPatch;\n+import org.apache.syncope.common.lib.to.ConnObjectTO;\n import org.apache.syncope.common.lib.to.LinkedAccountTO;\n import org.apache.syncope.common.lib.to.MembershipTO;\n import org.apache.syncope.common.lib.to.UserTO;\n@@ -381,29 +380,36 @@ public Pair<PropagationByResource<String>, PropagationByResource<Pair<String, St\n \n         AnyUtils anyUtils = anyUtilsFactory.getInstance(AnyTypeKind.USER);\n \n-        Collection<String> currentResources = userDAO.findAllResourceKeys(user.getKey());\n-\n-        // fetch connObjectKeys before update\n-        Map<String, String> oldConnObjectKeys = getConnObjectKeys(user, anyUtils);\n-\n         // realm\n         setRealm(user, userUR);\n \n         // password\n+        String password = null;\n+        boolean changePwd = false;\n         if (userUR.getPassword() != null) {\n             if (userUR.getPassword().getOperation() == PatchOperation.DELETE) {\n                 user.setEncodedPassword(null, null);\n-                propByRes.addAll(ResourceOperation.UPDATE, userUR.getPassword().getResources());\n+\n+                changePwd = true;\n             } else if (StringUtils.isNotBlank(userUR.getPassword().getValue())) {\n                 if (userUR.getPassword().isOnSyncope()) {\n                     setPassword(user, userUR.getPassword().getValue(), scce);\n                     user.setChangePwdDate(new Date());\n                 }\n \n+                password = userUR.getPassword().getValue();\n+                changePwd = true;\n+            }\n+\n+            if (changePwd) {\n                 propByRes.addAll(ResourceOperation.UPDATE, userUR.getPassword().getResources());\n             }\n         }\n \n+        // Save projection on Resources (before update)\n+        Map<String, ConnObjectTO> beforeOnResources =\n+                onResources(user, userDAO.findAllResourceKeys(user.getKey()), password, changePwd);\n+\n         // username\n         if (userUR.getUsername() != null && StringUtils.isNotBlank(userUR.getUsername().getValue())) {\n             String oldUsername = user.getUsername();\n@@ -418,8 +424,6 @@ public Pair<PropagationByResource<String>, PropagationByResource<Pair<String, St\n                 accessToken.setOwner(userUR.getUsername().getValue());\n                 accessTokenDAO.save(accessToken);\n             }\n-\n-            propByRes.addAll(ResourceOperation.UPDATE, currentResources);\n         }\n \n         // security question / answer:\n@@ -437,19 +441,6 @@ public Pair<PropagationByResource<String>, PropagationByResource<Pair<String, St\n             }\n         }\n \n-        if (userUR.getMustChangePassword() != null) {\n-            user.setMustChangePassword(userUR.getMustChangePassword().getValue());\n-\n-            propByRes.addAll(\n-                    ResourceOperation.UPDATE,\n-                    anyUtils.getAllResources(toBeUpdated).stream().\n-                            filter(resource -> resource.getProvision(toBeUpdated.getType()).isPresent()).\n-                            filter(resource -> mappingManager.hasMustChangePassword(\n-                            resource.getProvision(toBeUpdated.getType()).get())).\n-                            map(Entity::getKey).\n-                            collect(Collectors.toSet()));\n-        }\n-\n         // roles\n         for (StringPatchItem patch : userUR.getRoles()) {\n             Role role = roleDAO.find(patch.getValue());\n@@ -469,7 +460,7 @@ public Pair<PropagationByResource<String>, PropagationByResource<Pair<String, St\n         }\n \n         // attributes and resources\n-        propByRes.merge(fill(user, userUR, anyUtils, scce));\n+        fill(user, userUR, anyUtils, scce);\n \n         // relationships\n         Set<Pair<String, String>> relationships = new HashSet<>();\n@@ -522,22 +513,6 @@ public Pair<PropagationByResource<String>, PropagationByResource<Pair<String, St\n             }\n         });\n \n-        // prepare for membership-related resource management\n-        Collection<ExternalResource> resources = userDAO.findAllResources(user);\n-\n-        Map<String, Set<String>> reasons = new HashMap<>();\n-        user.getResources().forEach(\n-                resource -> reasons.put(resource.getKey(), new HashSet<>(Set.of(user.getKey()))));\n-        userDAO.findAllGroupKeys(user).forEach(group -> groupDAO.findAllResourceKeys(group).forEach(resource -> {\n-            if (!reasons.containsKey(resource)) {\n-                reasons.put(resource, new HashSet<>());\n-            }\n-            reasons.get(resource).add(group);\n-        }));\n-\n-        Set<String> toBeDeprovisioned = new HashSet<>();\n-        Set<String> toBeProvisioned = new HashSet<>();\n-\n         SyncopeClientException invalidValues = SyncopeClientException.build(ClientExceptionType.InvalidValues);\n \n         // memberships\n@@ -555,12 +530,9 @@ public Pair<PropagationByResource<String>, PropagationByResource<Pair<String, St\n                 });\n \n                 if (patch.getOperation() == PatchOperation.DELETE) {\n-                    groupDAO.findAllResourceKeys(membership.getRightEnd().getKey()).stream().\n-                            filter(reasons::containsKey).\n-                            forEach(resource -> {\n-                                reasons.get(resource).remove(membership.getRightEnd().getKey());\n-                                toBeProvisioned.add(resource);\n-                            });\n+                    propByRes.addAll(\n+                            ResourceOperation.UPDATE,\n+                            groupDAO.findAllResourceKeys((membership.getRightEnd().getKey())));\n                 }\n             });\n             if (patch.getOperation() == PatchOperation.ADD_REPLACE) {\n@@ -606,8 +578,6 @@ public Pair<PropagationByResource<String>, PropagationByResource<Pair<String, St\n                                         schema,\n                                         attr,\n                                         anyUtils,\n-                                        resources,\n-                                        propByRes,\n                                         invalidValues);\n                             }\n                         }\n@@ -616,7 +586,7 @@ public Pair<PropagationByResource<String>, PropagationByResource<Pair<String, St\n                         scce.addException(invalidValues);\n                     }\n \n-                    toBeProvisioned.addAll(groupDAO.findAllResourceKeys(group.getKey()));\n+                    propByRes.addAll(ResourceOperation.UPDATE, groupDAO.findAllResourceKeys(group.getKey()));\n \n                     // SYNCOPE-686: if password is invertible and we are adding resources with password mapping,\n                     // ensure that they are counted for password propagation\n@@ -675,50 +645,6 @@ public Pair<PropagationByResource<String>, PropagationByResource<Pair<String, St\n                 ResourceOperation.CREATE,\n                 Pair.of(account.getResource().getKey(), account.getConnObjectKeyValue())));\n \n-        // finalize resource management\n-        reasons.entrySet().stream().\n-                filter(entry -> entry.getValue().isEmpty()).\n-                forEach(entry -> toBeDeprovisioned.add(entry.getKey()));\n-\n-        propByRes.addAll(ResourceOperation.DELETE, toBeDeprovisioned);\n-        propByRes.addAll(ResourceOperation.UPDATE, toBeProvisioned);\n-\n-        // in case of new memberships all current resources need to be updated in order to propagate new group\n-        // attribute values.\n-        if (!toBeDeprovisioned.isEmpty() || !toBeProvisioned.isEmpty()) {\n-            currentResources.removeAll(toBeDeprovisioned);\n-            propByRes.addAll(ResourceOperation.UPDATE, currentResources);\n-        }\n-\n-        // check if some connObjectKey was changed by the update above\n-        Map<String, String> newConnObjectKeys = getConnObjectKeys(user, anyUtils);\n-        oldConnObjectKeys.entrySet().stream().\n-                filter(entry -> newConnObjectKeys.containsKey(entry.getKey())\n-                && !entry.getValue().equals(newConnObjectKeys.get(entry.getKey()))).\n-                forEach(entry -> {\n-                    propByRes.addOldConnObjectKey(entry.getKey(), entry.getValue());\n-                    propByRes.add(ResourceOperation.UPDATE, entry.getKey());\n-                });\n-\n-        Pair<Set<String>, Set<String>> dynGroupMembs = userDAO.saveAndGetDynGroupMembs(user);\n-\n-        // finally check if any resource assignment is to be processed due to dynamic group membership change\n-        dynGroupMembs.getLeft().stream().\n-                filter(group -> !dynGroupMembs.getRight().contains(group)).\n-                forEach(delete -> groupDAO.find(delete).getResources().stream().\n-                filter(resource -> !propByRes.contains(resource.getKey())).\n-                forEach(resource -> propByRes.add(ResourceOperation.DELETE, resource.getKey())));\n-        dynGroupMembs.getLeft().stream().\n-                filter(group -> dynGroupMembs.getRight().contains(group)).\n-                forEach(update -> groupDAO.find(update).getResources().stream().\n-                filter(resource -> !propByRes.contains(resource.getKey())).\n-                forEach(resource -> propByRes.add(ResourceOperation.UPDATE, resource.getKey())));\n-        dynGroupMembs.getRight().stream().\n-                filter(group -> !dynGroupMembs.getLeft().contains(group)).\n-                forEach(create -> groupDAO.find(create).getResources().stream().\n-                filter(resource -> !propByRes.contains(resource.getKey())).\n-                forEach(resource -> propByRes.add(ResourceOperation.CREATE, resource.getKey())));\n-\n         // Throw composite exception if there is at least one element set in the composing exceptions\n         if (scce.hasExceptions()) {\n             throw scce;\n@@ -727,13 +653,23 @@ public Pair<PropagationByResource<String>, PropagationByResource<Pair<String, St\n         // Re-merge any pending change from above\n         User saved = userDAO.save(user);\n \n-        // ensure not to DELETE on External Resources that remain assigned\n-        Set<String> assigned = saved.getResources().stream().\n-                map(ExternalResource::getKey).collect(Collectors.toCollection(HashSet::new));\n-        assigned.addAll(saved.getMemberships().stream().\n-                flatMap(m -> m.getRightEnd().getResources().stream()).map(ExternalResource::getKey).\n-                collect(Collectors.toSet()));\n-        propByRes.removeAll(ResourceOperation.DELETE, assigned);\n+        // Build final information for next stage (propagation)\n+        Map<String, ConnObjectTO> afterOnResources =\n+                onResources(user, userDAO.findAllResourceKeys(user.getKey()), password, changePwd);\n+        propByRes.merge(propByRes(beforeOnResources, afterOnResources));\n+\n+        if (userUR.getMustChangePassword() != null) {\n+            user.setMustChangePassword(userUR.getMustChangePassword().getValue());\n+\n+            propByRes.addAll(\n+                    ResourceOperation.UPDATE,\n+                    anyUtils.getAllResources(saved).stream().\n+                            map(resource -> resource.getProvision(saved.getType())).\n+                            filter(Optional::isPresent).map(Optional::get).\n+                            filter(mappingManager::hasMustChangePassword).\n+                            map(provision -> provision.getResource().getKey()).\n+                            collect(Collectors.toSet()));\n+        }\n \n         return Pair.of(propByRes, propByLinkedAccount);\n     }"},{"sha":"23b3b4c73491b21a0845214b99dfb8899966a7a2","filename":"core/provisioning-java/src/main/java/org/apache/syncope/core/provisioning/java/propagation/AbstractPropagationTaskExecutor.java","status":"modified","additions":5,"deletions":5,"changes":10,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/44db3ed2b914b7b2cedff8c34c7f2ef817e432a1/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpropagation%2FAbstractPropagationTaskExecutor.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/44db3ed2b914b7b2cedff8c34c7f2ef817e432a1/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpropagation%2FAbstractPropagationTaskExecutor.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpropagation%2FAbstractPropagationTaskExecutor.java?ref=44db3ed2b914b7b2cedff8c34c7f2ef817e432a1","patch":"@@ -26,9 +26,9 @@\n import java.util.Map;\n import java.util.Optional;\n import java.util.Set;\n-import java.util.function.Function;\n import java.util.stream.Collectors;\n import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n import org.apache.commons.lang3.StringUtils;\n import org.apache.syncope.common.lib.to.ExecTO;\n import org.apache.syncope.common.lib.types.AuditElements;\n@@ -234,9 +234,9 @@ protected Uid createOrUpdate(\n                     collect(Collectors.toMap(attr -> attr.getName().toUpperCase(), Function.identity()));\n \n             // Only compare attribute from beforeObj that are also being updated\n-            Set<String> skipAttrNames = originalAttrMap.keySet();\n+            Set<String> skipAttrNames = new HashSet<>(originalAttrMap.keySet());\n             skipAttrNames.removeAll(updateAttrMap.keySet());\n-            new HashSet<>(skipAttrNames).forEach(originalAttrMap::remove);\n+            skipAttrNames.forEach(originalAttrMap::remove);\n \n             Set<Attribute> originalAttrs = new HashSet<>(originalAttrMap.values());\n \n@@ -246,8 +246,8 @@ protected Uid createOrUpdate(\n             } else {\n                 LOG.debug(\"Attributes that would be updated {}\", attributes);\n \n-                Set<Attribute> strictlyModified = new HashSet<>();\n-                attributes.stream().filter(attr -> (!originalAttrs.contains(attr))).forEach(strictlyModified::add);\n+                Set<Attribute> strictlyModified =\n+                        attributes.stream().filter(attr -> !originalAttrs.contains(attr)).collect(Collectors.toSet());\n \n                 // 3. provision entry\n                 LOG.debug(\"Update {} on {}\", strictlyModified, task.getResource().getKey());"},{"sha":"ac131632478ebad8e3f490ecb12fe652f6282a24","filename":"fit/core-reference/src/test/java/org/apache/syncope/fit/core/PropagationTaskITCase.java","status":"modified","additions":81,"deletions":0,"changes":81,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/44db3ed2b914b7b2cedff8c34c7f2ef817e432a1/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FPropagationTaskITCase.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/44db3ed2b914b7b2cedff8c34c7f2ef817e432a1/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FPropagationTaskITCase.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FPropagationTaskITCase.java?ref=44db3ed2b914b7b2cedff8c34c7f2ef817e432a1","patch":"@@ -20,6 +20,7 @@\n \n import static org.junit.jupiter.api.Assertions.assertEquals;\n import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n import static org.junit.jupiter.api.Assertions.assertNotNull;\n import static org.junit.jupiter.api.Assertions.assertTrue;\n \n@@ -49,6 +50,7 @@\n import org.apache.syncope.common.lib.to.AnyObjectTO;\n import org.apache.syncope.common.lib.Attr;\n import org.apache.syncope.common.lib.request.GroupCR;\n+import org.apache.syncope.common.lib.request.GroupUR;\n import org.apache.syncope.common.lib.request.MembershipUR;\n import org.apache.syncope.common.lib.request.ResourceDR;\n import org.apache.syncope.common.lib.to.ConnObjectTO;\n@@ -69,9 +71,11 @@\n import org.apache.syncope.common.lib.types.ImplementationEngine;\n import org.apache.syncope.common.lib.types.AttrSchemaType;\n import org.apache.syncope.common.lib.types.IdRepoImplementationType;\n+import org.apache.syncope.common.lib.types.ExecStatus;\n import org.apache.syncope.common.lib.types.MappingPurpose;\n import org.apache.syncope.common.lib.types.PatchOperation;\n import org.apache.syncope.common.lib.types.ResourceDeassociationAction;\n+import org.apache.syncope.common.lib.types.ResourceOperation;\n import org.apache.syncope.common.lib.types.SchemaType;\n import org.apache.syncope.common.lib.types.TaskType;\n import org.apache.syncope.common.rest.api.RESTHeaders;\n@@ -84,6 +88,7 @@\n import org.apache.syncope.fit.core.reference.DateToLongItemTransformer;\n import org.identityconnectors.framework.common.objects.Attribute;\n import org.identityconnectors.framework.common.objects.AttributeUtil;\n+import org.identityconnectors.framework.common.objects.Name;\n import org.junit.jupiter.api.Test;\n import org.junit.jupiter.api.BeforeAll;\n \n@@ -632,4 +637,80 @@ public void issueSYNCOPE1567() {\n             }\n         }\n     }\n+\n+    @Test\n+    public void issueSYNCOPE1605() throws ParseException {\n+        ResourceTO ldap = resourceService.read(RESOURCE_NAME_LDAP);\n+        try {\n+            // 1. clone the LDAP resource and add some sensible mappings\n+            ProvisionTO provisionGroup =\n+                    SerializationUtils.clone(ldap.getProvision(AnyTypeKind.GROUP.name()).orElse(null));\n+            assertNotNull(provisionGroup);\n+            provisionGroup.getVirSchemas().clear();\n+            provisionGroup.getMapping().getItems().clear();\n+\n+            ItemTO item = new ItemTO();\n+            item.setConnObjectKey(true);\n+            item.setIntAttrName(\"name\");\n+            item.setExtAttrName(\"description\");\n+            item.setPurpose(MappingPurpose.BOTH);\n+\n+            provisionGroup.getMapping().setConnObjectKeyItem(item);\n+            provisionGroup.getMapping().setConnObjectLink(\"'cn=' + originalName + ',ou=groups,o=isp'\");\n+\n+            ldap.getProvisions().clear();\n+            ldap.getProvisions().add(provisionGroup);\n+\n+            ldap.setKey(RESOURCE_NAME_LDAP + \"1605\" + getUUIDString());\n+            resourceService.create(ldap);\n+\n+            // 1. create group with the new resource assigned\n+            String originalName = \"grp1605-\" + getUUIDString();\n+\n+            GroupCR groupCR = new GroupCR();\n+            groupCR.setName(\"SYNCOPEGROUP1605-\" + getUUIDString());\n+            groupCR.setRealm(\"/\");\n+            groupCR.getResources().add(ldap.getKey());\n+            groupCR.getPlainAttrs().add(new Attr.Builder(\"originalName\").value(originalName).build());\n+\n+            GroupTO groupTO = createGroup(groupCR).getEntity();\n+            assertNotNull(groupTO);\n+\n+            // 3. check attributes prepared for propagation\n+            PagedResult<PropagationTaskTO> tasks = taskService.search(new TaskQuery.Builder(TaskType.PROPAGATION).\n+                    resource(groupTO.getResources().iterator().next()).\n+                    anyTypeKind(AnyTypeKind.GROUP).entityKey(groupTO.getKey()).build());\n+            assertEquals(1, tasks.getSize());\n+            assertEquals(ResourceOperation.CREATE, tasks.getResult().get(0).getOperation());\n+            assertEquals(ExecStatus.SUCCESS.name(), tasks.getResult().get(0).getLatestExecStatus());\n+\n+            ConnObjectTO beforeConnObject =\n+                    resourceService.readConnObject(ldap.getKey(), AnyTypeKind.GROUP.name(), groupTO.getKey());\n+\n+            GroupUR groupUR = new GroupUR();\n+            groupUR.setKey(groupTO.getKey());\n+\n+            groupUR.getPlainAttrs().add(attrAddReplacePatch(\"originalName\", \"new\" + originalName));\n+            groupTO = updateGroup(groupUR).getEntity();\n+\n+            tasks = taskService.search(new TaskQuery.Builder(TaskType.PROPAGATION).\n+                    resource(groupTO.getResources().iterator().next()).\n+                    anyTypeKind(AnyTypeKind.GROUP).entityKey(groupTO.getKey()).orderBy(\"start DESC\").build());\n+            assertEquals(2, tasks.getSize());\n+            assertEquals(ResourceOperation.UPDATE, tasks.getResult().get(0).getOperation());\n+            assertEquals(ExecStatus.SUCCESS.name(), tasks.getResult().get(0).getLatestExecStatus());\n+\n+            ConnObjectTO afterConnObject =\n+                    resourceService.readConnObject(ldap.getKey(), AnyTypeKind.GROUP.name(), groupTO.getKey());\n+            assertNotEquals(afterConnObject.getAttr(Name.NAME).get().getValues().get(0),\n+                    beforeConnObject.getAttr(Name.NAME).get().getValues().get(0));\n+            assertTrue(afterConnObject.getAttr(Name.NAME).get().getValues().get(0).contains(\"new\" + originalName));\n+        } finally {\n+            try {\n+                resourceService.delete(ldap.getKey());\n+            } catch (Exception ignore) {\n+                // ignore\n+            }\n+        }\n+    }\n }"},{"sha":"22541e9dff1c9f071db5d2624d2cbb6cb2792f3b","filename":"fit/core-reference/src/test/java/org/apache/syncope/fit/core/UserIssuesITCase.java","status":"modified","additions":3,"deletions":3,"changes":6,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/44db3ed2b914b7b2cedff8c34c7f2ef817e432a1/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FUserIssuesITCase.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/44db3ed2b914b7b2cedff8c34c7f2ef817e432a1/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FUserIssuesITCase.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FUserIssuesITCase.java?ref=44db3ed2b914b7b2cedff8c34c7f2ef817e432a1","patch":"@@ -604,7 +604,7 @@ public void issueSYNCOPE354() {\n         ResourceTO ldap = resourceService.read(RESOURCE_NAME_LDAP);\n         ldap.getProvision(AnyTypeKind.GROUP.name()).get().getMapping().getItems().stream().\n                 filter(item -> (\"description\".equals(item.getExtAttrName()))).\n-                forEachOrdered(item -> item.setExtAttrName(\"uniqueMember\"));\n+                forEach(item -> item.setExtAttrName(\"uniqueMember\"));\n         resourceService.update(ldap);\n \n         // 1. create group with LDAP resource\n@@ -654,8 +654,8 @@ public void issueSYNCOPE354() {\n \n         // 7. restore original resource-ldap group mapping\n         ldap.getProvision(AnyTypeKind.GROUP.name()).get().getMapping().getItems().stream().\n-                filter(item -> (\"uniqueMember\".equals(item.getExtAttrName()))).\n-                forEachOrdered(item -> item.setExtAttrName(\"description\"));\n+                filter(item -> \"uniqueMember\".equals(item.getExtAttrName())).\n+                forEach(item -> item.setExtAttrName(\"description\"));\n         resourceService.update(ldap);\n     }\n "}]}