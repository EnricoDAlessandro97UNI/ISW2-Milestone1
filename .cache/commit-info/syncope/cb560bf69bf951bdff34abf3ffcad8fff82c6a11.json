{"sha":"cb560bf69bf951bdff34abf3ffcad8fff82c6a11","node_id":"MDY6Q29tbWl0NjM2ODc5MDYyOmNiNTYwYmY2OWJmOTUxYmRmZjM0YWJmM2ZmY2FkOGZmZjgyYzZhMTE=","commit":{"author":{"name":"Francesco Chicchiriccò","email":"ilgrosso@apache.org","date":"2019-10-08T09:26:19Z"},"committer":{"name":"Francesco Chicchiriccò","email":"ilgrosso@apache.org","date":"2019-10-08T11:36:17Z"},"message":"[SYNCOPE-957] Pull implemented","tree":{"sha":"b0c2993ff07a92411881b3e1fbb0fb063916c5b9","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/git/trees/b0c2993ff07a92411881b3e1fbb0fb063916c5b9"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/git/commits/cb560bf69bf951bdff34abf3ffcad8fff82c6a11","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/cb560bf69bf951bdff34abf3ffcad8fff82c6a11","html_url":"https://github.com/EnricoDAlessandro97UNI/syncope/commit/cb560bf69bf951bdff34abf3ffcad8fff82c6a11","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/comments","author":{"login":"ilgrosso","id":1064664,"node_id":"MDQ6VXNlcjEwNjQ2NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/1064664?v=4","gravatar_id":"","url":"https://api.github.com/users/ilgrosso","html_url":"https://github.com/ilgrosso","followers_url":"https://api.github.com/users/ilgrosso/followers","following_url":"https://api.github.com/users/ilgrosso/following{/other_user}","gists_url":"https://api.github.com/users/ilgrosso/gists{/gist_id}","starred_url":"https://api.github.com/users/ilgrosso/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ilgrosso/subscriptions","organizations_url":"https://api.github.com/users/ilgrosso/orgs","repos_url":"https://api.github.com/users/ilgrosso/repos","events_url":"https://api.github.com/users/ilgrosso/events{/privacy}","received_events_url":"https://api.github.com/users/ilgrosso/received_events","type":"User","site_admin":false},"committer":{"login":"ilgrosso","id":1064664,"node_id":"MDQ6VXNlcjEwNjQ2NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/1064664?v=4","gravatar_id":"","url":"https://api.github.com/users/ilgrosso","html_url":"https://github.com/ilgrosso","followers_url":"https://api.github.com/users/ilgrosso/followers","following_url":"https://api.github.com/users/ilgrosso/following{/other_user}","gists_url":"https://api.github.com/users/ilgrosso/gists{/gist_id}","starred_url":"https://api.github.com/users/ilgrosso/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ilgrosso/subscriptions","organizations_url":"https://api.github.com/users/ilgrosso/orgs","repos_url":"https://api.github.com/users/ilgrosso/repos","events_url":"https://api.github.com/users/ilgrosso/events{/privacy}","received_events_url":"https://api.github.com/users/ilgrosso/received_events","type":"User","site_admin":false},"parents":[{"sha":"79c3ed840793f753ce208ae49ff4a4bb5bd05c1a","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/79c3ed840793f753ce208ae49ff4a4bb5bd05c1a","html_url":"https://github.com/EnricoDAlessandro97UNI/syncope/commit/79c3ed840793f753ce208ae49ff4a4bb5bd05c1a"}],"stats":{"total":2741,"additions":2022,"deletions":719},"files":[{"sha":"8cef25300a28038b31515c831db262c42f77881a","filename":"client/idrepo/console/src/main/resources/org/apache/syncope/client/console/implementations/MyLogicActions.groovy","status":"modified","additions":41,"deletions":14,"changes":55,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/client%2Fidrepo%2Fconsole%2Fsrc%2Fmain%2Fresources%2Forg%2Fapache%2Fsyncope%2Fclient%2Fconsole%2Fimplementations%2FMyLogicActions.groovy","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/client%2Fidrepo%2Fconsole%2Fsrc%2Fmain%2Fresources%2Forg%2Fapache%2Fsyncope%2Fclient%2Fconsole%2Fimplementations%2FMyLogicActions.groovy","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/client%2Fidrepo%2Fconsole%2Fsrc%2Fmain%2Fresources%2Forg%2Fapache%2Fsyncope%2Fclient%2Fconsole%2Fimplementations%2FMyLogicActions.groovy?ref=cb560bf69bf951bdff34abf3ffcad8fff82c6a11","patch":"@@ -17,41 +17,68 @@\n  * under the License.\n  */\n import groovy.transform.CompileStatic\n+import java.util.List\n+import java.util.function.Function\n import org.apache.syncope.common.lib.request.AnyCR;\n import org.apache.syncope.common.lib.request.AnyUR;\n-import org.apache.syncope.common.lib.to.AnyTO;\n+import org.apache.syncope.common.lib.to.AnyTO\n+import org.apache.syncope.common.lib.to.PropagationStatus\n import org.apache.syncope.core.provisioning.api.LogicActions\n \n @CompileStatic\n class MyLogicActions implements LogicActions {\n   \n   @Override\n-  <C extends AnyCR> C beforeCreate(C input) {\n-    return input;\n+  <C extends AnyCR> Function<C, C> beforeCreate() {\n+    Function function = { \n+      C input ->\n+      return input;        \n+    }\n+    return function;\n   }\n \n   @Override\n-  <A extends AnyTO> A afterCreate(A input) {\n-    return input;\n+  <A extends AnyTO> Function<A, A> afterCreate(List<PropagationStatus> statuses) {\n+    Function function = { \n+      A input ->\n+      return input;        \n+    }\n+    return function;\n   }\n \n   @Override\n-  <U extends AnyUR> U beforeUpdate(U input) {\n-    return input;\n+  <U extends AnyUR> Function<U, U> beforeUpdate() {\n+    Function function = { \n+      U input ->\n+      return input;        \n+    }\n+    return function;\n   }\n \n   @Override\n-  <A extends AnyTO> A afterUpdate(A input) {\n-    return input;\n+  <A extends AnyTO> Function<A, A> afterUpdate(List<PropagationStatus> statuses) {\n+    Function function = { \n+      A input ->\n+      return input;        \n+    }\n+    return function;\n   }\n \n   @Override\n-  <A extends AnyTO> A beforeDelete(A input) {\n-    return input;\n+  <A extends AnyTO> Function<A, A> beforeDelete() {\n+    Function function = { \n+      A input ->\n+      return input;        \n+    }\n+    return function;\n   }\n \n   @Override\n-  <A extends AnyTO> A afterDelete(A input) {\n-    return input;\n+  <A extends AnyTO> Function<A, A> afterDelete(List<PropagationStatus> statuses) {\n+    Function function = { \n+      A input ->\n+      return input;        \n+    }\n+    return function;\n   }\n-}\n+}\n\\ No newline at end of file"},{"sha":"7a8b7652f96c2485c954d9b0de7626850cadf1ae","filename":"client/idrepo/console/src/main/resources/org/apache/syncope/client/console/implementations/MyPullActions.groovy","status":"modified","additions":7,"deletions":2,"changes":9,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/client%2Fidrepo%2Fconsole%2Fsrc%2Fmain%2Fresources%2Forg%2Fapache%2Fsyncope%2Fclient%2Fconsole%2Fimplementations%2FMyPullActions.groovy","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/client%2Fidrepo%2Fconsole%2Fsrc%2Fmain%2Fresources%2Forg%2Fapache%2Fsyncope%2Fclient%2Fconsole%2Fimplementations%2FMyPullActions.groovy","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/client%2Fidrepo%2Fconsole%2Fsrc%2Fmain%2Fresources%2Forg%2Fapache%2Fsyncope%2Fclient%2Fconsole%2Fimplementations%2FMyPullActions.groovy?ref=cb560bf69bf951bdff34abf3ffcad8fff82c6a11","patch":"@@ -29,13 +29,18 @@ import org.apache.syncope.core.provisioning.api.pushpull.ProvisioningReport\n import org.apache.syncope.core.provisioning.api.pushpull.PullActions\n import org.identityconnectors.framework.common.objects.SyncDelta\n import org.quartz.JobExecutionException\n+import java.util.function.Function\n \n @CompileStatic\n class MyPullActions implements PullActions {\n   \n   @Override\n-  SyncDelta preprocess(ProvisioningProfile profile, SyncDelta delta) {\n-    return delta;\n+  Function<SyncDelta, SyncDelta> preprocess(ProvisioningProfile<?, ?> profile) {\n+    Function function = { \n+      SyncDelta delta ->\n+      return delta;        \n+    }\n+    return function;\n   }\n   \n   @Override"},{"sha":"7ce3f71f2f2600dc09edb87a71195297951ca2d1","filename":"common/idrepo/lib/src/main/java/org/apache/syncope/common/lib/EntityTOUtils.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/common%2Fidrepo%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2FEntityTOUtils.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/common%2Fidrepo%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2FEntityTOUtils.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/common%2Fidrepo%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2FEntityTOUtils.java?ref=cb560bf69bf951bdff34abf3ffcad8fff82c6a11","patch":"@@ -58,7 +58,7 @@ public static Map<Pair<String, String>, LinkedAccountTO> buildLinkedAccountMap(\n             final Collection<LinkedAccountTO> accounts) {\n \n         return accounts.stream().collect(Collectors.toUnmodifiableMap(\n-                account -> Pair.of(account.getResource(), account.getconnObjectKeyValue()),\n+                account -> Pair.of(account.getResource(), account.getConnObjectKeyValue()),\n                 Function.identity(),\n                 (exist, repl) -> repl));\n     }"},{"sha":"05c626157a8ce1b67adb426a4c9bf437f102c163","filename":"common/idrepo/lib/src/main/java/org/apache/syncope/common/lib/to/LinkedAccountTO.java","status":"modified","additions":22,"deletions":5,"changes":27,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/common%2Fidrepo%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FLinkedAccountTO.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/common%2Fidrepo%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FLinkedAccountTO.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/common%2Fidrepo%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FLinkedAccountTO.java?ref=cb560bf69bf951bdff34abf3ffcad8fff82c6a11","patch":"@@ -20,7 +20,6 @@\n \n import com.fasterxml.jackson.annotation.JsonIgnore;\n import com.fasterxml.jackson.annotation.JsonProperty;\n-import java.io.Serializable;\n import java.util.HashSet;\n import java.util.Optional;\n import java.util.Set;\n@@ -34,7 +33,7 @@\n \n @XmlRootElement(name = \"linkedAccount\")\n @XmlType\n-public class LinkedAccountTO implements Serializable {\n+public class LinkedAccountTO implements EntityTO {\n \n     private static final long serialVersionUID = 7396929732310559535L;\n \n@@ -43,8 +42,13 @@ public static class Builder {\n         private final LinkedAccountTO instance = new LinkedAccountTO();\n \n         public Builder(final String resource, final String connObjectKeyValue) {\n+            this(null, resource, connObjectKeyValue);\n+        }\n+\n+        public Builder(final String key, final String resource, final String connObjectKeyValue) {\n+            instance.setKey(key);\n             instance.setResource(resource);\n-            instance.setconnObjectKeyValue(connObjectKeyValue);\n+            instance.setConnObjectKeyValue(connObjectKeyValue);\n         }\n \n         public Builder username(final String username) {\n@@ -67,6 +71,8 @@ public LinkedAccountTO build() {\n         }\n     }\n \n+    private String key;\n+\n     private String connObjectKeyValue;\n \n     private String resource;\n@@ -81,11 +87,20 @@ public LinkedAccountTO build() {\n \n     private final Set<String> privileges = new HashSet<>();\n \n-    public String getconnObjectKeyValue() {\n+    public String getKey() {\n+        return key;\n+    }\n+\n+    @Override\n+    public void setKey(final String key) {\n+        this.key = key;\n+    }\n+\n+    public String getConnObjectKeyValue() {\n         return connObjectKeyValue;\n     }\n \n-    public void setconnObjectKeyValue(final String connObjectKeyValue) {\n+    public void setConnObjectKeyValue(final String connObjectKeyValue) {\n         this.connObjectKeyValue = connObjectKeyValue;\n     }\n \n@@ -143,6 +158,7 @@ public Set<String> getPrivileges() {\n     @Override\n     public int hashCode() {\n         return new HashCodeBuilder().\n+                append(key).\n                 append(connObjectKeyValue).\n                 append(resource).\n                 append(username).\n@@ -165,6 +181,7 @@ public boolean equals(final Object obj) {\n         }\n         final LinkedAccountTO other = (LinkedAccountTO) obj;\n         return new EqualsBuilder().\n+                append(key, other.key).\n                 append(connObjectKeyValue, other.connObjectKeyValue).\n                 append(resource, other.resource).\n                 append(username, other.username)."},{"sha":"365801d7485c6eb4b134fab89ea7ca4a1f597c3f","filename":"core/idrepo/logic/src/main/java/org/apache/syncope/core/logic/AbstractAnyLogic.java","status":"modified","additions":34,"deletions":21,"changes":55,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/core%2Fidrepo%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Flogic%2FAbstractAnyLogic.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/core%2Fidrepo%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Flogic%2FAbstractAnyLogic.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fidrepo%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Flogic%2FAbstractAnyLogic.java?ref=cb560bf69bf951bdff34abf3ffcad8fff82c6a11","patch":"@@ -22,6 +22,7 @@\n import java.util.HashSet;\n import java.util.List;\n import java.util.Set;\n+import java.util.function.Function;\n import org.apache.commons.lang3.tuple.Pair;\n import org.apache.syncope.common.lib.SyncopeClientException;\n import org.apache.syncope.common.lib.request.AnyCR;\n@@ -86,6 +87,7 @@ private static List<LogicActions> getActions(final Realm realm) {\n         return actions;\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     protected Pair<C, List<LogicActions>> beforeCreate(final C input) {\n         Realm realm = realmDAO.findByFullPath(input.getRealm());\n         if (realm == null) {\n@@ -112,15 +114,18 @@ protected Pair<C, List<LogicActions>> beforeCreate(final C input) {\n         templateUtils.apply(anyCR, realm.getTemplate(anyType));\n \n         List<LogicActions> actions = getActions(realm);\n-        for (LogicActions action : actions) {\n-            anyCR = action.beforeCreate(anyCR);\n-        }\n+\n+        anyCR = (C) actions.stream().\n+                map(action -> action.beforeCreate()).\n+                reduce(Function.identity(), Function::andThen).\n+                apply(anyCR);\n \n         LOG.debug(\"Input: {}\\nOutput: {}\\n\", input, anyCR);\n \n         return Pair.of(anyCR, actions);\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     protected Pair<U, List<LogicActions>> beforeUpdate(final U input, final String realmPath) {\n         Realm realm = realmDAO.findByFullPath(realmPath);\n         if (realm == null) {\n@@ -129,18 +134,20 @@ protected Pair<U, List<LogicActions>> beforeUpdate(final U input, final String r\n             throw sce;\n         }\n \n-        U mod = input;\n+        U update = input;\n \n         List<LogicActions> actions = getActions(realm);\n-        for (LogicActions action : actions) {\n-            mod = action.beforeUpdate(mod);\n-        }\n+        update = (U) actions.stream().\n+                map(action -> action.beforeUpdate()).\n+                reduce(Function.identity(), Function::andThen).\n+                apply(update);\n \n-        LOG.debug(\"Input: {}\\nOutput: {}\\n\", input, mod);\n+        LOG.debug(\"Input: {}\\nOutput: {}\\n\", input, update);\n \n-        return Pair.of(mod, actions);\n+        return Pair.of(update, actions);\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     protected Pair<TO, List<LogicActions>> beforeDelete(final TO input) {\n         Realm realm = realmDAO.findByFullPath(input.getRealm());\n         if (realm == null) {\n@@ -152,23 +159,26 @@ protected Pair<TO, List<LogicActions>> beforeDelete(final TO input) {\n         TO any = input;\n \n         List<LogicActions> actions = getActions(realm);\n-        for (LogicActions action : actions) {\n-            any = action.beforeDelete(any);\n-        }\n+        any = (TO) actions.stream().\n+                map(action -> action.beforeDelete()).\n+                reduce(Function.identity(), Function::andThen).\n+                apply(any);\n \n         LOG.debug(\"Input: {}\\nOutput: {}\\n\", input, any);\n \n         return Pair.of(any, actions);\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     protected ProvisioningResult<TO> afterCreate(\n             final TO input, final List<PropagationStatus> statuses, final List<LogicActions> actions) {\n \n         TO any = input;\n \n-        for (LogicActions action : actions) {\n-            any = action.afterCreate(any, statuses);\n-        }\n+        any = (TO) actions.stream().\n+                map(action -> action.afterCreate(statuses)).\n+                reduce(Function.identity(), Function::andThen).\n+                apply(any);\n \n         ProvisioningResult<TO> result = new ProvisioningResult<>();\n         result.setEntity(any);\n@@ -197,9 +207,10 @@ protected ProvisioningResult<TO> afterUpdate(\n \n         TO any = input;\n \n-        for (LogicActions action : actions) {\n-            any = action.afterUpdate(any, statuses);\n-        }\n+        any = (TO) actions.stream().\n+                map(action -> action.afterUpdate(statuses)).\n+                reduce(Function.identity(), Function::andThen).\n+                apply(any);\n \n         ProvisioningResult<TO> result = new ProvisioningResult<>();\n         result.setEntity(any);\n@@ -208,14 +219,16 @@ protected ProvisioningResult<TO> afterUpdate(\n         return result;\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     protected ProvisioningResult<TO> afterDelete(\n             final TO input, final List<PropagationStatus> statuses, final List<LogicActions> actions) {\n \n         TO any = input;\n \n-        for (LogicActions action : actions) {\n-            any = action.afterDelete(any, statuses);\n-        }\n+        any = (TO) actions.stream().\n+                map(action -> action.afterDelete(statuses)).\n+                reduce(Function.identity(), Function::andThen).\n+                apply(any);\n \n         ProvisioningResult<TO> result = new ProvisioningResult<>();\n         result.setEntity(any);"},{"sha":"332baabfd22030dd268d8e67cfc716a8bcae9b0b","filename":"core/persistence-api/src/main/java/org/apache/syncope/core/persistence/api/dao/PullCorrelationRule.java","status":"modified","additions":33,"deletions":0,"changes":33,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/core%2Fpersistence-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fapi%2Fdao%2FPullCorrelationRule.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/core%2Fpersistence-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fapi%2Fdao%2FPullCorrelationRule.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fpersistence-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fapi%2Fdao%2FPullCorrelationRule.java?ref=cb560bf69bf951bdff34abf3ffcad8fff82c6a11","patch":"@@ -18,8 +18,10 @@\n  */\n package org.apache.syncope.core.persistence.api.dao;\n \n+import java.util.Optional;\n import org.apache.syncope.common.lib.policy.PullCorrelationRuleConf;\n import org.apache.syncope.core.persistence.api.dao.search.SearchCond;\n+import org.apache.syncope.core.persistence.api.entity.Any;\n import org.apache.syncope.core.persistence.api.entity.resource.Provision;\n import org.identityconnectors.framework.common.objects.SyncDelta;\n \n@@ -29,6 +31,8 @@\n @FunctionalInterface\n public interface PullCorrelationRule {\n \n+    PullMatch NO_MATCH = new PullMatch.Builder().build();\n+\n     default void setConf(PullCorrelationRuleConf conf) {\n     }\n \n@@ -40,4 +44,33 @@ default void setConf(PullCorrelationRuleConf conf) {\n      * @return search condition.\n      */\n     SearchCond getSearchCond(SyncDelta syncDelta, Provision provision);\n+\n+    /**\n+     * Create matching information for the given Any, found matching for the given\n+     * {@link SyncDelta} and {@link Provision}.\n+     * For users, this might end with creating / updating / deleting a\n+     * {@link org.apache.syncope.core.persistence.api.entity.user.LinkedAccount}.\n+     *\n+     * @param any any\n+     * @param syncDelta change operation, including external attributes\n+     * @param provision resource provision\n+     * @return matching information\n+     */\n+    default PullMatch matching(Any<?> any, SyncDelta syncDelta, Provision provision) {\n+        return new PullMatch.Builder().matchingKey(any.getKey()).build();\n+    }\n+\n+    /**\n+     * Optionally create matching information in case no matching Any was found for the given\n+     * {@link SyncDelta} and {@link Provision}.\n+     * For users, this might end with creating a\n+     * {@link org.apache.syncope.core.persistence.api.entity.user.LinkedAccount}.\n+     *\n+     * @param syncDelta change operation, including external attributes\n+     * @param provision resource provision\n+     * @return matching information\n+     */\n+    default Optional<PullMatch> unmatching(SyncDelta syncDelta, Provision provision) {\n+        return Optional.of(NO_MATCH);\n+    }\n }"},{"sha":"f66906f0fb045e80e72773591afa2914644b4419","filename":"core/persistence-api/src/main/java/org/apache/syncope/core/persistence/api/dao/PullMatch.java","status":"added","additions":116,"deletions":0,"changes":116,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/core%2Fpersistence-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fapi%2Fdao%2FPullMatch.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/core%2Fpersistence-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fapi%2Fdao%2FPullMatch.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fpersistence-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fapi%2Fdao%2FPullMatch.java?ref=cb560bf69bf951bdff34abf3ffcad8fff82c6a11","patch":"@@ -0,0 +1,116 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.core.persistence.api.dao;\n+\n+import java.io.Serializable;\n+import org.apache.commons.lang3.builder.EqualsBuilder;\n+import org.apache.commons.lang3.builder.HashCodeBuilder;\n+\n+public final class PullMatch implements Serializable {\n+\n+    private static final long serialVersionUID = 6515473131174179932L;\n+\n+    public enum MatchTarget {\n+        ANY,\n+        LINKED_ACCOUNT;\n+\n+    }\n+\n+    public static class Builder {\n+\n+        private final PullMatch instance = new PullMatch();\n+\n+        public Builder matchingKey(final String matchingKey) {\n+            instance.matchingKey = matchingKey;\n+            return this;\n+        }\n+\n+        public Builder matchTarget(final MatchTarget matchTarget) {\n+            instance.matchTarget = matchTarget;\n+            return this;\n+        }\n+\n+        public Builder linkingUserKey(final String linkingUserKey) {\n+            instance.linkingUserKey = linkingUserKey;\n+            return this;\n+        }\n+\n+        public PullMatch build() {\n+            return instance;\n+        }\n+    }\n+\n+    private MatchTarget matchTarget = MatchTarget.ANY;\n+\n+    private String matchingKey;\n+\n+    private String linkingUserKey;\n+\n+    private PullMatch() {\n+        // private constructor\n+    }\n+\n+    public MatchTarget getMatchTarget() {\n+        return matchTarget;\n+    }\n+\n+    public String getMatchingKey() {\n+        return matchingKey;\n+    }\n+\n+    public String getLinkingUserKey() {\n+        return linkingUserKey;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return new HashCodeBuilder().\n+                append(matchTarget).\n+                append(matchingKey).\n+                append(linkingUserKey).\n+                build();\n+    }\n+\n+    @Override\n+    public boolean equals(final Object obj) {\n+        if (this == obj) {\n+            return true;\n+        }\n+        if (obj == null) {\n+            return false;\n+        }\n+        if (getClass() != obj.getClass()) {\n+            return false;\n+        }\n+        final PullMatch other = (PullMatch) obj;\n+        return new EqualsBuilder().\n+                append(matchingKey, other.matchingKey).\n+                append(matchTarget, other.matchTarget).\n+                append(linkingUserKey, other.linkingUserKey).\n+                build();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"PullMatch{\"\n+                + \"matchTarget=\" + matchTarget\n+                + \", matchingKey=\" + matchingKey\n+                + \", linkingUserKey=\" + linkingUserKey + '}';\n+    }\n+}"},{"sha":"e2a2f659feb4f3e11966f196a71045805dd8ee74","filename":"core/provisioning-api/src/main/java/org/apache/syncope/core/provisioning/api/LogicActions.java","status":"modified","additions":13,"deletions":12,"changes":25,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/core%2Fprovisioning-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fapi%2FLogicActions.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/core%2Fprovisioning-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fapi%2FLogicActions.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fapi%2FLogicActions.java?ref=cb560bf69bf951bdff34abf3ffcad8fff82c6a11","patch":"@@ -19,6 +19,7 @@\n package org.apache.syncope.core.provisioning.api;\n \n import java.util.List;\n+import java.util.function.Function;\n import org.apache.syncope.common.lib.request.AnyCR;\n import org.apache.syncope.common.lib.request.AnyUR;\n import org.apache.syncope.common.lib.to.AnyTO;\n@@ -29,27 +30,27 @@\n  */\n public interface LogicActions {\n \n-    default <C extends AnyCR> C beforeCreate(C input) {\n-        return input;\n+    default <C extends AnyCR> Function<C, C> beforeCreate() {\n+        return Function.identity();\n     }\n \n-    default <A extends AnyTO> A afterCreate(A input, List<PropagationStatus> statuses) {\n-        return input;\n+    default <A extends AnyTO> Function<A, A> afterCreate(List<PropagationStatus> statuses) {\n+        return Function.identity();\n     }\n \n-    default <U extends AnyUR> U beforeUpdate(U input) {\n-        return input;\n+    default <U extends AnyUR> Function<U, U> beforeUpdate() {\n+        return Function.identity();\n     }\n \n-    default <A extends AnyTO> A afterUpdate(A input, List<PropagationStatus> statuses) {\n-        return input;\n+    default <A extends AnyTO> Function<A, A> afterUpdate(List<PropagationStatus> statuses) {\n+        return Function.identity();\n     }\n \n-    default <A extends AnyTO> A beforeDelete(A input) {\n-        return input;\n+    default <A extends AnyTO> Function<A, A> beforeDelete() {\n+        return Function.identity();\n     }\n \n-    default <A extends AnyTO> A afterDelete(A input, List<PropagationStatus> statuses) {\n-        return input;\n+    default <A extends AnyTO> Function<A, A> afterDelete(List<PropagationStatus> statuses) {\n+        return Function.identity();\n     }\n }"},{"sha":"73626b7c36da47aebdd38752368f634d7356bfd4","filename":"core/provisioning-api/src/main/java/org/apache/syncope/core/provisioning/api/PropagationByResource.java","status":"modified","additions":10,"deletions":10,"changes":20,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/core%2Fprovisioning-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fapi%2FPropagationByResource.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/core%2Fprovisioning-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fapi%2FPropagationByResource.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fapi%2FPropagationByResource.java?ref=cb560bf69bf951bdff34abf3ffcad8fff82c6a11","patch":"@@ -192,28 +192,28 @@ public boolean removeAll(final ResourceOperation type, final Set<T> keys) {\n      * Removes only the resource names in the underlying resource name sets that are contained in the specified\n      * collection.\n      *\n-     * @param resourceKeys collection containing resource names to be retained in the underlying resource name sets\n+     * @param keys collection containing resource names to be retained in the underlying resource name sets\n      * @return {@code true} if the underlying resource name sets changed as a result of the call\n      * @see Collection#removeAll(java.util.Collection)\n      */\n-    public boolean removeAll(final Collection<String> resourceKeys) {\n-        return toBeCreated.removeAll(resourceKeys)\n-                | toBeUpdated.removeAll(resourceKeys)\n-                | toBeDeleted.removeAll(resourceKeys);\n+    public boolean removeAll(final Collection<T> keys) {\n+        return toBeCreated.removeAll(keys)\n+                | toBeUpdated.removeAll(keys)\n+                | toBeDeleted.removeAll(keys);\n     }\n \n     /**\n      * Retains only the resource names in the underlying resource name sets that are contained in the specified\n      * collection.\n      *\n-     * @param resourceKeys collection containing resource names to be retained in the underlying resource name sets\n+     * @param keys collection containing resource names to be retained in the underlying resource name sets\n      * @return {@code true} if the underlying resource name sets changed as a result of the call\n      * @see Collection#retainAll(java.util.Collection)\n      */\n-    public boolean retainAll(final Collection<String> resourceKeys) {\n-        return toBeCreated.retainAll(resourceKeys)\n-                | toBeUpdated.retainAll(resourceKeys)\n-                | toBeDeleted.retainAll(resourceKeys);\n+    public boolean retainAll(final Collection<T> keys) {\n+        return toBeCreated.retainAll(keys)\n+                | toBeUpdated.retainAll(keys)\n+                | toBeDeleted.retainAll(keys);\n     }\n \n     public boolean contains(final ResourceOperation type, final T key) {"},{"sha":"f68f9aa7742cda68f90e3b242115aa8fd2a513f3","filename":"core/provisioning-api/src/main/java/org/apache/syncope/core/provisioning/api/cache/VirAttrCacheValue.java","status":"modified","additions":23,"deletions":42,"changes":65,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/core%2Fprovisioning-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fapi%2Fcache%2FVirAttrCacheValue.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/core%2Fprovisioning-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fapi%2Fcache%2FVirAttrCacheValue.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fapi%2Fcache%2FVirAttrCacheValue.java?ref=cb560bf69bf951bdff34abf3ffcad8fff82c6a11","patch":"@@ -22,7 +22,8 @@\n import java.util.Collection;\n import java.util.Date;\n import java.util.List;\n-import java.util.Objects;\n+import org.apache.commons.lang3.builder.EqualsBuilder;\n+import org.apache.commons.lang3.builder.HashCodeBuilder;\n \n /**\n  * Cache entry value.\n@@ -32,7 +33,7 @@ public class VirAttrCacheValue {\n     /**\n      * Virtual attribute values.\n      */\n-    private final List<String> values;\n+    private final List<String> values = new ArrayList<>();\n \n     /**\n      * Entry creation date.\n@@ -44,57 +45,39 @@ public class VirAttrCacheValue {\n      */\n     private Date lastAccessDate;\n \n-    public VirAttrCacheValue() {\n-        this.creationDate = new Date();\n-        this.lastAccessDate = new Date();\n-        this.values = new ArrayList<>();\n-    }\n-\n-    public void setValues(final Collection<Object> values) {\n-        this.values.clear();\n+    public VirAttrCacheValue(final Collection<Object> values) {\n+        creationDate = new Date();\n+        lastAccessDate = new Date();\n \n         if (values != null) {\n             values.forEach(value -> this.values.add(value.toString()));\n         }\n     }\n \n+    public List<String> getValues() {\n+        lastAccessDate = new Date();\n+        return values;\n+    }\n+\n     public Date getCreationDate() {\n-        if (creationDate != null) {\n-            return new Date(creationDate.getTime());\n-        }\n-        return null;\n+        return new Date(creationDate.getTime());\n     }\n \n     public void forceExpiring() {\n         creationDate = new Date(0);\n     }\n \n-    public List<String> getValues() {\n-        return values;\n-    }\n-\n     public Date getLastAccessDate() {\n-        if (lastAccessDate != null) {\n-            return new Date(lastAccessDate.getTime());\n-        }\n-        return null;\n-    }\n-\n-    public void setLastAccessDate(final Date lastAccessDate) {\n-        if (lastAccessDate != null) {\n-            this.lastAccessDate = new Date(lastAccessDate.getTime());\n-        } else {\n-            this.lastAccessDate = null;\n-        }\n+        return new Date(lastAccessDate.getTime());\n     }\n \n     @Override\n     public int hashCode() {\n-        int hash = 5;\n-        hash = 67 * hash + Objects.hashCode(this.values);\n-        hash = 67 * hash + Objects.hashCode(this.creationDate);\n-        hash = 67 * hash + Objects.hashCode(this.lastAccessDate);\n-        return hash;\n+        return new HashCodeBuilder().\n+                append(values).\n+                append(creationDate).\n+                append(lastAccessDate).\n+                build();\n     }\n \n     @Override\n@@ -109,13 +92,11 @@ public boolean equals(final Object obj) {\n             return false;\n         }\n         final VirAttrCacheValue other = (VirAttrCacheValue) obj;\n-        if (!Objects.equals(this.values, other.values)) {\n-            return false;\n-        }\n-        if (!Objects.equals(this.creationDate, other.creationDate)) {\n-            return false;\n-        }\n-        return Objects.equals(this.lastAccessDate, other.lastAccessDate);\n+        return new EqualsBuilder().\n+                append(values, other.values).\n+                append(creationDate, other.creationDate).\n+                append(lastAccessDate, other.lastAccessDate).\n+                build();\n     }\n \n     @Override"},{"sha":"81e34714cb586cf7aa4bb5e7bdde2267cf094517","filename":"core/provisioning-api/src/main/java/org/apache/syncope/core/provisioning/api/data/UserDataBinder.java","status":"modified","additions":4,"deletions":0,"changes":4,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/core%2Fprovisioning-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fapi%2Fdata%2FUserDataBinder.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/core%2Fprovisioning-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fapi%2Fdata%2FUserDataBinder.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fapi%2Fdata%2FUserDataBinder.java?ref=cb560bf69bf951bdff34abf3ffcad8fff82c6a11","patch":"@@ -21,7 +21,9 @@\n import org.apache.syncope.common.lib.request.UserCR;\n import org.apache.syncope.common.lib.request.UserUR;\n import org.apache.commons.lang3.tuple.Pair;\n+import org.apache.syncope.common.lib.to.LinkedAccountTO;\n import org.apache.syncope.common.lib.to.UserTO;\n+import org.apache.syncope.core.persistence.api.entity.user.LinkedAccount;\n import org.apache.syncope.core.provisioning.api.PropagationByResource;\n import org.apache.syncope.core.persistence.api.entity.user.User;\n \n@@ -35,6 +37,8 @@ public interface UserDataBinder {\n \n     UserTO getUserTO(User user, boolean details);\n \n+    LinkedAccountTO getLinkedAccountTO(LinkedAccount account);\n+\n     void create(User user, UserCR userCR);\n \n     /**"},{"sha":"3c0a6f0795481985209f6c392abb57eb4f5ea0c8","filename":"core/provisioning-api/src/main/java/org/apache/syncope/core/provisioning/api/pushpull/ProvisioningReport.java","status":"modified","additions":15,"deletions":15,"changes":30,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/core%2Fprovisioning-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fapi%2Fpushpull%2FProvisioningReport.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/core%2Fprovisioning-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fapi%2Fpushpull%2FProvisioningReport.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fapi%2Fpushpull%2FProvisioningReport.java?ref=cb560bf69bf951bdff34abf3ffcad8fff82c6a11","patch":"@@ -104,19 +104,6 @@ public void setUidValue(final String uidValue) {\n         this.uidValue = uidValue;\n     }\n \n-    @Override\n-    public String toString() {\n-        return new ToStringBuilder(this).\n-                append(message).\n-                append(status).\n-                append(anyType).\n-                append(operation).\n-                append(key).\n-                append(name).\n-                append(uidValue).\n-                build();\n-    }\n-\n     /**\n      * Human readable report string, using the given trace level.\n      *\n@@ -148,9 +135,22 @@ public String getReportString(final TraceLevel level) {\n      */\n     public static String generate(final Collection<ProvisioningReport> results, final TraceLevel level) {\n         StringBuilder sb = new StringBuilder();\n-        for (ProvisioningReport result : results) {\n+        results.forEach(result -> {\n             sb.append(result.getReportString(level)).append('\\n');\n-        }\n+        });\n         return sb.toString();\n     }\n+\n+    @Override\n+    public String toString() {\n+        return new ToStringBuilder(this).\n+                append(message).\n+                append(status).\n+                append(anyType).\n+                append(operation).\n+                append(key).\n+                append(name).\n+                append(uidValue).\n+                build();\n+    }\n }"},{"sha":"03690bd86bcd7e37179b34411912b49992afb0cd","filename":"core/provisioning-api/src/main/java/org/apache/syncope/core/provisioning/api/pushpull/PullActions.java","status":"modified","additions":33,"deletions":4,"changes":37,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/core%2Fprovisioning-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fapi%2Fpushpull%2FPullActions.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/core%2Fprovisioning-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fapi%2Fpushpull%2FPullActions.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fapi%2Fpushpull%2FPullActions.java?ref=cb560bf69bf951bdff34abf3ffcad8fff82c6a11","patch":"@@ -20,7 +20,9 @@\n \n import org.apache.syncope.common.lib.request.AnyCR;\n import org.apache.syncope.common.lib.request.AnyUR;\n+import java.util.function.Function;\n import org.apache.syncope.common.lib.to.EntityTO;\n+import org.apache.syncope.common.lib.to.LinkedAccountTO;\n import org.apache.syncope.common.lib.to.RealmTO;\n import org.identityconnectors.framework.common.objects.SyncDelta;\n import org.quartz.JobExecutionException;\n@@ -36,11 +38,10 @@ public interface PullActions extends ProvisioningActions {\n      * Pre-process the pull information received by the underlying connector, before any internal activity occurs.\n      *\n      * @param profile profile of the pull being executed.\n-     * @param delta retrieved pull information\n-     * @return pull information, possibly altered.\n+     * @return pull information, possibly altered\n      */\n-    default SyncDelta preprocess(ProvisioningProfile<?, ?> profile, SyncDelta delta) {\n-        return delta;\n+    default Function<SyncDelta, SyncDelta> preprocess(ProvisioningProfile<?, ?> profile) {\n+        return Function.identity();\n     }\n \n     /**\n@@ -59,6 +60,20 @@ default void beforeProvision(\n             AnyCR createReq) throws JobExecutionException {\n     }\n \n+    /**\n+     * Action to be executed before locally creating a linked account.\n+     *\n+     * @param profile profile of the pull being executed.\n+     * @param delta retrieved pull information\n+     * @param linkedAccount create request\n+     * @throws JobExecutionException in case of generic failure\n+     */\n+    default void beforeProvision(\n+            ProvisioningProfile<?, ?> profile,\n+            SyncDelta delta,\n+            LinkedAccountTO linkedAccount) throws JobExecutionException {\n+    }\n+\n     /**\n      * Action to be executed before to create a pulled realm locally.\n      * The realm is created locally upon pull in case of the un-matching rule\n@@ -91,6 +106,20 @@ default void beforeAssign(\n             AnyCR createReq) throws JobExecutionException {\n     }\n \n+    /**\n+     * Action to be executed before locally creating a linked account.\n+     *\n+     * @param profile profile of the pull being executed.\n+     * @param delta retrieved pull information\n+     * @param linkedAccount linked account\n+     * @throws JobExecutionException in case of generic failure\n+     */\n+    default void beforeAssign(\n+            ProvisioningProfile<?, ?> profile,\n+            SyncDelta delta,\n+            LinkedAccountTO linkedAccount) throws JobExecutionException {\n+    }\n+\n     /**\n      * Action to be executed before creating (and linking to the resource) a pulled realm locally.\n      * The realm is created locally and linked to the pulled resource upon pull in case of the"},{"sha":"e41eeb0bdd9df5c58076e5ceeb401c47d361743d","filename":"core/provisioning-java/src/main/java/org/apache/syncope/core/provisioning/java/VirAttrHandlerImpl.java","status":"modified","additions":4,"deletions":3,"changes":7,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2FVirAttrHandlerImpl.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2FVirAttrHandlerImpl.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2FVirAttrHandlerImpl.java?ref=cb560bf69bf951bdff34abf3ffcad8fff82c6a11","patch":"@@ -125,10 +125,11 @@ private Map<VirSchema, List<String>> getValues(final Any<?> any, final Set<VirSc\n                         schemasToRead.forEach(schema -> {\n                             Attribute attr = connectorObject.getAttributeByName(schema.getExtAttrName());\n                             if (attr != null) {\n-                                VirAttrCacheValue virAttrCacheValue = new VirAttrCacheValue();\n-                                virAttrCacheValue.setValues(attr.getValue());\n+                                VirAttrCacheValue virAttrCacheValue = new VirAttrCacheValue(attr.getValue());\n                                 virAttrCache.put(\n-                                        any.getType().getKey(), any.getKey(), schema.getKey(),\n+                                        any.getType().getKey(),\n+                                        any.getKey(),\n+                                        schema.getKey(),\n                                         virAttrCacheValue);\n                                 LOG.debug(\"Values for {} set in cache: {}\", schema, virAttrCacheValue);\n "},{"sha":"efc039eb685c09ee61015094508040715ec993d8","filename":"core/provisioning-java/src/main/java/org/apache/syncope/core/provisioning/java/data/UserDataBinderImpl.java","status":"modified","additions":26,"deletions":22,"changes":48,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fdata%2FUserDataBinderImpl.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fdata%2FUserDataBinderImpl.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fdata%2FUserDataBinderImpl.java?ref=cb560bf69bf951bdff34abf3ffcad8fff82c6a11","patch":"@@ -166,7 +166,7 @@ private void linkedAccount(\n             LOG.debug(\"Ignoring invalid resource {}\", accountTO.getResource());\n         } else {\n             Optional<? extends LinkedAccount> found =\n-                    user.getLinkedAccount(resource.getKey(), accountTO.getconnObjectKeyValue());\n+                    user.getLinkedAccount(resource.getKey(), accountTO.getConnObjectKeyValue());\n             LinkedAccount account = found.isPresent()\n                     ? found.get()\n                     : new Supplier<LinkedAccount>() {\n@@ -177,7 +177,7 @@ public LinkedAccount get() {\n                             acct.setOwner(user);\n                             user.add(acct);\n \n-                            acct.setConnObjectKeyValue(accountTO.getconnObjectKeyValue());\n+                            acct.setConnObjectKeyValue(accountTO.getConnObjectKeyValue());\n                             acct.setResource(resource);\n \n                             return acct;\n@@ -591,7 +591,7 @@ public Pair<PropagationByResource<String>, PropagationByResource<Pair<String, St\n         userUR.getLinkedAccounts().stream().filter(patch -> patch.getLinkedAccountTO() != null).forEach(patch -> {\n             user.getLinkedAccount(\n                     patch.getLinkedAccountTO().getResource(),\n-                    patch.getLinkedAccountTO().getconnObjectKeyValue()).ifPresent(account -> {\n+                    patch.getLinkedAccountTO().getConnObjectKeyValue()).ifPresent(account -> {\n \n                 if (patch.getOperation() == PatchOperation.DELETE) {\n                     user.getLinkedAccounts().remove(account);\n@@ -679,6 +679,28 @@ public Pair<PropagationByResource<String>, PropagationByResource<Pair<String, St\n         return Pair.of(propByRes, propByLinkedAccount);\n     }\n \n+    @Transactional(readOnly = true)\n+    @Override\n+    public LinkedAccountTO getLinkedAccountTO(final LinkedAccount account) {\n+        LinkedAccountTO accountTO = new LinkedAccountTO.Builder(\n+                account.getKey(), account.getResource().getKey(), account.getConnObjectKeyValue()).\n+                username(account.getUsername()).\n+                password(account.getPassword()).\n+                suspended(BooleanUtils.isTrue(account.isSuspended())).\n+                build();\n+\n+        account.getPlainAttrs().forEach(plainAttr -> {\n+            accountTO.getPlainAttrs().add(\n+                    new Attr.Builder(plainAttr.getSchema().getKey()).\n+                            values(plainAttr.getValuesAsStrings()).build());\n+        });\n+\n+        accountTO.getPrivileges().addAll(account.getPrivileges().stream().\n+                map(Entity::getKey).collect(Collectors.toList()));\n+\n+        return accountTO;\n+    }\n+\n     @Transactional(readOnly = true)\n     @Override\n     public UserTO getUserTO(final User user, final boolean details) {\n@@ -751,25 +773,7 @@ public UserTO getUserTO(final User user, final boolean details) {\n \n             // linked accounts\n             userTO.getLinkedAccounts().addAll(\n-                    user.getLinkedAccounts().stream().map(account -> {\n-                        LinkedAccountTO accountTO = new LinkedAccountTO.Builder(\n-                                account.getResource().getKey(), account.getConnObjectKeyValue()).\n-                                username(account.getUsername()).\n-                                password(user.getPassword()).\n-                                suspended(BooleanUtils.isTrue(account.isSuspended())).\n-                                build();\n-\n-                        account.getPlainAttrs().forEach(plainAttr -> {\n-                            accountTO.getPlainAttrs().add(\n-                                    new Attr.Builder(plainAttr.getSchema().getKey()).\n-                                            values(plainAttr.getValuesAsStrings()).build());\n-                        });\n-\n-                        accountTO.getPrivileges().addAll(account.getPrivileges().stream().\n-                                map(Entity::getKey).collect(Collectors.toList()));\n-\n-                        return accountTO;\n-                    }).collect(Collectors.toList()));\n+                    user.getLinkedAccounts().stream().map(this::getLinkedAccountTO).collect(Collectors.toList()));\n         }\n \n         return userTO;"},{"sha":"ca26d3c4b4dd3f98ce900840ff989174687f7aee","filename":"core/provisioning-java/src/main/java/org/apache/syncope/core/provisioning/java/propagation/AbstractPropagationTaskExecutor.java","status":"modified","additions":5,"deletions":3,"changes":8,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpropagation%2FAbstractPropagationTaskExecutor.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpropagation%2FAbstractPropagationTaskExecutor.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpropagation%2FAbstractPropagationTaskExecutor.java?ref=cb560bf69bf951bdff34abf3ffcad8fff82c6a11","patch":"@@ -654,9 +654,11 @@ protected ConnectorObject getRemoteObject(\n                 if (attr == null) {\n                     virAttrCache.expire(task.getAnyType(), task.getEntityKey(), item.getIntAttrName());\n                 } else {\n-                    VirAttrCacheValue cacheValue = new VirAttrCacheValue();\n-                    cacheValue.setValues(attr.getValue());\n-                    virAttrCache.put(task.getAnyType(), task.getEntityKey(), item.getIntAttrName(), cacheValue);\n+                    virAttrCache.put(\n+                            task.getAnyType(),\n+                            task.getEntityKey(),\n+                            item.getIntAttrName(),\n+                            new VirAttrCacheValue(attr.getValue()));\n                 }\n             }\n         } catch (TimeoutException toe) {"},{"sha":"11261a948d7253650400063c5b2da81e6523cc49","filename":"core/provisioning-java/src/main/java/org/apache/syncope/core/provisioning/java/propagation/PriorityPropagationTaskExecutor.java","status":"modified","additions":7,"deletions":4,"changes":11,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpropagation%2FPriorityPropagationTaskExecutor.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpropagation%2FPriorityPropagationTaskExecutor.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpropagation%2FPriorityPropagationTaskExecutor.java?ref=cb560bf69bf951bdff34abf3ffcad8fff82c6a11","patch":"@@ -68,8 +68,8 @@ public class PriorityPropagationTaskExecutor extends AbstractPropagationTaskExec\n      * {@link java.util.concurrent.CompletionService}\n      */\n     protected static PropagationTaskCallable newPropagationTaskCallable(\n-        final PropagationTaskInfo taskInfo, final PropagationReporter reporter) {\n-        \n+            final PropagationTaskInfo taskInfo, final PropagationReporter reporter) {\n+\n         PropagationTaskCallable callable = (PropagationTaskCallable) ApplicationContextProvider.getBeanFactory().\n                 createBean(DefaultPropagationTaskCallable.class, AbstractBeanDefinition.AUTOWIRE_BY_TYPE, false);\n         callable.setTaskInfo(taskInfo);\n@@ -115,16 +115,19 @@ protected void doExecute(\n         prioritizedTasks.forEach(task -> {\n             TaskExec execution = null;\n             ExecStatus execStatus;\n+            String errorMessage = null;\n             try {\n                 execution = newPropagationTaskCallable(task, reporter).call();\n                 execStatus = ExecStatus.valueOf(execution.getStatus());\n             } catch (Exception e) {\n                 LOG.error(\"Unexpected exception\", e);\n                 execStatus = ExecStatus.FAILURE;\n+                errorMessage = e.getMessage();\n             }\n             if (execStatus != ExecStatus.SUCCESS) {\n-                throw new PropagationException(task.getResource(), Optional.ofNullable(execution)\n-                        .map(Exec::getMessage).orElse(null));\n+                throw new PropagationException(\n+                        task.getResource(),\n+                        Optional.ofNullable(execution).map(Exec::getMessage).orElse(errorMessage));\n             }\n         });\n "},{"sha":"47957d66e0b8bdf08d15a3fcb36e11aa66fa3ff8","filename":"core/provisioning-java/src/main/java/org/apache/syncope/core/provisioning/java/propagation/PropagationManagerImpl.java","status":"modified","additions":30,"deletions":3,"changes":33,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpropagation%2FPropagationManagerImpl.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpropagation%2FPropagationManagerImpl.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpropagation%2FPropagationManagerImpl.java?ref=cb560bf69bf951bdff34abf3ffcad8fff82c6a11","patch":"@@ -191,7 +191,14 @@ protected List<PropagationTaskInfo> getCreateTasks(\n         }\n \n         if (noPropResourceKeys != null) {\n-            propByRes.get(ResourceOperation.CREATE).removeAll(noPropResourceKeys);\n+            if (propByRes != null) {\n+                propByRes.get(ResourceOperation.CREATE).removeAll(noPropResourceKeys);\n+            }\n+\n+            if (propByLinkedAccount != null) {\n+                propByLinkedAccount.get(ResourceOperation.CREATE).\n+                        removeIf(account -> noPropResourceKeys.contains(account.getLeft()));\n+            }\n         }\n \n         return createTasks(any, password, true, enable, false, propByRes, propByLinkedAccount, vAttrs);\n@@ -301,8 +308,19 @@ protected List<PropagationTaskInfo> getUpdateTasks(\n             final Collection<Attr> vAttrs,\n             final Collection<String> noPropResourceKeys) {\n \n-        if (noPropResourceKeys != null && propByRes != null) {\n-            propByRes.removeAll(noPropResourceKeys);\n+        if (noPropResourceKeys != null) {\n+            if (propByRes != null) {\n+                propByRes.removeAll(noPropResourceKeys);\n+            }\n+\n+            if (propByLinkedAccount != null) {\n+                propByLinkedAccount.get(ResourceOperation.CREATE).\n+                        removeIf(account -> noPropResourceKeys.contains(account.getLeft()));\n+                propByLinkedAccount.get(ResourceOperation.UPDATE).\n+                        removeIf(account -> noPropResourceKeys.contains(account.getLeft()));\n+                propByLinkedAccount.get(ResourceOperation.DELETE).\n+                        removeIf(account -> noPropResourceKeys.contains(account.getLeft()));\n+            }\n         }\n \n         return createTasks(\n@@ -355,6 +373,15 @@ protected List<PropagationTaskInfo> getDeleteTasks(\n \n         if (noPropResourceKeys != null) {\n             localPropByRes.removeAll(noPropResourceKeys);\n+\n+            if (propByLinkedAccount != null) {\n+                propByLinkedAccount.get(ResourceOperation.CREATE).\n+                        removeIf(account -> noPropResourceKeys.contains(account.getLeft()));\n+                propByLinkedAccount.get(ResourceOperation.UPDATE).\n+                        removeIf(account -> noPropResourceKeys.contains(account.getLeft()));\n+                propByLinkedAccount.get(ResourceOperation.DELETE).\n+                        removeIf(account -> noPropResourceKeys.contains(account.getLeft()));\n+            }\n         }\n \n         return createTasks(any, null, false, false, true, localPropByRes, propByLinkedAccount, null);"},{"sha":"4e22d29702181c5f6cd6f3a25a18288fd3bb0e9e","filename":"core/provisioning-java/src/main/java/org/apache/syncope/core/provisioning/java/pushpull/AbstractPullResultHandler.java","status":"modified","additions":246,"deletions":257,"changes":503,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FAbstractPullResultHandler.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FAbstractPullResultHandler.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FAbstractPullResultHandler.java?ref=cb560bf69bf951bdff34abf3ffcad8fff82c6a11","patch":"@@ -19,18 +19,17 @@\n package org.apache.syncope.core.provisioning.java.pushpull;\n \n import java.util.ArrayList;\n+import java.util.Collections;\n import java.util.Date;\n import java.util.List;\n-import java.util.Set;\n-\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n import org.apache.commons.lang3.exception.ExceptionUtils;\n-import org.apache.commons.lang3.tuple.Pair;\n import org.apache.syncope.common.lib.AnyOperations;\n import org.apache.syncope.common.lib.request.AnyCR;\n import org.apache.syncope.common.lib.request.AnyUR;\n import org.apache.syncope.common.lib.request.StringPatchItem;\n import org.apache.syncope.common.lib.to.AnyTO;\n-import org.apache.syncope.common.lib.types.AnyTypeKind;\n import org.apache.syncope.common.lib.types.AuditElements;\n import org.apache.syncope.common.lib.types.AuditElements.Result;\n import org.apache.syncope.common.lib.types.MatchingRule;\n@@ -48,7 +47,6 @@\n import org.apache.syncope.core.persistence.api.entity.AnyUtils;\n import org.apache.syncope.core.persistence.api.entity.EntityFactory;\n import org.apache.syncope.core.persistence.api.entity.Remediation;\n-import org.apache.syncope.core.persistence.api.entity.VirSchema;\n import org.apache.syncope.core.persistence.api.entity.resource.Provision;\n import org.apache.syncope.core.persistence.api.entity.task.PullTask;\n import org.apache.syncope.core.provisioning.api.AuditManager;\n@@ -59,6 +57,7 @@\n import org.apache.syncope.core.provisioning.api.pushpull.IgnoreProvisionException;\n import org.apache.syncope.core.provisioning.api.pushpull.ProvisioningReport;\n import org.apache.syncope.core.provisioning.api.pushpull.PullActions;\n+import org.apache.syncope.core.persistence.api.dao.PullMatch;\n import org.apache.syncope.core.provisioning.api.pushpull.SyncopePullExecutor;\n import org.apache.syncope.core.provisioning.api.pushpull.SyncopePullResultHandler;\n import org.apache.syncope.core.provisioning.java.utils.ConnObjectUtils;\n@@ -70,6 +69,7 @@\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.transaction.annotation.Transactional;\n \n+@Transactional(rollbackFor = Throwable.class)\n public abstract class AbstractPullResultHandler extends AbstractSyncopeResultHandler<PullTask, PullActions>\n         implements SyncopePullResultHandler {\n \n@@ -119,7 +119,6 @@ public void setPullExecutor(final SyncopePullExecutor executor) {\n         this.executor = executor;\n     }\n \n-    @Transactional\n     @Override\n     public boolean handle(final SyncDelta delta) {\n         Provision provision = null;\n@@ -181,18 +180,22 @@ public boolean handle(final SyncDelta delta) {\n         }\n     }\n \n-    protected List<ProvisioningReport> assign(\n-            final SyncDelta delta, final Provision provision, final AnyUtils anyUtils)\n-            throws JobExecutionException {\n+    protected List<ProvisioningReport> provision(\n+            final UnmatchingRule rule,\n+            final SyncDelta delta,\n+            final Provision provision,\n+            final AnyUtils anyUtils) throws JobExecutionException {\n \n         if (!profile.getTask().isPerformCreate()) {\n             LOG.debug(\"PullTask not configured for create\");\n-            finalize(UnmatchingRule.toEventName(UnmatchingRule.ASSIGN), Result.SUCCESS, null, null, delta);\n+            finalize(UnmatchingRule.toEventName(rule), Result.SUCCESS, null, null, delta);\n             return List.of();\n         }\n \n-        AnyCR anyCR = connObjectUtils.getAnyCR(delta.getObject(), profile.getTask(), provision, anyUtils);\n-        anyCR.getResources().add(profile.getTask().getResource().getKey());\n+        AnyCR anyCR = connObjectUtils.getAnyCR(delta.getObject(), profile.getTask(), provision, anyUtils, true);\n+        if (rule == UnmatchingRule.ASSIGN) {\n+            anyCR.getResources().add(profile.getTask().getResource().getKey());\n+        }\n \n         ProvisioningReport result = new ProvisioningReport();\n         result.setOperation(ResourceOperation.CREATE);\n@@ -203,49 +206,65 @@ protected List<ProvisioningReport> assign(\n \n         if (profile.isDryRun()) {\n             result.setKey(null);\n-            finalize(UnmatchingRule.toEventName(UnmatchingRule.ASSIGN), Result.SUCCESS, null, null, delta);\n+            finalize(UnmatchingRule.toEventName(rule), Result.SUCCESS, null, null, delta);\n         } else {\n             for (PullActions action : profile.getActions()) {\n-                action.beforeAssign(profile, delta, anyCR);\n+                if (rule == UnmatchingRule.ASSIGN) {\n+                    action.beforeAssign(profile, delta, anyCR);\n+                } else if (rule == UnmatchingRule.PROVISION) {\n+                    action.beforeProvision(profile, delta, anyCR);\n+                }\n             }\n \n-            create(anyCR, delta, UnmatchingRule.toEventName(UnmatchingRule.ASSIGN), provision, result);\n-        }\n-\n-        return List.of(result);\n-    }\n-\n-    protected List<ProvisioningReport> provision(\n-            final SyncDelta delta, final Provision provision, final AnyUtils anyUtils)\n-            throws JobExecutionException {\n-\n-        if (!profile.getTask().isPerformCreate()) {\n-            LOG.debug(\"PullTask not configured for create\");\n-            finalize(UnmatchingRule.toEventName(UnmatchingRule.PROVISION), Result.SUCCESS, null, null, delta);\n-            return List.of();\n-        }\n+            Object output;\n+            Result resultStatus;\n \n-        AnyCR anyCR = connObjectUtils.getAnyCR(delta.getObject(), profile.getTask(), provision, anyUtils);\n+            try {\n+                AnyTO created = doCreate(anyCR, delta);\n+                output = created;\n+                result.setKey(created.getKey());\n+                result.setName(getName(created));\n+                resultStatus = Result.SUCCESS;\n+\n+                for (PullActions action : profile.getActions()) {\n+                    action.after(profile, delta, created, result);\n+                }\n \n-        ProvisioningReport result = new ProvisioningReport();\n-        result.setOperation(ResourceOperation.CREATE);\n-        result.setAnyType(provision.getAnyType().getKey());\n-        result.setStatus(ProvisioningReport.Status.SUCCESS);\n-        result.setName(getName(anyCR));\n-        result.setUidValue(delta.getUid().getUidValue());\n+                LOG.debug(\"{} {} successfully created\", created.getType(), created.getKey());\n+            } catch (PropagationException e) {\n+                // A propagation failure doesn't imply a pull failure.\n+                // The propagation exception status will be reported into the propagation task execution.\n+                LOG.error(\"Could not propagate {} {}\",\n+                        provision.getAnyType().getKey(), delta.getUid().getUidValue(), e);\n+                output = e;\n+                resultStatus = Result.FAILURE;\n+            } catch (Exception e) {\n+                throwIgnoreProvisionException(delta, e);\n \n-        if (profile.isDryRun()) {\n-            result.setKey(null);\n-            finalize(UnmatchingRule.toEventName(UnmatchingRule.PROVISION), Result.SUCCESS, null, null, delta);\n-        } else {\n-            for (PullActions action : profile.getActions()) {\n-                action.beforeProvision(profile, delta, anyCR);\n+                result.setStatus(ProvisioningReport.Status.FAILURE);\n+                result.setMessage(ExceptionUtils.getRootCauseMessage(e));\n+                LOG.error(\"Could not create {} {} \", provision.getAnyType().getKey(), delta.getUid().getUidValue(), e);\n+                output = e;\n+                resultStatus = Result.FAILURE;\n+\n+                if (profile.getTask().isRemediation()) {\n+                    Remediation entity = entityFactory.newEntity(Remediation.class);\n+                    entity.setAnyType(provision.getAnyType());\n+                    entity.setOperation(ResourceOperation.CREATE);\n+                    entity.setPayload(anyCR);\n+                    entity.setError(result.getMessage());\n+                    entity.setInstant(new Date());\n+                    entity.setRemoteName(delta.getObject().getName().getNameValue());\n+                    entity.setPullTask(profile.getTask());\n+\n+                    remediationDAO.save(entity);\n+                }\n             }\n \n-            create(anyCR, delta, UnmatchingRule.toEventName(UnmatchingRule.PROVISION), provision, result);\n+            finalize(UnmatchingRule.toEventName(rule), resultStatus, null, output, delta);\n         }\n \n-        return List.of(result);\n+        return Collections.singletonList(result);\n     }\n \n     protected void throwIgnoreProvisionException(final SyncDelta delta, final Exception exception)\n@@ -266,87 +285,34 @@ protected void throwIgnoreProvisionException(final SyncDelta delta, final Except\n         }\n     }\n \n-    protected void create(\n-            final AnyCR anyCR,\n-            final SyncDelta delta,\n-            final String operation,\n-            final Provision provision,\n-            final ProvisioningReport result)\n-            throws JobExecutionException {\n-\n-        Object output;\n-        Result resultStatus;\n-\n-        try {\n-            AnyTO created = doCreate(anyCR, delta);\n-            output = created;\n-            result.setKey(created.getKey());\n-            result.setName(getName(created));\n-            resultStatus = Result.SUCCESS;\n-\n-            for (PullActions action : profile.getActions()) {\n-                action.after(profile, delta, created, result);\n-            }\n-\n-            LOG.debug(\"{} {} successfully created\", created.getType(), created.getKey());\n-        } catch (PropagationException e) {\n-            // A propagation failure doesn't imply a pull failure.\n-            // The propagation exception status will be reported into the propagation task execution.\n-            LOG.error(\"Could not propagate {} {}\", provision.getAnyType().getKey(), delta.getUid().getUidValue(), e);\n-            output = e;\n-            resultStatus = Result.FAILURE;\n-        } catch (Exception e) {\n-            throwIgnoreProvisionException(delta, e);\n-\n-            result.setStatus(ProvisioningReport.Status.FAILURE);\n-            result.setMessage(ExceptionUtils.getRootCauseMessage(e));\n-            LOG.error(\"Could not create {} {} \", provision.getAnyType().getKey(), delta.getUid().getUidValue(), e);\n-            output = e;\n-            resultStatus = Result.FAILURE;\n-\n-            if (profile.getTask().isRemediation()) {\n-                Remediation entity = entityFactory.newEntity(Remediation.class);\n-                entity.setAnyType(provision.getAnyType());\n-                entity.setOperation(ResourceOperation.CREATE);\n-                entity.setPayload(anyCR);\n-                entity.setError(result.getMessage());\n-                entity.setInstant(new Date());\n-                entity.setRemoteName(delta.getObject().getName().getNameValue());\n-                entity.setPullTask(profile.getTask());\n-\n-                remediationDAO.save(entity);\n-            }\n-        }\n-\n-        finalize(operation, resultStatus, null, output, delta);\n-    }\n-\n     protected List<ProvisioningReport> update(\n-            final SyncDelta delta, final List<String> anyKeys, final Provision provision) throws JobExecutionException {\n+            final SyncDelta delta,\n+            final List<PullMatch> matches,\n+            final Provision provision) throws JobExecutionException {\n \n         if (!profile.getTask().isPerformUpdate()) {\n             LOG.debug(\"PullTask not configured for update\");\n             finalize(MatchingRule.toEventName(MatchingRule.UPDATE), Result.SUCCESS, null, null, delta);\n-            return List.of();\n+            return Collections.<ProvisioningReport>emptyList();\n         }\n \n-        LOG.debug(\"About to update {}\", anyKeys);\n+        LOG.debug(\"About to update {}\", matches);\n \n         List<ProvisioningReport> results = new ArrayList<>();\n \n-        for (String key : anyKeys) {\n-            LOG.debug(\"About to update {}\", key);\n+        for (PullMatch match : matches) {\n+            LOG.debug(\"About to update {}\", match);\n \n             ProvisioningReport result = new ProvisioningReport();\n             result.setOperation(ResourceOperation.UPDATE);\n             result.setAnyType(provision.getAnyType().getKey());\n             result.setStatus(ProvisioningReport.Status.SUCCESS);\n-            result.setKey(key);\n+            result.setKey(match.getMatchingKey());\n \n-            AnyTO before = getAnyTO(key);\n+            AnyTO before = getAnyTO(match.getMatchingKey());\n             if (before == null) {\n                 result.setStatus(ProvisioningReport.Status.FAILURE);\n-                result.setMessage(String.format(\"Any '%s(%s)' not found\", provision.getAnyType().getKey(), key));\n+                result.setMessage(String.format(\"Any '%s(%s)' not found\", provision.getAnyType().getKey(), match));\n             } else {\n                 result.setName(getName(before));\n             }\n@@ -385,7 +351,7 @@ protected List<ProvisioningReport> update(\n                         resultStatus = Result.SUCCESS;\n                         result.setName(getName(updated));\n \n-                        LOG.debug(\"{} {} successfully updated\", provision.getAnyType().getKey(), key);\n+                        LOG.debug(\"{} {} successfully updated\", provision.getAnyType().getKey(), match);\n                     } catch (PropagationException e) {\n                         // A propagation failure doesn't imply a pull failure.\n                         // The propagation exception status will be reported into the propagation task execution.\n@@ -426,38 +392,36 @@ protected List<ProvisioningReport> update(\n     }\n \n     protected List<ProvisioningReport> deprovision(\n+            final MatchingRule matchingRule,\n             final SyncDelta delta,\n-            final List<String> anyKeys,\n-            final Provision provision,\n-            final boolean unlink)\n+            final List<PullMatch> matches,\n+            final Provision provision)\n             throws JobExecutionException {\n \n         if (!profile.getTask().isPerformUpdate()) {\n             LOG.debug(\"PullTask not configured for update\");\n-            finalize(unlink\n-                    ? MatchingRule.toEventName(MatchingRule.UNASSIGN)\n-                    : MatchingRule.toEventName(MatchingRule.DEPROVISION), Result.SUCCESS, null, null, delta);\n-            return List.of();\n+            finalize(MatchingRule.toEventName(matchingRule), Result.SUCCESS, null, null, delta);\n+            return Collections.<ProvisioningReport>emptyList();\n         }\n \n-        LOG.debug(\"About to deprovision {}\", anyKeys);\n+        LOG.debug(\"About to deprovision {}\", matches);\n \n-        final List<ProvisioningReport> results = new ArrayList<>();\n+        List<ProvisioningReport> results = new ArrayList<>();\n \n-        for (String key : anyKeys) {\n-            LOG.debug(\"About to unassign resource {}\", key);\n+        for (PullMatch match : matches) {\n+            LOG.debug(\"About to unassign resource {}\", match);\n \n             ProvisioningReport result = new ProvisioningReport();\n             result.setOperation(ResourceOperation.DELETE);\n             result.setAnyType(provision.getAnyType().getKey());\n             result.setStatus(ProvisioningReport.Status.SUCCESS);\n-            result.setKey(key);\n+            result.setKey(match.getMatchingKey());\n \n-            AnyTO before = getAnyTO(key);\n+            AnyTO before = getAnyTO(match.getMatchingKey());\n \n             if (before == null) {\n                 result.setStatus(ProvisioningReport.Status.FAILURE);\n-                result.setMessage(String.format(\"Any '%s(%s)' not found\", provision.getAnyType().getKey(), key));\n+                result.setMessage(String.format(\"Any '%s(%s)' not found\", provision.getAnyType().getKey(), match));\n             }\n \n             if (!profile.isDryRun()) {\n@@ -471,43 +435,36 @@ protected List<ProvisioningReport> deprovision(\n                     result.setName(getName(before));\n \n                     try {\n-                        if (unlink) {\n+                        if (matchingRule == MatchingRule.UNASSIGN) {\n                             for (PullActions action : profile.getActions()) {\n                                 action.beforeUnassign(profile, delta, before);\n                             }\n-                        } else {\n+                        } else if (matchingRule == MatchingRule.DEPROVISION) {\n                             for (PullActions action : profile.getActions()) {\n                                 action.beforeDeprovision(profile, delta, before);\n                             }\n                         }\n \n                         PropagationByResource<String> propByRes = new PropagationByResource<>();\n-                        propByRes.add(ResourceOperation.DELETE, profile.getTask().getResource().getKey());\n-\n-                        PropagationByResource<Pair<String, String>> propByLinkedAccount = new PropagationByResource<>();\n-                        if (getAnyUtils().anyTypeKind() == AnyTypeKind.USER) {\n-                            userDAO.findLinkedAccounts(key).forEach(account -> propByLinkedAccount.add(\n-                                    ResourceOperation.DELETE,\n-                                    Pair.of(account.getResource().getKey(), account.getConnObjectKeyValue())));\n-                        }\n+                        propByRes.add(ResourceOperation.DELETE, provision.getResource().getKey());\n \n                         taskExecutor.execute(propagationManager.getDeleteTasks(\n                                 provision.getAnyType().getKind(),\n-                                key,\n+                                match.getMatchingKey(),\n                                 propByRes,\n-                                propByLinkedAccount,\n+                                null,\n                                 null),\n                                 false);\n \n                         AnyUR anyUR = null;\n-                        if (unlink) {\n-                            anyUR = getAnyUtils().newAnyUR(key);\n+                        if (matchingRule == MatchingRule.UNASSIGN) {\n+                            anyUR = getAnyUtils().newAnyUR(match.getMatchingKey());\n                             anyUR.getResources().add(new StringPatchItem.Builder().\n                                     operation(PatchOperation.DELETE).\n                                     value(profile.getTask().getResource().getKey()).build());\n                         }\n                         if (anyUR == null) {\n-                            output = getAnyTO(key);\n+                            output = getAnyTO(match.getMatchingKey());\n                         } else {\n                             output = doUpdate(before, anyUR, delta, result);\n                         }\n@@ -518,7 +475,7 @@ protected List<ProvisioningReport> deprovision(\n \n                         resultStatus = Result.SUCCESS;\n \n-                        LOG.debug(\"{} {} successfully updated\", provision.getAnyType().getKey(), key);\n+                        LOG.debug(\"{} {} successfully updated\", provision.getAnyType().getKey(), match);\n                     } catch (PropagationException e) {\n                         // A propagation failure doesn't imply a pull failure.\n                         // The propagation exception status will be reported into the propagation task execution.\n@@ -537,9 +494,7 @@ protected List<ProvisioningReport> deprovision(\n                         resultStatus = Result.FAILURE;\n                     }\n                 }\n-                finalize(unlink\n-                        ? MatchingRule.toEventName(MatchingRule.UNASSIGN)\n-                        : MatchingRule.toEventName(MatchingRule.DEPROVISION), resultStatus, before, output, delta);\n+                finalize(MatchingRule.toEventName(matchingRule), resultStatus, before, output, delta);\n             }\n             results.add(result);\n         }\n@@ -549,7 +504,7 @@ protected List<ProvisioningReport> deprovision(\n \n     protected List<ProvisioningReport> link(\n             final SyncDelta delta,\n-            final List<String> anyKeys,\n+            final List<PullMatch> matches,\n             final Provision provision,\n             final boolean unlink)\n             throws JobExecutionException {\n@@ -559,27 +514,27 @@ protected List<ProvisioningReport> link(\n             finalize(unlink\n                     ? MatchingRule.toEventName(MatchingRule.UNLINK)\n                     : MatchingRule.toEventName(MatchingRule.LINK), Result.SUCCESS, null, null, delta);\n-            return List.of();\n+            return Collections.<ProvisioningReport>emptyList();\n         }\n \n-        LOG.debug(\"About to update {}\", anyKeys);\n+        LOG.debug(\"About to update {}\", matches);\n \n         final List<ProvisioningReport> results = new ArrayList<>();\n \n-        for (String key : anyKeys) {\n-            LOG.debug(\"About to unassign resource {}\", key);\n+        for (PullMatch match : matches) {\n+            LOG.debug(\"About to unassign resource {}\", match);\n \n             ProvisioningReport result = new ProvisioningReport();\n             result.setOperation(ResourceOperation.NONE);\n             result.setAnyType(provision.getAnyType().getKey());\n             result.setStatus(ProvisioningReport.Status.SUCCESS);\n-            result.setKey(key);\n+            result.setKey(match.getMatchingKey());\n \n-            AnyTO before = getAnyTO(key);\n+            AnyTO before = getAnyTO(match.getMatchingKey());\n \n             if (before == null) {\n                 result.setStatus(ProvisioningReport.Status.FAILURE);\n-                result.setMessage(String.format(\"Any '%s(%s)' not found\", provision.getAnyType().getKey(), key));\n+                result.setMessage(String.format(\"Any '%s(%s)' not found\", provision.getAnyType().getKey(), match));\n             }\n \n             if (!profile.isDryRun()) {\n@@ -618,7 +573,7 @@ protected List<ProvisioningReport> link(\n \n                         resultStatus = Result.SUCCESS;\n \n-                        LOG.debug(\"{} {} successfully updated\", provision.getAnyType().getKey(), key);\n+                        LOG.debug(\"{} {} successfully updated\", provision.getAnyType().getKey(), match);\n                     } catch (PropagationException e) {\n                         // A propagation failure doesn't imply a pull failure.\n                         // The propagation exception status will be reported into the propagation task execution.\n@@ -650,30 +605,30 @@ protected List<ProvisioningReport> link(\n \n     protected List<ProvisioningReport> delete(\n             final SyncDelta delta,\n-            final List<String> anyKeys,\n+            final List<PullMatch> matches,\n             final Provision provision)\n             throws JobExecutionException {\n \n         if (!profile.getTask().isPerformDelete()) {\n             LOG.debug(\"PullTask not configured for delete\");\n             finalize(ResourceOperation.DELETE.name().toLowerCase(), Result.SUCCESS, null, null, delta);\n-            return List.of();\n+            return Collections.<ProvisioningReport>emptyList();\n         }\n \n-        LOG.debug(\"About to delete {}\", anyKeys);\n+        LOG.debug(\"About to delete {}\", matches);\n \n         List<ProvisioningReport> results = new ArrayList<>();\n \n-        anyKeys.forEach(key -> {\n+        matches.forEach(match -> {\n             Object output;\n             Result resultStatus = Result.FAILURE;\n \n             ProvisioningReport result = new ProvisioningReport();\n \n             try {\n-                AnyTO before = getAnyTO(key);\n+                AnyTO before = getAnyTO(match.getMatchingKey());\n \n-                result.setKey(key);\n+                result.setKey(match.getMatchingKey());\n                 result.setName(getName(before));\n                 result.setOperation(ResourceOperation.DELETE);\n                 result.setAnyType(provision.getAnyType().getKey());\n@@ -685,8 +640,10 @@ protected List<ProvisioningReport> delete(\n                     }\n \n                     try {\n-                        getProvisioningManager().\n-                                delete(key, Set.of(profile.getTask().getResource().getKey()), true);\n+                        getProvisioningManager().delete(\n+                                match.getMatchingKey(),\n+                                Collections.singleton(profile.getTask().getResource().getKey()),\n+                                true);\n                         output = null;\n                         resultStatus = Result.SUCCESS;\n \n@@ -698,14 +655,14 @@ protected List<ProvisioningReport> delete(\n \n                         result.setStatus(ProvisioningReport.Status.FAILURE);\n                         result.setMessage(ExceptionUtils.getRootCauseMessage(e));\n-                        LOG.error(\"Could not delete {} {}\", provision.getAnyType().getKey(), key, e);\n+                        LOG.error(\"Could not delete {} {}\", provision.getAnyType().getKey(), match, e);\n                         output = e;\n \n                         if (profile.getTask().isRemediation()) {\n                             Remediation entity = entityFactory.newEntity(Remediation.class);\n                             entity.setAnyType(provision.getAnyType());\n                             entity.setOperation(ResourceOperation.DELETE);\n-                            entity.setPayload(key);\n+                            entity.setPayload(match.getMatchingKey());\n                             entity.setError(result.getMessage());\n                             entity.setInstant(new Date());\n                             entity.setRemoteName(delta.getObject().getName().getNameValue());\n@@ -720,11 +677,11 @@ protected List<ProvisioningReport> delete(\n \n                 results.add(result);\n             } catch (NotFoundException e) {\n-                LOG.error(\"Could not find {} {}\", provision.getAnyType().getKey(), key, e);\n+                LOG.error(\"Could not find {} {}\", provision.getAnyType().getKey(), match, e);\n             } catch (DelegatedAdministrationException e) {\n-                LOG.error(\"Not allowed to read {} {}\", provision.getAnyType().getKey(), key, e);\n+                LOG.error(\"Not allowed to read {} {}\", provision.getAnyType().getKey(), match, e);\n             } catch (Exception e) {\n-                LOG.error(\"Could not delete {} {}\", provision.getAnyType().getKey(), key, e);\n+                LOG.error(\"Could not delete {} {}\", provision.getAnyType().getKey(), match, e);\n             }\n         });\n \n@@ -733,7 +690,7 @@ protected List<ProvisioningReport> delete(\n \n     protected List<ProvisioningReport> ignore(\n             final SyncDelta delta,\n-            final List<String> anyKeys,\n+            final List<PullMatch> matches,\n             final Provision provision,\n             final boolean matching,\n             final String... message)\n@@ -743,7 +700,7 @@ protected List<ProvisioningReport> ignore(\n \n         List<ProvisioningReport> results = new ArrayList<>();\n \n-        if (anyKeys == null) {\n+        if (matches == null) {\n             ProvisioningReport report = new ProvisioningReport();\n             report.setKey(null);\n             report.setName(delta.getObject().getUid().getUidValue());\n@@ -756,9 +713,9 @@ protected List<ProvisioningReport> ignore(\n \n             results.add(report);\n         } else {\n-            for (String anyKey : anyKeys) {\n+            matches.forEach(match -> {\n                 ProvisioningReport report = new ProvisioningReport();\n-                report.setKey(anyKey);\n+                report.setKey(match.getMatchingKey());\n                 report.setName(delta.getObject().getUid().getUidValue());\n                 report.setOperation(ResourceOperation.NONE);\n                 report.setAnyType(provision.getAnyType().getKey());\n@@ -768,7 +725,7 @@ protected List<ProvisioningReport> ignore(\n                 }\n \n                 results.add(report);\n-            }\n+            });\n         }\n \n         finalize(matching\n@@ -778,6 +735,100 @@ protected List<ProvisioningReport> ignore(\n         return results;\n     }\n \n+    protected void handleAnys(\n+            final SyncDelta delta,\n+            final List<PullMatch> matches,\n+            final Provision provision,\n+            final AnyUtils anyUtils) throws JobExecutionException {\n+\n+        if (matches.isEmpty()) {\n+            LOG.debug(\"Nothing to do\");\n+            return;\n+        }\n+\n+        if (SyncDeltaType.CREATE_OR_UPDATE == delta.getDeltaType()) {\n+            if (matches.get(0).getMatchingKey() == null) {\n+                switch (profile.getTask().getUnmatchingRule()) {\n+                    case ASSIGN:\n+                    case PROVISION:\n+                        profile.getResults().addAll(\n+                                provision(profile.getTask().getUnmatchingRule(), delta, provision, anyUtils));\n+                        break;\n+\n+                    case IGNORE:\n+                        profile.getResults().addAll(ignore(delta, null, provision, false));\n+                        break;\n+\n+                    default:\n+                    // do nothing\n+                    }\n+            } else {\n+                // update VirAttrCache\n+                virSchemaDAO.findByProvision(provision).forEach(virSchema -> {\n+                    Attribute attr = delta.getObject().getAttributeByName(virSchema.getExtAttrName());\n+                    matches.forEach(match -> {\n+                        if (attr == null) {\n+                            virAttrCache.expire(\n+                                    provision.getAnyType().getKey(),\n+                                    match.getMatchingKey(),\n+                                    virSchema.getKey());\n+                        } else {\n+                            virAttrCache.put(\n+                                    provision.getAnyType().getKey(),\n+                                    match.getMatchingKey(),\n+                                    virSchema.getKey(),\n+                                    new VirAttrCacheValue(attr.getValue()));\n+                        }\n+                    });\n+                });\n+\n+                switch (profile.getTask().getMatchingRule()) {\n+                    case UPDATE:\n+                        profile.getResults().addAll(update(delta, matches, provision));\n+                        break;\n+\n+                    case DEPROVISION:\n+                    case UNASSIGN:\n+                        profile.getResults().addAll(\n+                                deprovision(profile.getTask().getMatchingRule(), delta, matches, provision));\n+                        break;\n+\n+                    case LINK:\n+                        profile.getResults().addAll(link(delta, matches, provision, false));\n+                        break;\n+\n+                    case UNLINK:\n+                        profile.getResults().addAll(link(delta, matches, provision, true));\n+                        break;\n+\n+                    case IGNORE:\n+                        profile.getResults().addAll(ignore(delta, matches, provision, true));\n+                        break;\n+\n+                    default:\n+                    // do nothing\n+                    }\n+            }\n+        } else if (SyncDeltaType.DELETE == delta.getDeltaType()) {\n+            profile.getResults().addAll(delete(delta, matches, provision));\n+        }\n+    }\n+\n+    protected void handleLinkedAccounts(\n+            final SyncDelta delta,\n+            final List<PullMatch> matches,\n+            final Provision provision,\n+            final AnyUtils anyUtils) throws JobExecutionException {\n+\n+        if (matches.isEmpty()) {\n+            LOG.debug(\"Nothing to do\");\n+            return;\n+        }\n+\n+        // nothing to do in the general case\n+        LOG.warn(\"Unexpected linked accounts found for {}: {}\", anyUtils.anyTypeKind(), matches);\n+    }\n+\n     /**\n      * Look into SyncDelta and take necessary profile.getActions() (create / update / delete) on any object(s).\n      *\n@@ -791,115 +842,53 @@ protected void doHandle(final SyncDelta delta, final Provision provision) throws\n         LOG.debug(\"Process {} for {} as {}\",\n                 delta.getDeltaType(), delta.getUid().getUidValue(), delta.getObject().getObjectClass());\n \n-        SyncDelta processed = delta;\n-        for (PullActions action : profile.getActions()) {\n-            processed = action.preprocess(profile, processed);\n-        }\n+        SyncDelta finalDelta = profile.getActions().stream().\n+                map(action -> action.preprocess(profile)).\n+                reduce(Function.identity(), Function::andThen).\n+                apply(delta);\n \n         LOG.debug(\"Transformed {} for {} as {}\",\n-                processed.getDeltaType(), processed.getUid().getUidValue(), processed.getObject().getObjectClass());\n+                finalDelta.getDeltaType(), finalDelta.getUid().getUidValue(), finalDelta.getObject().getObjectClass());\n \n         try {\n-            List<String> keys = pullUtils.match(processed, provision, anyUtils);\n+            List<PullMatch> matches = pullUtils.match(finalDelta, provision, anyUtils);\n             LOG.debug(\"Match(es) found for {} as {}: {}\",\n-                    processed.getUid().getUidValue(), processed.getObject().getObjectClass(), keys);\n+                    finalDelta.getUid().getUidValue(), finalDelta.getObject().getObjectClass(), matches);\n \n-            if (keys.size() > 1) {\n+            if (matches.size() > 1) {\n                 switch (profile.getConflictResolutionAction()) {\n                     case IGNORE:\n                         throw new IgnoreProvisionException(\"More than one match found for \"\n-                                + processed.getObject().getUid().getUidValue() + \": \" + keys);\n+                                + finalDelta.getObject().getUid().getUidValue() + \": \" + matches);\n \n                     case FIRSTMATCH:\n-                        keys = keys.subList(0, 1);\n+                        matches = matches.subList(0, 1);\n                         break;\n \n                     case LASTMATCH:\n-                        keys = keys.subList(keys.size() - 1, keys.size());\n+                        matches = matches.subList(matches.size() - 1, matches.size());\n                         break;\n \n                     default:\n-                    // keep anyKeys unmodified\n+                    // keep matches unmodified\n                 }\n             }\n \n-            if (SyncDeltaType.CREATE_OR_UPDATE == processed.getDeltaType()) {\n-                if (keys.isEmpty()) {\n-                    switch (profile.getTask().getUnmatchingRule()) {\n-                        case ASSIGN:\n-                            profile.getResults().addAll(assign(processed, provision, anyUtils));\n-                            break;\n-\n-                        case PROVISION:\n-                            profile.getResults().addAll(provision(processed, provision, anyUtils));\n-                            break;\n-\n-                        case IGNORE:\n-                            profile.getResults().addAll(ignore(processed, null, provision, false));\n-                            break;\n-\n-                        default:\n-                        // do nothing\n-                    }\n-                } else {\n-                    // update VirAttrCache\n-                    for (VirSchema virSchema : virSchemaDAO.findByProvision(provision)) {\n-                        Attribute attr = processed.getObject().getAttributeByName(virSchema.getExtAttrName());\n-                        for (String anyKey : keys) {\n-                            if (attr == null) {\n-                                virAttrCache.expire(\n-                                        provision.getAnyType().getKey(),\n-                                        anyKey,\n-                                        virSchema.getKey());\n-                            } else {\n-                                VirAttrCacheValue cacheValue = new VirAttrCacheValue();\n-                                cacheValue.setValues(attr.getValue());\n-                                virAttrCache.put(\n-                                        provision.getAnyType().getKey(),\n-                                        anyKey,\n-                                        virSchema.getKey(),\n-                                        cacheValue);\n-                            }\n-                        }\n-                    }\n-\n-                    switch (profile.getTask().getMatchingRule()) {\n-                        case UPDATE:\n-                            profile.getResults().addAll(update(processed, keys, provision));\n-                            break;\n-\n-                        case DEPROVISION:\n-                            profile.getResults().addAll(deprovision(processed, keys, provision, false));\n-                            break;\n-\n-                        case UNASSIGN:\n-                            profile.getResults().addAll(deprovision(processed, keys, provision, true));\n-                            break;\n-\n-                        case LINK:\n-                            profile.getResults().addAll(link(processed, keys, provision, false));\n-                            break;\n-\n-                        case UNLINK:\n-                            profile.getResults().addAll(link(processed, keys, provision, true));\n-                            break;\n-\n-                        case IGNORE:\n-                            profile.getResults().addAll(ignore(processed, keys, provision, true));\n-                            break;\n-\n-                        default:\n-                        // do nothing\n-                    }\n-                }\n-            } else if (SyncDeltaType.DELETE == processed.getDeltaType()) {\n-                if (keys.isEmpty()) {\n-                    finalize(ResourceOperation.DELETE.name().toLowerCase(), Result.SUCCESS, null, null, processed);\n-                    LOG.debug(\"No match found for deletion\");\n-                } else {\n-                    profile.getResults().addAll(delete(processed, keys, provision));\n-                }\n-            }\n+            // users, groups and any objects\n+            handleAnys(\n+                    finalDelta,\n+                    matches.stream().\n+                            filter(match -> match.getMatchTarget() == PullMatch.MatchTarget.ANY).\n+                            collect(Collectors.toList()), provision,\n+                    anyUtils);\n+\n+            // linked accounts\n+            handleLinkedAccounts(\n+                    finalDelta,\n+                    matches.stream().\n+                            filter(match -> match.getMatchTarget() == PullMatch.MatchTarget.LINKED_ACCOUNT).\n+                            collect(Collectors.toList()), provision,\n+                    anyUtils);\n         } catch (IllegalStateException | IllegalArgumentException e) {\n             LOG.warn(e.getMessage());\n         }"},{"sha":"9a2adf67dc3659193a91946675d18578a6993ea5","filename":"core/provisioning-java/src/main/java/org/apache/syncope/core/provisioning/java/pushpull/DefaultRealmPullResultHandler.java","status":"modified","additions":22,"deletions":21,"changes":43,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FDefaultRealmPullResultHandler.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FDefaultRealmPullResultHandler.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FDefaultRealmPullResultHandler.java?ref=cb560bf69bf951bdff34abf3ffcad8fff82c6a11","patch":"@@ -21,6 +21,7 @@\n import java.util.ArrayList;\n import java.util.List;\n import java.util.Set;\n+import java.util.function.Function;\n import org.apache.commons.lang3.exception.ExceptionUtils;\n import org.apache.syncope.common.lib.SyncopeClientException;\n import org.apache.syncope.common.lib.to.RealmTO;\n@@ -669,23 +670,23 @@ private void doHandle(final SyncDelta delta, final OrgUnit orgUnit) throws JobEx\n         LOG.debug(\"Process {} for {} as {}\",\n                 delta.getDeltaType(), delta.getUid().getUidValue(), delta.getObject().getObjectClass());\n \n-        SyncDelta processed = delta;\n-        for (PullActions action : profile.getActions()) {\n-            processed = action.preprocess(profile, processed);\n-        }\n+        SyncDelta finalDelta = profile.getActions().stream().\n+                map(action -> action.preprocess(profile)).\n+                reduce(Function.identity(), Function::andThen).\n+                apply(delta);\n \n         LOG.debug(\"Transformed {} for {} as {}\",\n-                processed.getDeltaType(), processed.getUid().getUidValue(), processed.getObject().getObjectClass());\n+                finalDelta.getDeltaType(), finalDelta.getUid().getUidValue(), finalDelta.getObject().getObjectClass());\n \n-        List<String> keys = pullUtils.match(processed, orgUnit);\n+        List<String> keys = pullUtils.match(finalDelta, orgUnit);\n         LOG.debug(\"Match found for {} as {}: {}\",\n-                processed.getUid().getUidValue(), processed.getObject().getObjectClass(), keys);\n+                finalDelta.getUid().getUidValue(), finalDelta.getObject().getObjectClass(), keys);\n \n         if (keys.size() > 1) {\n             switch (profile.getConflictResolutionAction()) {\n                 case IGNORE:\n                     throw new IgnoreProvisionException(\"More than one match found for \"\n-                            + processed.getObject().getUid().getUidValue() + \": \" + keys);\n+                            + finalDelta.getObject().getUid().getUidValue() + \": \" + keys);\n \n                 case FIRSTMATCH:\n                     keys = keys.subList(0, 1);\n@@ -701,19 +702,19 @@ private void doHandle(final SyncDelta delta, final OrgUnit orgUnit) throws JobEx\n         }\n \n         try {\n-            if (SyncDeltaType.CREATE_OR_UPDATE == processed.getDeltaType()) {\n+            if (SyncDeltaType.CREATE_OR_UPDATE == finalDelta.getDeltaType()) {\n                 if (keys.isEmpty()) {\n                     switch (profile.getTask().getUnmatchingRule()) {\n                         case ASSIGN:\n-                            profile.getResults().addAll(assign(processed, orgUnit));\n+                            profile.getResults().addAll(assign(finalDelta, orgUnit));\n                             break;\n \n                         case PROVISION:\n-                            profile.getResults().addAll(provision(processed, orgUnit));\n+                            profile.getResults().addAll(provision(finalDelta, orgUnit));\n                             break;\n \n                         case IGNORE:\n-                            profile.getResults().add(ignore(processed, false));\n+                            profile.getResults().add(ignore(finalDelta, false));\n                             break;\n \n                         default:\n@@ -722,39 +723,39 @@ private void doHandle(final SyncDelta delta, final OrgUnit orgUnit) throws JobEx\n                 } else {\n                     switch (profile.getTask().getMatchingRule()) {\n                         case UPDATE:\n-                            profile.getResults().addAll(update(processed, keys, false));\n+                            profile.getResults().addAll(update(finalDelta, keys, false));\n                             break;\n \n                         case DEPROVISION:\n-                            profile.getResults().addAll(deprovision(processed, keys, false));\n+                            profile.getResults().addAll(deprovision(finalDelta, keys, false));\n                             break;\n \n                         case UNASSIGN:\n-                            profile.getResults().addAll(deprovision(processed, keys, true));\n+                            profile.getResults().addAll(deprovision(finalDelta, keys, true));\n                             break;\n \n                         case LINK:\n-                            profile.getResults().addAll(link(processed, keys, false));\n+                            profile.getResults().addAll(link(finalDelta, keys, false));\n                             break;\n \n                         case UNLINK:\n-                            profile.getResults().addAll(link(processed, keys, true));\n+                            profile.getResults().addAll(link(finalDelta, keys, true));\n                             break;\n \n                         case IGNORE:\n-                            profile.getResults().add(ignore(processed, true));\n+                            profile.getResults().add(ignore(finalDelta, true));\n                             break;\n \n                         default:\n                         // do nothing\n                     }\n                 }\n-            } else if (SyncDeltaType.DELETE == processed.getDeltaType()) {\n+            } else if (SyncDeltaType.DELETE == finalDelta.getDeltaType()) {\n                 if (keys.isEmpty()) {\n-                    finalize(ResourceOperation.DELETE.name().toLowerCase(), Result.SUCCESS, null, null, processed);\n+                    finalize(ResourceOperation.DELETE.name().toLowerCase(), Result.SUCCESS, null, null, finalDelta);\n                     LOG.debug(\"No match found for deletion\");\n                 } else {\n-                    profile.getResults().addAll(delete(processed, keys));\n+                    profile.getResults().addAll(delete(finalDelta, keys));\n                 }\n             }\n         } catch (IllegalStateException | IllegalArgumentException e) {"},{"sha":"990f98af8fbcd9523b96fff530ff444eee7cfaeb","filename":"core/provisioning-java/src/main/java/org/apache/syncope/core/provisioning/java/pushpull/DefaultUserPullResultHandler.java","status":"modified","additions":522,"deletions":12,"changes":534,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FDefaultUserPullResultHandler.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FDefaultUserPullResultHandler.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FDefaultUserPullResultHandler.java?ref=cb560bf69bf951bdff34abf3ffcad8fff82c6a11","patch":"@@ -18,26 +18,49 @@\n  */\n package org.apache.syncope.core.provisioning.java.pushpull;\n \n+import java.util.Collections;\n+import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n+import java.util.Optional;\n import java.util.Set;\n-\n+import org.apache.commons.lang3.BooleanUtils;\n+import org.apache.commons.lang3.exception.ExceptionUtils;\n import org.apache.commons.lang3.tuple.Pair;\n+import org.apache.syncope.common.lib.Attr;\n import org.apache.syncope.common.lib.request.AnyCR;\n import org.apache.syncope.common.lib.request.AnyUR;\n import org.apache.syncope.common.lib.request.UserCR;\n import org.apache.syncope.common.lib.request.UserUR;\n+import org.apache.syncope.common.lib.request.LinkedAccountUR;\n import org.apache.syncope.common.lib.to.AnyTO;\n+import org.apache.syncope.common.lib.to.LinkedAccountTO;\n import org.apache.syncope.common.lib.to.PropagationStatus;\n import org.apache.syncope.common.lib.to.UserTO;\n import org.apache.syncope.common.lib.types.AnyTypeKind;\n+import org.apache.syncope.common.lib.types.AuditElements;\n+import org.apache.syncope.common.lib.types.AuditElements.Result;\n+import org.apache.syncope.common.lib.types.MatchingRule;\n+import org.apache.syncope.common.lib.types.PatchOperation;\n+import org.apache.syncope.common.lib.types.ResourceOperation;\n+import org.apache.syncope.common.lib.types.UnmatchingRule;\n+import org.apache.syncope.core.persistence.api.dao.PullMatch;\n import org.apache.syncope.core.persistence.api.entity.AnyUtils;\n+import org.apache.syncope.core.persistence.api.entity.resource.Provision;\n+import org.apache.syncope.core.persistence.api.entity.user.LinkedAccount;\n+import org.apache.syncope.core.persistence.api.entity.user.User;\n+import org.apache.syncope.core.provisioning.api.PropagationByResource;\n import org.apache.syncope.core.provisioning.api.ProvisioningManager;\n import org.apache.syncope.core.provisioning.api.UserProvisioningManager;\n import org.apache.syncope.core.provisioning.api.WorkflowResult;\n+import org.apache.syncope.core.provisioning.api.propagation.PropagationException;\n import org.apache.syncope.core.provisioning.api.pushpull.ProvisioningReport;\n+import org.apache.syncope.core.provisioning.api.pushpull.PullActions;\n import org.identityconnectors.framework.common.objects.SyncDelta;\n import org.apache.syncope.core.provisioning.api.pushpull.UserPullResultHandler;\n+import org.identityconnectors.framework.common.objects.AttributeUtil;\n+import org.identityconnectors.framework.common.objects.SyncDeltaType;\n+import org.quartz.JobExecutionException;\n import org.springframework.beans.factory.annotation.Autowired;\n \n public class DefaultUserPullResultHandler extends AbstractPullResultHandler implements UserPullResultHandler {\n@@ -76,14 +99,18 @@ protected WorkflowResult<? extends AnyUR> update(final AnyUR req) {\n         return new WorkflowResult<>(update.getResult().getLeft(), update.getPropByRes(), update.getPerformedTasks());\n     }\n \n+    protected Boolean enabled(final SyncDelta delta) {\n+        return profile.getTask().isSyncStatus() ? AttributeUtil.isEnabled(delta.getObject()) : null;\n+    }\n+\n     @Override\n     protected AnyTO doCreate(final AnyCR anyCR, final SyncDelta delta) {\n-        UserCR userCR = UserCR.class.cast(anyCR);\n-\n-        Boolean enabled = PullUtils.readEnabled(delta.getObject(), profile.getTask());\n-        Map.Entry<String, List<PropagationStatus>> created =\n-                userProvisioningManager.create(userCR, true, enabled,\n-                        Set.of(profile.getTask().getResource().getKey()), true);\n+        Map.Entry<String, List<PropagationStatus>> created = userProvisioningManager.create(\n+                UserCR.class.cast(anyCR),\n+                true,\n+                enabled(delta),\n+                Set.of(profile.getTask().getResource().getKey()),\n+                true);\n \n         return getAnyTO(created.getKey());\n     }\n@@ -95,16 +122,499 @@ protected AnyUR doUpdate(\n             final SyncDelta delta,\n             final ProvisioningReport result) {\n \n-        UserUR userUR = UserUR.class.cast(anyUR);\n-        Boolean enabled = PullUtils.readEnabled(delta.getObject(), profile.getTask());\n-\n         Pair<UserUR, List<PropagationStatus>> updated = userProvisioningManager.update(\n-                userUR,\n+                UserUR.class.cast(anyUR),\n                 result,\n-                enabled,\n+                enabled(delta),\n                 Set.of(profile.getTask().getResource().getKey()),\n                 true);\n \n         return updated.getLeft();\n     }\n+\n+    @Override\n+    protected void handleLinkedAccounts(\n+            final SyncDelta delta,\n+            final List<PullMatch> matches,\n+            final Provision provision,\n+            final AnyUtils anyUtils) throws JobExecutionException {\n+\n+        for (PullMatch match : matches) {\n+            User user = userDAO.find(match.getLinkingUserKey());\n+            if (user == null) {\n+                LOG.error(\"Could not find linking user, cannot process match {}\", match);\n+                return;\n+            }\n+\n+            Optional<? extends LinkedAccount> found =\n+                    user.getLinkedAccount(provision.getResource().getKey(), delta.getUid().getUidValue());\n+            if (found.isPresent()) {\n+                LinkedAccount account = found.get();\n+\n+                if (SyncDeltaType.CREATE_OR_UPDATE == delta.getDeltaType()) {\n+                    switch (profile.getTask().getMatchingRule()) {\n+                        case UPDATE:\n+                            update(delta, account, provision).ifPresent(profile.getResults()::add);\n+                            break;\n+\n+                        case DEPROVISION:\n+                        case UNASSIGN:\n+                            deprovision(profile.getTask().getMatchingRule(), delta, account).\n+                                    ifPresent(profile.getResults()::add);\n+                            break;\n+\n+                        case LINK:\n+                        case UNLINK:\n+                            LOG.warn(\"{} not applicable to linked accounts, ignoring\",\n+                                    profile.getTask().getMatchingRule());\n+                            break;\n+\n+                        case IGNORE:\n+                            profile.getResults().add(ignore(delta, account, true));\n+                            break;\n+\n+                        default:\n+                        // do nothing\n+                    }\n+                } else if (SyncDeltaType.DELETE == delta.getDeltaType()) {\n+                    delete(delta, account).ifPresent(profile.getResults()::add);\n+                }\n+            } else {\n+                if (SyncDeltaType.CREATE_OR_UPDATE == delta.getDeltaType()) {\n+                    LinkedAccountTO accountTO = new LinkedAccountTO();\n+                    accountTO.setConnObjectKeyValue(delta.getUid().getUidValue());\n+                    accountTO.setResource(provision.getResource().getKey());\n+\n+                    switch (profile.getTask().getUnmatchingRule()) {\n+                        case ASSIGN:\n+                        case PROVISION:\n+                            provision(profile.getTask().getUnmatchingRule(), delta, user, accountTO, provision).\n+                                    ifPresent(profile.getResults()::add);\n+                            break;\n+\n+                        case IGNORE:\n+                            profile.getResults().add(ignore(delta, null, false));\n+                            break;\n+\n+                        default:\n+                        // do nothing\n+                    }\n+                } else if (SyncDeltaType.DELETE == delta.getDeltaType()) {\n+                    finalize(\n+                            ResourceOperation.DELETE.name().toLowerCase(),\n+                            AuditElements.Result.SUCCESS,\n+                            null,\n+                            null,\n+                            delta);\n+                    LOG.debug(\"No match found for deletion\");\n+                }\n+            }\n+        }\n+    }\n+\n+    protected Optional<ProvisioningReport> deprovision(\n+            final MatchingRule matchingRule,\n+            final SyncDelta delta,\n+            final LinkedAccount account) throws JobExecutionException {\n+\n+        if (!profile.getTask().isPerformUpdate()) {\n+            LOG.debug(\"PullTask not configured for update\");\n+            finalize(MatchingRule.toEventName(MatchingRule.UPDATE), Result.SUCCESS, null, null, delta);\n+            return Optional.empty();\n+        }\n+\n+        LOG.debug(\"About to deprovision {}\", account);\n+\n+        ProvisioningReport report = new ProvisioningReport();\n+        report.setOperation(ResourceOperation.DELETE);\n+        report.setAnyType(PullMatch.MatchTarget.LINKED_ACCOUNT.name());\n+        report.setStatus(ProvisioningReport.Status.SUCCESS);\n+        report.setKey(account.getKey());\n+\n+        LinkedAccountTO before = userDataBinder.getLinkedAccountTO(account);\n+\n+        if (!profile.isDryRun()) {\n+            Object output = before;\n+            Result resultStatus;\n+\n+            try {\n+                if (matchingRule == MatchingRule.UNASSIGN) {\n+                    for (PullActions action : profile.getActions()) {\n+                        action.beforeUnassign(profile, delta, before);\n+                    }\n+                } else if (matchingRule == MatchingRule.DEPROVISION) {\n+                    for (PullActions action : profile.getActions()) {\n+                        action.beforeDeprovision(profile, delta, before);\n+                    }\n+                }\n+\n+                PropagationByResource<Pair<String, String>> propByLinkedAccount = new PropagationByResource<>();\n+                propByLinkedAccount.add(\n+                        ResourceOperation.DELETE,\n+                        Pair.of(account.getResource().getKey(), account.getConnObjectKeyValue()));\n+\n+                taskExecutor.execute(propagationManager.getDeleteTasks(\n+                        AnyTypeKind.USER,\n+                        account.getOwner().getKey(),\n+                        null,\n+                        propByLinkedAccount,\n+                        null),\n+                        false);\n+\n+                for (PullActions action : profile.getActions()) {\n+                    action.after(profile, delta, before, report);\n+                }\n+\n+                resultStatus = Result.SUCCESS;\n+\n+                LOG.debug(\"Linked account {} successfully updated\", account.getConnObjectKeyValue());\n+            } catch (PropagationException e) {\n+                // A propagation failure doesn't imply a pull failure.\n+                // The propagation exception status will be reported into the propagation task execution.\n+                LOG.error(\"Could not propagate linked acccount {}\", account.getConnObjectKeyValue());\n+                output = e;\n+                resultStatus = Result.FAILURE;\n+            } catch (Exception e) {\n+                throwIgnoreProvisionException(delta, e);\n+\n+                report.setStatus(ProvisioningReport.Status.FAILURE);\n+                report.setMessage(ExceptionUtils.getRootCauseMessage(e));\n+                LOG.error(\"Could not update linked account {}\", account, e);\n+                output = e;\n+                resultStatus = Result.FAILURE;\n+            }\n+\n+            finalize(MatchingRule.toEventName(matchingRule), resultStatus, before, output, delta);\n+        }\n+\n+        return Optional.of(report);\n+    }\n+\n+    protected Optional<ProvisioningReport> provision(\n+            final UnmatchingRule rule,\n+            final SyncDelta delta,\n+            final User user,\n+            final LinkedAccountTO accountTO,\n+            final Provision provision)\n+            throws JobExecutionException {\n+\n+        if (!profile.getTask().isPerformCreate()) {\n+            LOG.debug(\"PullTask not configured for create\");\n+            finalize(UnmatchingRule.toEventName(rule), Result.SUCCESS, null, null, delta);\n+            return Optional.empty();\n+        }\n+\n+        LOG.debug(\"About to create {}\", accountTO);\n+\n+        ProvisioningReport report = new ProvisioningReport();\n+        report.setOperation(ResourceOperation.CREATE);\n+        report.setName(accountTO.getConnObjectKeyValue());\n+        report.setAnyType(PullMatch.MatchTarget.LINKED_ACCOUNT.name());\n+        report.setStatus(ProvisioningReport.Status.SUCCESS);\n+\n+        if (profile.isDryRun()) {\n+            report.setKey(null);\n+            finalize(UnmatchingRule.toEventName(rule), Result.SUCCESS, null, null, delta);\n+        } else {\n+            UserTO owner = userDataBinder.getUserTO(user, false);\n+            UserCR connObject = connObjectUtils.getAnyCR(\n+                    delta.getObject(), profile.getTask(), provision, getAnyUtils(), false);\n+\n+            if (connObject.getUsername().equals(owner.getUsername())) {\n+                accountTO.setUsername(null);\n+            } else if (!connObject.getUsername().equals(accountTO.getUsername())) {\n+                accountTO.setUsername(connObject.getUsername());\n+            }\n+\n+            if (connObject.getPassword() != null) {\n+                accountTO.setPassword(connObject.getPassword());\n+            }\n+\n+            accountTO.setSuspended(BooleanUtils.isTrue(BooleanUtils.negate(enabled(delta))));\n+\n+            connObject.getPlainAttrs().forEach(connObjectAttr -> {\n+                Optional<Attr> ownerAttr = owner.getPlainAttr(connObjectAttr.getSchema());\n+                if (ownerAttr.isPresent() && ownerAttr.get().getValues().equals(connObjectAttr.getValues())) {\n+                    accountTO.getPlainAttrs().removeIf(attr -> connObjectAttr.getSchema().equals(attr.getSchema()));\n+                } else {\n+                    accountTO.getPlainAttrs().add(connObjectAttr);\n+                }\n+            });\n+\n+            for (PullActions action : profile.getActions()) {\n+                if (rule == UnmatchingRule.ASSIGN) {\n+                    action.beforeAssign(profile, delta, accountTO);\n+                } else if (rule == UnmatchingRule.PROVISION) {\n+                    action.beforeProvision(profile, delta, accountTO);\n+                }\n+            }\n+\n+            UserUR req = new UserUR();\n+            req.setKey(user.getKey());\n+            req.getLinkedAccounts().add(new LinkedAccountUR.Builder().\n+                    operation(PatchOperation.ADD_REPLACE).linkedAccountTO(accountTO).build());\n+\n+            Result resultStatus;\n+            Object output;\n+\n+            try {\n+                userProvisioningManager.update(\n+                        req,\n+                        report,\n+                        null,\n+                        Collections.singleton(profile.getTask().getResource().getKey()),\n+                        true);\n+                resultStatus = Result.SUCCESS;\n+\n+                LinkedAccountTO created = userDAO.find(req.getKey()).\n+                        getLinkedAccount(accountTO.getResource(), accountTO.getConnObjectKeyValue()).\n+                        map(acct -> userDataBinder.getLinkedAccountTO(acct)).\n+                        orElse(null);\n+                output = created;\n+                resultStatus = Result.SUCCESS;\n+\n+                for (PullActions action : profile.getActions()) {\n+                    action.after(profile, delta, created, report);\n+                }\n+\n+                LOG.debug(\"Linked account {} successfully created\", accountTO.getConnObjectKeyValue());\n+            } catch (PropagationException e) {\n+                // A propagation failure doesn't imply a pull failure.\n+                // The propagation exception status will be reported into the propagation task execution.\n+                LOG.error(\"Could not propagate linked acccount {}\", accountTO.getConnObjectKeyValue());\n+                output = e;\n+                resultStatus = Result.FAILURE;\n+            } catch (Exception e) {\n+                throwIgnoreProvisionException(delta, e);\n+\n+                report.setStatus(ProvisioningReport.Status.FAILURE);\n+                report.setMessage(ExceptionUtils.getRootCauseMessage(e));\n+                LOG.error(\"Could not create linked account {} \", accountTO.getConnObjectKeyValue(), e);\n+                output = e;\n+                resultStatus = Result.FAILURE;\n+            }\n+\n+            finalize(UnmatchingRule.toEventName(rule), resultStatus, null, output, delta);\n+        }\n+\n+        return Optional.of(report);\n+    }\n+\n+    protected Optional<ProvisioningReport> update(\n+            final SyncDelta delta,\n+            final LinkedAccount account,\n+            final Provision provision)\n+            throws JobExecutionException {\n+\n+        if (!profile.getTask().isPerformUpdate()) {\n+            LOG.debug(\"PullTask not configured for update\");\n+            finalize(MatchingRule.toEventName(MatchingRule.UPDATE), Result.SUCCESS, null, null, delta);\n+            return Optional.empty();\n+        }\n+\n+        LOG.debug(\"About to update {}\", account);\n+\n+        ProvisioningReport report = new ProvisioningReport();\n+        report.setOperation(ResourceOperation.UPDATE);\n+        report.setKey(account.getKey());\n+        report.setName(account.getConnObjectKeyValue());\n+        report.setAnyType(PullMatch.MatchTarget.LINKED_ACCOUNT.name());\n+        report.setStatus(ProvisioningReport.Status.SUCCESS);\n+\n+        if (!profile.isDryRun()) {\n+            LinkedAccountTO before = userDataBinder.getLinkedAccountTO(account);\n+\n+            UserTO owner = userDataBinder.getUserTO(account.getOwner(), false);\n+            UserCR connObject = connObjectUtils.getAnyCR(\n+                    delta.getObject(), profile.getTask(), provision, getAnyUtils(), false);\n+\n+            LinkedAccountTO update = userDataBinder.getLinkedAccountTO(account);\n+\n+            if (connObject.getUsername().equals(owner.getUsername())) {\n+                update.setUsername(null);\n+            } else if (!connObject.getUsername().equals(update.getUsername())) {\n+                update.setUsername(connObject.getUsername());\n+            }\n+\n+            if (connObject.getPassword() != null) {\n+                update.setPassword(connObject.getPassword());\n+            }\n+\n+            update.setSuspended(BooleanUtils.isTrue(BooleanUtils.negate(enabled(delta))));\n+\n+            Set<String> attrsToRemove = new HashSet<>();\n+            connObject.getPlainAttrs().forEach(connObjectAttr -> {\n+                Optional<Attr> ownerAttr = owner.getPlainAttr(connObjectAttr.getSchema());\n+                if (ownerAttr.isPresent() && ownerAttr.get().getValues().equals(connObjectAttr.getValues())) {\n+                    attrsToRemove.add(connObjectAttr.getSchema());\n+                } else {\n+                    Optional<Attr> updateAttr = update.getPlainAttr(connObjectAttr.getSchema());\n+                    if (!updateAttr.isPresent() || !updateAttr.get().getValues().equals(connObjectAttr.getValues())) {\n+                        attrsToRemove.add(connObjectAttr.getSchema());\n+                        update.getPlainAttrs().add(connObjectAttr);\n+                    }\n+                }\n+            });\n+            update.getPlainAttrs().removeIf(attr -> attrsToRemove.contains(attr.getSchema()));\n+\n+            UserUR patch = new UserUR();\n+            patch.setKey(account.getOwner().getKey());\n+            patch.getLinkedAccounts().add(new LinkedAccountUR.Builder().\n+                    operation(PatchOperation.ADD_REPLACE).linkedAccountTO(update).build());\n+\n+            for (PullActions action : profile.getActions()) {\n+                action.beforeUpdate(profile, delta, before, patch);\n+            }\n+\n+            Result resultStatus;\n+            Object output;\n+\n+            try {\n+                userProvisioningManager.update(\n+                        patch,\n+                        report,\n+                        null,\n+                        Collections.singleton(profile.getTask().getResource().getKey()),\n+                        true);\n+                resultStatus = Result.SUCCESS;\n+\n+                LinkedAccountTO updated = userDAO.find(patch.getKey()).\n+                        getLinkedAccount(account.getResource().getKey(), account.getConnObjectKeyValue()).\n+                        map(acct -> userDataBinder.getLinkedAccountTO(acct)).\n+                        orElse(null);\n+                output = updated;\n+                resultStatus = Result.SUCCESS;\n+\n+                for (PullActions action : profile.getActions()) {\n+                    action.after(profile, delta, updated, report);\n+                }\n+\n+                LOG.debug(\"Linked account {} successfully updated\", account.getConnObjectKeyValue());\n+            } catch (PropagationException e) {\n+                // A propagation failure doesn't imply a pull failure.\n+                // The propagation exception status will be reported into the propagation task execution.\n+                LOG.error(\"Could not propagate linked acccount {}\", account.getConnObjectKeyValue());\n+                output = e;\n+                resultStatus = Result.FAILURE;\n+            } catch (Exception e) {\n+                throwIgnoreProvisionException(delta, e);\n+\n+                report.setStatus(ProvisioningReport.Status.FAILURE);\n+                report.setMessage(ExceptionUtils.getRootCauseMessage(e));\n+                LOG.error(\"Could not update linked account {}\", account, e);\n+                output = e;\n+                resultStatus = Result.FAILURE;\n+            }\n+\n+            finalize(MatchingRule.toEventName(MatchingRule.UPDATE), resultStatus, before, output, delta);\n+        }\n+\n+        return Optional.of(report);\n+    }\n+\n+    protected Optional<ProvisioningReport> delete(\n+            final SyncDelta delta,\n+            final LinkedAccount account)\n+            throws JobExecutionException {\n+\n+        if (!profile.getTask().isPerformDelete()) {\n+            LOG.debug(\"PullTask not configured for delete\");\n+            finalize(ResourceOperation.DELETE.name().toLowerCase(), Result.SUCCESS, null, null, delta);\n+            return Optional.empty();\n+        }\n+\n+        LOG.debug(\"About to delete {}\", account);\n+\n+        Object output;\n+        Result resultStatus = Result.FAILURE;\n+\n+        ProvisioningReport report = new ProvisioningReport();\n+\n+        try {\n+            report.setKey(account.getKey());\n+            report.setName(account.getConnObjectKeyValue());\n+            report.setOperation(ResourceOperation.DELETE);\n+            report.setAnyType(PullMatch.MatchTarget.LINKED_ACCOUNT.name());\n+            report.setStatus(ProvisioningReport.Status.SUCCESS);\n+\n+            if (!profile.isDryRun()) {\n+                LinkedAccountTO before = userDataBinder.getLinkedAccountTO(account);\n+\n+                for (PullActions action : profile.getActions()) {\n+                    action.beforeDelete(profile, delta, before);\n+                }\n+\n+                UserUR req = new UserUR();\n+                req.setKey(account.getOwner().getKey());\n+                req.getLinkedAccounts().add(new LinkedAccountUR.Builder().\n+                        operation(PatchOperation.DELETE).linkedAccountTO(before).build());\n+\n+                try {\n+                    userProvisioningManager.update(\n+                            req,\n+                            report,\n+                            null,\n+                            Collections.singleton(profile.getTask().getResource().getKey()),\n+                            true);\n+                    resultStatus = Result.SUCCESS;\n+\n+                    output = null;\n+\n+                    for (PullActions action : profile.getActions()) {\n+                        action.after(profile, delta, before, report);\n+                    }\n+                } catch (Exception e) {\n+                    throwIgnoreProvisionException(delta, e);\n+\n+                    report.setStatus(ProvisioningReport.Status.FAILURE);\n+                    report.setMessage(ExceptionUtils.getRootCauseMessage(e));\n+                    LOG.error(\"Could not delete linked account {}\", account, e);\n+                    output = e;\n+                }\n+\n+                finalize(ResourceOperation.DELETE.name().toLowerCase(), resultStatus, before, output, delta);\n+            }\n+        } catch (Exception e) {\n+            LOG.error(\"Could not delete linked account {}\", account, e);\n+        }\n+\n+        return Optional.of(report);\n+    }\n+\n+    protected ProvisioningReport ignore(\n+            final SyncDelta delta,\n+            final LinkedAccount account,\n+            final boolean matching,\n+            final String... message)\n+            throws JobExecutionException {\n+\n+        LOG.debug(\"Linked account to ignore {}\", delta.getObject().getUid().getUidValue());\n+\n+        ProvisioningReport report = new ProvisioningReport();\n+        if (account == null) {\n+            report.setKey(null);\n+            report.setName(delta.getObject().getUid().getUidValue());\n+            report.setOperation(ResourceOperation.NONE);\n+            report.setAnyType(PullMatch.MatchTarget.LINKED_ACCOUNT.name());\n+            report.setStatus(ProvisioningReport.Status.SUCCESS);\n+            if (message != null && message.length >= 1) {\n+                report.setMessage(message[0]);\n+            }\n+        } else {\n+            report.setKey(account.getKey());\n+            report.setName(delta.getObject().getUid().getUidValue());\n+            report.setOperation(ResourceOperation.NONE);\n+            report.setAnyType(PullMatch.MatchTarget.LINKED_ACCOUNT.name());\n+            report.setStatus(ProvisioningReport.Status.SUCCESS);\n+            if (message != null && message.length >= 1) {\n+                report.setMessage(message[0]);\n+            }\n+        }\n+\n+        finalize(matching\n+                ? MatchingRule.toEventName(MatchingRule.IGNORE)\n+                : UnmatchingRule.toEventName(UnmatchingRule.IGNORE), AuditElements.Result.SUCCESS, null, null, delta);\n+\n+        return report;\n+    }\n }"},{"sha":"5dab00562e9325b0c2123e3717d0a3df2b9ca73d","filename":"core/provisioning-java/src/main/java/org/apache/syncope/core/provisioning/java/pushpull/PullUtils.java","status":"modified","additions":49,"deletions":47,"changes":96,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FPullUtils.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FPullUtils.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FPullUtils.java?ref=cb560bf69bf951bdff34abf3ffcad8fff82c6a11","patch":"@@ -20,7 +20,6 @@\n \n import java.text.ParseException;\n import java.util.ArrayList;\n-import java.util.Collections;\n import java.util.List;\n import java.util.Optional;\n import java.util.stream.Collectors;\n@@ -53,19 +52,18 @@\n import org.apache.syncope.core.persistence.api.entity.resource.OrgUnit;\n import org.apache.syncope.core.persistence.api.entity.resource.OrgUnitItem;\n import org.apache.syncope.core.persistence.api.entity.resource.Provision;\n-import org.apache.syncope.core.persistence.api.entity.task.ProvisioningTask;\n import org.apache.syncope.core.persistence.api.entity.user.User;\n import org.apache.syncope.core.provisioning.api.Connector;\n import org.apache.syncope.core.provisioning.api.IntAttrName;\n import org.apache.syncope.core.provisioning.api.data.ItemTransformer;\n+import org.apache.syncope.core.persistence.api.dao.PullMatch;\n import org.apache.syncope.core.provisioning.java.IntAttrNameParser;\n import org.apache.syncope.core.provisioning.java.utils.MappingUtils;\n import org.apache.syncope.core.spring.ImplementationManager;\n import org.identityconnectors.framework.common.objects.Attribute;\n import org.identityconnectors.framework.common.objects.AttributeUtil;\n import org.identityconnectors.framework.common.objects.ConnectorObject;\n import org.identityconnectors.framework.common.objects.Name;\n-import org.identityconnectors.framework.common.objects.OperationalAttributes;\n import org.identityconnectors.framework.common.objects.SearchResult;\n import org.identityconnectors.framework.common.objects.filter.FilterBuilder;\n import org.identityconnectors.framework.common.objects.SyncDelta;\n@@ -162,21 +160,21 @@ public boolean handle(final ConnectorObject connectorObject) {\n \n             ConnectorObject connObj = found.iterator().next();\n             try {\n-                List<String> anyKeys = match(\n+                List<PullMatch> matches = match(\n                         new SyncDeltaBuilder().\n                                 setToken(new SyncToken(\"\")).\n                                 setDeltaType(SyncDeltaType.CREATE_OR_UPDATE).\n                                 setObject(connObj).\n                                 build(),\n                         provision.get(), anyUtils);\n-                if (anyKeys.isEmpty()) {\n+                if (matches.isEmpty()) {\n                     LOG.debug(\"No matching {} found for {}, aborting\", anyUtils.anyTypeKind(), connObj);\n                 } else {\n-                    if (anyKeys.size() > 1) {\n-                        LOG.warn(\"More than one {} found {} - taking first only\", anyUtils.anyTypeKind(), anyKeys);\n+                    if (matches.size() > 1) {\n+                        LOG.warn(\"More than one {} found {} - taking first only\", anyUtils.anyTypeKind(), matches);\n                     }\n \n-                    result = Optional.ofNullable(anyKeys.iterator().next());\n+                    result = Optional.ofNullable(matches.iterator().next().getMatchingKey());\n                 }\n             } catch (IllegalArgumentException e) {\n                 LOG.warn(e.getMessage());\n@@ -186,9 +184,11 @@ public boolean handle(final ConnectorObject connectorObject) {\n         return result;\n     }\n \n-    private List<String> findByConnObjectKey(\n+    private List<PullMatch> findByConnObjectKey(\n             final SyncDelta syncDelta, final Provision provision, final AnyUtils anyUtils) {\n \n+        List<PullMatch> noMatchResult = List.of(PullCorrelationRule.NO_MATCH);\n+\n         String connObjectKey = null;\n \n         Optional<? extends MappingItem> connObjectKeyItem = MappingUtils.getConnObjectKeyItem(provision);\n@@ -200,37 +200,37 @@ private List<String> findByConnObjectKey(\n             }\n         }\n         if (connObjectKey == null) {\n-            return List.of();\n+            return noMatchResult;\n         }\n \n         for (ItemTransformer transformer : MappingUtils.getItemTransformers(connObjectKeyItem.get())) {\n             List<Object> output = transformer.beforePull(\n                     connObjectKeyItem.get(),\n                     null,\n-                    Collections.<Object>singletonList(connObjectKey));\n+                    List.of(connObjectKey));\n             if (output != null && !output.isEmpty()) {\n                 connObjectKey = output.get(0).toString();\n             }\n         }\n \n-        List<String> result = new ArrayList<>();\n-\n         IntAttrName intAttrName;\n         try {\n             intAttrName = intAttrNameParser.parse(\n                     connObjectKeyItem.get().getIntAttrName(),\n                     provision.getAnyType().getKind());\n         } catch (ParseException e) {\n             LOG.error(\"Invalid intAttrName '{}' specified, ignoring\", connObjectKeyItem.get().getIntAttrName(), e);\n-            return result;\n+            return noMatchResult;\n         }\n \n+        List<PullMatch> result = new ArrayList<>();\n+\n         if (intAttrName.getField() != null) {\n             switch (intAttrName.getField()) {\n                 case \"key\":\n                     Any<?> any = anyUtils.dao().find(connObjectKey);\n                     if (any != null) {\n-                        result.add(any.getKey());\n+                        result.add(new PullMatch.Builder().matchingKey(any.getKey()).build());\n                     }\n                     break;\n \n@@ -239,12 +239,13 @@ private List<String> findByConnObjectKey(\n                         AnyCond cond = new AnyCond(AttributeCond.Type.IEQ);\n                         cond.setSchema(\"username\");\n                         cond.setExpression(connObjectKey);\n-                        result.addAll(searchDAO.search(SearchCond.getLeafCond(cond), AnyTypeKind.USER).\n-                                stream().map(Entity::getKey).collect(Collectors.toList()));\n+                        result.addAll(searchDAO.search(SearchCond.getLeafCond(cond), AnyTypeKind.USER).stream().\n+                                map(user -> new PullMatch.Builder().matchingKey(user.getKey()).build()).\n+                                collect(Collectors.toList()));\n                     } else {\n                         User user = userDAO.findByUsername(connObjectKey);\n                         if (user != null) {\n-                            result.add(user.getKey());\n+                            result.add(new PullMatch.Builder().matchingKey(user.getKey()).build());\n                         }\n                     }\n                     break;\n@@ -254,25 +255,27 @@ private List<String> findByConnObjectKey(\n                         AnyCond cond = new AnyCond(AttributeCond.Type.IEQ);\n                         cond.setSchema(\"name\");\n                         cond.setExpression(connObjectKey);\n-                        result.addAll(searchDAO.search(SearchCond.getLeafCond(cond), AnyTypeKind.GROUP).\n-                                stream().map(Entity::getKey).collect(Collectors.toList()));\n+                        result.addAll(searchDAO.search(SearchCond.getLeafCond(cond), AnyTypeKind.GROUP).stream().\n+                                map(group -> new PullMatch.Builder().matchingKey(group.getKey()).build()).\n+                                collect(Collectors.toList()));\n                     } else {\n                         Group group = groupDAO.findByName(connObjectKey);\n                         if (group != null) {\n-                            result.add(group.getKey());\n+                            result.add(new PullMatch.Builder().matchingKey(group.getKey()).build());\n                         }\n                     }\n \n                     if (provision.getAnyType().getKind() == AnyTypeKind.ANY_OBJECT && provision.isIgnoreCaseMatch()) {\n                         AnyCond cond = new AnyCond(AttributeCond.Type.IEQ);\n                         cond.setSchema(\"name\");\n                         cond.setExpression(connObjectKey);\n-                        result.addAll(searchDAO.search(SearchCond.getLeafCond(cond), AnyTypeKind.ANY_OBJECT).\n-                                stream().map(Entity::getKey).collect(Collectors.toList()));\n+                        result.addAll(searchDAO.search(SearchCond.getLeafCond(cond), AnyTypeKind.ANY_OBJECT).stream().\n+                                map(anyObject -> new PullMatch.Builder().matchingKey(anyObject.getKey()).build()).\n+                                collect(Collectors.toList()));\n                     } else {\n                         AnyObject anyObject = anyObjectDAO.findByName(connObjectKey);\n                         if (anyObject != null) {\n-                            result.add(anyObject.getKey());\n+                            result.add(new PullMatch.Builder().matchingKey(anyObject.getKey()).build());\n                         }\n                     }\n                     break;\n@@ -295,35 +298,46 @@ private List<String> findByConnObjectKey(\n                     if (intAttrName.getSchema().isUniqueConstraint()) {\n                         anyUtils.dao().findByPlainAttrUniqueValue((PlainSchema) intAttrName.getSchema(),\n                                 (PlainAttrUniqueValue) value, provision.isIgnoreCaseMatch()).\n-                                ifPresent(found -> result.add(found.getKey()));\n+                                ifPresent(any -> result.add(new PullMatch.Builder().matchingKey(any.getKey()).build()));\n                     } else {\n                         result.addAll(anyUtils.dao().findByPlainAttrValue((PlainSchema) intAttrName.getSchema(),\n-                                value, provision.isIgnoreCaseMatch()).\n-                                stream().map(Entity::getKey).collect(Collectors.toList()));\n+                                value, provision.isIgnoreCaseMatch()).stream().\n+                                map(any -> new PullMatch.Builder().matchingKey(any.getKey()).build()).\n+                                collect(Collectors.toList()));\n                     }\n                     break;\n \n                 case DERIVED:\n-                    result.addAll(anyUtils.dao().findByDerAttrValue(\n-                            (DerSchema) intAttrName.getSchema(), connObjectKey, provision.isIgnoreCaseMatch()).\n-                            stream().map(Entity::getKey).collect(Collectors.toList()));\n+                    result.addAll(anyUtils.dao().findByDerAttrValue((DerSchema) intAttrName.getSchema(),\n+                            connObjectKey, provision.isIgnoreCaseMatch()).stream().\n+                            map(any -> new PullMatch.Builder().matchingKey(any.getKey()).build()).\n+                            collect(Collectors.toList()));\n                     break;\n \n                 default:\n             }\n         }\n \n-        return result;\n+        return result.isEmpty() ? noMatchResult : result;\n     }\n \n-    private List<String> findByCorrelationRule(\n+    private List<PullMatch> findByCorrelationRule(\n             final SyncDelta syncDelta,\n             final Provision provision,\n             final PullCorrelationRule rule,\n             final AnyTypeKind type) {\n \n-        return searchDAO.search(rule.getSearchCond(syncDelta, provision), type).stream().\n-                map(Entity::getKey).collect(Collectors.toList());\n+        List<PullMatch> result = new ArrayList<>();\n+\n+        result.addAll(searchDAO.search(rule.getSearchCond(syncDelta, provision), type).stream().\n+                map(any -> rule.matching(any, syncDelta, provision)).\n+                collect(Collectors.toList()));\n+\n+        if (result.isEmpty()) {\n+            rule.unmatching(syncDelta, provision).ifPresent(result::add);\n+        }\n+\n+        return result;\n     }\n \n     /**\n@@ -334,7 +348,7 @@ private List<String> findByCorrelationRule(\n      * @param anyUtils any utils\n      * @return list of matching users' / groups' / any objects' keys\n      */\n-    public List<String> match(\n+    public List<PullMatch> match(\n             final SyncDelta syncDelta,\n             final Provision provision,\n             final AnyUtils anyUtils) {\n@@ -432,16 +446,4 @@ public List<String> match(\n \n         return result;\n     }\n-\n-    public static Boolean readEnabled(final ConnectorObject connectorObject, final ProvisioningTask task) {\n-        Boolean enabled = null;\n-        if (task.isSyncStatus()) {\n-            Attribute status = AttributeUtil.find(OperationalAttributes.ENABLE_NAME, connectorObject.getAttributes());\n-            if (status != null && status.getValue() != null && !status.getValue().isEmpty()) {\n-                enabled = (Boolean) status.getValue().get(0);\n-            }\n-        }\n-\n-        return enabled;\n-    }\n }"},{"sha":"6db67f1d62d4d7757ed72c568c9147abaa827cf4","filename":"core/provisioning-java/src/main/java/org/apache/syncope/core/provisioning/java/pushpull/PushUtils.java","status":"modified","additions":0,"deletions":27,"changes":27,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FPushUtils.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FPushUtils.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FPushUtils.java?ref=cb560bf69bf951bdff34abf3ffcad8fff82c6a11","patch":"@@ -26,15 +26,13 @@\n import org.apache.syncope.core.persistence.api.entity.policy.PushCorrelationRuleEntity;\n import org.apache.syncope.core.persistence.api.entity.resource.MappingItem;\n import org.apache.syncope.core.persistence.api.entity.resource.Provision;\n-import org.apache.syncope.core.persistence.api.entity.user.LinkedAccount;\n import org.apache.syncope.core.provisioning.api.Connector;\n import org.apache.syncope.core.provisioning.api.MappingManager;\n import org.apache.syncope.core.provisioning.api.TimeoutException;\n import org.apache.syncope.core.provisioning.java.utils.MappingUtils;\n import org.apache.syncope.core.spring.ImplementationManager;\n import org.identityconnectors.framework.common.objects.AttributeBuilder;\n import org.identityconnectors.framework.common.objects.ConnectorObject;\n-import org.identityconnectors.framework.common.objects.Name;\n import org.identityconnectors.framework.common.objects.SearchResult;\n import org.identityconnectors.framework.spi.SearchResultsHandler;\n import org.slf4j.Logger;\n@@ -138,29 +136,4 @@ public List<ConnectorObject> findByConnObjectKey(\n \n         return obj == null ? List.of() : List.of(obj);\n     }\n-\n-    public ConnectorObject match(\n-            final Connector connector,\n-            final LinkedAccount account,\n-            final Provision provision) {\n-\n-        Optional<? extends MappingItem> connObjectKey = MappingUtils.getConnObjectKeyItem(provision);\n-        String connObjectKeyName = connObjectKey.isPresent()\n-                ? connObjectKey.get().getExtAttrName()\n-                : Name.NAME;\n-\n-        ConnectorObject obj = null;\n-        try {\n-            obj = connector.getObject(\n-                    provision.getObjectClass(),\n-                    AttributeBuilder.build(connObjectKeyName, account.getConnObjectKeyValue()),\n-                    provision.isIgnoreCaseMatch(),\n-                    MappingUtils.buildOperationOptions(provision.getMapping().getItems().iterator()));\n-        } catch (TimeoutException toe) {\n-            LOG.debug(\"Request timeout\", toe);\n-            throw toe;\n-        }\n-\n-        return obj;\n-    }\n }"},{"sha":"fda08a0e86771065a902de59125745a7cf8e8335","filename":"core/provisioning-java/src/main/java/org/apache/syncope/core/provisioning/java/utils/ConnObjectUtils.java","status":"modified","additions":65,"deletions":62,"changes":127,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Futils%2FConnObjectUtils.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Futils%2FConnObjectUtils.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Futils%2FConnObjectUtils.java?ref=cb560bf69bf951bdff34abf3ffcad8fff82c6a11","patch":"@@ -161,23 +161,27 @@ public static ConnObjectTO getConnObjectTO(final Set<Attribute> attrs) {\n      * @param pullTask pull task\n      * @param provision provision information\n      * @param anyUtils utils\n-     * @return UserTO for the user to be created\n+     * @param generatePasswordIfPossible whether password value shall be generated, in case not found from\n+     * connector object and allowed by resource configuration\n+     * @param <C> create request type\n+     * @return create request\n      */\n     @Transactional(readOnly = true)\n-    public AnyCR getAnyCR(\n+    public <C extends AnyCR> C getAnyCR(\n             final ConnectorObject obj,\n             final PullTask pullTask,\n             final Provision provision,\n-            final AnyUtils anyUtils) {\n+            final AnyUtils anyUtils,\n+            final boolean generatePasswordIfPossible) {\n \n         AnyTO anyTO = getAnyTOFromConnObject(obj, pullTask, provision, anyUtils);\n-        AnyCR anyCR = anyUtils.newAnyCR();\n+        C anyCR = anyUtils.newAnyCR();\n         EntityTOUtils.toAnyCR(anyTO, anyCR);\n \n         // (for users) if password was not set above, generate if resource is configured for that\n         if (anyCR instanceof UserCR\n                 && StringUtils.isBlank(((UserCR) anyCR).getPassword())\n-                && provision.getResource().isRandomPwdIfNotProvided()) {\n+                && generatePasswordIfPossible && provision.getResource().isRandomPwdIfNotProvided()) {\n \n             UserCR userCR = (UserCR) anyCR;\n             List<PasswordPolicy> passwordPolicies = new ArrayList<>();\n@@ -234,64 +238,63 @@ public <U extends AnyUR> U getAnyUR(\n         updated.setKey(key);\n \n         U anyUR = null;\n-        if (null != anyUtils.anyTypeKind()) {\n-            switch (anyUtils.anyTypeKind()) {\n-                case USER:\n-                    UserTO originalUser = (UserTO) original;\n-                    UserTO updatedUser = (UserTO) updated;\n-\n-                    if (StringUtils.isBlank(updatedUser.getUsername())) {\n-                        updatedUser.setUsername(originalUser.getUsername());\n-                    }\n-\n-                    // update password if and only if password is really changed\n-                    User user = userDAO.authFind(key);\n-                    if (StringUtils.isBlank(updatedUser.getPassword())\n-                            || ENCRYPTOR.verify(updatedUser.getPassword(),\n-                                    user.getCipherAlgorithm(), user.getPassword())) {\n-\n-                        updatedUser.setPassword(null);\n-                    }\n-\n-                    updatedUser.setSecurityQuestion(originalUser.getSecurityQuestion());\n-\n-                    if (!mappingManager.hasMustChangePassword(provision)) {\n-                        updatedUser.setMustChangePassword(originalUser.isMustChangePassword());\n-                    }\n-\n-                    anyUR = (U) AnyOperations.diff(updatedUser, originalUser, true);\n-                    break;\n-\n-                case GROUP:\n-                    GroupTO originalGroup = (GroupTO) original;\n-                    GroupTO updatedGroup = (GroupTO) updated;\n-\n-                    if (StringUtils.isBlank(updatedGroup.getName())) {\n-                        updatedGroup.setName(originalGroup.getName());\n-                    }\n-                    updatedGroup.setUserOwner(originalGroup.getUserOwner());\n-                    updatedGroup.setGroupOwner(originalGroup.getGroupOwner());\n-                    updatedGroup.setUDynMembershipCond(originalGroup.getUDynMembershipCond());\n-                    updatedGroup.getADynMembershipConds().putAll(originalGroup.getADynMembershipConds());\n-                    updatedGroup.getTypeExtensions().addAll(originalGroup.getTypeExtensions());\n-\n-                    anyUR = (U) AnyOperations.diff(updatedGroup, originalGroup, true);\n-                    break;\n-\n-                case ANY_OBJECT:\n-                    AnyObjectTO originalAnyObject = (AnyObjectTO) original;\n-                    AnyObjectTO updatedAnyObject = (AnyObjectTO) updated;\n-\n-                    if (StringUtils.isBlank(updatedAnyObject.getName())) {\n-                        updatedAnyObject.setName(originalAnyObject.getName());\n-                    }\n-\n-                    anyUR = (U) AnyOperations.diff(updatedAnyObject, originalAnyObject, true);\n-                    break;\n-\n-                default:\n-            }\n+        switch (anyUtils.anyTypeKind()) {\n+            case USER:\n+                UserTO originalUser = (UserTO) original;\n+                UserTO updatedUser = (UserTO) updated;\n+\n+                if (StringUtils.isBlank(updatedUser.getUsername())) {\n+                    updatedUser.setUsername(originalUser.getUsername());\n+                }\n+\n+                // update password if and only if password is really changed\n+                User user = userDAO.authFind(key);\n+                if (StringUtils.isBlank(updatedUser.getPassword())\n+                        || ENCRYPTOR.verify(updatedUser.getPassword(),\n+                                user.getCipherAlgorithm(), user.getPassword())) {\n+\n+                    updatedUser.setPassword(null);\n+                }\n+\n+                updatedUser.setSecurityQuestion(originalUser.getSecurityQuestion());\n+\n+                if (!mappingManager.hasMustChangePassword(provision)) {\n+                    updatedUser.setMustChangePassword(originalUser.isMustChangePassword());\n+                }\n+\n+                anyUR = (U) AnyOperations.diff(updatedUser, originalUser, true);\n+                break;\n+\n+            case GROUP:\n+                GroupTO originalGroup = (GroupTO) original;\n+                GroupTO updatedGroup = (GroupTO) updated;\n+\n+                if (StringUtils.isBlank(updatedGroup.getName())) {\n+                    updatedGroup.setName(originalGroup.getName());\n+                }\n+                updatedGroup.setUserOwner(originalGroup.getUserOwner());\n+                updatedGroup.setGroupOwner(originalGroup.getGroupOwner());\n+                updatedGroup.setUDynMembershipCond(originalGroup.getUDynMembershipCond());\n+                updatedGroup.getADynMembershipConds().putAll(originalGroup.getADynMembershipConds());\n+                updatedGroup.getTypeExtensions().addAll(originalGroup.getTypeExtensions());\n+\n+                anyUR = (U) AnyOperations.diff(updatedGroup, originalGroup, true);\n+                break;\n+\n+            case ANY_OBJECT:\n+                AnyObjectTO originalAnyObject = (AnyObjectTO) original;\n+                AnyObjectTO updatedAnyObject = (AnyObjectTO) updated;\n+\n+                if (StringUtils.isBlank(updatedAnyObject.getName())) {\n+                    updatedAnyObject.setName(originalAnyObject.getName());\n+                }\n+\n+                anyUR = (U) AnyOperations.diff(updatedAnyObject, originalAnyObject, true);\n+                break;\n+\n+            default:\n         }\n+\n         // SYNCOPE-1343, remove null or empty values from the patch plain attributes\n         if (anyUR != null) {\n             AnyOperations.cleanEmptyAttrs(updated, anyUR);"},{"sha":"ae0354122efea21a5ed95309898c614ff2093797","filename":"ext/oidcclient/logic/src/main/java/org/apache/syncope/core/logic/oidc/OIDCUserManager.java","status":"modified","additions":17,"deletions":12,"changes":29,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/ext%2Foidcclient%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Flogic%2Foidc%2FOIDCUserManager.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/ext%2Foidcclient%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Flogic%2Foidc%2FOIDCUserManager.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/ext%2Foidcclient%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Flogic%2Foidc%2FOIDCUserManager.java?ref=cb560bf69bf951bdff34abf3ffcad8fff82c6a11","patch":"@@ -23,6 +23,7 @@\n import java.util.Collections;\n import java.util.List;\n import java.util.Optional;\n+import java.util.function.Function;\n import java.util.stream.Collectors;\n import org.apache.commons.lang3.SerializationUtils;\n import org.apache.commons.lang3.tuple.Pair;\n@@ -241,9 +242,10 @@ public String create(final OIDCProvider op, final OIDCLoginResponseTO responseTO\n         }\n \n         List<OIDCProviderActions> actions = getActions(op);\n-        for (OIDCProviderActions action : actions) {\n-            userCR = action.beforeCreate(userCR, responseTO);\n-        }\n+        userCR = actions.stream().\n+                map(action -> action.beforeCreate(responseTO)).\n+                reduce(Function.identity(), Function::andThen).\n+                apply(userCR);\n \n         UserTO userTO = new UserTO();\n         fill(op, responseTO, userTO);\n@@ -259,9 +261,10 @@ public String create(final OIDCProvider op, final OIDCLoginResponseTO responseTO\n         Pair<String, List<PropagationStatus>> created = provisioningManager.create(userCR, false);\n         userTO = binder.getUserTO(created.getKey());\n \n-        for (OIDCProviderActions action : actions) {\n-            userTO = action.afterCreate(userTO, responseTO);\n-        }\n+        userTO = actions.stream().\n+                map(action -> action.afterCreate(responseTO)).\n+                reduce(Function.identity(), Function::andThen).\n+                apply(userTO);\n \n         return userTO.getUsername();\n     }\n@@ -276,16 +279,18 @@ public String update(final String username, final OIDCProvider op, final OIDCLog\n         UserUR userUR = AnyOperations.diff(userTO, original, true);\n \n         List<OIDCProviderActions> actions = getActions(op);\n-        for (OIDCProviderActions action : actions) {\n-            userUR = action.beforeUpdate(userUR, responseTO);\n-        }\n+        userUR = actions.stream().\n+                map(action -> action.beforeUpdate(responseTO)).\n+                reduce(Function.identity(), Function::andThen).\n+                apply(userUR);\n \n         Pair<UserUR, List<PropagationStatus>> updated = provisioningManager.update(userUR, false);\n         userTO = binder.getUserTO(updated.getLeft().getKey());\n \n-        for (OIDCProviderActions action : actions) {\n-            userTO = action.afterUpdate(userTO, responseTO);\n-        }\n+        userTO = actions.stream().\n+                map(action -> action.afterUpdate(responseTO)).\n+                reduce(Function.identity(), Function::andThen).\n+                apply(userTO);\n \n         return userTO.getUsername();\n     }"},{"sha":"4828fbb07f8a5966b64588525aead1fe8b355f6b","filename":"ext/oidcclient/provisioning-api/src/main/java/org/apache/syncope/core/provisioning/api/OIDCProviderActions.java","status":"modified","additions":13,"deletions":4,"changes":17,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/ext%2Foidcclient%2Fprovisioning-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fapi%2FOIDCProviderActions.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/ext%2Foidcclient%2Fprovisioning-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fapi%2FOIDCProviderActions.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/ext%2Foidcclient%2Fprovisioning-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fapi%2FOIDCProviderActions.java?ref=cb560bf69bf951bdff34abf3ffcad8fff82c6a11","patch":"@@ -18,18 +18,27 @@\n  */\n package org.apache.syncope.core.provisioning.api;\n \n+import java.util.function.Function;\n import org.apache.syncope.common.lib.request.UserCR;\n import org.apache.syncope.common.lib.request.UserUR;\n import org.apache.syncope.common.lib.to.OIDCLoginResponseTO;\n import org.apache.syncope.common.lib.to.UserTO;\n \n public interface OIDCProviderActions {\n \n-    UserCR beforeCreate(UserCR input, OIDCLoginResponseTO loginResponse);\n+    default Function<UserCR, UserCR> beforeCreate(OIDCLoginResponseTO loginResponse) {\n+        return Function.identity();\n+    }\n \n-    UserTO afterCreate(UserTO input, OIDCLoginResponseTO loginResponse);\n+    default Function<UserTO, UserTO> afterCreate(OIDCLoginResponseTO loginResponse) {\n+        return Function.identity();\n+    }\n \n-    UserUR beforeUpdate(UserUR input, OIDCLoginResponseTO loginResponse);\n+    default Function<UserUR, UserUR> beforeUpdate(OIDCLoginResponseTO loginResponse) {\n+        return Function.identity();\n+    }\n \n-    UserTO afterUpdate(UserTO input, OIDCLoginResponseTO loginResponse);\n+    default Function<UserTO, UserTO> afterUpdate(OIDCLoginResponseTO loginResponse) {\n+        return Function.identity();\n+    }\n }"},{"sha":"0dea98c3db5ea9f892a36018fb3eb238c0d268fd","filename":"ext/saml2sp/logic/src/main/java/org/apache/syncope/core/logic/saml2/SAML2UserManager.java","status":"modified","additions":17,"deletions":12,"changes":29,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/ext%2Fsaml2sp%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Flogic%2Fsaml2%2FSAML2UserManager.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/ext%2Fsaml2sp%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Flogic%2Fsaml2%2FSAML2UserManager.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/ext%2Fsaml2sp%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Flogic%2Fsaml2%2FSAML2UserManager.java?ref=cb560bf69bf951bdff34abf3ffcad8fff82c6a11","patch":"@@ -23,6 +23,7 @@\n import java.util.Collections;\n import java.util.List;\n import java.util.Optional;\n+import java.util.function.Function;\n import java.util.stream.Collectors;\n import org.apache.commons.lang3.SerializationUtils;\n import org.apache.commons.lang3.tuple.Pair;\n@@ -259,9 +260,10 @@ public String create(final SAML2IdPEntity idp, final SAML2LoginResponseTO respon\n         }\n \n         List<SAML2IdPActions> actions = getActions(idp);\n-        for (SAML2IdPActions action : actions) {\n-            userCR = action.beforeCreate(userCR, responseTO);\n-        }\n+        userCR = actions.stream().\n+                map(action -> action.beforeCreate(responseTO)).\n+                reduce(Function.identity(), Function::andThen).\n+                apply(userCR);\n \n         UserTO userTO = new UserTO();\n         fill(idp.getKey(), responseTO, userTO);\n@@ -277,9 +279,10 @@ public String create(final SAML2IdPEntity idp, final SAML2LoginResponseTO respon\n         Pair<String, List<PropagationStatus>> created = provisioningManager.create(userCR, false);\n         userTO = binder.getUserTO(created.getKey());\n \n-        for (SAML2IdPActions action : actions) {\n-            userTO = action.afterCreate(userTO, responseTO);\n-        }\n+        userTO = actions.stream().\n+                map(action -> action.afterCreate(responseTO)).\n+                reduce(Function.identity(), Function::andThen).\n+                apply(userTO);\n \n         return userTO.getUsername();\n     }\n@@ -294,16 +297,18 @@ public String update(final String username, final SAML2IdPEntity idp, final SAML\n         UserUR userUR = AnyOperations.diff(userTO, original, true);\n \n         List<SAML2IdPActions> actions = getActions(idp);\n-        for (SAML2IdPActions action : actions) {\n-            userUR = action.beforeUpdate(userUR, responseTO);\n-        }\n+        userUR = actions.stream().\n+                map(action -> action.beforeUpdate(responseTO)).\n+                reduce(Function.identity(), Function::andThen).\n+                apply(userUR);\n \n         Pair<UserUR, List<PropagationStatus>> updated = provisioningManager.update(userUR, false);\n         userTO = binder.getUserTO(updated.getLeft().getKey());\n \n-        for (SAML2IdPActions action : actions) {\n-            userTO = action.afterUpdate(userTO, responseTO);\n-        }\n+        userTO = actions.stream().\n+                map(action -> action.afterUpdate(responseTO)).\n+                reduce(Function.identity(), Function::andThen).\n+                apply(userTO);\n \n         return userTO.getUsername();\n     }"},{"sha":"9948e63c05d5c102bdcc116a8c453890b8ced0ad","filename":"ext/saml2sp/provisioning-api/src/main/java/org/apache/syncope/core/provisioning/api/SAML2IdPActions.java","status":"modified","additions":9,"deletions":8,"changes":17,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/ext%2Fsaml2sp%2Fprovisioning-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fapi%2FSAML2IdPActions.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/ext%2Fsaml2sp%2Fprovisioning-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fapi%2FSAML2IdPActions.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/ext%2Fsaml2sp%2Fprovisioning-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fapi%2FSAML2IdPActions.java?ref=cb560bf69bf951bdff34abf3ffcad8fff82c6a11","patch":"@@ -18,26 +18,27 @@\n  */\n package org.apache.syncope.core.provisioning.api;\n \n+import java.util.function.Function;\n import org.apache.syncope.common.lib.request.UserCR;\n import org.apache.syncope.common.lib.request.UserUR;\n import org.apache.syncope.common.lib.to.SAML2LoginResponseTO;\n import org.apache.syncope.common.lib.to.UserTO;\n \n public interface SAML2IdPActions {\n \n-    default UserCR beforeCreate(UserCR input, SAML2LoginResponseTO loginResponse) {\n-        return input;\n+    default Function<UserCR, UserCR> beforeCreate(SAML2LoginResponseTO loginResponse) {\n+        return Function.identity();\n     }\n \n-    default UserTO afterCreate(UserTO input, SAML2LoginResponseTO loginResponse) {\n-        return input;\n+    default Function<UserTO, UserTO> afterCreate(SAML2LoginResponseTO loginResponse) {\n+        return Function.identity();\n     }\n \n-    default UserUR beforeUpdate(UserUR input, SAML2LoginResponseTO loginResponse) {\n-        return input;\n+    default Function<UserUR, UserUR> beforeUpdate(SAML2LoginResponseTO loginResponse) {\n+        return Function.identity();\n     }\n \n-    default UserTO afterUpdate(UserTO input, SAML2LoginResponseTO loginResponse) {\n-        return input;\n+    default Function<UserTO, UserTO> afterUpdate(SAML2LoginResponseTO loginResponse) {\n+        return Function.identity();\n     }\n }"},{"sha":"ae9ce5ecbf9964b40ae1b41ea5ae5717f70554ea","filename":"fit/build-tools/src/main/java/org/apache/syncope/fit/buildtools/SyncopeBuildToolsApplication.java","status":"modified","additions":6,"deletions":5,"changes":11,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/fit%2Fbuild-tools%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fbuildtools%2FSyncopeBuildToolsApplication.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/fit%2Fbuild-tools%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fbuildtools%2FSyncopeBuildToolsApplication.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/fit%2Fbuild-tools%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fbuildtools%2FSyncopeBuildToolsApplication.java?ref=cb560bf69bf951bdff34abf3ffcad8fff82c6a11","patch":"@@ -30,6 +30,7 @@\n import org.apache.cxf.endpoint.Server;\n import org.apache.cxf.jaxrs.spring.JAXRSServerFactoryBeanDefinitionParser.SpringJAXRSServerFactoryBean;\n import org.apache.cxf.jaxws.EndpointImpl;\n+import org.apache.syncope.fit.buildtools.cxf.DateParamConverterProvider;\n import org.apache.syncope.fit.buildtools.cxf.ProvisioningImpl;\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.beans.factory.annotation.Value;\n@@ -44,10 +45,10 @@\n import org.springframework.jdbc.datasource.DriverManagerDataSource;\n \n @SpringBootApplication(scanBasePackages = \"org.apache.syncope.fit.buildtools\",\n-    exclude = {\n-        ErrorMvcAutoConfiguration.class,\n-        WebMvcAutoConfiguration.class,\n-        HttpMessageConvertersAutoConfiguration.class })\n+        exclude = {\n+            ErrorMvcAutoConfiguration.class,\n+            WebMvcAutoConfiguration.class,\n+            HttpMessageConvertersAutoConfiguration.class })\n public class SyncopeBuildToolsApplication extends SpringBootServletInitializer {\n \n     public static void main(final String[] args) {\n@@ -98,7 +99,7 @@ public Server restProvisioning() {\n         restProvisioning.setAddress(\"/rest\");\n         restProvisioning.setStaticSubresourceResolution(true);\n         restProvisioning.setBasePackages(List.of(\"org.apache.syncope.fit.buildtools.cxf\"));\n-        restProvisioning.setProviders(List.of(new JacksonJsonProvider()));\n+        restProvisioning.setProviders(List.of(new JacksonJsonProvider(), new DateParamConverterProvider()));\n         return restProvisioning.create();\n     }\n "},{"sha":"2c50207a5f3fc9311d8f7363c4734746384d3759","filename":"fit/build-tools/src/main/java/org/apache/syncope/fit/buildtools/cxf/DateParamConverterProvider.java","status":"added","additions":61,"deletions":0,"changes":61,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/fit%2Fbuild-tools%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fbuildtools%2Fcxf%2FDateParamConverterProvider.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/fit%2Fbuild-tools%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fbuildtools%2Fcxf%2FDateParamConverterProvider.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/fit%2Fbuild-tools%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fbuildtools%2Fcxf%2FDateParamConverterProvider.java?ref=cb560bf69bf951bdff34abf3ffcad8fff82c6a11","patch":"@@ -0,0 +1,61 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.fit.buildtools.cxf;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Type;\n+import java.util.Date;\n+import javax.ws.rs.ext.ParamConverter;\n+import javax.ws.rs.ext.ParamConverterProvider;\n+import org.springframework.util.StringUtils;\n+\n+public class DateParamConverterProvider implements ParamConverterProvider {\n+\n+    private static class DateParamConverter implements ParamConverter<Date> {\n+\n+        @Override\n+        public Date fromString(final String value) {\n+            if (StringUtils.isEmpty(value)) {\n+                return null;\n+            }\n+            try {\n+                return new Date(Long.valueOf(value));\n+            } catch (final NumberFormatException e) {\n+                throw new IllegalArgumentException(\"Unparsable date: \" + value, e);\n+            }\n+        }\n+\n+        @Override\n+        public String toString(final Date value) {\n+            return value == null ? null : String.valueOf(value.getTime());\n+        }\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> ParamConverter<T> getConverter(\n+            final Class<T> rawType, final Type genericType, final Annotation[] annotations) {\n+\n+        if (Date.class.equals(rawType)) {\n+            return (ParamConverter<T>) new DateParamConverter();\n+        }\n+\n+        return null;\n+    }\n+}"},{"sha":"add6f94a9d0c2823827a4d517b606ef549f004f7","filename":"fit/build-tools/src/main/java/org/apache/syncope/fit/buildtools/cxf/User.java","status":"modified","additions":15,"deletions":0,"changes":15,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/fit%2Fbuild-tools%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fbuildtools%2Fcxf%2FUser.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/fit%2Fbuild-tools%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fbuildtools%2Fcxf%2FUser.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/fit%2Fbuild-tools%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fbuildtools%2Fcxf%2FUser.java?ref=cb560bf69bf951bdff34abf3ffcad8fff82c6a11","patch":"@@ -25,6 +25,12 @@ public class User implements Serializable {\n \n     private static final long serialVersionUID = -7906946710921162676L;\n \n+    public enum Status {\n+        ACTIVE,\n+        INACTIVE;\n+\n+    }\n+\n     private UUID key;\n \n     private String username;\n@@ -37,6 +43,8 @@ public class User implements Serializable {\n \n     private String email;\n \n+    private Status status;\n+\n     public UUID getKey() {\n         return key;\n     }\n@@ -85,4 +93,11 @@ public void setEmail(final String email) {\n         this.email = email;\n     }\n \n+    public Status getStatus() {\n+        return status;\n+    }\n+\n+    public void setStatus(final Status status) {\n+        this.status = status;\n+    }\n }"},{"sha":"d6591b4ab40bdf1df52691b3b6416b0baacdcc46","filename":"fit/build-tools/src/main/java/org/apache/syncope/fit/buildtools/cxf/UserMetadata.java","status":"added","additions":57,"deletions":0,"changes":57,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/fit%2Fbuild-tools%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fbuildtools%2Fcxf%2FUserMetadata.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/fit%2Fbuild-tools%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fbuildtools%2Fcxf%2FUserMetadata.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/fit%2Fbuild-tools%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fbuildtools%2Fcxf%2FUserMetadata.java?ref=cb560bf69bf951bdff34abf3ffcad8fff82c6a11","patch":"@@ -0,0 +1,57 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.fit.buildtools.cxf;\n+\n+import java.io.Serializable;\n+import java.util.Date;\n+\n+public class UserMetadata implements Serializable {\n+\n+    private static final long serialVersionUID = -5448360771141372951L;\n+\n+    private User user;\n+\n+    private Date lastChangeDate;\n+\n+    private boolean deleted;\n+\n+    public User getUser() {\n+        return user;\n+    }\n+\n+    public void setUser(final User user) {\n+        this.user = user;\n+    }\n+\n+    public Date getLastChangeDate() {\n+        return lastChangeDate;\n+    }\n+\n+    public void setLastChangeDate(final Date lastChangeDate) {\n+        this.lastChangeDate = lastChangeDate;\n+    }\n+\n+    public boolean isDeleted() {\n+        return deleted;\n+    }\n+\n+    public void setDeleted(final boolean deleted) {\n+        this.deleted = deleted;\n+    }\n+}"},{"sha":"509a44be8ce4404448eab66a4736c4b579350b6a","filename":"fit/build-tools/src/main/java/org/apache/syncope/fit/buildtools/cxf/UserService.java","status":"modified","additions":6,"deletions":0,"changes":6,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/fit%2Fbuild-tools%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fbuildtools%2Fcxf%2FUserService.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/fit%2Fbuild-tools%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fbuildtools%2Fcxf%2FUserService.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/fit%2Fbuild-tools%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fbuildtools%2Fcxf%2FUserService.java?ref=cb560bf69bf951bdff34abf3ffcad8fff82c6a11","patch":"@@ -18,6 +18,7 @@\n  */\n package org.apache.syncope.fit.buildtools.cxf;\n \n+import java.util.Date;\n import java.util.List;\n import java.util.UUID;\n import javax.ws.rs.Consumes;\n@@ -39,6 +40,11 @@ public interface UserService {\n     @Produces({ MediaType.APPLICATION_JSON })\n     List<User> list();\n \n+    @GET\n+    @Path(\"changelog\")\n+    @Produces({ MediaType.APPLICATION_JSON })\n+    List<UserMetadata> changelog(@QueryParam(\"from\") Date from);\n+\n     @GET\n     @Path(\"{key}\")\n     @Produces({ MediaType.APPLICATION_JSON })"},{"sha":"321767fd7ec69cc6c2250cc65807de7b38516505","filename":"fit/build-tools/src/main/java/org/apache/syncope/fit/buildtools/cxf/UserServiceImpl.java","status":"modified","additions":58,"deletions":28,"changes":86,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/fit%2Fbuild-tools%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fbuildtools%2Fcxf%2FUserServiceImpl.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/fit%2Fbuild-tools%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fbuildtools%2Fcxf%2FUserServiceImpl.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/fit%2Fbuild-tools%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fbuildtools%2Fcxf%2FUserServiceImpl.java?ref=cb560bf69bf951bdff34abf3ffcad8fff82c6a11","patch":"@@ -18,11 +18,14 @@\n  */\n package org.apache.syncope.fit.buildtools.cxf;\n \n-import java.util.ArrayList;\n+import java.util.Date;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n+import java.util.Optional;\n import java.util.UUID;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n import javax.ws.rs.ClientErrorException;\n import javax.ws.rs.ForbiddenException;\n import javax.ws.rs.NotFoundException;\n@@ -34,90 +37,117 @@\n @Service\n public class UserServiceImpl implements UserService {\n \n-    private static final Map<UUID, User> USERS = new HashMap<UUID, User>();\n+    private static final Map<UUID, UserMetadata> USERS = new HashMap<>();\n \n     @Context\n     private UriInfo uriInfo;\n \n     @Override\n     public List<User> list() {\n-        return new ArrayList<>(USERS.values());\n+        return USERS.values().stream().\n+                filter(meta -> !meta.isDeleted()).\n+                map(UserMetadata::getUser).\n+                collect(Collectors.toList());\n+    }\n+\n+    @Override\n+    public List<UserMetadata> changelog(final Date from) {\n+        Stream<UserMetadata> users = USERS.values().stream();\n+        if (from != null) {\n+            users = users.filter(meta -> meta.getLastChangeDate().after(from));\n+        }\n+        return users.collect(Collectors.toList());\n     }\n \n     @Override\n     public User read(final UUID key) {\n-        User user = USERS.get(key);\n-        if (user == null) {\n+        UserMetadata meta = USERS.get(key);\n+        if (meta == null || meta.isDeleted()) {\n             throw new NotFoundException(key.toString());\n         }\n-        return user;\n+        return meta.getUser();\n     }\n \n     @Override\n     public Response create(final User user) {\n         if (user.getKey() == null) {\n             user.setKey(UUID.randomUUID());\n         }\n-        if (USERS.containsKey(user.getKey())) {\n+        if (user.getStatus() == null) {\n+            user.setStatus(User.Status.ACTIVE);\n+        }\n+\n+        UserMetadata meta = USERS.get(user.getKey());\n+        if (meta != null && !meta.isDeleted()) {\n             throw new ClientErrorException(\"User already exists: \" + user.getKey(), Response.Status.CONFLICT);\n         }\n-        USERS.put(user.getKey(), user);\n+\n+        meta = new UserMetadata();\n+        meta.setLastChangeDate(new Date());\n+        meta.setUser(user);\n+        USERS.put(user.getKey(), meta);\n \n         return Response.created(uriInfo.getAbsolutePathBuilder().path(user.getKey().toString()).build()).build();\n     }\n \n     @Override\n     public void update(final UUID key, final User updatedUser) {\n-        if (!USERS.containsKey(key)) {\n-            throw new NotFoundException(updatedUser.getKey().toString());\n+        UserMetadata meta = USERS.get(key);\n+        if (meta == null || meta.isDeleted()) {\n+            throw new NotFoundException(key.toString());\n         }\n-        User user = USERS.get(key);\n+\n         if (updatedUser.getUsername() != null) {\n-            user.setUsername(updatedUser.getUsername());\n+            meta.getUser().setUsername(updatedUser.getUsername());\n         }\n         if (updatedUser.getPassword() != null) {\n-            user.setPassword(updatedUser.getPassword());\n+            meta.getUser().setPassword(updatedUser.getPassword());\n         }\n         if (updatedUser.getFirstName() != null) {\n-            user.setFirstName(updatedUser.getFirstName());\n+            meta.getUser().setFirstName(updatedUser.getFirstName());\n         }\n         if (updatedUser.getSurname() != null) {\n-            user.setSurname(updatedUser.getSurname());\n+            meta.getUser().setSurname(updatedUser.getSurname());\n         }\n         if (updatedUser.getEmail() != null) {\n-            user.setEmail(updatedUser.getEmail());\n+            meta.getUser().setEmail(updatedUser.getEmail());\n+        }\n+        if (updatedUser.getStatus() != null) {\n+            meta.getUser().setStatus(updatedUser.getStatus());\n         }\n+\n+        meta.setLastChangeDate(new Date());\n     }\n \n     @Override\n     public void delete(final UUID key) {\n-        if (!USERS.containsKey(key)) {\n+        UserMetadata meta = USERS.get(key);\n+        if (meta == null || meta.isDeleted()) {\n             throw new NotFoundException(key.toString());\n         }\n-        USERS.remove(key);\n+\n+        meta.setDeleted(true);\n+        meta.setLastChangeDate(new Date());\n     }\n \n     @Override\n     public User authenticate(final String username, final String password) {\n-        User user = null;\n-        for (User entry : USERS.values()) {\n-            if (username.equals(entry.getUsername())) {\n-                user = entry;\n-            }\n-        }\n-        if (user == null) {\n+        Optional<User> user = USERS.values().stream().\n+                filter(meta -> !meta.isDeleted() && username.equals(meta.getUser().getUsername())).\n+                findFirst().map(UserMetadata::getUser);\n+\n+        if (!user.isPresent()) {\n             throw new NotFoundException(username);\n         }\n-        if (!password.equals(user.getPassword())) {\n+        if (!password.equals(user.get().getPassword())) {\n             throw new ForbiddenException();\n         }\n \n-        return user;\n+        return user.get();\n     }\n \n     @Override\n     public void clear() {\n         USERS.clear();\n     }\n-\n }"},{"sha":"d75efc8da0672d7232c5753db678c299d871e26d","filename":"fit/core-reference/src/main/java/org/apache/syncope/fit/core/reference/ITImplementationLookup.java","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/fit%2Fcore-reference%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2Freference%2FITImplementationLookup.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/fit%2Fcore-reference%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2Freference%2FITImplementationLookup.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/fit%2Fcore-reference%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2Freference%2FITImplementationLookup.java?ref=cb560bf69bf951bdff34abf3ffcad8fff82c6a11","patch":"@@ -133,6 +133,7 @@ public class ITImplementationLookup implements ImplementationLookup {\n         {\n             put(DummyPullCorrelationRuleConf.class, DummyPullCorrelationRule.class);\n             put(DefaultPullCorrelationRuleConf.class, DefaultPullCorrelationRule.class);\n+            put(LinkedAccountSamplePullCorrelationRuleConf.class, LinkedAccountSamplePullCorrelationRule.class);\n         }\n     };\n "},{"sha":"fed103df89c995047cb2899400408423ec3c2b47","filename":"fit/core-reference/src/main/java/org/apache/syncope/fit/core/reference/LinkedAccountSamplePullCorrelationRule.java","status":"added","additions":78,"deletions":0,"changes":78,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/fit%2Fcore-reference%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2Freference%2FLinkedAccountSamplePullCorrelationRule.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/fit%2Fcore-reference%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2Freference%2FLinkedAccountSamplePullCorrelationRule.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/fit%2Fcore-reference%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2Freference%2FLinkedAccountSamplePullCorrelationRule.java?ref=cb560bf69bf951bdff34abf3ffcad8fff82c6a11","patch":"@@ -0,0 +1,78 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.fit.core.reference;\n+\n+import java.util.Optional;\n+import org.apache.syncope.core.persistence.api.dao.PullCorrelationRule;\n+import org.apache.syncope.core.persistence.api.dao.PullCorrelationRuleConfClass;\n+import org.apache.syncope.core.persistence.api.dao.PullMatch;\n+import org.apache.syncope.core.persistence.api.dao.search.AttributeCond;\n+import org.apache.syncope.core.persistence.api.dao.search.SearchCond;\n+import org.apache.syncope.core.persistence.api.entity.Any;\n+import org.apache.syncope.core.persistence.api.entity.resource.Provision;\n+import org.identityconnectors.framework.common.objects.Attribute;\n+import org.identityconnectors.framework.common.objects.SyncDelta;\n+import org.springframework.util.CollectionUtils;\n+\n+@PullCorrelationRuleConfClass(LinkedAccountSamplePullCorrelationRuleConf.class)\n+public class LinkedAccountSamplePullCorrelationRule implements PullCorrelationRule {\n+\n+    public static final String VIVALDI_KEY = \"b3cbc78d-32e6-4bd4-92e0-bbe07566a2ee\";\n+\n+    @Override\n+    public SearchCond getSearchCond(final SyncDelta syncDelta, final Provision provision) {\n+        AttributeCond cond = new AttributeCond();\n+\n+        Attribute email = syncDelta.getObject().getAttributeByName(\"email\");\n+        if (email != null && !CollectionUtils.isEmpty(email.getValue())) {\n+            cond.setSchema(\"email\");\n+            cond.setType(AttributeCond.Type.EQ);\n+            cond.setExpression(email.getValue().get(0).toString());\n+        } else {\n+            cond.setSchema(\"\");\n+        }\n+\n+        return SearchCond.getLeafCond(cond);\n+    }\n+\n+    @Override\n+    public PullMatch matching(final Any<?> any, final SyncDelta syncDelta, final Provision provision) {\n+        // if match with internal user vivaldi was found but firstName is different, update linked account\n+        // instead of updating user\n+        Attribute firstName = syncDelta.getObject().getAttributeByName(\"firstName\");\n+        if (VIVALDI_KEY.equals(any.getKey())\n+                && firstName != null && !CollectionUtils.isEmpty(firstName.getValue())\n+                && !\"Antonio\".equals(firstName.getValue().get(0).toString())) {\n+\n+            return new PullMatch.Builder().\n+                    linkingUserKey(VIVALDI_KEY).\n+                    matchTarget(PullMatch.MatchTarget.LINKED_ACCOUNT).build();\n+        }\n+\n+        return PullCorrelationRule.super.matching(any, syncDelta, provision);\n+    }\n+\n+    @Override\n+    public Optional<PullMatch> unmatching(final SyncDelta syncDelta, final Provision provision) {\n+        // if no match with internal user was found, link account to vivaldi instead of creating new user\n+        return Optional.of(new PullMatch.Builder().\n+                linkingUserKey(VIVALDI_KEY).\n+                matchTarget(PullMatch.MatchTarget.LINKED_ACCOUNT).build());\n+    }\n+}"},{"sha":"4981c88bec653547a1da0c9941c3ab079fb3169b","filename":"fit/core-reference/src/main/java/org/apache/syncope/fit/core/reference/LinkedAccountSamplePullCorrelationRuleConf.java","status":"added","additions":29,"deletions":0,"changes":29,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/fit%2Fcore-reference%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2Freference%2FLinkedAccountSamplePullCorrelationRuleConf.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/fit%2Fcore-reference%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2Freference%2FLinkedAccountSamplePullCorrelationRuleConf.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/fit%2Fcore-reference%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2Freference%2FLinkedAccountSamplePullCorrelationRuleConf.java?ref=cb560bf69bf951bdff34abf3ffcad8fff82c6a11","patch":"@@ -0,0 +1,29 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.fit.core.reference;\n+\n+import org.apache.syncope.common.lib.policy.AbstractCorrelationRuleConf;\n+import org.apache.syncope.common.lib.policy.PullCorrelationRuleConf;\n+\n+public class LinkedAccountSamplePullCorrelationRuleConf\n+        extends AbstractCorrelationRuleConf implements PullCorrelationRuleConf {\n+\n+    private static final long serialVersionUID = -958386962492907926L;\n+\n+}"},{"sha":"9d3e9bdbce2847dd8d6e31b55c6350f9d8937258","filename":"fit/core-reference/src/test/java/org/apache/syncope/fit/AbstractITCase.java","status":"modified","additions":3,"deletions":0,"changes":3,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2FAbstractITCase.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2FAbstractITCase.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2FAbstractITCase.java?ref=cb560bf69bf951bdff34abf3ffcad8fff82c6a11","patch":"@@ -22,6 +22,7 @@\n import static org.junit.jupiter.api.Assertions.assertNotNull;\n import static org.junit.jupiter.api.Assertions.fail;\n \n+import com.fasterxml.jackson.databind.ObjectMapper;\n import java.io.IOException;\n import java.io.InputStream;\n import java.net.URI;\n@@ -133,6 +134,8 @@ public abstract class AbstractITCase {\n \n     protected static final Logger LOG = LoggerFactory.getLogger(AbstractITCase.class);\n \n+    protected static final ObjectMapper MAPPER = new ObjectMapper();\n+\n     protected static final String ADMIN_UNAME = \"admin\";\n \n     protected static final String ADMIN_PWD = \"password\";"},{"sha":"8b9f6829ba4379a99cb022d3dbc8b538ab33ef4d","filename":"fit/core-reference/src/test/java/org/apache/syncope/fit/core/BatchITCase.java","status":"modified","additions":0,"deletions":3,"changes":3,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FBatchITCase.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FBatchITCase.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FBatchITCase.java?ref=cb560bf69bf951bdff34abf3ffcad8fff82c6a11","patch":"@@ -25,7 +25,6 @@\n \n import com.fasterxml.jackson.core.JsonProcessingException;\n import com.fasterxml.jackson.core.type.TypeReference;\n-import com.fasterxml.jackson.databind.ObjectMapper;\n import java.io.ByteArrayInputStream;\n import java.io.IOException;\n import java.io.InputStream;\n@@ -70,8 +69,6 @@\n \n public class BatchITCase extends AbstractITCase {\n \n-    private static final ObjectMapper MAPPER = new ObjectMapper();\n-\n     private static String requestBody(final String boundary) throws JsonProcessingException, JAXBException {\n         List<BatchRequestItem> reqItems = new ArrayList<>();\n "},{"sha":"e87806713c249cd76ac4f812d8efc50c3dd656b2","filename":"fit/core-reference/src/test/java/org/apache/syncope/fit/core/DynRealmITCase.java","status":"modified","additions":0,"deletions":3,"changes":3,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FDynRealmITCase.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FDynRealmITCase.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FDynRealmITCase.java?ref=cb560bf69bf951bdff34abf3ffcad8fff82c6a11","patch":"@@ -24,7 +24,6 @@\n import static org.junit.jupiter.api.Assertions.assertTrue;\n import static org.junit.jupiter.api.Assertions.fail;\n \n-import com.fasterxml.jackson.databind.ObjectMapper;\n import com.fasterxml.jackson.databind.node.ArrayNode;\n import javax.ws.rs.core.GenericType;\n import javax.ws.rs.core.MediaType;\n@@ -65,8 +64,6 @@\n \n public class DynRealmITCase extends AbstractITCase {\n \n-    private static final ObjectMapper MAPPER = new ObjectMapper();\n-\n     @Test\n     public void misc() {\n         DynRealmTO dynRealm = null;"},{"sha":"f02f5cdf55049dd95efa3cf4098aba52a8994011","filename":"fit/core-reference/src/test/java/org/apache/syncope/fit/core/LinkedAccountITCase.java","status":"modified","additions":232,"deletions":3,"changes":235,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FLinkedAccountITCase.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FLinkedAccountITCase.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FLinkedAccountITCase.java?ref=cb560bf69bf951bdff34abf3ffcad8fff82c6a11","patch":"@@ -18,42 +18,60 @@\n  */\n package org.apache.syncope.fit.core;\n \n-import static org.apache.syncope.fit.AbstractITCase.getObject;\n import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n import static org.junit.jupiter.api.Assertions.assertNotEquals;\n import static org.junit.jupiter.api.Assertions.assertNotNull;\n import static org.junit.jupiter.api.Assertions.assertNull;\n import static org.junit.jupiter.api.Assertions.assertTrue;\n \n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import java.util.List;\n import java.util.Optional;\n import java.util.UUID;\n import javax.naming.NamingException;\n import javax.naming.directory.Attributes;\n import javax.naming.ldap.LdapContext;\n+import javax.ws.rs.core.HttpHeaders;\n import javax.ws.rs.core.MediaType;\n import javax.ws.rs.core.Response;\n import org.apache.commons.lang3.RandomStringUtils;\n import org.apache.syncope.common.lib.request.LinkedAccountUR;\n import org.apache.syncope.common.lib.request.UserCR;\n import org.apache.syncope.common.lib.request.UserUR;\n+import org.apache.commons.lang3.StringUtils;\n import org.apache.cxf.jaxrs.client.WebClient;\n+import org.apache.syncope.common.lib.SyncopeClientException;\n import org.apache.syncope.common.lib.SyncopeConstants;\n+import org.apache.syncope.common.lib.policy.PullPolicyTO;\n+import org.apache.syncope.common.lib.to.ExecTO;\n+import org.apache.syncope.common.lib.to.ImplementationTO;\n import org.apache.syncope.common.lib.to.LinkedAccountTO;\n import org.apache.syncope.common.lib.to.PagedResult;\n import org.apache.syncope.common.lib.to.PropagationTaskTO;\n+import org.apache.syncope.common.lib.to.PullTaskTO;\n import org.apache.syncope.common.lib.to.PushTaskTO;\n+import org.apache.syncope.common.lib.to.ResourceTO;\n import org.apache.syncope.common.lib.to.TaskTO;\n import org.apache.syncope.common.lib.to.UserTO;\n import org.apache.syncope.common.lib.types.AnyTypeKind;\n import org.apache.syncope.common.lib.types.ExecStatus;\n+import org.apache.syncope.common.lib.types.IdMImplementationType;\n+import org.apache.syncope.common.lib.types.ImplementationEngine;\n import org.apache.syncope.common.lib.types.MatchingRule;\n import org.apache.syncope.common.lib.types.PatchOperation;\n+import org.apache.syncope.common.lib.types.PolicyType;\n+import org.apache.syncope.common.lib.types.PullMode;\n import org.apache.syncope.common.lib.types.ResourceOperation;\n import org.apache.syncope.common.lib.types.TaskType;\n import org.apache.syncope.common.lib.types.UnmatchingRule;\n+import org.apache.syncope.common.rest.api.RESTHeaders;\n import org.apache.syncope.common.rest.api.beans.TaskQuery;\n import org.apache.syncope.common.rest.api.service.TaskService;\n+import org.apache.syncope.core.provisioning.api.serialization.POJOHelper;\n import org.apache.syncope.fit.AbstractITCase;\n+import org.apache.syncope.fit.core.reference.LinkedAccountSamplePullCorrelationRule;\n+import org.apache.syncope.fit.core.reference.LinkedAccountSamplePullCorrelationRuleConf;\n import org.junit.jupiter.api.Test;\n \n public class LinkedAccountITCase extends AbstractITCase {\n@@ -198,17 +216,18 @@ public void push() {\n         // 0b. set AES password cipher algorithm\n         confParamOps.set(SyncopeConstants.MASTER_DOMAIN, \"password.cipher.algorithm\", \"AES\");\n \n+        String userKey = null;\n+        String connObjectKeyValue = UUID.randomUUID().toString();\n         try {\n             // 1. create user with linked account\n             UserCR userCR = UserITCase.getSample(\n                     \"linkedAccount\" + RandomStringUtils.randomNumeric(5) + \"@syncope.apache.org\");\n-            String connObjectKeyValue = UUID.randomUUID().toString();\n \n             LinkedAccountTO account = new LinkedAccountTO.Builder(RESOURCE_NAME_REST, connObjectKeyValue).build();\n             userCR.getLinkedAccounts().add(account);\n \n             UserTO user = createUser(userCR).getEntity();\n-            String userKey = user.getKey();\n+            userKey = user.getKey();\n             assertNotNull(userKey);\n             assertNotEquals(userKey, connObjectKeyValue);\n \n@@ -271,6 +290,216 @@ public void push() {\n         } finally {\n             // restore initial cipher algorithm\n             confParamOps.set(SyncopeConstants.MASTER_DOMAIN, \"password.cipher.algorithm\", origpwdCipherAlgo);\n+\n+            // delete user and accounts\n+            if (userKey != null) {\n+                WebClient.create(BUILD_TOOLS_ADDRESS + \"/rest/users/\" + connObjectKeyValue).delete();\n+                WebClient.create(BUILD_TOOLS_ADDRESS + \"/rest/users/\" + userKey).delete();\n+\n+                userService.delete(userKey);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void pull() {\n+        // -----------------------------\n+        // Add a custom policy with correlation rule\n+        // -----------------------------\n+        ResourceTO restResource = resourceService.read(RESOURCE_NAME_REST);\n+        if (restResource.getPullPolicy() == null) {\n+            ImplementationTO rule = null;\n+            try {\n+                rule = implementationService.read(\n+                        IdMImplementationType.PULL_CORRELATION_RULE, \"LinkedAccountSamplePullCorrelationRule\");\n+            } catch (SyncopeClientException e) {\n+                if (e.getType().getResponseStatus() == Response.Status.NOT_FOUND) {\n+                    rule = new ImplementationTO();\n+                    rule.setKey(\"LinkedAccountSamplePullCorrelationRule\");\n+                    rule.setEngine(ImplementationEngine.JAVA);\n+                    rule.setType(IdMImplementationType.PULL_CORRELATION_RULE);\n+                    rule.setBody(POJOHelper.serialize(new LinkedAccountSamplePullCorrelationRuleConf()));\n+                    Response response = implementationService.create(rule);\n+                    rule = implementationService.read(\n+                            rule.getType(), response.getHeaderString(RESTHeaders.RESOURCE_KEY));\n+                    assertNotNull(rule.getKey());\n+                }\n+            }\n+            assertNotNull(rule);\n+\n+            PullPolicyTO policy = new PullPolicyTO();\n+            policy.setDescription(\"Linked Account sample Pull policy\");\n+            policy.getCorrelationRules().put(AnyTypeKind.USER.name(), rule.getKey());\n+            Response response = policyService.create(PolicyType.PULL, policy);\n+            policy = policyService.read(PolicyType.PULL, response.getHeaderString(RESTHeaders.RESOURCE_KEY));\n+            assertNotNull(policy.getKey());\n+\n+            restResource.setPullPolicy(policy.getKey());\n+            resourceService.update(restResource);\n+        }\n+\n+        // -----------------------------\n+        // -----------------------------\n+        // Add a pull task\n+        // -----------------------------\n+        String pullTaskKey;\n+\n+        PagedResult<PullTaskTO> tasks = taskService.search(\n+                new TaskQuery.Builder(TaskType.PULL).resource(RESOURCE_NAME_REST).build());\n+        if (tasks.getTotalCount() > 0) {\n+            pullTaskKey = tasks.getResult().get(0).getKey();\n+        } else {\n+            PullTaskTO task = new PullTaskTO();\n+            task.setDestinationRealm(SyncopeConstants.ROOT_REALM);\n+            task.setName(\"Linked Account Pull Task\");\n+            task.setActive(true);\n+            task.setResource(RESOURCE_NAME_REST);\n+            task.setPullMode(PullMode.INCREMENTAL);\n+            task.setPerformCreate(true);\n+            task.setPerformUpdate(true);\n+            task.setPerformDelete(true);\n+            task.setSyncStatus(true);\n+\n+            Response response = taskService.create(TaskType.PULL, task);\n+            task = taskService.read(TaskType.PULL, response.getHeaderString(RESTHeaders.RESOURCE_KEY), false);\n+            assertNotNull(task.getKey());\n+            pullTaskKey = task.getKey();\n+        }\n+        assertNotNull(pullTaskKey);\n+        // -----------------------------\n+\n+        // 1. create REST users\n+        WebClient webClient = WebClient.create(BUILD_TOOLS_ADDRESS + \"/rest/users\").\n+                accept(MediaType.APPLICATION_JSON_TYPE).type(MediaType.APPLICATION_JSON_TYPE);\n+\n+        ObjectNode user = MAPPER.createObjectNode();\n+        user.put(\"username\", \"linkedaccount1\");\n+        user.put(\"password\", \"Password123\");\n+        user.put(\"firstName\", \"Pasquale\");\n+        user.put(\"surname\", \"Vivaldi\");\n+        user.put(\"email\", \"vivaldi@syncope.org\");\n+\n+        Response response = webClient.post(user.toString());\n+        assertEquals(Response.Status.CREATED.getStatusCode(), response.getStatus());\n+        String user1Key = StringUtils.substringAfterLast(response.getHeaderString(HttpHeaders.LOCATION), \"/\");\n+        assertNotNull(user1Key);\n+\n+        user = MAPPER.createObjectNode();\n+        user.put(\"username\", \"vivaldi\");\n+        user.put(\"password\", \"Password123\");\n+        user.put(\"firstName\", \"Giovannino\");\n+        user.put(\"surname\", \"Vivaldi\");\n+        user.put(\"email\", \"vivaldi@syncope.org\");\n+\n+        response = webClient.post(user.toString());\n+        assertEquals(Response.Status.CREATED.getStatusCode(), response.getStatus());\n+        String user2Key = StringUtils.substringAfterLast(response.getHeaderString(HttpHeaders.LOCATION), \"/\");\n+        assertNotNull(user2Key);\n+\n+        user = MAPPER.createObjectNode();\n+        user.put(\"username\", \"not.vivaldi\");\n+        user.put(\"password\", \"Password123\");\n+        user.put(\"email\", \"not.vivaldi@syncope.org\");\n+\n+        response = webClient.post(user.toString());\n+        assertEquals(Response.Status.CREATED.getStatusCode(), response.getStatus());\n+        String user3Key = StringUtils.substringAfterLast(response.getHeaderString(HttpHeaders.LOCATION), \"/\");\n+        assertNotNull(user3Key);\n+\n+        // 2. execute pull task and verify linked accounts were pulled\n+        try {\n+            List<LinkedAccountTO> accounts = userService.read(\"vivaldi\").getLinkedAccounts();\n+            assertTrue(accounts.isEmpty());\n+\n+            ExecTO exec = AbstractTaskITCase.execProvisioningTask(taskService, TaskType.PULL, pullTaskKey, 50, false);\n+            assertEquals(ExecStatus.SUCCESS, ExecStatus.valueOf(exec.getStatus()));\n+\n+            accounts = userService.read(\"vivaldi\").getLinkedAccounts();\n+            assertEquals(3, accounts.size());\n+\n+            Optional<LinkedAccountTO> firstAccount = accounts.stream().\n+                    filter(account -> user1Key.equals(account.getConnObjectKeyValue())).\n+                    findFirst();\n+            assertTrue(firstAccount.isPresent());\n+            assertFalse(firstAccount.get().isSuspended());\n+            assertEquals(RESOURCE_NAME_REST, firstAccount.get().getResource());\n+            assertEquals(\"linkedaccount1\", firstAccount.get().getUsername());\n+            assertEquals(\"Pasquale\", firstAccount.get().getPlainAttr(\"firstname\").get().getValues().get(0));\n+\n+            Optional<LinkedAccountTO> secondAccount = accounts.stream().\n+                    filter(account -> user2Key.equals(account.getConnObjectKeyValue())).\n+                    findFirst();\n+            assertTrue(secondAccount.isPresent());\n+            assertFalse(secondAccount.get().isSuspended());\n+            assertEquals(RESOURCE_NAME_REST, secondAccount.get().getResource());\n+            assertNull(secondAccount.get().getUsername());\n+            assertEquals(\"Giovannino\", secondAccount.get().getPlainAttr(\"firstname\").get().getValues().get(0));\n+\n+            Optional<LinkedAccountTO> thirdAccount = accounts.stream().\n+                    filter(account -> user3Key.equals(account.getConnObjectKeyValue())).\n+                    filter(account -> \"not.vivaldi\".equals(account.getUsername())).\n+                    findFirst();\n+            assertTrue(thirdAccount.isPresent());\n+            assertFalse(thirdAccount.get().isSuspended());\n+            assertEquals(RESOURCE_NAME_REST, thirdAccount.get().getResource());\n+            assertEquals(\"not.vivaldi\", thirdAccount.get().getUsername());\n+\n+            // 3. update / remove REST users\n+            response = webClient.path(user1Key).delete();\n+            assertEquals(Response.Status.NO_CONTENT.getStatusCode(), response.getStatus());\n+\n+            user = MAPPER.createObjectNode();\n+            user.put(\"username\", \"linkedaccount2\");\n+            response = webClient.replacePath(user2Key).put(user.toString());\n+            assertEquals(Response.Status.NO_CONTENT.getStatusCode(), response.getStatus());\n+\n+            user = MAPPER.createObjectNode();\n+            user.put(\"status\", \"INACTIVE\");\n+            response = webClient.replacePath(user3Key).put(user.toString());\n+            assertEquals(Response.Status.NO_CONTENT.getStatusCode(), response.getStatus());\n+\n+            // 4. execute pull task again and verify linked accounts were pulled\n+            exec = AbstractTaskITCase.execProvisioningTask(taskService, TaskType.PULL, pullTaskKey, 50, false);\n+            assertEquals(ExecStatus.SUCCESS, ExecStatus.valueOf(exec.getStatus()));\n+\n+            accounts = userService.read(\"vivaldi\").getLinkedAccounts();\n+            assertEquals(2, accounts.size());\n+\n+            firstAccount = accounts.stream().\n+                    filter(account -> user1Key.equals(account.getConnObjectKeyValue())).\n+                    findFirst();\n+            assertFalse(firstAccount.isPresent());\n+\n+            secondAccount = accounts.stream().\n+                    filter(account -> user2Key.equals(account.getConnObjectKeyValue())).\n+                    findFirst();\n+            assertTrue(secondAccount.isPresent());\n+            assertFalse(secondAccount.get().isSuspended());\n+            assertEquals(user2Key, secondAccount.get().getConnObjectKeyValue());\n+            assertEquals(\"linkedaccount2\", secondAccount.get().getUsername());\n+\n+            thirdAccount = accounts.stream().\n+                    filter(account -> \"not.vivaldi\".equals(account.getUsername())).\n+                    findFirst();\n+            assertTrue(thirdAccount.isPresent());\n+            assertTrue(thirdAccount.get().isSuspended());\n+            assertEquals(user3Key, thirdAccount.get().getConnObjectKeyValue());\n+        } finally {\n+            // clean up\n+            UserUR patch = new UserUR();\n+            patch.setKey(LinkedAccountSamplePullCorrelationRule.VIVALDI_KEY);\n+            patch.getLinkedAccounts().add(new LinkedAccountUR.Builder().\n+                    operation(PatchOperation.DELETE).\n+                    linkedAccountTO(new LinkedAccountTO.Builder(RESOURCE_NAME_REST, user2Key).build()).\n+                    build());\n+            patch.getLinkedAccounts().add(new LinkedAccountUR.Builder().\n+                    operation(PatchOperation.DELETE).\n+                    linkedAccountTO(new LinkedAccountTO.Builder(RESOURCE_NAME_REST, user3Key).build()).\n+                    build());\n+            userService.update(patch);\n+\n+            webClient.replacePath(user2Key).delete();\n+            webClient.replacePath(user3Key).delete();\n         }\n     }\n }"},{"sha":"dcb7264106d24f9578054b7539ad25148b59e291","filename":"fit/core-reference/src/test/java/org/apache/syncope/fit/core/OpenAPIITCase.java","status":"modified","additions":1,"deletions":2,"changes":3,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FOpenAPIITCase.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FOpenAPIITCase.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FOpenAPIITCase.java?ref=cb560bf69bf951bdff34abf3ffcad8fff82c6a11","patch":"@@ -23,7 +23,6 @@\n import static org.junit.jupiter.api.Assertions.assertTrue;\n \n import com.fasterxml.jackson.databind.JsonNode;\n-import com.fasterxml.jackson.databind.ObjectMapper;\n import java.io.IOException;\n import java.io.InputStream;\n import javax.ws.rs.core.MediaType;\n@@ -40,7 +39,7 @@ public void openapi() throws IOException {\n         Response response = webClient.get();\n         assertEquals(200, response.getStatus());\n \n-        JsonNode tree = new ObjectMapper().readTree((InputStream) response.getEntity());\n+        JsonNode tree = MAPPER.readTree((InputStream) response.getEntity());\n         assertNotNull(tree);\n \n         JsonNode info = tree.get(\"info\");"},{"sha":"85bd8f339dc1eea7486758ef1ef1e95746c71dc7","filename":"fit/core-reference/src/test/java/org/apache/syncope/fit/core/PullTaskITCase.java","status":"modified","additions":22,"deletions":15,"changes":37,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FPullTaskITCase.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FPullTaskITCase.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FPullTaskITCase.java?ref=cb560bf69bf951bdff34abf3ffcad8fff82c6a11","patch":"@@ -482,26 +482,33 @@ public void reconcileFromScriptedSQL() throws IOException {\n         ProvisionTO provision = resource.getProvision(\"PRINTER\").get();\n         assertNotNull(provision);\n \n+        ImplementationTO transformer = null;\n+        try {\n+            transformer = implementationService.read(\n+                    IdMImplementationType.ITEM_TRANSFORMER, \"PrefixItemTransformer\");\n+        } catch (SyncopeClientException e) {\n+            if (e.getType().getResponseStatus() == Response.Status.NOT_FOUND) {\n+                transformer = new ImplementationTO();\n+                transformer.setKey(\"PrefixItemTransformer\");\n+                transformer.setEngine(ImplementationEngine.GROOVY);\n+                transformer.setType(IdMImplementationType.ITEM_TRANSFORMER);\n+                transformer.setBody(IOUtils.toString(\n+                        getClass().getResourceAsStream(\"/PrefixItemTransformer.groovy\"), StandardCharsets.UTF_8));\n+                Response response = implementationService.create(transformer);\n+                transformer = implementationService.read(\n+                        transformer.getType(), response.getHeaderString(RESTHeaders.RESOURCE_KEY));\n+                assertNotNull(transformer.getKey());\n+            }\n+        }\n+        assertNotNull(transformer);\n+\n         ItemTO mappingItem = provision.getMapping().getItems().stream().\n                 filter(object -> \"location\".equals(object.getIntAttrName())).findFirst().get();\n         assertNotNull(mappingItem);\n-\n-        final String prefix = \"PREFIX_\";\n-\n-        ImplementationTO transformer = new ImplementationTO();\n-        transformer.setKey(\"PrefixItemTransformer\");\n-        transformer.setEngine(ImplementationEngine.GROOVY);\n-        transformer.setType(IdMImplementationType.ITEM_TRANSFORMER);\n-        transformer.setBody(IOUtils.toString(\n-                getClass().getResourceAsStream(\"/PrefixItemTransformer.groovy\"), StandardCharsets.UTF_8));\n-        Response response = implementationService.create(transformer);\n-        transformer = implementationService.read(\n-                transformer.getType(), response.getHeaderString(RESTHeaders.RESOURCE_KEY));\n-        assertNotNull(transformer);\n-\n         mappingItem.getTransformers().clear();\n         mappingItem.getTransformers().add(transformer.getKey());\n \n+        final String prefix = \"PREFIX_\";\n         try {\n             resourceService.update(resource);\n             resourceService.removeSyncToken(resource.getKey(), provision.getAnyType());\n@@ -960,7 +967,7 @@ public void issueSYNCOPE258() throws IOException {\n \n         // asser for just one match\n         assertTrue(executed.getExecutions().get(0).getMessage().contains(\"[updated/failures]: 1/0\"),\n-            () -> executed.getExecutions().get(0).getMessage().substring(0, 55) + \"...\");\n+                () -> executed.getExecutions().get(0).getMessage().substring(0, 55) + \"...\");\n     }\n \n     @Test"},{"sha":"6d194086b1a7c1521822e9d424aded0fdb32d4ec","filename":"fit/core-reference/src/test/resources/DoubleValueLogicActions.groovy","status":"modified","additions":35,"deletions":26,"changes":61,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/fit%2Fcore-reference%2Fsrc%2Ftest%2Fresources%2FDoubleValueLogicActions.groovy","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/fit%2Fcore-reference%2Fsrc%2Ftest%2Fresources%2FDoubleValueLogicActions.groovy","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/fit%2Fcore-reference%2Fsrc%2Ftest%2Fresources%2FDoubleValueLogicActions.groovy?ref=cb560bf69bf951bdff34abf3ffcad8fff82c6a11","patch":"@@ -22,6 +22,7 @@ import org.apache.syncope.common.lib.Attr\n import org.apache.syncope.common.lib.request.AnyCR\n import org.apache.syncope.common.lib.request.AnyUR\n import org.apache.syncope.common.lib.request.AttrPatch\n+import java.util.function.Function\n import org.apache.syncope.core.provisioning.api.LogicActions\n \n /**\n@@ -33,42 +34,50 @@ class DoubleValueLogicActions implements LogicActions {\n   private static final String NAME = \"makeItDouble\";\n \n   @Override\n-  <C extends AnyCR> C beforeCreate(final C input) {\n-    for (Attr attr : input.getPlainAttrs()) {\n-      if (NAME.equals(attr.getSchema())) {\n-        List<String> values = new ArrayList<String>(attr.getValues().size());\n-        for (String value : attr.getValues()) {\n-          try {\n-            values.add(String.valueOf(2 * Long.parseLong(value)));\n-          } catch (NumberFormatException e) {\n-            // ignore\n+  <C extends AnyCR> Function<C, C> beforeCreate() {\n+    Function function = { \n+      C input ->\n+      for (Attr attr : input.getPlainAttrs()) {\n+        if (NAME.equals(attr.getSchema())) {\n+          List<String> values = new ArrayList<String>(attr.getValues().size());\n+          for (String value : attr.getValues()) {\n+            try {\n+              values.add(String.valueOf(2 * Long.parseLong(value)));\n+            } catch (NumberFormatException e) {\n+              // ignore\n+            }\n           }\n+          attr.getValues().clear();\n+          attr.getValues().addAll(values);\n         }\n-        attr.getValues().clear();\n-        attr.getValues().addAll(values);\n       }\n-    }\n \n-    return input;\n+      return input;        \n+    }\n+    return function;\n   }\n \n   @Override\n-  <R extends AnyUR> R beforeUpdate(final R input) {\n-    for (AttrPatch patch : input.getPlainAttrs()) {\n-      if (NAME.equals(patch.getAttr().getSchema())) {\n-        List<String> values = new ArrayList<String>(patch.getAttr().getValues().size());\n-        for (String value : patch.getAttr().getValues()) {\n-          try {\n-            values.add(String.valueOf(2 * Long.parseLong(value)));\n-          } catch (NumberFormatException e) {\n-            // ignore\n+  <R extends AnyUR> Function<R, R> beforeUpdate() {\n+    Function function = { \n+      R input ->\n+      for (AttrPatch patch : input.getPlainAttrs()) {\n+        if (NAME.equals(patch.getAttr().getSchema())) {\n+          List<String> values = new ArrayList<String>(patch.getAttr().getValues().size());\n+          for (String value : patch.getAttr().getValues()) {\n+            try {\n+              values.add(String.valueOf(2 * Long.parseLong(value)));\n+            } catch (NumberFormatException e) {\n+              // ignore\n+            }\n           }\n+          patch.getAttr().getValues().clear();\n+          patch.getAttr().getValues().addAll(values);\n         }\n-        patch.getAttr().getValues().clear();\n-        patch.getAttr().getValues().addAll(values);\n       }\n-    }\n \n-    return input;\n+      return input;\n+    }\n+    return function;\n   }\n }"},{"sha":"063165488b32e3c24dbab0837ee5e65cba2f245a","filename":"fit/core-reference/src/test/resources/rest/SearchScript.groovy","status":"modified","additions":2,"deletions":3,"changes":5,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/fit%2Fcore-reference%2Fsrc%2Ftest%2Fresources%2Frest%2FSearchScript.groovy","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/fit%2Fcore-reference%2Fsrc%2Ftest%2Fresources%2Frest%2FSearchScript.groovy","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/fit%2Fcore-reference%2Fsrc%2Ftest%2Fresources%2Frest%2FSearchScript.groovy?ref=cb560bf69bf951bdff34abf3ffcad8fff82c6a11","patch":"@@ -54,11 +54,10 @@ def buildConnectorObject(node) {\n   return [\n     __UID__:node.get(\"key\").textValue(), \n     __NAME__:node.get(\"key\").textValue(),\n+    __ENABLE__:node.get(\"status\").textValue().equals(\"ACTIVE\"),\n+    __PASSWORD__:new GuardedString(node.get(\"password\").textValue().toCharArray()),\n     key:node.get(\"key\").textValue(),\n     username:node.get(\"username\").textValue(),\n-    password:node.has(\"password\") && node.get(\"password\").textValue() != null\n-    ? new GuardedString(node.get(\"password\").textValue().toCharArray()) \n-  : null,\n     firstName:node.get(\"firstName\").textValue(),\n     surname:node.get(\"surname\").textValue(),\n     email:node.get(\"email\").textValue()"},{"sha":"69116143cd03d5846c5fadc7eb51962020af0267","filename":"fit/core-reference/src/test/resources/rest/SyncScript.groovy","status":"modified","additions":32,"deletions":8,"changes":40,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/fit%2Fcore-reference%2Fsrc%2Ftest%2Fresources%2Frest%2FSyncScript.groovy","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/cb560bf69bf951bdff34abf3ffcad8fff82c6a11/fit%2Fcore-reference%2Fsrc%2Ftest%2Fresources%2Frest%2FSyncScript.groovy","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/fit%2Fcore-reference%2Fsrc%2Ftest%2Fresources%2Frest%2FSyncScript.groovy?ref=cb560bf69bf951bdff34abf3ffcad8fff82c6a11","patch":"@@ -54,9 +54,10 @@ def buildConnectorObject(node) {\n   return [\n     __UID__:node.get(\"key\").textValue(), \n     __NAME__:node.get(\"key\").textValue(),\n+    __ENABLE__:node.get(\"status\").textValue().equals(\"ACTIVE\"),\n+    __PASSWORD__:new GuardedString(node.get(\"password\").textValue().toCharArray()),\n     key:node.get(\"key\").textValue(),\n     username:node.get(\"username\").textValue(),\n-    password:new GuardedString(node.get(\"password\").textValue().toCharArray()),\n     firstName:node.get(\"firstName\").textValue(),\n     surname:node.get(\"surname\").textValue(),\n     email:node.get(\"email\").textValue()\n@@ -84,17 +85,40 @@ if (action.equalsIgnoreCase(\"GET_LATEST_SYNC_TOKEN\")) {\n \n   switch (objectClass) {\n   case \"__ACCOUNT__\":\n-    webClient.path(\"/users\");\n+    webClient.path(\"/users/changelog\");      \n+    if (token != null) {\n+      webClient.query(\"from\", token.toString());            \n+    }\n+\n+    log.ok(\"Sending GET to {0}\", webClient.getCurrentURI().toASCIIString());\n+\n     Response response = webClient.get();    \n+\n+    log.ok(\"CHANGELOG response: {0} {1}\", response.getStatus(), response.getHeaders());\n+\n+    if (response.getStatus() != 200) {\n+      throw new RuntimeException(\"Unexpected response from server: \" \n+        + response.getStatus() + \" \" + response.getHeaders());\n+    }\n+    \n     ArrayNode node = mapper.readTree(response.getEntity());\n     \n     for (i = 0; i < node.size(); i++) {\n-      result.add([\n-          operation:\"CREATE_OR_UPDATE\",\n-          uid:node.get(i).get(\"key\").textValue(),\n-          token:new Date().getTime(),\n-          attributes:buildConnectorObject(node.get(i))\n-        ]);\n+      if (node.get(i).get(\"deleted\").booleanValue()) {\n+        result.add([\n+            operation:\"DELETE\",\n+            uid:node.get(i).get(\"user\").get(\"key\").textValue(),\n+            token:node.get(i).get(\"lastChangeDate\").longValue(),\n+            attributes:[]\n+          ]);        \n+      } else {\n+        result.add([\n+            operation:\"CREATE_OR_UPDATE\",\n+            uid:node.get(i).get(\"user\").get(\"key\").textValue(),\n+            token:node.get(i).get(\"lastChangeDate\").longValue(),\n+            attributes:buildConnectorObject(node.get(i).get(\"user\"))\n+          ]);\n+      }\n     }\n     break;\n   }"}]}