{"sha":"fca4bdbd08746b926bdb1d78f653a476ca1d9dbb","node_id":"MDY6Q29tbWl0NjM2ODc5MDYyOmZjYTRiZGJkMDg3NDZiOTI2YmRiMWQ3OGY2NTNhNDc2Y2ExZDlkYmI=","commit":{"author":{"name":"Fabio Martelli","email":"fabio.martelli@gmail.com","date":"2021-01-12T08:03:45Z"},"committer":{"name":"Francesco Chicchiricc√≤","email":"ilgrosso@apache.org","date":"2021-01-12T08:33:25Z"},"message":"[SYNCOPE-1609] Changes jsonb queries in order to improve performances (#233)","tree":{"sha":"f9e60c9c5d0434c92abb7bf2651d30c27af25c5e","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/git/trees/f9e60c9c5d0434c92abb7bf2651d30c27af25c5e"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/git/commits/fca4bdbd08746b926bdb1d78f653a476ca1d9dbb","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/fca4bdbd08746b926bdb1d78f653a476ca1d9dbb","html_url":"https://github.com/EnricoDAlessandro97UNI/syncope/commit/fca4bdbd08746b926bdb1d78f653a476ca1d9dbb","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/fca4bdbd08746b926bdb1d78f653a476ca1d9dbb/comments","author":{"login":"fmartelli","id":1791932,"node_id":"MDQ6VXNlcjE3OTE5MzI=","avatar_url":"https://avatars.githubusercontent.com/u/1791932?v=4","gravatar_id":"","url":"https://api.github.com/users/fmartelli","html_url":"https://github.com/fmartelli","followers_url":"https://api.github.com/users/fmartelli/followers","following_url":"https://api.github.com/users/fmartelli/following{/other_user}","gists_url":"https://api.github.com/users/fmartelli/gists{/gist_id}","starred_url":"https://api.github.com/users/fmartelli/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fmartelli/subscriptions","organizations_url":"https://api.github.com/users/fmartelli/orgs","repos_url":"https://api.github.com/users/fmartelli/repos","events_url":"https://api.github.com/users/fmartelli/events{/privacy}","received_events_url":"https://api.github.com/users/fmartelli/received_events","type":"User","site_admin":false},"committer":{"login":"ilgrosso","id":1064664,"node_id":"MDQ6VXNlcjEwNjQ2NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/1064664?v=4","gravatar_id":"","url":"https://api.github.com/users/ilgrosso","html_url":"https://github.com/ilgrosso","followers_url":"https://api.github.com/users/ilgrosso/followers","following_url":"https://api.github.com/users/ilgrosso/following{/other_user}","gists_url":"https://api.github.com/users/ilgrosso/gists{/gist_id}","starred_url":"https://api.github.com/users/ilgrosso/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ilgrosso/subscriptions","organizations_url":"https://api.github.com/users/ilgrosso/orgs","repos_url":"https://api.github.com/users/ilgrosso/repos","events_url":"https://api.github.com/users/ilgrosso/events{/privacy}","received_events_url":"https://api.github.com/users/ilgrosso/received_events","type":"User","site_admin":false},"parents":[{"sha":"9609ab7a22a9c9a2842233c1104eeacb35d31ffd","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/9609ab7a22a9c9a2842233c1104eeacb35d31ffd","html_url":"https://github.com/EnricoDAlessandro97UNI/syncope/commit/9609ab7a22a9c9a2842233c1104eeacb35d31ffd"}],"stats":{"total":1135,"additions":1003,"deletions":132},"files":[{"sha":"68da8bcb0f1199c62c7a16ce24d566c0b36cdf57","filename":"core/persistence-jpa-json/src/main/java/org/apache/syncope/core/persistence/jpa/dao/MyJPAJSONAnySearchDAO.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fca4bdbd08746b926bdb1d78f653a476ca1d9dbb/core%2Fpersistence-jpa-json%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fjpa%2Fdao%2FMyJPAJSONAnySearchDAO.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fca4bdbd08746b926bdb1d78f653a476ca1d9dbb/core%2Fpersistence-jpa-json%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fjpa%2Fdao%2FMyJPAJSONAnySearchDAO.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fpersistence-jpa-json%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fjpa%2Fdao%2FMyJPAJSONAnySearchDAO.java?ref=fca4bdbd08746b926bdb1d78f653a476ca1d9dbb","patch":"@@ -137,7 +137,7 @@ protected void parseOrderByForPlainSchema(\n         item.orderBy = fieldName + ' ' + clause.getDirection().name();\n     }\n \n-    private void fillAttrQuery(\n+    protected void fillAttrQuery(\n             final AnyUtils anyUtils,\n             final StringBuilder query,\n             final PlainAttrValue attrValue,"},{"sha":"f856493d6fa0959c7b11e24c6312c352dc06736f","filename":"core/persistence-jpa-json/src/main/java/org/apache/syncope/core/persistence/jpa/dao/PGJPAJSONAnySearchDAO.java","status":"modified","additions":990,"deletions":112,"changes":1102,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fca4bdbd08746b926bdb1d78f653a476ca1d9dbb/core%2Fpersistence-jpa-json%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fjpa%2Fdao%2FPGJPAJSONAnySearchDAO.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fca4bdbd08746b926bdb1d78f653a476ca1d9dbb/core%2Fpersistence-jpa-json%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fjpa%2Fdao%2FPGJPAJSONAnySearchDAO.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fpersistence-jpa-json%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fjpa%2Fdao%2FPGJPAJSONAnySearchDAO.java?ref=fca4bdbd08746b926bdb1d78f653a476ca1d9dbb","patch":"@@ -19,73 +19,52 @@\n package org.apache.syncope.core.persistence.jpa.dao;\n \n import java.text.ParseException;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.HashSet;\n import java.util.List;\n+import java.util.Optional;\n import java.util.Set;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n import java.util.stream.Collectors;\n+import javax.persistence.Query;\n+import javax.persistence.TemporalType;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.commons.lang3.StringUtils;\n import org.apache.commons.lang3.tuple.Pair;\n+import org.apache.commons.lang3.tuple.Triple;\n+import org.apache.syncope.common.lib.SyncopeClientException;\n+import org.apache.syncope.common.lib.types.AnyTypeKind;\n import org.apache.syncope.common.lib.types.AttrSchemaType;\n+import org.apache.syncope.common.lib.types.ClientExceptionType;\n import org.apache.syncope.core.persistence.api.dao.search.AnyCond;\n+import org.apache.syncope.core.persistence.api.dao.search.AnyTypeCond;\n+import org.apache.syncope.core.persistence.api.dao.search.AssignableCond;\n import org.apache.syncope.core.persistence.api.dao.search.AttrCond;\n+import org.apache.syncope.core.persistence.api.dao.search.DynRealmCond;\n+import org.apache.syncope.core.persistence.api.dao.search.MemberCond;\n+import org.apache.syncope.core.persistence.api.dao.search.MembershipCond;\n import org.apache.syncope.core.persistence.api.dao.search.OrderByClause;\n+import org.apache.syncope.core.persistence.api.dao.search.PrivilegeCond;\n+import org.apache.syncope.core.persistence.api.dao.search.RelationshipCond;\n+import org.apache.syncope.core.persistence.api.dao.search.RelationshipTypeCond;\n+import org.apache.syncope.core.persistence.api.dao.search.ResourceCond;\n+import org.apache.syncope.core.persistence.api.dao.search.RoleCond;\n+import org.apache.syncope.core.persistence.api.dao.search.SearchCond;\n+import org.apache.syncope.core.persistence.api.entity.Any;\n import org.apache.syncope.core.persistence.api.entity.AnyUtils;\n-import org.apache.syncope.core.persistence.api.entity.PlainAttr;\n-import org.apache.syncope.core.persistence.api.entity.PlainAttrUniqueValue;\n+import org.apache.syncope.core.persistence.api.entity.DynRealm;\n+import org.apache.syncope.core.persistence.api.entity.Entity;\n import org.apache.syncope.core.persistence.api.entity.PlainAttrValue;\n import org.apache.syncope.core.persistence.api.entity.PlainSchema;\n-import org.apache.syncope.core.provisioning.api.serialization.POJOHelper;\n-import org.apache.syncope.core.persistence.api.entity.JSONPlainAttr;\n+import org.apache.syncope.core.persistence.api.entity.Realm;\n import org.apache.syncope.core.provisioning.api.utils.FormatUtils;\n+import org.apache.syncope.core.provisioning.api.utils.RealmUtils;\n \n public class PGJPAJSONAnySearchDAO extends AbstractJPAJSONAnySearchDAO {\n \n-    @Override\n-    protected void processOBS(\n-            final SearchSupport svs,\n-            final OrderBySupport obs,\n-            final StringBuilder where) {\n-\n-        Set<String> attrs = obs.items.stream().\n-                map(item -> item.orderBy.substring(0, item.orderBy.indexOf(\" \"))).collect(Collectors.toSet());\n-\n-        obs.views.forEach(searchView -> {\n-            if (searchView.name.equals(svs.field().name)) {\n-                StringBuilder attrWhere = new StringBuilder();\n-                StringBuilder nullAttrWhere = new StringBuilder();\n-\n-                where.append(\", (SELECT * FROM \").append(searchView.name);\n-\n-                if (svs.nonMandatorySchemas || obs.nonMandatorySchemas) {\n-                    attrs.forEach(field -> {\n-                        if (attrWhere.length() == 0) {\n-                            attrWhere.append(\" WHERE \");\n-                        } else {\n-                            attrWhere.append(\" OR \");\n-                        }\n-                        attrWhere.append(\"plainAttrs @> '[{\\\"schema\\\":\\\"\").append(field).append(\"\\\"}]'::jsonb\");\n-\n-                        nullAttrWhere.append(\" UNION SELECT DISTINCT any_id,\").append(svs.table().alias).append(\".*, \").\n-                                append(\"'{\\\"schema\\\": \\\"\").\n-                                append(field).\n-                                append(\"\\\"}'::jsonb as attrs, '{}'::jsonb as attrValues\").\n-                                append(\" FROM \").append(svs.table().name).append(' ').append(svs.table().alias).\n-                                append(\", \").append(svs.field().name).\n-                                append(\" WHERE \").\n-                                append(\"any_id NOT IN \").\n-                                append(\"(SELECT distinct any_id FROM \").\n-                                append(svs.field().name).\n-                                append(\" WHERE \").append(svs.table().alias).append(\".id=any_id AND \").\n-                                append(\"plainAttrs @> '[{\\\"schema\\\":\\\"\").append(field).append(\"\\\"}]'::jsonb)\");\n-                    });\n-                    where.append(attrWhere).append(nullAttrWhere);\n-                }\n-\n-                where.append(')');\n-            } else {\n-                where.append(',').append(searchView.name);\n-            }\n-            where.append(' ').append(searchView.alias);\n-        });\n-    }\n+    protected static final String ALWAYS_FALSE_ASSERTION = \"1=2\";\n \n     @Override\n     protected void parseOrderByForPlainSchema(\n@@ -99,14 +78,14 @@ protected void parseOrderByForPlainSchema(\n         // keep track of involvement of non-mandatory schemas in the order by clauses\n         obs.nonMandatorySchemas = !\"true\".equals(schema.getMandatoryCondition());\n \n-        obs.views.add(svs.field());\n+        obs.views.add(svs.table());\n \n-        item.select = svs.field().alias + \".attrValues ->> '\" + key(schema.getType()) + \"' AS \" + fieldName;\n-        item.where = \"attrs ->> 'schema' = '\" + fieldName + '\\'';\n-        item.orderBy = fieldName + ' ' + clause.getDirection().name();\n+        item.select = fieldName + \" -> 0 AS \" + fieldName;\n+        item.where = StringUtils.EMPTY;\n+        item.orderBy = fieldName + \" \" + clause.getDirection().name();\n     }\n \n-    private void fillAttrQuery(\n+    protected void fillAttrQuery(\n             final AnyUtils anyUtils,\n             final StringBuilder query,\n             final PlainAttrValue attrValue,\n@@ -117,53 +96,117 @@ private void fillAttrQuery(\n             final SearchSupport svs) {\n \n         // This first branch is required for handling with not conditions given on multivalue fields (SYNCOPE-1419)\n-        if (not && schema.isMultivalue()\n-                && !(cond instanceof AnyCond)\n-                && cond.getType() != AttrCond.Type.ISNULL && cond.getType() != AttrCond.Type.ISNOTNULL) {\n-\n-            query.append(\"id NOT IN (SELECT DISTINCT any_id FROM \");\n-            query.append(svs.field().name).append(\" WHERE \");\n+        if (not && !(cond instanceof AnyCond)) {\n+            query.append(\"NOT (\");\n             fillAttrQuery(anyUtils, query, attrValue, schema, cond, false, parameters, svs);\n-            query.append(')');\n+            query.append(\")\");\n+        } else if (not && cond.getType() == AttrCond.Type.ISNULL) {\n+            cond.setType(AttrCond.Type.ISNOTNULL);\n+            fillAttrQuery(anyUtils, query, attrValue, schema, cond, true, parameters, svs);\n         } else {\n-            if (!not && cond.getType() == AttrCond.Type.EQ) {\n-                PlainAttr<?> container = anyUtils.newPlainAttr();\n-                container.setSchema(schema);\n-                if (attrValue instanceof PlainAttrUniqueValue) {\n-                    container.setUniqueValue((PlainAttrUniqueValue) attrValue);\n-                } else {\n-                    ((JSONPlainAttr) container).add(attrValue);\n+            String key = key(schema.getType());\n+\n+            String value = cond.getExpression();\n+            if (schema.getType() == AttrSchemaType.Date) {\n+                try {\n+                    value = String.valueOf(FormatUtils.parseDate(value).getTime());\n+                } catch (ParseException e) {\n+                    LOG.error(\"Could not parse {} as date\", value, e);\n                 }\n+            }\n \n-                query.append(\"plainAttrs @> '\").\n-                        append(POJOHelper.serialize(List.of(container)).replace(\"'\", \"''\")).\n-                        append(\"'::jsonb\");\n+            boolean isStr = true;\n+            boolean lower;\n+            if (schema.getType() == AttrSchemaType.String || schema.getType() == AttrSchemaType.Enum) {\n+                lower = (cond.getType() == AttrCond.Type.IEQ || cond.getType() == AttrCond.Type.ILIKE);\n             } else {\n-                String key = key(schema.getType());\n-                boolean lower = (schema.getType() == AttrSchemaType.String || schema.getType() == AttrSchemaType.Enum)\n-                        && (cond.getType() == AttrCond.Type.IEQ || cond.getType() == AttrCond.Type.ILIKE);\n-\n-                query.append(\"attrs ->> 'schema' = ?\").append(setParameter(parameters, cond.getSchema())).\n-                        append(\" AND \").\n-                        append(lower ? \"LOWER(\" : \"\").\n-                        append(schema.isUniqueConstraint()\n-                                ? \"attrs -> 'uniqueValue'\" : \"attrValues\").\n-                        append(\" ->> '\").append(key).append('\\'').\n-                        append(lower ? \")\" : \"\");\n-\n-                appendOp(query, cond.getType(), not);\n-\n-                String value = cond.getExpression();\n-                if (schema.getType() == AttrSchemaType.Date) {\n-                    try {\n-                        value = String.valueOf(FormatUtils.parseDate(value).getTime());\n-                    } catch (ParseException e) {\n-                        LOG.error(\"Could not parse {} as date\", value, e);\n+                lower = false;\n+                try {\n+                    switch (schema.getType()) {\n+                        case Date:\n+                        case Long:\n+                            Long.parseLong(value);\n+                            break;\n+                        case Double:\n+                            Double.parseDouble(value);\n+                            break;\n+                        case Boolean:\n+                            if (!(\"true\".equalsIgnoreCase(value) || \"false\".equalsIgnoreCase(value))) {\n+                                throw new IllegalArgumentException();\n+                            }\n+                            break;\n+                        default:\n                     }\n+\n+                    isStr = false;\n+                } catch (Exception nfe) {\n+                    // ignore}\n                 }\n-                query.append(lower ? \"LOWER(\" : \"\").\n-                        append('?').append(setParameter(parameters, value)).\n-                        append(lower ? \")\" : \"\");\n+            }\n+\n+            switch (cond.getType()) {\n+\n+                case ISNULL:\n+                    // shouldn't occour: processed before\n+                    break;\n+\n+                case ISNOTNULL:\n+                    query.append(\"jsonb_path_exists(\").append(schema.getKey()).append(\", '$[*]')\");\n+                    break;\n+\n+                case ILIKE:\n+                case LIKE:\n+                    // jsonb_path_exists(Nome, '$[*] ? (@.stringValue like_regex \"EL.*\" flag \"i\")')\n+                    if (schema.getType() == AttrSchemaType.String || schema.getType() == AttrSchemaType.Enum) {\n+                        query.append(\"jsonb_path_exists(\").append(schema.getKey()).append(\", '$[*] ? \").\n+                                append(\"(@.\").append(key).append(\" like_regex \\\"\").\n+                                append(value.replaceAll(\"%\", \".*\")).\n+                                append(\"\\\"\").\n+                                append(lower ? \" flag \\\"i\\\"\" : \"\").append(\")')\");\n+                    } else {\n+                        query.append(\" 1=2\");\n+                        LOG.error(\"LIKE is only compatible with string or enum schemas\");\n+                    }\n+                    break;\n+\n+                case IEQ:\n+                case EQ:\n+                    query.append(\"jsonb_path_exists(\").append(schema.getKey()).append(\", '$[*] ? \").\n+                            append(\"(@.\").append(key);\n+                    if (isStr) {\n+                        query.append(\" like_regex \\\"\").append(value.replace(\"'\", \"''\")).append(\"\\\"\");\n+                    } else {\n+                        query.append(\" == \").append(value);\n+                    }\n+\n+                    query.append(lower ? \" flag \\\"i\\\"\" : \"\").append(\")')\");\n+                    break;\n+\n+                case GE:\n+                    query.append(\"jsonb_path_exists(\").append(schema.getKey()).append(\", '$[*] ? \").\n+                            append(\"(@.\").append(key).append(\" >= \").\n+                            append(value).append(\")')\");\n+                    break;\n+\n+                case GT:\n+                    query.append(\"jsonb_path_exists(\").append(schema.getKey()).append(\", '$[*] ? \").\n+                            append(\"(@.\").append(key).append(\" > \").\n+                            append(value).append(\")')\");\n+                    break;\n+\n+                case LE:\n+                    query.append(\"jsonb_path_exists(\").append(schema.getKey()).append(\", '$[*] ? \").\n+                            append(\"(@.\").append(key).append(\" <= \").\n+                            append(value).append(\")')\");\n+                    break;\n+\n+                case LT:\n+                    query.append(\"jsonb_path_exists(\").append(schema.getKey()).append(\", '$[*] ? \").\n+                            append(\"(@.\").append(key).append(\" < \").\n+                            append(value).append(\")')\");\n+                    break;\n+\n+                default:\n             }\n         }\n     }\n@@ -179,7 +222,7 @@ protected String getQuery(\n         try {\n             checked = check(cond, svs.anyTypeKind);\n         } catch (IllegalArgumentException e) {\n-            return EMPTY_QUERY;\n+            return ALWAYS_FALSE_ASSERTION;\n         }\n \n         // normalize NULL / NOT NULL checks\n@@ -191,32 +234,867 @@ protected String getQuery(\n             }\n         }\n \n-        StringBuilder query =\n-                new StringBuilder(\"SELECT DISTINCT any_id FROM \").append(svs.field().name).append(\" WHERE \");\n+        StringBuilder query = new StringBuilder();\n+\n         switch (cond.getType()) {\n             case ISNOTNULL:\n-                query.append(\"plainAttrs @> '[{\\\"schema\\\":\\\"\").\n-                        append(checked.getLeft().getKey()).\n-                        append(\"\\\"}]'::jsonb\");\n+                query.append(not ? \" NOT \" : \" \").\n+                        append(\"jsonb_path_exists(\").append(checked.getLeft().getKey()).append(\",'$[*]')\");\n                 break;\n \n             case ISNULL:\n-                query.append(\"any_id NOT IN (\").\n-                        append(\"SELECT any_id FROM \").append(svs.field().name).\n-                        append(\" WHERE plainAttrs @> '[{\\\"schema\\\":\\\"\").\n-                        append(checked.getLeft().getKey()).\n-                        append(\"\\\"}]'::jsonb)\");\n+                query.append(not ? \" \" : \" NOT \").\n+                        append(\"jsonb_path_exists(\").append(checked.getLeft().getKey()).append(\",'$[*]')\");\n                 break;\n \n             default:\n-                if (not && !(cond instanceof AnyCond) && checked.getLeft().isMultivalue()) {\n-                    query = new StringBuilder(\"SELECT DISTINCT id AS any_id FROM \").append(svs.table().name).\n-                            append(\" WHERE \");\n-                }\n                 fillAttrQuery(anyUtilsFactory.getInstance(svs.anyTypeKind),\n                         query, checked.getRight(), checked.getLeft(), cond, not, parameters, svs);\n         }\n \n         return query.toString();\n     }\n+\n+    @Override\n+    protected String getQuery(\n+            final AnyTypeCond cond,\n+            final boolean not,\n+            final List<Object> parameters,\n+            final SearchSupport svs) {\n+\n+        StringBuilder query = new StringBuilder(\"type_id\");\n+\n+        if (not) {\n+            query.append(\"<>\");\n+        } else {\n+            query.append('=');\n+        }\n+\n+        query.append('?').append(setParameter(parameters, cond.getAnyTypeKey()));\n+\n+        return query.toString();\n+    }\n+\n+    @Override\n+    protected String getQuery(\n+            final RoleCond cond,\n+            final boolean not,\n+            final List<Object> parameters,\n+            final SearchSupport svs) {\n+\n+        StringBuilder query = new StringBuilder(\"(\");\n+\n+        if (not) {\n+            query.append(\"id NOT IN (\");\n+        } else {\n+            query.append(\"id IN (\");\n+        }\n+\n+        query.append(\"SELECT DISTINCT any_id FROM \").\n+                append(svs.role().name).append(\" WHERE \").\n+                append(\"role_id=?\").append(setParameter(parameters, cond.getRole())).\n+                append(\") \");\n+\n+        if (not) {\n+            query.append(\"AND id NOT IN (\");\n+        } else {\n+            query.append(\"OR id IN (\");\n+        }\n+\n+        query.append(\"SELECT DISTINCT any_id FROM \").\n+                append(svs.dynrolemembership().name).append(\" WHERE \").\n+                append(\"role_id=?\").append(setParameter(parameters, cond.getRole())).\n+                append(\")\");\n+\n+        query.append(\")\");\n+\n+        return query.toString();\n+    }\n+\n+    @Override\n+    protected String getQuery(\n+            final PrivilegeCond cond,\n+            final boolean not,\n+            final List<Object> parameters,\n+            final SearchSupport svs) {\n+\n+        StringBuilder query = new StringBuilder(\"(\");\n+\n+        if (not) {\n+            query.append(\"id NOT IN (\");\n+        } else {\n+            query.append(\"id IN (\");\n+        }\n+\n+        query.append(\"SELECT DISTINCT any_id FROM \").\n+                append(svs.priv().name).append(\" WHERE \").\n+                append(\"privilege_id=?\").append(setParameter(parameters, cond.getPrivilege())).\n+                append(\") \");\n+\n+        if (not) {\n+            query.append(\"AND id NOT IN (\");\n+        } else {\n+            query.append(\"OR id IN (\");\n+        }\n+\n+        query.append(\"SELECT DISTINCT any_id FROM \").\n+                append(svs.dynpriv().name).append(\" WHERE \").\n+                append(\"privilege_id=?\").append(setParameter(parameters, cond.getPrivilege())).\n+                append(\")\");\n+\n+        query.append(\")\");\n+\n+        return query.toString();\n+    }\n+\n+    @Override\n+    protected String getQuery(\n+            final DynRealmCond cond,\n+            final boolean not,\n+            final List<Object> parameters,\n+            final SearchSupport svs) {\n+\n+        StringBuilder query = new StringBuilder();\n+\n+        if (not) {\n+            query.append(\"id NOT IN (\");\n+        } else {\n+            query.append(\"id IN (\");\n+        }\n+\n+        query.append(\"SELECT DISTINCT any_id FROM \").\n+                append(svs.dynrealmmembership().name).append(\" WHERE \").\n+                append(\"dynRealm_id=?\").append(setParameter(parameters, cond.getDynRealm())).\n+                append(\")\");\n+\n+        return query.toString();\n+    }\n+\n+    @Override\n+    protected String getQuery(\n+            final ResourceCond cond,\n+            final boolean not,\n+            final List<Object> parameters,\n+            final SearchSupport svs) {\n+\n+        StringBuilder query = new StringBuilder();\n+\n+        if (not) {\n+            query.append(\"id NOT IN (\");\n+        } else {\n+            query.append(\"id IN (\");\n+        }\n+\n+        query.append(\"SELECT DISTINCT any_id FROM \").\n+                append(svs.resource().name).\n+                append(\" WHERE resource_id=?\").\n+                append(setParameter(parameters, cond.getResourceKey()));\n+\n+        if (svs.anyTypeKind == AnyTypeKind.USER || svs.anyTypeKind == AnyTypeKind.ANY_OBJECT) {\n+            query.append(\" UNION SELECT DISTINCT any_id FROM \").\n+                    append(svs.groupResource().name).\n+                    append(\" WHERE resource_id=?\").\n+                    append(setParameter(parameters, cond.getResourceKey()));\n+        }\n+\n+        query.append(')');\n+\n+        return query.toString();\n+    }\n+\n+    @Override\n+    protected String getQuery(\n+            final AssignableCond cond,\n+            final List<Object> parameters,\n+            final SearchSupport svs) {\n+\n+        Realm realm;\n+        try {\n+            realm = check(cond);\n+        } catch (IllegalArgumentException e) {\n+            return ALWAYS_FALSE_ASSERTION;\n+        }\n+\n+        StringBuilder query = new StringBuilder(\"(\");\n+        if (cond.isFromGroup()) {\n+            realmDAO.findDescendants(realm).forEach(current -> {\n+                query.append(\"realm_id=?\").append(setParameter(parameters, current.getKey())).append(\" OR \");\n+            });\n+            query.setLength(query.length() - 4);\n+        } else {\n+            for (Realm current = realm; current.getParent() != null; current = current.getParent()) {\n+                query.append(\"realm_id=?\").append(setParameter(parameters, current.getKey())).append(\" OR \");\n+            }\n+            query.append(\"realm_id=?\").append(setParameter(parameters, realmDAO.getRoot().getKey()));\n+        }\n+\n+        query.append(\")\");\n+\n+        return query.toString();\n+    }\n+\n+    @Override\n+    protected String getQuery(\n+            final MemberCond cond,\n+            final boolean not,\n+            final List<Object> parameters,\n+            final SearchSupport svs) {\n+\n+        String memberKey;\n+        try {\n+            memberKey = check(cond);\n+        } catch (IllegalArgumentException e) {\n+            return ALWAYS_FALSE_ASSERTION;\n+        }\n+\n+        StringBuilder query = new StringBuilder(\"(\");\n+\n+        if (not) {\n+            query.append(\"id NOT IN (\");\n+        } else {\n+            query.append(\"id IN (\");\n+        }\n+\n+        query.append(\"SELECT DISTINCT group_id AS any_id FROM \").\n+                append(new SearchSupport(AnyTypeKind.USER).membership().name).append(\" WHERE \").\n+                append(\"any_id=?\").append(setParameter(parameters, memberKey)).\n+                append(\") \");\n+\n+        if (not) {\n+            query.append(\"AND id NOT IN (\");\n+        } else {\n+            query.append(\"OR id IN (\");\n+        }\n+\n+        query.append(\"SELECT DISTINCT group_id AS any_id FROM \").\n+                append(new SearchSupport(AnyTypeKind.ANY_OBJECT).membership().name).append(\" WHERE \").\n+                append(\"any_id=?\").append(setParameter(parameters, memberKey)).\n+                append(\")\");\n+\n+        query.append(\")\");\n+\n+        return query.toString();\n+    }\n+\n+    @Override\n+    protected String getQuery(\n+            final RelationshipTypeCond cond,\n+            final boolean not,\n+            final List<Object> parameters,\n+            final SearchSupport svs) {\n+\n+        StringBuilder query = new StringBuilder(\"(\");\n+\n+        if (not) {\n+            query.append(\"id NOT IN (\");\n+        } else {\n+            query.append(\"id IN (\");\n+        }\n+\n+        query.append(\"SELECT any_id \").append(\"FROM \").\n+                append(svs.relationship().name).\n+                append(\" WHERE type=?\").append(setParameter(parameters, cond.getRelationshipTypeKey())).\n+                append(\" UNION SELECT right_any_id AS any_id FROM \").\n+                append(svs.relationship().name).\n+                append(\" WHERE type=?\").append(setParameter(parameters, cond.getRelationshipTypeKey())).\n+                append(')');\n+\n+        query.append(\")\");\n+\n+        return query.toString();\n+    }\n+\n+    @Override\n+    protected String getQuery(\n+            final RelationshipCond cond,\n+            final boolean not,\n+            final List<Object> parameters,\n+            final SearchSupport svs) {\n+\n+        String rightAnyObjectKey;\n+        try {\n+            rightAnyObjectKey = check(cond);\n+        } catch (IllegalArgumentException e) {\n+            return ALWAYS_FALSE_ASSERTION;\n+        }\n+\n+        StringBuilder query = new StringBuilder(\"(\");\n+\n+        if (not) {\n+            query.append(\"id NOT IN (\");\n+        } else {\n+            query.append(\"id IN (\");\n+        }\n+\n+        query.append(\"SELECT DISTINCT any_id FROM \").\n+                append(svs.relationship().name).append(\" WHERE \").\n+                append(\"right_any_id=?\").append(setParameter(parameters, rightAnyObjectKey)).\n+                append(')');\n+\n+        query.append(\")\");\n+\n+        return query.toString();\n+    }\n+\n+    @Override\n+    protected String getQuery(\n+            final MembershipCond cond,\n+            final boolean not,\n+            final List<Object> parameters,\n+            final SearchSupport svs) {\n+\n+        List<String> groupKeys;\n+        try {\n+            groupKeys = check(cond);\n+        } catch (IllegalArgumentException e) {\n+            return ALWAYS_FALSE_ASSERTION;\n+        }\n+\n+        String where = groupKeys.stream().\n+                map(key -> \"group_id=?\" + setParameter(parameters, key)).\n+                collect(Collectors.joining(\" OR \"));\n+\n+        StringBuilder query = new StringBuilder(\"(\");\n+\n+        if (not) {\n+            query.append(\"id NOT IN (\");\n+        } else {\n+            query.append(\"id IN (\");\n+        }\n+\n+        query.append(\"SELECT DISTINCT any_id FROM \").\n+                append(svs.membership().name).append(\" WHERE \").\n+                append(\"(\").append(where).append(\")\").\n+                append(\") \");\n+\n+        if (not) {\n+            query.append(\"AND id NOT IN (\");\n+        } else {\n+            query.append(\"OR id IN (\");\n+        }\n+\n+        query.append(\"SELECT DISTINCT any_id FROM \").\n+                append(svs.dyngroupmembership().name).append(\" WHERE \").\n+                append(\"(\").append(where).append(\")\").\n+                append(\")\");\n+\n+        query.append(\")\");\n+\n+        return query.toString();\n+    }\n+\n+    @Override\n+    protected String getQuery(\n+            final AnyCond cond,\n+            final boolean not,\n+            final List<Object> parameters,\n+            final SearchSupport svs) {\n+\n+        Triple<PlainSchema, PlainAttrValue, AnyCond> checked;\n+        try {\n+            checked = check(cond, svs.anyTypeKind);\n+        } catch (IllegalArgumentException e) {\n+            return ALWAYS_FALSE_ASSERTION;\n+        }\n+\n+        StringBuilder query = new StringBuilder();\n+\n+        PlainSchema schema = schemaDAO.find(cond.getSchema());\n+        if (schema == null) {\n+            fillAttrQuery(query, checked.getMiddle(), checked.getLeft(), checked.getRight(), not, parameters, svs);\n+        } else {\n+            fillAttrQuery(anyUtilsFactory.getInstance(svs.anyTypeKind),\n+                    query, checked.getMiddle(), checked.getLeft(), checked.getRight(), not, parameters, svs);\n+        }\n+\n+        return query.toString();\n+    }\n+\n+    @Override\n+    protected String buildAdminRealmsFilter(\n+            final Set<String> realmKeys,\n+            final SearchSupport svs,\n+            final List<Object> parameters) {\n+\n+        List<String> realmKeyArgs = realmKeys.stream().\n+                map(realmKey -> \"?\" + setParameter(parameters, realmKey)).\n+                collect(Collectors.toList());\n+        return \"realm_id IN (\" + StringUtils.join(realmKeyArgs, \", \") + \")\";\n+    }\n+\n+    @Override\n+    protected int doCount(final Set<String> adminRealms, final SearchCond cond, final AnyTypeKind kind) {\n+        List<Object> parameters = new ArrayList<>();\n+\n+        SearchSupport svs = buildSearchSupport(kind);\n+\n+        Pair<String, Set<String>> filter = getAdminRealmsFilter(adminRealms, svs, parameters);\n+\n+        Pair<StringBuilder, Set<String>> queryInfo =\n+                getQuery(buildEffectiveCond(cond, filter.getRight()), parameters, svs);\n+\n+        StringBuilder queryString =\n+                new StringBuilder(\"SELECT count(\").append(svs.table().alias).append(\".id\").append(\")\");\n+\n+        buildFrom(queryString, queryInfo, svs, null);\n+\n+        buildWhere(queryString, queryInfo, filter);\n+\n+        Query countQuery = entityManager().createNativeQuery(queryString.toString());\n+        fillWithParameters(countQuery, parameters);\n+\n+        return ((Number) countQuery.getSingleResult()).intValue();\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    protected <T extends Any<?>> List<T> doSearch(\n+            final Set<String> adminRealms,\n+            final SearchCond cond,\n+            final int page,\n+            final int itemsPerPage,\n+            final List<OrderByClause> orderBy,\n+            final AnyTypeKind kind) {\n+\n+        try {\n+            List<Object> parameters = new ArrayList<>();\n+\n+            SearchSupport svs = buildSearchSupport(kind);\n+\n+            Pair<String, Set<String>> filter = getAdminRealmsFilter(adminRealms, svs, parameters);\n+\n+            SearchCond effectiveCond = buildEffectiveCond(cond, filter.getRight());\n+\n+            // 1. get the query string from the search condition\n+            Pair<StringBuilder, Set<String>> queryInfo = getQuery(effectiveCond, parameters, svs);\n+\n+            // 2. take into account realms and ordering\n+            OrderBySupport obs = parseOrderBy(svs, orderBy);\n+\n+            StringBuilder queryString = new StringBuilder(\"SELECT \").append(svs.table().alias).append(\".id\");\n+            obs.items.forEach(item -> {\n+                queryString.append(\",\").append(item.select);\n+            });\n+\n+            buildFrom(queryString, queryInfo, svs, obs);\n+\n+            buildWhere(queryString, queryInfo, filter);\n+\n+            LOG.debug(\"Query: {}, parameters: {}\", queryString, parameters);\n+\n+            queryString.append(buildOrderBy(obs));\n+\n+            LOG.debug(\"Query with auth and order by statements: {}, parameters: {}\", queryString, parameters);\n+\n+            // 3. prepare the search query\n+            Query query = entityManager().createNativeQuery(queryString.toString());\n+\n+            // 4. page starts from 1, while setFirtResult() starts from 0\n+            query.setFirstResult(itemsPerPage * (page <= 0 ? 0 : page - 1));\n+\n+            if (itemsPerPage >= 0) {\n+                query.setMaxResults(itemsPerPage);\n+            }\n+\n+            // 5. populate the search query with parameter values\n+            fillWithParameters(query, parameters);\n+\n+            // 6. Prepare the result (avoiding duplicates)\n+            return buildResult(query.getResultList(), kind);\n+        } catch (SyncopeClientException e) {\n+            throw e;\n+        } catch (Exception e) {\n+            LOG.error(\"While searching for {}\", kind, e);\n+        }\n+\n+        return List.of();\n+    }\n+\n+    protected StringBuilder buildOrderBy(final OrderBySupport obs) {\n+        StringBuilder orderBy = new StringBuilder();\n+\n+        obs.items.forEach(item -> {\n+            orderBy.append(item.orderBy).append(',');\n+        });\n+        if (!obs.items.isEmpty()) {\n+            orderBy.insert(0, \" ORDER BY \");\n+            orderBy.deleteCharAt(orderBy.length() - 1);\n+        }\n+\n+        return orderBy;\n+    }\n+\n+    protected Pair<StringBuilder, Set<String>> getQuery(\n+            final SearchCond cond, final List<Object> parameters, final SearchSupport svs) {\n+\n+        boolean not = cond.getType() == SearchCond.Type.NOT_LEAF;\n+\n+        StringBuilder query = new StringBuilder();\n+        Set<String> involvedPlainAttrs = new HashSet<>();\n+\n+        switch (cond.getType()) {\n+            case LEAF:\n+            case NOT_LEAF:\n+                cond.getLeaf(AnyTypeCond.class).\n+                        filter(leaf -> AnyTypeKind.ANY_OBJECT == svs.anyTypeKind).\n+                        ifPresent(leaf -> query.append(getQuery(leaf, not, parameters, svs)));\n+\n+                cond.getLeaf(RelationshipTypeCond.class).\n+                        filter(leaf -> AnyTypeKind.GROUP != svs.anyTypeKind).\n+                        ifPresent(leaf -> query.append(getQuery(leaf, not, parameters, svs)));\n+\n+                cond.getLeaf(RelationshipCond.class).\n+                        filter(leaf -> AnyTypeKind.GROUP != svs.anyTypeKind).\n+                        ifPresent(leaf -> query.append(getQuery(leaf, not, parameters, svs)));\n+\n+                cond.getLeaf(MembershipCond.class).\n+                        filter(leaf -> AnyTypeKind.GROUP != svs.anyTypeKind).\n+                        ifPresent(leaf -> query.append(getQuery(leaf, not, parameters, svs)));\n+\n+                cond.getLeaf(MemberCond.class).\n+                        filter(leaf -> AnyTypeKind.GROUP == svs.anyTypeKind).\n+                        ifPresent(leaf -> query.append(getQuery(leaf, not, parameters, svs)));\n+\n+                cond.getLeaf(AssignableCond.class).\n+                        ifPresent(leaf -> query.append(getQuery(leaf, parameters, svs)));\n+\n+                cond.getLeaf(RoleCond.class).\n+                        filter(leaf -> AnyTypeKind.USER == svs.anyTypeKind).\n+                        ifPresent(leaf -> query.append(getQuery(leaf, not, parameters, svs)));\n+\n+                cond.getLeaf(PrivilegeCond.class).\n+                        filter(leaf -> AnyTypeKind.USER == svs.anyTypeKind).\n+                        ifPresent(leaf -> query.append(getQuery(leaf, not, parameters, svs)));\n+\n+                cond.getLeaf(DynRealmCond.class).\n+                        ifPresent(leaf -> query.append(getQuery(leaf, not, parameters, svs)));\n+\n+                cond.getLeaf(ResourceCond.class).\n+                        ifPresent(leaf -> query.append(getQuery(leaf, not, parameters, svs)));\n+\n+                Optional<AnyCond> anyCond = cond.getLeaf(AnyCond.class);\n+                if (anyCond.isPresent()) {\n+                    query.append(getQuery(anyCond.get(), not, parameters, svs));\n+                } else {\n+                    cond.getLeaf(AttrCond.class).ifPresent(leaf -> {\n+                        query.append(getQuery(leaf, not, parameters, svs));\n+                        try {\n+                            involvedPlainAttrs.add(check(leaf, svs.anyTypeKind).getLeft().getKey());\n+                        } catch (IllegalArgumentException e) {\n+                            // ignore\n+                        }\n+                    });\n+                }\n+\n+                // allow for additional search conditions\n+                getQueryForCustomConds(cond, parameters, svs, not, query);\n+                break;\n+\n+            case AND:\n+                Pair<StringBuilder, Set<String>> leftAndInfo = getQuery(cond.getLeft(), parameters, svs);\n+                involvedPlainAttrs.addAll(leftAndInfo.getRight());\n+\n+                Pair<StringBuilder, Set<String>> rigthAndInfo = getQuery(cond.getRight(), parameters, svs);\n+                involvedPlainAttrs.addAll(rigthAndInfo.getRight());\n+\n+                query.append(\"(\").\n+                        append(leftAndInfo.getKey()).\n+                        append(\" AND \").\n+                        append(rigthAndInfo.getKey()).\n+                        append(\")\");\n+                break;\n+\n+            case OR:\n+                Pair<StringBuilder, Set<String>> leftOrInfo = getQuery(cond.getLeft(), parameters, svs);\n+                involvedPlainAttrs.addAll(leftOrInfo.getRight());\n+\n+                Pair<StringBuilder, Set<String>> rigthOrInfo = getQuery(cond.getRight(), parameters, svs);\n+                involvedPlainAttrs.addAll(rigthOrInfo.getRight());\n+\n+                query.append(\"(\").\n+                        append(leftOrInfo.getKey()).\n+                        append(\" OR \").\n+                        append(rigthOrInfo.getKey()).\n+                        append(\")\");\n+                break;\n+\n+            default:\n+        }\n+\n+        return Pair.of(query, involvedPlainAttrs);\n+    }\n+\n+    protected void fillAttrQuery(\n+            final StringBuilder query,\n+            final PlainAttrValue attrValue,\n+            final PlainSchema schema,\n+            final AttrCond cond,\n+            final boolean not,\n+            final List<Object> parameters,\n+            final SearchSupport svs) {\n+\n+        // This first branch is required for handling with not conditions given on multivalue fields (SYNCOPE-1419)\n+        if (not && !(cond instanceof AnyCond)) {\n+\n+            query.append(\"NOT (\");\n+            fillAttrQuery(query, attrValue, schema, cond, false, parameters, svs);\n+            query.append(\")\");\n+        } else if (not && cond.getType() == AttrCond.Type.ISNULL) {\n+            cond.setType(AttrCond.Type.ISNOTNULL);\n+            fillAttrQuery(query, attrValue, schema, cond, true, parameters, svs);\n+        } else {\n+            boolean lower = (schema.getType() == AttrSchemaType.String || schema.getType() == AttrSchemaType.Enum)\n+                    && (cond.getType() == AttrCond.Type.IEQ || cond.getType() == AttrCond.Type.ILIKE);\n+\n+            String column = cond.getSchema();\n+            if ((schema.getType() == AttrSchemaType.String || schema.getType() == AttrSchemaType.Enum) && lower) {\n+                column = \"LOWER (\" + column + \")\";\n+            }\n+\n+            switch (cond.getType()) {\n+\n+                case ISNULL:\n+                    // shouldn't occour: processed before\n+                    break;\n+\n+                case ISNOTNULL:\n+                    query.append(column).append(\" IS NOT NULL\");\n+                    break;\n+\n+                case ILIKE:\n+                case LIKE:\n+                    if (schema.getType() == AttrSchemaType.String || schema.getType() == AttrSchemaType.Enum) {\n+                        query.append(column);\n+                        query.append(\" LIKE \");\n+                        if (lower) {\n+                            query.append(\"LOWER(?\").append(setParameter(parameters, cond.getExpression())).append(')');\n+                        } else {\n+                            query.append('?').append(setParameter(parameters, cond.getExpression()));\n+                        }\n+                    } else {\n+                        query.append(\" 1=2\");\n+                        LOG.error(\"LIKE is only compatible with string or enum schemas\");\n+                    }\n+                    break;\n+\n+                case IEQ:\n+                case EQ:\n+                    query.append(column);\n+                    query.append('=');\n+\n+                    if ((schema.getType() == AttrSchemaType.String\n+                            || schema.getType() == AttrSchemaType.Enum) && lower) {\n+                        query.append(\"LOWER(?\").append(setParameter(parameters, attrValue.getValue())).append(')');\n+                    } else {\n+                        query.append('?').append(setParameter(parameters, attrValue.getValue()));\n+                    }\n+                    break;\n+\n+                case GE:\n+                    query.append(column);\n+                    if (not) {\n+                        query.append('<');\n+                    } else {\n+                        query.append(\">=\");\n+                    }\n+                    query.append('?').append(setParameter(parameters, attrValue.getValue()));\n+                    break;\n+\n+                case GT:\n+                    query.append(column);\n+                    if (not) {\n+                        query.append(\"<=\");\n+                    } else {\n+                        query.append('>');\n+                    }\n+                    query.append('?').append(setParameter(parameters, attrValue.getValue()));\n+                    break;\n+\n+                case LE:\n+                    query.append(column);\n+                    if (not) {\n+                        query.append('>');\n+                    } else {\n+                        query.append(\"<=\");\n+                    }\n+                    query.append('?').append(setParameter(parameters, attrValue.getValue()));\n+                    break;\n+\n+                case LT:\n+                    query.append(column);\n+                    if (not) {\n+                        query.append(\">=\");\n+                    } else {\n+                        query.append('<');\n+                    }\n+                    query.append('?').append(setParameter(parameters, attrValue.getValue()));\n+                    break;\n+\n+                default:\n+            }\n+        }\n+    }\n+\n+    protected void fillWithParameters(final Query query, final List<Object> parameters) {\n+        for (int i = 0; i < parameters.size(); i++) {\n+            if (parameters.get(i) instanceof Date) {\n+                query.setParameter(i + 1, (Date) parameters.get(i), TemporalType.TIMESTAMP);\n+            } else if (parameters.get(i) instanceof Boolean) {\n+                query.setParameter(i + 1, ((Boolean) parameters.get(i))\n+                        ? 1\n+                        : 0);\n+            } else {\n+                query.setParameter(i + 1, parameters.get(i));\n+            }\n+        }\n+    }\n+\n+    protected OrderBySupport parseOrderBy(\n+            final SearchSupport svs,\n+            final List<OrderByClause> orderBy) {\n+\n+        AnyUtils anyUtils = anyUtilsFactory.getInstance(svs.anyTypeKind);\n+\n+        OrderBySupport obs = new OrderBySupport();\n+\n+        Set<String> orderByUniquePlainSchemas = new HashSet<>();\n+        Set<String> orderByNonUniquePlainSchemas = new HashSet<>();\n+        orderBy.forEach(clause -> {\n+            OrderBySupport.Item item = new OrderBySupport.Item();\n+\n+            parseOrderByForCustom(svs, clause, item, obs);\n+\n+            if (item.isEmpty()) {\n+                if (anyUtils.getField(clause.getField()) == null) {\n+                    PlainSchema schema = schemaDAO.find(clause.getField());\n+                    if (schema != null) {\n+                        if (schema.isUniqueConstraint()) {\n+                            orderByUniquePlainSchemas.add(schema.getKey());\n+                        } else {\n+                            orderByNonUniquePlainSchemas.add(schema.getKey());\n+                        }\n+                        if (orderByUniquePlainSchemas.size() > 1 || orderByNonUniquePlainSchemas.size() > 1) {\n+                            SyncopeClientException invalidSearch =\n+                                    SyncopeClientException.build(ClientExceptionType.InvalidSearchExpression);\n+                            invalidSearch.getElements().add(\"Order by more than one attribute is not allowed; \"\n+                                    + \"remove one from \" + (orderByUniquePlainSchemas.size() > 1\n+                                    ? orderByUniquePlainSchemas : orderByNonUniquePlainSchemas));\n+                            throw invalidSearch;\n+                        }\n+                        parseOrderByForPlainSchema(svs, obs, item, clause, schema, clause.getField());\n+                    }\n+                } else {\n+                    // Manage difference among external key attribute and internal JPA @Id\n+                    String fieldName = \"key\".equals(clause.getField()) ? \"id\" : clause.getField();\n+\n+                    // Adjust field name to column name\n+                    if (ArrayUtils.contains(RELATIONSHIP_FIELDS, fieldName)) {\n+                        fieldName += \"_id\";\n+                    }\n+\n+                    obs.views.add(svs.field());\n+\n+                    item.select = svs.table().alias + \".\" + fieldName;\n+                    item.where = StringUtils.EMPTY;\n+                    item.orderBy = svs.table().alias + \".\" + fieldName + \" \" + clause.getDirection().name();\n+                }\n+            }\n+\n+            if (item.isEmpty()) {\n+                LOG.warn(\"Cannot build any valid clause from {}\", clause);\n+            } else {\n+                obs.items.add(item);\n+            }\n+        });\n+\n+        return obs;\n+    }\n+\n+    protected Pair<String, Set<String>> getAdminRealmsFilter(\n+            final Set<String> adminRealms,\n+            final SearchSupport svs,\n+            final List<Object> parameters) {\n+\n+        Set<String> realmKeys = new HashSet<>();\n+        Set<String> dynRealmKeys = new HashSet<>();\n+        RealmUtils.normalize(adminRealms).forEach(realmPath -> {\n+            if (realmPath.startsWith(\"/\")) {\n+                Realm realm = realmDAO.findByFullPath(realmPath);\n+                if (realm == null) {\n+                    SyncopeClientException noRealm = SyncopeClientException.build(ClientExceptionType.InvalidRealm);\n+                    noRealm.getElements().add(\"Invalid realm specified: \" + realmPath);\n+                    throw noRealm;\n+                } else {\n+                    realmKeys.addAll(realmDAO.findDescendants(realm).stream().\n+                            map(Entity::getKey).collect(Collectors.toSet()));\n+                }\n+            } else {\n+                DynRealm dynRealm = dynRealmDAO.find(realmPath);\n+                if (dynRealm == null) {\n+                    LOG.warn(\"Ignoring invalid dynamic realm {}\", realmPath);\n+                } else {\n+                    dynRealmKeys.add(dynRealm.getKey());\n+                }\n+            }\n+        });\n+        if (!dynRealmKeys.isEmpty()) {\n+            realmKeys.addAll(realmDAO.findAll().stream().\n+                    map(Entity::getKey).collect(Collectors.toSet()));\n+        }\n+\n+        return Pair.of(buildAdminRealmsFilter(realmKeys, svs, parameters), dynRealmKeys);\n+    }\n+\n+    protected void buildFrom(\n+            final StringBuilder query,\n+            final Pair<StringBuilder, Set<String>> queryInfo,\n+            final SearchSupport svs,\n+            final OrderBySupport obs) {\n+\n+        query.append(\" FROM \").append(svs.table().name).append(\" \").append(svs.table().alias);\n+\n+        Set<String> schemas = queryInfo.getRight();\n+\n+        if (obs != null) {\n+            Pattern pattern = Pattern.compile(\"(.*) -> 0 AS .*\");\n+            obs.items.forEach(item -> {\n+                Matcher matcher = pattern.matcher(item.select);\n+                if (matcher.find()) {\n+                    schemas.add(matcher.group(1));\n+                }\n+            });\n+        }\n+\n+        schemas.forEach(schema -> {\n+            // i.e jsonb_path_query(plainattrs, '$[*] ? (@.schema==\"Nome\").\"values\"') AS Nome\n+            PlainSchema pschema = schemaDAO.find(schema);\n+            if (pschema == null) {\n+                // just to be sure\n+                LOG.warn(\"Ignoring invalid schema '{}'\", schema);\n+            } else {\n+                query.append(\",\").\n+                        append(\"jsonb_path_query_array(plainattrs, '$[*] ? (@.schema==\\\"\").\n+                        append(schema).append(\"\\\").\").\n+                        append(\"\\\"\").append(pschema.isUniqueConstraint() ? \"uniqueValue\" : \"values\").append(\"\\\"')\").\n+                        append(\" AS \").append(schema);\n+            }\n+        });\n+    }\n+\n+    protected void buildWhere(\n+            final StringBuilder query,\n+            final Pair<StringBuilder, Set<String>> queryInfo,\n+            final Pair<String, Set<String>> realms) {\n+        if (queryInfo.getLeft().length() > 0) {\n+            query.append(\" WHERE \").append(queryInfo.getLeft());\n+        }\n+\n+        if (realms.getLeft().length() > 0) {\n+            if (queryInfo.getLeft().length() > 0) {\n+                query.append(\" AND \").append(realms.getLeft());\n+            } else {\n+                query.append(\" WHERE \").append(realms.getLeft());\n+            }\n+        }\n+    }\n }"},{"sha":"3c0cf54c14e0e25ff8e394cfc6c43729a0dcfe5f","filename":"core/persistence-jpa-json/src/main/java/org/apache/syncope/core/persistence/jpa/dao/PGJPAJSONPlainSchemaDAO.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fca4bdbd08746b926bdb1d78f653a476ca1d9dbb/core%2Fpersistence-jpa-json%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fjpa%2Fdao%2FPGJPAJSONPlainSchemaDAO.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fca4bdbd08746b926bdb1d78f653a476ca1d9dbb/core%2Fpersistence-jpa-json%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fjpa%2Fdao%2FPGJPAJSONPlainSchemaDAO.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fpersistence-jpa-json%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fjpa%2Fdao%2FPGJPAJSONPlainSchemaDAO.java?ref=fca4bdbd08746b926bdb1d78f653a476ca1d9dbb","patch":"@@ -27,7 +27,7 @@ public class PGJPAJSONPlainSchemaDAO extends AbstractJPAJSONPlainSchemaDAO {\n     @Override\n     public <T extends PlainAttr<?>> boolean hasAttrs(final PlainSchema schema, final Class<T> reference) {\n         Query query = entityManager().createNativeQuery(\n-                \"SELECT COUNT(id) FROM \" + new SearchSupport(getAnyTypeKind(reference)).field().name\n+                \"SELECT COUNT(id) FROM \" + new SearchSupport(getAnyTypeKind(reference)).table().name\n                 + \" WHERE plainAttrs @> '[{\\\"schema\\\":\\\"\" + schema.getKey() + \"\\\"}]'::jsonb\");\n \n         return ((Number) query.getSingleResult()).intValue() > 0;"},{"sha":"f07024dff3d4585be638e923395ce50139c5aae8","filename":"core/persistence-jpa-json/src/main/resources/pgjsonb/views.xml","status":"modified","additions":0,"deletions":7,"changes":7,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fca4bdbd08746b926bdb1d78f653a476ca1d9dbb/core%2Fpersistence-jpa-json%2Fsrc%2Fmain%2Fresources%2Fpgjsonb%2Fviews.xml","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fca4bdbd08746b926bdb1d78f653a476ca1d9dbb/core%2Fpersistence-jpa-json%2Fsrc%2Fmain%2Fresources%2Fpgjsonb%2Fviews.xml","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fpersistence-jpa-json%2Fsrc%2Fmain%2Fresources%2Fpgjsonb%2Fviews.xml?ref=fca4bdbd08746b926bdb1d78f653a476ca1d9dbb","patch":"@@ -47,13 +47,6 @@ under the License.\n   </entry>\n \n   <!-- user -->\n-  <entry key=\"user_search\">\n-    CREATE VIEW user_search AS\n-\n-    SELECT u.id as any_id, u.*,attrs,attrValues\n-    FROM SyncopeUser u, jsonb_array_elements(COALESCE(u.plainAttrs, '[{}]'::jsonb)) attrs,\n-    jsonb_array_elements(COALESCE(attrs -> 'values', '[{}]'::jsonb)) attrValues\n-  </entry>\n   <entry key=\"user_search_urelationship\">\n     CREATE VIEW user_search_urelationship AS\n "},{"sha":"ffe36787192dc22f32f3fc5e250c1c0fab56b4d2","filename":"core/persistence-jpa/src/main/java/org/apache/syncope/core/persistence/jpa/dao/JPAAnySearchDAO.java","status":"modified","additions":6,"deletions":6,"changes":12,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fca4bdbd08746b926bdb1d78f653a476ca1d9dbb/core%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fjpa%2Fdao%2FJPAAnySearchDAO.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fca4bdbd08746b926bdb1d78f653a476ca1d9dbb/core%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fjpa%2Fdao%2FJPAAnySearchDAO.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fjpa%2Fdao%2FJPAAnySearchDAO.java?ref=fca4bdbd08746b926bdb1d78f653a476ca1d9dbb","patch":"@@ -564,7 +564,7 @@ private Pair<StringBuilder, Set<String>> getQuery(\n         return Pair.of(query, involvedPlainAttrs);\n     }\n \n-    protected static String getQuery(\n+    protected String getQuery(\n             final AnyTypeCond cond,\n             final boolean not,\n             final List<Object> parameters,\n@@ -584,7 +584,7 @@ protected static String getQuery(\n         return query.toString();\n     }\n \n-    protected static String getQuery(\n+    protected String getQuery(\n             final RelationshipTypeCond cond,\n             final boolean not,\n             final List<Object> parameters,\n@@ -685,7 +685,7 @@ protected String getQuery(\n         return query.toString();\n     }\n \n-    protected static String getQuery(\n+    protected String getQuery(\n             final RoleCond cond,\n             final boolean not,\n             final List<Object> parameters,\n@@ -719,7 +719,7 @@ protected static String getQuery(\n         return query.toString();\n     }\n \n-    protected static String getQuery(\n+    protected String getQuery(\n             final PrivilegeCond cond,\n             final boolean not,\n             final List<Object> parameters,\n@@ -753,7 +753,7 @@ protected static String getQuery(\n         return query.toString();\n     }\n \n-    protected static String getQuery(\n+    protected String getQuery(\n             final DynRealmCond cond,\n             final boolean not,\n             final List<Object> parameters,\n@@ -776,7 +776,7 @@ protected static String getQuery(\n         return query.toString();\n     }\n \n-    protected static String getQuery(\n+    protected String getQuery(\n             final ResourceCond cond,\n             final boolean not,\n             final List<Object> parameters,"},{"sha":"78bb99632af683910ca9b27c8a1ba089cef8b4a2","filename":"docker/src/main/resources/docker-compose/docker-compose-all.yml","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fca4bdbd08746b926bdb1d78f653a476ca1d9dbb/docker%2Fsrc%2Fmain%2Fresources%2Fdocker-compose%2Fdocker-compose-all.yml","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fca4bdbd08746b926bdb1d78f653a476ca1d9dbb/docker%2Fsrc%2Fmain%2Fresources%2Fdocker-compose%2Fdocker-compose-all.yml","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/docker%2Fsrc%2Fmain%2Fresources%2Fdocker-compose%2Fdocker-compose-all.yml?ref=fca4bdbd08746b926bdb1d78f653a476ca1d9dbb","patch":"@@ -28,7 +28,7 @@ services:\n      restart: always\n \n    db:\n-     image: postgres:12\n+     image: postgres:13\n      restart: always\n      environment:\n        POSTGRES_DB: syncope"},{"sha":"8abe5af8bb99f61e08af4ebc8a3ca829138469aa","filename":"docker/src/main/resources/docker-compose/docker-compose-ha.yml","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fca4bdbd08746b926bdb1d78f653a476ca1d9dbb/docker%2Fsrc%2Fmain%2Fresources%2Fdocker-compose%2Fdocker-compose-ha.yml","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fca4bdbd08746b926bdb1d78f653a476ca1d9dbb/docker%2Fsrc%2Fmain%2Fresources%2Fdocker-compose%2Fdocker-compose-ha.yml","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/docker%2Fsrc%2Fmain%2Fresources%2Fdocker-compose%2Fdocker-compose-ha.yml?ref=fca4bdbd08746b926bdb1d78f653a476ca1d9dbb","patch":"@@ -22,7 +22,7 @@ version: '3.3'\n \n services:\n    db:\n-     image: postgres:12\n+     image: postgres:13\n      restart: always\n      environment:\n        POSTGRES_DB: syncope"},{"sha":"a48a6e913f02b84c01cd3d6ac5b57e5466310cdd","filename":"docker/src/main/resources/docker-compose/docker-compose-pgjsonb.yml","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fca4bdbd08746b926bdb1d78f653a476ca1d9dbb/docker%2Fsrc%2Fmain%2Fresources%2Fdocker-compose%2Fdocker-compose-pgjsonb.yml","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fca4bdbd08746b926bdb1d78f653a476ca1d9dbb/docker%2Fsrc%2Fmain%2Fresources%2Fdocker-compose%2Fdocker-compose-pgjsonb.yml","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/docker%2Fsrc%2Fmain%2Fresources%2Fdocker-compose%2Fdocker-compose-pgjsonb.yml?ref=fca4bdbd08746b926bdb1d78f653a476ca1d9dbb","patch":"@@ -21,7 +21,7 @@ version: '3.3'\n \n services:\n    db:\n-     image: postgres:12\n+     image: postgres:13\n      restart: always\n      environment:\n        POSTGRES_DB: syncope"},{"sha":"c73fcb4799dddfff722e9d95dd41ab6d14d2be22","filename":"docker/src/main/resources/docker-compose/docker-compose-postgresql.yml","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fca4bdbd08746b926bdb1d78f653a476ca1d9dbb/docker%2Fsrc%2Fmain%2Fresources%2Fdocker-compose%2Fdocker-compose-postgresql.yml","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fca4bdbd08746b926bdb1d78f653a476ca1d9dbb/docker%2Fsrc%2Fmain%2Fresources%2Fdocker-compose%2Fdocker-compose-postgresql.yml","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/docker%2Fsrc%2Fmain%2Fresources%2Fdocker-compose%2Fdocker-compose-postgresql.yml?ref=fca4bdbd08746b926bdb1d78f653a476ca1d9dbb","patch":"@@ -21,7 +21,7 @@ version: '3.3'\n \n services:\n    db:\n-     image: postgres:12\n+     image: postgres:13\n      restart: always\n      environment:\n        POSTGRES_DB: syncope"},{"sha":"9fb242554953abc38c936dae1139d48610abe9b9","filename":"pom.xml","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fca4bdbd08746b926bdb1d78f653a476ca1d9dbb/pom.xml","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fca4bdbd08746b926bdb1d78f653a476ca1d9dbb/pom.xml","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/pom.xml?ref=fca4bdbd08746b926bdb1d78f653a476ca1d9dbb","patch":"@@ -515,7 +515,7 @@ under the License.\n     <payara.version>5.2020.7</payara.version>\n     <javax.faces.version>2.3.14</javax.faces.version>\n \n-    <docker.postgresql.version>12</docker.postgresql.version>\n+    <docker.postgresql.version>13</docker.postgresql.version>\n     <docker.mysql.version>8.0</docker.mysql.version>\n     <docker.mariadb.version>10.5</docker.mariadb.version>\n "}]}