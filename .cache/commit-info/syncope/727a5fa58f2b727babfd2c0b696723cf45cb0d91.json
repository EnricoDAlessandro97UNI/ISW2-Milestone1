{"sha":"727a5fa58f2b727babfd2c0b696723cf45cb0d91","node_id":"MDY6Q29tbWl0NjM2ODc5MDYyOjcyN2E1ZmE1OGYyYjcyN2JhYmZkMmMwYjY5NjcyM2NmNDVjYjBkOTE=","commit":{"author":{"name":"Andrea Patricelli","email":"andreapatricelli@apache.org","date":"2014-08-12T15:20:07Z"},"committer":{"name":"Andrea Patricelli","email":"andreapatricelli@apache.org","date":"2014-08-12T15:20:07Z"},"message":"merge from branch 1_2_X\n\ngit-svn-id: https://svn.apache.org/repos/asf/syncope/trunk@1617506 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"dd47620f39d1ec4ea71ce885805ea73703ca4fcc","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/git/trees/dd47620f39d1ec4ea71ce885805ea73703ca4fcc"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/git/commits/727a5fa58f2b727babfd2c0b696723cf45cb0d91","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/727a5fa58f2b727babfd2c0b696723cf45cb0d91","html_url":"https://github.com/EnricoDAlessandro97UNI/syncope/commit/727a5fa58f2b727babfd2c0b696723cf45cb0d91","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/727a5fa58f2b727babfd2c0b696723cf45cb0d91/comments","author":{"login":"andrea-patricelli","id":3763111,"node_id":"MDQ6VXNlcjM3NjMxMTE=","avatar_url":"https://avatars.githubusercontent.com/u/3763111?v=4","gravatar_id":"","url":"https://api.github.com/users/andrea-patricelli","html_url":"https://github.com/andrea-patricelli","followers_url":"https://api.github.com/users/andrea-patricelli/followers","following_url":"https://api.github.com/users/andrea-patricelli/following{/other_user}","gists_url":"https://api.github.com/users/andrea-patricelli/gists{/gist_id}","starred_url":"https://api.github.com/users/andrea-patricelli/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/andrea-patricelli/subscriptions","organizations_url":"https://api.github.com/users/andrea-patricelli/orgs","repos_url":"https://api.github.com/users/andrea-patricelli/repos","events_url":"https://api.github.com/users/andrea-patricelli/events{/privacy}","received_events_url":"https://api.github.com/users/andrea-patricelli/received_events","type":"User","site_admin":false},"committer":{"login":"andrea-patricelli","id":3763111,"node_id":"MDQ6VXNlcjM3NjMxMTE=","avatar_url":"https://avatars.githubusercontent.com/u/3763111?v=4","gravatar_id":"","url":"https://api.github.com/users/andrea-patricelli","html_url":"https://github.com/andrea-patricelli","followers_url":"https://api.github.com/users/andrea-patricelli/followers","following_url":"https://api.github.com/users/andrea-patricelli/following{/other_user}","gists_url":"https://api.github.com/users/andrea-patricelli/gists{/gist_id}","starred_url":"https://api.github.com/users/andrea-patricelli/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/andrea-patricelli/subscriptions","organizations_url":"https://api.github.com/users/andrea-patricelli/orgs","repos_url":"https://api.github.com/users/andrea-patricelli/repos","events_url":"https://api.github.com/users/andrea-patricelli/events{/privacy}","received_events_url":"https://api.github.com/users/andrea-patricelli/received_events","type":"User","site_admin":false},"parents":[{"sha":"e9668c86ba02f6da64f40aae8c3b7543a39fed78","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/e9668c86ba02f6da64f40aae8c3b7543a39fed78","html_url":"https://github.com/EnricoDAlessandro97UNI/syncope/commit/e9668c86ba02f6da64f40aae8c3b7543a39fed78"},{"sha":"35b1b5103afc059240bd18e024e1df7ab05fc20a","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/35b1b5103afc059240bd18e024e1df7ab05fc20a","html_url":"https://github.com/EnricoDAlessandro97UNI/syncope/commit/35b1b5103afc059240bd18e024e1df7ab05fc20a"}],"stats":{"total":1197,"additions":1195,"deletions":2},"files":[{"sha":"673a0dd0e1d3a34f334077472fd506b0645635fb","filename":"core-upgrader/pom.xml","status":"added","additions":83,"deletions":0,"changes":83,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/727a5fa58f2b727babfd2c0b696723cf45cb0d91/core-upgrader%2Fpom.xml","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/727a5fa58f2b727babfd2c0b696723cf45cb0d91/core-upgrader%2Fpom.xml","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core-upgrader%2Fpom.xml?ref=727a5fa58f2b727babfd2c0b696723cf45cb0d91","patch":"@@ -0,0 +1,83 @@\n+<?xml version=\"1.0\"?>\n+<!--\n+Licensed to the Apache Software Foundation (ASF) under one\n+or more contributor license agreements.  See the NOTICE file\n+distributed with this work for additional information\n+regarding copyright ownership.  The ASF licenses this file\n+to you under the Apache License, Version 2.0 (the\n+\"License\"); you may not use this file except in compliance\n+with the License.  You may obtain a copy of the License at\n+\n+  http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing,\n+software distributed under the License is distributed on an\n+\"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+KIND, either express or implied.  See the License for the\n+specific language governing permissions and limitations\n+under the License.\n+-->\n+<project xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\" xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n+  <modelVersion>4.0.0</modelVersion>\n+  \n+  <parent>\n+    <groupId>org.apache.syncope</groupId>\n+    <artifactId>syncope</artifactId>\n+    <version>1.2.0-SNAPSHOT</version>\n+  </parent>\n+ \n+  <groupId>org.apache.syncope</groupId>\n+  <artifactId>core-upgrader</artifactId>\n+  <packaging>jar</packaging>\n+ \n+  <name>Apache Syncope Upgrader</name>\n+  <description>Apache Syncope Upgrader from 1.1.X to 1.2.X</description>\n+  \n+  <properties>\n+    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+    <xstream.version>1.4.7</xstream.version>\n+  </properties>\n+  <dependencies>\n+\n+    <dependency>\n+      <groupId>org.apache.syncope</groupId>\n+      <artifactId>syncope-core</artifactId>\n+      <version>${project.version}</version>\n+      <classifier>classes</classifier>\n+      <scope>provided</scope>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.apache.syncope</groupId>\n+      <artifactId>syncope-common</artifactId>\n+      <version>${project.version}</version>\n+    </dependency>\n+    \n+    <dependency>\n+      <groupId>com.thoughtworks.xstream</groupId>\n+      <artifactId>xstream</artifactId>\n+      <version>${xstream.version}</version>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.apache.commons</groupId>\n+      <artifactId>commons-lang3</artifactId>\n+    </dependency>\n+  </dependencies>\n+  \n+  <build>\n+    <resources>\n+      <resource>\n+        <directory>src/main/resources</directory>\n+        <filtering>true</filtering>\n+      </resource>\n+      <resource>\n+        <directory>..</directory>\n+        <targetPath>META-INF</targetPath>\n+        <includes>\n+          <include>LICENSE</include>\n+          <include>NOTICE</include>\n+        </includes>\n+      </resource>\n+    </resources>\n+  </build>\n+</project>"},{"sha":"e95ca60d400beaa3f54047fca43483fc59584156","filename":"core-upgrader/src/main/java/org/apache/syncope/upgrader/ContentUpgrader.java","status":"added","additions":739,"deletions":0,"changes":739,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/727a5fa58f2b727babfd2c0b696723cf45cb0d91/core-upgrader%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fupgrader%2FContentUpgrader.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/727a5fa58f2b727babfd2c0b696723cf45cb0d91/core-upgrader%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fupgrader%2FContentUpgrader.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core-upgrader%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fupgrader%2FContentUpgrader.java?ref=727a5fa58f2b727babfd2c0b696723cf45cb0d91","patch":"@@ -0,0 +1,739 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.upgrader;\n+\n+import org.apache.syncope.upgrader.util.XMLDeserializer;\n+import org.apache.syncope.upgrader.util.SyncopeDefParams;\n+import java.io.IOException;\n+import java.lang.reflect.Field;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import javax.annotation.Resource;\n+import javax.sql.DataSource;\n+import org.activiti.engine.RepositoryService;\n+import org.activiti.engine.repository.Model;\n+import org.activiti.engine.repository.ProcessDefinition;\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.syncope.common.report.UserReportletConf;\n+import org.apache.syncope.common.to.RoleTO;\n+import org.apache.syncope.common.to.UserTO;\n+import org.apache.syncope.common.types.AbstractPolicySpec;\n+import org.apache.syncope.common.types.AttributableType;\n+import org.apache.syncope.common.types.AttributeSchemaType;\n+import org.apache.syncope.common.types.ConnConfProperty;\n+import org.apache.syncope.core.persistence.beans.AbstractAttr;\n+import org.apache.syncope.core.persistence.beans.AbstractAttrTemplate;\n+import org.apache.syncope.core.persistence.beans.AbstractDerAttr;\n+import org.apache.syncope.core.persistence.beans.AbstractSchema;\n+import org.apache.syncope.core.persistence.beans.AbstractVirAttr;\n+import org.apache.syncope.core.persistence.beans.ConnInstance;\n+import org.apache.syncope.core.persistence.beans.ExternalResource;\n+import org.apache.syncope.core.persistence.beans.Policy;\n+import org.apache.syncope.core.persistence.beans.PropagationTask;\n+import org.apache.syncope.core.persistence.beans.SyncTask;\n+import org.apache.syncope.core.persistence.beans.conf.CAttr;\n+import org.apache.syncope.core.persistence.beans.conf.CSchema;\n+import org.apache.syncope.core.persistence.beans.membership.MAttr;\n+import org.apache.syncope.core.persistence.beans.membership.MAttrTemplate;\n+import org.apache.syncope.core.persistence.beans.membership.MDerAttr;\n+import org.apache.syncope.core.persistence.beans.membership.MDerAttrTemplate;\n+import org.apache.syncope.core.persistence.beans.membership.MDerSchema;\n+import org.apache.syncope.core.persistence.beans.membership.MSchema;\n+import org.apache.syncope.core.persistence.beans.membership.MVirAttr;\n+import org.apache.syncope.core.persistence.beans.membership.MVirAttrTemplate;\n+import org.apache.syncope.core.persistence.beans.membership.MVirSchema;\n+import org.apache.syncope.core.persistence.beans.membership.Membership;\n+import org.apache.syncope.core.persistence.beans.role.RAttr;\n+import org.apache.syncope.core.persistence.beans.role.RAttrTemplate;\n+import org.apache.syncope.core.persistence.beans.role.RDerAttr;\n+import org.apache.syncope.core.persistence.beans.role.RDerAttrTemplate;\n+import org.apache.syncope.core.persistence.beans.role.RDerSchema;\n+import org.apache.syncope.core.persistence.beans.role.RSchema;\n+import org.apache.syncope.core.persistence.beans.role.RVirAttr;\n+import org.apache.syncope.core.persistence.beans.role.RVirAttrTemplate;\n+import org.apache.syncope.core.persistence.beans.role.RVirSchema;\n+import org.apache.syncope.core.persistence.beans.role.SyncopeRole;\n+import org.apache.syncope.core.persistence.dao.AttrDAO;\n+import org.apache.syncope.core.persistence.dao.AttrTemplateDAO;\n+import org.apache.syncope.core.persistence.dao.ConfDAO;\n+import org.apache.syncope.core.persistence.dao.ConnInstanceDAO;\n+import org.apache.syncope.core.persistence.dao.DerAttrDAO;\n+import org.apache.syncope.core.persistence.dao.DerSchemaDAO;\n+import org.apache.syncope.core.persistence.dao.MembershipDAO;\n+import org.apache.syncope.core.persistence.dao.PolicyDAO;\n+import org.apache.syncope.core.persistence.dao.ResourceDAO;\n+import org.apache.syncope.core.persistence.dao.RoleDAO;\n+import org.apache.syncope.core.persistence.dao.SchemaDAO;\n+import org.apache.syncope.core.persistence.dao.TaskDAO;\n+import org.apache.syncope.core.persistence.dao.VirAttrDAO;\n+import org.apache.syncope.core.persistence.dao.VirSchemaDAO;\n+import org.apache.syncope.core.util.AttributableUtil;\n+import org.apache.syncope.core.util.POJOHelper;\n+import org.apache.syncope.core.util.ResourceWithFallbackLoader;\n+import org.apache.syncope.core.workflow.user.activiti.ActivitiImportUtils;\n+import org.apache.syncope.core.workflow.user.activiti.ActivitiUserWorkflowAdapter;\n+import org.identityconnectors.framework.common.objects.Attribute;\n+import org.identityconnectors.framework.common.objects.SyncToken;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.InitializingBean;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.context.annotation.DependsOn;\n+import org.springframework.dao.DataAccessException;\n+import org.springframework.jdbc.core.JdbcTemplate;\n+import org.springframework.orm.jpa.JpaTransactionManager;\n+import org.springframework.stereotype.Component;\n+import org.springframework.transaction.TransactionStatus;\n+import org.springframework.transaction.support.TransactionCallbackWithoutResult;\n+import org.springframework.transaction.support.TransactionTemplate;\n+import org.springframework.util.ReflectionUtils;\n+\n+@Component\n+@DependsOn(\"springContextInitializer\")\n+public class ContentUpgrader implements InitializingBean {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(ContentUpgrader.class);\n+\n+    private JdbcTemplate jdbcTemplate;\n+\n+    @Autowired\n+    private DataSource dataSource;\n+\n+    @Autowired\n+    private ResourceDAO resourceDAO;\n+\n+    @Autowired\n+    private SchemaDAO schemaDAO;\n+\n+    @Autowired\n+    private DerSchemaDAO derSchemaDAO;\n+\n+    @Autowired\n+    private VirSchemaDAO virSchemaDAO;\n+\n+    @Autowired\n+    private ConfDAO confDAO;\n+\n+    @Autowired\n+    private ConnInstanceDAO connInstanceDAO;\n+\n+    @Autowired\n+    private PolicyDAO policyDAO;\n+\n+    @Autowired\n+    private TaskDAO taskDAO;\n+\n+    @Autowired\n+    private AttrDAO attrDAO;\n+\n+    @Autowired\n+    private DerAttrDAO derAttrDAO;\n+\n+    @Autowired\n+    private VirAttrDAO virAttrDAO;\n+\n+    @Autowired\n+    private AttrTemplateDAO attrTemplateDAO;\n+\n+    @Autowired\n+    private RoleDAO roleDAO;\n+\n+    @Autowired\n+    private MembershipDAO membershipDAO;\n+\n+    @Autowired\n+    private ActivitiImportUtils importUtils;\n+\n+    @Autowired\n+    private RepositoryService repositoryService;\n+\n+    @Autowired\n+    @Qualifier(\"transactionManager\")\n+    protected JpaTransactionManager txManager;\n+\n+    @Resource(name = \"userWorkflowXML\")\n+    private ResourceWithFallbackLoader userWorkflowXML;\n+\n+    private boolean continueUpgrade = true;\n+\n+    private boolean deleteOldWorkflow = false;\n+\n+    @Override\n+    public void afterPropertiesSet() throws Exception {\n+        jdbcTemplate = new JdbcTemplate(dataSource);\n+        final TransactionTemplate txTemplate = new TransactionTemplate(txManager);\n+\n+        txTemplate.execute(new TransactionCallbackWithoutResult() {\n+\n+            @Override\n+            protected void doInTransactionWithoutResult(final TransactionStatus status) {\n+                try {\n+                    doUpgradePhaseOne();\n+                } catch (Exception e) {\n+                    LOG.error(\"Upgrade STOPPED: an error occurred during upgrade\", e);\n+                }\n+            }\n+        });\n+\n+        if (continueUpgrade) {\n+            txTemplate.execute(new TransactionCallbackWithoutResult() {\n+\n+                @Override\n+                protected void doInTransactionWithoutResult(final TransactionStatus status) {\n+                    try {\n+                        doUpgradePhaseTwo();\n+                    } catch (Exception e) {\n+                        LOG.error(\"Upgrade STOPPED: an error occurred during upgrade\", e);\n+                    }\n+                }\n+            });\n+        } else {\n+            LOG.error(\"Upgrade STOPPED: can not continue due to previous errors, see exceptions above.\");\n+            return;\n+        }\n+        LOG.info(\"Upgrade completed SUCCESSFULLY.\");\n+    }\n+\n+    public void doUpgradePhaseOne() throws Exception {\n+        LOG.info(\"Beginning upgrade PHASE 1...\");\n+        upgradeSyncopeConf();\n+        upgradeExternalResource();\n+        upgradeConnInstance();\n+        updgradePropagationTask();\n+        upgradeSyncTask();\n+        upgradePolicy();\n+        upgradeReportletConf();\n+        upgradeWorkflow();\n+        addTemplatesToRoles();\n+        addTemplatesToMemberships();\n+        LOG.info(\"Upgrade PHASE 1 completed.\");\n+    }\n+\n+    private void doUpgradePhaseTwo() throws IOException {\n+        LOG.info(\"Beginning upgrade PHASE 2...\");\n+        addTemplatesToRAttrs();\n+        addTemplatesToMAttrs();\n+        LOG.info(\"Upgrade PHASE 2 completed.\");\n+    }\n+\n+    public void setDeleteOldWorkflow(final boolean deleteOldWorkflow) {\n+        this.deleteOldWorkflow = deleteOldWorkflow;\n+    }\n+\n+    private void upgradeExternalResource() throws Exception {\n+        LOG.info(\"Upgrading ExternalResource table...\");\n+        final Field jsonConf = ReflectionUtils.findField(ExternalResource.class, \"jsonConf\");\n+        jsonConf.setAccessible(true);\n+        final Field uSyncToken = ReflectionUtils.findField(ExternalResource.class, \"userializedSyncToken\");\n+        uSyncToken.setAccessible(true);\n+        final Field rSyncToken = ReflectionUtils.findField(ExternalResource.class, \"rserializedSyncToken\");\n+        rSyncToken.setAccessible(true);\n+        for (ExternalResource resource : resourceDAO.findAll()) {\n+            try {\n+                final String oldConf = (String) jsonConf.get(resource);\n+                if (StringUtils.isNotBlank(oldConf)) {\n+                    LOG.info(\"Upgrading resource {} jsonConf\", resource.getName());\n+                    resource.setConnInstanceConfiguration(\n+                            XMLDeserializer.<HashSet<ConnConfProperty>>deserialize(oldConf));\n+                }\n+\n+                final String oldUSyncToken = (String) uSyncToken.get(resource);\n+                final String oldRSyncToken = (String) rSyncToken.get(resource);\n+\n+                if (StringUtils.isNotBlank(oldUSyncToken)) {\n+                    LOG.info(\"Upgrading resource {} userializedSyncToken\", resource.getName());\n+                    resource.setUsyncToken(XMLDeserializer.<SyncToken>deserialize(oldUSyncToken));\n+                }\n+                if (StringUtils.isNotBlank(oldRSyncToken)) {\n+                    LOG.info(\"Upgrading resource {} rserializedSyncToken\", resource.getName());\n+                    resource.setRsyncToken(XMLDeserializer.<SyncToken>deserialize(oldRSyncToken));\n+                }\n+            } catch (Exception e) {\n+                LOG.error(\"While upgrading resource {}\", resource, e);\n+                continueUpgrade = false;\n+                throw e;\n+            }\n+        }\n+    }\n+\n+    private void upgradeConnInstance() throws Exception {\n+        LOG.info(\"Upgrading ConnInstance table...\");\n+        final Field jsonConf = ReflectionUtils.findField(ConnInstance.class, \"jsonConf\");\n+        jsonConf.setAccessible(true);\n+        for (ConnInstance connInstance : connInstanceDAO.findAll()) {\n+            LOG.info(\"Upgrading connInstance {} jsonConf\", connInstance);\n+            try {\n+                final String oldConf = (String) jsonConf.get(connInstance);\n+                connInstance.setConfiguration(XMLDeserializer.<HashSet<ConnConfProperty>>deserialize(oldConf));\n+            } catch (Exception e) {\n+                LOG.error(\"While upgrading connInstance {}\", connInstance, e);\n+                continueUpgrade = false;\n+                throw e;\n+            }\n+        }\n+    }\n+\n+    private void upgradePolicy() throws Exception {\n+        LOG.info(\"Upgrading Policy table...\");\n+        final Field specification = ReflectionUtils.findField(Policy.class, \"specification\");\n+        specification.setAccessible(true);\n+        for (Policy policy : policyDAO.findAll()) {\n+            LOG.info(\"Upgrading policy {} specification\", policy.getDescription());\n+            try {\n+                final String oldConf = (String) specification.get(policy);\n+                policy.setSpecification(XMLDeserializer.<AbstractPolicySpec>deserialize(oldConf));\n+            } catch (Exception e) {\n+                LOG.error(\"While upgrading policy {}\", policy, e);\n+                continueUpgrade = false;\n+                throw e;\n+            }\n+        }\n+    }\n+\n+    private void upgradeSyncTask() throws Exception {\n+        LOG.info(\"Upgrading Task table (sync tasks)...\");\n+        final Field userTemplate = ReflectionUtils.findField(SyncTask.class, \"userTemplate\");\n+        userTemplate.setAccessible(true);\n+        final Field roleTemplate = ReflectionUtils.findField(SyncTask.class, \"roleTemplate\");\n+        roleTemplate.setAccessible(true);\n+        for (SyncTask task : taskDAO.findAll(SyncTask.class)) {\n+            try {\n+                LOG.info(\"Upgrading syncTask {} userTemplate\", task.getName());\n+                final String oldUserTemplate = (String) userTemplate.get(task);\n+                final String oldRoleTemplate = (String) roleTemplate.get(task);\n+                if (oldUserTemplate != null) {\n+                    task.setUserTemplate(XMLDeserializer.<UserTO>deserialize(oldUserTemplate));\n+                }\n+                if (oldRoleTemplate != null) {\n+                    LOG.info(\"Upgrading syncTask {} roleTemplate\", task.getName());\n+                    task.setRoleTemplate(XMLDeserializer.<RoleTO>deserialize(oldRoleTemplate));\n+                }\n+            } catch (Exception e) {\n+                LOG.error(\"While upgrading syncTask {}\", task, e);\n+                continueUpgrade = false;\n+                throw e;\n+            }\n+        }\n+    }\n+\n+    private void updgradePropagationTask() throws Exception {\n+        LOG.info(\"Upgrading Task table (propagation tasks)...\");\n+        final Field xmlAttributes = ReflectionUtils.findField(PropagationTask.class, \"xmlAttributes\");\n+        xmlAttributes.setAccessible(true);\n+        for (PropagationTask task : taskDAO.findAll(PropagationTask.class)) {\n+            try {\n+                final String oldXmlAttr = (String) xmlAttributes.get(task);\n+                if (StringUtils.isNotBlank(oldXmlAttr)) {\n+                    LOG.info(\"Upgrading propagationTask {} xmlAttributes\", task.getId());\n+                    task.setAttributes(XMLDeserializer.<HashSet<Attribute>>deserialize(oldXmlAttr));\n+                }\n+            } catch (Exception e) {\n+                LOG.error(\"While upgrading propagationTask {}\", task, e);\n+                continueUpgrade = false;\n+                throw e;\n+            }\n+        }\n+    }\n+\n+    private void upgradeReportletConf() {\n+        LOG.info(\"Upgrading ReportletConf table...\");\n+        try {\n+            final List<Map<String, Object>> reportletConfs = jdbcTemplate.queryForList(\n+                    \"SELECT id, serializedInstance FROM ReportletConfInstance\");\n+            for (Map<String, Object> row : reportletConfs) {\n+                final String serializedInstance = (String) row.get(\"serializedInstance\");\n+                if (StringUtils.isNotBlank(serializedInstance)) {\n+                    LOG.info(\"Upgrading ReportletConf {} serializedInstance\", row.get(\"id\"));\n+                    final UserReportletConf set = XMLDeserializer.<UserReportletConf>deserialize(serializedInstance);\n+                    final String newSerializedInst = POJOHelper.serialize(set);\n+                    jdbcTemplate.update(\"UPDATE ReportletConfInstance set serializedInstance = ? WHERE id = ?\",\n+                            new Object[] { newSerializedInst, row.get(\"id\") });\n+                }\n+            }\n+        } catch (DataAccessException e) {\n+            LOG.error(\"Error accessing ReportletConfInstance table\", e);\n+            continueUpgrade = false;\n+            throw e;\n+        }\n+    }\n+\n+    private void upgradeSyncopeConf() {\n+        LOG.info(\"Upgrading SyncopeConf table...\");\n+        // get old syncope configuration from provisional table created ad hoc\n+        final Map<String, String> syncopeConf = new HashMap<String, String>();\n+        try {\n+            final List<Map<String, Object>> syncopeConfs = jdbcTemplate.queryForList(\n+                    \"SELECT * FROM SyncopeConf_temp\");\n+\n+            for (Map<String, Object> row : syncopeConfs) {\n+                final String confKey = (String) row.get(\"confKey\");\n+                if (StringUtils.isNotBlank(confKey) && !SyncopeDefParams.contains(confKey)) {\n+                    syncopeConf.put(confKey, (String) row.get(\"confValue\"));\n+                }\n+            }\n+\n+            // delete provisional table\n+            jdbcTemplate.update(\"DROP TABLE SyncopeConf_temp;\");\n+\n+        } catch (DataAccessException e) {\n+            LOG.error(\"Error accessing SyncopeConf table\", e);\n+            continueUpgrade = false;\n+            throw e;\n+        }\n+\n+        // save new, well-formed SyncopeConf and associated CSchema, CAttr and CAttrValue\n+        for (Map.Entry<String, String> entry : syncopeConf.entrySet()) {\n+            final String key = entry.getKey();\n+            final String value = entry.getValue();\n+            // 1. create CSChema\n+            CSchema confSchema = new CSchema();\n+            confSchema.setName(key);\n+            confSchema.setType(AttributeSchemaType.String);\n+            confSchema.setMultivalue(value.contains(\"|\"));\n+            confSchema.setUniqueConstraint(false);\n+            confSchema.setReadonly(false);\n+            confSchema = schemaDAO.save(confSchema);\n+            // 2. create and save CAttr\n+            final CAttr confAttr = new CAttr();\n+            confAttr.setSchema(confSchema);\n+            confAttr.setOwner(confDAO.get());\n+            if (confSchema.isMultivalue()) {\n+                for (String singleValue : value.split(\"|\")) {\n+                    confAttr.addValue(singleValue, AttributableUtil.getInstance(AttributableType.CONFIGURATION));\n+                }\n+            } else {\n+                confAttr.addValue(value, AttributableUtil.getInstance(AttributableType.CONFIGURATION));\n+            }\n+            confDAO.save(confAttr);\n+        }\n+    }\n+\n+    private void upgradeWorkflow() {\n+        try {\n+            LOG.info(\"Upgrading workflow version...\");\n+            final byte[] userWorkflowBytes = IOUtils.toString(userWorkflowXML.getResource().getInputStream()).getBytes();\n+\n+            // delete old workflow version if needed, Activiti 5.15.1 workflow referred to Syncope 1.1.X\n+            if (deleteOldWorkflow) {\n+                jdbcTemplate.update(\"DELETE FROM ACT_GE_BYTEARRAY WHERE NAME_ = ?;\",\n+                        ActivitiUserWorkflowAdapter.WF_PROCESS_RESOURCE);\n+            }\n+            if (userWorkflowBytes != null && userWorkflowBytes.length > 0) {\n+                // write default workflow value to database\n+                LOG.info(\"Importing default workflow for Syncope 1.2.X\");\n+\n+                importUtils.fromXML(userWorkflowBytes);\n+\n+                // add activiti model to database\n+                final Model model = repositoryService.newModel();\n+\n+                final ProcessDefinition processDefinition = repositoryService.createProcessDefinitionQuery().\n+                        processDefinitionKey(ActivitiUserWorkflowAdapter.WF_PROCESS_ID).latestVersion().singleResult();\n+\n+                model.setDeploymentId(processDefinition.getDeploymentId());\n+                model.setName(\"User Workflow\");\n+                model.setVersion(1);\n+                model.setMetaInfo(\"{\\\"name\\\":\\\"User Workflow\\\",\\\"revision\\\":2,\\\"description\\\":null}\");\n+                repositoryService.saveModel(model);\n+\n+                repositoryService.addModelEditorSource(repositoryService.createModelQuery().deploymentId(\n+                        processDefinition.getDeploymentId()).singleResult().getId(), userWorkflowBytes);\n+\n+                // update ACT_RU_EXECUTION table and ACT_RU_TASK tables for old database users with new process \n+                // id associated to the new workflow\n+                jdbcTemplate.update(\"UPDATE ACT_RU_EXECUTION SET PROC_DEF_ID_ = ?\", processDefinition.getId());\n+                jdbcTemplate.update(\"UPDATE ACT_RU_TASK SET PROC_DEF_ID_ = ?\", processDefinition.getId());\n+            }\n+        } catch (IOException e) {\n+            LOG.error(\"Error reading file {}\", ActivitiUserWorkflowAdapter.WF_PROCESS_RESOURCE, e);\n+        } catch (DataAccessException e) {\n+            LOG.error(\"Error accessing table ACT_GE_BYTEARRAY\", e);\n+        }\n+    }\n+\n+    private void addTemplatesToRoles() {\n+        try {\n+            LOG.info(\"Adding templates to roles\");\n+            for (SyncopeRole role : roleDAO.findAll()) {\n+\n+                final List<RAttr> newRattrs = new ArrayList<RAttr>();\n+                final List<RAttrTemplate> newRattrTemplates = new ArrayList<RAttrTemplate>();\n+\n+                final List<RDerAttr> newRDerattrs = new ArrayList<RDerAttr>();\n+                final List<RDerAttrTemplate> newRDerattrTemplates = new ArrayList<RDerAttrTemplate>();\n+\n+                final List<RVirAttr> newRVirattrs = new ArrayList<RVirAttr>();\n+                final List<RVirAttrTemplate> newRVirattrTemplates = new ArrayList<RVirAttrTemplate>();\n+\n+                LOG.info(\"Adding role templates to role {}\", role);\n+\n+                //Create normal attributes templates\n+                for (AbstractAttr attr : role.getAttrs()) {\n+                    final RAttrTemplate rAttrTemplate = new RAttrTemplate();\n+                    rAttrTemplate.setOwner(role);\n+                    LOG.info(\"Creating template for role normal attribute {}\", attr);\n+                    final String schemaName = jdbcTemplate.queryForObject(\n+                            \"SELECT schema_name FROM RAttr WHERE id = ?;\", String.class, attr.getId());\n+\n+                    rAttrTemplate.setSchema(schemaDAO.find(schemaName, RSchema.class));\n+                    newRattrTemplates.add(rAttrTemplate);\n+                }\n+\n+                //Create derived attributes templates\n+                for (AbstractDerAttr derAttr : role.getDerAttrs()) {\n+                    final RDerAttrTemplate rDerattrTemplate = new RDerAttrTemplate();\n+                    rDerattrTemplate.setOwner(role);\n+                    LOG.info(\"Creating template for role derived attribute {}\", derAttr);\n+                    final String derSchemaName = jdbcTemplate.queryForObject(\n+                            \"SELECT DERIVEDSCHEMA_NAME FROM RDerAttr WHERE id = ?;\", String.class, derAttr.getId());\n+\n+                    rDerattrTemplate.setSchema(derSchemaDAO.find(derSchemaName, RDerSchema.class));\n+                    newRDerattrTemplates.add(rDerattrTemplate);\n+                }\n+\n+                //Create virtual attributes templates\n+                for (AbstractVirAttr virAttr : role.getVirAttrs()) {\n+                    final RVirAttrTemplate rVirattrTemplate = new RVirAttrTemplate();\n+                    rVirattrTemplate.setOwner(role);\n+                    LOG.info(\"Creating template for role virtual attribute {}\", virAttr);\n+                    final String virSchemaName = jdbcTemplate.queryForObject(\n+                            \"SELECT VIRTUALSCHEMA_NAME FROM RVirAttr WHERE id = ?;\", String.class, virAttr.getId());\n+                    rVirattrTemplate.setSchema(virSchemaDAO.find(virSchemaName, RVirSchema.class));\n+                    newRVirattrTemplates.add(rVirattrTemplate);\n+                }\n+                role.setAttrs(newRattrs);\n+                role.setDerAttrs(newRDerattrs);\n+                role.setVirAttrs(newRVirattrs);\n+                role.getAttrTemplates(RAttrTemplate.class).addAll(newRattrTemplates);\n+                role.getAttrTemplates(RDerAttrTemplate.class).addAll(newRDerattrTemplates);\n+                role.getAttrTemplates(RVirAttrTemplate.class).addAll(newRVirattrTemplates);\n+            }\n+        } catch (DataAccessException ex) {\n+            LOG.error(\"Error accessing RAttr table\", ex);\n+        }\n+    }\n+\n+    private void addTemplatesToRAttrs() {\n+        try {\n+            LOG.info(\"Adding templates to role attributes\");\n+            for (SyncopeRole role : roleDAO.findAll()) {\n+\n+                final List<RAttr> newRattrs = new ArrayList<RAttr>();\n+                final List<RDerAttr> newRDerattrs = new ArrayList<RDerAttr>();\n+                final List<RVirAttr> newRVirattrs = new ArrayList<RVirAttr>();\n+\n+                // add template to normal attributes\n+                for (Long attrId : jdbcTemplate.queryForList(\"SELECT id FROM RAttr WHERE OWNER_ID = ?\", Long.class,\n+                        role.getId())) {\n+                    final RAttr rAttr = attrDAO.find(attrId, RAttr.class);\n+\n+                    LOG.info(\"Adding template to role attribute {}\", rAttr);\n+\n+                    final String schemaName = jdbcTemplate.queryForObject(\n+                            \"SELECT schema_name FROM RAttr WHERE id = ?;\", String.class, attrId);\n+\n+                    rAttr.setTemplate(getTemplate(role, schemaName, RAttrTemplate.class));\n+                    newRattrs.add(rAttr);\n+                }\n+\n+                // add template to derived attributes\n+                for (Long attrId : jdbcTemplate.queryForList(\"SELECT id FROM RDerAttr WHERE OWNER_ID = ?\", Long.class,\n+                        role.getId())) {\n+                    final RDerAttr rDerAttr = derAttrDAO.find(attrId, RDerAttr.class);\n+\n+                    LOG.info(\"Adding template to role attribute {}\", rDerAttr);\n+\n+                    final String derSchemaName = jdbcTemplate.queryForObject(\n+                            \"SELECT DERIVEDSCHEMA_NAME FROM RDerAttr WHERE id = ?;\", String.class, attrId);\n+\n+                    rDerAttr.setTemplate(getTemplate(role, derSchemaName, RDerAttrTemplate.class));\n+                    newRDerattrs.add(rDerAttr);\n+                }\n+\n+                // add template to virtual attributes\n+                for (Long attrId : jdbcTemplate.queryForList(\"SELECT id FROM RVirAttr WHERE OWNER_ID = ?\", Long.class,\n+                        role.getId())) {\n+                    final RVirAttr rVirAttr = virAttrDAO.find(attrId, RVirAttr.class);\n+\n+                    LOG.info(\"Adding template to role attribute {}\", rVirAttr);\n+\n+                    final String virSchemaName = jdbcTemplate.queryForObject(\n+                            \"SELECT VIRTUALSCHEMA_NAME FROM RVirAttr WHERE id = ?;\", String.class, attrId);\n+\n+                    rVirAttr.setTemplate(getTemplate(role, virSchemaName, RVirAttrTemplate.class));\n+                    newRVirattrs.add(rVirAttr);\n+                }\n+                role.setAttrs(newRattrs);\n+                role.setDerAttrs(newRDerattrs);\n+                role.setVirAttrs(newRVirattrs);\n+            }\n+\n+            // drop obsolete columns\n+            jdbcTemplate.update(\"ALTER TABLE RAttr DROP COLUMN schema_name;\");\n+            jdbcTemplate.update(\"ALTER TABLE RDerAttr DROP COLUMN DERIVEDSCHEMA_NAME;\");\n+            jdbcTemplate.update(\"ALTER TABLE RVirAttr DROP COLUMN VIRTUALSCHEMA_NAME;\");\n+\n+        } catch (DataAccessException ex) {\n+            LOG.error(\"Error accessing RAttr or RAttrTemplate table\", ex);\n+        }\n+    }\n+\n+    private void addTemplatesToMemberships() {\n+        try {\n+            LOG.info(\"Adding templates to memberships\");\n+            for (Membership membership : membershipDAO.findAll()) {\n+\n+                final List<MAttr> newMattrs = new ArrayList<MAttr>();\n+                final List<MAttrTemplate> newMattrTemplates = new ArrayList<MAttrTemplate>();\n+\n+                final List<MDerAttr> newMDerattrs = new ArrayList<MDerAttr>();\n+                final List<MDerAttrTemplate> newMDerattrTemplates = new ArrayList<MDerAttrTemplate>();\n+\n+                final List<MVirAttr> newMVirattrs = new ArrayList<MVirAttr>();\n+                final List<MVirAttrTemplate> newMVirattrTemplates = new ArrayList<MVirAttrTemplate>();\n+\n+                LOG.info(\"Adding template to membership {}\", membership);\n+\n+                //Create normal attributes templates\n+                for (AbstractAttr attr : membership.getAttrs()) {\n+                    final MAttrTemplate mAttrTemplate = new MAttrTemplate();\n+                    mAttrTemplate.setOwner(membership.getSyncopeRole());\n+                    final String schemaName = jdbcTemplate.queryForObject(\n+                            \"SELECT schema_name FROM MAttr WHERE id = ?;\", String.class, attr.getId());\n+\n+                    mAttrTemplate.setSchema(schemaDAO.find(schemaName, MSchema.class));\n+                    newMattrTemplates.add(mAttrTemplate);\n+                }\n+\n+                //Create derived attributes templates\n+                for (AbstractDerAttr mDerAttr : membership.getDerAttrs()) {\n+                    final MDerAttrTemplate mDerattrTemplate = new MDerAttrTemplate();\n+                    mDerattrTemplate.setOwner(membership.getSyncopeRole());\n+                    final String mDerSchemaName = jdbcTemplate.queryForObject(\n+                            \"SELECT DERIVEDSCHEMA_NAME FROM MDerAttr WHERE id = ?;\", String.class, mDerAttr.getId());\n+\n+                    mDerattrTemplate.setSchema(derSchemaDAO.find(mDerSchemaName, MDerSchema.class));\n+                    newMDerattrTemplates.add(mDerattrTemplate);\n+                }\n+\n+                //Create virtual attributes templates\n+                for (AbstractVirAttr mVirAttr : membership.getVirAttrs()) {\n+                    final MVirAttrTemplate mVirattrTemplate = new MVirAttrTemplate();\n+                    mVirattrTemplate.setOwner(membership.getSyncopeRole());\n+                    final String virSchemaName = jdbcTemplate.queryForObject(\n+                            \"SELECT VIRTUALSCHEMA_NAME FROM MVirAttr WHERE id = ?;\", String.class, mVirAttr.getId());\n+\n+                    mVirattrTemplate.setSchema(virSchemaDAO.find(virSchemaName, MVirSchema.class));\n+                    newMVirattrTemplates.add(mVirattrTemplate);\n+                }\n+                membership.setAttrs(newMattrs);\n+                membership.setDerAttrs(newMDerattrs);\n+                membership.setVirAttrs(newMVirattrs);\n+                membership.getSyncopeRole().getAttrTemplates(MAttrTemplate.class).addAll(newMattrTemplates);\n+                membership.getSyncopeRole().getAttrTemplates(MDerAttrTemplate.class).addAll(newMDerattrTemplates);\n+                membership.getSyncopeRole().getAttrTemplates(MVirAttrTemplate.class).addAll(newMVirattrTemplates);\n+            }\n+        } catch (DataAccessException ex) {\n+            LOG.error(\"Error accessing MAttr, MDerAttr or MVirAttr table\", ex);\n+        }\n+    }\n+\n+    private void addTemplatesToMAttrs() {\n+        try {\n+            LOG.info(\"Adding templates to membership attributes\");\n+            for (Membership membership : membershipDAO.findAll()) {\n+\n+                final List<MAttr> newMattrs = new ArrayList<MAttr>();\n+                final List<MDerAttr> newMDerattrs = new ArrayList<MDerAttr>();\n+                final List<MVirAttr> newMVirattrs = new ArrayList<MVirAttr>();\n+\n+                // add template to normal attributes\n+                for (Long attrId : jdbcTemplate.queryForList(\"SELECT id FROM MAttr WHERE OWNER_ID = ?\", Long.class,\n+                        membership.getId())) {\n+                    final MAttr mAttr = attrDAO.find(attrId, MAttr.class);\n+\n+                    LOG.info(\"Adding template to membership normal attribute {}\", mAttr);\n+\n+                    final String schemaName = jdbcTemplate.queryForObject(\n+                            \"SELECT schema_name FROM MAttr WHERE id = ?;\", String.class, attrId);\n+\n+                    mAttr.setTemplate(getTemplate(membership, schemaName, MAttrTemplate.class));\n+                    newMattrs.add(mAttr);\n+                }\n+\n+                // add template to derived attributes\n+                for (Long attrId : jdbcTemplate.queryForList(\"SELECT id FROM MDerAttr WHERE OWNER_ID = ?\", Long.class,\n+                        membership.getId())) {\n+                    final MDerAttr mDerAttr = derAttrDAO.find(attrId, MDerAttr.class);\n+\n+                    LOG.info(\"Adding template to membership derived attribute {}\", mDerAttr);\n+\n+                    final String derSchemaName = jdbcTemplate.queryForObject(\n+                            \"SELECT DERIVEDSCHEMA_NAME FROM MDerAttr WHERE id = ?;\", String.class, attrId);\n+\n+                    mDerAttr.setTemplate(getTemplate(membership, derSchemaName, MDerAttrTemplate.class));\n+                    newMDerattrs.add(mDerAttr);\n+                }\n+\n+                // add template to virtual attributes\n+                for (Long attrId : jdbcTemplate.queryForList(\"SELECT id FROM MVirAttr WHERE OWNER_ID = ?\", Long.class,\n+                        membership.getId())) {\n+                    final MVirAttr mVirAttr = virAttrDAO.find(attrId, MVirAttr.class);\n+\n+                    LOG.info(\"Adding template to membership virtual attribute {}\", mVirAttr);\n+\n+                    final String virSchemaName = jdbcTemplate.queryForObject(\n+                            \"SELECT VIRTUALSCHEMA_NAME FROM MVirAttr WHERE id = ?;\", String.class, attrId);\n+\n+                    mVirAttr.setTemplate(getTemplate(membership, virSchemaName, MVirAttrTemplate.class));\n+                    newMVirattrs.add(mVirAttr);\n+                }\n+                membership.setAttrs(newMattrs);\n+                membership.setDerAttrs(newMDerattrs);\n+                membership.setVirAttrs(newMVirattrs);\n+            }\n+\n+            // delete obsolete columns\n+            jdbcTemplate.update(\"ALTER TABLE MAttr DROP COLUMN schema_name;\");\n+            jdbcTemplate.update(\"ALTER TABLE MDerAttr DROP COLUMN DERIVEDSCHEMA_NAME;\");\n+            jdbcTemplate.update(\"ALTER TABLE MVirAttr DROP COLUMN VIRTUALSCHEMA_NAME;\");\n+        } catch (DataAccessException ex) {\n+            LOG.error(\"Error accessing MAttr or MAttrTemplate table\", ex);\n+        }\n+    }\n+\n+    private <T extends AbstractAttrTemplate<K>, K extends AbstractSchema> T getTemplate(final Object obj,\n+            final String schemaName, final Class<T> reference) {\n+        T attrTemplate = null;\n+        for (Number number : attrTemplateDAO.findBySchemaName(schemaName, reference)) {\n+            final T attrTemplateTemp = attrTemplateDAO.find((Long) number, reference);\n+\n+            if (attrTemplateTemp.getOwner().equals(obj instanceof SyncopeRole ? (SyncopeRole) obj : ((Membership) obj).\n+                    getSyncopeRole())) {\n+                attrTemplate = attrTemplateTemp;\n+            }\n+        }\n+        return attrTemplate;\n+    }\n+}"},{"sha":"ef90ee3aa6f1dc3d743e142959646bd67cccfed0","filename":"core-upgrader/src/main/java/org/apache/syncope/upgrader/util/GuardedStringConverter.java","status":"added","additions":128,"deletions":0,"changes":128,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/727a5fa58f2b727babfd2c0b696723cf45cb0d91/core-upgrader%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fupgrader%2Futil%2FGuardedStringConverter.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/727a5fa58f2b727babfd2c0b696723cf45cb0d91/core-upgrader%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fupgrader%2Futil%2FGuardedStringConverter.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core-upgrader%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fupgrader%2Futil%2FGuardedStringConverter.java?ref=727a5fa58f2b727babfd2c0b696723cf45cb0d91","patch":"@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.upgrader.util;\n+\n+import java.lang.reflect.Field;\n+\n+import org.identityconnectors.common.Base64;\n+import org.identityconnectors.common.security.EncryptorFactory;\n+import org.identityconnectors.common.security.GuardedString;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.thoughtworks.xstream.converters.Converter;\n+import com.thoughtworks.xstream.converters.MarshallingContext;\n+import com.thoughtworks.xstream.converters.UnmarshallingContext;\n+import com.thoughtworks.xstream.io.HierarchicalStreamReader;\n+import com.thoughtworks.xstream.io.HierarchicalStreamWriter;\n+\n+/**\n+ * Help in XStream serialization of GuardedString by (de)serializing instances using the default Encryptor (which works\n+ * consistently across class loading) instead of a random Encryptor instance.\n+ *\n+ * @see XMLSerializer\n+ * @see GuardedString\n+ */\n+public class GuardedStringConverter implements Converter {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(GuardedStringConverter.class);\n+\n+    @Override\n+    public void marshal(final Object source, final HierarchicalStreamWriter writer, final MarshallingContext context) {\n+        boolean readOnly = false;\n+        try {\n+            final Field readOnlyField = GuardedString.class.getDeclaredField(\"readOnly\");\n+            readOnlyField.setAccessible(true);\n+            readOnly = readOnlyField.getBoolean(source);\n+        } catch (Exception e) {\n+            LOG.error(\"Could not get field value\", e);\n+        }\n+        writer.startNode(\"readonly\");\n+        writer.setValue(Boolean.toString(readOnly));\n+        writer.endNode();\n+\n+        boolean disposed = false;\n+        try {\n+            final Field disposedField = GuardedString.class.getDeclaredField(\"disposed\");\n+            disposedField.setAccessible(true);\n+            disposed = disposedField.getBoolean(source);\n+        } catch (Exception e) {\n+            LOG.error(\"Could not get field value\", e);\n+        }\n+        writer.startNode(\"disposed\");\n+        writer.setValue(Boolean.toString(disposed));\n+        writer.endNode();\n+\n+        writer.startNode(\"encryptedBytes\");\n+        final StringBuilder cleartext = new StringBuilder();\n+        ((GuardedString) source).access(new GuardedString.Accessor() {\n+\n+            @Override\n+            public void access(final char[] clearChars) {\n+                cleartext.append(clearChars);\n+            }\n+        });\n+        final byte[] encryptedBytes =\n+                EncryptorFactory.getInstance().getDefaultEncryptor().encrypt(cleartext.toString().getBytes());\n+        writer.setValue(Base64.encode(encryptedBytes));\n+        writer.endNode();\n+    }\n+\n+    @Override\n+    public Object unmarshal(final HierarchicalStreamReader reader, final UnmarshallingContext context) {\n+        reader.moveDown();\n+        final boolean readOnly = Boolean.valueOf(reader.getValue());\n+        reader.moveUp();\n+\n+        reader.moveDown();\n+        final boolean disposed = Boolean.valueOf(reader.getValue());\n+        reader.moveUp();\n+\n+        reader.moveDown();\n+        final byte[] encryptedBytes = Base64.decode(reader.getValue());\n+        reader.moveUp();\n+\n+        final byte[] clearBytes = EncryptorFactory.getInstance().getDefaultEncryptor().decrypt(encryptedBytes);\n+\n+        final GuardedString dest = new GuardedString(new String(clearBytes).toCharArray());\n+\n+        try {\n+            final Field readOnlyField = GuardedString.class.getDeclaredField(\"readOnly\");\n+            readOnlyField.setAccessible(true);\n+            readOnlyField.setBoolean(dest, readOnly);\n+        } catch (Exception e) {\n+            LOG.error(\"Could not set field value to {}\", readOnly, e);\n+        }\n+\n+        try {\n+            final Field readOnlyField = GuardedString.class.getDeclaredField(\"disposed\");\n+            readOnlyField.setAccessible(true);\n+            readOnlyField.setBoolean(dest, disposed);\n+        } catch (Exception e) {\n+            LOG.error(\"Could not set field value to {}\", disposed, e);\n+        }\n+\n+        return dest;\n+    }\n+\n+    @Override\n+    public boolean canConvert(final Class type) {\n+        return type.equals(GuardedString.class);\n+    }\n+}\n\\ No newline at end of file"},{"sha":"4c4f314fc872ba2d2e1db6dadef37ef7494276d2","filename":"core-upgrader/src/main/java/org/apache/syncope/upgrader/util/SyncopeDefParams.java","status":"added","additions":51,"deletions":0,"changes":51,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/727a5fa58f2b727babfd2c0b696723cf45cb0d91/core-upgrader%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fupgrader%2Futil%2FSyncopeDefParams.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/727a5fa58f2b727babfd2c0b696723cf45cb0d91/core-upgrader%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fupgrader%2Futil%2FSyncopeDefParams.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core-upgrader%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fupgrader%2Futil%2FSyncopeDefParams.java?ref=727a5fa58f2b727babfd2c0b696723cf45cb0d91","patch":"@@ -0,0 +1,51 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.upgrader.util;\n+\n+public enum SyncopeDefParams {\n+\n+    PASSWORD_CIPHER_ALGORITHM(\"password.cipher.algorithm\"),\n+    NOTIFICATION_JOB_CRON_EXPRESSION(\"notificationjob.cronExpression\"),\n+    NOTIFICATION_MAX_RETRIES(\"notification.maxRetries\"),\n+    TOKEN_LENGTH(\"token.length\"),\n+    TOKEN_EXPIRE_TIME(\"token.expireTime\"),\n+    SELF_REGISTRATION_ALLOWED(\"selfRegistration.allowed\"),\n+    AUTHENTICATION_STATUSES(\"authentication.statuses\"),\n+    LOG_LASTLOGIN_DATE(\"log.lastlogindate\");\n+\n+    private final String name;\n+\n+    SyncopeDefParams(final String name) {\n+        this.name = name;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public static boolean contains(final String param) {\n+        boolean contains = false;\n+        for (SyncopeDefParams defParam : values()) {\n+            if (defParam.getName().equals(param)) {\n+                contains = true;\n+            }\n+        }\n+        return contains;\n+    }\n+}"},{"sha":"df2a58de2092a54281c9feca806dceb1a07d4c55","filename":"core-upgrader/src/main/java/org/apache/syncope/upgrader/util/XMLDeserializer.java","status":"added","additions":52,"deletions":0,"changes":52,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/727a5fa58f2b727babfd2c0b696723cf45cb0d91/core-upgrader%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fupgrader%2Futil%2FXMLDeserializer.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/727a5fa58f2b727babfd2c0b696723cf45cb0d91/core-upgrader%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fupgrader%2Futil%2FXMLDeserializer.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core-upgrader%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fupgrader%2Futil%2FXMLDeserializer.java?ref=727a5fa58f2b727babfd2c0b696723cf45cb0d91","patch":"@@ -0,0 +1,52 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.upgrader.util;\n+\n+import com.thoughtworks.xstream.XStream;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLDecoder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Helper class for deserialization of configuration objects, empowering XStream.\n+ *\n+ * @see http://xstream.codehaus.org/\n+ */\n+public final class XMLDeserializer {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(XMLDeserializer.class);\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T extends Object> T deserialize(final String serialized) {\n+        T result = null;\n+\n+        final XStream xstream = new XStream();\n+        xstream.registerConverter(new GuardedStringConverter());\n+        try {\n+            result = (T) xstream.fromXML(URLDecoder.decode(serialized, \"UTF-8\"));\n+        } catch (UnsupportedEncodingException e) {\n+            LOG.error(\"During deserialization: Bad serialized input string\", e);\n+        }\n+        return result;\n+    }\n+\n+    private XMLDeserializer() {\n+    }\n+}\n\\ No newline at end of file"},{"sha":"2690b5cd417f875b7a46abee3fe25ad9a7acabf9","filename":"core-upgrader/src/main/resources/syncope-1.1.X-1.2.X.sql","status":"added","additions":104,"deletions":0,"changes":104,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/727a5fa58f2b727babfd2c0b696723cf45cb0d91/core-upgrader%2Fsrc%2Fmain%2Fresources%2Fsyncope-1.1.X-1.2.X.sql","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/727a5fa58f2b727babfd2c0b696723cf45cb0d91/core-upgrader%2Fsrc%2Fmain%2Fresources%2Fsyncope-1.1.X-1.2.X.sql","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core-upgrader%2Fsrc%2Fmain%2Fresources%2Fsyncope-1.1.X-1.2.X.sql?ref=727a5fa58f2b727babfd2c0b696723cf45cb0d91","patch":"@@ -0,0 +1,104 @@\n+-- Licensed to the Apache Software Foundation (ASF) under one\n+-- or more contributor license agreements.  See the NOTICE file\n+-- distributed with this work for additional information\n+-- regarding copyright ownership.  The ASF licenses this file\n+-- to you under the Apache License, Version 2.0 (the\n+-- \"License\"); you may not use this file except in compliance\n+-- with the License.  You may obtain a copy of the License at\n+\n+--  http://www.apache.org/licenses/LICENSE-2.0\n+\n+-- Unless required by applicable law or agreed to in writing,\n+-- software distributed under the License is distributed on an\n+-- \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+-- KIND, either express or implied.  See the License for the\n+-- specific language governing permissions and limitations\n+-- under the License.\n+SET FOREIGN_KEY_CHECKS = 0;\n+\n+--SYNCOPE-451 upgrade table definitions to comply with new Apache OpenJpa 2.3.0 version\n+ALTER TABLE ConnInstance_capabilities CHANGE COLUMN capabilities capabilities VARCHAR(20);\n+ALTER TABLE ExternalResource CHANGE COLUMN createTraceLevel createTraceLevel VARCHAR(20);\n+ALTER TABLE ExternalResource CHANGE COLUMN deleteTraceLevel deleteTraceLevel VARCHAR(20);\n+ALTER TABLE ExternalResource CHANGE COLUMN syncTraceLevel syncTraceLevel VARCHAR(20);\n+ALTER TABLE ExternalResource CHANGE COLUMN propagationMode propagationMode VARCHAR(20);\n+ALTER TABLE ExternalResource CHANGE COLUMN updateTraceLevel updateTraceLevel VARCHAR(20);\n+ALTER TABLE MSchema CHANGE COLUMN type type VARCHAR(20);\n+ALTER TABLE RMappingItem CHANGE COLUMN intMappingType intMappingType VARCHAR(23);\n+ALTER TABLE RMappingItem CHANGE COLUMN purpose purpose VARCHAR(20);\n+ALTER TABLE RSchema CHANGE COLUMN type type VARCHAR(20);\n+ALTER TABLE SyncopeLogger CHANGE COLUMN logLevel logLevel VARCHAR(20);\n+ALTER TABLE SyncopeLogger CHANGE COLUMN logType logType VARCHAR(20);\n+ALTER TABLE SyncopeUser CHANGE COLUMN cipherAlgorithm cipherAlgorithm VARCHAR(20);\n+ALTER TABLE UMappingItem CHANGE COLUMN intMappingType intMappingType VARCHAR(23);\n+ALTER TABLE UMappingItem CHANGE COLUMN purpose purpose VARCHAR(20);\n+ALTER TABLE USchema CHANGE COLUMN type type VARCHAR(20);\n+ALTER TABLE SyncopeUser CHANGE COLUMN password password VARCHAR(255);\n+\n+-- SYNCOPE5-524\n+alter table ExternalResource change xmlConfiguration jsonConf text;\n+alter table ConnInstance change xmlConfiguration jsonConf text;\n+\n+-- preliminary steps for upgrade of (refactored) role and membership attributes\n+alter table RAttr drop foreign key RAttr_ibfk_2;\n+alter table RDerAttr drop foreign key RDerAttr_ibfk_2;\n+alter table RVirAttr drop foreign key RVirAttr_ibfk_2;\n+\n+alter table MAttr drop foreign key MAttr_ibfk_2;\n+alter table MDerAttr drop foreign key MDerAttr_ibfk_2;\n+alter table MVirAttr drop foreign key MVirAttr_ibfk_2;\n+\n+alter table UDerAttr drop foreign key UDerAttr_ibfk_2;\n+alter table UDerAttr change DERIVEDSCHEMA_NAME DERSCHEMA_NAME VARCHAR(255);\n+ALTER TABLE UDerAttr ADD CONSTRAINT  UDerAttr_ibfk_2 FOREIGN KEY (DERSCHEMA_NAME) REFERENCES UDerSchema (name);  \n+\n+alter table UVirAttr drop foreign key UVirAttr_ibfk_2;\n+alter table UVirAttr change VIRTUALSCHEMA_NAME VIRSCHEMA_NAME VARCHAR(255);\n+ALTER TABLE UVirAttr ADD CONSTRAINT UVirAttr_ibfk_2 FOREIGN KEY (VIRSCHEMA_NAME) REFERENCES UVirSchema (name);  \n+\n+-- SYNCOPE-444, SYNCOPE-409, SYNCOPE-445\n+ALTER TABLE Notification DROP COLUMN xmlAbout;\n+ALTER TABLE Notification DROP COLUMN xmlRecipients;\n+\n+-- create a backup of SyncopeConf table into new SyncopeConf_temp table\n+create table SyncopeConf_temp (confKey varchar(255) primary key, confValue varchar(255));\n+insert into SyncopeConf_temp (confKey,confValue) select confKey,confValue from SyncopeConf;\n+\n+-- delete SyncopeConf table, it will be created and initilized respectively by OpenJpa and ContentInitializer\n+DROP TABLE SyncopeConf;\n+\n+-- delete views and indexes, they will be recreated by ContentInitializer\n+DROP VIEW user_search;\n+DROP VIEW user_search_attr;\n+DROP VIEW user_search_membership;\n+DROP VIEW user_search_resource;\n+DROP VIEW user_search_null_attr;\n+DROP VIEW user_search_role_resource;\n+DROP VIEW user_search_unique_attr;\n+DROP VIEW role_search;\n+DROP VIEW role_search_attr;\n+DROP VIEW role_search_entitlements;\n+DROP VIEW role_search_null_attr;\n+DROP VIEW role_search_resource;\n+DROP VIEW role_search_unique_attr;\n+\n+DROP INDEX UAttrValue_stringvalueIndex ON UAttrValue;\n+DROP INDEX UAttrValue_datevalueIndex ON UAttrValue; \n+DROP INDEX UAttrValue_longvalueIndex ON UAttrValue;\n+DROP INDEX UAttrValue_doublevalueIndex ON UAttrValue;\n+DROP INDEX UAttrValue_booleanvalueIndex ON UAttrValue;\n+DROP INDEX MAttrValue_stringvalueIndex ON MAttrValue;\n+DROP INDEX MAttrValue_datevalueIndex ON MAttrValue;\n+DROP INDEX MAttrValue_longvalueIndex ON MAttrValue;\n+DROP INDEX MAttrValue_doublevalueIndex ON MAttrValue;\n+DROP INDEX MAttrValue_booleanvalueIndex ON MAttrValue;\n+DROP INDEX RAttrValue_stringvalueIndex ON RAttrValue;\n+DROP INDEX RAttrValue_datevalueIndex ON RAttrValue;\n+DROP INDEX RAttrValue_longvalueIndex ON RAttrValue;\n+DROP INDEX RAttrValue_doublevalueIndex ON RAttrValue;\n+DROP INDEX RAttrValue_booleanvalueIndex ON RAttrValue;\n+DROP INDEX Task_executedIndex ON Task;\n+DROP INDEX ACT_RU_TASK_PARENT_TASK_ID_ ON ACT_RU_TASK;\n+\n+\n+SET FOREIGN_KEY_CHECKS = 1;\n\\ No newline at end of file"},{"sha":"548d901c10797f766d41c07bfca1ff609c066be1","filename":"core-upgrader/src/main/resources/upgradeContext.xml","status":"added","additions":35,"deletions":0,"changes":35,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/727a5fa58f2b727babfd2c0b696723cf45cb0d91/core-upgrader%2Fsrc%2Fmain%2Fresources%2FupgradeContext.xml","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/727a5fa58f2b727babfd2c0b696723cf45cb0d91/core-upgrader%2Fsrc%2Fmain%2Fresources%2FupgradeContext.xml","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core-upgrader%2Fsrc%2Fmain%2Fresources%2FupgradeContext.xml?ref=727a5fa58f2b727babfd2c0b696723cf45cb0d91","patch":"@@ -0,0 +1,35 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<!--\n+Licensed to the Apache Software Foundation (ASF) under one\n+or more contributor license agreements.  See the NOTICE file\n+distributed with this work for additional information\n+regarding copyright ownership.  The ASF licenses this file\n+to you under the Apache License, Version 2.0 (the\n+\"License\"); you may not use this file except in compliance\n+with the License.  You may obtain a copy of the License at\n+\n+  http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing,\n+software distributed under the License is distributed on an\n+\"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+KIND, either express or implied.  See the License for the\n+specific language governing permissions and limitations\n+under the License.\n+-->\n+<beans xmlns=\"http://www.springframework.org/schema/beans\"\n+       xmlns:context=\"http://www.springframework.org/schema/context\"\n+       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+       xmlns:util=\"http://www.springframework.org/schema/util\"\n+       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n+                           http://www.springframework.org/schema/beans/spring-beans.xsd\n+                           http://www.springframework.org/schema/context\n+                           http://www.springframework.org/schema/context/spring-context.xsd\">\n+\n+  <context:annotation-config/>\n+  <context:component-scan base-package=\"org.apache.syncope.upgrader\"/>\n+  <bean id=\"userWorkflowXML\" class=\"org.apache.syncope.core.util.ResourceWithFallbackLoader\">\n+    <property name=\"primary\" value=\"file:${conf.directory}/userWorkflow.bpmn20.xml\"/>\n+    <property name=\"fallback\" value=\"classpath:userWorkflow.bpmn20.xml\"/>\n+  </bean>\n+</beans>"},{"sha":"21decb1b3f127c5e59c789bfdb1223eec67746c3","filename":"core/src/main/resources/log4j2.xml","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/727a5fa58f2b727babfd2c0b696723cf45cb0d91/core%2Fsrc%2Fmain%2Fresources%2Flog4j2.xml","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/727a5fa58f2b727babfd2c0b696723cf45cb0d91/core%2Fsrc%2Fmain%2Fresources%2Flog4j2.xml","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fresources%2Flog4j2.xml?ref=727a5fa58f2b727babfd2c0b696723cf45cb0d91","patch":"@@ -142,7 +142,7 @@ under the License.\n     <asyncLogger name=\"org.apache.cxf\" additivity=\"false\" level=\"ERROR\">\n       <appender-ref ref=\"rest\"/>\n     </asyncLogger>\n-            \n+     \n     <logger name=\"syncope.audit\" additivity=\"false\" level=\"DEBUG\">\n       <appender-ref ref=\"audit\"/>\n     </logger>"},{"sha":"ef23f424149c8e91940749aa946d44d03e76bbbb","filename":"pom.xml","status":"modified","additions":2,"deletions":1,"changes":3,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/727a5fa58f2b727babfd2c0b696723cf45cb0d91/pom.xml","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/727a5fa58f2b727babfd2c0b696723cf45cb0d91/pom.xml","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/pom.xml?ref=727a5fa58f2b727babfd2c0b696723cf45cb0d91","patch":"@@ -408,7 +408,7 @@ under the License.\n   <dependencyManagement>\n \n     <dependencies>\n-            \n+      \n       <dependency>\n         <groupId>javax.servlet</groupId>\n         <artifactId>javax.servlet-api</artifactId>\n@@ -1624,6 +1624,7 @@ under the License.\n     <module>console</module>\n     <module>standalone</module>\n     <module>installer</module>\n+    <module>core-upgrader</module>\n     <module>deb</module>\n   </modules>\n </project>"}]}