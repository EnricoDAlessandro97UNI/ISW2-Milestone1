{"sha":"e0798eaa1c39a02db05bb517b5ceb37ac6e93bdb","node_id":"MDY6Q29tbWl0NjM2ODc5MDYyOmUwNzk4ZWFhMWMzOWEwMmRiMDViYjUxN2I1Y2ViMzdhYzZlOTNiZGI=","commit":{"author":{"name":"Colm O hEigeartaigh","email":"coheigea@apache.org","date":"2017-06-15T11:05:54Z"},"committer":{"name":"Colm O hEigeartaigh","email":"coheigea@apache.org","date":"2017-06-15T11:06:22Z"},"message":"Fixing issue with getting bytes for jwtKey + adding JWT tests","tree":{"sha":"49b2d4313214cd238cfc64387d4f6dd2ded05f85","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/git/trees/49b2d4313214cd238cfc64387d4f6dd2ded05f85"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/git/commits/e0798eaa1c39a02db05bb517b5ceb37ac6e93bdb","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/e0798eaa1c39a02db05bb517b5ceb37ac6e93bdb","html_url":"https://github.com/EnricoDAlessandro97UNI/syncope/commit/e0798eaa1c39a02db05bb517b5ceb37ac6e93bdb","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/e0798eaa1c39a02db05bb517b5ceb37ac6e93bdb/comments","author":{"login":"coheigea","id":472162,"node_id":"MDQ6VXNlcjQ3MjE2Mg==","avatar_url":"https://avatars.githubusercontent.com/u/472162?v=4","gravatar_id":"","url":"https://api.github.com/users/coheigea","html_url":"https://github.com/coheigea","followers_url":"https://api.github.com/users/coheigea/followers","following_url":"https://api.github.com/users/coheigea/following{/other_user}","gists_url":"https://api.github.com/users/coheigea/gists{/gist_id}","starred_url":"https://api.github.com/users/coheigea/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coheigea/subscriptions","organizations_url":"https://api.github.com/users/coheigea/orgs","repos_url":"https://api.github.com/users/coheigea/repos","events_url":"https://api.github.com/users/coheigea/events{/privacy}","received_events_url":"https://api.github.com/users/coheigea/received_events","type":"User","site_admin":false},"committer":{"login":"coheigea","id":472162,"node_id":"MDQ6VXNlcjQ3MjE2Mg==","avatar_url":"https://avatars.githubusercontent.com/u/472162?v=4","gravatar_id":"","url":"https://api.github.com/users/coheigea","html_url":"https://github.com/coheigea","followers_url":"https://api.github.com/users/coheigea/followers","following_url":"https://api.github.com/users/coheigea/following{/other_user}","gists_url":"https://api.github.com/users/coheigea/gists{/gist_id}","starred_url":"https://api.github.com/users/coheigea/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coheigea/subscriptions","organizations_url":"https://api.github.com/users/coheigea/orgs","repos_url":"https://api.github.com/users/coheigea/repos","events_url":"https://api.github.com/users/coheigea/events{/privacy}","received_events_url":"https://api.github.com/users/coheigea/received_events","type":"User","site_admin":false},"parents":[{"sha":"03d5364b14bb911358f8b468924e304576ff99da","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/03d5364b14bb911358f8b468924e304576ff99da","html_url":"https://github.com/EnricoDAlessandro97UNI/syncope/commit/03d5364b14bb911358f8b468924e304576ff99da"}],"stats":{"total":316,"additions":314,"deletions":2},"files":[{"sha":"2705b4250824520cdd093e5d99b76d2ae8579dc6","filename":"core/spring/src/main/resources/securityContext.xml","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/e0798eaa1c39a02db05bb517b5ceb37ac6e93bdb/core%2Fspring%2Fsrc%2Fmain%2Fresources%2FsecurityContext.xml","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/e0798eaa1c39a02db05bb517b5ceb37ac6e93bdb/core%2Fspring%2Fsrc%2Fmain%2Fresources%2FsecurityContext.xml","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fspring%2Fsrc%2Fmain%2Fresources%2FsecurityContext.xml?ref=e0798eaa1c39a02db05bb517b5ceb37ac6e93bdb","patch":"@@ -49,13 +49,13 @@ under the License.\n     <constructor-arg value=\"${jwsKey}\"/>\n   </bean>\n   <bean id=\"jwsSignatureVerifier\" class=\"org.apache.cxf.rs.security.jose.jws.HmacJwsSignatureVerifier\">\n-    <constructor-arg value=\"${jwsKey}.bytes\" index=\"0\"/>\n+    <constructor-arg value=\"#{jwsKey.getBytes()}\" index=\"0\"/>\n     <constructor-arg index=\"1\">\n       <value type=\"org.apache.cxf.rs.security.jose.jwa.SignatureAlgorithm\">HS512</value>\n     </constructor-arg>\n   </bean>\n   <bean id=\"jwsSignatureProvider\" class=\"org.apache.cxf.rs.security.jose.jws.HmacJwsSignatureProvider\">\n-    <constructor-arg value=\"${jwsKey}.bytes\" index=\"0\"/>\n+    <constructor-arg value=\"#{jwsKey.getBytes()}\" index=\"0\"/>\n     <constructor-arg index=\"1\">\n       <value type=\"org.apache.cxf.rs.security.jose.jwa.SignatureAlgorithm\">HS512</value>\n     </constructor-arg>"},{"sha":"d39ca3cf545e747f8e132b6271e16152c9d2a1db","filename":"fit/core-reference/src/test/java/org/apache/syncope/fit/AbstractITCase.java","status":"modified","additions":9,"deletions":0,"changes":9,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/e0798eaa1c39a02db05bb517b5ceb37ac6e93bdb/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2FAbstractITCase.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/e0798eaa1c39a02db05bb517b5ceb37ac6e93bdb/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2FAbstractITCase.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2FAbstractITCase.java?ref=e0798eaa1c39a02db05bb517b5ceb37ac6e93bdb","patch":"@@ -59,6 +59,7 @@\n import org.apache.syncope.common.lib.types.PatchOperation;\n import org.apache.syncope.common.lib.types.SchemaType;\n import org.apache.syncope.common.rest.api.RESTHeaders;\n+import org.apache.syncope.common.rest.api.service.AccessTokenService;\n import org.apache.syncope.common.rest.api.service.AnyObjectService;\n import org.apache.syncope.common.rest.api.service.AnyTypeClassService;\n import org.apache.syncope.common.rest.api.service.AnyTypeService;\n@@ -163,6 +164,10 @@ public abstract class AbstractITCase {\n \n     protected static String ANONYMOUS_KEY;\n \n+    protected static String JWS_KEY;\n+\n+    protected static String JWT_ISSUER;\n+\n     protected static SyncopeClientFactoryBean clientFactory;\n \n     protected static SyncopeClient adminClient;\n@@ -235,6 +240,8 @@ public static void securitySetup() {\n \n             ANONYMOUS_UNAME = props.getProperty(\"anonymousUser\");\n             ANONYMOUS_KEY = props.getProperty(\"anonymousKey\");\n+            JWS_KEY = props.getProperty(\"jwsKey\");\n+            JWT_ISSUER = props.getProperty(\"jwtIssuer\");\n         } catch (Exception e) {\n             LOG.error(\"Could not read secretKey\", e);\n         } finally {\n@@ -243,6 +250,8 @@ public static void securitySetup() {\n \n         assertNotNull(ANONYMOUS_UNAME);\n         assertNotNull(ANONYMOUS_KEY);\n+        assertNotNull(JWS_KEY);\n+        assertNotNull(JWT_ISSUER);\n     }\n \n     @BeforeClass"},{"sha":"722b8b7ed6e946a701425c9473f902db0f36c1a0","filename":"fit/core-reference/src/test/java/org/apache/syncope/fit/core/JWTITCase.java","status":"added","additions":303,"deletions":0,"changes":303,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/e0798eaa1c39a02db05bb517b5ceb37ac6e93bdb/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FJWTITCase.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/e0798eaa1c39a02db05bb517b5ceb37ac6e93bdb/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FJWTITCase.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FJWTITCase.java?ref=e0798eaa1c39a02db05bb517b5ceb37ac6e93bdb","patch":"@@ -0,0 +1,303 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.fit.core;\n+\n+import static org.junit.Assert.*;\n+\n+import java.security.AccessControlException;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.Map;\n+import java.util.UUID;\n+\n+import javax.ws.rs.core.Response;\n+import javax.xml.ws.WebServiceException;\n+\n+import org.apache.cxf.rs.security.jose.common.JoseType;\n+import org.apache.cxf.rs.security.jose.jwa.SignatureAlgorithm;\n+import org.apache.cxf.rs.security.jose.jws.HmacJwsSignatureProvider;\n+import org.apache.cxf.rs.security.jose.jws.HmacJwsSignatureVerifier;\n+import org.apache.cxf.rs.security.jose.jws.JwsHeaders;\n+import org.apache.cxf.rs.security.jose.jws.JwsJwtCompactConsumer;\n+import org.apache.cxf.rs.security.jose.jws.JwsJwtCompactProducer;\n+import org.apache.cxf.rs.security.jose.jws.JwsSignatureProvider;\n+import org.apache.cxf.rs.security.jose.jws.JwsSignatureVerifier;\n+import org.apache.cxf.rs.security.jose.jwt.JwtClaims;\n+import org.apache.cxf.rs.security.jose.jwt.JwtToken;\n+import org.apache.syncope.client.lib.SyncopeClient;\n+import org.apache.syncope.common.rest.api.RESTHeaders;\n+import org.apache.syncope.common.rest.api.service.AccessTokenService;\n+import org.apache.syncope.common.rest.api.service.UserSelfService;\n+import org.apache.syncope.fit.AbstractITCase;\n+import org.junit.Test;\n+\n+/**\n+ * Some tests for JWT Tokens\n+ */\n+public class JWTITCase extends AbstractITCase {\n+\n+    @Test\n+    public void testGetJWTToken() throws ParseException {\n+        // Get the token\n+        SyncopeClient adminClient = clientFactory.create(ADMIN_UNAME, ADMIN_PWD);\n+        AccessTokenService accessTokenService = adminClient.getService(AccessTokenService.class);\n+\n+        Response response = accessTokenService.login();\n+        String token = response.getHeaderString(RESTHeaders.TOKEN);\n+        assertNotNull(token);\n+        String expiry = response.getHeaderString(RESTHeaders.TOKEN_EXPIRE);\n+        assertNotNull(expiry);\n+\n+        // Validate the signature\n+        JwsJwtCompactConsumer consumer = new JwsJwtCompactConsumer(token);\n+        JwsSignatureVerifier jwsSignatureVerifier =\n+            new HmacJwsSignatureVerifier(JWS_KEY.getBytes(), SignatureAlgorithm.HS512);\n+        assertTrue(consumer.verifySignatureWith(jwsSignatureVerifier));\n+\n+        Date now = new Date();\n+\n+        // Verify the expiry header matches that of the token\n+        Long expiryTime = consumer.getJwtClaims().getExpiryTime();\n+        assertNotNull(expiryTime);\n+\n+        SimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ssXXX\");\n+        Date tokenDate = dateFormat.parse(dateFormat.format(new Date(expiryTime.longValue())));\n+        Date parsedDate = dateFormat.parse(expiry);\n+\n+        assertEquals(tokenDate, parsedDate);\n+        assertTrue(parsedDate.after(now));\n+\n+        // Verify issuedAt\n+        Long issuedAt = consumer.getJwtClaims().getIssuedAt();\n+        assertNotNull(issuedAt);\n+        assertTrue(new Date(issuedAt.longValue()).before(now));\n+\n+        // Validate subject + issuer\n+        assertEquals(\"admin\", consumer.getJwtClaims().getSubject());\n+        assertEquals(JWT_ISSUER, consumer.getJwtClaims().getIssuer());\n+\n+        // Verify NotBefore\n+        Long notBefore = consumer.getJwtClaims().getNotBefore();\n+        assertNotNull(notBefore);\n+        assertTrue(new Date(notBefore.longValue()).before(now));\n+    }\n+\n+    @Test\n+    public void testQueryUsingToken() throws ParseException {\n+        // Get the token\n+        SyncopeClient adminClient = clientFactory.create(ADMIN_UNAME, ADMIN_PWD);\n+        AccessTokenService accessTokenService = adminClient.getService(AccessTokenService.class);\n+\n+        Response response = accessTokenService.login();\n+        String token = response.getHeaderString(RESTHeaders.TOKEN);\n+        assertNotNull(token);\n+\n+        // Query the UserSelfService using the token\n+        SyncopeClient jwtClient = clientFactory.create(token);\n+        UserSelfService jwtUserSelfService = jwtClient.getService(UserSelfService.class);\n+        jwtUserSelfService.read();\n+\n+        // Test a \"bad\" token\n+        jwtClient = clientFactory.create(token + \"xyz\");\n+        jwtUserSelfService = jwtClient.getService(UserSelfService.class);\n+        try {\n+            jwtUserSelfService.read();\n+            fail(\"Failure expected on a modified token\");\n+        } catch (WebServiceException ex) {\n+            // expected\n+        }\n+    }\n+\n+    @Test\n+    public void testTokenValidation() throws ParseException {\n+        // Get an initial token\n+        SyncopeClient adminClient = clientFactory.create(ADMIN_UNAME, ADMIN_PWD);\n+        AccessTokenService accessTokenService = adminClient.getService(AccessTokenService.class);\n+\n+        Response response = accessTokenService.login();\n+        String token = response.getHeaderString(RESTHeaders.TOKEN);\n+        assertNotNull(token);\n+        JwsJwtCompactConsumer consumer = new JwsJwtCompactConsumer(token);\n+        String tokenId = consumer.getJwtClaims().getTokenId();\n+\n+        // Create a new token using the Id of the first token\n+        Date now = new Date();\n+\n+        Calendar expiry = Calendar.getInstance();\n+        expiry.setTime(now);\n+        expiry.add(Calendar.MINUTE, 5);\n+\n+        JwtClaims jwtClaims = new JwtClaims();\n+        jwtClaims.setTokenId(tokenId);\n+        jwtClaims.setSubject(\"admin\");\n+        jwtClaims.setIssuedAt(now.getTime());\n+        jwtClaims.setIssuer(JWT_ISSUER);\n+        jwtClaims.setExpiryTime(expiry.getTime().getTime());\n+        jwtClaims.setNotBefore(now.getTime());\n+\n+        JwsHeaders jwsHeaders = new JwsHeaders(JoseType.JWT, SignatureAlgorithm.HS512);\n+        JwtToken jwtToken = new JwtToken(jwsHeaders, jwtClaims);\n+        JwsJwtCompactProducer producer = new JwsJwtCompactProducer(jwtToken);\n+\n+        JwsSignatureProvider jwsSignatureProvider =\n+            new HmacJwsSignatureProvider(JWS_KEY.getBytes(), SignatureAlgorithm.HS512);\n+        String signed = producer.signWith(jwsSignatureProvider);\n+\n+        SyncopeClient jwtClient = clientFactory.create(signed);\n+        UserSelfService jwtUserSelfService = jwtClient.getService(UserSelfService.class);\n+        jwtUserSelfService.read();\n+    }\n+\n+    @Test\n+    public void testInvalidIssuer() throws ParseException {\n+        // Get an initial token\n+        SyncopeClient adminClient = clientFactory.create(ADMIN_UNAME, ADMIN_PWD);\n+        AccessTokenService accessTokenService = adminClient.getService(AccessTokenService.class);\n+\n+        Response response = accessTokenService.login();\n+        String token = response.getHeaderString(RESTHeaders.TOKEN);\n+        assertNotNull(token);\n+        JwsJwtCompactConsumer consumer = new JwsJwtCompactConsumer(token);\n+        String tokenId = consumer.getJwtClaims().getTokenId();\n+\n+        // Create a new token using the Id of the first token\n+        Date now = new Date();\n+\n+        Calendar expiry = Calendar.getInstance();\n+        expiry.setTime(now);\n+        expiry.add(Calendar.MINUTE, 5);\n+\n+        JwtClaims jwtClaims = new JwtClaims();\n+        jwtClaims.setTokenId(tokenId);\n+        jwtClaims.setSubject(\"admin\");\n+        jwtClaims.setIssuedAt(now.getTime());\n+        jwtClaims.setIssuer(\"UnknownIssuer\");\n+        jwtClaims.setExpiryTime(expiry.getTime().getTime());\n+        jwtClaims.setNotBefore(now.getTime());\n+\n+        JwsHeaders jwsHeaders = new JwsHeaders(JoseType.JWT, SignatureAlgorithm.HS512);\n+        JwtToken jwtToken = new JwtToken(jwsHeaders, jwtClaims);\n+        JwsJwtCompactProducer producer = new JwsJwtCompactProducer(jwtToken);\n+\n+        JwsSignatureProvider jwsSignatureProvider =\n+            new HmacJwsSignatureProvider(JWS_KEY.getBytes(), SignatureAlgorithm.HS512);\n+        String signed = producer.signWith(jwsSignatureProvider);\n+\n+        SyncopeClient jwtClient = clientFactory.create(signed);\n+        UserSelfService jwtUserSelfService = jwtClient.getService(UserSelfService.class);\n+        try {\n+            jwtUserSelfService.read();\n+            fail(\"Failure expected on an invalid issuer\");\n+        } catch (AccessControlException ex) {\n+            // expected\n+        }\n+    }\n+\n+    @Test\n+    public void testExpiredToken() throws ParseException {\n+        // Get an initial token\n+        SyncopeClient adminClient = clientFactory.create(ADMIN_UNAME, ADMIN_PWD);\n+        AccessTokenService accessTokenService = adminClient.getService(AccessTokenService.class);\n+\n+        Response response = accessTokenService.login();\n+        String token = response.getHeaderString(RESTHeaders.TOKEN);\n+        assertNotNull(token);\n+        JwsJwtCompactConsumer consumer = new JwsJwtCompactConsumer(token);\n+        String tokenId = consumer.getJwtClaims().getTokenId();\n+\n+        // Create a new token using the Id of the first token\n+        Date now = new Date();\n+\n+        Calendar expiry = Calendar.getInstance();\n+        expiry.setTime(now);\n+        expiry.add(Calendar.MINUTE, 5);\n+\n+        JwtClaims jwtClaims = new JwtClaims();\n+        jwtClaims.setTokenId(tokenId);\n+        jwtClaims.setSubject(\"admin\");\n+        jwtClaims.setIssuedAt(now.getTime());\n+        jwtClaims.setIssuer(JWT_ISSUER);\n+        jwtClaims.setExpiryTime(now.getTime() - 5000L);\n+        jwtClaims.setNotBefore(now.getTime());\n+\n+        JwsHeaders jwsHeaders = new JwsHeaders(JoseType.JWT, SignatureAlgorithm.HS512);\n+        JwtToken jwtToken = new JwtToken(jwsHeaders, jwtClaims);\n+        JwsJwtCompactProducer producer = new JwsJwtCompactProducer(jwtToken);\n+\n+        JwsSignatureProvider jwsSignatureProvider =\n+            new HmacJwsSignatureProvider(JWS_KEY.getBytes(), SignatureAlgorithm.HS512);\n+        String signed = producer.signWith(jwsSignatureProvider);\n+\n+        SyncopeClient jwtClient = clientFactory.create(signed);\n+        UserSelfService jwtUserSelfService = jwtClient.getService(UserSelfService.class);\n+        try {\n+            jwtUserSelfService.read();\n+            fail(\"Failure expected on an expired token\");\n+        } catch (AccessControlException ex) {\n+            // expected\n+        }\n+    }\n+\n+    @Test\n+    public void testNotBefore() throws ParseException {\n+        // Get an initial token\n+        SyncopeClient adminClient = clientFactory.create(ADMIN_UNAME, ADMIN_PWD);\n+        AccessTokenService accessTokenService = adminClient.getService(AccessTokenService.class);\n+\n+        Response response = accessTokenService.login();\n+        String token = response.getHeaderString(RESTHeaders.TOKEN);\n+        assertNotNull(token);\n+        JwsJwtCompactConsumer consumer = new JwsJwtCompactConsumer(token);\n+        String tokenId = consumer.getJwtClaims().getTokenId();\n+\n+        // Create a new token using the Id of the first token\n+        Date now = new Date();\n+\n+        Calendar expiry = Calendar.getInstance();\n+        expiry.setTime(now);\n+        expiry.add(Calendar.MINUTE, 5);\n+\n+        JwtClaims jwtClaims = new JwtClaims();\n+        jwtClaims.setTokenId(tokenId);\n+        jwtClaims.setSubject(\"admin\");\n+        jwtClaims.setIssuedAt(now.getTime());\n+        jwtClaims.setIssuer(JWT_ISSUER);\n+        jwtClaims.setExpiryTime(expiry.getTime().getTime());\n+        jwtClaims.setNotBefore(now.getTime() + 60000L);\n+\n+        JwsHeaders jwsHeaders = new JwsHeaders(JoseType.JWT, SignatureAlgorithm.HS512);\n+        JwtToken jwtToken = new JwtToken(jwsHeaders, jwtClaims);\n+        JwsJwtCompactProducer producer = new JwsJwtCompactProducer(jwtToken);\n+\n+        JwsSignatureProvider jwsSignatureProvider =\n+            new HmacJwsSignatureProvider(JWS_KEY.getBytes(), SignatureAlgorithm.HS512);\n+        String signed = producer.signWith(jwsSignatureProvider);\n+\n+        SyncopeClient jwtClient = clientFactory.create(signed);\n+        UserSelfService jwtUserSelfService = jwtClient.getService(UserSelfService.class);\n+        try {\n+            jwtUserSelfService.read();\n+            fail(\"Failure expected on a token that is not valid yet\");\n+        } catch (AccessControlException ex) {\n+            // expected\n+        }\n+    }\n+}"}]}