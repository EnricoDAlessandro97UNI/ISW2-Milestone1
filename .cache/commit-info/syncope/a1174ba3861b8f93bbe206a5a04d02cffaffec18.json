{"sha":"a1174ba3861b8f93bbe206a5a04d02cffaffec18","node_id":"MDY6Q29tbWl0NjM2ODc5MDYyOmExMTc0YmEzODYxYjhmOTNiYmUyMDZhNWEwNGQwMmNmZmFmZmVjMTg=","commit":{"author":{"name":"Francesco Chicchiriccò","email":"ilgrosso@apache.org","date":"2013-04-03T13:24:54Z"},"committer":{"name":"Francesco Chicchiriccò","email":"ilgrosso@apache.org","date":"2013-04-03T13:24:54Z"},"message":"Merge from 1_0_X + refactoring content import / export for using Spring's JdbcTemplate instead of plain java.sql classes\n\ngit-svn-id: https://svn.apache.org/repos/asf/syncope/trunk@1463998 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"bf03347a2739a39f189d0851f89ede70a644fcd5","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/git/trees/bf03347a2739a39f189d0851f89ede70a644fcd5"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/git/commits/a1174ba3861b8f93bbe206a5a04d02cffaffec18","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/a1174ba3861b8f93bbe206a5a04d02cffaffec18","html_url":"https://github.com/EnricoDAlessandro97UNI/syncope/commit/a1174ba3861b8f93bbe206a5a04d02cffaffec18","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/a1174ba3861b8f93bbe206a5a04d02cffaffec18/comments","author":{"login":"ilgrosso","id":1064664,"node_id":"MDQ6VXNlcjEwNjQ2NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/1064664?v=4","gravatar_id":"","url":"https://api.github.com/users/ilgrosso","html_url":"https://github.com/ilgrosso","followers_url":"https://api.github.com/users/ilgrosso/followers","following_url":"https://api.github.com/users/ilgrosso/following{/other_user}","gists_url":"https://api.github.com/users/ilgrosso/gists{/gist_id}","starred_url":"https://api.github.com/users/ilgrosso/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ilgrosso/subscriptions","organizations_url":"https://api.github.com/users/ilgrosso/orgs","repos_url":"https://api.github.com/users/ilgrosso/repos","events_url":"https://api.github.com/users/ilgrosso/events{/privacy}","received_events_url":"https://api.github.com/users/ilgrosso/received_events","type":"User","site_admin":false},"committer":{"login":"ilgrosso","id":1064664,"node_id":"MDQ6VXNlcjEwNjQ2NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/1064664?v=4","gravatar_id":"","url":"https://api.github.com/users/ilgrosso","html_url":"https://github.com/ilgrosso","followers_url":"https://api.github.com/users/ilgrosso/followers","following_url":"https://api.github.com/users/ilgrosso/following{/other_user}","gists_url":"https://api.github.com/users/ilgrosso/gists{/gist_id}","starred_url":"https://api.github.com/users/ilgrosso/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ilgrosso/subscriptions","organizations_url":"https://api.github.com/users/ilgrosso/orgs","repos_url":"https://api.github.com/users/ilgrosso/repos","events_url":"https://api.github.com/users/ilgrosso/events{/privacy}","received_events_url":"https://api.github.com/users/ilgrosso/received_events","type":"User","site_admin":false},"parents":[{"sha":"991fb8a16f2dd538e404dbef7658aae5a17a3329","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/991fb8a16f2dd538e404dbef7658aae5a17a3329","html_url":"https://github.com/EnricoDAlessandro97UNI/syncope/commit/991fb8a16f2dd538e404dbef7658aae5a17a3329"}],"stats":{"total":929,"additions":396,"deletions":533},"files":[{"sha":"50735c63cf5b2db34759301d6bd69cdb31733c07","filename":"core/src/main/java/org/apache/syncope/core/init/ContentUpgrader.java","status":"modified","additions":2,"deletions":6,"changes":8,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/a1174ba3861b8f93bbe206a5a04d02cffaffec18/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Finit%2FContentUpgrader.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/a1174ba3861b8f93bbe206a5a04d02cffaffec18/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Finit%2FContentUpgrader.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Finit%2FContentUpgrader.java?ref=a1174ba3861b8f93bbe206a5a04d02cffaffec18","patch":"@@ -25,7 +25,6 @@\n import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n-import javax.sql.DataSource;\n import org.apache.commons.lang.StringUtils;\n import org.apache.syncope.common.search.NodeCond;\n import org.apache.syncope.common.to.UserTO;\n@@ -63,9 +62,6 @@\n @Component\n public class ContentUpgrader extends AbstractContentDealer {\n \n-    @Autowired\n-    private DataSource dataSource;\n-\n     @Autowired\n     private ConfDAO confDAO;\n \n@@ -286,8 +282,8 @@ public void upgrade() {\n \n         Connection conn = DataSourceUtils.getConnection(dataSource);\n         try {\n-            createIndexes(conn);\n-            createViews(conn);\n+            createIndexes();\n+            createViews();\n         } finally {\n             DataSourceUtils.releaseConnection(conn, dataSource);\n             if (conn != null) {"},{"sha":"0231c74dd514d68605d76199b875f0a5f23a49f9","filename":"core/src/main/java/org/apache/syncope/core/persistence/dao/impl/AbstractContentDealer.java","status":"modified","additions":52,"deletions":58,"changes":110,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/a1174ba3861b8f93bbe206a5a04d02cffaffec18/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2Fimpl%2FAbstractContentDealer.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/a1174ba3861b8f93bbe206a5a04d02cffaffec18/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2Fimpl%2FAbstractContentDealer.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2Fimpl%2FAbstractContentDealer.java?ref=a1174ba3861b8f93bbe206a5a04d02cffaffec18","patch":"@@ -18,91 +18,85 @@\n  */\n package org.apache.syncope.core.persistence.dao.impl;\n \n-import java.io.InputStream;\n-import java.sql.Connection;\n-import java.sql.PreparedStatement;\n-import java.sql.SQLException;\n+import java.io.IOException;\n import java.util.Properties;\n-import org.apache.commons.io.IOUtils;\n+import javax.sql.DataSource;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.core.io.ClassPathResource;\n+import org.springframework.core.io.support.PropertiesLoaderUtils;\n+import org.springframework.dao.DataAccessException;\n+import org.springframework.jdbc.core.JdbcTemplate;\n \n public abstract class AbstractContentDealer {\n \n     protected static final Logger LOG = LoggerFactory.getLogger(AbstractContentDealer.class);\n \n-    private static final String VIEWS_FILE = \"/views.xml\";\n+    protected static final String ROOT_ELEMENT = \"dataset\";\n \n-    private static final String INDEXES_FILE = \"/indexes.xml\";\n+    private static final String PERSISTENCE_PROPERTIES = \"/persistence.properties\";\n \n-    protected void createIndexes(final Connection conn) {\n-        LOG.debug(\"Creating indexes\");\n+    private static final String VIEWS_XML = \"/views.xml\";\n+\n+    private static final String INDEXES_XML = \"/indexes.xml\";\n+\n+    protected static String dbSchema;\n+\n+    protected static Properties views;\n+\n+    protected static Properties indexes;\n \n-        InputStream indexesStream = null;\n-        Properties indexes = new Properties();\n+    @Autowired\n+    protected DataSource dataSource;\n+\n+    static {\n         try {\n-            indexesStream = getClass().getResourceAsStream(INDEXES_FILE);\n-            indexes.loadFromXML(indexesStream);\n-        } catch (Exception e) {\n-            throw new RuntimeException(\"Error loading properties from stream\", e);\n-        } finally {\n-            IOUtils.closeQuietly(indexesStream);\n+            Properties persistence = PropertiesLoaderUtils.loadProperties(\n+                    new ClassPathResource(PERSISTENCE_PROPERTIES));\n+            dbSchema = persistence.getProperty(\"database.schema\");\n+\n+            views = PropertiesLoaderUtils.loadProperties(new ClassPathResource(VIEWS_XML));\n+\n+            indexes = PropertiesLoaderUtils.loadProperties(new ClassPathResource(INDEXES_XML));\n+        } catch (IOException e) {\n+            LOG.error(\"Could not read one or more properties files\", e);\n         }\n+    }\n+\n+    protected void createIndexes() {\n+        LOG.debug(\"Creating indexes\");\n+\n+        JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);\n \n         for (String idx : indexes.stringPropertyNames()) {\n             LOG.debug(\"Creating index {}\", indexes.get(idx).toString());\n-            PreparedStatement statement = null;\n+\n             try {\n-                final String updateIndexed = indexes.get(idx).toString();\n-                statement = conn.prepareStatement(updateIndexed);\n-                statement.executeUpdate();\n-            } catch (SQLException e) {\n+                jdbcTemplate.execute(indexes.get(idx).toString());\n+            } catch (DataAccessException e) {\n                 LOG.error(\"Could not create index \", e);\n-            } finally {\n-                closeStatement(statement);\n             }\n         }\n+\n+        LOG.debug(\"Indexes created\");\n     }\n \n-    protected void createViews(final Connection conn) {\n+    protected void createViews() {\n         LOG.debug(\"Creating views\");\n-        InputStream viewsStream = null;\n-        try {\n-            viewsStream = getClass().getResourceAsStream(VIEWS_FILE);\n-            Properties views = new Properties();\n-            views.loadFromXML(viewsStream);\n-\n-            for (String idx : views.stringPropertyNames()) {\n-                LOG.debug(\"Creating view {}\", views.get(idx).toString());\n-                PreparedStatement statement = null;\n-                try {\n-                    final String updateViews = views.get(idx).toString().replaceAll(\"\\\\n\", \" \");\n-                    statement = conn.prepareStatement(updateViews);\n-                    statement.executeUpdate();\n-                } catch (SQLException e) {\n-                    LOG.error(\"Could not create view \", e);\n-                } finally {\n-                    if (statement != null) {\n-                        statement.close();\n-                    }\n-                }\n-            }\n \n-            LOG.debug(\"Views created, go for indexes\");\n-        } catch (Exception e) {\n-            LOG.error(\"While creating views\", e);\n-        } finally {\n-            IOUtils.closeQuietly(viewsStream);\n-        }\n-    }\n+        JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);\n+\n+        for (String idx : views.stringPropertyNames()) {\n+            LOG.debug(\"Creating view {}\", views.get(idx).toString());\n \n-    protected void closeStatement(final PreparedStatement statement) {\n-        if (statement != null) {\n             try {\n-                statement.close();\n-            } catch (SQLException e) {\n-                LOG.error(\"Error closing SQL statement\", e);\n+                jdbcTemplate.execute(views.get(idx).toString().replaceAll(\"\\\\n\", \" \"));\n+            } catch (DataAccessException e) {\n+                LOG.error(\"Could not create view \", e);\n             }\n         }\n+\n+        LOG.debug(\"Ciews created\");\n     }\n }"},{"sha":"6f87071504885788e9e45d2534c698746e3c7998","filename":"core/src/main/java/org/apache/syncope/core/persistence/dao/impl/ContentLoader.java","status":"modified","additions":22,"deletions":62,"changes":84,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/a1174ba3861b8f93bbe206a5a04d02cffaffec18/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2Fimpl%2FContentLoader.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/a1174ba3861b8f93bbe206a5a04d02cffaffec18/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2Fimpl%2FContentLoader.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2Fimpl%2FContentLoader.java?ref=a1174ba3861b8f93bbe206a5a04d02cffaffec18","patch":"@@ -18,19 +18,15 @@\n  */\n package org.apache.syncope.core.persistence.dao.impl;\n \n+import static org.apache.syncope.core.persistence.dao.impl.AbstractContentDealer.LOG;\n import java.io.InputStream;\n-import java.sql.Connection;\n-import java.sql.PreparedStatement;\n-import java.sql.ResultSet;\n-import java.sql.SQLException;\n-import javax.sql.DataSource;\n import javax.xml.parsers.SAXParser;\n import javax.xml.parsers.SAXParserFactory;\n import org.apache.commons.io.IOUtils;\n import org.apache.syncope.core.persistence.beans.SyncopeConf;\n-import org.apache.syncope.core.util.ImportExport;\n-import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.jdbc.datasource.DataSourceUtils;\n+import org.apache.syncope.core.util.ContentLoaderHandler;\n+import org.springframework.dao.DataAccessException;\n+import org.springframework.jdbc.core.JdbcTemplate;\n import org.springframework.stereotype.Component;\n import org.springframework.transaction.annotation.Transactional;\n \n@@ -40,76 +36,40 @@\n @Component\n public class ContentLoader extends AbstractContentDealer {\n \n-    @Autowired\n-    private DataSource dataSource;\n-\n-    @Autowired\n-    private ImportExport importExport;\n+    public static final String CONTENT_XML = \"content.xml\";\n \n     @Transactional\n     public void load() {\n-        Connection conn = null;\n-        try {\n-            conn = DataSourceUtils.getConnection(dataSource);\n-\n-            boolean existingData = isDataPresent(conn);\n-            if (existingData) {\n-                LOG.info(\"Data found in the database, leaving untouched\");\n-            } else {\n-                LOG.info(\"Empty database found, loading default content\");\n-\n-                loadDefaultContent();\n-                createIndexes(conn);\n-                createViews(conn);\n-            }\n-        } finally {\n-            DataSourceUtils.releaseConnection(conn, dataSource);\n-            if (conn != null) {\n-                try {\n-                    if (!conn.isClosed()) {\n-                        conn.close();\n-                    }\n-                } catch (SQLException e) {\n-                    LOG.error(\"While releasing connection\", e);\n-                }\n-            }\n-        }\n-    }\n+        JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);\n \n-    private boolean isDataPresent(final Connection conn) {\n-        PreparedStatement statement = null;\n-        ResultSet rs = null;\n+        boolean existingData;\n         try {\n-            final String queryContent = \"SELECT * FROM \" + SyncopeConf.class.getSimpleName();\n-            statement = conn.prepareStatement(\n-                    queryContent, ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_READ_ONLY);\n-            rs = statement.executeQuery();\n-            rs.last();\n-            return rs.getRow() > 0;\n-        } catch (SQLException e) {\n+            existingData = jdbcTemplate.queryForObject(\"SELECT COUNT(0) FROM \" + SyncopeConf.class.getSimpleName(),\n+                    Integer.class) > 0;\n+        } catch (DataAccessException e) {\n             LOG.error(\"Could not access to table \" + SyncopeConf.class.getSimpleName(), e);\n-            return true;\n-        } finally {\n-            if (rs != null) {\n-                try {\n-                    rs.close();\n-                } catch (SQLException e) {\n-                    LOG.error(\"While closing tables result set\", e);\n-                }\n-            }\n+            existingData = true;\n+        }\n+\n+        if (existingData) {\n+            LOG.info(\"Data found in the database, leaving untouched\");\n+        } else {\n+            LOG.info(\"Empty database found, loading default content\");\n \n-            closeStatement(statement);\n+            loadDefaultContent();\n+            createIndexes();\n+            createViews();\n         }\n     }\n \n     private void loadDefaultContent() {\n         SAXParserFactory factory = SAXParserFactory.newInstance();\n         InputStream in = null;\n         try {\n-            in = getClass().getResourceAsStream(\"/\" + ImportExport.CONTENT_FILE);\n+            in = getClass().getResourceAsStream(\"/\" + CONTENT_XML);\n \n             SAXParser parser = factory.newSAXParser();\n-            parser.parse(in, importExport);\n+            parser.parse(in, new ContentLoaderHandler(dataSource, ROOT_ELEMENT));\n             LOG.debug(\"Default content successfully loaded\");\n         } catch (Exception e) {\n             LOG.error(\"While loading default content\", e);"},{"sha":"165f79bad85811720cf54fefe5112f01c0ae0888","filename":"core/src/main/java/org/apache/syncope/core/rest/controller/ConfigurationController.java","status":"modified","additions":5,"deletions":4,"changes":9,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/a1174ba3861b8f93bbe206a5a04d02cffaffec18/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Frest%2Fcontroller%2FConfigurationController.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/a1174ba3861b8f93bbe206a5a04d02cffaffec18/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Frest%2Fcontroller%2FConfigurationController.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Frest%2Fcontroller%2FConfigurationController.java?ref=a1174ba3861b8f93bbe206a5a04d02cffaffec18","patch":"@@ -38,9 +38,10 @@\n import org.apache.syncope.core.persistence.beans.SyncopeConf;\n import org.apache.syncope.core.persistence.dao.ConfDAO;\n import org.apache.syncope.core.persistence.dao.MissingConfKeyException;\n+import org.apache.syncope.core.persistence.dao.impl.ContentLoader;\n import org.apache.syncope.core.persistence.validation.attrvalue.Validator;\n import org.apache.syncope.core.rest.data.ConfigurationDataBinder;\n-import org.apache.syncope.core.util.ImportExport;\n+import org.apache.syncope.core.util.ContentExporter;\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.core.io.Resource;\n import org.springframework.core.io.support.ResourcePatternResolver;\n@@ -67,7 +68,7 @@ public class ConfigurationController extends AbstractController {\n     private ConfigurationDataBinder binder;\n \n     @Autowired\n-    private ImportExport importExport;\n+    private ContentExporter exporter;\n \n     @Autowired\n     private ImplementationClassNamesLoader classNamesLoader;\n@@ -205,7 +206,7 @@ public ModelAndView getMailTemplates() {\n     public void dbExport(final HttpServletResponse response) {\n         response.setContentType(MediaType.TEXT_XML);\n         response.setHeader(SyncopeConstants.CONTENT_DISPOSITION_HEADER,\n-                \"attachment; filename=\" + ImportExport.CONTENT_FILE);\n+                \"attachment; filename=\" + ContentLoader.CONTENT_XML);\n         try {\n             dbExportInternal(response.getOutputStream());\n         } catch (IOException e) {\n@@ -217,7 +218,7 @@ public void dbExport(final HttpServletResponse response) {\n     @Transactional(readOnly = true)\n     public void dbExportInternal(final OutputStream os) {\n         try {\n-            importExport.export(os, wfAdapterLoader.getTablePrefix());\n+            exporter.export(os, wfAdapterLoader.getTablePrefix());\n \n             auditManager.audit(Category.configuration, ConfigurationSubCategory.dbExport, Result.success,\n                     \"Successfully exported database content\");"},{"sha":"894356782fd694f74dfbac2a660a8e4d7740a39b","filename":"core/src/main/java/org/apache/syncope/core/rest/controller/ReportController.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/a1174ba3861b8f93bbe206a5a04d02cffaffec18/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Frest%2Fcontroller%2FReportController.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/a1174ba3861b8f93bbe206a5a04d02cffaffec18/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Frest%2Fcontroller%2FReportController.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Frest%2Fcontroller%2FReportController.java?ref=a1174ba3861b8f93bbe206a5a04d02cffaffec18","patch":"@@ -262,7 +262,7 @@ public void exportExecutionResult(final HttpServletResponse response,\n         try {\n             os = response.getOutputStream();\n         } catch (IOException e) {\n-            throw new RuntimeException(\"Could not retrieve stream\", e);\n+            throw new IllegalStateException(\"Could not get output stream\", e);\n         }\n         ReportExec reportExec = getAndCheckReportExecInternal(executionId);\n "},{"sha":"c190d3d8e57c670865ad0ebe2e3df083be2dcdef","filename":"core/src/main/java/org/apache/syncope/core/services/ConfigurationServiceImpl.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/a1174ba3861b8f93bbe206a5a04d02cffaffec18/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fservices%2FConfigurationServiceImpl.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/a1174ba3861b8f93bbe206a5a04d02cffaffec18/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fservices%2FConfigurationServiceImpl.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fservices%2FConfigurationServiceImpl.java?ref=a1174ba3861b8f93bbe206a5a04d02cffaffec18","patch":"@@ -35,8 +35,8 @@\n import org.apache.syncope.common.to.MailTemplateTO;\r\n import org.apache.syncope.common.to.ValidatorTO;\r\n import org.apache.syncope.common.util.CollectionWrapper;\r\n+import org.apache.syncope.core.persistence.dao.impl.ContentLoader;\r\n import org.apache.syncope.core.rest.controller.ConfigurationController;\r\n-import org.apache.syncope.core.util.ImportExport;\r\n import org.springframework.beans.factory.annotation.Autowired;\r\n import org.springframework.stereotype.Service;\r\n \r\n@@ -69,7 +69,7 @@ public void write(final OutputStream os) throws IOException {\n         return Response.ok(sout)\r\n                 .type(MediaType.TEXT_XML)\r\n                 .header(SyncopeConstants.CONTENT_DISPOSITION_HEADER,\r\n-                \"attachment; filename=\" + ImportExport.CONTENT_FILE)\r\n+                \"attachment; filename=\" + ContentLoader.CONTENT_XML)\r\n                 .build();\r\n     }\r\n \r"},{"sha":"d1eefc8787db94659c14ed1ce36f5b31f6bec9ba","filename":"core/src/main/java/org/apache/syncope/core/util/ContentExporter.java","status":"renamed","additions":104,"deletions":311,"changes":415,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/a1174ba3861b8f93bbe206a5a04d02cffaffec18/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Futil%2FContentExporter.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/a1174ba3861b8f93bbe206a5a04d02cffaffec18/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Futil%2FContentExporter.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Futil%2FContentExporter.java?ref=a1174ba3861b8f93bbe206a5a04d02cffaffec18","patch":"@@ -30,23 +30,16 @@\n import java.sql.SQLException;\n import java.sql.Timestamp;\n import java.sql.Types;\n-import java.text.ParseException;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collections;\n import java.util.Date;\n-import java.util.HashMap;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n-import java.util.Properties;\n import java.util.Set;\n import java.util.TreeMap;\n import java.util.TreeSet;\n-import javax.persistence.EntityManager;\n-import javax.persistence.Query;\n-import javax.persistence.TemporalType;\n-import javax.sql.DataSource;\n import javax.xml.transform.OutputKeys;\n import javax.xml.transform.Transformer;\n import javax.xml.transform.TransformerConfigurationException;\n@@ -56,232 +49,165 @@\n import org.apache.commons.io.IOUtils;\n import org.apache.commons.lang.StringUtils;\n import org.apache.syncope.common.SyncopeConstants;\n+import org.apache.syncope.core.persistence.dao.impl.AbstractContentDealer;\n import org.apache.syncope.core.util.multiparent.MultiParentNode;\n import org.apache.syncope.core.util.multiparent.MultiParentNodeOp;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n-import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.jdbc.datasource.DataSourceUtils;\n import org.springframework.security.crypto.codec.Hex;\n import org.springframework.stereotype.Component;\n-import org.xml.sax.Attributes;\n import org.xml.sax.SAXException;\n import org.xml.sax.helpers.AttributesImpl;\n-import org.xml.sax.helpers.DefaultHandler;\n \n+/**\n+ * Export internal storage content as XML.\n+ */\n @Component\n-public class ImportExport extends DefaultHandler {\n-\n-    private static final Logger LOG = LoggerFactory.getLogger(ImportExport.class);\n-\n-    public static final String CONTENT_FILE = \"content.xml\";\n-\n-    private static final String ROOT_ELEMENT = \"dataset\";\n-\n-    @Autowired\n-    private EntityManager entityManager;\n+public class ContentExporter extends AbstractContentDealer {\n \n-    @Autowired\n-    private DataSource dataSource;\n-\n-    private final static Set<String> TABLE_PREFIXES_TO_BE_EXCLUDED =\n-            new HashSet<String>(Arrays.asList(new String[]{\"QRTZ_\", \"LOGGING\", \"REPORTEXEC\", \"TASKEXEC\",\n+    protected final static Set<String> TABLE_PREFIXES_TO_BE_EXCLUDED =\n+            new HashSet<String>(Arrays.asList(new String[] {\"QRTZ_\", \"LOGGING\", \"REPORTEXEC\", \"TASKEXEC\",\n         \"SYNCOPEUSER\", \"UATTR\", \"UATTRVALUE\", \"UATTRUNIQUEVALUE\", \"UDERATTR\", \"UVIRATTR\",\n         \"MEMBERSHIP\", \"MATTR\", \"MATTRVALUE\", \"MATTRUNIQUEVALUE\", \"MDERATTR\", \"MVIRATTR\", \"USERREQUEST\"}));\n \n-    private final static Map<String, String> TABLES_TO_BE_FILTERED =\n+    protected static final Map<String, String> TABLES_TO_BE_FILTERED =\n             Collections.singletonMap(\"TASK\", \"DTYPE <> 'PropagationTask'\");\n \n-    private final static Map<String, Set<String>> COLUMNS_TO_BE_NULLIFIED =\n+    protected static final Map<String, Set<String>> COLUMNS_TO_BE_NULLIFIED =\n             Collections.singletonMap(\"SYNCOPEROLE\", Collections.singleton(\"USEROWNER_ID\"));\n \n-    private String readSchema() {\n-        String schema = null;\n-\n-        InputStream dbPropsStream = null;\n-        try {\n-            dbPropsStream = getClass().getResourceAsStream(\"/persistence.properties\");\n-            Properties dbProps = new Properties();\n-            dbProps.load(dbPropsStream);\n-            schema = dbProps.getProperty(\"database.schema\");\n-        } catch (Exception e) {\n-            if (LOG.isDebugEnabled()) {\n-                LOG.debug(\"Could not find persistence.properties\", e);\n-            } else {\n-                LOG.error(\"Could not find persistence.properties\");\n+    private boolean isTableAllowed(final String tableName) {\n+        boolean allowed = true;\n+        for (String prefix : TABLE_PREFIXES_TO_BE_EXCLUDED) {\n+            if (tableName.toUpperCase().startsWith(prefix)) {\n+                allowed = false;\n             }\n-        } finally {\n-            IOUtils.closeQuietly(dbPropsStream);\n         }\n-\n-        return schema;\n+        return allowed;\n     }\n \n-    private void setParameters(final String tableName, final Attributes attrs, final Query query) {\n-        Map<String, Integer> colTypes = new HashMap<String, Integer>();\n+    private List<String> sortByForeignKeys(final Connection conn, final Set<String> tableNames)\n+            throws SQLException {\n \n-        Connection conn = null;\n-        ResultSet rs = null;\n-        PreparedStatement stmt = null;\n-        try {\n-            conn = DataSourceUtils.getConnection(dataSource);\n+        Set<MultiParentNode<String>> roots = new HashSet<MultiParentNode<String>>();\n \n-            final String queryString = \"SELECT * FROM \" + tableName;\n-            stmt = conn.prepareStatement(queryString);\n-            rs = stmt.executeQuery();\n-            for (int i = 0; i < rs.getMetaData().getColumnCount(); i++) {\n-                colTypes.put(rs.getMetaData().getColumnName(i + 1).toUpperCase(),\n-                        rs.getMetaData().getColumnType(i + 1));\n+        final DatabaseMetaData meta = conn.getMetaData();\n+\n+        final Map<String, MultiParentNode<String>> exploited =\n+                new TreeMap<String, MultiParentNode<String>>(String.CASE_INSENSITIVE_ORDER);\n+\n+        final Set<String> pkTableNames = new HashSet<String>();\n+\n+        for (String tableName : tableNames) {\n+            MultiParentNode<String> node = exploited.get(tableName);\n+            if (node == null) {\n+                node = new MultiParentNode<String>(tableName);\n+                roots.add(node);\n+                exploited.put(tableName, node);\n             }\n-        } catch (SQLException e) {\n-            LOG.error(\"While setting column types\", e);\n-        } finally {\n-            if (stmt != null) {\n-                try {\n-                    stmt.close();\n-                } catch (SQLException e) {\n-                    LOG.error(\"While closing statement\", e);\n+\n+            pkTableNames.clear();\n+\n+            ResultSet rs = null;\n+            try {\n+                rs = meta.getImportedKeys(conn.getCatalog(), dbSchema, tableName);\n+\n+                // this is to avoid repetition\n+                while (rs.next()) {\n+                    pkTableNames.add(rs.getString(\"PKTABLE_NAME\"));\n                 }\n-            }\n-            if (rs != null) {\n-                try {\n-                    rs.close();\n-                } catch (SQLException e) {\n-                    LOG.error(\"While closing result set\", e);\n+            } finally {\n+                if (rs != null) {\n+                    try {\n+                        rs.close();\n+                    } catch (SQLException e) {\n+                        LOG.error(\"While closing tables result set\", e);\n+                    }\n                 }\n             }\n \n-            DataSourceUtils.releaseConnection(conn, dataSource);\n-            if (conn != null) {\n-                try {\n-                    if (!conn.isClosed()) {\n-                        conn.close();\n+            for (String pkTableName : pkTableNames) {\n+                if (!tableName.equalsIgnoreCase(pkTableName)) {\n+                    MultiParentNode<String> pkNode = exploited.get(pkTableName);\n+                    if (pkNode == null) {\n+                        pkNode = new MultiParentNode<String>(pkTableName);\n+                        roots.add(pkNode);\n+                        exploited.put(pkTableName, pkNode);\n+                    }\n+\n+                    pkNode.addChild(node);\n+\n+                    if (roots.contains(node)) {\n+                        roots.remove(node);\n                     }\n-                } catch (SQLException e) {\n-                    LOG.error(\"While releasing connection\", e);\n                 }\n             }\n         }\n \n-        for (int i = 0; i < attrs.getLength(); i++) {\n-            Integer colType = colTypes.get(attrs.getQName(i).toUpperCase());\n-            if (colType == null) {\n-                LOG.warn(\"No column type found for {}\", attrs.getQName(i).toUpperCase());\n-                colType = Types.VARCHAR;\n-            }\n+        final List<String> sortedTableNames = new ArrayList<String>(tableNames.size());\n+        MultiParentNodeOp.traverseTree(roots, sortedTableNames);\n \n-            switch (colType) {\n-                case Types.INTEGER:\n-                case Types.TINYINT:\n-                case Types.SMALLINT:\n-                    try {\n-                        query.setParameter(i + 1, Integer.valueOf(attrs.getValue(i)));\n-                    } catch (NumberFormatException e) {\n-                        LOG.error(\"Unparsable Integer '{}'\", attrs.getValue(i));\n-                        query.setParameter(i + 1, attrs.getValue(i));\n-                    }\n-                    break;\n+        // remove from sortedTableNames any table possibly added during lookup \n+        // but matching some item in this.tablePrefixesToBeExcluded\n+        sortedTableNames.retainAll(tableNames);\n \n-                case Types.NUMERIC:\n-                case Types.DECIMAL:\n-                case Types.BIGINT:\n-                    try {\n-                        query.setParameter(i + 1, Long.valueOf(attrs.getValue(i)));\n-                    } catch (NumberFormatException e) {\n-                        LOG.error(\"Unparsable Long '{}'\", attrs.getValue(i));\n-                        query.setParameter(i + 1, attrs.getValue(i));\n-                    }\n-                    break;\n+        LOG.debug(\"Tables after retainAll {}\", sortedTableNames);\n \n-                case Types.DOUBLE:\n-                    try {\n-                        query.setParameter(i + 1, Double.valueOf(attrs.getValue(i)));\n-                    } catch (NumberFormatException e) {\n-                        LOG.error(\"Unparsable Double '{}'\", attrs.getValue(i));\n-                        query.setParameter(i + 1, attrs.getValue(i));\n-                    }\n-                    break;\n+        Collections.reverse(sortedTableNames);\n \n-                case Types.REAL:\n-                case Types.FLOAT:\n-                    try {\n-                        query.setParameter(i + 1, Float.valueOf(attrs.getValue(i)));\n-                    } catch (NumberFormatException e) {\n-                        LOG.error(\"Unparsable Float '{}'\", attrs.getValue(i));\n-                        query.setParameter(i + 1, attrs.getValue(i));\n-                    }\n-                    break;\n+        return sortedTableNames;\n+    }\n \n-                case Types.DATE:\n-                case Types.TIME:\n-                case Types.TIMESTAMP:\n-                    try {\n-                        query.setParameter(i + 1, DataFormat.parseDate(attrs.getValue(i)), TemporalType.TIMESTAMP);\n-                    } catch (ParseException e) {\n-                        LOG.error(\"Unparsable Date '{}'\", attrs.getValue(i));\n-                        query.setParameter(i + 1, attrs.getValue(i));\n-                    }\n-                    break;\n+    private String getValues(final ResultSet rs, final String columnName, final Integer columnType)\n+            throws SQLException {\n \n-                case Types.BIT:\n-                case Types.BOOLEAN:\n-                    query.setParameter(i + 1, \"1\".equals(attrs.getValue(i)) ? Boolean.TRUE : Boolean.FALSE);\n-                    break;\n+        String res = null;\n \n+        try {\n+            switch (columnType) {\n                 case Types.BINARY:\n                 case Types.VARBINARY:\n                 case Types.LONGVARBINARY:\n-                    try {\n-                        query.setParameter(i + 1, Hex.decode(attrs.getValue(i)));\n-                    } catch (IllegalArgumentException e) {\n-                        query.setParameter(i + 1, attrs.getValue(i));\n+                    final InputStream is = rs.getBinaryStream(columnName);\n+                    if (is != null) {\n+                        res = new String(Hex.encode(IOUtils.toByteArray(is)));\n                     }\n                     break;\n \n                 case Types.BLOB:\n-                    try {\n-                        query.setParameter(i + 1, Hex.decode(attrs.getValue(i)));\n-                    } catch (IllegalArgumentException e) {\n-                        LOG.warn(\"Error decoding hex string to specify a blob parameter\", e);\n-                        query.setParameter(i + 1, attrs.getValue(i));\n-                    } catch (Exception e) {\n-                        LOG.warn(\"Error creating a new blob parameter\", e);\n+                    final Blob blob = rs.getBlob(columnName);\n+                    if (blob != null) {\n+                        res = new String(Hex.encode(IOUtils.toByteArray(blob.getBinaryStream())));\n                     }\n                     break;\n \n-                default:\n-                    query.setParameter(i + 1, attrs.getValue(i));\n-            }\n-        }\n-    }\n-\n-    @Override\n-    public void startElement(final String uri, final String localName, final String qName, final Attributes atts)\n-            throws SAXException {\n-\n-        // skip root element\n-        if (ROOT_ELEMENT.equals(qName)) {\n-            return;\n-        }\n-\n-        StringBuilder queryString = new StringBuilder(\"INSERT INTO \").append(qName).append('(');\n+                case Types.BIT:\n+                case Types.BOOLEAN:\n+                    if (rs.getBoolean(columnName)) {\n+                        res = \"1\";\n+                    } else {\n+                        res = \"0\";\n+                    }\n+                    break;\n \n-        StringBuilder values = new StringBuilder();\n+                case Types.DATE:\n+                case Types.TIME:\n+                case Types.TIMESTAMP:\n+                    final Timestamp timestamp = rs.getTimestamp(columnName);\n+                    if (timestamp != null) {\n+                        res = DataFormat.format(new Date(timestamp.getTime()));\n+                    }\n+                    break;\n \n-        for (int i = 0; i < atts.getLength(); i++) {\n-            queryString.append(atts.getQName(i));\n-            values.append('?');\n-            if (i < atts.getLength() - 1) {\n-                queryString.append(',');\n-                values.append(',');\n+                default:\n+                    res = rs.getString(columnName);\n             }\n+        } catch (IOException e) {\n+            LOG.error(\"Error retrieving hexadecimal string\", e);\n         }\n-        queryString.append(\") VALUES (\").append(values).append(')');\n-\n-        Query query = entityManager.createNativeQuery(queryString.toString());\n-        setParameters(qName, atts, query);\n \n-        query.executeUpdate();\n+        return res;\n     }\n \n     private void doExportTable(final TransformerHandler handler, final Connection conn, final String tableName,\n@@ -373,88 +299,6 @@ private void doExportTable(final TransformerHandler handler, final Connection co\n         }\n     }\n \n-    private List<String> sortByForeignKeys(final Connection conn, final Set<String> tableNames)\n-            throws SQLException {\n-\n-        Set<MultiParentNode<String>> roots = new HashSet<MultiParentNode<String>>();\n-\n-        final DatabaseMetaData meta = conn.getMetaData();\n-\n-        final Map<String, MultiParentNode<String>> exploited =\n-                new TreeMap<String, MultiParentNode<String>>(String.CASE_INSENSITIVE_ORDER);\n-\n-        final Set<String> pkTableNames = new HashSet<String>();\n-\n-        for (String tableName : tableNames) {\n-            MultiParentNode<String> node = exploited.get(tableName);\n-            if (node == null) {\n-                node = new MultiParentNode<String>(tableName);\n-                roots.add(node);\n-                exploited.put(tableName, node);\n-            }\n-\n-            pkTableNames.clear();\n-\n-            ResultSet rs = null;\n-            try {\n-                rs = meta.getImportedKeys(conn.getCatalog(), readSchema(), tableName);\n-\n-                // this is to avoid repetition\n-                while (rs.next()) {\n-                    pkTableNames.add(rs.getString(\"PKTABLE_NAME\"));\n-                }\n-            } finally {\n-                if (rs != null) {\n-                    try {\n-                        rs.close();\n-                    } catch (SQLException e) {\n-                        LOG.error(\"While closing tables result set\", e);\n-                    }\n-                }\n-            }\n-\n-            for (String pkTableName : pkTableNames) {\n-                if (!tableName.equalsIgnoreCase(pkTableName)) {\n-                    MultiParentNode<String> pkNode = exploited.get(pkTableName);\n-                    if (pkNode == null) {\n-                        pkNode = new MultiParentNode<String>(pkTableName);\n-                        roots.add(pkNode);\n-                        exploited.put(pkTableName, pkNode);\n-                    }\n-\n-                    pkNode.addChild(node);\n-\n-                    if (roots.contains(node)) {\n-                        roots.remove(node);\n-                    }\n-                }\n-            }\n-        }\n-\n-        final List<String> sortedTableNames = new ArrayList<String>(tableNames.size());\n-        MultiParentNodeOp.traverseTree(roots, sortedTableNames);\n-\n-        // remove from sortedTableNames any table possibly added during lookup \n-        // but matching some item in this.tablePrefixesToBeExcluded\n-        sortedTableNames.retainAll(tableNames);\n-\n-        LOG.debug(\"Tables after retainAll {}\", sortedTableNames);\n-\n-        Collections.reverse(sortedTableNames);\n-\n-        return sortedTableNames;\n-    }\n-\n-    private boolean isTableAllowed(final String tableName) {\n-        boolean allowed = true;\n-        for (String prefix : TABLE_PREFIXES_TO_BE_EXCLUDED) {\n-            if (tableName.toUpperCase().startsWith(prefix)) {\n-                allowed = false;\n-            }\n-        }\n-        return allowed;\n-    }\n-\n     public void export(final OutputStream os, final String wfTablePrefix)\n             throws SAXException, TransformerConfigurationException {\n \n@@ -479,9 +323,9 @@ public void export(final OutputStream os, final String wfTablePrefix)\n             conn = DataSourceUtils.getConnection(dataSource);\n             final DatabaseMetaData meta = conn.getMetaData();\n \n-            final String schema = readSchema();\n+            final String schema = dbSchema;\n \n-            rs = meta.getTables(null, schema, null, new String[]{\"TABLE\"});\n+            rs = meta.getTables(null, schema, null, new String[] {\"TABLE\"});\n \n             final Set<String> tableNames = new TreeSet<String>(String.CASE_INSENSITIVE_ORDER);\n \n@@ -529,55 +373,4 @@ public void export(final OutputStream os, final String wfTablePrefix)\n         handler.endElement(\"\", \"\", ROOT_ELEMENT);\n         handler.endDocument();\n     }\n-\n-    private String getValues(final ResultSet rs, final String columnName, final Integer columnType)\n-            throws SQLException {\n-\n-        String res = null;\n-\n-        try {\n-            switch (columnType) {\n-                case Types.BINARY:\n-                case Types.VARBINARY:\n-                case Types.LONGVARBINARY:\n-                    final InputStream is = rs.getBinaryStream(columnName);\n-                    if (is != null) {\n-                        res = new String(Hex.encode(IOUtils.toByteArray(is)));\n-                    }\n-                    break;\n-\n-                case Types.BLOB:\n-                    final Blob blob = rs.getBlob(columnName);\n-                    if (blob != null) {\n-                        res = new String(Hex.encode(IOUtils.toByteArray(blob.getBinaryStream())));\n-                    }\n-                    break;\n-\n-                case Types.BIT:\n-                case Types.BOOLEAN:\n-                    if (rs.getBoolean(columnName)) {\n-                        res = \"1\";\n-                    } else {\n-                        res = \"0\";\n-                    }\n-                    break;\n-\n-                case Types.DATE:\n-                case Types.TIME:\n-                case Types.TIMESTAMP:\n-                    final Timestamp timestamp = rs.getTimestamp(columnName);\n-                    if (timestamp != null) {\n-                        res = DataFormat.format(new Date(timestamp.getTime()));\n-                    }\n-                    break;\n-\n-                default:\n-                    res = rs.getString(columnName);\n-            }\n-        } catch (IOException e) {\n-            LOG.error(\"Error retrieving hexadecimal string\", e);\n-        }\n-\n-        return res;\n-    }\n }","previous_filename":"core/src/main/java/org/apache/syncope/core/util/ImportExport.java"},{"sha":"ea54a9087a234034b6f35a5afe77020bd0f5b77f","filename":"core/src/main/java/org/apache/syncope/core/util/ContentLoaderHandler.java","status":"added","additions":197,"deletions":0,"changes":197,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/a1174ba3861b8f93bbe206a5a04d02cffaffec18/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Futil%2FContentLoaderHandler.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/a1174ba3861b8f93bbe206a5a04d02cffaffec18/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Futil%2FContentLoaderHandler.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Futil%2FContentLoaderHandler.java?ref=a1174ba3861b8f93bbe206a5a04d02cffaffec18","patch":"@@ -0,0 +1,197 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.core.util;\n+\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Types;\n+import java.text.ParseException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import javax.sql.DataSource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.dao.DataAccessException;\n+import org.springframework.jdbc.core.JdbcTemplate;\n+import org.springframework.jdbc.core.ResultSetExtractor;\n+import org.springframework.security.crypto.codec.Hex;\n+import org.xml.sax.Attributes;\n+import org.xml.sax.SAXException;\n+import org.xml.sax.helpers.DefaultHandler;\n+\n+/**\n+ * SAX handler for generating SQL INSERT statements out of given XML file.\n+ */\n+public class ContentLoaderHandler extends DefaultHandler {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(ContentLoaderHandler.class);\n+\n+    private final DataSource dataSource;\n+\n+    private final String rootElement;\n+\n+    public ContentLoaderHandler(final DataSource dataSource, final String rootElement) {\n+        this.dataSource = dataSource;\n+        this.rootElement = rootElement;\n+    }\n+\n+    private Object[] getParameters(final String tableName, final Attributes attrs) {\n+        JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);\n+\n+        Map<String, Integer> colTypes = jdbcTemplate.query(\"SELECT * FROM \" + tableName,\n+                new ResultSetExtractor<Map<String, Integer>>() {\n+\n+            @Override\n+            public Map<String, Integer> extractData(final ResultSet rs) throws SQLException, DataAccessException {\n+                Map<String, Integer> colTypes = new HashMap<String, Integer>();\n+                for (int i = 1; i <= rs.getMetaData().getColumnCount(); i++) {\n+                    colTypes.put(rs.getMetaData().getColumnName(i).toUpperCase(),\n+                            rs.getMetaData().getColumnType(i));\n+                }\n+                return colTypes;\n+            }\n+        });\n+\n+        Object[] parameters = new Object[attrs.getLength()];\n+        for (int i = 0; i < attrs.getLength(); i++) {\n+            Integer colType = colTypes.get(attrs.getQName(i).toUpperCase());\n+            if (colType == null) {\n+                LOG.warn(\"No column type found for {}\", attrs.getQName(i).toUpperCase());\n+                colType = Types.VARCHAR;\n+            }\n+\n+            switch (colType) {\n+                case Types.INTEGER:\n+                case Types.TINYINT:\n+                case Types.SMALLINT:\n+                    try {\n+                        parameters[i] = Integer.valueOf(attrs.getValue(i));\n+                    } catch (NumberFormatException e) {\n+                        LOG.error(\"Unparsable Integer '{}'\", attrs.getValue(i));\n+                        parameters[i] = attrs.getValue(i);\n+                    }\n+                    break;\n+\n+                case Types.NUMERIC:\n+                case Types.DECIMAL:\n+                case Types.BIGINT:\n+                    try {\n+                        parameters[i] = Long.valueOf(attrs.getValue(i));\n+                    } catch (NumberFormatException e) {\n+                        LOG.error(\"Unparsable Long '{}'\", attrs.getValue(i));\n+                        parameters[i] = attrs.getValue(i);\n+                    }\n+                    break;\n+\n+                case Types.DOUBLE:\n+                    try {\n+                        parameters[i] = Double.valueOf(attrs.getValue(i));\n+                    } catch (NumberFormatException e) {\n+                        LOG.error(\"Unparsable Double '{}'\", attrs.getValue(i));\n+                        parameters[i] = attrs.getValue(i);\n+                    }\n+                    break;\n+\n+                case Types.REAL:\n+                case Types.FLOAT:\n+                    try {\n+                        parameters[i] = Float.valueOf(attrs.getValue(i));\n+                    } catch (NumberFormatException e) {\n+                        LOG.error(\"Unparsable Float '{}'\", attrs.getValue(i));\n+                        parameters[i] = attrs.getValue(i);\n+                    }\n+                    break;\n+\n+                case Types.DATE:\n+                case Types.TIME:\n+                case Types.TIMESTAMP:\n+                    try {\n+                        parameters[i] = DataFormat.parseDate(attrs.getValue(i));\n+                    } catch (ParseException e) {\n+                        LOG.error(\"Unparsable Date '{}'\", attrs.getValue(i));\n+                        parameters[i] = attrs.getValue(i);\n+                    }\n+                    break;\n+\n+                case Types.BIT:\n+                case Types.BOOLEAN:\n+                    parameters[i] = \"1\".equals(attrs.getValue(i)) ? Boolean.TRUE : Boolean.FALSE;\n+                    break;\n+\n+                case Types.BINARY:\n+                case Types.VARBINARY:\n+                case Types.LONGVARBINARY:\n+                    try {\n+                        parameters[i] = Hex.decode(attrs.getValue(i));\n+                    } catch (IllegalArgumentException e) {\n+                        parameters[i] = attrs.getValue(i);\n+                    }\n+                    break;\n+\n+                case Types.BLOB:\n+                    try {\n+                        parameters[i] = Hex.decode(attrs.getValue(i));\n+                    } catch (IllegalArgumentException e) {\n+                        LOG.warn(\"Error decoding hex string to specify a blob parameter\", e);\n+                        parameters[i] = attrs.getValue(i);\n+                    } catch (Exception e) {\n+                        LOG.warn(\"Error creating a new blob parameter\", e);\n+                    }\n+                    break;\n+\n+                default:\n+                    parameters[i] = attrs.getValue(i);\n+            }\n+        }\n+\n+        return parameters;\n+    }\n+\n+    @Override\n+    public void startElement(final String uri, final String localName, final String qName, final Attributes atts)\n+            throws SAXException {\n+\n+        // skip root element\n+        if (rootElement.equals(qName)) {\n+            return;\n+        }\n+\n+        StringBuilder query = new StringBuilder(\"INSERT INTO \").append(qName).append('(');\n+\n+        StringBuilder values = new StringBuilder();\n+\n+        for (int i = 0; i < atts.getLength(); i++) {\n+            query.append(atts.getQName(i));\n+            values.append('?');\n+            if (i < atts.getLength() - 1) {\n+                query.append(',');\n+                values.append(',');\n+            }\n+        }\n+        query.append(\") VALUES (\").append(values).append(')');\n+\n+        JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);\n+\n+        try {\n+            jdbcTemplate.update(query.toString(), getParameters(qName, atts));\n+        } catch (DataAccessException e) {\n+            LOG.error(\"While trying to perform {}\", query, e);\n+        }\n+    }\n+}"},{"sha":"1f828e2a01b12707d4ddd51bd3aaafa6f1a203cc","filename":"core/src/main/java/org/apache/syncope/core/util/MappingUtil.java","status":"modified","additions":4,"deletions":3,"changes":7,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/a1174ba3861b8f93bbe206a5a04d02cffaffec18/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Futil%2FMappingUtil.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/a1174ba3861b8f93bbe206a5a04d02cffaffec18/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Futil%2FMappingUtil.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Futil%2FMappingUtil.java?ref=a1174ba3861b8f93bbe206a5a04d02cffaffec18","patch":"@@ -364,12 +364,13 @@ public static List<AbstractAttrValue> getIntValues(final ExternalResource resour\n                         }\n                         if (vAttrsToBeRemoved != null && vAttrsToBeUpdated != null) {\n                             if (vAttrsToBeUpdated.containsKey(mappingItem.getIntAttrName())) {\n-                                virAttr.setValues(vAttrsToBeUpdated.get(mappingItem.getIntAttrName()).\n-                                        getValuesToBeAdded());\n+                                virAttr.setValues(\n+                                        vAttrsToBeUpdated.get(mappingItem.getIntAttrName()).getValuesToBeAdded());\n                             } else if (vAttrsToBeRemoved.contains(mappingItem.getIntAttrName())) {\n                                 virAttr.getValues().clear();\n                             } else {\n-                                throw new RuntimeException(\"Virtual attribute has not to be updated\");\n+                                throw new IllegalArgumentException(\"Don't need to update virtual attribute '\"\n+                                        + mappingItem.getIntAttrName() + \"'\");\n                             }\n                         }\n                     }"},{"sha":"eb7eff5033e57ba71267dfd6fe57621ffb7082ae","filename":"core/src/main/java/org/apache/syncope/core/util/SpringPersistenceUnitPostProcessor.java","status":"removed","additions":0,"deletions":80,"changes":80,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/991fb8a16f2dd538e404dbef7658aae5a17a3329/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Futil%2FSpringPersistenceUnitPostProcessor.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/991fb8a16f2dd538e404dbef7658aae5a17a3329/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Futil%2FSpringPersistenceUnitPostProcessor.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Futil%2FSpringPersistenceUnitPostProcessor.java?ref=991fb8a16f2dd538e404dbef7658aae5a17a3329","patch":"@@ -1,80 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-package org.apache.syncope.core.util;\n-\n-import java.io.IOException;\n-\n-import javax.persistence.Entity;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.core.io.Resource;\n-import org.springframework.core.io.support.ResourcePatternResolver;\n-import org.springframework.core.type.classreading.CachingMetadataReaderFactory;\n-import org.springframework.core.type.classreading.MetadataReader;\n-import org.springframework.orm.jpa.persistenceunit.MutablePersistenceUnitInfo;\n-import org.springframework.orm.jpa.persistenceunit.PersistenceUnitPostProcessor;\n-\n-/**\n- * Add to JPA persistence context all beans labeled as @Entity from given location. This is needed only when using\n- * LocalContainerEntityManagerFactoryBean with non-standard persistence.xml (currently JBoss-only).\n- */\n-public class SpringPersistenceUnitPostProcessor implements PersistenceUnitPostProcessor {\n-\n-    /**\n-     * Logger.\n-     */\n-    private static final Logger LOG = LoggerFactory.getLogger(SpringPersistenceUnitPostProcessor.class);\n-\n-    @Autowired\n-    private ResourcePatternResolver resResolver;\n-\n-    private String[] locations;\n-\n-    public void setLocations(final String[] locations) {\n-        this.locations = locations == null\n-                ? new String[0]\n-                : locations.clone();\n-    }\n-\n-    @Override\n-    public void postProcessPersistenceUnitInfo(final MutablePersistenceUnitInfo mpui) {\n-\n-        if (locations.length == 0) {\n-            LOG.warn(\"No locations provided\");\n-        }\n-\n-        CachingMetadataReaderFactory cachingMetadataReaderFactory = new CachingMetadataReaderFactory();\n-\n-        try {\n-            for (String location : locations) {\n-                for (Resource resource : resResolver.getResources(location)) {\n-                    MetadataReader metadataReader = cachingMetadataReaderFactory.getMetadataReader(resource);\n-                    if (metadataReader.getAnnotationMetadata().isAnnotated(Entity.class.getName())) {\n-                        mpui.addManagedClassName(metadataReader.getClassMetadata().getClassName());\n-                    }\n-                }\n-            }\n-            mpui.setExcludeUnlistedClasses(true);\n-        } catch (IOException e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-}"},{"sha":"8c12fa571dde2ab196940818150095e7139e6dbf","filename":"core/src/test/java/org/apache/syncope/core/init/ConnectorManagerTest.java","status":"modified","additions":1,"deletions":2,"changes":3,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/a1174ba3861b8f93bbe206a5a04d02cffaffec18/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Finit%2FConnectorManagerTest.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/a1174ba3861b8f93bbe206a5a04d02cffaffec18/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Finit%2FConnectorManagerTest.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Finit%2FConnectorManagerTest.java?ref=a1174ba3861b8f93bbe206a5a04d02cffaffec18","patch":"@@ -27,7 +27,6 @@\n import org.apache.syncope.core.rest.data.ResourceDataBinder;\n import org.apache.syncope.core.util.ApplicationContextProvider;\n import org.junit.Before;\n-import org.junit.Ignore;\n import org.junit.Test;\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.test.util.ReflectionTestUtils;\n@@ -54,7 +53,7 @@ public void before() {\n         connManager.unload();\n     }\n \n-    @Test@Ignore\n+    @Test\n     public void load() {\n         connManager.load();\n "},{"sha":"8e50e8f5a1c4177d328496037f288848868768c4","filename":"core/src/test/java/org/apache/syncope/core/rest/AbstractTest.java","status":"modified","additions":4,"deletions":3,"changes":7,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/a1174ba3861b8f93bbe206a5a04d02cffaffec18/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Frest%2FAbstractTest.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/a1174ba3861b8f93bbe206a5a04d02cffaffec18/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Frest%2FAbstractTest.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Frest%2FAbstractTest.java?ref=a1174ba3861b8f93bbe206a5a04d02cffaffec18","patch":"@@ -19,6 +19,7 @@\n package org.apache.syncope.core.rest;\n \n import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.fail;\n \n import java.util.ArrayList;\n import java.util.List;\n@@ -133,7 +134,7 @@ public abstract class AbstractTest {\n     private String contentType;\n \n     protected UserService userService;\n-    \n+\n     protected UserWorkflowService userWorkflowService;\n \n     protected RoleService roleService;\n@@ -357,12 +358,12 @@ protected void assertCreated(final Response response) {\n                 builder.append(key + \":\" + headers.getFirst(key) + \",\");\n             }\n             builder.append(\")\");\n-            throw new RuntimeException(\"Error on create. Status is : \" + response.getStatus() + \" with headers \"\n+            fail(\"Error on create. Status is : \" + response.getStatus() + \" with headers \"\n                     + builder.toString());\n         }\n     }\n \n-    <T extends AbstractSchemaTO> Response createSchema(final AttributableType kind,\n+    protected <T extends AbstractSchemaTO> Response createSchema(final AttributableType kind,\n             final SchemaType type, final T schemaTO) {\n         Response response = schemaService.create(kind, type, schemaTO);\n         if (response.getStatus() != HttpStatus.SC_CREATED) {"},{"sha":"cfb738a0ea002cf1a6c315b6e6e2bd0517208f56","filename":"core/src/test/java/org/apache/syncope/core/rest/TaskTestITCase.java","status":"modified","additions":2,"deletions":1,"changes":3,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/a1174ba3861b8f93bbe206a5a04d02cffaffec18/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Frest%2FTaskTestITCase.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/a1174ba3861b8f93bbe206a5a04d02cffaffec18/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Frest%2FTaskTestITCase.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Frest%2FTaskTestITCase.java?ref=a1174ba3861b8f93bbe206a5a04d02cffaffec18","patch":"@@ -23,6 +23,7 @@\n import static org.junit.Assert.assertNotNull;\n import static org.junit.Assert.assertNull;\n import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n \n import java.util.ArrayList;\n import java.util.Collections;\n@@ -721,7 +722,7 @@ private TaskExecTO execSyncTask(final Long taskId, final int maxWaitSeconds,\n             i++;\n         } while (preSyncSize == taskTO.getExecutions().size() && i < maxit);\n         if (i == maxit) {\n-            throw new RuntimeException(\"Timeout when executing task \" + taskId);\n+            fail(\"Timeout when executing task \" + taskId);\n         }\n         return taskTO.getExecutions().get(0);\n     }"}]}