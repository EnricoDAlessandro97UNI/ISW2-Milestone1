{"sha":"384ed3f2864467b061df7a91f6dd3f0dc4e8e623","node_id":"MDY6Q29tbWl0NjM2ODc5MDYyOjM4NGVkM2YyODY0NDY3YjA2MWRmN2E5MWY2ZGQzZjBkYzRlOGU2MjM=","commit":{"author":{"name":"Francesco Chicchiriccò","email":"ilgrosso@apache.org","date":"2012-12-11T14:05:25Z"},"committer":{"name":"Francesco Chicchiriccò","email":"ilgrosso@apache.org","date":"2012-12-11T14:05:25Z"},"message":"Moving the DEV_ROLE_PROVISIONING branch to trunk\n\ngit-svn-id: https://svn.apache.org/repos/asf/syncope/trunk@1420173 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"0a6a334e827e7fd6435d1b2f21fc9e61a74dc7ec","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/git/trees/0a6a334e827e7fd6435d1b2f21fc9e61a74dc7ec"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/git/commits/384ed3f2864467b061df7a91f6dd3f0dc4e8e623","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/384ed3f2864467b061df7a91f6dd3f0dc4e8e623","html_url":"https://github.com/EnricoDAlessandro97UNI/syncope/commit/384ed3f2864467b061df7a91f6dd3f0dc4e8e623","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/comments","author":{"login":"ilgrosso","id":1064664,"node_id":"MDQ6VXNlcjEwNjQ2NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/1064664?v=4","gravatar_id":"","url":"https://api.github.com/users/ilgrosso","html_url":"https://github.com/ilgrosso","followers_url":"https://api.github.com/users/ilgrosso/followers","following_url":"https://api.github.com/users/ilgrosso/following{/other_user}","gists_url":"https://api.github.com/users/ilgrosso/gists{/gist_id}","starred_url":"https://api.github.com/users/ilgrosso/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ilgrosso/subscriptions","organizations_url":"https://api.github.com/users/ilgrosso/orgs","repos_url":"https://api.github.com/users/ilgrosso/repos","events_url":"https://api.github.com/users/ilgrosso/events{/privacy}","received_events_url":"https://api.github.com/users/ilgrosso/received_events","type":"User","site_admin":false},"committer":{"login":"ilgrosso","id":1064664,"node_id":"MDQ6VXNlcjEwNjQ2NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/1064664?v=4","gravatar_id":"","url":"https://api.github.com/users/ilgrosso","html_url":"https://github.com/ilgrosso","followers_url":"https://api.github.com/users/ilgrosso/followers","following_url":"https://api.github.com/users/ilgrosso/following{/other_user}","gists_url":"https://api.github.com/users/ilgrosso/gists{/gist_id}","starred_url":"https://api.github.com/users/ilgrosso/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ilgrosso/subscriptions","organizations_url":"https://api.github.com/users/ilgrosso/orgs","repos_url":"https://api.github.com/users/ilgrosso/repos","events_url":"https://api.github.com/users/ilgrosso/events{/privacy}","received_events_url":"https://api.github.com/users/ilgrosso/received_events","type":"User","site_admin":false},"parents":[{"sha":"8fcd0ace968e4cb7b5c8b98066414c6b62a9ba81","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/8fcd0ace968e4cb7b5c8b98066414c6b62a9ba81","html_url":"https://github.com/EnricoDAlessandro97UNI/syncope/commit/8fcd0ace968e4cb7b5c8b98066414c6b62a9ba81"},{"sha":"4971a895796d8e31a860550c0d54332e2cab483d","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/4971a895796d8e31a860550c0d54332e2cab483d","html_url":"https://github.com/EnricoDAlessandro97UNI/syncope/commit/4971a895796d8e31a860550c0d54332e2cab483d"}],"stats":{"total":10238,"additions":6315,"deletions":3923},"files":[{"sha":"031fb3bb507d609d56c36ebb61e278fc41cadb0e","filename":"archetype/pom.xml","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/archetype%2Fpom.xml","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/archetype%2Fpom.xml","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/archetype%2Fpom.xml?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -25,7 +25,7 @@ under the License.\n   <parent>\n     <groupId>org.apache.syncope</groupId>\n     <artifactId>syncope</artifactId>\n-    <version>1.1.0-SNAPSHOT</version>\n+    <version>1.1.0-RP-SNAPSHOT</version>\n   </parent>\n \n   <name>Apache Syncope Archetype</name>"},{"sha":"0f07bde75f8eeda4c9fee9f86a91438a161f1909","filename":"build-tools/pom.xml","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/build-tools%2Fpom.xml","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/build-tools%2Fpom.xml","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/build-tools%2Fpom.xml?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -25,7 +25,7 @@ under the License.\n   <parent>\n     <groupId>org.apache.syncope</groupId>\n     <artifactId>syncope</artifactId>\n-    <version>1.1.0-SNAPSHOT</version>\n+    <version>1.1.0-RP-SNAPSHOT</version>\n   </parent>\n \n   <name>Apache Syncope Build Tools</name>"},{"sha":"bb46d1a7a8a1b47088f709ba1c0069bbbe4390f3","filename":"build-tools/src/main/java/org/apache/syncope/buildtools/ApacheDSStartStopListener.java","status":"modified","additions":24,"deletions":41,"changes":65,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/build-tools%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fbuildtools%2FApacheDSStartStopListener.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/build-tools%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fbuildtools%2FApacheDSStartStopListener.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/build-tools%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fbuildtools%2FApacheDSStartStopListener.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -38,7 +38,6 @@\n import org.apache.directory.server.xdbm.Index;\n import org.apache.directory.shared.ldap.entry.Entry;\n import org.apache.directory.shared.ldap.entry.ServerEntry;\n-import org.apache.directory.shared.ldap.exception.LdapException;\n import org.apache.directory.shared.ldap.name.DN;\n import org.apache.directory.shared.ldap.schema.SchemaManager;\n import org.apache.directory.shared.ldap.schema.ldif.extractor.SchemaLdifExtractor;\n@@ -58,52 +57,50 @@ public class ApacheDSStartStopListener implements ServletContextListener {\n     private LdapServer server;\n \n     /**\n-     * Initialize the schema manager and add the schema partition to\n-     * directory service.\n+     * Initialize the schema manager and add the schema partition to directory service.\n      *\n      * @throws Exception if the schema LDIF files are not found on the classpath\n      */\n     private void initSchemaPartition(final ServletContext servletContext) throws Exception {\n-\n-        Pattern sharedLdapSchemaManagerPattern = Pattern.compile(\".*apacheds-all-.*\\\\.jar\");\n+        final Pattern sharedLdapSchemaManagerPattern = Pattern.compile(\".*apacheds-all-.*\\\\.jar\");\n         File found = null;\n-        for (File jarFile : new File(servletContext.getRealPath(\"/WEB-INF/lib\")).listFiles()) {\n-\n+        for (final File jarFile : new File(servletContext.getRealPath(\"/WEB-INF/lib\")).listFiles()) {\n             if (sharedLdapSchemaManagerPattern.matcher(jarFile.getAbsolutePath()).matches()) {\n-\n                 found = jarFile;\n             }\n         }\n         if (found == null) {\n             throw new RuntimeException(\"No apache-ds-all JAR found under WEB-INF/lib\");\n         }\n \n-        SchemaPartition schemaPartition = service.getSchemaService().getSchemaPartition();\n+        final SchemaPartition schemaPartition = service.getSchemaService().getSchemaPartition();\n \n         // Init the LdifPartition\n-        LdifPartition ldifPartition = new LdifPartition();\n-        String workingDirectory = service.getWorkingDirectory().getPath();\n+        final LdifPartition ldifPartition = new LdifPartition();\n+        final String workingDirectory = service.getWorkingDirectory().getPath();\n         ldifPartition.setWorkingDirectory(workingDirectory + \"/schema\");\n \n         // Extract the schema on disk (a brand new one) and load the registries\n-        File schemaRepository = new File(workingDirectory, \"schema\");\n-        SchemaLdifExtractor extractor = new JarSchemaLdifExtractor(new File(workingDirectory), found);\n+        final File schemaRepository = new File(workingDirectory, \"schema\");\n+        final SchemaLdifExtractor extractor = new JarSchemaLdifExtractor(new File(workingDirectory), found);\n         extractor.extractOrCopy(true);\n \n         schemaPartition.setWrappedPartition(ldifPartition);\n \n-        SchemaLoader loader = new LdifSchemaLoader(schemaRepository);\n-        SchemaManager schemaManager = new DefaultSchemaManager(loader);\n+        final SchemaLoader loader = new LdifSchemaLoader(schemaRepository);\n+        final SchemaManager schemaManager = new DefaultSchemaManager(loader);\n         service.setSchemaManager(schemaManager);\n \n+        // Enable nis so that posixAccount and posixGroup are available\n+        schemaManager.enable(\"nis\");\n         // We have to load the schema now, otherwise we won't be able\n         // to initialize the Partitions, as we won't be able to parse \n         // and normalize their suffix DN\n         schemaManager.loadAllEnabled();\n \n         schemaPartition.setSchemaManager(schemaManager);\n \n-        List<Throwable> errors = schemaManager.getErrors();\n+        final List<Throwable> errors = schemaManager.getErrors();\n         if (!errors.isEmpty()) {\n             throw new RuntimeException(\"Schema load failed : \" + errors);\n         }\n@@ -118,9 +115,8 @@ private void initSchemaPartition(final ServletContext servletContext) throws Exc\n      * @throws Exception If the partition can't be added\n      */\n     private Partition addPartition(final String partitionId, final String partitionDn) throws Exception {\n-\n         // Create a new partition named 'foo'.\n-        JdbmPartition partition = new JdbmPartition();\n+        final JdbmPartition partition = new JdbmPartition();\n         partition.setId(partitionId);\n         partition.setPartitionDir(new File(service.getWorkingDirectory(), partitionId));\n         partition.setSuffix(partitionDn);\n@@ -137,8 +133,7 @@ private Partition addPartition(final String partitionId, final String partitionD\n      */\n     private void addIndex(final Partition partition, final String... attrs) {\n         // Index some attributes on the apache partition\n-        HashSet<Index<?, ServerEntry, Long>> indexedAttributes = new HashSet<Index<?, ServerEntry, Long>>();\n-\n+        final HashSet<Index<?, ServerEntry, Long>> indexedAttributes = new HashSet<Index<?, ServerEntry, Long>>();\n         for (String attribute : attrs) {\n             indexedAttributes.add(new JdbmIndex<String, ServerEntry>(attribute));\n         }\n@@ -147,14 +142,13 @@ private void addIndex(final Partition partition, final String... attrs) {\n     }\n \n     /**\n-     * Initialize the server. It creates the partition, adds the index, and\n-     * injects the context entries for the created partitions.\n+     * Initialize the server. It creates the partition, adds the index, and injects the context entries for the created\n+     * partitions.\n      *\n      * @param workDir the directory to be used for storing the data\n      * @throws Exception if there were some problems while initializing\n      */\n     private void initDirectoryService(final ServletContext servletContext, final File workDir) throws Exception {\n-\n         // Initialize the LDAP service\n         service = new DefaultDirectoryService();\n         service.setWorkingDirectory(workDir);\n@@ -164,36 +158,25 @@ private void initDirectoryService(final ServletContext servletContext, final Fil\n \n         // then the system partition\n         // this is a MANDATORY partition\n-        Partition systemPartition = addPartition(\"system\", ServerDNConstants.SYSTEM_DN);\n+        final Partition systemPartition = addPartition(\"system\", ServerDNConstants.SYSTEM_DN);\n         service.setSystemPartition(systemPartition);\n \n         // Disable the ChangeLog system\n         service.getChangeLog().setEnabled(false);\n         service.setDenormalizeOpAttrsEnabled(true);\n \n         // Now we can create as many partitions as we need\n-        Partition ispPartition = addPartition(\"isp\", \"o=isp\");\n+        final Partition ispPartition = addPartition(\"isp\", \"o=isp\");\n         addIndex(ispPartition, \"objectClass\", \"ou\", \"uid\");\n \n         // And start the service\n         service.startup();\n \n-        // Inject the foo root entry if it does not already exist\n-        try {\n-            service.getAdminSession().lookup(ispPartition.getSuffixDn());\n-        } catch (LdapException lnnfe) {\n-            DN dnIsp = new DN(\"o=isp\");\n-            ServerEntry rootEntry = service.newEntry(dnIsp);\n-            rootEntry.add(\"objectClass\", \"top\", \"organization\");\n-            rootEntry.add(\"o\", \"isp\");\n-            service.getAdminSession().add(rootEntry);\n-\n-            DN dnPeople = new DN(\"ou=People,o=isp\");\n-            ServerEntry peopleEntry = service.newEntry(dnPeople);\n-            peopleEntry.add(\"objectClass\", \"top\", \"organizationalUnit\");\n-            peopleEntry.add(\"ou\", \"People\");\n-            service.getAdminSession().add(peopleEntry);\n-        }\n+        // Finally, load content LDIF\n+        final LdifURLLoader contentLoader = new LdifURLLoader(service.getAdminSession(),\n+                servletContext.getResource(\"/WEB-INF/classes/content.ldif\"));\n+        final int numEntries = contentLoader.execute();\n+        servletContext.log(\"Successfully created \" + numEntries + \" entries\");\n     }\n \n     /**"},{"sha":"bb02d947591135d6c1dc79efd7fc07dcf662df14","filename":"build-tools/src/main/java/org/apache/syncope/buildtools/LdifURLLoader.java","status":"added","additions":127,"deletions":0,"changes":127,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/build-tools%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fbuildtools%2FLdifURLLoader.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/build-tools%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fbuildtools%2FLdifURLLoader.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/build-tools%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fbuildtools%2FLdifURLLoader.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -0,0 +1,127 @@\n+/*\n+ *  Licensed to the Apache Software Foundation (ASF) under one\n+ *  or more contributor license agreements.  See the NOTICE file\n+ *  distributed with this work for additional information\n+ *  regarding copyright ownership.  The ASF licenses this file\n+ *  to you under the Apache License, Version 2.0 (the\n+ *  \"License\"); you may not use this file except in compliance\n+ *  with the License.  You may obtain a copy of the License at\n+ *  \n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *  \n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License. \n+ *  \n+ */\n+package org.apache.syncope.buildtools;\n+\n+import java.io.FileNotFoundException;\n+import java.io.InputStream;\n+import java.net.URL;\n+import java.util.List;\n+import javax.naming.NamingException;\n+import org.apache.directory.server.core.CoreSession;\n+import org.apache.directory.server.i18n.I18n;\n+import org.apache.directory.shared.ldap.entry.DefaultServerEntry;\n+import org.apache.directory.shared.ldap.entry.Entry;\n+import org.apache.directory.shared.ldap.entry.Modification;\n+import org.apache.directory.shared.ldap.ldif.LdifEntry;\n+import org.apache.directory.shared.ldap.ldif.LdifReader;\n+import org.apache.directory.shared.ldap.name.DN;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Support for commands to load an LDIF from an URL into a DirContext.\n+ *\n+ * @see org.apache.directory.server.protocol.shared.store.LdifFileLoader\n+ */\n+public class LdifURLLoader {\n+\n+    /**\n+     * Logger.\n+     */\n+    private static final Logger LOG = LoggerFactory.getLogger(LdifURLLoader.class);\n+\n+    /**\n+     * A handle on the top core session.\n+     */\n+    protected CoreSession coreSession;\n+\n+    /**\n+     * The LDIF URL.\n+     */\n+    protected URL ldif;\n+\n+    /**\n+     * The total count of entries loaded.\n+     */\n+    private int count;\n+\n+    public LdifURLLoader(final CoreSession coreSession, final URL ldif) {\n+        this.coreSession = coreSession;\n+        this.ldif = ldif;\n+    }\n+\n+    /**\n+     * Opens the LDIF file and loads the entries into the context.\n+     *\n+     * @return The count of entries created.\n+     */\n+    public int execute() {\n+        DN rdn = null;\n+        InputStream in = null;\n+\n+        try {\n+            in = ldif.openStream();\n+\n+            for (final LdifEntry ldifEntry : new LdifReader(in)) {\n+                final DN dn = ldifEntry.getDn();\n+\n+                if (ldifEntry.isEntry()) {\n+                    final Entry entry = ldifEntry.getEntry();\n+                    try {\n+                        coreSession.lookup(dn);\n+                        LOG.info(\"Found {}, will not create.\", rdn);\n+                    } catch (Exception e) {\n+                        try {\n+                            coreSession.add(new DefaultServerEntry(\n+                                    coreSession.getDirectoryService().getSchemaManager(), entry));\n+                            count++;\n+                            LOG.info(\"Created {}.\", rdn);\n+                        } catch (NamingException ne) {\n+                            LOG.info(\"Could not create entry {}\", entry, ne);\n+                        }\n+                    }\n+                } else {\n+                    //modify\n+                    final List<Modification> items = ldifEntry.getModificationItems();\n+                    try {\n+                        coreSession.modify(dn, items);\n+                        LOG.info(\"Modified: \" + dn + \" with modificationItems: \" + items);\n+                    } catch (NamingException e) {\n+                        LOG.info(\"Could not modify: \" + dn + \" with modificationItems: \" + items, e);\n+                    }\n+                }\n+            }\n+        } catch (FileNotFoundException fnfe) {\n+            LOG.error(I18n.err(I18n.ERR_173));\n+        } catch (Exception ioe) {\n+            LOG.error(I18n.err(I18n.ERR_174), ioe);\n+        } finally {\n+            if (in != null) {\n+                try {\n+                    in.close();\n+                } catch (Exception e) {\n+                    LOG.error(I18n.err(I18n.ERR_175), e);\n+                }\n+            }\n+        }\n+\n+        return count;\n+    }\n+}"},{"sha":"79b4e4606a9a84c9c4f780fe0a9832eacbef48ee","filename":"build-tools/src/main/resources/content.ldif","status":"added","additions":31,"deletions":0,"changes":31,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/build-tools%2Fsrc%2Fmain%2Fresources%2Fcontent.ldif","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/build-tools%2Fsrc%2Fmain%2Fresources%2Fcontent.ldif","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/build-tools%2Fsrc%2Fmain%2Fresources%2Fcontent.ldif?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -0,0 +1,31 @@\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#       http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+DN: o=isp\n+objectClass: organization\n+objectClass: top\n+o: isp\n+\n+DN: ou=People,o=isp\n+objectClass: organizationalUnit\n+objectClass: top\n+ou: People\n+\n+DN: ou=Groups,o=isp\n+objectClass: organizationalUnit\n+objectClass: top\n+ou: Groups\n+\n+DN: cn=testLDAPGroup,ou=Groups,o=isp\n+objectClass: groupOfUniqueNames\n+objectClass: top\n+cn: testLDAPGroup\n+uniqueMember: uid=admin,ou=system"},{"sha":"03c75a2b0664100f599784fcd4bcdc1470d9d90c","filename":"client/pom.xml","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/client%2Fpom.xml","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/client%2Fpom.xml","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/client%2Fpom.xml?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -25,7 +25,7 @@ under the License.\n   <parent>\n     <groupId>org.apache.syncope</groupId>\n     <artifactId>syncope</artifactId>\n-    <version>1.1.0-SNAPSHOT</version>\n+    <version>1.1.0-RP-SNAPSHOT</version>\n   </parent>\n \n   <name>Apache Syncope Client</name>\n@@ -48,7 +48,7 @@ under the License.\n       <groupId>commons-lang</groupId>\n       <artifactId>commons-lang</artifactId>\n     </dependency>\n-\n+    \n     <dependency>\n       <groupId>org.springframework</groupId>\n       <artifactId>spring-webmvc</artifactId>"},{"sha":"1f3789f2d9575db5f5d50507db991e0ec47e1f09","filename":"client/src/main/java/org/apache/syncope/client/search/AttributableCond.java","status":"renamed","additions":3,"deletions":3,"changes":6,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/client%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fsearch%2FAttributableCond.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/client%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fsearch%2FAttributableCond.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/client%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fsearch%2FAttributableCond.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -21,14 +21,14 @@\n /**\n  * Search condition to be applied when comparing bean attribute values.\n  */\n-public class SyncopeUserCond extends AttributeCond {\n+public class AttributableCond extends AttributeCond {\n \n     private static final long serialVersionUID = -1880319220462653955L;\n \n-    public SyncopeUserCond() {\n+    public AttributableCond() {\n     }\n \n-    public SyncopeUserCond(Type conditionType) {\n+    public AttributableCond(Type conditionType) {\n         super(conditionType);\n     }\n }","previous_filename":"client/src/main/java/org/apache/syncope/client/search/SyncopeUserCond.java"},{"sha":"2ae726522229ec0e9ac0e5e5563d783a08f3d8cc","filename":"client/src/main/java/org/apache/syncope/client/search/NodeCond.java","status":"modified","additions":13,"deletions":13,"changes":26,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/client%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fsearch%2FNodeCond.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/client%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fsearch%2FNodeCond.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/client%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fsearch%2FNodeCond.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -32,7 +32,7 @@ public enum Type {\n \n     private Type type;\n \n-    private SyncopeUserCond syncopeUserCond;\n+    private AttributableCond attributableCond;\n \n     private AttributeCond attributeCond;\n \n@@ -44,11 +44,11 @@ public enum Type {\n \n     private NodeCond rightNodeCond;\n \n-    public static NodeCond getLeafCond(final SyncopeUserCond syncopeUserCond) {\n+    public static NodeCond getLeafCond(final AttributableCond syncopeUserCond) {\n         NodeCond nodeCond = new NodeCond();\n \n         nodeCond.type = Type.LEAF;\n-        nodeCond.syncopeUserCond = syncopeUserCond;\n+        nodeCond.attributableCond = syncopeUserCond;\n \n         return nodeCond;\n     }\n@@ -80,7 +80,7 @@ public static NodeCond getLeafCond(final ResourceCond resourceCond) {\n         return nodeCond;\n     }\n \n-    public static NodeCond getNotLeafCond(final SyncopeUserCond syncopeUserCond) {\n+    public static NodeCond getNotLeafCond(final AttributableCond syncopeUserCond) {\n         NodeCond nodeCond = getLeafCond(syncopeUserCond);\n         nodeCond.type = Type.NOT_LEAF;\n         return nodeCond;\n@@ -150,12 +150,12 @@ public void setResourceCond(final ResourceCond resourceCond) {\n         this.resourceCond = resourceCond;\n     }\n \n-    public SyncopeUserCond getSyncopeUserCond() {\n-        return syncopeUserCond;\n+    public AttributableCond getAttributableCond() {\n+        return attributableCond;\n     }\n \n-    public void setSyncopeUserCond(final SyncopeUserCond syncopeUserCond) {\n-        this.syncopeUserCond = syncopeUserCond;\n+    public void setAttributableCond(final AttributableCond attributableCond) {\n+        this.attributableCond = attributableCond;\n     }\n \n     public final NodeCond getLeftNodeCond() {\n@@ -190,13 +190,13 @@ public final boolean checkValidity() {\n         switch (type) {\n             case LEAF:\n             case NOT_LEAF:\n-                return (syncopeUserCond != null && attributeCond == null && membershipCond == null\n-                        && resourceCond == null && syncopeUserCond.checkValidity())\n-                        || (syncopeUserCond == null && attributeCond != null && membershipCond == null\n+                return (attributableCond != null && attributeCond == null && membershipCond == null\n+                        && resourceCond == null && attributableCond.checkValidity())\n+                        || (attributableCond == null && attributeCond != null && membershipCond == null\n                                 && resourceCond == null && attributeCond.checkValidity())\n-                        || (syncopeUserCond == null && attributeCond == null && membershipCond != null\n+                        || (attributableCond == null && attributeCond == null && membershipCond != null\n                                 && resourceCond == null && membershipCond.checkValidity())\n-                        || (syncopeUserCond == null && attributeCond == null && membershipCond == null\n+                        || (attributableCond == null && attributeCond == null && membershipCond == null\n                                 && resourceCond != null && resourceCond.checkValidity());\n             case AND:\n             case OR:"},{"sha":"7ae391173f9ad522acdff6e3f4610777f1b6922a","filename":"client/src/main/java/org/apache/syncope/client/to/AbstractAttributableTO.java","status":"modified","additions":31,"deletions":0,"changes":31,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/client%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fto%2FAbstractAttributableTO.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/client%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fto%2FAbstractAttributableTO.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/client%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fto%2FAbstractAttributableTO.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -39,12 +39,15 @@ public abstract class AbstractAttributableTO extends ConnObjectTO {\n \n     private Set<String> resources;\n \n+    private List<PropagationTO> propagationTOs;\n+\n     protected AbstractAttributableTO() {\n         super();\n \n         derivedAttributes = new ArrayList<AttributeTO>();\n         virtualAttributes = new ArrayList<AttributeTO>();\n         resources = new HashSet<String>();\n+        propagationTOs = new ArrayList<PropagationTO>();\n     }\n \n     public long getId() {\n@@ -137,4 +140,32 @@ public Set<String> getResources() {\n     public void setResources(final Set<String> resources) {\n         this.resources = resources;\n     }\n+\n+    public boolean addPropagationTO(final PropagationTO status) {\n+        return propagationTOs.add(status);\n+    }\n+\n+    public boolean removePropagationTO(final String resource) {\n+        if (resource != null && getPropagationTOs().isEmpty()) {\n+            final List<PropagationTO> toBeRemoved = new ArrayList<PropagationTO>();\n+\n+            for (PropagationTO propagationTO : getPropagationTOs()) {\n+                if (resource.equals(propagationTO.getResourceName())) {\n+                    toBeRemoved.add(propagationTO);\n+                }\n+            }\n+\n+            return propagationTOs.removeAll(toBeRemoved);\n+        }\n+        return false;\n+    }\n+\n+    public List<PropagationTO> getPropagationTOs() {\n+        return propagationTOs;\n+    }\n+\n+    public void setPropagationTOs(final List<PropagationTO> propagationTOs) {\n+        this.propagationTOs.clear();\n+        this.propagationTOs.addAll(propagationTOs);\n+    }\n }"},{"sha":"8bf03c021a94c876a23f96d1ba52f18b7d8aa9cd","filename":"client/src/main/java/org/apache/syncope/client/to/MappingItemTO.java","status":"renamed","additions":5,"deletions":4,"changes":9,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/client%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fto%2FMappingItemTO.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/client%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fto%2FMappingItemTO.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/client%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fto%2FMappingItemTO.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -21,14 +21,15 @@\n import org.apache.syncope.client.AbstractBaseBean;\n import org.apache.syncope.types.IntMappingType;\n \n-public class SchemaMappingTO extends AbstractBaseBean {\n+public class MappingItemTO extends AbstractBaseBean {\n+\n+    private static final long serialVersionUID = 2983498836767176862L;\n \n     private Long id;\n \n     /**\n-     * Attribute schema to be mapped.\n-     * Consider that we can associate tha same attribute schema more\n-     * than once, with different aliases, to different resource attributes.\n+     * Attribute schema to be mapped. Consider that we can associate tha same attribute schema more than once, with\n+     * different aliases, to different resource attributes.\n      */\n     private String intAttrName;\n ","previous_filename":"client/src/main/java/org/apache/syncope/client/to/SchemaMappingTO.java"},{"sha":"3b7408b722fb852e1ebd4332b0b710470e66d33a","filename":"client/src/main/java/org/apache/syncope/client/to/MappingTO.java","status":"added","additions":123,"deletions":0,"changes":123,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/client%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fto%2FMappingTO.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/client%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fto%2FMappingTO.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/client%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fto%2FMappingTO.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -0,0 +1,123 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.client.to;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import org.apache.syncope.client.AbstractBaseBean;\n+import org.apache.syncope.types.IntMappingType;\n+\n+public class MappingTO extends AbstractBaseBean {\n+\n+    private static final long serialVersionUID = 8447688036282611118L;\n+\n+    private String accountLink;\n+\n+    private List<MappingItemTO> items;\n+\n+    public MappingTO() {\n+        super();\n+\n+        items = new ArrayList<MappingItemTO>();\n+    }\n+\n+    public String getAccountLink() {\n+        return accountLink;\n+    }\n+\n+    public void setAccountLink(String accountLink) {\n+        this.accountLink = accountLink;\n+    }\n+\n+    public <T extends MappingItemTO> T getAccountIdItem() {\n+        T accountIdItem = null;\n+        for (MappingItemTO item : getItems()) {\n+            if (item.isAccountid()) {\n+                accountIdItem = (T) item;\n+            }\n+        }\n+        return accountIdItem;\n+    }\n+\n+    protected <T extends MappingItemTO> boolean addAccountIdItem(final T accountIdItem) {\n+        if (IntMappingType.UserVirtualSchema == accountIdItem.getIntMappingType()\n+                || IntMappingType.RoleVirtualSchema == accountIdItem.getIntMappingType()\n+                || IntMappingType.MembershipVirtualSchema == accountIdItem.getIntMappingType()\n+                || IntMappingType.Password == accountIdItem.getIntMappingType()) {\n+\n+            throw new IllegalArgumentException(\"Virtual attributes cannot be set as accountId\");\n+        }\n+        if (IntMappingType.Password == accountIdItem.getIntMappingType()) {\n+            throw new IllegalArgumentException(\"Password attributes cannot be set as accountId\");\n+        }\n+\n+        accountIdItem.setExtAttrName(\"__NAME__\");\n+        accountIdItem.setAccountid(true);\n+\n+        return this.addItem(accountIdItem);\n+    }\n+\n+    public boolean setAccountIdItem(final MappingItemTO accountIdItem) {\n+        if (accountIdItem == null) {\n+            return this.removeItem(getAccountIdItem());\n+        } else {\n+            return addAccountIdItem(accountIdItem);\n+        }\n+    }\n+\n+    public MappingItemTO getPasswordItem() {\n+        MappingItemTO passwordItem = null;\n+        for (MappingItemTO item : getItems()) {\n+            if (item.isPassword()) {\n+                passwordItem = item;\n+            }\n+        }\n+        return passwordItem;\n+    }\n+\n+    public boolean setPasswordItem(final MappingItemTO passwordItem) {\n+        if (passwordItem == null) {\n+            return this.removeItem(getPasswordItem());\n+        } else {\n+            passwordItem.setExtAttrName(\"__PASSWORD__\");\n+            passwordItem.setPassword(true);\n+            return addItem(passwordItem);\n+        }\n+    }\n+\n+    public <T extends MappingItemTO> List<T> getItems() {\n+        return (List<T>) items;\n+    }\n+\n+    public boolean addItem(final MappingItemTO item) {\n+        return item == null ? false : this.items.contains(item) || this.items.add(item);\n+    }\n+\n+    public boolean removeItem(final MappingItemTO item) {\n+        return this.items.remove(item);\n+    }\n+\n+    public void setItems(final Collection<MappingItemTO> items) {\n+        this.items.clear();\n+        if (items != null && !items.isEmpty()) {\n+            this.items.addAll(items);\n+        }\n+    }\n+}"},{"sha":"f54d3e8a8fdb554e25c67abaafdc8c2ad216a934","filename":"client/src/main/java/org/apache/syncope/client/to/MembershipTO.java","status":"modified","additions":21,"deletions":1,"changes":22,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/client%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fto%2FMembershipTO.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/client%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fto%2FMembershipTO.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/client%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fto%2FMembershipTO.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -19,6 +19,7 @@\n package org.apache.syncope.client.to;\n \n import java.util.Collections;\n+import java.util.List;\n import java.util.Set;\n \n public class MembershipTO extends AbstractAttributableTO {\n@@ -57,10 +58,29 @@ public boolean removeResource(String resource) {\n \n     @Override\n     public Set<String> getResources() {\n-        return Collections.emptySet();\n+        return Collections.EMPTY_SET;\n     }\n \n     @Override\n     public void setResources(Set<String> resources) {\n     }\n+\n+    @Override\n+    public boolean addPropagationTO(PropagationTO status) {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean removePropagationTO(String resource) {\n+        return false;\n+    }\n+\n+    @Override\n+    public List<PropagationTO> getPropagationTOs() {\n+        return Collections.EMPTY_LIST;\n+    }\n+\n+    @Override\n+    public void setPropagationTOs(List<PropagationTO> propagationTOs) {\n+    }\n }"},{"sha":"cffc059e6c91fddaadbfab087a9e93e7cd6a9c79","filename":"client/src/main/java/org/apache/syncope/client/to/PropagationTaskTO.java","status":"modified","additions":30,"deletions":9,"changes":39,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/client%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fto%2FPropagationTaskTO.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/client%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fto%2FPropagationTaskTO.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/client%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fto%2FPropagationTaskTO.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -18,16 +18,17 @@\n  */\n package org.apache.syncope.client.to;\n \n+import org.apache.syncope.types.AttributableType;\n import org.apache.syncope.types.PropagationMode;\n-import org.apache.syncope.types.PropagationOperation;\n+import org.apache.syncope.types.ResourceOperation;\n \n public class PropagationTaskTO extends TaskTO {\n \n     private static final long serialVersionUID = 386450127003321197L;\n \n     private PropagationMode propagationMode;\n \n-    private PropagationOperation propagationOperation;\n+    private ResourceOperation propagationOperation;\n \n     private String accountId;\n \n@@ -37,7 +38,11 @@ public class PropagationTaskTO extends TaskTO {\n \n     private String resource;\n \n-    private long user;\n+    private String objectClassName;\n+\n+    private AttributableType subjectType;\n+\n+    private Long subjectId;\n \n     public String getAccountId() {\n         return accountId;\n@@ -71,11 +76,11 @@ public void setResource(String resource) {\n         this.resource = resource;\n     }\n \n-    public PropagationOperation getPropagationOperation() {\n+    public ResourceOperation getPropagationOperation() {\n         return propagationOperation;\n     }\n \n-    public void setPropagationOperation(PropagationOperation propagationOperation) {\n+    public void setPropagationOperation(ResourceOperation propagationOperation) {\n \n         this.propagationOperation = propagationOperation;\n     }\n@@ -88,11 +93,27 @@ public void setXmlAttributes(String xmlAttributes) {\n         this.xmlAttributes = xmlAttributes;\n     }\n \n-    public long getUser() {\n-        return user;\n+    public String getObjectClassName() {\n+        return objectClassName;\n+    }\n+\n+    public void setObjectClassName(String objectClassName) {\n+        this.objectClassName = objectClassName;\n+    }\n+\n+    public AttributableType getSubjectType() {\n+        return subjectType;\n+    }\n+\n+    public void setSubjectType(AttributableType subjectType) {\n+        this.subjectType = subjectType;\n+    }\n+\n+    public Long getSubjectId() {\n+        return subjectId;\n     }\n \n-    public void setUser(long user) {\n-        this.user = user;\n+    public void setSubjectId(Long subjectId) {\n+        this.subjectId = subjectId;\n     }\n }"},{"sha":"9f9779a2d80dc974e00fcd932bed5e096e7c209c","filename":"client/src/main/java/org/apache/syncope/client/to/ResourceTO.java","status":"modified","additions":40,"deletions":42,"changes":82,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/client%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fto%2FResourceTO.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/client%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fto%2FResourceTO.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/client%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fto%2FResourceTO.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -18,9 +18,7 @@\n  */\n package org.apache.syncope.client.to;\n \n-import java.util.ArrayList;\n import java.util.HashSet;\n-import java.util.List;\n import java.util.Set;\n import org.apache.syncope.client.AbstractBaseBean;\n import org.apache.syncope.types.ConnConfProperty;\n@@ -41,12 +39,9 @@ public class ResourceTO extends AbstractBaseBean {\n      */\n     private Long connectorId;\n \n-    /**\n-     * Attribute mappings.\n-     */\n-    private List<SchemaMappingTO> mappings;\n+    private MappingTO umapping;\n \n-    private String accountLink;\n+    private MappingTO rmapping;\n \n     private boolean propagationPrimary;\n \n@@ -72,12 +67,15 @@ public class ResourceTO extends AbstractBaseBean {\n \n     private Set<ConnConfProperty> connConfProperties;\n \n-    private String syncToken;\n+    private String usyncToken;\n \n-    private String actionsClassName;\n+    private String rsyncToken;\n+\n+    private String propagationActionsClassName;\n \n     public ResourceTO() {\n-        mappings = new ArrayList<SchemaMappingTO>();\n+        super();\n+\n         connConfProperties = new HashSet<ConnConfProperty>();\n         propagationMode = PropagationMode.TWO_PHASES;\n         propagationPriority = 0;\n@@ -88,6 +86,14 @@ public ResourceTO() {\n         syncTraceLevel = TraceLevel.ALL;\n     }\n \n+    public String getName() {\n+        return name;\n+    }\n+\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+\n     public boolean isEnforceMandatoryCondition() {\n         return enforceMandatoryCondition;\n     }\n@@ -104,36 +110,20 @@ public void setConnectorId(Long connectorId) {\n         this.connectorId = connectorId;\n     }\n \n-    public boolean addMapping(SchemaMappingTO mapping) {\n-        return mappings.add(mapping);\n-    }\n-\n-    public boolean removeMapping(SchemaMappingTO mapping) {\n-        return mappings.remove(mapping);\n+    public MappingTO getUmapping() {\n+        return umapping;\n     }\n \n-    public List<SchemaMappingTO> getMappings() {\n-        return mappings;\n+    public void setUmapping(MappingTO umapping) {\n+        this.umapping = umapping;\n     }\n \n-    public void setMappings(List<SchemaMappingTO> mappings) {\n-        this.mappings = mappings;\n+    public MappingTO getRmapping() {\n+        return rmapping;\n     }\n \n-    public String getAccountLink() {\n-        return accountLink;\n-    }\n-\n-    public void setAccountLink(String accountLink) {\n-        this.accountLink = accountLink;\n-    }\n-\n-    public String getName() {\n-        return name;\n-    }\n-\n-    public void setName(String name) {\n-        this.name = name;\n+    public void setRmapping(MappingTO rmapping) {\n+        this.rmapping = rmapping;\n     }\n \n     public boolean isPropagationPrimary() {\n@@ -224,19 +214,27 @@ public void setSyncTraceLevel(final TraceLevel syncTraceLevel) {\n         this.syncTraceLevel = syncTraceLevel;\n     }\n \n-    public String getSyncToken() {\n-        return syncToken;\n+    public String getUsyncToken() {\n+        return usyncToken;\n+    }\n+\n+    public void setUsyncToken(final String syncToken) {\n+        this.usyncToken = syncToken;\n+    }\n+\n+    public String getRsyncToken() {\n+        return rsyncToken;\n     }\n \n-    public void setSyncToken(final String syncToken) {\n-        this.syncToken = syncToken;\n+    public void setRsyncToken(final String syncToken) {\n+        this.rsyncToken = syncToken;\n     }\n \n-    public String getActionsClassName() {\n-        return actionsClassName;\n+    public String getPropagationActionsClassName() {\n+        return propagationActionsClassName;\n     }\n \n-    public void setActionsClassName(final String actionsClassName) {\n-        this.actionsClassName = actionsClassName;\n+    public void setPropagationActionsClassName(final String propagationActionsClassName) {\n+        this.propagationActionsClassName = propagationActionsClassName;\n     }\n }"},{"sha":"db044c7de5c135f8651efc892445945f8abffa2c","filename":"client/src/main/java/org/apache/syncope/client/to/SyncTaskTO.java","status":"modified","additions":10,"deletions":0,"changes":10,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/client%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fto%2FSyncTaskTO.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/client%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fto%2FSyncTaskTO.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/client%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fto%2FSyncTaskTO.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -26,6 +26,8 @@ public class SyncTaskTO extends SchedTaskTO {\n \n     private UserTO userTemplate;\n \n+    private RoleTO roleTemplate;\n+\n     private boolean performCreate;\n \n     private boolean performUpdate;\n@@ -46,6 +48,14 @@ public void setUserTemplate(UserTO userTemplate) {\n         this.userTemplate = userTemplate;\n     }\n \n+    public RoleTO getRoleTemplate() {\n+        return roleTemplate;\n+    }\n+\n+    public void setRoleTemplate(RoleTO roleTemplate) {\n+        this.roleTemplate = roleTemplate;\n+    }\n+\n     public String getResource() {\n         return resource;\n     }"},{"sha":"743de02ef6915b86e9a5647c94c3c03ea46d9052","filename":"client/src/main/java/org/apache/syncope/client/to/UserTO.java","status":"modified","additions":0,"deletions":32,"changes":32,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/client%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fto%2FUserTO.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/client%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fto%2FUserTO.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/client%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fto%2FUserTO.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -37,8 +37,6 @@ public class UserTO extends AbstractAttributableTO {\n \n     private List<MembershipTO> memberships;\n \n-    private List<PropagationTO> propagationTOs;\n-\n     private String status;\n \n     private String token;\n@@ -59,7 +57,6 @@ public UserTO() {\n         super();\n \n         memberships = new ArrayList<MembershipTO>();\n-        propagationTOs = new ArrayList<PropagationTO>();\n     }\n \n     public String getPassword() {\n@@ -171,35 +168,6 @@ public void setLastLoginDate(Date lastLoginDate) {\n         this.lastLoginDate = lastLoginDate;\n     }\n \n-    public void addPropagationTO(final PropagationTO status) {\n-        propagationTOs.add(status);\n-    }\n-\n-    public void removePropagationTO(final String resource) {\n-        if (resource != null && getPropagationTOs().isEmpty()) {\n-\n-            final List<PropagationTO> toBeRemoved = new ArrayList<PropagationTO>();\n-\n-            for (PropagationTO propagationTO : getPropagationTOs()) {\n-                if (resource.equals(propagationTO.getResourceName())) {\n-                    toBeRemoved.add(propagationTO);\n-                }\n-            }\n-\n-            propagationTOs.removeAll(toBeRemoved);\n-        }\n-    }\n-\n-    public List<PropagationTO> getPropagationTOs() {\n-        return propagationTOs;\n-    }\n-\n-    public void setPropagationTOs(final List<PropagationTO> propagationTOs) {\n-\n-        this.propagationTOs.clear();\n-        this.propagationTOs.addAll(propagationTOs);\n-    }\n-\n     @Override\n     public String toString() {\n         return new ReflectionToStringBuilder(this, ToStringStyle.MULTI_LINE_STYLE) {"},{"sha":"f8c6f24c437d93f5be4940a8a3bddb11b723ab36","filename":"client/src/main/java/org/apache/syncope/client/util/AttributableOperations.java","status":"modified","additions":14,"deletions":4,"changes":18,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/client%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Futil%2FAttributableOperations.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/client%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Futil%2FAttributableOperations.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/client%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Futil%2FAttributableOperations.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -197,20 +197,18 @@ public static UserMod diff(final UserTO updated, final UserTO original) {\n      * @param incremental perform incremental diff (without removing existing info)\n      * @return UserMod containing differences\n      */\n-    public static UserMod diff(final UserTO updated, final UserTO original, boolean incremental) {\n+    public static UserMod diff(final UserTO updated, final UserTO original, final boolean incremental) {\n         UserMod result = new UserMod();\n \n         diff(updated, original, result, incremental);\n \n         // 1. password\n         if (original.getPassword() != null && !original.getPassword().equals(updated.getPassword())) {\n-\n             result.setPassword(updated.getPassword());\n         }\n \n         // 2. username\n         if (original.getUsername() != null && !original.getUsername().equals(updated.getUsername())) {\n-\n             result.setUsername(updated.getUsername());\n         }\n \n@@ -278,9 +276,21 @@ public static UserMod diff(final UserTO updated, final UserTO original, boolean\n      * @return RoleMod containing differences\n      */\n     public static RoleMod diff(final RoleTO updated, final RoleTO original) {\n+        return diff(updated, original, false);\n+    }\n+\n+    /**\n+     * Calculate modifications needed by first in order to be equal to second.\n+     *\n+     * @param updated updated RoleTO\n+     * @param original original RoleTO\n+     * @param incremental perform incremental diff (without removing existing info)\n+     * @return RoleMod containing differences\n+     */\n+    public static RoleMod diff(final RoleTO updated, final RoleTO original, final boolean incremental) {\n         RoleMod result = new RoleMod();\n \n-        diff(updated, original, result, false);\n+        diff(updated, original, result, incremental);\n \n         // 1. inheritance\n         result.setInheritOwner(updated.isInheritOwner());"},{"sha":"aff1523bdc95592fdca8420aec10c1458684e405","filename":"client/src/main/java/org/apache/syncope/types/EntityViolationType.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/client%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Ftypes%2FEntityViolationType.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/client%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Ftypes%2FEntityViolationType.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/client%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Ftypes%2FEntityViolationType.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -23,6 +23,7 @@ public enum EntityViolationType {\n     Standard(\"\"),\n     InvalidAccountPolicy(\"org.apache.syncope.core.validation.accountpolicy\"),\n     InvalidEntitlementName(\"org.apache.syncope.core.validation.entitlement.name\"),\n+    InvalidMapping(\"org.apache.syncope.core.validation.mapping\"),\n     InvalidMSchema(\"org.apache.syncope.core.validation.attrvalue.mSchema\"),\n     InvalidMDerSchema(\"org.apache.syncope.core.validation.attrvalue.mDerSchema\"),\n     InvalidMVirSchema(\"org.apache.syncope.core.validation.attrvalue.mVirSchema\"),\n@@ -40,7 +41,6 @@ public enum EntityViolationType {\n     InvalidSchemaTypeSpecification(\"org.apache.syncope.core.validation.attrvalue.schemaTypeSpecification\"),\n     InvalidSchedTask(\"org.apache.syncope.core.validation.schedtask\"),\n     InvalidSyncTask(\"org.apache.syncope.core.validation.synctask\"),\n-    InvalidSchemaMapping(\"org.apache.syncope.core.validation.mapping\"),\n     InvalidSyncPolicy(\"org.apache.syncope.core.validation.syncpolicy\"),\n     InvalidUSchema(\"org.apache.syncope.core.validation.attrvalue.uSchema\"),\n     InvalidUDerSchema(\"org.apache.syncope.core.validation.attrvalue.derSchema\"),"},{"sha":"8105a3084f54541f94aa87bd04fdf0690e700c26","filename":"client/src/main/java/org/apache/syncope/types/IntMappingType.java","status":"modified","additions":29,"deletions":8,"changes":37,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/client%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Ftypes%2FIntMappingType.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/client%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Ftypes%2FIntMappingType.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/client%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Ftypes%2FIntMappingType.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -34,21 +34,24 @@ public enum IntMappingType {\n     UserSchema(AttributableType.USER),\n     UserDerivedSchema(AttributableType.USER),\n     UserVirtualSchema(AttributableType.USER),\n-    SyncopeUserId(AttributableType.USER),\n-    Password(AttributableType.USER),\n+    UserId(AttributableType.USER),\n     Username(AttributableType.USER),\n+    Password(AttributableType.USER),\n     // -------------------------\n     // Role attribute types (the same in RoleMappingType)\n     // -------------------------\n     RoleSchema(AttributableType.ROLE),\n     RoleDerivedSchema(AttributableType.ROLE),\n     RoleVirtualSchema(AttributableType.ROLE),\n+    RoleId(AttributableType.ROLE),\n+    RoleName(AttributableType.ROLE),\n     // -------------------------\n     // Membership attribute types (the same in MembershipMappingType)\n     // -------------------------\n     MembershipSchema(AttributableType.MEMBERSHIP),\n     MembershipDerivedSchema(AttributableType.MEMBERSHIP),\n-    MembershipVirtualSchema(AttributableType.MEMBERSHIP);\n+    MembershipVirtualSchema(AttributableType.MEMBERSHIP),\n+    MembershipId(AttributableType.MEMBERSHIP);\n \n     private AttributableType attributableType;\n \n@@ -105,6 +108,13 @@ public static Set<IntMappingType> getAttributeTypes(final AttributableType attri\n         return res;\n     }\n \n+    public static Set<IntMappingType> getEmbedded() {\n+        return EnumSet.of(\n+                IntMappingType.UserId, IntMappingType.Username, IntMappingType.Password,\n+                IntMappingType.RoleId, IntMappingType.RoleName,\n+                IntMappingType.MembershipId);\n+    }\n+\n     /**\n      * Check if attribute type belongs to the specified attributable type set.\n      *\n@@ -120,19 +130,24 @@ public static boolean contains(final AttributableType attributableType, final St\n                         return true;\n                     }\n                 }\n+                break;\n+\n             case MEMBERSHIP:\n                 for (MembershipMappingType c : MembershipMappingType.values()) {\n                     if (c.name().equals(type)) {\n                         return true;\n                     }\n                 }\n+                break;\n+\n             case USER:\n             default:\n                 for (UserMappingType c : UserMappingType.values()) {\n                     if (c.name().equals(type)) {\n                         return true;\n                     }\n                 }\n+                break;\n         }\n         return false;\n     }\n@@ -145,9 +160,10 @@ private enum UserMappingType {\n         UserSchema,\n         UserDerivedSchema,\n         UserVirtualSchema,\n-        SyncopeUserId,\n-        Password,\n-        Username;\n+        UserId,\n+        Username,\n+        Password;\n+\n     }\n \n     /**\n@@ -157,7 +173,10 @@ private enum RoleMappingType {\n \n         RoleSchema,\n         RoleDerivedSchema,\n-        RoleVirtualSchema;\n+        RoleVirtualSchema,\n+        RoleId,\n+        RoleName;\n+\n     }\n \n     /**\n@@ -167,6 +186,8 @@ private enum MembershipMappingType {\n \n         MembershipSchema,\n         MembershipDerivedSchema,\n-        MembershipVirtualSchema;\n+        MembershipVirtualSchema,\n+        MembershipId;\n+\n     }\n }"},{"sha":"3c87a46a83960602c52f3a0be6623ef3e941d937","filename":"client/src/main/java/org/apache/syncope/types/ResourceOperation.java","status":"renamed","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/client%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Ftypes%2FResourceOperation.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/client%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Ftypes%2FResourceOperation.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/client%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Ftypes%2FResourceOperation.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -18,7 +18,7 @@\n  */\n package org.apache.syncope.types;\n \n-public enum PropagationOperation {\n+public enum ResourceOperation {\n \n     CREATE,\n     UPDATE,","previous_filename":"client/src/main/java/org/apache/syncope/types/PropagationOperation.java"},{"sha":"16f80ca1e58cc738b0054bcdbf7f82fbf74d6bf9","filename":"client/src/main/java/org/apache/syncope/types/SyncPolicySpec.java","status":"modified","additions":30,"deletions":14,"changes":44,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/client%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Ftypes%2FSyncPolicySpec.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/client%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Ftypes%2FSyncPolicySpec.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/client%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Ftypes%2FSyncPolicySpec.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -27,36 +27,52 @@ public class SyncPolicySpec extends AbstractPolicySpec {\n     private static final long serialVersionUID = -3144027171719498127L;\n \n     /**\n-     * SyncopeUsers attributes and user schemas used to disambiguate.\n+     * SyncopeUser attributes and fields for matching during synchronization.\n      */\n     @SchemaList(extended = true)\n-    private List<String> alternativeSearchAttrs;\n+    private List<String> uAltSearchSchemas;\n+\n+    /**\n+     * SyncopeRole attributes and fields for matching during synchronization.\n+     */\n+    @SchemaList(extended = true)\n+    private List<String> rAltSearchSchemas;\n \n     /**\n      * Conflict resolution action.\n      */\n     private ConflictResolutionAction conflictResolutionAction;\n \n+    public SyncPolicySpec() {\n+        super();\n+\n+        uAltSearchSchemas = new ArrayList<String>();\n+        rAltSearchSchemas = new ArrayList<String>();\n+    }\n+\n     public ConflictResolutionAction getConflictResolutionAction() {\n-        if (conflictResolutionAction == null) {\n-            return ConflictResolutionAction.IGNORE;\n-        } else {\n-            return conflictResolutionAction;\n-        }\n+        return conflictResolutionAction == null\n+                ? ConflictResolutionAction.IGNORE\n+                : conflictResolutionAction;\n     }\n \n     public void setConflictResolutionAction(final ConflictResolutionAction conflictResolutionAction) {\n         this.conflictResolutionAction = conflictResolutionAction;\n     }\n \n-    public List<String> getAlternativeSearchAttrs() {\n-        if (alternativeSearchAttrs == null) {\n-            alternativeSearchAttrs = new ArrayList<String>();\n-        }\n-        return alternativeSearchAttrs;\n+    public List<String> getuAltSearchSchemas() {\n+        return uAltSearchSchemas;\n+    }\n+\n+    public void setuAltSearchSchemas(List<String> uAltSearchSchemas) {\n+        this.uAltSearchSchemas = uAltSearchSchemas;\n+    }\n+\n+    public List<String> getrAltSearchSchemas() {\n+        return rAltSearchSchemas;\n     }\n \n-    public void setAlternativeSearchAttrs(final List<String> alternativeSearchAttrs) {\n-        this.alternativeSearchAttrs = alternativeSearchAttrs;\n+    public void setrAltSearchSchemas(List<String> rAltSearchSchemas) {\n+        this.rAltSearchSchemas = rAltSearchSchemas;\n     }\n }"},{"sha":"333afa8560b24055bb3a8b73d5fab70e7dc7977a","filename":"client/src/main/java/org/apache/syncope/types/SyncopeClientExceptionType.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/client%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Ftypes%2FSyncopeClientExceptionType.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/client%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Ftypes%2FSyncopeClientExceptionType.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/client%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Ftypes%2FSyncopeClientExceptionType.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -56,7 +56,7 @@ public enum SyncopeClientExceptionType {\n     InvalidValues(\"Syncope.InvalidValues\", \"Syncope.InvalidValues.attributeName\"),\n     NotFound(\"Syncope.NotFound\", \"Syncope.NotFound.entity\"),\n     Propagation(\"Syncope.Propagation\", \"Syncope.Propagation.resourceName\"),\n-    RejectedUserCreate(\"Syncope.RejectUserCreate\", \"Syncope.RejectUserCreate.syncopeUserId\"),\n+    RejectedUserCreate(\"Syncope.RejectUserCreate\", \"Syncope.RejectUserCreate.userId\"),\n     RequiredValuesMissing(\"Syncope.RequiredValuesMissing\", \"Syncope.RequiredValuesMissing.attributeName\"),\n     Scheduling(\"Syncope.Scheduling\", \"Syncope.Scheduling.message\"),\n     UnauthorizedRole(\"Syncope.UnauthorizedRole\", \"Syncope.UnauthorizedRole.id\"),"},{"sha":"08939ddf967b305a871641354c85838e25115d8f","filename":"console/pom.xml","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/console%2Fpom.xml","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/console%2Fpom.xml","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/console%2Fpom.xml?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -25,7 +25,7 @@ under the License.\n   <parent>\n     <groupId>org.apache.syncope</groupId>\n     <artifactId>syncope</artifactId>\n-    <version>1.1.0-SNAPSHOT</version>\n+    <version>1.1.0-RP-SNAPSHOT</version>\n   </parent>\n \n   <name>Apache Syncope Console</name>\n@@ -523,7 +523,7 @@ under the License.\n               </execution>\n               <execution>\n                 <id>stop-container</id>\n-                <phase>post-integration-test</phase>\n+                <phase>post-integratison-test</phase>\n                 <goals>\n                   <goal>stop</goal>\n                 </goals>"},{"sha":"b8f5b2d4e089cdf5ba3368e832607cafd4c823b1","filename":"console/src/main/java/org/apache/syncope/console/commons/StatusUtils.java","status":"modified","additions":14,"deletions":12,"changes":26,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/console%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fconsole%2Fcommons%2FStatusUtils.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/console%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fconsole%2Fcommons%2FStatusUtils.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/console%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fconsole%2Fcommons%2FStatusUtils.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -23,17 +23,17 @@\n import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-import org.springframework.beans.factory.annotation.Autowired;\n import org.apache.syncope.client.to.AttributeTO;\n import org.apache.syncope.client.to.ConnObjectTO;\n+import org.apache.syncope.client.to.MappingItemTO;\n import org.apache.syncope.client.to.ResourceTO;\n-import org.apache.syncope.client.to.SchemaMappingTO;\n import org.apache.syncope.client.to.UserTO;\n import org.apache.syncope.console.rest.ResourceRestClient;\n import org.apache.syncope.console.rest.UserRestClient;\n import org.apache.syncope.types.IntMappingType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n \n public class StatusUtils {\n \n@@ -73,9 +73,9 @@ public List<StatusBean> getRemoteStatuses(final UserTO userTO) {\n \n             switch (accountId != null\n                     ? accountId.getKey()\n-                    : IntMappingType.SyncopeUserId) {\n+                    : IntMappingType.UserId) {\n \n-                case SyncopeUserId:\n+                case UserId:\n                     objectId = String.valueOf(userTO.getId());\n                     break;\n                 case Username:\n@@ -131,8 +131,8 @@ public StatusBean getRemoteStatus(final ConnObjectTO objectTO) {\n             final StatusUtils.Status status = enabled == null\n                     ? StatusUtils.Status.UNDEFINED\n                     : enabled\n-                            ? StatusUtils.Status.ACTIVE\n-                            : StatusUtils.Status.SUSPENDED;\n+                    ? StatusUtils.Status.ACTIVE\n+                    : StatusUtils.Status.SUSPENDED;\n \n             final String accountLink = getAccountLink(objectTO);\n \n@@ -172,10 +172,12 @@ public String getAccountLink(final ConnObjectTO objectTO) {\n     public Map.Entry<IntMappingType, String> getAccountId(final ResourceTO resourceTO) {\n         Map.Entry<IntMappingType, String> accountId = null;\n \n-        for (SchemaMappingTO mapping : resourceTO.getMappings()) {\n-            if (mapping.isAccountid()) {\n-                accountId = new AbstractMap.SimpleEntry<IntMappingType, String>(mapping.getIntMappingType(), mapping\n-                        .getIntAttrName());\n+        if (resourceTO.getUmapping() != null) {\n+            for (MappingItemTO item : resourceTO.getUmapping().getItems()) {\n+                if (item.isAccountid()) {\n+                    accountId = new AbstractMap.SimpleEntry<IntMappingType, String>(\n+                            item.getIntMappingType(), item.getIntAttrName());\n+                }\n             }\n         }\n "},{"sha":"aefb3dc11c035f6acb447f67d197cb195b8308b6","filename":"console/src/main/java/org/apache/syncope/console/pages/NotificationModalPage.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/console%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fconsole%2Fpages%2FNotificationModalPage.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/console%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fconsole%2Fpages%2FNotificationModalPage.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/console%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fconsole%2Fpages%2FNotificationModalPage.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -107,7 +107,7 @@ public NotificationModalPage(final PageReference callPageRef, final ModalWindow\n                 new PropertyModel<IntMappingType>(notificationTO, \"recipientAttrType\"));\n \n         final Set<IntMappingType> toBeFiltered = new HashSet<IntMappingType>();\n-        toBeFiltered.add(IntMappingType.SyncopeUserId);\n+        toBeFiltered.add(IntMappingType.UserId);\n         toBeFiltered.add(IntMappingType.Password);\n \n         recipientAttrType.setChoices(new ArrayList<IntMappingType>("},{"sha":"181daf84c7bf685fdb60c52a6672d72a9178a769","filename":"console/src/main/java/org/apache/syncope/console/pages/ResourceModalPage.java","status":"modified","additions":3,"deletions":3,"changes":6,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/console%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fconsole%2Fpages%2FResourceModalPage.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/console%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fconsole%2Fpages%2FResourceModalPage.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/console%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fconsole%2Fpages%2FResourceModalPage.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -18,8 +18,8 @@\n  */\n package org.apache.syncope.console.pages;\n \n+import org.apache.syncope.client.to.MappingItemTO;\n import org.apache.syncope.client.to.ResourceTO;\n-import org.apache.syncope.client.to.SchemaMappingTO;\n import org.apache.syncope.console.commons.CloseOnESCBehavior;\n import org.apache.syncope.console.pages.panels.ResourceConnConfPanel;\n import org.apache.syncope.console.pages.panels.ResourceDetailsPanel;\n@@ -91,8 +91,8 @@ protected void onSubmit(final AjaxRequestTarget target, final Form<?> form) {\n \n                 int accountIdCount = 0;\n \n-                for (SchemaMappingTO mapping : resourceTO.getMappings()) {\n-                    if (mapping.isAccountid()) {\n+                for (MappingItemTO item : resourceTO.getUmapping().getItems()) {\n+                    if (item.isAccountid()) {\n                         accountIdCount++;\n                     }\n                 }"},{"sha":"da3cff44319df7de120a2f4f69a82cdb204092d6","filename":"console/src/main/java/org/apache/syncope/console/pages/panels/PolicyBeanPanel.java","status":"modified","additions":10,"deletions":10,"changes":20,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/console%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fconsole%2Fpages%2Fpanels%2FPolicyBeanPanel.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/console%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fconsole%2Fpages%2Fpanels%2FPolicyBeanPanel.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/console%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fconsole%2Fpages%2Fpanels%2FPolicyBeanPanel.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -26,6 +26,15 @@\n import java.util.List;\n import java.util.Set;\n import org.apache.syncope.annotation.SchemaList;\n+import org.apache.syncope.console.commons.XMLRolesReader;\n+import org.apache.syncope.console.rest.SchemaRestClient;\n+import org.apache.syncope.console.wicket.markup.html.form.AbstractFieldPanel;\n+import org.apache.syncope.console.wicket.markup.html.form.AjaxCheckBoxPanel;\n+import org.apache.syncope.console.wicket.markup.html.form.AjaxDropDownChoicePanel;\n+import org.apache.syncope.console.wicket.markup.html.form.AjaxPalettePanel;\n+import org.apache.syncope.console.wicket.markup.html.form.AjaxTextFieldPanel;\n+import org.apache.syncope.console.wicket.markup.html.form.FieldPanel;\n+import org.apache.syncope.console.wicket.markup.html.form.MultiValueSelectorPanel;\n import org.apache.syncope.types.AbstractPolicySpec;\n import org.apache.syncope.types.AttributableType;\n import org.apache.syncope.types.ConflictResolutionAction;\n@@ -45,15 +54,6 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.springframework.util.StringUtils;\n-import org.apache.syncope.console.commons.XMLRolesReader;\n-import org.apache.syncope.console.rest.SchemaRestClient;\n-import org.apache.syncope.console.wicket.markup.html.form.AbstractFieldPanel;\n-import org.apache.syncope.console.wicket.markup.html.form.AjaxCheckBoxPanel;\n-import org.apache.syncope.console.wicket.markup.html.form.AjaxDropDownChoicePanel;\n-import org.apache.syncope.console.wicket.markup.html.form.AjaxPalettePanel;\n-import org.apache.syncope.console.wicket.markup.html.form.AjaxTextFieldPanel;\n-import org.apache.syncope.console.wicket.markup.html.form.FieldPanel;\n-import org.apache.syncope.console.wicket.markup.html.form.MultiValueSelectorPanel;\n \n public class PolicyBeanPanel extends Panel {\n \n@@ -210,7 +210,7 @@ private <T extends Serializable> AjaxCheckBoxPanel getActivationControl(final Ab\n             private static final long serialVersionUID = -1107858522700306810L;\n \n             @Override\n-            protected void onUpdate(AjaxRequestTarget target) {\n+            protected void onUpdate(final AjaxRequestTarget target) {\n                 if (check.getModelObject()) {\n                     panel.setEnabled(true);\n                     panel.setModelObject(reinitializedValue);"},{"sha":"e9d5580b5f1376c6377cea86e2607d4fd0ee689d","filename":"console/src/main/java/org/apache/syncope/console/pages/panels/ResourceDetailsPanel.java","status":"modified","additions":4,"deletions":3,"changes":7,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/console%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fconsole%2Fpages%2Fpanels%2FResourceDetailsPanel.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/console%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fconsole%2Fpages%2Fpanels%2FResourceDetailsPanel.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/console%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fconsole%2Fpages%2Fpanels%2FResourceDetailsPanel.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -130,7 +130,7 @@ protected List<ConnInstanceTO> load() {\n         add(deleteTraceLevel);\n \n         final AjaxDropDownChoicePanel<TraceLevel> syncTraceLevel = new AjaxDropDownChoicePanel<TraceLevel>(\n-                \"syncTraceLevel\", new ResourceModel(\"syncTraceLevel\", \"syncTraceLevel\").getObject(), \n+                \"syncTraceLevel\", new ResourceModel(\"syncTraceLevel\", \"syncTraceLevel\").getObject(),\n                 new PropertyModel<TraceLevel>(resourceTO, \"syncTraceLevel\"));\n         syncTraceLevel.setChoices(Arrays.asList(TraceLevel.values()));\n         add(syncTraceLevel);\n@@ -145,14 +145,15 @@ protected List<ConnInstanceTO> load() {\n             @Override\n             protected void onUpdate(final AjaxRequestTarget art) {\n                 if (resetToken.getModelObject()) {\n-                    resourceTO.setSyncToken(null);\n+                    resourceTO.setUsyncToken(null);\n+                    resourceTO.setRsyncToken(null);\n                 }\n             }\n         });\n         add(resetToken);\n \n         final AjaxDropDownChoicePanel<ConnInstanceTO> conn = new AjaxDropDownChoicePanel<ConnInstanceTO>(\"connector\",\n-                new ResourceModel(\"connector\", \"connector\").getObject(), \n+                new ResourceModel(\"connector\", \"connector\").getObject(),\n                 new PropertyModel<ConnInstanceTO>(this, \"connInstanceTO\"));\n         conn.setChoices(connectors.getObject());\n         conn.setChoiceRenderer(new ChoiceRenderer(\"displayName\", \"id\"));"},{"sha":"5fb456b8a20386a8fb75f2723b62e739dff6add6","filename":"console/src/main/java/org/apache/syncope/console/pages/panels/ResourceMappingPanel.java","status":"modified","additions":52,"deletions":49,"changes":101,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/console%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fconsole%2Fpages%2Fpanels%2FResourceMappingPanel.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/console%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fconsole%2Fpages%2Fpanels%2FResourceMappingPanel.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/console%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fconsole%2Fpages%2Fpanels%2FResourceMappingPanel.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -18,13 +18,27 @@\n  */\n package org.apache.syncope.console.pages.panels;\n \n-import java.io.Serializable;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collections;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Set;\n+import org.apache.syncope.client.to.ConnInstanceTO;\n+import org.apache.syncope.client.to.MappingItemTO;\n+import org.apache.syncope.client.to.MappingTO;\n+import org.apache.syncope.client.to.ResourceTO;\n+import org.apache.syncope.console.pages.panels.ResourceConnConfPanel.ConnConfModEvent;\n+import org.apache.syncope.console.rest.ConnectorRestClient;\n+import org.apache.syncope.console.rest.SchemaRestClient;\n+import org.apache.syncope.console.wicket.markup.html.form.AjaxCheckBoxPanel;\n+import org.apache.syncope.console.wicket.markup.html.form.AjaxDecoratedCheckbox;\n+import org.apache.syncope.console.wicket.markup.html.form.AjaxDropDownChoicePanel;\n+import org.apache.syncope.console.wicket.markup.html.form.AjaxTextFieldPanel;\n+import org.apache.syncope.console.wicket.markup.html.form.FieldPanel;\n+import org.apache.syncope.types.AttributableType;\n+import org.apache.syncope.types.ConnConfProperty;\n+import org.apache.syncope.types.IntMappingType;\n import org.apache.wicket.ajax.AjaxRequestTarget;\n import org.apache.wicket.ajax.form.AjaxFormComponentUpdatingBehavior;\n import org.apache.wicket.ajax.markup.html.form.AjaxButton;\n@@ -41,20 +55,6 @@\n import org.apache.wicket.spring.injection.annot.SpringBean;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n-import org.apache.syncope.client.to.ConnInstanceTO;\n-import org.apache.syncope.client.to.ResourceTO;\n-import org.apache.syncope.client.to.SchemaMappingTO;\n-import org.apache.syncope.console.pages.panels.ResourceConnConfPanel.ConnConfModEvent;\n-import org.apache.syncope.console.rest.ConnectorRestClient;\n-import org.apache.syncope.console.rest.SchemaRestClient;\n-import org.apache.syncope.console.wicket.markup.html.form.AjaxCheckBoxPanel;\n-import org.apache.syncope.console.wicket.markup.html.form.AjaxDecoratedCheckbox;\n-import org.apache.syncope.console.wicket.markup.html.form.AjaxDropDownChoicePanel;\n-import org.apache.syncope.console.wicket.markup.html.form.AjaxTextFieldPanel;\n-import org.apache.syncope.console.wicket.markup.html.form.FieldPanel;\n-import org.apache.syncope.types.AttributableType;\n-import org.apache.syncope.types.ConnConfProperty;\n-import org.apache.syncope.types.IntMappingType;\n import org.apache.wicket.Component;\n import org.apache.wicket.ajax.attributes.AjaxCallListener;\n import org.apache.wicket.ajax.attributes.AjaxRequestAttributes;\n@@ -115,7 +115,7 @@ public class ResourceMappingPanel extends Panel {\n      * Mapping container.\n      */\n     private final transient WebMarkupContainer mappingContainer;\n-    \n+\n     /**\n      * AccountLink container.\n      */\n@@ -153,30 +153,33 @@ public ResourceMappingPanel(final String panelid, final ResourceTO resourceTO) {\n         setOutputMarkupId(true);\n \n         this.resourceTO = resourceTO;\n+        if (resourceTO.getUmapping() == null) {\n+            resourceTO.setUmapping(new MappingTO());\n+        }\n \n         initResourceSchemaNames();\n-        \n+\n         accountLinkContainer = new WebMarkupContainer(\"accountLinkContainer\");\n         accountLinkContainer.setOutputMarkupId(true);\n         add(accountLinkContainer);\n \n         boolean accountLinkEnabled = false;\n-        if (resourceTO.getAccountLink() != null) {\n+        if (resourceTO.getUmapping().getAccountLink() != null) {\n             accountLinkEnabled = true;\n         }\n-        final AjaxCheckBoxPanel accountLinkCheckbox = new AjaxCheckBoxPanel(\"accountLinkCheckbox\", \n-                        new ResourceModel(\"accountLinkCheckbox\", \"accountLinkCheckbox\").getObject(),\n-                        new Model<Boolean>(Boolean.valueOf(accountLinkEnabled)));\n+        final AjaxCheckBoxPanel accountLinkCheckbox = new AjaxCheckBoxPanel(\"accountLinkCheckbox\",\n+                new ResourceModel(\"accountLinkCheckbox\", \"accountLinkCheckbox\").getObject(),\n+                new Model<Boolean>(Boolean.valueOf(accountLinkEnabled)));\n         accountLinkCheckbox.setEnabled(true);\n-        \n+\n         accountLinkContainer.add(accountLinkCheckbox);\n \n         final AjaxTextFieldPanel accountLink = new AjaxTextFieldPanel(\"accountLink\", new ResourceModel(\"accountLink\",\n-                \"accountLink\").getObject(), new PropertyModel<String>(resourceTO, \"accountLink\"));\n+                \"accountLink\").getObject(), new PropertyModel<String>(resourceTO.getUmapping(), \"accountLink\"));\n         accountLink.setEnabled(accountLinkEnabled);\n-        \n+\n         accountLinkContainer.add(accountLink);\n-        \n+\n         accountLinkCheckbox.getField().add(new AjaxFormComponentUpdatingBehavior(\"onchange\") {\n \n             private static final long serialVersionUID = -1107858522700306810L;\n@@ -190,31 +193,31 @@ protected void onUpdate(final AjaxRequestTarget target) {\n                     accountLink.setEnabled(Boolean.FALSE);\n                     accountLink.setModelObject(\"\");\n                 }\n-                \n+\n                 target.add(accountLink);\n             }\n         });\n-        \n+\n \n         mappingContainer = new WebMarkupContainer(\"mappingContainer\");\n         mappingContainer.setOutputMarkupId(true);\n         add(mappingContainer);\n \n-        mappings = new ListView<SchemaMappingTO>(\"mappings\", resourceTO.getMappings()) {\n+        mappings = new ListView<MappingItemTO>(\"mappings\", resourceTO.getUmapping().getItems()) {\n \n             /**\n              * Serial version UID.\n              */\n             private static final long serialVersionUID = 4949588177564901031L;\n \n             @Override\n-            protected void populateItem(final ListItem<SchemaMappingTO> item) {\n+            protected void populateItem(final ListItem<MappingItemTO> item) {\n \n-                final SchemaMappingTO mappingTO = item.getModelObject();\n+                final MappingItemTO mapItem = item.getModelObject();\n \n                 final AttributableType entity;\n-                if (mappingTO.getIntMappingType() != null) {\n-                    entity = mappingTO.getIntMappingType().getAttributableType();\n+                if (mapItem.getIntMappingType() != null) {\n+                    entity = mapItem.getIntMappingType().getAttributableType();\n                 } else {\n                     entity = null;\n                 }\n@@ -228,14 +231,14 @@ protected void populateItem(final ListItem<SchemaMappingTO> item) {\n                     @Override\n                     protected void onUpdate(final AjaxRequestTarget target) {\n                         int index = -1;\n-                        for (int i = 0; i < resourceTO.getMappings().size() && index == -1; i++) {\n-                            if (mappingTO.equals(resourceTO.getMappings().get(i))) {\n+                        for (int i = 0; i < resourceTO.getUmapping().getItems().size() && index == -1; i++) {\n+                            if (mapItem.equals(resourceTO.getUmapping().getItems().get(i))) {\n                                 index = i;\n                             }\n                         }\n \n                         if (index != -1) {\n-                            resourceTO.getMappings().remove(index);\n+                            resourceTO.getUmapping().getItems().remove(index);\n                             item.getParent().removeAll();\n                             target.add(mappingContainer);\n                         }\n@@ -259,7 +262,7 @@ public CharSequence getPrecondition(final Component component) {\n                 });\n \n                 final AjaxDropDownChoicePanel<String> intAttrNames = new AjaxDropDownChoicePanel<String>(\"intAttrNames\",\n-                        getString(\"intAttrNames\"), new PropertyModel<String>(mappingTO, \"intAttrName\"));\n+                        getString(\"intAttrNames\"), new PropertyModel<String>(mapItem, \"intAttrName\"));\n                 intAttrNames.setChoices(schemaNames);\n                 intAttrNames.setRequired(true);\n                 intAttrNames.setStyleSheet(fieldStyle);\n@@ -268,7 +271,7 @@ public CharSequence getPrecondition(final Component component) {\n                 final AjaxDropDownChoicePanel<IntMappingType> typesPanel =\n                         new AjaxDropDownChoicePanel<IntMappingType>(\"intMappingTypes\",\n                         new ResourceModel(\"intMappingTypes\", \"intMappingTypes\").getObject(),\n-                        new PropertyModel<IntMappingType>(mappingTO, \"intMappingType\"));\n+                        new PropertyModel<IntMappingType>(mapItem, \"intMappingType\"));\n \n                 // typesPanel onChange behavior provided below ...\n \n@@ -308,16 +311,16 @@ protected void onUpdate(final AjaxRequestTarget target) {\n \n                 if (schemaNames.isEmpty()) {\n                     extAttrName = new AjaxTextFieldPanel(\"extAttrName\", new ResourceModel(\"extAttrNames\",\n-                            \"extAttrNames\").getObject(), new PropertyModel<String>(mappingTO, \"extAttrName\"));\n+                            \"extAttrNames\").getObject(), new PropertyModel<String>(mapItem, \"extAttrName\"));\n \n                 } else {\n                     extAttrName = new AjaxDropDownChoicePanel<String>(\"extAttrName\", new ResourceModel(\"extAttrNames\",\n-                            \"extAttrNames\").getObject(), new PropertyModel(mappingTO, \"extAttrName\"));\n+                            \"extAttrNames\").getObject(), new PropertyModel(mapItem, \"extAttrName\"));\n                     ((AjaxDropDownChoicePanel) extAttrName).setChoices(schemaNames);\n                 }\n \n                 boolean required = false;\n-                if (mappingTO != null && !mappingTO.isAccountid() && !mappingTO.isPassword()) {\n+                if (mapItem != null && !mapItem.isAccountid() && !mapItem.isPassword()) {\n                     required = true;\n                 }\n \n@@ -329,7 +332,7 @@ protected void onUpdate(final AjaxRequestTarget target) {\n                 item.add(extAttrName);\n \n                 final AjaxTextFieldPanel mandatory = new AjaxTextFieldPanel(\"mandatoryCondition\", new ResourceModel(\n-                        \"mandatoryCondition\", \"mandatoryCondition\").getObject(), new PropertyModel(mappingTO,\n+                        \"mandatoryCondition\", \"mandatoryCondition\").getObject(), new PropertyModel(mapItem,\n                         \"mandatoryCondition\"));\n \n                 mandatory.setChoices(Arrays.asList(new String[]{\"true\", \"false\"}));\n@@ -339,15 +342,15 @@ protected void onUpdate(final AjaxRequestTarget target) {\n                 item.add(mandatory);\n \n                 final AjaxCheckBoxPanel accountId = new AjaxCheckBoxPanel(\"accountId\", new ResourceModel(\"accountId\",\n-                        \"accountId\").getObject(), new PropertyModel(mappingTO, \"accountid\"));\n+                        \"accountId\").getObject(), new PropertyModel(mapItem, \"accountid\"));\n \n                 accountId.getField().add(new AjaxFormComponentUpdatingBehavior(onchange) {\n \n                     private static final long serialVersionUID = -1107858522700306810L;\n \n                     @Override\n                     protected void onUpdate(final AjaxRequestTarget target) {\n-                        extAttrName.setEnabled(!accountId.getModelObject() && !mappingTO.isPassword());\n+                        extAttrName.setEnabled(!accountId.getModelObject() && !mapItem.isPassword());\n                         extAttrName.setModelObject(null);\n                         extAttrName.setRequired(!accountId.getModelObject());\n                         target.add(extAttrName);\n@@ -357,15 +360,15 @@ protected void onUpdate(final AjaxRequestTarget target) {\n                 item.add(accountId);\n \n                 final AjaxCheckBoxPanel password = new AjaxCheckBoxPanel(\"password\", new ResourceModel(\"password\",\n-                        \"password\").getObject(), new PropertyModel(mappingTO, \"password\"));\n+                        \"password\").getObject(), new PropertyModel(mapItem, \"password\"));\n \n                 password.getField().add(new AjaxFormComponentUpdatingBehavior(onchange) {\n \n                     private static final long serialVersionUID = -1107858522700306810L;\n \n                     @Override\n                     protected void onUpdate(final AjaxRequestTarget target) {\n-                        extAttrName.setEnabled(!mappingTO.isAccountid() && !password.getModelObject());\n+                        extAttrName.setEnabled(!mapItem.isAccountid() && !password.getModelObject());\n                         extAttrName.setModelObject(null);\n                         extAttrName.setRequired(!password.getModelObject());\n                         target.add(extAttrName);\n@@ -391,8 +394,8 @@ protected void onUpdate(final AjaxRequestTarget target) {\n                     }\n                 });\n \n-                setAttrNames(mappingTO.getIntMappingType(), intAttrNames);\n-                setAccountId(mappingTO.getIntMappingType(), accountId, password);\n+                setAttrNames(mapItem.getIntMappingType(), intAttrNames);\n+                setAccountId(mapItem.getIntMappingType(), accountId, password);\n             }\n         };\n \n@@ -405,7 +408,7 @@ protected void onUpdate(final AjaxRequestTarget target) {\n \n             @Override\n             protected void onSubmit(final AjaxRequestTarget target, final Form<?> form) {\n-                resourceTO.getMappings().add(new SchemaMappingTO());\n+                resourceTO.getUmapping().getItems().add(new MappingItemTO());\n                 target.add(mappingContainer);\n             }\n \n@@ -511,7 +514,7 @@ private void setAttrNames(final IntMappingType type, final AjaxDropDownChoicePan\n                     toBeUpdated.setChoices(schemaRestClient.getVirtualSchemaNames(type.getAttributableType()));\n                     break;\n \n-                case SyncopeUserId:\n+                case UserId:\n                 case Password:\n                 case Username:\n                 default:"},{"sha":"6ca6d5fa4188a97eabbdd4be5d3ce43c2865a77d","filename":"console/src/main/java/org/apache/syncope/console/pages/panels/UserSearchPanel.java","status":"modified","additions":8,"deletions":8,"changes":16,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/console%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fconsole%2Fpages%2Fpanels%2FUserSearchPanel.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/console%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fconsole%2Fpages%2Fpanels%2FUserSearchPanel.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/console%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fconsole%2Fpages%2Fpanels%2FUserSearchPanel.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -23,11 +23,11 @@\n import java.util.Arrays;\n import java.util.Collections;\n import java.util.List;\n+import org.apache.syncope.client.search.AttributableCond;\n import org.apache.syncope.client.search.AttributeCond;\n import org.apache.syncope.client.search.MembershipCond;\n import org.apache.syncope.client.search.NodeCond;\n import org.apache.syncope.client.search.ResourceCond;\n-import org.apache.syncope.client.search.SyncopeUserCond;\n import org.apache.syncope.client.to.ResourceTO;\n import org.apache.syncope.client.to.RoleTO;\n import org.apache.syncope.client.to.UserTO;\n@@ -321,11 +321,11 @@ private List<SearchCondWrapper> getSearchCondWrappers(final NodeCond searchCond,\n     private SearchCondWrapper getSearchCondWrapper(final NodeCond searchCond) {\n         SearchCondWrapper wrapper = new SearchCondWrapper();\n \n-        if (searchCond.getSyncopeUserCond() != null) {\n+        if (searchCond.getAttributableCond() != null) {\n             wrapper.setFilterType(FilterType.ATTRIBUTE);\n-            wrapper.setFilterName(searchCond.getSyncopeUserCond().getSchema());\n-            wrapper.setType(searchCond.getSyncopeUserCond().getType());\n-            wrapper.setFilterValue(searchCond.getSyncopeUserCond().getExpression());\n+            wrapper.setFilterName(searchCond.getAttributableCond().getSchema());\n+            wrapper.setType(searchCond.getAttributableCond().getType());\n+            wrapper.setFilterValue(searchCond.getAttributableCond().getExpression());\n         }\n         if (searchCond.getAttributeCond() != null) {\n             wrapper.setFilterType(FilterType.ATTRIBUTE);\n@@ -374,10 +374,10 @@ private NodeCond buildSearchCond(final List<SearchCondWrapper> conditions) {\n \n                 final AttributeCond attributeCond;\n                 if (dnames.getObject().contains(schema)) {\n-                    attributeCond = new SyncopeUserCond();\n+                    attributeCond = new AttributableCond();\n                     nodeCond = searchConditionWrapper.isNotOperator()\n-                            ? NodeCond.getNotLeafCond((SyncopeUserCond) attributeCond)\n-                            : NodeCond.getLeafCond((SyncopeUserCond) attributeCond);\n+                            ? NodeCond.getNotLeafCond((AttributableCond) attributeCond)\n+                            : NodeCond.getLeafCond((AttributableCond) attributeCond);\n                 } else {\n                     attributeCond = new AttributeCond();\n                     nodeCond = searchConditionWrapper.isNotOperator()"},{"sha":"5fd738e7ad2ec5c68c3f733227a67e267bdc2ad7","filename":"console/src/main/java/org/apache/syncope/console/rest/NotificationRestClient.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/console%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fconsole%2Frest%2FNotificationRestClient.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/console%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fconsole%2Frest%2FNotificationRestClient.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/console%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fconsole%2Frest%2FNotificationRestClient.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -67,6 +67,6 @@ public List<String> getMailTemplates()\n     public List<String> getEvents()\n             throws SyncopeClientCompositeErrorException {\n         return Arrays.asList(SyncopeSession.get().getRestTemplate().getForObject(\n-                baseURL + \"workflow/tasks.json\", String[].class));\n+                baseURL + \"workflow/tasks/user.json\", String[].class));\n     }\n }"},{"sha":"64e6afbeced57f42e1d95d434129586387d38b52","filename":"console/src/main/java/org/apache/syncope/console/rest/WorkflowRestClient.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/console%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fconsole%2Frest%2FWorkflowRestClient.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/console%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fconsole%2Frest%2FWorkflowRestClient.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/console%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fconsole%2Frest%2FWorkflowRestClient.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -29,11 +29,11 @@ public class WorkflowRestClient extends AbstractBaseRestClient {\n     public WorkflowDefinitionTO getDefinition()\n             throws SyncopeClientCompositeErrorException {\n         return SyncopeSession.get().getRestTemplate().getForObject(\n-                baseURL + \"workflow/definition.json\", WorkflowDefinitionTO.class);\n+                baseURL + \"workflow/definition/user.json\", WorkflowDefinitionTO.class);\n     }\n \n     public void updateDefinition(final WorkflowDefinitionTO workflowDef)\n             throws SyncopeClientCompositeErrorException {\n-        SyncopeSession.get().getRestTemplate().put(baseURL + \"/workflow/definition.json\", workflowDef);\n+        SyncopeSession.get().getRestTemplate().put(baseURL + \"workflow/definition/user.json\", workflowDef);\n     }\n }"},{"sha":"5f6b4a28b89053bb0e9c24907efe385347e2675b","filename":"console/src/test/java/org/apache/syncope/console/AbstractTest.java","status":"modified","additions":1,"deletions":3,"changes":4,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/console%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fconsole%2FAbstractTest.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/console%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fconsole%2FAbstractTest.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/console%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fconsole%2FAbstractTest.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -28,7 +28,7 @@\n import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n \n @RunWith(SpringJUnit4ClassRunner.class)\n-@ContextConfiguration(locations = { \"classpath:applicationContext.xml\" })\n+@ContextConfiguration(locations = {\"classpath:applicationContext.xml\"})\n public abstract class AbstractTest extends SeleneseTestCase {\n \n     /**\n@@ -45,7 +45,6 @@ public abstract class AbstractTest extends SeleneseTestCase {\n     @Override\n     @Before\n     public void setUp() throws Exception {\n-\n         super.setUp(BASE_URL, \"*firefox\");\n \n         selenium.open(\"/syncope-console/\");\n@@ -59,7 +58,6 @@ public void setUp() throws Exception {\n     @Override\n     @After\n     public void tearDown() throws Exception {\n-\n         selenium.click(\"css=img[alt=\\\"Logout\\\"]\");\n         selenium.stop();\n         super.tearDown();"},{"sha":"84f741c14fa28509f356bdffbb33555bff8a4140","filename":"core/pom.xml","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fpom.xml","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fpom.xml","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fpom.xml?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -25,7 +25,7 @@ under the License.\n   <parent>\n     <groupId>org.apache.syncope</groupId>\n     <artifactId>syncope</artifactId>\n-    <version>1.1.0-SNAPSHOT</version>\n+    <version>1.1.0-RP-SNAPSHOT</version>\n   </parent>\n \n   <name>Apache Syncope Core</name>"},{"sha":"892b03370a5e45d3e9387c12c22ccf4a0a324c04","filename":"core/src/main/java/org/apache/syncope/core/init/ConnInstanceLoader.java","status":"modified","additions":1,"deletions":2,"changes":3,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Finit%2FConnInstanceLoader.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Finit%2FConnInstanceLoader.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Finit%2FConnInstanceLoader.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -128,8 +128,7 @@ public void unregisterConnector(final String id) {\n \n     @Transactional(readOnly = true)\n     public void load() {\n-        // This is needed to avoid encoding problems when sending error\n-        // messages via REST\n+        // This is needed to avoid encoding problems when sending error messages via REST\n         CurrentLocale.set(Locale.ENGLISH);\n \n         // Next load all resource-specific connectors."},{"sha":"d24ed36fc2e0fa9ea342553762468ce3dac72ede","filename":"core/src/main/java/org/apache/syncope/core/init/ContentLoader.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Finit%2FContentLoader.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Finit%2FContentLoader.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Finit%2FContentLoader.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -156,8 +156,8 @@ public void load() {\n             LOG.error(\"While creating indexes\", e);\n         }\n \n-        // Can't test wfAdapter.getClass() because it is @Autowired\n-        if (SpringContextInitializer.isActivitiConfigured()) {\n+        // Can't test uwfAdapter.getClass() because it is @Autowired\n+        if (SpringContextInitializer.isActivitiEnabledForUsers()) {\n             try {\n                 statement = conn.prepareStatement(\"DELETE FROM ACT_GE_PROPERTY\");\n                 statement.executeUpdate();"},{"sha":"ff469445c9725455d86b6c321284f4fc85ac29b8","filename":"core/src/main/java/org/apache/syncope/core/init/SpringContextInitializer.java","status":"modified","additions":21,"deletions":12,"changes":33,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Finit%2FSpringContextInitializer.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Finit%2FSpringContextInitializer.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Finit%2FSpringContextInitializer.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -22,8 +22,9 @@\n import java.io.InputStream;\n import java.util.Properties;\n import javax.servlet.ServletContext;\n-import org.apache.syncope.core.workflow.ActivitiUserWorkflowAdapter;\n-import org.apache.syncope.core.workflow.UserWorkflowAdapter;\n+import org.apache.syncope.core.workflow.role.RoleWorkflowAdapter;\n+import org.apache.syncope.core.workflow.user.UserWorkflowAdapter;\n+import org.apache.syncope.core.workflow.user.activiti.ActivitiUserWorkflowAdapter;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.springframework.beans.BeansException;\n@@ -47,13 +48,13 @@ public class SpringContextInitializer implements ServletContextAware, BeanFactor\n      */\n     private static final Logger LOG = LoggerFactory.getLogger(SpringContextInitializer.class);\n \n-    private static String wfAdapterClassName;\n+    private static String uwfAdapterClassName;\n \n     static {\n         try {\n-            initWFAdapterClassName();\n+            initUWFAdapterClassName();\n         } catch (IOException e) {\n-            LOG.error(\"Could not init wfAdapterClassName\", e);\n+            LOG.error(\"Could not init uwfAdapterClassName\", e);\n         }\n     }\n \n@@ -62,13 +63,13 @@ public class SpringContextInitializer implements ServletContextAware, BeanFactor\n      *\n      * @throws IOException if anything goes wrong\n      */\n-    public static void initWFAdapterClassName() throws IOException {\n+    public static void initUWFAdapterClassName() throws IOException {\n         Properties props = new java.util.Properties();\n         InputStream propStream = null;\n         try {\n             propStream = ContentLoader.class.getResourceAsStream(\"/workflow.properties\");\n             props.load(propStream);\n-            wfAdapterClassName = props.getProperty(\"wfAdapter\");\n+            uwfAdapterClassName = props.getProperty(\"uwfAdapter\");\n         } catch (Exception e) {\n             LOG.error(\"Could not load workflow.properties\", e);\n         } finally {\n@@ -83,8 +84,8 @@ public static void initWFAdapterClassName() throws IOException {\n      *\n      * @return whether Activiti is configured for workflow or not\n      */\n-    public static boolean isActivitiConfigured() {\n-        return wfAdapterClassName != null && wfAdapterClassName.equals(ActivitiUserWorkflowAdapter.class.getName());\n+    public static boolean isActivitiEnabledForUsers() {\n+        return uwfAdapterClassName != null && uwfAdapterClassName.equals(ActivitiUserWorkflowAdapter.class.getName());\n     }\n \n     @Autowired\n@@ -97,7 +98,10 @@ public static boolean isActivitiConfigured() {\n     private JobInstanceLoader jobInstanceLoader;\n \n     @Autowired\n-    private UserWorkflowAdapter wfAdapter;\n+    private UserWorkflowAdapter uwfAdapter;\n+\n+    @Autowired\n+    private RoleWorkflowAdapter rwfAdapter;\n \n     @Autowired\n     private LoggerLoader loggerLoader;\n@@ -124,9 +128,14 @@ public void afterPropertiesSet() throws Exception {\n         loggerLoader.load();\n         classNamesLoader.load();\n \n-        if (wfAdapter.getLoaderClass() != null) {\n+        if (uwfAdapter.getLoaderClass() != null) {\n+            final WorkflowLoader wfLoader = (WorkflowLoader) beanFactory.createBean(\n+                    uwfAdapter.getLoaderClass(), AbstractBeanDefinition.AUTOWIRE_BY_TYPE, false);\n+            wfLoader.load();\n+        }\n+        if (rwfAdapter.getLoaderClass() != null) {\n             final WorkflowLoader wfLoader = (WorkflowLoader) beanFactory.createBean(\n-                    wfAdapter.getLoaderClass(), AbstractBeanDefinition.AUTOWIRE_BY_TYPE, false);\n+                    rwfAdapter.getLoaderClass(), AbstractBeanDefinition.AUTOWIRE_BY_TYPE, false);\n             wfLoader.load();\n         }\n     }"},{"sha":"b1b89144f91b8426d2f5a4a1954cafe9eb0e7916","filename":"core/src/main/java/org/apache/syncope/core/notification/NotificationManager.java","status":"modified","additions":17,"deletions":18,"changes":35,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fnotification%2FNotificationManager.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fnotification%2FNotificationManager.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fnotification%2FNotificationManager.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -24,6 +24,7 @@\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n+import org.apache.syncope.core.persistence.beans.AbstractAttributable;\n import org.apache.syncope.core.persistence.beans.Notification;\n import org.apache.syncope.core.persistence.beans.NotificationTask;\n import org.apache.syncope.core.persistence.beans.SyncopeConf;\n@@ -32,16 +33,18 @@\n import org.apache.syncope.core.persistence.beans.user.UAttr;\n import org.apache.syncope.core.persistence.beans.user.UDerAttr;\n import org.apache.syncope.core.persistence.beans.user.UVirAttr;\n+import org.apache.syncope.core.persistence.dao.AttributableSearchDAO;\n import org.apache.syncope.core.persistence.dao.ConfDAO;\n import org.apache.syncope.core.persistence.dao.EntitlementDAO;\n import org.apache.syncope.core.persistence.dao.NotificationDAO;\n import org.apache.syncope.core.persistence.dao.TaskDAO;\n import org.apache.syncope.core.persistence.dao.UserDAO;\n-import org.apache.syncope.core.persistence.dao.UserSearchDAO;\n import org.apache.syncope.core.rest.data.UserDataBinder;\n+import org.apache.syncope.core.util.AttributableUtil;\n import org.apache.syncope.core.util.ConnObjectUtil;\n import org.apache.syncope.core.util.EntitlementUtil;\n import org.apache.syncope.core.util.NotFoundException;\n+import org.apache.syncope.types.AttributableType;\n import org.apache.syncope.types.IntMappingType;\n import org.apache.velocity.app.VelocityEngine;\n import org.apache.velocity.exception.VelocityException;\n@@ -89,7 +92,7 @@ public class NotificationManager {\n      * User Search DAO.\n      */\n     @Autowired\n-    private UserSearchDAO searchDAO;\n+    private AttributableSearchDAO searchDAO;\n \n     /**\n      * Task DAO.\n@@ -117,18 +120,16 @@ public class NotificationManager {\n      *\n      * @param notification notification to take as model\n      * @param user the user this task is about\n-     * @param emailSchema name of user schema containing e-mail address\n      * @return notification task, fully populated\n      */\n     private NotificationTask getNotificationTask(final Notification notification, final SyncopeUser user) {\n+        connObjectUtil.retrieveVirAttrValues(user, AttributableUtil.getInstance(AttributableType.USER));\n \n-        connObjectUtil.retrieveVirAttrValues(user);\n-\n-        final List<SyncopeUser> recipients = new ArrayList<SyncopeUser>();\n+        final List<AbstractAttributable> recipients = new ArrayList<AbstractAttributable>();\n \n         if (notification.getRecipients() != null) {\n-            recipients.addAll(searchDAO.search(EntitlementUtil.getRoleIds(\n-                    entitlementDAO.findAll()), notification.getRecipients()));\n+            recipients.addAll(searchDAO.search(EntitlementUtil.getRoleIds(entitlementDAO.findAll()),\n+                    notification.getRecipients(), AttributableUtil.getInstance(AttributableType.USER)));\n         }\n \n         if (notification.isSelfAsRecipient()) {\n@@ -137,13 +138,11 @@ private NotificationTask getNotificationTask(final Notification notification, fi\n \n         Set<String> recipientEmails = new HashSet<String>();\n \n-        for (SyncopeUser recipient : recipients) {\n-\n-            connObjectUtil.retrieveVirAttrValues(recipient);\n-\n-            String email = getRecipientEmail(\n-                    notification.getRecipientAttrType(), notification.getRecipientAttrName(), recipient);\n+        for (AbstractAttributable recipient : recipients) {\n+            connObjectUtil.retrieveVirAttrValues(recipient, AttributableUtil.getInstance(AttributableType.USER));\n \n+            String email = getRecipientEmail(notification.getRecipientAttrType(),\n+                    notification.getRecipientAttrName(), (SyncopeUser) recipient);\n             if (email == null) {\n                 LOG.warn(\"{} cannot be notified: {} not found\", recipient, notification.getRecipientAttrName());\n             } else {\n@@ -196,15 +195,15 @@ public void createTasks(final Long userId, final Set<String> performedTasks)\n         }\n \n         for (Notification notification : notificationDAO.findAll()) {\n-            if (searchDAO.matches(user, notification.getAbout())) {\n+            if (searchDAO.matches(user, notification.getAbout(), AttributableUtil.getInstance(AttributableType.USER))) {\n                 Set<String> events = new HashSet<String>(notification.getEvents());\n                 events.retainAll(performedTasks);\n \n-                if (!events.isEmpty()) {\n+                if (events.isEmpty()) {\n+                    LOG.debug(\"No events found about {}\", user);\n+                } else {\n                     LOG.debug(\"Creating notification task for events {} about {}\", events, user);\n                     taskDAO.save(getNotificationTask(notification, user));\n-                } else {\n-                    LOG.debug(\"No events found about {}\", user);\n                 }\n             }\n         }"},{"sha":"7b7e6471a6c056de5102d253f1bfc54eb00855ca","filename":"core/src/main/java/org/apache/syncope/core/persistence/beans/AbstractMapping.java","status":"added","additions":89,"deletions":0,"changes":89,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fbeans%2FAbstractMapping.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fbeans%2FAbstractMapping.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fbeans%2FAbstractMapping.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -0,0 +1,89 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.core.persistence.beans;\n+\n+import java.util.List;\n+import javax.persistence.Cacheable;\n+import javax.persistence.MappedSuperclass;\n+import org.apache.syncope.types.IntMappingType;\n+import org.identityconnectors.framework.common.objects.Uid;\n+\n+@MappedSuperclass\n+@Cacheable\n+public abstract class AbstractMapping extends AbstractBaseBean {\n+\n+    private static final long serialVersionUID = 4316047254916259158L;\n+\n+    /**\n+     * A JEXL expression for determining how to find the account id in external resource's space.\n+     */\n+    private String accountLink;\n+\n+    public abstract Long getId();\n+\n+    public abstract void setResource(ExternalResource resource);\n+\n+    public abstract ExternalResource getResource();\n+\n+    public String getAccountLink() {\n+        return accountLink;\n+    }\n+\n+    public void setAccountLink(final String accountLink) {\n+        this.accountLink = accountLink;\n+    }\n+\n+    public <T extends AbstractMappingItem> T getAccountIdItem() {\n+        T accountIdItem = null;\n+        for (AbstractMappingItem item : getItems()) {\n+            if (item.isAccountid()) {\n+                accountIdItem = (T) item;\n+            }\n+        }\n+        return accountIdItem;\n+    }\n+\n+    protected <T extends AbstractMappingItem> boolean addAccountIdItem(final T accountIdItem) {\n+        if (IntMappingType.UserVirtualSchema == accountIdItem.getIntMappingType()\n+                || IntMappingType.RoleVirtualSchema == accountIdItem.getIntMappingType()\n+                || IntMappingType.MembershipVirtualSchema == accountIdItem.getIntMappingType()\n+                || IntMappingType.Password == accountIdItem.getIntMappingType()) {\n+\n+            throw new IllegalArgumentException(\"Virtual attributes cannot be set as accountId\");\n+        }\n+        if (IntMappingType.Password == accountIdItem.getIntMappingType()) {\n+            throw new IllegalArgumentException(\"Password attributes cannot be set as accountId\");\n+        }\n+\n+        accountIdItem.setExtAttrName(Uid.NAME);\n+        accountIdItem.setAccountid(true);\n+\n+        return this.addItem(accountIdItem);\n+    }\n+\n+    public abstract <T extends AbstractMappingItem> void setAccountIdItem(final T accountIdItem);\n+\n+    public abstract <T extends AbstractMappingItem> List<T> getItems();\n+\n+    public abstract <T extends AbstractMappingItem> boolean addItem(T item);\n+\n+    public abstract <T extends AbstractMappingItem> boolean removeItem(T item);\n+\n+    public abstract <T extends AbstractMappingItem> void setItems(final List<T> items);\n+}"},{"sha":"9e5a6eb4e52a1cd15ae1cc130155e474d1711d77","filename":"core/src/main/java/org/apache/syncope/core/persistence/beans/AbstractMappingItem.java","status":"renamed","additions":57,"deletions":52,"changes":109,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fbeans%2FAbstractMappingItem.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fbeans%2FAbstractMappingItem.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fbeans%2FAbstractMappingItem.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -21,47 +21,38 @@\n import javax.persistence.Basic;\n import javax.persistence.Cacheable;\n import javax.persistence.Column;\n-import javax.persistence.Entity;\n import javax.persistence.EnumType;\n import javax.persistence.Enumerated;\n-import javax.persistence.Id;\n-import javax.persistence.ManyToOne;\n+import javax.persistence.MappedSuperclass;\n import javax.validation.constraints.Max;\n import javax.validation.constraints.Min;\n-import javax.validation.constraints.NotNull;\n-import org.apache.syncope.core.persistence.validation.entity.SchemaMappingCheck;\n import org.apache.syncope.types.IntMappingType;\n \n-@Entity\n+@MappedSuperclass\n @Cacheable\n-@SchemaMappingCheck\n-public class SchemaMapping extends AbstractBaseBean {\n+public abstract class AbstractMappingItem extends AbstractBaseBean {\n \n     private static final long serialVersionUID = 7383601853619332424L;\n \n-    @Id\n-    private Long id;\n-\n     @Column(nullable = true)\n     private String intAttrName;\n \n     @Column(nullable = false)\n     @Enumerated(EnumType.STRING)\n     private IntMappingType intMappingType;\n \n-    /**\n-     * Resource that has fields to be mapped over user attribute schemas.\n-     */\n-    @ManyToOne\n-    @NotNull\n-    private ExternalResource resource;\n-\n     /**\n      * Target resource's field to be mapped.\n      */\n     @Column(nullable = true)\n     private String extAttrName;\n \n+    /**\n+     * Specify if the mapped target resource's field is nullable.\n+     */\n+    @Column(nullable = false)\n+    private String mandatoryCondition;\n+\n     /**\n      * Specify if the mapped target resource's field is the key.\n      */\n@@ -80,69 +71,67 @@ public class SchemaMapping extends AbstractBaseBean {\n     @Max(1)\n     private Integer password;\n \n-    /**\n-     * Specify if the mapped target resource's field is nullable.\n-     */\n-    @Column(nullable = false)\n-    private String mandatoryCondition;\n-\n-    public SchemaMapping() {\n+    public AbstractMappingItem() {\n         super();\n \n+        mandatoryCondition = Boolean.FALSE.toString();\n+\n         accountid = getBooleanAsInteger(false);\n         password = getBooleanAsInteger(false);\n-        mandatoryCondition = Boolean.FALSE.toString();\n     }\n \n-    public Long getId() {\n-        return id;\n-    }\n+    public abstract Long getId();\n \n-    public boolean isAccountid() {\n-        return isBooleanAsInteger(accountid);\n-    }\n+    public abstract <T extends AbstractMapping> T getMapping();\n \n-    public void setAccountid(boolean accountid) {\n-        this.accountid = getBooleanAsInteger(accountid);\n-    }\n+    public abstract <T extends AbstractMapping> void setMapping(T mapping);\n \n     public String getExtAttrName() {\n         return extAttrName;\n     }\n \n-    public void setExtAttrName(String extAttrName) {\n+    public void setExtAttrName(final String extAttrName) {\n         this.extAttrName = extAttrName;\n     }\n \n     public String getMandatoryCondition() {\n         return mandatoryCondition;\n     }\n \n-    public void setMandatoryCondition(String mandatoryCondition) {\n+    public void setMandatoryCondition(final String mandatoryCondition) {\n         this.mandatoryCondition = mandatoryCondition;\n     }\n \n-    public boolean isPassword() {\n-        return isBooleanAsInteger(password);\n-    }\n+    public String getIntAttrName() {\n+        final String name;\n \n-    public void setPassword(boolean password) {\n-        this.password = getBooleanAsInteger(password);\n-    }\n+        switch (getIntMappingType()) {\n+            case UserId:\n+            case RoleId:\n+            case MembershipId:\n+                name = \"id\";\n+                break;\n \n-    public ExternalResource getResource() {\n-        return resource;\n-    }\n+            case Username:\n+                name = \"username\";\n+                break;\n \n-    public void setResource(ExternalResource resource) {\n-        this.resource = resource;\n-    }\n+            case RoleName:\n+                name = \"roleName\";\n+                break;\n \n-    public String getIntAttrName() {\n-        return intAttrName;\n+            case Password:\n+                name = \"password\";\n+                break;\n+\n+            default:\n+                name = intAttrName;\n+        }\n+\n+        return name;\n     }\n \n-    public void setIntAttrName(String intAttrName) {\n+    public void setIntAttrName(final String intAttrName) {\n         this.intAttrName = intAttrName;\n     }\n \n@@ -153,4 +142,20 @@ public IntMappingType getIntMappingType() {\n     public void setIntMappingType(IntMappingType intMappingType) {\n         this.intMappingType = intMappingType;\n     }\n+\n+    public boolean isAccountid() {\n+        return isBooleanAsInteger(accountid);\n+    }\n+\n+    public void setAccountid(boolean accountid) {\n+        this.accountid = getBooleanAsInteger(accountid);\n+    }\n+\n+    public boolean isPassword() {\n+        return isBooleanAsInteger(password);\n+    }\n+\n+    public void setPassword(boolean password) {\n+        this.password = getBooleanAsInteger(password);\n+    }\n }","previous_filename":"core/src/main/java/org/apache/syncope/core/persistence/beans/SchemaMapping.java"},{"sha":"df0d396e8fa135fca42cd3ddd06549ff25dd8e7d","filename":"core/src/main/java/org/apache/syncope/core/persistence/beans/ExternalResource.java","status":"modified","additions":66,"deletions":72,"changes":138,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fbeans%2FExternalResource.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fbeans%2FExternalResource.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fbeans%2FExternalResource.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -22,7 +22,6 @@\n import java.util.HashSet;\n import java.util.Set;\n import javax.persistence.Basic;\n-import javax.persistence.Cacheable;\n import javax.persistence.CascadeType;\n import javax.persistence.Column;\n import javax.persistence.Entity;\n@@ -32,25 +31,24 @@\n import javax.persistence.Id;\n import javax.persistence.Lob;\n import javax.persistence.ManyToOne;\n-import javax.persistence.OneToMany;\n-import javax.validation.Valid;\n+import javax.persistence.OneToOne;\n import javax.validation.constraints.Max;\n import javax.validation.constraints.Min;\n import javax.validation.constraints.NotNull;\n import org.apache.commons.lang.StringUtils;\n import org.apache.syncope.client.util.XMLSerializer;\n+import org.apache.syncope.core.persistence.beans.role.RMapping;\n+import org.apache.syncope.core.persistence.beans.user.UMapping;\n import org.apache.syncope.core.persistence.validation.entity.ExternalResourceCheck;\n import org.apache.syncope.types.ConnConfProperty;\n-import org.apache.syncope.types.IntMappingType;\n import org.apache.syncope.types.PropagationMode;\n import org.apache.syncope.types.TraceLevel;\n import org.identityconnectors.framework.common.objects.SyncToken;\n \n /**\n- * A resource to which propagation occurs.\n+ * Resource for propagation and synchronization.\n  */\n @Entity\n-@Cacheable\n @ExternalResourceCheck\n public class ExternalResource extends AbstractBaseBean {\n \n@@ -79,17 +77,16 @@ public class ExternalResource extends AbstractBaseBean {\n     private ConnInstance connector;\n \n     /**\n-     * Attribute mappings.\n+     * Mapping for user objects.\n      */\n-    @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.EAGER, mappedBy = \"resource\")\n-    @Valid\n-    private Set<SchemaMapping> mappings;\n+    @OneToOne(cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.EAGER, mappedBy = \"resource\")\n+    private UMapping umapping;\n \n     /**\n-     * A JEXL expression for determining how to link user account id in Syncope DB to user account id in target\n-     * resource's DB.\n+     * Mapping for role objects.\n      */\n-    private String accountLink;\n+    @OneToOne(cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.EAGER, mappedBy = \"resource\")\n+    private RMapping rmapping;\n \n     /**\n      * Is this resource primary, for propagations?\n@@ -142,15 +139,21 @@ public class ExternalResource extends AbstractBaseBean {\n     private String xmlConfiguration;\n \n     /**\n-     * SyncToken for calling ConnId's sync().\n+     * SyncToken for calling ConnId's sync() on users.\n      */\n     @Lob\n-    private String serializedSyncToken;\n+    private String userializedSyncToken;\n+\n+    /**\n+     * SyncToken for calling ConnId's sync() on roles.\n+     */\n+    @Lob\n+    private String rserializedSyncToken;\n \n     /**\n      * (Optional) class for PropagationAction.\n      */\n-    private String actionsClassName;\n+    private String propagationActionsClassName;\n \n     /**\n      * Default constructor.\n@@ -159,7 +162,6 @@ public ExternalResource() {\n         super();\n \n         enforceMandatoryCondition = getBooleanAsInteger(false);\n-        mappings = new HashSet<SchemaMapping>();\n         propagationPrimary = 0;\n         propagationPriority = 0;\n         propagationMode = PropagationMode.TWO_PHASES;\n@@ -186,6 +188,22 @@ public void setConnector(ConnInstance connector) {\n         this.connector = connector;\n     }\n \n+    public UMapping getUmapping() {\n+        return umapping;\n+    }\n+\n+    public void setUmapping(final UMapping umapping) {\n+        this.umapping = umapping;\n+    }\n+\n+    public RMapping getRmapping() {\n+        return rmapping;\n+    }\n+\n+    public void setRmapping(final RMapping rmapping) {\n+        this.rmapping = rmapping;\n+    }\n+\n     public boolean isPropagationPrimary() {\n         return isBooleanAsInteger(propagationPrimary);\n     }\n@@ -212,48 +230,6 @@ public void setPropagationMode(PropagationMode propagationMode) {\n         this.propagationMode = propagationMode;\n     }\n \n-    public Set<SchemaMapping> getMappings() {\n-        return mappings;\n-    }\n-\n-    public Set<SchemaMapping> getMappings(final String intAttrName, final IntMappingType intMappingType) {\n-        Set<SchemaMapping> result = new HashSet<SchemaMapping>();\n-        for (SchemaMapping mapping : mappings) {\n-            if (intAttrName.equals(mapping.getIntAttrName()) && mapping.getIntMappingType() == intMappingType) {\n-                result.add(mapping);\n-            }\n-        }\n-\n-        return result;\n-    }\n-\n-    public boolean removeMapping(final SchemaMapping mapping) {\n-        return mappings.remove(mapping);\n-    }\n-\n-    public boolean addMapping(final SchemaMapping mapping) {\n-        return mappings.contains(mapping) || mappings.add(mapping);\n-    }\n-\n-    public void setMappings(final Set<SchemaMapping> mappings) {\n-        for (SchemaMapping mapping : this.mappings) {\n-            mapping.setResource(null);\n-        }\n-        this.mappings.clear();\n-\n-        if (mappings != null) {\n-            this.mappings.addAll(mappings);\n-        }\n-    }\n-\n-    public String getAccountLink() {\n-        return accountLink;\n-    }\n-\n-    public void setAccountLink(final String accountLink) {\n-        this.accountLink = accountLink;\n-    }\n-\n     public String getName() {\n         return name;\n     }\n@@ -337,29 +313,47 @@ public Set<ConnConfProperty> getConfiguration() {\n         return result;\n     }\n \n-    public String getSerializedSyncToken() {\n-        return serializedSyncToken;\n+    public String getUserializedSyncToken() {\n+        return userializedSyncToken;\n+    }\n+\n+    public SyncToken getUsyncToken() {\n+        return userializedSyncToken == null\n+                ? null\n+                : XMLSerializer.<SyncToken>deserialize(userializedSyncToken);\n+    }\n+\n+    public void setUserializedSyncToken(final String serializedSyncToken) {\n+        this.userializedSyncToken = serializedSyncToken;\n+    }\n+\n+    public void setUsyncToken(final SyncToken syncToken) {\n+        userializedSyncToken = XMLSerializer.serialize(syncToken);\n+    }\n+\n+    public String getRserializedSyncToken() {\n+        return rserializedSyncToken;\n     }\n \n-    public SyncToken getSyncToken() {\n-        return serializedSyncToken == null\n+    public SyncToken getRsyncToken() {\n+        return rserializedSyncToken == null\n                 ? null\n-                : XMLSerializer.<SyncToken>deserialize(serializedSyncToken);\n+                : XMLSerializer.<SyncToken>deserialize(rserializedSyncToken);\n     }\n \n-    public void setSerializedSyncToken(final String serializedSyncToken) {\n-        this.serializedSyncToken = serializedSyncToken;\n+    public void setRserializedSyncToken(final String serializedSyncToken) {\n+        this.rserializedSyncToken = serializedSyncToken;\n     }\n \n-    public void setSyncToken(final SyncToken syncToken) {\n-        serializedSyncToken = XMLSerializer.serialize(syncToken);\n+    public void setRsyncToken(final SyncToken syncToken) {\n+        rserializedSyncToken = XMLSerializer.serialize(syncToken);\n     }\n \n-    public String getActionsClassName() {\n-        return actionsClassName;\n+    public String getPropagationActionsClassName() {\n+        return propagationActionsClassName;\n     }\n \n-    public void setActionsClassName(final String actionsClassName) {\n-        this.actionsClassName = actionsClassName;\n+    public void setPropagationActionsClassName(final String propagationActionsClassName) {\n+        this.propagationActionsClassName = propagationActionsClassName;\n     }\n }"},{"sha":"f4dbf76b7c84955c954bec27167d22b45da47f9e","filename":"core/src/main/java/org/apache/syncope/core/persistence/beans/PropagationTask.java","status":"modified","additions":32,"deletions":15,"changes":47,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fbeans%2FPropagationTask.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fbeans%2FPropagationTask.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fbeans%2FPropagationTask.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -25,10 +25,10 @@\n import javax.persistence.Lob;\n import javax.persistence.ManyToOne;\n import org.apache.syncope.client.util.XMLSerializer;\n-import org.apache.syncope.core.persistence.beans.user.SyncopeUser;\n import org.apache.syncope.core.persistence.validation.entity.PropagationTaskCheck;\n+import org.apache.syncope.types.AttributableType;\n import org.apache.syncope.types.PropagationMode;\n-import org.apache.syncope.types.PropagationOperation;\n+import org.apache.syncope.types.ResourceOperation;\n import org.identityconnectors.framework.common.objects.Attribute;\n \n /**\n@@ -50,7 +50,7 @@ public class PropagationTask extends Task {\n      * @see PropagationOperation\n      */\n     @Enumerated(EnumType.STRING)\n-    private PropagationOperation propagationOperation;\n+    private ResourceOperation propagationOperation;\n \n     /**\n      * The accountId on the external resource.\n@@ -68,11 +68,12 @@ public class PropagationTask extends Task {\n     @Lob\n     private String xmlAttributes;\n \n-    /**\n-     * User whose data are propagated.\n-     */\n-    @ManyToOne\n-    private SyncopeUser syncopeUser;\n+    private String objectClassName;\n+\n+    @Enumerated(EnumType.STRING)\n+    private AttributableType subjectType;\n+\n+    private Long subjectId;\n \n     /**\n      * ExternalResource to which the propagation happens.\n@@ -97,7 +98,7 @@ public void setOldAccountId(String oldAccountId) {\n     }\n \n     public Set<Attribute> getAttributes() {\n-        return XMLSerializer.<Set<Attribute>> deserialize(xmlAttributes);\n+        return XMLSerializer.<Set<Attribute>>deserialize(xmlAttributes);\n     }\n \n     public void setAttributes(final Set<Attribute> attributes) {\n@@ -112,11 +113,11 @@ public void setPropagationMode(PropagationMode propagationMode) {\n         this.propagationMode = propagationMode;\n     }\n \n-    public PropagationOperation getPropagationOperation() {\n+    public ResourceOperation getPropagationOperation() {\n         return propagationOperation;\n     }\n \n-    public void setPropagationOperation(PropagationOperation propagationOperation) {\n+    public void setPropagationOperation(ResourceOperation propagationOperation) {\n \n         this.propagationOperation = propagationOperation;\n     }\n@@ -129,11 +130,27 @@ public void setResource(ExternalResource resource) {\n         this.resource = resource;\n     }\n \n-    public SyncopeUser getSyncopeUser() {\n-        return syncopeUser;\n+    public String getObjectClassName() {\n+        return objectClassName;\n+    }\n+\n+    public void setObjectClassName(String objectClassName) {\n+        this.objectClassName = objectClassName;\n+    }\n+\n+    public AttributableType getSubjectType() {\n+        return subjectType;\n+    }\n+\n+    public void setSubjectType(AttributableType subjectType) {\n+        this.subjectType = subjectType;\n+    }\n+\n+    public Long getSubjectId() {\n+        return subjectId;\n     }\n \n-    public void setSyncopeUser(SyncopeUser syncopeUser) {\n-        this.syncopeUser = syncopeUser;\n+    public void setSubjectId(Long subjectId) {\n+        this.subjectId = subjectId;\n     }\n }"},{"sha":"2f86aaec24af23d2332b28fb9c03913c2f1f64c6","filename":"core/src/main/java/org/apache/syncope/core/persistence/beans/SyncTask.java","status":"modified","additions":14,"deletions":0,"changes":14,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fbeans%2FSyncTask.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fbeans%2FSyncTask.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fbeans%2FSyncTask.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -24,6 +24,7 @@\n import javax.persistence.ManyToOne;\n import javax.validation.constraints.Max;\n import javax.validation.constraints.Min;\n+import org.apache.syncope.client.to.RoleTO;\n import org.apache.syncope.client.to.UserTO;\n import org.apache.syncope.client.util.XMLSerializer;\n import org.apache.syncope.core.persistence.validation.entity.SyncTaskCheck;\n@@ -44,6 +45,9 @@ public class SyncTask extends SchedTask {\n     @Lob\n     private String userTemplate;\n \n+    @Lob\n+    private String roleTemplate;\n+\n     @Basic\n     @Min(0)\n     @Max(1)\n@@ -102,6 +106,16 @@ public void setUserTemplate(final UserTO userTemplate) {\n         this.userTemplate = XMLSerializer.serialize(userTemplate);\n     }\n \n+    public RoleTO getRoleTemplate() {\n+        return userTemplate == null\n+                ? new RoleTO()\n+                : XMLSerializer.<RoleTO>deserialize(roleTemplate);\n+    }\n+\n+    public void setRoleTemplate(final RoleTO roleTemplate) {\n+        this.roleTemplate = XMLSerializer.serialize(roleTemplate);\n+    }\n+\n     public boolean isPerformCreate() {\n         return isBooleanAsInteger(performCreate);\n     }"},{"sha":"eb807c5c0da6d1963245d2b80ae2169145d5fddd","filename":"core/src/main/java/org/apache/syncope/core/persistence/beans/membership/MAttr.java","status":"modified","additions":14,"deletions":6,"changes":20,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fbeans%2Fmembership%2FMAttr.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fbeans%2Fmembership%2FMAttr.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fbeans%2Fmembership%2FMAttr.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -29,25 +29,30 @@\n import javax.persistence.OneToMany;\n import javax.persistence.OneToOne;\n import javax.validation.Valid;\n-import org.apache.syncope.core.persistence.beans.AbstractAttributable;\n import org.apache.syncope.core.persistence.beans.AbstractAttr;\n import org.apache.syncope.core.persistence.beans.AbstractAttrValue;\n+import org.apache.syncope.core.persistence.beans.AbstractAttributable;\n import org.apache.syncope.core.persistence.beans.AbstractSchema;\n \n @Entity\n public class MAttr extends AbstractAttr {\n \n     private static final long serialVersionUID = 3755864809152866489L;\n+\n     @Id\n     private Long id;\n+\n     @ManyToOne(fetch = FetchType.EAGER)\n     private Membership owner;\n+\n     @ManyToOne(fetch = FetchType.EAGER)\n     @JoinColumn(name = \"schema_name\")\n     private MSchema schema;\n+\n     @OneToMany(cascade = CascadeType.MERGE, orphanRemoval = true, mappedBy = \"attribute\")\n     @Valid\n     private List<MAttrValue> values;\n+\n     @OneToOne(cascade = CascadeType.ALL, mappedBy = \"attribute\")\n     @Valid\n     private MAttrUniqueValue uniqueValue;\n@@ -68,7 +73,7 @@ public <T extends AbstractAttributable> T getOwner() {\n     }\n \n     @Override\n-    public <T extends AbstractAttributable> void setOwner(T owner) {\n+    public <T extends AbstractAttributable> void setOwner(final T owner) {\n         if (!(owner instanceof Membership)) {\n             throw new ClassCastException(\"owner is expected to be typed Membership: \" + owner.getClass().getName());\n         }\n@@ -81,7 +86,7 @@ public <T extends AbstractSchema> T getSchema() {\n     }\n \n     @Override\n-    public <T extends AbstractSchema> void setSchema(T schema) {\n+    public <T extends AbstractSchema> void setSchema(final T schema) {\n         if (!(schema instanceof MSchema)) {\n             throw new ClassCastException(\"schema is expected to be typed MSchema: \" + schema.getClass().getName());\n         }\n@@ -91,7 +96,8 @@ public <T extends AbstractSchema> void setSchema(T schema) {\n     @Override\n     public <T extends AbstractAttrValue> boolean addValue(final T attributeValue) {\n         if (!(attributeValue instanceof MAttrValue)) {\n-            throw new ClassCastException(\"attributeValue is expected to be typed MAttrValue: \" + attributeValue.getClass().getName());\n+            throw new ClassCastException(\"attributeValue is expected to be typed MAttrValue: \" + attributeValue.\n+                    getClass().getName());\n         }\n         attributeValue.setAttribute(this);\n         return values.add((MAttrValue) attributeValue);\n@@ -100,7 +106,8 @@ public <T extends AbstractAttrValue> boolean addValue(final T attributeValue) {\n     @Override\n     public <T extends AbstractAttrValue> boolean removeValue(final T attributeValue) {\n         if (!(attributeValue instanceof MAttrValue)) {\n-            throw new ClassCastException(\"attributeValue is expected to be typed MAttrValue: \" + attributeValue.getClass().getName());\n+            throw new ClassCastException(\"attributeValue is expected to be typed MAttrValue: \" + attributeValue.\n+                    getClass().getName());\n         }\n         boolean result = values.remove((MAttrValue) attributeValue);\n         attributeValue.setAttribute(null);\n@@ -132,7 +139,8 @@ public <T extends AbstractAttrValue> T getUniqueValue() {\n     @Override\n     public <T extends AbstractAttrValue> void setUniqueValue(final T uniqueAttributeValue) {\n         if (!(uniqueAttributeValue instanceof MAttrUniqueValue)) {\n-            throw new ClassCastException(\"uniqueAttributeValue is expected to be typed MAttrUniqueValue: \" + uniqueAttributeValue.getClass().getName());\n+            throw new ClassCastException(\"uniqueAttributeValue is expected to be typed MAttrUniqueValue: \"\n+                    + uniqueAttributeValue.getClass().getName());\n         }\n         this.uniqueValue = (MAttrUniqueValue) uniqueAttributeValue;\n     }"},{"sha":"6a8b3ef404eabdd5c3c4431c59c9c4f8dee08092","filename":"core/src/main/java/org/apache/syncope/core/persistence/beans/role/RAttr.java","status":"modified","additions":14,"deletions":6,"changes":20,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fbeans%2Frole%2FRAttr.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fbeans%2Frole%2FRAttr.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fbeans%2Frole%2FRAttr.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -29,25 +29,30 @@\n import javax.persistence.OneToMany;\n import javax.persistence.OneToOne;\n import javax.validation.Valid;\n-import org.apache.syncope.core.persistence.beans.AbstractAttributable;\n import org.apache.syncope.core.persistence.beans.AbstractAttr;\n import org.apache.syncope.core.persistence.beans.AbstractAttrValue;\n+import org.apache.syncope.core.persistence.beans.AbstractAttributable;\n import org.apache.syncope.core.persistence.beans.AbstractSchema;\n \n @Entity\n public class RAttr extends AbstractAttr {\n \n     private static final long serialVersionUID = 2848159565890995780L;\n+\n     @Id\n     private Long id;\n+\n     @ManyToOne(fetch = FetchType.EAGER)\n     private SyncopeRole owner;\n+\n     @ManyToOne(fetch = FetchType.EAGER)\n     @JoinColumn(name = \"schema_name\")\n     private RSchema schema;\n+\n     @OneToMany(cascade = CascadeType.MERGE, orphanRemoval = true, mappedBy = \"attribute\")\n     @Valid\n     private List<RAttrValue> values;\n+\n     @OneToOne(cascade = CascadeType.ALL, mappedBy = \"attribute\")\n     @Valid\n     private RAttrUniqueValue uniqueValue;\n@@ -68,7 +73,7 @@ public <T extends AbstractAttributable> T getOwner() {\n     }\n \n     @Override\n-    public <T extends AbstractAttributable> void setOwner(T owner) {\n+    public <T extends AbstractAttributable> void setOwner(final T owner) {\n         if (!(owner instanceof SyncopeRole)) {\n             throw new ClassCastException(\"owner is expected to be typed SyncopeRole: \" + owner.getClass().getName());\n         }\n@@ -81,7 +86,7 @@ public <T extends AbstractSchema> T getSchema() {\n     }\n \n     @Override\n-    public <T extends AbstractSchema> void setSchema(T schema) {\n+    public <T extends AbstractSchema> void setSchema(final T schema) {\n         if (!(schema instanceof RSchema)) {\n             throw new ClassCastException(\"schema is expected to be typed RSchema: \" + schema.getClass().getName());\n         }\n@@ -91,15 +96,17 @@ public <T extends AbstractSchema> void setSchema(T schema) {\n     @Override\n     public <T extends AbstractAttrValue> boolean addValue(final T attributeValue) {\n         if (!(attributeValue instanceof RAttrValue)) {\n-            throw new ClassCastException(\"attributeValue is expected to be typed RAttrValue: \" + attributeValue.getClass().getName());\n+            throw new ClassCastException(\"attributeValue is expected to be typed RAttrValue: \" + attributeValue.\n+                    getClass().getName());\n         }\n         return values.add((RAttrValue) attributeValue);\n     }\n \n     @Override\n     public <T extends AbstractAttrValue> boolean removeValue(final T attributeValue) {\n         if (!(attributeValue instanceof RAttrValue)) {\n-            throw new ClassCastException(\"attributeValue is expected to be typed RAttrValue: \" + attributeValue.getClass().getName());\n+            throw new ClassCastException(\"attributeValue is expected to be typed RAttrValue: \" + attributeValue.\n+                    getClass().getName());\n         }\n         return values.remove((RAttrValue) attributeValue);\n     }\n@@ -129,7 +136,8 @@ public <T extends AbstractAttrValue> T getUniqueValue() {\n     @Override\n     public <T extends AbstractAttrValue> void setUniqueValue(final T uniqueAttributeValue) {\n         if (!(uniqueAttributeValue instanceof RAttrUniqueValue)) {\n-            throw new ClassCastException(\"uniqueAttributeValue is expected to be typed RAttrUniqueValue: \" + uniqueAttributeValue.getClass().getName());\n+            throw new ClassCastException(\"uniqueAttributeValue is expected to be typed RAttrUniqueValue: \"\n+                    + uniqueAttributeValue.getClass().getName());\n         }\n         this.uniqueValue = (RAttrUniqueValue) uniqueAttributeValue;\n     }"},{"sha":"d7f5a9a3dc34f908482b64c4d6934f756dfb0bb8","filename":"core/src/main/java/org/apache/syncope/core/persistence/beans/role/RMapping.java","status":"added","additions":118,"deletions":0,"changes":118,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fbeans%2Frole%2FRMapping.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fbeans%2Frole%2FRMapping.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fbeans%2Frole%2FRMapping.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -0,0 +1,118 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.core.persistence.beans.role;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+import javax.persistence.CascadeType;\n+import javax.persistence.Entity;\n+import javax.persistence.FetchType;\n+import javax.persistence.Id;\n+import javax.persistence.OneToMany;\n+import javax.persistence.OneToOne;\n+import org.apache.syncope.core.persistence.beans.AbstractMapping;\n+import org.apache.syncope.core.persistence.beans.AbstractMappingItem;\n+import org.apache.syncope.core.persistence.beans.ExternalResource;\n+\n+@Entity\n+public class RMapping extends AbstractMapping {\n+\n+    private static final long serialVersionUID = -4370284858054993282L;\n+\n+    @Id\n+    private Long id;\n+\n+    /**\n+     * Resource owning this mapping.\n+     */\n+    @OneToOne\n+    private ExternalResource resource;\n+\n+    /*\n+     * Attribute mappings.\n+     */\n+    @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.EAGER, mappedBy = \"mapping\")\n+    private List<RMappingItem> items;\n+\n+    public RMapping() {\n+        super();\n+\n+        items = new ArrayList<RMappingItem>();\n+    }\n+\n+    @Override\n+    public Long getId() {\n+        return id;\n+    }\n+\n+    @Override\n+    public ExternalResource getResource() {\n+        return resource;\n+    }\n+\n+    @Override\n+    public void setResource(final ExternalResource resource) {\n+        this.resource = resource;\n+    }\n+\n+    @Override\n+    public <T extends AbstractMappingItem> void setAccountIdItem(final T accountIdItem) {\n+        if (accountIdItem != null && !(accountIdItem instanceof RMappingItem)) {\n+            throw new ClassCastException(\"accountIdItem is expected to be typed RMappingItem: \"\n+                    + accountIdItem.getClass().getName());\n+        }\n+\n+        addAccountIdItem(accountIdItem);\n+    }\n+\n+    @Override\n+    public <T extends AbstractMappingItem> List<T> getItems() {\n+        return (List<T>) this.items;\n+    }\n+\n+    @Override\n+    public <T extends AbstractMappingItem> boolean addItem(final T item) {\n+        if (item != null && !(item instanceof RMappingItem)) {\n+            throw new ClassCastException(\"items are expected to be typed RMappingItem: \" + item.getClass().getName());\n+        }\n+        return item == null ? false : this.items.contains((RMappingItem) item) || this.items.add((RMappingItem) item);\n+    }\n+\n+    @Override\n+    public <T extends AbstractMappingItem> boolean removeItem(final T item) {\n+        if (item != null && !(item instanceof RMappingItem)) {\n+            throw new ClassCastException(\"items are expected to be typed RMappingItem: \" + item.getClass().getName());\n+        }\n+        return this.items.remove((RMappingItem) item);\n+    }\n+\n+    @Override\n+    public <T extends AbstractMappingItem> void setItems(final List<T> items) {\n+        this.items.clear();\n+        if (items != null && !items.isEmpty()) {\n+            T item = items.iterator().next();\n+            if (!(item instanceof RMappingItem)) {\n+                throw new ClassCastException(\"items are expected to be typed RMappingItem: \"\n+                        + item.getClass().getName());\n+            }\n+            this.items.addAll((Set<RMappingItem>) items);\n+        }\n+    }\n+}"},{"sha":"caba6edfcd1056a7683eab258d8b279416df3fc4","filename":"core/src/main/java/org/apache/syncope/core/persistence/beans/role/RMappingItem.java","status":"added","additions":56,"deletions":0,"changes":56,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fbeans%2Frole%2FRMappingItem.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fbeans%2Frole%2FRMappingItem.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fbeans%2Frole%2FRMappingItem.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -0,0 +1,56 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.core.persistence.beans.role;\n+\n+import javax.persistence.Entity;\n+import javax.persistence.Id;\n+import javax.persistence.ManyToOne;\n+import org.apache.syncope.core.persistence.beans.AbstractMapping;\n+import org.apache.syncope.core.persistence.beans.AbstractMappingItem;\n+\n+@Entity\n+public class RMappingItem extends AbstractMappingItem {\n+\n+    private static final long serialVersionUID = 2936446317887310833L;\n+\n+    @Id\n+    private Long id;\n+\n+    @ManyToOne\n+    private RMapping mapping;\n+\n+    @Override\n+    public Long getId() {\n+        return id;\n+    }\n+\n+    @Override\n+    public <T extends AbstractMapping> T getMapping() {\n+        return (T) mapping;\n+    }\n+\n+    @Override\n+    public <T extends AbstractMapping> void setMapping(final T mapping) {\n+        if (mapping != null && !(mapping instanceof RMapping)) {\n+            throw new ClassCastException(\"accountIdItem is expected to be typed RMapping: \"\n+                    + mapping.getClass().getName());\n+        }\n+        this.mapping = (RMapping) mapping;\n+    }\n+}"},{"sha":"d9396d306a039c121f52d59d70cd683cb62dfc23","filename":"core/src/main/java/org/apache/syncope/core/persistence/beans/role/RVirAttr.java","status":"modified","additions":5,"deletions":2,"changes":7,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fbeans%2Frole%2FRVirAttr.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fbeans%2Frole%2FRVirAttr.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fbeans%2Frole%2FRVirAttr.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -18,7 +18,7 @@\n  */\n package org.apache.syncope.core.persistence.beans.role;\n \n-import java.util.Collections;\n+import java.util.ArrayList;\n import java.util.List;\n import javax.persistence.Entity;\n import javax.persistence.FetchType;\n@@ -66,6 +66,9 @@ public <T extends AbstractVirSchema> void setVirtualSchema(final T virtualSchema\n \n     @Override\n     public List<String> getValues() {\n-        return Collections.emptyList();\n+        if (values == null) {\n+            values = new ArrayList<String>();\n+        }\n+        return values;\n     }\n }"},{"sha":"b749575d13dd9eefa3c47f77949b9dd4493348a1","filename":"core/src/main/java/org/apache/syncope/core/persistence/beans/user/UAttr.java","status":"modified","additions":12,"deletions":4,"changes":16,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fbeans%2Fuser%2FUAttr.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fbeans%2Fuser%2FUAttr.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fbeans%2Fuser%2FUAttr.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -29,9 +29,9 @@\n import javax.persistence.OneToMany;\n import javax.persistence.OneToOne;\n import javax.validation.Valid;\n-import org.apache.syncope.core.persistence.beans.AbstractAttributable;\n import org.apache.syncope.core.persistence.beans.AbstractAttr;\n import org.apache.syncope.core.persistence.beans.AbstractAttrValue;\n+import org.apache.syncope.core.persistence.beans.AbstractAttributable;\n import org.apache.syncope.core.persistence.beans.AbstractSchema;\n \n /**\n@@ -41,28 +41,33 @@\n public class UAttr extends AbstractAttr {\n \n     private static final long serialVersionUID = 6333601983691157406L;\n+\n     /**\n      * Auto-generated id for this table.\n      */\n     @Id\n     private Long id;\n+\n     /**\n      * The owner of this attribute.\n      */\n     @ManyToOne(fetch = FetchType.EAGER)\n     private SyncopeUser owner;\n+\n     /**\n      * The schema of this attribute.\n      */\n     @ManyToOne(fetch = FetchType.EAGER)\n     @JoinColumn(name = \"schema_name\")\n     private USchema schema;\n+\n     /**\n      * Values of this attribute (if schema is not UNIQUE).\n      */\n     @OneToMany(cascade = CascadeType.MERGE, orphanRemoval = true, mappedBy = \"attribute\")\n     @Valid\n     private List<UAttrValue> values;\n+\n     /**\n      * Value of this attribute (if schema is UNIQUE).\n      */\n@@ -112,15 +117,17 @@ public <T extends AbstractSchema> void setSchema(final T schema) {\n     @Override\n     public <T extends AbstractAttrValue> boolean addValue(final T attributeValue) {\n         if (!(attributeValue instanceof UAttrValue)) {\n-            throw new ClassCastException(\"attributeValue is expected to be typed UAttrValue: \" + attributeValue.getClass().getName());\n+            throw new ClassCastException(\"attributeValue is expected to be typed UAttrValue: \" + attributeValue.\n+                    getClass().getName());\n         }\n         return values.add((UAttrValue) attributeValue);\n     }\n \n     @Override\n     public <T extends AbstractAttrValue> boolean removeValue(final T attributeValue) {\n         if (!(attributeValue instanceof UAttrValue)) {\n-            throw new ClassCastException(\"attributeValue is expected to be typed UAttrValue: \" + attributeValue.getClass().getName());\n+            throw new ClassCastException(\"attributeValue is expected to be typed UAttrValue: \" + attributeValue.\n+                    getClass().getName());\n         }\n         return values.remove((UAttrValue) attributeValue);\n     }\n@@ -150,7 +157,8 @@ public <T extends AbstractAttrValue> T getUniqueValue() {\n     @Override\n     public <T extends AbstractAttrValue> void setUniqueValue(final T uniqueAttributeValue) {\n         if (!(uniqueAttributeValue instanceof UAttrUniqueValue)) {\n-            throw new ClassCastException(\"uniqueAttributeValue is expected to be typed UAttrUniqueValue: \" + uniqueAttributeValue.getClass().getName());\n+            throw new ClassCastException(\"uniqueAttributeValue is expected to be typed UAttrUniqueValue: \"\n+                    + uniqueAttributeValue.getClass().getName());\n         }\n         this.uniqueValue = (UAttrUniqueValue) uniqueAttributeValue;\n     }"},{"sha":"4806dc89ac15caa4dd9271658989d86d79c31909","filename":"core/src/main/java/org/apache/syncope/core/persistence/beans/user/UMapping.java","status":"added","additions":135,"deletions":0,"changes":135,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fbeans%2Fuser%2FUMapping.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fbeans%2Fuser%2FUMapping.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fbeans%2Fuser%2FUMapping.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -0,0 +1,135 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.core.persistence.beans.user;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+import javax.persistence.CascadeType;\n+import javax.persistence.Entity;\n+import javax.persistence.FetchType;\n+import javax.persistence.Id;\n+import javax.persistence.OneToMany;\n+import javax.persistence.OneToOne;\n+import org.apache.syncope.core.persistence.beans.AbstractMapping;\n+import org.apache.syncope.core.persistence.beans.AbstractMappingItem;\n+import org.apache.syncope.core.persistence.beans.ExternalResource;\n+import org.identityconnectors.framework.common.objects.OperationalAttributes;\n+\n+@Entity\n+public class UMapping extends AbstractMapping {\n+\n+    private static final long serialVersionUID = 4285801404504561073L;\n+\n+    @Id\n+    private Long id;\n+\n+    /**\n+     * Resource owning this mapping.\n+     */\n+    @OneToOne\n+    private ExternalResource resource;\n+\n+    /**\n+     * Attribute mappings.\n+     */\n+    @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.EAGER, mappedBy = \"mapping\")\n+    private List<UMappingItem> items;\n+\n+    public UMapping() {\n+        super();\n+\n+        items = new ArrayList<UMappingItem>();\n+    }\n+\n+    @Override\n+    public Long getId() {\n+        return id;\n+    }\n+\n+    @Override\n+    public ExternalResource getResource() {\n+        return resource;\n+    }\n+\n+    @Override\n+    public void setResource(final ExternalResource resource) {\n+        this.resource = resource;\n+    }\n+\n+    @Override\n+    public <T extends AbstractMappingItem> void setAccountIdItem(final T accountIdItem) {\n+        if (accountIdItem != null && !(accountIdItem instanceof UMappingItem)) {\n+            throw new ClassCastException(\"accountIdItem is expected to be typed UMappingItem: \"\n+                    + accountIdItem.getClass().getName());\n+        }\n+\n+        addAccountIdItem(accountIdItem);\n+    }\n+\n+    public UMappingItem getPasswordItem() {\n+        UMappingItem passwordItem = null;\n+        for (AbstractMappingItem item : getItems()) {\n+            if (item.isPassword()) {\n+                passwordItem = (UMappingItem) item;\n+            }\n+        }\n+        return passwordItem;\n+    }\n+\n+    public boolean setPasswordItem(final UMappingItem passwordItem) {\n+        passwordItem.setExtAttrName(OperationalAttributes.PASSWORD_NAME);\n+        passwordItem.setPassword(true);\n+        return addItem(passwordItem);\n+    }\n+\n+    @Override\n+    public <T extends AbstractMappingItem> List<T> getItems() {\n+        return (List<T>) this.items;\n+    }\n+\n+    @Override\n+    public <T extends AbstractMappingItem> boolean addItem(final T item) {\n+        if (item != null && !(item instanceof UMappingItem)) {\n+            throw new ClassCastException(\"items are expected to be typed UMappingItem: \" + item.getClass().getName());\n+        }\n+        return item == null ? false : this.items.contains((UMappingItem) item) || this.items.add((UMappingItem) item);\n+    }\n+\n+    @Override\n+    public <T extends AbstractMappingItem> boolean removeItem(final T item) {\n+        if (item != null && !(item instanceof UMappingItem)) {\n+            throw new ClassCastException(\"items are expected to be typed UMappingItem: \" + item.getClass().getName());\n+        }\n+        return this.items.remove((UMappingItem) item);\n+    }\n+\n+    @Override\n+    public <T extends AbstractMappingItem> void setItems(final List<T> items) {\n+        this.items.clear();\n+        if (items != null && !items.isEmpty()) {\n+            T item = items.iterator().next();\n+            if (!(item instanceof UMappingItem)) {\n+                throw new ClassCastException(\"items are expected to be typed UMappingItem: \"\n+                        + item.getClass().getName());\n+            }\n+            this.items.addAll((Set<UMappingItem>) items);\n+        }\n+    }\n+}"},{"sha":"4f44261b0cfed7145d120bc043480a10f4133246","filename":"core/src/main/java/org/apache/syncope/core/persistence/beans/user/UMappingItem.java","status":"added","additions":56,"deletions":0,"changes":56,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fbeans%2Fuser%2FUMappingItem.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fbeans%2Fuser%2FUMappingItem.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fbeans%2Fuser%2FUMappingItem.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -0,0 +1,56 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.core.persistence.beans.user;\n+\n+import javax.persistence.Entity;\n+import javax.persistence.Id;\n+import javax.persistence.ManyToOne;\n+import org.apache.syncope.core.persistence.beans.AbstractMapping;\n+import org.apache.syncope.core.persistence.beans.AbstractMappingItem;\n+\n+@Entity\n+public class UMappingItem extends AbstractMappingItem {\n+\n+    private static final long serialVersionUID = 2936446317887310833L;\n+\n+    @Id\n+    private Long id;\n+\n+    @ManyToOne\n+    private UMapping mapping;\n+\n+    @Override\n+    public Long getId() {\n+        return id;\n+    }\n+\n+    @Override\n+    public <T extends AbstractMapping> T getMapping() {\n+        return (T) mapping;\n+    }\n+\n+    @Override\n+    public <T extends AbstractMapping> void setMapping(final T mapping) {\n+        if (mapping != null && !(mapping instanceof UMapping)) {\n+            throw new ClassCastException(\"accountIdItem is expected to be typed UMapping: \"\n+                    + mapping.getClass().getName());\n+        }\n+        this.mapping = (UMapping) mapping;\n+    }\n+}"},{"sha":"5525d183bec5f11a9d7157c502968f95fc370eb8","filename":"core/src/main/java/org/apache/syncope/core/persistence/dao/AttributableDAO.java","status":"added","additions":40,"deletions":0,"changes":40,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2FAttributableDAO.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2FAttributableDAO.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2FAttributableDAO.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -0,0 +1,40 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.core.persistence.dao;\n+\n+import java.util.List;\n+import org.apache.syncope.core.persistence.beans.AbstractAttrValue;\n+import org.apache.syncope.core.persistence.beans.AbstractAttributable;\n+import org.apache.syncope.core.persistence.beans.ExternalResource;\n+import org.apache.syncope.core.rest.controller.InvalidSearchConditionException;\n+import org.apache.syncope.core.util.AttributableUtil;\n+\n+public interface AttributableDAO extends DAO {\n+\n+    <T extends AbstractAttributable> List<T> findByAttrValue(String schemaName,\n+            AbstractAttrValue attrValue, AttributableUtil attrUtil);\n+\n+    <T extends AbstractAttributable> AbstractAttributable findByAttrUniqueValue(String schemaName,\n+            AbstractAttrValue attrUniqueValue, AttributableUtil attrUtil);\n+\n+    <T extends AbstractAttributable> List<T> findByDerAttrValue(String schemaName, String value,\n+            AttributableUtil attrUtil) throws InvalidSearchConditionException;\n+\n+    <T extends AbstractAttributable> List<T> findByResource(ExternalResource resource, Class<T> reference);\n+}"},{"sha":"15492edb840ae8bac45a25f6058ecdc2cd565fb4","filename":"core/src/main/java/org/apache/syncope/core/persistence/dao/AttributableSearchDAO.java","status":"renamed","additions":21,"deletions":11,"changes":32,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2FAttributableSearchDAO.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2FAttributableSearchDAO.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2FAttributableSearchDAO.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -21,39 +21,49 @@\n import java.util.List;\n import java.util.Set;\n import org.apache.syncope.client.search.NodeCond;\n-import org.apache.syncope.core.persistence.beans.user.SyncopeUser;\n+import org.apache.syncope.core.persistence.beans.AbstractAttributable;\n+import org.apache.syncope.core.util.AttributableUtil;\n \n-public interface UserSearchDAO extends DAO {\n+public interface AttributableSearchDAO extends DAO {\n \n     /**\n      * @param adminRoles the set of admin roles owned by the caller\n      * @param searchCondition the search condition\n+     * @param attrUtil AttributeUtil\n      * @return size of search result\n      */\n-    int count(Set<Long> adminRoles, NodeCond searchCondition);\n+    int count(Set<Long> adminRoles, NodeCond searchCondition, AttributableUtil attrUtil);\n \n     /**\n      * @param adminRoles the set of admin roles owned by the caller\n      * @param searchCondition the search condition\n-     * @return the list of users matching the given search condition\n+     * @param attrUtil AttributeUtil\n+     * @param <T> user/role\n+     * @return the list of users/roles matching the given search condition\n      */\n-    List<SyncopeUser> search(Set<Long> adminRoles, NodeCond searchCondition);\n+    <T extends AbstractAttributable> List<T> search(Set<Long> adminRoles, NodeCond searchCondition,\n+            AttributableUtil attrUtil);\n \n     /**\n      * @param adminRoles the set of admin roles owned by the caller\n      * @param searchCondition the search condition\n      * @param page position of the first result, start from 1\n      * @param itemsPerPage number of results per page\n-     * @return the list of users matching the given search condition\n+     * @param attrUtil AttributeUtil\n+     * @param <T> user/role\n+     * @return the list of users/roles matching the given search condition (in the given page)\n      */\n-    List<SyncopeUser> search(Set<Long> adminRoles, NodeCond searchCondition, int page, int itemsPerPage);\n+    <T extends AbstractAttributable> List<T> search(Set<Long> adminRoles, NodeCond searchCondition,\n+            int page, int itemsPerPage, AttributableUtil attrUtil);\n \n     /**\n-     * Verify if user matched the given search condition.\n+     * Verify if user/role matches the given search condition.\n      *\n-     * @param user to be checked\n+     * @param subject to be checked\n      * @param searchCondition to be verified\n-     * @return true if user matched searchCondition\n+     * @param attrUtil AttributeUtil\n+     * @param <T> user/role\n+     * @return true if user/role matches searchCondition\n      */\n-    boolean matches(SyncopeUser user, NodeCond searchCondition);\n+    <T extends AbstractAttributable> boolean matches(T subject, NodeCond searchCondition, AttributableUtil attrUtil);\n }","previous_filename":"core/src/main/java/org/apache/syncope/core/persistence/dao/UserSearchDAO.java"},{"sha":"6f7fd094315d3f8359037ccf942463333361352a","filename":"core/src/main/java/org/apache/syncope/core/persistence/dao/ResourceDAO.java","status":"modified","additions":3,"deletions":6,"changes":9,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2FResourceDAO.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2FResourceDAO.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2FResourceDAO.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -19,8 +19,8 @@\n package org.apache.syncope.core.persistence.dao;\n \n import java.util.List;\n+import org.apache.syncope.core.persistence.beans.AbstractMappingItem;\n import org.apache.syncope.core.persistence.beans.ExternalResource;\n-import org.apache.syncope.core.persistence.beans.SchemaMapping;\n import org.apache.syncope.core.persistence.validation.entity.InvalidEntityException;\n import org.apache.syncope.types.IntMappingType;\n \n@@ -34,11 +34,8 @@ public interface ResourceDAO extends DAO {\n \n     ExternalResource save(ExternalResource resource) throws InvalidEntityException;\n \n-    List<SchemaMapping> findAllMappings();\n-\n-    SchemaMapping getMappingForAccountId(String resourceName);\n-\n-    void deleteMappings(String schemaName, IntMappingType intMappingType);\n+    <T extends AbstractMappingItem> void deleteMapping(String schemaName, IntMappingType intMappingType,\n+            Class<T> reference);\n \n     void delete(String name);\n }"},{"sha":"262bc102b7d628cc2ffcaeb51f32fc425f094dee","filename":"core/src/main/java/org/apache/syncope/core/persistence/dao/RoleDAO.java","status":"modified","additions":13,"deletions":3,"changes":16,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2FRoleDAO.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2FRoleDAO.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2FRoleDAO.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -24,9 +24,11 @@\n import org.apache.syncope.core.persistence.beans.membership.Membership;\n import org.apache.syncope.core.persistence.beans.role.SyncopeRole;\n import org.apache.syncope.core.persistence.beans.user.SyncopeUser;\n+import org.apache.syncope.core.persistence.beans.user.UAttrValue;\n import org.apache.syncope.core.persistence.validation.entity.InvalidEntityException;\n+import org.apache.syncope.core.rest.controller.InvalidSearchConditionException;\n \n-public interface RoleDAO extends DAO {\n+public interface RoleDAO extends AttributableDAO {\n \n     SyncopeRole find(Long id);\n \n@@ -38,19 +40,27 @@ public interface RoleDAO extends DAO {\n \n     List<SyncopeRole> findByEntitlement(final Entitlement entitlement);\n \n-    List<SyncopeRole> findByResource(ExternalResource resource);\n-\n     List<SyncopeRole> findAncestors(SyncopeRole role);\n \n     List<SyncopeRole> findChildren(SyncopeRole role);\n \n     List<SyncopeRole> findDescendants(SyncopeRole role);\n \n+    List<SyncopeRole> findByDerAttrValue(String schemaName, String value) throws InvalidSearchConditionException;\n+\n+    List<SyncopeRole> findByAttrValue(String schemaName, UAttrValue attrValue);\n+\n+    SyncopeRole findByAttrUniqueValue(String schemaName, UAttrValue attrUniqueValue);\n+\n+    List<SyncopeRole> findByResource(ExternalResource resource);\n+\n     List<SyncopeRole> findAll();\n \n     List<Membership> findMemberships(SyncopeRole role);\n \n     SyncopeRole save(SyncopeRole syncopeRole) throws InvalidEntityException;\n \n+    void delete(SyncopeRole role);\n+\n     void delete(Long id);\n }"},{"sha":"d0a82dd3bcbb912086c33e74249075edb0552593","filename":"core/src/main/java/org/apache/syncope/core/persistence/dao/TaskDAO.java","status":"modified","additions":0,"deletions":6,"changes":6,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2FTaskDAO.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2FTaskDAO.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2FTaskDAO.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -20,9 +20,7 @@\n \n import java.util.List;\n import org.apache.syncope.core.persistence.beans.ExternalResource;\n-import org.apache.syncope.core.persistence.beans.PropagationTask;\n import org.apache.syncope.core.persistence.beans.Task;\n-import org.apache.syncope.core.persistence.beans.user.SyncopeUser;\n import org.apache.syncope.core.persistence.validation.entity.InvalidEntityException;\n \n public interface TaskDAO extends DAO {\n@@ -37,10 +35,6 @@ public interface TaskDAO extends DAO {\n \n     <T extends Task> List<T> findAll(int page, int itemsPerPage, Class<T> reference);\n \n-    List<PropagationTask> findAll(ExternalResource resource, SyncopeUser user);\n-\n-    List<PropagationTask> findAll(SyncopeUser user);\n-\n     <T extends Task> int count(Class<T> reference);\n \n     <T extends Task> T save(T task) throws InvalidEntityException;"},{"sha":"bcec899c519f1c5b9ead734f2ca2634739fd6998","filename":"core/src/main/java/org/apache/syncope/core/persistence/dao/UserDAO.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2FUserDAO.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2FUserDAO.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2FUserDAO.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -26,7 +26,7 @@\n import org.apache.syncope.core.persistence.validation.entity.InvalidEntityException;\n import org.apache.syncope.core.rest.controller.InvalidSearchConditionException;\n \n-public interface UserDAO extends DAO {\n+public interface UserDAO extends AttributableDAO {\n \n     SyncopeUser find(Long id);\n "},{"sha":"6408a6ccd6d499d5c194f8304f8e1f2bf0732513","filename":"core/src/main/java/org/apache/syncope/core/persistence/dao/impl/AbstractAttributableDAOImpl.java","status":"added","additions":341,"deletions":0,"changes":341,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2Fimpl%2FAbstractAttributableDAOImpl.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2Fimpl%2FAbstractAttributableDAOImpl.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2Fimpl%2FAbstractAttributableDAOImpl.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -0,0 +1,341 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.core.persistence.dao.impl;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import javax.persistence.Query;\n+import javax.persistence.TemporalType;\n+import org.apache.commons.jexl2.parser.Parser;\n+import org.apache.commons.jexl2.parser.ParserConstants;\n+import org.apache.commons.jexl2.parser.Token;\n+import org.apache.syncope.core.persistence.beans.AbstractAttrValue;\n+import org.apache.syncope.core.persistence.beans.AbstractAttributable;\n+import org.apache.syncope.core.persistence.beans.AbstractDerSchema;\n+import org.apache.syncope.core.persistence.beans.AbstractSchema;\n+import org.apache.syncope.core.persistence.beans.ExternalResource;\n+import org.apache.syncope.core.persistence.dao.AttributableDAO;\n+import org.apache.syncope.core.persistence.dao.DerSchemaDAO;\n+import org.apache.syncope.core.persistence.dao.SchemaDAO;\n+import org.apache.syncope.core.rest.controller.InvalidSearchConditionException;\n+import org.apache.syncope.core.util.AttributableUtil;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.util.StringUtils;\n+\n+public abstract class AbstractAttributableDAOImpl extends AbstractDAOImpl implements AttributableDAO {\n+\n+    @Autowired\n+    protected SchemaDAO schemaDAO;\n+\n+    @Autowired\n+    protected DerSchemaDAO derSchemaDAO;\n+\n+    /**\n+     * Split an attribute value recurring on provided literals/tokens.\n+     *\n+     * @param attrValue value to be split\n+     * @param literals literals/tokens\n+     * @return\n+     */\n+    private List<String> split(final String attrValue, final List<String> literals) {\n+        final List<String> attrValues = new ArrayList<String>();\n+\n+        if (literals.isEmpty()) {\n+            attrValues.add(attrValue);\n+        } else {\n+            for (String token : attrValue.split(Pattern.quote(literals.get(0)))) {\n+                attrValues.addAll(split(token, literals.subList(1, literals.size())));\n+            }\n+        }\n+\n+        return attrValues;\n+    }\n+\n+    /**\n+     * Generate one where clause for each different attribute schema into the derived schema expression provided.\n+     *\n+     * @param expression derived schema expression\n+     * @param value derived attribute value\n+     * @return where clauses to use to build the query\n+     * @throws InvalidSearchConditionException in case of errors retrieving identifiers\n+     */\n+    private Set<String> getWhereClause(final String expression, final String value, final AttributableUtil attrUtil)\n+            throws InvalidSearchConditionException {\n+\n+        final Parser parser = new Parser(new StringReader(expression));\n+\n+        // Schema names\n+        final List<String> identifiers = new ArrayList<String>();\n+\n+        // Literals\n+        final List<String> literals = new ArrayList<String>();\n+\n+        // Get schema names and literals\n+        Token token;\n+        while ((token = parser.getNextToken()) != null && StringUtils.hasText(token.toString())) {\n+\n+            if (token.kind == ParserConstants.STRING_LITERAL) {\n+                literals.add(token.toString().substring(1, token.toString().length() - 1));\n+            }\n+\n+            if (token.kind == ParserConstants.IDENTIFIER) {\n+                identifiers.add(token.toString());\n+            }\n+        }\n+\n+        // Sort literals in order to process later literals included into others\n+        Collections.sort(literals, new Comparator<String>() {\n+\n+            @Override\n+            public int compare(String t, String t1) {\n+                if (t == null && t1 == null) {\n+                    return 0;\n+                } else if (t != null && t1 == null) {\n+                    return -1;\n+                } else if (t == null && t1 != null) {\n+                    return 1;\n+                } else if (t.length() == t1.length()) {\n+                    return 0;\n+                } else if (t.length() > t1.length()) {\n+                    return -1;\n+                } else {\n+                    return 1;\n+                }\n+            }\n+        });\n+\n+        // Split value on provided literals\n+        final List<String> attrValues = split(value, literals);\n+\n+        if (attrValues.size() != identifiers.size()) {\n+            LOG.error(\"Ambiguous jexl expression resolution.\");\n+            throw new InvalidSearchConditionException(\"literals and values have different size\");\n+        }\n+\n+        // clauses to be used with INTERSECTed queries\n+        final Set<String> clauses = new HashSet<String>();\n+\n+        // builder to build the clauses\n+        final StringBuilder bld = new StringBuilder();\n+\n+        // Contains used identifiers in order to avoid replications\n+        final Set<String> used = new HashSet<String>();\n+\n+        // Create several clauses: one for eanch identifiers\n+        for (int i = 0; i < identifiers.size(); i++) {\n+            if (!used.contains(identifiers.get(i))) {\n+\n+                // verify schema existence and get schema type\n+                AbstractSchema schema = schemaDAO.find(identifiers.get(i), attrUtil.schemaClass());\n+                if (schema == null) {\n+                    LOG.error(\"Invalid schema name '{}'\", identifiers.get(i));\n+                    throw new InvalidSearchConditionException(\"Invalid schema name \" + identifiers.get(i));\n+                }\n+\n+                // clear builder\n+                bld.delete(0, bld.length());\n+\n+                bld.append(\"(\");\n+\n+                // set schema name\n+                bld.append(\"s.name = '\").append(identifiers.get(i)).append(\"'\");\n+\n+                bld.append(\" AND \");\n+\n+                bld.append(\"s.name = a.schema_name\").append(\" AND \");\n+\n+                bld.append(\"a.id = v.attribute_id\");\n+\n+                bld.append(\" AND \");\n+\n+                // use a value clause different for eanch different schema type\n+                switch (schema.getType()) {\n+                    case Boolean:\n+                        bld.append(\"v.booleanValue = '\").append(attrValues.get(i)).append(\"'\");\n+                        break;\n+                    case Long:\n+                        bld.append(\"v.longValue = \").append(attrValues.get(i));\n+                        break;\n+                    case Double:\n+                        bld.append(\"v.doubleValue = \").append(attrValues.get(i));\n+                        break;\n+                    case Date:\n+                        bld.append(\"v.dateValue = '\").append(attrValues.get(i)).append(\"'\");\n+                        break;\n+                    default:\n+                        bld.append(\"v.stringValue = '\").append(attrValues.get(i)).append(\"'\");\n+                }\n+\n+                bld.append(\")\");\n+\n+                used.add(identifiers.get(i));\n+\n+                clauses.add(bld.toString());\n+            }\n+        }\n+\n+        LOG.debug(\"Generated where clauses {}\", clauses);\n+\n+        return clauses;\n+    }\n+\n+    protected abstract <T extends AbstractAttributable> T find(final Long id);\n+\n+    @Override\n+    public <T extends AbstractAttributable> List<T> findByAttrValue(final String schemaName,\n+            final AbstractAttrValue attrValue, final AttributableUtil attrUtil) {\n+\n+        AbstractSchema schema = schemaDAO.find(schemaName, attrUtil.schemaClass());\n+        if (schema == null) {\n+            LOG.error(\"Invalid schema name '{}'\", schemaName);\n+            return Collections.EMPTY_LIST;\n+        }\n+\n+        final String entityName = schema.isUniqueConstraint()\n+                ? attrUtil.attrUniqueValueClass().getName()\n+                : attrUtil.attrValueClass().getName();\n+\n+        Query query = entityManager.createQuery(\"SELECT e FROM \" + entityName + \" e\"\n+                + \" WHERE e.attribute.schema.name = :schemaName \" + \" AND (e.stringValue IS NOT NULL\"\n+                + \" AND e.stringValue = :stringValue)\" + \" OR (e.booleanValue IS NOT NULL\"\n+                + \" AND e.booleanValue = :booleanValue)\" + \" OR (e.dateValue IS NOT NULL\"\n+                + \" AND e.dateValue = :dateValue)\" + \" OR (e.longValue IS NOT NULL\" + \" AND e.longValue = :longValue)\"\n+                + \" OR (e.doubleValue IS NOT NULL\" + \" AND e.doubleValue = :doubleValue)\");\n+\n+        query.setParameter(\"schemaName\", schemaName);\n+        query.setParameter(\"stringValue\", attrValue.getStringValue());\n+        query.setParameter(\"booleanValue\", attrValue.getBooleanValue() == null\n+                ? null\n+                : attrValue.getBooleanAsInteger(attrValue.getBooleanValue()));\n+        if (attrValue.getDateValue() == null) {\n+            query.setParameter(\"dateValue\", null);\n+        } else {\n+            query.setParameter(\"dateValue\", attrValue.getDateValue(), TemporalType.TIMESTAMP);\n+        }\n+        query.setParameter(\"longValue\", attrValue.getLongValue());\n+        query.setParameter(\"doubleValue\", attrValue.getDoubleValue());\n+\n+        List<T> result = new ArrayList<T>();\n+        for (AbstractAttrValue value : (List<AbstractAttrValue>) query.getResultList()) {\n+            T subject = value.getAttribute().getOwner();\n+            if (!result.contains(subject)) {\n+                result.add(subject);\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    @Override\n+    public <T extends AbstractAttributable> AbstractAttributable findByAttrUniqueValue(final String schemaName,\n+            final AbstractAttrValue attrUniqueValue, final AttributableUtil attrUtil) {\n+\n+        AbstractSchema schema = schemaDAO.find(schemaName, attrUtil.schemaClass());\n+        if (schema == null) {\n+            LOG.error(\"Invalid schema name '{}'\", schemaName);\n+            return null;\n+        }\n+        if (!schema.isUniqueConstraint()) {\n+            LOG.error(\"This schema has not unique constraint: '{}'\", schemaName);\n+            return null;\n+        }\n+\n+        List<T> result = findByAttrValue(schemaName, attrUniqueValue, attrUtil);\n+        return result.isEmpty()\n+                ? null\n+                : result.iterator().next();\n+    }\n+\n+    /**\n+     * Find users / roles by derived attribute value. This method could fail if one or more string literals contained\n+     * into the derived attribute value provided derive from identifier (schema name) replacement. When you are going to\n+     * specify a derived attribute expression you must be quite sure that string literals used to build the expression\n+     * cannot be found into the attribute values used to replace attribute schema names used as identifiers.\n+     *\n+     * @param schemaName derived schema name\n+     * @param value derived attribute value\n+     * @return list of users / roles\n+     * @throws InvalidSearchConditionException in case of errors retrieving schema names used to buid the derived schema\n+     * expression.\n+     */\n+    @Override\n+    public <T extends AbstractAttributable> List<T> findByDerAttrValue(final String schemaName, final String value,\n+            final AttributableUtil attrUtil)\n+            throws InvalidSearchConditionException {\n+\n+        AbstractDerSchema schema = derSchemaDAO.find(schemaName, attrUtil.derSchemaClass());\n+        if (schema == null) {\n+            LOG.error(\"Invalid schema name '{}'\", schemaName);\n+            return Collections.EMPTY_LIST;\n+        }\n+\n+        // query string\n+        final StringBuilder querystring = new StringBuilder();\n+\n+        boolean subquery = false;\n+        for (String clause : getWhereClause(schema.getExpression(), value, attrUtil)) {\n+            if (querystring.length() > 0) {\n+                subquery = true;\n+                querystring.append(\" AND a.owner_id IN ( \");\n+            }\n+\n+            querystring.append(\"SELECT a.owner_id \").\n+                    append(\"FROM \").append(attrUtil.attrClass().getSimpleName()).append(\" a, \").\n+                    append(attrUtil.attrValueClass().getSimpleName()).append(\" v, \").\n+                    append(attrUtil.schemaClass().getSimpleName()).append(\" s \").\n+                    append(\"WHERE \").append(clause);\n+\n+            if (subquery) {\n+                querystring.append(')');\n+            }\n+        }\n+\n+        LOG.debug(\"Execute query {}\", querystring);\n+\n+        final Query query = entityManager.createNativeQuery(querystring.toString());\n+\n+        final List<T> result = new ArrayList<T>();\n+\n+        for (Object userId : query.getResultList()) {\n+            T subject = find(Long.parseLong(userId.toString()));\n+            if (!result.contains(subject)) {\n+                result.add(subject);\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    @Override\n+    public <T extends AbstractAttributable> List<T> findByResource(final ExternalResource resource,\n+            final Class<T> reference) {\n+\n+        Query query = entityManager.createQuery(\"SELECT e FROM \" + reference.getSimpleName() + \" e \"\n+                + \"WHERE :resource MEMBER OF e.resources\");\n+        query.setParameter(\"resource\", resource);\n+\n+        return query.getResultList();\n+    }\n+}"},{"sha":"90d2c41778f0956f6f91b3c9f22c76efc64b644f","filename":"core/src/main/java/org/apache/syncope/core/persistence/dao/impl/AttributableSearchDAOImpl.java","status":"renamed","additions":129,"deletions":113,"changes":242,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2Fimpl%2FAttributableSearchDAOImpl.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2Fimpl%2FAttributableSearchDAOImpl.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2Fimpl%2FAttributableSearchDAOImpl.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -28,26 +28,28 @@\n import javax.persistence.Query;\n import javax.persistence.TemporalType;\n import javax.validation.ValidationException;\n-import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.stereotype.Repository;\n+import org.apache.syncope.client.search.AttributableCond;\n import org.apache.syncope.client.search.AttributeCond;\n-import org.apache.syncope.client.search.SyncopeUserCond;\n import org.apache.syncope.client.search.MembershipCond;\n import org.apache.syncope.client.search.NodeCond;\n import org.apache.syncope.client.search.ResourceCond;\n-import org.apache.syncope.core.persistence.beans.user.SyncopeUser;\n-import org.apache.syncope.core.persistence.beans.user.UAttrValue;\n-import org.apache.syncope.core.persistence.beans.user.USchema;\n+import org.apache.syncope.core.persistence.beans.AbstractAttrValue;\n+import org.apache.syncope.core.persistence.beans.AbstractAttributable;\n+import org.apache.syncope.core.persistence.beans.AbstractSchema;\n+import org.apache.syncope.core.persistence.dao.AttributableSearchDAO;\n import org.apache.syncope.core.persistence.dao.RoleDAO;\n import org.apache.syncope.core.persistence.dao.SchemaDAO;\n import org.apache.syncope.core.persistence.dao.UserDAO;\n-import org.apache.syncope.core.persistence.dao.UserSearchDAO;\n+import org.apache.syncope.core.util.AttributableUtil;\n+import org.apache.syncope.types.AttributableType;\n import org.apache.syncope.types.SchemaType;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Repository;\n \n @Repository\n-public class UserSearchDAOImpl extends AbstractDAOImpl implements UserSearchDAO {\n+public class AttributableSearchDAOImpl extends AbstractDAOImpl implements AttributableSearchDAO {\n \n-    static final private String EMPTY_ATTR_QUERY = \"SELECT user_id FROM user_search_attr WHERE 1=2\";\n+    static final private String EMPTY_ATTR_QUERY = \"SELECT subject_id FROM user_search_attr WHERE 1=2\";\n \n     @Autowired\n     private UserDAO userDAO;\n@@ -58,20 +60,18 @@ public class UserSearchDAOImpl extends AbstractDAOImpl implements UserSearchDAO\n     @Autowired\n     private SchemaDAO schemaDAO;\n \n-    public UserSearchDAOImpl() {\n-        super();\n-    }\n-\n-    private String getAdminRolesFilter(final Set<Long> adminRoles) {\n+    private String getAdminRolesFilter(final Set<Long> adminRoles, final AttributableUtil attrUtil) {\n         final StringBuilder adminRolesFilter = new StringBuilder();\n \n-        adminRolesFilter.append(\"SELECT syncopeUser_id AS user_id \").append(\"FROM Membership M1 \").\n-                append(\"WHERE syncopeRole_id IN (\");\n-\n-        adminRolesFilter.append(\"SELECT syncopeRole_id \").append(\"FROM Membership M2 \").\n-                append(\"WHERE M2.syncopeUser_id=M1.syncopeUser_id \").append(\"AND syncopeRole_id NOT IN (\");\n+        if (attrUtil.getType() == AttributableType.USER) {\n+            adminRolesFilter.append(\"SELECT syncopeUser_id AS subject_id FROM Membership M1 WHERE syncopeRole_id IN (\").\n+                    append(\"SELECT syncopeRole_id FROM Membership M2 WHERE M2.syncopeUser_id=M1.syncopeUser_id \").\n+                    append(\"AND syncopeRole_id NOT IN (\");\n+        }\n \n-        adminRolesFilter.append(\"SELECT id AS syncopeRole_id FROM SyncopeRole\");\n+        adminRolesFilter.append(\"SELECT id AS \").\n+                append(attrUtil.getType() == AttributableType.USER ? \"syncopeRole\" : \"subject\").\n+                append(\"_id FROM SyncopeRole\");\n \n         boolean firstRole = true;\n \n@@ -80,32 +80,34 @@ private String getAdminRolesFilter(final Set<Long> adminRoles) {\n                 adminRolesFilter.append(\" WHERE\");\n                 firstRole = false;\n             } else {\n-                adminRolesFilter.append(\" OR\");\n+                adminRolesFilter.append(attrUtil.getType() == AttributableType.USER ? \" OR\" : \" AND\");\n             }\n-            adminRolesFilter.append(\" id=\").append(adminRoleId);\n+            adminRolesFilter.append(attrUtil.getType() == AttributableType.USER\n+                    ? \" id=\" : \" id <>\").append(adminRoleId);\n         }\n \n-        adminRolesFilter.append(\"))\");\n+        if (attrUtil.getType() == AttributableType.USER) {\n+            adminRolesFilter.append(\"))\");\n+        }\n \n         return adminRolesFilter.toString();\n     }\n \n     @Override\n-    public int count(final Set<Long> adminRoles, final NodeCond searchCondition) {\n-\n+    public int count(final Set<Long> adminRoles, final NodeCond searchCondition, final AttributableUtil attrUtil) {\n         List<Object> parameters = Collections.synchronizedList(new ArrayList<Object>());\n \n         // 1. get the query string from the search condition\n-        StringBuilder queryString = getQuery(searchCondition, parameters);\n+        StringBuilder queryString = getQuery(searchCondition, parameters, attrUtil);\n \n         // 2. take into account administrative roles\n-        queryString.insert(0, \"SELECT u.user_id FROM (\");\n-        queryString.append(\") u WHERE user_id NOT IN (\");\n-        queryString.append(getAdminRolesFilter(adminRoles)).append(\")\");\n+        queryString.insert(0, \"SELECT u.subject_id FROM (\");\n+        queryString.append(\") u WHERE subject_id NOT IN (\");\n+        queryString.append(getAdminRolesFilter(adminRoles, attrUtil)).append(\")\");\n \n         // 3. prepare the COUNT query\n-        queryString.insert(0, \"SELECT COUNT(user_id) FROM (\");\n-        queryString.append(\") count_user_id\");\n+        queryString.insert(0, \"SELECT COUNT(subject_id) FROM (\");\n+        queryString.append(\") count_subject_id\");\n \n         Query countQuery = entityManager.createNativeQuery(queryString.toString());\n         fillWithParameters(countQuery, parameters);\n@@ -119,44 +121,47 @@ public int count(final Set<Long> adminRoles, final NodeCond searchCondition) {\n     }\n \n     @Override\n-    public List<SyncopeUser> search(final Set<Long> adminRoles, final NodeCond searchCondition) {\n-        return search(adminRoles, searchCondition, -1, -1);\n+    public <T extends AbstractAttributable> List<T> search(final Set<Long> adminRoles, final NodeCond searchCondition,\n+            final AttributableUtil attrUtil) {\n+\n+        return search(adminRoles, searchCondition, -1, -1, attrUtil);\n     }\n \n     @Override\n-    public List<SyncopeUser> search(\n-            final Set<Long> adminRoles, final NodeCond searchCondition, final int page, final int itemsPerPage) {\n+    public <T extends AbstractAttributable> List<T> search(final Set<Long> adminRoles, final NodeCond searchCondition,\n+            final int page, final int itemsPerPage, final AttributableUtil attrUtil) {\n \n-        List<SyncopeUser> result = Collections.emptyList();\n+        List<T> result = Collections.EMPTY_LIST;\n \n         if (adminRoles != null && (!adminRoles.isEmpty() || roleDAO.findAll().isEmpty())) {\n             LOG.debug(\"Search condition:\\n{}\", searchCondition);\n \n-            if (!searchCondition.checkValidity()) {\n-                LOG.error(\"Invalid search condition:\\n{}\", searchCondition);\n-            } else {\n+            if (searchCondition.checkValidity()) {\n                 try {\n-                    result = doSearch(adminRoles, searchCondition, page, itemsPerPage);\n+                    result = doSearch(adminRoles, searchCondition, page, itemsPerPage, attrUtil);\n                 } catch (Exception e) {\n-                    LOG.error(\"While searching users\", e);\n+                    LOG.error(\"While searching for {}\", attrUtil.getType(), e);\n                 }\n+            } else {\n+                LOG.error(\"Invalid search condition:\\n{}\", searchCondition);\n             }\n         }\n \n         return result;\n     }\n \n     @Override\n-    public boolean matches(final SyncopeUser user, final NodeCond searchCondition) {\n+    public <T extends AbstractAttributable> boolean matches(final T user, final NodeCond searchCondition,\n+            final AttributableUtil attrUtil) {\n \n         List<Object> parameters = Collections.synchronizedList(new ArrayList<Object>());\n \n         // 1. get the query string from the search condition\n-        StringBuilder queryString = getQuery(searchCondition, parameters);\n+        StringBuilder queryString = getQuery(searchCondition, parameters, attrUtil);\n \n         // 2. take into account the passed user\n-        queryString.insert(0, \"SELECT u.user_id FROM (\");\n-        queryString.append(\") u WHERE user_id=?\").append(setParameter(parameters, user.getId()));\n+        queryString.insert(0, \"SELECT u.subject_id FROM (\");\n+        queryString.append(\") u WHERE subject_id=?\").append(setParameter(parameters, user.getId()));\n \n         // 3. prepare the search query\n         Query query = entityManager.createNativeQuery(queryString.toString());\n@@ -165,13 +170,12 @@ public boolean matches(final SyncopeUser user, final NodeCond searchCondition) {\n         fillWithParameters(query, parameters);\n \n         // 5. executes query\n-        List<SyncopeUser> result = query.getResultList();\n+        List<T> result = query.getResultList();\n \n         return !result.isEmpty();\n     }\n \n     private int setParameter(final List<Object> parameters, final Object parameter) {\n-\n         int key;\n         synchronized (parameters) {\n             parameters.add(parameter);\n@@ -182,7 +186,6 @@ private int setParameter(final List<Object> parameters, final Object parameter)\n     }\n \n     private void fillWithParameters(final Query query, final List<Object> parameters) {\n-\n         for (int i = 0; i < parameters.size(); i++) {\n             if (parameters.get(i) instanceof Date) {\n                 query.setParameter(i + 1, (Date) parameters.get(i), TemporalType.TIMESTAMP);\n@@ -196,31 +199,29 @@ private void fillWithParameters(final Query query, final List<Object> parameters\n         }\n     }\n \n-    private List<SyncopeUser> doSearch(\n-            final Set<Long> adminRoles, final NodeCond nodeCond, final int page, final int itemsPerPage) {\n+    private <T extends AbstractAttributable> List<T> doSearch(final Set<Long> adminRoles, final NodeCond nodeCond,\n+            final int page, final int itemsPerPage, final AttributableUtil attrUtil) {\n \n         List<Object> parameters = Collections.synchronizedList(new ArrayList<Object>());\n \n         // 1. get the query string from the search condition\n-        final StringBuilder queryString = getQuery(nodeCond, parameters);\n+        final StringBuilder queryString = getQuery(nodeCond, parameters, attrUtil);\n \n         // 2. take into account administrative roles\n         if (queryString.charAt(0) == '(') {\n-            queryString.insert(0, \"SELECT u.user_id FROM \");\n-            queryString.append(\" u WHERE user_id NOT IN (\");\n+            queryString.insert(0, \"SELECT u.subject_id FROM \");\n+            queryString.append(\" u WHERE subject_id NOT IN (\");\n         } else {\n-            queryString.insert(0, \"SELECT u.user_id FROM (\");\n-            queryString.append(\") u WHERE user_id NOT IN (\");\n+            queryString.insert(0, \"SELECT u.subject_id FROM (\");\n+            queryString.append(\") u WHERE subject_id NOT IN (\");\n         }\n-        queryString.append(getAdminRolesFilter(adminRoles)).append(\")\");\n+        queryString.append(getAdminRolesFilter(adminRoles, attrUtil)).append(\")\");\n \n         // 3. prepare the search query\n         final Query query = entityManager.createNativeQuery(queryString.toString());\n \n         // page starts from 1, while setFirtResult() starts from 0\n-        query.setFirstResult(itemsPerPage * (page <= 0\n-                ? 0\n-                : page - 1));\n+        query.setFirstResult(itemsPerPage * (page <= 0 ? 0 : page - 1));\n \n         if (itemsPerPage >= 0) {\n             query.setMaxResults(itemsPerPage);\n@@ -232,69 +233,77 @@ private List<SyncopeUser> doSearch(\n         LOG.debug(\"Native query\\n{}\\nwith parameters\\n{}\", queryString.toString(), parameters);\n \n         // 5. Prepare the result (avoiding duplicates - set)\n-        final Set<Number> userIds = new HashSet<Number>();\n+        final Set<Number> subjectIds = new HashSet<Number>();\n         final List resultList = query.getResultList();\n \n         //fix for HHH-5902 - bug hibernate\n         if (resultList != null) {\n             for (Object userId : resultList) {\n                 if (userId instanceof Object[]) {\n-                    userIds.add((Number) ((Object[]) userId)[0]);\n+                    subjectIds.add((Number) ((Object[]) userId)[0]);\n                 } else {\n-                    userIds.add((Number) userId);\n+                    subjectIds.add((Number) userId);\n                 }\n             }\n         }\n \n-        final List<SyncopeUser> result = new ArrayList<SyncopeUser>(userIds.size());\n+        final List<T> result = new ArrayList<T>(subjectIds.size());\n \n-        SyncopeUser user;\n-        for (Object userId : userIds) {\n-            user = userDAO.find(((Number) userId).longValue());\n-            if (user == null) {\n-                LOG.error(\"Could not find user with id {}, \" + \"even though returned by the native query\", userId);\n+        for (Object subjectId : subjectIds) {\n+            T subject = attrUtil.getType() == AttributableType.USER\n+                    ? (T) userDAO.find(((Number) subjectId).longValue())\n+                    : (T) roleDAO.find(((Number) subjectId).longValue());\n+            if (subject == null) {\n+                LOG.error(\"Could not find {} with id {}, even though returned by the native query\",\n+                        attrUtil.getType(), subjectId);\n             } else {\n-                result.add(user);\n+                result.add(subject);\n             }\n         }\n \n         return result;\n     }\n \n-    private StringBuilder getQuery(final NodeCond nodeCond, final List<Object> parameters) {\n+    private StringBuilder getQuery(final NodeCond nodeCond, final List<Object> parameters,\n+            final AttributableUtil attrUtil) {\n \n         StringBuilder query = new StringBuilder();\n \n         switch (nodeCond.getType()) {\n \n             case LEAF:\n             case NOT_LEAF:\n-                if (nodeCond.getMembershipCond() != null) {\n+                if (nodeCond.getMembershipCond() != null && AttributableType.USER == attrUtil.getType()) {\n                     query.append(getQuery(nodeCond.getMembershipCond(), nodeCond.getType() == NodeCond.Type.NOT_LEAF,\n-                            parameters));\n+                            parameters, attrUtil));\n                 }\n                 if (nodeCond.getResourceCond() != null) {\n                     query.append(getQuery(nodeCond.getResourceCond(), nodeCond.getType() == NodeCond.Type.NOT_LEAF,\n-                            parameters));\n+                            parameters, attrUtil));\n                 }\n                 if (nodeCond.getAttributeCond() != null) {\n                     query.append(getQuery(nodeCond.getAttributeCond(), nodeCond.getType() == NodeCond.Type.NOT_LEAF,\n-                            parameters));\n+                            parameters, attrUtil));\n                 }\n-                if (nodeCond.getSyncopeUserCond() != null) {\n-                    query.append(getQuery(nodeCond.getSyncopeUserCond(), nodeCond.getType() == NodeCond.Type.NOT_LEAF,\n-                            parameters));\n+                if (nodeCond.getAttributableCond() != null) {\n+                    query.append(getQuery(nodeCond.getAttributableCond(), nodeCond.getType() == NodeCond.Type.NOT_LEAF,\n+                            parameters, attrUtil));\n                 }\n                 break;\n \n             case AND:\n-                query.append(getQuery(nodeCond.getLeftNodeCond(), parameters)).append(\" AND user_id IN ( \").append(\n-                        getQuery(nodeCond.getRightNodeCond(), parameters).append(\")\"));\n+                query.append(getQuery(nodeCond.getLeftNodeCond(), parameters, attrUtil)).\n+                        append(\" AND subject_id IN ( \").\n+                        append(getQuery(nodeCond.getRightNodeCond(), parameters, attrUtil).\n+                        append(\")\"));\n                 break;\n \n             case OR:\n-                query.append(\"(\").append(getQuery(nodeCond.getLeftNodeCond(), parameters)).append(\" UNION \").append(\n-                        getQuery(nodeCond.getRightNodeCond(), parameters).append(\")\"));\n+                query.append(\"(\").\n+                        append(getQuery(nodeCond.getLeftNodeCond(), parameters, attrUtil)).\n+                        append(\" UNION \").\n+                        append(getQuery(nodeCond.getRightNodeCond(), parameters, attrUtil).\n+                        append(\")\"));\n                 break;\n \n             default:\n@@ -303,17 +312,20 @@ private StringBuilder getQuery(final NodeCond nodeCond, final List<Object> param\n         return query;\n     }\n \n-    private String getQuery(final MembershipCond cond, final boolean not, final List<Object> parameters) {\n+    private String getQuery(final MembershipCond cond, final boolean not, final List<Object> parameters,\n+            final AttributableUtil attrUtil) {\n \n-        StringBuilder query = new StringBuilder(\"SELECT DISTINCT user_id FROM user_search WHERE \");\n+        StringBuilder query = new StringBuilder(\"SELECT DISTINCT subject_id FROM \").\n+                append(attrUtil.searchView()).append(\" WHERE \");\n \n         if (not) {\n-            query.append(\"user_id NOT IN (\");\n+            query.append(\"subject_id NOT IN (\");\n         } else {\n-            query.append(\"user_id IN (\");\n+            query.append(\"subject_id IN (\");\n         }\n \n-        query.append(\"SELECT DISTINCT user_id \").append(\"FROM user_search_membership WHERE \");\n+        query.append(\"SELECT DISTINCT subject_id \").append(\"FROM \").\n+                append(attrUtil.searchView()).append(\"_membership WHERE \");\n \n         if (cond.getRoleId() != null) {\n             query.append(\"role_id=?\").append(setParameter(parameters, cond.getRoleId()));\n@@ -326,17 +338,20 @@ private String getQuery(final MembershipCond cond, final boolean not, final List\n         return query.toString();\n     }\n \n-    private String getQuery(final ResourceCond cond, final boolean not, final List<Object> parameters) {\n+    private String getQuery(final ResourceCond cond, final boolean not, final List<Object> parameters,\n+            final AttributableUtil attrUtil) {\n \n-        final StringBuilder query = new StringBuilder(\"SELECT DISTINCT user_id FROM user_search WHERE \");\n+        final StringBuilder query = new StringBuilder(\"SELECT DISTINCT subject_id FROM \").\n+                append(attrUtil.searchView()).append(\" WHERE \");\n \n         if (not) {\n-            query.append(\"user_id NOT IN (\");\n+            query.append(\"subject_id NOT IN (\");\n         } else {\n-            query.append(\"user_id IN (\");\n+            query.append(\"subject_id IN (\");\n         }\n \n-        query.append(\"SELECT DISTINCT user_id \").append(\"FROM user_search_resource WHERE \");\n+        query.append(\"SELECT DISTINCT subject_id \").append(\"FROM \").\n+                append(attrUtil.searchView()).append(\"_resource WHERE \");\n \n         query.append(\"resource_name=?\").append(setParameter(parameters, cond.getResourceName()));\n \n@@ -345,10 +360,10 @@ private String getQuery(final ResourceCond cond, final boolean not, final List<O\n         return query.toString();\n     }\n \n-    private void fillAttributeQuery(final StringBuilder query, final UAttrValue attrValue, final USchema schema,\n-            final AttributeCond cond, final boolean not, final List<Object> parameters) {\n+    private void fillAttributeQuery(final StringBuilder query, final AbstractAttrValue attrValue,\n+            final AbstractSchema schema, final AttributeCond cond, final boolean not, final List<Object> parameters) {\n \n-        String column = (cond instanceof SyncopeUserCond)\n+        String column = (cond instanceof AttributableCond)\n                 ? cond.getSchema()\n                 : \"' AND \" + getFieldName(schema.getType());\n \n@@ -377,7 +392,7 @@ private void fillAttributeQuery(final StringBuilder query, final UAttrValue attr\n                     query.append(\" LIKE '\").append(cond.getExpression()).append(\"'\");\n \n                 } else {\n-                    if (!(cond instanceof SyncopeUserCond)) {\n+                    if (!(cond instanceof AttributableCond)) {\n                         query.append(\"' AND\");\n                     }\n                     query.append(\" 1=2\");\n@@ -471,15 +486,16 @@ private String getFieldName(final SchemaType type) {\n         return result;\n     }\n \n-    private String getQuery(final AttributeCond cond, final boolean not, final List<Object> parameters) {\n+    private String getQuery(final AttributeCond cond, final boolean not, final List<Object> parameters,\n+            AttributableUtil attrUtil) {\n \n-        USchema schema = schemaDAO.find(cond.getSchema(), USchema.class);\n+        AbstractSchema schema = schemaDAO.find(cond.getSchema(), attrUtil.schemaClass());\n         if (schema == null) {\n             LOG.warn(\"Ignoring invalid schema '{}'\", cond.getSchema());\n             return EMPTY_ATTR_QUERY;\n         }\n \n-        UAttrValue attrValue = new UAttrValue();\n+        AbstractAttrValue attrValue = attrUtil.newAttrValue();\n         try {\n             if (cond.getType() != AttributeCond.Type.LIKE && cond.getType() != AttributeCond.Type.ISNULL\n                     && cond.getType() != AttributeCond.Type.ISNOTNULL) {\n@@ -491,21 +507,21 @@ private String getQuery(final AttributeCond cond, final boolean not, final List<\n             return EMPTY_ATTR_QUERY;\n         }\n \n-        StringBuilder query = new StringBuilder(\"SELECT DISTINCT user_id FROM user_search_attr WHERE \").append(\n-                \"schema_name='\").append(schema.getName());\n+        StringBuilder query = new StringBuilder(\"SELECT DISTINCT subject_id FROM \").\n+                append(attrUtil.searchView()).append(\"_attr WHERE \").append(\"schema_name='\").append(schema.getName());\n         fillAttributeQuery(query, attrValue, schema, cond, not, parameters);\n \n         return query.toString();\n     }\n \n-    private String getQuery(final SyncopeUserCond cond, final boolean not, final List<Object> parameters) {\n-\n-        Field syncopeUserClassField = null;\n-        // loop over SyncopeUser class and all superclasses searching for field\n-        for (Class<?> i = SyncopeUser.class; syncopeUserClassField == null && i != Object.class;) {\n+    private String getQuery(final AttributableCond cond, final boolean not, final List<Object> parameters,\n+            final AttributableUtil attrUtil) {\n \n+        Field attributableClassField = null;\n+        // loop over attributable class and all superclasses searching for field\n+        for (Class i = attrUtil.attributableClass(); attributableClassField == null && i != Object.class;) {\n             try {\n-                syncopeUserClassField = i.getDeclaredField(cond.getSchema());\n+                attributableClassField = i.getDeclaredField(cond.getSchema());\n             } catch (Exception ignore) {\n                 // ignore exception\n                 LOG.debug(\"Field '{}' not found on class '{}'\", new String[]{cond.getSchema(), i.getSimpleName()},\n@@ -514,21 +530,20 @@ private String getQuery(final SyncopeUserCond cond, final boolean not, final Lis\n                 i = i.getSuperclass();\n             }\n         }\n-        if (syncopeUserClassField == null) {\n+        if (attributableClassField == null) {\n             LOG.warn(\"Ignoring invalid schema '{}'\", cond.getSchema());\n             return EMPTY_ATTR_QUERY;\n         }\n \n-        USchema schema = new USchema();\n-        schema.setName(syncopeUserClassField.getName());\n+        AbstractSchema schema = attrUtil.newSchema();\n+        schema.setName(attributableClassField.getName());\n         for (SchemaType type : SchemaType.values()) {\n-            if (syncopeUserClassField.getType().getName().equals(type.getClassName())) {\n-\n+            if (attributableClassField.getType().getName().equals(type.getClassName())) {\n                 schema.setType(type);\n             }\n         }\n \n-        UAttrValue attrValue = new UAttrValue();\n+        AbstractAttrValue attrValue = attrUtil.newAttrValue();\n         try {\n             if (cond.getType() != AttributeCond.Type.LIKE && cond.getType() != AttributeCond.Type.ISNULL\n                     && cond.getType() != AttributeCond.Type.ISNOTNULL) {\n@@ -540,7 +555,8 @@ private String getQuery(final SyncopeUserCond cond, final boolean not, final Lis\n             return EMPTY_ATTR_QUERY;\n         }\n \n-        final StringBuilder query = new StringBuilder(\"SELECT DISTINCT user_id FROM user_search WHERE \");\n+        final StringBuilder query = new StringBuilder(\"SELECT DISTINCT subject_id FROM \").\n+                append(attrUtil.searchView()).append(\" WHERE \");\n \n         fillAttributeQuery(query, attrValue, schema, cond, not, parameters);\n ","previous_filename":"core/src/main/java/org/apache/syncope/core/persistence/dao/impl/UserSearchDAOImpl.java"},{"sha":"b475a673b095d7e7087e09ed30f782cbc9a112cd","filename":"core/src/main/java/org/apache/syncope/core/persistence/dao/impl/DerSchemaDAOImpl.java","status":"modified","additions":3,"deletions":6,"changes":9,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2Fimpl%2FDerSchemaDAOImpl.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2Fimpl%2FDerSchemaDAOImpl.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2Fimpl%2FDerSchemaDAOImpl.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -26,6 +26,7 @@\n import org.springframework.stereotype.Repository;\n import org.apache.syncope.core.persistence.beans.AbstractDerAttr;\n import org.apache.syncope.core.persistence.beans.AbstractDerSchema;\n+import org.apache.syncope.core.persistence.beans.user.UMappingItem;\n import org.apache.syncope.core.persistence.dao.DerAttrDAO;\n import org.apache.syncope.core.persistence.dao.DerSchemaDAO;\n import org.apache.syncope.core.persistence.dao.ResourceDAO;\n@@ -60,20 +61,16 @@ public <T extends AbstractDerSchema> T save(final T derivedSchema) {\n \n     @Override\n     public void delete(final String name, final AttributableUtil attributableUtil) {\n-\n         final AbstractDerSchema derivedSchema = find(name, attributableUtil.derSchemaClass());\n-\n         if (derivedSchema == null) {\n             return;\n         }\n \n-        List<? extends AbstractDerAttr> attributes = getAttributes(derivedSchema, attributableUtil\n-                .derAttrClass());\n+        List<? extends AbstractDerAttr> attributes = getAttributes(derivedSchema, attributableUtil.derAttrClass());\n \n         final Set<Long> derivedAttributeIds = new HashSet<Long>(attributes.size());\n \n         Class attributeClass = null;\n-\n         for (AbstractDerAttr attribute : attributes) {\n             derivedAttributeIds.add(attribute.getId());\n             attributeClass = attribute.getClass();\n@@ -83,7 +80,7 @@ public void delete(final String name, final AttributableUtil attributableUtil) {\n             derivedAttributeDAO.delete(derivedAttributeId, attributeClass);\n         }\n \n-        resourceDAO.deleteMappings(name, attributableUtil.derIntMappingType());\n+        resourceDAO.deleteMapping(name, attributableUtil.derIntMappingType(), UMappingItem.class);\n \n         entityManager.remove(derivedSchema);\n     }"},{"sha":"4663cb1b88ae87d18a33a228ce6ae76821661457","filename":"core/src/main/java/org/apache/syncope/core/persistence/dao/impl/PolicyDAOImpl.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2Fimpl%2FPolicyDAOImpl.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2Fimpl%2FPolicyDAOImpl.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2Fimpl%2FPolicyDAOImpl.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -20,13 +20,13 @@\n \n import java.util.List;\n import javax.persistence.Query;\n-import org.springframework.stereotype.Repository;\n import org.apache.syncope.core.persistence.beans.AccountPolicy;\n import org.apache.syncope.core.persistence.beans.PasswordPolicy;\n import org.apache.syncope.core.persistence.beans.Policy;\n import org.apache.syncope.core.persistence.beans.SyncPolicy;\n import org.apache.syncope.core.persistence.dao.PolicyDAO;\n import org.apache.syncope.types.PolicyType;\n+import org.springframework.stereotype.Repository;\n \n @Repository\n public class PolicyDAOImpl extends AbstractDAOImpl implements PolicyDAO {"},{"sha":"5b04ae1c07bd96206a36327346e4c405edb9c230","filename":"core/src/main/java/org/apache/syncope/core/persistence/dao/impl/ResourceDAOImpl.java","status":"modified","additions":47,"deletions":28,"changes":75,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2Fimpl%2FResourceDAOImpl.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2Fimpl%2FResourceDAOImpl.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2Fimpl%2FResourceDAOImpl.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -18,14 +18,17 @@\n  */\n package org.apache.syncope.core.persistence.dao.impl;\n \n+import java.util.EnumSet;\n+import java.util.HashSet;\n import java.util.List;\n+import java.util.Set;\n import javax.persistence.NoResultException;\n import javax.persistence.Query;\n import javax.persistence.TypedQuery;\n import org.apache.syncope.core.init.ConnInstanceLoader;\n+import org.apache.syncope.core.persistence.beans.AbstractMappingItem;\n import org.apache.syncope.core.persistence.beans.ExternalResource;\n import org.apache.syncope.core.persistence.beans.PropagationTask;\n-import org.apache.syncope.core.persistence.beans.SchemaMapping;\n import org.apache.syncope.core.persistence.beans.SyncTask;\n import org.apache.syncope.core.persistence.beans.role.SyncopeRole;\n import org.apache.syncope.core.persistence.beans.user.SyncopeUser;\n@@ -103,41 +106,40 @@ public ExternalResource save(final ExternalResource resource) {\n     }\n \n     @Override\n-    public List<SchemaMapping> findAllMappings() {\n-        Query query = entityManager.createQuery(\"SELECT e FROM \" + SchemaMapping.class.getSimpleName() + \" e\");\n-\n-        return query.getResultList();\n-    }\n-\n-    @Override\n-    public SchemaMapping getMappingForAccountId(final String resourceName) {\n-\n-        Query query = entityManager.createQuery(\"SELECT m FROM \" + SchemaMapping.class.getSimpleName() + \" m \"\n-                + \"WHERE m.resource.name=:resourceName \" + \"AND m.accountid = 1\");\n-        query.setParameter(\"resourceName\", resourceName);\n-\n-        return (SchemaMapping) query.getSingleResult();\n-    }\n-\n-    @Override\n-    public void deleteMappings(final String intAttrName, final IntMappingType intMappingType) {\n-\n-        if (intMappingType == IntMappingType.SyncopeUserId || intMappingType == IntMappingType.Password\n-                || intMappingType == IntMappingType.Username) {\n+    public <T extends AbstractMappingItem> void deleteMapping(final String intAttrName,\n+            final IntMappingType intMappingType, final Class<T> reference) {\n \n+        if (IntMappingType.getEmbedded().contains(intMappingType)) {\n             return;\n         }\n \n-        Query query = entityManager.createQuery(\"DELETE FROM \" + SchemaMapping.class.getSimpleName()\n-                + \" m WHERE m.intAttrName=:intAttrName \" + \"AND m.intMappingType=:intMappingType\");\n+        Query query = entityManager.createQuery(\"SELECT m FROM \" + reference.getSimpleName()\n+                + \" m WHERE m.intAttrName=:intAttrName AND m.intMappingType=:intMappingType\");\n         query.setParameter(\"intAttrName\", intAttrName);\n         query.setParameter(\"intMappingType\", intMappingType);\n \n-        int items = query.executeUpdate();\n-        LOG.debug(\"Removed {} schema mappings\", items);\n+        Set<Long> itemIds = new HashSet<Long>();\n+        for (T item : (List<T>) query.getResultList()) {\n+            itemIds.add(item.getId());\n+        }\n+        Class mappingRef = null;\n+        for (Long itemId : itemIds) {\n+            T item = entityManager.find(reference, itemId);\n+            if (item != null) {\n+                mappingRef = item.getMapping().getClass();\n+\n+                item.getMapping().removeItem(item);\n+                item.setMapping(null);\n+\n+                entityManager.remove(item);\n+            }\n+        }\n \n-        // Make empty SchemaMapping query cache\n-        entityManager.getEntityManagerFactory().getCache().evict(SchemaMapping.class);\n+        // Make empty query cache for *MappingItem and related *Mapping\n+        entityManager.getEntityManagerFactory().getCache().evict(reference);\n+        if (mappingRef != null) {\n+            entityManager.getEntityManagerFactory().getCache().evict(mappingRef);\n+        }\n     }\n \n     @Override\n@@ -164,6 +166,23 @@ public void delete(final String name) {\n         }\n         resource.setConnector(null);\n \n+        if (resource.getUmapping() != null) {\n+            for (AbstractMappingItem item : resource.getUmapping().getItems()) {\n+                item.setMapping(null);\n+            }\n+            resource.getUmapping().getItems().clear();\n+            resource.getUmapping().setResource(null);\n+            resource.setUmapping(null);\n+        }\n+        if (resource.getRmapping() != null) {\n+            for (AbstractMappingItem item : resource.getRmapping().getItems()) {\n+                item.setMapping(null);\n+            }\n+            resource.getRmapping().getItems().clear();\n+            resource.getRmapping().setResource(null);\n+            resource.setRmapping(null);\n+        }\n+\n         entityManager.remove(resource);\n     }\n }"},{"sha":"1d785878d183448abf08660bc005ba335e0cb88e","filename":"core/src/main/java/org/apache/syncope/core/persistence/dao/impl/RoleDAOImpl.java","status":"modified","additions":47,"deletions":19,"changes":66,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2Fimpl%2FRoleDAOImpl.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2Fimpl%2FRoleDAOImpl.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2Fimpl%2FRoleDAOImpl.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -23,20 +23,25 @@\n import javax.persistence.NoResultException;\n import javax.persistence.Query;\n import javax.persistence.TypedQuery;\n+import org.apache.syncope.core.persistence.beans.AbstractVirAttr;\n import org.apache.syncope.core.persistence.beans.Entitlement;\n import org.apache.syncope.core.persistence.beans.ExternalResource;\n import org.apache.syncope.core.persistence.beans.membership.Membership;\n import org.apache.syncope.core.persistence.beans.role.SyncopeRole;\n import org.apache.syncope.core.persistence.beans.user.SyncopeUser;\n+import org.apache.syncope.core.persistence.beans.user.UAttrValue;\n import org.apache.syncope.core.persistence.dao.EntitlementDAO;\n import org.apache.syncope.core.persistence.dao.RoleDAO;\n import org.apache.syncope.core.persistence.dao.UserDAO;\n+import org.apache.syncope.core.rest.controller.InvalidSearchConditionException;\n+import org.apache.syncope.core.util.AttributableUtil;\n import org.apache.syncope.core.util.EntitlementUtil;\n+import org.apache.syncope.types.AttributableType;\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.stereotype.Repository;\n \n @Repository\n-public class RoleDAOImpl extends AbstractDAOImpl implements RoleDAO {\n+public class RoleDAOImpl extends AbstractAttributableDAOImpl implements RoleDAO {\n \n     @Autowired\n     private UserDAO userDAO;\n@@ -129,15 +134,6 @@ public List<SyncopeRole> findByEntitlement(final Entitlement entitlement) {\n         return query.getResultList();\n     }\n \n-    @Override\n-    public List<SyncopeRole> findByResource(final ExternalResource resource) {\n-        Query query = entityManager.createQuery(\"SELECT e FROM \" + SyncopeRole.class.getSimpleName() + \" e \"\n-                + \"WHERE :resource MEMBER OF e.resources\");\n-        query.setParameter(\"resource\", resource);\n-\n-        return query.getResultList();\n-    }\n-\n     private void findAncestors(final List<SyncopeRole> result, final SyncopeRole role) {\n         if (role.getParent() != null && !result.contains(role.getParent())) {\n             result.add(role.getParent());\n@@ -176,6 +172,29 @@ public List<SyncopeRole> findDescendants(final SyncopeRole role) {\n         return result;\n     }\n \n+    @Override\n+    public List<SyncopeRole> findByDerAttrValue(final String schemaName, final String value)\n+            throws InvalidSearchConditionException {\n+\n+        return findByDerAttrValue(schemaName, value, AttributableUtil.getInstance(AttributableType.ROLE));\n+    }\n+\n+    @Override\n+    public List<SyncopeRole> findByAttrValue(final String schemaName, final UAttrValue attrValue) {\n+        return findByAttrValue(schemaName, attrValue, AttributableUtil.getInstance(AttributableType.ROLE));\n+    }\n+\n+    @Override\n+    public SyncopeRole findByAttrUniqueValue(final String schemaName, final UAttrValue attrUniqueValue) {\n+        return (SyncopeRole) findByAttrUniqueValue(schemaName, attrUniqueValue,\n+                AttributableUtil.getInstance(AttributableType.ROLE));\n+    }\n+\n+    @Override\n+    public List<SyncopeRole> findByResource(final ExternalResource resource) {\n+        return findByResource(resource, SyncopeRole.class);\n+    }\n+\n     @Override\n     public List<SyncopeRole> findAll() {\n         Query query = entityManager.createQuery(\"SELECT e FROM SyncopeRole e\");\n@@ -203,19 +222,18 @@ public SyncopeRole save(final SyncopeRole role) {\n             role.setPasswordPolicy(null);\n         }\n \n-        final SyncopeRole savedRole = entityManager.merge(role);\n-        entitlementDAO.saveEntitlementRole(savedRole);\n+        final SyncopeRole merged = entityManager.merge(role);\n+        for (AbstractVirAttr virtual : merged.getVirtualAttributes()) {\n+            virtual.setValues(role.getVirtualAttribute(virtual.getVirtualSchema().getName()).getValues());\n+        }\n \n-        return savedRole;\n+        entitlementDAO.saveEntitlementRole(merged);\n+\n+        return merged;\n     }\n \n     @Override\n-    public void delete(final Long id) {\n-        SyncopeRole role = find(id);\n-        if (role == null) {\n-            return;\n-        }\n-\n+    public void delete(final SyncopeRole role) {\n         for (SyncopeRole roleToBeDeleted : findDescendants(role)) {\n             for (Membership membership : findMemberships(roleToBeDeleted)) {\n                 membership.getSyncopeUser().removeMembership(membership);\n@@ -234,4 +252,14 @@ public void delete(final Long id) {\n             entitlementDAO.delete(EntitlementUtil.getEntitlementNameFromRoleId(roleToBeDeleted.getId()));\n         }\n     }\n+\n+    @Override\n+    public void delete(final Long id) {\n+        SyncopeRole role = find(id);\n+        if (role == null) {\n+            return;\n+        }\n+\n+        delete(role);\n+    }\n }"},{"sha":"489fc0cc1ada20f2e207130b83b0e08a7e911bcd","filename":"core/src/main/java/org/apache/syncope/core/persistence/dao/impl/SchemaDAOImpl.java","status":"modified","additions":4,"deletions":4,"changes":8,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2Fimpl%2FSchemaDAOImpl.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2Fimpl%2FSchemaDAOImpl.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2Fimpl%2FSchemaDAOImpl.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -22,14 +22,15 @@\n import java.util.List;\n import java.util.Set;\n import javax.persistence.Query;\n-import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.stereotype.Repository;\n import org.apache.syncope.core.persistence.beans.AbstractAttr;\n import org.apache.syncope.core.persistence.beans.AbstractSchema;\n+import org.apache.syncope.core.persistence.beans.user.UMappingItem;\n import org.apache.syncope.core.persistence.dao.AttrDAO;\n import org.apache.syncope.core.persistence.dao.ResourceDAO;\n import org.apache.syncope.core.persistence.dao.SchemaDAO;\n import org.apache.syncope.core.util.AttributableUtil;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Repository;\n \n @Repository\n public class SchemaDAOImpl extends AbstractDAOImpl implements SchemaDAO {\n@@ -71,7 +72,6 @@ public <T extends AbstractSchema> T save(final T schema) {\n \n     @Override\n     public void delete(final String name, final AttributableUtil attributableUtil) {\n-\n         AbstractSchema schema = find(name, attributableUtil.schemaClass());\n         if (schema == null) {\n             return;\n@@ -87,7 +87,7 @@ public void delete(final String name, final AttributableUtil attributableUtil) {\n             attributeDAO.delete(attributeId, attributableUtil.attrClass());\n         }\n \n-        resourceDAO.deleteMappings(name, attributableUtil.intMappingType());\n+        resourceDAO.deleteMapping(name, attributableUtil.intMappingType(), UMappingItem.class);\n \n         entityManager.remove(schema);\n     }"},{"sha":"e7b9f8f855c34d5290fd9730f1654477268bc607","filename":"core/src/main/java/org/apache/syncope/core/persistence/dao/impl/TaskDAOImpl.java","status":"modified","additions":0,"deletions":30,"changes":30,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2Fimpl%2FTaskDAOImpl.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2Fimpl%2FTaskDAOImpl.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2Fimpl%2FTaskDAOImpl.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -23,11 +23,9 @@\n import javax.persistence.Query;\n import org.apache.syncope.core.persistence.beans.ExternalResource;\n import org.apache.syncope.core.persistence.beans.NotificationTask;\n-import org.apache.syncope.core.persistence.beans.PropagationTask;\n import org.apache.syncope.core.persistence.beans.SchedTask;\n import org.apache.syncope.core.persistence.beans.SyncTask;\n import org.apache.syncope.core.persistence.beans.Task;\n-import org.apache.syncope.core.persistence.beans.user.SyncopeUser;\n import org.apache.syncope.core.persistence.dao.TaskDAO;\n import org.springframework.stereotype.Repository;\n import org.springframework.transaction.annotation.Transactional;\n@@ -116,34 +114,6 @@ public <T extends Task> List<T> findAll(final int page, final int itemsPerPage,\n         return query.getResultList();\n     }\n \n-    @Override\n-    public List<PropagationTask> findAll(final SyncopeUser user) {\n-        StringBuilder queryString = buildfindAllQuery(PropagationTask.class);\n-\n-        queryString.append(\"WHERE e.syncopeUser=:user \");\n-        queryString.append(\"ORDER BY e.id DESC\");\n-\n-        final Query query = entityManager.createQuery(queryString.toString());\n-        query.setParameter(\"user\", user);\n-\n-        return query.getResultList();\n-    }\n-\n-    @Override\n-    public List<PropagationTask> findAll(final ExternalResource resource, final SyncopeUser user) {\n-\n-        StringBuilder queryString = buildfindAllQuery(PropagationTask.class);\n-        queryString.append(\"WHERE e.syncopeUser=:user \");\n-        queryString.append(\"AND e.resource=:resource \");\n-        queryString.append(\"ORDER BY e.id DESC\");\n-\n-        final Query query = entityManager.createQuery(queryString.toString());\n-        query.setParameter(\"user\", user);\n-        query.setParameter(\"resource\", resource);\n-\n-        return query.getResultList();\n-    }\n-\n     @Override\n     public <T extends Task> int count(final Class<T> reference) {\n         Query countQuery = entityManager.createNativeQuery(\"SELECT COUNT(id) FROM Task WHERE DTYPE=?1\");"},{"sha":"325d0fff52e404d24afc1ad7f883076578044762","filename":"core/src/main/java/org/apache/syncope/core/persistence/dao/impl/UserDAOImpl.java","status":"modified","additions":11,"deletions":303,"changes":314,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2Fimpl%2FUserDAOImpl.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2Fimpl%2FUserDAOImpl.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2Fimpl%2FUserDAOImpl.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -18,56 +18,31 @@\n  */\n package org.apache.syncope.core.persistence.dao.impl;\n \n-import java.io.StringReader;\n import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.Comparator;\n-import java.util.HashSet;\n import java.util.List;\n import java.util.Set;\n-import java.util.regex.Pattern;\n import javax.persistence.NoResultException;\n import javax.persistence.Query;\n-import javax.persistence.TemporalType;\n import javax.persistence.TypedQuery;\n-import org.apache.commons.jexl2.parser.Parser;\n-import org.apache.commons.jexl2.parser.ParserConstants;\n-import org.apache.commons.jexl2.parser.Token;\n-import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.stereotype.Repository;\n-import org.springframework.util.StringUtils;\n-import org.apache.syncope.core.persistence.beans.AbstractAttrValue;\n import org.apache.syncope.core.persistence.beans.AbstractVirAttr;\n import org.apache.syncope.core.persistence.beans.ExternalResource;\n-import org.apache.syncope.core.persistence.beans.PropagationTask;\n import org.apache.syncope.core.persistence.beans.membership.Membership;\n import org.apache.syncope.core.persistence.beans.user.SyncopeUser;\n-import org.apache.syncope.core.persistence.beans.user.UAttrUniqueValue;\n import org.apache.syncope.core.persistence.beans.user.UAttrValue;\n-import org.apache.syncope.core.persistence.beans.user.UDerSchema;\n-import org.apache.syncope.core.persistence.beans.user.USchema;\n-import org.apache.syncope.core.persistence.dao.DerSchemaDAO;\n import org.apache.syncope.core.persistence.dao.RoleDAO;\n-import org.apache.syncope.core.persistence.dao.SchemaDAO;\n-import org.apache.syncope.core.persistence.dao.TaskDAO;\n import org.apache.syncope.core.persistence.dao.UserDAO;\n import org.apache.syncope.core.rest.controller.InvalidSearchConditionException;\n+import org.apache.syncope.core.util.AttributableUtil;\n+import org.apache.syncope.types.AttributableType;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Repository;\n \n @Repository\n-public class UserDAOImpl extends AbstractDAOImpl implements UserDAO {\n-\n-    @Autowired\n-    private SchemaDAO schemaDAO;\n-\n-    @Autowired\n-    private DerSchemaDAO derSchemaDAO;\n+public class UserDAOImpl extends AbstractAttributableDAOImpl implements UserDAO {\n \n     @Autowired\n     private RoleDAO roleDAO;\n \n-    @Autowired\n-    private TaskDAO taskDAO;\n-\n     @Override\n     public SyncopeUser find(final Long id) {\n         TypedQuery<SyncopeUser> query = entityManager.createQuery(\"SELECT e FROM \" + SyncopeUser.class.getSimpleName()\n@@ -107,135 +82,27 @@ public SyncopeUser findByWorkflowId(final String workflowId) {\n         return query.getSingleResult();\n     }\n \n-    /**\n-     * Find users by derived attribute value. This method could fail if one or more string literals contained into the\n-     * derived attribute value provided derive from identifier (schema name) replacement. When you are going to specify\n-     * a derived attribute expression you must be quite sure that string literals used to build the expression cannot be\n-     * found into the attribute values used to replace attribute schema names used as identifiers.\n-     *\n-     * @param schemaName derived schema name.\n-     * @param value derived attribute value.\n-     * @return list of users.\n-     * @throws InvalidSearchConditionException in case of errors retrieving schema names used to buid the derived schema\n-     * expression.\n-     */\n     @Override\n     public List<SyncopeUser> findByDerAttrValue(final String schemaName, final String value)\n             throws InvalidSearchConditionException {\n \n-        UDerSchema schema = derSchemaDAO.find(schemaName, UDerSchema.class);\n-        if (schema == null) {\n-            LOG.error(\"Invalid schema name '{}'\", schemaName);\n-            return Collections.emptyList();\n-        }\n-\n-        // query string\n-        final StringBuilder querystring = new StringBuilder();\n-\n-        boolean subquery = false;\n-        for (String clause : getWhereClause(schema.getExpression(), value)) {\n-            if (querystring.length() > 0) {\n-                subquery = true;\n-                querystring.append(\" AND a.owner_id IN ( \");\n-            }\n-\n-            querystring.append(\"SELECT a.owner_id \").append(\"FROM UAttr a, UAttrValue v, USchema s \").append(\"WHERE \")\n-                    .append(clause);\n-\n-            if (subquery) {\n-                querystring.append(')');\n-            }\n-        }\n-\n-        LOG.debug(\"Execute query {}\", querystring);\n-\n-        final Query query = entityManager.createNativeQuery(querystring.toString());\n-\n-        final List<SyncopeUser> result = new ArrayList<SyncopeUser>();\n-\n-        SyncopeUser user;\n-        for (Object userId : query.getResultList()) {\n-            user = find(Long.parseLong(userId.toString()));\n-            if (!result.contains(user)) {\n-                result.add(user);\n-            }\n-        }\n-\n-        return result;\n+        return findByDerAttrValue(schemaName, value, AttributableUtil.getInstance(AttributableType.USER));\n     }\n \n     @Override\n     public List<SyncopeUser> findByAttrValue(final String schemaName, final UAttrValue attrValue) {\n-\n-        USchema schema = schemaDAO.find(schemaName, USchema.class);\n-        if (schema == null) {\n-            LOG.error(\"Invalid schema name '{}'\", schemaName);\n-            return Collections.emptyList();\n-        }\n-\n-        final String entityName = schema.isUniqueConstraint()\n-                ? UAttrUniqueValue.class.getName()\n-                : UAttrValue.class.getName();\n-\n-        Query query = entityManager.createQuery(\"SELECT e FROM \" + entityName + \" e\"\n-                + \" WHERE e.attribute.schema.name = :schemaName \" + \" AND (e.stringValue IS NOT NULL\"\n-                + \" AND e.stringValue = :stringValue)\" + \" OR (e.booleanValue IS NOT NULL\"\n-                + \" AND e.booleanValue = :booleanValue)\" + \" OR (e.dateValue IS NOT NULL\"\n-                + \" AND e.dateValue = :dateValue)\" + \" OR (e.longValue IS NOT NULL\" + \" AND e.longValue = :longValue)\"\n-                + \" OR (e.doubleValue IS NOT NULL\" + \" AND e.doubleValue = :doubleValue)\");\n-\n-        query.setParameter(\"schemaName\", schemaName);\n-        query.setParameter(\"stringValue\", attrValue.getStringValue());\n-        query.setParameter(\"booleanValue\", attrValue.getBooleanValue() == null\n-                ? null\n-                : attrValue.getBooleanAsInteger(attrValue.getBooleanValue()));\n-        if (attrValue.getDateValue() != null) {\n-            query.setParameter(\"dateValue\", attrValue.getDateValue(), TemporalType.TIMESTAMP);\n-        } else {\n-            query.setParameter(\"dateValue\", null);\n-        }\n-        query.setParameter(\"longValue\", attrValue.getLongValue());\n-        query.setParameter(\"doubleValue\", attrValue.getDoubleValue());\n-\n-        List<SyncopeUser> result = new ArrayList<SyncopeUser>();\n-        SyncopeUser user;\n-        for (AbstractAttrValue value : (List<AbstractAttrValue>) query.getResultList()) {\n-\n-            user = (SyncopeUser) value.getAttribute().getOwner();\n-            if (!result.contains(user)) {\n-                result.add(user);\n-            }\n-        }\n-\n-        return result;\n+        return findByAttrValue(schemaName, attrValue, AttributableUtil.getInstance(AttributableType.USER));\n     }\n \n     @Override\n     public SyncopeUser findByAttrUniqueValue(final String schemaName, final UAttrValue attrUniqueValue) {\n-\n-        USchema schema = schemaDAO.find(schemaName, USchema.class);\n-        if (schema == null) {\n-            LOG.error(\"Invalid schema name '{}'\", schemaName);\n-            return null;\n-        }\n-        if (!schema.isUniqueConstraint()) {\n-            LOG.error(\"This schema has not unique constraint: '{}'\", schemaName);\n-            return null;\n-        }\n-\n-        List<SyncopeUser> result = findByAttrValue(schemaName, attrUniqueValue);\n-        return result.isEmpty()\n-                ? null\n-                : result.iterator().next();\n+        return (SyncopeUser) findByAttrUniqueValue(schemaName, attrUniqueValue,\n+                AttributableUtil.getInstance(AttributableType.USER));\n     }\n \n     @Override\n     public List<SyncopeUser> findByResource(final ExternalResource resource) {\n-        Query query = entityManager.createQuery(\"SELECT e FROM \" + SyncopeUser.class.getSimpleName() + \" e \"\n-                + \"WHERE :resource MEMBER OF e.resources\");\n-        query.setParameter(\"resource\", resource);\n-\n-        return query.getResultList();\n+        return findByResource(resource, SyncopeUser.class);\n     }\n \n     private StringBuilder getFindAllQuery(final Set<Long> adminRoles) {\n@@ -275,7 +142,6 @@ public final List<SyncopeUser> findAll(final Set<Long> adminRoles) {\n \n     @Override\n     public final List<SyncopeUser> findAll(final Set<Long> adminRoles, final int page, final int itemsPerPage) {\n-\n         final Query query = entityManager.createNativeQuery(getFindAllQuery(adminRoles).toString());\n \n         query.setFirstResult(itemsPerPage * (page <= 0\n@@ -328,8 +194,7 @@ public final int count(final Set<Long> adminRoles) {\n \n     @Override\n     public SyncopeUser save(final SyncopeUser user) {\n-        SyncopeUser merged = entityManager.merge(user);\n-\n+        final SyncopeUser merged = entityManager.merge(user);\n         for (AbstractVirAttr virtual : merged.getVirtualAttributes()) {\n             virtual.setValues(user.getVirtualAttribute(virtual.getVirtualSchema().getName()).getValues());\n         }\n@@ -362,163 +227,6 @@ public void delete(final SyncopeUser user) {\n         }\n         user.getMemberships().clear();\n \n-        for (PropagationTask task : taskDAO.findAll(user)) {\n-            task.setSyncopeUser(null);\n-        }\n-\n         entityManager.remove(user);\n     }\n-\n-    /**\n-     * Generate one where clause for each different attribute schema into the derived schema expression provided.\n-     *\n-     * @param expression derived schema expression.\n-     * @param value derived attribute value.\n-     * @return where clauses to use to build the query.\n-     * @throws InvalidSearchConditionException in case of errors retrieving identifiers.\n-     */\n-    private Set<String> getWhereClause(final String expression, final String value)\n-            throws InvalidSearchConditionException {\n-        final Parser parser = new Parser(new StringReader(expression));\n-\n-        // Schema names\n-        final List<String> identifiers = new ArrayList<String>();\n-\n-        // Literals\n-        final List<String> literals = new ArrayList<String>();\n-\n-        // Get schema names and literals\n-        Token token;\n-        while ((token = parser.getNextToken()) != null && StringUtils.hasText(token.toString())) {\n-\n-            if (token.kind == ParserConstants.STRING_LITERAL) {\n-                literals.add(token.toString().substring(1, token.toString().length() - 1));\n-            }\n-\n-            if (token.kind == ParserConstants.IDENTIFIER) {\n-                identifiers.add(token.toString());\n-            }\n-        }\n-\n-        // Sort literals in order to process later literals included into others\n-        Collections.sort(literals, new Comparator<String>() {\n-\n-            @Override\n-            public int compare(String t, String t1) {\n-                if (t == null && t1 == null) {\n-                    return 0;\n-                } else if (t != null && t1 == null) {\n-                    return -1;\n-                } else if (t == null && t1 != null) {\n-                    return 1;\n-                } else if (t.length() == t1.length()) {\n-                    return 0;\n-                } else if (t.length() > t1.length()) {\n-                    return -1;\n-                } else {\n-                    return 1;\n-                }\n-            }\n-        });\n-\n-        // Split value on provided literals\n-        final List<String> attrValues = split(value, literals);\n-\n-        if (attrValues.size() != identifiers.size()) {\n-            LOG.error(\"Ambiguous jexl expression resolution.\");\n-            throw new InvalidSearchConditionException(\"literals and values have different size\");\n-        }\n-\n-        // clauses to be used with INTERSECTed queries\n-        final Set<String> clauses = new HashSet<String>();\n-\n-        // builder to build the clauses\n-        final StringBuilder bld = new StringBuilder();\n-\n-        // Contains used identifiers in order to avoid replications\n-        final Set<String> used = new HashSet<String>();\n-\n-        USchema schema;\n-\n-        // Create several clauses: one for eanch identifiers\n-        for (int i = 0; i < identifiers.size(); i++) {\n-            if (!used.contains(identifiers.get(i))) {\n-\n-                // verify schema existence and get schema type\n-                schema = schemaDAO.find(identifiers.get(i), USchema.class);\n-                if (schema == null) {\n-                    LOG.error(\"Invalid schema name '{}'\", identifiers.get(i));\n-                    throw new InvalidSearchConditionException(\"Invalid schema name \" + identifiers.get(i));\n-                }\n-\n-                // clear builder\n-                bld.delete(0, bld.length());\n-\n-                bld.append(\"(\");\n-\n-                // set schema name\n-                bld.append(\"s.name = '\").append(identifiers.get(i)).append(\"'\");\n-\n-                bld.append(\" AND \");\n-\n-                bld.append(\"s.name = a.schema_name\").append(\" AND \");\n-\n-                bld.append(\"a.id = v.attribute_id\");\n-\n-                bld.append(\" AND \");\n-\n-                // use a value clause different for eanch different schema type\n-                switch (schema.getType()) {\n-                    case Boolean:\n-                        bld.append(\"v.booleanValue = '\").append(attrValues.get(i)).append(\"'\");\n-                        break;\n-                    case Long:\n-                        bld.append(\"v.longValue = \").append(attrValues.get(i));\n-                        break;\n-                    case Double:\n-                        bld.append(\"v.doubleValue = \").append(attrValues.get(i));\n-                        break;\n-                    case Date:\n-                        bld.append(\"v.dateValue = '\").append(attrValues.get(i)).append(\"'\");\n-                        break;\n-                    default:\n-                        bld.append(\"v.stringValue = '\").append(attrValues.get(i)).append(\"'\");\n-                }\n-\n-                bld.append(\")\");\n-\n-                used.add(identifiers.get(i));\n-\n-                clauses.add(bld.toString());\n-            }\n-        }\n-\n-        LOG.debug(\"Generated where clauses {}\", clauses);\n-\n-        return clauses;\n-    }\n-\n-    /**\n-     * Split an attribute value recurring on provided literals/tokens.\n-     *\n-     * @param attrValue value to be split.\n-     * @param literals literals/tokens.\n-     * @return\n-     */\n-    private List<String> split(final String attrValue, final List<String> literals) {\n-\n-        final List<String> attrValues = new ArrayList<String>();\n-\n-        if (literals.isEmpty()) {\n-            attrValues.add(attrValue);\n-        } else {\n-\n-            for (String token : attrValue.split(Pattern.quote(literals.get(0)))) {\n-\n-                attrValues.addAll(split(token, literals.subList(1, literals.size())));\n-            }\n-        }\n-\n-        return attrValues;\n-    }\n }"},{"sha":"81cde0c042ee30abe3ff34d03bd55149a69a7f8e","filename":"core/src/main/java/org/apache/syncope/core/persistence/dao/impl/VirSchemaDAOImpl.java","status":"modified","additions":4,"deletions":6,"changes":10,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2Fimpl%2FVirSchemaDAOImpl.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2Fimpl%2FVirSchemaDAOImpl.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2Fimpl%2FVirSchemaDAOImpl.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -22,14 +22,15 @@\n import java.util.List;\n import java.util.Set;\n import javax.persistence.Query;\n-import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.stereotype.Repository;\n import org.apache.syncope.core.persistence.beans.AbstractVirAttr;\n import org.apache.syncope.core.persistence.beans.AbstractVirSchema;\n+import org.apache.syncope.core.persistence.beans.user.UMappingItem;\n import org.apache.syncope.core.persistence.dao.ResourceDAO;\n import org.apache.syncope.core.persistence.dao.VirAttrDAO;\n import org.apache.syncope.core.persistence.dao.VirSchemaDAO;\n import org.apache.syncope.core.util.AttributableUtil;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Repository;\n \n @Repository\n public class VirSchemaDAOImpl extends AbstractDAOImpl implements VirSchemaDAO {\n@@ -42,13 +43,11 @@ public class VirSchemaDAOImpl extends AbstractDAOImpl implements VirSchemaDAO {\n \n     @Override\n     public <T extends AbstractVirSchema> T find(final String name, final Class<T> reference) {\n-\n         return entityManager.find(reference, name);\n     }\n \n     @Override\n     public <T extends AbstractVirSchema> List<T> findAll(final Class<T> reference) {\n-\n         Query query = entityManager.createQuery(\"SELECT e FROM \" + reference.getSimpleName() + \" e\");\n         return query.getResultList();\n     }\n@@ -60,7 +59,6 @@ public <T extends AbstractVirSchema> T save(final T virtualSchema) {\n \n     @Override\n     public void delete(final String name, final AttributableUtil attributableUtil) {\n-\n         final AbstractVirSchema virtualSchema = find(name, attributableUtil.virSchemaClass());\n \n         if (virtualSchema == null) {\n@@ -82,7 +80,7 @@ public void delete(final String name, final AttributableUtil attributableUtil) {\n             virtualAttributeDAO.delete(virtualAttributeId, attributeClass);\n         }\n \n-        resourceDAO.deleteMappings(name, attributableUtil.virIntMappingType());\n+        resourceDAO.deleteMapping(name, attributableUtil.virIntMappingType(), UMappingItem.class);\n \n         entityManager.remove(virtualSchema);\n     }"},{"sha":"0b9abd016428af1d6f7dfa000369d5f93486aadc","filename":"core/src/main/java/org/apache/syncope/core/persistence/validation/entity/ExternalResourceValidator.java","status":"modified","additions":70,"deletions":39,"changes":109,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fvalidation%2Fentity%2FExternalResourceValidator.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fvalidation%2Fentity%2FExternalResourceValidator.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fvalidation%2Fentity%2FExternalResourceValidator.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -21,8 +21,9 @@\n import javax.validation.ConstraintValidator;\n import javax.validation.ConstraintValidatorContext;\n import org.apache.commons.lang.StringUtils;\n+import org.apache.syncope.core.persistence.beans.AbstractMapping;\n+import org.apache.syncope.core.persistence.beans.AbstractMappingItem;\n import org.apache.syncope.core.persistence.beans.ExternalResource;\n-import org.apache.syncope.core.persistence.beans.SchemaMapping;\n import org.apache.syncope.core.propagation.PropagationActions;\n import org.apache.syncope.types.EntityViolationType;\n \n@@ -33,51 +34,81 @@ public class ExternalResourceValidator extends AbstractValidator implements\n     public void initialize(final ExternalResourceCheck constraintAnnotation) {\n     }\n \n-    @Override\n-    public boolean isValid(final ExternalResource object, final ConstraintValidatorContext context) {\n-\n-        boolean isValid;\n-\n-        if (object == null) {\n-            isValid = true;\n-        } else {\n-            int accountIds = 0;\n-            for (SchemaMapping mapping : object.getMappings()) {\n-                if (mapping.isAccountid()) {\n-                    accountIds++;\n-                }\n-            }\n-            isValid = accountIds == 1;\n+    private boolean isValid(final AbstractMappingItem item, final ConstraintValidatorContext context) {\n+        if (StringUtils.isBlank(item.getExtAttrName())) {\n+            context.buildConstraintViolationWithTemplate(EntityViolationType.InvalidMapping.toString())\n+                    .addNode(item + \".extAttrName is null\").addConstraintViolation();\n \n-            if (!isValid) {\n-                LOG.error(\"Mappings for \" + object + \" have 0 or >1 account ids\");\n+            return false;\n+        }\n \n-                context.disableDefaultConstraintViolation();\n-                context.buildConstraintViolationWithTemplate(EntityViolationType.InvalidResource.toString())\n-                        .addNode(object + \".accountIds.size==\" + accountIds).addConstraintViolation();\n+        if (StringUtils.isBlank(item.getIntAttrName())) {\n+            context.buildConstraintViolationWithTemplate(EntityViolationType.InvalidMapping.toString())\n+                    .addNode(item + \".intAttrName is null\").addConstraintViolation();\n+\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    private boolean isValid(final AbstractMapping mapping, final ConstraintValidatorContext context) {\n+        if (mapping == null) {\n+            return true;\n+        }\n+\n+        int accountIds = 0;\n+        for (AbstractMappingItem item : mapping.getItems()) {\n+            if (item.isAccountid()) {\n+                accountIds++;\n             }\n+        }\n+        if (accountIds != 1) {\n+            context.buildConstraintViolationWithTemplate(EntityViolationType.InvalidMapping.toString())\n+                    .addNode(mapping + \".accountId.size==\" + accountIds).addConstraintViolation();\n+            return false;\n+        }\n \n-            if (StringUtils.isNotBlank(object.getActionsClassName())) {\n-                Class<?> actionsClass = null;\n-                boolean isAssignable = false;\n-                try {\n-                    actionsClass = Class.forName(object.getActionsClassName());\n-                    isAssignable = PropagationActions.class.isAssignableFrom(actionsClass);\n-                } catch (Exception e) {\n-                    LOG.error(\"Invalid PropagationActions specified\", e);\n-                    isValid = false;\n-                }\n-\n-                if (actionsClass == null || !isAssignable) {\n-                    isValid = false;\n-\n-                    context.disableDefaultConstraintViolation();\n-                    context.buildConstraintViolationWithTemplate(EntityViolationType.InvalidResource.toString())\n-                            .addNode(object + \".actionsClassName is not valid\").addConstraintViolation();\n-                }\n+        boolean isValid = true;\n+\n+        int passwords = 0;\n+        for (AbstractMappingItem item : mapping.getItems()) {\n+            isValid &= isValid(item, context);\n+\n+            if (item.isPassword()) {\n+                passwords++;\n             }\n         }\n+        if (passwords > 1) {\n+            context.buildConstraintViolationWithTemplate(EntityViolationType.InvalidMapping.toString())\n+                    .addNode(mapping + \".password.size==\" + passwords).addConstraintViolation();\n+            isValid = false;\n+        }\n \n         return isValid;\n     }\n+\n+    @Override\n+    public boolean isValid(final ExternalResource resource, final ConstraintValidatorContext context) {\n+        context.disableDefaultConstraintViolation();\n+\n+        if (StringUtils.isNotBlank(resource.getPropagationActionsClassName())) {\n+            Class<?> actionsClass = null;\n+            boolean isAssignable = false;\n+            try {\n+                actionsClass = Class.forName(resource.getPropagationActionsClassName());\n+                isAssignable = PropagationActions.class.isAssignableFrom(actionsClass);\n+            } catch (Exception e) {\n+                LOG.error(\"Invalid PropagationActions specified: {}\", resource.getPropagationActionsClassName(), e);\n+            }\n+\n+            if (actionsClass == null || !isAssignable) {\n+                context.buildConstraintViolationWithTemplate(EntityViolationType.InvalidResource.toString())\n+                        .addNode(resource + \".actionsClassName is not valid\").addConstraintViolation();\n+                return false;\n+            }\n+        }\n+\n+        return isValid(resource.getUmapping(), context) && isValid(resource.getRmapping(), context);\n+    }\n }"},{"sha":"8acba22e12a6df2510163fd97e8bb35969ddd5da","filename":"core/src/main/java/org/apache/syncope/core/persistence/validation/entity/InvalidEntityException.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fvalidation%2Fentity%2FInvalidEntityException.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fvalidation%2Fentity%2FInvalidEntityException.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fvalidation%2Fentity%2FInvalidEntityException.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -34,7 +34,8 @@ public class InvalidEntityException extends ValidationException {\n \n     private final Map<Class, Set<EntityViolationType>> violations;\n \n-    public InvalidEntityException(final String entityClassSimpleName, final Set<ConstraintViolation<Object>> violations) {\n+    public InvalidEntityException(final String entityClassSimpleName,\n+            final Set<ConstraintViolation<Object>> violations) {\n \n         super();\n \n@@ -51,7 +52,6 @@ public InvalidEntityException(final String entityClassSimpleName, final Set<Cons\n             }\n \n             if (!this.violations.containsKey(violation.getLeafBean().getClass())) {\n-\n                 this.violations.put(violation.getLeafBean().getClass(), EnumSet.noneOf(EntityViolationType.class));\n             }\n "},{"sha":"79fae8f5ddced44b6ce073dff0c3f387da8c6e42","filename":"core/src/main/java/org/apache/syncope/core/persistence/validation/entity/PropagationTaskValidator.java","status":"modified","additions":7,"deletions":7,"changes":14,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fvalidation%2Fentity%2FPropagationTaskValidator.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fvalidation%2Fentity%2FPropagationTaskValidator.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fvalidation%2Fentity%2FPropagationTaskValidator.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -34,20 +34,20 @@ public void initialize(final PropagationTaskCheck constraintAnnotation) {\n     }\n \n     @Override\n-    public boolean isValid(final PropagationTask object, final ConstraintValidatorContext context) {\n+    public boolean isValid(final PropagationTask task, final ConstraintValidatorContext context) {\n \n         boolean isValid;\n \n-        if (object == null) {\n+        if (task == null) {\n             isValid = true;\n         } else {\n-            isValid = object.getPropagationMode() != null\n-                    && object.getPropagationOperation() != null\n-                    && !object.getAttributes().isEmpty()\n-                    && object.getResource() != null;\n+            isValid = task.getPropagationMode() != null\n+                    && task.getPropagationOperation() != null\n+                    && !task.getAttributes().isEmpty()\n+                    && task.getResource() != null;\n \n             if (isValid) {\n-                List<TaskExec> executions = object.getExecs();\n+                List<TaskExec> executions = task.getExecs();\n                 for (TaskExec execution : executions) {\n                     try {\n                         PropagationTaskExecStatus.valueOf(execution.getStatus());"},{"sha":"94d61b87378dda359e067170026a551bea8a40c3","filename":"core/src/main/java/org/apache/syncope/core/persistence/validation/entity/SchemaMappingCheck.java","status":"removed","additions":0,"deletions":40,"changes":40,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/8fcd0ace968e4cb7b5c8b98066414c6b62a9ba81/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fvalidation%2Fentity%2FSchemaMappingCheck.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/8fcd0ace968e4cb7b5c8b98066414c6b62a9ba81/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fvalidation%2Fentity%2FSchemaMappingCheck.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fvalidation%2Fentity%2FSchemaMappingCheck.java?ref=8fcd0ace968e4cb7b5c8b98066414c6b62a9ba81","patch":"@@ -1,40 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-package org.apache.syncope.core.persistence.validation.entity;\n-\n-import java.lang.annotation.Documented;\n-import java.lang.annotation.ElementType;\n-import java.lang.annotation.Retention;\n-import java.lang.annotation.RetentionPolicy;\n-import java.lang.annotation.Target;\n-import javax.validation.Constraint;\n-import javax.validation.Payload;\n-\n-@Target( { ElementType.TYPE })\n-@Retention(RetentionPolicy.RUNTIME)\n-@Constraint(validatedBy = SchemaMappingValidator.class)\n-@Documented\n-public @interface SchemaMappingCheck {\n-\n-    String message() default \"{org.apache.syncope.core.validation.mapping}\";\n-\n-    Class<?>[] groups() default {};\n-\n-    Class<? extends Payload>[] payload() default {};\n-}"},{"sha":"162925e010ad2131a808a013962d623daf359068","filename":"core/src/main/java/org/apache/syncope/core/persistence/validation/entity/SchemaMappingValidator.java","status":"removed","additions":0,"deletions":75,"changes":75,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/8fcd0ace968e4cb7b5c8b98066414c6b62a9ba81/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fvalidation%2Fentity%2FSchemaMappingValidator.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/8fcd0ace968e4cb7b5c8b98066414c6b62a9ba81/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fvalidation%2Fentity%2FSchemaMappingValidator.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fvalidation%2Fentity%2FSchemaMappingValidator.java?ref=8fcd0ace968e4cb7b5c8b98066414c6b62a9ba81","patch":"@@ -1,75 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-package org.apache.syncope.core.persistence.validation.entity;\n-\n-import javax.validation.ConstraintValidator;\n-import javax.validation.ConstraintValidatorContext;\n-import org.apache.commons.lang.StringUtils;\n-import org.apache.syncope.core.persistence.beans.SchemaMapping;\n-import org.apache.syncope.core.util.SchemaMappingUtil;\n-import org.apache.syncope.types.EntityViolationType;\n-import org.apache.syncope.types.IntMappingType;\n-\n-public class SchemaMappingValidator extends AbstractValidator implements\n-        ConstraintValidator<SchemaMappingCheck, SchemaMapping> {\n-\n-    @Override\n-    public void initialize(final SchemaMappingCheck constraintAnnotation) {\n-    }\n-\n-    @Override\n-    public boolean isValid(final SchemaMapping mapping, final ConstraintValidatorContext context) {\n-\n-        context.disableDefaultConstraintViolation();\n-\n-        if (StringUtils.isBlank(SchemaMappingUtil.getExtAttrName(mapping))) {\n-            context.buildConstraintViolationWithTemplate(\"Missing external attribute name\").addNode(\n-                    EntityViolationType.InvalidSchemaMapping.toString()).addConstraintViolation();\n-\n-            return false;\n-        }\n-\n-        if (StringUtils.isBlank(SchemaMappingUtil.getIntAttrName(mapping))) {\n-            context.buildConstraintViolationWithTemplate(\"Missing internal attribute name\").addNode(\n-                    EntityViolationType.InvalidSchemaMapping.toString()).addConstraintViolation();\n-\n-            return false;\n-        }\n-\n-        if (mapping.isAccountid()\n-                && (IntMappingType.UserVirtualSchema == mapping.getIntMappingType()\n-                        || IntMappingType.RoleVirtualSchema == mapping.getIntMappingType()\n-                        || IntMappingType.MembershipVirtualSchema == mapping.getIntMappingType() || IntMappingType.Password == mapping\n-                        .getIntMappingType())) {\n-            context.buildConstraintViolationWithTemplate(\"Virtual attribute as accountId is not permitted\").addNode(\n-                    EntityViolationType.InvalidSchemaMapping.toString()).addConstraintViolation();\n-\n-            return false;\n-        }\n-\n-        if (mapping.isAccountid() && (IntMappingType.Password == mapping.getIntMappingType() || mapping.isPassword())) {\n-            context.buildConstraintViolationWithTemplate(\"Password as accountId is not permitted\").addNode(\n-                    EntityViolationType.InvalidSchemaMapping.toString()).addConstraintViolation();\n-\n-            return false;\n-        }\n-\n-        return true;\n-    }\n-}"},{"sha":"db35f789c3bf00ff78bc67cf9675cb1737e370ff","filename":"core/src/main/java/org/apache/syncope/core/policy/AccountPolicyEnforcer.java","status":"modified","additions":4,"deletions":4,"changes":8,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpolicy%2FAccountPolicyEnforcer.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpolicy%2FAccountPolicyEnforcer.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpolicy%2FAccountPolicyEnforcer.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -28,7 +28,7 @@\n import org.apache.syncope.core.propagation.PropagationManager;\n import org.apache.syncope.core.propagation.PropagationTaskExecutor;\n import org.apache.syncope.core.rest.data.UserDataBinder;\n-import org.apache.syncope.core.workflow.UserWorkflowAdapter;\n+import org.apache.syncope.core.workflow.user.UserWorkflowAdapter;\n import org.apache.syncope.core.workflow.WorkflowResult;\n import org.apache.syncope.types.AccountPolicySpec;\n import org.apache.syncope.types.PolicyType;\n@@ -39,7 +39,7 @@\n public class AccountPolicyEnforcer extends PolicyEnforcer<AccountPolicySpec, SyncopeUser> {\n \n     @Autowired\n-    private UserWorkflowAdapter wfAdapter;\n+    private UserWorkflowAdapter uwfAdapter;\n \n     @Autowired\n     private PropagationManager propagationManager;\n@@ -116,11 +116,11 @@ public void enforce(final AccountPolicySpec policy, final PolicyType type, final\n                 user.setFailedLogins(user.getFailedLogins() - 1);\n \n                 // disable user\n-                final WorkflowResult<Long> updated = wfAdapter.suspend(user);\n+                final WorkflowResult<Long> updated = uwfAdapter.suspend(user);\n \n                 // propagate suspension if and only if it is required by policy\n                 if (policy.isPropagateSuspension()) {\n-                    final List<PropagationTask> tasks = propagationManager.getUpdateTaskIds(\n+                    final List<PropagationTask> tasks = propagationManager.getUserUpdateTaskIds(\n                             new WorkflowResult<Map.Entry<Long, Boolean>>(\n                             new DefaultMapEntry(updated.getResult(), Boolean.FALSE),\n                             updated.getPropByRes(), updated.getPerformedTasks()));"},{"sha":"1998dc498ab6ece912a2dd889671fb6f171e2e75","filename":"core/src/main/java/org/apache/syncope/core/propagation/AbstractPropagationTaskExecutor.java","status":"modified","additions":173,"deletions":154,"changes":327,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpropagation%2FAbstractPropagationTaskExecutor.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpropagation%2FAbstractPropagationTaskExecutor.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpropagation%2FAbstractPropagationTaskExecutor.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -28,15 +28,16 @@\n import java.util.Set;\n import org.apache.commons.lang.StringUtils;\n import org.apache.syncope.core.init.ConnInstanceLoader;\n+import org.apache.syncope.core.persistence.beans.AbstractAttributable;\n import org.apache.syncope.core.persistence.beans.ExternalResource;\n import org.apache.syncope.core.persistence.beans.PropagationTask;\n import org.apache.syncope.core.persistence.beans.TaskExec;\n-import org.apache.syncope.core.persistence.beans.user.SyncopeUser;\n import org.apache.syncope.core.persistence.dao.TaskDAO;\n-import org.apache.syncope.core.persistence.dao.UserDAO;\n+import org.apache.syncope.core.rest.data.RoleDataBinder;\n+import org.apache.syncope.core.rest.data.UserDataBinder;\n import org.apache.syncope.core.util.ApplicationContextProvider;\n+import org.apache.syncope.core.util.AttributableUtil;\n import org.apache.syncope.core.util.ConnObjectUtil;\n-import org.apache.syncope.core.util.NotFoundException;\n import org.apache.syncope.types.PropagationMode;\n import org.apache.syncope.types.PropagationTaskExecStatus;\n import org.apache.syncope.types.TraceLevel;\n@@ -68,21 +69,24 @@ public abstract class AbstractPropagationTaskExecutor implements PropagationTask\n     @Autowired\n     protected ConnInstanceLoader connLoader;\n \n-    @Autowired\n-    protected ConnObjectUtil connObjectUtil;\n-\n     /**\n-     * User DAO.\n+     * ConnObjectUtil.\n      */\n     @Autowired\n-    protected UserDAO userDAO;\n+    protected ConnObjectUtil connObjectUtil;\n \n     /**\n      * Task DAO.\n      */\n     @Autowired\n     protected TaskDAO taskDAO;\n \n+    @Autowired\n+    protected UserDataBinder userDataBinder;\n+\n+    @Autowired\n+    protected RoleDataBinder roleDataBinder;\n+\n     @Override\n     public TaskExec execute(final PropagationTask task) {\n         return execute(task, null);\n@@ -91,14 +95,14 @@ public TaskExec execute(final PropagationTask task) {\n     protected PropagationActions getPropagationActions(final ExternalResource resource) {\n         PropagationActions result = null;\n \n-        if (StringUtils.isNotBlank(resource.getActionsClassName())) {\n+        if (StringUtils.isNotBlank(resource.getPropagationActionsClassName())) {\n             try {\n-                Class<?> actionsClass = Class.forName(resource.getActionsClassName());\n+                Class<?> actionsClass = Class.forName(resource.getPropagationActionsClassName());\n                 result = (PropagationActions) ApplicationContextProvider.getBeanFactory().\n                         createBean(actionsClass, AbstractBeanDefinition.AUTOWIRE_BY_TYPE, true);\n             } catch (ClassNotFoundException e) {\n                 LOG.error(\"Invalid PropagationAction class name '{}' for resource {}\",\n-                        new Object[]{resource, resource.getActionsClassName(), e});\n+                        new Object[]{resource, resource.getPropagationActionsClassName(), e});\n             }\n         }\n \n@@ -109,6 +113,151 @@ protected PropagationActions getPropagationActions(final ExternalResource resour\n         return result;\n     }\n \n+    protected void createOrUpdate(final PropagationTask task, final ConnectorObject beforeObj,\n+            final ConnectorFacadeProxy connector, final Set<String> propagationAttempted) {\n+\n+        // set of attributes to be propagated\n+        final Set<Attribute> attributes = new HashSet<Attribute>(task.getAttributes());\n+\n+        if (beforeObj == null) {\n+            // 1. get accountId\n+            final String accountId = task.getAccountId();\n+\n+            // 2. get name\n+            final Name name = (Name) AttributeUtil.find(Name.NAME, attributes);\n+\n+            // 3. check if:\n+            //      * accountId is not blank;\n+            //      * accountId is not equal to Name.\n+            if (StringUtils.isNotBlank(accountId) && (name == null || !accountId.equals(name.getNameValue()))) {\n+                // 3.a retrieve uid\n+                final Uid uid = (Uid) AttributeUtil.find(Uid.NAME, attributes);\n+\n+                // 3.b add Uid if not provided\n+                if (uid == null) {\n+                    attributes.add(AttributeBuilder.build(Uid.NAME, Collections.singleton(accountId)));\n+                }\n+            }\n+\n+            // 4. provision entry\n+            LOG.debug(\"Create {} on {}\", attributes, task.getResource().getName());\n+\n+            connector.create(task.getPropagationMode(), new ObjectClass(task.getObjectClassName()),\n+                    attributes, null, propagationAttempted);\n+        } else {\n+            // 1. check if rename is really required\n+            final Name newName = (Name) AttributeUtil.find(Name.NAME, attributes);\n+\n+            LOG.debug(\"Rename required with value {}\", newName);\n+\n+            if (newName != null && newName.equals(beforeObj.getName())\n+                    && !newName.getNameValue().equals(beforeObj.getUid().getUidValue())) {\n+\n+                LOG.debug(\"Remote object name unchanged\");\n+                attributes.remove(newName);\n+            }\n+\n+            // 2. check wether anything is actually needing to be propagated, i.e. if there is attribute\n+            // difference between beforeObj - just read above from the connector - and the values to be propagated\n+            Map<String, Attribute> originalAttrMap = connObjectUtil.toMap(beforeObj.getAttributes());\n+            Map<String, Attribute> updateAttrMap = connObjectUtil.toMap(attributes);\n+\n+            // Only compare attribute from beforeObj that are also being updated\n+            Set<String> skipAttrNames = originalAttrMap.keySet();\n+            skipAttrNames.removeAll(updateAttrMap.keySet());\n+            for (String attrName : new HashSet<String>(skipAttrNames)) {\n+                originalAttrMap.remove(attrName);\n+            }\n+\n+            Set<Attribute> originalAttrs = new HashSet<Attribute>(originalAttrMap.values());\n+\n+            if (originalAttrs.equals(attributes)) {\n+                LOG.debug(\"Don't need to propagate anything: {} is equal to {}\", originalAttrs, attributes);\n+            } else {\n+                LOG.debug(\"Attributes that would be updated {}\", attributes);\n+\n+                Set<Attribute> strictlyModified = new HashSet<Attribute>();\n+                for (Attribute attr : attributes) {\n+                    if (!originalAttrs.contains(attr)) {\n+                        strictlyModified.add(attr);\n+                    }\n+                }\n+\n+                // 3. provision entry\n+                LOG.debug(\"Update {} on {}\", strictlyModified, task.getResource().getName());\n+\n+                connector.update(task.getPropagationMode(), beforeObj.getObjectClass(),\n+                        beforeObj.getUid(), strictlyModified, null, propagationAttempted);\n+            }\n+        }\n+    }\n+\n+    protected AbstractAttributable getSubject(final PropagationTask task) {\n+        AbstractAttributable subject = null;\n+\n+        if (task.getSubjectId() != null) {\n+            switch (task.getSubjectType()) {\n+                case USER:\n+                    try {\n+                        subject = userDataBinder.getUserFromId(task.getSubjectId());\n+                    } catch (Exception e) {\n+                        LOG.error(\"Could not read user {}\", task.getSubjectId(), e);\n+                    }\n+                    break;\n+\n+                case ROLE:\n+                    try {\n+                        subject = roleDataBinder.getRoleFromId(task.getSubjectId());\n+                    } catch (Exception e) {\n+                        LOG.error(\"Could not read role {}\", task.getSubjectId(), e);\n+                    }\n+                    break;\n+\n+                case MEMBERSHIP:\n+                default:\n+            }\n+        }\n+\n+        return subject;\n+    }\n+\n+    protected void delete(final PropagationTask task, final ConnectorObject beforeObj,\n+            final ConnectorFacadeProxy connector, final Set<String> propagationAttempted) {\n+\n+        if (beforeObj == null) {\n+            LOG.debug(\"{} not found on external resource: ignoring delete\", task.getAccountId());\n+        } else {\n+            /*\n+             * We must choose here whether to\n+             *  a. actually delete the provided user from the external resource\n+             *  b. just update the provided user data onto the external resource\n+             *\n+             * (a) happens when either there is no user associated with the PropagationTask (this takes\n+             * place when the task is generated via UserController.delete()) or the provided updated\n+             * user hasn't the current resource assigned (when the task is generated via\n+             * UserController.update()).\n+             *\n+             * (b) happens when the provided updated user does have the current resource assigned\n+             * (when the task is generated via UserController.update()): this basically means that\n+             * before such update, this user used to have the current resource assigned by more than\n+             * one mean (for example, two different memberships with the same resource).\n+             */\n+            AbstractAttributable subject = getSubject(task);\n+            if (subject == null || !subject.getResourceNames().contains(task.getResource().getName())) {\n+                LOG.debug(\"Delete {} on {}\", beforeObj.getUid(), task.getResource().getName());\n+\n+                connector.delete(\n+                        task.getPropagationMode(),\n+                        beforeObj.getObjectClass(),\n+                        beforeObj.getUid(),\n+                        null,\n+                        propagationAttempted);\n+            } else {\n+                createOrUpdate(task, beforeObj, connector, propagationAttempted);\n+            }\n+        }\n+    }\n+\n     @Override\n     public TaskExec execute(final PropagationTask task, final PropagationHandler handler) {\n         final PropagationActions actions = getPropagationActions(task.getResource());\n@@ -130,142 +279,19 @@ public TaskExec execute(final PropagationTask task, final PropagationHandler han\n         try {\n             connector = connLoader.getConnector(task.getResource());\n \n-            // Try to read user BEFORE any actual operation\n-            beforeObj = getRemoteObject(connector, task, false);\n+            // Try to read remote object (user / group) BEFORE any actual operation\n+            beforeObj = getRemoteObject(task, connector, false);\n \n             actions.before(task, beforeObj);\n \n             switch (task.getPropagationOperation()) {\n                 case CREATE:\n                 case UPDATE:\n-                    // set of attributes to be propagated\n-                    final Set<Attribute> attributes = new HashSet<Attribute>(task.getAttributes());\n-\n-                    if (beforeObj == null) {\n-                        // 1. get accountId\n-                        final String accountId = task.getAccountId();\n-\n-                        // 2. get name\n-                        final Name name = (Name) AttributeUtil.find(Name.NAME, attributes);\n-\n-                        // 3. check if:\n-                        //      * accountId is not blank;\n-                        //      * accountId is not equal to Name.\n-                        if (StringUtils.isNotBlank(accountId)\n-                                && (name == null || !accountId.equals(name.getNameValue()))) {\n-\n-                            // 3.a retrieve uid\n-                            final Uid uid = (Uid) AttributeUtil.find(Uid.NAME, attributes);\n-\n-                            // 3.b add Uid if not provided\n-                            if (uid == null) {\n-                                attributes.add(AttributeBuilder.build(Uid.NAME, Collections.singleton(accountId)));\n-                            }\n-                        }\n-\n-                        // 4. provision entry\n-                        connector.create(task.getPropagationMode(), ObjectClass.ACCOUNT, attributes, null,\n-                                propagationAttempted);\n-                    } else {\n-                        // 1. check if rename is really required\n-                        final Name newName = (Name) AttributeUtil.find(Name.NAME, attributes);\n-\n-                        LOG.debug(\"Rename required with value {}\", newName);\n-\n-                        if (newName != null && newName.equals(beforeObj.getName())\n-                                && !beforeObj.getUid().getUidValue().equals(newName.getNameValue())) {\n-\n-                            LOG.debug(\"Remote object name unchanged\");\n-                            attributes.remove(newName);\n-                        }\n-\n-                        // 2. check wether anything is actually needing to be propagated, i.e. if there is attribute\n-                        // difference between beforeObj - just read above from the connector - and the values to\n-                        // be propagated\n-                        Map<String, Attribute> originalAttrMap = connObjectUtil.toMap(beforeObj.getAttributes());\n-                        Map<String, Attribute> updateAttrMap = connObjectUtil.toMap(attributes);\n-\n-                        // Only compare attribute from beforeObj that are also being updated\n-                        Set<String> skipAttrNames = originalAttrMap.keySet();\n-                        skipAttrNames.removeAll(updateAttrMap.keySet());\n-                        for (String attrName : new HashSet<String>(skipAttrNames)) {\n-                            originalAttrMap.remove(attrName);\n-                        }\n-\n-                        Set<Attribute> originalAttrs = new HashSet<Attribute>(originalAttrMap.values());\n-\n-                        if (originalAttrs.equals(attributes)) {\n-                            LOG.debug(\"Don't need to propagate anything: {} is equal to {}\", originalAttrs, attributes);\n-                        } else {\n-                            LOG.debug(\"Attributes that would be updated {}\", attributes);\n-\n-                            Set<Attribute> strictlyModified = new HashSet<Attribute>();\n-                            for (Attribute attr : attributes) {\n-                                if (!originalAttrs.contains(attr)) {\n-                                    strictlyModified.add(attr);\n-                                }\n-                            }\n-\n-                            LOG.debug(\"Attributes that will be actually propagated for update {}\", strictlyModified);\n-\n-                            connector.update(task.getPropagationMode(), ObjectClass.ACCOUNT, beforeObj.getUid(),\n-                                    strictlyModified, null, propagationAttempted);\n-                        }\n-                    }\n+                    createOrUpdate(task, beforeObj, connector, propagationAttempted);\n                     break;\n \n                 case DELETE:\n-                    if (beforeObj == null) {\n-                        LOG.debug(\"{} not found on external resource: ignoring delete\", task.getAccountId());\n-                    } else {\n-                        /*\n-                         * We must choose here whether to\n-                         *  a. actually delete the provided user from the external resource\n-                         *  b. just update the provided user data onto the external resource\n-                         *\n-                         * (a) happens when either there is no user associated with the PropagationTask (this takes\n-                         * place when the task is generated via UserController.delete()) or the provided updated\n-                         * user hasn't the current resource assigned (when the task is generated via\n-                         * UserController.update()).\n-                         *\n-                         * (b) happens when the provided updated user does have the current resource assigned\n-                         * (when the task is generated via UserController.update()): this basically means that\n-                         * before such update, this user used to have the current resource assigned by more than\n-                         * one mean (for example, two different memberships with the same resource).\n-                         */\n-\n-                        SyncopeUser user = null;\n-                        if (task.getSyncopeUser() != null) {\n-                            try {\n-                                user = getSyncopeUser(task.getSyncopeUser().getId());\n-                            } catch (NotFoundException e) {\n-                                LOG.warn(\"Requesting to delete a non-existing user from {}\",\n-                                        task.getResource().getName(), e);\n-                            }\n-                        }\n-\n-                        if (user == null || !user.getResourceNames().contains(task.getResource().getName())) {\n-                            LOG.debug(\"Perform deprovisioning on {}\", task.getResource().getName());\n-\n-                            connector.delete(\n-                                    task.getPropagationMode(),\n-                                    ObjectClass.ACCOUNT,\n-                                    beforeObj.getUid(),\n-                                    null,\n-                                    propagationAttempted);\n-                        } else {\n-                            LOG.debug(\"Update remote object on {}\", task.getResource().getName());\n-\n-                            connector.update(\n-                                    task.getPropagationMode(),\n-                                    ObjectClass.ACCOUNT,\n-                                    beforeObj.getUid(),\n-                                    task.getAttributes(),\n-                                    null,\n-                                    propagationAttempted);\n-                        }\n-                    }\n-\n+                    delete(task, beforeObj, connector, propagationAttempted);\n                     break;\n \n                 default:\n@@ -298,9 +324,9 @@ public TaskExec execute(final PropagationTask task, final PropagationHandler han\n \n             propagationAttempted.add(task.getPropagationOperation().name().toLowerCase());\n         } finally {\n-            // Try to read user AFTER any actual operation\n+            // Try to read remote object (user / group) AFTER any actual operation\n             if (connector != null) {\n-                afterObj = getRemoteObject(connector, task, true);\n+                afterObj = getRemoteObject(task, connector, true);\n             }\n \n             LOG.debug(\"Update execution for {}\", task);\n@@ -351,17 +377,6 @@ public void execute(final Collection<PropagationTask> tasks) throws PropagationE\n     public abstract void execute(Collection<PropagationTask> tasks, PropagationHandler handler)\n             throws PropagationException;\n \n-    protected SyncopeUser getSyncopeUser(final Long userId)\n-            throws NotFoundException {\n-\n-        SyncopeUser user = userDAO.find(userId);\n-        if (user == null) {\n-            throw new NotFoundException(\"User \" + userId);\n-        }\n-\n-        return user;\n-    }\n-\n     /**\n      * Check whether an execution has to be stored, for a given task.\n      *\n@@ -406,7 +421,7 @@ protected boolean hasToBeregistered(final PropagationTask task, final TaskExec e\n      * @param latest 'FALSE' to retrieve object using old accountId if not null.\n      * @return remote connector object.\n      */\n-    protected ConnectorObject getRemoteObject(final ConnectorFacadeProxy connector, final PropagationTask task,\n+    protected ConnectorObject getRemoteObject(final PropagationTask task, final ConnectorFacadeProxy connector,\n             final boolean latest) {\n \n         String accountId = latest || task.getOldAccountId() == null\n@@ -415,8 +430,12 @@ protected ConnectorObject getRemoteObject(final ConnectorFacadeProxy connector,\n \n         ConnectorObject obj = null;\n         try {\n-            obj = connector.getObject(task.getPropagationMode(), task.getPropagationOperation(), ObjectClass.ACCOUNT,\n-                    new Uid(accountId), connector.getOperationOptions(task.getResource()));\n+            obj = connector.getObject(task.getPropagationMode(),\n+                    task.getPropagationOperation(),\n+                    new ObjectClass(task.getObjectClassName()),\n+                    new Uid(accountId),\n+                    connector.getOperationOptions(AttributableUtil.getInstance(task.getSubjectType()).\n+                    getMappingItems(task.getResource())));\n         } catch (RuntimeException ignore) {\n             LOG.debug(\"While resolving {}\", accountId, ignore);\n         }"},{"sha":"f9e284371e28ddfe8bf5d1c43211d77ef4ce6f8f","filename":"core/src/main/java/org/apache/syncope/core/propagation/ConnectorFacadeProxy.java","status":"modified","additions":62,"deletions":75,"changes":137,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpropagation%2FConnectorFacadeProxy.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpropagation%2FConnectorFacadeProxy.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpropagation%2FConnectorFacadeProxy.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -20,21 +20,19 @@\n \n import java.io.File;\n import java.net.URI;\n-import java.util.Arrays;\n+import java.util.Collection;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Set;\n+import org.apache.syncope.core.persistence.beans.AbstractMappingItem;\n import org.apache.syncope.core.persistence.beans.ConnInstance;\n-import org.apache.syncope.core.persistence.beans.ExternalResource;\n-import org.apache.syncope.core.persistence.beans.SchemaMapping;\n import org.apache.syncope.core.persistence.dao.MissingConfKeyException;\n import org.apache.syncope.core.util.ConnBundleManager;\n import org.apache.syncope.core.util.NotFoundException;\n-import org.apache.syncope.core.util.SchemaMappingUtil;\n import org.apache.syncope.types.ConnConfProperty;\n import org.apache.syncope.types.ConnectorCapability;\n import org.apache.syncope.types.PropagationMode;\n-import org.apache.syncope.types.PropagationOperation;\n+import org.apache.syncope.types.ResourceOperation;\n import org.identityconnectors.common.security.GuardedByteArray;\n import org.identityconnectors.common.security.GuardedString;\n import org.identityconnectors.framework.api.APIConfiguration;\n@@ -62,7 +60,6 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.springframework.util.ClassUtils;\n-import org.springframework.util.StringUtils;\n \n /**\n  * Intercept calls to ConnectorFacade's methods and check if the corresponding connector instance has been configured to\n@@ -148,9 +145,9 @@ public ConnectorFacadeProxy(final ConnInstance connInstance, final ConnBundleMan\n \n         // Set all of the ConfigurationProperties needed by the connector.\n         for (ConnConfProperty property : connInstance.getConfiguration()) {\n-            final Object propertyValue = getPropertyValue(property);\n-            if (propertyValue != null) {\n-                properties.setPropertyValue(property.getSchema().getName(), propertyValue);\n+            if (property.getValues() != null && !property.getValues().isEmpty()) {\n+                properties.setPropertyValue(property.getSchema().getName(),\n+                        getPropertyValue(property.getSchema().getType(), property.getValues()));\n             }\n         }\n \n@@ -313,7 +310,7 @@ public ConnectorObject getObject(final ObjectClass objectClass, final Uid uid, f\n      * @param options ConnId's OperationOptions\n      * @return ConnId's connector object for given uid\n      */\n-    public ConnectorObject getObject(final PropagationMode propagationMode, final PropagationOperation operationType,\n+    public ConnectorObject getObject(final PropagationMode propagationMode, final ResourceOperation operationType,\n             final ObjectClass objectClass, final Uid uid, final OperationOptions options) {\n \n         ConnectorObject result = null;\n@@ -325,16 +322,20 @@ public ConnectorObject getObject(final PropagationMode propagationMode, final Pr\n                 switch (operationType) {\n                     case CREATE:\n                         if (propagationMode == null || (propagationMode == PropagationMode.ONE_PHASE\n-                                ? activeConnInstance.getCapabilities().contains(ConnectorCapability.ONE_PHASE_CREATE)\n-                                : activeConnInstance.getCapabilities().contains(ConnectorCapability.TWO_PHASES_CREATE))) {\n+                                ? activeConnInstance.getCapabilities().\n+                                contains(ConnectorCapability.ONE_PHASE_CREATE)\n+                                : activeConnInstance.getCapabilities().\n+                                contains(ConnectorCapability.TWO_PHASES_CREATE))) {\n \n                             result = connector.getObject(objectClass, uid, options);\n                         }\n                         break;\n                     case UPDATE:\n                         if (propagationMode == null || (propagationMode == PropagationMode.ONE_PHASE\n-                                ? activeConnInstance.getCapabilities().contains(ConnectorCapability.ONE_PHASE_UPDATE)\n-                                : activeConnInstance.getCapabilities().contains(ConnectorCapability.TWO_PHASES_UPDATE))) {\n+                                ? activeConnInstance.getCapabilities().\n+                                contains(ConnectorCapability.ONE_PHASE_UPDATE)\n+                                : activeConnInstance.getCapabilities().\n+                                contains(ConnectorCapability.TWO_PHASES_UPDATE))) {\n \n                             result = connector.getObject(objectClass, uid, options);\n                         }\n@@ -397,13 +398,11 @@ public Attribute getObjectAttribute(final ObjectClass objectClass, final Uid uid\n \n         Attribute attribute = null;\n \n-        try {\n-            final ConnectorObject object = connector.getObject(objectClass, uid, options);\n-\n-            attribute = object.getAttributeByName(attributeName);\n-        } catch (NullPointerException e) {\n-            // ignore exception\n+        final ConnectorObject object = connector.getObject(objectClass, uid, options);\n+        if (object == null) {\n             LOG.debug(\"Object for '{}' not found\", uid.getUidValue());\n+        } else {\n+            attribute = object.getAttributeByName(attributeName);\n         }\n \n         return attribute;\n@@ -414,23 +413,20 @@ public Attribute getObjectAttribute(final ObjectClass objectClass, final Uid uid\n      * @param objectClass ConnId's object class\n      * @param uid ConnId's Uid\n      * @param options ConnId's OperationOptions\n-     * @param attributeNames attributes to read\n      * @return attributes (if present)\n      */\n     public Set<Attribute> getObjectAttributes(final ObjectClass objectClass, final Uid uid,\n             final OperationOptions options) {\n \n         final Set<Attribute> attributes = new HashSet<Attribute>();\n \n-        try {\n-            final ConnectorObject object = connector.getObject(objectClass, uid, options);\n-\n+        ConnectorObject object = connector.getObject(objectClass, uid, options);\n+        if (object == null) {\n+            LOG.debug(\"Object for '{}' not found\", uid.getUidValue());\n+        } else {\n             for (String attribute : options.getAttributesToGet()) {\n                 attributes.add(object.getAttributeByName(attribute));\n             }\n-        } catch (NullPointerException e) {\n-            // ignore exception\n-            LOG.debug(\"Object for '{}' not found\", uid.getUidValue());\n         }\n \n         return attributes;\n@@ -486,70 +482,61 @@ public ConnInstance getActiveConnInstance() {\n         return activeConnInstance;\n     }\n \n-    public OperationOptions getOperationOptions(final ExternalResource resource) {\n-\n+    public OperationOptions getOperationOptions(final Collection<AbstractMappingItem> mapItems) {\n         // -------------------------------------\n         // Ask just for mapped attributes\n         // -------------------------------------\n         final OperationOptionsBuilder oob = new OperationOptionsBuilder();\n \n-        final Set<String> attributesToGet = new HashSet<String>(Arrays.asList(new String[]{Name.NAME, Uid.NAME,\n-                    OperationalAttributes.ENABLE_NAME}));\n+        final Set<String> attrsToGet = new HashSet<String>();\n+        attrsToGet.add(Name.NAME);\n+        attrsToGet.add(Uid.NAME);\n+        attrsToGet.add(OperationalAttributes.ENABLE_NAME);\n \n-        for (SchemaMapping mapping : resource.getMappings()) {\n-            final String extAttrName = SchemaMappingUtil.getExtAttrName(mapping);\n-\n-            if (StringUtils.hasText(extAttrName)) {\n-                attributesToGet.add(extAttrName);\n-            }\n+        for (AbstractMappingItem item : mapItems) {\n+            attrsToGet.add(item.getExtAttrName());\n         }\n \n-        oob.setAttributesToGet(attributesToGet);\n+        oob.setAttributesToGet(attrsToGet);\n         // -------------------------------------\n \n         return oob.build();\n     }\n \n-    private Object getPropertyValue(final ConnConfProperty property) {\n+    private Object getPropertyValue(final String propType, final List<Object> values) {\n         Object value = null;\n \n-        final List<Object> values = property.getValues();\n-\n-        if (values != null && !values.isEmpty()) {\n-            try {\n-                final Class propertySchemaClass = ClassUtils.forName(property.getSchema().getType(), ClassUtils.\n-                        getDefaultClassLoader());\n-\n-                if (GuardedString.class.equals(propertySchemaClass)) {\n-                    value = new GuardedString((values.get(0).toString()).toCharArray());\n-                } else if (GuardedByteArray.class.equals(propertySchemaClass)) {\n-                    value = new GuardedByteArray((byte[]) values.get(0));\n-                } else if (Character.class.equals(propertySchemaClass) || Character.TYPE.equals(propertySchemaClass)) {\n-                    value = values.get(0) != null && !values.get(0).toString().isEmpty()\n-                            ? values.get(0).toString().charAt(0)\n-                            : null;\n-                } else if (Integer.class.equals(propertySchemaClass) || Integer.TYPE.equals(propertySchemaClass)) {\n-                    value = Integer.parseInt(values.get(0).toString());\n-                } else if (Long.class.equals(propertySchemaClass) || Long.TYPE.equals(propertySchemaClass)) {\n-                    value = Long.parseLong(values.get(0).toString());\n-                } else if (Float.class.equals(propertySchemaClass) || Float.TYPE.equals(propertySchemaClass)) {\n-                    value = Float.parseFloat(values.get(0).toString());\n-                } else if (Double.class.equals(propertySchemaClass) || Double.TYPE.equals(propertySchemaClass)) {\n-                    value = Double.parseDouble(values.get(0).toString());\n-                } else if (Boolean.class.equals(propertySchemaClass) || Boolean.TYPE.equals(propertySchemaClass)) {\n-                    value = Boolean.parseBoolean(values.get(0).toString());\n-                } else if (URI.class.equals(propertySchemaClass)) {\n-                    value = URI.create(values.get(0).toString());\n-                } else if (File.class.equals(propertySchemaClass)) {\n-                    value = new File(values.get(0).toString());\n-                } else if (String[].class.equals(propertySchemaClass)) {\n-                    value = values.toArray(new String[]{});\n-                } else {\n-                    value = values.get(0).toString();\n-                }\n-            } catch (Exception e) {\n-                LOG.error(\"Invalid ConnConfProperty specified: {}\", property, e);\n+        try {\n+            final Class propertySchemaClass = ClassUtils.forName(propType, ClassUtils.getDefaultClassLoader());\n+\n+            if (GuardedString.class.equals(propertySchemaClass)) {\n+                value = new GuardedString(values.get(0).toString().toCharArray());\n+            } else if (GuardedByteArray.class.equals(propertySchemaClass)) {\n+                value = new GuardedByteArray((byte[]) values.get(0));\n+            } else if (Character.class.equals(propertySchemaClass) || Character.TYPE.equals(propertySchemaClass)) {\n+                value = values.get(0) == null || values.get(0).toString().isEmpty()\n+                        ? null : values.get(0).toString().charAt(0);\n+            } else if (Integer.class.equals(propertySchemaClass) || Integer.TYPE.equals(propertySchemaClass)) {\n+                value = Integer.parseInt(values.get(0).toString());\n+            } else if (Long.class.equals(propertySchemaClass) || Long.TYPE.equals(propertySchemaClass)) {\n+                value = Long.parseLong(values.get(0).toString());\n+            } else if (Float.class.equals(propertySchemaClass) || Float.TYPE.equals(propertySchemaClass)) {\n+                value = Float.parseFloat(values.get(0).toString());\n+            } else if (Double.class.equals(propertySchemaClass) || Double.TYPE.equals(propertySchemaClass)) {\n+                value = Double.parseDouble(values.get(0).toString());\n+            } else if (Boolean.class.equals(propertySchemaClass) || Boolean.TYPE.equals(propertySchemaClass)) {\n+                value = Boolean.parseBoolean(values.get(0).toString());\n+            } else if (URI.class.equals(propertySchemaClass)) {\n+                value = URI.create(values.get(0).toString());\n+            } else if (File.class.equals(propertySchemaClass)) {\n+                value = new File(values.get(0).toString());\n+            } else if (String[].class.equals(propertySchemaClass)) {\n+                value = values.toArray(new String[]{});\n+            } else {\n+                value = values.get(0) == null ? null : values.get(0).toString();\n             }\n+        } catch (Exception e) {\n+            LOG.error(\"Invalid ConnConfProperty specified: {} {}\", propType, values, e);\n         }\n \n         return value;"},{"sha":"81a8abdbc15cefe472557515ba713732ca755feb","filename":"core/src/main/java/org/apache/syncope/core/propagation/DefaultPropagationHandler.java","status":"added","additions":56,"deletions":0,"changes":56,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpropagation%2FDefaultPropagationHandler.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpropagation%2FDefaultPropagationHandler.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpropagation%2FDefaultPropagationHandler.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -0,0 +1,56 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.core.propagation;\n+\n+import java.util.List;\n+import org.apache.syncope.client.to.PropagationTO;\n+import org.apache.syncope.core.util.ConnObjectUtil;\n+import org.apache.syncope.types.PropagationTaskExecStatus;\n+import org.identityconnectors.framework.common.objects.ConnectorObject;\n+\n+public class DefaultPropagationHandler implements PropagationHandler {\n+\n+    private final ConnObjectUtil connObjectUtil;\n+\n+    private final List<PropagationTO> propagations;\n+\n+    public DefaultPropagationHandler(final ConnObjectUtil connObjectUtil, final List<PropagationTO> propagations) {\n+        this.connObjectUtil = connObjectUtil;\n+        this.propagations = propagations;\n+    }\n+\n+    @Override\n+    public void handle(final String resourceName, final PropagationTaskExecStatus executionStatus,\n+            final ConnectorObject beforeObj, final ConnectorObject afterObj) {\n+\n+        final PropagationTO propagation = new PropagationTO();\n+        propagation.setResourceName(resourceName);\n+        propagation.setStatus(executionStatus);\n+\n+        if (beforeObj != null) {\n+            propagation.setBeforeObj(connObjectUtil.getConnObjectTO(beforeObj));\n+        }\n+\n+        if (afterObj != null) {\n+            propagation.setAfterObj(connObjectUtil.getConnObjectTO(afterObj));\n+        }\n+\n+        propagations.add(propagation);\n+    }\n+}"},{"sha":"bbd261f856c3baf1a420784039559d6b3968afd1","filename":"core/src/main/java/org/apache/syncope/core/propagation/LDAPMembershipPropagationActions.java","status":"added","additions":105,"deletions":0,"changes":105,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpropagation%2FLDAPMembershipPropagationActions.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpropagation%2FLDAPMembershipPropagationActions.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpropagation%2FLDAPMembershipPropagationActions.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -0,0 +1,105 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.core.propagation;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import org.apache.commons.jexl2.JexlContext;\n+import org.apache.commons.jexl2.MapContext;\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.syncope.core.persistence.beans.PropagationTask;\n+import org.apache.syncope.core.persistence.beans.role.SyncopeRole;\n+import org.apache.syncope.core.persistence.beans.user.SyncopeUser;\n+import org.apache.syncope.core.persistence.dao.UserDAO;\n+import org.apache.syncope.core.util.JexlUtil;\n+import org.apache.syncope.types.AttributableType;\n+import org.apache.syncope.types.ResourceOperation;\n+import org.identityconnectors.framework.common.objects.Attribute;\n+import org.identityconnectors.framework.common.objects.AttributeBuilder;\n+import org.identityconnectors.framework.common.objects.ConnectorObject;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+/**\n+ * Simple action for propagating role memberships to LDAP groups, when the same resource is configured for both users\n+ * and roles.\n+ */\n+public class LDAPMembershipPropagationActions extends DefaultPropagationActions {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(LDAPMembershipPropagationActions.class);\n+\n+    /**\n+     * Allows easy subclassing for the ConnId AD connector bundle.\n+     */\n+    protected static final String GROUP_MEMBERSHIP_ATTR = \"ldapGroups\";\n+\n+    @Autowired\n+    private UserDAO userDAO;\n+\n+    @Autowired\n+    private JexlUtil jexlUtil;\n+\n+    @Transactional(readOnly = true)\n+    @Override\n+    public void before(final PropagationTask task, final ConnectorObject beforeObj) {\n+        super.before(task, beforeObj);\n+\n+        if (ResourceOperation.DELETE != task.getPropagationOperation()\n+                && AttributableType.USER == task.getSubjectType() && task.getResource().getRmapping() != null) {\n+\n+            SyncopeUser user = userDAO.find(task.getSubjectId());\n+            if (user == null) {\n+                throw new IllegalArgumentException(\"User \" + task.getSubjectId() + \" not found\");\n+            }\n+\n+            List<String> roleAccountLinks = new ArrayList<String>();\n+            for (SyncopeRole role : user.getRoles()) {\n+                if (role.getResourceNames().contains(task.getResource().getName())\n+                        && StringUtils.isNotBlank(task.getResource().getRmapping().getAccountLink())) {\n+\n+                    LOG.debug(\"Evaluating accountLink for {}\", role);\n+\n+                    final JexlContext jexlContext = new MapContext();\n+                    jexlUtil.addFieldsToContext(role, jexlContext);\n+                    jexlUtil.addAttrsToContext(role.getAttributes(), jexlContext);\n+                    jexlUtil.addDerAttrsToContext(role.getDerivedAttributes(), role.getAttributes(), jexlContext);\n+                    final String roleAccountLink = jexlUtil.evaluate(task.getResource().getRmapping().getAccountLink(),\n+                            jexlContext);\n+                    LOG.debug(\"AccountLink for {} is '{}'\", role, roleAccountLink);\n+                    if (StringUtils.isNotBlank(roleAccountLink)) {\n+                        roleAccountLinks.add(roleAccountLink);\n+                    }\n+                }\n+            }\n+            LOG.debug(\"Role accountLinks to propagate for membership: {}\", roleAccountLinks);\n+\n+            if (!roleAccountLinks.isEmpty()) {\n+                Set<Attribute> attributes = new HashSet<Attribute>(task.getAttributes());\n+                attributes.add(AttributeBuilder.build(GROUP_MEMBERSHIP_ATTR, roleAccountLinks));\n+                task.setAttributes(attributes);\n+            }\n+        } else {\n+            LOG.debug(\"Not about user, or role mapping missing for resource: not doing anything\");\n+        }\n+    }\n+}"},{"sha":"c59c098a55fd744fb0315321c1d8ec880dba6d83","filename":"core/src/main/java/org/apache/syncope/core/propagation/PropagationByResource.java","status":"modified","additions":31,"deletions":9,"changes":40,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpropagation%2FPropagationByResource.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpropagation%2FPropagationByResource.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpropagation%2FPropagationByResource.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -24,7 +24,7 @@\n import java.util.HashSet;\n import java.util.Map;\n import java.util.Set;\n-import org.apache.syncope.types.PropagationOperation;\n+import org.apache.syncope.types.ResourceOperation;\n \n /**\n  * Utility class for encapsulating operations to be performed on various resources.\n@@ -82,7 +82,7 @@ public final void purge() {\n      * @param resourceName target resource\n      * @return whether the operation was successful or not\n      */\n-    public final boolean add(final PropagationOperation type, final String resourceName) {\n+    public final boolean add(final ResourceOperation type, final String resourceName) {\n         Set<String> set;\n         switch (type) {\n             case CREATE:\n@@ -109,7 +109,7 @@ public final boolean add(final PropagationOperation type, final String resourceN\n      * @param resourceNames target resources\n      * @return whether the operation was successful or not\n      */\n-    public boolean addAll(final PropagationOperation type, final Set<String> resourceNames) {\n+    public boolean addAll(final ResourceOperation type, final Set<String> resourceNames) {\n         Set<String> set;\n         switch (type) {\n             case CREATE:\n@@ -136,7 +136,7 @@ public boolean addAll(final PropagationOperation type, final Set<String> resourc\n      * @param resourceName target resource\n      * @return whether the operation was successful or not\n      */\n-    public final boolean remove(final PropagationOperation type, final String resourceName) {\n+    public final boolean remove(final ResourceOperation type, final String resourceName) {\n         boolean result = false;\n \n         switch (type) {\n@@ -158,13 +158,35 @@ public final boolean remove(final PropagationOperation type, final String resour\n         return result;\n     }\n \n+    public boolean contains(final ResourceOperation type, final String resourceName) {\n+        boolean result = false;\n+\n+        switch (type) {\n+            case CREATE:\n+                result = toBeCreated.contains(resourceName);\n+                break;\n+\n+            case UPDATE:\n+                result = toBeUpdated.contains(resourceName);\n+                break;\n+\n+            case DELETE:\n+                result = toBeDeleted.contains(resourceName);\n+                break;\n+\n+            default:\n+        }\n+\n+        return result;\n+    }\n+\n     /**\n      * Get resources for a given resource operation type.\n      *\n      * @param type resource operation type\n      * @return resource matching the given type\n      */\n-    public final Set<String> get(final PropagationOperation type) {\n+    public final Set<String> get(final ResourceOperation type) {\n         Set<String> result = Collections.emptySet();\n \n         switch (type) {\n@@ -192,7 +214,7 @@ public final Set<String> get(final PropagationOperation type) {\n      * @param type resource operation type\n      * @param resourceNames to be set\n      */\n-    public final void set(final PropagationOperation type, final Set<String> resourceNames) {\n+    public final void set(final ResourceOperation type, final Set<String> resourceNames) {\n \n         switch (type) {\n             case CREATE:\n@@ -220,9 +242,9 @@ public final void set(final PropagationOperation type, final Set<String> resourc\n      * @param propByRes to be merged\n      */\n     public final void merge(final PropagationByResource propByRes) {\n-        toBeCreated.addAll(propByRes.get(PropagationOperation.CREATE));\n-        toBeUpdated.addAll(propByRes.get(PropagationOperation.UPDATE));\n-        toBeDeleted.addAll(propByRes.get(PropagationOperation.DELETE));\n+        toBeCreated.addAll(propByRes.get(ResourceOperation.CREATE));\n+        toBeUpdated.addAll(propByRes.get(ResourceOperation.UPDATE));\n+        toBeDeleted.addAll(propByRes.get(ResourceOperation.DELETE));\n         oldAccountIds.putAll(propByRes.getOldAccountIds());\n     }\n "},{"sha":"ff160a77b89c323883aaadeba872752731464892","filename":"core/src/main/java/org/apache/syncope/core/propagation/PropagationManager.java","status":"modified","additions":286,"deletions":139,"changes":425,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpropagation%2FPropagationManager.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpropagation%2FPropagationManager.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpropagation%2FPropagationManager.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -33,24 +33,27 @@\n import org.apache.syncope.client.to.AttributeTO;\n import org.apache.syncope.core.persistence.beans.AbstractAttrValue;\n import org.apache.syncope.core.persistence.beans.AbstractAttributable;\n+import org.apache.syncope.core.persistence.beans.AbstractMappingItem;\n import org.apache.syncope.core.persistence.beans.AbstractSchema;\n import org.apache.syncope.core.persistence.beans.ExternalResource;\n import org.apache.syncope.core.persistence.beans.PropagationTask;\n-import org.apache.syncope.core.persistence.beans.SchemaMapping;\n-import org.apache.syncope.core.persistence.beans.membership.Membership;\n+import org.apache.syncope.core.persistence.beans.role.SyncopeRole;\n import org.apache.syncope.core.persistence.beans.user.SyncopeUser;\n import org.apache.syncope.core.persistence.dao.ResourceDAO;\n import org.apache.syncope.core.persistence.dao.SchemaDAO;\n-import org.apache.syncope.core.persistence.dao.UserDAO;\n+import org.apache.syncope.core.rest.controller.UnauthorizedRoleException;\n+import org.apache.syncope.core.rest.data.AbstractAttributableDataBinder;\n+import org.apache.syncope.core.rest.data.RoleDataBinder;\n import org.apache.syncope.core.rest.data.UserDataBinder;\n import org.apache.syncope.core.util.AttributableUtil;\n+import org.apache.syncope.core.util.ConnObjectUtil;\n import org.apache.syncope.core.util.JexlUtil;\n+import org.apache.syncope.core.util.MappingUtil;\n import org.apache.syncope.core.util.NotFoundException;\n-import org.apache.syncope.core.util.SchemaMappingUtil;\n import org.apache.syncope.core.workflow.WorkflowResult;\n import org.apache.syncope.types.AttributableType;\n import org.apache.syncope.types.IntMappingType;\n-import org.apache.syncope.types.PropagationOperation;\n+import org.apache.syncope.types.ResourceOperation;\n import org.apache.syncope.types.SchemaType;\n import org.identityconnectors.framework.common.FrameworkUtil;\n import org.identityconnectors.framework.common.objects.Attribute;\n@@ -80,10 +83,10 @@ public class PropagationManager {\n     private UserDataBinder userDataBinder;\n \n     /**\n-     * User DAO.\n+     * User DataBinder.\n      */\n     @Autowired\n-    private UserDAO userDAO;\n+    private RoleDataBinder roleDataBinder;\n \n     /**\n      * Resource DAO.\n@@ -97,90 +100,131 @@ public class PropagationManager {\n     @Autowired\n     private SchemaDAO schemaDAO;\n \n+    /**\n+     * ConnObjectUtil.\n+     */\n+    @Autowired\n+    private ConnObjectUtil connObjectUtil;\n+\n     /**\n      * JEXL engine for evaluating connector's account link.\n      */\n     @Autowired\n     private JexlUtil jexlUtil;\n \n-    protected SyncopeUser getSyncopeUser(final Long userId)\n-            throws NotFoundException {\n-\n-        SyncopeUser user = userDAO.find(userId);\n-        if (user == null) {\n-            throw new NotFoundException(\"User \" + userId);\n-        }\n-\n-        return user;\n-    }\n-\n     /**\n      * Create the user on every associated resource.\n      *\n      * @param wfResult user to be propagated (and info associated), as per result from workflow\n      * @param password to be set\n      * @param vAttrs virtual attributes to be set\n      * @return list of propagation tasks\n-     * @throws NotFoundException if userId is not found\n+     * @throws NotFoundException if user is not found\n+     * @throws UnauthorizedRoleException if caller doesn't own enough entitlements to administer the given user\n      */\n-    public List<PropagationTask> getCreateTaskIds(final WorkflowResult<Map.Entry<Long, Boolean>> wfResult,\n+    public List<PropagationTask> getUserCreateTaskIds(final WorkflowResult<Map.Entry<Long, Boolean>> wfResult,\n             final String password, final List<AttributeTO> vAttrs)\n-            throws NotFoundException {\n+            throws NotFoundException, UnauthorizedRoleException {\n \n-        return getCreateTaskIds(wfResult, password, vAttrs, null);\n+        return getUserCreateTaskIds(wfResult, password, vAttrs, null);\n     }\n \n     /**\n      * Create the user on every associated resource.\n      *\n-     * @param wfResult user to be propagated (and info associated), as per result from workflow.\n-     * @param password to be set.\n-     * @param vAttrs virtual attributes to be set.\n-     * @param syncResourceNames external resources performing sync, hence not to be considered for propagation.\n-     * @return list of propagation tasks.\n-     * @throws NotFoundException if userId is not found.\n+     * @param wfResult user to be propagated (and info associated), as per result from workflow\n+     * @param password to be set\n+     * @param vAttrs virtual attributes to be set\n+     * @param syncResourceNames external resources performing sync, hence not to be considered for propagation\n+     * @return list of propagation tasks\n+     * @throws NotFoundException if user is not found\n+     * @throws UnauthorizedRoleException if caller doesn't own enough entitlements to administer the given user\n      */\n-    public List<PropagationTask> getCreateTaskIds(final WorkflowResult<Map.Entry<Long, Boolean>> wfResult,\n+    public List<PropagationTask> getUserCreateTaskIds(final WorkflowResult<Map.Entry<Long, Boolean>> wfResult,\n             final String password, final List<AttributeTO> vAttrs, final Set<String> syncResourceNames)\n-            throws NotFoundException {\n+            throws NotFoundException, UnauthorizedRoleException {\n \n-        SyncopeUser user = getSyncopeUser(wfResult.getResult().getKey());\n+        SyncopeUser user = userDataBinder.getUserFromId(wfResult.getResult().getKey());\n         if (vAttrs != null && !vAttrs.isEmpty()) {\n             userDataBinder.fillVirtual(user, vAttrs, AttributableUtil.getInstance(AttributableType.USER));\n         }\n+        return getCreateTaskIds(user, password, vAttrs,\n+                wfResult.getResult().getValue(), wfResult.getPropByRes(), syncResourceNames);\n+    }\n+\n+    /**\n+     * Create the role on every associated resource.\n+     *\n+     * @param wfResult user to be propagated (and info associated), as per result from workflow\n+     * @param vAttrs virtual attributes to be set\n+     * @return list of propagation tasks\n+     * @throws NotFoundException if role is not found\n+     * @throws UnauthorizedRoleException if caller doesn't own enough entitlements to administer the given role\n+     */\n+    public List<PropagationTask> getRoleCreateTaskIds(final WorkflowResult<Long> wfResult,\n+            final List<AttributeTO> vAttrs)\n+            throws NotFoundException, UnauthorizedRoleException {\n+\n+        return getRoleCreateTaskIds(wfResult, vAttrs, null);\n+    }\n+\n+    /**\n+     * Create the role on every associated resource.\n+     *\n+     * @param wfResult role to be propagated (and info associated), as per result from workflow\n+     * @param vAttrs virtual attributes to be set\n+     * @param syncResourceNames external resources performing sync, hence not to be considered for propagation\n+     * @return list of propagation tasks\n+     * @throws NotFoundException if role is not found\n+     * @throws UnauthorizedRoleException if caller doesn't own enough entitlements to administer the given role\n+     */\n+    public List<PropagationTask> getRoleCreateTaskIds(final WorkflowResult<Long> wfResult,\n+            final List<AttributeTO> vAttrs, final Set<String> syncResourceNames)\n+            throws NotFoundException, UnauthorizedRoleException {\n+\n+        SyncopeRole role = roleDataBinder.getRoleFromId(wfResult.getResult());\n+        if (vAttrs != null && !vAttrs.isEmpty()) {\n+            roleDataBinder.fillVirtual(role, vAttrs, AttributableUtil.getInstance(AttributableType.ROLE));\n+        }\n+        return getCreateTaskIds(role, null, vAttrs, null, wfResult.getPropByRes(), syncResourceNames);\n+    }\n+\n+    protected List<PropagationTask> getCreateTaskIds(final AbstractAttributable attributable,\n+            final String password, final List<AttributeTO> vAttrs, final Boolean enable,\n+            final PropagationByResource propByRes, final Set<String> syncResourceNames) {\n \n-        final PropagationByResource propByRes = wfResult.getPropByRes();\n         if (propByRes == null || propByRes.isEmpty()) {\n-            return Collections.emptyList();\n+            return Collections.EMPTY_LIST;\n         }\n \n         if (syncResourceNames != null) {\n-            propByRes.get(PropagationOperation.CREATE).removeAll(syncResourceNames);\n+            propByRes.get(ResourceOperation.CREATE).removeAll(syncResourceNames);\n         }\n \n-        return createTasks(user, password, wfResult.getResult().getValue(), false, propByRes);\n+        return createTasks(attributable, password, enable, false, propByRes);\n     }\n \n     /**\n      * Performs update on each resource associated to the user excluding the specified into 'resourceNames' parameter.\n      *\n-     * @param user to be propagated.\n-     * @param enable whether user must be enabled or not.\n+     * @param user to be propagated\n+     * @param enable whether user must be enabled or not\n      * @param syncResourceNames external resource names not to be considered for propagation. Use this during sync and\n-     * disable/enable actions limited to the external resources only.\n+     * disable/enable actions limited to the external resources only\n      * @return list of propagation tasks\n-     * @throws NotFoundException if userId is not found\n+     * @throws NotFoundException if user is not found\n      */\n-    public List<PropagationTask> getUpdateTaskIds(final SyncopeUser user, final Boolean enable,\n+    public List<PropagationTask> getUserUpdateTaskIds(final SyncopeUser user, final Boolean enable,\n             final Set<String> syncResourceNames)\n             throws NotFoundException {\n \n-        return getUpdateTaskIds(user, // SyncopeUser to be updated on external resources\n+        return getUpdateTaskIds(\n+                user, // SyncopeUser to be updated on external resources\n                 null, // no propagation by resources\n+                enable, // status to be propagated\n                 null, // no password\n                 null, // no virtual attributes to be managed\n                 null, // no virtual attributes to be managed\n-                enable, // status to be propagated\n                 syncResourceNames);\n     }\n \n@@ -189,78 +233,123 @@ public List<PropagationTask> getUpdateTaskIds(final SyncopeUser user, final Bool\n      *\n      * @param wfResult user to be propagated (and info associated), as per result from workflow.\n      * @return list of propagation tasks\n-     * @throws NotFoundException if userId is not found\n+     * @throws NotFoundException if user is not found\n+     * @throws UnauthorizedRoleException if caller doesn't own enough entitlements to administer the given user\n      */\n-    public List<PropagationTask> getUpdateTaskIds(final WorkflowResult<Map.Entry<Long, Boolean>> wfResult)\n-            throws NotFoundException {\n+    public List<PropagationTask> getUserUpdateTaskIds(final WorkflowResult<Map.Entry<Long, Boolean>> wfResult)\n+            throws NotFoundException, UnauthorizedRoleException {\n \n-        return getUpdateTaskIds(wfResult, null, null, null, null);\n+        return getUserUpdateTaskIds(wfResult, null, null, null, null);\n     }\n \n     /**\n      * Performs update on each resource associated to the user.\n      *\n-     * @param wfResult user to be propagated (and info associated), as per result from workflow.\n-     * @param password to be updated.\n-     * @param vAttrsToBeRemoved virtual attributes to be removed.\n-     * @param vAttrsToBeUpdated virtual attributes to be added.\n-     * @return list of propagation tasks.\n-     * @throws NotFoundException if userId is not found.\n+     * @param wfResult user to be propagated (and info associated), as per result from workflow\n+     * @param password to be updated\n+     * @param vAttrsToBeRemoved virtual attributes to be removed\n+     * @param vAttrsToBeUpdated virtual attributes to be added\n+     * @return list of propagation tasks\n+     * @throws NotFoundException if user is not found\n+     * @throws UnauthorizedRoleException if caller doesn't own enough entitlements to administer the given user\n      */\n-    public List<PropagationTask> getUpdateTaskIds(final WorkflowResult<Map.Entry<Long, Boolean>> wfResult,\n+    public List<PropagationTask> getUserUpdateTaskIds(final WorkflowResult<Map.Entry<Long, Boolean>> wfResult,\n             final String password, final Set<String> vAttrsToBeRemoved, final Set<AttributeMod> vAttrsToBeUpdated)\n-            throws NotFoundException {\n+            throws NotFoundException, UnauthorizedRoleException {\n \n-        return getUpdateTaskIds(wfResult, password, vAttrsToBeRemoved, vAttrsToBeUpdated, null);\n+        return getUserUpdateTaskIds(wfResult, password, vAttrsToBeRemoved, vAttrsToBeUpdated, null);\n     }\n \n     /**\n      * Performs update on each resource associated to the user.\n      *\n-     * @param wfResult user to be propagated (and info associated), as per result from workflow.\n-     * @param password to be updated.\n-     * @param vAttrsToBeRemoved virtual attributes to be removed.\n-     * @param vAttrsToBeUpdated virtual attributes to be added.\n+     * @param wfResult user to be propagated (and info associated), as per result from workflow\n+     * @param password to be updated\n+     * @param vAttrsToBeRemoved virtual attributes to be removed\n+     * @param vAttrsToBeUpdated virtual attributes to be added\n      * @param syncResourceNames external resource names not to be considered for propagation. Use this during sync and\n-     * disable/enable actions limited to the external resources only.\n-     * @return list of propagation tasks.\n-     * @throws NotFoundException if userId is not found.\n+     * disable/enable actions limited to the external resources only\n+     * @return list of propagation tasks\n+     * @throws NotFoundException if user is not found\n+     * @throws UnauthorizedRoleException if caller doesn't own enough entitlements to administer the given user\n      */\n-    public List<PropagationTask> getUpdateTaskIds(final WorkflowResult<Map.Entry<Long, Boolean>> wfResult,\n+    public List<PropagationTask> getUserUpdateTaskIds(final WorkflowResult<Map.Entry<Long, Boolean>> wfResult,\n             final String password, final Set<String> vAttrsToBeRemoved, final Set<AttributeMod> vAttrsToBeUpdated,\n             final Set<String> syncResourceNames)\n-            throws NotFoundException {\n+            throws NotFoundException, UnauthorizedRoleException {\n+\n+        SyncopeUser user = userDataBinder.getUserFromId(wfResult.getResult().getKey());\n+        return getUpdateTaskIds(user, password, wfResult.getResult().getValue(),\n+                vAttrsToBeRemoved, vAttrsToBeUpdated, wfResult.getPropByRes(), syncResourceNames);\n+    }\n \n-        SyncopeUser user = getSyncopeUser(wfResult.getResult().getKey());\n+    /**\n+     * Performs update on each resource associated to the role.\n+     *\n+     * @param wfResult role to be propagated (and info associated), as per result from workflow\n+     * @param vAttrsToBeRemoved virtual attributes to be removed\n+     * @param vAttrsToBeUpdated virtual attributes to be added\n+     * @return list of propagation tasks\n+     * @throws NotFoundException if role is not found\n+     * @throws UnauthorizedRoleException if caller doesn't own enough entitlements to administer the given role\n+     */\n+    public List<PropagationTask> getRoleUpdateTaskIds(final WorkflowResult<Long> wfResult,\n+            final Set<String> vAttrsToBeRemoved, final Set<AttributeMod> vAttrsToBeUpdated)\n+            throws NotFoundException, UnauthorizedRoleException {\n \n-        return getUpdateTaskIds(user, wfResult.getPropByRes(), password, vAttrsToBeRemoved, vAttrsToBeUpdated, wfResult.\n-                getResult().getValue(), syncResourceNames);\n+        return getRoleUpdateTaskIds(wfResult, vAttrsToBeRemoved, vAttrsToBeUpdated, null);\n     }\n \n-    private List<PropagationTask> getUpdateTaskIds(final SyncopeUser user, final PropagationByResource propByRes,\n-            final String password, final Set<String> vAttrsToBeRemoved, final Set<AttributeMod> vAttrsToBeUpdated,\n-            final Boolean enable, final Set<String> syncResourceNames)\n+    /**\n+     * Performs update on each resource associated to the role.\n+     *\n+     * @param wfResult role to be propagated (and info associated), as per result from workflow\n+     * @param vAttrsToBeRemoved virtual attributes to be removed\n+     * @param vAttrsToBeUpdated virtual attributes to be added\n+     * @param syncResourceNames external resource names not to be considered for propagation. Use this during sync and\n+     * disable/enable actions limited to the external resources only\n+     * @return list of propagation tasks\n+     * @throws NotFoundException if role is not found\n+     * @throws UnauthorizedRoleException if caller doesn't own enough entitlements to administer the given role\n+     */\n+    public List<PropagationTask> getRoleUpdateTaskIds(final WorkflowResult<Long> wfResult,\n+            final Set<String> vAttrsToBeRemoved, final Set<AttributeMod> vAttrsToBeUpdated,\n+            final Set<String> syncResourceNames)\n+            throws NotFoundException, UnauthorizedRoleException {\n+\n+        SyncopeRole role = roleDataBinder.getRoleFromId(wfResult.getResult());\n+        return getUpdateTaskIds(role, null, null,\n+                vAttrsToBeRemoved, vAttrsToBeUpdated, wfResult.getPropByRes(), syncResourceNames);\n+    }\n+\n+    protected List<PropagationTask> getUpdateTaskIds(final AbstractAttributable attributable,\n+            final String password, final Boolean enable,\n+            final Set<String> vAttrsToBeRemoved, final Set<AttributeMod> vAttrsToBeUpdated,\n+            final PropagationByResource propByRes, final Set<String> syncResourceNames)\n             throws NotFoundException {\n \n-        PropagationByResource localPropByRes = userDataBinder.fillVirtual(user, vAttrsToBeRemoved == null\n+        AbstractAttributableDataBinder binder = attributable instanceof SyncopeUser\n+                ? userDataBinder : roleDataBinder;\n+\n+        PropagationByResource localPropByRes = binder.fillVirtual(attributable, vAttrsToBeRemoved == null\n                 ? Collections.EMPTY_SET\n                 : vAttrsToBeRemoved, vAttrsToBeUpdated == null\n                 ? Collections.EMPTY_SET\n-                : vAttrsToBeUpdated, AttributableUtil.getInstance(AttributableType.USER));\n+                : vAttrsToBeUpdated, AttributableUtil.getInstance(attributable));\n \n-        if (propByRes != null && !propByRes.isEmpty()) {\n-            localPropByRes.merge(propByRes);\n+        if (propByRes == null || propByRes.isEmpty()) {\n+            localPropByRes.addAll(ResourceOperation.UPDATE, attributable.getResourceNames());\n         } else {\n-            localPropByRes.addAll(PropagationOperation.UPDATE, user.getResourceNames());\n+            localPropByRes.merge(propByRes);\n         }\n \n         if (syncResourceNames != null) {\n-            localPropByRes.get(PropagationOperation.CREATE).removeAll(syncResourceNames);\n-            localPropByRes.get(PropagationOperation.UPDATE).removeAll(syncResourceNames);\n-            localPropByRes.get(PropagationOperation.DELETE).removeAll(syncResourceNames);\n+            localPropByRes.get(ResourceOperation.CREATE).removeAll(syncResourceNames);\n+            localPropByRes.get(ResourceOperation.UPDATE).removeAll(syncResourceNames);\n+            localPropByRes.get(ResourceOperation.DELETE).removeAll(syncResourceNames);\n         }\n \n-        return createTasks(user, password, enable, false, localPropByRes);\n+        return createTasks(attributable, password, enable, false, localPropByRes);\n     }\n \n     /**\n@@ -271,11 +360,12 @@ private List<PropagationTask> getUpdateTaskIds(final SyncopeUser user, final Pro\n      * @param userId to be deleted\n      * @return list of propagation tasks\n      * @throws NotFoundException if user is not found\n+     * @throws UnauthorizedRoleException if caller doesn't own enough entitlements to administer the given user\n      */\n-    public List<PropagationTask> getDeleteTaskIds(final Long userId)\n-            throws NotFoundException {\n+    public List<PropagationTask> getUserDeleteTaskIds(final Long userId)\n+            throws NotFoundException, UnauthorizedRoleException {\n \n-        return getDeleteTaskIds(userId, null);\n+        return getUserDeleteTaskIds(userId, null);\n     }\n \n     /**\n@@ -287,69 +377,118 @@ public List<PropagationTask> getDeleteTaskIds(final Long userId)\n      * @param syncResourceName name of external resource performing sync, hence not to be considered for propagation\n      * @return list of propagation tasks\n      * @throws NotFoundException if user is not found\n+     * @throws UnauthorizedRoleException if caller doesn't own enough entitlements to administer the given user\n      */\n-    public List<PropagationTask> getDeleteTaskIds(final Long userId, final String syncResourceName)\n-            throws NotFoundException {\n+    public List<PropagationTask> getUserDeleteTaskIds(final Long userId, final String syncResourceName)\n+            throws NotFoundException, UnauthorizedRoleException {\n \n-        SyncopeUser user = getSyncopeUser(userId);\n+        SyncopeUser user = userDataBinder.getUserFromId(userId);\n+        return getDeleteTaskIds(user, syncResourceName);\n+    }\n+\n+    /**\n+     * Perform delete on each resource associated to the role. It is possible to ask for a mandatory provisioning for\n+     * some resources specifying a set of resource names. Exceptions won't be ignored and the process will be stopped if\n+     * the creation fails onto a mandatory resource.\n+     *\n+     * @param roleId to be deleted\n+     * @return list of propagation tasks\n+     * @throws NotFoundException if role is not found\n+     * @throws UnauthorizedRoleException if caller doesn't own enough entitlements to administer the given role\n+     */\n+    public List<PropagationTask> getRoleDeleteTaskIds(final Long roleId)\n+            throws NotFoundException, UnauthorizedRoleException {\n+\n+        return getRoleDeleteTaskIds(roleId, null);\n+    }\n+\n+    /**\n+     * Perform delete on each resource associated to the user. It is possible to ask for a mandatory provisioning for\n+     * some resources specifying a set of resource names. Exceptions won't be ignored and the process will be stopped if\n+     * the creation fails onto a mandatory resource.\n+     *\n+     * @param roleId to be deleted\n+     * @param syncResourceName name of external resource performing sync, hence not to be considered for propagation\n+     * @return list of propagation tasks\n+     * @throws NotFoundException if role is not found\n+     * @throws UnauthorizedRoleException if caller doesn't own enough entitlements to administer the given role\n+     */\n+    public List<PropagationTask> getRoleDeleteTaskIds(final Long roleId, final String syncResourceName)\n+            throws NotFoundException, UnauthorizedRoleException {\n+\n+        SyncopeRole role = roleDataBinder.getRoleFromId(roleId);\n+        return getDeleteTaskIds(role, syncResourceName);\n+    }\n+\n+    protected List<PropagationTask> getDeleteTaskIds(final AbstractAttributable attributable,\n+            final String syncResourceName) {\n \n         final PropagationByResource propByRes = new PropagationByResource();\n-        propByRes.set(PropagationOperation.DELETE, user.getResourceNames());\n+        propByRes.set(ResourceOperation.DELETE, attributable.getResourceNames());\n         if (syncResourceName != null) {\n-            propByRes.get(PropagationOperation.DELETE).remove(syncResourceName);\n+            propByRes.get(ResourceOperation.DELETE).remove(syncResourceName);\n         }\n-\n-        return createTasks(user, null, false, true, propByRes);\n+        return createTasks(attributable, null, false, true, propByRes);\n     }\n \n     /**\n-     * Prepare an attribute for sending to a connector instance.\n+     * Prepare an attribute to be sent to a connector instance.\n      *\n-     * @param mapping schema mapping for the given attribute\n-     * @param user given user\n+     * @param <T> user / role\n+     * @param mapItem mapping item for the given attribute\n+     * @param subject given user\n      * @param password clear-text password\n      * @return account link + prepared attribute\n      * @throws ClassNotFoundException if schema type for given mapping does not exists in current class loader\n      */\n-    private Map.Entry<String, Attribute> prepareAttribute(final SchemaMapping mapping, final SyncopeUser user,\n-            final String password)\n+    protected <T extends AbstractAttributable> Map.Entry<String, Attribute> prepareAttribute(\n+            final AbstractMappingItem mapItem, final T subject, final String password)\n             throws ClassNotFoundException {\n \n         final List<AbstractAttributable> attributables = new ArrayList<AbstractAttributable>();\n \n-        switch (mapping.getIntMappingType().getAttributableType()) {\n+        switch (mapItem.getIntMappingType().getAttributableType()) {\n             case USER:\n-                attributables.addAll(Collections.singleton(user));\n+                if (subject instanceof SyncopeUser) {\n+                    attributables.add(subject);\n+                }\n                 break;\n+\n             case ROLE:\n-                final List<Membership> memberships = user.getMemberships();\n-                for (Membership membership : memberships) {\n-                    attributables.add(membership.getSyncopeRole());\n+                if (subject instanceof SyncopeUser) {\n+                    attributables.addAll(((SyncopeUser) subject).getRoles());\n+                }\n+                if (subject instanceof SyncopeRole) {\n+                    attributables.add(subject);\n                 }\n                 break;\n+\n             case MEMBERSHIP:\n-                attributables.addAll(user.getMemberships());\n+                if (subject instanceof SyncopeUser) {\n+                    attributables.addAll(((SyncopeUser) subject).getMemberships());\n+                }\n                 break;\n+\n             default:\n         }\n \n         final Entry<AbstractSchema, List<AbstractAttrValue>> entry =\n-                SchemaMappingUtil.getIntValues(mapping, attributables, password, schemaDAO);\n+                MappingUtil.getIntValues(mapItem, attributables, password, schemaDAO);\n \n         final List<AbstractAttrValue> values = entry.getValue();\n         final AbstractSchema schema = entry.getKey();\n         final SchemaType schemaType = schema == null ? SchemaType.String : schema.getType();\n \n-        final String extAttrName = SchemaMappingUtil.getExtAttrName(mapping);\n+        final String extAttrName = mapItem.getExtAttrName();\n \n         LOG.debug(\"Define mapping for: \"\n                 + \"\\n* ExtAttrName \" + extAttrName\n-                + \"\\n* is accountId \" + mapping.isAccountid()\n-                + \"\\n* is password \" + (mapping.isPassword() || mapping.getIntMappingType().equals(\n-                IntMappingType.Password))\n-                + \"\\n* mandatory condition \" + mapping.getMandatoryCondition()\n-                + \"\\n* Schema \" + mapping.getIntAttrName()\n-                + \"\\n* IntMappingType \" + mapping.getIntMappingType().toString()\n+                + \"\\n* is accountId \" + mapItem.isAccountid()\n+                + \"\\n* is password \"\n+                + (mapItem.isPassword() || mapItem.getIntMappingType().equals(IntMappingType.Password))\n+                + \"\\n* mandatory condition \" + mapItem.getMandatoryCondition()\n+                + \"\\n* Schema \" + mapItem.getIntAttrName()\n+                + \"\\n* IntMappingType \" + mapItem.getIntMappingType().toString()\n                 + \"\\n* ClassType \" + schemaType.getClassName()\n                 + \"\\n* Values \" + values);\n \n@@ -363,49 +502,52 @@ private Map.Entry<String, Attribute> prepareAttribute(final SchemaMapping mappin\n             }\n         }\n \n-        Map.Entry<String, Attribute> res;\n+        Map.Entry<String, Attribute> result;\n \n-        if (mapping.isAccountid()) {\n-            res = new DefaultMapEntry(objValues.iterator().next().toString(), null);\n-        } else if (mapping.isPassword()) {\n-            res = new DefaultMapEntry(null,\n+        if (mapItem.isAccountid()) {\n+            result = new DefaultMapEntry(objValues.iterator().next().toString(), null);\n+        } else if (mapItem.isPassword()) {\n+            result = new DefaultMapEntry(null,\n                     AttributeBuilder.buildPassword(objValues.iterator().next().toString().toCharArray()));\n         } else {\n             if (schema != null && schema.isMultivalue()) {\n-                res = new DefaultMapEntry(null, AttributeBuilder.build(extAttrName, objValues));\n+                result = new DefaultMapEntry(null, AttributeBuilder.build(extAttrName, objValues));\n             } else {\n-                res = new DefaultMapEntry(null, objValues.isEmpty()\n+                result = new DefaultMapEntry(null, objValues.isEmpty()\n                         ? AttributeBuilder.build(extAttrName)\n                         : AttributeBuilder.build(extAttrName, objValues.iterator().next()));\n             }\n         }\n \n-        return res;\n+        return result;\n     }\n \n     /**\n      * Prepare attributes for sending to a connector instance.\n      *\n-     * @param user given user\n+     * @param <T> user / role\n+     * @param subject given user / role\n      * @param password clear-text password\n      * @param enable whether user must be enabled or not\n      * @param resource target resource\n+     * @param attrUtil attributable util to get info about subject\n      * @return account link + prepared attributes\n      */\n-    private Map.Entry<String, Set<Attribute>> prepareAttributes(final SyncopeUser user, final String password,\n-            final Boolean enable, final ExternalResource resource) {\n+    protected <T extends AbstractAttributable> Map.Entry<String, Set<Attribute>> prepareAttributes(final T subject,\n+            final String password, final Boolean enable, final ExternalResource resource,\n+            final AttributableUtil attrUtil) {\n \n         LOG.debug(\"Preparing resource attributes for {} on resource {} with attributes {}\",\n-                new Object[]{user, resource, user.getAttributes()});\n+                new Object[]{subject, resource, subject.getAttributes()});\n \n         Set<Attribute> attributes = new HashSet<Attribute>();\n         String accountId = null;\n \n-        for (SchemaMapping mapping : resource.getMappings()) {\n-            LOG.debug(\"Processing schema {}\", SchemaMappingUtil.getIntAttrName(mapping));\n+        for (AbstractMappingItem mapping : attrUtil.getMappingItems(resource)) {\n+            LOG.debug(\"Processing schema {}\", mapping.getIntAttrName());\n \n             try {\n-                Map.Entry<String, Attribute> preparedAttribute = prepareAttribute(mapping, user, password);\n+                Map.Entry<String, Attribute> preparedAttribute = prepareAttribute(mapping, subject, password);\n \n                 if (preparedAttribute.getKey() != null) {\n                     accountId = preparedAttribute.getKey();\n@@ -425,26 +567,25 @@ private Map.Entry<String, Set<Attribute>> prepareAttributes(final SyncopeUser us\n \n                         attributes.add(AttributeBuilder.build(preparedAttribute.getValue().getName(), values));\n                     }\n-\n                 }\n             } catch (Exception e) {\n-                LOG.debug(\"Attribute '{}' processing failed\", SchemaMappingUtil.getIntAttrName(mapping), e);\n+                LOG.debug(\"Attribute '{}' processing failed\", mapping.getIntAttrName(), e);\n             }\n         }\n \n-        if (StringUtils.isNotBlank(accountId)) {\n+        if (StringUtils.isBlank(accountId)) {\n             // LOG error but avoid to throw exception: leave it to the external resource\n             LOG.error(\"Missing accountId for '{}': \", resource.getName());\n         }\n \n         // Evaluate AccountLink expression\n         String evalAccountLink = null;\n-        if (StringUtils.isNotBlank(resource.getAccountLink())) {\n+        if (StringUtils.isNotBlank(attrUtil.getAccountLink(resource))) {\n             final JexlContext jexlContext = new MapContext();\n-            jexlUtil.addFieldsToContext(user, jexlContext);\n-            jexlUtil.addAttrsToContext(user.getAttributes(), jexlContext);\n-            jexlUtil.addDerAttrsToContext(user.getDerivedAttributes(), user.getAttributes(), jexlContext);\n-            evalAccountLink = jexlUtil.evaluate(resource.getAccountLink(), jexlContext);\n+            jexlUtil.addFieldsToContext(subject, jexlContext);\n+            jexlUtil.addAttrsToContext(subject.getAttributes(), jexlContext);\n+            jexlUtil.addDerAttrsToContext(subject.getDerivedAttributes(), subject.getAttributes(), jexlContext);\n+            evalAccountLink = jexlUtil.evaluate(attrUtil.getAccountLink(resource), jexlContext);\n         }\n \n         // If AccountLink evaluates to an empty string, just use the provided AccountId as Name(),\n@@ -471,41 +612,47 @@ private Map.Entry<String, Set<Attribute>> prepareAttributes(final SyncopeUser us\n     /**\n      * Create propagation tasks.\n      *\n-     * @param user user to be provisioned\n+     * @param <T> user / role\n+     * @param subject user / role to be provisioned\n      * @param password cleartext password to be provisioned\n      * @param enable whether user must be enabled or not\n-     * @param deleteOnResource whether user must be deleted anyway from external resource or not\n+     * @param deleteOnResource whether user / role must be deleted anyway from external resource or not\n      * @param propByRes operation to be performed per resource\n      * @return list of propagation tasks created\n      */\n-    protected List<PropagationTask> createTasks(final SyncopeUser user, final String password, final Boolean enable,\n-            final boolean deleteOnResource, final PropagationByResource propByRes) {\n+    protected <T extends AbstractAttributable> List<PropagationTask> createTasks(final T subject,\n+            final String password, final Boolean enable, final boolean deleteOnResource,\n+            final PropagationByResource propByRes) {\n+\n+        LOG.debug(\"Provisioning subject {}:\\n{}\", subject, propByRes);\n \n-        LOG.debug(\"Provisioning with user {}:\\n{}\", user, propByRes);\n+        AttributableUtil attrUtil = AttributableUtil.getInstance(subject);\n \n         // Avoid duplicates - see javadoc\n         propByRes.purge();\n         LOG.debug(\"After purge: {}\", propByRes);\n \n         final List<PropagationTask> tasks = new ArrayList<PropagationTask>();\n \n-        for (PropagationOperation operation : PropagationOperation.values()) {\n+        for (ResourceOperation operation : ResourceOperation.values()) {\n             for (String resourceName : propByRes.get(operation)) {\n                 final ExternalResource resource = resourceDAO.find(resourceName);\n                 if (resource == null) {\n                     LOG.error(\"Invalid resource name specified: {}, ignoring...\", resourceName);\n                 } else {\n                     PropagationTask task = new PropagationTask();\n                     task.setResource(resource);\n+                    task.setObjectClassName(connObjectUtil.fromAttributable(subject).getObjectClassValue());\n+                    task.setSubjectType(AttributableUtil.getInstance(subject).getType());\n                     if (!deleteOnResource) {\n-                        task.setSyncopeUser(user);\n+                        task.setSubjectId(subject.getId());\n                     }\n                     task.setPropagationOperation(operation);\n                     task.setPropagationMode(resource.getPropagationMode());\n                     task.setOldAccountId(propByRes.getOldAccountId(resource.getName()));\n \n                     Map.Entry<String, Set<Attribute>> preparedAttrs =\n-                            prepareAttributes(user, password, enable, resource);\n+                            prepareAttributes(subject, password, enable, resource, attrUtil);\n                     task.setAccountId(preparedAttrs.getKey());\n                     task.setAttributes(preparedAttrs.getValue());\n "},{"sha":"e6443184fda57369d306a6c723487418c29c5973","filename":"core/src/main/java/org/apache/syncope/core/report/UserReportlet.java","status":"modified","additions":25,"deletions":17,"changes":42,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Freport%2FUserReportlet.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Freport%2FUserReportlet.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Freport%2FUserReportlet.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -22,7 +22,6 @@\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n-import org.springframework.beans.factory.annotation.Autowired;\n import org.apache.syncope.client.report.UserReportletConf;\n import org.apache.syncope.client.report.UserReportletConf.Feature;\n import org.apache.syncope.client.to.AbstractAttributableTO;\n@@ -31,21 +30,24 @@\n import org.apache.syncope.client.to.UserTO;\n import org.apache.syncope.core.persistence.beans.membership.Membership;\n import org.apache.syncope.core.persistence.beans.user.SyncopeUser;\n+import org.apache.syncope.core.persistence.dao.AttributableSearchDAO;\n import org.apache.syncope.core.persistence.dao.EntitlementDAO;\n import org.apache.syncope.core.persistence.dao.UserDAO;\n-import org.apache.syncope.core.persistence.dao.UserSearchDAO;\n+import static org.apache.syncope.core.report.ReportXMLConst.*;\n import org.apache.syncope.core.rest.data.RoleDataBinder;\n import org.apache.syncope.core.rest.data.UserDataBinder;\n-import static org.apache.syncope.core.report.ReportXMLConst.*;\n+import org.apache.syncope.core.util.AttributableUtil;\n import org.apache.syncope.core.util.EntitlementUtil;\n+import org.apache.syncope.types.AttributableType;\n+import org.springframework.beans.factory.annotation.Autowired;\n import org.xml.sax.ContentHandler;\n import org.xml.sax.SAXException;\n import org.xml.sax.helpers.AttributesImpl;\n \n @ReportletConfClass(UserReportletConf.class)\n public class UserReportlet extends AbstractReportlet<UserReportletConf> {\n \n-    private final static int PAGE_SIZE = 10;\n+    private static final int PAGE_SIZE = 10;\n \n     @Autowired\n     private EntitlementDAO entitlementDAO;\n@@ -54,7 +56,7 @@ public class UserReportlet extends AbstractReportlet<UserReportletConf> {\n     private UserDAO userDAO;\n \n     @Autowired\n-    private UserSearchDAO searchDAO;\n+    private AttributableSearchDAO searchDAO;\n \n     @Autowired\n     private UserDataBinder userDataBinder;\n@@ -63,19 +65,26 @@ public class UserReportlet extends AbstractReportlet<UserReportletConf> {\n     private RoleDataBinder roleDataBinder;\n \n     private List<SyncopeUser> getPagedUsers(final int page) {\n-        Set<Long> adminRoleIds = EntitlementUtil.getRoleIds(entitlementDAO.findAll());\n+        final Set<Long> adminRoleIds = EntitlementUtil.getRoleIds(entitlementDAO.findAll());\n \n-        return conf.getMatchingCond() == null\n-                ? userDAO.findAll(adminRoleIds, page, PAGE_SIZE)\n-                : searchDAO.search(adminRoleIds, conf.getMatchingCond(), page, PAGE_SIZE);\n+        final List<SyncopeUser> result;\n+        if (conf.getMatchingCond() == null) {\n+            result = userDAO.findAll(adminRoleIds, page, PAGE_SIZE);\n+        } else {\n+            result = searchDAO.search(adminRoleIds, conf.getMatchingCond(), page, PAGE_SIZE,\n+                    AttributableUtil.getInstance(AttributableType.USER));\n+        }\n+\n+        return result;\n     }\n \n     private int count() {\n         Set<Long> adminRoleIds = EntitlementUtil.getRoleIds(entitlementDAO.findAll());\n \n         return conf.getMatchingCond() == null\n                 ? userDAO.count(adminRoleIds)\n-                : searchDAO.count(adminRoleIds, conf.getMatchingCond());\n+                : searchDAO.count(adminRoleIds, conf.getMatchingCond(),\n+                AttributableUtil.getInstance(AttributableType.USER));\n     }\n \n     private void doExtractResources(final ContentHandler handler, final AbstractAttributableTO attributableTO)\n@@ -122,8 +131,8 @@ private void doExtractAttributes(final ContentHandler handler, final AbstractAtt\n                         handler.endElement(\"\", \"\", \"value\");\n                     }\n                 } else {\n-                    LOG.debug(\"{} not found for {}[{}]\", new Object[] { attrName,\n-                            attributableTO.getClass().getSimpleName(), attributableTO.getId() });\n+                    LOG.debug(\"{} not found for {}[{}]\", new Object[]{attrName,\n+                                attributableTO.getClass().getSimpleName(), attributableTO.getId()});\n                 }\n \n                 handler.endElement(\"\", \"\", \"attribute\");\n@@ -148,8 +157,8 @@ private void doExtractAttributes(final ContentHandler handler, final AbstractAtt\n                         handler.endElement(\"\", \"\", \"value\");\n                     }\n                 } else {\n-                    LOG.debug(\"{} not found for {}[{}]\", new Object[] { attrName,\n-                            attributableTO.getClass().getSimpleName(), attributableTO.getId() });\n+                    LOG.debug(\"{} not found for {}[{}]\", new Object[]{attrName,\n+                                attributableTO.getClass().getSimpleName(), attributableTO.getId()});\n                 }\n \n                 handler.endElement(\"\", \"\", \"derivedAttribute\");\n@@ -174,8 +183,8 @@ private void doExtractAttributes(final ContentHandler handler, final AbstractAtt\n                         handler.endElement(\"\", \"\", \"value\");\n                     }\n                 } else {\n-                    LOG.debug(\"{} not found for {}[{}]\", new Object[] { attrName,\n-                            attributableTO.getClass().getSimpleName(), attributableTO.getId() });\n+                    LOG.debug(\"{} not found for {}[{}]\", new Object[]{attrName,\n+                                attributableTO.getClass().getSimpleName(), attributableTO.getId()});\n                 }\n \n                 handler.endElement(\"\", \"\", \"virtualAttribute\");\n@@ -302,7 +311,6 @@ private void doExtract(final ContentHandler handler, final List<SyncopeUser> use\n \n     @Override\n     protected void doExtract(final ContentHandler handler) throws SAXException, ReportException {\n-\n         for (int i = 1; i <= (count() / PAGE_SIZE) + 1; i++) {\n             doExtract(handler, getPagedUsers(i));\n         }"},{"sha":"2f205b9f0fe5ca608e5f797bebe3082d393f701f","filename":"core/src/main/java/org/apache/syncope/core/rest/controller/ResourceController.java","status":"modified","additions":12,"deletions":33,"changes":45,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Frest%2Fcontroller%2FResourceController.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Frest%2Fcontroller%2FResourceController.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Frest%2Fcontroller%2FResourceController.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -18,28 +18,26 @@\n  */\n package org.apache.syncope.core.rest.controller;\n \n-import java.util.ArrayList;\n import java.util.List;\n import java.util.Set;\n import javax.servlet.http.HttpServletResponse;\n import org.apache.syncope.client.to.ConnObjectTO;\n import org.apache.syncope.client.to.ResourceTO;\n-import org.apache.syncope.client.to.SchemaMappingTO;\n import org.apache.syncope.client.validation.SyncopeClientCompositeErrorException;\n import org.apache.syncope.core.audit.AuditManager;\n import org.apache.syncope.core.init.ConnInstanceLoader;\n import org.apache.syncope.core.init.ImplementationClassNamesLoader;\n import org.apache.syncope.core.persistence.beans.ConnInstance;\n import org.apache.syncope.core.persistence.beans.ExternalResource;\n-import org.apache.syncope.core.persistence.beans.role.SyncopeRole;\n import org.apache.syncope.core.persistence.dao.ConnInstanceDAO;\n import org.apache.syncope.core.persistence.dao.ResourceDAO;\n-import org.apache.syncope.core.persistence.dao.RoleDAO;\n import org.apache.syncope.core.propagation.ConnectorFacadeProxy;\n import org.apache.syncope.core.rest.data.ResourceDataBinder;\n+import org.apache.syncope.core.util.AttributableUtil;\n import org.apache.syncope.core.util.ConnBundleManager;\n import org.apache.syncope.core.util.ConnObjectUtil;\n import org.apache.syncope.core.util.NotFoundException;\n+import org.apache.syncope.types.AttributableType;\n import org.apache.syncope.types.AuditElements;\n import org.apache.syncope.types.AuditElements.Category;\n import org.apache.syncope.types.AuditElements.ResourceSubCategory;\n@@ -74,9 +72,6 @@ public class ResourceController extends AbstractController {\n     @Autowired\n     private ConnInstanceDAO connInstanceDAO;\n \n-    @Autowired\n-    private RoleDAO roleDAO;\n-\n     @Autowired\n     private ResourceDataBinder binder;\n \n@@ -205,44 +200,28 @@ public List<ResourceTO> list(@RequestParam(required = false, value = \"connInstan\n         return result;\n     }\n \n-    @PreAuthorize(\"hasRole('RESOURCE_READ')\")\n-    @RequestMapping(method = RequestMethod.GET, value = \"/{roleId}/mappings\")\n-    public List<SchemaMappingTO> getRoleResourcesMapping(@PathVariable(\"roleId\") final Long roleId)\n-            throws NotFoundException {\n-\n-        SyncopeRole role = roleDAO.find(roleId);\n-        if (role == null) {\n-            throw new NotFoundException(\"Role '\" + roleId + \"'\");\n-        }\n-\n-        List<SchemaMappingTO> roleMappings = new ArrayList<SchemaMappingTO>();\n-\n-        for (ExternalResource resource : role.getResources()) {\n-            roleMappings.addAll(binder.getSchemaMappingTOs(resource.getMappings()));\n-        }\n-\n-        auditManager.audit(Category.resource, ResourceSubCategory.getRoleResourcesMapping, Result.success,\n-                \"Found \" + roleMappings.size() + \" mappings for role \" + roleId);\n-\n-        return roleMappings;\n-    }\n-\n     @PreAuthorize(\"hasRole('RESOURCE_GETOBJECT')\")\n     @Transactional(readOnly = true)\n-    @RequestMapping(method = RequestMethod.GET, value = \"/{resourceName}/read/{objectId}\")\n+    @RequestMapping(method = RequestMethod.GET, value = \"/{resourceName}/read/{type}/{objectId}\")\n     public ConnObjectTO getObject(@PathVariable(\"resourceName\") final String resourceName,\n-            @PathVariable(\"objectId\") final String objectId)\n+            @PathVariable(\"type\") final AttributableType type, @PathVariable(\"objectId\") final String objectId)\n             throws NotFoundException {\n \n         ExternalResource resource = resourceDAO.find(resourceName);\n         if (resource == null) {\n             throw new NotFoundException(\"Resource '\" + resourceName + \"'\");\n         }\n \n+        if (AttributableType.MEMBERSHIP == type) {\n+        }\n+\n+        AttributableUtil attrUtil = AttributableUtil.getInstance(type);\n+        ObjectClass objectClass = AttributableType.USER == type ? ObjectClass.ACCOUNT : ObjectClass.GROUP;\n+\n         final ConnectorFacadeProxy connector = connLoader.getConnector(resource);\n \n-        final ConnectorObject connectorObject = connector.getObject(ObjectClass.ACCOUNT, new Uid(objectId), connector.\n-                getOperationOptions(resource));\n+        final ConnectorObject connectorObject = connector.getObject(objectClass, new Uid(objectId),\n+                connector.getOperationOptions(attrUtil.getMappingItems(resource)));\n \n         if (connectorObject == null) {\n             throw new NotFoundException(\"Object \" + objectId + \" not found on resource \" + resourceName);"},{"sha":"ff4a319d8f765a48a59e9c47e8c327bd0b31ec17","filename":"core/src/main/java/org/apache/syncope/core/rest/controller/RoleController.java","status":"modified","additions":170,"deletions":33,"changes":203,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Frest%2Fcontroller%2FRoleController.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Frest%2Fcontroller%2FRoleController.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Frest%2Fcontroller%2FRoleController.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -19,20 +19,35 @@\n package org.apache.syncope.core.rest.controller;\n \n import java.util.ArrayList;\n+import java.util.Collections;\n import java.util.List;\n import java.util.Set;\n import javax.servlet.http.HttpServletResponse;\n import org.apache.syncope.client.mod.RoleMod;\n+import org.apache.syncope.client.search.NodeCond;\n+import org.apache.syncope.client.to.PropagationTO;\n import org.apache.syncope.client.to.RoleTO;\n-import org.apache.syncope.client.validation.SyncopeClientCompositeErrorException;\n import org.apache.syncope.core.audit.AuditManager;\n+import org.apache.syncope.core.persistence.beans.PropagationTask;\n import org.apache.syncope.core.persistence.beans.role.SyncopeRole;\n import org.apache.syncope.core.persistence.beans.user.SyncopeUser;\n+import org.apache.syncope.core.persistence.dao.AttributableSearchDAO;\n import org.apache.syncope.core.persistence.dao.RoleDAO;\n import org.apache.syncope.core.persistence.dao.UserDAO;\n+import org.apache.syncope.core.propagation.DefaultPropagationHandler;\n+import org.apache.syncope.core.propagation.PropagationException;\n+import org.apache.syncope.core.propagation.PropagationManager;\n+import org.apache.syncope.core.propagation.PropagationTaskExecutor;\n import org.apache.syncope.core.rest.data.RoleDataBinder;\n+import org.apache.syncope.core.util.AttributableUtil;\n+import org.apache.syncope.core.util.ConnObjectUtil;\n import org.apache.syncope.core.util.EntitlementUtil;\n import org.apache.syncope.core.util.NotFoundException;\n+import org.apache.syncope.core.workflow.WorkflowException;\n+import org.apache.syncope.core.workflow.WorkflowResult;\n+import org.apache.syncope.core.workflow.role.RoleWorkflowAdapter;\n+import org.apache.syncope.types.AttributableType;\n+import org.apache.syncope.types.AuditElements;\n import org.apache.syncope.types.AuditElements.Category;\n import org.apache.syncope.types.AuditElements.Result;\n import org.apache.syncope.types.AuditElements.RoleSubCategory;\n@@ -45,6 +60,7 @@\n import org.springframework.web.bind.annotation.RequestBody;\n import org.springframework.web.bind.annotation.RequestMapping;\n import org.springframework.web.bind.annotation.RequestMethod;\n+import org.springframework.web.servlet.ModelAndView;\n \n @Controller\n @RequestMapping(\"/role\")\n@@ -59,16 +75,34 @@ public class RoleController extends AbstractController {\n     @Autowired\n     private UserDAO userDAO;\n \n+    @Autowired\n+    private AttributableSearchDAO searchDAO;\n+\n     @Autowired\n     private RoleDataBinder dataBinder;\n \n+    @Autowired\n+    private RoleWorkflowAdapter rwfAdapter;\n+\n+    @Autowired\n+    private PropagationManager propagationManager;\n+\n+    @Autowired\n+    private PropagationTaskExecutor taskExecutor;\n+\n+    /**\n+     * ConnectorObject util.\n+     */\n+    @Autowired\n+    private ConnObjectUtil connObjectUtil;\n+\n     @PreAuthorize(\"hasRole('ROLE_READ')\")\n     @RequestMapping(method = RequestMethod.GET, value = \"/read/{roleId}\")\n     @Transactional(readOnly = true)\n     public RoleTO read(@PathVariable(\"roleId\") final Long roleId)\n             throws NotFoundException, UnauthorizedRoleException {\n \n-        SyncopeRole role = dataBinder.getSyncopeRole(roleId);\n+        SyncopeRole role = dataBinder.getRoleFromId(roleId);\n \n         Set<Long> allowedRoleIds = EntitlementUtil.getRoleIds(EntitlementUtil.getOwnedEntitlementNames());\n         if (!allowedRoleIds.contains(role.getId())) {\n@@ -87,16 +121,22 @@ public RoleTO read(@PathVariable(\"roleId\") final Long roleId)\n     public RoleTO selfRead(@PathVariable(\"roleId\") final Long roleId)\n             throws NotFoundException, UnauthorizedRoleException {\n \n-        SyncopeRole role = dataBinder.getSyncopeRole(roleId);\n+        // Explicit search instead of using dataBinder.getRoleFromId() in order to bypass auth checks - will do here\n+        SyncopeRole role = roleDAO.find(roleId);\n+        if (role == null) {\n+            throw new NotFoundException(\"Role \" + roleId);\n+        }\n \n+        Set<Long> ownedRoleIds;\n         SyncopeUser authUser = userDAO.find(SecurityContextHolder.getContext().getAuthentication().getName());\n         if (authUser == null) {\n-            throw new NotFoundException(\"Authenticated user \"\n-                    + SecurityContextHolder.getContext().getAuthentication().getName());\n+            ownedRoleIds = Collections.EMPTY_SET;\n+        } else {\n+            ownedRoleIds = authUser.getRoleIds();\n         }\n \n         Set<Long> allowedRoleIds = EntitlementUtil.getRoleIds(EntitlementUtil.getOwnedEntitlementNames());\n-        allowedRoleIds.addAll(authUser.getRoleIds());\n+        allowedRoleIds.addAll(ownedRoleIds);\n         if (!allowedRoleIds.contains(role.getId())) {\n             throw new UnauthorizedRoleException(role.getId());\n         }\n@@ -113,7 +153,7 @@ public RoleTO selfRead(@PathVariable(\"roleId\") final Long roleId)\n     public RoleTO parent(@PathVariable(\"roleId\") final Long roleId)\n             throws NotFoundException, UnauthorizedRoleException {\n \n-        SyncopeRole role = dataBinder.getSyncopeRole(roleId);\n+        SyncopeRole role = dataBinder.getRoleFromId(roleId);\n \n         Set<Long> allowedRoleIds = EntitlementUtil.getRoleIds(EntitlementUtil.getOwnedEntitlementNames());\n         if (role.getParent() != null && !allowedRoleIds.contains(role.getParent().getId())) {\n@@ -135,8 +175,10 @@ public RoleTO parent(@PathVariable(\"roleId\") final Long roleId)\n     @PreAuthorize(\"hasRole('ROLE_READ')\")\n     @RequestMapping(method = RequestMethod.GET, value = \"/children/{roleId}\")\n     @Transactional(readOnly = true)\n-    public List<RoleTO> children(@PathVariable(\"roleId\") final Long roleId) throws NotFoundException {\n-        SyncopeRole role = dataBinder.getSyncopeRole(roleId);\n+    public List<RoleTO> children(@PathVariable(\"roleId\") final Long roleId)\n+            throws NotFoundException, UnauthorizedRoleException {\n+\n+        SyncopeRole role = dataBinder.getRoleFromId(roleId);\n \n         Set<Long> allowedRoleIds = EntitlementUtil.getRoleIds(EntitlementUtil.getOwnedEntitlementNames());\n \n@@ -154,10 +196,82 @@ public List<RoleTO> children(@PathVariable(\"roleId\") final Long roleId) throws N\n         return childrenTOs;\n     }\n \n+    @PreAuthorize(\"hasRole('ROLE_READ')\")\n+    @RequestMapping(method = RequestMethod.POST, value = \"/search\")\n+    @Transactional(readOnly = true, rollbackFor = {Throwable.class})\n+    public List<RoleTO> search(@RequestBody final NodeCond searchCondition)\n+            throws InvalidSearchConditionException {\n+\n+        LOG.debug(\"Role search called with condition {}\", searchCondition);\n+\n+        if (!searchCondition.checkValidity()) {\n+            LOG.error(\"Invalid search condition: {}\", searchCondition);\n+            throw new InvalidSearchConditionException();\n+        }\n+\n+        List<SyncopeRole> matchingRoles = searchDAO.search(EntitlementUtil.getRoleIds(EntitlementUtil.\n+                getOwnedEntitlementNames()), searchCondition, AttributableUtil.getInstance(AttributableType.ROLE));\n+        List<RoleTO> result = new ArrayList<RoleTO>(matchingRoles.size());\n+        for (SyncopeRole role : matchingRoles) {\n+            result.add(dataBinder.getRoleTO(role));\n+        }\n+\n+        auditManager.audit(Category.role, AuditElements.RoleSubCategory.read, Result.success,\n+                \"Successfully searched for roles: \" + result.size());\n+\n+        return result;\n+    }\n+\n+    @PreAuthorize(\"hasRole('ROLE_READ')\")\n+    @RequestMapping(method = RequestMethod.POST, value = \"/search/{page}/{size}\")\n+    @Transactional(readOnly = true, rollbackFor = {Throwable.class})\n+    public List<RoleTO> search(@RequestBody final NodeCond searchCondition, @PathVariable(\"page\") final int page,\n+            @PathVariable(\"size\") final int size)\n+            throws InvalidSearchConditionException {\n+\n+        LOG.debug(\"Role search called with condition {}\", searchCondition);\n+\n+        if (!searchCondition.checkValidity()) {\n+            LOG.error(\"Invalid search condition: {}\", searchCondition);\n+            throw new InvalidSearchConditionException();\n+        }\n+\n+        final List<SyncopeRole> matchingRoles = searchDAO.search(EntitlementUtil.getRoleIds(EntitlementUtil.\n+                getOwnedEntitlementNames()), searchCondition, page, size,\n+                AttributableUtil.getInstance(AttributableType.ROLE));\n+\n+        final List<RoleTO> result = new ArrayList<RoleTO>(matchingRoles.size());\n+        for (SyncopeRole role : matchingRoles) {\n+            result.add(dataBinder.getRoleTO(role));\n+        }\n+\n+        auditManager.audit(Category.role, AuditElements.RoleSubCategory.read, Result.success,\n+                \"Successfully searched for roles (page=\" + page + \", size=\" + size + \"): \" + result.size());\n+\n+        return result;\n+    }\n+\n+    @PreAuthorize(\"hasRole('ROLE_READ')\")\n+    @RequestMapping(method = RequestMethod.POST, value = \"/search/count\")\n+    @Transactional(readOnly = true, rollbackFor = {Throwable.class})\n+    public ModelAndView searchCount(@RequestBody final NodeCond searchCondition)\n+            throws InvalidSearchConditionException {\n+\n+        if (!searchCondition.checkValidity()) {\n+            LOG.error(\"Invalid search condition: {}\", searchCondition);\n+            throw new InvalidSearchConditionException();\n+        }\n+\n+        final Set<Long> adminRoleIds = EntitlementUtil.getRoleIds(EntitlementUtil.getOwnedEntitlementNames());\n+        return new ModelAndView().addObject(searchDAO.count(adminRoleIds, searchCondition,\n+                AttributableUtil.getInstance(AttributableType.ROLE)));\n+    }\n+\n     @RequestMapping(method = RequestMethod.GET, value = \"/list\")\n     @Transactional(readOnly = true)\n     public List<RoleTO> list() {\n         List<SyncopeRole> roles = roleDAO.findAll();\n+\n         List<RoleTO> roleTOs = new ArrayList<RoleTO>(roles.size());\n         for (SyncopeRole role : roles) {\n             roleTOs.add(dataBinder.getRoleTO(role));\n@@ -172,7 +286,7 @@ public List<RoleTO> list() {\n     @PreAuthorize(\"hasRole('ROLE_CREATE')\")\n     @RequestMapping(method = RequestMethod.POST, value = \"/create\")\n     public RoleTO create(final HttpServletResponse response, @RequestBody final RoleTO roleTO)\n-            throws SyncopeClientCompositeErrorException, UnauthorizedRoleException {\n+            throws UnauthorizedRoleException, WorkflowException, NotFoundException, PropagationException {\n \n         LOG.debug(\"Role create called with parameters {}\", roleTO);\n \n@@ -181,53 +295,76 @@ public RoleTO create(final HttpServletResponse response, @RequestBody final Role\n             throw new UnauthorizedRoleException(roleTO.getParent());\n         }\n \n-        SyncopeRole role = roleDAO.save(dataBinder.create(roleTO));\n+        WorkflowResult<Long> created = rwfAdapter.create(roleTO);\n+\n+        EntitlementUtil.extendAuthContext(created.getResult());\n+\n+        List<PropagationTask> tasks = propagationManager.getRoleCreateTaskIds(created, roleTO.getVirtualAttributes());\n+\n+        final List<PropagationTO> propagations = new ArrayList<PropagationTO>();\n+        taskExecutor.execute(tasks, new DefaultPropagationHandler(connObjectUtil, propagations));\n+\n+        final RoleTO savedTO = dataBinder.getRoleTO(created.getResult());\n+        savedTO.setPropagationTOs(propagations);\n+\n+        LOG.debug(\"About to return created role\\n{}\", savedTO);\n \n         auditManager.audit(Category.role, RoleSubCategory.create, Result.success,\n-                \"Successfully created role: \" + role.getId());\n+                \"Successfully created role: \" + savedTO.getId());\n \n         response.setStatus(HttpServletResponse.SC_CREATED);\n-        return dataBinder.getRoleTO(role);\n+        return savedTO;\n     }\n \n     @PreAuthorize(\"hasRole('ROLE_UPDATE')\")\n     @RequestMapping(method = RequestMethod.POST, value = \"/update\")\n-    public RoleTO update(@RequestBody final RoleMod roleMod) throws NotFoundException, UnauthorizedRoleException {\n-        LOG.debug(\"Role update called with parameter {}\", roleMod);\n+    public RoleTO update(@RequestBody final RoleMod roleMod)\n+            throws NotFoundException, UnauthorizedRoleException, WorkflowException, PropagationException {\n \n-        SyncopeRole role = dataBinder.getSyncopeRole(roleMod.getId());\n+        LOG.debug(\"Role update called with {}\", roleMod);\n \n-        Set<Long> allowedRoleIds = EntitlementUtil.getRoleIds(EntitlementUtil.getOwnedEntitlementNames());\n-        if (!allowedRoleIds.contains(role.getId())) {\n-            throw new UnauthorizedRoleException(role.getId());\n-        }\n+        SyncopeRole role = dataBinder.getRoleFromId(roleMod.getId());\n \n-        dataBinder.update(role, roleMod);\n-        role = roleDAO.save(role);\n+        WorkflowResult<Long> updated = rwfAdapter.update(roleMod);\n+\n+        List<PropagationTask> tasks = propagationManager.getRoleUpdateTaskIds(updated,\n+                roleMod.getVirtualAttributesToBeRemoved(), roleMod.getVirtualAttributesToBeUpdated());\n+\n+        final List<PropagationTO> propagations = new ArrayList<PropagationTO>();\n+        taskExecutor.execute(tasks, new DefaultPropagationHandler(connObjectUtil, propagations));\n+\n+        final RoleTO updatedTO = dataBinder.getRoleTO(updated.getResult());\n+        updatedTO.setPropagationTOs(propagations);\n \n         auditManager.audit(Category.role, RoleSubCategory.update, Result.success,\n                 \"Successfully updated role: \" + role.getId());\n \n-        return dataBinder.getRoleTO(role);\n+        LOG.debug(\"About to return updated role\\n{}\", updatedTO);\n+\n+        return updatedTO;\n     }\n \n     @PreAuthorize(\"hasRole('ROLE_DELETE')\")\n     @RequestMapping(method = RequestMethod.GET, value = \"/delete/{roleId}\")\n-    public RoleTO delete(@PathVariable(\"roleId\") final Long roleId) throws NotFoundException, UnauthorizedRoleException {\n-        SyncopeRole role = dataBinder.getSyncopeRole(roleId);\n+    public RoleTO delete(@PathVariable(\"roleId\") final Long roleId)\n+            throws NotFoundException, UnauthorizedRoleException, WorkflowException, PropagationException {\n \n-        RoleTO roleToDelete = dataBinder.getRoleTO(role);\n+        SyncopeRole role = dataBinder.getRoleFromId(roleId);\n \n-        Set<Long> allowedRoleIds = EntitlementUtil.getRoleIds(EntitlementUtil.getOwnedEntitlementNames());\n-        if (!allowedRoleIds.contains(role.getId())) {\n-            throw new UnauthorizedRoleException(role.getId());\n-        }\n+        RoleTO roleTO = dataBinder.getRoleTO(role);\n+\n+        List<PropagationTask> tasks = propagationManager.getRoleDeleteTaskIds(roleId);\n+\n+        final List<PropagationTO> propagations = new ArrayList<PropagationTO>();\n+        taskExecutor.execute(tasks, new DefaultPropagationHandler(connObjectUtil, propagations));\n+\n+        rwfAdapter.delete(roleId);\n \n         auditManager.audit(Category.role, RoleSubCategory.delete, Result.success,\n-                \"Successfully deleted role: \" + role.getId());\n+                \"Successfully deleted role: \" + roleId);\n \n-        roleDAO.delete(roleId);\n+        LOG.debug(\"Role successfully deleted: {}\", roleId);\n \n-        return roleToDelete;\n+        return roleTO;\n     }\n }"},{"sha":"534904bdf5791c00f07857fd522f91b0b2e1e435","filename":"core/src/main/java/org/apache/syncope/core/rest/controller/UserController.java","status":"modified","additions":49,"deletions":101,"changes":150,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Frest%2Fcontroller%2FUserController.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Frest%2Fcontroller%2FUserController.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Frest%2Fcontroller%2FUserController.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -36,24 +36,24 @@\n import org.apache.syncope.core.notification.NotificationManager;\n import org.apache.syncope.core.persistence.beans.PropagationTask;\n import org.apache.syncope.core.persistence.beans.user.SyncopeUser;\n+import org.apache.syncope.core.persistence.dao.AttributableSearchDAO;\n import org.apache.syncope.core.persistence.dao.UserDAO;\n-import org.apache.syncope.core.persistence.dao.UserSearchDAO;\n+import org.apache.syncope.core.propagation.DefaultPropagationHandler;\n import org.apache.syncope.core.propagation.PropagationException;\n-import org.apache.syncope.core.propagation.PropagationHandler;\n import org.apache.syncope.core.propagation.PropagationManager;\n import org.apache.syncope.core.propagation.PropagationTaskExecutor;\n import org.apache.syncope.core.rest.data.UserDataBinder;\n+import org.apache.syncope.core.util.AttributableUtil;\n import org.apache.syncope.core.util.ConnObjectUtil;\n import org.apache.syncope.core.util.EntitlementUtil;\n import org.apache.syncope.core.util.NotFoundException;\n-import org.apache.syncope.core.workflow.UserWorkflowAdapter;\n import org.apache.syncope.core.workflow.WorkflowException;\n import org.apache.syncope.core.workflow.WorkflowResult;\n+import org.apache.syncope.core.workflow.user.UserWorkflowAdapter;\n+import org.apache.syncope.types.AttributableType;\n import org.apache.syncope.types.AuditElements.Category;\n import org.apache.syncope.types.AuditElements.Result;\n import org.apache.syncope.types.AuditElements.UserSubCategory;\n-import org.apache.syncope.types.PropagationTaskExecStatus;\n-import org.identityconnectors.framework.common.objects.ConnectorObject;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.springframework.beans.factory.annotation.Autowired;\n@@ -90,13 +90,13 @@ public class UserController {\n     private UserDAO userDAO;\n \n     @Autowired\n-    private UserSearchDAO searchDAO;\n+    private AttributableSearchDAO searchDAO;\n \n     @Autowired\n     private UserDataBinder dataBinder;\n \n     @Autowired\n-    private UserWorkflowAdapter wfAdapter;\n+    private UserWorkflowAdapter uwfAdapter;\n \n     @Autowired\n     private PropagationManager propagationManager;\n@@ -146,9 +146,9 @@ public ModelAndView searchCount(@RequestBody final NodeCond searchCondition)\n             throw new InvalidSearchConditionException();\n         }\n \n-        Set<Long> adminRoleIds = EntitlementUtil.getRoleIds(EntitlementUtil.getOwnedEntitlementNames());\n-\n-        return new ModelAndView().addObject(searchDAO.count(adminRoleIds, searchCondition));\n+        final Set<Long> adminRoleIds = EntitlementUtil.getRoleIds(EntitlementUtil.getOwnedEntitlementNames());\n+        return new ModelAndView().addObject(searchDAO.count(adminRoleIds, searchCondition,\n+                AttributableUtil.getInstance(AttributableType.USER)));\n     }\n \n     @PreAuthorize(\"hasRole('USER_LIST')\")\n@@ -159,7 +159,6 @@ public List<UserTO> list() {\n                 userDAO.findAll(EntitlementUtil.getRoleIds(EntitlementUtil.getOwnedEntitlementNames()));\n \n         List<UserTO> userTOs = new ArrayList<UserTO>(users.size());\n-\n         for (SyncopeUser user : users) {\n             userTOs.add(dataBinder.getUserTO(user));\n         }\n@@ -243,7 +242,7 @@ public List<UserTO> search(@RequestBody final NodeCond searchCondition)\n         }\n \n         List<SyncopeUser> matchingUsers = searchDAO.search(EntitlementUtil.getRoleIds(EntitlementUtil.\n-                getOwnedEntitlementNames()), searchCondition);\n+                getOwnedEntitlementNames()), searchCondition, AttributableUtil.getInstance(AttributableType.USER));\n         List<UserTO> result = new ArrayList<UserTO>(matchingUsers.size());\n         for (SyncopeUser user : matchingUsers) {\n             result.add(dataBinder.getUserTO(user));\n@@ -270,7 +269,8 @@ public List<UserTO> search(@RequestBody final NodeCond searchCondition, @PathVar\n         }\n \n         final List<SyncopeUser> matchingUsers = searchDAO.search(EntitlementUtil.getRoleIds(EntitlementUtil.\n-                getOwnedEntitlementNames()), searchCondition, page, size);\n+                getOwnedEntitlementNames()), searchCondition, page, size,\n+                AttributableUtil.getInstance(AttributableType.USER));\n \n         final List<UserTO> result = new ArrayList<UserTO>(matchingUsers.size());\n         for (SyncopeUser user : matchingUsers) {\n@@ -301,34 +301,13 @@ public UserTO create(final HttpServletResponse response, @RequestBody final User\n             throw new UnauthorizedRoleException(requestRoleIds);\n         }\n \n-        WorkflowResult<Map.Entry<Long, Boolean>> created = wfAdapter.create(userTO);\n+        WorkflowResult<Map.Entry<Long, Boolean>> created = uwfAdapter.create(userTO);\n \n-        List<PropagationTask> tasks = propagationManager.getCreateTaskIds(\n+        List<PropagationTask> tasks = propagationManager.getUserCreateTaskIds(\n                 created, userTO.getPassword(), userTO.getVirtualAttributes());\n \n         final List<PropagationTO> propagations = new ArrayList<PropagationTO>();\n-\n-        taskExecutor.execute(tasks, new PropagationHandler() {\n-\n-            @Override\n-            public void handle(final String resourceName, final PropagationTaskExecStatus executionStatus,\n-                    final ConnectorObject beforeObj, final ConnectorObject afterObj) {\n-\n-                final PropagationTO propagation = new PropagationTO();\n-                propagation.setResourceName(resourceName);\n-                propagation.setStatus(executionStatus);\n-\n-                if (beforeObj != null) {\n-                    propagation.setBeforeObj(connObjectUtil.getConnObjectTO(beforeObj));\n-                }\n-\n-                if (afterObj != null) {\n-                    propagation.setAfterObj(connObjectUtil.getConnObjectTO(afterObj));\n-                }\n-\n-                propagations.add(propagation);\n-            }\n-        });\n+        taskExecutor.execute(tasks, new DefaultPropagationHandler(connObjectUtil, propagations));\n \n         notificationManager.createTasks(created.getResult().getKey(), created.getPerformedTasks());\n \n@@ -351,34 +330,13 @@ public UserTO update(@RequestBody final UserMod userMod)\n \n         LOG.debug(\"User update called with {}\", userMod);\n \n-        WorkflowResult<Map.Entry<Long, Boolean>> updated = wfAdapter.update(userMod);\n+        WorkflowResult<Map.Entry<Long, Boolean>> updated = uwfAdapter.update(userMod);\n \n-        List<PropagationTask> tasks = propagationManager.getUpdateTaskIds(updated, userMod.getPassword(), userMod.\n-                getVirtualAttributesToBeRemoved(), userMod.getVirtualAttributesToBeUpdated(), null);\n+        List<PropagationTask> tasks = propagationManager.getUserUpdateTaskIds(updated, userMod.getPassword(),\n+                userMod.getVirtualAttributesToBeRemoved(), userMod.getVirtualAttributesToBeUpdated());\n \n         final List<PropagationTO> propagations = new ArrayList<PropagationTO>();\n-\n-        taskExecutor.execute(tasks, new PropagationHandler() {\n-\n-            @Override\n-            public void handle(final String resourceName, final PropagationTaskExecStatus executionStatus,\n-                    final ConnectorObject before, final ConnectorObject after) {\n-\n-                final PropagationTO propagation = new PropagationTO();\n-                propagation.setResourceName(resourceName);\n-                propagation.setStatus(executionStatus);\n-\n-                if (before != null) {\n-                    propagation.setBeforeObj(connObjectUtil.getConnObjectTO(before));\n-                }\n-\n-                if (after != null) {\n-                    propagation.setAfterObj(connObjectUtil.getConnObjectTO(after));\n-                }\n-\n-                propagations.add(propagation);\n-            }\n-        });\n+        taskExecutor.execute(tasks, new DefaultPropagationHandler(connObjectUtil, propagations));\n \n         notificationManager.createTasks(updated.getResult().getKey(), updated.getPerformedTasks());\n \n@@ -540,10 +498,12 @@ public UserTO executeWorkflow(@RequestBody final UserTO userTO, @PathVariable(\"t\n \n         LOG.debug(\"About to execute {} on {}\", taskId, userTO.getId());\n \n-        WorkflowResult<Long> updated = wfAdapter.execute(userTO, taskId);\n+        WorkflowResult<Long> updated = uwfAdapter.execute(userTO, taskId);\n \n-        List<PropagationTask> tasks = propagationManager.getUpdateTaskIds(new WorkflowResult<Map.Entry<Long, Boolean>>(\n-                new DefaultMapEntry(updated.getResult(), null), updated.getPropByRes(), updated.getPerformedTasks()));\n+        List<PropagationTask> tasks = propagationManager.getUserUpdateTaskIds(\n+                new WorkflowResult<Map.Entry<Long, Boolean>>(new DefaultMapEntry(updated.getResult(), null),\n+                updated.getPropByRes(),\n+                updated.getPerformedTasks()));\n \n         taskExecutor.execute(tasks);\n \n@@ -563,7 +523,7 @@ public UserTO executeWorkflow(@RequestBody final UserTO userTO, @PathVariable(\"t\n     @RequestMapping(method = RequestMethod.GET, value = \"/workflow/form/list\")\n     @Transactional(readOnly = true, rollbackFor = {Throwable.class})\n     public List<WorkflowFormTO> getForms() {\n-        List<WorkflowFormTO> forms = wfAdapter.getForms();\n+        List<WorkflowFormTO> forms = uwfAdapter.getForms();\n \n         auditManager.audit(Category.user, UserSubCategory.getForms, Result.success,\n                 \"Successfully list workflow forms: \" + forms.size());\n@@ -578,7 +538,7 @@ public WorkflowFormTO getFormForUser(@PathVariable(\"userId\") final Long userId)\n             throws UnauthorizedRoleException, NotFoundException, WorkflowException {\n \n         SyncopeUser user = dataBinder.getUserFromId(userId);\n-        WorkflowFormTO result = wfAdapter.getForm(user.getWorkflowId());\n+        WorkflowFormTO result = uwfAdapter.getForm(user.getWorkflowId());\n \n         auditManager.audit(Category.user, UserSubCategory.getFormForUser, Result.success,\n                 \"Successfully read workflow form for user: \" + user.getUsername());\n@@ -592,7 +552,7 @@ public WorkflowFormTO getFormForUser(@PathVariable(\"userId\") final Long userId)\n     public WorkflowFormTO claimForm(@PathVariable(\"taskId\") final String taskId)\n             throws NotFoundException, WorkflowException {\n \n-        WorkflowFormTO result = wfAdapter.claimForm(taskId,\n+        WorkflowFormTO result = uwfAdapter.claimForm(taskId,\n                 SecurityContextHolder.getContext().getAuthentication().getName());\n \n         auditManager.audit(Category.user, UserSubCategory.claimForm, Result.success,\n@@ -609,12 +569,18 @@ public UserTO submitForm(@RequestBody final WorkflowFormTO form)\n \n         LOG.debug(\"About to process form {}\", form);\n \n-        WorkflowResult<Map.Entry<Long, String>> updated = wfAdapter.submitForm(form, SecurityContextHolder.getContext().\n+        WorkflowResult<Map.Entry<Long, String>> updated = uwfAdapter.submitForm(form,\n+                SecurityContextHolder.getContext().\n                 getAuthentication().getName());\n \n-        List<PropagationTask> tasks = propagationManager.getUpdateTaskIds(new WorkflowResult<Map.Entry<Long, Boolean>>(\n-                new DefaultMapEntry(updated.getResult().getKey(), Boolean.TRUE), updated.getPropByRes(), updated.\n-                getPerformedTasks()), updated.getResult().getValue(), null, null);\n+        List<PropagationTask> tasks = propagationManager.getUserUpdateTaskIds(\n+                new WorkflowResult<Map.Entry<Long, Boolean>>(\n+                new DefaultMapEntry(updated.getResult().getKey(), Boolean.TRUE),\n+                updated.getPropByRes(),\n+                updated.getPerformedTasks()),\n+                updated.getResult().getValue(),\n+                null,\n+                null);\n         taskExecutor.execute(tasks);\n \n         final UserTO savedTO = dataBinder.getUserTO(updated.getResult().getKey());\n@@ -636,11 +602,11 @@ private UserTO setStatus(final SyncopeUser user, final String token, final Set<S\n         WorkflowResult<Long> updated;\n         if (performLocally) {\n             if (\"suspend\".equals(task)) {\n-                updated = wfAdapter.suspend(user.getId());\n+                updated = uwfAdapter.suspend(user.getId());\n             } else if (\"reactivate\".equals(task)) {\n-                updated = wfAdapter.reactivate(user.getId());\n+                updated = uwfAdapter.reactivate(user.getId());\n             } else {\n-                updated = wfAdapter.activate(user.getId(), token);\n+                updated = uwfAdapter.activate(user.getId(), token);\n             }\n         } else {\n             updated = new WorkflowResult<Long>(user.getId(), null, task);\n@@ -657,7 +623,7 @@ private UserTO setStatus(final SyncopeUser user, final String token, final Set<S\n             resources.addAll(user.getResourceNames());\n         }\n \n-        List<PropagationTask> tasks = propagationManager.getUpdateTaskIds(user, status, resources);\n+        List<PropagationTask> tasks = propagationManager.getUserUpdateTaskIds(user, status, resources);\n \n         taskExecutor.execute(tasks);\n         notificationManager.createTasks(updated.getResult(), updated.getPerformedTasks());\n@@ -676,42 +642,24 @@ protected UserTO doDelete(final Long userId)\n             throws NotFoundException, WorkflowException, PropagationException, UnauthorizedRoleException {\n         // Note here that we can only notify about \"delete\", not any other\n         // task defined in workflow process definition: this because this\n-        // information could only be available after wfAdapter.delete(), which\n+        // information could only be available after uwfAdapter.delete(), which\n         // will also effectively remove user from db, thus making virtually\n         // impossible by NotificationManager to fetch required user information\n         notificationManager.createTasks(userId, Collections.singleton(\"delete\"));\n \n-        List<PropagationTask> tasks = propagationManager.getDeleteTaskIds(userId);\n+        List<PropagationTask> tasks = propagationManager.getUserDeleteTaskIds(userId);\n \n         final UserTO userTO = new UserTO();\n         userTO.setId(userId);\n \n-        taskExecutor.execute(tasks, new PropagationHandler() {\n-\n-            @Override\n-            public void handle(final String resourceName, final PropagationTaskExecStatus executionStatus,\n-                    final ConnectorObject before, final ConnectorObject after) {\n-\n-                final PropagationTO propagation = new PropagationTO();\n-                propagation.setResourceName(resourceName);\n-                propagation.setStatus(executionStatus);\n-\n-                if (before != null) {\n-                    propagation.setBeforeObj(connObjectUtil.getConnObjectTO(before));\n-                }\n-\n-                if (after != null) {\n-                    propagation.setAfterObj(connObjectUtil.getConnObjectTO(after));\n-                }\n-\n-                userTO.addPropagationTO(propagation);\n-            }\n-        });\n+        final List<PropagationTO> propagations = new ArrayList<PropagationTO>();\n+        taskExecutor.execute(tasks, new DefaultPropagationHandler(connObjectUtil, propagations));\n+        userTO.setPropagationTOs(propagations);\n \n-        wfAdapter.delete(userId);\n+        uwfAdapter.delete(userId);\n \n         auditManager.audit(Category.user, UserSubCategory.delete, Result.success,\n-                \"Successfully deleted user: \" + userTO.getUsername());\n+                \"Successfully deleted user: \" + userId);\n \n         LOG.debug(\"User successfully deleted: {}\", userId);\n "},{"sha":"c933589f1e623d18dd721c32cf7aa01b2d5c2dee","filename":"core/src/main/java/org/apache/syncope/core/rest/controller/WorkflowController.java","status":"modified","additions":55,"deletions":17,"changes":72,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Frest%2Fcontroller%2FWorkflowController.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Frest%2Fcontroller%2FWorkflowController.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Frest%2Fcontroller%2FWorkflowController.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -22,8 +22,10 @@\n import org.apache.syncope.client.to.WorkflowDefinitionTO;\n import org.apache.syncope.core.audit.AuditManager;\n import org.apache.syncope.core.util.NotFoundException;\n-import org.apache.syncope.core.workflow.UserWorkflowAdapter;\n+import org.apache.syncope.core.workflow.WorkflowAdapter;\n import org.apache.syncope.core.workflow.WorkflowException;\n+import org.apache.syncope.core.workflow.role.RoleWorkflowAdapter;\n+import org.apache.syncope.core.workflow.user.UserWorkflowAdapter;\n import org.apache.syncope.types.AuditElements.Category;\n import org.apache.syncope.types.AuditElements.Result;\n import org.apache.syncope.types.AuditElements.WorkflowSubCategory;\n@@ -44,39 +46,75 @@ public class WorkflowController extends AbstractController {\n     private AuditManager auditManager;\n \n     @Autowired\n-    private UserWorkflowAdapter wfAdapter;\n+    private UserWorkflowAdapter uwfAdapter;\n \n-    @PreAuthorize(\"hasRole('WORKFLOW_DEF_READ')\")\n-    @RequestMapping(method = RequestMethod.GET, value = \"/definition\")\n-    @Transactional(readOnly = true)\n-    public WorkflowDefinitionTO getDefinition() throws WorkflowException {\n-        WorkflowDefinitionTO result = wfAdapter.getDefinition();\n+    @Autowired\n+    private RoleWorkflowAdapter rwfAdapter;\n+    private WorkflowDefinitionTO getDefinition(final WorkflowAdapter adapter) throws WorkflowException {\n+        WorkflowDefinitionTO result = adapter.getDefinition();\n \n         auditManager.audit(Category.workflow, WorkflowSubCategory.getDefinition, Result.success,\n-                \"Successfully got workflow definition\");\n+                \"Successfully read workflow definition\");\n \n         return result;\n     }\n \n-    @PreAuthorize(\"hasRole('WORKFLOW_DEF_UPDATE')\")\n-    @RequestMapping(method = RequestMethod.PUT, value = \"/definition\")\n-    public void updateDefinition(@RequestBody final WorkflowDefinitionTO definition)\n+    @PreAuthorize(\"hasRole('WORKFLOW_DEF_READ')\")\n+    @RequestMapping(method = RequestMethod.GET, value = \"/definition/user\")\n+    @Transactional(readOnly = true)\n+    public WorkflowDefinitionTO getUserDefinition() throws WorkflowException {\n+        return getDefinition(uwfAdapter);\n+    }\n+\n+    @PreAuthorize(\"hasRole('WORKFLOW_DEF_READ')\")\n+    @RequestMapping(method = RequestMethod.GET, value = \"/definition/role\")\n+    @Transactional(readOnly = true)\n+    public WorkflowDefinitionTO getRoleDefinition() throws WorkflowException {\n+        return getDefinition(rwfAdapter);\n+    }\n+\n+    private void updateDefinition(final WorkflowAdapter adapter, final WorkflowDefinitionTO definition)\n             throws NotFoundException, WorkflowException {\n \n-        wfAdapter.updateDefinition(definition);\n+        adapter.updateDefinition(definition);\n \n         auditManager.audit(Category.workflow, WorkflowSubCategory.updateDefinition, Result.success,\n                 \"Successfully updated workflow definition\");\n     }\n \n-    @PreAuthorize(\"hasRole('WORKFLOW_TASK_LIST')\")\n-    @RequestMapping(method = RequestMethod.GET, value = \"/tasks\")\n-    public ModelAndView getDefinedTasks() throws WorkflowException {\n-        List<String> definedTasks = wfAdapter.getDefinedTasks();\n+    @PreAuthorize(\"hasRole('WORKFLOW_DEF_UPDATE')\")\n+    @RequestMapping(method = RequestMethod.PUT, value = \"/definition/user\")\n+    public void updateUserDefinition(@RequestBody final WorkflowDefinitionTO definition)\n+            throws NotFoundException, WorkflowException {\n+        updateDefinition(uwfAdapter, definition);\n+    }\n+\n+    @PreAuthorize(\"hasRole('WORKFLOW_DEF_UPDATE')\")\n+    @RequestMapping(method = RequestMethod.PUT, value = \"/definition/role\")\n+    public void updateRoleDefinition(@RequestBody final WorkflowDefinitionTO definition)\n+            throws NotFoundException, WorkflowException {\n+\n+        updateDefinition(rwfAdapter, definition);\n+    }\n+\n+    private List<String> getDefinedTasks(final WorkflowAdapter adapter) throws WorkflowException {\n+        List<String> definedTasks = adapter.getDefinedTasks();\n \n         auditManager.audit(Category.workflow, WorkflowSubCategory.getDefinedTasks, Result.success,\n                 \"Successfully got the list of defined workflow tasks: \" + definedTasks.size());\n \n-        return new ModelAndView().addObject(definedTasks);\n+        return definedTasks;\n+    }\n+\n+    @PreAuthorize(\"hasRole('WORKFLOW_TASK_LIST')\")\n+    @RequestMapping(method = RequestMethod.GET, value = \"/tasks/user\")\n+    public ModelAndView getDefinedUserTasks() throws WorkflowException {\n+        return new ModelAndView().addObject(getDefinedTasks(uwfAdapter));\n+    }\n+\n+    @PreAuthorize(\"hasRole('WORKFLOW_TASK_LIST')\")\n+    @RequestMapping(method = RequestMethod.GET, value = \"/tasks/role\")\n+    public ModelAndView getDefinedRoleTasks() throws WorkflowException {\n+        return new ModelAndView().addObject(getDefinedTasks(rwfAdapter));\n     }\n }"},{"sha":"4d9e2fd084b53de44cfdbe6f0d93d0da153b7d32","filename":"core/src/main/java/org/apache/syncope/core/rest/data/AbstractAttributableDataBinder.java","status":"modified","additions":159,"deletions":185,"changes":344,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Frest%2Fdata%2FAbstractAttributableDataBinder.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Frest%2Fdata%2FAbstractAttributableDataBinder.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Frest%2Fdata%2FAbstractAttributableDataBinder.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -29,9 +29,6 @@\n import org.apache.commons.jexl2.JexlContext;\n import org.apache.commons.jexl2.MapContext;\n import org.apache.commons.lang.StringUtils;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-import org.springframework.beans.factory.annotation.Autowired;\n import org.apache.syncope.client.mod.AbstractAttributableMod;\n import org.apache.syncope.client.mod.AttributeMod;\n import org.apache.syncope.client.to.AbstractAttributableTO;\n@@ -43,11 +40,11 @@\n import org.apache.syncope.core.persistence.beans.AbstractAttributable;\n import org.apache.syncope.core.persistence.beans.AbstractDerAttr;\n import org.apache.syncope.core.persistence.beans.AbstractDerSchema;\n+import org.apache.syncope.core.persistence.beans.AbstractMappingItem;\n import org.apache.syncope.core.persistence.beans.AbstractSchema;\n import org.apache.syncope.core.persistence.beans.AbstractVirAttr;\n import org.apache.syncope.core.persistence.beans.AbstractVirSchema;\n import org.apache.syncope.core.persistence.beans.ExternalResource;\n-import org.apache.syncope.core.persistence.beans.SchemaMapping;\n import org.apache.syncope.core.persistence.dao.AttrDAO;\n import org.apache.syncope.core.persistence.dao.AttrValueDAO;\n import org.apache.syncope.core.persistence.dao.ConfDAO;\n@@ -64,10 +61,14 @@\n import org.apache.syncope.core.propagation.PropagationByResource;\n import org.apache.syncope.core.util.AttributableUtil;\n import org.apache.syncope.core.util.JexlUtil;\n+import org.apache.syncope.core.util.MappingUtil;\n import org.apache.syncope.types.AttributableType;\n import org.apache.syncope.types.IntMappingType;\n-import org.apache.syncope.types.PropagationOperation;\n+import org.apache.syncope.types.ResourceOperation;\n import org.apache.syncope.types.SyncopeClientExceptionType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n \n public abstract class AbstractAttributableDataBinder {\n \n@@ -119,7 +120,6 @@ public abstract class AbstractAttributableDataBinder {\n     private JexlUtil jexlUtil;\n \n     private <T extends AbstractSchema> T getSchema(final String schemaName, final Class<T> reference) {\n-\n         T schema = null;\n         if (StringUtils.isNotBlank(schemaName)) {\n             schema = schemaDAO.find(schemaName, reference);\n@@ -139,7 +139,6 @@ private <T extends AbstractSchema> T getSchema(final String schemaName, final Cl\n     }\n \n     private <T extends AbstractDerSchema> T getDerivedSchema(final String derSchemaName, final Class<T> reference) {\n-\n         T derivedSchema = null;\n         if (StringUtils.isNotBlank(derSchemaName)) {\n             derivedSchema = derSchemaDAO.find(derSchemaName, reference);\n@@ -152,7 +151,6 @@ private <T extends AbstractDerSchema> T getDerivedSchema(final String derSchemaN\n     }\n \n     private <T extends AbstractVirSchema> T getVirtualSchema(final String virSchemaName, final Class<T> reference) {\n-\n         T virtualSchema = null;\n         if (StringUtils.isNotBlank(virSchemaName)) {\n             virtualSchema = virSchemaDAO.find(virSchemaName, reference);\n@@ -167,7 +165,6 @@ private <T extends AbstractVirSchema> T getVirtualSchema(final String virSchemaN\n \n     private ExternalResource getResource(final String resourceName) {\n         ExternalResource resource = resourceDAO.find(resourceName);\n-\n         if (resource == null) {\n             LOG.debug(\"Ignoring invalid resource {} \", resourceName);\n         }\n@@ -196,7 +193,7 @@ protected void fillAttribute(final List<String> values, final AttributableUtil a\n                 } catch (ValidationException e) {\n                     LOG.error(\"Invalid value for attribute \" + schema.getName() + \": \" + value, e);\n \n-                    invalidValues.addElement(schema.getName() + \": \" + value \n+                    invalidValues.addElement(schema.getName() + \": \" + value\n                             + \" - \" + e.getMessage());\n                 }\n             }\n@@ -214,36 +211,37 @@ private boolean evaluateMandatoryCondition(final String mandatoryCondition,\n         return Boolean.parseBoolean(jexlUtil.evaluate(mandatoryCondition, jexlContext));\n     }\n \n-    private boolean evaluateMandatoryCondition(final ExternalResource resource, final AbstractAttributable attributable,\n-            final String intAttrName, final IntMappingType intMappingType) {\n+    private boolean evaluateMandatoryCondition(final AttributableUtil attrUtil, final ExternalResource resource,\n+            final AbstractAttributable attributable, final String intAttrName, final IntMappingType intMappingType) {\n \n         boolean result = false;\n \n-        final Set<SchemaMapping> mappings = resource.getMappings(intAttrName, intMappingType);\n-        for (Iterator<SchemaMapping> itor = mappings.iterator(); itor.hasNext() && !result;) {\n-            final SchemaMapping mapping = itor.next();\n+        final List<AbstractMappingItem> mappings = MappingUtil.getMatchingMappingItems(\n+                attrUtil.getMappingItems(resource), intAttrName, intMappingType);\n+        for (Iterator<AbstractMappingItem> itor = mappings.iterator(); itor.hasNext() && !result;) {\n+            final AbstractMappingItem mapping = itor.next();\n             result |= evaluateMandatoryCondition(mapping.getMandatoryCondition(), attributable);\n         }\n \n         return result;\n     }\n \n-    private boolean evaluateMandatoryCondition(final AbstractAttributable attributable, final String intAttrName,\n-            final IntMappingType intMappingType) {\n+    private boolean evaluateMandatoryCondition(final AttributableUtil attrUtil,\n+            final AbstractAttributable attributable, final String intAttrName, final IntMappingType intMappingType) {\n \n         boolean result = false;\n \n         for (Iterator<ExternalResource> itor = attributable.getResources().iterator(); itor.hasNext() && !result;) {\n             final ExternalResource resource = itor.next();\n             if (resource.isEnforceMandatoryCondition()) {\n-                result |= evaluateMandatoryCondition(resource, attributable, intAttrName, intMappingType);\n+                result |= evaluateMandatoryCondition(attrUtil, resource, attributable, intAttrName, intMappingType);\n             }\n         }\n \n         return result;\n     }\n \n-    private SyncopeClientException checkMandatory(final AttributableUtil attributableUtil,\n+    private SyncopeClientException checkMandatory(final AttributableUtil attrUtil,\n             final AbstractAttributable attributable) {\n \n         SyncopeClientException reqValMissing = new SyncopeClientException(\n@@ -252,31 +250,32 @@ private SyncopeClientException checkMandatory(final AttributableUtil attributabl\n         LOG.debug(\"Check mandatory constraint among resources {}\", attributable.getResources());\n \n         // Check if there is some mandatory schema defined for which no value has been provided\n-        for (AbstractSchema schema : schemaDAO.findAll(attributableUtil.schemaClass())) {\n+        for (AbstractSchema schema : schemaDAO.findAll(attrUtil.schemaClass())) {\n             if (attributable.getAttribute(schema.getName()) == null\n                     && !schema.isReadonly()\n                     && (evaluateMandatoryCondition(schema.getMandatoryCondition(), attributable)\n-                    || evaluateMandatoryCondition(attributable, schema.getName(), attributableUtil.intMappingType()))) {\n+                    || evaluateMandatoryCondition(attrUtil, attributable, schema.getName(),\n+                    attrUtil.intMappingType()))) {\n \n                 LOG.error(\"Mandatory schema \" + schema.getName() + \" not provided with values\");\n \n                 reqValMissing.addElement(schema.getName());\n             }\n         }\n-        for (AbstractDerSchema derSchema : derSchemaDAO.findAll(attributableUtil.derSchemaClass())) {\n+        for (AbstractDerSchema derSchema : derSchemaDAO.findAll(attrUtil.derSchemaClass())) {\n             if (attributable.getDerivedAttribute(derSchema.getName()) == null\n-                    && evaluateMandatoryCondition(\n-                    attributable, derSchema.getName(), attributableUtil.derIntMappingType())) {\n+                    && evaluateMandatoryCondition(attrUtil, attributable, derSchema.getName(),\n+                    attrUtil.derIntMappingType())) {\n \n                 LOG.error(\"Mandatory derived schema \" + derSchema.getName() + \" does not evaluate to any value\");\n \n                 reqValMissing.addElement(derSchema.getName());\n             }\n         }\n-        for (AbstractVirSchema virSchema : virSchemaDAO.findAll(attributableUtil.virSchemaClass())) {\n+        for (AbstractVirSchema virSchema : virSchemaDAO.findAll(attrUtil.virSchemaClass())) {\n             if (attributable.getAttribute(virSchema.getName()) == null\n-                    && evaluateMandatoryCondition(\n-                    attributable, virSchema.getName(), attributableUtil.virIntMappingType())) {\n+                    && evaluateMandatoryCondition(attrUtil, attributable, virSchema.getName(),\n+                    attrUtil.virIntMappingType())) {\n \n                 LOG.error(\"Mandatory virtual schema \" + virSchema.getName() + \" not provided with values\");\n \n@@ -289,35 +288,34 @@ && evaluateMandatoryCondition(\n \n     public PropagationByResource fillVirtual(final AbstractAttributable attributable,\n             final Set<String> vAttrsToBeRemoved, final Set<AttributeMod> vAttrsToBeUpdated,\n-            final AttributableUtil attributableUtil) {\n+            final AttributableUtil attrUtil) {\n \n         PropagationByResource propByRes = new PropagationByResource();\n \n         // 1. virtual attributes to be removed\n         for (String vAttrToBeRemoved : vAttrsToBeRemoved) {\n-            AbstractVirSchema virtualSchema = getVirtualSchema(vAttrToBeRemoved, attributableUtil.virSchemaClass());\n-\n+            AbstractVirSchema virtualSchema = getVirtualSchema(vAttrToBeRemoved, attrUtil.virSchemaClass());\n             if (virtualSchema != null) {\n                 AbstractVirAttr virAttr = attributable.getVirtualAttribute(virtualSchema.getName());\n-\n                 if (virAttr == null) {\n                     LOG.debug(\"No virtual attribute found for schema {}\", virtualSchema.getName());\n                 } else {\n                     attributable.removeVirtualAttribute(virAttr);\n                     virAttrDAO.delete(virAttr);\n                 }\n \n-                for (SchemaMapping mapping : resourceDAO.findAllMappings()) {\n-                    if (virtualSchema.getName().equals(mapping.getIntAttrName())\n-                            && mapping.getIntMappingType() == attributableUtil.virIntMappingType()\n-                            && mapping.getResource() != null\n-                            && attributable.getResources().contains(mapping.getResource())) {\n+                for (ExternalResource resource : resourceDAO.findAll()) {\n+                    for (AbstractMappingItem mapItem : attrUtil.getMappingItems(resource)) {\n+                        if (virtualSchema.getName().equals(mapItem.getIntAttrName())\n+                                && mapItem.getIntMappingType() == attrUtil.virIntMappingType()\n+                                && attributable.getResources().contains(resource)) {\n \n-                        propByRes.add(PropagationOperation.UPDATE, mapping.getResource().getName());\n+                            propByRes.add(ResourceOperation.UPDATE, resource.getName());\n \n-                        // TODO: using virtual attribute as AccountId must be avoided\n-                        if (mapping.isAccountid() && virAttr != null && !virAttr.getValues().isEmpty()) {\n-                            propByRes.addOldAccountId(mapping.getResource().getName(), virAttr.getValues().get(0));\n+                            // Using virtual attribute as AccountId must be avoided\n+                            if (mapItem.isAccountid() && virAttr != null && !virAttr.getValues().isEmpty()) {\n+                                propByRes.addOldAccountId(resource.getName(), virAttr.getValues().get(0));\n+                            }\n                         }\n                     }\n                 }\n@@ -328,36 +326,34 @@ public PropagationByResource fillVirtual(final AbstractAttributable attributable\n \n         // 2. virtual attributes to be updated\n         for (AttributeMod vAttrToBeUpdated : vAttrsToBeUpdated) {\n-            AbstractVirSchema virtualSchema = getVirtualSchema(vAttrToBeUpdated.getSchema(),\n-                    attributableUtil.virSchemaClass());\n-\n-            if (virtualSchema != null) {\n-                for (SchemaMapping mapping : resourceDAO.findAllMappings()) {\n-                    if (virtualSchema.getName().equals(mapping.getIntAttrName())\n-                            && mapping.getIntMappingType() == attributableUtil.virIntMappingType()\n-                            && mapping.getResource() != null\n-                            && attributable.getResources().contains(mapping.getResource())) {\n-\n-                        propByRes.add(PropagationOperation.UPDATE, mapping.getResource().getName());\n+            AbstractVirSchema virSchema = getVirtualSchema(vAttrToBeUpdated.getSchema(), attrUtil.virSchemaClass());\n+            if (virSchema != null) {\n+                for (ExternalResource resource : resourceDAO.findAll()) {\n+                    for (AbstractMappingItem mapItem : attrUtil.getMappingItems(resource)) {\n+                        if (virSchema.getName().equals(mapItem.getIntAttrName())\n+                                && mapItem.getIntMappingType() == attrUtil.virIntMappingType()\n+                                && attributable.getResources().contains(resource)) {\n+\n+                            propByRes.add(ResourceOperation.UPDATE, resource.getName());\n+                        }\n                     }\n                 }\n \n-                AbstractVirAttr virtualAttribute = attributable.getVirtualAttribute(virtualSchema.getName());\n-\n-                if (virtualAttribute == null) {\n-                    virtualAttribute = attributableUtil.newVirAttr();\n-                    virtualAttribute.setVirtualSchema(virtualSchema);\n-                    attributable.addVirtualAttribute(virtualAttribute);\n+                AbstractVirAttr virAttr = attributable.getVirtualAttribute(virSchema.getName());\n+                if (virAttr == null) {\n+                    virAttr = attrUtil.newVirAttr();\n+                    virAttr.setVirtualSchema(virSchema);\n+                    attributable.addVirtualAttribute(virAttr);\n                 }\n \n-                final List<String> values = new ArrayList<String>(virtualAttribute.getValues());\n+                final List<String> values = new ArrayList<String>(virAttr.getValues());\n                 values.removeAll(vAttrToBeUpdated.getValuesToBeRemoved());\n                 values.addAll(vAttrToBeUpdated.getValuesToBeAdded());\n \n-                virtualAttribute.setValues(values);\n+                virAttr.setValues(values);\n \n                 // Owner cannot be specified before otherwise a virtual attribute remove will be invalidated.\n-                virtualAttribute.setOwner(attributable);\n+                virAttr.setOwner(attributable);\n             }\n         }\n \n@@ -367,22 +363,19 @@ public PropagationByResource fillVirtual(final AbstractAttributable attributable\n     }\n \n     protected PropagationByResource fill(final AbstractAttributable attributable,\n-            final AbstractAttributableMod attributableMod, final AttributableUtil attributableUtil,\n-            final SyncopeClientCompositeErrorException compositeErrorException)\n+            final AbstractAttributableMod attributableMod, final AttributableUtil attrUtil,\n+            final SyncopeClientCompositeErrorException scce)\n             throws SyncopeClientCompositeErrorException {\n \n         PropagationByResource propByRes = new PropagationByResource();\n \n         SyncopeClientException invalidValues = new SyncopeClientException(SyncopeClientExceptionType.InvalidValues);\n \n         // 1. resources to be removed\n-        ExternalResource resource;\n         for (String resourceToBeRemoved : attributableMod.getResourcesToBeRemoved()) {\n-\n-            resource = getResource(resourceToBeRemoved);\n-\n+            ExternalResource resource = getResource(resourceToBeRemoved);\n             if (resource != null) {\n-                propByRes.add(PropagationOperation.DELETE, resource.getName());\n+                propByRes.add(ResourceOperation.DELETE, resource.getName());\n                 attributable.removeResource(resource);\n             }\n         }\n@@ -391,30 +384,20 @@ protected PropagationByResource fill(final AbstractAttributable attributable,\n \n         // 2. resources to be added\n         for (String resourceToBeAdded : attributableMod.getResourcesToBeAdded()) {\n-\n-            resource = getResource(resourceToBeAdded);\n-\n+            ExternalResource resource = getResource(resourceToBeAdded);\n             if (resource != null) {\n-                propByRes.add(PropagationOperation.CREATE, resource.getName());\n+                propByRes.add(ResourceOperation.CREATE, resource.getName());\n                 attributable.addResource(resource);\n             }\n         }\n \n         LOG.debug(\"Resources to be added:\\n{}\", propByRes);\n \n-        AbstractSchema schema;\n-        AbstractAttr attribute;\n-        AbstractDerSchema derivedSchema;\n-        AbstractDerAttr derivedAttribute;\n-\n         // 3. attributes to be removed\n         for (String attributeToBeRemoved : attributableMod.getAttributesToBeRemoved()) {\n-\n-            schema = getSchema(attributeToBeRemoved, attributableUtil.schemaClass());\n-\n+            AbstractSchema schema = getSchema(attributeToBeRemoved, attrUtil.schemaClass());\n             if (schema != null) {\n-                attribute = attributable.getAttribute(schema.getName());\n-\n+                AbstractAttr attribute = attributable.getAttribute(schema.getName());\n                 if (attribute == null) {\n                     LOG.debug(\"No attribute found for schema {}\", schema);\n                 } else {\n@@ -425,25 +408,28 @@ protected PropagationByResource fill(final AbstractAttributable attributable,\n                         }\n                     }\n \n-                    if (!schema.isUniqueConstraint() || (!attribute.getUniqueValue().getStringValue().equals(newValue))) {\n+                    if (!schema.isUniqueConstraint()\n+                            || (!attribute.getUniqueValue().getStringValue().equals(newValue))) {\n \n                         attributable.removeAttribute(attribute);\n-                        attrDAO.delete(attribute.getId(), attributableUtil.attrClass());\n+                        attrDAO.delete(attribute.getId(), attrUtil.attrClass());\n                     }\n                 }\n \n-                for (SchemaMapping mapping : resourceDAO.findAllMappings()) {\n-                    if (schema.getName().equals(mapping.getIntAttrName())\n-                            && mapping.getIntMappingType() == attributableUtil.intMappingType()\n-                            && mapping.getResource() != null\n-                            && attributable.getResources().contains(mapping.getResource())) {\n+                for (ExternalResource resource : resourceDAO.findAll()) {\n+                    for (AbstractMappingItem mapItem : attrUtil.getMappingItems(resource)) {\n+                        if (schema.getName().equals(mapItem.getIntAttrName())\n+                                && mapItem.getIntMappingType() == attrUtil.intMappingType()\n+                                && attributable.getResources().contains(resource)) {\n \n-                        propByRes.add(PropagationOperation.UPDATE, mapping.getResource().getName());\n+                            propByRes.add(ResourceOperation.UPDATE, resource.getName());\n \n-                        if (mapping.isAccountid() && attribute != null && !attribute.getValuesAsStrings().isEmpty()) {\n+                            if (mapItem.isAccountid() && attribute != null\n+                                    && !attribute.getValuesAsStrings().isEmpty()) {\n \n-                            propByRes.addOldAccountId(mapping.getResource().getName(), attribute.getValuesAsStrings().\n-                                    iterator().next());\n+                                propByRes.addOldAccountId(resource.getName(),\n+                                        attribute.getValuesAsStrings().iterator().next());\n+                            }\n                         }\n                     }\n                 }\n@@ -453,36 +439,32 @@ protected PropagationByResource fill(final AbstractAttributable attributable,\n         LOG.debug(\"Attributes to be removed:\\n{}\", propByRes);\n \n         // 4. attributes to be updated\n-        Set<Long> valuesToBeRemoved;\n-        List<String> valuesToBeAdded;\n         for (AttributeMod attributeMod : attributableMod.getAttributesToBeUpdated()) {\n-\n-            schema = getSchema(attributeMod.getSchema(), attributableUtil.schemaClass());\n-\n+            AbstractSchema schema = getSchema(attributeMod.getSchema(), attrUtil.schemaClass());\n             if (schema != null) {\n-                for (SchemaMapping mapping : resourceDAO.findAllMappings()) {\n-                    if (schema.getName().equals(mapping.getIntAttrName())\n-                            && mapping.getIntMappingType() == attributableUtil.intMappingType()\n-                            && mapping.getResource() != null\n-                            && attributable.getResources().contains(mapping.getResource())) {\n+                for (ExternalResource resource : resourceDAO.findAll()) {\n+                    for (AbstractMappingItem mapItem : attrUtil.getMappingItems(resource)) {\n+                        if (schema.getName().equals(mapItem.getIntAttrName())\n+                                && mapItem.getIntMappingType() == attrUtil.intMappingType()\n+                                && attributable.getResources().contains(resource)) {\n \n-                        propByRes.add(PropagationOperation.UPDATE, mapping.getResource().getName());\n+                            propByRes.add(ResourceOperation.UPDATE, resource.getName());\n+                        }\n                     }\n                 }\n \n-                attribute = attributable.getAttribute(schema.getName());\n+                AbstractAttr attribute = attributable.getAttribute(schema.getName());\n                 if (attribute == null) {\n-                    attribute = attributableUtil.newAttr();\n+                    attribute = attrUtil.newAttr();\n                     attribute.setSchema(schema);\n                     attribute.setOwner(attributable);\n \n                     attributable.addAttribute(attribute);\n                 }\n \n                 // 1.1 remove values\n-                valuesToBeRemoved = new HashSet<Long>();\n+                Set<Long> valuesToBeRemoved = new HashSet<Long>();\n                 for (String valueToBeRemoved : attributeMod.getValuesToBeRemoved()) {\n-\n                     if (attribute.getSchema().isUniqueConstraint()) {\n                         if (attribute.getUniqueValue() != null\n                                 && valueToBeRemoved.equals(attribute.getUniqueValue().getValueAsString())) {\n@@ -498,17 +480,16 @@ protected PropagationByResource fill(final AbstractAttributable attributable,\n                     }\n                 }\n                 for (Long attributeValueId : valuesToBeRemoved) {\n-                    attributeValueDAO.delete(attributeValueId, attributableUtil.attrValueClass());\n+                    attributeValueDAO.delete(attributeValueId, attrUtil.attrValueClass());\n                 }\n \n                 // 1.2 add values\n-                valuesToBeAdded = attributeMod.getValuesToBeAdded();\n-                if (valuesToBeAdded != null\n-                        && !valuesToBeAdded.isEmpty()\n-                        && (!schema.isUniqueConstraint() || attribute.getUniqueValue() == null || !valuesToBeAdded.\n-                        iterator().next().equals(attribute.getUniqueValue().getValueAsString()))) {\n+                List<String> valuesToBeAdded = attributeMod.getValuesToBeAdded();\n+                if (valuesToBeAdded != null && !valuesToBeAdded.isEmpty()\n+                        && (!schema.isUniqueConstraint() || attribute.getUniqueValue() == null\n+                        || !valuesToBeAdded.iterator().next().equals(attribute.getUniqueValue().getValueAsString()))) {\n \n-                    fillAttribute(attributeMod.getValuesToBeAdded(), attributableUtil, schema, attribute, invalidValues);\n+                    fillAttribute(attributeMod.getValuesToBeAdded(), attrUtil, schema, attribute, invalidValues);\n                 }\n \n                 // if no values are in, the attribute can be safely removed\n@@ -519,38 +500,36 @@ protected PropagationByResource fill(final AbstractAttributable attributable,\n         }\n \n         if (!invalidValues.isEmpty()) {\n-            compositeErrorException.addException(invalidValues);\n+            scce.addException(invalidValues);\n         }\n \n         LOG.debug(\"Attributes to be updated:\\n{}\", propByRes);\n \n         // 5. derived attributes to be removed\n-        for (String derivedAttributeToBeRemoved : attributableMod.getDerivedAttributesToBeRemoved()) {\n-\n-            derivedSchema = getDerivedSchema(derivedAttributeToBeRemoved, attributableUtil.derSchemaClass());\n-\n-            if (derivedSchema != null) {\n-                derivedAttribute = attributable.getDerivedAttribute(derivedSchema.getName());\n-\n-                if (derivedAttribute == null) {\n-                    LOG.debug(\"No derived attribute found for schema {}\", derivedSchema.getName());\n+        for (String derAttrToBeRemoved : attributableMod.getDerivedAttributesToBeRemoved()) {\n+            AbstractDerSchema derSchema = getDerivedSchema(derAttrToBeRemoved, attrUtil.derSchemaClass());\n+            if (derSchema != null) {\n+                AbstractDerAttr derAttr = attributable.getDerivedAttribute(derSchema.getName());\n+                if (derAttr == null) {\n+                    LOG.debug(\"No derived attribute found for schema {}\", derSchema.getName());\n                 } else {\n-                    derAttrDAO.delete(derivedAttribute);\n+                    derAttrDAO.delete(derAttr);\n                 }\n \n-                for (SchemaMapping mapping : resourceDAO.findAllMappings()) {\n-                    if (derivedSchema.getName().equals(mapping.getIntAttrName())\n-                            && mapping.getIntMappingType() == attributableUtil.derIntMappingType()\n-                            && mapping.getResource() != null\n-                            && attributable.getResources().contains(mapping.getResource())) {\n+                for (ExternalResource resource : resourceDAO.findAll()) {\n+                    for (AbstractMappingItem mapItem : attrUtil.getMappingItems(resource)) {\n+                        if (derSchema.getName().equals(mapItem.getIntAttrName())\n+                                && mapItem.getIntMappingType() == attrUtil.derIntMappingType()\n+                                && attributable.getResources().contains(resource)) {\n \n-                        propByRes.add(PropagationOperation.UPDATE, mapping.getResource().getName());\n+                            propByRes.add(ResourceOperation.UPDATE, resource.getName());\n \n-                        if (mapping.isAccountid() && derivedAttribute != null\n-                                && !derivedAttribute.getValue(attributable.getAttributes()).isEmpty()) {\n+                            if (mapItem.isAccountid() && derAttr != null\n+                                    && !derAttr.getValue(attributable.getAttributes()).isEmpty()) {\n \n-                            propByRes.addOldAccountId(mapping.getResource().getName(),\n-                                    derivedAttribute.getValue(attributable.getAttributes()));\n+                                propByRes.addOldAccountId(resource.getName(),\n+                                        derAttr.getValue(attributable.getAttributes()));\n+                            }\n                         }\n                     }\n                 }\n@@ -560,46 +539,45 @@ protected PropagationByResource fill(final AbstractAttributable attributable,\n         LOG.debug(\"Derived attributes to be removed:\\n{}\", propByRes);\n \n         // 6. derived attributes to be added\n-        for (String derivedAttributeToBeAdded : attributableMod.getDerivedAttributesToBeAdded()) {\n-\n-            derivedSchema = getDerivedSchema(derivedAttributeToBeAdded, attributableUtil.derSchemaClass());\n-\n-            if (derivedSchema != null) {\n-                for (SchemaMapping mapping : resourceDAO.findAllMappings()) {\n-                    if (derivedSchema.getName().equals(mapping.getIntAttrName())\n-                            && mapping.getIntMappingType() == attributableUtil.derIntMappingType()\n-                            && mapping.getResource() != null\n-                            && attributable.getResources().contains(mapping.getResource())) {\n-\n-                        propByRes.add(PropagationOperation.UPDATE, mapping.getResource().getName());\n+        for (String derAttrToBeAdded : attributableMod.getDerivedAttributesToBeAdded()) {\n+            AbstractDerSchema derSchema = getDerivedSchema(derAttrToBeAdded, attrUtil.derSchemaClass());\n+            if (derSchema != null) {\n+                for (ExternalResource resource : resourceDAO.findAll()) {\n+                    for (AbstractMappingItem mapItem : attrUtil.getMappingItems(resource)) {\n+                        if (derSchema.getName().equals(mapItem.getIntAttrName())\n+                                && mapItem.getIntMappingType() == attrUtil.derIntMappingType()\n+                                && attributable.getResources().contains(resource)) {\n+\n+                            propByRes.add(ResourceOperation.UPDATE, resource.getName());\n+                        }\n                     }\n                 }\n \n-                derivedAttribute = attributableUtil.newDerAttr();\n-                derivedAttribute.setDerivedSchema(derivedSchema);\n-                derivedAttribute.setOwner(attributable);\n-                attributable.addDerivedAttribute(derivedAttribute);\n+                AbstractDerAttr derAttr = attrUtil.newDerAttr();\n+                derAttr.setDerivedSchema(derSchema);\n+                derAttr.setOwner(attributable);\n+                attributable.addDerivedAttribute(derAttr);\n             }\n         }\n \n         LOG.debug(\"Derived attributes to be added:\\n{}\", propByRes);\n \n-        // 7. virtual attributes: for users this is delegated to PropagationManager\n-        if (AttributableType.USER != attributableUtil.getType()) {\n-            fillVirtual(attributable, attributableMod.getVirtualAttributesToBeRemoved(), attributableMod.\n-                    getVirtualAttributesToBeUpdated(), attributableUtil);\n+        // 7. virtual attributes: for users and roles this is delegated to PropagationManager\n+        if (AttributableType.USER != attrUtil.getType() && AttributableType.ROLE != attrUtil.getType()) {\n+            fillVirtual(attributable, attributableMod.getVirtualAttributesToBeRemoved(),\n+                    attributableMod.getVirtualAttributesToBeUpdated(), attrUtil);\n         }\n \n         // Finally, check if mandatory values are missing\n-        SyncopeClientException requiredValuesMissing = checkMandatory(attributableUtil, attributable);\n+        SyncopeClientException requiredValuesMissing = checkMandatory(attrUtil, attributable);\n         if (!requiredValuesMissing.isEmpty()) {\n-            compositeErrorException.addException(requiredValuesMissing);\n+            scce.addException(requiredValuesMissing);\n         }\n \n         // Throw composite exception if there is at least one element set\n         // in the composing exceptions\n-        if (compositeErrorException.hasExceptions()) {\n-            throw compositeErrorException;\n+        if (scce.hasExceptions()) {\n+            throw scce;\n         }\n \n         return propByRes;\n@@ -610,35 +588,30 @@ protected PropagationByResource fill(final AbstractAttributable attributable,\n      *\n      * @param attributable attributable.\n      * @param vAttrs virtual attributes to be added.\n-     * @param attributableUtil attributable util.\n+     * @param attrUtil attributable util.\n      */\n     public void fillVirtual(final AbstractAttributable attributable, final List<AttributeTO> vAttrs,\n-            final AttributableUtil attributableUtil) {\n+            final AttributableUtil attrUtil) {\n \n         for (AttributeTO attributeTO : vAttrs) {\n-            AbstractVirAttr virtualAttribute = attributable.getVirtualAttribute(attributeTO.getSchema());\n-\n-            if (virtualAttribute == null) {\n-                AbstractVirSchema virtualSchema = getVirtualSchema(attributeTO.getSchema(),\n-                        attributableUtil.virSchemaClass());\n-\n-                if (virtualSchema != null) {\n-                    virtualAttribute = attributableUtil.newVirAttr();\n-                    virtualAttribute.setVirtualSchema(virtualSchema);\n-                    virtualAttribute.setOwner(attributable);\n-                    attributable.addVirtualAttribute(virtualAttribute);\n-                    virtualAttribute.setValues(attributeTO.getValues());\n+            AbstractVirAttr virAttr = attributable.getVirtualAttribute(attributeTO.getSchema());\n+            if (virAttr == null) {\n+                AbstractVirSchema virSchema = getVirtualSchema(attributeTO.getSchema(), attrUtil.virSchemaClass());\n+                if (virSchema != null) {\n+                    virAttr = attrUtil.newVirAttr();\n+                    virAttr.setVirtualSchema(virSchema);\n+                    virAttr.setOwner(attributable);\n+                    attributable.addVirtualAttribute(virAttr);\n+                    virAttr.setValues(attributeTO.getValues());\n                 }\n-\n             } else {\n-                virtualAttribute.setValues(attributeTO.getValues());\n+                virAttr.setValues(attributeTO.getValues());\n             }\n-\n         }\n     }\n \n     protected void fill(final AbstractAttributable attributable, final AbstractAttributableTO attributableTO,\n-            final AttributableUtil attributableUtil, final SyncopeClientCompositeErrorException compositeErrorException)\n+            final AttributableUtil attributableUtil, final SyncopeClientCompositeErrorException scce)\n             throws SyncopeClientCompositeErrorException {\n \n         // 1. attributes\n@@ -671,7 +644,7 @@ protected void fill(final AbstractAttributable attributable, final AbstractAttri\n         }\n \n         if (!invalidValues.isEmpty()) {\n-            compositeErrorException.addException(invalidValues);\n+            scce.addException(invalidValues);\n         }\n \n         // 2. derived attributes\n@@ -689,11 +662,12 @@ protected void fill(final AbstractAttributable attributable, final AbstractAttri\n             }\n         }\n \n-        // 3. user virtual attributes will be valued by the propagation manager only (if needed).\n-        if (AttributableType.USER == attributableUtil.getType()) {\n+        // 3. user and role virtual attributes will be evaluated by the propagation manager only (if needed).\n+        if (AttributableType.USER == attributableUtil.getType()\n+                || AttributableType.ROLE == attributableUtil.getType()) {\n+\n             for (AttributeTO vattrTO : attributableTO.getVirtualAttributes()) {\n-                AbstractVirSchema uVirSchema = getVirtualSchema(vattrTO.getSchema(),\n-                        attributableUtil.virSchemaClass());\n+                AbstractVirSchema uVirSchema = getVirtualSchema(vattrTO.getSchema(), attributableUtil.virSchemaClass());\n \n                 if (uVirSchema != null) {\n                     AbstractVirAttr vattr = attributableUtil.newVirAttr();\n@@ -718,13 +692,13 @@ protected void fill(final AbstractAttributable attributable, final AbstractAttri\n \n         SyncopeClientException requiredValuesMissing = checkMandatory(attributableUtil, attributable);\n         if (!requiredValuesMissing.isEmpty()) {\n-            compositeErrorException.addException(requiredValuesMissing);\n+            scce.addException(requiredValuesMissing);\n         }\n \n         // Throw composite exception if there is at least one element set\n         // in the composing exceptions\n-        if (compositeErrorException.hasExceptions()) {\n-            throw compositeErrorException;\n+        if (scce.hasExceptions()) {\n+            throw scce;\n         }\n     }\n "},{"sha":"3c45179493b793f7bb6d046ab6fedd6215aec5d0","filename":"core/src/main/java/org/apache/syncope/core/rest/data/ResourceDataBinder.java","status":"modified","additions":173,"deletions":162,"changes":335,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Frest%2Fdata%2FResourceDataBinder.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Frest%2Fdata%2FResourceDataBinder.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Frest%2Fdata%2FResourceDataBinder.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -26,16 +26,22 @@\n import java.util.Map;\n import java.util.Set;\n import org.apache.commons.lang.SerializationUtils;\n+import org.apache.syncope.client.to.MappingItemTO;\n+import org.apache.syncope.client.to.MappingTO;\n import org.apache.syncope.client.to.ResourceTO;\n-import org.apache.syncope.client.to.SchemaMappingTO;\n import org.apache.syncope.client.validation.SyncopeClientCompositeErrorException;\n import org.apache.syncope.client.validation.SyncopeClientException;\n+import org.apache.syncope.core.persistence.beans.AbstractMapping;\n+import org.apache.syncope.core.persistence.beans.AbstractMappingItem;\n import org.apache.syncope.core.persistence.beans.AccountPolicy;\n import org.apache.syncope.core.persistence.beans.ConnInstance;\n import org.apache.syncope.core.persistence.beans.ExternalResource;\n import org.apache.syncope.core.persistence.beans.PasswordPolicy;\n-import org.apache.syncope.core.persistence.beans.SchemaMapping;\n import org.apache.syncope.core.persistence.beans.SyncPolicy;\n+import org.apache.syncope.core.persistence.beans.role.RMapping;\n+import org.apache.syncope.core.persistence.beans.role.RMappingItem;\n+import org.apache.syncope.core.persistence.beans.user.UMapping;\n+import org.apache.syncope.core.persistence.beans.user.UMappingItem;\n import org.apache.syncope.core.persistence.dao.ConnInstanceDAO;\n import org.apache.syncope.core.persistence.dao.PolicyDAO;\n import org.apache.syncope.core.util.JexlUtil;\n@@ -58,7 +64,7 @@ public class ResourceDataBinder {\n      */\n     private static final Logger LOG = LoggerFactory.getLogger(ResourceDataBinder.class);\n \n-    private static final String[] MAPPING_IGNORE_PROPERTIES = {\"id\", \"resource\", \"syncToken\"};\n+    private static final String[] MAPPINGITEM_IGNORE_PROPERTIES = {\"id\", \"mapping\"};\n \n     @Autowired\n     private ConnInstanceDAO connInstanceDAO;\n@@ -69,9 +75,6 @@ public class ResourceDataBinder {\n     @Autowired\n     private PolicyDAO policyDAO;\n \n-    @Autowired\n-    private ConnInstanceDataBinder connInstancebinder;\n-\n     public ExternalResource create(final ResourceTO resourceTO)\n             throws SyncopeClientCompositeErrorException {\n \n@@ -104,124 +107,73 @@ public ExternalResource update(final ExternalResource resource, final ResourceTO\n \n         resource.setPropagationMode(resourceTO.getPropagationMode());\n \n-        resource.setMappings(getSchemaMappings(resource, resourceTO.getMappings()));\n-\n-        resource.setAccountLink(resourceTO.getAccountLink());\n+        if (resourceTO.getUmapping() != null) {\n+            UMapping mapping = new UMapping();\n+            resource.setUmapping(mapping);\n+            populateMapping(resourceTO.getUmapping(), mapping, new UMappingItem());\n+        }\n+        if (resourceTO.getRmapping() != null) {\n+            RMapping mapping = new RMapping();\n+            resource.setRmapping(mapping);\n+            populateMapping(resourceTO.getRmapping(), mapping, new RMappingItem());\n+        }\n \n         resource.setCreateTraceLevel(resourceTO.getCreateTraceLevel());\n         resource.setUpdateTraceLevel(resourceTO.getUpdateTraceLevel());\n         resource.setDeleteTraceLevel(resourceTO.getDeleteTraceLevel());\n         resource.setSyncTraceLevel(resourceTO.getSyncTraceLevel());\n \n-        resource.setPasswordPolicy(resourceTO.getPasswordPolicy() != null\n-                ? (PasswordPolicy) policyDAO.find(resourceTO.getPasswordPolicy())\n-                : null);\n+        resource.setPasswordPolicy(resourceTO.getPasswordPolicy() == null\n+                ? null : (PasswordPolicy) policyDAO.find(resourceTO.getPasswordPolicy()));\n \n-        resource.setAccountPolicy(resourceTO.getAccountPolicy() != null\n-                ? (AccountPolicy) policyDAO.find(resourceTO.getAccountPolicy())\n-                : null);\n+        resource.setAccountPolicy(resourceTO.getAccountPolicy() == null\n+                ? null : (AccountPolicy) policyDAO.find(resourceTO.getAccountPolicy()));\n \n-        resource.setSyncPolicy(resourceTO.getSyncPolicy() != null\n-                ? (SyncPolicy) policyDAO.find(resourceTO.getSyncPolicy())\n-                : null);\n+        resource.setSyncPolicy(resourceTO.getSyncPolicy() == null\n+                ? null : (SyncPolicy) policyDAO.find(resourceTO.getSyncPolicy()));\n \n         resource.setConnectorConfigurationProperties(new HashSet<ConnConfProperty>(resourceTO.getConnConfProperties()));\n \n-        if (resourceTO.getSyncToken() == null) {\n-            resource.setSerializedSyncToken(null);\n+        if (resourceTO.getUsyncToken() == null) {\n+            resource.setUserializedSyncToken(null);\n+        }\n+        if (resourceTO.getRsyncToken() == null) {\n+            resource.setRserializedSyncToken(null);\n         }\n \n-        resource.setActionsClassName(resourceTO.getActionsClassName());\n+        resource.setPropagationActionsClassName(resourceTO.getPropagationActionsClassName());\n \n         return resource;\n     }\n \n-    public List<ResourceTO> getResourceTOs(final Collection<ExternalResource> resources) {\n-        List<ResourceTO> resourceTOs = new ArrayList<ResourceTO>();\n-        for (ExternalResource resource : resources) {\n-            resourceTOs.add(getResourceTO(resource));\n-        }\n-\n-        return resourceTOs;\n-    }\n+    private void populateMapping(final MappingTO mappingTO, final AbstractMapping mapping,\n+            final AbstractMappingItem prototype) {\n \n-    public ResourceTO getResourceTO(final ExternalResource resource) {\n+        mapping.setAccountLink(mappingTO.getAccountLink());\n \n-        if (resource == null) {\n-            return null;\n+        for (AbstractMappingItem item : getMappingItems(mappingTO.getItems(), prototype)) {\n+            if (item.isAccountid()) {\n+                mapping.setAccountIdItem(item);\n+            } else if (item.isPassword()) {\n+                ((UMapping) mapping).setPasswordItem((UMappingItem) item);\n+            } else {\n+                mapping.addItem(item);\n+            }\n         }\n-\n-        ResourceTO resourceTO = new ResourceTO();\n-\n-        // set the resource name\n-        resourceTO.setName(resource.getName());\n-\n-        // set the connector instance\n-        ConnInstance connector = resource.getConnector();\n-\n-        resourceTO.setConnectorId(connector != null\n-                ? connector.getId()\n-                : null);\n-\n-        // set the mappings\n-        resourceTO.setMappings(getSchemaMappingTOs(resource.getMappings()));\n-\n-        resourceTO.setAccountLink(resource.getAccountLink());\n-\n-        resourceTO.setEnforceMandatoryCondition(resource.isEnforceMandatoryCondition());\n-\n-        resourceTO.setPropagationPrimary(resource.isPropagationPrimary());\n-\n-        resourceTO.setPropagationPriority(resource.getPropagationPriority());\n-\n-        resourceTO.setPropagationMode(resource.getPropagationMode());\n-\n-        resourceTO.setCreateTraceLevel(resource.getCreateTraceLevel());\n-        resourceTO.setUpdateTraceLevel(resource.getUpdateTraceLevel());\n-        resourceTO.setDeleteTraceLevel(resource.getDeleteTraceLevel());\n-        resourceTO.setSyncTraceLevel(resource.getSyncTraceLevel());\n-\n-        resourceTO.setPasswordPolicy(resource.getPasswordPolicy() != null\n-                ? resource.getPasswordPolicy().getId()\n-                : null);\n-\n-        resourceTO.setAccountPolicy(resource.getAccountPolicy() != null\n-                ? resource.getAccountPolicy().getId()\n-                : null);\n-\n-        resourceTO.setSyncPolicy(resource.getSyncPolicy() != null\n-                ? resource.getSyncPolicy().getId()\n-                : null);\n-\n-        resourceTO.setConnectorConfigurationProperties(resource.getConfiguration());\n-        resourceTO.setSyncToken(resource.getSerializedSyncToken());\n-\n-        resourceTO.setActionsClassName(resource.getActionsClassName());\n-\n-        return resourceTO;\n     }\n \n-    private Set<SchemaMapping> getSchemaMappings(final ExternalResource resource,\n-            final List<SchemaMappingTO> mappings) {\n-\n-        if (mappings == null) {\n-            return null;\n-        }\n-\n-        final Set<SchemaMapping> schemaMappings = new HashSet<SchemaMapping>();\n+    private Set<AbstractMappingItem> getMappingItems(final Collection<MappingItemTO> itemTOs,\n+            final AbstractMappingItem prototype) {\n \n-        SchemaMapping schemaMapping;\n-        for (SchemaMappingTO mapping : mappings) {\n-            schemaMapping = getSchemaMapping(resource, mapping);\n-            if (schemaMapping != null) {\n-                schemaMappings.add(schemaMapping);\n-            }\n+        Set<AbstractMappingItem> items = new HashSet<AbstractMappingItem>(itemTOs.size());\n+        for (MappingItemTO itemTO : itemTOs) {\n+            items.add(getMappingItem(itemTO, prototype));\n         }\n \n-        return schemaMappings;\n+        return items;\n     }\n \n-    private SchemaMapping getSchemaMapping(final ExternalResource resource, final SchemaMappingTO mappingTO)\n+    private AbstractMappingItem getMappingItem(final MappingItemTO itemTO, final AbstractMappingItem prototype)\n             throws SyncopeClientCompositeErrorException {\n \n         SyncopeClientCompositeErrorException scce = new SyncopeClientCompositeErrorException(HttpStatus.BAD_REQUEST);\n@@ -231,27 +183,16 @@ private SchemaMapping getSchemaMapping(final ExternalResource resource, final Sc\n \n         // this control needs to be free to get schema names\n         // without a complete/good resourceTO object\n-        if (mappingTO == null || mappingTO.getIntMappingType() == null) {\n+        if (itemTO == null || itemTO.getIntMappingType() == null) {\n             LOG.error(\"Null mappingTO provided\");\n             return null;\n         }\n \n-        if (mappingTO.getIntAttrName() == null) {\n-            switch (mappingTO.getIntMappingType()) {\n-                case SyncopeUserId:\n-                    mappingTO.setIntAttrName(IntMappingType.SyncopeUserId.toString());\n-                    break;\n-\n-                case Password:\n-                    mappingTO.setIntAttrName(IntMappingType.Password.toString());\n-                    break;\n-\n-                case Username:\n-                    mappingTO.setIntAttrName(IntMappingType.Username.toString());\n-                    break;\n-\n-                default:\n-                    requiredValuesMissing.addElement(\"intAttrName\");\n+        if (itemTO.getIntAttrName() == null) {\n+            if (IntMappingType.getEmbedded().contains(itemTO.getIntMappingType())) {\n+                itemTO.setIntAttrName(itemTO.getIntMappingType().toString());\n+            } else {\n+                requiredValuesMissing.addElement(\"intAttrName\");\n             }\n         }\n \n@@ -262,14 +203,13 @@ private SchemaMapping getSchemaMapping(final ExternalResource resource, final Sc\n         }\n \n         // no mandatory condition implies mandatory condition false\n-        if (!jexlUtil.isExpressionValid(mappingTO.getMandatoryCondition() != null\n-                ? mappingTO.getMandatoryCondition()\n-                : \"false\")) {\n+        if (!jexlUtil.isExpressionValid(itemTO.getMandatoryCondition() == null\n+                ? \"false\" : itemTO.getMandatoryCondition())) {\n \n             SyncopeClientException invalidMandatoryCondition = new SyncopeClientException(\n                     SyncopeClientExceptionType.InvalidValues);\n \n-            invalidMandatoryCondition.addElement(mappingTO.getMandatoryCondition());\n+            invalidMandatoryCondition.addElement(itemTO.getMandatoryCondition());\n \n             scce.addException(invalidMandatoryCondition);\n         }\n@@ -278,50 +218,9 @@ private SchemaMapping getSchemaMapping(final ExternalResource resource, final Sc\n             throw scce;\n         }\n \n-        SchemaMapping mapping = new SchemaMapping();\n-\n-        BeanUtils.copyProperties(mappingTO, mapping, MAPPING_IGNORE_PROPERTIES);\n-\n-        mapping.setResource(resource);\n-\n-        return mapping;\n-    }\n-\n-    public List<SchemaMappingTO> getSchemaMappingTOs(final Collection<SchemaMapping> mappings) {\n-        if (mappings == null) {\n-            LOG.error(\"No mapping provided.\");\n-\n-            return null;\n-        }\n-\n-        List<SchemaMappingTO> schemaMappingTOs = new ArrayList<SchemaMappingTO>();\n-        for (SchemaMapping mapping : mappings) {\n-            LOG.debug(\"Asking for TO for {}\", mapping);\n-\n-            schemaMappingTOs.add(getSchemaMappingTO(mapping));\n-        }\n-\n-        LOG.debug(\"Collected TOs: {}\", schemaMappingTOs);\n-\n-        return schemaMappingTOs;\n-    }\n-\n-    public SchemaMappingTO getSchemaMappingTO(final SchemaMapping schemaMapping) {\n-        if (schemaMapping == null) {\n-            LOG.error(\"Provided null mapping\");\n-\n-            return null;\n-        }\n-\n-        SchemaMappingTO schemaMappingTO = new SchemaMappingTO();\n-\n-        BeanUtils.copyProperties(schemaMapping, schemaMappingTO, MAPPING_IGNORE_PROPERTIES);\n-\n-        schemaMappingTO.setId(schemaMapping.getId());\n-\n-        LOG.debug(\"Obtained SchemaMappingTO {}\", schemaMappingTO);\n-\n-        return schemaMappingTO;\n+        AbstractMappingItem item = (AbstractMappingItem) SerializationUtils.clone(prototype);\n+        BeanUtils.copyProperties(itemTO, item, MAPPINGITEM_IGNORE_PROPERTIES);\n+        return item;\n     }\n \n     public ConnInstance getConnInstance(final ExternalResource resource) {\n@@ -370,4 +269,116 @@ private ConnInstance getConnInstance(final ConnInstance connInstance, final Set<\n \n         return connInstance;\n     }\n+\n+    public List<ResourceTO> getResourceTOs(final Collection<ExternalResource> resources) {\n+        List<ResourceTO> resourceTOs = new ArrayList<ResourceTO>();\n+        for (ExternalResource resource : resources) {\n+            resourceTOs.add(getResourceTO(resource));\n+        }\n+\n+        return resourceTOs;\n+    }\n+\n+    public ResourceTO getResourceTO(final ExternalResource resource) {\n+        if (resource == null) {\n+            return null;\n+        }\n+\n+        ResourceTO resourceTO = new ResourceTO();\n+\n+        // set the resource name\n+        resourceTO.setName(resource.getName());\n+\n+        // set the connector instance\n+        ConnInstance connector = resource.getConnector();\n+\n+        resourceTO.setConnectorId(connector == null ? null : connector.getId());\n+\n+        // set the mappings\n+        if (resource.getUmapping() != null) {\n+            MappingTO mappingTO = new MappingTO();\n+            resourceTO.setUmapping(mappingTO);\n+            populateMappingTO(resource.getUmapping(), mappingTO);\n+        }\n+        if (resource.getRmapping() != null) {\n+            MappingTO mappingTO = new MappingTO();\n+            resourceTO.setRmapping(mappingTO);\n+            populateMappingTO(resource.getRmapping(), mappingTO);\n+        }\n+\n+        resourceTO.setEnforceMandatoryCondition(resource.isEnforceMandatoryCondition());\n+\n+        resourceTO.setPropagationPrimary(resource.isPropagationPrimary());\n+\n+        resourceTO.setPropagationPriority(resource.getPropagationPriority());\n+\n+        resourceTO.setPropagationMode(resource.getPropagationMode());\n+\n+        resourceTO.setCreateTraceLevel(resource.getCreateTraceLevel());\n+        resourceTO.setUpdateTraceLevel(resource.getUpdateTraceLevel());\n+        resourceTO.setDeleteTraceLevel(resource.getDeleteTraceLevel());\n+        resourceTO.setSyncTraceLevel(resource.getSyncTraceLevel());\n+\n+        resourceTO.setPasswordPolicy(resource.getPasswordPolicy() == null\n+                ? null : resource.getPasswordPolicy().getId());\n+\n+        resourceTO.setAccountPolicy(resource.getAccountPolicy() == null\n+                ? null : resource.getAccountPolicy().getId());\n+\n+        resourceTO.setSyncPolicy(resource.getSyncPolicy() == null\n+                ? null : resource.getSyncPolicy().getId());\n+\n+        resourceTO.setConnectorConfigurationProperties(resource.getConfiguration());\n+\n+        resourceTO.setUsyncToken(resource.getUserializedSyncToken());\n+        resourceTO.setRsyncToken(resource.getRserializedSyncToken());\n+\n+        resourceTO.setPropagationActionsClassName(resource.getPropagationActionsClassName());\n+\n+        return resourceTO;\n+    }\n+\n+    private void populateMappingTO(final AbstractMapping mapping, final MappingTO mappingTO) {\n+        mappingTO.setAccountLink(mapping.getAccountLink());\n+\n+        for (MappingItemTO itemTO : getMappingItemTOs(mapping.getItems())) {\n+            if (itemTO.isAccountid()) {\n+                mappingTO.setAccountIdItem(itemTO);\n+            } else if (itemTO.isPassword()) {\n+                mappingTO.setPasswordItem(itemTO);\n+            } else {\n+                mappingTO.addItem(itemTO);\n+            }\n+        }\n+    }\n+\n+    private Set<MappingItemTO> getMappingItemTOs(final Collection<AbstractMappingItem> items) {\n+        Set<MappingItemTO> mappingTOs = new HashSet<MappingItemTO>();\n+        for (AbstractMappingItem item : items) {\n+            LOG.debug(\"Asking for TO for {}\", item);\n+            mappingTOs.add(getMappingItemTO(item));\n+        }\n+\n+        LOG.debug(\"Collected TOs: {}\", mappingTOs);\n+\n+        return mappingTOs;\n+    }\n+\n+    private MappingItemTO getMappingItemTO(final AbstractMappingItem item) {\n+        if (item == null) {\n+            LOG.error(\"Provided null mapping\");\n+\n+            return null;\n+        }\n+\n+        MappingItemTO itemTO = new MappingItemTO();\n+\n+        BeanUtils.copyProperties(item, itemTO, MAPPINGITEM_IGNORE_PROPERTIES);\n+\n+        itemTO.setId(item.getId());\n+\n+        LOG.debug(\"Obtained SchemaMappingTO {}\", itemTO);\n+\n+        return itemTO;\n+    }\n }"},{"sha":"9014046eb16644c0eefba7eeac0470c30473f770","filename":"core/src/main/java/org/apache/syncope/core/rest/data/RoleDataBinder.java","status":"modified","additions":49,"deletions":5,"changes":54,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Frest%2Fdata%2FRoleDataBinder.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Frest%2Fdata%2FRoleDataBinder.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Frest%2Fdata%2FRoleDataBinder.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -19,6 +19,7 @@\n package org.apache.syncope.core.rest.data;\n \n import java.util.List;\n+import java.util.Set;\n import org.apache.syncope.client.mod.RoleMod;\n import org.apache.syncope.client.to.RoleTO;\n import org.apache.syncope.client.validation.SyncopeClientCompositeErrorException;\n@@ -33,31 +34,51 @@\n import org.apache.syncope.core.persistence.beans.user.SyncopeUser;\n import org.apache.syncope.core.persistence.dao.EntitlementDAO;\n import org.apache.syncope.core.propagation.PropagationByResource;\n+import org.apache.syncope.core.rest.controller.UnauthorizedRoleException;\n import org.apache.syncope.core.util.AttributableUtil;\n+import org.apache.syncope.core.util.ConnObjectUtil;\n+import org.apache.syncope.core.util.EntitlementUtil;\n import org.apache.syncope.core.util.NotFoundException;\n import org.apache.syncope.types.AttributableType;\n+import org.apache.syncope.types.ResourceOperation;\n import org.apache.syncope.types.SyncopeClientExceptionType;\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.http.HttpStatus;\n import org.springframework.stereotype.Component;\n+import org.springframework.transaction.annotation.Transactional;\n \n @Component\n+@Transactional(rollbackFor = {Throwable.class})\n public class RoleDataBinder extends AbstractAttributableDataBinder {\n \n+    @Autowired\n+    private ConnObjectUtil connObjectUtil;\n+\n     @Autowired\n     private EntitlementDAO entitlementDAO;\n \n-    public SyncopeRole getSyncopeRole(final Long roleId) throws NotFoundException {\n+    @Transactional(readOnly = true)\n+    public SyncopeRole getRoleFromId(final Long roleId)\n+            throws NotFoundException, UnauthorizedRoleException {\n+\n+        if (roleId == null) {\n+            throw new NotFoundException(\"Null role id\");\n+        }\n+\n         SyncopeRole role = roleDAO.find(roleId);\n         if (role == null) {\n             throw new NotFoundException(\"Role \" + roleId);\n         }\n \n+        Set<Long> allowedRoleIds = EntitlementUtil.getRoleIds(EntitlementUtil.getOwnedEntitlementNames());\n+        if (!allowedRoleIds.contains(role.getId())) {\n+            throw new UnauthorizedRoleException(role.getId());\n+        }\n         return role;\n     }\n \n-    public SyncopeRole create(final RoleTO roleTO) throws SyncopeClientCompositeErrorException {\n-        SyncopeRole role = new SyncopeRole();\n+    public SyncopeRole create(final SyncopeRole role, final RoleTO roleTO)\n+            throws SyncopeClientCompositeErrorException {\n \n         role.setInheritOwner(roleTO.isInheritOwner());\n \n@@ -146,15 +167,26 @@ public SyncopeRole create(final RoleTO roleTO) throws SyncopeClientCompositeErro\n     public PropagationByResource update(final SyncopeRole role, final RoleMod roleMod)\n             throws SyncopeClientCompositeErrorException {\n \n+        PropagationByResource propByRes = new PropagationByResource();\n+\n         SyncopeClientCompositeErrorException scce = new SyncopeClientCompositeErrorException(HttpStatus.BAD_REQUEST);\n \n+        Set<String> currentResources = role.getResourceNames();\n+\n         // name\n         SyncopeClientException invalidRoles = new SyncopeClientException(SyncopeClientExceptionType.InvalidRoles);\n         if (roleMod.getName() != null) {\n             SyncopeRole otherRole = roleDAO.find(roleMod.getName(),\n                     role.getParent() == null ? null : role.getParent().getId());\n             if (otherRole == null || role.equals(otherRole)) {\n-                role.setName(roleMod.getName());\n+                if (!roleMod.getName().equals(role.getName())) {\n+                    propByRes.addAll(ResourceOperation.UPDATE, currentResources);\n+                    for (String resource : currentResources) {\n+                        propByRes.addOldAccountId(resource, role.getName());\n+                    }\n+\n+                    role.setName(roleMod.getName());\n+                }\n             } else {\n                 LOG.error(\"Another role exists with the same name and the same parent role: \" + otherRole);\n \n@@ -222,10 +254,15 @@ public PropagationByResource update(final SyncopeRole role, final RoleMod roleMo\n         }\n \n         // attributes, derived attributes, virtual attributes and resources\n-        return fill(role, roleMod, AttributableUtil.getInstance(AttributableType.ROLE), scce);\n+        propByRes.merge(fill(role, roleMod, AttributableUtil.getInstance(AttributableType.ROLE), scce));\n+\n+        return propByRes;\n     }\n \n+    @Transactional(readOnly = true)\n     public RoleTO getRoleTO(final SyncopeRole role) {\n+        connObjectUtil.retrieveVirAttrValues(role, AttributableUtil.getInstance(AttributableType.ROLE));\n+\n         RoleTO roleTO = new RoleTO();\n         roleTO.setId(role.getId());\n         roleTO.setName(role.getName());\n@@ -278,4 +315,11 @@ public RoleTO getRoleTO(final SyncopeRole role) {\n \n         return roleTO;\n     }\n+\n+    @Transactional(readOnly = true)\n+    public RoleTO getRoleTO(final Long roleId)\n+            throws NotFoundException, UnauthorizedRoleException {\n+\n+        return getRoleTO(getRoleFromId(roleId));\n+    }\n }"},{"sha":"cbd146c2b2d2d1dbcc412d79341612864d065b22","filename":"core/src/main/java/org/apache/syncope/core/rest/data/TaskDataBinder.java","status":"modified","additions":44,"deletions":44,"changes":88,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Frest%2Fdata%2FTaskDataBinder.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Frest%2Fdata%2FTaskDataBinder.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Frest%2Fdata%2FTaskDataBinder.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -22,7 +22,7 @@\n import org.apache.syncope.client.to.AbstractAttributableTO;\n import org.apache.syncope.client.to.AttributeTO;\n import org.apache.syncope.client.to.MembershipTO;\n-import org.apache.syncope.client.to.PropagationTaskTO;\n+import org.apache.syncope.client.to.RoleTO;\n import org.apache.syncope.client.to.SchedTaskTO;\n import org.apache.syncope.client.to.SyncTaskTO;\n import org.apache.syncope.client.to.TaskExecTO;\n@@ -64,7 +64,7 @@ public class TaskDataBinder {\n      */\n     private static final Logger LOG = LoggerFactory.getLogger(TaskDataBinder.class);\n \n-    private static final String[] IGNORE_TASK_PROPERTIES = {\"latestExecStatus\", \"executions\", \"resource\", \"user\"};\n+    private static final String[] IGNORE_TASK_PROPERTIES = {\"latestExecStatus\", \"executions\", \"resource\",};\n \n     private static final String[] IGNORE_TASK_EXECUTION_PROPERTIES = {\"id\", \"task\"};\n \n@@ -81,34 +81,29 @@ public class TaskDataBinder {\n     private JexlUtil jexlUtil;\n \n     private void checkJexl(final AbstractAttributableTO attributableTO, final SyncopeClientException sce) {\n-\n         for (AttributeTO attrTO : attributableTO.getAttributes()) {\n             if (!attrTO.getValues().isEmpty() && !jexlUtil.isExpressionValid(attrTO.getValues().get(0))) {\n-\n                 sce.addElement(\"Invalid JEXL: \" + attrTO.getValues().get(0));\n             }\n         }\n         for (AttributeTO attrTO : attributableTO.getVirtualAttributes()) {\n             if (!attrTO.getValues().isEmpty() && !jexlUtil.isExpressionValid(attrTO.getValues().get(0))) {\n-\n                 sce.addElement(\"Invalid JEXL: \" + attrTO.getValues().get(0));\n             }\n         }\n     }\n \n     private void fill(final SyncTask task, final SyncTaskTO taskTO) {\n+        SyncopeClientException sce = new SyncopeClientException(SyncopeClientExceptionType.InvalidSyncTask);\n+\n+        // 1. validate JEXL expressions in user and role templates\n         if (taskTO.getUserTemplate() != null) {\n             UserTO template = taskTO.getUserTemplate();\n \n-            // 1. validate JEXL expressions in user template\n-            SyncopeClientException sce = new SyncopeClientException(SyncopeClientExceptionType.InvalidSyncTask);\n-\n             if (StringUtils.isNotBlank(template.getUsername()) && !jexlUtil.isExpressionValid(template.getUsername())) {\n-\n                 sce.addElement(\"Invalid JEXL: \" + template.getUsername());\n             }\n             if (StringUtils.isNotBlank(template.getPassword()) && !jexlUtil.isExpressionValid(template.getPassword())) {\n-\n                 sce.addElement(\"Invalid JEXL: \" + template.getPassword());\n             }\n \n@@ -117,18 +112,28 @@ private void fill(final SyncTask task, final SyncTaskTO taskTO) {\n             for (MembershipTO memb : template.getMemberships()) {\n                 checkJexl(memb, sce);\n             }\n+        }\n+        if (taskTO.getRoleTemplate() != null) {\n+            RoleTO template = taskTO.getRoleTemplate();\n \n-            if (!sce.isEmpty()) {\n-                SyncopeClientCompositeErrorException scce = new SyncopeClientCompositeErrorException(\n-                        HttpStatus.BAD_REQUEST);\n-                scce.addException(sce);\n-                throw scce;\n+            if (StringUtils.isNotBlank(template.getName()) && !jexlUtil.isExpressionValid(template.getName())) {\n+                sce.addElement(\"Invalid JEXL: \" + template.getName());\n             }\n+\n+            checkJexl(template, sce);\n+        }\n+        if (!sce.isEmpty()) {\n+            SyncopeClientCompositeErrorException scce = new SyncopeClientCompositeErrorException(\n+                    HttpStatus.BAD_REQUEST);\n+            scce.addException(sce);\n+            throw scce;\n         }\n \n-        // 2. all JEXL expressions are valid: accept user template\n+        // 2. all JEXL expressions are valid: accept user and role templates\n         task.setUserTemplate(taskTO.getUserTemplate());\n+        task.setRoleTemplate(taskTO.getRoleTemplate());\n \n+        // 3. fill the remaining fields\n         task.setPerformCreate(taskTO.isPerformCreate());\n         task.setPerformUpdate(taskTO.isPerformUpdate());\n         task.setPerformDelete(taskTO.isPerformDelete());\n@@ -146,26 +151,23 @@ public SchedTask createSchedTask(final SchedTaskTO taskTO, final TaskUtil taskUt\n         task.setName(taskTO.getName());\n         task.setDescription(taskTO.getDescription());\n \n-        switch (taskUtil) {\n-            case SCHED:\n-                task.setJobClassName(taskTO.getJobClassName());\n-                break;\n-\n-            case SYNC:\n-                if (!(taskTO instanceof SyncTaskTO)) {\n-                    throw new ClassCastException(\"taskUtil is type SyncTask but taskTO is not SyncTaskTO: \" + taskTO.\n-                            getClass().getName());\n-                }\n-                SyncTaskTO syncTaskTO = (SyncTaskTO) taskTO;\n+        if (taskUtil == TaskUtil.SCHED) {\n+            task.setJobClassName(taskTO.getJobClassName());\n+        }\n+        if (taskUtil == TaskUtil.SYNC) {\n+            if (!(taskTO instanceof SyncTaskTO)) {\n+                throw new ClassCastException(\"taskUtil is type SyncTask but taskTO is not SyncTaskTO: \" + taskTO.\n+                        getClass().getName());\n+            }\n+            SyncTaskTO syncTaskTO = (SyncTaskTO) taskTO;\n \n-                ExternalResource resource = resourceDAO.find(syncTaskTO.getResource());\n-                if (resource == null) {\n-                    throw new NotFoundException(\"Resource \" + syncTaskTO.getResource());\n-                }\n-                ((SyncTask) task).setResource(resource);\n+            ExternalResource resource = resourceDAO.find(syncTaskTO.getResource());\n+            if (resource == null) {\n+                throw new NotFoundException(\"Resource \" + syncTaskTO.getResource());\n+            }\n+            ((SyncTask) task).setResource(resource);\n \n-                fill((SyncTask) task, syncTaskTO);\n-                break;\n+            fill((SyncTask) task, syncTaskTO);\n         }\n \n         return task;\n@@ -252,28 +254,26 @@ public TaskTO getTaskTO(final Task task, final TaskUtil taskUtil) {\n                     throw new ClassCastException(\"taskUtil is type Propagation but task is not PropagationTask: \"\n                             + task.getClass().getName());\n                 }\n-\n-                ((PropagationTaskTO) taskTO).setResource(((PropagationTask) task).getResource().getName());\n-                if (((PropagationTask) task).getSyncopeUser() != null) {\n-                    ((PropagationTaskTO) taskTO).setUser(((PropagationTask) task).getSyncopeUser().getId());\n-                }\n                 break;\n \n             case SCHED:\n+                if (!(task instanceof SchedTask)) {\n+                    throw new ClassCastException(\"taskUtil is type Sched but task is not SchedTask: \"\n+                            + task.getClass().getName());\n+                }\n                 setExecTime((SchedTaskTO) taskTO, task);\n                 ((SchedTaskTO) taskTO).setName(((SchedTask) task).getName());\n                 ((SchedTaskTO) taskTO).setDescription(((SchedTask) task).getDescription());\n                 break;\n \n             case SYNC:\n+                if (!(task instanceof SyncTask)) {\n+                    throw new ClassCastException(\"taskUtil is type Sync but task is not SyncTask: \"\n+                            + task.getClass().getName());\n+                }\n                 setExecTime((SchedTaskTO) taskTO, task);\n                 ((SyncTaskTO) taskTO).setName(((SyncTask) task).getName());\n                 ((SyncTaskTO) taskTO).setDescription(((SyncTask) task).getDescription());\n-                if (!(task instanceof SyncTask)) {\n-                    throw new ClassCastException(\"taskUtil is type Sync but task is not SyncTask: \" + task.getClass().\n-                            getName());\n-                }\n-\n                 ((SyncTaskTO) taskTO).setResource(((SyncTask) task).getResource().getName());\n                 break;\n "},{"sha":"26d7a6499c5ed6c8ce9bb34896ab67068ffbaaa5","filename":"core/src/main/java/org/apache/syncope/core/rest/data/UserDataBinder.java","status":"modified","additions":12,"deletions":17,"changes":29,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Frest%2Fdata%2FUserDataBinder.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Frest%2Fdata%2FUserDataBinder.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Frest%2Fdata%2FUserDataBinder.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -30,10 +30,10 @@\n import org.apache.syncope.client.validation.SyncopeClientException;\n import org.apache.syncope.core.persistence.beans.AbstractAttr;\n import org.apache.syncope.core.persistence.beans.AbstractDerAttr;\n+import org.apache.syncope.core.persistence.beans.AbstractMappingItem;\n import org.apache.syncope.core.persistence.beans.AbstractVirAttr;\n import org.apache.syncope.core.persistence.beans.ExternalResource;\n import org.apache.syncope.core.persistence.beans.Policy;\n-import org.apache.syncope.core.persistence.beans.SchemaMapping;\n import org.apache.syncope.core.persistence.beans.membership.MAttr;\n import org.apache.syncope.core.persistence.beans.membership.MDerAttr;\n import org.apache.syncope.core.persistence.beans.membership.MVirAttr;\n@@ -51,7 +51,7 @@\n import org.apache.syncope.types.CipherAlgorithm;\n import org.apache.syncope.types.IntMappingType;\n import org.apache.syncope.types.PasswordPolicySpec;\n-import org.apache.syncope.types.PropagationOperation;\n+import org.apache.syncope.types.ResourceOperation;\n import org.apache.syncope.types.SyncopeClientExceptionType;\n import org.springframework.beans.BeanUtils;\n import org.springframework.beans.factory.annotation.Autowired;\n@@ -271,20 +271,19 @@ public PropagationByResource update(final SyncopeUser user, final UserMod userMo\n \n             user.setChangePwdDate(new Date());\n \n-            propByRes.addAll(PropagationOperation.UPDATE, currentResources);\n+            propByRes.addAll(ResourceOperation.UPDATE, currentResources);\n         }\n \n         // username\n         if (userMod.getUsername() != null && !userMod.getUsername().equals(user.getUsername())) {\n-\n             String oldUsername = user.getUsername();\n \n             user.setUsername(userMod.getUsername());\n-            propByRes.addAll(PropagationOperation.UPDATE, currentResources);\n+            propByRes.addAll(ResourceOperation.UPDATE, currentResources);\n \n             for (ExternalResource resource : user.getResources()) {\n-                for (SchemaMapping mapping : resource.getMappings()) {\n-                    if (mapping.isAccountid() && mapping.getIntMappingType() == IntMappingType.Username) {\n+                for (AbstractMappingItem mapItem : resource.getUmapping().getItems()) {\n+                    if (mapItem.isAccountid() && mapItem.getIntMappingType() == IntMappingType.Username) {\n                         propByRes.addOldAccountId(resource.getName(), oldUsername);\n                     }\n                 }\n@@ -304,11 +303,10 @@ public PropagationByResource update(final SyncopeUser user, final UserMod userMo\n         final Set<String> toBeProvisioned = new HashSet<String>();\n \n         // memberships to be removed\n-        Membership membership;\n         for (Long membershipId : userMod.getMembershipsToBeRemoved()) {\n             LOG.debug(\"Membership to be removed: {}\", membershipId);\n \n-            membership = membershipDAO.find(membershipId);\n+            Membership membership = membershipDAO.find(membershipId);\n             if (membership == null) {\n                 LOG.debug(\"Invalid membership id specified to be removed: {}\", membershipId);\n             } else {\n@@ -345,7 +343,6 @@ public PropagationByResource update(final SyncopeUser user, final UserMod userMo\n \n                     // remove virtual attributes\n                     for (AbstractVirAttr virAttr : membership.getVirtualAttributes()) {\n-\n                         attributeIds.add(virAttr.getId());\n                     }\n                     for (Long virAttrId : attributeIds) {\n@@ -368,7 +365,7 @@ public PropagationByResource update(final SyncopeUser user, final UserMod userMo\n             if (role == null) {\n                 LOG.debug(\"Ignoring invalid role {}\", membershipMod.getRole());\n             } else {\n-                membership = user.getMembership(role.getId());\n+                Membership membership = user.getMembership(role.getId());\n                 if (membership == null) {\n                     membership = new Membership();\n                     membership.setSyncopeRole(role);\n@@ -396,30 +393,28 @@ public PropagationByResource update(final SyncopeUser user, final UserMod userMo\n             throw scce;\n         }\n \n-        propByRes.addAll(PropagationOperation.DELETE, toBeDeprovisioned);\n-        propByRes.addAll(PropagationOperation.UPDATE, toBeProvisioned);\n+        propByRes.addAll(ResourceOperation.DELETE, toBeDeprovisioned);\n+        propByRes.addAll(ResourceOperation.UPDATE, toBeProvisioned);\n \n         /**\n          * In case of new memberships all the current resources have to be updated in order to propagate new role and\n          * membership attribute values.\n          */\n         if (!toBeDeprovisioned.isEmpty() || !toBeProvisioned.isEmpty()) {\n             currentResources.removeAll(toBeDeprovisioned);\n-            propByRes.addAll(PropagationOperation.UPDATE, currentResources);\n+            propByRes.addAll(ResourceOperation.UPDATE, currentResources);\n         }\n \n         return propByRes;\n     }\n \n     @Transactional(readOnly = true)\n     public UserTO getUserTO(final SyncopeUser user) {\n-\n         UserTO userTO = new UserTO();\n \n         BeanUtils.copyProperties(user, userTO, IGNORE_USER_PROPERTIES);\n \n-        // retrieve virtual values\n-        connObjectUtil.retrieveVirAttrValues(user);\n+        connObjectUtil.retrieveVirAttrValues(user, AttributableUtil.getInstance(AttributableType.USER));\n \n         fillTO(userTO, user.getAttributes(), user.getDerivedAttributes(), user.getVirtualAttributes(),\n                 user.getResources());"},{"sha":"ec46cccf02dca57a96c8bd78d6ec1f321a221293","filename":"core/src/main/java/org/apache/syncope/core/sync/DefaultSyncActions.java","status":"modified","additions":13,"deletions":8,"changes":21,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fsync%2FDefaultSyncActions.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fsync%2FDefaultSyncActions.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fsync%2FDefaultSyncActions.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -19,8 +19,8 @@\n package org.apache.syncope.core.sync;\n \n import java.util.List;\n-import org.apache.syncope.client.mod.UserMod;\n-import org.apache.syncope.client.to.UserTO;\n+import org.apache.syncope.client.mod.AbstractAttributableMod;\n+import org.apache.syncope.client.to.AbstractAttributableTO;\n import org.apache.syncope.core.persistence.beans.SyncTask;\n import org.identityconnectors.framework.common.objects.SyncDelta;\n import org.quartz.JobExecutionException;\n@@ -35,24 +35,29 @@ public void beforeAll(final SyncTask task) throws JobExecutionException {\n     }\n \n     @Override\n-    public SyncDelta beforeCreate(final SyncDelta delta, final UserTO user) throws JobExecutionException {\n+    public <T extends AbstractAttributableTO> SyncDelta beforeCreate(final SyncDelta delta, final T subject)\n+            throws JobExecutionException {\n+\n         return delta;\n     }\n \n     @Override\n-    public SyncDelta beforeUpdate(final SyncDelta delta, final UserTO user, final UserMod userMod)\n-            throws JobExecutionException {\n+    public <T extends AbstractAttributableTO, K extends AbstractAttributableMod> SyncDelta beforeUpdate(\n+            final SyncDelta delta, final T subject, final K subjectMod) throws JobExecutionException {\n+\n         return delta;\n     }\n \n     @Override\n-    public SyncDelta beforeDelete(final SyncDelta delta, final UserTO user) throws JobExecutionException {\n+    public <T extends AbstractAttributableTO> SyncDelta beforeDelete(final SyncDelta delta, final T subject)\n+            throws JobExecutionException {\n+\n         return delta;\n     }\n \n     @Override\n-    public void after(final SyncDelta delta, final UserTO user, final SyncResult result)\n-            throws JobExecutionException {\n+    public <T extends AbstractAttributableTO> void after(final SyncDelta delta, final T subject,\n+            final SyncResult result) throws JobExecutionException {\n     }\n \n     @Override"},{"sha":"345b0407ca251eaf3c908a4bb587712686e0958d","filename":"core/src/main/java/org/apache/syncope/core/sync/SyncActions.java","status":"modified","additions":26,"deletions":23,"changes":49,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fsync%2FSyncActions.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fsync%2FSyncActions.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fsync%2FSyncActions.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -19,8 +19,8 @@\n package org.apache.syncope.core.sync;\n \n import java.util.List;\n-import org.apache.syncope.client.mod.UserMod;\n-import org.apache.syncope.client.to.UserTO;\n+import org.apache.syncope.client.mod.AbstractAttributableMod;\n+import org.apache.syncope.client.to.AbstractAttributableTO;\n import org.apache.syncope.core.persistence.beans.SyncTask;\n import org.identityconnectors.framework.common.objects.SyncDelta;\n import org.quartz.JobExecutionException;\n@@ -41,51 +41,54 @@ public interface SyncActions {\n     /**\n      * Action to be executed before to create a synchronized user locally.\n      *\n-     * @param delta retrieved synchronization information.\n-     * @param user user to be created.\n+     * @param delta retrieved synchronization information\n+     * @param subject user / role to be created\n      * @return synchronization information used for user status evaluation and to be passed to the 'after' method.\n-     * @throws JobExecutionException in case of generic failure.\n+     * @throws JobExecutionException in case of generic failure\n      */\n-    SyncDelta beforeCreate(final SyncDelta delta, final UserTO user) throws JobExecutionException;\n+    <T extends AbstractAttributableTO> SyncDelta beforeCreate(final SyncDelta delta, final T subject)\n+            throws JobExecutionException;\n \n     /**\n      * Action to be executed before to update a synchronized user locally.\n      *\n-     * @param delta retrieved synchronization information.\n-     * @param user local user information.\n-     * @param userMod modification.\n+     * @param delta retrieved synchronization information\n+     * @param subject local user / role information\n+     * @param subjectMod modification\n      * @return synchronization information used for logging and to be passed to the 'after' method.\n      * @throws JobExecutionException in case of generic failure.\n      */\n-    SyncDelta beforeUpdate(final SyncDelta delta, final UserTO user, final UserMod userMod)\n-            throws JobExecutionException;\n+    <T extends AbstractAttributableTO, K extends AbstractAttributableMod> SyncDelta beforeUpdate(final SyncDelta delta,\n+            final T subject, final K subjectMod) throws JobExecutionException;\n \n     /**\n      * Action to be executed before to delete a synchronized user locally.\n      *\n-     * @param delta retrieved synchronization information.\n-     * @param userlocal user to be deleted.\n+     * @param delta retrieved synchronization information\n+     * @param subject lcao user / role to be deleted\n      * @return synchronization information used for logging and to be passed to the 'after' method.\n-     * @throws JobExecutionException in case of generic failure.\n+     * @throws JobExecutionException in case of generic failure\n      */\n-    SyncDelta beforeDelete(final SyncDelta delta, final UserTO user) throws JobExecutionException;\n+    <T extends AbstractAttributableTO> SyncDelta beforeDelete(final SyncDelta delta, final T subject)\n+            throws JobExecutionException;\n \n     /**\n      * Action to be executed after each local user synchronization.\n      *\n-     * @param delta retrieved synchronization information (may be modified by 'beforeCreate/beforeUpdate/beforeDelete').\n-     * @param user synchronized local user.\n-     * @param result global synchronization results at the current synchronization step.\n-     * @throws JobExecutionException in case of generic failure.\n+     * @param delta retrieved synchronization information (may be modified by 'beforeCreate/beforeUpdate/beforeDelete')\n+     * @param subject synchronized local user / role\n+     * @param result global synchronization results at the current synchronization step\n+     * @throws JobExecutionException in case of generic failure\n      */\n-    void after(final SyncDelta delta, final UserTO user, final SyncResult result) throws JobExecutionException;\n+    <T extends AbstractAttributableTO> void after(final SyncDelta delta, final T subject, final SyncResult result)\n+            throws JobExecutionException;\n \n     /**\n      * Action to be executed after the synchronization task completion.\n      *\n-     * @param task executed synchronization task.\n-     * @param results synchronization result.\n-     * @throws JobExecutionException in case of generic failure.\n+     * @param task executed synchronization task\n+     * @param results synchronization result\n+     * @throws JobExecutionException in case of generic failure\n      */\n     void afterAll(final SyncTask task, final List<SyncResult> results) throws JobExecutionException;\n }"},{"sha":"f58c553f7246e294f2a93bcbb9647a601e1d05ed","filename":"core/src/main/java/org/apache/syncope/core/sync/SyncJob.java","status":"modified","additions":156,"deletions":43,"changes":199,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fsync%2FSyncJob.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fsync%2FSyncJob.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fsync%2FSyncJob.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -23,17 +23,17 @@\n import org.apache.syncope.core.init.ConnInstanceLoader;\n import org.apache.syncope.core.persistence.beans.Entitlement;\n import org.apache.syncope.core.persistence.beans.ExternalResource;\n-import org.apache.syncope.core.persistence.beans.SchemaMapping;\n import org.apache.syncope.core.persistence.beans.SyncPolicy;\n import org.apache.syncope.core.persistence.beans.SyncTask;\n import org.apache.syncope.core.persistence.beans.TaskExec;\n+import org.apache.syncope.core.persistence.beans.role.RMapping;\n+import org.apache.syncope.core.persistence.beans.user.UMapping;\n import org.apache.syncope.core.persistence.dao.EntitlementDAO;\n import org.apache.syncope.core.persistence.dao.ResourceDAO;\n import org.apache.syncope.core.propagation.ConnectorFacadeProxy;\n import org.apache.syncope.core.quartz.AbstractTaskJob;\n import org.apache.syncope.core.util.ApplicationContextProvider;\n import org.apache.syncope.core.util.EntitlementUtil;\n-import org.apache.syncope.core.util.SchemaMappingUtil;\n import org.apache.syncope.types.ConflictResolutionAction;\n import org.apache.syncope.types.SyncPolicySpec;\n import org.apache.syncope.types.TraceLevel;\n@@ -105,27 +105,63 @@ private String createReport(final List<SyncResult> syncResults, final TraceLevel\n             report.append(\"==>Dry run only, no modifications were made<==\\n\\n\");\n         }\n \n-        List<SyncResult> created = new ArrayList<SyncResult>();\n-        List<SyncResult> createdFailed = new ArrayList<SyncResult>();\n-        List<SyncResult> updated = new ArrayList<SyncResult>();\n-        List<SyncResult> updatedFailed = new ArrayList<SyncResult>();\n-        List<SyncResult> deleted = new ArrayList<SyncResult>();\n-        List<SyncResult> deletedFailed = new ArrayList<SyncResult>();\n+        List<SyncResult> uSuccCreate = new ArrayList<SyncResult>();\n+        List<SyncResult> uFailCreate = new ArrayList<SyncResult>();\n+        List<SyncResult> uSuccUpdate = new ArrayList<SyncResult>();\n+        List<SyncResult> uFailUpdate = new ArrayList<SyncResult>();\n+        List<SyncResult> uSuccDelete = new ArrayList<SyncResult>();\n+        List<SyncResult> uFailDelete = new ArrayList<SyncResult>();\n+        List<SyncResult> rSuccCreate = new ArrayList<SyncResult>();\n+        List<SyncResult> rFailCreate = new ArrayList<SyncResult>();\n+        List<SyncResult> rSuccUpdate = new ArrayList<SyncResult>();\n+        List<SyncResult> rFailUpdate = new ArrayList<SyncResult>();\n+        List<SyncResult> rSuccDelete = new ArrayList<SyncResult>();\n+        List<SyncResult> rFailDelete = new ArrayList<SyncResult>();\n \n         for (SyncResult syncResult : syncResults) {\n             switch (syncResult.getStatus()) {\n                 case SUCCESS:\n                     switch (syncResult.getOperation()) {\n                         case CREATE:\n-                            created.add(syncResult);\n+                            switch (syncResult.getSubjectType()) {\n+                                case USER:\n+                                    uSuccCreate.add(syncResult);\n+                                    break;\n+\n+                                case ROLE:\n+                                    rSuccCreate.add(syncResult);\n+                                    break;\n+\n+                                default:\n+                            }\n                             break;\n \n                         case UPDATE:\n-                            updated.add(syncResult);\n+                            switch (syncResult.getSubjectType()) {\n+                                case USER:\n+                                    uSuccUpdate.add(syncResult);\n+                                    break;\n+\n+                                case ROLE:\n+                                    rSuccUpdate.add(syncResult);\n+                                    break;\n+\n+                                default:\n+                            }\n                             break;\n \n                         case DELETE:\n-                            deleted.add(syncResult);\n+                            switch (syncResult.getSubjectType()) {\n+                                case USER:\n+                                    uSuccDelete.add(syncResult);\n+                                    break;\n+\n+                                case ROLE:\n+                                    rSuccDelete.add(syncResult);\n+                                    break;\n+\n+                                default:\n+                            }\n                             break;\n \n                         default:\n@@ -135,15 +171,45 @@ private String createReport(final List<SyncResult> syncResults, final TraceLevel\n                 case FAILURE:\n                     switch (syncResult.getOperation()) {\n                         case CREATE:\n-                            createdFailed.add(syncResult);\n+                            switch (syncResult.getSubjectType()) {\n+                                case USER:\n+                                    uFailCreate.add(syncResult);\n+                                    break;\n+\n+                                case ROLE:\n+                                    rFailCreate.add(syncResult);\n+                                    break;\n+\n+                                default:\n+                            }\n                             break;\n \n                         case UPDATE:\n-                            updatedFailed.add(syncResult);\n+                            switch (syncResult.getSubjectType()) {\n+                                case USER:\n+                                    uFailUpdate.add(syncResult);\n+                                    break;\n+\n+                                case ROLE:\n+                                    rFailUpdate.add(syncResult);\n+                                    break;\n+\n+                                default:\n+                            }\n                             break;\n \n                         case DELETE:\n-                            deletedFailed.add(syncResult);\n+                            switch (syncResult.getSubjectType()) {\n+                                case USER:\n+                                    uFailDelete.add(syncResult);\n+                                    break;\n+\n+                                case ROLE:\n+                                    rFailDelete.add(syncResult);\n+                                    break;\n+\n+                                default:\n+                            }\n                             break;\n \n                         default:\n@@ -155,36 +221,63 @@ private String createReport(final List<SyncResult> syncResults, final TraceLevel\n         }\n \n         // Summary, also to be included for FAILURE and ALL, so create it anyway.\n-        report.append(\"Users [created/failures]: \").append(created.size()).append('/').append(createdFailed.size())\n-                .append(' ').append(\"[updated/failures]: \").append(updated.size()).append('/').append(\n-                updatedFailed.size()).append(' ').append(\"[deleted/ failures]: \").append(deleted.size())\n-                .append('/').append(deletedFailed.size());\n+        report.append(\"Users \").\n+                append(\"[created/failures]: \").append(uSuccCreate.size()).append('/').append(uFailCreate.size()).\n+                append(' ').\n+                append(\"[updated/failures]: \").append(uSuccUpdate.size()).append('/').append(uFailUpdate.size()).\n+                append(' ').\n+                append(\"[deleted/failures]: \").append(uSuccDelete.size()).append('/').append(uFailDelete.size()).\n+                append('\\n');\n+        report.append(\"Roles \").\n+                append(\"[created/failures]: \").append(rSuccCreate.size()).append('/').append(rFailCreate.size()).\n+                append(' ').\n+                append(\"[updated/failures]: \").append(rSuccUpdate.size()).append('/').append(rFailUpdate.size()).\n+                append(' ').\n+                append(\"[deleted/failures]: \").append(rSuccDelete.size()).append('/').append(rFailDelete.size());\n \n         // Failures\n         if (syncTraceLevel == TraceLevel.FAILURES || syncTraceLevel == TraceLevel.ALL) {\n+            if (!uFailCreate.isEmpty()) {\n+                report.append(\"\\n\\nUsers failed to create: \");\n+                report.append(SyncResult.produceReport(uFailCreate, syncTraceLevel));\n+            }\n+            if (!uFailUpdate.isEmpty()) {\n+                report.append(\"\\nUsers failed to update: \");\n+                report.append(SyncResult.produceReport(uFailUpdate, syncTraceLevel));\n+            }\n+            if (!uFailDelete.isEmpty()) {\n+                report.append(\"\\nUsers failed to delete: \");\n+                report.append(SyncResult.produceReport(uFailDelete, syncTraceLevel));\n+            }\n \n-            if (!createdFailed.isEmpty()) {\n-                report.append(\"\\n\\nFailed to create: \");\n-                report.append(SyncResult.reportSetOfSynchronizationResult(createdFailed, syncTraceLevel));\n+            if (!rFailCreate.isEmpty()) {\n+                report.append(\"\\n\\nRoles failed to create: \");\n+                report.append(SyncResult.produceReport(rFailCreate, syncTraceLevel));\n             }\n-            if (!updatedFailed.isEmpty()) {\n-                report.append(\"\\nFailed to update: \");\n-                report.append(SyncResult.reportSetOfSynchronizationResult(updatedFailed, syncTraceLevel));\n+            if (!rFailUpdate.isEmpty()) {\n+                report.append(\"\\nRoles failed to update: \");\n+                report.append(SyncResult.produceReport(rFailUpdate, syncTraceLevel));\n             }\n-            if (!deletedFailed.isEmpty()) {\n-                report.append(\"\\nFailed to delete: \");\n-                report.append(SyncResult.reportSetOfSynchronizationResult(deletedFailed, syncTraceLevel));\n+            if (!rFailDelete.isEmpty()) {\n+                report.append(\"\\nRoles failed to delete: \");\n+                report.append(SyncResult.produceReport(rFailDelete, syncTraceLevel));\n             }\n         }\n \n         // Succeeded, only if on 'ALL' level\n         if (syncTraceLevel == TraceLevel.ALL) {\n-            report.append(\"\\n\\nCreated:\\n\")\n-                    .append(SyncResult.reportSetOfSynchronizationResult(created, syncTraceLevel))\n-                    .append(\"\\nUpdated:\\n\")\n-                    .append(SyncResult.reportSetOfSynchronizationResult(updated, syncTraceLevel))\n-                    .append(\"\\nDeleted:\\n\")\n-                    .append(SyncResult.reportSetOfSynchronizationResult(deleted, syncTraceLevel));\n+            report.append(\"\\n\\nUsers created:\\n\")\n+                    .append(SyncResult.produceReport(uSuccCreate, syncTraceLevel))\n+                    .append(\"\\nUsers updated:\\n\")\n+                    .append(SyncResult.produceReport(uSuccUpdate, syncTraceLevel))\n+                    .append(\"\\nUsers deleted:\\n\")\n+                    .append(SyncResult.produceReport(uSuccDelete, syncTraceLevel));\n+            report.append(\"\\n\\nRoles created:\\n\")\n+                    .append(SyncResult.produceReport(rSuccCreate, syncTraceLevel))\n+                    .append(\"\\nRoles updated:\\n\")\n+                    .append(SyncResult.produceReport(rSuccUpdate, syncTraceLevel))\n+                    .append(\"\\nRoles deleted:\\n\")\n+                    .append(SyncResult.produceReport(rSuccDelete, syncTraceLevel));\n         }\n \n         return report.toString();\n@@ -228,12 +321,19 @@ protected String doExecute(final boolean dryRun) throws JobExecutionException {\n             throw new JobExecutionException(msg, e);\n         }\n \n-        final SchemaMapping accountIdMap = SchemaMappingUtil.getAccountIdMapping(syncTask.getResource().getMappings());\n-        if (accountIdMap == null) {\n-            throw new JobExecutionException(\"Invalid account id mapping for resource \" + syncTask.getResource());\n+        UMapping uMapping = syncTask.getResource().getUmapping();\n+        if (uMapping != null && uMapping.getAccountIdItem() == null) {\n+            throw new JobExecutionException(\"Invalid user account id mapping for resource \" + syncTask.getResource());\n+        }\n+        RMapping rMapping = syncTask.getResource().getRmapping();\n+        if (rMapping != null && rMapping.getAccountIdItem() == null) {\n+            throw new JobExecutionException(\"Invalid role account id mapping for resource \" + syncTask.getResource());\n+        }\n+        if (uMapping == null && rMapping == null) {\n+            return \"No mapping configured for both users and roles: aborting...\";\n         }\n \n-        LOG.debug(\"Execute synchronization with token {}\", syncTask.getResource().getSyncToken());\n+        LOG.debug(\"Execute synchronization with token {}\", syncTask.getResource().getUsyncToken());\n \n         final List<SyncResult> results = new ArrayList<SyncResult>();\n \n@@ -256,17 +356,30 @@ protected String doExecute(final boolean dryRun) throws JobExecutionException {\n         actions.beforeAll(syncTask);\n         try {\n             if (syncTask.isFullReconciliation()) {\n-                connector.getAllObjects(ObjectClass.ACCOUNT, handler,\n-                        connector.getOperationOptions(syncTask.getResource()));\n+                if (uMapping != null) {\n+                    connector.getAllObjects(ObjectClass.ACCOUNT, handler,\n+                            connector.getOperationOptions(uMapping.getItems()));\n+                }\n+                if (rMapping != null) {\n+                    connector.getAllObjects(ObjectClass.GROUP, handler,\n+                            connector.getOperationOptions(rMapping.getItems()));\n+                }\n             } else {\n-                connector.sync(ObjectClass.ACCOUNT, syncTask.getResource().getSyncToken(), handler,\n-                        connector.getOperationOptions(syncTask.getResource()));\n+                if (uMapping != null) {\n+                    connector.sync(ObjectClass.ACCOUNT, syncTask.getResource().getUsyncToken(), handler,\n+                            connector.getOperationOptions(uMapping.getItems()));\n+                }\n+                if (rMapping != null) {\n+                    connector.sync(ObjectClass.GROUP, syncTask.getResource().getUsyncToken(), handler,\n+                            connector.getOperationOptions(rMapping.getItems()));\n+                }\n             }\n \n             if (!dryRun && !syncTask.isFullReconciliation()) {\n                 try {\n                     ExternalResource resource = resourceDAO.find(syncTask.getResource().getName());\n-                    resource.setSyncToken(connector.getLatestSyncToken(ObjectClass.ACCOUNT));\n+                    resource.setUsyncToken(connector.getLatestSyncToken(ObjectClass.ACCOUNT));\n+                    resource.setRsyncToken(connector.getLatestSyncToken(ObjectClass.GROUP));\n                     resourceDAO.save(resource);\n                 } catch (Exception e) {\n                     throw new JobExecutionException(\"While updating SyncToken\", e);\n@@ -281,7 +394,7 @@ protected String doExecute(final boolean dryRun) throws JobExecutionException {\n \n         LOG.debug(\"Sync result: {}\", result);\n \n-        return result.toString();\n+        return result;\n     }\n \n     @Override"},{"sha":"0dfd10c37af1d12c157c65e0080ea5f460121946","filename":"core/src/main/java/org/apache/syncope/core/sync/SyncResult.java","status":"modified","additions":36,"deletions":34,"changes":70,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fsync%2FSyncResult.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fsync%2FSyncResult.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fsync%2FSyncResult.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -19,32 +19,27 @@\n package org.apache.syncope.core.sync;\n \n import java.util.Collection;\n-\n import org.apache.commons.lang.StringUtils;\n import org.apache.commons.lang.builder.ReflectionToStringBuilder;\n import org.apache.commons.lang.builder.ToStringStyle;\n import org.apache.syncope.core.quartz.AbstractTaskJob.Status;\n+import org.apache.syncope.types.AttributableType;\n+import org.apache.syncope.types.ResourceOperation;\n import org.apache.syncope.types.TraceLevel;\n \n public class SyncResult {\n \n-    static enum Operation {\n-\n-        CREATE,\n-        UPDATE,\n-        DELETE\n-\n-    }\n-\n     private String message;\n \n     private Status status;\n \n-    private Operation operation;\n+    private AttributableType subjectType;\n+\n+    private ResourceOperation operation;\n \n-    private Long userId;\n+    private Long id;\n \n-    private String username;\n+    private String name;\n \n     public String getMessage() {\n         return message;\n@@ -54,20 +49,20 @@ public void setMessage(final String message) {\n         this.message = message;\n     }\n \n-    public String getUsername() {\n-        return username;\n+    public String getName() {\n+        return name;\n     }\n \n-    public void setUsername(final String username) {\n-        this.username = username;\n+    public void setName(final String name) {\n+        this.name = name;\n     }\n \n-    public Long getUserId() {\n-        return userId;\n+    public Long getId() {\n+        return id;\n     }\n \n-    public void setUserId(Long userId) {\n-        this.userId = userId;\n+    public void setId(Long id) {\n+        this.id = id;\n     }\n \n     public Status getStatus() {\n@@ -78,12 +73,20 @@ public void setStatus(final Status status) {\n         this.status = status;\n     }\n \n-    public Operation getOperation() {\n-        return this.operation;\n+    public AttributableType getSubjectType() {\n+        return subjectType;\n     }\n \n-    public void setOperation(Operation t) {\n-        this.operation = t;\n+    public void setSubjectType(final AttributableType subjectType) {\n+        this.subjectType = subjectType;\n+    }\n+\n+    public ResourceOperation getOperation() {\n+        return operation;\n+    }\n+\n+    public void setOperation(final ResourceOperation operation) {\n+        this.operation = operation;\n     }\n \n     @Override\n@@ -93,6 +96,7 @@ public String toString() {\n \n     /**\n      * Human readable report string, using the given trace level.\n+     *\n      * @param level trace level\n      * @return String for certain levels, null for level NONE\n      */\n@@ -101,30 +105,28 @@ public String getReportString(final TraceLevel level) {\n             // No per entry log in this case.\n             return null;\n         } else if (level == TraceLevel.FAILURES && status == Status.FAILURE) {\n-\n             // only report failures\n-            return String.format(\"Failed %s (id/name): %d/%s with message: %s\", operation, userId, username, message);\n+            return String.format(\"Failed %s (id/name): %d/%s with message: %s\", operation, id, name, message);\n         } else {\n             // All\n-            return String.format(\"%s %s (id/ name): %d/ %s %s\", operation, status, userId, username, StringUtils\n-                    .isEmpty(message)\n+            return String.format(\"%s %s (id/name): %d/%s %s\", operation, status, id, name,\n+                    StringUtils.isBlank(message)\n                     ? \"\"\n                     : \"with message: \" + message);\n         }\n     }\n \n     /**\n-     * Helper method to invoke logging per synchronization result for the\n-     * given trace level.\n+     * Helper method to invoke logging per synchronization result for the given trace level.\n+     *\n      * @param results synchronization result\n      * @param level trace level\n      * @return report as string\n      */\n-    public static String reportSetOfSynchronizationResult(final Collection<SyncResult> results, final TraceLevel level) {\n-\n+    public static String produceReport(final Collection<SyncResult> results, final TraceLevel level) {\n         StringBuilder sb = new StringBuilder();\n-        for (SyncResult sr : results) {\n-            sb.append(sr.getReportString(level)).append(\"\\n\");\n+        for (SyncResult result : results) {\n+            sb.append(result.getReportString(level)).append(\"\\n\");\n         }\n         return sb.toString();\n     }"},{"sha":"cd867350115761e80a54fb4943f80f6c160580eb","filename":"core/src/main/java/org/apache/syncope/core/sync/SyncopeSyncResultHandler.java","status":"modified","additions":345,"deletions":217,"changes":562,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fsync%2FSyncopeSyncResultHandler.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fsync%2FSyncopeSyncResultHandler.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fsync%2FSyncopeSyncResultHandler.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -24,37 +24,48 @@\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n+import org.apache.syncope.client.mod.AbstractAttributableMod;\n+import org.apache.syncope.client.mod.RoleMod;\n import org.apache.syncope.client.mod.UserMod;\n+import org.apache.syncope.client.search.AttributableCond;\n import org.apache.syncope.client.search.AttributeCond;\n import org.apache.syncope.client.search.NodeCond;\n-import org.apache.syncope.client.search.SyncopeUserCond;\n+import org.apache.syncope.client.to.AbstractAttributableTO;\n+import org.apache.syncope.client.to.RoleTO;\n import org.apache.syncope.client.to.UserTO;\n import org.apache.syncope.core.notification.NotificationManager;\n+import org.apache.syncope.core.persistence.beans.AbstractAttrValue;\n+import org.apache.syncope.core.persistence.beans.AbstractAttributable;\n+import org.apache.syncope.core.persistence.beans.AbstractMappingItem;\n+import org.apache.syncope.core.persistence.beans.AbstractSchema;\n import org.apache.syncope.core.persistence.beans.PropagationTask;\n-import org.apache.syncope.core.persistence.beans.SchemaMapping;\n import org.apache.syncope.core.persistence.beans.SyncTask;\n+import org.apache.syncope.core.persistence.beans.role.SyncopeRole;\n import org.apache.syncope.core.persistence.beans.user.SyncopeUser;\n-import org.apache.syncope.core.persistence.beans.user.UAttrValue;\n-import org.apache.syncope.core.persistence.beans.user.USchema;\n+import org.apache.syncope.core.persistence.dao.AttributableSearchDAO;\n import org.apache.syncope.core.persistence.dao.EntitlementDAO;\n+import org.apache.syncope.core.persistence.dao.RoleDAO;\n import org.apache.syncope.core.persistence.dao.SchemaDAO;\n import org.apache.syncope.core.persistence.dao.UserDAO;\n-import org.apache.syncope.core.persistence.dao.UserSearchDAO;\n import org.apache.syncope.core.persistence.validation.attrvalue.ParsingValidationException;\n import org.apache.syncope.core.propagation.PropagationException;\n import org.apache.syncope.core.propagation.PropagationManager;\n import org.apache.syncope.core.propagation.PropagationTaskExecutor;\n import org.apache.syncope.core.quartz.AbstractTaskJob;\n import org.apache.syncope.core.rest.controller.InvalidSearchConditionException;\n import org.apache.syncope.core.rest.controller.UnauthorizedRoleException;\n+import org.apache.syncope.core.rest.data.RoleDataBinder;\n import org.apache.syncope.core.rest.data.UserDataBinder;\n+import org.apache.syncope.core.util.AttributableUtil;\n import org.apache.syncope.core.util.ConnObjectUtil;\n import org.apache.syncope.core.util.EntitlementUtil;\n import org.apache.syncope.core.util.NotFoundException;\n-import org.apache.syncope.core.util.SchemaMappingUtil;\n-import org.apache.syncope.core.workflow.UserWorkflowAdapter;\n import org.apache.syncope.core.workflow.WorkflowResult;\n+import org.apache.syncope.core.workflow.role.RoleWorkflowAdapter;\n+import org.apache.syncope.core.workflow.user.UserWorkflowAdapter;\n+import org.apache.syncope.types.AttributableType;\n import org.apache.syncope.types.ConflictResolutionAction;\n+import org.apache.syncope.types.ResourceOperation;\n import org.apache.syncope.types.SyncPolicySpec;\n import org.identityconnectors.framework.common.objects.Attribute;\n import org.identityconnectors.framework.common.objects.AttributeUtil;\n@@ -72,7 +83,7 @@ public class SyncopeSyncResultHandler implements SyncResultsHandler {\n     /**\n      * Logger.\n      */\n-    private static final Logger LOG = LoggerFactory.getLogger(SyncopeSyncResultHandler.class);\n+    protected static final Logger LOG = LoggerFactory.getLogger(SyncopeSyncResultHandler.class);\n \n     /**\n      * Entitlement DAO.\n@@ -92,11 +103,17 @@ public class SyncopeSyncResultHandler implements SyncResultsHandler {\n     @Autowired\n     private UserDAO userDAO;\n \n+    /**\n+     * Role DAO.\n+     */\n+    @Autowired\n+    private RoleDAO roleDAO;\n+\n     /**\n      * User search DAO.\n      */\n     @Autowired\n-    private UserSearchDAO userSearchDAO;\n+    private AttributableSearchDAO searchDAO;\n \n     /**\n      * ConnectorObject util.\n@@ -108,7 +125,13 @@ public class SyncopeSyncResultHandler implements SyncResultsHandler {\n      * User workflow adapter.\n      */\n     @Autowired\n-    private UserWorkflowAdapter wfAdapter;\n+    private UserWorkflowAdapter uwfAdapter;\n+\n+    /**\n+     * Role workflow adapter.\n+     */\n+    @Autowired\n+    private RoleWorkflowAdapter rwfAdapter;\n \n     /**\n      * Propagation Manager.\n@@ -128,6 +151,12 @@ public class SyncopeSyncResultHandler implements SyncResultsHandler {\n     @Autowired\n     private UserDataBinder userDataBinder;\n \n+    /**\n+     * Role data binder.\n+     */\n+    @Autowired\n+    private RoleDataBinder roleDataBinder;\n+\n     /**\n      * Notification Manager.\n      */\n@@ -178,318 +207,412 @@ public boolean handle(final SyncDelta delta) {\n         }\n     }\n \n-    /**\n-     * Find users based on mapped uid value (or previous uid value, if updated).\n-     *\n-     * @param delta sync delta\n-     * @return list of matching users\n-     */\n-    private List<Long> findExistingUsers(final SyncDelta delta) {\n-        final String uid = delta.getPreviousUid() == null\n-                ? delta.getUid().getUidValue()\n-                : delta.getPreviousUid().getUidValue();\n-\n-        // ---------------------------------\n-        // Get sync policy specification\n-        // ---------------------------------\n-        SyncPolicySpec policySpec = null;\n-        if (syncTask.getResource().getSyncPolicy() != null) {\n-            policySpec = (SyncPolicySpec) syncTask.getResource().getSyncPolicy().getSpecification();\n-        }\n-        // ---------------------------------\n-\n+    private List<Long> findByAccountIdItem(final String uid, final AttributableUtil attrUtil) {\n         final List<Long> result = new ArrayList<Long>();\n \n-        if (policySpec == null || policySpec.getAlternativeSearchAttrs().isEmpty()) {\n-            SyncopeUser found;\n-            List<SyncopeUser> users;\n-\n-            final SchemaMapping accountIdMap =\n-                    SchemaMappingUtil.getAccountIdMapping(syncTask.getResource().getMappings());\n-            switch (accountIdMap.getIntMappingType()) {\n-                case Username:\n-                    found = userDAO.find(uid);\n-                    if (found != null) {\n-                        result.add(found.getId());\n-                    }\n-                    break;\n+        final AbstractMappingItem accountIdItem = attrUtil.getAccountIdItem(syncTask.getResource());\n+        switch (accountIdItem.getIntMappingType()) {\n+            case UserSchema:\n+            case RoleSchema:\n+                final AbstractAttrValue value = attrUtil.newAttrValue();\n \n-                case SyncopeUserId:\n-                    found = userDAO.find(Long.parseLong(uid));\n-                    if (found != null) {\n-                        result.add(found.getId());\n+                AbstractSchema schema = schemaDAO.find(accountIdItem.getIntAttrName(), attrUtil.schemaClass());\n+                if (schema == null) {\n+                    value.setStringValue(uid);\n+                } else {\n+                    try {\n+                        value.parseValue(schema, uid);\n+                    } catch (ParsingValidationException e) {\n+                        LOG.error(\"While parsing provided __UID__ {}\", uid, e);\n+                        value.setStringValue(uid);\n                     }\n-                    break;\n+                }\n \n-                case UserSchema:\n-                    final UAttrValue value = new UAttrValue();\n+                List<AbstractAttributable> subjects =\n+                        userDAO.findByAttrValue(accountIdItem.getIntAttrName(), value, attrUtil);\n+                for (AbstractAttributable subject : subjects) {\n+                    result.add(subject.getId());\n+                }\n+                break;\n \n-                    USchema schema = schemaDAO.find(accountIdMap.getIntAttrName(), USchema.class);\n-                    if (schema == null) {\n-                        value.setStringValue(uid);\n-                    } else {\n-                        try {\n-                            value.parseValue(schema, uid);\n-                        } catch (ParsingValidationException e) {\n-                            LOG.error(\"While parsing provided __UID__ {}\", uid, e);\n-                            value.setStringValue(uid);\n-                        }\n+            case UserDerivedSchema:\n+            case RoleDerivedSchema:\n+                try {\n+                    subjects = userDAO.findByDerAttrValue(accountIdItem.getIntAttrName(), uid, attrUtil);\n+                    for (AbstractAttributable subject : subjects) {\n+                        result.add(subject.getId());\n                     }\n+                } catch (InvalidSearchConditionException e) {\n+                    LOG.error(\"Could not search for matching subjects\", e);\n+                }\n+                break;\n \n-                    users = userDAO.findByAttrValue(accountIdMap.getIntAttrName(), value);\n-                    for (SyncopeUser user : users) {\n-                        result.add(user.getId());\n-                    }\n-                    break;\n+            case Username:\n+                SyncopeUser user = userDAO.find(uid);\n+                if (user != null) {\n+                    result.add(user.getId());\n+                }\n+                break;\n \n-                case UserDerivedSchema:\n-                    try {\n-                        users = userDAO.findByDerAttrValue(accountIdMap.getIntAttrName(), uid);\n-                        for (SyncopeUser user : users) {\n-                            result.add(user.getId());\n-                        }\n-                    } catch (InvalidSearchConditionException e) {\n-                        LOG.error(\"Could not search for matching users\", e);\n-                    }\n-                    break;\n+            case UserId:\n+                user = userDAO.find(Long.parseLong(uid));\n+                if (user != null) {\n+                    result.add(user.getId());\n+                }\n+                break;\n \n-                default:\n-                    LOG.error(\"Invalid accountId type '{}'\", accountIdMap.getIntMappingType());\n-            }\n-        } else {\n-            // search for external attribute's name/value of each specified name\n+            case RoleName:\n+                List<SyncopeRole> roles = roleDAO.find(uid);\n+                for (SyncopeRole role : roles) {\n+                    result.add(role.getId());\n+                }\n+                break;\n \n-            final Map<String, Attribute> extValues = new HashMap<String, Attribute>();\n+            case RoleId:\n+                SyncopeRole role = roleDAO.find(Long.parseLong(uid));\n+                if (role != null) {\n+                    result.add(role.getId());\n+                }\n+                break;\n \n-            for (SchemaMapping mapping : syncTask.getResource().getMappings()) {\n-                extValues.put(SchemaMappingUtil.getIntAttrName(mapping),\n-                        delta.getObject().getAttributeByName(SchemaMappingUtil.getExtAttrName(mapping)));\n-            }\n+            default:\n+                LOG.error(\"Invalid accountId type '{}'\", accountIdItem.getIntMappingType());\n+        }\n+\n+        return result;\n+    }\n \n-            // search for user by attribute(s) specified in the policy\n-            NodeCond searchCond = null;\n+    private List<Long> findByAttributableSearch(final SyncDelta delta, final SyncPolicySpec policySpec,\n+            final AttributableUtil attrUtil) {\n \n-            for (String schema : policySpec.getAlternativeSearchAttrs()) {\n-                Attribute value = extValues.get(schema);\n+        final List<Long> result = new ArrayList<Long>();\n \n-                AttributeCond.Type type;\n-                String expression = null;\n+        // search for external attribute's name/value of each specified name\n \n-                if (value == null || value.getValue() == null || value.getValue().isEmpty()) {\n-                    type = AttributeCond.Type.ISNULL;\n-                } else {\n-                    type = AttributeCond.Type.EQ;\n-                    expression = value.getValue().size() > 1\n-                            ? value.getValue().toString()\n-                            : value.getValue().get(0).toString();\n-                }\n+        final Map<String, Attribute> extValues = new HashMap<String, Attribute>();\n \n-                NodeCond nodeCond;\n-                // just Username or SyncopeUserId can be selected to be used\n-                if (\"id\".equalsIgnoreCase(schema) || \"username\".equalsIgnoreCase(schema)) {\n-                    SyncopeUserCond cond = new SyncopeUserCond();\n-                    cond.setSchema(schema);\n-                    cond.setType(type);\n-                    cond.setExpression(expression);\n+        for (AbstractMappingItem item : attrUtil.getMappingItems(syncTask.getResource())) {\n+            extValues.put(item.getIntAttrName(), delta.getObject().getAttributeByName(item.getExtAttrName()));\n+        }\n \n-                    nodeCond = NodeCond.getLeafCond(cond);\n-                } else {\n-                    AttributeCond cond = new AttributeCond();\n-                    cond.setSchema(schema);\n-                    cond.setType(type);\n-                    cond.setExpression(expression);\n+        // search for user/role by attribute(s) specified in the policy\n+        NodeCond searchCond = null;\n \n-                    nodeCond = NodeCond.getLeafCond(cond);\n-                }\n+        for (String schema : attrUtil.getAltSearchSchemas(policySpec)) {\n+            Attribute value = extValues.get(schema);\n \n-                searchCond = searchCond == null\n-                        ? nodeCond\n-                        : NodeCond.getAndCond(searchCond, nodeCond);\n+            AttributeCond.Type type;\n+            String expression = null;\n+\n+            if (value == null || value.getValue() == null || value.getValue().isEmpty()) {\n+                type = AttributeCond.Type.ISNULL;\n+            } else {\n+                type = AttributeCond.Type.EQ;\n+                expression = value.getValue().size() > 1\n+                        ? value.getValue().toString()\n+                        : value.getValue().get(0).toString();\n             }\n \n-            final List<SyncopeUser> users =\n-                    userSearchDAO.search(EntitlementUtil.getRoleIds(entitlementDAO.findAll()), searchCond);\n-            for (SyncopeUser user : users) {\n-                result.add(user.getId());\n+            NodeCond nodeCond;\n+            // users: just id or username can be selected to be used\n+            // roles: just id or name can be selected to be used\n+            if (\"id\".equalsIgnoreCase(schema) || \"username\".equalsIgnoreCase(schema)\n+                    || \"name\".equalsIgnoreCase(schema)) {\n+\n+                AttributableCond cond = new AttributableCond();\n+                cond.setSchema(schema);\n+                cond.setType(type);\n+                cond.setExpression(expression);\n+\n+                nodeCond = NodeCond.getLeafCond(cond);\n+            } else {\n+                AttributeCond cond = new AttributeCond();\n+                cond.setSchema(schema);\n+                cond.setType(type);\n+                cond.setExpression(expression);\n+\n+                nodeCond = NodeCond.getLeafCond(cond);\n             }\n+\n+            searchCond = searchCond == null\n+                    ? nodeCond\n+                    : NodeCond.getAndCond(searchCond, nodeCond);\n+        }\n+\n+        final List<AbstractAttributable> subjects = searchDAO.search(\n+                EntitlementUtil.getRoleIds(entitlementDAO.findAll()), searchCond, attrUtil);\n+        for (AbstractAttributable subject : subjects) {\n+            result.add(subject.getId());\n         }\n \n         return result;\n     }\n \n-    private List<SyncResult> createUser(SyncDelta delta, final boolean dryRun) throws JobExecutionException {\n+    /**\n+     * Find users / roles based on mapped uid value (or previous uid value, if updated).\n+     *\n+     * @param delta sync delta\n+     * @param attrUtil attributable util\n+     * @return list of matching users / roles\n+     */\n+    protected List<Long> findExisting(final SyncDelta delta, final AttributableUtil attrUtil) {\n+        final String uid = delta.getPreviousUid() == null\n+                ? delta.getUid().getUidValue()\n+                : delta.getPreviousUid().getUidValue();\n+\n+        SyncPolicySpec policySpec = null;\n+        if (syncTask.getResource().getSyncPolicy() != null) {\n+            policySpec = (SyncPolicySpec) syncTask.getResource().getSyncPolicy().getSpecification();\n+        }\n+\n+        return policySpec == null || attrUtil.getAltSearchSchemas(policySpec).isEmpty()\n+                ? findByAccountIdItem(uid, attrUtil)\n+                : findByAttributableSearch(delta, policySpec, attrUtil);\n+    }\n+\n+    protected List<SyncResult> create(SyncDelta delta, final AttributableUtil attrUtil,\n+            final boolean dryRun) throws JobExecutionException {\n+\n         if (!syncTask.isPerformCreate()) {\n             LOG.debug(\"SyncTask not configured for create\");\n-            return Collections.emptyList();\n+            return Collections.EMPTY_LIST;\n         }\n \n         final SyncResult result = new SyncResult();\n-        result.setOperation(SyncResult.Operation.CREATE);\n+        result.setOperation(ResourceOperation.CREATE);\n+        result.setSubjectType(attrUtil.getType());\n \n-        UserTO userTO = connObjectUtil.getUserTO(delta.getObject(), syncTask);\n+        AbstractAttributableTO subjectTO = connObjectUtil.getAttributableTO(delta.getObject(), syncTask, attrUtil);\n \n-        delta = actions.beforeCreate(delta, userTO);\n+        delta = actions.beforeCreate(delta, subjectTO);\n \n         if (dryRun) {\n-            result.setUserId(0L);\n-            result.setUsername(userTO.getUsername());\n+            result.setId(0L);\n+            if (subjectTO instanceof UserTO) {\n+                result.setName(((UserTO) subjectTO).getUsername());\n+            }\n+            if (subjectTO instanceof RoleTO) {\n+                result.setName(((RoleTO) subjectTO).getName());\n+            }\n             result.setStatus(AbstractTaskJob.Status.SUCCESS);\n         } else {\n             try {\n-                // --------------------------\n-                // Check for status synchronization ...\n-                // --------------------------\n-                Boolean enabled = null;\n-                if (syncTask.isSyncStatus()) {\n-                    Attribute status = AttributeUtil.find(OperationalAttributes.ENABLE_NAME,\n-                            delta.getObject().getAttributes());\n-                    if (status != null && status.getValue() != null && !status.getValue().isEmpty()) {\n-                        enabled = (Boolean) status.getValue().get(0);\n+                if (AttributableType.USER == attrUtil.getType()) {\n+                    // --------------------------\n+                    // Check for status synchronization ...\n+                    // --------------------------\n+                    Boolean enabled = null;\n+                    if (syncTask.isSyncStatus()) {\n+                        Attribute status = AttributeUtil.find(OperationalAttributes.ENABLE_NAME,\n+                                delta.getObject().getAttributes());\n+                        if (status != null && status.getValue() != null && !status.getValue().isEmpty()) {\n+                            enabled = (Boolean) status.getValue().get(0);\n+                        }\n                     }\n+                    // --------------------------\n+\n+                    WorkflowResult<Map.Entry<Long, Boolean>> created =\n+                            uwfAdapter.create((UserTO) subjectTO, true, enabled);\n+\n+                    List<PropagationTask> tasks = propagationManager.getUserCreateTaskIds(created,\n+                            ((UserTO) subjectTO).getPassword(), subjectTO.getVirtualAttributes(),\n+                            Collections.singleton(syncTask.getResource().getName()));\n+\n+                    taskExecutor.execute(tasks);\n+\n+                    notificationManager.createTasks(created.getResult().getKey(), created.getPerformedTasks());\n+\n+                    subjectTO = userDataBinder.getUserTO(created.getResult().getKey());\n+\n+                    result.setId(created.getResult().getKey());\n                 }\n-                // --------------------------\n+                if (AttributableType.ROLE == attrUtil.getType()) {\n+                    WorkflowResult<Long> created = rwfAdapter.create((RoleTO) subjectTO);\n \n-                WorkflowResult<Map.Entry<Long, Boolean>> created = wfAdapter.create(userTO, true, enabled);\n+                    EntitlementUtil.extendAuthContext(created.getResult());\n \n-                List<PropagationTask> tasks = propagationManager.getCreateTaskIds(created, userTO.getPassword(),\n-                        userTO.getVirtualAttributes(), Collections.singleton(syncTask.getResource().getName()));\n+                    List<PropagationTask> tasks = propagationManager.getRoleCreateTaskIds(created,\n+                            subjectTO.getVirtualAttributes(), Collections.singleton(syncTask.getResource().getName()));\n \n-                taskExecutor.execute(tasks);\n+                    taskExecutor.execute(tasks);\n \n-                notificationManager.createTasks(created.getResult().getKey(), created.getPerformedTasks());\n+                    subjectTO = roleDataBinder.getRoleTO(created.getResult());\n \n-                userTO = userDataBinder.getUserTO(created.getResult().getKey());\n+                    result.setId(created.getResult());\n+                }\n \n-                result.setUserId(created.getResult().getKey());\n-                result.setUsername(userTO.getUsername());\n+                if (subjectTO instanceof UserTO) {\n+                    result.setName(((UserTO) subjectTO).getUsername());\n+                }\n+                if (subjectTO instanceof RoleTO) {\n+                    result.setName(((RoleTO) subjectTO).getName());\n+                }\n                 result.setStatus(AbstractTaskJob.Status.SUCCESS);\n             } catch (PropagationException e) {\n-                LOG.error(\"Could not propagate user \" + delta.getUid().getUidValue(), e);\n+                LOG.error(\"Could not propagate {} {}\", attrUtil.getType(), delta.getUid().getUidValue(), e);\n             } catch (Exception e) {\n                 result.setStatus(AbstractTaskJob.Status.FAILURE);\n                 result.setMessage(e.getMessage());\n-                LOG.error(\"Could not create user \" + delta.getUid().getUidValue(), e);\n+                LOG.error(\"Could not create {} {} \", attrUtil.getType(), delta.getUid().getUidValue(), e);\n             }\n         }\n \n-        actions.after(delta, userTO, result);\n+        actions.after(delta, subjectTO, result);\n         return Collections.singletonList(result);\n     }\n \n-    private List<SyncResult> updateUsers(SyncDelta delta, final List<Long> users, final boolean dryRun)\n-            throws JobExecutionException {\n+    protected List<SyncResult> update(SyncDelta delta, final List<Long> subjects, final AttributableUtil attrUtil,\n+            final boolean dryRun) throws JobExecutionException {\n \n         if (!syncTask.isPerformUpdate()) {\n             LOG.debug(\"SyncTask not configured for update\");\n-            return Collections.emptyList();\n+            return Collections.EMPTY_LIST;\n         }\n \n-        LOG.debug(\"About to update {}\", users);\n+        LOG.debug(\"About to update {}\", subjects);\n \n-        List<SyncResult> results = new ArrayList<SyncResult>();\n+        List<SyncResult> updResults = new ArrayList<SyncResult>();\n \n-        for (Long userId : users) {\n+        for (Long id : subjects) {\n             final SyncResult result = new SyncResult();\n-            result.setOperation(SyncResult.Operation.UPDATE);\n+            result.setOperation(ResourceOperation.UPDATE);\n+            result.setSubjectType(attrUtil.getType());\n \n             try {\n-                UserTO userTO = userDataBinder.getUserTO(userId);\n+                AbstractAttributableTO subjectTO = AttributableType.USER == attrUtil.getType()\n+                        ? userDataBinder.getUserTO(id)\n+                        : roleDataBinder.getRoleTO(id);\n                 try {\n-\n-                    final UserMod userMod = connObjectUtil.getUserMod(userId, delta.getObject(), syncTask);\n-                    delta = actions.beforeUpdate(delta, userTO, userMod);\n+                    final AbstractAttributableMod mod = connObjectUtil.getAttributableMod(\n+                            id, delta.getObject(), subjectTO, syncTask, attrUtil);\n+                    delta = actions.beforeUpdate(delta, subjectTO, mod);\n \n                     result.setStatus(AbstractTaskJob.Status.SUCCESS);\n-                    result.setUserId(userMod.getId());\n-                    result.setUsername(userMod.getUsername());\n+                    result.setId(mod.getId());\n+                    if (mod instanceof UserMod) {\n+                        result.setName(((UserMod) mod).getUsername());\n+                    }\n+                    if (mod instanceof RoleMod) {\n+                        result.setName(((RoleMod) mod).getName());\n+                    }\n \n                     if (!dryRun) {\n-                        WorkflowResult<Map.Entry<Long, Boolean>> updated = wfAdapter.update(userMod);\n+                        if (AttributableType.USER == attrUtil.getType()) {\n+                            WorkflowResult<Map.Entry<Long, Boolean>> updated = uwfAdapter.update((UserMod) mod);\n \n-                        List<PropagationTask> tasks = propagationManager.getUpdateTaskIds(updated,\n-                                userMod.getPassword(), userMod.getVirtualAttributesToBeRemoved(),\n-                                userMod.getVirtualAttributesToBeUpdated(),\n-                                Collections.singleton(syncTask.getResource().getName()));\n+                            List<PropagationTask> tasks = propagationManager.getUserUpdateTaskIds(updated,\n+                                    ((UserMod) mod).getPassword(), mod.getVirtualAttributesToBeRemoved(),\n+                                    mod.getVirtualAttributesToBeUpdated(),\n+                                    Collections.singleton(syncTask.getResource().getName()));\n \n-                        taskExecutor.execute(tasks);\n+                            taskExecutor.execute(tasks);\n+\n+                            notificationManager.createTasks(updated.getResult().getKey(), updated.getPerformedTasks());\n \n-                        notificationManager.createTasks(updated.getResult().getKey(), updated.getPerformedTasks());\n+                            subjectTO = userDataBinder.getUserTO(updated.getResult().getKey());\n+                        }\n+                        if (AttributableType.ROLE == attrUtil.getType()) {\n+                            WorkflowResult<Long> updated = rwfAdapter.update((RoleMod) mod);\n+\n+                            List<PropagationTask> tasks = propagationManager.getRoleUpdateTaskIds(updated,\n+                                    mod.getVirtualAttributesToBeRemoved(), mod.getVirtualAttributesToBeUpdated(),\n+                                    Collections.singleton(syncTask.getResource().getName()));\n \n-                        userTO = userDataBinder.getUserTO(updated.getResult().getKey());\n+                            taskExecutor.execute(tasks);\n+\n+                            subjectTO = roleDataBinder.getRoleTO(updated.getResult());\n+                        }\n                     }\n                 } catch (PropagationException e) {\n-                    LOG.error(\"Could not propagate user \" + delta.getUid().getUidValue(), e);\n+                    LOG.error(\"Could not propagate {} {}\", attrUtil.getType(), delta.getUid().getUidValue(), e);\n                 } catch (Exception e) {\n                     result.setStatus(AbstractTaskJob.Status.FAILURE);\n                     result.setMessage(e.getMessage());\n-                    LOG.error(\"Could not update user \" + delta.getUid().getUidValue(), e);\n+                    LOG.error(\"Could not update {} {}\", attrUtil.getType(), delta.getUid().getUidValue(), e);\n                 }\n \n-                actions.after(delta, userTO, result);\n-                results.add(result);\n+                actions.after(delta, subjectTO, result);\n+                updResults.add(result);\n             } catch (NotFoundException e) {\n-                LOG.error(\"Could not find user {}\", userId, e);\n+                LOG.error(\"Could not find {} {}\", attrUtil.getType(), id, e);\n             } catch (UnauthorizedRoleException e) {\n-                LOG.error(\"Not allowed to read user {}\", userId, e);\n+                LOG.error(\"Not allowed to read {} {}\", attrUtil.getType(), id, e);\n             }\n         }\n \n-        return results;\n+        return updResults;\n     }\n \n-    private List<SyncResult> deleteUsers(SyncDelta delta, final List<Long> users, final boolean dryRun)\n-            throws JobExecutionException {\n+    protected List<SyncResult> delete(SyncDelta delta, final List<Long> subjects, final AttributableUtil attrUtil,\n+            final boolean dryRun) throws JobExecutionException {\n \n         if (!syncTask.isPerformDelete()) {\n             LOG.debug(\"SyncTask not configured for delete\");\n-            return Collections.emptyList();\n+            return Collections.EMPTY_LIST;\n         }\n \n-        LOG.debug(\"About to delete {}\", users);\n+        LOG.debug(\"About to delete {}\", subjects);\n \n-        List<SyncResult> results = new ArrayList<SyncResult>();\n+        List<SyncResult> delResults = new ArrayList<SyncResult>();\n \n-        for (Long userId : users) {\n+        for (Long id : subjects) {\n             try {\n-                UserTO userTO = userDataBinder.getUserTO(userId);\n-                delta = actions.beforeDelete(delta, userTO);\n+                AbstractAttributableTO subjectTO = AttributableType.USER == attrUtil.getType()\n+                        ? userDataBinder.getUserTO(id)\n+                        : roleDataBinder.getRoleTO(id);\n+                delta = actions.beforeDelete(delta, subjectTO);\n \n                 final SyncResult result = new SyncResult();\n-                result.setUserId(userId);\n-                result.setUsername(userTO.getUsername());\n-                result.setOperation(SyncResult.Operation.DELETE);\n+                result.setId(id);\n+                if (subjectTO instanceof UserTO) {\n+                    result.setName(((UserTO) subjectTO).getUsername());\n+                }\n+                if (subjectTO instanceof RoleTO) {\n+                    result.setName(((RoleTO) subjectTO).getName());\n+                }\n+                result.setOperation(ResourceOperation.DELETE);\n+                result.setSubjectType(attrUtil.getType());\n                 result.setStatus(AbstractTaskJob.Status.SUCCESS);\n \n                 if (!dryRun) {\n                     try {\n-                        List<PropagationTask> tasks = propagationManager.getDeleteTaskIds(userId,\n-                                syncTask.getResource().getName());\n+                        List<PropagationTask> tasks = Collections.EMPTY_LIST;\n+                        if (AttributableType.USER == attrUtil.getType()) {\n+                            tasks = propagationManager.getUserDeleteTaskIds(id, syncTask.getResource().getName());\n+                            notificationManager.createTasks(id, Collections.singleton(\"delete\"));\n+                        }\n+                        if (AttributableType.ROLE == attrUtil.getType()) {\n+                            tasks = propagationManager.getRoleDeleteTaskIds(id, syncTask.getResource().getName());\n+                        }\n                         taskExecutor.execute(tasks);\n-\n-                        notificationManager.createTasks(userId, Collections.singleton(\"delete\"));\n                     } catch (Exception e) {\n-                        LOG.error(\"Could not propagate user \" + userId, e);\n+                        LOG.error(\"Could not propagate user \" + id, e);\n                     }\n \n                     try {\n-                        wfAdapter.delete(userId);\n+                        if (AttributableType.USER == attrUtil.getType()) {\n+                            uwfAdapter.delete(id);\n+                        }\n+                        if (AttributableType.ROLE == attrUtil.getType()) {\n+                            rwfAdapter.delete(id);\n+                        }\n                     } catch (Exception e) {\n                         result.setStatus(AbstractTaskJob.Status.FAILURE);\n                         result.setMessage(e.getMessage());\n-                        LOG.error(\"Could not delete user \" + userId, e);\n+                        LOG.error(\"Could not delete {} {}\", attrUtil.getType(), id, e);\n                     }\n                 }\n \n-                actions.after(delta, userTO, result);\n-                results.add(result);\n+                actions.after(delta, subjectTO, result);\n+                delResults.add(result);\n             } catch (NotFoundException e) {\n-                LOG.error(\"Could not find user {}\", userId, e);\n+                LOG.error(\"Could not find {} {}\", attrUtil.getType(), id, e);\n             } catch (UnauthorizedRoleException e) {\n-                LOG.error(\"Not allowed to read user {}\", userId, e);\n+                LOG.error(\"Not allowed to read {} {}\", attrUtil.getType(), id, e);\n             }\n         }\n \n-        return results;\n+        return delResults;\n     }\n \n     /**\n@@ -502,31 +625,35 @@ private List<SyncResult> deleteUsers(SyncDelta delta, final List<Long> users, fi\n     protected final List<SyncResult> doHandle(final SyncDelta delta) throws JobExecutionException {\n         final List<SyncResult> results = new ArrayList<SyncResult>();\n \n-        LOG.debug(\"Process '{}' for '{}'\", delta.getDeltaType(), delta.getUid().getUidValue());\n+        LOG.debug(\"Process {} for {} as {}\",\n+                delta.getDeltaType(), delta.getUid().getUidValue(), delta.getObject().getObjectClass());\n+\n+        AttributableUtil attrUtil = AttributableUtil.getInstance(delta.getObject().getObjectClass());\n \n-        final List<Long> users = findExistingUsers(delta);\n+        final List<Long> subjects = findExisting(delta, attrUtil);\n \n         if (SyncDeltaType.CREATE_OR_UPDATE == delta.getDeltaType()) {\n-            if (users.isEmpty()) {\n-                results.addAll(createUser(delta, dryRun));\n-            } else if (users.size() == 1) {\n-                results.addAll(updateUsers(delta, users.subList(0, 1), dryRun));\n+            if (subjects.isEmpty()) {\n+                results.addAll(create(delta, attrUtil, dryRun));\n+            } else if (subjects.size() == 1) {\n+                results.addAll(update(delta, subjects.subList(0, 1), attrUtil, dryRun));\n             } else {\n                 switch (resAct) {\n                     case IGNORE:\n-                        LOG.error(\"More than one match {}\", users);\n+                        LOG.error(\"More than one match {}\", subjects);\n                         break;\n \n                     case FIRSTMATCH:\n-                        results.addAll(updateUsers(delta, users.subList(0, 1), dryRun));\n+                        results.addAll(update(delta, subjects.subList(0, 1), attrUtil, dryRun));\n                         break;\n \n                     case LASTMATCH:\n-                        results.addAll(updateUsers(delta, users.subList(users.size() - 1, users.size()), dryRun));\n+                        results.addAll(update(delta, subjects.subList(subjects.size() - 1, subjects.size()), attrUtil,\n+                                dryRun));\n                         break;\n \n                     case ALL:\n-                        results.addAll(updateUsers(delta, users, dryRun));\n+                        results.addAll(update(delta, subjects, attrUtil, dryRun));\n                         break;\n \n                     default:\n@@ -535,26 +662,27 @@ protected final List<SyncResult> doHandle(final SyncDelta delta) throws JobExecu\n         }\n \n         if (SyncDeltaType.DELETE == delta.getDeltaType()) {\n-            if (users.isEmpty()) {\n+            if (subjects.isEmpty()) {\n                 LOG.debug(\"No match found for deletion\");\n-            } else if (users.size() == 1) {\n-                results.addAll(deleteUsers(delta, users, dryRun));\n+            } else if (subjects.size() == 1) {\n+                results.addAll(delete(delta, subjects, attrUtil, dryRun));\n             } else {\n                 switch (resAct) {\n                     case IGNORE:\n-                        LOG.error(\"More than one match {}\", users);\n+                        LOG.error(\"More than one match {}\", subjects);\n                         break;\n \n                     case FIRSTMATCH:\n-                        results.addAll(deleteUsers(delta, users.subList(0, 1), dryRun));\n+                        results.addAll(delete(delta, subjects.subList(0, 1), attrUtil, dryRun));\n                         break;\n \n                     case LASTMATCH:\n-                        results.addAll(deleteUsers(delta, users.subList(users.size() - 1, users.size()), dryRun));\n+                        results.addAll(delete(delta, subjects.subList(subjects.size() - 1, subjects.size()), attrUtil,\n+                                dryRun));\n                         break;\n \n                     case ALL:\n-                        results.addAll(deleteUsers(delta, users, dryRun));\n+                        results.addAll(delete(delta, subjects, attrUtil, dryRun));\n                         break;\n \n                     default:"},{"sha":"88d72595f56ce3e1968b129ec049c6ebaf7851ed","filename":"core/src/main/java/org/apache/syncope/core/util/AttributableUtil.java","status":"modified","additions":228,"deletions":0,"changes":228,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Futil%2FAttributableUtil.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Futil%2FAttributableUtil.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Futil%2FAttributableUtil.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -18,13 +18,22 @@\n  */\n package org.apache.syncope.core.util;\n \n+import java.util.Collections;\n+import java.util.List;\n+import org.apache.syncope.client.to.AbstractAttributableTO;\n+import org.apache.syncope.client.to.MembershipTO;\n+import org.apache.syncope.client.to.RoleTO;\n+import org.apache.syncope.client.to.UserTO;\n import org.apache.syncope.core.persistence.beans.AbstractAttr;\n import org.apache.syncope.core.persistence.beans.AbstractAttrValue;\n+import org.apache.syncope.core.persistence.beans.AbstractAttributable;\n import org.apache.syncope.core.persistence.beans.AbstractDerAttr;\n import org.apache.syncope.core.persistence.beans.AbstractDerSchema;\n+import org.apache.syncope.core.persistence.beans.AbstractMappingItem;\n import org.apache.syncope.core.persistence.beans.AbstractSchema;\n import org.apache.syncope.core.persistence.beans.AbstractVirAttr;\n import org.apache.syncope.core.persistence.beans.AbstractVirSchema;\n+import org.apache.syncope.core.persistence.beans.ExternalResource;\n import org.apache.syncope.core.persistence.beans.membership.MAttr;\n import org.apache.syncope.core.persistence.beans.membership.MAttrUniqueValue;\n import org.apache.syncope.core.persistence.beans.membership.MAttrValue;\n@@ -33,24 +42,31 @@\n import org.apache.syncope.core.persistence.beans.membership.MSchema;\n import org.apache.syncope.core.persistence.beans.membership.MVirAttr;\n import org.apache.syncope.core.persistence.beans.membership.MVirSchema;\n+import org.apache.syncope.core.persistence.beans.membership.Membership;\n import org.apache.syncope.core.persistence.beans.role.RAttr;\n import org.apache.syncope.core.persistence.beans.role.RAttrUniqueValue;\n import org.apache.syncope.core.persistence.beans.role.RAttrValue;\n import org.apache.syncope.core.persistence.beans.role.RDerAttr;\n import org.apache.syncope.core.persistence.beans.role.RDerSchema;\n+import org.apache.syncope.core.persistence.beans.role.RMappingItem;\n import org.apache.syncope.core.persistence.beans.role.RSchema;\n import org.apache.syncope.core.persistence.beans.role.RVirAttr;\n import org.apache.syncope.core.persistence.beans.role.RVirSchema;\n+import org.apache.syncope.core.persistence.beans.role.SyncopeRole;\n+import org.apache.syncope.core.persistence.beans.user.SyncopeUser;\n import org.apache.syncope.core.persistence.beans.user.UAttr;\n import org.apache.syncope.core.persistence.beans.user.UAttrUniqueValue;\n import org.apache.syncope.core.persistence.beans.user.UAttrValue;\n import org.apache.syncope.core.persistence.beans.user.UDerAttr;\n import org.apache.syncope.core.persistence.beans.user.UDerSchema;\n+import org.apache.syncope.core.persistence.beans.user.UMappingItem;\n import org.apache.syncope.core.persistence.beans.user.USchema;\n import org.apache.syncope.core.persistence.beans.user.UVirAttr;\n import org.apache.syncope.core.persistence.beans.user.UVirSchema;\n import org.apache.syncope.types.AttributableType;\n import org.apache.syncope.types.IntMappingType;\n+import org.apache.syncope.types.SyncPolicySpec;\n+import org.identityconnectors.framework.common.objects.ObjectClass;\n \n public class AttributableUtil {\n \n@@ -64,14 +80,154 @@ public static AttributableUtil valueOf(final String name) {\n         return new AttributableUtil(AttributableType.valueOf(name));\n     }\n \n+    public static AttributableUtil getInstance(final ObjectClass objectClass) {\n+        AttributableType type = null;\n+        if (ObjectClass.ACCOUNT.equals(objectClass)) {\n+            type = AttributableType.USER;\n+        }\n+        if (ObjectClass.GROUP.equals(objectClass)) {\n+            type = AttributableType.ROLE;\n+        }\n+\n+        if (type == null) {\n+            throw new IllegalArgumentException(\"ObjectClass not supported: \" + objectClass);\n+        }\n+\n+        return new AttributableUtil(type);\n+    }\n+\n+    public static AttributableUtil getInstance(final AbstractAttributable attributable) {\n+        AttributableType type = null;\n+        if (attributable instanceof SyncopeUser) {\n+            type = AttributableType.USER;\n+        }\n+        if (attributable instanceof SyncopeRole) {\n+            type = AttributableType.ROLE;\n+        }\n+        if (attributable instanceof Membership) {\n+            type = AttributableType.MEMBERSHIP;\n+        }\n+\n+        if (type == null) {\n+            throw new IllegalArgumentException(\"Attributable type not supported: \" + attributable.getClass().getName());\n+        }\n+\n+        return new AttributableUtil(type);\n+    }\n+\n     private AttributableUtil(final AttributableType type) {\n         this.type = type;\n     }\n \n+    public <T extends AbstractAttributable> Class<T> attributableClass() {\n+        Class result;\n+\n+        switch (type) {\n+            case ROLE:\n+                result = SyncopeRole.class;\n+                break;\n+            case MEMBERSHIP:\n+                result = Membership.class;\n+            case USER:\n+            default:\n+                result = SyncopeUser.class;\n+                break;\n+        }\n+\n+        return result;\n+    }\n+\n     public AttributableType getType() {\n         return type;\n     }\n \n+    public String getAccountLink(final ExternalResource resource) {\n+        String result = null;\n+\n+        if (resource != null) {\n+            switch (type) {\n+                case USER:\n+                    if (resource.getUmapping() != null) {\n+                        result = resource.getUmapping().getAccountLink();\n+                    }\n+                    break;\n+                case ROLE:\n+                    if (resource.getRmapping() != null) {\n+                        result = resource.getRmapping().getAccountLink();\n+                    }\n+                    break;\n+                case MEMBERSHIP:\n+                default:\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    public <T extends AbstractMappingItem> T getAccountIdItem(final ExternalResource resource) {\n+        T result = null;\n+\n+        if (resource != null) {\n+            switch (type) {\n+                case USER:\n+                    if (resource.getUmapping() != null) {\n+                        result = resource.getUmapping().getAccountIdItem();\n+                    }\n+                    break;\n+                case ROLE:\n+                    if (resource.getRmapping() != null) {\n+                        result = resource.getRmapping().getAccountIdItem();\n+                    }\n+                    break;\n+                case MEMBERSHIP:\n+                default:\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    public <T extends AbstractMappingItem> List<T> getMappingItems(final ExternalResource resource) {\n+        List<T> result = Collections.EMPTY_LIST;\n+\n+        if (resource != null) {\n+            switch (type) {\n+                case USER:\n+                    if (resource.getUmapping() != null) {\n+                        result = resource.getUmapping().getItems();\n+                    }\n+                    break;\n+                case ROLE:\n+                    if (resource.getRmapping() != null) {\n+                        result = resource.getRmapping().getItems();\n+                    }\n+                    break;\n+                case MEMBERSHIP:\n+                default:\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    public <T extends AbstractMappingItem> Class<T> mappingItemClass() {\n+        Class result;\n+\n+        switch (type) {\n+            case USER:\n+                result = UMappingItem.class;\n+                break;\n+            case ROLE:\n+                result = RMappingItem.class;\n+                break;\n+            case MEMBERSHIP:\n+            default:\n+                result = AbstractMappingItem.class;\n+        }\n+\n+        return result;\n+    }\n+\n     public IntMappingType intMappingType() {\n         IntMappingType result;\n \n@@ -381,6 +537,24 @@ public <T extends AbstractAttrValue> T newAttrValue() {\n         return result;\n     }\n \n+    public <T extends AbstractAttrValue> Class<T> attrUniqueValueClass() {\n+        Class result = null;\n+\n+        switch (type) {\n+            case USER:\n+                result = UAttrUniqueValue.class;\n+                break;\n+            case ROLE:\n+                result = RAttrUniqueValue.class;\n+                break;\n+            case MEMBERSHIP:\n+                result = MAttrUniqueValue.class;\n+                break;\n+        }\n+\n+        return result;\n+    }\n+\n     public <T extends AbstractAttrValue> T newAttrUniqueValue() {\n         T result = null;\n \n@@ -398,4 +572,58 @@ public <T extends AbstractAttrValue> T newAttrUniqueValue() {\n \n         return result;\n     }\n+\n+    public List<String> getAltSearchSchemas(final SyncPolicySpec policySpec) {\n+        List<String> result = Collections.EMPTY_LIST;\n+\n+        if (policySpec != null) {\n+            switch (type) {\n+                case USER:\n+                    result = policySpec.getuAltSearchSchemas();\n+                    break;\n+                case ROLE:\n+                    result = policySpec.getrAltSearchSchemas();\n+                    break;\n+                case MEMBERSHIP:\n+                default:\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    public String searchView() {\n+        String result = \"\";\n+\n+        switch (type) {\n+            case USER:\n+                result = \"user_search\";\n+                break;\n+            case ROLE:\n+                result = \"role_search\";\n+                break;\n+            case MEMBERSHIP:\n+            default:\n+        }\n+\n+        return result;\n+    }\n+\n+    public <T extends AbstractAttributableTO> T newAttributableTO() {\n+        T result = null;\n+\n+        switch (type) {\n+            case USER:\n+                result = (T) new UserTO();\n+                break;\n+            case ROLE:\n+                result = (T) new RoleTO();\n+                break;\n+            case MEMBERSHIP:\n+                result = (T) new MembershipTO();\n+                break;\n+        }\n+\n+        return result;\n+    }\n }"},{"sha":"a93f12096f03856565d31a9da3b2507f8498f8fc","filename":"core/src/main/java/org/apache/syncope/core/util/ConnObjectUtil.java","status":"modified","additions":179,"deletions":101,"changes":280,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Futil%2FConnObjectUtil.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Futil%2FConnObjectUtil.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Futil%2FConnObjectUtil.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -28,18 +28,19 @@\n import java.util.Set;\n import org.apache.commons.lang.RandomStringUtils;\n import org.apache.commons.lang.StringUtils;\n-import org.apache.syncope.client.mod.UserMod;\n+import org.apache.syncope.client.mod.AbstractAttributableMod;\n import org.apache.syncope.client.to.AbstractAttributableTO;\n import org.apache.syncope.client.to.AttributeTO;\n import org.apache.syncope.client.to.ConnObjectTO;\n import org.apache.syncope.client.to.MembershipTO;\n+import org.apache.syncope.client.to.RoleTO;\n import org.apache.syncope.client.to.UserTO;\n import org.apache.syncope.client.util.AttributableOperations;\n import org.apache.syncope.core.init.ConnInstanceLoader;\n import org.apache.syncope.core.persistence.beans.AbstractAttributable;\n+import org.apache.syncope.core.persistence.beans.AbstractMappingItem;\n import org.apache.syncope.core.persistence.beans.AbstractVirAttr;\n import org.apache.syncope.core.persistence.beans.ExternalResource;\n-import org.apache.syncope.core.persistence.beans.SchemaMapping;\n import org.apache.syncope.core.persistence.beans.SyncTask;\n import org.apache.syncope.core.persistence.beans.role.SyncopeRole;\n import org.apache.syncope.core.persistence.beans.user.SyncopeUser;\n@@ -49,6 +50,8 @@\n import org.apache.syncope.core.propagation.ConnectorFacadeProxy;\n import org.apache.syncope.core.rest.controller.UnauthorizedRoleException;\n import org.apache.syncope.core.rest.data.UserDataBinder;\n+import org.apache.syncope.types.AttributableType;\n+import org.apache.syncope.types.IntMappingType;\n import org.apache.syncope.types.PasswordPolicySpec;\n import org.identityconnectors.common.security.GuardedByteArray;\n import org.identityconnectors.common.security.GuardedString;\n@@ -70,7 +73,7 @@ public class ConnObjectUtil {\n     /**\n      * Logger.\n      */\n-    protected static final Logger LOG = LoggerFactory.getLogger(ConnObjectUtil.class);\n+    private static final Logger LOG = LoggerFactory.getLogger(ConnObjectUtil.class);\n \n     /**\n      * JEXL engine for evaluating connector's account link.\n@@ -96,31 +99,53 @@ public class ConnObjectUtil {\n     @Autowired\n     private PasswordGenerator pwdGen;\n \n+    public ObjectClass fromAttributable(final AbstractAttributable attributable) {\n+        if (attributable == null\n+                || (!(attributable instanceof SyncopeUser) && !(attributable instanceof SyncopeRole))) {\n+\n+            throw new IllegalArgumentException(\"No ObjectClass could be provided for \" + attributable);\n+        }\n+\n+        ObjectClass result = null;\n+        if (attributable instanceof SyncopeUser) {\n+            result = ObjectClass.ACCOUNT;\n+        }\n+        if (attributable instanceof SyncopeRole) {\n+            result = ObjectClass.GROUP;\n+        }\n+\n+        return result;\n+    }\n+\n     /**\n      * Build an UserTO out of connector object attributes and schema mapping.\n      *\n      * @param obj connector object\n      * @param syncTask synchronization task\n+     * @param attrUtil AttributableUtil\n+     * @param <T> user/role\n      * @return UserTO for the user to be created\n      */\n     @Transactional(readOnly = true)\n-    public UserTO getUserTO(final ConnectorObject obj, final SyncTask syncTask) {\n-        UserTO userTO = getUserTOFromConnObject(obj, syncTask);\n+    public <T extends AbstractAttributableTO> T getAttributableTO(final ConnectorObject obj, final SyncTask syncTask,\n+            final AttributableUtil attrUtil) {\n+\n+        T subjectTO = getAttributableTOFromConnObject(obj, syncTask, attrUtil);\n \n         // if password was not set above, generate\n-        if (StringUtils.isBlank(userTO.getPassword())) {\n+        if (AttributableType.USER == attrUtil.getType() && StringUtils.isBlank(((UserTO) subjectTO).getPassword())) {\n             List<PasswordPolicySpec> ppSpecs = new ArrayList<PasswordPolicySpec>();\n             ppSpecs.add((PasswordPolicySpec) policyDAO.getGlobalPasswordPolicy().getSpecification());\n \n-            for (MembershipTO memb : userTO.getMemberships()) {\n+            for (MembershipTO memb : ((UserTO) subjectTO).getMemberships()) {\n                 SyncopeRole role = roleDAO.find(memb.getRoleId());\n                 if (role != null && role.getPasswordPolicy() != null\n                         && role.getPasswordPolicy().getSpecification() != null) {\n \n                     ppSpecs.add((PasswordPolicySpec) role.getPasswordPolicy().getSpecification());\n                 }\n             }\n-            for (String resName : userTO.getResources()) {\n+            for (String resName : subjectTO.getResources()) {\n                 ExternalResource resource = resourceDAO.find(resName);\n                 if (resource != null && resource.getPasswordPolicy() != null\n                         && resource.getPasswordPolicy().getSpecification() != null) {\n@@ -133,142 +158,197 @@ public UserTO getUserTO(final ConnectorObject obj, final SyncTask syncTask) {\n             try {\n                 password = pwdGen.generatePasswordFromPwdSpec(ppSpecs);\n             } catch (IncompatiblePolicyException e) {\n-                LOG.error(\"Could not generate policy-compliant random password for {}\", userTO, e);\n+                LOG.error(\"Could not generate policy-compliant random password for {}\", subjectTO, e);\n \n                 password = RandomStringUtils.randomAlphanumeric(16);\n             }\n-            userTO.setPassword(password);\n+            ((UserTO) subjectTO).setPassword(password);\n         }\n \n-        return userTO;\n+        return subjectTO;\n     }\n \n     /**\n      * Build an UserMod out of connector object attributes and schema mapping.\n      *\n-     * @param userId user to be updated\n+     * @param id user to be updated\n      * @param obj connector object\n+     * @param original subject to get diff from\n      * @param syncTask synchronization task\n-     * @return UserMod for the user to be updated\n+     * @param attrUtil AttributableUtil\n+     * @param <T> user/role\n+     * @return modifications for the user/role to be updated\n      */\n     @Transactional(readOnly = true)\n-    public UserMod getUserMod(final Long userId, final ConnectorObject obj, final SyncTask syncTask)\n+    public <T extends AbstractAttributableMod> T getAttributableMod(final Long id, final ConnectorObject obj,\n+            final AbstractAttributableTO original, final SyncTask syncTask, final AttributableUtil attrUtil)\n             throws NotFoundException, UnauthorizedRoleException {\n \n-        final SyncopeUser user = userDataBinder.getUserFromId(userId);\n-        final UserTO original = userDataBinder.getUserTO(user);\n+        final AbstractAttributableTO updated = getAttributableTOFromConnObject(obj, syncTask, attrUtil);\n+        updated.setId(id);\n \n-        final UserTO updated = getUserTOFromConnObject(obj, syncTask);\n-        updated.setId(userId);\n+        if (AttributableType.USER == attrUtil.getType()) {\n+            // update password if and only if password is really changed\n+            final SyncopeUser user = userDataBinder.getUserFromId(id);\n+            if (StringUtils.isBlank(((UserTO) updated).getPassword())\n+                    || userDataBinder.verifyPassword(user, ((UserTO) updated).getPassword())) {\n \n-        // update password if and only if password is really changed\n-        if (StringUtils.isBlank(updated.getPassword()) || userDataBinder.verifyPassword(user, updated.getPassword())) {\n-            updated.setPassword(null);\n-        }\n+                ((UserTO) updated).setPassword(null);\n+            }\n \n-        final UserMod userMod = AttributableOperations.diff(updated, original, true);\n+            return (T) AttributableOperations.diff(((UserTO) updated), ((UserTO) original), true);\n+        }\n+        if (AttributableType.ROLE == attrUtil.getType()) {\n+            return (T) AttributableOperations.diff(((RoleTO) updated), ((RoleTO) original), true);\n+        }\n \n-        return userMod;\n+        return null;\n     }\n \n-    private UserTO getUserTOFromConnObject(final ConnectorObject obj, final SyncTask syncTask) {\n-        final UserTO userTO = new UserTO();\n+    private <T extends AbstractAttributableTO> T getAttributableTOFromConnObject(final ConnectorObject obj,\n+            final SyncTask syncTask, final AttributableUtil attrUtil) {\n+\n+        final T attributableTO = attrUtil.newAttributableTO();\n \n         // 1. fill with data from connector object\n-        for (SchemaMapping mapping : syncTask.getResource().getMappings()) {\n-            Attribute attribute = obj.getAttributeByName(SchemaMappingUtil.getExtAttrName(mapping));\n+        for (AbstractMappingItem item : attrUtil.getMappingItems(syncTask.getResource())) {\n+            Attribute attribute = obj.getAttributeByName(item.getExtAttrName());\n \n             AttributeTO attributeTO;\n-            switch (mapping.getIntMappingType()) {\n-                case SyncopeUserId:\n+            switch (item.getIntMappingType()) {\n+                case UserId:\n+                case RoleId:\n                     break;\n \n                 case Password:\n-                    if (attribute != null && attribute.getValue() != null && !attribute.getValue().isEmpty()) {\n-                        userTO.setPassword(getPassword(attribute.getValue().get(0)));\n+                    if (attributableTO instanceof UserTO && attribute != null && attribute.getValue() != null\n+                            && !attribute.getValue().isEmpty()) {\n+\n+                        ((UserTO) attributableTO).setPassword(getPassword(attribute.getValue().get(0)));\n                     }\n                     break;\n \n                 case Username:\n-                    userTO.setUsername(attribute == null || attribute.getValue().isEmpty()\n-                            ? null\n-                            : attribute.getValue().get(0).toString());\n+                    if (attributableTO instanceof UserTO) {\n+                        ((UserTO) attributableTO).setUsername(attribute == null || attribute.getValue().isEmpty()\n+                                ? null\n+                                : attribute.getValue().get(0).toString());\n+                    }\n+                    break;\n+\n+                case RoleName:\n+                    if (attributableTO instanceof RoleTO) {\n+                        ((RoleTO) attributableTO).setName(attribute == null || attribute.getValue().isEmpty()\n+                                ? null\n+                                : attribute.getValue().get(0).toString());\n+                    }\n                     break;\n \n                 case UserSchema:\n+                case RoleSchema:\n                     attributeTO = new AttributeTO();\n-                    attributeTO.setSchema(mapping.getIntAttrName());\n+                    attributeTO.setSchema(item.getIntAttrName());\n \n                     for (Object value : attribute == null || attribute.getValue() == null\n                             ? Collections.emptyList()\n                             : attribute.getValue()) {\n+\n                         attributeTO.addValue(value.toString());\n                     }\n \n-                    userTO.addAttribute(attributeTO);\n+                    attributableTO.addAttribute(attributeTO);\n                     break;\n \n                 case UserDerivedSchema:\n+                case RoleDerivedSchema:\n                     attributeTO = new AttributeTO();\n-                    attributeTO.setSchema(mapping.getIntAttrName());\n-                    userTO.addDerivedAttribute(attributeTO);\n+                    attributeTO.setSchema(item.getIntAttrName());\n+                    attributableTO.addDerivedAttribute(attributeTO);\n                     break;\n \n                 case UserVirtualSchema:\n+                case RoleVirtualSchema:\n                     attributeTO = new AttributeTO();\n-                    attributeTO.setSchema(mapping.getIntAttrName());\n+                    attributeTO.setSchema(item.getIntAttrName());\n \n                     for (Object value : attribute == null || attribute.getValue() == null\n                             ? Collections.emptyList()\n                             : attribute.getValue()) {\n+\n                         attributeTO.addValue(value.toString());\n                     }\n \n-                    userTO.addVirtualAttribute(attributeTO);\n+                    attributableTO.addVirtualAttribute(attributeTO);\n                     break;\n \n                 default:\n             }\n         }\n \n         // 2. add data from defined template (if any)\n-        UserTO template = syncTask.getUserTemplate();\n+        AbstractAttributableTO template = AttributableType.USER == attrUtil.getType()\n+                ? syncTask.getUserTemplate() : syncTask.getRoleTemplate();\n         if (template != null) {\n-            if (StringUtils.isNotBlank(template.getUsername())) {\n-                String evaluated = jexlUtil.evaluate(template.getUsername(), userTO);\n-                if (StringUtils.isNotBlank(evaluated)) {\n-                    userTO.setUsername(evaluated);\n+            if (template instanceof UserTO) {\n+                if (StringUtils.isNotBlank(((UserTO) template).getUsername())) {\n+                    String evaluated = jexlUtil.evaluate(((UserTO) template).getUsername(), attributableTO);\n+                    if (StringUtils.isNotBlank(evaluated)) {\n+                        ((UserTO) attributableTO).setUsername(evaluated);\n+                    }\n                 }\n-            }\n \n-            if (StringUtils.isNotBlank(template.getPassword())) {\n-                String evaluated = jexlUtil.evaluate(template.getPassword(), userTO);\n-                if (StringUtils.isNotBlank(evaluated)) {\n-                    userTO.setPassword(evaluated);\n+                if (StringUtils.isNotBlank(((UserTO) template).getPassword())) {\n+                    String evaluated = jexlUtil.evaluate(((UserTO) template).getPassword(), attributableTO);\n+                    if (StringUtils.isNotBlank(evaluated)) {\n+                        ((UserTO) attributableTO).setPassword(evaluated);\n+                    }\n+                }\n+\n+                Map<Long, MembershipTO> currentMembs = ((UserTO) attributableTO).getMembershipMap();\n+                for (MembershipTO membTO : ((UserTO) template).getMemberships()) {\n+                    MembershipTO membTBU;\n+                    if (currentMembs.containsKey(membTO.getRoleId())) {\n+                        membTBU = currentMembs.get(membTO.getRoleId());\n+                    } else {\n+                        membTBU = new MembershipTO();\n+                        membTBU.setRoleId(membTO.getRoleId());\n+                        ((UserTO) attributableTO).addMembership(membTBU);\n+                    }\n+                    fillFromTemplate(membTBU, membTO);\n                 }\n             }\n+            if (template instanceof RoleTO) {\n+                if (StringUtils.isNotBlank(((RoleTO) template).getName())) {\n+                    String evaluated = jexlUtil.evaluate(((RoleTO) template).getName(), attributableTO);\n+                    if (StringUtils.isNotBlank(evaluated)) {\n+                        ((RoleTO) attributableTO).setName(evaluated);\n+                    }\n+                }\n \n-            fillFromTemplate(userTO, template);\n+                ((RoleTO) attributableTO).setParent(((RoleTO) template).getParent());\n \n-            for (String resource : template.getResources()) {\n-                userTO.addResource(resource);\n+                ((RoleTO) attributableTO).setUserOwner(((RoleTO) template).getUserOwner());\n+                ((RoleTO) attributableTO).setRoleOwner(((RoleTO) template).getRoleOwner());\n+\n+                ((RoleTO) attributableTO).setAccountPolicy(((RoleTO) template).getAccountPolicy());\n+                ((RoleTO) attributableTO).setPasswordPolicy(((RoleTO) template).getPasswordPolicy());\n+\n+                ((RoleTO) attributableTO).setInheritOwner(((RoleTO) template).isInheritOwner());\n+                ((RoleTO) attributableTO).setInheritAttributes(((RoleTO) template).isInheritAttributes());\n+                ((RoleTO) attributableTO).setInheritDerivedAttributes(((RoleTO) template).isInheritDerivedAttributes());\n+                ((RoleTO) attributableTO).setInheritVirtualAttributes(((RoleTO) template).isInheritVirtualAttributes());\n+                ((RoleTO) attributableTO).setInheritPasswordPolicy(((RoleTO) template).isInheritPasswordPolicy());\n+                ((RoleTO) attributableTO).setInheritAccountPolicy(((RoleTO) template).isInheritAccountPolicy());\n             }\n \n-            Map<Long, MembershipTO> currentMembs = userTO.getMembershipMap();\n-            for (MembershipTO membTO : template.getMemberships()) {\n-                MembershipTO membTBU;\n-                if (currentMembs.containsKey(membTO.getRoleId())) {\n-                    membTBU = currentMembs.get(membTO.getRoleId());\n-                } else {\n-                    membTBU = new MembershipTO();\n-                    membTBU.setRoleId(membTO.getRoleId());\n-                    userTO.addMembership(membTBU);\n-                }\n-                fillFromTemplate(membTBU, membTO);\n+            fillFromTemplate(attributableTO, template);\n+\n+            for (String resource : template.getResources()) {\n+                attributableTO.addResource(resource);\n             }\n         }\n \n-        return userTO;\n+        return attributableTO;\n     }\n \n     /**\n@@ -336,48 +416,51 @@ public ConnObjectTO getConnObjectTO(final ConnectorObject connObject) {\n      * Query connected external resources for values to populated virtual attributes associated with the given owner.\n      *\n      * @param owner user or role\n+     * @param attrUtil attributable util\n      */\n-    public void retrieveVirAttrValues(final AbstractAttributable owner) {\n+    public void retrieveVirAttrValues(final AbstractAttributable owner, final AttributableUtil attrUtil) {\n         final ConfigurableApplicationContext context = ApplicationContextProvider.getApplicationContext();\n         final ConnInstanceLoader connInstanceLoader = context.getBean(ConnInstanceLoader.class);\n \n-        final Map<SchemaMappingWrapper, ConnectorObject> remoteObjects =\n-                new HashMap<SchemaMappingWrapper, ConnectorObject>();\n+        final Map<ConnectorObject, Set<AbstractMappingItem>> connObj2MapItems =\n+                new HashMap<ConnectorObject, Set<AbstractMappingItem>>();\n \n         for (ExternalResource resource : owner.getResources()) {\n             LOG.debug(\"Retrieve remote object from '{}'\", resource.getName());\n             try {\n-                final SchemaMappingWrapper mappings = new SchemaMappingWrapper(resource.getMappings());\n-\n-                final String accountId = SchemaMappingUtil.getAccountIdValue(owner, mappings.getAccountIdMapping());\n+                final String accountId = attrUtil.getAccountIdItem(resource) == null\n+                        ? null : MappingUtil.getAccountIdValue(owner, attrUtil.getAccountIdItem(resource));\n \n                 LOG.debug(\"Search for object with accountId '{}'\", accountId);\n \n                 if (StringUtils.isNotBlank(accountId)) {\n                     // Retrieve attributes to get\n+                    final Set<AbstractMappingItem> virMapItems = new HashSet<AbstractMappingItem>();\n                     final Set<String> extAttrNames = new HashSet<String>();\n \n-                    for (Set<SchemaMapping> virAttrMappings : mappings.getuVirMappings().values()) {\n-                        for (SchemaMapping virAttrMapping : virAttrMappings) {\n-                            extAttrNames.add(SchemaMappingUtil.getExtAttrName(virAttrMapping));\n+                    for (AbstractMappingItem item : attrUtil.getMappingItems(resource)) {\n+                        if ((AttributableType.USER == attrUtil.getType()\n+                                && item.getIntMappingType() == IntMappingType.UserVirtualSchema)\n+                                || (AttributableType.ROLE == attrUtil.getType()\n+                                && item.getIntMappingType() == IntMappingType.RoleVirtualSchema)) {\n+\n+                            virMapItems.add(item);\n+                            extAttrNames.add(item.getExtAttrName());\n                         }\n                     }\n \n                     // Search for remote object\n-                    if (extAttrNames != null) {\n-                        final OperationOptionsBuilder oob = new OperationOptionsBuilder();\n-                        oob.setAttributesToGet(extAttrNames);\n-\n-                        final ConnectorFacadeProxy connector = connInstanceLoader.getConnector(resource);\n-                        final ConnectorObject connectorObject =\n-                                connector.getObject(ObjectClass.ACCOUNT, new Uid(accountId), oob.build());\n-\n-                        if (connectorObject != null) {\n-                            remoteObjects.put(mappings, connectorObject);\n-                        }\n-\n-                        LOG.debug(\"Retrieved remotye object {}\", connectorObject);\n+                    final OperationOptionsBuilder oob = new OperationOptionsBuilder();\n+                    oob.setAttributesToGet(extAttrNames);\n+\n+                    final ConnectorFacadeProxy connector = connInstanceLoader.getConnector(resource);\n+                    final ConnectorObject connObj =\n+                            connector.getObject(fromAttributable(owner), new Uid(accountId), oob.build());\n+                    if (connObj != null) {\n+                        connObj2MapItems.put(connObj, virMapItems);\n                     }\n+\n+                    LOG.debug(\"Retrieved remote object {}\", connObj);\n                 }\n             } catch (Exception e) {\n                 LOG.error(\"Unable to retrieve virtual attribute values on '{}'\", resource.getName(), e);\n@@ -387,19 +470,14 @@ public void retrieveVirAttrValues(final AbstractAttributable owner) {\n         for (AbstractVirAttr virAttr : owner.getVirtualAttributes()) {\n             LOG.debug(\"Provide value for virtual attribute '{}'\", virAttr.getVirtualSchema().getName());\n \n-            for (Map.Entry<SchemaMappingWrapper, ConnectorObject> entry : remoteObjects.entrySet()) {\n-                final Set<SchemaMapping> virAttrMappings = entry.getKey().getuVirMappings().\n-                        get(virAttr.getVirtualSchema().getName());\n-\n-                if (virAttrMappings != null) {\n-                    for (SchemaMapping virAttrMapping : virAttrMappings) {\n-                        final String extAttrName = SchemaMappingUtil.getExtAttrName(virAttrMapping);\n-                        final Attribute extAttr = entry.getValue().getAttributeByName(extAttrName);\n-                        if (extAttr != null && extAttr.getValue() != null && !extAttr.getValue().isEmpty()) {\n-                            for (Object obj : extAttr.getValue()) {\n-                                if (obj != null) {\n-                                    virAttr.addValue(obj.toString());\n-                                }\n+            for (Map.Entry<ConnectorObject, Set<AbstractMappingItem>> entry : connObj2MapItems.entrySet()) {\n+                for (AbstractMappingItem vAttrMapItem : entry.getValue()) {\n+                    final String extAttrName = vAttrMapItem.getExtAttrName();\n+                    final Attribute extAttr = entry.getKey().getAttributeByName(extAttrName);\n+                    if (extAttr != null && extAttr.getValue() != null && !extAttr.getValue().isEmpty()) {\n+                        for (Object obj : extAttr.getValue()) {\n+                            if (obj != null) {\n+                                virAttr.addValue(obj.toString());\n                             }\n                         }\n                     }"},{"sha":"373b45794cd87b09b374bd82b1f95c1a6bb2a297","filename":"core/src/main/java/org/apache/syncope/core/util/EntitlementUtil.java","status":"modified","additions":18,"deletions":0,"changes":18,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Futil%2FEntitlementUtil.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Futil%2FEntitlementUtil.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Futil%2FEntitlementUtil.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -18,14 +18,18 @@\n  */\n package org.apache.syncope.core.util;\n \n+import java.util.ArrayList;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Set;\n import java.util.regex.Pattern;\n import org.apache.syncope.core.persistence.beans.Entitlement;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n+import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;\n+import org.springframework.security.core.Authentication;\n import org.springframework.security.core.GrantedAuthority;\n+import org.springframework.security.core.authority.SimpleGrantedAuthority;\n import org.springframework.security.core.context.SecurityContext;\n import org.springframework.security.core.context.SecurityContextHolder;\n \n@@ -101,6 +105,20 @@ public static Set<Long> getRoleIds(final List<Entitlement> entitlements) {\n         return getRoleIds(names);\n     }\n \n+    /**\n+     * Extend the current authentication context to include the given role.\n+     * \n+     * @param roleId role id\n+     */\n+    public static void extendAuthContext(final Long roleId) {\n+        Authentication auth = SecurityContextHolder.getContext().getAuthentication();\n+        List<GrantedAuthority> authorities = new ArrayList<GrantedAuthority>(auth.getAuthorities());\n+        authorities.add(new SimpleGrantedAuthority(EntitlementUtil.getEntitlementNameFromRoleId(roleId)));\n+        Authentication newAuth = new UsernamePasswordAuthenticationToken(\n+                auth.getPrincipal(), auth.getCredentials(), authorities);\n+        SecurityContextHolder.getContext().setAuthentication(newAuth);\n+    }\n+\n     /**\n      * Private default constructor, for static-only classes.\n      */"},{"sha":"2c6d22b95afdc4a019520e03a91cbb5fb86e3c89","filename":"core/src/main/java/org/apache/syncope/core/util/MappingUtil.java","status":"renamed","additions":100,"deletions":140,"changes":240,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Futil%2FMappingUtil.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Futil%2FMappingUtil.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Futil%2FMappingUtil.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -21,7 +21,6 @@\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n-import java.util.HashMap;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n@@ -31,101 +30,65 @@\n import org.apache.syncope.core.persistence.beans.AbstractAttrValue;\n import org.apache.syncope.core.persistence.beans.AbstractAttributable;\n import org.apache.syncope.core.persistence.beans.AbstractDerAttr;\n+import org.apache.syncope.core.persistence.beans.AbstractMappingItem;\n import org.apache.syncope.core.persistence.beans.AbstractSchema;\n import org.apache.syncope.core.persistence.beans.AbstractVirAttr;\n-import org.apache.syncope.core.persistence.beans.SchemaMapping;\n import org.apache.syncope.core.persistence.beans.membership.MDerSchema;\n import org.apache.syncope.core.persistence.beans.membership.MSchema;\n import org.apache.syncope.core.persistence.beans.membership.MVirSchema;\n+import org.apache.syncope.core.persistence.beans.role.RAttrValue;\n import org.apache.syncope.core.persistence.beans.role.RDerSchema;\n import org.apache.syncope.core.persistence.beans.role.RSchema;\n import org.apache.syncope.core.persistence.beans.role.RVirSchema;\n+import org.apache.syncope.core.persistence.beans.role.SyncopeRole;\n import org.apache.syncope.core.persistence.beans.user.SyncopeUser;\n import org.apache.syncope.core.persistence.beans.user.UAttrValue;\n import org.apache.syncope.core.persistence.beans.user.UDerSchema;\n import org.apache.syncope.core.persistence.beans.user.USchema;\n import org.apache.syncope.core.persistence.beans.user.UVirSchema;\n import org.apache.syncope.core.persistence.dao.SchemaDAO;\n import org.apache.syncope.types.IntMappingType;\n-import org.identityconnectors.framework.common.objects.OperationalAttributes;\n-import org.identityconnectors.framework.common.objects.Uid;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-public class SchemaMappingUtil {\n+public final class MappingUtil {\n \n     /**\n      * Logger.\n      */\n-    protected static final Logger LOG = LoggerFactory.getLogger(SchemaMappingUtil.class);\n+    private static final Logger LOG = LoggerFactory.getLogger(MappingUtil.class);\n \n-    public static String getExtAttrName(final SchemaMapping mapping) {\n-        final String name;\n-\n-        if (mapping.isAccountid()) {\n-            name = Uid.NAME;\n-        } else if (mapping.isPassword()) {\n-            name = OperationalAttributes.PASSWORD_NAME;\n-        } else {\n-            name = mapping.getExtAttrName();\n-        }\n-\n-        return name;\n+    private MappingUtil() {\n     }\n \n-    public static String getIntAttrName(final SchemaMapping mapping) {\n-        final String name;\n+    public static <T extends AbstractMappingItem> List<T> getMatchingMappingItems(final Collection<T> items,\n+            final String intAttrName, final IntMappingType type) {\n \n-        switch (mapping.getIntMappingType()) {\n-            case SyncopeUserId:\n-                name = \"id\";\n-                break;\n-            case Username:\n-                name = \"username\";\n-                break;\n-            case Password:\n-                name = \"password\";\n-                break;\n-            default:\n-                name = mapping.getIntAttrName();\n-        }\n-\n-        return name;\n-    }\n+        final List<T> result = new ArrayList<T>();\n \n-    public static Set<SchemaMapping> getMappings(final Collection<SchemaMapping> mappings, final String intAttrName,\n-            final IntMappingType type) {\n-\n-        final Set<SchemaMapping> result = new HashSet<SchemaMapping>();\n-\n-        for (SchemaMapping schemaMapping : mappings) {\n-            if (schemaMapping.getIntMappingType() == type && intAttrName.equals(getIntAttrName(schemaMapping))) {\n-                result.add(schemaMapping);\n+        for (T mapItem : items) {\n+            if (mapItem.getIntMappingType() == type && intAttrName.equals(mapItem.getIntAttrName())) {\n+                result.add(mapItem);\n             }\n         }\n \n         return result;\n     }\n \n-    public static Set<SchemaMapping> getMappings(final Collection<SchemaMapping> mappings, final String intAttrName) {\n+    public static <T extends AbstractMappingItem> Set<T> getMatchingMappingItems(final Collection<T> mapItems,\n+            final String intAttrName) {\n \n-        final Set<SchemaMapping> result = new HashSet<SchemaMapping>();\n+        final Set<T> result = new HashSet<T>();\n \n-        for (SchemaMapping schemaMapping : mappings) {\n-            if (intAttrName.equals(getIntAttrName(schemaMapping))) {\n-                result.add(schemaMapping);\n+        for (T mapItem : mapItems) {\n+            if (intAttrName.equals(mapItem.getIntAttrName())) {\n+                result.add(mapItem);\n             }\n         }\n \n         return result;\n     }\n \n-    public static String getIntAttrName(final SchemaMapping mapping, final IntMappingType type) {\n-        return type == mapping.getIntMappingType()\n-                ? getIntAttrName(mapping)\n-                : null;\n-    }\n-\n     /**\n      * Get attribute values.\n      *\n@@ -135,7 +98,7 @@ public static String getIntAttrName(final SchemaMapping mapping, final IntMappin\n      * @param schemaDAO schema DAO\n      * @return schema and attribute values.\n      */\n-    public static Map.Entry<AbstractSchema, List<AbstractAttrValue>> getIntValues(final SchemaMapping mapping,\n+    public static Map.Entry<AbstractSchema, List<AbstractAttrValue>> getIntValues(final AbstractMappingItem mapping,\n             final List<AbstractAttributable> attributables, final String password, final SchemaDAO schemaDAO) {\n \n         LOG.debug(\"Get attributes for '{}' and mapping type '{}'\", attributables, mapping.getIntMappingType());\n@@ -148,8 +111,8 @@ public static Map.Entry<AbstractSchema, List<AbstractAttrValue>> getIntValues(fi\n             case UserSchema:\n             case RoleSchema:\n             case MembershipSchema:\n-                schema = schemaDAO.find(mapping.getIntAttrName(), SchemaMappingUtil.getIntMappingTypeClass(mapping.\n-                        getIntMappingType()));\n+                schema = schemaDAO.find(mapping.getIntAttrName(),\n+                        MappingUtil.getIntMappingTypeClass(mapping.getIntMappingType()));\n \n                 for (AbstractAttributable attributable : attributables) {\n                     final AbstractAttr attr = attributable.getAttribute(mapping.getIntAttrName());\n@@ -159,31 +122,34 @@ public static Map.Entry<AbstractSchema, List<AbstractAttrValue>> getIntValues(fi\n                                 ? Collections.singletonList(attr.getUniqueValue()) : attr.getValues());\n                     }\n \n-                    LOG.debug(\"Retrieved attribute {}\" + \"\\n* IntAttrName {}\" + \"\\n* IntMappingType {}\"\n-                            + \"\\n* Attribute values {}\", new Object[]{attr, mapping.getIntAttrName(),\n-                                mapping.getIntMappingType(), values});\n+                    LOG.debug(\"Retrieved attribute {}\"\n+                            + \"\\n* IntAttrName {}\"\n+                            + \"\\n* IntMappingType {}\"\n+                            + \"\\n* Attribute values {}\",\n+                            new Object[]{attr, mapping.getIntAttrName(), mapping.getIntMappingType(), values});\n                 }\n \n                 break;\n \n             case UserVirtualSchema:\n             case RoleVirtualSchema:\n             case MembershipVirtualSchema:\n-\n                 for (AbstractAttributable attributable : attributables) {\n                     AbstractVirAttr virAttr = attributable.getVirtualAttribute(mapping.getIntAttrName());\n \n-                    if (virAttr != null && virAttr.getValues() != null) {\n+                    if (virAttr != null) {\n                         for (String value : virAttr.getValues()) {\n                             AbstractAttrValue attrValue = new UAttrValue();\n                             attrValue.setStringValue(value);\n                             values.add(attrValue);\n                         }\n                     }\n \n-                    LOG.debug(\"Retrieved virtual attribute {}\" + \"\\n* IntAttrName {}\" + \"\\n* IntMappingType {}\"\n-                            + \"\\n* Attribute values {}\", new Object[]{virAttr, mapping.getIntAttrName(),\n-                                mapping.getIntMappingType(), values});\n+                    LOG.debug(\"Retrieved virtual attribute {}\"\n+                            + \"\\n* IntAttrName {}\"\n+                            + \"\\n* IntMappingType {}\"\n+                            + \"\\n* Attribute values {}\",\n+                            new Object[]{virAttr, mapping.getIntAttrName(), mapping.getIntMappingType(), values});\n                 }\n                 break;\n \n@@ -192,149 +158,189 @@ public static Map.Entry<AbstractSchema, List<AbstractAttrValue>> getIntValues(fi\n             case MembershipDerivedSchema:\n                 for (AbstractAttributable attributable : attributables) {\n                     AbstractDerAttr derAttr = attributable.getDerivedAttribute(mapping.getIntAttrName());\n-\n                     if (derAttr != null) {\n-                        AbstractAttrValue attrValue = new UAttrValue();\n+                        AbstractAttrValue attrValue = (attributable instanceof SyncopeRole)\n+                                ? new RAttrValue() : new UAttrValue();\n                         attrValue.setStringValue(derAttr.getValue(attributable.getAttributes()));\n                         values.add(attrValue);\n                     }\n \n-                    LOG.debug(\"Retrieved attribute {}\" + \"\\n* IntAttrName {}\" + \"\\n* IntMappingType {}\"\n-                            + \"\\n* Attribute values {}\", new Object[]{derAttr, mapping.getIntAttrName(),\n-                                mapping.getIntMappingType(), values});\n+                    LOG.debug(\"Retrieved attribute {}\"\n+                            + \"\\n* IntAttrName {}\"\n+                            + \"\\n* IntMappingType {}\"\n+                            + \"\\n* Attribute values {}\",\n+                            new Object[]{derAttr, mapping.getIntAttrName(), mapping.getIntMappingType(), values});\n                 }\n                 break;\n \n-            case Username:\n+            case UserId:\n+            case RoleId:\n+            case MembershipId:\n                 for (AbstractAttributable attributable : attributables) {\n                     AbstractAttrValue attrValue = new UAttrValue();\n-                    attrValue.setStringValue(((SyncopeUser) attributable).getUsername());\n+                    attrValue.setStringValue(attributable.getId().toString());\n                     values.add(attrValue);\n                 }\n                 break;\n \n-            case SyncopeUserId:\n+            case Username:\n                 for (AbstractAttributable attributable : attributables) {\n-                    AbstractAttrValue attrValue = new UAttrValue();\n-                    attrValue.setStringValue(attributable.getId().toString());\n-                    values.add(attrValue);\n+                    if (attributable instanceof SyncopeUser) {\n+                        AbstractAttrValue attrValue = new UAttrValue();\n+                        attrValue.setStringValue(((SyncopeUser) attributable).getUsername());\n+                        values.add(attrValue);\n+                    }\n                 }\n                 break;\n \n             case Password:\n                 AbstractAttrValue attrValue = new UAttrValue();\n-\n                 if (password != null) {\n                     attrValue.setStringValue(password);\n                 }\n-\n                 values.add(attrValue);\n                 break;\n \n+            case RoleName:\n+                for (AbstractAttributable attributable : attributables) {\n+                    if (attributable instanceof SyncopeRole) {\n+                        attrValue = new RAttrValue();\n+                        attrValue.setStringValue(((SyncopeRole) attributable).getName());\n+                        values.add(attrValue);\n+                    }\n+                }\n+                break;\n+\n             default:\n         }\n \n-        LOG.debug(\"Retrived values '{}'\", values);\n+        LOG.debug(\"Retrieved values '{}'\", values);\n \n         return new DefaultMapEntry(schema, values);\n     }\n \n-    public static List<String> getIntValueAsStrings(\n-            final AbstractAttributable attributable, final SchemaMapping mapping) {\n-        \n-        return getIntValueAsStrings(attributable, mapping, null);\n-    }\n-\n-    public static List<String> getIntValueAsStrings(\n-            final AbstractAttributable attributable, final SchemaMapping mapping, String clearPassword) {\n+    public static List<String> getIntValueAsStrings(final AbstractAttributable attributable,\n+            final AbstractMappingItem mapItem, final String clearPassword) {\n \n         List<String> value = new ArrayList<String>();\n \n-        if (mapping != null) {\n-            switch (mapping.getIntMappingType()) {\n+        if (mapItem != null) {\n+            switch (mapItem.getIntMappingType()) {\n                 case Username:\n                     if (!(attributable instanceof SyncopeUser)) {\n                         throw new ClassCastException(\"mappingtype is Username, but attributable is not SyncopeUser: \"\n                                 + attributable.getClass().getName());\n                     }\n                     value.add(((SyncopeUser) attributable).getUsername());\n                     break;\n+\n                 case Password:\n                     if (clearPassword != null) {\n                         value.add(clearPassword);\n                     }\n                     break;\n+\n                 case UserSchema:\n                 case RoleSchema:\n                 case MembershipSchema:\n-                    AbstractAttr abstractAttr = attributable.getAttribute(mapping.getIntAttrName());\n+                    AbstractAttr abstractAttr = attributable.getAttribute(mapItem.getIntAttrName());\n                     if (abstractAttr != null && abstractAttr.getValues() != null) {\n                         value.addAll(abstractAttr.getValuesAsStrings());\n                     }\n                     break;\n+\n                 case UserVirtualSchema:\n                 case RoleVirtualSchema:\n                 case MembershipVirtualSchema:\n-                    AbstractVirAttr abstractVirAttr = attributable.getVirtualAttribute(mapping.getIntAttrName());\n+                    AbstractVirAttr abstractVirAttr = attributable.getVirtualAttribute(mapItem.getIntAttrName());\n                     if (abstractVirAttr != null && abstractVirAttr.getValues() != null) {\n                         value.addAll(abstractVirAttr.getValues());\n                     }\n                     break;\n+\n                 case UserDerivedSchema:\n                 case RoleDerivedSchema:\n                 case MembershipDerivedSchema:\n-                    AbstractDerAttr abstractDerAttr = attributable.getDerivedAttribute(mapping.getIntAttrName());\n+                    AbstractDerAttr abstractDerAttr = attributable.getDerivedAttribute(mapItem.getIntAttrName());\n                     if (abstractDerAttr != null) {\n                         String abstractDerAttrValue = abstractDerAttr.getValue(attributable.getAttributes());\n                         if (abstractDerAttrValue != null) {\n                             value.add(abstractDerAttrValue);\n                         }\n                     }\n                     break;\n+\n                 default:\n             }\n         }\n \n         return value;\n     }\n \n+    public static List<String> getIntValueAsStrings(final AbstractAttributable attributable,\n+            final AbstractMappingItem mapItem) {\n+\n+        return getIntValueAsStrings(attributable, mapItem, null);\n+    }\n+\n+    /**\n+     * Get accountId internal value.\n+     *\n+     * @param attributable attributable\n+     * @param accountIdItem accountid mapping item\n+     * @return accountId internal value\n+     */\n+    public static String getAccountIdValue(final AbstractAttributable attributable,\n+            final AbstractMappingItem accountIdItem) {\n+\n+        final List<String> values = getIntValueAsStrings(attributable, accountIdItem);\n+        return values == null || values.isEmpty()\n+                ? null\n+                : values.get(0);\n+    }\n+\n     /**\n      * For given source mapping type, return the corresponding Class object.\n      *\n      * @param intMappingType source mapping type\n      * @return corresponding Class object, if any (can be null)\n      */\n     public static Class getIntMappingTypeClass(final IntMappingType intMappingType) {\n-\n         Class result;\n \n         switch (intMappingType) {\n             case UserSchema:\n                 result = USchema.class;\n                 break;\n+\n             case RoleSchema:\n                 result = RSchema.class;\n                 break;\n+\n             case MembershipSchema:\n                 result = MSchema.class;\n                 break;\n \n             case UserDerivedSchema:\n                 result = UDerSchema.class;\n                 break;\n+\n             case RoleDerivedSchema:\n                 result = RDerSchema.class;\n                 break;\n+\n             case MembershipDerivedSchema:\n                 result = MDerSchema.class;\n                 break;\n \n             case UserVirtualSchema:\n                 result = UVirSchema.class;\n                 break;\n+\n             case RoleVirtualSchema:\n                 result = RVirSchema.class;\n                 break;\n+\n             case MembershipVirtualSchema:\n                 result = MVirSchema.class;\n                 break;\n@@ -345,50 +351,4 @@ public static Class getIntMappingTypeClass(final IntMappingType intMappingType)\n \n         return result;\n     }\n-\n-    /**\n-     * Get first occurance of accountId mapping from a collection of mappings.\n-     *\n-     * @param mappings collection of SchemaMapping\n-     * @return AccountId mapping or null if no occurences found\n-     */\n-    public static SchemaMapping getAccountIdMapping(final Collection<SchemaMapping> mappings) {\n-        for (SchemaMapping mapping : mappings) {\n-            if (mapping.isAccountid()) {\n-                return mapping;\n-            }\n-        }\n-\n-        return null;\n-    }\n-\n-    /**\n-     * Get accountId internal value.\n-     *\n-     * @param attributable attributable\n-     * @param mappings collection of SchemaMapping\n-     * @return accountId internal value\n-     */\n-    public static String getAccountIdValue(final AbstractAttributable attributable,\n-            final Collection<SchemaMapping> mappings) {\n-\n-        final List<String> values = getIntValueAsStrings(attributable, getAccountIdMapping(mappings));\n-        return values == null || values.isEmpty()\n-                ? null\n-                : values.get(0);\n-    }\n-\n-    /**\n-     * Get accountId internal value.\n-     *\n-     * @param attributable attributable\n-     * @param mapping accountId mapping\n-     * @return accountId internal value\n-     */\n-    public static String getAccountIdValue(final AbstractAttributable attributable, final SchemaMapping mapping) {\n-        final List<String> values = getIntValueAsStrings(attributable, mapping);\n-        return values == null || values.isEmpty()\n-                ? null\n-                : values.get(0);\n-    }\n }","previous_filename":"core/src/main/java/org/apache/syncope/core/util/SchemaMappingUtil.java"},{"sha":"f83093b15aa15637556e87ab314543780625f53e","filename":"core/src/main/java/org/apache/syncope/core/util/SchemaMappingWrapper.java","status":"removed","additions":0,"deletions":187,"changes":187,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/8fcd0ace968e4cb7b5c8b98066414c6b62a9ba81/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Futil%2FSchemaMappingWrapper.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/8fcd0ace968e4cb7b5c8b98066414c6b62a9ba81/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Futil%2FSchemaMappingWrapper.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Futil%2FSchemaMappingWrapper.java?ref=8fcd0ace968e4cb7b5c8b98066414c6b62a9ba81","patch":"@@ -1,187 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-package org.apache.syncope.core.util;\n-\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.Map;\n-import java.util.Set;\n-import org.apache.syncope.core.persistence.beans.SchemaMapping;\n-\n-/**\n- *\n- * @author ilgrosso\n- */\n-public class SchemaMappingWrapper {\n-\n-    private SchemaMapping accountIdMapping = null;\n-\n-    private SchemaMapping passwordMapping = null;\n-\n-    private final Map<String, Set<SchemaMapping>> uMappings = new HashMap<String, Set<SchemaMapping>>();\n-\n-    private final Map<String, Set<SchemaMapping>> uVirMappings = new HashMap<String, Set<SchemaMapping>>();\n-\n-    private final Map<String, Set<SchemaMapping>> uDerMappings = new HashMap<String, Set<SchemaMapping>>();\n-\n-    private final Map<String, Set<SchemaMapping>> rMappings = new HashMap<String, Set<SchemaMapping>>();\n-\n-    private final Map<String, Set<SchemaMapping>> rVirMappings = new HashMap<String, Set<SchemaMapping>>();\n-\n-    private final Map<String, Set<SchemaMapping>> rDerMappings = new HashMap<String, Set<SchemaMapping>>();\n-\n-    private final Map<String, Set<SchemaMapping>> mMappings = new HashMap<String, Set<SchemaMapping>>();\n-\n-    private final Map<String, Set<SchemaMapping>> mVirMappings = new HashMap<String, Set<SchemaMapping>>();\n-\n-    private final Map<String, Set<SchemaMapping>> mDerMappings = new HashMap<String, Set<SchemaMapping>>();\n-\n-    public SchemaMappingWrapper(final Set<SchemaMapping> mappings) {\n-        if (mappings == null) {\n-            return;\n-        }\n-        for (SchemaMapping mapping : mappings) {\n-            if (mapping.isAccountid() && accountIdMapping == null) {\n-                accountIdMapping = mapping;\n-            } else if (mapping.isPassword() && passwordMapping == null) {\n-                passwordMapping = mapping;\n-            } else {\n-                final String intAttrName = SchemaMappingUtil.getIntAttrName(mapping);\n-                switch (mapping.getIntMappingType()) {\n-                    case Password:\n-                        if (passwordMapping == null) {\n-                            passwordMapping = mapping;\n-                        }\n-                        break;\n-\n-                    case Username:\n-                    case SyncopeUserId:\n-                    case UserSchema:\n-                        if (uMappings.get(intAttrName) == null) {\n-                            uMappings.put(intAttrName, new HashSet<SchemaMapping>());\n-                        }\n-                        uMappings.get(intAttrName).add(mapping);\n-                        break;\n-\n-                    case RoleSchema:\n-                        if (rMappings.get(intAttrName) == null) {\n-                            rMappings.put(intAttrName, new HashSet<SchemaMapping>());\n-                        }\n-                        rMappings.get(intAttrName).add(mapping);\n-                        break;\n-\n-                    case MembershipSchema:\n-                        if (mMappings.get(intAttrName) == null) {\n-                            mMappings.put(intAttrName, new HashSet<SchemaMapping>());\n-                        }\n-                        mMappings.get(intAttrName).add(mapping);\n-                        break;\n-\n-                    case UserDerivedSchema:\n-                        if (uDerMappings.get(intAttrName) == null) {\n-                            uDerMappings.put(intAttrName, new HashSet<SchemaMapping>());\n-                        }\n-                        uDerMappings.get(intAttrName).add(mapping);\n-                        break;\n-\n-                    case RoleDerivedSchema:\n-                        if (rDerMappings.get(intAttrName) == null) {\n-                            rDerMappings.put(intAttrName, new HashSet<SchemaMapping>());\n-                        }\n-                        rDerMappings.get(intAttrName).add(mapping);\n-                        break;\n-\n-                    case MembershipDerivedSchema:\n-                        if (mDerMappings.get(intAttrName) == null) {\n-                            mDerMappings.put(intAttrName, new HashSet<SchemaMapping>());\n-                        }\n-                        mDerMappings.get(intAttrName).add(mapping);\n-                        break;\n-\n-                    case UserVirtualSchema:\n-                        if (uVirMappings.get(intAttrName) == null) {\n-                            uVirMappings.put(intAttrName, new HashSet<SchemaMapping>());\n-                        }\n-                        uVirMappings.get(intAttrName).add(mapping);\n-                        break;\n-\n-                    case RoleVirtualSchema:\n-                        if (rVirMappings.get(intAttrName) == null) {\n-                            rVirMappings.put(intAttrName, new HashSet<SchemaMapping>());\n-                        }\n-                        rVirMappings.get(intAttrName).add(mapping);\n-                        break;\n-\n-                    case MembershipVirtualSchema:\n-                        if (mVirMappings.get(intAttrName) == null) {\n-                            mVirMappings.put(intAttrName, new HashSet<SchemaMapping>());\n-                        }\n-                        mVirMappings.get(intAttrName).add(mapping);\n-                        break;\n-\n-                    default:\n-                }\n-            }\n-        }\n-    }\n-\n-    public SchemaMapping getAccountIdMapping() {\n-        return accountIdMapping;\n-    }\n-\n-    public Map<String, Set<SchemaMapping>> getmDerMappings() {\n-        return mDerMappings;\n-    }\n-\n-    public Map<String, Set<SchemaMapping>> getmMappings() {\n-        return mMappings;\n-    }\n-\n-    public Map<String, Set<SchemaMapping>> getmVirMappings() {\n-        return mVirMappings;\n-    }\n-\n-    public SchemaMapping getPasswordMapping() {\n-        return passwordMapping;\n-    }\n-\n-    public Map<String, Set<SchemaMapping>> getrDerMappings() {\n-        return rDerMappings;\n-    }\n-\n-    public Map<String, Set<SchemaMapping>> getrMappings() {\n-        return rMappings;\n-    }\n-\n-    public Map<String, Set<SchemaMapping>> getrVirMappings() {\n-        return rVirMappings;\n-    }\n-\n-    public Map<String, Set<SchemaMapping>> getuDerMappings() {\n-        return uDerMappings;\n-    }\n-\n-    public Map<String, Set<SchemaMapping>> getuMappings() {\n-        return uMappings;\n-    }\n-\n-    public Map<String, Set<SchemaMapping>> getuVirMappings() {\n-        return uVirMappings;\n-    }\n-}"},{"sha":"310b56a9ad8721a0195ab91f15632684590f2042","filename":"core/src/main/java/org/apache/syncope/core/workflow/WorkflowAdapter.java","status":"added","additions":103,"deletions":0,"changes":103,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fworkflow%2FWorkflowAdapter.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fworkflow%2FWorkflowAdapter.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fworkflow%2FWorkflowAdapter.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -0,0 +1,103 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.core.workflow;\n+\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.syncope.client.to.WorkflowDefinitionTO;\n+import org.apache.syncope.client.to.WorkflowFormTO;\n+import org.apache.syncope.core.init.WorkflowLoader;\n+import org.apache.syncope.core.util.NotFoundException;\n+\n+public interface WorkflowAdapter {\n+\n+    /**\n+     * Give the class to be instantiated and invoked by SpringContextInitializer for loading anything needed by this\n+     * adapter.\n+     *\n+     * @return null if no init is needed or the WorkflowLoader class for handling initialization\n+     * @see org.apache.syncope.core.init.SpringContextInitializer\n+     */\n+    Class<? extends WorkflowLoader> getLoaderClass();\n+\n+    /**\n+     * Get workflow definition.\n+     *\n+     * @return workflow definition as XML\n+     * @throws WorkflowException workflow exception\n+     */\n+    WorkflowDefinitionTO getDefinition() throws WorkflowException;\n+\n+    /**\n+     * Update workflow definition.\n+     *\n+     * @param definition definition as XML\n+     * @throws NotFoundException definition not found exception\n+     * @throws WorkflowException workflow exception\n+     */\n+    void updateDefinition(WorkflowDefinitionTO definition) throws NotFoundException, WorkflowException;\n+\n+    /**\n+     * Get list of defined tasks in workflow.\n+     *\n+     * @return list of defined tasks in workflow\n+     * @throws WorkflowException workflow exception\n+     */\n+    List<String> getDefinedTasks() throws WorkflowException;\n+\n+    /**\n+     * Get all defined forms for current workflow process instances.\n+     *\n+     * @return list of defined forms\n+     */\n+    List<WorkflowFormTO> getForms();\n+\n+    /**\n+     * Get form for given workflowId (if present).\n+     *\n+     * @param workflowId workflow id\n+     * @return form (if present), otherwise null\n+     * @throws NotFoundException definition not found exception\n+     * @throws WorkflowException workflow exception\n+     */\n+    WorkflowFormTO getForm(String workflowId) throws NotFoundException, WorkflowException;\n+\n+    /**\n+     * Claim a form for a given user.\n+     *\n+     * @param taskId Workflow task to which the form is associated\n+     * @param username claiming username\n+     * @return updated form\n+     * @throws NotFoundException not found exception\n+     * @throws WorkflowException workflow exception\n+     */\n+    WorkflowFormTO claimForm(String taskId, String username) throws NotFoundException, WorkflowException;\n+\n+    /**\n+     * Submit a form.\n+     *\n+     * @param form to be submitted\n+     * @param username submitting username\n+     * @return user updated by this form submit\n+     * @throws NotFoundException not found exception\n+     * @throws WorkflowException workflow exception\n+     */\n+    WorkflowResult<Map.Entry<Long, String>> submitForm(WorkflowFormTO form, String username)\n+            throws NotFoundException, WorkflowException;\n+}"},{"sha":"83120cbb9a37ae926046c00ed1b4b6c6f619ae0e","filename":"core/src/main/java/org/apache/syncope/core/workflow/role/AbstractRoleWorkflowAdapter.java","status":"added","additions":63,"deletions":0,"changes":63,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fworkflow%2Frole%2FAbstractRoleWorkflowAdapter.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fworkflow%2Frole%2FAbstractRoleWorkflowAdapter.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fworkflow%2Frole%2FAbstractRoleWorkflowAdapter.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -0,0 +1,63 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.core.workflow.role;\n+\n+import org.apache.syncope.client.mod.RoleMod;\n+import org.apache.syncope.core.init.WorkflowLoader;\n+import org.apache.syncope.core.persistence.beans.role.SyncopeRole;\n+import org.apache.syncope.core.persistence.dao.RoleDAO;\n+import org.apache.syncope.core.rest.controller.UnauthorizedRoleException;\n+import org.apache.syncope.core.rest.data.RoleDataBinder;\n+import org.apache.syncope.core.util.NotFoundException;\n+import org.apache.syncope.core.workflow.WorkflowException;\n+import org.apache.syncope.core.workflow.WorkflowResult;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+@Transactional(rollbackFor = {Throwable.class})\n+public abstract class AbstractRoleWorkflowAdapter implements RoleWorkflowAdapter {\n+\n+    @Autowired\n+    protected RoleDataBinder dataBinder;\n+\n+    @Autowired\n+    protected RoleDAO roleDAO;\n+\n+    @Override\n+    public Class<? extends WorkflowLoader> getLoaderClass() {\n+        return null;\n+    }\n+\n+    protected abstract WorkflowResult<Long> doUpdate(SyncopeRole role, RoleMod roleMod)\n+            throws WorkflowException;\n+\n+    @Override\n+    public WorkflowResult<Long> update(final RoleMod roleMod)\n+            throws UnauthorizedRoleException, NotFoundException, WorkflowException {\n+\n+        return doUpdate(dataBinder.getRoleFromId(roleMod.getId()), roleMod);\n+    }\n+\n+    protected abstract void doDelete(SyncopeRole role) throws WorkflowException;\n+\n+    @Override\n+    public void delete(final Long roleId) throws UnauthorizedRoleException, NotFoundException, WorkflowException {\n+        doDelete(dataBinder.getRoleFromId(roleId));\n+    }\n+}"},{"sha":"06820d1bf9024b64842423849d025b7ca06aa146","filename":"core/src/main/java/org/apache/syncope/core/workflow/role/NoOpRoleWorkflowAdapter.java","status":"added","additions":131,"deletions":0,"changes":131,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fworkflow%2Frole%2FNoOpRoleWorkflowAdapter.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fworkflow%2Frole%2FNoOpRoleWorkflowAdapter.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fworkflow%2Frole%2FNoOpRoleWorkflowAdapter.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -0,0 +1,131 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.core.workflow.role;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.syncope.client.mod.RoleMod;\n+import org.apache.syncope.client.to.RoleTO;\n+import org.apache.syncope.client.to.WorkflowDefinitionTO;\n+import org.apache.syncope.client.to.WorkflowFormTO;\n+import org.apache.syncope.core.persistence.beans.role.SyncopeRole;\n+import org.apache.syncope.core.propagation.PropagationByResource;\n+import org.apache.syncope.core.rest.controller.UnauthorizedRoleException;\n+import org.apache.syncope.core.util.NotFoundException;\n+import org.apache.syncope.core.workflow.WorkflowException;\n+import org.apache.syncope.core.workflow.WorkflowResult;\n+import org.apache.syncope.types.ResourceOperation;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+/**\n+ * Simple implementation basically not involving any workflow engine.\n+ */\n+@Transactional(rollbackFor = {Throwable.class})\n+public class NoOpRoleWorkflowAdapter extends AbstractRoleWorkflowAdapter {\n+\n+    private static final List<String> TASKS = Arrays.asList(new String[]{\"create\", \"update\", \"delete\"});\n+\n+    @Override\n+    public WorkflowResult<Long> create(final RoleTO roleTO)\n+            throws UnauthorizedRoleException, WorkflowException {\n+\n+        SyncopeRole role = new SyncopeRole();\n+        dataBinder.create(role, roleTO);\n+        role = roleDAO.save(role);\n+\n+        final PropagationByResource propByRes = new PropagationByResource();\n+        propByRes.set(ResourceOperation.CREATE, role.getResourceNames());\n+\n+        return new WorkflowResult<Long>(role.getId(), propByRes, \"create\");\n+    }\n+\n+    @Override\n+    protected WorkflowResult<Long> doUpdate(final SyncopeRole role, final RoleMod roleMod)\n+            throws WorkflowException {\n+\n+        PropagationByResource propByRes = dataBinder.update(role, roleMod);\n+\n+        SyncopeRole updated = roleDAO.save(role);\n+\n+        return new WorkflowResult<Long>(updated.getId(), propByRes, \"update\");\n+    }\n+\n+    @Override\n+    protected void doDelete(final SyncopeRole role)\n+            throws WorkflowException {\n+\n+        roleDAO.delete(role);\n+    }\n+\n+    @Override\n+    public WorkflowResult<Long> execute(RoleTO roleTO, String taskId) throws UnauthorizedRoleException,\n+            NotFoundException, WorkflowException {\n+\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public WorkflowDefinitionTO getDefinition()\n+            throws WorkflowException {\n+\n+        return new WorkflowDefinitionTO();\n+    }\n+\n+    @Override\n+    public void updateDefinition(final WorkflowDefinitionTO definition)\n+            throws NotFoundException, WorkflowException {\n+\n+        throw new WorkflowException(new UnsupportedOperationException(\"Not supported.\"));\n+    }\n+\n+    @Override\n+    public List<String> getDefinedTasks()\n+            throws WorkflowException {\n+\n+        return TASKS;\n+    }\n+\n+    @Override\n+    public List<WorkflowFormTO> getForms() {\n+        return Collections.emptyList();\n+    }\n+\n+    @Override\n+    public WorkflowFormTO getForm(final String workflowId)\n+            throws NotFoundException, WorkflowException {\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public WorkflowFormTO claimForm(final String taskId, final String username)\n+            throws NotFoundException, WorkflowException {\n+\n+        throw new WorkflowException(new UnsupportedOperationException(\"Not supported.\"));\n+    }\n+\n+    @Override\n+    public WorkflowResult<Map.Entry<Long, String>> submitForm(final WorkflowFormTO form, final String username)\n+            throws NotFoundException, WorkflowException {\n+\n+        throw new WorkflowException(new UnsupportedOperationException(\"Not supported.\"));\n+    }\n+}"},{"sha":"b70fc2ae6013a43f4f2cc673d4eaaeae4dea6d05","filename":"core/src/main/java/org/apache/syncope/core/workflow/role/RoleWorkflowAdapter.java","status":"added","additions":78,"deletions":0,"changes":78,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fworkflow%2Frole%2FRoleWorkflowAdapter.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fworkflow%2Frole%2FRoleWorkflowAdapter.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fworkflow%2Frole%2FRoleWorkflowAdapter.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -0,0 +1,78 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.core.workflow.role;\n+\n+import org.apache.syncope.client.mod.RoleMod;\n+import org.apache.syncope.client.to.RoleTO;\n+import org.apache.syncope.core.rest.controller.UnauthorizedRoleException;\n+import org.apache.syncope.core.util.NotFoundException;\n+import org.apache.syncope.core.workflow.WorkflowAdapter;\n+import org.apache.syncope.core.workflow.WorkflowException;\n+import org.apache.syncope.core.workflow.WorkflowResult;\n+\n+/**\n+ * Interface for calling underlying workflow implementations.\n+ */\n+public interface RoleWorkflowAdapter extends WorkflowAdapter {\n+\n+    /**\n+     * Create a role.\n+     *\n+     * @param roleTO role to be created and wether to propagate it as active\n+     * @return role just created\n+     * @throws UnauthorizedRoleException authorization exception\n+     * @throws WorkflowException workflow exception\n+     */\n+    WorkflowResult<Long> create(RoleTO roleTO) throws UnauthorizedRoleException, WorkflowException;\n+\n+    /**\n+     * Execute a task on a role.\n+     *\n+     * @param roleTO role to be subject to task\n+     * @param taskId to be executed\n+     * @return role just updated\n+     * @throws UnauthorizedRoleException authorization exception\n+     * @throws NotFoundException role not found exception\n+     * @throws WorkflowException workflow exception\n+     */\n+    WorkflowResult<Long> execute(RoleTO roleTO, String taskId)\n+            throws UnauthorizedRoleException, NotFoundException, WorkflowException;\n+\n+    /**\n+     * Update a role.\n+     *\n+     * @param roleMod modification set to be performed\n+     * @return role just updated and propagations to be performed\n+     * @throws UnauthorizedRoleException authorization exception\n+     * @throws NotFoundException role not found exception\n+     * @throws WorkflowException workflow exception\n+     */\n+    WorkflowResult<Long> update(RoleMod roleMod)\n+            throws UnauthorizedRoleException, NotFoundException, WorkflowException;\n+\n+    /**\n+     * Delete a role.\n+     *\n+     * @param roleId role to be deleted\n+     * @throws UnauthorizedRoleException authorization exception\n+     * @throws NotFoundException role not found exception\n+     * @throws WorkflowException workflow exception\n+     */\n+    void delete(Long roleId) throws UnauthorizedRoleException, NotFoundException, WorkflowException;\n+}"},{"sha":"7fea9433a019741f0a429301e90a7b9318cfcce7","filename":"core/src/main/java/org/apache/syncope/core/workflow/user/AbstractUserWorkflowAdapter.java","status":"renamed","additions":3,"deletions":2,"changes":5,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fworkflow%2Fuser%2FAbstractUserWorkflowAdapter.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fworkflow%2Fuser%2FAbstractUserWorkflowAdapter.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fworkflow%2Fuser%2FAbstractUserWorkflowAdapter.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -16,7 +16,7 @@\n  * specific language governing permissions and limitations\n  * under the License.\n  */\n-package org.apache.syncope.core.workflow;\n+package org.apache.syncope.core.workflow.user;\n \n import java.util.Map;\n import java.util.Map.Entry;\n@@ -28,6 +28,8 @@\n import org.apache.syncope.core.rest.controller.UnauthorizedRoleException;\n import org.apache.syncope.core.rest.data.UserDataBinder;\n import org.apache.syncope.core.util.NotFoundException;\n+import org.apache.syncope.core.workflow.WorkflowException;\n+import org.apache.syncope.core.workflow.WorkflowResult;\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.transaction.annotation.Transactional;\n \n@@ -110,7 +112,6 @@ public WorkflowResult<Long> reactivate(final Long userId)\n \n     @Override\n     public void delete(final Long userId) throws UnauthorizedRoleException, NotFoundException, WorkflowException {\n-\n         doDelete(dataBinder.getUserFromId(userId));\n     }\n }","previous_filename":"core/src/main/java/org/apache/syncope/core/workflow/AbstractUserWorkflowAdapter.java"},{"sha":"469089ed110c68173410ed94ccabdb47fb44d707","filename":"core/src/main/java/org/apache/syncope/core/workflow/user/NoOpUserWorkflowAdapter.java","status":"renamed","additions":5,"deletions":3,"changes":8,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fworkflow%2Fuser%2FNoOpUserWorkflowAdapter.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fworkflow%2Fuser%2FNoOpUserWorkflowAdapter.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fworkflow%2Fuser%2FNoOpUserWorkflowAdapter.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -16,7 +16,7 @@\n  * specific language governing permissions and limitations\n  * under the License.\n  */\n-package org.apache.syncope.core.workflow;\n+package org.apache.syncope.core.workflow.user;\n \n import java.util.Arrays;\n import java.util.Collections;\n@@ -31,7 +31,9 @@\n import org.apache.syncope.core.propagation.PropagationByResource;\n import org.apache.syncope.core.rest.controller.UnauthorizedRoleException;\n import org.apache.syncope.core.util.NotFoundException;\n-import org.apache.syncope.types.PropagationOperation;\n+import org.apache.syncope.core.workflow.WorkflowException;\n+import org.apache.syncope.core.workflow.WorkflowResult;\n+import org.apache.syncope.types.ResourceOperation;\n import org.springframework.transaction.annotation.Transactional;\n \n /**\n@@ -81,7 +83,7 @@ public WorkflowResult<Map.Entry<Long, Boolean>> create(final UserTO userTO, fina\n         user = userDAO.save(user);\n \n         final PropagationByResource propByRes = new PropagationByResource();\n-        propByRes.set(PropagationOperation.CREATE, user.getResourceNames());\n+        propByRes.set(ResourceOperation.CREATE, user.getResourceNames());\n \n         return new WorkflowResult<Map.Entry<Long, Boolean>>(new DefaultMapEntry(user.getId(), propagateEnable),\n                 propByRes, \"create\");","previous_filename":"core/src/main/java/org/apache/syncope/core/workflow/NoOpUserWorkflowAdapter.java"},{"sha":"ba28ad1ba4daf0f057b0ce9924af3960246f75a9","filename":"core/src/main/java/org/apache/syncope/core/workflow/user/UserWorkflowAdapter.java","status":"renamed","additions":7,"deletions":83,"changes":90,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fworkflow%2Fuser%2FUserWorkflowAdapter.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fworkflow%2Fuser%2FUserWorkflowAdapter.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fworkflow%2Fuser%2FUserWorkflowAdapter.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -16,33 +16,22 @@\n  * specific language governing permissions and limitations\n  * under the License.\n  */\n-package org.apache.syncope.core.workflow;\n+package org.apache.syncope.core.workflow.user;\n \n-import java.util.List;\n import java.util.Map;\n import org.apache.syncope.client.mod.UserMod;\n import org.apache.syncope.client.to.UserTO;\n-import org.apache.syncope.client.to.WorkflowDefinitionTO;\n-import org.apache.syncope.client.to.WorkflowFormTO;\n-import org.apache.syncope.core.init.SpringContextInitializer;\n-import org.apache.syncope.core.init.WorkflowLoader;\n import org.apache.syncope.core.persistence.beans.user.SyncopeUser;\n import org.apache.syncope.core.rest.controller.UnauthorizedRoleException;\n import org.apache.syncope.core.util.NotFoundException;\n+import org.apache.syncope.core.workflow.WorkflowAdapter;\n+import org.apache.syncope.core.workflow.WorkflowException;\n+import org.apache.syncope.core.workflow.WorkflowResult;\n \n /**\n  * Interface for calling underlying workflow implementations.\n  */\n-public interface UserWorkflowAdapter {\n-\n-    /**\n-     * Give the class to be instantiated and invoked by SpringContextInitializer for loading anything needed by this\n-     * adapter.\n-     *\n-     * @return null if no init is needed or the WorkflowLoader class for handling initialization\n-     * @see SpringContextInitializer\n-     */\n-    Class<? extends WorkflowLoader> getLoaderClass();\n+public interface UserWorkflowAdapter extends WorkflowAdapter {\n \n     /**\n      * Create an user.\n@@ -71,7 +60,7 @@ WorkflowResult<Map.Entry<Long, Boolean>> create(UserTO userTO, boolean disablePw\n      *\n      * @param userTO user to be created and wether to propagate it as active\n      * @param disablePwdPolicyCheck disable password policy check?\n-     * @param enabled specify true/false to force active/supended status.\n+     * @param enabled specify true/false to force active/supended status\n      * @return user just created\n      * @throws UnauthorizedRoleException authorization exception\n      * @throws WorkflowException workflow exception\n@@ -106,7 +95,7 @@ WorkflowResult<Long> activate(Long userId, String token)\n             throws UnauthorizedRoleException, NotFoundException, WorkflowException;\n \n     /**\n-     * Updated an user.\n+     * Update an user.\n      *\n      * @param userMod modification set to be performed\n      * @return user just updated and propagations to be performed\n@@ -158,69 +147,4 @@ WorkflowResult<Map.Entry<Long, Boolean>> update(UserMod userMod)\n      * @throws WorkflowException workflow exception\n      */\n     void delete(Long userId) throws UnauthorizedRoleException, NotFoundException, WorkflowException;\n-\n-    /**\n-     * Get workflow definition.\n-     *\n-     * @return workflow definition as XML\n-     * @throws WorkflowException workflow exception\n-     */\n-    WorkflowDefinitionTO getDefinition() throws WorkflowException;\n-\n-    /**\n-     * Update workflow definition.\n-     *\n-     * @param definition definition as XML\n-     * @throws NotFoundException definition not found exception\n-     * @throws WorkflowException workflow exception\n-     */\n-    void updateDefinition(WorkflowDefinitionTO definition) throws NotFoundException, WorkflowException;\n-\n-    /**\n-     * Get list of defined tasks in workflow.\n-     *\n-     * @return list of defined tasks in workflow\n-     * @throws WorkflowException workflow exception\n-     */\n-    List<String> getDefinedTasks() throws WorkflowException;\n-\n-    /**\n-     * Get all defined forms for current workflow process instances.\n-     *\n-     * @return list of defined forms\n-     */\n-    List<WorkflowFormTO> getForms();\n-\n-    /**\n-     * Get form for given workflowId (if present).\n-     *\n-     * @param workflowId workflow id\n-     * @return form (if present), otherwise null\n-     * @throws NotFoundException definition not found exception\n-     * @throws WorkflowException workflow exception\n-     */\n-    WorkflowFormTO getForm(String workflowId) throws NotFoundException, WorkflowException;\n-\n-    /**\n-     * Claim a form for a given user.\n-     *\n-     * @param taskId Workflow task to which the form is associated\n-     * @param username claiming username\n-     * @return updated form\n-     * @throws NotFoundException not found exception\n-     * @throws WorkflowException workflow exception\n-     */\n-    WorkflowFormTO claimForm(String taskId, String username) throws NotFoundException, WorkflowException;\n-\n-    /**\n-     * Submit a form.\n-     *\n-     * @param form to be submitted\n-     * @param username submitting username\n-     * @return user updated by this form submit\n-     * @throws NotFoundException not found exception\n-     * @throws WorkflowException workflow exception\n-     */\n-    WorkflowResult<Map.Entry<Long, String>> submitForm(WorkflowFormTO form, String username)\n-            throws NotFoundException, WorkflowException;\n }","previous_filename":"core/src/main/java/org/apache/syncope/core/workflow/UserWorkflowAdapter.java"},{"sha":"75ac4df2fa10737742be0fe60d729ac504b91feb","filename":"core/src/main/java/org/apache/syncope/core/workflow/user/activiti/ActivitiUserWorkflowAdapter.java","status":"renamed","additions":6,"deletions":5,"changes":11,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fworkflow%2Fuser%2Factiviti%2FActivitiUserWorkflowAdapter.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fworkflow%2Fuser%2Factiviti%2FActivitiUserWorkflowAdapter.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fworkflow%2Fuser%2Factiviti%2FActivitiUserWorkflowAdapter.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -16,7 +16,7 @@\n  * specific language governing permissions and limitations\n  * under the License.\n  */\n-package org.apache.syncope.core.workflow;\n+package org.apache.syncope.core.workflow.user.activiti;\n \n import java.io.BufferedReader;\n import java.io.ByteArrayInputStream;\n@@ -59,13 +59,15 @@\n import org.apache.syncope.client.to.WorkflowDefinitionTO;\n import org.apache.syncope.client.to.WorkflowFormPropertyTO;\n import org.apache.syncope.client.to.WorkflowFormTO;\n-import org.apache.syncope.core.init.ActivitiWorkflowLoader;\n import org.apache.syncope.core.init.WorkflowLoader;\n import org.apache.syncope.core.persistence.beans.user.SyncopeUser;\n import org.apache.syncope.core.propagation.PropagationByResource;\n import org.apache.syncope.core.rest.controller.UnauthorizedRoleException;\n import org.apache.syncope.core.util.NotFoundException;\n-import org.apache.syncope.types.PropagationOperation;\n+import org.apache.syncope.core.workflow.WorkflowException;\n+import org.apache.syncope.core.workflow.WorkflowResult;\n+import org.apache.syncope.core.workflow.user.AbstractUserWorkflowAdapter;\n+import org.apache.syncope.types.ResourceOperation;\n import org.apache.syncope.types.WorkflowFormPropertyType;\n import org.identityconnectors.common.security.EncryptorFactory;\n import org.slf4j.Logger;\n@@ -235,13 +237,12 @@ public WorkflowResult<Map.Entry<Long, Boolean>> create(final UserTO userTO, fina\n         // save resources to be propagated and password for later -\n         // after form submission - propagation\n         PropagationByResource propByRes = new PropagationByResource();\n-        propByRes.set(PropagationOperation.CREATE, user.getResourceNames());\n+        propByRes.set(ResourceOperation.CREATE, user.getResourceNames());\n \n         String formTaskId = getFormTask(user);\n         if (formTaskId != null) {\n             // SYNCOPE-238: This is needed to simplify the task query in this.getForms()\n             taskService.setVariableLocal(formTaskId, TASK_IS_FORM, Boolean.TRUE);\n-\n             runtimeService.setVariable(processInstance.getProcessInstanceId(), PROP_BY_RESOURCE, propByRes);\n             propByRes = null;\n ","previous_filename":"core/src/main/java/org/apache/syncope/core/workflow/ActivitiUserWorkflowAdapter.java"},{"sha":"33342c992a2c8eff459498ed13e6e37098b09c1d","filename":"core/src/main/java/org/apache/syncope/core/workflow/user/activiti/ActivitiWorkflowLoader.java","status":"renamed","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fworkflow%2Fuser%2Factiviti%2FActivitiWorkflowLoader.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fworkflow%2Fuser%2Factiviti%2FActivitiWorkflowLoader.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fworkflow%2Fuser%2Factiviti%2FActivitiWorkflowLoader.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -16,14 +16,14 @@\n  * specific language governing permissions and limitations\n  * under the License.\n  */\n-package org.apache.syncope.core.init;\n+package org.apache.syncope.core.workflow.user.activiti;\n \n import java.io.IOException;\n import java.io.InputStream;\n import java.util.List;\n import org.activiti.engine.RepositoryService;\n import org.activiti.engine.repository.ProcessDefinition;\n-import org.apache.syncope.core.workflow.ActivitiUserWorkflowAdapter;\n+import org.apache.syncope.core.init.WorkflowLoader;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.springframework.beans.factory.annotation.Autowired;","previous_filename":"core/src/main/java/org/apache/syncope/core/init/ActivitiWorkflowLoader.java"},{"sha":"d46756ef755cc9b46bbc4da865164ac4829351ad","filename":"core/src/main/java/org/apache/syncope/core/workflow/user/activiti/SyncopeEntitiesVariableType.java","status":"renamed","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fworkflow%2Fuser%2Factiviti%2FSyncopeEntitiesVariableType.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fworkflow%2Fuser%2Factiviti%2FSyncopeEntitiesVariableType.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fworkflow%2Fuser%2Factiviti%2FSyncopeEntitiesVariableType.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -16,7 +16,7 @@\n  * specific language governing permissions and limitations\n  * under the License.\n  */\n-package org.apache.syncope.core.workflow.activiti;\n+package org.apache.syncope.core.workflow.user.activiti;\n \n import org.activiti.engine.impl.variable.SerializableType;\n import org.apache.syncope.core.persistence.beans.AbstractBaseBean;","previous_filename":"core/src/main/java/org/apache/syncope/core/workflow/activiti/SyncopeEntitiesVariableType.java"},{"sha":"cfe20d6228f16330b4660e528c565452ec785c9f","filename":"core/src/main/java/org/apache/syncope/core/workflow/user/activiti/SyncopeGroupManager.java","status":"renamed","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fworkflow%2Fuser%2Factiviti%2FSyncopeGroupManager.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fworkflow%2Fuser%2Factiviti%2FSyncopeGroupManager.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fworkflow%2Fuser%2Factiviti%2FSyncopeGroupManager.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -16,7 +16,7 @@\n  * specific language governing permissions and limitations\n  * under the License.\n  */\n-package org.apache.syncope.core.workflow.activiti;\n+package org.apache.syncope.core.workflow.user.activiti;\n \n import java.util.ArrayList;\n import java.util.Collections;","previous_filename":"core/src/main/java/org/apache/syncope/core/workflow/activiti/SyncopeGroupManager.java"},{"sha":"5d071c24285d5fed0b4521a399c7416fc66a06f8","filename":"core/src/main/java/org/apache/syncope/core/workflow/user/activiti/SyncopeGroupQueryImpl.java","status":"renamed","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fworkflow%2Fuser%2Factiviti%2FSyncopeGroupQueryImpl.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fworkflow%2Fuser%2Factiviti%2FSyncopeGroupQueryImpl.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fworkflow%2Fuser%2Factiviti%2FSyncopeGroupQueryImpl.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -16,7 +16,7 @@\n  * specific language governing permissions and limitations\n  * under the License.\n  */\n-package org.apache.syncope.core.workflow.activiti;\n+package org.apache.syncope.core.workflow.user.activiti;\n \n import java.util.ArrayList;\n import java.util.Collections;","previous_filename":"core/src/main/java/org/apache/syncope/core/workflow/activiti/SyncopeGroupQueryImpl.java"},{"sha":"3dd4f2103dc454c5e6bd7af7c3e71ce3cd880ff2","filename":"core/src/main/java/org/apache/syncope/core/workflow/user/activiti/SyncopeSession.java","status":"renamed","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fworkflow%2Fuser%2Factiviti%2FSyncopeSession.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fworkflow%2Fuser%2Factiviti%2FSyncopeSession.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fworkflow%2Fuser%2Factiviti%2FSyncopeSession.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -16,7 +16,7 @@\n  * specific language governing permissions and limitations\n  * under the License.\n  */\n-package org.apache.syncope.core.workflow.activiti;\n+package org.apache.syncope.core.workflow.user.activiti;\n \n import org.activiti.engine.impl.interceptor.Session;\n ","previous_filename":"core/src/main/java/org/apache/syncope/core/workflow/activiti/SyncopeSession.java"},{"sha":"41513eaf57d0ff4f8aaffb07c60685e08d060970","filename":"core/src/main/java/org/apache/syncope/core/workflow/user/activiti/SyncopeSessionFactory.java","status":"renamed","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fworkflow%2Fuser%2Factiviti%2FSyncopeSessionFactory.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fworkflow%2Fuser%2Factiviti%2FSyncopeSessionFactory.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fworkflow%2Fuser%2Factiviti%2FSyncopeSessionFactory.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -16,7 +16,7 @@\n  * specific language governing permissions and limitations\n  * under the License.\n  */\n-package org.apache.syncope.core.workflow.activiti;\n+package org.apache.syncope.core.workflow.user.activiti;\n \n import org.activiti.engine.impl.interceptor.Session;\n import org.activiti.engine.impl.interceptor.SessionFactory;","previous_filename":"core/src/main/java/org/apache/syncope/core/workflow/activiti/SyncopeSessionFactory.java"},{"sha":"023823db5e1511d614f8520ba04d06824b744dee","filename":"core/src/main/java/org/apache/syncope/core/workflow/user/activiti/SyncopeUserManager.java","status":"renamed","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fworkflow%2Fuser%2Factiviti%2FSyncopeUserManager.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fworkflow%2Fuser%2Factiviti%2FSyncopeUserManager.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fworkflow%2Fuser%2Factiviti%2FSyncopeUserManager.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -16,7 +16,7 @@\n  * specific language governing permissions and limitations\n  * under the License.\n  */\n-package org.apache.syncope.core.workflow.activiti;\n+package org.apache.syncope.core.workflow.user.activiti;\n \n import java.util.ArrayList;\n import java.util.Collections;","previous_filename":"core/src/main/java/org/apache/syncope/core/workflow/activiti/SyncopeUserManager.java"},{"sha":"76d3eeb38c0310a2888f1373946fc52faf052cc1","filename":"core/src/main/java/org/apache/syncope/core/workflow/user/activiti/SyncopeUserQueryImpl.java","status":"renamed","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fworkflow%2Fuser%2Factiviti%2FSyncopeUserQueryImpl.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fworkflow%2Fuser%2Factiviti%2FSyncopeUserQueryImpl.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fworkflow%2Fuser%2Factiviti%2FSyncopeUserQueryImpl.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -16,7 +16,7 @@\n  * specific language governing permissions and limitations\n  * under the License.\n  */\n-package org.apache.syncope.core.workflow.activiti;\n+package org.apache.syncope.core.workflow.user.activiti;\n \n import java.util.ArrayList;\n import java.util.Collections;","previous_filename":"core/src/main/java/org/apache/syncope/core/workflow/activiti/SyncopeUserQueryImpl.java"},{"sha":"4b28f3c6337daa8aeccbda2a9ec6c9ac6cdd4b6d","filename":"core/src/main/java/org/apache/syncope/core/workflow/user/activiti/task/AbstractActivitiDelegate.java","status":"renamed","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fworkflow%2Fuser%2Factiviti%2Ftask%2FAbstractActivitiDelegate.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fworkflow%2Fuser%2Factiviti%2Ftask%2FAbstractActivitiDelegate.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fworkflow%2Fuser%2Factiviti%2Ftask%2FAbstractActivitiDelegate.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -16,7 +16,7 @@\n  * specific language governing permissions and limitations\n  * under the License.\n  */\n-package org.apache.syncope.core.workflow.activiti;\n+package org.apache.syncope.core.workflow.user.activiti.task;\n \n import org.activiti.engine.TaskService;\n import org.activiti.engine.delegate.DelegateExecution;","previous_filename":"core/src/main/java/org/apache/syncope/core/workflow/activiti/AbstractActivitiDelegate.java"},{"sha":"457ff2fc7ee15a10a2e2105eb002821b343eb230","filename":"core/src/main/java/org/apache/syncope/core/workflow/user/activiti/task/AutoActivate.java","status":"renamed","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fworkflow%2Fuser%2Factiviti%2Ftask%2FAutoActivate.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fworkflow%2Fuser%2Factiviti%2Ftask%2FAutoActivate.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fworkflow%2Fuser%2Factiviti%2Ftask%2FAutoActivate.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -16,10 +16,10 @@\n  * specific language governing permissions and limitations\n  * under the License.\n  */\n-package org.apache.syncope.core.workflow.activiti;\n+package org.apache.syncope.core.workflow.user.activiti.task;\n \n import org.activiti.engine.delegate.DelegateExecution;\n-import org.apache.syncope.core.workflow.ActivitiUserWorkflowAdapter;\n+import org.apache.syncope.core.workflow.user.activiti.ActivitiUserWorkflowAdapter;\n \n public class AutoActivate extends AbstractActivitiDelegate {\n ","previous_filename":"core/src/main/java/org/apache/syncope/core/workflow/activiti/AutoActivate.java"},{"sha":"282affda167d91c2f464ec60e41af8d4e4cfb915","filename":"core/src/main/java/org/apache/syncope/core/workflow/user/activiti/task/Create.java","status":"renamed","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fworkflow%2Fuser%2Factiviti%2Ftask%2FCreate.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fworkflow%2Fuser%2Factiviti%2Ftask%2FCreate.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fworkflow%2Fuser%2Factiviti%2Ftask%2FCreate.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -16,12 +16,12 @@\n  * specific language governing permissions and limitations\n  * under the License.\n  */\n-package org.apache.syncope.core.workflow.activiti;\n+package org.apache.syncope.core.workflow.user.activiti.task;\n \n import org.activiti.engine.delegate.DelegateExecution;\n import org.apache.syncope.client.to.UserTO;\n import org.apache.syncope.core.persistence.beans.user.SyncopeUser;\n-import org.apache.syncope.core.workflow.ActivitiUserWorkflowAdapter;\n+import org.apache.syncope.core.workflow.user.activiti.ActivitiUserWorkflowAdapter;\n \n public class Create extends AbstractActivitiDelegate {\n ","previous_filename":"core/src/main/java/org/apache/syncope/core/workflow/activiti/Create.java"},{"sha":"1849c870286045f53f93d4d4e2360632db0ca564","filename":"core/src/main/java/org/apache/syncope/core/workflow/user/activiti/task/Delete.java","status":"renamed","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fworkflow%2Fuser%2Factiviti%2Ftask%2FDelete.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fworkflow%2Fuser%2Factiviti%2Ftask%2FDelete.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fworkflow%2Fuser%2Factiviti%2Ftask%2FDelete.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -16,11 +16,11 @@\n  * specific language governing permissions and limitations\n  * under the License.\n  */\n-package org.apache.syncope.core.workflow.activiti;\n+package org.apache.syncope.core.workflow.user.activiti.task;\n \n import org.activiti.engine.delegate.DelegateExecution;\n import org.apache.syncope.core.persistence.beans.user.SyncopeUser;\n-import org.apache.syncope.core.workflow.ActivitiUserWorkflowAdapter;\n+import org.apache.syncope.core.workflow.user.activiti.ActivitiUserWorkflowAdapter;\n \n public class Delete extends AbstractActivitiDelegate {\n ","previous_filename":"core/src/main/java/org/apache/syncope/core/workflow/activiti/Delete.java"},{"sha":"eefca2be595d7d4ab3a46492ff535867a75eedb8","filename":"core/src/main/java/org/apache/syncope/core/workflow/user/activiti/task/GenerateToken.java","status":"renamed","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fworkflow%2Fuser%2Factiviti%2Ftask%2FGenerateToken.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fworkflow%2Fuser%2Factiviti%2Ftask%2FGenerateToken.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fworkflow%2Fuser%2Factiviti%2Ftask%2FGenerateToken.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -16,11 +16,11 @@\n  * specific language governing permissions and limitations\n  * under the License.\n  */\n-package org.apache.syncope.core.workflow.activiti;\n+package org.apache.syncope.core.workflow.user.activiti.task;\n \n import org.activiti.engine.delegate.DelegateExecution;\n import org.apache.syncope.core.persistence.beans.user.SyncopeUser;\n-import org.apache.syncope.core.workflow.ActivitiUserWorkflowAdapter;\n+import org.apache.syncope.core.workflow.user.activiti.ActivitiUserWorkflowAdapter;\n \n public class GenerateToken extends AbstractActivitiDelegate {\n ","previous_filename":"core/src/main/java/org/apache/syncope/core/workflow/activiti/GenerateToken.java"},{"sha":"920376ca13956cd7f933b86075368daf555c44e6","filename":"core/src/main/java/org/apache/syncope/core/workflow/user/activiti/task/Reactivate.java","status":"renamed","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fworkflow%2Fuser%2Factiviti%2Ftask%2FReactivate.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fworkflow%2Fuser%2Factiviti%2Ftask%2FReactivate.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fworkflow%2Fuser%2Factiviti%2Ftask%2FReactivate.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -16,7 +16,7 @@\n  * specific language governing permissions and limitations\n  * under the License.\n  */\n-package org.apache.syncope.core.workflow.activiti;\n+package org.apache.syncope.core.workflow.user.activiti.task;\n \n import org.activiti.engine.delegate.DelegateExecution;\n ","previous_filename":"core/src/main/java/org/apache/syncope/core/workflow/activiti/Reactivate.java"},{"sha":"df24bca8e99580b4a5c1cd459cf711049dea7382","filename":"core/src/main/java/org/apache/syncope/core/workflow/user/activiti/task/Suspend.java","status":"renamed","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fworkflow%2Fuser%2Factiviti%2Ftask%2FSuspend.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fworkflow%2Fuser%2Factiviti%2Ftask%2FSuspend.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fworkflow%2Fuser%2Factiviti%2Ftask%2FSuspend.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -16,7 +16,7 @@\n  * specific language governing permissions and limitations\n  * under the License.\n  */\n-package org.apache.syncope.core.workflow.activiti;\n+package org.apache.syncope.core.workflow.user.activiti.task;\n \n import org.activiti.engine.delegate.DelegateExecution;\n ","previous_filename":"core/src/main/java/org/apache/syncope/core/workflow/activiti/Suspend.java"},{"sha":"1899be62f91df8cbe52ac36e9dfbbc801c4bf65c","filename":"core/src/main/java/org/apache/syncope/core/workflow/user/activiti/task/Update.java","status":"renamed","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fworkflow%2Fuser%2Factiviti%2Ftask%2FUpdate.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fworkflow%2Fuser%2Factiviti%2Ftask%2FUpdate.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fworkflow%2Fuser%2Factiviti%2Ftask%2FUpdate.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -16,13 +16,13 @@\n  * specific language governing permissions and limitations\n  * under the License.\n  */\n-package org.apache.syncope.core.workflow.activiti;\n+package org.apache.syncope.core.workflow.user.activiti.task;\n \n import org.activiti.engine.delegate.DelegateExecution;\n import org.apache.syncope.client.mod.UserMod;\n import org.apache.syncope.core.persistence.beans.user.SyncopeUser;\n import org.apache.syncope.core.propagation.PropagationByResource;\n-import org.apache.syncope.core.workflow.ActivitiUserWorkflowAdapter;\n+import org.apache.syncope.core.workflow.user.activiti.ActivitiUserWorkflowAdapter;\n \n public class Update extends AbstractActivitiDelegate {\n ","previous_filename":"core/src/main/java/org/apache/syncope/core/workflow/activiti/Update.java"},{"sha":"b5d69c5e608ea516b69ec2818b40a6309d7c2f9c","filename":"core/src/main/resources/META-INF/orm.xml","status":"modified","additions":27,"deletions":3,"changes":30,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fresources%2FMETA-INF%2Form.xml","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fresources%2FMETA-INF%2Form.xml","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fresources%2FMETA-INF%2Form.xml?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -55,11 +55,35 @@ under the License.\n     </attributes>\n   </entity>\n \n-  <entity class=\"org.apache.syncope.core.persistence.beans.SchemaMapping\">\n+  <entity class=\"org.apache.syncope.core.persistence.beans.user.UMapping\">\n     <attributes>\n       <id name=\"id\">\n-        <generated-value generator=\"SEQ_SchemaMapping\" strategy=\"TABLE\"/>\n-        <table-generator name=\"SEQ_SchemaMapping\" pk-column-value=\"SEQ_SchemaMapping\" initial-value=\"1000\"/>\n+        <generated-value generator=\"SEQ_UMapping\" strategy=\"TABLE\"/>\n+        <table-generator name=\"SEQ_UMapping\" pk-column-value=\"SEQ_UMapping\" initial-value=\"100\"/>\n+      </id>\n+    </attributes>\n+  </entity>\n+  <entity class=\"org.apache.syncope.core.persistence.beans.role.RMapping\">\n+    <attributes>\n+      <id name=\"id\">\n+        <generated-value generator=\"SEQ_RMapping\" strategy=\"TABLE\"/>\n+        <table-generator name=\"SEQ_RMapping\" pk-column-value=\"SEQ_RMapping\" initial-value=\"100\"/>\n+      </id>\n+    </attributes>\n+  </entity>\n+  <entity class=\"org.apache.syncope.core.persistence.beans.user.UMappingItem\">\n+    <attributes>\n+      <id name=\"id\">\n+        <generated-value generator=\"SEQ_UMappingItem\" strategy=\"TABLE\"/>\n+        <table-generator name=\"SEQ_UMappingItem\" pk-column-value=\"SEQ_UMappingItem\" initial-value=\"1000\"/>\n+      </id>\n+    </attributes>\n+  </entity>\n+  <entity class=\"org.apache.syncope.core.persistence.beans.role.RMappingItem\">\n+    <attributes>\n+      <id name=\"id\">\n+        <generated-value generator=\"SEQ_RMappingItem\" strategy=\"TABLE\"/>\n+        <table-generator name=\"SEQ_RMappingItem\" pk-column-value=\"SEQ_RMappingItem\" initial-value=\"1000\"/>\n       </id>\n     </attributes>\n   </entity>"},{"sha":"9c490c86ce07e6a75be3acfc7f55009cf563cf59","filename":"core/src/main/resources/META-INF/orm.xml.oracle","status":"modified","additions":27,"deletions":3,"changes":30,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fresources%2FMETA-INF%2Form.xml.oracle","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fresources%2FMETA-INF%2Form.xml.oracle","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fresources%2FMETA-INF%2Form.xml.oracle?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -55,11 +55,35 @@ under the License.\n     </attributes>\n   </entity>\n \n-  <entity class=\"org.apache.syncope.core.persistence.beans.SchemaMapping\">\n+  <entity class=\"org.apache.syncope.core.persistence.beans.user.UMapping\">\n     <attributes>\n       <id name=\"id\">\n-        <generated-value generator=\"SEQ_SchemaMapping\" strategy=\"TABLE\"/>\n-        <table-generator name=\"SEQ_SchemaMapping\" pk-column-value=\"SEQ_SchemaMapping\" initial-value=\"1000\"/>\n+        <generated-value generator=\"SEQ_UMapping\" strategy=\"TABLE\"/>\n+        <table-generator name=\"SEQ_UMapping\" pk-column-value=\"SEQ_UMapping\" initial-value=\"100\"/>\n+      </id>\n+    </attributes>\n+  </entity>\n+  <entity class=\"org.apache.syncope.core.persistence.beans.role.RMapping\">\n+    <attributes>\n+      <id name=\"id\">\n+        <generated-value generator=\"SEQ_RMapping\" strategy=\"TABLE\"/>\n+        <table-generator name=\"SEQ_RMapping\" pk-column-value=\"SEQ_RMapping\" initial-value=\"100\"/>\n+      </id>\n+    </attributes>\n+  </entity>\n+  <entity class=\"org.apache.syncope.core.persistence.beans.user.UMappingItem\">\n+    <attributes>\n+      <id name=\"id\">\n+        <generated-value generator=\"SEQ_UMappingItem\" strategy=\"TABLE\"/>\n+        <table-generator name=\"SEQ_UMappingItem\" pk-column-value=\"SEQ_UMappingItem\" initial-value=\"1000\"/>\n+      </id>\n+    </attributes>\n+  </entity>\n+  <entity class=\"org.apache.syncope.core.persistence.beans.role.RMappingItem\">\n+    <attributes>\n+      <id name=\"id\">\n+        <generated-value generator=\"SEQ_RMappingItem\" strategy=\"TABLE\"/>\n+        <table-generator name=\"SEQ_RMappingItem\" pk-column-value=\"SEQ_RMappingItem\" initial-value=\"1000\"/>\n       </id>\n     </attributes>\n   </entity>"},{"sha":"22eee9196e7ee8c30760c50d8abbc596827c04ee","filename":"core/src/main/resources/META-INF/orm.xml.sqlserver","status":"modified","additions":27,"deletions":3,"changes":30,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fresources%2FMETA-INF%2Form.xml.sqlserver","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fresources%2FMETA-INF%2Form.xml.sqlserver","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fresources%2FMETA-INF%2Form.xml.sqlserver?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -55,11 +55,35 @@ under the License.\n     </attributes>\n   </entity>\n \n-  <entity class=\"org.apache.syncope.core.persistence.beans.SchemaMapping\">\n+  <entity class=\"org.apache.syncope.core.persistence.beans.user.UMapping\">\n     <attributes>\n       <id name=\"id\">\n-        <generated-value generator=\"SEQ_SchemaMapping\" strategy=\"TABLE\"/>\n-        <table-generator name=\"SEQ_SchemaMapping\" pk-column-value=\"SEQ_SchemaMapping\" initial-value=\"1000\"/>\n+        <generated-value generator=\"SEQ_UMapping\" strategy=\"TABLE\"/>\n+        <table-generator name=\"SEQ_UMapping\" pk-column-value=\"SEQ_UMapping\" initial-value=\"100\"/>\n+      </id>\n+    </attributes>\n+  </entity>\n+  <entity class=\"org.apache.syncope.core.persistence.beans.role.RMapping\">\n+    <attributes>\n+      <id name=\"id\">\n+        <generated-value generator=\"SEQ_RMapping\" strategy=\"TABLE\"/>\n+        <table-generator name=\"SEQ_RMapping\" pk-column-value=\"SEQ_RMapping\" initial-value=\"100\"/>\n+      </id>\n+    </attributes>\n+  </entity>\n+  <entity class=\"org.apache.syncope.core.persistence.beans.user.UMappingItem\">\n+    <attributes>\n+      <id name=\"id\">\n+        <generated-value generator=\"SEQ_UMappingItem\" strategy=\"TABLE\"/>\n+        <table-generator name=\"SEQ_UMappingItem\" pk-column-value=\"SEQ_UMappingItem\" initial-value=\"1000\"/>\n+      </id>\n+    </attributes>\n+  </entity>\n+  <entity class=\"org.apache.syncope.core.persistence.beans.role.RMappingItem\">\n+    <attributes>\n+      <id name=\"id\">\n+        <generated-value generator=\"SEQ_RMappingItem\" strategy=\"TABLE\"/>\n+        <table-generator name=\"SEQ_RMappingItem\" pk-column-value=\"SEQ_RMappingItem\" initial-value=\"1000\"/>\n       </id>\n     </attributes>\n   </entity>"},{"sha":"dd8e4deb910adbf2bd79a0db9d83a4557fd8022d","filename":"core/src/main/resources/persistenceContextEMFactory.xml","status":"modified","additions":2,"deletions":1,"changes":3,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fresources%2FpersistenceContextEMFactory.xml","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fresources%2FpersistenceContextEMFactory.xml","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fresources%2FpersistenceContextEMFactory.xml?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -37,7 +37,8 @@ under the License.\n     <property name=\"jpaPropertyMap\">\n       <map>\n         <!--<entry key=\"openjpa.Log\" value=\"SQL=TRACE\"/>\n-        <entry key=\"openjpa.ConnectionFactoryProperties\" value=\"PrettyPrint=true, PrettyPrintLineLength=80\"/>-->\n+        <entry key=\"openjpa.ConnectionFactoryProperties\" \n+               value=\"PrintParameters=true, PrettyPrint=true, PrettyPrintLineLength=80\"/>-->\n                 \n         <entry key=\"openjpa.NontransactionalWrite\" value=\"false\"/>\n         <entry key=\"openjpa.AutoDetach\" value=\"close, commit, nontx-read, rollback\"/>"},{"sha":"e8ac8734dec5e4f265f9b4fd07e83dd3a7f70d1a","filename":"core/src/main/resources/userWorkflow.bpmn20.xml","status":"modified","additions":13,"deletions":7,"changes":20,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fresources%2FuserWorkflow.bpmn20.xml","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fresources%2FuserWorkflow.bpmn20.xml","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fresources%2FuserWorkflow.bpmn20.xml?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -35,7 +35,8 @@ under the License.\n     <!-- Create an user -->\n     <sequenceFlow id=\"flow1\" sourceRef=\"theStart\" targetRef=\"create\"/>\n       \n-    <serviceTask id=\"create\" name=\"Create\" activiti:class=\"org.apache.syncope.core.workflow.activiti.Create\"/>\n+    <serviceTask id=\"create\" name=\"Create\" \n+                 activiti:class=\"org.apache.syncope.core.workflow.user.activiti.task.Create\"/>\n \n     <sequenceFlow id=\"flow2\" sourceRef=\"create\" targetRef=\"createGW\"/>\n         \n@@ -81,12 +82,13 @@ under the License.\n       <conditionExpression xsi:type=\"tFormalExpression\">${!enabled}</conditionExpression>\n     </sequenceFlow>\n     \n-    <serviceTask id=\"activate\" name=\"Activate\" activiti:class=\"org.apache.syncope.core.workflow.activiti.AutoActivate\"/>\n+    <serviceTask id=\"activate\" name=\"Activate\" \n+                 activiti:class=\"org.apache.syncope.core.workflow.user.activiti.task.AutoActivate\"/>\n     <sequenceFlow id=\"flow4\" sourceRef=\"activate\" targetRef=\"active\"/>\n \n     <!-- Double opt-in required -->\n     <serviceTask id=\"generateToken\" name=\"Generate token\" \n-                 activiti:class=\"org.apache.syncope.core.workflow.activiti.GenerateToken\"/>\n+                 activiti:class=\"org.apache.syncope.core.workflow.user.activiti.task.GenerateToken\"/>\n         \n     <sequenceFlow id=\"flow5\" sourceRef=\"generateToken\" targetRef=\"created\"/>\n \n@@ -126,12 +128,14 @@ under the License.\n     </sequenceFlow>\n \n     <!-- Update an active user -->\n-    <serviceTask id=\"update\" name=\"Update\" activiti:class=\"org.apache.syncope.core.workflow.activiti.Update\"/>\n+    <serviceTask id=\"update\" name=\"Update\" \n+                 activiti:class=\"org.apache.syncope.core.workflow.user.activiti.task.Update\"/>\n \n     <sequenceFlow id=\"flow9\" sourceRef=\"update\" targetRef=\"active\"/>\n \n     <!-- Suspend an active user -->\n-    <serviceTask id=\"suspend\" name=\"Suspend\" activiti:class=\"org.apache.syncope.core.workflow.activiti.Suspend\"/>\n+    <serviceTask id=\"suspend\" name=\"Suspend\" \n+                 activiti:class=\"org.apache.syncope.core.workflow.user.activiti.task.Suspend\"/>\n \n     <sequenceFlow id=\"flow10\" sourceRef=\"suspend\" targetRef=\"suspended\"/>\n \n@@ -148,7 +152,8 @@ under the License.\n     </sequenceFlow>\n \n     <!-- Reactivate a suspended user -->\n-    <serviceTask id=\"reactivate\" name =\"Reactivate\" activiti:class=\"org.apache.syncope.core.workflow.activiti.Reactivate\"/>\n+    <serviceTask id=\"reactivate\" name =\"Reactivate\" \n+                 activiti:class=\"org.apache.syncope.core.workflow.user.activiti.task.Reactivate\"/>\n \n     <sequenceFlow id=\"flow12\" sourceRef=\"reactivate\" targetRef=\"active\"/>\n         \n@@ -167,7 +172,8 @@ under the License.\n     <sequenceFlow id=\"flow14\" sourceRef=\"rejected\" targetRef=\"delete\"/>\n \n     <!-- Delete an user (created, active or suspended) -->\n-    <serviceTask id=\"delete\" name=\"Delete\" activiti:class=\"org.apache.syncope.core.workflow.activiti.Delete\"/>\n+    <serviceTask id=\"delete\" name=\"Delete\" \n+                 activiti:class=\"org.apache.syncope.core.workflow.user.activiti.task.Delete\"/>\n \n     <sequenceFlow id=\"flow99\" sourceRef=\"delete\" targetRef=\"theEnd\"/>\n "},{"sha":"5be6063a48fc10523de12b3831417a03461d92eb","filename":"core/src/main/resources/views.xml","status":"modified","additions":56,"deletions":7,"changes":63,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fresources%2Fviews.xml","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fresources%2Fviews.xml","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fresources%2Fviews.xml?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -24,12 +24,12 @@ under the License.\n   <entry key=\"user_search\">\n     CREATE VIEW user_search AS\n  \n-    SELECT u.id as user_id, u.* FROM SyncopeUser u\n+    SELECT u.id as subject_id, u.* FROM SyncopeUser u\n   </entry>\n   <entry key=\"user_search_attr\">\n     CREATE VIEW user_search_attr AS\n \n-    SELECT ua.owner_id AS user_id,\n+    SELECT ua.owner_id AS subject_id,\n     ua.schema_name AS schema_name,\n     uav.booleanvalue AS booleanvalue,\n     uav.datevalue AS datevalue,\n@@ -41,7 +41,7 @@ under the License.\n \n     UNION ALL\n \n-    SELECT ua.owner_id AS user_id,\n+    SELECT ua.owner_id AS subject_id,\n     ua.schema_name AS schema_name,\n     uav.booleanvalue AS booleanvalue,\n     uav.datevalue AS datevalue,\n@@ -53,7 +53,7 @@ under the License.\n \n     UNION ALL\n \n-    SELECT u.id AS user_id,\n+    SELECT u.id AS subject_id,\n     USchema.name AS schema_name,\n     NULL AS booleanvalue,\n     NULL AS datevalue,\n@@ -67,20 +67,69 @@ under the License.\n   <entry key=\"user_search_membership\">\n     CREATE VIEW user_search_membership AS\n \n-    SELECT m.syncopeuser_id AS user_id, r.id AS role_id, r.name AS role_name\n+    SELECT m.syncopeuser_id AS subject_id, r.id AS role_id, r.name AS role_name\n     FROM Membership m, SyncopeRole r\n     WHERE m.syncoperole_id = r.id\n   </entry>\n   <entry key=\"user_search_resource\">\n     CREATE VIEW user_search_resource AS\n \n-    SELECT st.user_id AS user_id, st.resource_name AS resource_name\n+    SELECT st.user_id AS subject_id, st.resource_name AS resource_name\n     FROM SyncopeUser_ExternalResource st\n \n     UNION ALL\n \n-    SELECT m.syncopeuser_id AS user_id, st.resource_name AS resource_name\n+    SELECT m.syncopeuser_id AS subject_id, st.resource_name AS resource_name\n     FROM Membership m, SyncopeRole r, SyncopeRole_ExternalResource st\n     WHERE m.syncoperole_id = r.id AND st.role_id = r.id\n   </entry>\n+  <entry key=\"role_search\">\n+    CREATE VIEW role_search AS\n+ \n+    SELECT r.id as subject_id, r.* FROM SyncopeRole r\n+  </entry>\n+  <entry key=\"role_search_attr\">\n+    CREATE VIEW role_search_attr AS\n+\n+    SELECT ra.owner_id AS subject_id,\n+    ra.schema_name AS schema_name,\n+    rav.booleanvalue AS booleanvalue,\n+    rav.datevalue AS datevalue,\n+    rav.doublevalue AS doublevalue,\n+    rav.longvalue AS longvalue,\n+    rav.stringvalue AS stringvalue\n+    FROM RAttrUniqueValue rav, RAttr ra\n+    WHERE rav.attribute_id = ra.id\n+\n+    UNION ALL\n+\n+    SELECT ra.owner_id AS subject_id,\n+    ra.schema_name AS schema_name,\n+    rav.booleanvalue AS booleanvalue,\n+    rav.datevalue AS datevalue,\n+    rav.doublevalue AS doublevalue,\n+    rav.longvalue AS longvalue,\n+    rav.stringvalue AS stringvalue\n+    FROM RAttrValue rav, RAttr ra\n+    WHERE rav.attribute_id = ra.id\n+\n+    UNION ALL\n+\n+    SELECT r.id AS subject_id,\n+    RSchema.name AS schema_name,\n+    NULL AS booleanvalue,\n+    NULL AS datevalue,\n+    NULL AS doublevalue,\n+    NULL AS longvalue,\n+    NULL AS stringvalue\n+    FROM SyncopeRole r CROSS JOIN RSchema\n+    LEFT OUTER JOIN RAttr ra ON (RSchema.name = ra.schema_name AND ra.owner_id = r.id)\n+    WHERE ra.id IS NULL\n+  </entry>\n+  <entry key=\"role_search_resource\">\n+    CREATE VIEW role_search_resource AS\n+\n+    SELECT st.role_id AS subject_id, st.resource_name AS resource_name\n+    FROM SyncopeRole_ExternalResource st\n+  </entry>\n </properties>"},{"sha":"cf8be0b337212f46835160bee6e3fa9d6923ed44","filename":"core/src/main/resources/workflow.properties","status":"modified","additions":3,"deletions":2,"changes":5,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fresources%2Fworkflow.properties","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fresources%2Fworkflow.properties","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fresources%2Fworkflow.properties?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -14,5 +14,6 @@\n # KIND, either express or implied.  See the License for the\n # specific language governing permissions and limitations\n # under the License.\n-wfAdapter=org.apache.syncope.core.workflow.ActivitiUserWorkflowAdapter\n-jobExecutorActivate=true\n\\ No newline at end of file\n+uwfAdapter=org.apache.syncope.core.workflow.user.activiti.ActivitiUserWorkflowAdapter\n+rwfAdapter=org.apache.syncope.core.workflow.role.NoOpRoleWorkflowAdapter\n+jobExecutorActivate=true"},{"sha":"0826f6420d2ede5a7cb0b539099663d3132861cb","filename":"core/src/main/resources/workflowContext.xml","status":"modified","additions":8,"deletions":7,"changes":15,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fresources%2FworkflowContext.xml","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Fmain%2Fresources%2FworkflowContext.xml","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fresources%2FworkflowContext.xml?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -27,10 +27,11 @@ under the License.\n     <constructor-arg value=\"${adminUser}\"/>\n   </bean>\n     \n-  <bean id=\"wfAdapter\" class=\"${wfAdapter}\"/>\n+  <bean id=\"uwfAdapter\" class=\"${uwfAdapter}\"/>\n+  <bean id=\"rwfAdapter\" class=\"${rwfAdapter}\"/>\n \n-  <bean id=\"syncopeActivitiUserManager\" class=\"org.apache.syncope.core.workflow.activiti.SyncopeUserManager\"/>\n-  <bean id=\"syncopeActivitiGroupManager\" class=\"org.apache.syncope.core.workflow.activiti.SyncopeGroupManager\"/>\n+  <bean id=\"syncopeActivitiUserManager\" class=\"org.apache.syncope.core.workflow.user.activiti.SyncopeUserManager\"/>\n+  <bean id=\"syncopeActivitiGroupManager\" class=\"org.apache.syncope.core.workflow.user.activiti.SyncopeGroupManager\"/>\n                 \n   <bean id=\"processEngineConfiguration\" class=\"org.activiti.spring.SpringProcessEngineConfiguration\">\n     <property name=\"dataSource\" ref=\"dataSource\" />\n@@ -46,17 +47,17 @@ under the License.\n         \n     <property name=\"customSessionFactories\">\n       <list>          \n-        <bean class=\"org.apache.syncope.core.workflow.activiti.SyncopeSessionFactory\">\n+        <bean class=\"org.apache.syncope.core.workflow.user.activiti.SyncopeSessionFactory\">\n           <property name=\"syncopeSession\" ref=\"syncopeActivitiUserManager\"/>\n         </bean>\n-        <bean class=\"org.apache.syncope.core.workflow.activiti.SyncopeSessionFactory\">\n+        <bean class=\"org.apache.syncope.core.workflow.user.activiti.SyncopeSessionFactory\">\n           <property name=\"syncopeSession\" ref=\"syncopeActivitiGroupManager\"/>\n         </bean>\n       </list>\n     </property>\n     <property name=\"customPreVariableTypes\">\n       <list>\n-        <bean class=\"org.apache.syncope.core.workflow.activiti.SyncopeEntitiesVariableType\"/>\n+        <bean class=\"org.apache.syncope.core.workflow.user.activiti.SyncopeEntitiesVariableType\"/>\n       </list>    \n     </property>\n   </bean>\n@@ -81,4 +82,4 @@ under the License.\n       </value>\n     </property>\n   </bean>\n-</beans>\n\\ No newline at end of file\n+</beans>"},{"sha":"00f34b0167328bf1b2663759a77872fc31fdca75","filename":"core/src/test/java/org/apache/syncope/core/persistence/dao/AttributableSearchTest.java","status":"renamed","additions":89,"deletions":34,"changes":123,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2FAttributableSearchTest.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2FAttributableSearchTest.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2FAttributableSearchTest.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -18,9 +18,6 @@\n  */\n package org.apache.syncope.core.persistence.dao;\n \n-import org.apache.syncope.core.persistence.dao.EntitlementDAO;\n-import org.apache.syncope.core.persistence.dao.UserDAO;\n-import org.apache.syncope.core.persistence.dao.UserSearchDAO;\n import static org.junit.Assert.*;\n \n import java.util.HashSet;\n@@ -36,38 +33,59 @@\n import org.apache.syncope.client.search.MembershipCond;\n import org.apache.syncope.client.search.NodeCond;\n import org.apache.syncope.client.search.ResourceCond;\n-import org.apache.syncope.client.search.SyncopeUserCond;\n+import org.apache.syncope.client.search.AttributableCond;\n+import org.apache.syncope.core.persistence.beans.role.SyncopeRole;\n import org.apache.syncope.core.persistence.beans.user.SyncopeUser;\n+import org.apache.syncope.core.util.AttributableUtil;\n import org.apache.syncope.core.util.EntitlementUtil;\n+import org.apache.syncope.types.AttributableType;\n \n @RunWith(SpringJUnit4ClassRunner.class)\n @ContextConfiguration(locations = {\"classpath:syncopeContext.xml\", \"classpath:persistenceContext.xml\",\n     \"classpath:schedulingContext.xml\", \"classpath:workflowContext.xml\"})\n @Transactional\n-public class UserSearchTest {\n+public class AttributableSearchTest {\n \n     @Autowired\n     private UserDAO userDAO;\n \n     @Autowired\n-    private UserSearchDAO searchDAO;\n+    private RoleDAO roleDAO;\n+\n+    @Autowired\n+    private AttributableSearchDAO searchDAO;\n \n     @Autowired\n     private EntitlementDAO entitlementDAO;\n \n     @Test\n-    public void matches() {\n+    public void userMatch() {\n         SyncopeUser user = userDAO.find(1L);\n         assertNotNull(user);\n \n         MembershipCond membershipCond = new MembershipCond();\n         membershipCond.setRoleId(5L);\n \n-        assertFalse(searchDAO.matches(user, NodeCond.getLeafCond(membershipCond)));\n+        assertFalse(searchDAO.matches(user, NodeCond.getLeafCond(membershipCond),\n+                AttributableUtil.getInstance(AttributableType.USER)));\n \n         membershipCond.setRoleId(1L);\n \n-        assertTrue(searchDAO.matches(user, NodeCond.getLeafCond(membershipCond)));\n+        assertTrue(searchDAO.matches(user, NodeCond.getLeafCond(membershipCond),\n+                AttributableUtil.getInstance(AttributableType.USER)));\n+    }\n+\n+    @Test\n+    public void roleMatch() {\n+        SyncopeRole role = roleDAO.find(1L);\n+        assertNotNull(role);\n+\n+        AttributeCond attrCond = new AttributeCond();\n+        attrCond.setSchema(\"show\");\n+        attrCond.setType(AttributeCond.Type.ISNOTNULL);\n+\n+        assertTrue(searchDAO.matches(role, NodeCond.getLeafCond(attrCond),\n+                AttributableUtil.getInstance(AttributableType.ROLE)));\n     }\n \n     @Test\n@@ -92,7 +110,8 @@ public void searchWithLikeCondition() {\n \n         assertTrue(cond.checkValidity());\n \n-        List<SyncopeUser> users = searchDAO.search(EntitlementUtil.getRoleIds(entitlementDAO.findAll()), cond);\n+        List<SyncopeUser> users = searchDAO.search(EntitlementUtil.getRoleIds(entitlementDAO.findAll()), cond,\n+                AttributableUtil.getInstance(AttributableType.USER));\n         assertNotNull(users);\n         assertEquals(1, users.size());\n     }\n@@ -106,7 +125,8 @@ public void searchWithNotCondition() {\n         final NodeCond cond = NodeCond.getNotLeafCond(fullnameLeafCond);\n         assertTrue(cond.checkValidity());\n \n-        final List<SyncopeUser> users = searchDAO.search(EntitlementUtil.getRoleIds(entitlementDAO.findAll()), cond);\n+        final List<SyncopeUser> users = searchDAO.search(EntitlementUtil.getRoleIds(entitlementDAO.findAll()), cond,\n+                AttributableUtil.getInstance(AttributableType.USER));\n         assertNotNull(users);\n         assertEquals(2, users.size());\n \n@@ -126,7 +146,8 @@ public void searchByBoolean() {\n         final NodeCond cond = NodeCond.getLeafCond(coolLeafCond);\n         assertTrue(cond.checkValidity());\n \n-        final List<SyncopeUser> users = searchDAO.search(EntitlementUtil.getRoleIds(entitlementDAO.findAll()), cond);\n+        final List<SyncopeUser> users = searchDAO.search(EntitlementUtil.getRoleIds(entitlementDAO.findAll()), cond,\n+                AttributableUtil.getInstance(AttributableType.USER));\n         assertNotNull(users);\n         assertEquals(1, users.size());\n \n@@ -155,11 +176,13 @@ public void searchByPageAndSize() {\n \n         assertTrue(cond.checkValidity());\n \n-        List<SyncopeUser> users = searchDAO.search(EntitlementUtil.getRoleIds(entitlementDAO.findAll()), cond, 1, 2);\n+        List<SyncopeUser> users = searchDAO.search(EntitlementUtil.getRoleIds(entitlementDAO.findAll()), cond, 1, 2,\n+                AttributableUtil.getInstance(AttributableType.USER));\n         assertNotNull(users);\n         assertEquals(1, users.size());\n \n-        users = searchDAO.search(EntitlementUtil.getRoleIds(entitlementDAO.findAll()), cond, 2, 2);\n+        users = searchDAO.search(EntitlementUtil.getRoleIds(entitlementDAO.findAll()), cond, 2, 2,\n+                AttributableUtil.getInstance(AttributableType.USER));\n         assertNotNull(users);\n         assertTrue(users.isEmpty());\n     }\n@@ -170,15 +193,17 @@ public void searchByMembership() {\n         membershipCond.setRoleId(1L);\n \n         List<SyncopeUser> users = searchDAO.search(\n-                EntitlementUtil.getRoleIds(entitlementDAO.findAll()), NodeCond.getLeafCond(membershipCond));\n+                EntitlementUtil.getRoleIds(entitlementDAO.findAll()), NodeCond.getLeafCond(membershipCond),\n+                AttributableUtil.getInstance(AttributableType.USER));\n         assertNotNull(users);\n         assertEquals(2, users.size());\n \n         membershipCond = new MembershipCond();\n         membershipCond.setRoleId(5L);\n \n         users = searchDAO.search(\n-                EntitlementUtil.getRoleIds(entitlementDAO.findAll()), NodeCond.getNotLeafCond(membershipCond));\n+                EntitlementUtil.getRoleIds(entitlementDAO.findAll()), NodeCond.getNotLeafCond(membershipCond),\n+                AttributableUtil.getInstance(AttributableType.USER));\n         assertNotNull(users);\n         assertEquals(5, users.size());\n     }\n@@ -189,15 +214,17 @@ public void searchByIsNull() {\n         coolLeafCond.setSchema(\"cool\");\n \n         List<SyncopeUser> users = searchDAO.search(\n-                EntitlementUtil.getRoleIds(entitlementDAO.findAll()), NodeCond.getLeafCond(coolLeafCond));\n+                EntitlementUtil.getRoleIds(entitlementDAO.findAll()), NodeCond.getLeafCond(coolLeafCond),\n+                AttributableUtil.getInstance(AttributableType.USER));\n         assertNotNull(users);\n         assertEquals(4, users.size());\n \n         coolLeafCond = new AttributeCond(AttributeCond.Type.ISNOTNULL);\n         coolLeafCond.setSchema(\"cool\");\n \n         users = searchDAO.search(\n-                EntitlementUtil.getRoleIds(entitlementDAO.findAll()), NodeCond.getLeafCond(coolLeafCond));\n+                EntitlementUtil.getRoleIds(entitlementDAO.findAll()), NodeCond.getLeafCond(coolLeafCond),\n+                AttributableUtil.getInstance(AttributableType.USER));\n         assertNotNull(users);\n         assertEquals(1, users.size());\n     }\n@@ -215,37 +242,62 @@ public void searchByResource() {\n         assertTrue(searchCondition.checkValidity());\n \n         List<SyncopeUser> users = searchDAO.search(\n-                EntitlementUtil.getRoleIds(entitlementDAO.findAll()), searchCondition);\n+                EntitlementUtil.getRoleIds(entitlementDAO.findAll()), searchCondition,\n+                AttributableUtil.getInstance(AttributableType.USER));\n \n         assertNotNull(users);\n         assertEquals(1, users.size());\n     }\n \n     @Test\n     public void searchByUsernameAndId() {\n-        final SyncopeUserCond usernameLeafCond = new SyncopeUserCond(SyncopeUserCond.Type.EQ);\n+        final AttributableCond usernameLeafCond = new AttributableCond(AttributableCond.Type.EQ);\n         usernameLeafCond.setSchema(\"username\");\n         usernameLeafCond.setExpression(\"user1\");\n \n-        final SyncopeUserCond idRightCond = new SyncopeUserCond(SyncopeUserCond.Type.LT);\n+        final AttributableCond idRightCond = new AttributableCond(AttributableCond.Type.LT);\n         idRightCond.setSchema(\"id\");\n         idRightCond.setExpression(\"2\");\n \n         final NodeCond searchCondition = NodeCond.getOrCond(NodeCond.getLeafCond(usernameLeafCond),\n                 NodeCond.getLeafCond(idRightCond));\n \n         final List<SyncopeUser> matchingUsers = searchDAO.search(EntitlementUtil.getRoleIds(entitlementDAO.findAll()),\n-                searchCondition);\n+                searchCondition, AttributableUtil.getInstance(AttributableType.USER));\n \n         assertNotNull(matchingUsers);\n         assertEquals(1, matchingUsers.size());\n         assertEquals(\"user1\", matchingUsers.iterator().next().getUsername());\n         assertEquals(1L, matchingUsers.iterator().next().getId().longValue());\n     }\n \n+    @Test\n+    public void searchByRolenameAndId() {\n+        final AttributableCond rolenameLeafCond = new AttributableCond(AttributableCond.Type.EQ);\n+        rolenameLeafCond.setSchema(\"name\");\n+        rolenameLeafCond.setExpression(\"root\");\n+\n+        final AttributableCond idRightCond = new AttributableCond(AttributableCond.Type.LT);\n+        idRightCond.setSchema(\"id\");\n+        idRightCond.setExpression(\"2\");\n+\n+        final NodeCond searchCondition = NodeCond.getAndCond(NodeCond.getLeafCond(rolenameLeafCond),\n+                NodeCond.getLeafCond(idRightCond));\n+\n+        assertTrue(searchCondition.checkValidity());\n+\n+        final List<SyncopeRole> matchingRoles = searchDAO.search(EntitlementUtil.getRoleIds(entitlementDAO.findAll()),\n+                searchCondition, AttributableUtil.getInstance(AttributableType.ROLE));\n+\n+        assertNotNull(matchingRoles);\n+        assertEquals(1, matchingRoles.size());\n+        assertEquals(\"root\", matchingRoles.iterator().next().getName());\n+        assertEquals(1L, matchingRoles.iterator().next().getId().longValue());\n+    }\n+\n     @Test\n     public void searchByUsernameAndFullname() {\n-        final SyncopeUserCond usernameLeafCond = new SyncopeUserCond(SyncopeUserCond.Type.EQ);\n+        final AttributableCond usernameLeafCond = new AttributableCond(AttributableCond.Type.EQ);\n         usernameLeafCond.setSchema(\"username\");\n         usernameLeafCond.setExpression(\"user1\");\n \n@@ -257,36 +309,39 @@ public void searchByUsernameAndFullname() {\n                 NodeCond.getLeafCond(idRightCond));\n \n         final List<SyncopeUser> matchingUsers =\n-                searchDAO.search(EntitlementUtil.getRoleIds(entitlementDAO.findAll()), searchCondition);\n+                searchDAO.search(EntitlementUtil.getRoleIds(entitlementDAO.findAll()), searchCondition,\n+                AttributableUtil.getInstance(AttributableType.USER));\n \n         assertNotNull(matchingUsers);\n         assertEquals(2, matchingUsers.size());\n     }\n \n     @Test\n     public void searchById() {\n-        SyncopeUserCond idLeafCond = new SyncopeUserCond(SyncopeUserCond.Type.LT);\n+        AttributableCond idLeafCond = new AttributableCond(AttributableCond.Type.LT);\n         idLeafCond.setSchema(\"id\");\n         idLeafCond.setExpression(\"2\");\n \n         NodeCond searchCondition = NodeCond.getLeafCond(idLeafCond);\n         assertTrue(searchCondition.checkValidity());\n \n         List<SyncopeUser> matchingUsers =\n-                searchDAO.search(EntitlementUtil.getRoleIds(entitlementDAO.findAll()), searchCondition);\n+                searchDAO.search(EntitlementUtil.getRoleIds(entitlementDAO.findAll()), searchCondition,\n+                AttributableUtil.getInstance(AttributableType.USER));\n \n         assertNotNull(matchingUsers);\n         assertEquals(1, matchingUsers.size());\n         assertEquals(1L, matchingUsers.iterator().next().getId().longValue());\n \n-        idLeafCond = new SyncopeUserCond(SyncopeUserCond.Type.LT);\n+        idLeafCond = new AttributableCond(AttributableCond.Type.LT);\n         idLeafCond.setSchema(\"id\");\n         idLeafCond.setExpression(\"4\");\n \n         searchCondition = NodeCond.getNotLeafCond(idLeafCond);\n         assertTrue(searchCondition.checkValidity());\n \n-        matchingUsers = searchDAO.search(EntitlementUtil.getRoleIds(entitlementDAO.findAll()), searchCondition);\n+        matchingUsers = searchDAO.search(EntitlementUtil.getRoleIds(entitlementDAO.findAll()), searchCondition,\n+                AttributableUtil.getInstance(AttributableType.USER));\n \n         assertNotNull(matchingUsers);\n         assertEquals(2, matchingUsers.size());\n@@ -301,43 +356,43 @@ public void issue202() {\n         final ResourceCond ws1 = new ResourceCond();\n         ws1.setResourceName(\"ws-target-resource-list-mappings-1\");\n \n-        final NodeCond searchCondition = \n+        final NodeCond searchCondition =\n                 NodeCond.getAndCond(NodeCond.getNotLeafCond(ws2), NodeCond.getNotLeafCond(ws1));\n         assertTrue(searchCondition.checkValidity());\n \n         final List<SyncopeUser> users = searchDAO.search(EntitlementUtil.getRoleIds(entitlementDAO.findAll()),\n-                searchCondition);\n+                searchCondition, AttributableUtil.getInstance(AttributableType.USER));\n         assertNotNull(users);\n         assertEquals(2, users.size());\n         assertEquals(4L, users.iterator().next().getId().longValue());\n     }\n \n     @Test\n     public void issue242() {\n-        final SyncopeUserCond cond = new SyncopeUserCond(AttributeCond.Type.LIKE);\n+        final AttributableCond cond = new AttributableCond(AttributeCond.Type.LIKE);\n         cond.setSchema(\"id\");\n         cond.setExpression(\"test%\");\n \n         final NodeCond searchCondition = NodeCond.getLeafCond(cond);\n         assertTrue(searchCondition.checkValidity());\n \n         final List<SyncopeUser> users = searchDAO.search(EntitlementUtil.getRoleIds(entitlementDAO.findAll()),\n-                searchCondition);\n+                searchCondition, AttributableUtil.getInstance(AttributableType.USER));\n         assertNotNull(users);\n         assertTrue(users.isEmpty());\n     }\n \n     @Test\n     public void issueSYNCOPE46() {\n-        final SyncopeUserCond cond = new SyncopeUserCond(AttributeCond.Type.LIKE);\n+        final AttributableCond cond = new AttributableCond(AttributeCond.Type.LIKE);\n         cond.setSchema(\"username\");\n         cond.setExpression(\"%user%\");\n \n         final NodeCond searchCondition = NodeCond.getLeafCond(cond);\n         assertTrue(searchCondition.checkValidity());\n \n         final List<SyncopeUser> users = searchDAO.search(EntitlementUtil.getRoleIds(entitlementDAO.findAll()),\n-                searchCondition);\n+                searchCondition, AttributableUtil.getInstance(AttributableType.USER));\n         assertNotNull(users);\n         assertEquals(5, users.size());\n     }","previous_filename":"core/src/test/java/org/apache/syncope/core/persistence/dao/UserSearchTest.java"},{"sha":"57e9937dc5724fd96f261fa5011545a870ee303e","filename":"core/src/test/java/org/apache/syncope/core/persistence/dao/DerSchemaTest.java","status":"modified","additions":0,"deletions":2,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2FDerSchemaTest.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2FDerSchemaTest.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2FDerSchemaTest.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -18,8 +18,6 @@\n  */\n package org.apache.syncope.core.persistence.dao;\n \n-import org.apache.syncope.core.persistence.dao.SchemaDAO;\n-import org.apache.syncope.core.persistence.dao.DerSchemaDAO;\n import static org.junit.Assert.*;\n \n import java.util.List;"},{"sha":"a88d67cc1e97ba246faa18729e6dd3675fc59939","filename":"core/src/test/java/org/apache/syncope/core/persistence/dao/PolicyTest.java","status":"modified","additions":0,"deletions":1,"changes":1,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2FPolicyTest.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2FPolicyTest.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2FPolicyTest.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -18,7 +18,6 @@\n  */\n package org.apache.syncope.core.persistence.dao;\n \n-import org.apache.syncope.core.persistence.dao.PolicyDAO;\n import static org.junit.Assert.*;\n \n import java.util.List;"},{"sha":"9db3aeda9b5e5187ac0c0a90b1b1066e8a6e1dd1","filename":"core/src/test/java/org/apache/syncope/core/persistence/dao/ResourceTest.java","status":"modified","additions":74,"deletions":84,"changes":158,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2FResourceTest.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2FResourceTest.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2FResourceTest.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -22,13 +22,13 @@\n \n import java.util.ArrayList;\n import java.util.List;\n-import java.util.Set;\n import org.apache.syncope.core.AbstractTest;\n import org.apache.syncope.core.persistence.beans.ConnInstance;\n import org.apache.syncope.core.persistence.beans.ExternalResource;\n-import org.apache.syncope.core.persistence.beans.SchemaMapping;\n+import org.apache.syncope.core.persistence.beans.AbstractMappingItem;\n+import org.apache.syncope.core.persistence.beans.user.UMapping;\n+import org.apache.syncope.core.persistence.beans.user.UMappingItem;\n import org.apache.syncope.core.persistence.validation.entity.InvalidEntityException;\n-import org.apache.syncope.core.util.SchemaMappingUtil;\n import org.apache.syncope.types.AttributableType;\n import org.apache.syncope.types.IntMappingType;\n import org.connid.bundles.soap.WebServiceConnector;\n@@ -45,30 +45,30 @@ public class ResourceTest extends AbstractTest {\n     @Test\n     public void findById() {\n         ExternalResource resource = resourceDAO.find(\"ws-target-resource-1\");\n-\n         assertNotNull(\"findById did not work\", resource);\n \n         ConnInstance connector = resource.getConnector();\n-\n         assertNotNull(\"connector not found\", connector);\n-\n         assertEquals(\"invalid connector name\", WebServiceConnector.class.getName(), connector.getConnectorName());\n-\n         assertEquals(\"invalid bundle name\", \"org.connid.bundles.soap\", connector.getBundleName());\n-\n         assertEquals(\"invalid bundle version\", connidSoapVersion, connector.getVersion());\n \n-        Set<SchemaMapping> mappings = resource.getMappings();\n-        assertNotNull(\"mappings not found\", mappings);\n-        assertFalse(\"no mapping specified\", mappings.isEmpty());\n+        assertFalse(\"no mapping specified\", resource.getUmapping().getItems().isEmpty());\n \n         List<Long> mappingIds = new ArrayList<Long>();\n-        for (SchemaMapping mapping : mappings) {\n-            mappingIds.add(mapping.getId());\n+        for (AbstractMappingItem item : resource.getUmapping().getItems()) {\n+            mappingIds.add(item.getId());\n         }\n         assertTrue(mappingIds.contains(100L));\n     }\n \n+    @Test\n+    public void findAll() {\n+        List<ExternalResource> resources = resourceDAO.findAll();\n+        assertNotNull(resources);\n+        assertEquals(16, resources.size());\n+    }\n+\n     @Test\n     public void findAllByPriority() {\n         List<ExternalResource> resources = resourceDAO.findAllByPriority();\n@@ -78,8 +78,9 @@ public void findAllByPriority() {\n \n     @Test\n     public void getAccountId() {\n-        SchemaMapping mapping = resourceDAO.getMappingForAccountId(\"ws-target-resource-2\");\n-        assertEquals(\"fullname\", SchemaMappingUtil.getIntAttrName(mapping));\n+        ExternalResource resource = resourceDAO.find(\"ws-target-resource-2\");\n+        assertNotNull(resource);\n+        assertEquals(\"fullname\", resource.getUmapping().getAccountIdItem().getIntAttrName());\n     }\n \n     @Test\n@@ -89,154 +90,143 @@ public void save() {\n         resource.setPropagationPriority(2);\n         resource.setPropagationPrimary(true);\n \n-        SchemaMapping accountId = new SchemaMapping();\n-        accountId.setResource(resource);\n-        accountId.setAccountid(true);\n+        UMapping mapping = new UMapping();\n+        resource.setUmapping(mapping);\n+\n+        UMappingItem accountId = new UMappingItem();\n         accountId.setExtAttrName(\"username\");\n         accountId.setIntAttrName(\"fullname\");\n-        accountId.setIntMappingType(IntMappingType.SyncopeUserId);\n-\n-        resource.addMapping(accountId);\n+        accountId.setIntMappingType(IntMappingType.UserId);\n+        mapping.setAccountIdItem(accountId);\n \n         ConnInstance connector = resourceDAO.find(\"ws-target-resource-1\").getConnector();\n-\n         resource.setConnector(connector);\n \n         // save the resource\n         ExternalResource actual = resourceDAO.save(resource);\n \n         assertNotNull(actual);\n         assertNotNull(actual.getConnector());\n+        assertNotNull(actual.getUmapping());\n+        assertFalse(actual.getUmapping().getItems().isEmpty());\n         assertEquals(Integer.valueOf(2), actual.getPropagationPriority());\n         assertTrue(actual.isPropagationPrimary());\n     }\n \n     @Test(expected = InvalidEntityException.class)\n     public void saveInvalidMappingIntAttr() {\n-\n         ExternalResource resource = new ExternalResource();\n         resource.setName(\"ws-target-resource-basic-save-invalid\");\n \n         ConnInstance connector = resourceDAO.find(\"ws-target-resource-1\").getConnector();\n-\n         resource.setConnector(connector);\n \n-        SchemaMapping accountId = new SchemaMapping();\n-        accountId.setResource(resource);\n+        UMapping mapping = new UMapping();\n+        resource.setUmapping(mapping);\n+\n+        UMappingItem accountId = new UMappingItem();\n         accountId.setAccountid(true);\n         accountId.setIntMappingType(IntMappingType.UserSchema);\n-\n-        resource.addMapping(accountId);\n+        mapping.addItem(accountId);\n \n         // save the resource\n         ExternalResource actual = resourceDAO.save(resource);\n-\n         assertNotNull(actual);\n     }\n \n-    @Test(expected = InvalidEntityException.class)\n+    @Test(expected = IllegalArgumentException.class)\n     public void saveInvalidAccountIdMapping() {\n-\n         ExternalResource resource = new ExternalResource();\n         resource.setName(\"ws-target-resource-basic-save-invalid\");\n \n         ConnInstance connector = resourceDAO.find(\"ws-target-resource-1\").getConnector();\n-\n         resource.setConnector(connector);\n \n-        SchemaMapping accountId = new SchemaMapping();\n-        accountId.setResource(resource);\n+        UMapping mapping = new UMapping();\n+        resource.setUmapping(mapping);\n+\n+        UMappingItem accountId = new UMappingItem();\n         accountId.setAccountid(true);\n         accountId.setIntMappingType(IntMappingType.UserVirtualSchema);\n-\n-        resource.addMapping(accountId);\n+        mapping.setAccountIdItem(accountId);\n \n         // save the resource\n         ExternalResource actual = resourceDAO.save(resource);\n-\n         assertNotNull(actual);\n     }\n \n     @Test(expected = InvalidEntityException.class)\n     public void saveInvalidMappingExtAttr() {\n-\n         ExternalResource resource = new ExternalResource();\n         resource.setName(\"ws-target-resource-basic-save-invalid\");\n \n         ConnInstance connector = resourceDAO.find(\"ws-target-resource-1\").getConnector();\n-\n         resource.setConnector(connector);\n \n-        SchemaMapping mapping = new SchemaMapping();\n-        mapping.setResource(resource);\n-        mapping.setAccountid(true);\n-        mapping.setIntAttrName(\"fullname\");\n-        mapping.setIntMappingType(IntMappingType.UserSchema);\n-\n-        resource.addMapping(mapping);\n+        UMapping mapping = new UMapping();\n+        resource.setUmapping(mapping);\n \n-        mapping = new SchemaMapping();\n-        mapping.setResource(resource);\n-        mapping.setIntAttrName(\"userId\");\n-        mapping.setIntMappingType(IntMappingType.UserSchema);\n+        UMappingItem item = new UMappingItem();\n+        item.setAccountid(true);\n+        item.setIntAttrName(\"fullname\");\n+        item.setIntMappingType(IntMappingType.UserSchema);\n+        mapping.addItem(item);\n \n-        resource.addMapping(mapping);\n+        item = new UMappingItem();\n+        item.setIntAttrName(\"userId\");\n+        item.setIntMappingType(IntMappingType.UserSchema);\n+        mapping.addItem(item);\n \n-        resourceDAO.save(resource);\n+        ExternalResource actual = resourceDAO.save(resource);\n+        assertNotNull(actual);\n     }\n \n     @Test\n     public void saveWithRoleMappingType() {\n-\n         ExternalResource resource = new ExternalResource();\n         resource.setName(\"ws-target-resource-basic-save-invalid\");\n \n         ConnInstance connector = resourceDAO.find(\"ws-target-resource-1\").getConnector();\n-\n         resource.setConnector(connector);\n \n-        SchemaMapping mapping = new SchemaMapping();\n-        mapping.setResource(resource);\n-        mapping.setAccountid(true);\n-        mapping.setIntAttrName(\"fullname\");\n-        mapping.setIntMappingType(IntMappingType.UserSchema);\n-\n-        resource.addMapping(mapping);\n+        UMapping mapping = new UMapping();\n+        resource.setUmapping(mapping);\n \n-        mapping = new SchemaMapping();\n-        mapping.setResource(resource);\n-        mapping.setIntAttrName(\"icon\");\n-        mapping.setExtAttrName(\"icon\");\n-        mapping.setIntMappingType(IntMappingType.RoleSchema);\n+        UMappingItem item = new UMappingItem();\n+        item.setIntAttrName(\"fullname\");\n+        item.setIntMappingType(IntMappingType.UserSchema);\n+        mapping.setAccountIdItem(item);\n \n-        resource.addMapping(mapping);\n+        item = new UMappingItem();\n+        item.setIntAttrName(\"icon\");\n+        item.setExtAttrName(\"icon\");\n+        item.setIntMappingType(IntMappingType.RoleSchema);\n+        mapping.addItem(item);\n \n-        mapping = new SchemaMapping();\n-        mapping.setResource(resource);\n-        mapping.setIntAttrName(\"mderiveddata\");\n-        mapping.setExtAttrName(\"mderiveddata\");\n-        mapping.setIntMappingType(IntMappingType.MembershipDerivedSchema);\n-\n-        resource.addMapping(mapping);\n+        item = new UMappingItem();\n+        item.setIntAttrName(\"mderiveddata\");\n+        item.setExtAttrName(\"mderiveddata\");\n+        item.setIntMappingType(IntMappingType.MembershipDerivedSchema);\n+        mapping.addItem(item);\n \n         // save the resource\n         ExternalResource actual = resourceDAO.save(resource);\n-\n         assertNotNull(actual);\n \n-        assertEquals(3, actual.getMappings().size());\n+        int items = 0;\n+        for (AbstractMappingItem mapItem : actual.getUmapping().getItems()) {\n+            items++;\n \n-        for (SchemaMapping schemaMapping : actual.getMappings()) {\n-\n-            if (\"icon\".equals(SchemaMappingUtil.getIntAttrName(schemaMapping))) {\n-                assertTrue(IntMappingType.contains(AttributableType.ROLE, schemaMapping.getIntMappingType().toString()));\n+            if (\"icon\".equals(mapItem.getIntAttrName())) {\n+                assertTrue(IntMappingType.contains(AttributableType.ROLE,\n+                        mapItem.getIntMappingType().toString()));\n             }\n-\n-            if (\"mderiveddata\".equals(SchemaMappingUtil.getIntAttrName(schemaMapping))) {\n-                assertTrue(IntMappingType.contains(AttributableType.MEMBERSHIP, schemaMapping.getIntMappingType()\n-                        .toString()));\n+            if (\"mderiveddata\".equals(mapItem.getIntAttrName())) {\n+                assertTrue(IntMappingType.contains(AttributableType.MEMBERSHIP,\n+                        mapItem.getIntMappingType().toString()));\n             }\n         }\n+        assertEquals(3, items);\n     }\n \n     @Test"},{"sha":"dc0ee64902df11c3739f8e5fefab73260f37fd60","filename":"core/src/test/java/org/apache/syncope/core/persistence/dao/TaskTest.java","status":"modified","additions":5,"deletions":13,"changes":18,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2FTaskTest.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2FTaskTest.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2FTaskTest.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -32,8 +32,9 @@\n import org.apache.syncope.core.persistence.beans.user.SyncopeUser;\n import org.apache.syncope.core.persistence.validation.entity.InvalidEntityException;\n import org.apache.syncope.core.quartz.TestSyncActions;\n+import org.apache.syncope.types.AttributableType;\n import org.apache.syncope.types.PropagationMode;\n-import org.apache.syncope.types.PropagationOperation;\n+import org.apache.syncope.types.ResourceOperation;\n import org.identityconnectors.framework.common.objects.Attribute;\n import org.identityconnectors.framework.common.objects.AttributeBuilder;\n import org.junit.Test;\n@@ -68,16 +69,7 @@ public void findAll() {\n         assertEquals(1, sclist.size());\n \n         List<SyncTask> sylist = taskDAO.findAll(SyncTask.class);\n-        assertEquals(4, sylist.size());\n-\n-        ExternalResource resource = resourceDAO.find(\"ws-target-resource-2\");\n-        assertNotNull(resource);\n-\n-        SyncopeUser user = userDAO.find(1L);\n-        assertNotNull(user);\n-\n-        plist = taskDAO.findAll(resource, user);\n-        assertEquals(3, plist.size());\n+        assertEquals(5, sylist.size());\n     }\n \n     @Test\n@@ -90,9 +82,9 @@ public void savePropagationTask() {\n \n         PropagationTask task = new PropagationTask();\n         task.setResource(resource);\n-        task.setSyncopeUser(user);\n+        task.setSubjectType(AttributableType.USER);\n         task.setPropagationMode(PropagationMode.TWO_PHASES);\n-        task.setPropagationOperation(PropagationOperation.CREATE);\n+        task.setPropagationOperation(ResourceOperation.CREATE);\n         task.setAccountId(\"one@two.com\");\n \n         Set<Attribute> attributes = new HashSet<Attribute>();"},{"sha":"bb665df9d354bb6c441f8c16dccb3dd2de66bcff","filename":"core/src/test/java/org/apache/syncope/core/persistence/relationships/AttributableSearchTest.java","status":"renamed","additions":9,"deletions":10,"changes":19,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Frelationships%2FAttributableSearchTest.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Frelationships%2FAttributableSearchTest.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Frelationships%2FAttributableSearchTest.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -18,7 +18,6 @@\n  */\n package org.apache.syncope.core.persistence.relationships;\n \n-import org.apache.syncope.core.persistence.dao.*;\n import static org.junit.Assert.*;\n \n import java.util.HashSet;\n@@ -34,35 +33,34 @@\n import org.apache.syncope.client.search.NodeCond;\n import org.apache.syncope.core.persistence.beans.role.SyncopeRole;\n import org.apache.syncope.core.persistence.beans.user.SyncopeUser;\n+import org.apache.syncope.core.persistence.dao.AttributableSearchDAO;\n+import org.apache.syncope.core.persistence.dao.EntitlementDAO;\n+import org.apache.syncope.core.persistence.dao.RoleDAO;\n+import org.apache.syncope.core.util.AttributableUtil;\n import org.apache.syncope.core.util.EntitlementUtil;\n+import org.apache.syncope.types.AttributableType;\n \n @RunWith(SpringJUnit4ClassRunner.class)\n @ContextConfiguration(locations = {\"classpath:syncopeContext.xml\", \"classpath:persistenceContext.xml\",\n     \"classpath:schedulingContext.xml\", \"classpath:workflowContext.xml\"})\n @Transactional\n-public class UserSearchTest {\n-\n-    @Autowired\n-    private UserDAO userDAO;\n+public class AttributableSearchTest {\n \n     @Autowired\n     private RoleDAO roleDAO;\n \n     @Autowired\n-    private UserSearchDAO searchDAO;\n+    private AttributableSearchDAO searchDAO;\n \n     @Autowired\n     private EntitlementDAO entitlementDAO;\n \n     @Test\n     public void issueSYNCOPE95() {\n-\n         Set<SyncopeRole> roles = new HashSet<SyncopeRole>(roleDAO.findAll());\n-\n         for (SyncopeRole role : roles) {\n             roleDAO.delete(role.getId());\n         }\n-\n         roleDAO.flush();\n \n         final AttributeCond coolLeafCond = new AttributeCond(AttributeCond.Type.EQ);\n@@ -72,7 +70,8 @@ public void issueSYNCOPE95() {\n         final NodeCond cond = NodeCond.getLeafCond(coolLeafCond);\n         assertTrue(cond.checkValidity());\n \n-        final List<SyncopeUser> users = searchDAO.search(EntitlementUtil.getRoleIds(entitlementDAO.findAll()), cond);\n+        final List<SyncopeUser> users = searchDAO.search(EntitlementUtil.getRoleIds(entitlementDAO.findAll()), cond,\n+                AttributableUtil.getInstance(AttributableType.USER));\n         assertNotNull(users);\n         assertEquals(1, users.size());\n ","previous_filename":"core/src/test/java/org/apache/syncope/core/persistence/relationships/UserSearchTest.java"},{"sha":"4264f602985fe60380cd0bffd1d7e8173ffffd42","filename":"core/src/test/java/org/apache/syncope/core/persistence/relationships/ResourceTest.java","status":"modified","additions":104,"deletions":64,"changes":168,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Frelationships%2FResourceTest.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Frelationships%2FResourceTest.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Frelationships%2FResourceTest.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -18,20 +18,22 @@\n  */\n package org.apache.syncope.core.persistence.relationships;\n \n+import java.io.IOException;\n+import java.io.StringWriter;\n+import java.util.Arrays;\n import static org.junit.Assert.*;\n \n-import java.util.ArrayList;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Set;\n+import org.apache.syncope.client.to.MappingItemTO;\n+import org.apache.syncope.client.to.MappingTO;\n import org.junit.Test;\n import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.transaction.annotation.Transactional;\n import org.apache.syncope.client.to.ResourceTO;\n-import org.apache.syncope.client.to.SchemaMappingTO;\n import org.apache.syncope.core.persistence.beans.ConnInstance;\n import org.apache.syncope.core.persistence.beans.ExternalResource;\n-import org.apache.syncope.core.persistence.beans.SchemaMapping;\n+import org.apache.syncope.core.persistence.beans.AbstractMappingItem;\n import org.apache.syncope.core.persistence.beans.user.SyncopeUser;\n import org.apache.syncope.core.persistence.beans.user.USchema;\n import org.apache.syncope.core.persistence.dao.ConnInstanceDAO;\n@@ -42,11 +44,14 @@\n import org.apache.syncope.core.AbstractTest;\n import org.apache.syncope.core.persistence.beans.PasswordPolicy;\n import org.apache.syncope.core.persistence.beans.PropagationTask;\n+import org.apache.syncope.core.persistence.beans.user.UMapping;\n+import org.apache.syncope.core.persistence.beans.user.UMappingItem;\n import org.apache.syncope.core.persistence.dao.PolicyDAO;\n import org.apache.syncope.core.persistence.dao.TaskDAO;\n-import org.apache.syncope.core.util.SchemaMappingUtil;\n import org.apache.syncope.types.PropagationMode;\n import org.apache.syncope.types.IntMappingType;\n+import org.codehaus.jackson.map.ObjectMapper;\n+import org.springframework.transaction.annotation.Transactional;\n \n @Transactional\n public class ResourceTest extends AbstractTest {\n@@ -72,6 +77,37 @@ public class ResourceTest extends AbstractTest {\n     @Autowired\n     private PolicyDAO policyDAO;\n \n+    @Test\n+    public void databinding() throws IOException {\n+        ExternalResource resource = resourceDAO.find(\"ws-target-resource-2\");\n+        assertNotNull(resource);\n+\n+        ResourceTO resourceTO = resourceDataBinder.getResourceTO(resource);\n+        assertNotNull(resourceTO);\n+\n+        ExternalResource fromto = resourceDataBinder.update(resource, resourceTO);\n+        assertNotNull(fromto);\n+        assertEquals(resource, fromto);\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        StringWriter writer = new StringWriter();\n+        mapper.writeValue(writer, resourceTO);\n+\n+        assertEquals(resourceTO, mapper.readValue(writer.toString(), ResourceTO.class));\n+\n+        List<ResourceTO> resourceTOs = resourceDataBinder.getResourceTOs(resourceDAO.findAll());\n+        assertNotNull(resourceTOs);\n+        assertFalse(resourceTOs.isEmpty());\n+\n+        writer = new StringWriter();\n+        mapper.writeValue(writer, resourceTOs);\n+\n+        ResourceTO[] actual = mapper.readValue(writer.toString(), ResourceTO[].class);\n+        assertEquals(resourceTOs, Arrays.asList(actual));\n+    }\n+\n+    @Test\n     public void createWithPasswordPolicy() {\n         final String resourceName = \"resourceWithPasswordPolicy\";\n \n@@ -80,6 +116,10 @@ public void createWithPasswordPolicy() {\n         resource.setName(resourceName);\n         resource.setPasswordPolicy(policy);\n \n+        ConnInstance connector = connInstanceDAO.find(100L);\n+        assertNotNull(\"connector not found\", connector);\n+        resource.setConnector(connector);\n+\n         ExternalResource actual = resourceDAO.save(resource);\n         assertNotNull(actual);\n \n@@ -100,33 +140,39 @@ public void createWithPasswordPolicy() {\n     public void issue42() {\n         USchema userId = schemaDAO.find(\"userId\", USchema.class);\n \n-        Set<SchemaMapping> beforeUserIdMappings = new HashSet<SchemaMapping>();\n-        for (SchemaMapping mapping : resourceDAO.findAllMappings()) {\n-            if (userId.getName().equals(SchemaMappingUtil.getIntAttrName(mapping, IntMappingType.UserSchema))) {\n-                beforeUserIdMappings.add(mapping);\n+        Set<AbstractMappingItem> beforeUserIdMappings = new HashSet<AbstractMappingItem>();\n+        for (ExternalResource res : resourceDAO.findAll()) {\n+            if (res.getUmapping() != null) {\n+                for (AbstractMappingItem mapItem : res.getUmapping().getItems()) {\n+                    if (userId.getName().equals(mapItem.getIntAttrName())) {\n+                        beforeUserIdMappings.add(mapItem);\n+                    }\n+                }\n             }\n         }\n \n-        SchemaMappingTO schemaMappingTO = new SchemaMappingTO();\n-        schemaMappingTO.setIntAttrName(\"userId\");\n-        schemaMappingTO.setIntMappingType(IntMappingType.UserSchema);\n-        schemaMappingTO.setExtAttrName(\"campo1\");\n-        schemaMappingTO.setAccountid(true);\n-        schemaMappingTO.setPassword(false);\n-        schemaMappingTO.setMandatoryCondition(\"false\");\n-\n-        List<SchemaMappingTO> schemaMappingTOs = new ArrayList<SchemaMappingTO>();\n-        schemaMappingTOs.add(schemaMappingTO);\n-\n         ResourceTO resourceTO = new ResourceTO();\n         resourceTO.setName(\"resource-issue42\");\n         resourceTO.setConnectorId(100L);\n-        resourceTO.setMappings(schemaMappingTOs);\n         resourceTO.setPropagationMode(PropagationMode.ONE_PHASE);\n         resourceTO.setEnforceMandatoryCondition(true);\n \n+        MappingTO mapping = new MappingTO();\n+        resourceTO.setUmapping(mapping);\n+\n+        MappingItemTO item = new MappingItemTO();\n+        item.setIntAttrName(\"userId\");\n+        item.setIntMappingType(IntMappingType.UserSchema);\n+        item.setExtAttrName(\"campo1\");\n+        item.setAccountid(true);\n+        item.setMandatoryCondition(\"false\");\n+        mapping.setAccountIdItem(item);\n+\n         ExternalResource resource = resourceDataBinder.create(resourceTO);\n         resource = resourceDAO.save(resource);\n+        assertNotNull(resource);\n+        assertNotNull(resource.getUmapping());\n+        assertEquals(1, resource.getUmapping().getItems().size());\n \n         resourceDAO.flush();\n \n@@ -136,10 +182,14 @@ public void issue42() {\n \n         userId = schemaDAO.find(\"userId\", USchema.class);\n \n-        Set<SchemaMapping> afterUserIdMappings = new HashSet<SchemaMapping>();\n-        for (SchemaMapping mapping : resourceDAO.findAllMappings()) {\n-            if (userId.getName().equals(SchemaMappingUtil.getIntAttrName(mapping, IntMappingType.UserSchema))) {\n-                afterUserIdMappings.add(mapping);\n+        Set<AbstractMappingItem> afterUserIdMappings = new HashSet<AbstractMappingItem>();\n+        for (ExternalResource res : resourceDAO.findAll()) {\n+            if (res.getUmapping() != null) {\n+                for (AbstractMappingItem mapItem : res.getUmapping().getItems()) {\n+                    if (userId.getName().equals(mapItem.getIntAttrName())) {\n+                        afterUserIdMappings.add(mapItem);\n+                    }\n+                }\n             }\n         }\n \n@@ -157,39 +207,40 @@ public void save() {\n \n         resource.setConnector(connector);\n \n+        UMapping mapping = new UMapping();\n+        mapping.setResource(resource);\n+        resource.setUmapping(mapping);\n+\n         // specify mappings\n         for (int i = 0; i < 3; i++) {\n-            SchemaMapping mapping = new SchemaMapping();\n-            mapping.setExtAttrName(\"test\" + i);\n-            mapping.setIntAttrName(\"nonexistent\" + i);\n-            mapping.setIntMappingType(IntMappingType.UserSchema);\n-            mapping.setMandatoryCondition(\"false\");\n-\n-            mapping.setResource(resource);\n-            resource.addMapping(mapping);\n+            UMappingItem item = new UMappingItem();\n+            item.setExtAttrName(\"test\" + i);\n+            item.setIntAttrName(\"nonexistent\" + i);\n+            item.setIntMappingType(IntMappingType.UserSchema);\n+            item.setMandatoryCondition(\"false\");\n+            mapping.addItem(item);\n+            item.setMapping(mapping);\n         }\n-        SchemaMapping accountId = new SchemaMapping();\n-        accountId.setAccountid(true);\n+        UMappingItem accountId = new UMappingItem();\n         accountId.setExtAttrName(\"username\");\n         accountId.setIntAttrName(\"username\");\n-        accountId.setIntMappingType(IntMappingType.SyncopeUserId);\n-\n-        accountId.setResource(resource);\n-        resource.addMapping(accountId);\n+        accountId.setIntMappingType(IntMappingType.UserId);\n+        mapping.setAccountIdItem(accountId);\n+        accountId.setMapping(mapping);\n \n         // map a derived attribute\n-        SchemaMapping derived = new SchemaMapping();\n+        UMappingItem derived = new UMappingItem();\n         derived.setAccountid(false);\n         derived.setExtAttrName(\"fullname\");\n         derived.setIntAttrName(\"cn\");\n         derived.setIntMappingType(IntMappingType.UserDerivedSchema);\n-\n-        derived.setResource(resource);\n-        resource.addMapping(derived);\n+        mapping.addItem(derived);\n+        derived.setMapping(mapping);\n \n         // save the resource\n         ExternalResource actual = resourceDAO.save(resource);\n         assertNotNull(actual);\n+        assertNotNull(actual.getUmapping());\n \n         resourceDAO.flush();\n         resourceDAO.detach(actual);\n@@ -218,9 +269,9 @@ public void save() {\n         assertTrue(resource.getConnector().equals(connector));\n \n         // check mappings\n-        Set<SchemaMapping> schemaMappings = resource.getMappings();\n-        assertNotNull(schemaMappings);\n-        assertEquals(5, schemaMappings.size());\n+        List<UMappingItem> items = resource.getUmapping().getItems();\n+        assertNotNull(items);\n+        assertEquals(5, items.size());\n \n         // check user\n         user = userDAO.find(1L);\n@@ -295,30 +346,19 @@ public void delete() {\n     public void issue243() {\n         ExternalResource csv = resourceDAO.find(\"resource-csv\");\n         assertNotNull(csv);\n-        int origMappings = csv.getMappings().size();\n \n-        SchemaMapping newMapping = new SchemaMapping();\n-        newMapping.setIntMappingType(IntMappingType.Username);\n-        newMapping.setExtAttrName(\"TEST\");\n-        newMapping.setResource(csv);\n-        csv.addMapping(newMapping);\n+        int origMapItems = csv.getUmapping().getItems().size();\n+\n+        UMappingItem newMapItem = new UMappingItem();\n+        newMapItem.setIntMappingType(IntMappingType.Username);\n+        newMapItem.setExtAttrName(\"TEST\");\n+        csv.getUmapping().addItem(newMapItem);\n \n         resourceDAO.save(csv);\n         resourceDAO.flush();\n \n         csv = resourceDAO.find(\"resource-csv\");\n         assertNotNull(csv);\n-        assertEquals(origMappings + 1, csv.getMappings().size());\n-\n-        resourceDAO.clear();\n-\n-        int currentMappings = 0;\n-        List<SchemaMapping> allMappings = resourceDAO.findAllMappings();\n-        for (SchemaMapping mapping : allMappings) {\n-            if (\"resource-csv\".equals(mapping.getResource().getName())) {\n-                currentMappings++;\n-            }\n-        }\n-        assertEquals(csv.getMappings().size(), currentMappings);\n+        assertEquals(origMapItems + 1, csv.getUmapping().getItems().size());\n     }\n }"},{"sha":"d18dad927df6fe7a62e7824d9c8996b864852c37","filename":"core/src/test/java/org/apache/syncope/core/persistence/relationships/SchemaTest.java","status":"modified","additions":46,"deletions":32,"changes":78,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Frelationships%2FSchemaTest.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Frelationships%2FSchemaTest.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Frelationships%2FSchemaTest.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -18,26 +18,24 @@\n  */\n package org.apache.syncope.core.persistence.relationships;\n \n-import java.util.HashSet;\n-import java.util.Set;\n import static org.junit.Assert.*;\n-import org.junit.Test;\n \n+import java.util.HashSet;\n+import java.util.Set;\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.transaction.annotation.Transactional;\n-import org.apache.syncope.core.persistence.beans.SchemaMapping;\n+import org.apache.syncope.core.persistence.beans.AbstractMappingItem;\n import org.apache.syncope.core.persistence.beans.user.UAttr;\n import org.apache.syncope.core.persistence.beans.user.USchema;\n import org.apache.syncope.core.persistence.dao.AttrDAO;\n-import org.apache.syncope.core.persistence.dao.DerSchemaDAO;\n import org.apache.syncope.core.persistence.dao.ResourceDAO;\n import org.apache.syncope.core.persistence.dao.SchemaDAO;\n import org.apache.syncope.core.persistence.dao.UserDAO;\n import org.apache.syncope.core.AbstractTest;\n+import org.apache.syncope.core.persistence.beans.ExternalResource;\n import org.apache.syncope.core.util.AttributableUtil;\n-import org.apache.syncope.core.util.SchemaMappingUtil;\n import org.apache.syncope.types.AttributableType;\n-import org.apache.syncope.types.IntMappingType;\n+import org.junit.Test;\n \n @Transactional\n public class SchemaTest extends AbstractTest {\n@@ -48,30 +46,30 @@ public class SchemaTest extends AbstractTest {\n     @Autowired\n     private SchemaDAO schemaDAO;\n \n-    @Autowired\n-    private DerSchemaDAO derSchemaDAO;\n-\n     @Autowired\n     private AttrDAO attrDAO;\n \n     @Autowired\n     private ResourceDAO resourceDAO;\n \n     @Test\n-    public void test1() {\n+    public void deleteFullname() {\n         // search for user schema fullname\n         USchema schema = schemaDAO.find(\"fullname\", USchema.class);\n-\n         assertNotNull(schema);\n \n         // check for associated mappings\n-        Set<SchemaMapping> mappings = new HashSet<SchemaMapping>();\n-        for (SchemaMapping mapping : resourceDAO.findAllMappings()) {\n-            if (schema.getName().equals(SchemaMappingUtil.getIntAttrName(mapping, IntMappingType.UserSchema))) {\n-                mappings.add(mapping);\n+        Set<AbstractMappingItem> mapItems = new HashSet<AbstractMappingItem>();\n+        for (ExternalResource resource : resourceDAO.findAll()) {\n+            if (resource.getUmapping() != null) {\n+                for (AbstractMappingItem mapItem : resource.getUmapping().getItems()) {\n+                    if (schema.getName().equals(mapItem.getIntAttrName())) {\n+                        mapItems.add(mapItem);\n+                    }\n+                }\n             }\n         }\n-        assertFalse(mappings.isEmpty());\n+        assertFalse(mapItems.isEmpty());\n \n         // delete user schema fullname\n         schemaDAO.delete(\"fullname\", AttributableUtil.getInstance(AttributableType.USER));\n@@ -80,17 +78,22 @@ public void test1() {\n \n         // check for schema deletion\n         schema = schemaDAO.find(\"fullname\", USchema.class);\n-\n         assertNull(schema);\n \n+        schemaDAO.clear();\n+\n         // check for mappings deletion\n-        mappings = new HashSet<SchemaMapping>();\n-        for (SchemaMapping mapping : resourceDAO.findAllMappings()) {\n-            if (\"fullname\".equals(SchemaMappingUtil.getIntAttrName(mapping, IntMappingType.UserSchema))) {\n-                mappings.add(mapping);\n+        mapItems = new HashSet<AbstractMappingItem>();\n+        for (ExternalResource resource : resourceDAO.findAll()) {\n+            if (resource.getUmapping() != null) {\n+                for (AbstractMappingItem mapItem : resource.getUmapping().getItems()) {\n+                    if (\"fullname\".equals(mapItem.getIntAttrName())) {\n+                        mapItems.add(mapItem);\n+                    }\n+                }\n             }\n         }\n-        assertTrue(mappings.isEmpty());\n+        assertTrue(mapItems.isEmpty());\n \n         assertNull(attrDAO.find(100L, UAttr.class));\n         assertNull(attrDAO.find(300L, UAttr.class));\n@@ -99,18 +102,20 @@ public void test1() {\n     }\n \n     @Test\n-    public void test2() {\n-\n+    public void deleteSurname() {\n         // search for user schema fullname\n         USchema schema = schemaDAO.find(\"surname\", USchema.class);\n-\n         assertNotNull(schema);\n \n         // check for associated mappings\n-        Set<SchemaMapping> mappings = new HashSet<SchemaMapping>();\n-        for (SchemaMapping mapping : resourceDAO.findAllMappings()) {\n-            if (schema.getName().equals(SchemaMappingUtil.getIntAttrName(mapping, IntMappingType.UserSchema))) {\n-                mappings.add(mapping);\n+        Set<AbstractMappingItem> mappings = new HashSet<AbstractMappingItem>();\n+        for (ExternalResource resource : resourceDAO.findAll()) {\n+            if (resource.getUmapping() != null) {\n+                for (AbstractMappingItem mapItem : resource.getUmapping().getItems()) {\n+                    if (schema.getName().equals(mapItem.getIntAttrName())) {\n+                        mappings.add(mapItem);\n+                    }\n+                }\n             }\n         }\n         assertFalse(mappings.isEmpty());\n@@ -122,9 +127,18 @@ public void test2() {\n \n         // check for schema deletion\n         schema = schemaDAO.find(\"surname\", USchema.class);\n-\n         assertNull(schema);\n+    }\n+\n+    @Test\n+    public void deleteALong() {\n+        assertEquals(6, resourceDAO.find(\"resource-db-sync\").getUmapping().getItems().size());\n+\n+        schemaDAO.delete(\"aLong\", AttributableUtil.getInstance(AttributableType.USER));\n+        assertNull(schemaDAO.find(\"aLong\", USchema.class));\n+\n+        schemaDAO.flush();\n \n-        assertNull(schemaDAO.find(\"surname\", USchema.class));\n+        assertEquals(5, resourceDAO.find(\"resource-db-sync\").getUmapping().getItems().size());\n     }\n }"},{"sha":"3d60a8614c60875fdfae2291b8aecaa2cbc80529","filename":"core/src/test/java/org/apache/syncope/core/persistence/relationships/TaskTest.java","status":"modified","additions":4,"deletions":3,"changes":7,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Frelationships%2FTaskTest.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Frelationships%2FTaskTest.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Frelationships%2FTaskTest.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -38,9 +38,10 @@\n import org.apache.syncope.core.persistence.dao.TaskDAO;\n import org.apache.syncope.core.persistence.dao.TaskExecDAO;\n import org.apache.syncope.core.persistence.dao.UserDAO;\n+import org.apache.syncope.types.AttributableType;\n import org.apache.syncope.types.PropagationMode;\n import org.apache.syncope.types.PropagationTaskExecStatus;\n-import org.apache.syncope.types.PropagationOperation;\n+import org.apache.syncope.types.ResourceOperation;\n \n @Transactional\n public class TaskTest extends AbstractTest {\n@@ -77,9 +78,9 @@ public void save() {\n \n         PropagationTask task = new PropagationTask();\n         task.setResource(resource);\n-        task.setSyncopeUser(user);\n+        task.setSubjectType(AttributableType.USER);\n         task.setPropagationMode(PropagationMode.TWO_PHASES);\n-        task.setPropagationOperation(PropagationOperation.CREATE);\n+        task.setPropagationOperation(ResourceOperation.CREATE);\n         task.setAccountId(\"one@two.com\");\n \n         Set<Attribute> attributes = new HashSet<Attribute>();"},{"sha":"32b0a1bb5c9dc82faafabed8f40ee01c8f794316","filename":"core/src/test/java/org/apache/syncope/core/quartz/TestSyncActions.java","status":"modified","additions":13,"deletions":12,"changes":25,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fquartz%2FTestSyncActions.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fquartz%2FTestSyncActions.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fquartz%2FTestSyncActions.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -19,10 +19,10 @@\n package org.apache.syncope.core.quartz;\n \n import java.util.Collections;\n+import org.apache.syncope.client.mod.AbstractAttributableMod;\n import org.apache.syncope.client.mod.AttributeMod;\n-import org.apache.syncope.client.mod.UserMod;\n+import org.apache.syncope.client.to.AbstractAttributableTO;\n import org.apache.syncope.client.to.AttributeTO;\n-import org.apache.syncope.client.to.UserTO;\n import org.apache.syncope.core.sync.DefaultSyncActions;\n import org.identityconnectors.framework.common.objects.SyncDelta;\n import org.quartz.JobExecutionException;\n@@ -32,40 +32,41 @@ public class TestSyncActions extends DefaultSyncActions {\n     private int counter = 0;\n \n     @Override\n-    public SyncDelta beforeCreate(final SyncDelta delta, final UserTO user) throws JobExecutionException {\n+    public <T extends AbstractAttributableTO> SyncDelta beforeCreate(final SyncDelta delta, final T subject)\n+            throws JobExecutionException {\n \n         AttributeTO attrTO = null;\n-        for (int i = 0; i < user.getAttributes().size(); i++) {\n-            if (\"fullname\".equals(user.getAttributes().get(i).getSchema())) {\n-                attrTO = user.getAttributes().get(i);\n+        for (int i = 0; i < subject.getAttributes().size(); i++) {\n+            if (\"fullname\".equals(subject.getAttributes().get(i).getSchema())) {\n+                attrTO = subject.getAttributes().get(i);\n             }\n         }\n         if (attrTO == null) {\n             attrTO = new AttributeTO();\n             attrTO.setSchema(\"fullname\");\n-            user.addAttribute(attrTO);\n+            subject.addAttribute(attrTO);\n         }\n         attrTO.setValues(Collections.singletonList(String.valueOf(counter++)));\n \n         return delta;\n     }\n \n     @Override\n-    public SyncDelta beforeUpdate(final SyncDelta delta, final UserTO user, final UserMod userMod)\n-            throws JobExecutionException {\n+    public <T extends AbstractAttributableTO, K extends AbstractAttributableMod> SyncDelta beforeUpdate(\n+            final SyncDelta delta, final T subject, final K subjectMod) throws JobExecutionException {\n \n-        userMod.addAttributeToBeRemoved(\"fullname\");\n+        subjectMod.addAttributeToBeRemoved(\"fullname\");\n \n         AttributeMod fullnameMod = null;\n-        for (AttributeMod attrMod : userMod.getAttributesToBeUpdated()) {\n+        for (AttributeMod attrMod : subjectMod.getAttributesToBeUpdated()) {\n             if (\"fullname\".equals(attrMod.getSchema())) {\n                 fullnameMod = attrMod;\n             }\n         }\n         if (fullnameMod == null) {\n             fullnameMod = new AttributeMod();\n             fullnameMod.setSchema(\"fullname\");\n-            userMod.addAttributeToBeUpdated(fullnameMod);\n+            subjectMod.addAttributeToBeUpdated(fullnameMod);\n         }\n \n         fullnameMod.setValuesToBeAdded(Collections.singletonList(String.valueOf(counter++)));"},{"sha":"9ca5b52eeb32cc034166172acae64682c4b983c8","filename":"core/src/test/java/org/apache/syncope/core/rest/ConnInstanceTestITCase.java","status":"modified","additions":11,"deletions":7,"changes":18,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Frest%2FConnInstanceTestITCase.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Frest%2FConnInstanceTestITCase.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Frest%2FConnInstanceTestITCase.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -38,8 +38,9 @@\n import org.springframework.web.client.HttpStatusCodeException;\n import org.apache.syncope.client.to.ConnBundleTO;\n import org.apache.syncope.client.to.ConnInstanceTO;\n+import org.apache.syncope.client.to.MappingItemTO;\n+import org.apache.syncope.client.to.MappingTO;\n import org.apache.syncope.client.to.ResourceTO;\n-import org.apache.syncope.client.to.SchemaMappingTO;\n import org.apache.syncope.client.validation.SyncopeClientCompositeErrorException;\n import org.apache.syncope.types.ConnConfPropSchema;\n import org.apache.syncope.types.ConnConfProperty;\n@@ -611,12 +612,15 @@ public void issueSYNCOPE112() {\n \n         resourceTO.setConnectorConfigurationProperties(conf);\n \n-        SchemaMappingTO schemaMappingTO = new SchemaMappingTO();\n-        schemaMappingTO.setExtAttrName(\"uid\");\n-        schemaMappingTO.setIntAttrName(\"userId\");\n-        schemaMappingTO.setIntMappingType(IntMappingType.UserSchema);\n-        schemaMappingTO.setAccountid(true);\n-        resourceTO.addMapping(schemaMappingTO);\n+        MappingTO mapping = new MappingTO();\n+        resourceTO.setUmapping(mapping);\n+\n+        MappingItemTO mapItem = new MappingItemTO();\n+        mapItem.setExtAttrName(\"uid\");\n+        mapItem.setIntAttrName(\"userId\");\n+        mapItem.setIntMappingType(IntMappingType.UserSchema);\n+        mapItem.setAccountid(true);\n+        mapping.setAccountIdItem(mapItem);\n         // ----------------------------------------\n \n         // ----------------------------------------"},{"sha":"93758765a4bda17491c49bdf4e176e0e0c2b3ef3","filename":"core/src/test/java/org/apache/syncope/core/rest/ResourceTestITCase.java","status":"modified","additions":133,"deletions":128,"changes":261,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Frest%2FResourceTestITCase.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Frest%2FResourceTestITCase.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Frest%2FResourceTestITCase.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -20,8 +20,8 @@\n \n import static org.junit.Assert.*;\n \n-import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.Collection;\n import java.util.Collections;\n import java.util.HashSet;\n import java.util.List;\n@@ -30,7 +30,8 @@\n import org.springframework.http.HttpStatus;\n import org.springframework.web.client.HttpStatusCodeException;\n import org.apache.syncope.client.to.ResourceTO;\n-import org.apache.syncope.client.to.SchemaMappingTO;\n+import org.apache.syncope.client.to.MappingItemTO;\n+import org.apache.syncope.client.to.MappingTO;\n import org.apache.syncope.client.validation.SyncopeClientCompositeErrorException;\n import org.apache.syncope.client.validation.SyncopeClientException;\n import org.apache.syncope.types.ConnConfPropSchema;\n@@ -51,17 +52,6 @@ public void getPropagationActionsClasses() {\n         assertFalse(actions.isEmpty());\n     }\n \n-    @Test(expected = SyncopeClientCompositeErrorException.class)\n-    public void createExistingResource() {\n-        final String resourceName = \"ws-target-resource-1\";\n-        ResourceTO resourceTO = new ResourceTO();\n-\n-        resourceTO.setName(resourceName);\n-        resourceTO.setConnectorId(100L);\n-\n-        restTemplate.postForObject(BASE_URL + \"resource/create.json\", resourceTO, ResourceTO.class);\n-    }\n-\n     @Test\n     public void create() {\n         String resourceName = \"ws-target-resource-create\";\n@@ -70,35 +60,36 @@ public void create() {\n         resourceTO.setName(resourceName);\n         resourceTO.setConnectorId(102L);\n \n-        SchemaMappingTO schemaMappingTO = new SchemaMappingTO();\n-        schemaMappingTO.setExtAttrName(\"uid\");\n-        schemaMappingTO.setIntAttrName(\"userId\");\n-        schemaMappingTO.setIntMappingType(IntMappingType.UserSchema);\n-        resourceTO.addMapping(schemaMappingTO);\n-\n-        schemaMappingTO = new SchemaMappingTO();\n-        schemaMappingTO.setExtAttrName(\"username\");\n-        schemaMappingTO.setIntAttrName(\"fullname\");\n-        schemaMappingTO.setIntMappingType(IntMappingType.SyncopeUserId);\n-        schemaMappingTO.setAccountid(true);\n-        resourceTO.addMapping(schemaMappingTO);\n-\n-        schemaMappingTO = new SchemaMappingTO();\n-        schemaMappingTO.setExtAttrName(\"fullname\");\n-        schemaMappingTO.setIntAttrName(\"cn\");\n-        schemaMappingTO.setIntMappingType(IntMappingType.UserSchema);\n-        schemaMappingTO.setAccountid(false);\n-        resourceTO.addMapping(schemaMappingTO);\n+        MappingTO mapping = new MappingTO();\n \n-        ResourceTO actual = restTemplate.postForObject(BASE_URL + \"resource/create.json\", resourceTO, ResourceTO.class);\n+        MappingItemTO item = new MappingItemTO();\n+        item.setExtAttrName(\"uid\");\n+        item.setIntAttrName(\"userId\");\n+        item.setIntMappingType(IntMappingType.UserSchema);\n+        mapping.addItem(item);\n \n-        assertNotNull(actual);\n+        item = new MappingItemTO();\n+        item.setExtAttrName(\"username\");\n+        item.setIntAttrName(\"fullname\");\n+        item.setIntMappingType(IntMappingType.UserId);\n+        item.setAccountid(true);\n+        mapping.setAccountIdItem(item);\n \n-        // check the existence\n+        item = new MappingItemTO();\n+        item.setExtAttrName(\"fullname\");\n+        item.setIntAttrName(\"cn\");\n+        item.setIntMappingType(IntMappingType.UserSchema);\n+        item.setAccountid(false);\n+        mapping.addItem(item);\n+\n+        resourceTO.setUmapping(mapping);\n+\n+        ResourceTO actual = restTemplate.postForObject(BASE_URL + \"resource/create.json\", resourceTO, ResourceTO.class);\n+        assertNotNull(actual);\n \n+        // check for existence\n         actual = restTemplate.getForObject(BASE_URL + \"resource/read/{resourceName}.json\", ResourceTO.class,\n                 resourceName);\n-\n         assertNotNull(actual);\n     }\n \n@@ -107,29 +98,33 @@ public void createOverridingProps() {\n         String resourceName = \"overriding-conn-conf-target-resource-create\";\n         ResourceTO resourceTO = new ResourceTO();\n \n-        SchemaMappingTO schemaMappingTO = new SchemaMappingTO();\n-        schemaMappingTO.setExtAttrName(\"uid\");\n-        schemaMappingTO.setIntAttrName(\"userId\");\n-        schemaMappingTO.setIntMappingType(IntMappingType.UserSchema);\n-        resourceTO.addMapping(schemaMappingTO);\n-\n-        schemaMappingTO = new SchemaMappingTO();\n-        schemaMappingTO.setExtAttrName(\"username\");\n-        schemaMappingTO.setIntAttrName(\"fullname\");\n-        schemaMappingTO.setIntMappingType(IntMappingType.SyncopeUserId);\n-        schemaMappingTO.setAccountid(true);\n-        resourceTO.addMapping(schemaMappingTO);\n-\n-        schemaMappingTO = new SchemaMappingTO();\n-        schemaMappingTO.setExtAttrName(\"fullname\");\n-        schemaMappingTO.setIntAttrName(\"cn\");\n-        schemaMappingTO.setIntMappingType(IntMappingType.UserSchema);\n-        schemaMappingTO.setAccountid(false);\n-        resourceTO.addMapping(schemaMappingTO);\n+        MappingTO mapping = new MappingTO();\n+\n+        MappingItemTO item = new MappingItemTO();\n+        item.setExtAttrName(\"uid\");\n+        item.setIntAttrName(\"userId\");\n+        item.setIntMappingType(IntMappingType.UserSchema);\n+        mapping.addItem(item);\n+\n+        item = new MappingItemTO();\n+        item.setExtAttrName(\"username\");\n+        item.setIntAttrName(\"fullname\");\n+        item.setIntMappingType(IntMappingType.UserId);\n+        item.setAccountid(true);\n+        mapping.setAccountIdItem(item);\n+\n+        item = new MappingItemTO();\n+        item.setExtAttrName(\"fullname\");\n+        item.setIntAttrName(\"cn\");\n+        item.setIntMappingType(IntMappingType.UserSchema);\n+        item.setAccountid(false);\n+        mapping.addItem(item);\n \n         resourceTO.setName(resourceName);\n         resourceTO.setConnectorId(102L);\n \n+        resourceTO.setUmapping(mapping);\n+\n         ConnConfProperty p = new ConnConfProperty();\n         ConnConfPropSchema schema = new ConnConfPropSchema();\n         schema.setType(\"java.lang.String\");\n@@ -139,64 +134,76 @@ public void createOverridingProps() {\n         p.setValues(Collections.singletonList(\"http://invalidurl/\"));\n \n         Set<ConnConfProperty> connectorConfigurationProperties = new HashSet<ConnConfProperty>(Arrays.asList(p));\n-\n         resourceTO.setConnectorConfigurationProperties(connectorConfigurationProperties);\n \n         ResourceTO actual = restTemplate.postForObject(BASE_URL + \"resource/create.json\", resourceTO, ResourceTO.class);\n-\n         assertNotNull(actual);\n \n         // check the existence\n \n         actual = restTemplate.getForObject(BASE_URL + \"resource/read/{resourceName}.json\", ResourceTO.class,\n                 resourceName);\n-\n         assertNotNull(actual);\n     }\n \n     @Test\n-    public void createWithSingleMapping() {\n+    public void createWithSingleMappingItem() {\n         String resourceName = \"ws-target-resource-create-single\";\n         ResourceTO resourceTO = new ResourceTO();\n-\n         resourceTO.setName(resourceName);\n         resourceTO.setConnectorId(102L);\n \n-        SchemaMappingTO schemaMappingTO = new SchemaMappingTO();\n-        schemaMappingTO.setIntMappingType(IntMappingType.SyncopeUserId);\n-        schemaMappingTO.setAccountid(true);\n-        resourceTO.addMapping(schemaMappingTO);\n+        MappingTO umapping = new MappingTO();\n \n-        ResourceTO actual = restTemplate.postForObject(BASE_URL + \"resource/create.json\", resourceTO, ResourceTO.class);\n+        MappingItemTO item = new MappingItemTO();\n+        item.setIntMappingType(IntMappingType.UserId);\n+        item.setAccountid(true);\n+        umapping.setAccountIdItem(item);\n+\n+        resourceTO.setUmapping(umapping);\n \n+        MappingTO rmapping = new MappingTO();\n+\n+        item = new MappingItemTO();\n+        item.setIntMappingType(IntMappingType.RoleId);\n+        item.setAccountid(true);\n+        rmapping.setAccountIdItem(item);\n+\n+        resourceTO.setRmapping(rmapping);\n+\n+        ResourceTO actual = restTemplate.postForObject(BASE_URL + \"resource/create.json\", resourceTO, ResourceTO.class);\n         assertNotNull(actual);\n+        assertNotNull(actual.getUmapping());\n+        assertNotNull(actual.getUmapping().getItems());\n+        assertNotNull(actual.getRmapping());\n+        assertNotNull(actual.getRmapping().getItems());\n     }\n \n     @Test\n-    public void createWithWrongMapping() {\n+    public void createWithInvalidMapping() {\n         String resourceName = \"ws-target-resource-create-wrong\";\n         ResourceTO resourceTO = new ResourceTO();\n-\n         resourceTO.setName(resourceName);\n         resourceTO.setConnectorId(102L);\n \n-        SchemaMappingTO schemaMappingTO = new SchemaMappingTO();\n-        schemaMappingTO.setIntMappingType(IntMappingType.SyncopeUserId);\n-        schemaMappingTO.setAccountid(true);\n-        resourceTO.addMapping(schemaMappingTO);\n+        MappingTO mapping = new MappingTO();\n+\n+        MappingItemTO item = new MappingItemTO();\n+        item.setIntMappingType(IntMappingType.UserId);\n+        item.setAccountid(true);\n+        mapping.setAccountIdItem(item);\n \n-        schemaMappingTO = new SchemaMappingTO();\n-        schemaMappingTO.setIntMappingType(IntMappingType.UserSchema);\n-        schemaMappingTO.setExtAttrName(\"email\");\n+        item = new MappingItemTO();\n+        item.setIntMappingType(IntMappingType.UserSchema);\n+        item.setExtAttrName(\"email\");\n         // missing intAttrName ...\n-        resourceTO.addMapping(schemaMappingTO);\n+        mapping.addItem(item);\n \n-        Throwable t = null;\n+        resourceTO.setUmapping(mapping);\n \n+        Throwable t = null;\n         try {\n-\n             restTemplate.postForObject(BASE_URL + \"resource/create.json\", resourceTO, ResourceTO.class);\n-\n         } catch (SyncopeClientCompositeErrorException e) {\n             t = e;\n \n@@ -214,20 +221,23 @@ public void createWithWrongMapping() {\n     public void createWithoutExtAttr() {\n         String resourceName = \"ws-target-resource-create-wrong\";\n         ResourceTO resourceTO = new ResourceTO();\n-\n         resourceTO.setName(resourceName);\n         resourceTO.setConnectorId(102L);\n \n-        SchemaMappingTO schemaMappingTO = new SchemaMappingTO();\n-        schemaMappingTO.setIntMappingType(IntMappingType.SyncopeUserId);\n-        schemaMappingTO.setAccountid(true);\n-        resourceTO.addMapping(schemaMappingTO);\n+        MappingTO mapping = new MappingTO();\n+\n+        MappingItemTO item = new MappingItemTO();\n+        item.setIntMappingType(IntMappingType.UserId);\n+        item.setAccountid(true);\n+        mapping.setAccountIdItem(item);\n \n-        schemaMappingTO = new SchemaMappingTO();\n-        schemaMappingTO.setIntMappingType(IntMappingType.UserSchema);\n-        schemaMappingTO.setIntAttrName(\"usernane\");\n+        item = new MappingItemTO();\n+        item.setIntMappingType(IntMappingType.UserSchema);\n+        item.setIntAttrName(\"usernane\");\n         // missing extAttrName ...\n-        resourceTO.addMapping(schemaMappingTO);\n+        mapping.addItem(item);\n+\n+        resourceTO.setUmapping(mapping);\n \n         restTemplate.postForObject(BASE_URL + \"resource/create.json\", resourceTO, ResourceTO.class);\n     }\n@@ -236,27 +246,28 @@ public void createWithoutExtAttr() {\n     public void createWithPasswordPolicy() {\n         String resourceName = \"res-with-password-policy\";\n         ResourceTO resourceTO = new ResourceTO();\n-\n         resourceTO.setName(resourceName);\n         resourceTO.setConnectorId(102L);\n         resourceTO.setPasswordPolicy(4L);\n \n-        SchemaMappingTO schemaMappingTO = new SchemaMappingTO();\n-        schemaMappingTO.setExtAttrName(\"uid\");\n-        schemaMappingTO.setIntAttrName(\"userId\");\n-        schemaMappingTO.setIntMappingType(IntMappingType.UserSchema);\n-        schemaMappingTO.setAccountid(true);\n-        resourceTO.addMapping(schemaMappingTO);\n+        MappingTO mapping = new MappingTO();\n \n-        ResourceTO actual = restTemplate.postForObject(BASE_URL + \"resource/create.json\", resourceTO, ResourceTO.class);\n+        MappingItemTO item = new MappingItemTO();\n+        item.setExtAttrName(\"uid\");\n+        item.setIntAttrName(\"userId\");\n+        item.setIntMappingType(IntMappingType.UserSchema);\n+        item.setAccountid(true);\n+        mapping.setAccountIdItem(item);\n+\n+        resourceTO.setUmapping(mapping);\n \n+        ResourceTO actual = restTemplate.postForObject(BASE_URL + \"resource/create.json\", resourceTO, ResourceTO.class);\n         assertNotNull(actual);\n \n         // check the existence\n \n         actual = restTemplate.getForObject(BASE_URL + \"resource/read/{resourceName}.json\", ResourceTO.class,\n                 resourceName);\n-\n         assertNotNull(actual);\n         assertNotNull(actual.getPasswordPolicy());\n         assertEquals(4L, (long) actual.getPasswordPolicy());\n@@ -266,7 +277,6 @@ public void createWithPasswordPolicy() {\n     public void updateWithException() {\n         try {\n             ResourceTO resourceTO = new ResourceTO();\n-\n             resourceTO.setName(\"resourcenotfound\");\n \n             restTemplate.postForObject(BASE_URL + \"resource/update.json\", resourceTO, ResourceTO.class);\n@@ -279,48 +289,43 @@ public void updateWithException() {\n     public void update() {\n         final String resourceName = \"ws-target-resource-update\";\n         ResourceTO resourceTO = new ResourceTO();\n-\n         resourceTO.setName(resourceName);\n         resourceTO.setConnectorId(101L);\n \n-        List<SchemaMappingTO> schemaMappingTOs = new ArrayList<SchemaMappingTO>();\n+        MappingTO mapping = new MappingTO();\n \n         // Update with an existing and already assigned mapping\n-        SchemaMappingTO schemaMappingTO = new SchemaMappingTO();\n-        schemaMappingTO.setId(112L);\n-        schemaMappingTO.setExtAttrName(\"test3\");\n-        schemaMappingTO.setIntAttrName(\"fullname\");\n-        schemaMappingTO.setIntMappingType(IntMappingType.UserSchema);\n-        schemaMappingTOs.add(schemaMappingTO);\n+        MappingItemTO item = new MappingItemTO();\n+        item.setId(112L);\n+        item.setExtAttrName(\"test3\");\n+        item.setIntAttrName(\"fullname\");\n+        item.setIntMappingType(IntMappingType.UserSchema);\n+        mapping.addItem(item);\n \n         // Update defining new mappings\n         for (int i = 4; i < 6; i++) {\n-            schemaMappingTO = new SchemaMappingTO();\n-            schemaMappingTO.setExtAttrName(\"test\" + i);\n-            schemaMappingTO.setIntAttrName(\"fullname\");\n-            schemaMappingTO.setIntMappingType(IntMappingType.UserSchema);\n-            schemaMappingTOs.add(schemaMappingTO);\n+            item = new MappingItemTO();\n+            item.setExtAttrName(\"test\" + i);\n+            item.setIntAttrName(\"fullname\");\n+            item.setIntMappingType(IntMappingType.UserSchema);\n+            mapping.addItem(item);\n         }\n-        schemaMappingTO = new SchemaMappingTO();\n-        schemaMappingTO.setExtAttrName(\"username\");\n-        schemaMappingTO.setIntAttrName(\"fullname\");\n-        schemaMappingTO.setIntMappingType(IntMappingType.SyncopeUserId);\n-        schemaMappingTO.setAccountid(true);\n-        schemaMappingTOs.add(schemaMappingTO);\n+        item = new MappingItemTO();\n+        item.setExtAttrName(\"username\");\n+        item.setIntAttrName(\"fullname\");\n+        item.setIntMappingType(IntMappingType.UserId);\n+        item.setAccountid(true);\n+        mapping.setAccountIdItem(item);\n \n-        resourceTO.setMappings(schemaMappingTOs);\n+        resourceTO.setUmapping(mapping);\n \n         ResourceTO actual = restTemplate.postForObject(BASE_URL + \"resource/update.json\", resourceTO, ResourceTO.class);\n-\n         assertNotNull(actual);\n \n-        // check the existence\n-\n-        List<SchemaMappingTO> mappings = actual.getMappings();\n-\n-        assertNotNull(mappings);\n-\n-        assertEquals(4, mappings.size());\n+        // check for existence\n+        Collection<MappingItemTO> mapItems = actual.getUmapping().getItems();\n+        assertNotNull(mapItems);\n+        assertEquals(4, mapItems.size());\n     }\n \n     @Test\n@@ -339,14 +344,14 @@ public void updateResetSyncToken() {\n         String resourceName = \"ws-target-resource-update-resetsynctoken\";\n         ResourceTO pre = restTemplate.getForObject(BASE_URL + \"/resource/read/{resourceName}.json\", ResourceTO.class,\n                 resourceName);\n-        assertNotNull(pre.getSyncToken());\n+        assertNotNull(pre.getUsyncToken());\n \n-        pre.setSyncToken(null);\n+        pre.setUsyncToken(null);\n \n         ResourceTO actual = restTemplate.postForObject(BASE_URL + \"resource/update.json\", pre, ResourceTO.class);\n \n         // check that the synctoken has been reset\n-        assertNull(actual.getSyncToken());\n+        assertNull(actual.getUsyncToken());\n     }\n \n     @Test"},{"sha":"621da2747f54056b2cd74adf63cd24dafd55a56c","filename":"core/src/test/java/org/apache/syncope/core/rest/RoleTestITCase.java","status":"modified","additions":42,"deletions":18,"changes":60,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Frest%2FRoleTestITCase.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Frest%2FRoleTestITCase.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Frest%2FRoleTestITCase.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -18,24 +18,21 @@\n  */\n package org.apache.syncope.core.rest;\n \n+import static org.junit.Assert.*;\n+\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.List;\n import org.apache.http.auth.UsernamePasswordCredentials;\n import org.apache.http.impl.client.DefaultHttpClient;\n import org.apache.syncope.client.http.PreemptiveAuthHttpRequestFactory;\n import org.apache.syncope.client.mod.RoleMod;\n+import org.apache.syncope.client.to.ConnObjectTO;\n import org.apache.syncope.client.to.RoleTO;\n import org.apache.syncope.client.to.UserTO;\n import org.apache.syncope.client.validation.SyncopeClientCompositeErrorException;\n import org.apache.syncope.client.validation.SyncopeClientException;\n import org.apache.syncope.types.SyncopeClientExceptionType;\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertFalse;\n-import static org.junit.Assert.assertNotNull;\n-import static org.junit.Assert.assertNull;\n-import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.fail;\n import org.junit.FixMethodOrder;\n import org.junit.Test;\n import org.junit.runners.MethodSorters;\n@@ -75,19 +72,36 @@ public void create() {\n         // inherited so setter execution should be ignored\n         roleTO.setPasswordPolicy(2L);\n \n-        RoleTO actual = restTemplate.postForObject(BASE_URL + \"role/create\", roleTO, RoleTO.class);\n+        roleTO.addAttribute(attributeTO(\"icon\", \"anIcon\"));\n \n-        roleTO.setId(actual.getId());\n+        roleTO.addDerivedAttribute(attributeTO(\"ownerDN\", null));\n \n-        roleTO.setPasswordPolicy(4L);\n+        roleTO.addVirtualAttribute(attributeTO(\"rvirtualdata\", \"rvirtualvalue\"));\n \n-        assertEquals(roleTO, actual);\n+        roleTO.setRoleOwner(8L);\n \n-        assertNotNull(actual.getAccountPolicy());\n-        assertEquals(6L, (long) actual.getAccountPolicy());\n+        roleTO.addResource(\"resource-ldap\");\n \n-        assertNotNull(actual.getPasswordPolicy());\n-        assertEquals(4L, (long) actual.getPasswordPolicy());\n+        roleTO = restTemplate.postForObject(BASE_URL + \"role/create\", roleTO, RoleTO.class);\n+        assertNotNull(roleTO);\n+\n+        assertNotNull(roleTO.getVirtualAttributeMap());\n+        assertNotNull(roleTO.getVirtualAttributeMap().get(\"rvirtualdata\").getValues());\n+        assertFalse(roleTO.getVirtualAttributeMap().get(\"rvirtualdata\").getValues().isEmpty());\n+        assertEquals(\"rvirtualvalue\", roleTO.getVirtualAttributeMap().get(\"rvirtualdata\").getValues().get(0));\n+\n+        assertNotNull(roleTO.getAccountPolicy());\n+        assertEquals(6L, (long) roleTO.getAccountPolicy());\n+\n+        assertNotNull(roleTO.getPasswordPolicy());\n+        assertEquals(4L, (long) roleTO.getPasswordPolicy());\n+\n+        assertTrue(roleTO.getResources().contains(\"resource-ldap\"));\n+\n+        ConnObjectTO connObjectTO = restTemplate.getForObject(BASE_URL\n+                + \"/resource/resource-ldap/read/ROLE/lastRole.json\", ConnObjectTO.class);\n+        assertNotNull(connObjectTO);\n+        assertNotNull(connObjectTO.getAttributeMap().get(\"owner\"));\n     }\n \n     @Test\n@@ -98,11 +112,9 @@ public void createWithPasswordPolicy() {\n         roleTO.setPasswordPolicy(4L);\n \n         RoleTO actual = restTemplate.postForObject(BASE_URL + \"role/create\", roleTO, RoleTO.class);\n-\n         assertNotNull(actual);\n \n         actual = restTemplate.getForObject(BASE_URL + \"role/read/{roleId}.json\", RoleTO.class, actual.getId());\n-\n         assertNotNull(actual);\n         assertNotNull(actual.getPasswordPolicy());\n         assertEquals(4L, (long) actual.getPasswordPolicy());\n@@ -116,10 +128,20 @@ public void delete() {\n             assertEquals(HttpStatus.NOT_FOUND, e.getStatusCode());\n         }\n \n-        RoleTO deletedRole = restTemplate.getForObject(BASE_URL + \"role/delete/{roleId}\", RoleTO.class, 5);\n+        RoleTO roleTO = new RoleTO();\n+        roleTO.setName(\"toBeDeleted\");\n+        roleTO.setParent(8L);\n+\n+        roleTO.addResource(\"resource-ldap\");\n+\n+        roleTO = restTemplate.postForObject(BASE_URL + \"role/create\", roleTO, RoleTO.class);\n+        assertNotNull(roleTO);\n+\n+        RoleTO deletedRole = restTemplate.getForObject(BASE_URL + \"role/delete/{roleId}\", RoleTO.class, roleTO.getId());\n         assertNotNull(deletedRole);\n+\n         try {\n-            restTemplate.getForObject(BASE_URL + \"role/read/{roleId}.json\", RoleTO.class, 2);\n+            restTemplate.getForObject(BASE_URL + \"role/read/{roleId}.json\", RoleTO.class, deletedRole.getId());\n         } catch (HttpStatusCodeException e) {\n             assertEquals(HttpStatus.NOT_FOUND, e.getStatusCode());\n         }\n@@ -200,6 +222,8 @@ public void update() {\n \n         roleTO.addAttribute(attributeTO(\"icon\", \"anIcon\"));\n \n+        roleTO.addResource(\"resource-ldap\");\n+\n         roleTO = restTemplate.postForObject(BASE_URL + \"role/create\", roleTO, RoleTO.class);\n \n         assertEquals(1, roleTO.getAttributes().size());"},{"sha":"61903dba33ac164d7ed8c199648ec3ada01728e1","filename":"core/src/test/java/org/apache/syncope/core/rest/SearchTestITCase.java","status":"added","additions":208,"deletions":0,"changes":208,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Frest%2FSearchTestITCase.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Frest%2FSearchTestITCase.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Frest%2FSearchTestITCase.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -0,0 +1,208 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.core.rest;\n+\n+import static org.junit.Assert.*;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import org.apache.syncope.client.search.AttributableCond;\n+import org.apache.syncope.client.search.AttributeCond;\n+import org.apache.syncope.client.search.NodeCond;\n+import org.apache.syncope.client.search.ResourceCond;\n+import org.apache.syncope.client.to.RoleTO;\n+import org.apache.syncope.client.to.UserTO;\n+import org.junit.FixMethodOrder;\n+import org.junit.Test;\n+import org.junit.runners.MethodSorters;\n+\n+@FixMethodOrder(MethodSorters.JVM)\n+public class SearchTestITCase extends AbstractTest {\n+\n+    @Test\n+    public void searchUser() {\n+        // LIKE\n+        AttributeCond fullnameLeafCond1 = new AttributeCond(AttributeCond.Type.LIKE);\n+        fullnameLeafCond1.setSchema(\"fullname\");\n+        fullnameLeafCond1.setExpression(\"%o%\");\n+\n+        AttributeCond fullnameLeafCond2 = new AttributeCond(AttributeCond.Type.LIKE);\n+        fullnameLeafCond2.setSchema(\"fullname\");\n+        fullnameLeafCond2.setExpression(\"%i%\");\n+\n+        NodeCond searchCondition = NodeCond.getAndCond(NodeCond.getLeafCond(fullnameLeafCond1), NodeCond.getLeafCond(\n+                fullnameLeafCond2));\n+\n+        assertTrue(searchCondition.checkValidity());\n+\n+        List<UserTO> matchedUsers = Arrays.asList(restTemplate.postForObject(BASE_URL + \"user/search\", searchCondition,\n+                UserTO[].class));\n+        assertNotNull(matchedUsers);\n+        assertFalse(matchedUsers.isEmpty());\n+        for (UserTO user : matchedUsers) {\n+            assertNotNull(user);\n+        }\n+\n+        // ISNULL\n+        AttributeCond isNullCond = new AttributeCond(AttributeCond.Type.ISNULL);\n+        isNullCond.setSchema(\"loginDate\");\n+        searchCondition = NodeCond.getLeafCond(isNullCond);\n+\n+        matchedUsers = Arrays.asList(restTemplate.postForObject(BASE_URL + \"user/search\", searchCondition,\n+                UserTO[].class));\n+        assertNotNull(matchedUsers);\n+        assertFalse(matchedUsers.isEmpty());\n+\n+        Set<Long> userIds = new HashSet<Long>(matchedUsers.size());\n+        for (UserTO user : matchedUsers) {\n+            userIds.add(user.getId());\n+        }\n+        assertTrue(userIds.contains(2L));\n+        assertTrue(userIds.contains(3L));\n+    }\n+\n+    @Test\n+    public void searchByUsernameAndId() {\n+        final AttributableCond usernameLeafCond = new AttributableCond(AttributableCond.Type.EQ);\n+        usernameLeafCond.setSchema(\"username\");\n+        usernameLeafCond.setExpression(\"user1\");\n+\n+        final AttributableCond idRightCond = new AttributableCond(AttributableCond.Type.LT);\n+        idRightCond.setSchema(\"id\");\n+        idRightCond.setExpression(\"2\");\n+\n+        final NodeCond searchCondition = NodeCond.getAndCond(NodeCond.getLeafCond(usernameLeafCond), NodeCond.\n+                getLeafCond(idRightCond));\n+\n+        assertTrue(searchCondition.checkValidity());\n+\n+        final List<UserTO> matchingUsers = Arrays.asList(restTemplate.postForObject(BASE_URL + \"user/search\",\n+                searchCondition, UserTO[].class));\n+\n+        assertNotNull(matchingUsers);\n+        assertEquals(1, matchingUsers.size());\n+        assertEquals(\"user1\", matchingUsers.iterator().next().getUsername());\n+        assertEquals(1L, matchingUsers.iterator().next().getId());\n+    }\n+\n+    @Test\n+    public void searchByRolenameAndId() {\n+        final AttributableCond rolenameLeafCond = new AttributableCond(AttributableCond.Type.EQ);\n+        rolenameLeafCond.setSchema(\"name\");\n+        rolenameLeafCond.setExpression(\"root\");\n+\n+        final AttributableCond idRightCond = new AttributableCond(AttributableCond.Type.LT);\n+        idRightCond.setSchema(\"id\");\n+        idRightCond.setExpression(\"2\");\n+\n+        final NodeCond searchCondition = NodeCond.getAndCond(NodeCond.getLeafCond(rolenameLeafCond),\n+                NodeCond.getLeafCond(idRightCond));\n+\n+        assertTrue(searchCondition.checkValidity());\n+\n+        final List<RoleTO> matchingRoles = Arrays.asList(restTemplate.postForObject(BASE_URL + \"role/search\",\n+                searchCondition, RoleTO[].class));\n+\n+        assertNotNull(matchingRoles);\n+        assertEquals(1, matchingRoles.size());\n+        assertEquals(\"root\", matchingRoles.iterator().next().getName());\n+        assertEquals(1L, matchingRoles.iterator().next().getId());\n+    }\n+\n+    @Test\n+    public void searchUserByResourceName() {\n+        ResourceCond ws2 = new ResourceCond();\n+        ws2.setResourceName(\"ws-target-resource2\");\n+\n+        ResourceCond ws1 = new ResourceCond();\n+        ws1.setResourceName(\"ws-target-resource-list-mappings-2\");\n+\n+        NodeCond searchCondition = NodeCond.getAndCond(NodeCond.getNotLeafCond(ws2), NodeCond.getLeafCond(ws1));\n+\n+        assertTrue(searchCondition.checkValidity());\n+\n+        List<UserTO> matchedUsers = Arrays.asList(restTemplate.postForObject(BASE_URL + \"user/search\", searchCondition,\n+                UserTO[].class));\n+        assertNotNull(matchedUsers);\n+        assertFalse(matchedUsers.isEmpty());\n+\n+        Set<Long> userIds = new HashSet<Long>(matchedUsers.size());\n+        for (UserTO user : matchedUsers) {\n+            userIds.add(user.getId());\n+        }\n+\n+        assertEquals(1, userIds.size());\n+        assertTrue(userIds.contains(2L));\n+    }\n+\n+    @Test\n+    public void paginatedSearch() {\n+        // LIKE\n+        AttributeCond fullnameLeafCond1 = new AttributeCond(AttributeCond.Type.LIKE);\n+        fullnameLeafCond1.setSchema(\"fullname\");\n+        fullnameLeafCond1.setExpression(\"%o%\");\n+\n+        AttributeCond fullnameLeafCond2 = new AttributeCond(AttributeCond.Type.LIKE);\n+        fullnameLeafCond2.setSchema(\"fullname\");\n+        fullnameLeafCond2.setExpression(\"%i%\");\n+\n+        NodeCond searchCondition = NodeCond.getAndCond(NodeCond.getLeafCond(fullnameLeafCond1), NodeCond.getLeafCond(\n+                fullnameLeafCond2));\n+\n+        assertTrue(searchCondition.checkValidity());\n+\n+        List<UserTO> matchedUsers = Arrays.asList(restTemplate.postForObject(BASE_URL + \"user/search/{page}/{size}\",\n+                searchCondition, UserTO[].class, 1, 2));\n+        assertNotNull(matchedUsers);\n+\n+        assertFalse(matchedUsers.isEmpty());\n+        for (UserTO user : matchedUsers) {\n+            assertNotNull(user);\n+        }\n+\n+        // ISNULL\n+        AttributeCond isNullCond = new AttributeCond(AttributeCond.Type.ISNULL);\n+        isNullCond.setSchema(\"loginDate\");\n+        searchCondition = NodeCond.getLeafCond(isNullCond);\n+\n+        matchedUsers = Arrays.asList(restTemplate.postForObject(BASE_URL + \"user/search/{page}/{size}\",\n+                searchCondition, UserTO[].class, 1, 2));\n+\n+        assertNotNull(matchedUsers);\n+        assertFalse(matchedUsers.isEmpty());\n+        Set<Long> userIds = new HashSet<Long>(matchedUsers.size());\n+        for (UserTO user : matchedUsers) {\n+            userIds.add(user.getId());\n+        }\n+        assertEquals(2, userIds.size());\n+    }\n+\n+    @Test\n+    public void searchCount() {\n+        AttributeCond isNullCond = new AttributeCond(AttributeCond.Type.ISNULL);\n+        isNullCond.setSchema(\"loginDate\");\n+        NodeCond searchCond = NodeCond.getLeafCond(isNullCond);\n+\n+        Integer count = restTemplate.postForObject(BASE_URL + \"user/search/count.json\", searchCond, Integer.class);\n+        assertNotNull(count);\n+        assertTrue(count > 0);\n+    }\n+}"},{"sha":"6311750f3ed556ba2c706b24c6d867d77b0ca23b","filename":"core/src/test/java/org/apache/syncope/core/rest/TaskTestITCase.java","status":"modified","additions":57,"deletions":7,"changes":64,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Frest%2FTaskTestITCase.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Frest%2FTaskTestITCase.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Frest%2FTaskTestITCase.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -21,12 +21,14 @@\n import java.util.Arrays;\n import java.util.List;\n import java.util.Set;\n+import org.apache.syncope.client.search.AttributableCond;\n import org.apache.syncope.client.search.MembershipCond;\n import org.apache.syncope.client.search.NodeCond;\n import org.apache.syncope.client.to.MembershipTO;\n import org.apache.syncope.client.to.NotificationTO;\n import org.apache.syncope.client.to.NotificationTaskTO;\n import org.apache.syncope.client.to.PropagationTaskTO;\n+import org.apache.syncope.client.to.RoleTO;\n import org.apache.syncope.client.to.SchedTaskTO;\n import org.apache.syncope.client.to.SyncTaskTO;\n import org.apache.syncope.client.to.TaskExecTO;\n@@ -79,12 +81,16 @@ public void create() {\n         task.setName(\"Test create Sync\");\n         task.setResource(\"ws-target-resource-2\");\n \n-        UserTO template = new UserTO();\n-        template.addResource(\"ws-target-resource-2\");\n+        UserTO userTemplate = new UserTO();\n+        userTemplate.addResource(\"ws-target-resource-2\");\n         MembershipTO membershipTO = new MembershipTO();\n         membershipTO.setRoleId(8L);\n-        template.addMembership(membershipTO);\n-        task.setUserTemplate(template);\n+        userTemplate.addMembership(membershipTO);\n+        task.setUserTemplate(userTemplate);\n+\n+        RoleTO roleTemplate = new RoleTO();\n+        roleTemplate.addResource(\"resource-ldap\");\n+        task.setRoleTemplate(roleTemplate);\n \n         SyncTaskTO actual = restTemplate.postForObject(BASE_URL + \"task/create/sync\", task, SyncTaskTO.class);\n         assertNotNull(actual);\n@@ -93,6 +99,8 @@ public void create() {\n         assertNotNull(task);\n         assertEquals(actual.getId(), task.getId());\n         assertEquals(actual.getJobClassName(), task.getJobClassName());\n+        assertEquals(userTemplate, task.getUserTemplate());\n+        assertEquals(roleTemplate, task.getRoleTemplate());\n     }\n \n     @Test\n@@ -263,7 +271,7 @@ public void sync() {\n         userTO = restTemplate.getForObject(BASE_URL + \"user/read/{userId}.json\", UserTO.class, userTO.getId());\n         assertNotNull(userTO);\n         assertEquals(\"test9\", userTO.getUsername());\n-        assertEquals(SpringContextInitializer.isActivitiConfigured() ? \"active\" : \"created\", userTO.getStatus());\n+        assertEquals(SpringContextInitializer.isActivitiEnabledForUsers() ? \"active\" : \"created\", userTO.getStatus());\n         assertEquals(\"test9@syncope.apache.org\", userTO.getAttributeMap().get(\"email\").getValues().get(0));\n         assertEquals(\"test9@syncope.apache.org\", userTO.getAttributeMap().get(\"userId\").getValues().get(0));\n         assertTrue(Integer.valueOf(userTO.getAttributeMap().get(\"fullname\").getValues().get(0)) <= 10);\n@@ -301,7 +309,7 @@ public void sync() {\n     }\n \n     @Test\n-    public void reconcile() {\n+    public void reconcileUsers() {\n         // Update sync task\n         SyncTaskTO task = restTemplate.getForObject(BASE_URL + \"task/read/{taskId}\", SyncTaskTO.class, 7);\n         assertNotNull(task);\n@@ -318,19 +326,61 @@ public void reconcile() {\n         SyncTaskTO actual = restTemplate.postForObject(BASE_URL + \"task/update/sync\", task, SyncTaskTO.class);\n         assertNotNull(actual);\n         assertEquals(task.getId(), actual.getId());\n+        assertEquals(template, actual.getUserTemplate());\n+        assertEquals(new RoleTO(), actual.getRoleTemplate());\n \n         TaskExecTO execution = execTask(SyncTaskTO.class, actual.getId(), 20, false);\n+\n         final String status = execution.getStatus();\n         assertNotNull(status);\n         assertTrue(PropagationTaskExecStatus.valueOf(status).isSuccessful());\n \n         final UserTO userTO =\n                 restTemplate.getForObject(BASE_URL + \"user/readByUsername/{username}.json\", UserTO.class, \"testuser1\");\n-\n         assertNotNull(userTO);\n         assertEquals(\"reconciled@syncope.apache.org\", userTO.getAttributeMap().get(\"userId\").getValues().get(0));\n     }\n \n+    @Test\n+    public void reconcileRoles() {\n+        // Update sync task\n+        SyncTaskTO task = restTemplate.getForObject(BASE_URL + \"task/read/{taskId}\", SyncTaskTO.class, 11);\n+        assertNotNull(task);\n+\n+        //  add user template\n+        RoleTO template = new RoleTO();\n+        template.setParent(8L);\n+        template.addAttribute(attributeTO(\"show\", \"'true'\"));\n+\n+        task.setRoleTemplate(template);\n+\n+        SyncTaskTO actual = restTemplate.postForObject(BASE_URL + \"task/update/sync\", task, SyncTaskTO.class);\n+        assertNotNull(actual);\n+        assertEquals(task.getId(), actual.getId());\n+        assertEquals(template, actual.getRoleTemplate());\n+        assertEquals(new UserTO(), actual.getUserTemplate());\n+\n+        TaskExecTO execution = execTask(SyncTaskTO.class, actual.getId(), 20, false);\n+\n+        final String status = execution.getStatus();\n+        assertNotNull(status);\n+        assertTrue(PropagationTaskExecStatus.valueOf(status).isSuccessful());\n+\n+        final AttributableCond rolenameLeafCond = new AttributableCond(AttributableCond.Type.EQ);\n+        rolenameLeafCond.setSchema(\"name\");\n+        rolenameLeafCond.setExpression(\"testLDAPGroup\");\n+        final List<RoleTO> matchingRoles = Arrays.asList(restTemplate.postForObject(BASE_URL + \"role/search\",\n+                NodeCond.getLeafCond(rolenameLeafCond), RoleTO[].class));\n+        assertNotNull(matchingRoles);\n+        assertEquals(1, matchingRoles.size());\n+\n+        final RoleTO roleTO = matchingRoles.iterator().next();\n+        assertNotNull(roleTO);\n+        assertEquals(\"testLDAPGroup\", roleTO.getName());\n+        assertEquals(8L, roleTO.getParent());\n+        assertEquals(\"true\", roleTO.getAttributeMap().get(\"show\").getValues().get(0));\n+    }\n+\n     @Test\n     public void issue196() {\n         TaskExecTO exec = restTemplate.postForObject(BASE_URL + \"task/execute/{taskId}\", null, TaskExecTO.class, 6);"},{"sha":"06125291e8b9092b815b7ab0760526baa46023b4","filename":"core/src/test/java/org/apache/syncope/core/rest/UserTestITCase.java","status":"modified","additions":33,"deletions":210,"changes":243,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Frest%2FUserTestITCase.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Frest%2FUserTestITCase.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Frest%2FUserTestITCase.java?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -18,25 +18,21 @@\n  */\n package org.apache.syncope.core.rest;\n \n+import static org.junit.Assert.*;\n+\n import java.text.DateFormat;\n import java.text.SimpleDateFormat;\n import java.util.Arrays;\n import java.util.Collections;\n import java.util.Date;\n-import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n-import java.util.Set;\n import org.apache.http.auth.UsernamePasswordCredentials;\n import org.apache.http.impl.client.DefaultHttpClient;\n import org.apache.syncope.client.http.PreemptiveAuthHttpRequestFactory;\n import org.apache.syncope.client.mod.AttributeMod;\n import org.apache.syncope.client.mod.MembershipMod;\n import org.apache.syncope.client.mod.UserMod;\n-import org.apache.syncope.client.search.AttributeCond;\n-import org.apache.syncope.client.search.NodeCond;\n-import org.apache.syncope.client.search.ResourceCond;\n-import org.apache.syncope.client.search.SyncopeUserCond;\n import org.apache.syncope.client.to.AttributeTO;\n import org.apache.syncope.client.to.ConfigurationTO;\n import org.apache.syncope.client.to.ConnObjectTO;\n@@ -58,7 +54,6 @@\n import org.apache.syncope.types.PropagationTaskExecStatus;\n import org.apache.syncope.types.SyncopeClientExceptionType;\n import org.identityconnectors.framework.common.objects.OperationalAttributes;\n-import static org.junit.Assert.*;\n import org.junit.Assume;\n import org.junit.FixMethodOrder;\n import org.junit.Test;\n@@ -442,10 +437,7 @@ public void create() {\n         userTO.addMembership(membershipTO);\n \n         // add an attribute with no values: must be ignored\n-        AttributeTO nullValueAttrTO = new AttributeTO();\n-        nullValueAttrTO.setSchema(\"subscriptionDate\");\n-        nullValueAttrTO.setValues(null);\n-        membershipTO.addAttribute(nullValueAttrTO);\n+        membershipTO.addAttribute(attributeTO(\"subscriptionDate\", null));\n \n         // add an attribute with a non-existing schema: must be ignored\n         AttributeTO attrWithInvalidSchemaTO = attributeTO(\"invalid schema\", \"a value\");\n@@ -576,7 +568,7 @@ public void createWithRequiredValueMissing() {\n \n     @Test\n     public void createWithReject() {\n-        Assume.assumeTrue(SpringContextInitializer.isActivitiConfigured());\n+        Assume.assumeTrue(SpringContextInitializer.isActivitiEnabledForUsers());\n \n         UserTO userTO = getSampleTO(\"createWithReject@syncope.apache.org\");\n \n@@ -639,7 +631,7 @@ public void createWithReject() {\n \n     @Test\n     public void createWithApproval() {\n-        Assume.assumeTrue(SpringContextInitializer.isActivitiConfigured());\n+        Assume.assumeTrue(SpringContextInitializer.isActivitiEnabledForUsers());\n \n         JdbcTemplate jdbcTemplate = new JdbcTemplate(testDataSource);\n \n@@ -786,17 +778,6 @@ public void count() {\n         assertTrue(count > 0);\n     }\n \n-    @Test\n-    public void searchCount() {\n-        AttributeCond isNullCond = new AttributeCond(AttributeCond.Type.ISNULL);\n-        isNullCond.setSchema(\"loginDate\");\n-        NodeCond searchCond = NodeCond.getLeafCond(isNullCond);\n-\n-        Integer count = restTemplate.postForObject(BASE_URL + \"user/search/count.json\", searchCond, Integer.class);\n-        assertNotNull(count);\n-        assertTrue(count > 0);\n-    }\n-\n     @Test\n     public void list() {\n         List<UserTO> users = Arrays.asList(restTemplate.getForObject(BASE_URL + \"user/list.json\", UserTO[].class));\n@@ -843,140 +824,6 @@ public void read() {\n         assertFalse(userTO.getAttributes().isEmpty());\n     }\n \n-    @Test\n-    public void search() {\n-        // LIKE\n-        AttributeCond fullnameLeafCond1 = new AttributeCond(AttributeCond.Type.LIKE);\n-        fullnameLeafCond1.setSchema(\"fullname\");\n-        fullnameLeafCond1.setExpression(\"%o%\");\n-\n-        AttributeCond fullnameLeafCond2 = new AttributeCond(AttributeCond.Type.LIKE);\n-        fullnameLeafCond2.setSchema(\"fullname\");\n-        fullnameLeafCond2.setExpression(\"%i%\");\n-\n-        NodeCond searchCondition = NodeCond.getAndCond(NodeCond.getLeafCond(fullnameLeafCond1), NodeCond.getLeafCond(\n-                fullnameLeafCond2));\n-\n-        assertTrue(searchCondition.checkValidity());\n-\n-        List<UserTO> matchedUsers = Arrays.asList(restTemplate.postForObject(BASE_URL + \"user/search\", searchCondition,\n-                UserTO[].class));\n-        assertNotNull(matchedUsers);\n-        assertFalse(matchedUsers.isEmpty());\n-        for (UserTO user : matchedUsers) {\n-            assertNotNull(user);\n-        }\n-\n-        // ISNULL\n-        AttributeCond isNullCond = new AttributeCond(AttributeCond.Type.ISNULL);\n-        isNullCond.setSchema(\"loginDate\");\n-        searchCondition = NodeCond.getLeafCond(isNullCond);\n-\n-        matchedUsers = Arrays.asList(restTemplate.postForObject(BASE_URL + \"user/search\", searchCondition,\n-                UserTO[].class));\n-        assertNotNull(matchedUsers);\n-        assertFalse(matchedUsers.isEmpty());\n-\n-        Set<Long> userIds = new HashSet<Long>(matchedUsers.size());\n-        for (UserTO user : matchedUsers) {\n-            userIds.add(user.getId());\n-        }\n-        assertTrue(userIds.contains(2L));\n-        assertTrue(userIds.contains(3L));\n-    }\n-\n-    @Test\n-    public void searchByUsernameAndId() {\n-        final SyncopeUserCond usernameLeafCond = new SyncopeUserCond(SyncopeUserCond.Type.EQ);\n-        usernameLeafCond.setSchema(\"username\");\n-        usernameLeafCond.setExpression(\"user1\");\n-\n-        final SyncopeUserCond idRightCond = new SyncopeUserCond(SyncopeUserCond.Type.LT);\n-        idRightCond.setSchema(\"id\");\n-        idRightCond.setExpression(\"2\");\n-\n-        final NodeCond searchCondition = NodeCond.getAndCond(NodeCond.getLeafCond(usernameLeafCond), NodeCond.\n-                getLeafCond(idRightCond));\n-\n-        assertTrue(searchCondition.checkValidity());\n-\n-        final List<UserTO> matchingUsers = Arrays.asList(restTemplate.postForObject(BASE_URL + \"user/search\",\n-                searchCondition, UserTO[].class));\n-\n-        assertNotNull(matchingUsers);\n-        assertEquals(1, matchingUsers.size());\n-        assertEquals(\"user1\", matchingUsers.iterator().next().getUsername());\n-        assertEquals(1L, matchingUsers.iterator().next().getId());\n-    }\n-\n-    @Test\n-    public void searchUserByResourceName() {\n-        ResourceCond ws2 = new ResourceCond();\n-        ws2.setResourceName(\"ws-target-resource2\");\n-\n-        ResourceCond ws1 = new ResourceCond();\n-        ws1.setResourceName(\"ws-target-resource-list-mappings-2\");\n-\n-        NodeCond searchCondition = NodeCond.getAndCond(NodeCond.getNotLeafCond(ws2), NodeCond.getLeafCond(ws1));\n-\n-        assertTrue(searchCondition.checkValidity());\n-\n-        List<UserTO> matchedUsers = Arrays.asList(restTemplate.postForObject(BASE_URL + \"user/search\", searchCondition,\n-                UserTO[].class));\n-        assertNotNull(matchedUsers);\n-        assertFalse(matchedUsers.isEmpty());\n-\n-        Set<Long> userIds = new HashSet<Long>(matchedUsers.size());\n-        for (UserTO user : matchedUsers) {\n-            userIds.add(user.getId());\n-        }\n-\n-        assertEquals(1, userIds.size());\n-        assertTrue(userIds.contains(2L));\n-    }\n-\n-    @Test\n-    public void paginatedSearch() {\n-        // LIKE\n-        AttributeCond fullnameLeafCond1 = new AttributeCond(AttributeCond.Type.LIKE);\n-        fullnameLeafCond1.setSchema(\"fullname\");\n-        fullnameLeafCond1.setExpression(\"%o%\");\n-\n-        AttributeCond fullnameLeafCond2 = new AttributeCond(AttributeCond.Type.LIKE);\n-        fullnameLeafCond2.setSchema(\"fullname\");\n-        fullnameLeafCond2.setExpression(\"%i%\");\n-\n-        NodeCond searchCondition = NodeCond.getAndCond(NodeCond.getLeafCond(fullnameLeafCond1), NodeCond.getLeafCond(\n-                fullnameLeafCond2));\n-\n-        assertTrue(searchCondition.checkValidity());\n-\n-        List<UserTO> matchedUsers = Arrays.asList(restTemplate.postForObject(BASE_URL + \"user/search/{page}/{size}\",\n-                searchCondition, UserTO[].class, 1, 2));\n-        assertNotNull(matchedUsers);\n-\n-        assertFalse(matchedUsers.isEmpty());\n-        for (UserTO user : matchedUsers) {\n-            assertNotNull(user);\n-        }\n-\n-        // ISNULL\n-        AttributeCond isNullCond = new AttributeCond(AttributeCond.Type.ISNULL);\n-        isNullCond.setSchema(\"loginDate\");\n-        searchCondition = NodeCond.getLeafCond(isNullCond);\n-\n-        matchedUsers = Arrays.asList(restTemplate.postForObject(BASE_URL + \"user/search/{page}/{size}\",\n-                searchCondition, UserTO[].class, 1, 2));\n-\n-        assertNotNull(matchedUsers);\n-        assertFalse(matchedUsers.isEmpty());\n-        Set<Long> userIds = new HashSet<Long>(matchedUsers.size());\n-        for (UserTO user : matchedUsers) {\n-            userIds.add(user.getId());\n-        }\n-        assertEquals(2, userIds.size());\n-    }\n-\n     @Test\n     public void updateWithouPassword() {\n         UserTO userTO = getSampleTO(\"updatewithout@password.com\");\n@@ -1222,15 +1069,14 @@ public void verifyTaskRegistration() {\n             }\n         }\n \n-        // default configuration for ws-target-resource2:\n-        //             no delete executions have to be registered\n+        // default configuration for ws-target-resource2: no delete executions have to be registered\n         // --> no more tasks/executions should be added\n         assertEquals(newMaxId, maxId);\n     }\n \n     @Test\n     public void createActivate() {\n-        Assume.assumeTrue(SpringContextInitializer.isActivitiConfigured());\n+        Assume.assumeTrue(SpringContextInitializer.isActivitiEnabledForUsers());\n \n         UserTO userTO = getSampleTO(\"createActivate@syncope.apache.org\");\n \n@@ -1258,7 +1104,7 @@ public void createActivate() {\n \n     @Test\n     public void createActivateByUsername() {\n-        Assume.assumeTrue(SpringContextInitializer.isActivitiConfigured());\n+        Assume.assumeTrue(SpringContextInitializer.isActivitiEnabledForUsers());\n \n         UserTO userTO = getSampleTO(\"createActivateByUsername@syncope.apache.org\");\n \n@@ -1296,7 +1142,7 @@ public void suspendReactivate() {\n         userTO = restTemplate.postForObject(BASE_URL + \"user/create\", userTO, UserTO.class);\n \n         assertNotNull(userTO);\n-        assertEquals(SpringContextInitializer.isActivitiConfigured() ? \"active\" : \"created\", userTO.getStatus());\n+        assertEquals(SpringContextInitializer.isActivitiEnabledForUsers() ? \"active\" : \"created\", userTO.getStatus());\n \n         userTO = restTemplate.getForObject(BASE_URL + \"user/suspend/\" + userTO.getId(), UserTO.class);\n \n@@ -1320,7 +1166,7 @@ public void suspendReactivateByUsername() {\n         userTO = restTemplate.postForObject(BASE_URL + \"user/create\", userTO, UserTO.class);\n \n         assertNotNull(userTO);\n-        assertEquals(SpringContextInitializer.isActivitiConfigured() ? \"active\" : \"created\", userTO.getStatus());\n+        assertEquals(SpringContextInitializer.isActivitiEnabledForUsers() ? \"active\" : \"created\", userTO.getStatus());\n \n         userTO = restTemplate.getForObject(\n                 BASE_URL + \"user/suspendByUsername/{username}.json\", UserTO.class, userTO.getUsername());\n@@ -1357,7 +1203,7 @@ public void suspendReactivateOnResource() {\n         userTO = restTemplate.postForObject(BASE_URL + \"user/create\", userTO, UserTO.class);\n \n         assertNotNull(userTO);\n-        assertEquals(SpringContextInitializer.isActivitiConfigured() ? \"active\" : \"created\", userTO.getStatus());\n+        assertEquals(SpringContextInitializer.isActivitiEnabledForUsers() ? \"active\" : \"created\", userTO.getStatus());\n \n         String query = \"?resourceNames=\" + dbTable.getName() + \"&resourceNames=\" + ldap.getName()\n                 + \"&performLocally=true\"; // check also performLocally\n@@ -1371,44 +1217,39 @@ public void suspendReactivateOnResource() {\n         assertNotNull(dbTableUID);\n \n         ConnObjectTO connObjectTO = restTemplate.getForObject(BASE_URL\n-                + \"/resource/{resourceName}/read/{objectId}.json\", ConnObjectTO.class, dbTable.getName(), dbTableUID);\n-\n+                + \"/resource/{resourceName}/read/USER/{objectId}.json\", ConnObjectTO.class,\n+                dbTable.getName(), dbTableUID);\n         assertFalse(Boolean.parseBoolean(connObjectTO.getAttributeMap().get(OperationalAttributes.ENABLE_NAME).\n                 getValues().\n                 get(0)));\n \n         String ldapUID = userTO.getUsername();\n         assertNotNull(ldapUID);\n \n-        connObjectTO = restTemplate.getForObject(BASE_URL + \"/resource/{resourceName}/read/{objectId}.json\",\n+        connObjectTO = restTemplate.getForObject(BASE_URL + \"/resource/{resourceName}/read/USER/{objectId}.json\",\n                 ConnObjectTO.class, ldap.getName(), ldapUID);\n-\n         assertNotNull(connObjectTO);\n \n         query = \"?resourceNames=\" + ldap.getName() + \"&performLocally=false\"; // check also performLocally\n \n         userTO = restTemplate.getForObject(BASE_URL + \"user/reactivate/\" + userTO.getId() + query, UserTO.class);\n-\n         assertNotNull(userTO);\n         assertEquals(\"suspended\", userTO.getStatus());\n \n-        connObjectTO = restTemplate.getForObject(BASE_URL + \"/resource/{resourceName}/read/{objectId}.json\",\n+        connObjectTO = restTemplate.getForObject(BASE_URL + \"/resource/{resourceName}/read/USER/{objectId}.json\",\n                 ConnObjectTO.class, dbTable.getName(), dbTableUID);\n-\n         assertFalse(Boolean.parseBoolean(connObjectTO.getAttributeMap().get(OperationalAttributes.ENABLE_NAME).\n                 getValues().\n                 get(0)));\n \n         query = \"?resourceNames=\" + dbTable.getName() + \"&performLocally=true\"; // check also performLocally\n \n         userTO = restTemplate.getForObject(BASE_URL + \"user/reactivate/\" + userTO.getId() + query, UserTO.class);\n-\n         assertNotNull(userTO);\n         assertEquals(\"active\", userTO.getStatus());\n \n-        connObjectTO = restTemplate.getForObject(BASE_URL + \"/resource/{resourceName}/read/{objectId}.json\",\n+        connObjectTO = restTemplate.getForObject(BASE_URL + \"/resource/{resourceName}/read/USER/{objectId}.json\",\n                 ConnObjectTO.class, dbTable.getName(), dbTableUID);\n-\n         assertTrue(Boolean.parseBoolean(connObjectTO.getAttributeMap().get(OperationalAttributes.ENABLE_NAME).\n                 getValues().\n                 get(0)));\n@@ -1616,11 +1457,9 @@ public void roleAttrPropagation() {\n         assertNotNull(actual.getDerivedAttributeMap().get(\"csvuserid\"));\n \n         ConnObjectTO connObjectTO = restTemplate.getForObject(BASE_URL\n-                + \"/resource/{resourceName}/read/{objectId}.json\", ConnObjectTO.class, \"resource-csv\", actual.\n-                getDerivedAttributeMap().get(\"csvuserid\").getValues().get(0));\n-\n+                + \"/resource/{resourceName}/read/USER/{objectId}.json\", ConnObjectTO.class, \"resource-csv\",\n+                actual.getDerivedAttributeMap().get(\"csvuserid\").getValues().get(0));\n         assertNotNull(connObjectTO);\n-\n         assertEquals(\"sx-dx\", connObjectTO.getAttributeMap().get(\"ROLE\").getValues().get(0));\n     }\n \n@@ -1635,18 +1474,11 @@ public void membershipAttrPropagation() {\n \n         MembershipTO membershipTO = new MembershipTO();\n         membershipTO.setRoleId(1L);\n-\n-        AttributeTO mderived_sx = new AttributeTO();\n-        mderived_sx.setSchema(\"mderived_sx\");\n-        mderived_sx.setValues(Collections.singletonList(\"sx\"));\n-        membershipTO.addAttribute(mderived_sx);\n-\n-        AttributeTO mderived_dx = new AttributeTO();\n-        mderived_dx.setSchema(\"mderived_dx\");\n-        mderived_dx.setValues(Collections.singletonList(\"dx\"));\n-        membershipTO.addAttribute(mderived_dx);\n+        membershipTO.addAttribute(attributeTO(\"mderived_sx\", \"sx\"));\n+        membershipTO.addAttribute(attributeTO(\"mderived_dx\", \"dx\"));\n         membershipTO.addDerivedAttribute(attributeTO(\"mderToBePropagated\", null));\n         userTO.addMembership(membershipTO);\n+\n         userTO.addResource(\"resource-csv\");\n \n         UserTO actual = restTemplate.postForObject(BASE_URL + \"user/create\", userTO, UserTO.class);\n@@ -1655,11 +1487,9 @@ public void membershipAttrPropagation() {\n         assertNotNull(actual.getDerivedAttributeMap().get(\"csvuserid\"));\n \n         ConnObjectTO connObjectTO = restTemplate.getForObject(BASE_URL\n-                + \"/resource/{resourceName}/read/{objectId}.json\", ConnObjectTO.class, \"resource-csv\", actual.\n-                getDerivedAttributeMap().get(\"csvuserid\").getValues().get(0));\n-\n+                + \"/resource/{resourceName}/read/USER/{objectId}.json\", ConnObjectTO.class, \"resource-csv\",\n+                actual.getDerivedAttributeMap().get(\"csvuserid\").getValues().get(0));\n         assertNotNull(connObjectTO);\n-\n         assertEquals(\"sx-dx\", connObjectTO.getAttributeMap().get(\"MEMBERSHIP\").getValues().get(0));\n     }\n \n@@ -1723,9 +1553,8 @@ public void issueSYNCOPE108() {\n         assertEquals(1, actual.getResources().size());\n \n         ConnObjectTO connObjectTO = restTemplate.getForObject(BASE_URL\n-                + \"/resource/{resourceName}/read/{objectId}.json\", ConnObjectTO.class, \"resource-csv\", actual.\n-                getDerivedAttributeMap().get(\"csvuserid\").getValues().get(0));\n-\n+                + \"/resource/{resourceName}/read/USER/{objectId}.json\", ConnObjectTO.class, \"resource-csv\",\n+                actual.getDerivedAttributeMap().get(\"csvuserid\").getValues().get(0));\n         assertNotNull(connObjectTO);\n \n         // -----------------------------------\n@@ -1741,9 +1570,8 @@ public void issueSYNCOPE108() {\n         assertEquals(1, actual.getMemberships().size());\n \n         connObjectTO = restTemplate.getForObject(BASE_URL\n-                + \"/resource/{resourceName}/read/{objectId}.json\", ConnObjectTO.class, \"resource-csv\",\n+                + \"/resource/{resourceName}/read/USER/{objectId}.json\", ConnObjectTO.class, \"resource-csv\",\n                 actual.getDerivedAttributeMap().get(\"csvuserid\").getValues().get(0));\n-\n         assertNotNull(connObjectTO);\n         // -----------------------------------\n \n@@ -1761,9 +1589,8 @@ public void issueSYNCOPE108() {\n         assertFalse(actual.getResources().isEmpty());\n \n         connObjectTO = restTemplate.getForObject(BASE_URL\n-                + \"/resource/{resourceName}/read/{objectId}.json\", ConnObjectTO.class, \"resource-csv\", actual.\n-                getDerivedAttributeMap().get(\"csvuserid\").getValues().get(0));\n-\n+                + \"/resource/{resourceName}/read/USER/{objectId}.json\", ConnObjectTO.class, \"resource-csv\",\n+                actual.getDerivedAttributeMap().get(\"csvuserid\").getValues().get(0));\n         assertNotNull(connObjectTO);\n         // -----------------------------------\n \n@@ -1784,8 +1611,8 @@ public void issueSYNCOPE108() {\n \n         try {\n             restTemplate.getForObject(BASE_URL\n-                    + \"/resource/{resourceName}/read/{objectId}.json\", ConnObjectTO.class, \"resource-csv\", actual.\n-                    getDerivedAttributeMap().get(\"csvuserid\").getValues().get(0));\n+                    + \"/resource/{resourceName}/read/USER/{objectId}.json\", ConnObjectTO.class, \"resource-csv\",\n+                    actual.getDerivedAttributeMap().get(\"csvuserid\").getValues().get(0));\n         } catch (SyncopeClientCompositeErrorException e) {\n             assertNotNull(e.getException(SyncopeClientExceptionType.NotFound));\n             t = e;\n@@ -1820,11 +1647,10 @@ public void issueSYNCOPE111() {\n         assertEquals(2, actual.getMemberships().size());\n \n         ConnObjectTO connObjectTO = restTemplate.getForObject(\n-                BASE_URL + \"/resource/{resourceName}/read/{objectId}.json\",\n+                BASE_URL + \"/resource/{resourceName}/read/USER/{objectId}.json\",\n                 ConnObjectTO.class,\n                 \"resource-ldap\",\n                 userTO.getUsername());\n-\n         assertNotNull(connObjectTO);\n \n         AttributeTO postalAddress = connObjectTO.getAttributeMap().get(\"postalAddress\");\n@@ -1853,11 +1679,10 @@ public void issueSYNCOPE111() {\n         assertEquals(1, actual.getMemberships().size());\n \n         connObjectTO = restTemplate.getForObject(\n-                BASE_URL + \"/resource/{resourceName}/read/{objectId}.json\",\n+                BASE_URL + \"/resource/{resourceName}/read/USER/{objectId}.json\",\n                 ConnObjectTO.class,\n                 \"resource-ldap\",\n                 userTO.getUsername());\n-\n         assertNotNull(connObjectTO);\n \n         postalAddress = connObjectTO.getAttributeMap().get(\"postalAddress\");\n@@ -1890,13 +1715,11 @@ public void issueSYNCOPE185() {\n         // 3. try (and fail) to find this user on the external LDAP resource\n         SyncopeClientException sce = null;\n         try {\n-            restTemplate.getForObject(\n-                    BASE_URL + \"/resource/{resourceName}/read/{objectId}.json\",\n+            restTemplate.getForObject(BASE_URL + \"/resource/{resourceName}/read/USER/{objectId}.json\",\n                     ConnObjectTO.class, \"resource-ldap\", userTO.getUsername());\n             fail(\"This entry should not be present on this resource\");\n         } catch (SyncopeClientCompositeErrorException sccee) {\n             sce = sccee.getException(SyncopeClientExceptionType.NotFound);\n-\n         }\n         assertNotNull(sce);\n     }"},{"sha":"d75098e7e8492e314e065d8d29c891d7dc86eca2","filename":"core/src/test/resources/content.xml","status":"modified","additions":240,"deletions":230,"changes":470,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Ftest%2Fresources%2Fcontent.xml","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Ftest%2Fresources%2Fcontent.xml","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Ftest%2Fresources%2Fcontent.xml?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623"},{"sha":"4942f1502a8cecc6e3166dcff60e31841ad85da6","filename":"core/src/test/resources/noopworkflow/workflow.properties","status":"modified","additions":3,"deletions":2,"changes":5,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Ftest%2Fresources%2Fnoopworkflow%2Fworkflow.properties","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Ftest%2Fresources%2Fnoopworkflow%2Fworkflow.properties","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Ftest%2Fresources%2Fnoopworkflow%2Fworkflow.properties?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -14,5 +14,6 @@\n # KIND, either express or implied.  See the License for the\n # specific language governing permissions and limitations\n # under the License.\n-wfAdapter=org.apache.syncope.core.workflow.NoOpUserWorkflowAdapter\n-jobExecutorActivate=false\n\\ No newline at end of file\n+uwfAdapter=org.apache.syncope.core.workflow.user.NoOpUserWorkflowAdapter\n+rwfAdapter=org.apache.syncope.core.workflow.role.NoOpRoleWorkflowAdapter\n+jobExecutorActivate=false"},{"sha":"840e134bdc9fa1e1cc49d9e445f7b1d11322d40b","filename":"core/src/test/resources/noopworkflow/workflowContext.xml","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Ftest%2Fresources%2Fnoopworkflow%2FworkflowContext.xml","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Ftest%2Fresources%2Fnoopworkflow%2FworkflowContext.xml","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Ftest%2Fresources%2Fnoopworkflow%2FworkflowContext.xml?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -27,7 +27,7 @@ under the License.\n     <constructor-arg value=\"${adminUser}\"/>\n   </bean>\n     \n-  <bean id=\"wfAdapter\" class=\"${wfAdapter}\"/>\n+  <bean id=\"uwfAdapter\" class=\"${uwfAdapter}\"/>\n \n   <bean id=\"velocityEngine\" class=\"org.springframework.ui.velocity.VelocityEngineFactoryBean\">\n     <property name=\"velocityProperties\">"},{"sha":"05cfa04468cbcf970023e701eaf413d826d41ac8","filename":"core/src/test/resources/workflow.properties","status":"modified","additions":3,"deletions":2,"changes":5,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Ftest%2Fresources%2Fworkflow.properties","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/core%2Fsrc%2Ftest%2Fresources%2Fworkflow.properties","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Ftest%2Fresources%2Fworkflow.properties?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -14,5 +14,6 @@\n # KIND, either express or implied.  See the License for the\n # specific language governing permissions and limitations\n # under the License.\n-wfAdapter=org.apache.syncope.core.workflow.ActivitiUserWorkflowAdapter\n-jobExecutorActivate=false\n\\ No newline at end of file\n+uwfAdapter=org.apache.syncope.core.workflow.user.activiti.ActivitiUserWorkflowAdapter\n+rwfAdapter=org.apache.syncope.core.workflow.role.NoOpRoleWorkflowAdapter\n+jobExecutorActivate=false"},{"sha":"24754f9329d8c163e4da45dc21cf2727b3eab8ab","filename":"pom.xml","status":"modified","additions":3,"deletions":3,"changes":6,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/pom.xml","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/384ed3f2864467b061df7a91f6dd3f0dc4e8e623/pom.xml","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/pom.xml?ref=384ed3f2864467b061df7a91f6dd3f0dc4e8e623","patch":"@@ -27,7 +27,7 @@ under the License.\n         \n   <groupId>org.apache.syncope</groupId>\n   <artifactId>syncope</artifactId>\n-  <version>1.1.0-SNAPSHOT</version>\n+  <version>1.1.0-RP-SNAPSHOT</version>\n   <packaging>pom</packaging>\n \n   <parent>\n@@ -261,7 +261,7 @@ under the License.\n     <connid.soap.version>1.2.3</connid.soap.version>\n     <connid.db.table.version>2.1.4</connid.db.table.version>\n     <connid.csvdir.version>0.5</connid.csvdir.version>\n-    <connid.ldap.version>1.3.3</connid.ldap.version>\n+    <connid.ldap.version>1.3.4</connid.ldap.version>\n \n     <commons-jexl.version>2.1.1</commons-jexl.version>\n     <commons-lang.version>2.6</commons-lang.version>\n@@ -741,7 +741,7 @@ under the License.\n       <id>activiti</id>\n       <url>https://artifacts.alfresco.com/nexus/content/groups/public/</url>\n     </repository>\n-\n+    \n   </repositories>\n \n   <build>"}]}