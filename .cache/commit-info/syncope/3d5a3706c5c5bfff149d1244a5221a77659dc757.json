{"sha":"3d5a3706c5c5bfff149d1244a5221a77659dc757","node_id":"MDY6Q29tbWl0NjM2ODc5MDYyOjNkNWEzNzA2YzVjNWJmZmYxNDlkMTI0NGE1MjIxYTc3NjU5ZGM3NTc=","commit":{"author":{"name":"Marco Di Sabatino Di Diodoro","email":"mdisabatino@apache.org","date":"2014-11-10T10:48:08Z"},"committer":{"name":"Marco Di Sabatino Di Diodoro","email":"mdisabatino@apache.org","date":"2014-11-10T10:48:08Z"},"message":"[SYNCOPE-601]","tree":{"sha":"a5b209056f4c333a1b28ea4f6cf43416a4bd1d2e","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/git/trees/a5b209056f4c333a1b28ea4f6cf43416a4bd1d2e"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/git/commits/3d5a3706c5c5bfff149d1244a5221a77659dc757","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/3d5a3706c5c5bfff149d1244a5221a77659dc757","html_url":"https://github.com/EnricoDAlessandro97UNI/syncope/commit/3d5a3706c5c5bfff149d1244a5221a77659dc757","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/3d5a3706c5c5bfff149d1244a5221a77659dc757/comments","author":{"login":"mdisabatino","id":1792527,"node_id":"MDQ6VXNlcjE3OTI1Mjc=","avatar_url":"https://avatars.githubusercontent.com/u/1792527?v=4","gravatar_id":"","url":"https://api.github.com/users/mdisabatino","html_url":"https://github.com/mdisabatino","followers_url":"https://api.github.com/users/mdisabatino/followers","following_url":"https://api.github.com/users/mdisabatino/following{/other_user}","gists_url":"https://api.github.com/users/mdisabatino/gists{/gist_id}","starred_url":"https://api.github.com/users/mdisabatino/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mdisabatino/subscriptions","organizations_url":"https://api.github.com/users/mdisabatino/orgs","repos_url":"https://api.github.com/users/mdisabatino/repos","events_url":"https://api.github.com/users/mdisabatino/events{/privacy}","received_events_url":"https://api.github.com/users/mdisabatino/received_events","type":"User","site_admin":false},"committer":{"login":"mdisabatino","id":1792527,"node_id":"MDQ6VXNlcjE3OTI1Mjc=","avatar_url":"https://avatars.githubusercontent.com/u/1792527?v=4","gravatar_id":"","url":"https://api.github.com/users/mdisabatino","html_url":"https://github.com/mdisabatino","followers_url":"https://api.github.com/users/mdisabatino/followers","following_url":"https://api.github.com/users/mdisabatino/following{/other_user}","gists_url":"https://api.github.com/users/mdisabatino/gists{/gist_id}","starred_url":"https://api.github.com/users/mdisabatino/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mdisabatino/subscriptions","organizations_url":"https://api.github.com/users/mdisabatino/orgs","repos_url":"https://api.github.com/users/mdisabatino/repos","events_url":"https://api.github.com/users/mdisabatino/events{/privacy}","received_events_url":"https://api.github.com/users/mdisabatino/received_events","type":"User","site_admin":false},"parents":[{"sha":"296ffa369f50f31ccef85078a60daeb8c16ff912","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/296ffa369f50f31ccef85078a60daeb8c16ff912","html_url":"https://github.com/EnricoDAlessandro97UNI/syncope/commit/296ffa369f50f31ccef85078a60daeb8c16ff912"}],"stats":{"total":130,"additions":72,"deletions":58},"files":[{"sha":"f2cb5bd99c83702283d8a79d3419821f84d12509","filename":"core/src/main/java/org/apache/syncope/core/sync/impl/SyncopeSyncResultHandler.java","status":"modified","additions":72,"deletions":58,"changes":130,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/3d5a3706c5c5bfff149d1244a5221a77659dc757/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fsync%2Fimpl%2FSyncopeSyncResultHandler.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/3d5a3706c5c5bfff149d1244a5221a77659dc757/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fsync%2Fimpl%2FSyncopeSyncResultHandler.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fsync%2Fimpl%2FSyncopeSyncResultHandler.java?ref=3d5a3706c5c5bfff149d1244a5221a77659dc757","patch":"@@ -392,10 +392,15 @@ protected List<Long> findByAttributableSearch(\n         for (String schema : altSearchSchemas) {\n             Attribute value = extValues.get(schema);\n \n+            if (value == null) {\n+                throw new IllegalArgumentException(\n+                        \"Connector object does not contains the attributes to perform the search: \" + schema);\n+            }\n+\n             AttributeCond.Type type;\n             String expression = null;\n \n-            if (value == null || value.getValue() == null || value.getValue().isEmpty()\n+            if (value.getValue() == null || value.getValue().isEmpty()\n                     || (value.getValue().size() == 1 && value.getValue().get(0) == null)) {\n                 type = AttributeCond.Type.ISNULL;\n             } else {\n@@ -487,15 +492,19 @@ public Long findMatchingAttributableId(final ObjectClass objectClass, final Stri\n             }\n \n             ConnectorObject connObj = found.iterator().next();\n-            final List<Long> subjectIds = findExisting(connObj.getUid().getUidValue(), connObj, attrUtil);\n-            if (subjectIds.isEmpty()) {\n-                LOG.debug(\"No matching {} found for {}, aborting\", attrUtil.getType(), connObj);\n-            } else {\n-                if (subjectIds.size() > 1) {\n-                    LOG.warn(\"More than one {} found {} - taking first only\", attrUtil.getType(), subjectIds);\n-                }\n+            try {\n+                final List<Long> subjectIds = findExisting(connObj.getUid().getUidValue(), connObj, attrUtil);\n+                if (subjectIds.isEmpty()) {\n+                    LOG.debug(\"No matching {} found for {}, aborting\", attrUtil.getType(), connObj);\n+                } else {\n+                    if (subjectIds.size() > 1) {\n+                        LOG.warn(\"More than one {} found {} - taking first only\", attrUtil.getType(), subjectIds);\n+                    }\n \n-                result = subjectIds.iterator().next();\n+                    result = subjectIds.iterator().next();\n+                }\n+            } catch (IllegalArgumentException e) {\n+                LOG.warn(e.getMessage());\n             }\n         }\n \n@@ -951,63 +960,68 @@ protected final void doHandle(final SyncDelta delta)\n         final String uid = delta.getPreviousUid() == null\n                 ? delta.getUid().getUidValue()\n                 : delta.getPreviousUid().getUidValue();\n-        final List<Long> subjectIds = findExisting(uid, delta.getObject(), attrUtil);\n \n-        if (SyncDeltaType.CREATE_OR_UPDATE == delta.getDeltaType()) {\n-            if (subjectIds.isEmpty()) {\n-                results.addAll(create(delta, attrUtil, dryRun));\n-            } else if (subjectIds.size() == 1) {\n-                results.addAll(update(delta, subjectIds.subList(0, 1), attrUtil, dryRun));\n-            } else {\n-                switch (resAct) {\n-                    case IGNORE:\n-                        LOG.error(\"More than one match {}\", subjectIds);\n-                        break;\n+        try {\n+            final List<Long> subjectIds = findExisting(uid, delta.getObject(), attrUtil);\n+\n+            if (SyncDeltaType.CREATE_OR_UPDATE == delta.getDeltaType()) {\n+                if (subjectIds.isEmpty()) {\n+                    results.addAll(create(delta, attrUtil, dryRun));\n+                } else if (subjectIds.size() == 1) {\n+                    results.addAll(update(delta, subjectIds.subList(0, 1), attrUtil, dryRun));\n+                } else {\n+                    switch (resAct) {\n+                        case IGNORE:\n+                            LOG.error(\"More than one match {}\", subjectIds);\n+                            break;\n \n-                    case FIRSTMATCH:\n-                        results.addAll(update(delta, subjectIds.subList(0, 1), attrUtil, dryRun));\n-                        break;\n+                        case FIRSTMATCH:\n+                            results.addAll(update(delta, subjectIds.subList(0, 1), attrUtil, dryRun));\n+                            break;\n \n-                    case LASTMATCH:\n-                        results.addAll(update(delta, subjectIds.subList(subjectIds.size() - 1, subjectIds.size()),\n-                                attrUtil, dryRun));\n-                        break;\n+                        case LASTMATCH:\n+                            results.addAll(update(delta, subjectIds.subList(subjectIds.size() - 1, subjectIds.size()),\n+                                    attrUtil, dryRun));\n+                            break;\n \n-                    case ALL:\n-                        results.addAll(update(delta, subjectIds, attrUtil, dryRun));\n-                        break;\n+                        case ALL:\n+                            results.addAll(update(delta, subjectIds, attrUtil, dryRun));\n+                            break;\n \n-                    default:\n+                        default:\n+                    }\n                 }\n-            }\n-        } else if (SyncDeltaType.DELETE == delta.getDeltaType()) {\n-            if (subjectIds.isEmpty()) {\n-                LOG.debug(\"No match found for deletion\");\n-            } else if (subjectIds.size() == 1) {\n-                results.addAll(delete(delta, subjectIds, attrUtil, dryRun));\n-            } else {\n-                switch (resAct) {\n-                    case IGNORE:\n-                        LOG.error(\"More than one match {}\", subjectIds);\n-                        break;\n-\n-                    case FIRSTMATCH:\n-                        results.addAll(delete(delta, subjectIds.subList(0, 1), attrUtil, dryRun));\n-                        break;\n-\n-                    case LASTMATCH:\n-                        results.addAll(delete(delta, subjectIds.subList(subjectIds.size() - 1, subjectIds.size()),\n-                                attrUtil,\n-                                dryRun));\n-                        break;\n-\n-                    case ALL:\n-                        results.addAll(delete(delta, subjectIds, attrUtil, dryRun));\n-                        break;\n-\n-                    default:\n+            } else if (SyncDeltaType.DELETE == delta.getDeltaType()) {\n+                if (subjectIds.isEmpty()) {\n+                    LOG.debug(\"No match found for deletion\");\n+                } else if (subjectIds.size() == 1) {\n+                    results.addAll(delete(delta, subjectIds, attrUtil, dryRun));\n+                } else {\n+                    switch (resAct) {\n+                        case IGNORE:\n+                            LOG.error(\"More than one match {}\", subjectIds);\n+                            break;\n+\n+                        case FIRSTMATCH:\n+                            results.addAll(delete(delta, subjectIds.subList(0, 1), attrUtil, dryRun));\n+                            break;\n+\n+                        case LASTMATCH:\n+                            results.addAll(delete(delta, subjectIds.subList(subjectIds.size() - 1, subjectIds.size()),\n+                                    attrUtil,\n+                                    dryRun));\n+                            break;\n+\n+                        case ALL:\n+                            results.addAll(delete(delta, subjectIds, attrUtil, dryRun));\n+                            break;\n+\n+                        default:\n+                    }\n                 }\n             }\n+        } catch (IllegalArgumentException e) {\n+            LOG.warn(e.getMessage());\n         }\n     }\n }"}]}