{"sha":"501375b0f8b2d060e86539ef629d66bcf2e79aa3","node_id":"MDY6Q29tbWl0NjM2ODc5MDYyOjUwMTM3NWIwZjhiMmQwNjBlODY1MzllZjYyOWQ2NmJjZjJlNzlhYTM=","commit":{"author":{"name":"Francesco Chicchiriccò","email":"ilgrosso@apache.org","date":"2020-11-05T10:44:53Z"},"committer":{"name":"Francesco Chicchiriccò","email":"ilgrosso@apache.org","date":"2020-11-05T11:14:19Z"},"message":"[SYNCOPE-1598] Raise error in case of 2+ memberships for same group","tree":{"sha":"a3214b7e5f757ee455d6cfb4fcebecfcb3537f05","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/git/trees/a3214b7e5f757ee455d6cfb4fcebecfcb3537f05"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/git/commits/501375b0f8b2d060e86539ef629d66bcf2e79aa3","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/501375b0f8b2d060e86539ef629d66bcf2e79aa3","html_url":"https://github.com/EnricoDAlessandro97UNI/syncope/commit/501375b0f8b2d060e86539ef629d66bcf2e79aa3","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/501375b0f8b2d060e86539ef629d66bcf2e79aa3/comments","author":{"login":"ilgrosso","id":1064664,"node_id":"MDQ6VXNlcjEwNjQ2NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/1064664?v=4","gravatar_id":"","url":"https://api.github.com/users/ilgrosso","html_url":"https://github.com/ilgrosso","followers_url":"https://api.github.com/users/ilgrosso/followers","following_url":"https://api.github.com/users/ilgrosso/following{/other_user}","gists_url":"https://api.github.com/users/ilgrosso/gists{/gist_id}","starred_url":"https://api.github.com/users/ilgrosso/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ilgrosso/subscriptions","organizations_url":"https://api.github.com/users/ilgrosso/orgs","repos_url":"https://api.github.com/users/ilgrosso/repos","events_url":"https://api.github.com/users/ilgrosso/events{/privacy}","received_events_url":"https://api.github.com/users/ilgrosso/received_events","type":"User","site_admin":false},"committer":{"login":"ilgrosso","id":1064664,"node_id":"MDQ6VXNlcjEwNjQ2NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/1064664?v=4","gravatar_id":"","url":"https://api.github.com/users/ilgrosso","html_url":"https://github.com/ilgrosso","followers_url":"https://api.github.com/users/ilgrosso/followers","following_url":"https://api.github.com/users/ilgrosso/following{/other_user}","gists_url":"https://api.github.com/users/ilgrosso/gists{/gist_id}","starred_url":"https://api.github.com/users/ilgrosso/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ilgrosso/subscriptions","organizations_url":"https://api.github.com/users/ilgrosso/orgs","repos_url":"https://api.github.com/users/ilgrosso/repos","events_url":"https://api.github.com/users/ilgrosso/events{/privacy}","received_events_url":"https://api.github.com/users/ilgrosso/received_events","type":"User","site_admin":false},"parents":[{"sha":"6798f7155e8cf2af6df4b2c7a847185eb34637ac","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/6798f7155e8cf2af6df4b2c7a847185eb34637ac","html_url":"https://github.com/EnricoDAlessandro97UNI/syncope/commit/6798f7155e8cf2af6df4b2c7a847185eb34637ac"}],"stats":{"total":259,"additions":195,"deletions":64},"files":[{"sha":"709d4ab5c0f8e9cb1d9e0c9fb97a99669c5c219d","filename":"core/provisioning-java/src/main/java/org/apache/syncope/core/provisioning/java/data/AnyObjectDataBinderImpl.java","status":"modified","additions":109,"deletions":64,"changes":173,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/501375b0f8b2d060e86539ef629d66bcf2e79aa3/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fdata%2FAnyObjectDataBinderImpl.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/501375b0f8b2d060e86539ef629d66bcf2e79aa3/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fdata%2FAnyObjectDataBinderImpl.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fdata%2FAnyObjectDataBinderImpl.java?ref=501375b0f8b2d060e86539ef629d66bcf2e79aa3","patch":"@@ -162,77 +162,96 @@ public void create(final AnyObject anyObject, final AnyObjectCR anyObjectCR) {\n         }\n         anyObject.setRealm(realm);\n \n-        AnyUtils anyUtils = anyUtilsFactory.getInstance(AnyTypeKind.ANY_OBJECT);\n-        if (anyObject.getRealm() != null) {\n-            // relationships\n-            anyObjectCR.getRelationships().forEach(relationshipTO -> {\n-                if (StringUtils.isBlank(relationshipTO.getOtherEndType())\n-                        || AnyTypeKind.USER.name().equals(relationshipTO.getOtherEndType())\n-                        || AnyTypeKind.GROUP.name().equals(relationshipTO.getOtherEndType())) {\n-\n-                    SyncopeClientException invalidAnyType =\n-                            SyncopeClientException.build(ClientExceptionType.InvalidAnyType);\n-                    invalidAnyType.getElements().add(AnyType.class.getSimpleName()\n-                            + \" not allowed for relationship: \" + relationshipTO.getOtherEndType());\n-                    scce.addException(invalidAnyType);\n-                } else {\n-                    AnyObject otherEnd = anyObjectDAO.find(relationshipTO.getOtherEndKey());\n-                    if (otherEnd == null) {\n-                        LOG.debug(\"Ignoring invalid anyObject \" + relationshipTO.getOtherEndKey());\n-                    } else if (anyObject.getRealm().getFullPath().startsWith(otherEnd.getRealm().getFullPath())) {\n-                        RelationshipType relationshipType = relationshipTypeDAO.find(relationshipTO.getType());\n-                        if (relationshipType == null) {\n-                            LOG.debug(\"Ignoring invalid relationship type {}\", relationshipTO.getType());\n-                        } else {\n-                            ARelationship relationship = entityFactory.newEntity(ARelationship.class);\n-                            relationship.setType(relationshipType);\n-                            relationship.setRightEnd(otherEnd);\n-                            relationship.setLeftEnd(anyObject);\n-\n-                            anyObject.add(relationship);\n-                        }\n+        // relationships\n+        Set<Pair<String, String>> relationships = new HashSet<>();\n+        anyObjectCR.getRelationships().forEach(relationshipTO -> {\n+            if (StringUtils.isBlank(relationshipTO.getOtherEndType())\n+                    || AnyTypeKind.USER.name().equals(relationshipTO.getOtherEndType())\n+                    || AnyTypeKind.GROUP.name().equals(relationshipTO.getOtherEndType())) {\n+\n+                SyncopeClientException invalidAnyType =\n+                        SyncopeClientException.build(ClientExceptionType.InvalidAnyType);\n+                invalidAnyType.getElements().add(AnyType.class.getSimpleName()\n+                        + \" not allowed for relationship: \" + relationshipTO.getOtherEndType());\n+                scce.addException(invalidAnyType);\n+            } else {\n+                AnyObject otherEnd = anyObjectDAO.find(relationshipTO.getOtherEndKey());\n+                if (otherEnd == null) {\n+                    LOG.debug(\"Ignoring invalid anyObject \" + relationshipTO.getOtherEndKey());\n+                } else if (relationships.contains(Pair.of(otherEnd.getKey(), relationshipTO.getType()))) {\n+                    LOG.error(\"{} was already in relationship {} with {}\",\n+                            otherEnd, relationshipTO.getType(), anyObject);\n+\n+                    SyncopeClientException assigned =\n+                            SyncopeClientException.build(ClientExceptionType.InvalidRelationship);\n+                    assigned.getElements().add(otherEnd.getType().getKey() + \" \" + otherEnd.getName()\n+                            + \" in relationship \" + relationshipTO.getType());\n+                    scce.addException(assigned);\n+                } else if (anyObject.getRealm().getFullPath().startsWith(otherEnd.getRealm().getFullPath())) {\n+                    relationships.add(Pair.of(otherEnd.getKey(), relationshipTO.getType()));\n+\n+                    RelationshipType relationshipType = relationshipTypeDAO.find(relationshipTO.getType());\n+                    if (relationshipType == null) {\n+                        LOG.debug(\"Ignoring invalid relationship type {}\", relationshipTO.getType());\n                     } else {\n-                        LOG.error(\"{} cannot be related to {}\", otherEnd, anyObject);\n+                        ARelationship relationship = entityFactory.newEntity(ARelationship.class);\n+                        relationship.setType(relationshipType);\n+                        relationship.setRightEnd(otherEnd);\n+                        relationship.setLeftEnd(anyObject);\n \n-                        SyncopeClientException unrelatable =\n-                                SyncopeClientException.build(ClientExceptionType.InvalidRelationship);\n-                        unrelatable.getElements().add(otherEnd.getType().getKey() + \" \" + otherEnd.getName()\n-                                + \" cannot be related\");\n-                        scce.addException(unrelatable);\n+                        anyObject.add(relationship);\n                     }\n-                }\n-            });\n-\n-            // memberships\n-            anyObjectCR.getMemberships().forEach(membershipTO -> {\n-                Group group = membershipTO.getGroupKey() == null\n-                        ? groupDAO.findByName(membershipTO.getGroupName())\n-                        : groupDAO.find(membershipTO.getGroupKey());\n-                if (group == null) {\n-                    LOG.debug(\"Ignoring invalid group \"\n-                            + membershipTO.getGroupKey() + \" / \" + membershipTO.getGroupName());\n-                } else if (anyObject.getRealm().getFullPath().startsWith(group.getRealm().getFullPath())) {\n-                    AMembership membership = entityFactory.newEntity(AMembership.class);\n-                    membership.setRightEnd(group);\n-                    membership.setLeftEnd(anyObject);\n-\n-                    anyObject.add(membership);\n-\n-                    // membership attributes\n-                    fill(anyObject, membership, membershipTO, anyUtils, scce);\n                 } else {\n-                    LOG.error(\"{} cannot be assigned to {}\", group, anyObject);\n+                    LOG.error(\"{} cannot be related to {}\", otherEnd, anyObject);\n \n-                    SyncopeClientException unassignable =\n-                            SyncopeClientException.build(ClientExceptionType.InvalidMembership);\n-                    unassignable.getElements().add(\"Group \" + group.getName() + \" cannot be assigned\");\n-                    scce.addException(unassignable);\n+                    SyncopeClientException unrelatable =\n+                            SyncopeClientException.build(ClientExceptionType.InvalidRelationship);\n+                    unrelatable.getElements().add(otherEnd.getType().getKey() + \" \" + otherEnd.getName()\n+                            + \" cannot be related\");\n+                    scce.addException(unrelatable);\n                 }\n-            });\n-        }\n+            }\n+        });\n+\n+        // memberships\n+        Set<String> groups = new HashSet<>();\n+        anyObjectCR.getMemberships().forEach(membershipTO -> {\n+            Group group = membershipTO.getGroupKey() == null\n+                    ? groupDAO.findByName(membershipTO.getGroupName())\n+                    : groupDAO.find(membershipTO.getGroupKey());\n+            if (group == null) {\n+                LOG.debug(\"Ignoring invalid group \"\n+                        + membershipTO.getGroupKey() + \" / \" + membershipTO.getGroupName());\n+            } else if (groups.contains(group.getKey())) {\n+                LOG.error(\"{} was already assigned to {}\", group, anyObject);\n+\n+                SyncopeClientException assigned =\n+                        SyncopeClientException.build(ClientExceptionType.InvalidMembership);\n+                assigned.getElements().add(\"Group \" + group.getName() + \" was already assigned\");\n+                scce.addException(assigned);\n+            } else if (anyObject.getRealm().getFullPath().startsWith(group.getRealm().getFullPath())) {\n+                groups.add(group.getKey());\n+\n+                AMembership membership = entityFactory.newEntity(AMembership.class);\n+                membership.setRightEnd(group);\n+                membership.setLeftEnd(anyObject);\n+\n+                anyObject.add(membership);\n+\n+                // membership attributes\n+                fill(anyObject, membership, membershipTO, anyUtilsFactory.getInstance(AnyTypeKind.ANY_OBJECT), scce);\n+            } else {\n+                LOG.error(\"{} cannot be assigned to {}\", group, anyObject);\n+\n+                SyncopeClientException unassignable =\n+                        SyncopeClientException.build(ClientExceptionType.InvalidMembership);\n+                unassignable.getElements().add(\"Group \" + group.getName() + \" cannot be assigned\");\n+                scce.addException(unassignable);\n+            }\n+        });\n \n         // attributes and resources\n-        fill(anyObject, anyObjectCR, anyUtils, scce);\n+        fill(anyObject, anyObjectCR, anyUtilsFactory.getInstance(AnyTypeKind.ANY_OBJECT), scce);\n \n         // Throw composite exception if there is at least one element set in the composing exceptions\n         if (scce.hasExceptions()) {\n@@ -270,8 +289,10 @@ public PropagationByResource<String> update(final AnyObject toBeUpdated, final A\n         propByRes.merge(fill(anyObject, anyObjectUR, anyUtils, scce));\n \n         // relationships\n+        Set<Pair<String, String>> relationships = new HashSet<>();\n         anyObjectUR.getRelationships().stream().\n-                filter(patch -> patch.getRelationshipTO() != null).forEachOrdered((patch) -> {\n+                filter(patch -> patch.getRelationshipTO() != null).forEach(patch -> {\n+\n             RelationshipType relationshipType = relationshipTypeDAO.find(patch.getRelationshipTO().getType());\n             if (relationshipType == null) {\n                 LOG.debug(\"Ignoring invalid relationship type {}\", patch.getRelationshipTO().getType());\n@@ -296,7 +317,21 @@ public PropagationByResource<String> update(final AnyObject toBeUpdated, final A\n                         AnyObject otherEnd = anyObjectDAO.find(patch.getRelationshipTO().getOtherEndKey());\n                         if (otherEnd == null) {\n                             LOG.debug(\"Ignoring invalid any object {}\", patch.getRelationshipTO().getOtherEndKey());\n+                        } else if (relationships.contains(\n+                                Pair.of(otherEnd.getKey(), patch.getRelationshipTO().getType()))) {\n+\n+                            LOG.error(\"{} was already in relationship {} with {}\",\n+                                    anyObject, patch.getRelationshipTO().getType(), otherEnd);\n+\n+                            SyncopeClientException assigned =\n+                                    SyncopeClientException.build(ClientExceptionType.InvalidRelationship);\n+                            assigned.getElements().add(\"AnyObject was already in relationship \"\n+                                    + patch.getRelationshipTO().getType() + \" with \"\n+                                    + otherEnd.getType().getKey() + \" \" + otherEnd.getName());\n+                            scce.addException(assigned);\n                         } else if (anyObject.getRealm().getFullPath().startsWith(otherEnd.getRealm().getFullPath())) {\n+                            relationships.add(Pair.of(otherEnd.getKey(), patch.getRelationshipTO().getType()));\n+\n                             ARelationship newRelationship = entityFactory.newEntity(ARelationship.class);\n                             newRelationship.setType(relationshipType);\n                             newRelationship.setRightEnd(otherEnd);\n@@ -337,6 +372,7 @@ public PropagationByResource<String> update(final AnyObject toBeUpdated, final A\n         SyncopeClientException invalidValues = SyncopeClientException.build(ClientExceptionType.InvalidValues);\n \n         // memberships\n+        Set<String> groups = new HashSet<>();\n         anyObjectUR.getMemberships().stream().filter(patch -> patch.getGroup() != null).forEach(patch -> {\n             anyObject.getMembership(patch.getGroup()).ifPresent(membership -> {\n                 anyObject.remove(membership);\n@@ -361,7 +397,16 @@ public PropagationByResource<String> update(final AnyObject toBeUpdated, final A\n                 Group group = groupDAO.find(patch.getGroup());\n                 if (group == null) {\n                     LOG.debug(\"Ignoring invalid group {}\", patch.getGroup());\n+                } else if (groups.contains(group.getKey())) {\n+                    LOG.error(\"Multiple patches for group {} of {} were found\", group, anyObject);\n+\n+                    SyncopeClientException assigned =\n+                            SyncopeClientException.build(ClientExceptionType.InvalidMembership);\n+                    assigned.getElements().add(\"Multiple patches for group \" + group.getName() + \" were found\");\n+                    scce.addException(assigned);\n                 } else if (anyObject.getRealm().getFullPath().startsWith(group.getRealm().getFullPath())) {\n+                    groups.add(group.getKey());\n+\n                     AMembership newMembership = entityFactory.newEntity(AMembership.class);\n                     newMembership.setRightEnd(group);\n                     newMembership.setLeftEnd(anyObject);"},{"sha":"2d015d746df169caad1debda5883ddb410fbc2c7","filename":"core/provisioning-java/src/main/java/org/apache/syncope/core/provisioning/java/data/UserDataBinderImpl.java","status":"modified","additions":46,"deletions":0,"changes":46,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/501375b0f8b2d060e86539ef629d66bcf2e79aa3/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fdata%2FUserDataBinderImpl.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/501375b0f8b2d060e86539ef629d66bcf2e79aa3/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fdata%2FUserDataBinderImpl.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fdata%2FUserDataBinderImpl.java?ref=501375b0f8b2d060e86539ef629d66bcf2e79aa3","patch":"@@ -268,11 +268,22 @@ public void create(final User user, final UserCR userCR) {\n         user.setRealm(realm);\n \n         // relationships\n+        Set<Pair<String, String>> relationships = new HashSet<>();\n         userCR.getRelationships().forEach(relationshipTO -> {\n             AnyObject otherEnd = anyObjectDAO.find(relationshipTO.getOtherEndKey());\n             if (otherEnd == null) {\n                 LOG.debug(\"Ignoring invalid anyObject \" + relationshipTO.getOtherEndKey());\n+            } else if (relationships.contains(Pair.of(otherEnd.getKey(), relationshipTO.getType()))) {\n+                LOG.error(\"{} was already in relationship {} with {}\", otherEnd, relationshipTO.getType(), user);\n+\n+                SyncopeClientException assigned =\n+                        SyncopeClientException.build(ClientExceptionType.InvalidRelationship);\n+                assigned.getElements().add(otherEnd.getType().getKey() + \" \" + otherEnd.getName()\n+                        + \" in relationship \" + relationshipTO.getType());\n+                scce.addException(assigned);\n             } else if (user.getRealm().getFullPath().startsWith(otherEnd.getRealm().getFullPath())) {\n+                relationships.add(Pair.of(otherEnd.getKey(), relationshipTO.getType()));\n+\n                 RelationshipType relationshipType = relationshipTypeDAO.find(relationshipTO.getType());\n                 if (relationshipType == null) {\n                     LOG.debug(\"Ignoring invalid relationship type {}\", relationshipTO.getType());\n@@ -296,14 +307,24 @@ public void create(final User user, final UserCR userCR) {\n         });\n \n         // memberships\n+        Set<String> groups = new HashSet<>();\n         userCR.getMemberships().forEach(membershipTO -> {\n             Group group = membershipTO.getGroupKey() == null\n                     ? groupDAO.findByName(membershipTO.getGroupName())\n                     : groupDAO.find(membershipTO.getGroupKey());\n             if (group == null) {\n                 LOG.debug(\"Ignoring invalid group {}\",\n                         membershipTO.getGroupKey() + \" / \" + membershipTO.getGroupName());\n+            } else if (groups.contains(group.getKey())) {\n+                LOG.error(\"{} was already assigned to {}\", group, user);\n+\n+                SyncopeClientException assigned =\n+                        SyncopeClientException.build(ClientExceptionType.InvalidMembership);\n+                assigned.getElements().add(\"Group \" + group.getName() + \" was already assigned\");\n+                scce.addException(assigned);\n             } else if (user.getRealm().getFullPath().startsWith(group.getRealm().getFullPath())) {\n+                groups.add(group.getKey());\n+\n                 UMembership membership = entityFactory.newEntity(UMembership.class);\n                 membership.setRightEnd(group);\n                 membership.setLeftEnd(user);\n@@ -451,6 +472,7 @@ public Pair<PropagationByResource<String>, PropagationByResource<Pair<String, St\n         propByRes.merge(fill(user, userUR, anyUtils, scce));\n \n         // relationships\n+        Set<Pair<String, String>> relationships = new HashSet<>();\n         userUR.getRelationships().stream().filter(patch -> patch.getRelationshipTO() != null).forEach(patch -> {\n             RelationshipType relationshipType = relationshipTypeDAO.find(patch.getRelationshipTO().getType());\n             if (relationshipType == null) {\n@@ -466,7 +488,21 @@ public Pair<PropagationByResource<String>, PropagationByResource<Pair<String, St\n                     AnyObject otherEnd = anyObjectDAO.find(patch.getRelationshipTO().getOtherEndKey());\n                     if (otherEnd == null) {\n                         LOG.debug(\"Ignoring invalid any object {}\", patch.getRelationshipTO().getOtherEndKey());\n+                    } else if (relationships.contains(\n+                            Pair.of(otherEnd.getKey(), patch.getRelationshipTO().getType()))) {\n+\n+                        LOG.error(\"{} was already in relationship {} with {}\",\n+                                user, patch.getRelationshipTO().getType(), otherEnd);\n+\n+                        SyncopeClientException assigned =\n+                                SyncopeClientException.build(ClientExceptionType.InvalidRelationship);\n+                        assigned.getElements().add(\"User was already in relationship \"\n+                                + patch.getRelationshipTO().getType() + \" with \"\n+                                + otherEnd.getType().getKey() + \" \" + otherEnd.getName());\n+                        scce.addException(assigned);\n                     } else if (user.getRealm().getFullPath().startsWith(otherEnd.getRealm().getFullPath())) {\n+                        relationships.add(Pair.of(otherEnd.getKey(), patch.getRelationshipTO().getType()));\n+\n                         URelationship newRelationship = entityFactory.newEntity(URelationship.class);\n                         newRelationship.setType(relationshipType);\n                         newRelationship.setRightEnd(otherEnd);\n@@ -505,6 +541,7 @@ public Pair<PropagationByResource<String>, PropagationByResource<Pair<String, St\n         SyncopeClientException invalidValues = SyncopeClientException.build(ClientExceptionType.InvalidValues);\n \n         // memberships\n+        Set<String> groups = new HashSet<>();\n         userUR.getMemberships().stream().filter(patch -> patch.getGroup() != null).forEach(patch -> {\n             user.getMembership(patch.getGroup()).ifPresent(membership -> {\n                 user.remove(membership);\n@@ -530,7 +567,16 @@ public Pair<PropagationByResource<String>, PropagationByResource<Pair<String, St\n                 Group group = groupDAO.find(patch.getGroup());\n                 if (group == null) {\n                     LOG.debug(\"Ignoring invalid group {}\", patch.getGroup());\n+                } else if (groups.contains(group.getKey())) {\n+                    LOG.error(\"Multiple patches for group {} of {} were found\", group, user);\n+\n+                    SyncopeClientException assigned =\n+                            SyncopeClientException.build(ClientExceptionType.InvalidMembership);\n+                    assigned.getElements().add(\"Multiple patches for group \" + group.getName() + \" were found\");\n+                    scce.addException(assigned);\n                 } else if (user.getRealm().getFullPath().startsWith(group.getRealm().getFullPath())) {\n+                    groups.add(group.getKey());\n+\n                     UMembership newMembership = entityFactory.newEntity(UMembership.class);\n                     newMembership.setRightEnd(group);\n                     newMembership.setLeftEnd(user);"},{"sha":"ecb61a296794705c0e39999c85a644e0e5146108","filename":"fit/core-reference/src/test/java/org/apache/syncope/fit/core/MembershipITCase.java","status":"modified","additions":40,"deletions":0,"changes":40,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/501375b0f8b2d060e86539ef629d66bcf2e79aa3/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FMembershipITCase.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/501375b0f8b2d060e86539ef629d66bcf2e79aa3/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FMembershipITCase.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FMembershipITCase.java?ref=501375b0f8b2d060e86539ef629d66bcf2e79aa3","patch":"@@ -34,6 +34,9 @@\n import org.apache.syncope.common.lib.request.UserCR;\n import org.apache.syncope.common.lib.request.UserUR;\n import org.apache.syncope.common.lib.Attr;\n+import org.apache.syncope.common.lib.request.AnyObjectCR;\n+import org.apache.syncope.common.lib.request.AnyObjectUR;\n+import org.apache.syncope.common.lib.to.AnyObjectTO;\n import org.apache.syncope.common.lib.to.ExecTO;\n import org.apache.syncope.common.lib.to.GroupTO;\n import org.apache.syncope.common.lib.to.ItemTO;\n@@ -301,4 +304,41 @@ public void pull() {\n             resourceService.delete(newResource.getKey());\n         }\n     }\n+\n+    @Test\n+    public void createDoubleMembership() {\n+        AnyObjectCR anyObjectCR = AnyObjectITCase.getSample(\"createDoubleMembership\");\n+        anyObjectCR.setRealm(\"/even/two\");\n+        anyObjectCR.getMemberships().add(new MembershipTO.Builder(\"034740a9-fa10-453b-af37-dc7897e98fb1\").build());\n+        anyObjectCR.getMemberships().add(new MembershipTO.Builder(\"034740a9-fa10-453b-af37-dc7897e98fb1\").build());\n+\n+        try {\n+            createAnyObject(anyObjectCR);\n+            fail(\"This should not happen\");\n+        } catch (SyncopeClientException e) {\n+            assertEquals(ClientExceptionType.InvalidMembership, e.getType());\n+        }\n+    }\n+\n+    @Test\n+    public void updateDoubleMembership() {\n+        AnyObjectCR anyObjecCR = AnyObjectITCase.getSample(\"update\");\n+        anyObjecCR.setRealm(\"/even/two\");\n+        AnyObjectTO anyObjecTO = createAnyObject(anyObjecCR).getEntity();\n+        assertNotNull(anyObjecTO.getKey());\n+\n+        AnyObjectUR req = new AnyObjectUR();\n+        req.setKey(anyObjecTO.getKey());\n+        req.getMemberships().add(new MembershipUR.Builder(\"034740a9-fa10-453b-af37-dc7897e98fb1\").build());\n+        MembershipUR mp = new MembershipUR.Builder(\"034740a9-fa10-453b-af37-dc7897e98fb1\").build();\n+        mp.getPlainAttrs().add(attr(\"any\", \"useless\"));\n+        req.getMemberships().add(mp);\n+\n+        try {\n+            updateAnyObject(req).getEntity();\n+            fail(\"This should not happen\");\n+        } catch (SyncopeClientException e) {\n+            assertEquals(ClientExceptionType.InvalidMembership, e.getType());\n+        }\n+    }\n }"}]}