{"sha":"64495efbbc906599bf3c7de1c0692a7c3139b024","node_id":"MDY6Q29tbWl0NjM2ODc5MDYyOjY0NDk1ZWZiYmM5MDY1OTliZjNjN2RlMWMwNjkyYTdjMzEzOWIwMjQ=","commit":{"author":{"name":"Francesco Chicchiriccò","email":"ilgrosso@apache.org","date":"2019-10-22T07:13:42Z"},"committer":{"name":"Francesco Chicchiriccò","email":"ilgrosso@apache.org","date":"2019-10-22T08:53:57Z"},"message":"[SYNCOPE-1500] Reconciliation now supports single pull / push + [SYNCOPE-957] Reconciliation now supports Linked Accounts + [SYNCOPE-1499] Use Push correlation rule wherever it makes sense","tree":{"sha":"7d9adfafd3b640f481cfe51557e2915654c0aed7","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/git/trees/7d9adfafd3b640f481cfe51557e2915654c0aed7"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/git/commits/64495efbbc906599bf3c7de1c0692a7c3139b024","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/64495efbbc906599bf3c7de1c0692a7c3139b024","html_url":"https://github.com/EnricoDAlessandro97UNI/syncope/commit/64495efbbc906599bf3c7de1c0692a7c3139b024","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/64495efbbc906599bf3c7de1c0692a7c3139b024/comments","author":{"login":"ilgrosso","id":1064664,"node_id":"MDQ6VXNlcjEwNjQ2NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/1064664?v=4","gravatar_id":"","url":"https://api.github.com/users/ilgrosso","html_url":"https://github.com/ilgrosso","followers_url":"https://api.github.com/users/ilgrosso/followers","following_url":"https://api.github.com/users/ilgrosso/following{/other_user}","gists_url":"https://api.github.com/users/ilgrosso/gists{/gist_id}","starred_url":"https://api.github.com/users/ilgrosso/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ilgrosso/subscriptions","organizations_url":"https://api.github.com/users/ilgrosso/orgs","repos_url":"https://api.github.com/users/ilgrosso/repos","events_url":"https://api.github.com/users/ilgrosso/events{/privacy}","received_events_url":"https://api.github.com/users/ilgrosso/received_events","type":"User","site_admin":false},"committer":{"login":"ilgrosso","id":1064664,"node_id":"MDQ6VXNlcjEwNjQ2NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/1064664?v=4","gravatar_id":"","url":"https://api.github.com/users/ilgrosso","html_url":"https://github.com/ilgrosso","followers_url":"https://api.github.com/users/ilgrosso/followers","following_url":"https://api.github.com/users/ilgrosso/following{/other_user}","gists_url":"https://api.github.com/users/ilgrosso/gists{/gist_id}","starred_url":"https://api.github.com/users/ilgrosso/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ilgrosso/subscriptions","organizations_url":"https://api.github.com/users/ilgrosso/orgs","repos_url":"https://api.github.com/users/ilgrosso/repos","events_url":"https://api.github.com/users/ilgrosso/events{/privacy}","received_events_url":"https://api.github.com/users/ilgrosso/received_events","type":"User","site_admin":false},"parents":[{"sha":"4b20e81b05948da257eded5601b5538cf92f919d","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/4b20e81b05948da257eded5601b5538cf92f919d","html_url":"https://github.com/EnricoDAlessandro97UNI/syncope/commit/4b20e81b05948da257eded5601b5538cf92f919d"}],"stats":{"total":3748,"additions":1970,"deletions":1778},"files":[{"sha":"4c778dd7f6eec3cc5ad209b7b8febdcbcef67a36","filename":"client/idm/console/src/main/java/org/apache/syncope/client/console/commons/IdMStatusProvider.java","status":"modified","additions":1,"deletions":2,"changes":3,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/64495efbbc906599bf3c7de1c0692a7c3139b024/client%2Fidm%2Fconsole%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fconsole%2Fcommons%2FIdMStatusProvider.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/64495efbbc906599bf3c7de1c0692a7c3139b024/client%2Fidm%2Fconsole%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fconsole%2Fcommons%2FIdMStatusProvider.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/client%2Fidm%2Fconsole%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fconsole%2Fcommons%2FIdMStatusProvider.java?ref=64495efbbc906599bf3c7de1c0692a7c3139b024","patch":"@@ -29,7 +29,6 @@\n import org.apache.syncope.client.console.wicket.markup.html.form.ActionLink;\n import org.apache.syncope.common.lib.to.AnyTO;\n import org.apache.syncope.common.lib.to.ConnObjectTO;\n-import org.apache.syncope.common.lib.types.AnyTypeKind;\n import org.apache.syncope.common.lib.types.IdMEntitlement;\n \n public class IdMStatusProvider implements StatusProvider {\n@@ -41,7 +40,7 @@ public List<Triple<ConnObjectTO, ConnObjectWrapper, String>> get(\n             final AnyTO any, final Collection<String> resources) {\n \n         return ReconStatusUtils.getReconStatuses(\n-                AnyTypeKind.fromTOClass(any.getClass()), any.getKey(), any.getResources()).stream().\n+                any.getType(), any.getKey(), any.getResources()).stream().\n                 map(status -> Triple.<ConnObjectTO, ConnObjectWrapper, String>of(\n                 status.getRight().getOnSyncope(),\n                 new ConnObjectWrapper(any, status.getLeft(), status.getRight().getOnResource()),"},{"sha":"4d7f94c4dd9e237f8bcd91095fb3d9af118d58fa","filename":"client/idm/console/src/main/java/org/apache/syncope/client/console/rest/ReconciliationRestClient.java","status":"modified","additions":7,"deletions":17,"changes":24,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/64495efbbc906599bf3c7de1c0692a7c3139b024/client%2Fidm%2Fconsole%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fconsole%2Frest%2FReconciliationRestClient.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/64495efbbc906599bf3c7de1c0692a7c3139b024/client%2Fidm%2Fconsole%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fconsole%2Frest%2FReconciliationRestClient.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/client%2Fidm%2Fconsole%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fconsole%2Frest%2FReconciliationRestClient.java?ref=64495efbbc906599bf3c7de1c0692a7c3139b024","patch":"@@ -21,32 +21,22 @@\n import org.apache.syncope.common.lib.to.PullTaskTO;\n import org.apache.syncope.common.lib.to.PushTaskTO;\n import org.apache.syncope.common.lib.to.ReconStatus;\n-import org.apache.syncope.common.lib.types.AnyTypeKind;\n+import org.apache.syncope.common.rest.api.beans.ReconQuery;\n import org.apache.syncope.common.rest.api.service.ReconciliationService;\n \n public class ReconciliationRestClient extends BaseRestClient {\n \n     private static final long serialVersionUID = -3161863874876938094L;\n \n-    public static ReconStatus status(final AnyTypeKind anyTypeKind, final String anyKey, final String resourceKey) {\n-        return getService(ReconciliationService.class).status(anyTypeKind, anyKey, resourceKey);\n+    public static ReconStatus status(final ReconQuery reconQuery) {\n+        return getService(ReconciliationService.class).status(reconQuery);\n     }\n \n-    public static void push(\n-        final AnyTypeKind anyTypeKind,\n-        final String anyKey,\n-        final String resourceKey,\n-        final PushTaskTO pushTask) {\n-\n-        getService(ReconciliationService.class).push(anyTypeKind, anyKey, resourceKey, pushTask);\n+    public static void push(final ReconQuery reconQuery, final PushTaskTO pushTask) {\n+        getService(ReconciliationService.class).push(reconQuery, pushTask);\n     }\n \n-    public static void pull(\n-        final AnyTypeKind anyTypeKind,\n-        final String anyKey,\n-        final String resourceKey,\n-        final PullTaskTO pullTask) {\n-\n-        getService(ReconciliationService.class).pull(anyTypeKind, anyKey, resourceKey, pullTask);\n+    public static void pull(final ReconQuery reconQuery, final PullTaskTO pullTask) {\n+        getService(ReconciliationService.class).pull(reconQuery, pullTask);\n     }\n }"},{"sha":"7081671cbb1729e6cafadf158f0c642ad39079f8","filename":"client/idm/console/src/main/java/org/apache/syncope/client/console/status/AnyStatusDirectoryPanel.java","status":"modified","additions":4,"deletions":4,"changes":8,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/64495efbbc906599bf3c7de1c0692a7c3139b024/client%2Fidm%2Fconsole%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fconsole%2Fstatus%2FAnyStatusDirectoryPanel.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/64495efbbc906599bf3c7de1c0692a7c3139b024/client%2Fidm%2Fconsole%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fconsole%2Fstatus%2FAnyStatusDirectoryPanel.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/client%2Fidm%2Fconsole%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fconsole%2Fstatus%2FAnyStatusDirectoryPanel.java?ref=64495efbbc906599bf3c7de1c0692a7c3139b024","patch":"@@ -192,7 +192,7 @@ public ActionsPanel<StatusBean> getActions(final IModel<StatusBean> model) {\n                 @Override\n                 public void onClick(final AjaxRequestTarget target, final StatusBean bean) {\n                     multiLevelPanelRef.next(bean.getResource(),\n-                            new ReconStatusPanel(bean.getResource(), anyTypeKind, anyTO.getKey()),\n+                            new ReconStatusPanel(bean.getResource(), anyTO.getType(), anyTO.getKey()),\n                             target);\n                     target.add(multiLevelPanelRef);\n                     AnyStatusDirectoryPanel.this.getTogglePanel().close(target);\n@@ -211,7 +211,7 @@ public void onClick(final AjaxRequestTarget target, final StatusBean bean) {\n                             new ReconTaskPanel(\n                                     bean.getResource(),\n                                     new PushTaskTO(),\n-                                    anyTypeKind,\n+                                    anyTO.getType(),\n                                     anyTO.getKey(),\n                                     multiLevelPanelRef,\n                                     pageRef),\n@@ -231,7 +231,7 @@ public void onClick(final AjaxRequestTarget target, final StatusBean bean) {\n                             new ReconTaskPanel(\n                                     bean.getResource(),\n                                     new PullTaskTO(),\n-                                    anyTypeKind,\n+                                    anyTO.getType(),\n                                     anyTO.getKey(),\n                                     multiLevelPanelRef,\n                                     pageRef),\n@@ -288,7 +288,7 @@ protected List<StatusBean> getStatusBeans(final long first, final long count) {\n             List<StatusBean> statusBeans = actual.getResources().stream().map(resource -> {\n                 List<Pair<String, ReconStatus>> statuses = List.of();\n                 if (statusOnly) {\n-                    statuses = ReconStatusUtils.getReconStatuses(anyTypeKind, anyTO.getKey(), List.of(resource));\n+                    statuses = ReconStatusUtils.getReconStatuses(anyTO.getType(), anyTO.getKey(), List.of(resource));\n                 }\n \n                 return StatusUtils.getStatusBean(actual,"},{"sha":"a7f23602426f72266e6e01adeca8ca17cf4f0ac8","filename":"client/idm/console/src/main/java/org/apache/syncope/client/console/status/ReconStatusPanel.java","status":"modified","additions":4,"deletions":5,"changes":9,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/64495efbbc906599bf3c7de1c0692a7c3139b024/client%2Fidm%2Fconsole%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fconsole%2Fstatus%2FReconStatusPanel.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/64495efbbc906599bf3c7de1c0692a7c3139b024/client%2Fidm%2Fconsole%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fconsole%2Fstatus%2FReconStatusPanel.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/client%2Fidm%2Fconsole%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fconsole%2Fstatus%2FReconStatusPanel.java?ref=64495efbbc906599bf3c7de1c0692a7c3139b024","patch":"@@ -25,7 +25,6 @@\n import org.apache.syncope.client.console.wizards.any.ConnObjectPanel;\n import org.apache.syncope.common.lib.to.ConnObjectTO;\n import org.apache.syncope.common.lib.to.ReconStatus;\n-import org.apache.syncope.common.lib.types.AnyTypeKind;\n import org.apache.wicket.model.IModel;\n import org.apache.wicket.model.Model;\n import org.apache.wicket.model.ResourceModel;\n@@ -36,17 +35,17 @@ public class ReconStatusPanel extends RemoteObjectPanel {\n \n     private final String resource;\n \n-    private final AnyTypeKind anyTypeKind;\n+    private final String anyTypeKey;\n \n     private final String anyKey;\n \n     public ReconStatusPanel(\n             final String resource,\n-            final AnyTypeKind anyTypeKind,\n+            final String anyTypeKey,\n             final String anyKey) {\n \n         this.resource = resource;\n-        this.anyTypeKind = anyTypeKind;\n+        this.anyTypeKey = anyTypeKey;\n         this.anyKey = anyKey;\n \n         add(new ConnObjectPanel(\n@@ -59,7 +58,7 @@ public ReconStatusPanel(\n     @Override\n     protected Pair<ConnObjectTO, ConnObjectTO> getConnObjectTOs() {\n         List<Pair<String, ReconStatus>> statuses =\n-                ReconStatusUtils.getReconStatuses(anyTypeKind, anyKey, List.of(resource));\n+                ReconStatusUtils.getReconStatuses(anyTypeKey, anyKey, List.of(resource));\n \n         return statuses.isEmpty()\n                 ? null"},{"sha":"9da9dcfa23737da47701e2c5697f939aecb05e33","filename":"client/idm/console/src/main/java/org/apache/syncope/client/console/status/ReconStatusUtils.java","status":"modified","additions":5,"deletions":4,"changes":9,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/64495efbbc906599bf3c7de1c0692a7c3139b024/client%2Fidm%2Fconsole%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fconsole%2Fstatus%2FReconStatusUtils.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/64495efbbc906599bf3c7de1c0692a7c3139b024/client%2Fidm%2Fconsole%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fconsole%2Fstatus%2FReconStatusUtils.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/client%2Fidm%2Fconsole%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fconsole%2Fstatus%2FReconStatusUtils.java?ref=64495efbbc906599bf3c7de1c0692a7c3139b024","patch":"@@ -26,7 +26,7 @@\n import org.apache.commons.lang3.tuple.Pair;\n import org.apache.syncope.client.console.rest.ReconciliationRestClient;\n import org.apache.syncope.common.lib.to.ReconStatus;\n-import org.apache.syncope.common.lib.types.AnyTypeKind;\n+import org.apache.syncope.common.rest.api.beans.ReconQuery;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -37,13 +37,14 @@ public final class ReconStatusUtils implements Serializable {\n     private static final Logger LOG = LoggerFactory.getLogger(ReconStatusUtils.class);\n \n     public static List<Pair<String, ReconStatus>> getReconStatuses(\n-            final AnyTypeKind anyTypeKind, final String anyKey, final Collection<String> resources) {\n+            final String anyTypeKey, final String anyKey, final Collection<String> resources) {\n \n         return resources.stream().map(resource -> {\n             try {\n-                return Pair.of(resource, ReconciliationRestClient.status(anyTypeKind, anyKey, resource));\n+                return Pair.of(resource, ReconciliationRestClient.status(\n+                        new ReconQuery.Builder(anyTypeKey, resource).anyKey(anyKey).build()));\n             } catch (Exception e) {\n-                LOG.warn(\"Unexpected error for {} {} on {}\", anyTypeKind, anyKey, resource, e);\n+                LOG.warn(\"Unexpected error for {} {} on {}\", anyTypeKey, anyKey, resource, e);\n                 return null;\n             }\n         }).filter(Objects::nonNull).collect(Collectors.toList());"},{"sha":"48228f608460effa7ccb76366248a3bdfcff279f","filename":"client/idm/console/src/main/java/org/apache/syncope/client/console/status/ReconTaskPanel.java","status":"modified","additions":13,"deletions":15,"changes":28,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/64495efbbc906599bf3c7de1c0692a7c3139b024/client%2Fidm%2Fconsole%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fconsole%2Fstatus%2FReconTaskPanel.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/64495efbbc906599bf3c7de1c0692a7c3139b024/client%2Fidm%2Fconsole%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fconsole%2Fstatus%2FReconTaskPanel.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/client%2Fidm%2Fconsole%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fconsole%2Fstatus%2FReconTaskPanel.java?ref=64495efbbc906599bf3c7de1c0692a7c3139b024","patch":"@@ -34,10 +34,10 @@\n import org.apache.syncope.common.lib.to.ProvisioningTaskTO;\n import org.apache.syncope.common.lib.to.PullTaskTO;\n import org.apache.syncope.common.lib.to.PushTaskTO;\n-import org.apache.syncope.common.lib.types.AnyTypeKind;\n import org.apache.syncope.common.lib.types.IdMImplementationType;\n import org.apache.syncope.common.lib.types.MatchingRule;\n import org.apache.syncope.common.lib.types.UnmatchingRule;\n+import org.apache.syncope.common.rest.api.beans.ReconQuery;\n import org.apache.wicket.PageReference;\n import org.apache.wicket.ajax.AjaxRequestTarget;\n import org.apache.wicket.ajax.markup.html.form.AjaxSubmitLink;\n@@ -81,7 +81,7 @@ protected List<String> load() {\n     public ReconTaskPanel(\n             final String resource,\n             final ProvisioningTaskTO taskTO,\n-            final AnyTypeKind anyTypeKind,\n+            final String anyType,\n             final String anyKey,\n             final MultilevelPanel multiLevelPanelRef,\n             final PageReference pageRef) {\n@@ -92,41 +92,41 @@ public ReconTaskPanel(\n         AjaxPalettePanel<String> actions = new AjaxPalettePanel.Builder<String>().\n                 setAllowMoveAll(true).setAllowOrder(true).\n                 build(\"actions\",\n-                        new PropertyModel<List<String>>(taskTO, \"actions\"),\n+                        new PropertyModel<>(taskTO, \"actions\"),\n                         new ListModel<>(taskTO instanceof PushTaskTO\n                                 ? pushActions.getObject() : pullActions.getObject()));\n         actions.setOutputMarkupId(true);\n         form.add(actions);\n \n         AjaxDropDownChoicePanel<MatchingRule> matchingRule = new AjaxDropDownChoicePanel<>(\n-                \"matchingRule\", \"matchingRule\", new PropertyModel<MatchingRule>(taskTO, \"matchingRule\"), false);\n+                \"matchingRule\", \"matchingRule\", new PropertyModel<>(taskTO, \"matchingRule\"), false);\n         matchingRule.setChoices(List.of(MatchingRule.values()));\n         form.add(matchingRule);\n \n         AjaxDropDownChoicePanel<UnmatchingRule> unmatchingRule = new AjaxDropDownChoicePanel<>(\n-                \"unmatchingRule\", \"unmatchingRule\", new PropertyModel<UnmatchingRule>(taskTO, \"unmatchingRule\"),\n+                \"unmatchingRule\", \"unmatchingRule\", new PropertyModel<>(taskTO, \"unmatchingRule\"),\n                 false);\n         unmatchingRule.setChoices(List.of(UnmatchingRule.values()));\n         form.add(unmatchingRule);\n \n         taskTO.setPerformCreate(true);\n         AjaxCheckBoxPanel performCreate = new AjaxCheckBoxPanel(\n-                \"performCreate\", \"performCreate\", new PropertyModel<Boolean>(taskTO, \"performCreate\"), false);\n+                \"performCreate\", \"performCreate\", new PropertyModel<>(taskTO, \"performCreate\"), false);\n         form.add(performCreate);\n \n         taskTO.setPerformUpdate(true);\n         AjaxCheckBoxPanel performUpdate = new AjaxCheckBoxPanel(\n-                \"performUpdate\", \"performUpdate\", new PropertyModel<Boolean>(taskTO, \"performUpdate\"), false);\n+                \"performUpdate\", \"performUpdate\", new PropertyModel<>(taskTO, \"performUpdate\"), false);\n         form.add(performUpdate);\n \n         taskTO.setPerformDelete(true);\n         AjaxCheckBoxPanel performDelete = new AjaxCheckBoxPanel(\n-                \"performDelete\", \"performDelete\", new PropertyModel<Boolean>(taskTO, \"performDelete\"), false);\n+                \"performDelete\", \"performDelete\", new PropertyModel<>(taskTO, \"performDelete\"), false);\n         form.add(performDelete);\n \n         taskTO.setSyncStatus(true);\n         AjaxCheckBoxPanel syncStatus = new AjaxCheckBoxPanel(\n-                \"syncStatus\", \"syncStatus\", new PropertyModel<Boolean>(taskTO, \"syncStatus\"), false);\n+                \"syncStatus\", \"syncStatus\", new PropertyModel<>(taskTO, \"syncStatus\"), false);\n         form.add(syncStatus);\n \n         form.add(new AjaxSubmitLink(\"reconcile\") {\n@@ -135,19 +135,17 @@ public ReconTaskPanel(\n \n             @Override\n             protected void onSubmit(final AjaxRequestTarget target) {\n+                ReconQuery reconQuery = new ReconQuery.Builder(anyType, resource).anyKey(anyKey).build();\n                 try {\n                     if (taskTO instanceof PushTaskTO) {\n-                        ReconciliationRestClient.push(anyTypeKind, anyKey, resource,\n-                            (PushTaskTO) form.getModelObject());\n+                        ReconciliationRestClient.push(reconQuery, (PushTaskTO) form.getModelObject());\n                     } else {\n-                        ReconciliationRestClient.pull(anyTypeKind, anyKey, resource,\n-                            (PullTaskTO) form.getModelObject());\n+                        ReconciliationRestClient.pull(reconQuery, (PullTaskTO) form.getModelObject());\n                     }\n \n                     SyncopeConsoleSession.get().info(getString(Constants.OPERATION_SUCCEEDED));\n                 } catch (Exception e) {\n-                    LOG.error(\"While attempting reconciliation on {} {} {} {}\",\n-                            anyTypeKind, anyKey, resource, form.getModelObject(), e);\n+                    LOG.error(\"While attempting reconciliation on {}\", reconQuery, form.getModelObject(), e);\n                     SyncopeConsoleSession.get().error(resource + \": \"\n                             + (StringUtils.isBlank(e.getMessage()) ? e.getClass().getName() : e.getMessage()));\n                 }"},{"sha":"7660e30841acb73b61eadf4fa61148d0c18fbf8c","filename":"client/idm/console/src/main/java/org/apache/syncope/client/console/status/ResourceStatusDirectoryPanel.java","status":"modified","additions":6,"deletions":23,"changes":29,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/64495efbbc906599bf3c7de1c0692a7c3139b024/client%2Fidm%2Fconsole%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fconsole%2Fstatus%2FResourceStatusDirectoryPanel.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/64495efbbc906599bf3c7de1c0692a7c3139b024/client%2Fidm%2Fconsole%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fconsole%2Fstatus%2FResourceStatusDirectoryPanel.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/client%2Fidm%2Fconsole%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fconsole%2Fstatus%2FResourceStatusDirectoryPanel.java?ref=64495efbbc906599bf3c7de1c0692a7c3139b024","patch":"@@ -103,23 +103,6 @@ protected List<IColumn<StatusBean, String>> getColumns() {\n         return columns;\n     }\n \n-    private AnyTypeKind getAnyTypeKind() {\n-        if (StringUtils.isBlank(type)) {\n-            return null;\n-        }\n-\n-        switch (type) {\n-            case \"USER\":\n-                return AnyTypeKind.USER;\n-\n-            case \"GROUP\":\n-                return AnyTypeKind.GROUP;\n-\n-            default:\n-                return AnyTypeKind.ANY_OBJECT;\n-        }\n-    }\n-\n     @Override\n     public ActionsPanel<StatusBean> getActions(final IModel<StatusBean> model) {\n         final ActionsPanel<StatusBean> panel = super.getActions(model);\n@@ -130,13 +113,13 @@ public ActionsPanel<StatusBean> getActions(final IModel<StatusBean> model) {\n \n             @Override\n             protected boolean statusCondition(final StatusBean bean) {\n-                return getAnyTypeKind() != null;\n+                return StringUtils.isNotBlank(type);\n             }\n \n             @Override\n             public void onClick(final AjaxRequestTarget target, final StatusBean bean) {\n                 multiLevelPanelRef.next(bean.getResource(),\n-                        new ReconStatusPanel(bean.getResource(), getAnyTypeKind(), bean.getKey()),\n+                        new ReconStatusPanel(bean.getResource(), type, bean.getKey()),\n                         target);\n                 target.add(multiLevelPanelRef);\n                 getTogglePanel().close(target);\n@@ -149,7 +132,7 @@ public void onClick(final AjaxRequestTarget target, final StatusBean bean) {\n \n             @Override\n             protected boolean statusCondition(final StatusBean bean) {\n-                return getAnyTypeKind() != null;\n+                return StringUtils.isNotBlank(type);\n             }\n \n             @Override\n@@ -158,7 +141,7 @@ public void onClick(final AjaxRequestTarget target, final StatusBean bean) {\n                         new ReconTaskPanel(\n                                 bean.getResource(),\n                                 new PushTaskTO(),\n-                                getAnyTypeKind(),\n+                                type,\n                                 bean.getKey(),\n                                 multiLevelPanelRef,\n                                 pageRef),\n@@ -174,7 +157,7 @@ public void onClick(final AjaxRequestTarget target, final StatusBean bean) {\n \n             @Override\n             protected boolean statusCondition(final StatusBean bean) {\n-                return getAnyTypeKind() != null;\n+                return StringUtils.isNotBlank(type);\n             }\n \n             @Override\n@@ -183,7 +166,7 @@ public void onClick(final AjaxRequestTarget target, final StatusBean bean) {\n                         new ReconTaskPanel(\n                                 bean.getResource(),\n                                 new PullTaskTO(),\n-                                getAnyTypeKind(),\n+                                type,\n                                 bean.getKey(),\n                                 multiLevelPanelRef,\n                                 pageRef),"},{"sha":"fe33e4e137346c879589cf6c3a79c15d150c9a97","filename":"client/idrepo/common-ui/src/main/java/org/apache/syncope/client/ui/commons/status/StatusUtils.java","status":"modified","additions":3,"deletions":3,"changes":6,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/64495efbbc906599bf3c7de1c0692a7c3139b024/client%2Fidrepo%2Fcommon-ui%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fui%2Fcommons%2Fstatus%2FStatusUtils.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/64495efbbc906599bf3c7de1c0692a7c3139b024/client%2Fidrepo%2Fcommon-ui%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fui%2Fcommons%2Fstatus%2FStatusUtils.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/client%2Fidrepo%2Fcommon-ui%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fui%2Fcommons%2Fstatus%2FStatusUtils.java?ref=64495efbbc906599bf3c7de1c0692a7c3139b024","patch":"@@ -50,8 +50,8 @@ public static StatusBean getStatusBean(\n         if (connObjectTO != null) {\n             Boolean enabled = isEnabled(connObjectTO);\n             statusBean.setStatus(Optional.ofNullable(enabled).map(aBoolean -> aBoolean\n-                ? Status.ACTIVE\n-                : Status.SUSPENDED).orElseGet(() -> (notUser ? Status.ACTIVE : Status.UNDEFINED)));\n+                    ? Status.ACTIVE\n+                    : Status.SUSPENDED).orElseGet(() -> (notUser ? Status.ACTIVE : Status.UNDEFINED)));\n \n             statusBean.setConnObjectLink(getConnObjectLink(connObjectTO));\n         }\n@@ -69,7 +69,7 @@ public static StatusBean getStatusBean(\n         if (connObjectTO != null) {\n             Boolean enabled = isEnabled(connObjectTO);\n             statusBean.setStatus(Optional.ofNullable(enabled)\n-                .filter(aBoolean -> !aBoolean).map(aBoolean -> Status.SUSPENDED).orElse(Status.ACTIVE));\n+                    .filter(aBoolean -> !aBoolean).map(aBoolean -> Status.SUSPENDED).orElse(Status.ACTIVE));\n \n             statusBean.setConnObjectLink(getConnObjectLink(connObjectTO));\n         }"},{"sha":"481eaa9459319232eddd96b2688d1bcbbb6f59e9","filename":"client/idrepo/console/src/main/java/org/apache/syncope/client/console/wizards/any/StatusPanel.java","status":"modified","additions":3,"deletions":3,"changes":6,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/64495efbbc906599bf3c7de1c0692a7c3139b024/client%2Fidrepo%2Fconsole%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fconsole%2Fwizards%2Fany%2FStatusPanel.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/64495efbbc906599bf3c7de1c0692a7c3139b024/client%2Fidrepo%2Fconsole%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fconsole%2Fwizards%2Fany%2FStatusPanel.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/client%2Fidrepo%2Fconsole%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fconsole%2Fwizards%2Fany%2FStatusPanel.java?ref=64495efbbc906599bf3c7de1c0692a7c3139b024","patch":"@@ -201,9 +201,9 @@ public Map<String, StatusBean> getInitialStatusBeanMap() {\n     }\n \n     protected static Pair<ConnObjectTO, ConnObjectTO> getConnObjectTOs(\n-        final String anyKey,\n-        final String resource,\n-        final List<Triple<ConnObjectTO, ConnObjectWrapper, String>> objects) {\n+            final String anyKey,\n+            final String resource,\n+            final List<Triple<ConnObjectTO, ConnObjectWrapper, String>> objects) {\n \n         for (Triple<ConnObjectTO, ConnObjectWrapper, String> object : objects) {\n             if (anyKey.equals(object.getMiddle().getAny().getKey())"},{"sha":"b7b44741c0adaf1ab12d6bf37b370be5e20251a5","filename":"common/idm/lib/src/main/java/org/apache/syncope/common/lib/to/ReconStatus.java","status":"modified","additions":35,"deletions":0,"changes":35,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/64495efbbc906599bf3c7de1c0692a7c3139b024/common%2Fidm%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FReconStatus.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/64495efbbc906599bf3c7de1c0692a7c3139b024/common%2Fidm%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FReconStatus.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/common%2Fidm%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FReconStatus.java?ref=64495efbbc906599bf3c7de1c0692a7c3139b024","patch":"@@ -22,6 +22,8 @@\n import java.io.Serializable;\n import javax.xml.bind.annotation.XmlRootElement;\n import javax.xml.bind.annotation.XmlType;\n+import org.apache.syncope.common.lib.types.AnyTypeKind;\n+import org.apache.syncope.common.lib.types.MatchType;\n \n /**\n  * Reconciliation status.\n@@ -32,10 +34,43 @@ public class ReconStatus implements Serializable {\n \n     private static final long serialVersionUID = -8516345256596521490L;\n \n+    private AnyTypeKind anyTypeKind;\n+\n+    private String anyKey;\n+\n+    private MatchType matchType;\n+\n     private ConnObjectTO onSyncope;\n \n     private ConnObjectTO onResource;\n \n+    @Schema(accessMode = Schema.AccessMode.READ_ONLY)\n+    public AnyTypeKind getAnyTypeKind() {\n+        return anyTypeKind;\n+    }\n+\n+    public void setAnyTypeKind(final AnyTypeKind anyTypeKind) {\n+        this.anyTypeKind = anyTypeKind;\n+    }\n+\n+    @Schema(accessMode = Schema.AccessMode.READ_ONLY)\n+    public String getAnyKey() {\n+        return anyKey;\n+    }\n+\n+    public void setAnyKey(final String anyKey) {\n+        this.anyKey = anyKey;\n+    }\n+\n+    @Schema(accessMode = Schema.AccessMode.READ_ONLY)\n+    public MatchType getMatchType() {\n+        return matchType;\n+    }\n+\n+    public void setMatchType(final MatchType matchType) {\n+        this.matchType = matchType;\n+    }\n+\n     @Schema(accessMode = Schema.AccessMode.READ_ONLY)\n     public ConnObjectTO getOnSyncope() {\n         return onSyncope;"},{"sha":"ddd6799e071310d44670028cb48d3637862752f8","filename":"common/idm/rest-api/src/main/java/org/apache/syncope/common/rest/api/beans/ReconQuery.java","status":"added","additions":96,"deletions":0,"changes":96,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/64495efbbc906599bf3c7de1c0692a7c3139b024/common%2Fidm%2Frest-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Frest%2Fapi%2Fbeans%2FReconQuery.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/64495efbbc906599bf3c7de1c0692a7c3139b024/common%2Fidm%2Frest-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Frest%2Fapi%2Fbeans%2FReconQuery.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/common%2Fidm%2Frest-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Frest%2Fapi%2Fbeans%2FReconQuery.java?ref=64495efbbc906599bf3c7de1c0692a7c3139b024","patch":"@@ -0,0 +1,96 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.common.rest.api.beans;\n+\n+import javax.validation.constraints.NotNull;\n+import javax.ws.rs.QueryParam;\n+\n+public class ReconQuery {\n+\n+    public static class Builder {\n+\n+        private final ReconQuery instance;\n+\n+        public Builder(final String anyTypeKey, final String resourceKey) {\n+            instance = new ReconQuery();\n+            instance.setAnyTypeKey(anyTypeKey);\n+            instance.setResourceKey(resourceKey);\n+        }\n+\n+        public Builder anyKey(final String anyKey) {\n+            instance.setAnyKey(anyKey);\n+            return this;\n+        }\n+\n+        public Builder connObjectKeyValue(final String connObjectKeyValue) {\n+            instance.setConnObjectKeyValue(connObjectKeyValue);\n+            return this;\n+        }\n+\n+        public ReconQuery build() {\n+            return instance;\n+        }\n+    }\n+\n+    private String anyTypeKey;\n+\n+    private String anyKey;\n+\n+    private String resourceKey;\n+\n+    private String connObjectKeyValue;\n+\n+    public String getAnyTypeKey() {\n+        return anyTypeKey;\n+    }\n+\n+    @NotNull\n+    @QueryParam(\"anyTypeKey\")\n+    public void setAnyTypeKey(final String anyTypeKey) {\n+        this.anyTypeKey = anyTypeKey;\n+    }\n+\n+    public String getAnyKey() {\n+        return anyKey;\n+    }\n+\n+    @QueryParam(\"anyKey\")\n+    public void setAnyKey(final String anyKey) {\n+        this.anyKey = anyKey;\n+    }\n+\n+    public String getResourceKey() {\n+        return resourceKey;\n+    }\n+\n+    @NotNull\n+    @QueryParam(\"resourceKey\")\n+    public void setResourceKey(final String resourceKey) {\n+        this.resourceKey = resourceKey;\n+    }\n+\n+    public String getConnObjectKeyValue() {\n+        return connObjectKeyValue;\n+    }\n+\n+    @QueryParam(\"connObjectKeyValue\")\n+    public void setConnObjectKeyValue(final String connObjectKeyValue) {\n+        this.connObjectKeyValue = connObjectKeyValue;\n+    }\n+}"},{"sha":"cb44ef9b4d8a2fe8246801c65cb69800a0e8c8cd","filename":"common/idm/rest-api/src/main/java/org/apache/syncope/common/rest/api/service/ReconciliationService.java","status":"modified","additions":11,"deletions":32,"changes":43,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/64495efbbc906599bf3c7de1c0692a7c3139b024/common%2Fidm%2Frest-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Frest%2Fapi%2Fservice%2FReconciliationService.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/64495efbbc906599bf3c7de1c0692a7c3139b024/common%2Fidm%2Frest-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Frest%2Fapi%2Fservice%2FReconciliationService.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/common%2Fidm%2Frest-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Frest%2Fapi%2Fservice%2FReconciliationService.java?ref=64495efbbc906599bf3c7de1c0692a7c3139b024","patch":"@@ -24,18 +24,18 @@\n import io.swagger.v3.oas.annotations.security.SecurityRequirements;\n import io.swagger.v3.oas.annotations.tags.Tag;\n import javax.validation.constraints.NotNull;\n+import javax.ws.rs.BeanParam;\n import javax.ws.rs.Consumes;\n import javax.ws.rs.GET;\n import javax.ws.rs.POST;\n import javax.ws.rs.Path;\n import javax.ws.rs.Produces;\n-import javax.ws.rs.QueryParam;\n import javax.ws.rs.core.MediaType;\n import org.apache.syncope.common.lib.to.PullTaskTO;\n import org.apache.syncope.common.lib.to.PushTaskTO;\n import org.apache.syncope.common.lib.to.ReconStatus;\n-import org.apache.syncope.common.lib.types.AnyTypeKind;\n import org.apache.syncope.common.rest.api.RESTHeaders;\n+import org.apache.syncope.common.rest.api.beans.ReconQuery;\n \n /**\n  * REST operations for reconciliation.\n@@ -48,29 +48,19 @@\n public interface ReconciliationService extends JAXRSService {\n \n     /**\n-     * Gets current attributes on Syncope and on the given External Resource, related to given user, group or\n-     * any object.\n+     * Gets compared status between attributes in Syncope and on the given External Resource.\n      *\n-     * @param anyTypeKind anyTypeKind\n-     * @param anyKey user, group or any object: if value looks like a UUID then it is interpreted as key, otherwise as\n-     * a (user)name\n-     * @param resourceKey resource key\n+     * @param query query conditions\n      * @return reconciliation status\n      */\n     @GET\n     @Produces({ MediaType.APPLICATION_JSON, RESTHeaders.APPLICATION_YAML, MediaType.APPLICATION_XML })\n-    ReconStatus status(\n-            @NotNull @QueryParam(\"anyTypeKind\") AnyTypeKind anyTypeKind,\n-            @NotNull @QueryParam(\"anyKey\") String anyKey,\n-            @NotNull @QueryParam(\"resourceKey\") String resourceKey);\n+    ReconStatus status(@BeanParam ReconQuery query);\n \n     /**\n-     * Pushes the given user, group or any object in Syncope onto the External Resource.\n+     * Pushes the matching user, group, any object or linked account in Syncope onto the External Resource.\n      *\n-     * @param anyTypeKind anyTypeKind\n-     * @param anyKey user, group or any object: if value looks like a UUID then it is interpreted as key, otherwise as\n-     * a (user)name\n-     * @param resourceKey resource key\n+     * @param query query conditions\n      * @param pushTask push specification\n      */\n     @ApiResponses(\n@@ -79,19 +69,12 @@ ReconStatus status(\n     @Path(\"push\")\n     @Consumes({ MediaType.APPLICATION_JSON, RESTHeaders.APPLICATION_YAML, MediaType.APPLICATION_XML })\n     @Produces({ MediaType.APPLICATION_JSON, RESTHeaders.APPLICATION_YAML, MediaType.APPLICATION_XML })\n-    void push(\n-            @NotNull @QueryParam(\"anyTypeKind\") AnyTypeKind anyTypeKind,\n-            @NotNull @QueryParam(\"anyKey\") String anyKey,\n-            @NotNull @QueryParam(\"resourceKey\") String resourceKey,\n-            @NotNull PushTaskTO pushTask);\n+    void push(@BeanParam ReconQuery query, @NotNull PushTaskTO pushTask);\n \n     /**\n-     * Pulls the given user, group or any object from the External Resource into Syncope.\n+     * Pulls the matching user, group, any object or linked account from the External Resource into Syncope.\n      *\n-     * @param anyTypeKind anyTypeKind\n-     * @param anyKey user, group or any object: if value looks like a UUID then it is interpreted as key, otherwise as\n-     * a (user)name\n-     * @param resourceKey resource key\n+     * @param query query conditions\n      * @param pullTask pull specification\n      */\n     @ApiResponses(\n@@ -100,9 +83,5 @@ void push(\n     @Path(\"pull\")\n     @Consumes({ MediaType.APPLICATION_JSON, RESTHeaders.APPLICATION_YAML, MediaType.APPLICATION_XML })\n     @Produces({ MediaType.APPLICATION_JSON, RESTHeaders.APPLICATION_YAML, MediaType.APPLICATION_XML })\n-    void pull(\n-            @NotNull @QueryParam(\"anyTypeKind\") AnyTypeKind anyTypeKind,\n-            @NotNull @QueryParam(\"anyKey\") String anyKey,\n-            @NotNull @QueryParam(\"resourceKey\") String resourceKey,\n-            @NotNull PullTaskTO pullTask);\n+    void pull(@BeanParam ReconQuery query, @NotNull PullTaskTO pullTask);\n }"},{"sha":"6d4b822ee15e14885dd8f7b4f5363eefdedb78e6","filename":"common/idrepo/lib/src/main/java/org/apache/syncope/common/lib/collections/IteratorChain.java","status":"removed","additions":0,"deletions":281,"changes":281,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/4b20e81b05948da257eded5601b5538cf92f919d/common%2Fidrepo%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fcollections%2FIteratorChain.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/4b20e81b05948da257eded5601b5538cf92f919d/common%2Fidrepo%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fcollections%2FIteratorChain.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/common%2Fidrepo%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fcollections%2FIteratorChain.java?ref=4b20e81b05948da257eded5601b5538cf92f919d","patch":"@@ -1,281 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-package org.apache.syncope.common.lib.collections;\n-\n-import java.util.Collection;\n-import java.util.Collections;\n-import java.util.Iterator;\n-import java.util.LinkedList;\n-import java.util.Queue;\n-\n-/**\n- * An IteratorChain is an Iterator that wraps a number of Iterators.\n- *\n- * This class makes multiple iterators look like one to the caller. When any\n- * method from the Iterator interface is called, the IteratorChain will delegate\n- * to a single underlying Iterator. The IteratorChain will invoke the Iterators\n- * in sequence until all Iterators are exhausted.\n- *\n- * Under many circumstances, linking Iterators together in this manner is more\n- * efficient (and convenient) than reading out the contents of each Iterator\n- * into a List and creating a new Iterator.\n- *\n- * Calling a method that adds new Iterator <i>after a method in the Iterator\n- * interface has been called</i> will result in an UnsupportedOperationException.\n- *\n- * NOTE: As from version 3.0, the IteratorChain may contain no iterators. In\n- * this case the class will function as an empty iterator.\n- *\n- * NOTE: As from version 4.0, the IteratorChain stores the iterators in a queue\n- * and removes any reference to them as soon as they are not used anymore. Thus\n- * the methods {@code setIterator(Iterator)} and {@code getIterators()} have been\n- * removed and {@link #size()} will return the number of remaining iterators in\n- * the queue.\n- *\n- * @param <E> the type of elements held in this collection\n- */\n-public class IteratorChain<E> implements Iterator<E> {\n-\n-    /** The chain of iterators. */\n-    private final Queue<Iterator<? extends E>> iteratorChain = new LinkedList<>();\n-\n-    /** The current iterator. */\n-    private Iterator<? extends E> currentIterator = null;\n-\n-    /**\n-     * The \"last used\" Iterator is the Iterator upon which next() or hasNext()\n-     * was most recently called used for the remove() operation only.\n-     */\n-    private Iterator<? extends E> lastUsedIterator = null;\n-\n-    /**\n-     * ComparatorChain is \"locked\" after the first time compare(Object,Object)\n-     * is called.\n-     */\n-    private boolean isLocked = false;\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Construct an IteratorChain with no Iterators.\n-     *\n-     * You will normally use {@link #addIterator(Iterator)} to add some\n-     * iterators after using this constructor.\n-     */\n-    public IteratorChain() {\n-        super();\n-    }\n-\n-    /**\n-     * Construct an IteratorChain with a single Iterator.\n-     *\n-     * This method takes one iterator. The newly constructed iterator will\n-     * iterate through that iterator. Thus calling this constructor on its own\n-     * will have no effect other than decorating the input iterator.\n-     *\n-     * You will normally use {@link #addIterator(Iterator)} to add some more\n-     * iterators after using this constructor.\n-     *\n-     * @param iterator the first child iterator in the IteratorChain, not null\n-     * @throws NullPointerException if the iterator is null\n-     */\n-    public IteratorChain(final Iterator<? extends E> iterator) {\n-        super();\n-        addIterator(iterator);\n-    }\n-\n-    /**\n-     * Constructs a new {@code IteratorChain} over the two given iterators.\n-     *\n-     * This method takes two iterators. The newly constructed iterator will\n-     * iterate through each one of the input iterators in turn.\n-     *\n-     * @param first the first child iterator in the IteratorChain, not null\n-     * @param second the second child iterator in the IteratorChain, not null\n-     * @throws NullPointerException if either iterator is null\n-     */\n-    public IteratorChain(final Iterator<? extends E> first, final Iterator<? extends E> second) {\n-        super();\n-        addIterator(first);\n-        addIterator(second);\n-    }\n-\n-    /**\n-     * Constructs a new {@code IteratorChain} over the array of iterators.\n-     *\n-     * This method takes an array of iterators. The newly constructed iterator\n-     * will iterate through each one of the input iterators in turn.\n-     *\n-     * @param iteratorChain the array of iterators, not null\n-     * @throws NullPointerException if iterators array is or contains null\n-     */\n-    @SafeVarargs\n-    public IteratorChain(final Iterator<? extends E>... iteratorChain) {\n-        super();\n-        for (final Iterator<? extends E> element : iteratorChain) {\n-            addIterator(element);\n-        }\n-    }\n-\n-    /**\n-     * Constructs a new {@code IteratorChain} over the collection of\n-     * iterators.\n-     *\n-     * This method takes a collection of iterators. The newly constructed\n-     * iterator will iterate through each one of the input iterators in turn.\n-     *\n-     * @param iteratorChain the collection of iterators, not null\n-     * @throws NullPointerException if iterators collection is or contains null\n-     * @throws ClassCastException if iterators collection doesn't contain an\n-     * iterator\n-     */\n-    public IteratorChain(final Collection<Iterator<? extends E>> iteratorChain) {\n-        super();\n-        iteratorChain.forEach(this::addIterator);\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Add an Iterator to the end of the chain\n-     *\n-     * @param iterator Iterator to add\n-     * @throws IllegalStateException if I've already started iterating\n-     * @throws NullPointerException if the iterator is null\n-     */\n-    private void addIterator(final Iterator<? extends E> iterator) {\n-        checkLocked();\n-        if (iterator == null) {\n-            throw new NullPointerException(\"Iterator must not be null\");\n-        }\n-        iteratorChain.add(iterator);\n-    }\n-\n-    /**\n-     * Returns the remaining number of Iterators in the current IteratorChain.\n-     *\n-     * @return Iterator count\n-     */\n-    public int size() {\n-        return iteratorChain.size();\n-    }\n-\n-    /**\n-     * Determine if modifications can still be made to the IteratorChain.\n-     * IteratorChains cannot be modified once they have executed a method from\n-     * the Iterator interface.\n-     *\n-     * @return true if IteratorChain cannot be modified, false if it can\n-     */\n-    public boolean isLocked() {\n-        return isLocked;\n-    }\n-\n-    /**\n-     * Checks whether the iterator chain is now locked and in use.\n-     */\n-    private void checkLocked() {\n-        if (isLocked) {\n-            throw new UnsupportedOperationException(\n-                    \"IteratorChain cannot be changed after the first use of a method from the Iterator interface\");\n-        }\n-    }\n-\n-    /**\n-     * Lock the chain so no more iterators can be added. This must be called\n-     * from all Iterator interface methods.\n-     */\n-    private void lockChain() {\n-        if (!isLocked) {\n-            isLocked = true;\n-        }\n-    }\n-\n-    /**\n-     * Updates the current iterator field to ensure that the current Iterator is\n-     * not exhausted\n-     */\n-    protected void updateCurrentIterator() {\n-        if (currentIterator == null) {\n-            if (iteratorChain.isEmpty()) {\n-                currentIterator = Collections.emptyListIterator();\n-            } else {\n-                currentIterator = iteratorChain.remove();\n-            }\n-            // set last used iterator here, in case the user calls remove\n-            // before calling hasNext() or next() (although they shouldn't)\n-            lastUsedIterator = currentIterator;\n-        }\n-\n-        while (!currentIterator.hasNext() && !iteratorChain.isEmpty()) {\n-            currentIterator = iteratorChain.remove();\n-        }\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Return true if any Iterator in the IteratorChain has a remaining element.\n-     *\n-     * @return true if elements remain\n-     */\n-    @Override\n-    public boolean hasNext() {\n-        lockChain();\n-        updateCurrentIterator();\n-        lastUsedIterator = currentIterator;\n-\n-        return currentIterator.hasNext();\n-    }\n-\n-    /**\n-     * Returns the next Object of the current Iterator\n-     *\n-     * @return Object from the current Iterator\n-     * @throws java.util.NoSuchElementException if all the Iterators are\n-     * exhausted\n-     */\n-    @Override\n-    public E next() {\n-        lockChain();\n-        updateCurrentIterator();\n-        lastUsedIterator = currentIterator;\n-\n-        return currentIterator.next();\n-    }\n-\n-    /**\n-     * Removes from the underlying collection the last element returned by the\n-     * Iterator. As with next() and hasNext(), this method calls remove() on the\n-     * underlying Iterator. Therefore, this method may throw an\n-     * UnsupportedOperationException if the underlying Iterator does not support\n-     * this method.\n-     *\n-     * @throws UnsupportedOperationException if the remove operator is not\n-     * supported by the underlying Iterator\n-     * @throws IllegalStateException if the next method has not yet been called,\n-     * or the remove method has already been called after the last call to the\n-     * next method.\n-     */\n-    @Override\n-    public void remove() {\n-        lockChain();\n-        if (currentIterator == null) {\n-            updateCurrentIterator();\n-        }\n-        lastUsedIterator.remove();\n-    }\n-}"},{"sha":"0885aacad83e5e21a4c9de76ab93442fec02bf3e","filename":"common/idrepo/lib/src/main/java/org/apache/syncope/common/lib/types/MatchType.java","status":"added","additions":28,"deletions":0,"changes":28,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/64495efbbc906599bf3c7de1c0692a7c3139b024/common%2Fidrepo%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Ftypes%2FMatchType.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/64495efbbc906599bf3c7de1c0692a7c3139b024/common%2Fidrepo%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Ftypes%2FMatchType.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/common%2Fidrepo%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Ftypes%2FMatchType.java?ref=64495efbbc906599bf3c7de1c0692a7c3139b024","patch":"@@ -0,0 +1,28 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.common.lib.types;\n+\n+import javax.xml.bind.annotation.XmlEnum;\n+\n+@XmlEnum\n+public enum MatchType {\n+    ANY,\n+    LINKED_ACCOUNT;\n+\n+}"},{"sha":"c34b10c878091acce7776ca1d737ba0c4f637c13","filename":"core/idm/logic/pom.xml","status":"modified","additions":5,"deletions":0,"changes":5,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fidm%2Flogic%2Fpom.xml","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fidm%2Flogic%2Fpom.xml","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fidm%2Flogic%2Fpom.xml?ref=64495efbbc906599bf3c7de1c0692a7c3139b024","patch":"@@ -43,6 +43,11 @@ under the License.\n       <artifactId>syncope-core-idrepo-logic</artifactId>\n       <version>${project.version}</version>\n     </dependency>\n+    <dependency>\n+      <groupId>org.apache.syncope.common.idm</groupId>\n+      <artifactId>syncope-common-idm-rest-api</artifactId>\n+      <version>${project.version}</version>\n+    </dependency>\n   </dependencies>\n \n   <build>"},{"sha":"490864f595cbe08f14ff53c42da9a3ebc0a15b53","filename":"core/idm/logic/src/main/java/org/apache/syncope/core/logic/ReconciliationLogic.java","status":"modified","additions":200,"deletions":103,"changes":303,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fidm%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Flogic%2FReconciliationLogic.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fidm%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Flogic%2FReconciliationLogic.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fidm%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Flogic%2FReconciliationLogic.java?ref=64495efbbc906599bf3c7de1c0692a7c3139b024","patch":"@@ -19,14 +19,15 @@\n package org.apache.syncope.core.logic;\n \n import java.lang.reflect.Method;\n-import java.util.Iterator;\n+import java.util.ArrayList;\n import java.util.List;\n+import java.util.Optional;\n import java.util.Set;\n-import java.util.stream.Collectors;\n+import org.apache.commons.lang3.StringUtils;\n import org.apache.commons.lang3.tuple.Pair;\n-import org.apache.syncope.common.lib.SyncopeClientException;\n-import org.apache.syncope.common.lib.collections.IteratorChain;\n import org.apache.syncope.common.lib.Attr;\n+import org.apache.syncope.common.lib.SyncopeClientException;\n+import org.apache.syncope.common.lib.SyncopeConstants;\n import org.apache.syncope.common.lib.to.ConnObjectTO;\n import org.apache.syncope.common.lib.to.EntityTO;\n import org.apache.syncope.common.lib.to.PullTaskTO;\n@@ -36,29 +37,32 @@\n import org.apache.syncope.common.lib.types.ClientExceptionType;\n import org.apache.syncope.common.lib.types.IdMEntitlement;\n import org.apache.syncope.common.lib.types.IdRepoEntitlement;\n+import org.apache.syncope.common.lib.types.MatchType;\n+import org.apache.syncope.common.rest.api.beans.ReconQuery;\n+import org.apache.syncope.core.persistence.api.dao.AnyDAO;\n+import org.apache.syncope.core.persistence.api.dao.AnyTypeDAO;\n import org.apache.syncope.core.persistence.api.dao.ExternalResourceDAO;\n import org.apache.syncope.core.persistence.api.dao.NotFoundException;\n-import org.apache.syncope.core.persistence.api.dao.VirSchemaDAO;\n+import org.apache.syncope.core.persistence.api.dao.RealmDAO;\n import org.apache.syncope.core.persistence.api.entity.Any;\n-import org.apache.syncope.core.persistence.api.entity.AnyUtils;\n+import org.apache.syncope.core.persistence.api.entity.AnyType;\n import org.apache.syncope.core.persistence.api.entity.AnyUtilsFactory;\n-import org.apache.syncope.core.persistence.api.entity.VirSchema;\n import org.apache.syncope.core.persistence.api.entity.resource.ExternalResource;\n import org.apache.syncope.core.persistence.api.entity.resource.MappingItem;\n import org.apache.syncope.core.persistence.api.entity.resource.Provision;\n-import org.apache.syncope.core.provisioning.api.Connector;\n+import org.apache.syncope.core.persistence.api.entity.user.LinkedAccount;\n import org.apache.syncope.core.provisioning.api.ConnectorFactory;\n import org.apache.syncope.core.provisioning.api.MappingManager;\n+import org.apache.syncope.core.provisioning.api.VirAttrHandler;\n import org.apache.syncope.core.provisioning.api.pushpull.ProvisioningReport;\n import org.apache.syncope.core.provisioning.api.pushpull.SyncopeSinglePullExecutor;\n import org.apache.syncope.core.provisioning.api.pushpull.SyncopeSinglePushExecutor;\n+import org.apache.syncope.core.provisioning.java.pushpull.InboundMatcher;\n+import org.apache.syncope.core.provisioning.java.pushpull.OutboundMatcher;\n import org.apache.syncope.core.provisioning.java.utils.ConnObjectUtils;\n import org.apache.syncope.core.provisioning.java.utils.MappingUtils;\n import org.identityconnectors.framework.common.objects.Attribute;\n-import org.identityconnectors.framework.common.objects.AttributeBuilder;\n-import org.identityconnectors.framework.common.objects.AttributeUtil;\n import org.identityconnectors.framework.common.objects.ConnectorObject;\n-import org.identityconnectors.framework.common.objects.Name;\n import org.identityconnectors.framework.common.objects.Uid;\n import org.quartz.JobExecutionException;\n import org.springframework.beans.factory.annotation.Autowired;\n@@ -71,15 +75,27 @@ public class ReconciliationLogic extends AbstractTransactionalLogic<EntityTO> {\n     @Autowired\n     private AnyUtilsFactory anyUtilsFactory;\n \n+    @Autowired\n+    private AnyTypeDAO anyTypeDAO;\n+\n     @Autowired\n     private ExternalResourceDAO resourceDAO;\n \n     @Autowired\n-    private VirSchemaDAO virSchemaDAO;\n+    private RealmDAO realmDAO;\n+\n+    @Autowired\n+    private VirAttrHandler virAttrHandler;\n \n     @Autowired\n     private MappingManager mappingManager;\n \n+    @Autowired\n+    private InboundMatcher inboundMatcher;\n+\n+    @Autowired\n+    private OutboundMatcher outboundMatcher;\n+\n     @Autowired\n     private ConnectorFactory connFactory;\n \n@@ -89,118 +105,190 @@ public class ReconciliationLogic extends AbstractTransactionalLogic<EntityTO> {\n     @Autowired\n     private SyncopeSinglePushExecutor singlePushExecutor;\n \n-    @SuppressWarnings(\"unchecked\")\n-    private Pair<Any<?>, Provision> init(final AnyTypeKind anyTypeKind, final String anyKey, final String resourceKey) {\n-        AnyUtils anyUtils = anyUtilsFactory.getInstance(anyTypeKind);\n-\n-        Any<?> any = anyUtils.dao().authFind(anyKey);\n-        if (any == null) {\n-            throw new NotFoundException(anyTypeKind + \" '\" + anyKey + '\\'');\n+    private Provision getProvision(final String anyTypeKey, final String resourceKey) {\n+        AnyType anyType = anyTypeDAO.find(anyTypeKey);\n+        if (anyType == null) {\n+            throw new NotFoundException(\"AnyType '\" + anyTypeKey + \"'\");\n         }\n \n         ExternalResource resource = resourceDAO.find(resourceKey);\n         if (resource == null) {\n-            throw new NotFoundException(\"Resource '\" + resourceKey + '\\'');\n+            throw new NotFoundException(\"Resource '\" + resourceKey + \"'\");\n         }\n-        Provision provision = resource.getProvision(any.getType()).orElseThrow(()\n-                -> new NotFoundException(\"Provision for \" + any.getType() + \" on Resource '\" + resourceKey + '\\''));\n+        Provision provision = resource.getProvision(anyType).\n+                orElseThrow(() -> new NotFoundException(\n+                \"Provision for \" + anyType + \" on Resource '\" + resourceKey + \"'\"));\n         if (provision.getMapping() == null) {\n-            throw new NotFoundException(\"Mapping for \" + any.getType() + \" on Resource '\" + resourceKey + '\\'');\n+            throw new NotFoundException(\"Mapping for \" + anyType + \" on Resource '\" + resourceKey + \"'\");\n         }\n \n-        return (Pair<Any<?>, Provision>) Pair.of(any, provision);\n+        return provision;\n     }\n \n-    private ConnObjectTO getOnSyncope(final Any<?> any, final Provision provision, final String resourceKey) {\n-        Pair<String, Set<Attribute>> attrs = mappingManager.prepareAttrs(any, null, false, true, provision);\n+    private ConnObjectTO getOnSyncope(\n+            final MappingItem connObjectKeyItem,\n+            final String connObjectKeyValue,\n+            final Set<Attribute> attrs) {\n \n-        MappingItem connObjectKey = provision.getMapping().getConnObjectKeyItem().orElseThrow(()\n-                -> new NotFoundException(\"No RemoteKey set for \" + resourceKey));\n-\n-        ConnObjectTO connObjectTO = ConnObjectUtils.getConnObjectTO(attrs.getRight());\n-        if (attrs.getLeft() != null) {\n-            connObjectTO.getAttrs().add(new Attr.Builder(connObjectKey.getExtAttrName()).\n-                    value(attrs.getLeft()).build());\n-            connObjectTO.getAttrs().add(new Attr.Builder(Uid.NAME).\n-                    value(attrs.getLeft()).build());\n-        }\n+        ConnObjectTO connObjectTO = ConnObjectUtils.getConnObjectTO(attrs);\n+        connObjectTO.getAttrs().add(new Attr.Builder(connObjectKeyItem.getExtAttrName()).\n+                value(connObjectKeyValue).build());\n+        connObjectTO.getAttrs().add(new Attr.Builder(Uid.NAME).\n+                value(connObjectKeyValue).build());\n \n         return connObjectTO;\n     }\n \n-    private ConnObjectTO getOnResource(final Any<?> any, final Provision provision) {\n-        // 1. build connObjectKeyItem\n-        MappingItem connObjectKeyItem = MappingUtils.getConnObjectKeyItem(provision).orElseThrow(()\n-                -> new NotFoundException(\"ConnObjectKey for \" + any.getType()\n-                        + \" on resource '\" + provision.getResource().getKey() + '\\''));\n-        String connObjectKeyValue = mappingManager.getConnObjectKeyValue(any, provision).orElse(null);\n-        if (connObjectKeyValue == null) {\n-            return null;\n-        }\n+    private ConnObjectTO getOnSyncope(\n+            final Any<?> any,\n+            final MappingItem connObjectKeyItem,\n+            final Provision provision) {\n \n-        // 2. determine attributes to query\n-        Set<MappingItem> linkinMappingItems = virSchemaDAO.findByProvision(provision).stream().\n-                map(VirSchema::asLinkingMappingItem).collect(Collectors.toSet());\n-        Iterator<MappingItem> mapItems = new IteratorChain<>(\n-                provision.getMapping().getItems().iterator(),\n-                linkinMappingItems.iterator());\n-\n-        // 3. read from the underlying connector\n-        ConnObjectTO connObjectTO = null;\n-\n-        Connector connector = connFactory.getConnector(provision.getResource());\n-        ConnectorObject connectorObject = connector.getObject(\n-                provision.getObjectClass(),\n-                AttributeBuilder.build(connObjectKeyItem.getExtAttrName(), connObjectKeyValue),\n-                provision.isIgnoreCaseMatch(),\n-                MappingUtils.buildOperationOptions(mapItems));\n-        if (connectorObject != null) {\n-            Set<Attribute> attributes = connectorObject.getAttributes();\n-            if (AttributeUtil.find(Uid.NAME, attributes) == null) {\n-                attributes.add(connectorObject.getUid());\n-            }\n-            if (AttributeUtil.find(Name.NAME, attributes) == null) {\n-                attributes.add(connectorObject.getName());\n-            }\n+        Pair<String, Set<Attribute>> prepared = mappingManager.prepareAttrs(any, null, false, true, provision);\n+        return getOnSyncope(connObjectKeyItem, prepared.getLeft(), prepared.getRight());\n+    }\n \n-            connObjectTO = ConnObjectUtils.getConnObjectTO(attributes);\n-        }\n+    private ConnObjectTO getOnSyncope(\n+            final LinkedAccount account,\n+            final MappingItem connObjectKeyItem,\n+            final Provision provision) {\n \n-        return connObjectTO;\n+        Set<Attribute> attrs = mappingManager.prepareAttrs(account.getOwner(), account, null, false, provision);\n+        return getOnSyncope(connObjectKeyItem, account.getConnObjectKeyValue(), attrs);\n+    }\n+\n+    private Any<?> getAny(final Provision provision, final String anyKey) {\n+        AnyDAO<Any<?>> dao = anyUtilsFactory.getInstance(provision.getAnyType().getKind()).dao();\n+        Any<?> any = SyncopeConstants.UUID_PATTERN.matcher(anyKey).matches()\n+                ? dao.authFind(anyKey)\n+                : dao.authFind(dao.findKey(anyKey));\n+        if (any == null) {\n+            throw new NotFoundException(provision.getAnyType().getKey() + \" '\" + anyKey + \"'\");\n+        }\n+        return any;\n     }\n \n     @PreAuthorize(\"hasRole('\" + IdMEntitlement.RESOURCE_GET_CONNOBJECT + \"')\")\n-    public ReconStatus status(final AnyTypeKind anyTypeKind, final String anyKey, final String resourceKey) {\n-        Pair<Any<?>, Provision> init = init(anyTypeKind, anyKey, resourceKey);\n+    public ReconStatus status(final ReconQuery query) {\n+        Provision provision = getProvision(query.getAnyTypeKey(), query.getResourceKey());\n+\n+        MappingItem connObjectKeyItem = MappingUtils.getConnObjectKeyItem(provision).\n+                orElseThrow(() -> new NotFoundException(\n+                \"ConnObjectKey for \" + provision.getAnyType().getKey()\n+                + \" on resource '\" + provision.getResource().getKey() + \"'\"));\n \n         ReconStatus status = new ReconStatus();\n-        status.setOnSyncope(getOnSyncope(init.getLeft(), init.getRight(), resourceKey));\n-        status.setOnResource(getOnResource(init.getLeft(), init.getRight()));\n+\n+        if (query.getConnObjectKeyValue() != null) {\n+            inboundMatcher.matchByConnObjectKeyValue(connObjectKeyItem, query.getConnObjectKeyValue(), provision).\n+                    stream().findFirst().ifPresent(match -> {\n+                        if (match.getAny() != null) {\n+                            status.setMatchType(MatchType.ANY);\n+                            status.setAnyTypeKind(match.getAny().getType().getKind());\n+                            status.setAnyKey(match.getAny().getKey());\n+                            status.setOnSyncope(getOnSyncope(match.getAny(), connObjectKeyItem, provision));\n+                        } else if (match.getLinkedAccount() != null) {\n+                            status.setMatchType(MatchType.LINKED_ACCOUNT);\n+                            status.setAnyTypeKind(AnyTypeKind.USER);\n+                            status.setAnyKey(match.getLinkedAccount().getOwner().getKey());\n+                            status.setOnSyncope(getOnSyncope(match.getLinkedAccount(), connObjectKeyItem, provision));\n+                        }\n+                    });\n+\n+            outboundMatcher.matchByConnObjectKeyValue(\n+                    connFactory.getConnector(provision.getResource()),\n+                    connObjectKeyItem,\n+                    query.getConnObjectKeyValue(),\n+                    provision).\n+                    ifPresent(connObj -> {\n+                        status.setOnResource(ConnObjectUtils.getConnObjectTO(connObj.getAttributes()));\n+\n+                        if (status.getMatchType() == MatchType.ANY && StringUtils.isNotBlank(status.getAnyKey())) {\n+                            virAttrHandler.setValues(getAny(provision, status.getAnyKey()), connObj);\n+                        }\n+                    });\n+        }\n+        if (query.getAnyKey() != null) {\n+            Any<?> any = getAny(provision, query.getAnyKey());\n+            status.setMatchType(MatchType.ANY);\n+            status.setAnyTypeKind(any.getType().getKind());\n+            status.setAnyKey(any.getKey());\n+            status.setOnSyncope(getOnSyncope(any, connObjectKeyItem, provision));\n+\n+            List<ConnectorObject> connObjs = outboundMatcher.match(\n+                    connFactory.getConnector(provision.getResource()), any, provision);\n+            if (!connObjs.isEmpty()) {\n+                status.setOnResource(ConnObjectUtils.getConnObjectTO(connObjs.get(0).getAttributes()));\n+\n+                if (connObjs.size() > 1) {\n+                    LOG.warn(\"Expected single match, found {}\", connObjs);\n+                } else {\n+                    virAttrHandler.setValues(any, connObjs.get(0));\n+                }\n+            }\n+        }\n \n         return status;\n     }\n \n     @PreAuthorize(\"hasRole('\" + IdRepoEntitlement.TASK_EXECUTE + \"')\")\n-    public void push(\n-            final AnyTypeKind anyTypeKind,\n-            final String anyKey,\n-            final String resourceKey,\n-            final PushTaskTO pushTask) {\n+    public void push(final ReconQuery query, final PushTaskTO pushTask) {\n+        Provision provision = getProvision(query.getAnyTypeKey(), query.getResourceKey());\n \n-        Pair<Any<?>, Provision> init = init(anyTypeKind, anyKey, resourceKey);\n+        MappingItem connObjectKeyItem = MappingUtils.getConnObjectKeyItem(provision).\n+                orElseThrow(() -> new NotFoundException(\n+                \"ConnObjectKey for \" + provision.getAnyType().getKey()\n+                + \" on resource '\" + provision.getResource().getKey() + \"'\"));\n \n         SyncopeClientException sce = SyncopeClientException.build(ClientExceptionType.Reconciliation);\n-        try {\n-            List<ProvisioningReport> results = singlePushExecutor.push(\n-                    init.getRight(),\n-                    connFactory.getConnector(init.getRight().getResource()),\n-                    init.getLeft(),\n-                    pushTask);\n-            if (!results.isEmpty() && results.get(0).getStatus() == ProvisioningReport.Status.FAILURE) {\n-                sce.getElements().add(results.get(0).getMessage());\n+        List<ProvisioningReport> results = new ArrayList<>();\n+\n+        if (query.getConnObjectKeyValue() != null) {\n+            inboundMatcher.matchByConnObjectKeyValue(connObjectKeyItem, query.getConnObjectKeyValue(), provision).\n+                    stream().findFirst().ifPresent(match -> {\n+                        try {\n+                            if (match.getMatchTarget() == MatchType.ANY) {\n+                                results.addAll(singlePushExecutor.push(\n+                                        provision,\n+                                        connFactory.getConnector(provision.getResource()),\n+                                        match.getAny(),\n+                                        pushTask));\n+                                if (!results.isEmpty()\n+                                        && results.get(0).getStatus() == ProvisioningReport.Status.FAILURE) {\n+\n+                                    sce.getElements().add(results.get(0).getMessage());\n+                                }\n+                            } else {\n+                                ProvisioningReport result = singlePushExecutor.push(\n+                                        provision,\n+                                        connFactory.getConnector(provision.getResource()),\n+                                        match.getLinkedAccount(),\n+                                        pushTask);\n+                                if (result.getStatus() == ProvisioningReport.Status.FAILURE) {\n+                                    sce.getElements().add(results.get(0).getMessage());\n+                                } else {\n+                                    results.add(result);\n+                                }\n+                            }\n+                        } catch (JobExecutionException e) {\n+                            sce.getElements().add(e.getMessage());\n+                        }\n+                    });\n+        }\n+\n+        if (sce.isEmpty() && results.isEmpty() && query.getAnyKey() != null) {\n+            try {\n+                results.addAll(singlePushExecutor.push(\n+                        provision,\n+                        connFactory.getConnector(provision.getResource()),\n+                        getAny(provision, query.getAnyKey()),\n+                        pushTask));\n+                if (!results.isEmpty() && results.get(0).getStatus() == ProvisioningReport.Status.FAILURE) {\n+                    sce.getElements().add(results.get(0).getMessage());\n+                }\n+            } catch (JobExecutionException e) {\n+                sce.getElements().add(e.getMessage());\n             }\n-        } catch (JobExecutionException e) {\n-            sce.getElements().add(e.getMessage());\n         }\n \n         if (!sce.isEmpty()) {\n@@ -209,22 +297,31 @@ public void push(\n     }\n \n     @PreAuthorize(\"hasRole('\" + IdRepoEntitlement.TASK_EXECUTE + \"')\")\n-    public void pull(\n-            final AnyTypeKind anyTypeKind,\n-            final String anyKey,\n-            final String resourceKey,\n-            final PullTaskTO pullTask) {\n+    public void pull(final ReconQuery query, final PullTaskTO pullTask) {\n+        Provision provision = getProvision(query.getAnyTypeKey(), query.getResourceKey());\n \n-        Pair<Any<?>, Provision> init = init(anyTypeKind, anyKey, resourceKey);\n+        Optional<String> connObjectKeyValue = Optional.ofNullable(query.getConnObjectKeyValue());\n+        if (query.getAnyKey() != null) {\n+            Any<?> any = getAny(provision, query.getAnyKey());\n+            connObjectKeyValue = mappingManager.getConnObjectKeyValue(any, provision);\n+        }\n+        if (!connObjectKeyValue.isPresent()) {\n+            throw new NotFoundException(\n+                    \"ConnObjectKey for \" + provision.getAnyType().getKey()\n+                    + \" on resource '\" + provision.getResource().getKey() + \"'\");\n+        }\n+\n+        if (pullTask.getDestinationRealm() == null || realmDAO.findByFullPath(pullTask.getDestinationRealm()) == null) {\n+            throw new NotFoundException(\"Realm \" + pullTask.getDestinationRealm());\n+        }\n \n         SyncopeClientException sce = SyncopeClientException.build(ClientExceptionType.Reconciliation);\n         try {\n             List<ProvisioningReport> results = singlePullExecutor.pull(\n-                    init.getRight(),\n-                    connFactory.getConnector(init.getRight().getResource()),\n-                    init.getRight().getMapping().getConnObjectKeyItem().get().getExtAttrName(),\n-                    mappingManager.getConnObjectKeyValue(init.getLeft(), init.getRight()).get(),\n-                    init.getLeft().getRealm(),\n+                    provision,\n+                    connFactory.getConnector(provision.getResource()),\n+                    provision.getMapping().getConnObjectKeyItem().get().getExtAttrName(),\n+                    connObjectKeyValue.get(),\n                     pullTask);\n             if (!results.isEmpty() && results.get(0).getStatus() == ProvisioningReport.Status.FAILURE) {\n                 sce.getElements().add(results.get(0).getMessage());"},{"sha":"29befbf4e79c5c120476b1cd09be3f93086169ac","filename":"core/idm/logic/src/main/java/org/apache/syncope/core/logic/ResourceLogic.java","status":"modified","additions":56,"deletions":81,"changes":137,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fidm%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Flogic%2FResourceLogic.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fidm%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Flogic%2FResourceLogic.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fidm%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Flogic%2FResourceLogic.java?ref=64495efbbc906599bf3c7de1c0692a7c3139b024","patch":"@@ -20,15 +20,14 @@\n \n import java.lang.reflect.Method;\n import java.util.ArrayList;\n-import java.util.Iterator;\n import java.util.List;\n import java.util.Optional;\n import java.util.Set;\n import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n import org.apache.commons.lang3.StringUtils;\n import org.apache.commons.lang3.ArrayUtils;\n import org.apache.commons.lang3.tuple.Pair;\n-import org.apache.syncope.common.lib.collections.IteratorChain;\n import org.apache.syncope.common.lib.SyncopeClientException;\n import org.apache.syncope.common.lib.SyncopeConstants;\n import org.apache.syncope.common.lib.to.ConnObjectTO;\n@@ -54,21 +53,17 @@\n import org.apache.syncope.core.persistence.api.entity.ConnInstance;\n import org.apache.syncope.core.persistence.api.entity.VirSchema;\n import org.apache.syncope.core.persistence.api.entity.resource.Provision;\n-import org.apache.syncope.core.provisioning.api.MappingManager;\n+import org.apache.syncope.core.provisioning.api.VirAttrHandler;\n import org.apache.syncope.core.provisioning.api.data.ConnInstanceDataBinder;\n import org.apache.syncope.core.provisioning.api.utils.RealmUtils;\n+import org.apache.syncope.core.provisioning.java.pushpull.OutboundMatcher;\n import org.apache.syncope.core.provisioning.java.utils.MappingUtils;\n import org.apache.syncope.core.spring.security.AuthContextUtils;\n import org.apache.syncope.core.spring.security.DelegatedAdministrationException;\n-import org.identityconnectors.framework.common.objects.Attribute;\n-import org.identityconnectors.framework.common.objects.AttributeBuilder;\n-import org.identityconnectors.framework.common.objects.AttributeUtil;\n import org.identityconnectors.framework.common.objects.ConnectorObject;\n-import org.identityconnectors.framework.common.objects.Name;\n import org.identityconnectors.framework.common.objects.ObjectClass;\n import org.identityconnectors.framework.common.objects.OperationOptions;\n import org.identityconnectors.framework.common.objects.SearchResult;\n-import org.identityconnectors.framework.common.objects.Uid;\n import org.identityconnectors.framework.common.objects.filter.Filter;\n import org.identityconnectors.framework.spi.SearchResultsHandler;\n import org.springframework.beans.factory.annotation.Autowired;\n@@ -91,14 +86,17 @@ public class ResourceLogic extends AbstractTransactionalLogic<ResourceTO> {\n     @Autowired\n     private VirSchemaDAO virSchemaDAO;\n \n+    @Autowired\n+    private VirAttrHandler virAttrHandler;\n+\n     @Autowired\n     private ResourceDataBinder binder;\n \n     @Autowired\n     private ConnInstanceDataBinder connInstanceDataBinder;\n \n     @Autowired\n-    private MappingManager mappingManager;\n+    private OutboundMatcher outboundMatcher;\n \n     @Autowired\n     private ConnectorFactory connFactory;\n@@ -267,9 +265,7 @@ public List<ResourceTO> list() {\n         return resourceDAO.findAll().stream().map(binder::getResourceTO).collect(Collectors.toList());\n     }\n \n-    private Pair<AnyType, Provision> connObjectInit(\n-            final String resourceKey, final String anyTypeKey) {\n-\n+    private Provision getProvision(final String resourceKey, final String anyTypeKey) {\n         ExternalResource resource = resourceDAO.authFind(resourceKey);\n         if (resource == null) {\n             throw new NotFoundException(\"Resource '\" + resourceKey + '\\'');\n@@ -280,53 +276,9 @@ private Pair<AnyType, Provision> connObjectInit(\n             throw new NotFoundException(\"AnyType '\" + anyTypeKey + '\\'');\n         }\n \n-        Provision provision = resource.getProvision(anyType).\n+        return resource.getProvision(anyType).\n                 orElseThrow(() -> new NotFoundException(\n                 \"Provision on resource '\" + resourceKey + \"' for type '\" + anyTypeKey + \"'\"));\n-\n-        return Pair.of(anyType, provision);\n-    }\n-\n-    private ConnObjectTO readConnObject(\n-            final Provision provision,\n-            final String connObjectKeyValue) {\n-\n-        // 0. build connObjectKeyItem\n-        MappingItem connObjectKeyItem = MappingUtils.getConnObjectKeyItem(provision).\n-                orElseThrow(() -> new NotFoundException(\n-                \"ConnObjectKey mapping for \" + provision.getAnyType().getKey()\n-                + \" on resource '\" + provision.getResource().getKey() + \"'\"));\n-\n-        // 1. determine attributes to query\n-        Set<MappingItem> linkinMappingItems = virSchemaDAO.findByProvision(provision).stream().\n-                map(virSchema -> virSchema.asLinkingMappingItem()).collect(Collectors.toSet());\n-        Iterator<MappingItem> mapItems = new IteratorChain<>(\n-                provision.getMapping().getItems().iterator(),\n-                linkinMappingItems.iterator());\n-\n-        // 2. read from the underlying connector\n-        Connector connector = connFactory.getConnector(provision.getResource());\n-        ConnectorObject connectorObject = connector.getObject(\n-                provision.getObjectClass(),\n-                AttributeBuilder.build(connObjectKeyItem.getExtAttrName(), connObjectKeyValue),\n-                provision.isIgnoreCaseMatch(),\n-                MappingUtils.buildOperationOptions(mapItems));\n-        if (connectorObject == null) {\n-            throw new NotFoundException(\n-                    \"Object \" + connObjectKeyValue + \" with class \" + provision.getObjectClass()\n-                    + \" not found on resource \" + provision.getResource().getKey());\n-        }\n-\n-        // 3. build result\n-        Set<Attribute> attributes = connectorObject.getAttributes();\n-        if (AttributeUtil.find(Uid.NAME, attributes) == null) {\n-            attributes.add(connectorObject.getUid());\n-        }\n-        if (AttributeUtil.find(Name.NAME, attributes) == null) {\n-            attributes.add(connectorObject.getName());\n-        }\n-\n-        return ConnObjectUtils.getConnObjectTO(connectorObject);\n     }\n \n     @PreAuthorize(\"hasRole('\" + IdMEntitlement.RESOURCE_GET_CONNOBJECT + \"')\")\n@@ -336,31 +288,58 @@ public ConnObjectTO readConnObjectByAnyKey(\n             final String anyTypeKey,\n             final String anyKey) {\n \n-        Pair<AnyType, Provision> init = connObjectInit(key, anyTypeKey);\n+        Provision provision = getProvision(key, anyTypeKey);\n \n         // 1. find any\n-        Any<?> any = anyUtilsFactory.getInstance(init.getLeft().getKind()).dao().authFind(anyKey);\n+        Any<?> any = anyUtilsFactory.getInstance(provision.getAnyType().getKind()).dao().authFind(anyKey);\n         if (any == null) {\n-            throw new NotFoundException(init.getLeft() + \" \" + anyKey);\n+            throw new NotFoundException(provision.getAnyType() + \" \" + anyKey);\n         }\n \n-        // 2. find connObjectKeyValue\n-        String connObjectKeyValue = mappingManager.getConnObjectKeyValue(any, init.getRight()).\n-                orElseThrow(() -> new NotFoundException(\n-                \"ConnObjectKey value for \" + init.getLeft() + \" \" + anyKey + \" on resource '\" + key + \"'\"));\n+        // 2. find on resource\n+        List<ConnectorObject> connObjs = outboundMatcher.match(\n+                connFactory.getConnector(provision.getResource()), any, provision);\n+        if (connObjs.isEmpty()) {\n+            throw new NotFoundException(\n+                    \"Object \" + any + \" with class \" + provision.getObjectClass()\n+                    + \" not found on resource \" + provision.getResource().getKey());\n+        }\n+\n+        if (connObjs.size() > 1) {\n+            LOG.warn(\"Expected single match, found {}\", connObjs);\n+        } else {\n+            virAttrHandler.setValues(any, connObjs.get(0));\n+        }\n \n-        return readConnObject(init.getRight(), connObjectKeyValue);\n+        return ConnObjectUtils.getConnObjectTO(connObjs.get(0).getAttributes());\n     }\n \n     @PreAuthorize(\"hasRole('\" + IdMEntitlement.RESOURCE_GET_CONNOBJECT + \"')\")\n     @Transactional(readOnly = true)\n-    public ConnObjectTO readConnObjectByConnObjectKey(\n+    public ConnObjectTO readConnObjectByConnObjectKeyValue(\n             final String key,\n             final String anyTypeKey,\n             final String connObjectKeyValue) {\n \n-        Pair<AnyType, Provision> init = connObjectInit(key, anyTypeKey);\n-        return readConnObject(init.getRight(), connObjectKeyValue);\n+        Provision provision = getProvision(key, anyTypeKey);\n+\n+        MappingItem connObjectKeyItem = MappingUtils.getConnObjectKeyItem(provision).\n+                orElseThrow(() -> new NotFoundException(\n+                \"ConnObjectKey mapping for \" + provision.getAnyType().getKey()\n+                + \" on resource '\" + provision.getResource().getKey() + \"'\"));\n+\n+        Optional<ConnectorObject> connObj = outboundMatcher.matchByConnObjectKeyValue(\n+                connFactory.getConnector(provision.getResource()),\n+                connObjectKeyItem,\n+                connObjectKeyValue,\n+                provision);\n+        if (connObj.isPresent()) {\n+            return ConnObjectUtils.getConnObjectTO(connObj.get().getAttributes());\n+        }\n+\n+        throw new NotFoundException(\n+                \"Object \" + connObjectKeyValue + \" with class \" + provision.getObjectClass()\n+                + \" not found on resource \" + provision.getResource().getKey());\n     }\n \n     @PreAuthorize(\"hasRole('\" + IdMEntitlement.RESOURCE_LIST_CONNOBJECT + \"')\")\n@@ -386,19 +365,15 @@ public Pair<SearchResult, List<ConnObjectTO>> searchConnObjects(\n             }\n \n             objectClass = resource.getOrgUnit().getObjectClass();\n-            options = MappingUtils.buildOperationOptions(\n-                    MappingUtils.getPropagationItems(resource.getOrgUnit().getItems()).iterator());\n+            options = MappingUtils.buildOperationOptions(resource.getOrgUnit().getItems().stream());\n         } else {\n-            Pair<AnyType, Provision> init = connObjectInit(key, anyTypeKey);\n-            resource = init.getRight().getResource();\n-            objectClass = init.getRight().getObjectClass();\n-            init.getRight().getMapping().getItems();\n-\n-            Set<MappingItem> linkinMappingItems = virSchemaDAO.findByProvision(init.getRight()).stream().\n-                    map(VirSchema::asLinkingMappingItem).collect(Collectors.toSet());\n-            Iterator<MappingItem> mapItems = new IteratorChain<>(\n-                    init.getRight().getMapping().getItems().iterator(),\n-                    linkinMappingItems.iterator());\n+            Provision provision = getProvision(key, anyTypeKey);\n+            resource = provision.getResource();\n+            objectClass = provision.getObjectClass();\n+\n+            Stream<MappingItem> mapItems = Stream.concat(\n+                    provision.getMapping().getItems().stream(),\n+                    virSchemaDAO.findByProvision(provision).stream().map(VirSchema::asLinkingMappingItem));\n             options = MappingUtils.buildOperationOptions(mapItems);\n         }\n \n@@ -410,7 +385,7 @@ public Pair<SearchResult, List<ConnObjectTO>> searchConnObjects(\n \n                     @Override\n                     public boolean handle(final ConnectorObject connectorObject) {\n-                        connObjects.add(ConnObjectUtils.getConnObjectTO(connectorObject));\n+                        connObjects.add(ConnObjectUtils.getConnObjectTO(connectorObject.getAttributes()));\n                         // safety protection against uncontrolled result size\n                         count++;\n                         return count < size;"},{"sha":"7b77c2f50c2d7e5ee412a7e80a3815543ffed0c9","filename":"core/idm/rest-cxf/src/main/java/org/apache/syncope/core/rest/cxf/service/ReconciliationServiceImpl.java","status":"modified","additions":18,"deletions":31,"changes":49,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fidm%2Frest-cxf%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Frest%2Fcxf%2Fservice%2FReconciliationServiceImpl.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fidm%2Frest-cxf%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Frest%2Fcxf%2Fservice%2FReconciliationServiceImpl.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fidm%2Frest-cxf%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Frest%2Fcxf%2Fservice%2FReconciliationServiceImpl.java?ref=64495efbbc906599bf3c7de1c0692a7c3139b024","patch":"@@ -18,13 +18,13 @@\n  */\n package org.apache.syncope.core.rest.cxf.service;\n \n+import javax.validation.ValidationException;\n import org.apache.syncope.common.lib.to.PullTaskTO;\n import org.apache.syncope.common.lib.to.PushTaskTO;\n import org.apache.syncope.common.lib.to.ReconStatus;\n-import org.apache.syncope.common.lib.types.AnyTypeKind;\n+import org.apache.syncope.common.rest.api.beans.ReconQuery;\n import org.apache.syncope.common.rest.api.service.ReconciliationService;\n import org.apache.syncope.core.logic.ReconciliationLogic;\n-import org.apache.syncope.core.persistence.api.entity.AnyUtilsFactory;\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.stereotype.Service;\n \n@@ -34,42 +34,29 @@ public class ReconciliationServiceImpl extends AbstractServiceImpl implements Re\n     @Autowired\n     private ReconciliationLogic logic;\n \n-    @Autowired\n-    private AnyUtilsFactory anyUtilsFactory;\n+    private void validate(final ReconQuery reconQuery) {\n+        if ((reconQuery.getAnyKey() == null && reconQuery.getConnObjectKeyValue() == null)\n+                || (reconQuery.getAnyKey() != null && reconQuery.getConnObjectKeyValue() != null)) {\n \n-    @Override\n-    public ReconStatus status(final AnyTypeKind anyTypeKind, final String anyKey, final String resourceKey) {\n-        return logic.status(\n-                anyTypeKind,\n-                getActualKey(anyUtilsFactory.getInstance(anyTypeKind).dao(), anyKey),\n-                resourceKey);\n+            throw new ValidationException(\"Either provide anyKey or connObjectKeyValue, not both\");\n+        }\n     }\n \n     @Override\n-    public void push(\n-            final AnyTypeKind anyTypeKind,\n-            final String anyKey,\n-            final String resourceKey,\n-            final PushTaskTO pushTask) {\n-\n-        logic.push(\n-                anyTypeKind,\n-                getActualKey(anyUtilsFactory.getInstance(anyTypeKind).dao(), anyKey),\n-                resourceKey,\n-                pushTask);\n+    public ReconStatus status(final ReconQuery reconQuery) {\n+        validate(reconQuery);\n+        return logic.status(reconQuery);\n     }\n \n     @Override\n-    public void pull(\n-            final AnyTypeKind anyTypeKind,\n-            final String anyKey,\n-            final String resourceKey,\n-            final PullTaskTO pullTask) {\n+    public void push(final ReconQuery reconQuery, final PushTaskTO pushTask) {\n+        validate(reconQuery);\n+        logic.push(reconQuery, pushTask);\n+    }\n \n-        logic.pull(\n-                anyTypeKind,\n-                getActualKey(anyUtilsFactory.getInstance(anyTypeKind).dao(), anyKey),\n-                resourceKey,\n-                pullTask);\n+    @Override\n+    public void pull(final ReconQuery reconQuery, final PullTaskTO pullTask) {\n+        validate(reconQuery);\n+        logic.pull(reconQuery, pullTask);\n     }\n }"},{"sha":"3eb8954f4e6b7ab7f63f7f84ae421af12ce5c9a2","filename":"core/idm/rest-cxf/src/main/java/org/apache/syncope/core/rest/cxf/service/ResourceServiceImpl.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fidm%2Frest-cxf%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Frest%2Fcxf%2Fservice%2FResourceServiceImpl.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fidm%2Frest-cxf%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Frest%2Fcxf%2Fservice%2FResourceServiceImpl.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fidm%2Frest-cxf%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Frest%2Fcxf%2Fservice%2FResourceServiceImpl.java?ref=64495efbbc906599bf3c7de1c0692a7c3139b024","patch":"@@ -94,7 +94,7 @@ public List<ResourceTO> list() {\n     public ConnObjectTO readConnObject(final String key, final String anyTypeKey, final String value) {\n         return SyncopeConstants.UUID_PATTERN.matcher(value).matches()\n                 ? logic.readConnObjectByAnyKey(key, anyTypeKey, value)\n-                : logic.readConnObjectByConnObjectKey(key, anyTypeKey, value);\n+                : logic.readConnObjectByConnObjectKeyValue(key, anyTypeKey, value);\n     }\n \n     @Override"},{"sha":"1503b4238a24f4080802f9ed85d3823d9e35e6b9","filename":"core/idrepo/logic/src/main/java/org/apache/syncope/core/logic/AnyTypeLogic.java","status":"modified","additions":0,"deletions":1,"changes":1,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fidrepo%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Flogic%2FAnyTypeLogic.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fidrepo%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Flogic%2FAnyTypeLogic.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fidrepo%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Flogic%2FAnyTypeLogic.java?ref=64495efbbc906599bf3c7de1c0692a7c3139b024","patch":"@@ -94,7 +94,6 @@ public AnyTypeTO update(final AnyTypeTO anyTypeTO) {\n         }\n \n         binder.update(anyType, anyTypeTO);\n-        anyType = anyTypeDAO.save(anyType);\n \n         return binder.getAnyTypeTO(anyTypeDAO.save(anyType));\n     }"},{"sha":"47b2bd732ebaf202dc9171205e99f6272c404d99","filename":"core/persistence-api/src/main/java/org/apache/syncope/core/persistence/api/dao/PullCorrelationRule.java","status":"modified","additions":3,"deletions":2,"changes":5,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fpersistence-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fapi%2Fdao%2FPullCorrelationRule.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fpersistence-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fapi%2Fdao%2FPullCorrelationRule.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fpersistence-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fapi%2Fdao%2FPullCorrelationRule.java?ref=64495efbbc906599bf3c7de1c0692a7c3139b024","patch":"@@ -20,6 +20,7 @@\n \n import java.util.Optional;\n import org.apache.syncope.common.lib.policy.PullCorrelationRuleConf;\n+import org.apache.syncope.common.lib.types.MatchType;\n import org.apache.syncope.core.persistence.api.dao.search.SearchCond;\n import org.apache.syncope.core.persistence.api.entity.Any;\n import org.apache.syncope.core.persistence.api.entity.resource.Provision;\n@@ -31,7 +32,7 @@\n @FunctionalInterface\n public interface PullCorrelationRule {\n \n-    PullMatch NO_MATCH = new PullMatch.Builder().build();\n+    PullMatch NO_MATCH = new PullMatch(MatchType.ANY, null);\n \n     default void setConf(PullCorrelationRuleConf conf) {\n     }\n@@ -57,7 +58,7 @@ default void setConf(PullCorrelationRuleConf conf) {\n      * @return matching information\n      */\n     default PullMatch matching(Any<?> any, SyncDelta syncDelta, Provision provision) {\n-        return new PullMatch.Builder().matchingKey(any.getKey()).build();\n+        return new PullMatch(MatchType.ANY, any);\n     }\n \n     /**"},{"sha":"75d292aef073a4e4fd0ae58158cd7a9142c46c51","filename":"core/persistence-api/src/main/java/org/apache/syncope/core/persistence/api/dao/PullMatch.java","status":"modified","additions":25,"deletions":44,"changes":69,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fpersistence-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fapi%2Fdao%2FPullMatch.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fpersistence-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fapi%2Fdao%2FPullMatch.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fpersistence-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fapi%2Fdao%2FPullMatch.java?ref=64495efbbc906599bf3c7de1c0692a7c3139b024","patch":"@@ -21,69 +21,49 @@\n import java.io.Serializable;\n import org.apache.commons.lang3.builder.EqualsBuilder;\n import org.apache.commons.lang3.builder.HashCodeBuilder;\n+import org.apache.syncope.common.lib.types.MatchType;\n+import org.apache.syncope.core.persistence.api.entity.Any;\n+import org.apache.syncope.core.persistence.api.entity.Entity;\n+import org.apache.syncope.core.persistence.api.entity.user.LinkedAccount;\n \n public final class PullMatch implements Serializable {\n \n     private static final long serialVersionUID = 6515473131174179932L;\n \n-    public enum MatchTarget {\n-        ANY,\n-        LINKED_ACCOUNT;\n+    private final MatchType matchTarget;\n \n-    }\n-\n-    public static class Builder {\n-\n-        private final PullMatch instance = new PullMatch();\n+    private Any<?> any;\n \n-        public Builder matchingKey(final String matchingKey) {\n-            instance.matchingKey = matchingKey;\n-            return this;\n-        }\n-\n-        public Builder matchTarget(final MatchTarget matchTarget) {\n-            instance.matchTarget = matchTarget;\n-            return this;\n-        }\n+    private LinkedAccount linkedAccount;\n \n-        public Builder linkingUserKey(final String linkingUserKey) {\n-            instance.linkingUserKey = linkingUserKey;\n-            return this;\n-        }\n+    public PullMatch(final MatchType matchTarget, final Entity entity) {\n+        this.matchTarget = matchTarget;\n \n-        public PullMatch build() {\n-            return instance;\n+        if (entity instanceof Any) {\n+            any = (Any<?>) entity;\n+        } else if (entity instanceof LinkedAccount) {\n+            linkedAccount = (LinkedAccount) entity;\n         }\n     }\n \n-    private MatchTarget matchTarget = MatchTarget.ANY;\n-\n-    private String matchingKey;\n-\n-    private String linkingUserKey;\n-\n-    private PullMatch() {\n-        // private constructor\n-    }\n-\n-    public MatchTarget getMatchTarget() {\n+    public MatchType getMatchTarget() {\n         return matchTarget;\n     }\n \n-    public String getMatchingKey() {\n-        return matchingKey;\n+    public Any<?> getAny() {\n+        return any;\n     }\n \n-    public String getLinkingUserKey() {\n-        return linkingUserKey;\n+    public LinkedAccount getLinkedAccount() {\n+        return linkedAccount;\n     }\n \n     @Override\n     public int hashCode() {\n         return new HashCodeBuilder().\n                 append(matchTarget).\n-                append(matchingKey).\n-                append(linkingUserKey).\n+                append(any).\n+                append(linkedAccount).\n                 build();\n     }\n \n@@ -100,17 +80,18 @@ public boolean equals(final Object obj) {\n         }\n         final PullMatch other = (PullMatch) obj;\n         return new EqualsBuilder().\n-                append(matchingKey, other.matchingKey).\n                 append(matchTarget, other.matchTarget).\n-                append(linkingUserKey, other.linkingUserKey).\n+                append(any, other.any).\n+                append(linkedAccount, other.linkedAccount).\n                 build();\n     }\n \n     @Override\n     public String toString() {\n         return \"PullMatch{\"\n                 + \"matchTarget=\" + matchTarget\n-                + \", matchingKey=\" + matchingKey\n-                + \", linkingUserKey=\" + linkingUserKey + '}';\n+                + \", any=\" + any\n+                + \", linkedAccount=\" + linkedAccount\n+                + '}';\n     }\n }"},{"sha":"dacb88cc13047c231975a2f457359bd30da3ae4b","filename":"core/persistence-api/src/main/java/org/apache/syncope/core/persistence/api/dao/UserDAO.java","status":"modified","additions":3,"deletions":0,"changes":3,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fpersistence-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fapi%2Fdao%2FUserDAO.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fpersistence-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fapi%2Fdao%2FUserDAO.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fpersistence-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fapi%2Fdao%2FUserDAO.java?ref=64495efbbc906599bf3c7de1c0692a7c3139b024","patch":"@@ -21,6 +21,7 @@\n import java.util.Collection;\n import java.util.List;\n import java.util.Map;\n+import java.util.Optional;\n import java.util.Set;\n import org.apache.commons.lang3.tuple.Pair;\n import org.apache.syncope.core.persistence.api.entity.Privilege;\n@@ -62,6 +63,8 @@ public interface UserDAO extends AnyDAO<User> {\n \n     boolean linkedAccountExists(String userKey, String connObjectKeyValue);\n \n+    Optional<? extends LinkedAccount> findLinkedAccount(ExternalResource resource, String connObjectKeyValue);\n+\n     List<LinkedAccount> findLinkedAccounts(String userKey);\n \n     List<LinkedAccount> findLinkedAccountsByResource(ExternalResource resource);"},{"sha":"56980435ad6d3915e61210925e3883907bbbfa84","filename":"core/persistence-jpa/src/main/java/org/apache/syncope/core/persistence/jpa/dao/JPAUserDAO.java","status":"modified","additions":15,"deletions":0,"changes":15,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fjpa%2Fdao%2FJPAUserDAO.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fjpa%2Fdao%2FJPAUserDAO.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fjpa%2Fdao%2FJPAUserDAO.java?ref=64495efbbc906599bf3c7de1c0692a7c3139b024","patch":"@@ -25,6 +25,7 @@\n import java.util.List;\n import java.util.Map;\n import java.util.Objects;\n+import java.util.Optional;\n import java.util.Set;\n import java.util.regex.Pattern;\n import java.util.stream.Collectors;\n@@ -554,6 +555,20 @@ public boolean linkedAccountExists(final String userKey, final String connObject\n         return !query.getResultList().isEmpty();\n     }\n \n+    @Override\n+    public Optional<? extends LinkedAccount> findLinkedAccount(\n+            final ExternalResource resource, final String connObjectKeyValue) {\n+\n+        TypedQuery<LinkedAccount> query = entityManager().createQuery(\n+                \"SELECT e FROM \" + JPALinkedAccount.class.getSimpleName() + \" e \"\n+                + \"WHERE e.resource=:resource AND e.connObjectKeyValue=:connObjectKeyValue\", LinkedAccount.class);\n+        query.setParameter(\"resource\", resource);\n+        query.setParameter(\"connObjectKeyValue\", connObjectKeyValue);\n+\n+        List<LinkedAccount> result = query.getResultList();\n+        return query.getResultList().isEmpty() ? Optional.empty() : Optional.of(result.get(0));\n+    }\n+\n     @Transactional(readOnly = true)\n     @Override\n     public List<LinkedAccount> findLinkedAccounts(final String userKey) {"},{"sha":"34ea16ee05b94a09d851007d57f97338c6230e06","filename":"core/persistence-jpa/src/test/java/org/apache/syncope/core/persistence/jpa/inner/PolicyTest.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fpersistence-jpa%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fjpa%2Finner%2FPolicyTest.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fpersistence-jpa%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fjpa%2Finner%2FPolicyTest.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fpersistence-jpa%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fjpa%2Finner%2FPolicyTest.java?ref=64495efbbc906599bf3c7de1c0692a7c3139b024","patch":"@@ -92,7 +92,7 @@ public void findByKey() {\n                 POJOHelper.deserialize(pushCR.getImplementation().getBody(), DefaultPushCorrelationRuleConf.class);\n         assertNotNull(pushCRConf);\n         assertEquals(1, pushCRConf.getSchemas().size());\n-        assertTrue(pushCRConf.getSchemas().contains(\"email\"));\n+        assertTrue(pushCRConf.getSchemas().contains(\"surname\"));\n     }\n \n     @Test"},{"sha":"9043a9516e5bcd4c634e7dd33861b4652dcb915e","filename":"core/persistence-jpa/src/test/resources/domains/MasterContent.xml","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fpersistence-jpa%2Fsrc%2Ftest%2Fresources%2Fdomains%2FMasterContent.xml","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fpersistence-jpa%2Fsrc%2Ftest%2Fresources%2Fdomains%2FMasterContent.xml","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fpersistence-jpa%2Fsrc%2Ftest%2Fresources%2Fdomains%2FMasterContent.xml?ref=64495efbbc906599bf3c7de1c0692a7c3139b024","patch":"@@ -511,7 +511,7 @@ under the License.\n   <!-- push policies -->\n   <PushPolicy id=\"fb6530e5-892d-4f47-a46b-180c5b6c5c83\" description=\"a push policy\" conflictResolutionAction=\"IGNORE\"/>\n   <Implementation id=\"TestPushCorrelationRule\" type=\"PUSH_CORRELATION_RULE\" engine=\"JAVA\"\n-                  body='{\"@class\":\"org.apache.syncope.common.lib.policy.DefaultPushCorrelationRuleConf\",\"name\":\"org.apache.syncope.common.lib.policy.DefaultPushCorrelationRuleConf\",\"schemas\":[\"email\"]}'/>\n+                  body='{\"@class\":\"org.apache.syncope.common.lib.policy.DefaultPushCorrelationRuleConf\",\"name\":\"org.apache.syncope.common.lib.policy.DefaultPushCorrelationRuleConf\",\"schemas\":[\"surname\"]}'/>\n   <PushCorrelationRuleEntity id=\"24463935-32a0-4272-bc78-04d6d0adc69e\" pushPolicy_id=\"fb6530e5-892d-4f47-a46b-180c5b6c5c83\" \n                              anyType_id=\"USER\" implementation_id=\"TestPushCorrelationRule\"/>\n   "},{"sha":"886457cda7f2920ba7bc3aa82c2eb819dca02343","filename":"core/provisioning-api/src/main/java/org/apache/syncope/core/provisioning/api/VirAttrHandler.java","status":"modified","additions":9,"deletions":0,"changes":9,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fprovisioning-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fapi%2FVirAttrHandler.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fprovisioning-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fapi%2FVirAttrHandler.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fapi%2FVirAttrHandler.java?ref=64495efbbc906599bf3c7de1c0692a7c3139b024","patch":"@@ -23,9 +23,18 @@\n import org.apache.syncope.core.persistence.api.entity.Any;\n import org.apache.syncope.core.persistence.api.entity.Membership;\n import org.apache.syncope.core.persistence.api.entity.VirSchema;\n+import org.identityconnectors.framework.common.objects.ConnectorObject;\n \n public interface VirAttrHandler {\n \n+    /**\n+     * Updates cache with values from external resource.\n+     *\n+     * @param any any object\n+     * @param connObj connector object from external resource\n+     */\n+    void setValues(Any<?> any, ConnectorObject connObj);\n+\n     /**\n      * Query external resource (or cache, if configured) associated to the given any for values associated to the given\n      * virtual schema, not related to any membership."},{"sha":"c0ca0694f710a23830d8eef1a723556037709aec","filename":"core/provisioning-api/src/main/java/org/apache/syncope/core/provisioning/api/pushpull/SyncopeSinglePullExecutor.java","status":"modified","additions":0,"deletions":2,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fprovisioning-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fapi%2Fpushpull%2FSyncopeSinglePullExecutor.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fprovisioning-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fapi%2Fpushpull%2FSyncopeSinglePullExecutor.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fapi%2Fpushpull%2FSyncopeSinglePullExecutor.java?ref=64495efbbc906599bf3c7de1c0692a7c3139b024","patch":"@@ -20,7 +20,6 @@\n \n import java.util.List;\n import org.apache.syncope.common.lib.to.PullTaskTO;\n-import org.apache.syncope.core.persistence.api.entity.Realm;\n import org.apache.syncope.core.persistence.api.entity.resource.Provision;\n import org.apache.syncope.core.provisioning.api.Connector;\n import org.quartz.JobExecutionException;\n@@ -33,6 +32,5 @@ List<ProvisioningReport> pull(\n             Connector connector,\n             String connObjectKey,\n             String connObjectValue,\n-            Realm realm,\n             PullTaskTO pullTaskTO) throws JobExecutionException;\n }"},{"sha":"8053a652c496b71991dfd24a537ce5aa66d54c9f","filename":"core/provisioning-api/src/main/java/org/apache/syncope/core/provisioning/api/pushpull/SyncopeSinglePushExecutor.java","status":"modified","additions":7,"deletions":1,"changes":8,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fprovisioning-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fapi%2Fpushpull%2FSyncopeSinglePushExecutor.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fprovisioning-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fapi%2Fpushpull%2FSyncopeSinglePushExecutor.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fapi%2Fpushpull%2FSyncopeSinglePushExecutor.java?ref=64495efbbc906599bf3c7de1c0692a7c3139b024","patch":"@@ -22,15 +22,21 @@\n import org.apache.syncope.common.lib.to.PushTaskTO;\n import org.apache.syncope.core.persistence.api.entity.Any;\n import org.apache.syncope.core.persistence.api.entity.resource.Provision;\n+import org.apache.syncope.core.persistence.api.entity.user.LinkedAccount;\n import org.apache.syncope.core.provisioning.api.Connector;\n import org.quartz.JobExecutionException;\n \n-@FunctionalInterface\n public interface SyncopeSinglePushExecutor {\n \n     List<ProvisioningReport> push(\n             Provision provision,\n             Connector connector,\n             Any<?> any,\n             PushTaskTO pushTaskTO) throws JobExecutionException;\n+\n+    ProvisioningReport push(\n+            Provision provision,\n+            Connector connector,\n+            LinkedAccount account,\n+            PushTaskTO pushTaskTO) throws JobExecutionException;\n }"},{"sha":"06adc0b3fb1033591ad6620ebbcc7d9477a0047a","filename":"core/provisioning-api/src/main/java/org/apache/syncope/core/provisioning/api/pushpull/UserPushResultHandler.java","status":"modified","additions":4,"deletions":0,"changes":4,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fprovisioning-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fapi%2Fpushpull%2FUserPushResultHandler.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fprovisioning-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fapi%2Fpushpull%2FUserPushResultHandler.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fapi%2Fpushpull%2FUserPushResultHandler.java?ref=64495efbbc906599bf3c7de1c0692a7c3139b024","patch":"@@ -18,6 +18,10 @@\n  */\n package org.apache.syncope.core.provisioning.api.pushpull;\n \n+import org.apache.syncope.core.persistence.api.entity.resource.Provision;\n+import org.apache.syncope.core.persistence.api.entity.user.LinkedAccount;\n+\n public interface UserPushResultHandler extends SyncopePushResultHandler {\n \n+    boolean handle(LinkedAccount account, Provision provision);\n }"},{"sha":"8a7813a2b623aacdb8f2e50d1e544b7812dfba9d","filename":"core/provisioning-java/src/main/java/org/apache/syncope/core/provisioning/java/DefaultAnyObjectProvisioningManager.java","status":"modified","additions":5,"deletions":6,"changes":11,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2FDefaultAnyObjectProvisioningManager.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2FDefaultAnyObjectProvisioningManager.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2FDefaultAnyObjectProvisioningManager.java?ref=64495efbbc906599bf3c7de1c0692a7c3139b024","patch":"@@ -42,7 +42,6 @@\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.transaction.annotation.Propagation;\n import org.springframework.transaction.annotation.Transactional;\n-\n import javax.annotation.Resource;\n \n public class DefaultAnyObjectProvisioningManager implements AnyObjectProvisioningManager {\n@@ -86,7 +85,7 @@ public Pair<String, List<PropagationStatus>> create(\n                 created.getPropByRes(),\n                 anyObjectCR.getVirAttrs(),\n                 excludedResources);\n-        PropagationReporter propagationReporter = taskExecutor.execute(taskInfos, nullPriorityAsync, this.adminUser);\n+        PropagationReporter propagationReporter = taskExecutor.execute(taskInfos, nullPriorityAsync, adminUser);\n \n         return Pair.of(created.getResult(), propagationReporter.getStatuses());\n     }\n@@ -114,7 +113,7 @@ public Pair<AnyObjectUR, List<PropagationStatus>> update(\n                 null,\n                 anyObjectUR.getVirAttrs(),\n                 excludedResources);\n-        PropagationReporter propagationReporter = taskExecutor.execute(taskInfos, nullPriorityAsync, this.adminUser);\n+        PropagationReporter propagationReporter = taskExecutor.execute(taskInfos, nullPriorityAsync, adminUser);\n \n         return Pair.of(updated.getResult(), propagationReporter.getStatuses());\n     }\n@@ -143,7 +142,7 @@ public List<PropagationStatus> delete(\n                 propByRes,\n                 null,\n                 excludedResources);\n-        PropagationReporter propagationReporter = taskExecutor.execute(taskInfos, nullPriorityAsync, this.adminUser);\n+        PropagationReporter propagationReporter = taskExecutor.execute(taskInfos, nullPriorityAsync, adminUser);\n \n         try {\n             awfAdapter.delete(key);\n@@ -180,7 +179,7 @@ public List<PropagationStatus> provision(\n                 null,\n                 null,\n                 null);\n-        PropagationReporter propagationReporter = taskExecutor.execute(taskInfos, nullPriorityAsync, this.adminUser);\n+        PropagationReporter propagationReporter = taskExecutor.execute(taskInfos, nullPriorityAsync, adminUser);\n \n         return propagationReporter.getStatuses();\n     }\n@@ -200,7 +199,7 @@ public List<PropagationStatus> deprovision(\n                 anyObjectDAO.findAllResourceKeys(key).stream().\n                         filter(resource -> !resources.contains(resource)).\n                         collect(Collectors.toList()));\n-        PropagationReporter propagationReporter = taskExecutor.execute(taskInfos, nullPriorityAsync, this.adminUser);\n+        PropagationReporter propagationReporter = taskExecutor.execute(taskInfos, nullPriorityAsync, adminUser);\n \n         return propagationReporter.getStatuses();\n     }"},{"sha":"a0ec90f94215c1c728e40576776914eda4d12c36","filename":"core/provisioning-java/src/main/java/org/apache/syncope/core/provisioning/java/DefaultGroupProvisioningManager.java","status":"modified","additions":6,"deletions":7,"changes":13,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2FDefaultGroupProvisioningManager.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2FDefaultGroupProvisioningManager.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2FDefaultGroupProvisioningManager.java?ref=64495efbbc906599bf3c7de1c0692a7c3139b024","patch":"@@ -45,7 +45,6 @@\n import org.apache.syncope.core.workflow.api.GroupWorkflowAdapter;\n import org.springframework.transaction.annotation.Propagation;\n import org.springframework.transaction.annotation.Transactional;\n-\n import javax.annotation.Resource;\n \n public class DefaultGroupProvisioningManager implements GroupProvisioningManager {\n@@ -82,7 +81,7 @@ public Pair<String, List<PropagationStatus>> create(final GroupCR groupCR, final\n                 created.getPropByRes(),\n                 groupCR.getVirAttrs(),\n                 Set.of());\n-        PropagationReporter propagationReporter = taskExecutor.execute(tasks, nullPriorityAsync, this.adminUser);\n+        PropagationReporter propagationReporter = taskExecutor.execute(tasks, nullPriorityAsync, adminUser);\n \n         return Pair.of(created.getResult(), propagationReporter.getStatuses());\n     }\n@@ -108,7 +107,7 @@ public Pair<String, List<PropagationStatus>> create(\n                 created.getPropByRes(),\n                 groupCR.getVirAttrs(),\n                 excludedResources);\n-        PropagationReporter propagationReporter = taskExecutor.execute(tasks, nullPriorityAsync, this.adminUser);\n+        PropagationReporter propagationReporter = taskExecutor.execute(tasks, nullPriorityAsync, adminUser);\n \n         return Pair.of(created.getResult(), propagationReporter.getStatuses());\n     }\n@@ -136,7 +135,7 @@ public Pair<GroupUR, List<PropagationStatus>> update(\n                 null,\n                 groupUR.getVirAttrs(),\n                 excludedResources);\n-        PropagationReporter propagationReporter = taskExecutor.execute(tasks, nullPriorityAsync, this.adminUser);\n+        PropagationReporter propagationReporter = taskExecutor.execute(tasks, nullPriorityAsync, adminUser);\n \n         return Pair.of(updated.getResult(), propagationReporter.getStatuses());\n     }\n@@ -180,7 +179,7 @@ public List<PropagationStatus> delete(\n                 null,\n                 null));\n \n-        PropagationReporter propagationReporter = taskExecutor.execute(taskInfos, nullPriorityAsync, this.adminUser);\n+        PropagationReporter propagationReporter = taskExecutor.execute(taskInfos, nullPriorityAsync, adminUser);\n \n         gwfAdapter.delete(key);\n \n@@ -208,7 +207,7 @@ public List<PropagationStatus> provision(\n                 null,\n                 null,\n                 null);\n-        PropagationReporter propagationReporter = taskExecutor.execute(taskInfos, nullPriorityAsync, this.adminUser);\n+        PropagationReporter propagationReporter = taskExecutor.execute(taskInfos, nullPriorityAsync, adminUser);\n \n         return propagationReporter.getStatuses();\n     }\n@@ -228,7 +227,7 @@ public List<PropagationStatus> deprovision(\n                 groupDAO.findAllResourceKeys(key).stream().\n                         filter(resource -> !resources.contains(resource)).\n                         collect(Collectors.toList()));\n-        PropagationReporter propagationReporter = taskExecutor.execute(taskInfos, nullPriorityAsync, this.adminUser);\n+        PropagationReporter propagationReporter = taskExecutor.execute(taskInfos, nullPriorityAsync, adminUser);\n \n         return propagationReporter.getStatuses();\n     }"},{"sha":"bb868892996f1f73a36f7f518326a2751f2c9f31","filename":"core/provisioning-java/src/main/java/org/apache/syncope/core/provisioning/java/DefaultUserProvisioningManager.java","status":"modified","additions":9,"deletions":9,"changes":18,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2FDefaultUserProvisioningManager.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2FDefaultUserProvisioningManager.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2FDefaultUserProvisioningManager.java?ref=64495efbbc906599bf3c7de1c0692a7c3139b024","patch":"@@ -101,7 +101,7 @@ public Pair<String, List<PropagationStatus>> create(\n                 created.getPropByLinkedAccount(),\n                 userCR.getVirAttrs(),\n                 excludedResources);\n-        PropagationReporter propagationReporter = taskExecutor.execute(taskInfos, nullPriorityAsync, this.adminUser);\n+        PropagationReporter propagationReporter = taskExecutor.execute(taskInfos, nullPriorityAsync, adminUser);\n \n         return Pair.of(created.getResult().getLeft(), propagationReporter.getStatuses());\n     }\n@@ -111,7 +111,7 @@ public Pair<UserUR, List<PropagationStatus>> update(final UserUR userUR, final b\n         UserWorkflowResult<Pair<UserUR, Boolean>> updated = uwfAdapter.update(userUR);\n \n         List<PropagationTaskInfo> taskInfos = propagationManager.getUserUpdateTasks(updated);\n-        PropagationReporter propagationReporter = taskExecutor.execute(taskInfos, nullPriorityAsync, this.adminUser);\n+        PropagationReporter propagationReporter = taskExecutor.execute(taskInfos, nullPriorityAsync, adminUser);\n \n         return Pair.of(updated.getResult().getLeft(), propagationReporter.getStatuses());\n     }\n@@ -172,7 +172,7 @@ public Pair<UserUR, List<PropagationStatus>> update(\n \n         List<PropagationTaskInfo> taskInfos = propagationManager.getUserUpdateTasks(\n                 updated, updated.getResult().getLeft().getPassword() != null, excludedResources);\n-        PropagationReporter propagationReporter = taskExecutor.execute(taskInfos, nullPriorityAsync, this.adminUser);\n+        PropagationReporter propagationReporter = taskExecutor.execute(taskInfos, nullPriorityAsync, adminUser);\n \n         return Pair.of(updated.getResult().getLeft(), propagationReporter.getStatuses());\n     }\n@@ -205,7 +205,7 @@ public List<PropagationStatus> delete(\n                 propByRes,\n                 propByLinkedAccount,\n                 excludedResources);\n-        PropagationReporter propagationReporter = taskExecutor.execute(taskInfos, nullPriorityAsync, this.adminUser);\n+        PropagationReporter propagationReporter = taskExecutor.execute(taskInfos, nullPriorityAsync, adminUser);\n \n         try {\n             uwfAdapter.delete(key);\n@@ -266,7 +266,7 @@ protected List<PropagationStatus> propagateStatus(final StatusR statusR, final b\n                 null,\n                 null,\n                 null);\n-        PropagationReporter propagationReporter = taskExecutor.execute(taskInfos, nullPriorityAsync, this.adminUser);\n+        PropagationReporter propagationReporter = taskExecutor.execute(taskInfos, nullPriorityAsync, adminUser);\n \n         return propagationReporter.getStatuses();\n     }\n@@ -285,7 +285,7 @@ public void internalSuspend(final String key) {\n                     updated.getLeft().getPropByRes(),\n                     updated.getLeft().getPropByLinkedAccount(),\n                     updated.getLeft().getPerformedTasks()));\n-            taskExecutor.execute(taskInfos, false, this.adminUser);\n+            taskExecutor.execute(taskInfos, false, adminUser);\n         }\n     }\n \n@@ -318,7 +318,7 @@ public List<PropagationStatus> provision(\n                 Pair.of(userUR, (Boolean) null), propByRes, null, \"update\");\n \n         List<PropagationTaskInfo> taskInfos = propagationManager.getUserUpdateTasks(wfResult, changePwd, null);\n-        PropagationReporter propagationReporter = taskExecutor.execute(taskInfos, nullPriorityAsync, this.adminUser);\n+        PropagationReporter propagationReporter = taskExecutor.execute(taskInfos, nullPriorityAsync, adminUser);\n \n         return propagationReporter.getStatuses();\n     }\n@@ -345,7 +345,7 @@ public List<PropagationStatus> deprovision(\n                 userDAO.findAllResourceKeys(key).stream().\n                         filter(resource -> !resources.contains(resource)).\n                         collect(Collectors.toList()));\n-        PropagationReporter propagationReporter = taskExecutor.execute(taskInfos, nullPriorityAsync, this.adminUser);\n+        PropagationReporter propagationReporter = taskExecutor.execute(taskInfos, nullPriorityAsync, adminUser);\n \n         return propagationReporter.getStatuses();\n     }\n@@ -360,6 +360,6 @@ public void confirmPasswordReset(final String key, final String token, final Str\n         UserWorkflowResult<Pair<UserUR, Boolean>> updated = uwfAdapter.confirmPasswordReset(key, token, password);\n \n         List<PropagationTaskInfo> taskInfos = propagationManager.getUserUpdateTasks(updated);\n-        taskExecutor.execute(taskInfos, false, this.adminUser);\n+        taskExecutor.execute(taskInfos, false, adminUser);\n     }\n }"},{"sha":"63fd67d441222dfa2457d79d06a33bb3f819c104","filename":"core/provisioning-java/src/main/java/org/apache/syncope/core/provisioning/java/MappingManagerImpl.java","status":"modified","additions":30,"deletions":29,"changes":59,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2FMappingManagerImpl.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2FMappingManagerImpl.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2FMappingManagerImpl.java?ref=64495efbbc906599bf3c7de1c0692a7c3139b024","patch":"@@ -195,13 +195,13 @@ public Pair<String, Set<Attribute>> prepareAttrs(\n                 any, provision, any.getPlainAttrs());\n \n         Set<Attribute> attributes = new HashSet<>();\n-        String connObjectKey = null;\n+        String[] connObjectKeyValue = new String[1];\n \n-        for (Item mapItem : MappingUtils.getPropagationItems(provision.getMapping().getItems())) {\n+        MappingUtils.getPropagationItems(provision.getMapping().getItems().stream()).forEach(mapItem -> {\n             LOG.debug(\"Processing expression '{}'\", mapItem.getIntAttrName());\n \n             try {\n-                String processedConnObjectKey = processPreparedAttr(\n+                String processedConnObjectKeyValue = processPreparedAttr(\n                         prepareAttr(\n                                 provision,\n                                 mapItem,\n@@ -211,27 +211,28 @@ public Pair<String, Set<Attribute>> prepareAttrs(\n                                 AccountGetter.DEFAULT,\n                                 PlainAttrGetter.DEFAULT),\n                         attributes);\n-                if (processedConnObjectKey != null) {\n-                    connObjectKey = processedConnObjectKey;\n+                if (processedConnObjectKeyValue != null) {\n+                    connObjectKeyValue[0] = processedConnObjectKeyValue;\n                 }\n             } catch (Exception e) {\n                 LOG.error(\"Expression '{}' processing failed\", mapItem.getIntAttrName(), e);\n             }\n-        }\n+        });\n \n-        Optional<? extends MappingItem> connObjectKeyItem = MappingUtils.getConnObjectKeyItem(provision);\n-        if (connObjectKeyItem.isPresent()) {\n-            Attribute connObjectKeyExtAttr = AttributeUtil.find(connObjectKeyItem.get().getExtAttrName(), attributes);\n-            if (connObjectKeyExtAttr != null) {\n-                attributes.remove(connObjectKeyExtAttr);\n-                attributes.add(AttributeBuilder.build(connObjectKeyItem.get().getExtAttrName(), connObjectKey));\n+        MappingUtils.getConnObjectKeyItem(provision).ifPresent(connObjectKeyItem -> {\n+            Attribute connObjectKeyAttr = AttributeUtil.find(connObjectKeyItem.getExtAttrName(), attributes);\n+            if (connObjectKeyAttr != null) {\n+                attributes.remove(connObjectKeyAttr);\n+                attributes.add(AttributeBuilder.build(connObjectKeyItem.getExtAttrName(), connObjectKeyValue[0]));\n             }\n-            Name name = MappingUtils.evaluateNAME(any, provision, connObjectKey);\n+            Name name = MappingUtils.evaluateNAME(any, provision, connObjectKeyValue[0]);\n             attributes.add(name);\n-            if (connObjectKey != null && !connObjectKey.equals(name.getNameValue()) && connObjectKeyExtAttr == null) {\n-                attributes.add(AttributeBuilder.build(connObjectKeyItem.get().getExtAttrName(), connObjectKey));\n+            if (connObjectKeyAttr == null\n+                    && connObjectKeyValue[0] != null && !connObjectKeyValue[0].equals(name.getNameValue())) {\n+\n+                attributes.add(AttributeBuilder.build(connObjectKeyItem.getExtAttrName(), connObjectKeyValue[0]));\n             }\n-        }\n+        });\n \n         if (enable != null) {\n             attributes.add(AttributeBuilder.buildEnabled(enable));\n@@ -243,7 +244,7 @@ public Pair<String, Set<Attribute>> prepareAttrs(\n             }\n         }\n \n-        return Pair.of(connObjectKey, attributes);\n+        return Pair.of(connObjectKeyValue[0], attributes);\n     }\n \n     @Transactional(readOnly = true)\n@@ -261,7 +262,7 @@ public Set<Attribute> prepareAttrs(\n \n         Set<Attribute> attributes = new HashSet<>();\n \n-        for (Item mapItem : MappingUtils.getPropagationItems(provision.getMapping().getItems())) {\n+        MappingUtils.getPropagationItems(provision.getMapping().getItems().stream()).forEach(mapItem -> {\n             LOG.debug(\"Processing expression '{}'\", mapItem.getIntAttrName());\n \n             try {\n@@ -290,7 +291,7 @@ public Set<Attribute> prepareAttrs(\n             } catch (Exception e) {\n                 LOG.error(\"Expression '{}' processing failed\", mapItem.getIntAttrName(), e);\n             }\n-        }\n+        });\n \n         String connObjectKey = account.getConnObjectKeyValue();\n         MappingUtils.getConnObjectKeyItem(provision).ifPresent(connObjectKeyItem -> {\n@@ -339,15 +340,15 @@ public Pair<String, Set<Attribute>> prepareAttrs(final Realm realm, final OrgUni\n         LOG.debug(\"Preparing resource attributes for {} with orgUnit {}\", realm, orgUnit);\n \n         Set<Attribute> attributes = new HashSet<>();\n-        String connObjectKey = null;\n+        String[] connObjectKeyValue = new String[1];\n \n-        for (Item orgUnitItem : MappingUtils.getPropagationItems(orgUnit.getItems())) {\n+        MappingUtils.getPropagationItems(orgUnit.getItems().stream()).forEach(orgUnitItem -> {\n             LOG.debug(\"Processing expression '{}'\", orgUnitItem.getIntAttrName());\n \n             String value = getIntValue(realm, orgUnitItem);\n \n             if (orgUnitItem.isConnObjectKey()) {\n-                connObjectKey = value;\n+                connObjectKeyValue[0] = value;\n             }\n \n             Attribute alreadyAdded = AttributeUtil.find(orgUnitItem.getExtAttrName(), attributes);\n@@ -368,19 +369,19 @@ public Pair<String, Set<Attribute>> prepareAttrs(final Realm realm, final OrgUni\n \n                 attributes.add(AttributeBuilder.build(orgUnitItem.getExtAttrName(), values));\n             }\n-        }\n+        });\n \n         Optional<? extends OrgUnitItem> connObjectKeyItem = orgUnit.getConnObjectKeyItem();\n         if (connObjectKeyItem.isPresent()) {\n-            Attribute connObjectKeyExtAttr = AttributeUtil.find(connObjectKeyItem.get().getExtAttrName(), attributes);\n-            if (connObjectKeyExtAttr != null) {\n-                attributes.remove(connObjectKeyExtAttr);\n-                attributes.add(AttributeBuilder.build(connObjectKeyItem.get().getExtAttrName(), connObjectKey));\n+            Attribute connObjectKeyAttr = AttributeUtil.find(connObjectKeyItem.get().getExtAttrName(), attributes);\n+            if (connObjectKeyAttr != null) {\n+                attributes.remove(connObjectKeyAttr);\n+                attributes.add(AttributeBuilder.build(connObjectKeyItem.get().getExtAttrName(), connObjectKeyValue[0]));\n             }\n-            attributes.add(MappingUtils.evaluateNAME(realm, orgUnit, connObjectKey));\n+            attributes.add(MappingUtils.evaluateNAME(realm, orgUnit, connObjectKeyValue[0]));\n         }\n \n-        return Pair.of(connObjectKey, attributes);\n+        return Pair.of(connObjectKeyValue[0], attributes);\n     }\n \n     protected String getPasswordAttrValue(final Provision provision, final Account account, final String defaultValue) {"},{"sha":"11cdc39dec59cac7e18f808dd3eedb417749b250","filename":"core/provisioning-java/src/main/java/org/apache/syncope/core/provisioning/java/VirAttrHandlerImpl.java","status":"modified","additions":65,"deletions":69,"changes":134,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2FVirAttrHandlerImpl.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2FVirAttrHandlerImpl.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2FVirAttrHandlerImpl.java?ref=64495efbbc906599bf3c7de1c0692a7c3139b024","patch":"@@ -22,25 +22,22 @@\n import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n-import java.util.Optional;\n import java.util.Set;\n-import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.apache.syncope.core.persistence.api.dao.AllowedSchemas;\n import org.apache.syncope.core.persistence.api.entity.Any;\n import org.apache.syncope.core.persistence.api.entity.AnyUtilsFactory;\n+import org.apache.syncope.core.persistence.api.entity.LinkingMappingItem;\n import org.apache.syncope.core.persistence.api.entity.Membership;\n import org.apache.syncope.core.persistence.api.entity.VirSchema;\n import org.apache.syncope.core.persistence.api.entity.resource.ExternalResource;\n-import org.apache.syncope.core.persistence.api.entity.resource.MappingItem;\n import org.apache.syncope.core.persistence.api.entity.resource.Provision;\n-import org.apache.syncope.core.provisioning.api.Connector;\n import org.apache.syncope.core.provisioning.api.ConnectorFactory;\n-import org.apache.syncope.core.provisioning.api.MappingManager;\n import org.apache.syncope.core.provisioning.api.VirAttrHandler;\n import org.apache.syncope.core.provisioning.api.cache.VirAttrCache;\n import org.apache.syncope.core.provisioning.api.cache.VirAttrCacheValue;\n-import org.apache.syncope.core.provisioning.java.utils.MappingUtils;\n+import org.apache.syncope.core.provisioning.java.pushpull.OutboundMatcher;\n import org.identityconnectors.framework.common.objects.Attribute;\n-import org.identityconnectors.framework.common.objects.AttributeBuilder;\n import org.identityconnectors.framework.common.objects.ConnectorObject;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -61,86 +58,85 @@ public class VirAttrHandlerImpl implements VirAttrHandler {\n     private VirAttrCache virAttrCache;\n \n     @Autowired\n-    private MappingManager mappingManager;\n+    private OutboundMatcher outboundMatcher;\n \n     @Autowired\n     private AnyUtilsFactory anyUtilsFactory;\n \n+    @Override\n+    public void setValues(final Any<?> any, final ConnectorObject connObj) {\n+        if (any == null) {\n+            LOG.warn(\"Null any passed, ignoring\");\n+            return;\n+        }\n+\n+        AllowedSchemas<VirSchema> schemas =\n+                anyUtilsFactory.getInstance(any).dao().findAllowedSchemas(any, VirSchema.class);\n+        Stream.concat(\n+                schemas.getForSelf().stream(),\n+                schemas.getForMemberships().values().stream().flatMap(Set::stream)).forEach(schema -> {\n+            Attribute attr = connObj.getAttributeByName(schema.getExtAttrName());\n+            if (attr == null) {\n+                virAttrCache.expire(any.getType().getKey(), any.getKey(), schema.getKey());\n+            } else {\n+                VirAttrCacheValue virAttrCacheValue = new VirAttrCacheValue(attr.getValue());\n+                virAttrCache.put(\n+                        any.getType().getKey(),\n+                        any.getKey(),\n+                        schema.getKey(),\n+                        virAttrCacheValue);\n+                LOG.debug(\"Values for {} set in cache: {}\", schema, virAttrCacheValue);\n+            }\n+        });\n+    }\n+\n     private Map<VirSchema, List<String>> getValues(final Any<?> any, final Set<VirSchema> schemas) {\n-        Set<ExternalResource> ownedResources = anyUtilsFactory.getInstance(any).getAllResources(any);\n+        Set<ExternalResource> resources = anyUtilsFactory.getInstance(any).getAllResources(any);\n \n         Map<VirSchema, List<String>> result = new HashMap<>();\n \n         Map<Provision, Set<VirSchema>> toRead = new HashMap<>();\n \n-        schemas.forEach(schema -> {\n-            if (ownedResources.contains(schema.getProvision().getResource())) {\n-                VirAttrCacheValue virAttrCacheValue =\n-                        virAttrCache.get(any.getType().getKey(), any.getKey(), schema.getKey());\n-\n-                if (virAttrCache.isValidEntry(virAttrCacheValue)) {\n-                    LOG.debug(\"Values for {} found in cache: {}\", schema, virAttrCacheValue);\n-                    result.put(schema, virAttrCacheValue.getValues());\n-                } else if (schema.getProvision().getAnyType().equals(any.getType())) {\n-                    Set<VirSchema> schemasToRead = toRead.get(schema.getProvision());\n-                    if (schemasToRead == null) {\n-                        schemasToRead = new HashSet<>();\n-                        toRead.put(schema.getProvision(), schemasToRead);\n-                    }\n-                    schemasToRead.add(schema);\n+        schemas.stream().filter(schema -> resources.contains(schema.getProvision().getResource())).forEach(schema -> {\n+            VirAttrCacheValue virAttrCacheValue =\n+                    virAttrCache.get(any.getType().getKey(), any.getKey(), schema.getKey());\n+\n+            if (virAttrCache.isValidEntry(virAttrCacheValue)) {\n+                LOG.debug(\"Values for {} found in cache: {}\", schema, virAttrCacheValue);\n+                result.put(schema, virAttrCacheValue.getValues());\n+            } else if (schema.getProvision().getAnyType().equals(any.getType())) {\n+                Set<VirSchema> schemasToRead = toRead.get(schema.getProvision());\n+                if (schemasToRead == null) {\n+                    schemasToRead = new HashSet<>();\n+                    toRead.put(schema.getProvision(), schemasToRead);\n                 }\n-            } else {\n-                LOG.debug(\"Not considering {} since {} is not assigned to {}\",\n-                        schema, any, schema.getProvision().getResource());\n+                schemasToRead.add(schema);\n             }\n         });\n \n         toRead.forEach((provision, schemasToRead) -> {\n             LOG.debug(\"About to read from {}: {}\", provision, schemasToRead);\n \n-            Optional<? extends MappingItem> connObjectKeyItem = MappingUtils.getConnObjectKeyItem(provision);\n-            String connObjectKeyValue = connObjectKeyItem.isPresent()\n-                    ? mappingManager.getConnObjectKeyValue(any, provision).orElse(null)\n-                    : null;\n-            if (connObjectKeyItem.isEmpty() || connObjectKeyValue == null) {\n-                LOG.error(\"No ConnObjectKey or value found for {}, ignoring...\", provision);\n-            } else {\n-                Set<MappingItem> linkingMappingItems = new HashSet<>();\n-                linkingMappingItems.add(connObjectKeyItem.get());\n-                linkingMappingItems.addAll(schemasToRead.stream().\n-                        map(VirSchema::asLinkingMappingItem).collect(Collectors.toSet()));\n-\n-                Connector connector = connFactory.getConnector(provision.getResource());\n-                try {\n-                    ConnectorObject connectorObject = connector.getObject(\n-                            provision.getObjectClass(),\n-                            AttributeBuilder.build(connObjectKeyItem.get().getExtAttrName(), connObjectKeyValue),\n-                            provision.isIgnoreCaseMatch(),\n-                            MappingUtils.buildOperationOptions(linkingMappingItems.iterator()));\n-\n-                    if (connectorObject == null) {\n-                        LOG.debug(\"No read from {} with filter '{} == {}'\",\n-                                provision, connObjectKeyItem.get().getExtAttrName(), connObjectKeyValue);\n-                    } else {\n-                        schemasToRead.forEach(schema -> {\n-                            Attribute attr = connectorObject.getAttributeByName(schema.getExtAttrName());\n-                            if (attr != null) {\n-                                VirAttrCacheValue virAttrCacheValue = new VirAttrCacheValue(attr.getValue());\n-                                virAttrCache.put(\n-                                        any.getType().getKey(),\n-                                        any.getKey(),\n-                                        schema.getKey(),\n-                                        virAttrCacheValue);\n-                                LOG.debug(\"Values for {} set in cache: {}\", schema, virAttrCacheValue);\n-\n-                                result.put(schema, virAttrCacheValue.getValues());\n-                            }\n-                        });\n-                    }\n-                } catch (Exception e) {\n-                    LOG.error(\"Error reading from {}\", provision, e);\n+            outboundMatcher.match(\n+                    connFactory.getConnector(provision.getResource()),\n+                    any,\n+                    provision,\n+                    schemasToRead.stream().map(VirSchema::asLinkingMappingItem).toArray(LinkingMappingItem[]::new)).\n+                    forEach(connObj -> schemasToRead.forEach(schema -> {\n+\n+                Attribute attr = connObj.getAttributeByName(schema.getExtAttrName());\n+                if (attr != null) {\n+                    VirAttrCacheValue virAttrCacheValue = new VirAttrCacheValue(attr.getValue());\n+                    virAttrCache.put(\n+                            any.getType().getKey(),\n+                            any.getKey(),\n+                            schema.getKey(),\n+                            virAttrCacheValue);\n+                    LOG.debug(\"Values for {} set in cache: {}\", schema, virAttrCacheValue);\n+\n+                    result.put(schema, virAttrCacheValue.getValues());\n                 }\n-            }\n+            }));\n         });\n \n         return result;"},{"sha":"4f9649a986bf832ae5a360c469cec7da190e4226","filename":"core/provisioning-java/src/main/java/org/apache/syncope/core/provisioning/java/data/AbstractAnyDataBinder.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fdata%2FAbstractAnyDataBinder.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fdata%2FAbstractAnyDataBinder.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fdata%2FAbstractAnyDataBinder.java?ref=64495efbbc906599bf3c7de1c0692a7c3139b024","patch":"@@ -206,7 +206,7 @@ protected void fillAttr(\n     private List<String> evaluateMandatoryCondition(final Provision provision, final Any<?> any) {\n         List<String> missingAttrNames = new ArrayList<>();\n \n-        MappingUtils.getPropagationItems(provision.getMapping().getItems()).forEach(mapItem -> {\n+        MappingUtils.getPropagationItems(provision.getMapping().getItems().stream()).forEach(mapItem -> {\n             IntAttrName intAttrName = null;\n             try {\n                 intAttrName = intAttrNameParser.parse(mapItem.getIntAttrName(), provision.getAnyType().getKind());\n@@ -344,7 +344,7 @@ protected void processAttrPatch(\n                 filter(resource -> resource.getProvision(any.getType()).isPresent()\n                 && resource.getProvision(any.getType()).get().getMapping() != null).\n                 forEach(resource -> MappingUtils.getPropagationItems(\n-                resource.getProvision(any.getType()).get().getMapping().getItems()).stream().\n+                resource.getProvision(any.getType()).get().getMapping().getItems().stream()).\n                 filter(item -> (schema.getKey().equals(item.getIntAttrName()))).\n                 forEach(item -> {\n                     propByRes.add(ResourceOperation.UPDATE, resource.getKey());"},{"sha":"284abeb914ebc54d62629939ff88bd6f16dc9e79","filename":"core/provisioning-java/src/main/java/org/apache/syncope/core/provisioning/java/data/AnyObjectDataBinderImpl.java","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fdata%2FAnyObjectDataBinderImpl.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fdata%2FAnyObjectDataBinderImpl.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fdata%2FAnyObjectDataBinderImpl.java?ref=64495efbbc906599bf3c7de1c0692a7c3139b024","patch":"@@ -72,6 +72,7 @@ public AnyObjectTO getAnyObjectTO(final String key) {\n         return getAnyObjectTO(anyObjectDAO.authFind(key), true);\n     }\n \n+    @Transactional(readOnly = true)\n     @Override\n     public AnyObjectTO getAnyObjectTO(final AnyObject anyObject, final boolean details) {\n         AnyObjectTO anyObjectTO = new AnyObjectTO();"},{"sha":"6cf9a19d8fe5647ddc189eaa3d92cc87af48f0fa","filename":"core/provisioning-java/src/main/java/org/apache/syncope/core/provisioning/java/data/AnyTypeDataBinderImpl.java","status":"modified","additions":3,"deletions":5,"changes":8,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fdata%2FAnyTypeDataBinderImpl.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fdata%2FAnyTypeDataBinderImpl.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fdata%2FAnyTypeDataBinderImpl.java?ref=64495efbbc906599bf3c7de1c0692a7c3139b024","patch":"@@ -37,6 +37,7 @@\n import org.apache.syncope.core.persistence.api.entity.AnyType;\n import org.apache.syncope.core.persistence.api.entity.AnyTypeClass;\n import org.apache.syncope.common.lib.types.EntitlementsHolder;\n+import org.apache.syncope.core.persistence.api.entity.Entity;\n import org.apache.syncope.core.provisioning.api.data.AnyTypeDataBinder;\n import org.apache.syncope.core.provisioning.api.serialization.POJOHelper;\n import org.apache.syncope.core.spring.security.AuthContextUtils;\n@@ -85,7 +86,7 @@ public AnyType create(final AnyTypeTO anyTypeTO) {\n                 }));\n \n                 added.forEach(entitlement -> authorities.add(\n-                    new SyncopeGrantedAuthority(entitlement, SyncopeConstants.ROOT_REALM)));\n+                        new SyncopeGrantedAuthority(entitlement, SyncopeConstants.ROOT_REALM)));\n \n                 accessToken.setAuthorities(ENCRYPTOR.encode(\n                         POJOHelper.serialize(authorities), CipherAlgorithm.AES).\n@@ -160,12 +161,9 @@ public AnyTypeTO delete(final AnyType anyType) {\n     @Override\n     public AnyTypeTO getAnyTypeTO(final AnyType anyType) {\n         AnyTypeTO anyTypeTO = new AnyTypeTO();\n-\n         anyTypeTO.setKey(anyType.getKey());\n         anyTypeTO.setKind(anyType.getKind());\n-        anyType.getClasses().forEach(anyTypeClass -> anyTypeTO.getClasses().add(anyTypeClass.getKey()));\n-\n+        anyTypeTO.getClasses().addAll(anyType.getClasses().stream().map(Entity::getKey).collect(Collectors.toList()));\n         return anyTypeTO;\n     }\n-\n }"},{"sha":"133f17178d5e3272d8e8977f35f71cc279132842","filename":"core/provisioning-java/src/main/java/org/apache/syncope/core/provisioning/java/data/ResourceDataBinderImpl.java","status":"modified","additions":6,"deletions":7,"changes":13,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fdata%2FResourceDataBinderImpl.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fdata%2FResourceDataBinderImpl.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fdata%2FResourceDataBinderImpl.java?ref=64495efbbc906599bf3c7de1c0692a7c3139b024","patch":"@@ -26,9 +26,9 @@\n import java.util.List;\n import java.util.Optional;\n import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n import org.apache.commons.lang3.StringUtils;\n import org.apache.syncope.common.keymaster.client.api.ConfParamOps;\n-import org.apache.syncope.common.lib.collections.IteratorChain;\n import org.apache.syncope.common.lib.SyncopeClientCompositeException;\n import org.apache.syncope.common.lib.SyncopeClientException;\n import org.apache.syncope.common.lib.to.AnyTypeClassTO;\n@@ -230,18 +230,17 @@ public ExternalResource update(final ExternalResource resource, final ResourceTO\n                     }\n \n                     AnyTypeClassTO allowedSchemas = new AnyTypeClassTO();\n-                    for (Iterator<AnyTypeClass> itor = new IteratorChain<>(\n-                            provision.getAnyType().getClasses().iterator(),\n-                            provision.getAuxClasses().iterator()); itor.hasNext();) {\n+                    Stream.concat(\n+                            provision.getAnyType().getClasses().stream(),\n+                            provision.getAuxClasses().stream()).forEach(anyTypeClass -> {\n \n-                        AnyTypeClass anyTypeClass = itor.next();\n                         allowedSchemas.getPlainSchemas().addAll(anyTypeClass.getPlainSchemas().stream().\n                                 map(Entity::getKey).collect(Collectors.toList()));\n                         allowedSchemas.getDerSchemas().addAll(anyTypeClass.getDerSchemas().stream().\n                                 map(Entity::getKey).collect(Collectors.toList()));\n                         allowedSchemas.getVirSchemas().addAll(anyTypeClass.getVirSchemas().stream().\n                                 map(Entity::getKey).collect(Collectors.toList()));\n-                    }\n+                    });\n \n                     populateMapping(\n                             provisionTO.getMapping(),\n@@ -627,7 +626,7 @@ public ResourceTO getResourceTO(final ExternalResource resource) {\n \n         resourceTO.setConnector(Optional.ofNullable(connector).map(Entity::getKey).orElse(null));\n         resourceTO.setConnectorDisplayName(Optional.ofNullable(connector)\n-            .map(ConnInstance::getDisplayName).orElse(null));\n+                .map(ConnInstance::getDisplayName).orElse(null));\n \n         // set the provision information\n         resource.getProvisions().forEach(provision -> {"},{"sha":"257efaeb566a46e20bcddf559d9f61b766c1f0f7","filename":"core/provisioning-java/src/main/java/org/apache/syncope/core/provisioning/java/job/JobManagerImpl.java","status":"modified","additions":7,"deletions":7,"changes":14,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fjob%2FJobManagerImpl.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fjob%2FJobManagerImpl.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fjob%2FJobManagerImpl.java?ref=64495efbbc906599bf3c7de1c0692a7c3139b024","patch":"@@ -102,7 +102,7 @@ public class JobManagerImpl implements JobManager, SyncopeCoreLoader {\n \n     @Resource(name = \"adminUser\")\n     private String adminUser;\n-    \n+\n     private boolean disableQuartzInstance;\n \n     public void setDisableQuartzInstance(final boolean disableQuartzInstance) {\n@@ -222,7 +222,7 @@ private static <T> T createSpringBean(final Class<T> jobClass) {\n \n     @Override\n     public Map<String, Object> register(final SchedTask task, final Date startAt, final long interruptMaxRetries,\n-                                        final String executor)\n+            final String executor)\n             throws SchedulerException {\n \n         TaskJob job = createSpringBean(TaskJob.class);\n@@ -258,7 +258,7 @@ public Map<String, Object> register(final SchedTask task, final Date startAt, fi\n \n     @Override\n     public void register(final Report report, final Date startAt, final long interruptMaxRetries,\n-                         final String executor) throws SchedulerException {\n+            final String executor) throws SchedulerException {\n \n         ReportJob job = createSpringBean(ReportJob.class);\n         job.setReportKey(report.getKey());\n@@ -347,7 +347,7 @@ public void load(final String domain, final DataSource datasource) {\n             for (Iterator<SchedTask> it = tasks.iterator(); it.hasNext() && !loadException;) {\n                 SchedTask task = it.next();\n                 try {\n-                    register(task, task.getStartAt(), conf.getRight(), this.adminUser);\n+                    register(task, task.getStartAt(), conf.getRight(), adminUser);\n                 } catch (Exception e) {\n                     LOG.error(\"While loading job instance for task \" + task.getKey(), e);\n                     loadException = true;\n@@ -361,7 +361,7 @@ public void load(final String domain, final DataSource datasource) {\n                 for (Iterator<Report> it = reportDAO.findAll().iterator(); it.hasNext() && !loadException;) {\n                     Report report = it.next();\n                     try {\n-                        register(report, null, conf.getRight(), this.adminUser);\n+                        register(report, null, conf.getRight(), adminUser);\n                     } catch (Exception e) {\n                         LOG.error(\"While loading job instance for report \" + report.getName(), e);\n                         loadException = true;\n@@ -387,7 +387,7 @@ public void load(final String domain, final DataSource datasource) {\n \n                 try {\n                     NotificationJob job = createSpringBean(NotificationJob.class);\n-                    Map<String, Object> jobData = createJobMapForExecutionContext(this.adminUser);\n+                    Map<String, Object> jobData = createJobMapForExecutionContext(adminUser);\n                     registerJob(\n                             NOTIFICATION_JOB.getName(),\n                             job,\n@@ -403,7 +403,7 @@ public void load(final String domain, final DataSource datasource) {\n             LOG.debug(\"Registering {}\", SystemLoadReporterJob.class);\n             try {\n                 SystemLoadReporterJob job = createSpringBean(SystemLoadReporterJob.class);\n-                Map<String, Object> jobData = createJobMapForExecutionContext(this.adminUser);\n+                Map<String, Object> jobData = createJobMapForExecutionContext(adminUser);\n                 registerJob(\n                         StringUtils.uncapitalize(SystemLoadReporterJob.class.getSimpleName()),\n                         job,"},{"sha":"70077db6784c5af901826404546e8583cdbffa4a","filename":"core/provisioning-java/src/main/java/org/apache/syncope/core/provisioning/java/job/report/ReconciliationReportlet.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fjob%2Freport%2FReconciliationReportlet.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fjob%2Freport%2FReconciliationReportlet.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fjob%2Freport%2FReconciliationReportlet.java?ref=64495efbbc906599bf3c7de1c0692a7c3139b024","patch":"@@ -288,7 +288,7 @@ private void doExtract(final ContentHandler handler, final List<? extends Any<?>\n                             provision.getObjectClass(),\n                             AttributeBuilder.build(connObjectKeyItem.get().getExtAttrName(), connObjectKeyValue),\n                             provision.isIgnoreCaseMatch(),\n-                            MappingUtils.buildOperationOptions(provision.getMapping().getItems().iterator()));\n+                            MappingUtils.buildOperationOptions(provision.getMapping().getItems().stream()));\n \n                     if (connectorObject == null) {\n                         // 2. not found on resource?"},{"sha":"bbfc20d248266ce623ee421d3244c632e6fb3378","filename":"core/provisioning-java/src/main/java/org/apache/syncope/core/provisioning/java/propagation/AbstractPropagationTaskExecutor.java","status":"modified","additions":10,"deletions":57,"changes":67,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpropagation%2FAbstractPropagationTaskExecutor.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpropagation%2FAbstractPropagationTaskExecutor.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpropagation%2FAbstractPropagationTaskExecutor.java?ref=64495efbbc906599bf3c7de1c0692a7c3139b024","patch":"@@ -30,9 +30,7 @@\n import java.util.stream.Collectors;\n import java.util.concurrent.atomic.AtomicReference;\n import org.apache.commons.lang3.StringUtils;\n-import org.apache.syncope.common.lib.collections.IteratorChain;\n import org.apache.syncope.common.lib.to.ExecTO;\n-import org.apache.syncope.common.lib.types.AnyTypeKind;\n import org.apache.syncope.common.lib.types.AuditElements;\n import org.apache.syncope.common.lib.types.AuditElements.Result;\n import org.apache.syncope.common.lib.types.ExecStatus;\n@@ -42,7 +40,6 @@\n import org.apache.syncope.core.persistence.api.dao.TaskDAO;\n import org.apache.syncope.core.persistence.api.dao.UserDAO;\n import org.apache.syncope.core.persistence.api.entity.EntityFactory;\n-import org.apache.syncope.core.persistence.api.entity.VirSchema;\n import org.apache.syncope.core.persistence.api.entity.task.PropagationTask;\n import org.apache.syncope.core.persistence.api.entity.task.TaskExec;\n import org.apache.syncope.core.provisioning.api.Connector;\n@@ -55,22 +52,19 @@\n import org.apache.syncope.core.provisioning.api.utils.ExceptionUtils2;\n import org.apache.syncope.core.persistence.api.dao.AnyObjectDAO;\n import org.apache.syncope.core.persistence.api.dao.ExternalResourceDAO;\n-import org.apache.syncope.core.persistence.api.dao.VirSchemaDAO;\n import org.apache.syncope.core.persistence.api.entity.AnyUtilsFactory;\n import org.apache.syncope.core.persistence.api.entity.resource.ExternalResource;\n-import org.apache.syncope.core.persistence.api.entity.resource.MappingItem;\n import org.apache.syncope.core.persistence.api.entity.resource.OrgUnit;\n import org.apache.syncope.core.persistence.api.entity.resource.OrgUnitItem;\n import org.apache.syncope.core.persistence.api.entity.resource.Provision;\n import org.apache.syncope.core.persistence.api.entity.task.TaskUtilsFactory;\n import org.apache.syncope.core.provisioning.api.AuditManager;\n-import org.apache.syncope.core.provisioning.api.cache.VirAttrCache;\n-import org.apache.syncope.core.provisioning.api.cache.VirAttrCacheValue;\n import org.apache.syncope.core.provisioning.api.data.TaskDataBinder;\n import org.apache.syncope.core.provisioning.api.notification.NotificationManager;\n import org.apache.syncope.core.provisioning.api.propagation.PropagationException;\n import org.apache.syncope.core.provisioning.api.propagation.PropagationTaskInfo;\n import org.apache.syncope.core.provisioning.api.serialization.POJOHelper;\n+import org.apache.syncope.core.provisioning.java.pushpull.OutboundMatcher;\n import org.apache.syncope.core.provisioning.java.utils.MappingUtils;\n import org.apache.syncope.core.spring.ImplementationManager;\n import org.apache.syncope.core.spring.security.AuthContextUtils;\n@@ -132,9 +126,6 @@ public abstract class AbstractPropagationTaskExecutor implements PropagationTask\n     @Autowired\n     protected ExternalResourceDAO resourceDAO;\n \n-    @Autowired\n-    protected VirSchemaDAO virSchemaDAO;\n-\n     /**\n      * Notification Manager.\n      */\n@@ -163,7 +154,7 @@ public abstract class AbstractPropagationTaskExecutor implements PropagationTask\n     protected EntityFactory entityFactory;\n \n     @Autowired\n-    protected VirAttrCache virAttrCache;\n+    protected OutboundMatcher outboundMatcher;\n \n     protected List<PropagationActions> getPropagationActions(final ExternalResource resource) {\n         List<PropagationActions> result = new ArrayList<>();\n@@ -348,7 +339,7 @@ public TaskExec execute(final PropagationTaskInfo taskInfo, final String executo\n \n     @Override\n     public TaskExec execute(final PropagationTaskInfo taskInfo, final PropagationReporter reporter,\n-                            final String executor) {\n+            final String executor) {\n         PropagationTask task;\n         if (taskInfo.getKey() == null) {\n             task = entityFactory.newEntity(PropagationTask.class);\n@@ -626,53 +617,14 @@ protected ConnectorObject getRemoteObject(\n             final Provision provision,\n             final boolean latest) {\n \n-        String connObjectKey = latest || task.getOldConnObjectKey() == null\n+        String connObjectKeyValue = latest || task.getOldConnObjectKey() == null\n                 ? task.getConnObjectKey()\n                 : task.getOldConnObjectKey();\n \n-        boolean isLinkedAccount = task.getAnyTypeKind() == AnyTypeKind.USER\n-                && userDAO.linkedAccountExists(task.getEntityKey(), connObjectKey);\n-\n-        Set<MappingItem> linkingMappingItems = isLinkedAccount\n-                ? Set.of()\n-                : virSchemaDAO.findByProvision(provision).stream().\n-                        map(VirSchema::asLinkingMappingItem).collect(Collectors.toSet());\n-\n-        Optional<? extends MappingItem> connObjectKeyItem = MappingUtils.getConnObjectKeyItem(provision);\n-        String connObjectKeyName = connObjectKeyItem.isPresent()\n-                ? connObjectKeyItem.get().getExtAttrName()\n-                : Name.NAME;\n-\n-        ConnectorObject obj = null;\n-        try {\n-            obj = connector.getObject(\n-                    new ObjectClass(task.getObjectClassName()),\n-                    AttributeBuilder.build(connObjectKeyName, connObjectKey),\n-                    provision.isIgnoreCaseMatch(),\n-                    MappingUtils.buildOperationOptions(new IteratorChain<>(\n-                            MappingUtils.getPropagationItems(provision.getMapping().getItems()).iterator(),\n-                            linkingMappingItems.iterator())));\n-\n-            for (MappingItem item : linkingMappingItems) {\n-                Attribute attr = obj.getAttributeByName(item.getExtAttrName());\n-                if (attr == null) {\n-                    virAttrCache.expire(task.getAnyType(), task.getEntityKey(), item.getIntAttrName());\n-                } else {\n-                    virAttrCache.put(\n-                            task.getAnyType(),\n-                            task.getEntityKey(),\n-                            item.getIntAttrName(),\n-                            new VirAttrCacheValue(attr.getValue()));\n-                }\n-            }\n-        } catch (TimeoutException toe) {\n-            LOG.debug(\"Request timeout\", toe);\n-            throw toe;\n-        } catch (RuntimeException ignore) {\n-            LOG.debug(\"While resolving {}\", connObjectKey, ignore);\n-        }\n+        List<ConnectorObject> matches = outboundMatcher.match(task, connector, provision, connObjectKeyValue);\n+        LOG.debug(\"Found for propagation task {}: {}\", task, matches);\n \n-        return obj;\n+        return matches.isEmpty() ? null : matches.get(0);\n     }\n \n     /**\n@@ -698,11 +650,12 @@ protected ConnectorObject getRemoteObject(\n         Optional<? extends OrgUnitItem> connObjectKeyItem = orgUnit.getConnObjectKeyItem();\n         if (connObjectKeyItem.isPresent()) {\n             try {\n-                obj = connector.getObject(new ObjectClass(task.getObjectClassName()),\n+                obj = connector.getObject(\n+                        new ObjectClass(task.getObjectClassName()),\n                         AttributeBuilder.build(connObjectKeyItem.get().getExtAttrName(), connObjectKey),\n                         orgUnit.isIgnoreCaseMatch(),\n                         MappingUtils.buildOperationOptions(\n-                                MappingUtils.getPropagationItems(orgUnit.getItems()).iterator()));\n+                                MappingUtils.getPropagationItems(orgUnit.getItems().stream())));\n             } catch (TimeoutException toe) {\n                 LOG.debug(\"Request timeout\", toe);\n                 throw toe;"},{"sha":"b96cc3a19f5e13befcefb25dee64220ffddc49ba","filename":"core/provisioning-java/src/main/java/org/apache/syncope/core/provisioning/java/propagation/AzurePropagationActions.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpropagation%2FAzurePropagationActions.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpropagation%2FAzurePropagationActions.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpropagation%2FAzurePropagationActions.java?ref=64495efbbc906599bf3c7de1c0692a7c3139b024","patch":"@@ -35,7 +35,7 @@\n  * This class is required during setup of an External Resource based on the ConnId\n  * <a href=\"https://github.com/Tirasa/ConnIdAzureBundle\">Azure connector</a>.\n  *\n- * It ensures to send the configured e-mail address as <pre>__NAME__</pre>.\n+ * It ensures to send the configured e-mail address as {@code __NAME__}.\n  */\n public class AzurePropagationActions implements PropagationActions {\n \n@@ -70,7 +70,7 @@ private static void setName(final PropagationTask task) {\n         Set<Attribute> attrs = new HashSet<>(task.getAttributes());\n \n         if (AttributeUtil.find(getEmailAttrName(), attrs) == null) {\n-            LOG.warn(\"Can't find {} attribute to set as __NAME__ attribute value, skipping...\", getEmailAttrName());\n+            LOG.warn(\"Can't find {} to set as {} attribute value, skipping...\", getEmailAttrName(), Name.NAME);\n             return;\n         }\n "},{"sha":"5fbb4b091fbe191ea346c147be89485c330cff15","filename":"core/provisioning-java/src/main/java/org/apache/syncope/core/provisioning/java/propagation/DefaultPropagationReporter.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpropagation%2FDefaultPropagationReporter.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpropagation%2FDefaultPropagationReporter.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpropagation%2FDefaultPropagationReporter.java?ref=64495efbbc906599bf3c7de1c0692a7c3139b024","patch":"@@ -59,11 +59,11 @@ public void onSuccessOrNonPriorityResourceFailures(\n         status.setFailureReason(failureReason);\n \n         if (beforeObj != null) {\n-            status.setBeforeObj(ConnObjectUtils.getConnObjectTO(beforeObj));\n+            status.setBeforeObj(ConnObjectUtils.getConnObjectTO(beforeObj.getAttributes()));\n         }\n \n         if (afterObj != null) {\n-            status.setAfterObj(ConnObjectUtils.getConnObjectTO(afterObj));\n+            status.setAfterObj(ConnObjectUtils.getConnObjectTO(afterObj.getAttributes()));\n         }\n \n         add(status);"},{"sha":"a106842880825f8169123520b9c4ea6216fe09d9","filename":"core/provisioning-java/src/main/java/org/apache/syncope/core/provisioning/java/propagation/GoogleAppsPropagationActions.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpropagation%2FGoogleAppsPropagationActions.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpropagation%2FGoogleAppsPropagationActions.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpropagation%2FGoogleAppsPropagationActions.java?ref=64495efbbc906599bf3c7de1c0692a7c3139b024","patch":"@@ -36,7 +36,7 @@\n  * This class is required during setup of an External Resource based on the ConnId\n  * <a href=\"https://github.com/Tirasa/ConnIdGoogleAppsBundle\">GoogleApps connector</a>.\n  *\n- * It ensures to send the configured e-mail address as <pre>__NAME__</pre>.\n+ * It ensures to send the configured e-mail address as {@code __NAME__}.\n  */\n public class GoogleAppsPropagationActions implements PropagationActions {\n \n@@ -59,7 +59,7 @@ public void before(final PropagationTask task, final ConnectorObject beforeObj)\n         Set<Attribute> attrs = new HashSet<>(task.getAttributes());\n \n         if (AttributeUtil.find(getEmailAttrName(), attrs) == null) {\n-            LOG.warn(\"Can't find {} attribute to set as __NAME__ attribute value, skipping...\", getEmailAttrName());\n+            LOG.warn(\"Can't find {} to set as {} attribute value, skipping...\", getEmailAttrName(), Name.NAME);\n             return;\n         }\n "},{"sha":"1c387127a23b643f5e15a1050e68311bf00a0196","filename":"core/provisioning-java/src/main/java/org/apache/syncope/core/provisioning/java/propagation/PropagationManagerImpl.java","status":"modified","additions":11,"deletions":10,"changes":21,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpropagation%2FPropagationManagerImpl.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpropagation%2FPropagationManagerImpl.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpropagation%2FPropagationManagerImpl.java?ref=64495efbbc906599bf3c7de1c0692a7c3139b024","patch":"@@ -18,6 +18,7 @@\n  */\n package org.apache.syncope.core.provisioning.java.propagation;\n \n+import java.util.stream.Stream;\n import org.apache.commons.lang3.StringUtils;\n import org.apache.commons.lang3.tuple.Pair;\n import org.apache.syncope.common.lib.Attr;\n@@ -393,7 +394,7 @@ protected PropagationTaskInfo newTask(\n             final ResourceOperation operation,\n             final Provision provision,\n             final boolean deleteOnResource,\n-            final List<? extends Item> mappingItems,\n+            final Stream<? extends Item> mappingItems,\n             final Pair<String, Set<Attribute>> preparedAttrs) {\n \n         PropagationTaskInfo task = new PropagationTaskInfo();\n@@ -411,7 +412,7 @@ protected PropagationTaskInfo newTask(\n         // if so, add special attributes that will be evaluated by PropagationTaskExecutor\n         List<String> mandatoryMissing = new ArrayList<>();\n         List<String> mandatoryNullOrEmpty = new ArrayList<>();\n-        mappingItems.stream().filter(item -> (!item.isConnObjectKey()\n+        mappingItems.filter(item -> (!item.isConnObjectKey()\n                 && JexlUtils.evaluateMandatoryCondition(item.getMandatoryCondition(), any))).forEach(item -> {\n \n             Attribute attr = AttributeUtil.find(item.getExtAttrName(), preparedAttrs.getRight());\n@@ -507,16 +508,16 @@ protected List<PropagationTaskInfo> createTasks(\n             Provision provision = Optional.ofNullable(resource).\n                     map(externalResource -> externalResource.getProvision(any.getType()).\n                     orElse(null)).orElse(null);\n-            List<? extends Item> mappingItems = provision == null\n-                    ? List.of()\n-                    : MappingUtils.getPropagationItems(provision.getMapping().getItems());\n+            Stream<? extends Item> mappingItems = provision == null\n+                    ? Stream.empty()\n+                    : MappingUtils.getPropagationItems(provision.getMapping().getItems().stream());\n \n             if (resource == null) {\n                 LOG.error(\"Invalid resource name specified: {}, ignoring...\", resourceKey);\n             } else if (provision == null) {\n                 LOG.error(\"No provision specified on resource {} for type {}, ignoring...\",\n                         resource, any.getType());\n-            } else if (mappingItems.isEmpty()) {\n+            } else if (provision.getMapping() == null || provision.getMapping().getItems().isEmpty()) {\n                 LOG.warn(\"Requesting propagation for {} but no propagation mapping provided for {}\",\n                         any.getType(), resource);\n             } else {\n@@ -553,9 +554,9 @@ protected List<PropagationTaskInfo> createTasks(\n                 Provision provision = account == null || account.getResource() == null\n                         ? null\n                         : account.getResource().getProvision(AnyTypeKind.USER.name()).orElse(null);\n-                List<? extends Item> mappingItems = provision == null\n-                        ? List.of()\n-                        : MappingUtils.getPropagationItems(provision.getMapping().getItems());\n+                Stream<? extends Item> mappingItems = provision == null\n+                        ? Stream.empty()\n+                        : MappingUtils.getPropagationItems(provision.getMapping().getItems().stream());\n \n                 if (account == null) {\n                     LOG.error(\"Invalid operation {} on deleted account {} on resource {}, ignoring...\",\n@@ -565,7 +566,7 @@ protected List<PropagationTaskInfo> createTasks(\n                 } else if (provision == null) {\n                     LOG.error(\"No provision specified on resource {} for type {}, ignoring...\",\n                             account.getResource(), AnyTypeKind.USER.name());\n-                } else if (mappingItems.isEmpty()) {\n+                } else if (provision.getMapping() == null || provision.getMapping().getItems().isEmpty()) {\n                     LOG.warn(\"Requesting propagation for {} but no propagation mapping provided for {}\",\n                             AnyTypeKind.USER.name(), account.getResource());\n                 } else {"},{"sha":"7229f075ca8d0c5b67613d464b2380705ce04ee6","filename":"core/provisioning-java/src/main/java/org/apache/syncope/core/provisioning/java/pushpull/ADMembershipPullActions.java","status":"modified","additions":4,"deletions":10,"changes":14,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FADMembershipPullActions.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FADMembershipPullActions.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FADMembershipPullActions.java?ref=64495efbbc906599bf3c7de1c0692a7c3139b024","patch":"@@ -18,8 +18,6 @@\n  */\n package org.apache.syncope.core.provisioning.java.pushpull;\n \n-import java.util.Optional;\n-import org.apache.syncope.common.lib.types.ConnConfProperty;\n import org.apache.syncope.core.provisioning.api.Connector;\n \n /**\n@@ -38,14 +36,10 @@ public class ADMembershipPullActions extends LDAPMembershipPullActions {\n      */\n     @Override\n     protected String getGroupMembershipAttrName(final Connector connector) {\n-        Optional<ConnConfProperty> groupMembership = connector.getConnInstance().getConf().stream().\n+        return connector.getConnInstance().getConf().stream().\n                 filter(property -> \"groupMemberReferenceAttribute\".equals(property.getSchema().getName())\n-                && !property.getValues().isEmpty()).\n-                findFirst();\n-\n-        return groupMembership.isPresent()\n-                ? (String) groupMembership.get().getValues().get(0)\n-                : \"member\";\n+                && !property.getValues().isEmpty()).findFirst().\n+                map(groupMembership -> (String) groupMembership.getValues().get(0)).\n+                orElse(\"member\");\n     }\n-\n }"},{"sha":"7afe3a5ce3af85f3f6fe19d27d3c4a8334849a8a","filename":"core/provisioning-java/src/main/java/org/apache/syncope/core/provisioning/java/pushpull/AbstractPullResultHandler.java","status":"modified","additions":68,"deletions":71,"changes":139,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FAbstractPullResultHandler.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FAbstractPullResultHandler.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FAbstractPullResultHandler.java?ref=64495efbbc906599bf3c7de1c0692a7c3139b024","patch":"@@ -30,8 +30,10 @@\n import org.apache.syncope.common.lib.request.AnyUR;\n import org.apache.syncope.common.lib.request.StringPatchItem;\n import org.apache.syncope.common.lib.to.AnyTO;\n+import org.apache.syncope.common.lib.types.AnyTypeKind;\n import org.apache.syncope.common.lib.types.AuditElements;\n import org.apache.syncope.common.lib.types.AuditElements.Result;\n+import org.apache.syncope.common.lib.types.MatchType;\n import org.apache.syncope.common.lib.types.MatchingRule;\n import org.apache.syncope.common.lib.types.PatchOperation;\n import org.apache.syncope.core.provisioning.api.PropagationByResource;\n@@ -44,7 +46,6 @@\n import org.apache.syncope.core.provisioning.api.propagation.PropagationException;\n import org.apache.syncope.core.spring.security.DelegatedAdministrationException;\n import org.apache.syncope.core.persistence.api.dao.VirSchemaDAO;\n-import org.apache.syncope.core.persistence.api.entity.AnyUtils;\n import org.apache.syncope.core.persistence.api.entity.EntityFactory;\n import org.apache.syncope.core.persistence.api.entity.Remediation;\n import org.apache.syncope.core.persistence.api.entity.resource.Provision;\n@@ -69,17 +70,12 @@\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.transaction.annotation.Transactional;\n \n-import javax.annotation.Resource;\n-\n @Transactional(rollbackFor = Throwable.class)\n public abstract class AbstractPullResultHandler extends AbstractSyncopeResultHandler<PullTask, PullActions>\n         implements SyncopePullResultHandler {\n \n-    @Resource(name = \"adminUser\")\n-    protected String adminUser;\n-    \n     @Autowired\n-    protected PullUtils pullUtils;\n+    protected InboundMatcher inboundMatcher;\n \n     @Autowired\n     protected NotificationManager notificationManager;\n@@ -130,8 +126,8 @@ public boolean handle(final SyncDelta delta) {\n         try {\n             provision = profile.getTask().getResource().getProvision(delta.getObject().getObjectClass()).\n                     orElseThrow(() -> new JobExecutionException(\n-                    \"No provision found on \" + profile.getTask().getResource() + \" for \"\n-                    + delta.getObject().getObjectClass()));\n+                    \"No provision found on \" + profile.getTask().getResource()\n+                    + \" for \" + delta.getObject().getObjectClass()));\n \n             doHandle(delta, provision);\n             executor.reportHandled(delta.getObjectClass(), delta.getObject().getName());\n@@ -188,16 +184,15 @@ public boolean handle(final SyncDelta delta) {\n     protected List<ProvisioningReport> provision(\n             final UnmatchingRule rule,\n             final SyncDelta delta,\n-            final Provision provision,\n-            final AnyUtils anyUtils) throws JobExecutionException {\n+            final Provision provision) throws JobExecutionException {\n \n         if (!profile.getTask().isPerformCreate()) {\n             LOG.debug(\"PullTask not configured for create\");\n-            finalize(UnmatchingRule.toEventName(rule), Result.SUCCESS, null, null, delta);\n-            return List.of();\n+            end(provision.getAnyType().getKind(), UnmatchingRule.toEventName(rule), Result.SUCCESS, null, null, delta);\n+            return Collections.<ProvisioningReport>emptyList();\n         }\n \n-        AnyCR anyCR = connObjectUtils.getAnyCR(delta.getObject(), profile.getTask(), provision, anyUtils, true);\n+        AnyCR anyCR = connObjectUtils.getAnyCR(delta.getObject(), profile.getTask(), provision, true);\n         if (rule == UnmatchingRule.ASSIGN) {\n             anyCR.getResources().add(profile.getTask().getResource().getKey());\n         }\n@@ -211,7 +206,7 @@ protected List<ProvisioningReport> provision(\n \n         if (profile.isDryRun()) {\n             result.setKey(null);\n-            finalize(UnmatchingRule.toEventName(rule), Result.SUCCESS, null, null, delta);\n+            end(provision.getAnyType().getKind(), UnmatchingRule.toEventName(rule), Result.SUCCESS, null, null, delta);\n         } else {\n             for (PullActions action : profile.getActions()) {\n                 if (rule == UnmatchingRule.ASSIGN) {\n@@ -266,7 +261,7 @@ protected List<ProvisioningReport> provision(\n                 }\n             }\n \n-            finalize(UnmatchingRule.toEventName(rule), resultStatus, null, output, delta);\n+            end(provision.getAnyType().getKind(), UnmatchingRule.toEventName(rule), resultStatus, null, output, delta);\n         }\n \n         return Collections.singletonList(result);\n@@ -297,7 +292,8 @@ protected List<ProvisioningReport> update(\n \n         if (!profile.getTask().isPerformUpdate()) {\n             LOG.debug(\"PullTask not configured for update\");\n-            finalize(MatchingRule.toEventName(MatchingRule.UPDATE), Result.SUCCESS, null, null, delta);\n+            end(provision.getAnyType().getKind(),\n+                    MatchingRule.toEventName(MatchingRule.UPDATE), Result.SUCCESS, null, null, delta);\n             return Collections.<ProvisioningReport>emptyList();\n         }\n \n@@ -312,9 +308,9 @@ protected List<ProvisioningReport> update(\n             result.setOperation(ResourceOperation.UPDATE);\n             result.setAnyType(provision.getAnyType().getKey());\n             result.setStatus(ProvisioningReport.Status.SUCCESS);\n-            result.setKey(match.getMatchingKey());\n+            result.setKey(match.getAny().getKey());\n \n-            AnyTO before = getAnyTO(match.getMatchingKey());\n+            AnyTO before = getAnyTO(match.getAny());\n             if (before == null) {\n                 result.setStatus(ProvisioningReport.Status.FAILURE);\n                 result.setMessage(String.format(\"Any '%s(%s)' not found\", provision.getAnyType().getKey(), match));\n@@ -338,8 +334,7 @@ protected List<ProvisioningReport> update(\n                                 delta.getObject(),\n                                 before,\n                                 profile.getTask(),\n-                                provision,\n-                                getAnyUtils());\n+                                provision);\n \n                         for (PullActions action : profile.getActions()) {\n                             action.beforeUpdate(profile, delta, before, anyUR);\n@@ -388,7 +383,8 @@ protected List<ProvisioningReport> update(\n                         }\n                     }\n                 }\n-                finalize(MatchingRule.toEventName(MatchingRule.UPDATE),\n+                end(provision.getAnyType().getKind(),\n+                        MatchingRule.toEventName(MatchingRule.UPDATE),\n                         resultStatus, before, output, delta, effectiveReq);\n             }\n             results.add(result);\n@@ -405,7 +401,8 @@ protected List<ProvisioningReport> deprovision(\n \n         if (!profile.getTask().isPerformUpdate()) {\n             LOG.debug(\"PullTask not configured for update\");\n-            finalize(MatchingRule.toEventName(matchingRule), Result.SUCCESS, null, null, delta);\n+            end(provision.getAnyType().getKind(),\n+                    MatchingRule.toEventName(matchingRule), Result.SUCCESS, null, null, delta);\n             return Collections.<ProvisioningReport>emptyList();\n         }\n \n@@ -420,9 +417,9 @@ protected List<ProvisioningReport> deprovision(\n             result.setOperation(ResourceOperation.DELETE);\n             result.setAnyType(provision.getAnyType().getKey());\n             result.setStatus(ProvisioningReport.Status.SUCCESS);\n-            result.setKey(match.getMatchingKey());\n+            result.setKey(match.getAny().getKey());\n \n-            AnyTO before = getAnyTO(match.getMatchingKey());\n+            AnyTO before = getAnyTO(match.getAny());\n \n             if (before == null) {\n                 result.setStatus(ProvisioningReport.Status.FAILURE);\n@@ -455,22 +452,22 @@ protected List<ProvisioningReport> deprovision(\n \n                         taskExecutor.execute(propagationManager.getDeleteTasks(\n                                 provision.getAnyType().getKind(),\n-                                match.getMatchingKey(),\n+                                match.getAny().getKey(),\n                                 propByRes,\n                                 null,\n                                 null),\n                                 false,\n-                                this.adminUser);\n+                                adminUser);\n \n                         AnyUR anyUR = null;\n                         if (matchingRule == MatchingRule.UNASSIGN) {\n-                            anyUR = getAnyUtils().newAnyUR(match.getMatchingKey());\n+                            anyUR = getAnyUtils().newAnyUR(match.getAny().getKey());\n                             anyUR.getResources().add(new StringPatchItem.Builder().\n                                     operation(PatchOperation.DELETE).\n                                     value(profile.getTask().getResource().getKey()).build());\n                         }\n                         if (anyUR == null) {\n-                            output = getAnyTO(match.getMatchingKey());\n+                            output = getAnyTO(match.getAny());\n                         } else {\n                             output = doUpdate(before, anyUR, delta, result);\n                         }\n@@ -500,7 +497,8 @@ protected List<ProvisioningReport> deprovision(\n                         resultStatus = Result.FAILURE;\n                     }\n                 }\n-                finalize(MatchingRule.toEventName(matchingRule), resultStatus, before, output, delta);\n+                end(provision.getAnyType().getKind(),\n+                        MatchingRule.toEventName(matchingRule), resultStatus, before, output, delta);\n             }\n             results.add(result);\n         }\n@@ -517,9 +515,11 @@ protected List<ProvisioningReport> link(\n \n         if (!profile.getTask().isPerformUpdate()) {\n             LOG.debug(\"PullTask not configured for update\");\n-            finalize(unlink\n-                    ? MatchingRule.toEventName(MatchingRule.UNLINK)\n-                    : MatchingRule.toEventName(MatchingRule.LINK), Result.SUCCESS, null, null, delta);\n+            end(provision.getAnyType().getKind(),\n+                    unlink\n+                            ? MatchingRule.toEventName(MatchingRule.UNLINK)\n+                            : MatchingRule.toEventName(MatchingRule.LINK),\n+                    Result.SUCCESS, null, null, delta);\n             return Collections.<ProvisioningReport>emptyList();\n         }\n \n@@ -534,9 +534,9 @@ protected List<ProvisioningReport> link(\n             result.setOperation(ResourceOperation.NONE);\n             result.setAnyType(provision.getAnyType().getKey());\n             result.setStatus(ProvisioningReport.Status.SUCCESS);\n-            result.setKey(match.getMatchingKey());\n+            result.setKey(match.getAny().getKey());\n \n-            AnyTO before = getAnyTO(match.getMatchingKey());\n+            AnyTO before = getAnyTO(match.getAny());\n \n             if (before == null) {\n                 result.setStatus(ProvisioningReport.Status.FAILURE);\n@@ -598,9 +598,10 @@ protected List<ProvisioningReport> link(\n                         resultStatus = Result.FAILURE;\n                     }\n                 }\n-                finalize(unlink\n-                        ? MatchingRule.toEventName(MatchingRule.UNLINK)\n-                        : MatchingRule.toEventName(MatchingRule.LINK),\n+                end(provision.getAnyType().getKind(),\n+                        unlink\n+                                ? MatchingRule.toEventName(MatchingRule.UNLINK)\n+                                : MatchingRule.toEventName(MatchingRule.LINK),\n                         resultStatus, before, output, delta, effectiveReq);\n             }\n             results.add(result);\n@@ -617,7 +618,8 @@ protected List<ProvisioningReport> delete(\n \n         if (!profile.getTask().isPerformDelete()) {\n             LOG.debug(\"PullTask not configured for delete\");\n-            finalize(ResourceOperation.DELETE.name().toLowerCase(), Result.SUCCESS, null, null, delta);\n+            end(provision.getAnyType().getKind(),\n+                    ResourceOperation.DELETE.name().toLowerCase(), Result.SUCCESS, null, null, delta);\n             return Collections.<ProvisioningReport>emptyList();\n         }\n \n@@ -632,9 +634,9 @@ protected List<ProvisioningReport> delete(\n             ProvisioningReport result = new ProvisioningReport();\n \n             try {\n-                AnyTO before = getAnyTO(match.getMatchingKey());\n+                AnyTO before = getAnyTO(match.getAny());\n \n-                result.setKey(match.getMatchingKey());\n+                result.setKey(match.getAny().getKey());\n                 result.setName(getName(before));\n                 result.setOperation(ResourceOperation.DELETE);\n                 result.setAnyType(provision.getAnyType().getKey());\n@@ -647,7 +649,7 @@ protected List<ProvisioningReport> delete(\n \n                     try {\n                         getProvisioningManager().delete(\n-                                match.getMatchingKey(),\n+                                match.getAny().getKey(),\n                                 Collections.singleton(profile.getTask().getResource().getKey()),\n                                 true);\n                         output = null;\n@@ -668,7 +670,7 @@ protected List<ProvisioningReport> delete(\n                             Remediation entity = entityFactory.newEntity(Remediation.class);\n                             entity.setAnyType(provision.getAnyType());\n                             entity.setOperation(ResourceOperation.DELETE);\n-                            entity.setPayload(match.getMatchingKey());\n+                            entity.setPayload(match.getAny().getKey());\n                             entity.setError(result.getMessage());\n                             entity.setInstant(new Date());\n                             entity.setRemoteName(delta.getObject().getName().getNameValue());\n@@ -678,7 +680,8 @@ protected List<ProvisioningReport> delete(\n                         }\n                     }\n \n-                    finalize(ResourceOperation.DELETE.name().toLowerCase(), resultStatus, before, output, delta);\n+                    end(provision.getAnyType().getKind(),\n+                            ResourceOperation.DELETE.name().toLowerCase(), resultStatus, before, output, delta);\n                 }\n \n                 results.add(result);\n@@ -721,7 +724,7 @@ protected List<ProvisioningReport> ignore(\n         } else {\n             matches.forEach(match -> {\n                 ProvisioningReport report = new ProvisioningReport();\n-                report.setKey(match.getMatchingKey());\n+                report.setKey(match.getAny().getKey());\n                 report.setName(delta.getObject().getUid().getUidValue());\n                 report.setOperation(ResourceOperation.NONE);\n                 report.setAnyType(provision.getAnyType().getKey());\n@@ -734,31 +737,31 @@ protected List<ProvisioningReport> ignore(\n             });\n         }\n \n-        finalize(matching\n-                ? MatchingRule.toEventName(MatchingRule.IGNORE)\n-                : UnmatchingRule.toEventName(UnmatchingRule.IGNORE), Result.SUCCESS, null, null, delta);\n+        end(provision.getAnyType().getKind(),\n+                matching\n+                        ? MatchingRule.toEventName(MatchingRule.IGNORE)\n+                        : UnmatchingRule.toEventName(UnmatchingRule.IGNORE), Result.SUCCESS, null, null, delta);\n \n         return results;\n     }\n \n     protected void handleAnys(\n             final SyncDelta delta,\n             final List<PullMatch> matches,\n-            final Provision provision,\n-            final AnyUtils anyUtils) throws JobExecutionException {\n+            final Provision provision) throws JobExecutionException {\n \n         if (matches.isEmpty()) {\n             LOG.debug(\"Nothing to do\");\n             return;\n         }\n \n         if (SyncDeltaType.CREATE_OR_UPDATE == delta.getDeltaType()) {\n-            if (matches.get(0).getMatchingKey() == null) {\n+            if (matches.get(0).getAny() == null) {\n                 switch (profile.getTask().getUnmatchingRule()) {\n                     case ASSIGN:\n                     case PROVISION:\n                         profile.getResults().addAll(\n-                                provision(profile.getTask().getUnmatchingRule(), delta, provision, anyUtils));\n+                                provision(profile.getTask().getUnmatchingRule(), delta, provision));\n                         break;\n \n                     case IGNORE:\n@@ -776,12 +779,12 @@ protected void handleAnys(\n                         if (attr == null) {\n                             virAttrCache.expire(\n                                     provision.getAnyType().getKey(),\n-                                    match.getMatchingKey(),\n+                                    match.getAny().getKey(),\n                                     virSchema.getKey());\n                         } else {\n                             virAttrCache.put(\n                                     provision.getAnyType().getKey(),\n-                                    match.getMatchingKey(),\n+                                    match.getAny().getKey(),\n                                     virSchema.getKey(),\n                                     new VirAttrCacheValue(attr.getValue()));\n                         }\n@@ -823,16 +826,15 @@ protected void handleAnys(\n     protected void handleLinkedAccounts(\n             final SyncDelta delta,\n             final List<PullMatch> matches,\n-            final Provision provision,\n-            final AnyUtils anyUtils) throws JobExecutionException {\n+            final Provision provision) throws JobExecutionException {\n \n         if (matches.isEmpty()) {\n             LOG.debug(\"Nothing to do\");\n             return;\n         }\n \n         // nothing to do in the general case\n-        LOG.warn(\"Unexpected linked accounts found for {}: {}\", anyUtils.anyTypeKind(), matches);\n+        LOG.warn(\"Unexpected linked accounts found for {}: {}\", provision.getAnyType().getKind(), matches);\n     }\n \n     /**\n@@ -843,8 +845,6 @@ protected void handleLinkedAccounts(\n      * @throws JobExecutionException in case of pull failure.\n      */\n     protected void doHandle(final SyncDelta delta, final Provision provision) throws JobExecutionException {\n-        AnyUtils anyUtils = getAnyUtils();\n-\n         LOG.debug(\"Process {} for {} as {}\",\n                 delta.getDeltaType(), delta.getUid().getUidValue(), delta.getObject().getObjectClass());\n \n@@ -857,7 +857,7 @@ protected void doHandle(final SyncDelta delta, final Provision provision) throws\n                 finalDelta.getDeltaType(), finalDelta.getUid().getUidValue(), finalDelta.getObject().getObjectClass());\n \n         try {\n-            List<PullMatch> matches = pullUtils.match(finalDelta, provision, anyUtils);\n+            List<PullMatch> matches = inboundMatcher.match(finalDelta, provision);\n             LOG.debug(\"Match(es) found for {} as {}: {}\",\n                     finalDelta.getUid().getUidValue(), finalDelta.getObject().getObjectClass(), matches);\n \n@@ -884,23 +884,22 @@ protected void doHandle(final SyncDelta delta, final Provision provision) throws\n             handleAnys(\n                     finalDelta,\n                     matches.stream().\n-                            filter(match -> match.getMatchTarget() == PullMatch.MatchTarget.ANY).\n-                            collect(Collectors.toList()), provision,\n-                    anyUtils);\n+                            filter(match -> match.getMatchTarget() == MatchType.ANY).\n+                            collect(Collectors.toList()), provision);\n \n             // linked accounts\n             handleLinkedAccounts(\n                     finalDelta,\n                     matches.stream().\n-                            filter(match -> match.getMatchTarget() == PullMatch.MatchTarget.LINKED_ACCOUNT).\n-                            collect(Collectors.toList()), provision,\n-                    anyUtils);\n+                            filter(match -> match.getMatchTarget() == MatchType.LINKED_ACCOUNT).\n+                            collect(Collectors.toList()), provision);\n         } catch (IllegalStateException | IllegalArgumentException e) {\n             LOG.warn(e.getMessage());\n         }\n     }\n \n-    protected void finalize(\n+    protected void end(\n+            final AnyTypeKind anyTypeKind,\n             final String event,\n             final Result result,\n             final Object before,\n@@ -912,12 +911,10 @@ protected void finalize(\n             this.latestResult = result;\n         }\n \n-        AnyUtils anyUtils = getAnyUtils();\n-\n         notificationManager.createTasks(\n                 AuthContextUtils.getUsername(),\n                 AuditElements.EventCategoryType.PULL,\n-                anyUtils.anyTypeKind().name().toLowerCase(),\n+                anyTypeKind.name().toLowerCase(),\n                 profile.getTask().getResource().getKey(),\n                 event,\n                 result,\n@@ -929,7 +926,7 @@ protected void finalize(\n         auditManager.audit(\n                 AuthContextUtils.getUsername(),\n                 AuditElements.EventCategoryType.PULL,\n-                anyUtils.anyTypeKind().name().toLowerCase(),\n+                anyTypeKind.name().toLowerCase(),\n                 profile.getTask().getResource().getKey(),\n                 event,\n                 result,"},{"sha":"f8a4e1b0b2ab0f15e5138c985fd230368234fdf0","filename":"core/provisioning-java/src/main/java/org/apache/syncope/core/provisioning/java/pushpull/AbstractPushResultHandler.java","status":"modified","additions":9,"deletions":14,"changes":23,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FAbstractPushResultHandler.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FAbstractPushResultHandler.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FAbstractPushResultHandler.java?ref=64495efbbc906599bf3c7de1c0692a7c3139b024","patch":"@@ -62,16 +62,11 @@\n import org.springframework.transaction.annotation.Propagation;\n import org.springframework.transaction.annotation.Transactional;\n \n-import javax.annotation.Resource;\n-\n public abstract class AbstractPushResultHandler extends AbstractSyncopeResultHandler<PushTask, PushActions>\n         implements SyncopePushResultHandler {\n \n     @Autowired\n-    protected PushUtils pushUtils;\n-\n-    @Resource(name = \"adminUser\")\n-    protected String adminUser;\n+    protected OutboundMatcher outboundMatcher;\n \n     /**\n      * Notification Manager.\n@@ -129,13 +124,13 @@ protected void update(\n         if (!taskInfos.isEmpty()) {\n             taskInfos.get(0).setBeforeObj(Optional.of(beforeObj));\n             PropagationReporter reporter = new DefaultPropagationReporter();\n-            taskExecutor.execute(taskInfos.get(0), reporter, this.adminUser);\n+            taskExecutor.execute(taskInfos.get(0), reporter, adminUser);\n             reportPropagation(result, reporter);\n         }\n     }\n \n     protected void deprovision(final Any<?> any, final ConnectorObject beforeObj, final ProvisioningReport result) {\n-        AnyTO before = getAnyTO(any.getKey());\n+        AnyTO before = getAnyTO(any);\n \n         List<String> noPropResources = new ArrayList<>(before.getResources());\n         noPropResources.remove(profile.getTask().getResource().getKey());\n@@ -153,13 +148,13 @@ protected void deprovision(final Any<?> any, final ConnectorObject beforeObj, fi\n         if (!taskInfos.isEmpty()) {\n             taskInfos.get(0).setBeforeObj(Optional.of(beforeObj));\n             PropagationReporter reporter = new DefaultPropagationReporter();\n-            taskExecutor.execute(taskInfos.get(0), reporter, this.adminUser);\n+            taskExecutor.execute(taskInfos.get(0), reporter, adminUser);\n             reportPropagation(result, reporter);\n         }\n     }\n \n     protected void provision(final Any<?> any, final Boolean enable, final ProvisioningReport result) {\n-        AnyTO before = getAnyTO(any.getKey());\n+        AnyTO before = getAnyTO(any);\n \n         List<String> noPropResources = new ArrayList<>(before.getResources());\n         noPropResources.remove(profile.getTask().getResource().getKey());\n@@ -177,7 +172,7 @@ protected void provision(final Any<?> any, final Boolean enable, final Provision\n         if (!taskInfos.isEmpty()) {\n             taskInfos.get(0).setBeforeObj(Optional.ofNullable(null));\n             PropagationReporter reporter = new DefaultPropagationReporter();\n-            taskExecutor.execute(taskInfos.get(0), reporter, this.adminUser);\n+            taskExecutor.execute(taskInfos.get(0), reporter, adminUser);\n             reportPropagation(result, reporter);\n         }\n     }\n@@ -263,11 +258,11 @@ protected void doHandle(final Any<?> any, final Provision provision) throws JobE\n         result.setAnyType(any.getType().getKey());\n         result.setName(getName(any));\n \n-        LOG.debug(\"Propagating {} with key {} towards {}\",\n+        LOG.debug(\"Pushing {} with key {} towards {}\",\n                 any.getType().getKind(), any.getKey(), profile.getTask().getResource());\n \n         // Try to read remote object BEFORE any actual operation\n-        List<ConnectorObject> connObjs = pushUtils.match(profile.getConnector(), any, provision);\n+        List<ConnectorObject> connObjs = outboundMatcher.match(profile.getConnector(), any, provision);\n         LOG.debug(\"Match(es) found for {} as {}: {}\", any, provision.getObjectClass(), connObjs);\n \n         if (connObjs.size() > 1) {\n@@ -460,7 +455,7 @@ protected void doHandle(final Any<?> any, final Provision provision) throws JobE\n \n                 if (notificationsAvailable || auditRequested) {\n                     resultStatus = AuditElements.Result.SUCCESS;\n-                    output = pushUtils.findByConnObjectKey(profile.getConnector(), any, provision);\n+                    output = outboundMatcher.match(profile.getConnector(), any, provision);\n                 }\n             } catch (IgnoreProvisionException e) {\n                 throw e;"},{"sha":"35a1180760c9de7f1ffaaf5bd92e994c2b851268","filename":"core/provisioning-java/src/main/java/org/apache/syncope/core/provisioning/java/pushpull/AbstractRealmResultHandler.java","status":"modified","additions":4,"deletions":0,"changes":4,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FAbstractRealmResultHandler.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FAbstractRealmResultHandler.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FAbstractRealmResultHandler.java?ref=64495efbbc906599bf3c7de1c0692a7c3139b024","patch":"@@ -18,6 +18,7 @@\n  */\n package org.apache.syncope.core.provisioning.java.pushpull;\n \n+import javax.annotation.Resource;\n import org.apache.syncope.core.persistence.api.dao.RealmDAO;\n import org.apache.syncope.core.persistence.api.entity.task.ProvisioningTask;\n import org.apache.syncope.core.provisioning.api.AuditManager;\n@@ -69,6 +70,9 @@\n     @Autowired\n     protected PropagationTaskExecutor taskExecutor;\n \n+    @Resource(name = \"adminUser\")\n+    protected String adminUser;\n+\n     /**\n      * Provisioning profile.\n      */"},{"sha":"3b5e8f25e89a9dc03812af63a62b010492005ca6","filename":"core/provisioning-java/src/main/java/org/apache/syncope/core/provisioning/java/pushpull/AbstractSyncopeResultHandler.java","status":"modified","additions":8,"deletions":3,"changes":11,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FAbstractSyncopeResultHandler.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FAbstractSyncopeResultHandler.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FAbstractSyncopeResultHandler.java?ref=64495efbbc906599bf3c7de1c0692a7c3139b024","patch":"@@ -18,17 +18,19 @@\n  */\n package org.apache.syncope.core.provisioning.java.pushpull;\n \n+import javax.annotation.Resource;\n import org.apache.syncope.common.lib.request.AnyUR;\n import org.apache.syncope.common.lib.to.AnyTO;\n+import org.apache.syncope.core.persistence.api.entity.Any;\n+import org.apache.syncope.core.persistence.api.entity.AnyUtils;\n+import org.apache.syncope.core.persistence.api.entity.AnyUtilsFactory;\n import org.apache.syncope.core.persistence.api.entity.task.ProvisioningTask;\n import org.apache.syncope.core.provisioning.api.data.GroupDataBinder;\n import org.apache.syncope.core.provisioning.api.data.UserDataBinder;\n import org.apache.syncope.core.provisioning.api.propagation.PropagationManager;\n import org.apache.syncope.core.provisioning.api.propagation.PropagationTaskExecutor;\n import org.apache.syncope.core.provisioning.api.pushpull.ProvisioningProfile;\n import org.apache.syncope.core.provisioning.api.pushpull.SyncopeResultHandler;\n-import org.apache.syncope.core.persistence.api.entity.AnyUtils;\n-import org.apache.syncope.core.persistence.api.entity.AnyUtilsFactory;\n import org.apache.syncope.core.provisioning.api.WorkflowResult;\n import org.apache.syncope.core.provisioning.api.data.AnyObjectDataBinder;\n import org.apache.syncope.core.provisioning.api.pushpull.ProvisioningActions;\n@@ -83,14 +85,17 @@\n     @Autowired\n     protected AnyUtilsFactory anyUtilsFactory;\n \n+    @Resource(name = \"adminUser\")\n+    protected String adminUser;\n+\n     /**\n      * Provisioning profile.\n      */\n     protected ProvisioningProfile<T, A> profile;\n \n     protected abstract AnyUtils getAnyUtils();\n \n-    protected abstract AnyTO getAnyTO(String key);\n+    protected abstract AnyTO getAnyTO(Any<?> any);\n \n     protected abstract WorkflowResult<? extends AnyUR> update(AnyUR req);\n "},{"sha":"a87fff4e67db096f93adb561d344b4ecbaed9390","filename":"core/provisioning-java/src/main/java/org/apache/syncope/core/provisioning/java/pushpull/DefaultAnyObjectPullResultHandler.java","status":"modified","additions":5,"deletions":3,"changes":8,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FDefaultAnyObjectPullResultHandler.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FDefaultAnyObjectPullResultHandler.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FDefaultAnyObjectPullResultHandler.java?ref=64495efbbc906599bf3c7de1c0692a7c3139b024","patch":"@@ -31,7 +31,9 @@\n import org.apache.syncope.common.lib.to.PropagationStatus;\n import org.apache.syncope.common.lib.to.AnyObjectTO;\n import org.apache.syncope.common.lib.types.AnyTypeKind;\n+import org.apache.syncope.core.persistence.api.entity.Any;\n import org.apache.syncope.core.persistence.api.entity.AnyUtils;\n+import org.apache.syncope.core.persistence.api.entity.anyobject.AnyObject;\n import org.apache.syncope.core.provisioning.api.AnyObjectProvisioningManager;\n import org.apache.syncope.core.provisioning.api.ProvisioningManager;\n import org.apache.syncope.core.provisioning.api.WorkflowResult;\n@@ -66,8 +68,8 @@ protected String getName(final AnyCR anyCR) {\n     }\n \n     @Override\n-    protected AnyTO getAnyTO(final String key) {\n-        return anyObjectDataBinder.getAnyObjectTO(key);\n+    protected AnyTO getAnyTO(final Any<?> any) {\n+        return anyObjectDataBinder.getAnyObjectTO((AnyObject) any, true);\n     }\n \n     @Override\n@@ -82,7 +84,7 @@ protected AnyTO doCreate(final AnyCR anyCR, final SyncDelta delta) {\n         Map.Entry<String, List<PropagationStatus>> created = anyObjectProvisioningManager.create(\n                 anyObjectCR, Set.of(profile.getTask().getResource().getKey()), true);\n \n-        return getAnyTO(created.getKey());\n+        return anyObjectDataBinder.getAnyObjectTO(created.getKey());\n     }\n \n     @Override"},{"sha":"dc7ab630512db141c2c346b25ca3f03e88e49458","filename":"core/provisioning-java/src/main/java/org/apache/syncope/core/provisioning/java/pushpull/DefaultAnyObjectPushResultHandler.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FDefaultAnyObjectPushResultHandler.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FDefaultAnyObjectPushResultHandler.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FDefaultAnyObjectPushResultHandler.java?ref=64495efbbc906599bf3c7de1c0692a7c3139b024","patch":"@@ -41,8 +41,8 @@ protected String getName(final Any<?> any) {\n     }\n \n     @Override\n-    protected AnyTO getAnyTO(final String key) {\n-        return anyObjectDataBinder.getAnyObjectTO(key);\n+    protected AnyTO getAnyTO(final Any<?> any) {\n+        return anyObjectDataBinder.getAnyObjectTO((AnyObject) any, true);\n     }\n \n     @Override"},{"sha":"96c765ac0c26ba93b8e534611d50c6151c327e76","filename":"core/provisioning-java/src/main/java/org/apache/syncope/core/provisioning/java/pushpull/DefaultGroupPullResultHandler.java","status":"modified","additions":5,"deletions":3,"changes":8,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FDefaultGroupPullResultHandler.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FDefaultGroupPullResultHandler.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FDefaultGroupPullResultHandler.java?ref=64495efbbc906599bf3c7de1c0692a7c3139b024","patch":"@@ -34,7 +34,9 @@\n import org.apache.syncope.common.lib.to.GroupTO;\n import org.apache.syncope.common.lib.types.AnyTypeKind;\n import org.apache.syncope.common.lib.types.PatchOperation;\n+import org.apache.syncope.core.persistence.api.entity.Any;\n import org.apache.syncope.core.persistence.api.entity.AnyUtils;\n+import org.apache.syncope.core.persistence.api.entity.group.Group;\n import org.apache.syncope.core.provisioning.api.GroupProvisioningManager;\n import org.apache.syncope.core.provisioning.api.ProvisioningManager;\n import org.apache.syncope.core.provisioning.api.WorkflowResult;\n@@ -76,8 +78,8 @@ protected String getName(final AnyCR anyCR) {\n     }\n \n     @Override\n-    protected AnyTO getAnyTO(final String key) {\n-        return groupDataBinder.getGroupTO(key);\n+    protected AnyTO getAnyTO(final Any<?> any) {\n+        return groupDataBinder.getGroupTO((Group) any, true);\n     }\n \n     @Override\n@@ -95,7 +97,7 @@ protected AnyTO doCreate(final AnyCR anyCR, final SyncDelta delta) {\n                 Set.of(profile.getTask().getResource().getKey()),\n                 true);\n \n-        return getAnyTO(created.getKey());\n+        return groupDataBinder.getGroupTO(created.getKey());\n     }\n \n     @Override"},{"sha":"714711c831569b520c127ccaef4f3628e050c131","filename":"core/provisioning-java/src/main/java/org/apache/syncope/core/provisioning/java/pushpull/DefaultGroupPushResultHandler.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FDefaultGroupPushResultHandler.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FDefaultGroupPushResultHandler.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FDefaultGroupPushResultHandler.java?ref=64495efbbc906599bf3c7de1c0692a7c3139b024","patch":"@@ -41,8 +41,8 @@ protected String getName(final Any<?> any) {\n     }\n \n     @Override\n-    protected AnyTO getAnyTO(final String key) {\n-        return groupDataBinder.getGroupTO(key);\n+    protected AnyTO getAnyTO(final Any<?> any) {\n+        return groupDataBinder.getGroupTO((Group) any, true);\n     }\n \n     @Override"},{"sha":"d275ea2762390ca6dbdc64808f4c419575b91ecd","filename":"core/provisioning-java/src/main/java/org/apache/syncope/core/provisioning/java/pushpull/DefaultRealmPullResultHandler.java","status":"modified","additions":154,"deletions":201,"changes":355,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FDefaultRealmPullResultHandler.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FDefaultRealmPullResultHandler.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FDefaultRealmPullResultHandler.java?ref=64495efbbc906599bf3c7de1c0692a7c3139b024","patch":"@@ -57,18 +57,13 @@\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.transaction.annotation.Transactional;\n \n-import javax.annotation.Resource;\n-\n @Transactional(rollbackFor = Throwable.class)\n public class DefaultRealmPullResultHandler\n         extends AbstractRealmResultHandler<PullTask, PullActions>\n         implements RealmPullResultHandler {\n \n-    @Resource(name = \"adminUser\")\n-    protected String adminUser;\n-\n     @Autowired\n-    private PullUtils pullUtils;\n+    private InboundMatcher inboundMatcher;\n \n     @Autowired\n     private ConnObjectUtils connObjectUtils;\n@@ -244,7 +239,7 @@ private void create(\n             propByRes.addAll(ResourceOperation.CREATE, realm.getResourceKeys());\n             if (unmatchingRule == UnmatchingRule.ASSIGN) {\n                 List<PropagationTaskInfo> taskInfos = propagationManager.createTasks(realm, propByRes, null);\n-                taskExecutor.execute(taskInfos, false, this.adminUser);\n+                taskExecutor.execute(taskInfos, false, adminUser);\n             }\n \n             RealmTO actual = binder.getRealmTO(realm, true);\n@@ -279,7 +274,7 @@ private void create(\n         finalize(UnmatchingRule.toEventName(unmatchingRule), resultStatus, null, output, delta);\n     }\n \n-    private List<ProvisioningReport> update(final SyncDelta delta, final List<String> keys, final boolean inLink)\n+    private List<ProvisioningReport> update(final SyncDelta delta, final List<Realm> realms, final boolean inLink)\n             throws JobExecutionException {\n \n         if (!profile.getTask().isPerformUpdate()) {\n@@ -288,84 +283,74 @@ private List<ProvisioningReport> update(final SyncDelta delta, final List<String\n             return List.of();\n         }\n \n-        LOG.debug(\"About to update {}\", keys);\n+        LOG.debug(\"About to update {}\", realms);\n \n         List<ProvisioningReport> results = new ArrayList<>();\n \n-        for (String key : keys) {\n-            LOG.debug(\"About to update {}\", key);\n+        for (Realm realm : realms) {\n+            LOG.debug(\"About to update {}\", realm);\n \n             ProvisioningReport result = new ProvisioningReport();\n             result.setOperation(ResourceOperation.UPDATE);\n             result.setAnyType(REALM_TYPE);\n             result.setStatus(ProvisioningReport.Status.SUCCESS);\n-            result.setKey(key);\n-\n-            Realm realm = realmDAO.find(key);\n-            RealmTO before = binder.getRealmTO(realm, true);\n-            if (before == null) {\n-                result.setStatus(ProvisioningReport.Status.FAILURE);\n-                result.setMessage(String.format(\"Realm '%s' not found\", key));\n-            } else {\n-                result.setName(before.getFullPath());\n-            }\n+            result.setKey(realm.getKey());\n+            result.setName(realm.getFullPath());\n \n             if (!profile.isDryRun()) {\n                 Result resultStatus;\n                 Object output;\n \n-                if (before == null) {\n-                    resultStatus = Result.FAILURE;\n-                    output = null;\n-                } else {\n-                    try {\n-                        if (!inLink) {\n-                            for (PullActions action : profile.getActions()) {\n-                                action.beforeUpdate(profile, delta, before, null);\n-                            }\n+                RealmTO before = binder.getRealmTO(realm, true);\n+                try {\n+                    if (!inLink) {\n+                        for (PullActions action : profile.getActions()) {\n+                            action.beforeUpdate(profile, delta, before, null);\n                         }\n+                    }\n \n-                        PropagationByResource<String> propByRes = binder.update(realm, before);\n-                        realm = realmDAO.save(realm);\n-                        RealmTO updated = binder.getRealmTO(realm, true);\n+                    PropagationByResource<String> propByRes = binder.update(realm, before);\n+                    realm = realmDAO.save(realm);\n+                    RealmTO updated = binder.getRealmTO(realm, true);\n \n-                        List<PropagationTaskInfo> taskInfos = propagationManager.createTasks(realm, propByRes, null);\n-                        taskExecutor.execute(taskInfos, false, this.adminUser);\n+                    List<PropagationTaskInfo> taskInfos = propagationManager.createTasks(realm, propByRes, null);\n+                    taskExecutor.execute(taskInfos, false, adminUser);\n \n-                        for (PullActions action : profile.getActions()) {\n-                            action.after(profile, delta, updated, result);\n-                        }\n+                    for (PullActions action : profile.getActions()) {\n+                        action.after(profile, delta, updated, result);\n+                    }\n \n-                        output = updated;\n-                        resultStatus = Result.SUCCESS;\n-                        result.setName(updated.getFullPath());\n+                    output = updated;\n+                    resultStatus = Result.SUCCESS;\n+                    result.setName(updated.getFullPath());\n \n-                        LOG.debug(\"{} successfully updated\", updated);\n-                    } catch (PropagationException e) {\n-                        // A propagation failure doesn't imply a pull failure.\n-                        // The propagation exception status will be reported into the propagation task execution.\n-                        LOG.error(\"Could not propagate Realm {}\", delta.getUid().getUidValue(), e);\n-                        output = e;\n-                        resultStatus = Result.FAILURE;\n-                    } catch (Exception e) {\n-                        throwIgnoreProvisionException(delta, e);\n+                    LOG.debug(\"{} successfully updated\", updated);\n+                } catch (PropagationException e) {\n+                    // A propagation failure doesn't imply a pull failure.\n+                    // The propagation exception status will be reported into the propagation task execution.\n+                    LOG.error(\"Could not propagate Realm {}\", delta.getUid().getUidValue(), e);\n+                    output = e;\n+                    resultStatus = Result.FAILURE;\n+                } catch (Exception e) {\n+                    throwIgnoreProvisionException(delta, e);\n \n-                        result.setStatus(ProvisioningReport.Status.FAILURE);\n-                        result.setMessage(ExceptionUtils.getRootCauseMessage(e));\n-                        LOG.error(\"Could not update Realm {}\", delta.getUid().getUidValue(), e);\n-                        output = e;\n-                        resultStatus = Result.FAILURE;\n-                    }\n+                    result.setStatus(ProvisioningReport.Status.FAILURE);\n+                    result.setMessage(ExceptionUtils.getRootCauseMessage(e));\n+                    LOG.error(\"Could not update Realm {}\", delta.getUid().getUidValue(), e);\n+                    output = e;\n+                    resultStatus = Result.FAILURE;\n                 }\n+\n                 finalize(MatchingRule.toEventName(MatchingRule.UPDATE), resultStatus, before, output, delta);\n             }\n+\n             results.add(result);\n         }\n \n         return results;\n     }\n \n-    private List<ProvisioningReport> deprovision(final SyncDelta delta, final List<String> keys, final boolean unlink)\n+    private List<ProvisioningReport> deprovision(final SyncDelta delta, final List<Realm> realms, final boolean unlink)\n             throws JobExecutionException {\n \n         if (!profile.getTask().isPerformUpdate()) {\n@@ -376,95 +361,84 @@ private List<ProvisioningReport> deprovision(final SyncDelta delta, final List<S\n             return List.of();\n         }\n \n-        LOG.debug(\"About to deprovision {}\", keys);\n+        LOG.debug(\"About to deprovision {}\", realms);\n \n         final List<ProvisioningReport> results = new ArrayList<>();\n \n-        for (String key : keys) {\n-            LOG.debug(\"About to unassign resource {}\", key);\n+        for (Realm realm : realms) {\n+            LOG.debug(\"About to unassign resource {}\", realm);\n \n             ProvisioningReport result = new ProvisioningReport();\n             result.setOperation(ResourceOperation.DELETE);\n             result.setAnyType(REALM_TYPE);\n             result.setStatus(ProvisioningReport.Status.SUCCESS);\n-            result.setKey(key);\n-\n-            Realm realm = realmDAO.find(key);\n-            RealmTO before = binder.getRealmTO(realm, true);\n-            if (before == null) {\n-                result.setStatus(ProvisioningReport.Status.FAILURE);\n-                result.setMessage(String.format(\"Realm '%s' not found\", key));\n-            } else {\n-                result.setName(before.getFullPath());\n-            }\n+            result.setKey(realm.getKey());\n+            result.setName(realm.getFullPath());\n \n             if (!profile.isDryRun()) {\n                 Object output;\n                 Result resultStatus;\n \n-                if (before == null) {\n-                    resultStatus = Result.FAILURE;\n-                    output = null;\n-                } else {\n-                    try {\n-                        if (unlink) {\n-                            for (PullActions action : profile.getActions()) {\n-                                action.beforeUnassign(profile, delta, before);\n-                            }\n-                        } else {\n-                            for (PullActions action : profile.getActions()) {\n-                                action.beforeDeprovision(profile, delta, before);\n-                            }\n-                        }\n-\n-                        PropagationByResource<String> propByRes = new PropagationByResource<>();\n-                        propByRes.add(ResourceOperation.DELETE, profile.getTask().getResource().getKey());\n-                        taskExecutor.execute(propagationManager.createTasks(realm, propByRes, null),\n-                            false, this.adminUser);\n-\n-                        RealmTO realmTO;\n-                        if (unlink) {\n-                            realm.getResources().remove(profile.getTask().getResource());\n-                            realmTO = binder.getRealmTO(realmDAO.save(realm), true);\n-                        } else {\n-                            realmTO = binder.getRealmTO(realm, true);\n+                RealmTO before = binder.getRealmTO(realm, true);\n+                try {\n+                    if (unlink) {\n+                        for (PullActions action : profile.getActions()) {\n+                            action.beforeUnassign(profile, delta, before);\n                         }\n-                        output = realmTO;\n-\n+                    } else {\n                         for (PullActions action : profile.getActions()) {\n-                            action.after(profile, delta, realmTO, result);\n+                            action.beforeDeprovision(profile, delta, before);\n                         }\n+                    }\n \n-                        resultStatus = Result.SUCCESS;\n+                    PropagationByResource<String> propByRes = new PropagationByResource<>();\n+                    propByRes.add(ResourceOperation.DELETE, profile.getTask().getResource().getKey());\n+                    taskExecutor.execute(propagationManager.createTasks(realm, propByRes, null), false, adminUser);\n \n-                        LOG.debug(\"{} successfully updated\", realm);\n-                    } catch (PropagationException e) {\n-                        // A propagation failure doesn't imply a pull failure.\n-                        // The propagation exception status will be reported into the propagation task execution.\n-                        LOG.error(\"Could not propagate Realm {}\", delta.getUid().getUidValue(), e);\n-                        output = e;\n-                        resultStatus = Result.FAILURE;\n-                    } catch (Exception e) {\n-                        throwIgnoreProvisionException(delta, e);\n+                    RealmTO realmTO;\n+                    if (unlink) {\n+                        realm.getResources().remove(profile.getTask().getResource());\n+                        realmTO = binder.getRealmTO(realmDAO.save(realm), true);\n+                    } else {\n+                        realmTO = binder.getRealmTO(realm, true);\n+                    }\n+                    output = realmTO;\n \n-                        result.setStatus(ProvisioningReport.Status.FAILURE);\n-                        result.setMessage(ExceptionUtils.getRootCauseMessage(e));\n-                        LOG.error(\"Could not update Realm {}\", delta.getUid().getUidValue(), e);\n-                        output = e;\n-                        resultStatus = Result.FAILURE;\n+                    for (PullActions action : profile.getActions()) {\n+                        action.after(profile, delta, realmTO, result);\n                     }\n+\n+                    resultStatus = Result.SUCCESS;\n+\n+                    LOG.debug(\"{} successfully updated\", realm);\n+                } catch (PropagationException e) {\n+                    // A propagation failure doesn't imply a pull failure.\n+                    // The propagation exception status will be reported into the propagation task execution.\n+                    LOG.error(\"Could not propagate Realm {}\", delta.getUid().getUidValue(), e);\n+                    output = e;\n+                    resultStatus = Result.FAILURE;\n+                } catch (Exception e) {\n+                    throwIgnoreProvisionException(delta, e);\n+\n+                    result.setStatus(ProvisioningReport.Status.FAILURE);\n+                    result.setMessage(ExceptionUtils.getRootCauseMessage(e));\n+                    LOG.error(\"Could not update Realm {}\", delta.getUid().getUidValue(), e);\n+                    output = e;\n+                    resultStatus = Result.FAILURE;\n                 }\n+\n                 finalize(unlink\n                         ? MatchingRule.toEventName(MatchingRule.UNASSIGN)\n                         : MatchingRule.toEventName(MatchingRule.DEPROVISION), resultStatus, before, output, delta);\n             }\n+\n             results.add(result);\n         }\n \n         return results;\n     }\n \n-    private List<ProvisioningReport> link(final SyncDelta delta, final List<String> keys, final boolean unlink)\n+    private List<ProvisioningReport> link(final SyncDelta delta, final List<Realm> realms, final boolean unlink)\n             throws JobExecutionException {\n \n         if (!profile.getTask().isPerformUpdate()) {\n@@ -475,72 +449,62 @@ private List<ProvisioningReport> link(final SyncDelta delta, final List<String>\n             return List.of();\n         }\n \n-        LOG.debug(\"About to link {}\", keys);\n+        LOG.debug(\"About to link {}\", realms);\n \n         final List<ProvisioningReport> results = new ArrayList<>();\n \n-        for (String key : keys) {\n-            LOG.debug(\"About to unassign resource {}\", key);\n+        for (Realm realm : realms) {\n+            LOG.debug(\"About to unassign resource {}\", realm);\n \n             ProvisioningReport result = new ProvisioningReport();\n             result.setOperation(ResourceOperation.NONE);\n             result.setAnyType(REALM_TYPE);\n             result.setStatus(ProvisioningReport.Status.SUCCESS);\n-            result.setKey(key);\n-\n-            Realm realm = realmDAO.find(key);\n-            RealmTO before = binder.getRealmTO(realm, true);\n-            if (before == null) {\n-                result.setStatus(ProvisioningReport.Status.FAILURE);\n-                result.setMessage(String.format(\"Realm '%s' not found\", key));\n-            } else {\n-                result.setName(before.getFullPath());\n-            }\n+            result.setKey(realm.getKey());\n+            result.setName(realm.getFullPath());\n \n-            Object output;\n-            Result resultStatus;\n             if (!profile.isDryRun()) {\n-                if (before == null) {\n-                    resultStatus = Result.FAILURE;\n-                    output = null;\n-                } else {\n-                    try {\n-                        if (unlink) {\n-                            for (PullActions action : profile.getActions()) {\n-                                action.beforeUnlink(profile, delta, before);\n-                            }\n-                        } else {\n-                            for (PullActions action : profile.getActions()) {\n-                                action.beforeLink(profile, delta, before);\n-                            }\n-                        }\n+                Object output;\n+                Result resultStatus;\n \n-                        if (unlink) {\n-                            realm.getResources().remove(profile.getTask().getResource());\n-                        } else {\n-                            realm.add(profile.getTask().getResource());\n+                RealmTO before = binder.getRealmTO(realm, true);\n+                try {\n+                    if (unlink) {\n+                        for (PullActions action : profile.getActions()) {\n+                            action.beforeUnlink(profile, delta, before);\n                         }\n-                        output = update(delta, List.of(key), true);\n+                    } else {\n+                        for (PullActions action : profile.getActions()) {\n+                            action.beforeLink(profile, delta, before);\n+                        }\n+                    }\n \n-                        resultStatus = Result.SUCCESS;\n+                    if (unlink) {\n+                        realm.getResources().remove(profile.getTask().getResource());\n+                    } else {\n+                        realm.add(profile.getTask().getResource());\n+                    }\n+                    output = update(delta, List.of(realm), true);\n \n-                        LOG.debug(\"{} successfully updated\", realm);\n-                    } catch (PropagationException e) {\n-                        // A propagation failure doesn't imply a pull failure.\n-                        // The propagation exception status will be reported into the propagation task execution.\n-                        LOG.error(\"Could not propagate Realm {}\", delta.getUid().getUidValue(), e);\n-                        output = e;\n-                        resultStatus = Result.FAILURE;\n-                    } catch (Exception e) {\n-                        throwIgnoreProvisionException(delta, e);\n+                    resultStatus = Result.SUCCESS;\n \n-                        result.setStatus(ProvisioningReport.Status.FAILURE);\n-                        result.setMessage(ExceptionUtils.getRootCauseMessage(e));\n-                        LOG.error(\"Could not update Realm {}\", delta.getUid().getUidValue(), e);\n-                        output = e;\n-                        resultStatus = Result.FAILURE;\n-                    }\n+                    LOG.debug(\"{} successfully updated\", realm);\n+                } catch (PropagationException e) {\n+                    // A propagation failure doesn't imply a pull failure.\n+                    // The propagation exception status will be reported into the propagation task execution.\n+                    LOG.error(\"Could not propagate Realm {}\", delta.getUid().getUidValue(), e);\n+                    output = e;\n+                    resultStatus = Result.FAILURE;\n+                } catch (Exception e) {\n+                    throwIgnoreProvisionException(delta, e);\n+\n+                    result.setStatus(ProvisioningReport.Status.FAILURE);\n+                    result.setMessage(ExceptionUtils.getRootCauseMessage(e));\n+                    LOG.error(\"Could not update Realm {}\", delta.getUid().getUidValue(), e);\n+                    output = e;\n+                    resultStatus = Result.FAILURE;\n                 }\n+\n                 finalize(unlink\n                         ? MatchingRule.toEventName(MatchingRule.UNLINK)\n                         : MatchingRule.toEventName(MatchingRule.LINK), resultStatus, before, output, delta);\n@@ -551,7 +515,7 @@ private List<ProvisioningReport> link(final SyncDelta delta, final List<String>\n         return results;\n     }\n \n-    private List<ProvisioningReport> delete(final SyncDelta delta, final List<String> keys)\n+    private List<ProvisioningReport> delete(final SyncDelta delta, final List<Realm> realms)\n             throws JobExecutionException {\n \n         if (!profile.getTask().isPerformDelete()) {\n@@ -560,31 +524,24 @@ private List<ProvisioningReport> delete(final SyncDelta delta, final List<String\n             return List.of();\n         }\n \n-        LOG.debug(\"About to delete {}\", keys);\n+        LOG.debug(\"About to delete {}\", realms);\n \n         List<ProvisioningReport> results = new ArrayList<>();\n \n-        for (String key : keys) {\n+        realms.forEach(realm -> {\n             Object output;\n             Result resultStatus = Result.FAILURE;\n \n             ProvisioningReport result = new ProvisioningReport();\n \n+            RealmTO before = binder.getRealmTO(realm, true);\n             try {\n-                result.setKey(key);\n+                result.setKey(realm.getKey());\n+                result.setName(realm.getFullPath());\n                 result.setOperation(ResourceOperation.DELETE);\n                 result.setAnyType(REALM_TYPE);\n                 result.setStatus(ProvisioningReport.Status.SUCCESS);\n \n-                Realm realm = realmDAO.find(key);\n-                RealmTO before = binder.getRealmTO(realm, true);\n-                if (before == null) {\n-                    result.setStatus(ProvisioningReport.Status.FAILURE);\n-                    result.setMessage(String.format(\"Realm '%s' not found\", key));\n-                } else {\n-                    result.setName(before.getFullPath());\n-                }\n-\n                 if (!profile.isDryRun()) {\n                     for (PullActions action : profile.getActions()) {\n                         action.beforeDelete(profile, delta, before);\n@@ -615,7 +572,7 @@ private List<ProvisioningReport> delete(final SyncDelta delta, final List<String\n                         PropagationByResource<String> propByRes = new PropagationByResource<>();\n                         propByRes.addAll(ResourceOperation.DELETE, realm.getResourceKeys());\n                         List<PropagationTaskInfo> taskInfos = propagationManager.createTasks(realm, propByRes, null);\n-                        taskExecutor.execute(taskInfos, false, this.adminUser);\n+                        taskExecutor.execute(taskInfos, false, adminUser);\n \n                         realmDAO.delete(realm);\n \n@@ -639,20 +596,16 @@ private List<ProvisioningReport> delete(final SyncDelta delta, final List<String\n \n                 results.add(result);\n             } catch (DelegatedAdministrationException e) {\n-                LOG.error(\"Not allowed to read Realm {}\", key, e);\n+                LOG.error(\"Not allowed to read Realm {}\", realm, e);\n             } catch (Exception e) {\n-                LOG.error(\"Could not delete Realm {}\", key, e);\n+                LOG.error(\"Could not delete Realm {}\", realm, e);\n             }\n-        }\n+        });\n \n         return results;\n     }\n \n-    private ProvisioningReport ignore(\n-            final SyncDelta delta,\n-            final boolean matching)\n-            throws JobExecutionException {\n-\n+    private ProvisioningReport ignore(final SyncDelta delta, final boolean matching) throws JobExecutionException {\n         LOG.debug(\"Any to ignore {}\", delta.getObject().getUid().getUidValue());\n \n         ProvisioningReport result = new ProvisioningReport();\n@@ -684,22 +637,22 @@ private void doHandle(final SyncDelta delta, final OrgUnit orgUnit) throws JobEx\n         LOG.debug(\"Transformed {} for {} as {}\",\n                 finalDelta.getDeltaType(), finalDelta.getUid().getUidValue(), finalDelta.getObject().getObjectClass());\n \n-        List<String> keys = pullUtils.match(finalDelta, orgUnit);\n+        List<Realm> realms = inboundMatcher.match(finalDelta, orgUnit);\n         LOG.debug(\"Match found for {} as {}: {}\",\n-                finalDelta.getUid().getUidValue(), finalDelta.getObject().getObjectClass(), keys);\n+                finalDelta.getUid().getUidValue(), finalDelta.getObject().getObjectClass(), realms);\n \n-        if (keys.size() > 1) {\n+        if (realms.size() > 1) {\n             switch (profile.getConflictResolutionAction()) {\n                 case IGNORE:\n                     throw new IgnoreProvisionException(\"More than one match found for \"\n-                            + finalDelta.getObject().getUid().getUidValue() + \": \" + keys);\n+                            + finalDelta.getObject().getUid().getUidValue() + \": \" + realms);\n \n                 case FIRSTMATCH:\n-                    keys = keys.subList(0, 1);\n+                    realms = realms.subList(0, 1);\n                     break;\n \n                 case LASTMATCH:\n-                    keys = keys.subList(keys.size() - 1, keys.size());\n+                    realms = realms.subList(realms.size() - 1, realms.size());\n                     break;\n \n                 default:\n@@ -709,7 +662,7 @@ private void doHandle(final SyncDelta delta, final OrgUnit orgUnit) throws JobEx\n \n         try {\n             if (SyncDeltaType.CREATE_OR_UPDATE == finalDelta.getDeltaType()) {\n-                if (keys.isEmpty()) {\n+                if (realms.isEmpty()) {\n                     switch (profile.getTask().getUnmatchingRule()) {\n                         case ASSIGN:\n                             profile.getResults().addAll(assign(finalDelta, orgUnit));\n@@ -729,23 +682,23 @@ private void doHandle(final SyncDelta delta, final OrgUnit orgUnit) throws JobEx\n                 } else {\n                     switch (profile.getTask().getMatchingRule()) {\n                         case UPDATE:\n-                            profile.getResults().addAll(update(finalDelta, keys, false));\n+                            profile.getResults().addAll(update(finalDelta, realms, false));\n                             break;\n \n                         case DEPROVISION:\n-                            profile.getResults().addAll(deprovision(finalDelta, keys, false));\n+                            profile.getResults().addAll(deprovision(finalDelta, realms, false));\n                             break;\n \n                         case UNASSIGN:\n-                            profile.getResults().addAll(deprovision(finalDelta, keys, true));\n+                            profile.getResults().addAll(deprovision(finalDelta, realms, true));\n                             break;\n \n                         case LINK:\n-                            profile.getResults().addAll(link(finalDelta, keys, false));\n+                            profile.getResults().addAll(link(finalDelta, realms, false));\n                             break;\n \n                         case UNLINK:\n-                            profile.getResults().addAll(link(finalDelta, keys, true));\n+                            profile.getResults().addAll(link(finalDelta, realms, true));\n                             break;\n \n                         case IGNORE:\n@@ -757,11 +710,11 @@ private void doHandle(final SyncDelta delta, final OrgUnit orgUnit) throws JobEx\n                     }\n                 }\n             } else if (SyncDeltaType.DELETE == finalDelta.getDeltaType()) {\n-                if (keys.isEmpty()) {\n+                if (realms.isEmpty()) {\n                     finalize(ResourceOperation.DELETE.name().toLowerCase(), Result.SUCCESS, null, null, finalDelta);\n                     LOG.debug(\"No match found for deletion\");\n                 } else {\n-                    profile.getResults().addAll(delete(finalDelta, keys));\n+                    profile.getResults().addAll(delete(finalDelta, realms));\n                 }\n             }\n         } catch (IllegalStateException | IllegalArgumentException e) {"},{"sha":"3576c8cf8ca36f8926d14cd0a6f5cee1e848f67f","filename":"core/provisioning-java/src/main/java/org/apache/syncope/core/provisioning/java/pushpull/DefaultRealmPushResultHandler.java","status":"modified","additions":8,"deletions":13,"changes":21,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FDefaultRealmPushResultHandler.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FDefaultRealmPushResultHandler.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FDefaultRealmPushResultHandler.java?ref=64495efbbc906599bf3c7de1c0692a7c3139b024","patch":"@@ -20,10 +20,10 @@\n \n import java.util.ArrayList;\n import java.util.HashMap;\n-import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n import java.util.Optional;\n+import java.util.stream.Stream;\n import org.apache.commons.lang3.exception.ExceptionUtils;\n import org.apache.syncope.common.lib.to.RealmTO;\n import org.apache.syncope.common.lib.types.AuditElements;\n@@ -60,15 +60,10 @@\n import org.springframework.transaction.annotation.Propagation;\n import org.springframework.transaction.annotation.Transactional;\n \n-import javax.annotation.Resource;\n-\n public class DefaultRealmPushResultHandler\n         extends AbstractRealmResultHandler<PushTask, PushActions>\n         implements RealmPushResultHandler {\n \n-    @Resource(name = \"adminUser\")\n-    protected String adminUser;\n-\n     @Autowired\n     private MappingManager mappingManager;\n \n@@ -115,7 +110,7 @@ private Realm update(final RealmTO realmTO, final ConnectorObject beforeObj, fin\n         if (!taskInfos.isEmpty()) {\n             taskInfos.get(0).setBeforeObj(Optional.ofNullable(beforeObj));\n             PropagationReporter reporter = new DefaultPropagationReporter();\n-            taskExecutor.execute(taskInfos.get(0), reporter, this.adminUser);\n+            taskExecutor.execute(taskInfos.get(0), reporter, adminUser);\n             reportPropagation(result, reporter);\n         }\n \n@@ -133,7 +128,7 @@ private void deprovision(final Realm realm, final ConnectorObject beforeObj, fin\n         if (!taskInfos.isEmpty()) {\n             taskInfos.get(0).setBeforeObj(Optional.ofNullable(beforeObj));\n             PropagationReporter reporter = new DefaultPropagationReporter();\n-            taskExecutor.execute(taskInfos.get(0), reporter, this.adminUser);\n+            taskExecutor.execute(taskInfos.get(0), reporter, adminUser);\n             reportPropagation(result, reporter);\n         }\n     }\n@@ -146,7 +141,7 @@ private void provision(final Realm realm, final ProvisioningReport result) {\n         propByRes.add(ResourceOperation.CREATE, profile.getTask().getResource().getKey());\n \n         PropagationReporter reporter = taskExecutor.execute(\n-                propagationManager.createTasks(realm, propByRes, noPropResources), false, this.adminUser);\n+                propagationManager.createTasks(realm, propByRes, noPropResources), false, adminUser);\n         reportPropagation(result, reporter);\n     }\n \n@@ -180,15 +175,15 @@ protected ConnectorObject getRemoteObject(\n             final String connObjectKey,\n             final String connObjectKeyValue,\n             final boolean ignoreCaseMatch,\n-            final Iterator<? extends Item> iterator) {\n+            final Stream<? extends Item> mapItems) {\n \n         ConnectorObject obj = null;\n         try {\n             obj = profile.getConnector().getObject(\n                     objectClass,\n                     AttributeBuilder.build(connObjectKey, connObjectKeyValue),\n                     ignoreCaseMatch,\n-                    MappingUtils.buildOperationOptions(iterator));\n+                    MappingUtils.buildOperationOptions(mapItems));\n         } catch (TimeoutException toe) {\n             LOG.debug(\"Request timeout\", toe);\n             throw toe;\n@@ -224,7 +219,7 @@ private void doHandle(final Realm realm) throws JobExecutionException {\n                     connObjectKey.get().getExtAttrName(),\n                     connObjecKeyValue.get(),\n                     orgUnit.isIgnoreCaseMatch(),\n-                    orgUnit.getItems().iterator());\n+                    orgUnit.getItems().stream());\n         } else {\n             LOG.debug(\"OrgUnitItem {} or its value {} are null\", connObjectKey, connObjecKeyValue);\n         }\n@@ -406,7 +401,7 @@ private void doHandle(final Realm realm) throws JobExecutionException {\n                                 connObjectKey.get().getExtAttrName(),\n                                 connObjecKeyValue.get(),\n                                 orgUnit.isIgnoreCaseMatch(),\n-                                orgUnit.getItems().iterator());\n+                                orgUnit.getItems().stream());\n                     }\n                 }\n             } catch (IgnoreProvisionException e) {"},{"sha":"3ddd89e38afd5c9c3c6dc9cb24744414193ad437","filename":"core/provisioning-java/src/main/java/org/apache/syncope/core/provisioning/java/pushpull/DefaultUserPullResultHandler.java","status":"modified","additions":33,"deletions":27,"changes":60,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FDefaultUserPullResultHandler.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FDefaultUserPullResultHandler.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FDefaultUserPullResultHandler.java?ref=64495efbbc906599bf3c7de1c0692a7c3139b024","patch":"@@ -40,11 +40,13 @@\n import org.apache.syncope.common.lib.types.AnyTypeKind;\n import org.apache.syncope.common.lib.types.AuditElements;\n import org.apache.syncope.common.lib.types.AuditElements.Result;\n+import org.apache.syncope.common.lib.types.MatchType;\n import org.apache.syncope.common.lib.types.MatchingRule;\n import org.apache.syncope.common.lib.types.PatchOperation;\n import org.apache.syncope.common.lib.types.ResourceOperation;\n import org.apache.syncope.common.lib.types.UnmatchingRule;\n import org.apache.syncope.core.persistence.api.dao.PullMatch;\n+import org.apache.syncope.core.persistence.api.entity.Any;\n import org.apache.syncope.core.persistence.api.entity.AnyUtils;\n import org.apache.syncope.core.persistence.api.entity.resource.Provision;\n import org.apache.syncope.core.persistence.api.entity.user.LinkedAccount;\n@@ -90,8 +92,8 @@ protected String getName(final AnyCR anyCR) {\n     }\n \n     @Override\n-    protected AnyTO getAnyTO(final String key) {\n-        return userDataBinder.getUserTO(key);\n+    protected AnyTO getAnyTO(final Any<?> any) {\n+        return userDataBinder.getUserTO((User) any, true);\n     }\n \n     @Override\n@@ -113,7 +115,7 @@ protected AnyTO doCreate(final AnyCR anyCR, final SyncDelta delta) {\n                 Set.of(profile.getTask().getResource().getKey()),\n                 true);\n \n-        return getAnyTO(created.getKey());\n+        return userDataBinder.getUserTO(created.getKey());\n     }\n \n     @Override\n@@ -137,11 +139,10 @@ protected AnyUR doUpdate(\n     protected void handleLinkedAccounts(\n             final SyncDelta delta,\n             final List<PullMatch> matches,\n-            final Provision provision,\n-            final AnyUtils anyUtils) throws JobExecutionException {\n+            final Provision provision) throws JobExecutionException {\n \n         for (PullMatch match : matches) {\n-            User user = userDAO.find(match.getLinkingUserKey());\n+            User user = (User) match.getAny();\n             if (user == null) {\n                 LOG.error(\"Could not find linking user, cannot process match {}\", match);\n                 return;\n@@ -201,7 +202,8 @@ protected void handleLinkedAccounts(\n                         // do nothing\n                     }\n                 } else if (SyncDeltaType.DELETE == delta.getDeltaType()) {\n-                    finalize(\n+                    end(\n+                            AnyTypeKind.USER,\n                             ResourceOperation.DELETE.name().toLowerCase(),\n                             AuditElements.Result.SUCCESS,\n                             null,\n@@ -220,15 +222,16 @@ protected Optional<ProvisioningReport> deprovision(\n \n         if (!profile.getTask().isPerformUpdate()) {\n             LOG.debug(\"PullTask not configured for update\");\n-            finalize(MatchingRule.toEventName(MatchingRule.UPDATE), Result.SUCCESS, null, null, delta);\n+            end(AnyTypeKind.USER,\n+                    MatchingRule.toEventName(MatchingRule.UPDATE), Result.SUCCESS, null, null, delta);\n             return Optional.empty();\n         }\n \n         LOG.debug(\"About to deprovision {}\", account);\n \n         ProvisioningReport report = new ProvisioningReport();\n         report.setOperation(ResourceOperation.DELETE);\n-        report.setAnyType(PullMatch.MatchTarget.LINKED_ACCOUNT.name());\n+        report.setAnyType(MatchType.LINKED_ACCOUNT.name());\n         report.setStatus(ProvisioningReport.Status.SUCCESS);\n         report.setKey(account.getKey());\n \n@@ -285,7 +288,7 @@ protected Optional<ProvisioningReport> deprovision(\n                 resultStatus = Result.FAILURE;\n             }\n \n-            finalize(MatchingRule.toEventName(matchingRule), resultStatus, before, output, delta);\n+            end(AnyTypeKind.USER, MatchingRule.toEventName(matchingRule), resultStatus, before, output, delta);\n         }\n \n         return Optional.of(report);\n@@ -301,7 +304,7 @@ protected Optional<ProvisioningReport> provision(\n \n         if (!profile.getTask().isPerformCreate()) {\n             LOG.debug(\"PullTask not configured for create\");\n-            finalize(UnmatchingRule.toEventName(rule), Result.SUCCESS, null, null, delta);\n+            end(AnyTypeKind.USER, UnmatchingRule.toEventName(rule), Result.SUCCESS, null, null, delta);\n             return Optional.empty();\n         }\n \n@@ -310,16 +313,16 @@ protected Optional<ProvisioningReport> provision(\n         ProvisioningReport report = new ProvisioningReport();\n         report.setOperation(ResourceOperation.CREATE);\n         report.setName(accountTO.getConnObjectKeyValue());\n-        report.setAnyType(PullMatch.MatchTarget.LINKED_ACCOUNT.name());\n+        report.setAnyType(MatchType.LINKED_ACCOUNT.name());\n         report.setStatus(ProvisioningReport.Status.SUCCESS);\n \n         if (profile.isDryRun()) {\n             report.setKey(null);\n-            finalize(UnmatchingRule.toEventName(rule), Result.SUCCESS, null, null, delta);\n+            end(AnyTypeKind.USER, UnmatchingRule.toEventName(rule), Result.SUCCESS, null, null, delta);\n         } else {\n             UserTO owner = userDataBinder.getUserTO(user, false);\n             UserCR connObject = connObjectUtils.getAnyCR(\n-                    delta.getObject(), profile.getTask(), provision, getAnyUtils(), false);\n+                    delta.getObject(), profile.getTask(), provision, false);\n \n             if (connObject.getUsername().equals(owner.getUsername())) {\n                 accountTO.setUsername(null);\n@@ -395,7 +398,7 @@ protected Optional<ProvisioningReport> provision(\n                 resultStatus = Result.FAILURE;\n             }\n \n-            finalize(UnmatchingRule.toEventName(rule), resultStatus, null, output, delta);\n+            end(AnyTypeKind.USER, UnmatchingRule.toEventName(rule), resultStatus, null, output, delta);\n         }\n \n         return Optional.of(report);\n@@ -409,7 +412,7 @@ protected Optional<ProvisioningReport> update(\n \n         if (!profile.getTask().isPerformUpdate()) {\n             LOG.debug(\"PullTask not configured for update\");\n-            finalize(MatchingRule.toEventName(MatchingRule.UPDATE), Result.SUCCESS, null, null, delta);\n+            end(AnyTypeKind.USER, MatchingRule.toEventName(MatchingRule.UPDATE), Result.SUCCESS, null, null, delta);\n             return Optional.empty();\n         }\n \n@@ -419,15 +422,15 @@ protected Optional<ProvisioningReport> update(\n         report.setOperation(ResourceOperation.UPDATE);\n         report.setKey(account.getKey());\n         report.setName(account.getConnObjectKeyValue());\n-        report.setAnyType(PullMatch.MatchTarget.LINKED_ACCOUNT.name());\n+        report.setAnyType(MatchType.LINKED_ACCOUNT.name());\n         report.setStatus(ProvisioningReport.Status.SUCCESS);\n \n         if (!profile.isDryRun()) {\n             LinkedAccountTO before = userDataBinder.getLinkedAccountTO(account);\n \n             UserTO owner = userDataBinder.getUserTO(account.getOwner(), false);\n             UserCR connObject = connObjectUtils.getAnyCR(\n-                    delta.getObject(), profile.getTask(), provision, getAnyUtils(), false);\n+                    delta.getObject(), profile.getTask(), provision, false);\n \n             LinkedAccountTO update = userDataBinder.getLinkedAccountTO(account);\n \n@@ -507,7 +510,7 @@ protected Optional<ProvisioningReport> update(\n                 resultStatus = Result.FAILURE;\n             }\n \n-            finalize(MatchingRule.toEventName(MatchingRule.UPDATE), resultStatus, before, output, delta);\n+            end(AnyTypeKind.USER, MatchingRule.toEventName(MatchingRule.UPDATE), resultStatus, before, output, delta);\n         }\n \n         return Optional.of(report);\n@@ -520,7 +523,7 @@ protected Optional<ProvisioningReport> delete(\n \n         if (!profile.getTask().isPerformDelete()) {\n             LOG.debug(\"PullTask not configured for delete\");\n-            finalize(ResourceOperation.DELETE.name().toLowerCase(), Result.SUCCESS, null, null, delta);\n+            end(AnyTypeKind.USER, ResourceOperation.DELETE.name().toLowerCase(), Result.SUCCESS, null, null, delta);\n             return Optional.empty();\n         }\n \n@@ -535,7 +538,7 @@ protected Optional<ProvisioningReport> delete(\n             report.setKey(account.getKey());\n             report.setName(account.getConnObjectKeyValue());\n             report.setOperation(ResourceOperation.DELETE);\n-            report.setAnyType(PullMatch.MatchTarget.LINKED_ACCOUNT.name());\n+            report.setAnyType(MatchType.LINKED_ACCOUNT.name());\n             report.setStatus(ProvisioningReport.Status.SUCCESS);\n \n             if (!profile.isDryRun()) {\n@@ -573,7 +576,8 @@ protected Optional<ProvisioningReport> delete(\n                     output = e;\n                 }\n \n-                finalize(ResourceOperation.DELETE.name().toLowerCase(), resultStatus, before, output, delta);\n+                end(AnyTypeKind.USER,\n+                        ResourceOperation.DELETE.name().toLowerCase(), resultStatus, before, output, delta);\n             }\n         } catch (Exception e) {\n             LOG.error(\"Could not delete linked account {}\", account, e);\n@@ -596,7 +600,7 @@ protected ProvisioningReport ignore(\n             report.setKey(null);\n             report.setName(delta.getObject().getUid().getUidValue());\n             report.setOperation(ResourceOperation.NONE);\n-            report.setAnyType(PullMatch.MatchTarget.LINKED_ACCOUNT.name());\n+            report.setAnyType(MatchType.LINKED_ACCOUNT.name());\n             report.setStatus(ProvisioningReport.Status.SUCCESS);\n             if (message != null && message.length >= 1) {\n                 report.setMessage(message[0]);\n@@ -605,16 +609,18 @@ protected ProvisioningReport ignore(\n             report.setKey(account.getKey());\n             report.setName(delta.getObject().getUid().getUidValue());\n             report.setOperation(ResourceOperation.NONE);\n-            report.setAnyType(PullMatch.MatchTarget.LINKED_ACCOUNT.name());\n+            report.setAnyType(MatchType.LINKED_ACCOUNT.name());\n             report.setStatus(ProvisioningReport.Status.SUCCESS);\n             if (message != null && message.length >= 1) {\n                 report.setMessage(message[0]);\n             }\n         }\n \n-        finalize(matching\n-                ? MatchingRule.toEventName(MatchingRule.IGNORE)\n-                : UnmatchingRule.toEventName(UnmatchingRule.IGNORE), AuditElements.Result.SUCCESS, null, null, delta);\n+        end(AnyTypeKind.USER,\n+                matching\n+                        ? MatchingRule.toEventName(MatchingRule.IGNORE)\n+                        : UnmatchingRule.toEventName(UnmatchingRule.IGNORE),\n+                AuditElements.Result.SUCCESS, null, null, delta);\n \n         return report;\n     }"},{"sha":"d7060c311efdc3d0d5dc369d30dcce165f8f0d59","filename":"core/provisioning-java/src/main/java/org/apache/syncope/core/provisioning/java/pushpull/DefaultUserPushResultHandler.java","status":"modified","additions":243,"deletions":7,"changes":250,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FDefaultUserPushResultHandler.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FDefaultUserPushResultHandler.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FDefaultUserPushResultHandler.java?ref=64495efbbc906599bf3c7de1c0692a7c3139b024","patch":"@@ -22,24 +22,38 @@\n import java.util.List;\n import java.util.Optional;\n import java.util.stream.Collectors;\n+import org.apache.commons.lang3.BooleanUtils;\n+import org.apache.commons.lang3.exception.ExceptionUtils;\n import org.apache.commons.lang3.tuple.Pair;\n import org.apache.syncope.common.lib.request.AnyUR;\n import org.apache.syncope.common.lib.request.UserUR;\n import org.apache.syncope.common.lib.to.AnyTO;\n import org.apache.syncope.common.lib.types.AnyTypeKind;\n+import org.apache.syncope.common.lib.types.MatchType;\n+import org.apache.syncope.common.lib.types.MatchingRule;\n import org.apache.syncope.core.provisioning.api.PropagationByResource;\n import org.apache.syncope.common.lib.types.ResourceOperation;\n+import org.apache.syncope.common.lib.types.UnmatchingRule;\n import org.apache.syncope.core.persistence.api.entity.Any;\n import org.apache.syncope.core.persistence.api.entity.AnyUtils;\n import org.apache.syncope.core.persistence.api.entity.Entity;\n+import org.apache.syncope.core.persistence.api.entity.resource.Provision;\n+import org.apache.syncope.core.persistence.api.entity.user.LinkedAccount;\n import org.apache.syncope.core.persistence.api.entity.user.User;\n+import org.apache.syncope.core.provisioning.api.UserWorkflowResult;\n import org.apache.syncope.core.provisioning.api.WorkflowResult;\n import org.apache.syncope.core.provisioning.api.propagation.PropagationReporter;\n import org.apache.syncope.core.provisioning.api.propagation.PropagationTaskInfo;\n+import org.apache.syncope.core.provisioning.api.pushpull.IgnoreProvisionException;\n import org.apache.syncope.core.provisioning.api.pushpull.ProvisioningReport;\n+import org.apache.syncope.core.provisioning.api.pushpull.PushActions;\n import org.apache.syncope.core.provisioning.api.pushpull.UserPushResultHandler;\n import org.apache.syncope.core.provisioning.java.propagation.DefaultPropagationReporter;\n+import org.apache.syncope.core.provisioning.java.utils.MappingUtils;\n import org.identityconnectors.framework.common.objects.ConnectorObject;\n+import org.quartz.JobExecutionException;\n+import org.springframework.transaction.annotation.Propagation;\n+import org.springframework.transaction.annotation.Transactional;\n \n public class DefaultUserPushResultHandler extends AbstractPushResultHandler implements UserPushResultHandler {\n \n@@ -54,13 +68,13 @@ protected String getName(final Any<?> any) {\n     }\n \n     @Override\n-    protected AnyTO getAnyTO(final String key) {\n-        return userDataBinder.getUserTO(key);\n+    protected AnyTO getAnyTO(final Any<?> any) {\n+        return userDataBinder.getUserTO((User) any, true);\n     }\n \n     @Override\n     protected void provision(final Any<?> any, final Boolean enabled, final ProvisioningReport result) {\n-        AnyTO before = getAnyTO(any.getKey());\n+        AnyTO before = getAnyTO(any);\n \n         List<String> noPropResources = new ArrayList<>(before.getResources());\n         noPropResources.remove(profile.getTask().getResource().getKey());\n@@ -83,7 +97,7 @@ protected void provision(final Any<?> any, final Boolean enabled, final Provisio\n                 before.getVirAttrs(),\n                 noPropResources),\n                 false,\n-                this.adminUser);\n+                adminUser);\n         reportPropagation(result, reporter);\n     }\n \n@@ -122,14 +136,14 @@ protected void update(\n         if (!taskInfos.isEmpty()) {\n             taskInfos.get(0).setBeforeObj(Optional.of(beforeObj));\n             PropagationReporter reporter = new DefaultPropagationReporter();\n-            taskExecutor.execute(taskInfos.get(0), reporter, this.adminUser);\n+            taskExecutor.execute(taskInfos.get(0), reporter, adminUser);\n             reportPropagation(result, reporter);\n         }\n     }\n \n     @Override\n     protected void deprovision(final Any<?> any, final ConnectorObject beforeObj, final ProvisioningReport result) {\n-        AnyTO before = getAnyTO(any.getKey());\n+        AnyTO before = getAnyTO(any);\n \n         List<String> noPropResources = new ArrayList<>(before.getResources());\n         noPropResources.remove(profile.getTask().getResource().getKey());\n@@ -153,7 +167,7 @@ protected void deprovision(final Any<?> any, final ConnectorObject beforeObj, fi\n         if (!taskInfos.isEmpty()) {\n             taskInfos.get(0).setBeforeObj(Optional.of(beforeObj));\n             PropagationReporter reporter = new DefaultPropagationReporter();\n-            taskExecutor.execute(taskInfos.get(0), reporter, this.adminUser);\n+            taskExecutor.execute(taskInfos.get(0), reporter, adminUser);\n             reportPropagation(result, reporter);\n         }\n     }\n@@ -163,4 +177,226 @@ protected WorkflowResult<? extends AnyUR> update(final AnyUR req) {\n         WorkflowResult<Pair<UserUR, Boolean>> update = uwfAdapter.update((UserUR) req);\n         return new WorkflowResult<>(update.getResult().getLeft(), update.getPropByRes(), update.getPerformedTasks());\n     }\n+\n+    @Transactional(propagation = Propagation.REQUIRES_NEW)\n+    @Override\n+    public boolean handle(final LinkedAccount account, final Provision provision) {\n+        try {\n+            doHandle(account, provision);\n+            return true;\n+        } catch (IgnoreProvisionException e) {\n+            ProvisioningReport ignoreResult = profile.getResults().stream().\n+                    filter(report -> account.getKey().equalsIgnoreCase(report.getKey())).\n+                    findFirst().\n+                    orElse(null);\n+            if (ignoreResult == null) {\n+                ignoreResult = new ProvisioningReport();\n+                ignoreResult.setKey(account.getKey());\n+                ignoreResult.setAnyType(MatchType.LINKED_ACCOUNT.name());\n+\n+                profile.getResults().add(ignoreResult);\n+            }\n+\n+            ignoreResult.setOperation(ResourceOperation.NONE);\n+            ignoreResult.setStatus(ProvisioningReport.Status.IGNORE);\n+            ignoreResult.setMessage(e.getMessage());\n+\n+            LOG.warn(\"Ignoring during push\", e);\n+            return true;\n+        } catch (JobExecutionException e) {\n+            LOG.error(\"Push failed\", e);\n+            return false;\n+        }\n+    }\n+\n+    protected void doHandle(final LinkedAccount account, final Provision provision) throws JobExecutionException {\n+        ProvisioningReport result = new ProvisioningReport();\n+        profile.getResults().add(result);\n+\n+        result.setKey(account.getKey());\n+        result.setAnyType(MatchType.LINKED_ACCOUNT.name());\n+        result.setName(account.getConnObjectKeyValue());\n+\n+        LOG.debug(\"Pushing linked account {} towards {}\", account.getKey(), profile.getTask().getResource());\n+\n+        // Try to read remote object BEFORE any actual operation\n+        Optional<ConnectorObject> connObj = MappingUtils.getConnObjectKeyItem(provision).\n+                map(connObjectKeyItem -> outboundMatcher.matchByConnObjectKeyValue(\n+                profile.getConnector(), connObjectKeyItem, account.getConnObjectKeyValue(), provision)).\n+                orElse(Optional.empty());\n+        LOG.debug(\"Match found for linked account {} as {}: {}\", account, provision.getObjectClass(), connObj);\n+\n+        ConnectorObject beforeObj = connObj.isPresent() ? connObj.get() : null;\n+\n+        if (profile.isDryRun()) {\n+            if (beforeObj == null) {\n+                result.setOperation(toResourceOperation(profile.getTask().getUnmatchingRule()));\n+            } else {\n+                result.setOperation(toResourceOperation(profile.getTask().getMatchingRule()));\n+            }\n+            result.setStatus(ProvisioningReport.Status.SUCCESS);\n+        } else {\n+            Boolean enable = profile.getTask().isSyncStatus()\n+                    ? BooleanUtils.negate(account.isSuspended())\n+                    : null;\n+            try {\n+                if (beforeObj == null) {\n+                    result.setOperation(toResourceOperation(profile.getTask().getUnmatchingRule()));\n+\n+                    switch (profile.getTask().getUnmatchingRule()) {\n+                        case ASSIGN:\n+                        case PROVISION:\n+                            for (PushActions action : profile.getActions()) {\n+                                if (profile.getTask().getUnmatchingRule() == UnmatchingRule.ASSIGN) {\n+                                    action.beforeAssign(profile, account);\n+                                } else {\n+                                    action.beforeProvision(profile, account);\n+                                }\n+                            }\n+\n+                            if (!profile.getTask().isPerformCreate()) {\n+                                LOG.debug(\"PushTask not configured for create\");\n+                                result.setStatus(ProvisioningReport.Status.IGNORE);\n+                            } else {\n+                                provision(account, enable, result);\n+                            }\n+                            break;\n+\n+                        case UNLINK:\n+                            LOG.warn(\"{} not applicable to linked accounts, ignoring\",\n+                                    profile.getTask().getUnmatchingRule());\n+                            break;\n+\n+                        case IGNORE:\n+                            result.setStatus(ProvisioningReport.Status.IGNORE);\n+                            break;\n+\n+                        default:\n+                        // do nothing\n+                    }\n+                } else {\n+                    result.setOperation(toResourceOperation(profile.getTask().getMatchingRule()));\n+\n+                    switch (profile.getTask().getMatchingRule()) {\n+                        case UPDATE:\n+                            for (PushActions action : profile.getActions()) {\n+                                action.beforeUpdate(profile, account);\n+                            }\n+                            if (!profile.getTask().isPerformUpdate()) {\n+                                LOG.debug(\"PushTask not configured for update\");\n+                                result.setStatus(ProvisioningReport.Status.IGNORE);\n+                            } else {\n+                                update(account, enable, beforeObj, ResourceOperation.UPDATE, result);\n+                            }\n+                            break;\n+\n+                        case UNASSIGN:\n+                        case DEPROVISION:\n+                            for (PushActions action : profile.getActions()) {\n+                                if (profile.getTask().getMatchingRule() == MatchingRule.UNASSIGN) {\n+                                    action.beforeUnassign(profile, account);\n+                                } else {\n+                                    action.beforeDeprovision(profile, account);\n+                                }\n+                            }\n+\n+                            if (!profile.getTask().isPerformDelete()) {\n+                                LOG.debug(\"PushTask not configured for delete\");\n+                                result.setStatus(ProvisioningReport.Status.IGNORE);\n+                            } else {\n+                                update(account, enable, beforeObj, ResourceOperation.DELETE, result);\n+                            }\n+                            break;\n+\n+                        case LINK:\n+                        case UNLINK:\n+                            LOG.warn(\"{} not applicable to linked accounts, ignoring\",\n+                                    profile.getTask().getMatchingRule());\n+                            break;\n+\n+                        case IGNORE:\n+                            result.setStatus(ProvisioningReport.Status.IGNORE);\n+                            break;\n+\n+                        default:\n+                        // do nothing\n+                    }\n+                }\n+\n+                for (PushActions action : profile.getActions()) {\n+                    action.after(profile, account, result);\n+                }\n+\n+                if (result.getStatus() == null) {\n+                    result.setStatus(ProvisioningReport.Status.SUCCESS);\n+                }\n+            } catch (IgnoreProvisionException e) {\n+                throw e;\n+            } catch (Exception e) {\n+                result.setStatus(ProvisioningReport.Status.FAILURE);\n+                result.setMessage(ExceptionUtils.getRootCauseMessage(e));\n+\n+                LOG.warn(\"Error pushing linked account {} towards {}\", account, profile.getTask().getResource(), e);\n+\n+                for (PushActions action : profile.getActions()) {\n+                    action.onError(profile, account, result, e);\n+                }\n+\n+                throw new JobExecutionException(e);\n+            }\n+        }\n+    }\n+\n+    protected void provision(\n+            final LinkedAccount account,\n+            final Boolean enable,\n+            final ProvisioningReport result) {\n+\n+        PropagationByResource<Pair<String, String>> propByLinkedAccount = new PropagationByResource<>();\n+        propByLinkedAccount.add(\n+                ResourceOperation.CREATE,\n+                Pair.of(account.getResource().getKey(), account.getConnObjectKeyValue()));\n+\n+        List<PropagationTaskInfo> taskInfos = propagationManager.getUserCreateTasks(\n+                account.getOwner().getKey(),\n+                null,\n+                enable,\n+                new PropagationByResource<>(),\n+                propByLinkedAccount,\n+                null,\n+                null);\n+        if (!taskInfos.isEmpty()) {\n+            taskInfos.get(0).setBeforeObj(Optional.ofNullable(null));\n+            PropagationReporter reporter = new DefaultPropagationReporter();\n+            taskExecutor.execute(taskInfos.get(0), reporter, adminUser);\n+            reportPropagation(result, reporter);\n+        }\n+    }\n+\n+    protected void update(\n+            final LinkedAccount account,\n+            final Boolean enable,\n+            final ConnectorObject beforeObj,\n+            final ResourceOperation operation,\n+            final ProvisioningReport result) {\n+\n+        UserUR req = new UserUR();\n+        req.setKey(account.getOwner().getKey());\n+\n+        PropagationByResource<Pair<String, String>> propByLinkedAccount = new PropagationByResource<>();\n+        propByLinkedAccount.add(operation, Pair.of(account.getResource().getKey(), account.getConnObjectKeyValue()));\n+\n+        List<PropagationTaskInfo> taskInfos = propagationManager.getUserUpdateTasks(\n+                new UserWorkflowResult<>(\n+                        Pair.of(req, enable),\n+                        new PropagationByResource<>(),\n+                        propByLinkedAccount,\n+                        \"\"));\n+        if (!taskInfos.isEmpty()) {\n+            taskInfos.get(0).setBeforeObj(Optional.ofNullable(null));\n+            PropagationReporter reporter = new DefaultPropagationReporter();\n+            taskExecutor.execute(taskInfos.get(0), reporter, adminUser);\n+            reportPropagation(result, reporter);\n+        }\n+    }\n }"},{"sha":"33a9764a235b2c3cfb80de3afd5e3b958e5238b5","filename":"core/provisioning-java/src/main/java/org/apache/syncope/core/provisioning/java/pushpull/InboundMatcher.java","status":"renamed","additions":140,"deletions":143,"changes":283,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FInboundMatcher.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FInboundMatcher.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FInboundMatcher.java?ref=64495efbbc906599bf3c7de1c0692a7c3139b024","patch":"@@ -20,43 +20,45 @@\n \n import java.text.ParseException;\n import java.util.ArrayList;\n+import java.util.Collections;\n import java.util.List;\n import java.util.Optional;\n import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n import org.apache.syncope.common.lib.types.AnyTypeKind;\n+import org.apache.syncope.common.lib.types.MatchType;\n import org.apache.syncope.core.persistence.api.attrvalue.validation.ParsingValidationException;\n import org.apache.syncope.core.persistence.api.dao.AnyObjectDAO;\n import org.apache.syncope.core.persistence.api.dao.AnySearchDAO;\n import org.apache.syncope.core.persistence.api.dao.GroupDAO;\n import org.apache.syncope.core.persistence.api.dao.PullCorrelationRule;\n import org.apache.syncope.core.persistence.api.dao.RealmDAO;\n-import org.apache.syncope.core.persistence.api.dao.UserDAO;\n-import org.apache.syncope.core.persistence.api.dao.search.AnyCond;\n-import org.apache.syncope.core.persistence.api.dao.search.AttributeCond;\n-import org.apache.syncope.core.persistence.api.dao.search.SearchCond;\n-import org.apache.syncope.core.persistence.api.entity.Any;\n import org.apache.syncope.core.persistence.api.entity.AnyType;\n-import org.apache.syncope.core.persistence.api.entity.AnyUtils;\n-import org.apache.syncope.core.persistence.api.entity.AnyUtilsFactory;\n-import org.apache.syncope.core.persistence.api.entity.Entity;\n-import org.apache.syncope.core.persistence.api.entity.DerSchema;\n-import org.apache.syncope.core.persistence.api.entity.PlainAttrUniqueValue;\n-import org.apache.syncope.core.persistence.api.entity.PlainAttrValue;\n-import org.apache.syncope.core.persistence.api.entity.PlainSchema;\n import org.apache.syncope.core.persistence.api.entity.Realm;\n-import org.apache.syncope.core.persistence.api.entity.anyobject.AnyObject;\n-import org.apache.syncope.core.persistence.api.entity.group.Group;\n import org.apache.syncope.core.persistence.api.entity.policy.PullCorrelationRuleEntity;\n import org.apache.syncope.core.persistence.api.entity.resource.ExternalResource;\n import org.apache.syncope.core.persistence.api.entity.resource.MappingItem;\n import org.apache.syncope.core.persistence.api.entity.resource.OrgUnit;\n import org.apache.syncope.core.persistence.api.entity.resource.OrgUnitItem;\n import org.apache.syncope.core.persistence.api.entity.resource.Provision;\n-import org.apache.syncope.core.persistence.api.entity.user.User;\n import org.apache.syncope.core.provisioning.api.Connector;\n import org.apache.syncope.core.provisioning.api.IntAttrName;\n import org.apache.syncope.core.provisioning.api.data.ItemTransformer;\n import org.apache.syncope.core.persistence.api.dao.PullMatch;\n+import org.apache.syncope.core.persistence.api.dao.UserDAO;\n+import org.apache.syncope.core.persistence.api.dao.VirSchemaDAO;\n+import org.apache.syncope.core.persistence.api.dao.search.AnyCond;\n+import org.apache.syncope.core.persistence.api.dao.search.AttributeCond;\n+import org.apache.syncope.core.persistence.api.dao.search.SearchCond;\n+import org.apache.syncope.core.persistence.api.entity.Any;\n+import org.apache.syncope.core.persistence.api.entity.AnyUtils;\n+import org.apache.syncope.core.persistence.api.entity.AnyUtilsFactory;\n+import org.apache.syncope.core.persistence.api.entity.DerSchema;\n+import org.apache.syncope.core.persistence.api.entity.PlainAttrUniqueValue;\n+import org.apache.syncope.core.persistence.api.entity.PlainAttrValue;\n+import org.apache.syncope.core.persistence.api.entity.PlainSchema;\n+import org.apache.syncope.core.persistence.api.entity.VirSchema;\n+import org.apache.syncope.core.provisioning.api.VirAttrHandler;\n import org.apache.syncope.core.provisioning.java.IntAttrNameParser;\n import org.apache.syncope.core.provisioning.java.utils.MappingUtils;\n import org.apache.syncope.core.spring.ImplementationManager;\n@@ -70,72 +72,70 @@\n import org.identityconnectors.framework.common.objects.SyncDeltaBuilder;\n import org.identityconnectors.framework.common.objects.SyncDeltaType;\n import org.identityconnectors.framework.common.objects.SyncToken;\n+import org.identityconnectors.framework.common.objects.Uid;\n import org.identityconnectors.framework.spi.SearchResultsHandler;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.stereotype.Component;\n import org.springframework.transaction.annotation.Transactional;\n+import org.springframework.util.CollectionUtils;\n \n @Transactional(readOnly = true)\n @Component\n-public class PullUtils {\n+public class InboundMatcher {\n \n-    private static final Logger LOG = LoggerFactory.getLogger(PullUtils.class);\n+    private static final Logger LOG = LoggerFactory.getLogger(InboundMatcher.class);\n \n-    /**\n-     * Any Object DAO.\n-     */\n     @Autowired\n-    private AnyObjectDAO anyObjectDAO;\n+    private UserDAO userDAO;\n \n-    /**\n-     * User DAO.\n-     */\n     @Autowired\n-    private UserDAO userDAO;\n+    private AnyObjectDAO anyObjectDAO;\n \n-    /**\n-     * Group DAO.\n-     */\n     @Autowired\n     private GroupDAO groupDAO;\n \n-    /**\n-     * Search DAO.\n-     */\n     @Autowired\n     private AnySearchDAO searchDAO;\n \n     @Autowired\n     private RealmDAO realmDAO;\n \n     @Autowired\n-    private AnyUtilsFactory anyUtilsFactory;\n+    private VirSchemaDAO virSchemaDAO;\n+\n+    @Autowired\n+    private VirAttrHandler virAttrHandler;\n \n     @Autowired\n     private IntAttrNameParser intAttrNameParser;\n \n-    public Optional<String> match(\n+    @Autowired\n+    private AnyUtilsFactory anyUtilsFactory;\n+\n+    public Optional<PullMatch> match(\n             final AnyType anyType,\n-            final String name,\n+            final String nameValue,\n             final ExternalResource resource,\n-            final Connector connector,\n-            final boolean ignoreCaseMatch) {\n+            final Connector connector) {\n \n         Optional<? extends Provision> provision = resource.getProvision(anyType);\n-        if (provision.isEmpty()) {\n+        if (!provision.isPresent()) {\n             return Optional.empty();\n         }\n \n-        Optional<String> result = Optional.empty();\n-\n-        AnyUtils anyUtils = anyUtilsFactory.getInstance(anyType.getKind());\n+        Stream<MappingItem> mapItems = Stream.concat(\n+                provision.get().getMapping().getItems().stream(),\n+                virSchemaDAO.findByProvision(provision.get()).stream().map(VirSchema::asLinkingMappingItem));\n \n         List<ConnectorObject> found = new ArrayList<>();\n-        Name nameAttr = new Name(name);\n+\n+        Name nameAttr = new Name(nameValue);\n         connector.search(provision.get().getObjectClass(),\n-                ignoreCaseMatch ? FilterBuilder.equalsIgnoreCase(nameAttr) : FilterBuilder.equalTo(nameAttr),\n+                provision.get().isIgnoreCaseMatch()\n+                ? FilterBuilder.equalsIgnoreCase(nameAttr)\n+                : FilterBuilder.equalTo(nameAttr),\n                 new SearchResultsHandler() {\n \n             @Override\n@@ -147,15 +147,16 @@ public void handleResult(final SearchResult result) {\n             public boolean handle(final ConnectorObject connectorObject) {\n                 return found.add(connectorObject);\n             }\n-        }, MappingUtils.buildOperationOptions(\n-                        MappingUtils.getPullItems(provision.get().getMapping().getItems()).iterator()));\n+        }, MappingUtils.buildOperationOptions(mapItems));\n+\n+        Optional<PullMatch> result = Optional.empty();\n \n         if (found.isEmpty()) {\n-            LOG.debug(\"No {} found on {} with __NAME__ {}\", provision.get().getObjectClass(), resource, name);\n+            LOG.debug(\"No {} found on {} with {} {}\", provision.get().getObjectClass(), resource, Name.NAME, nameValue);\n         } else {\n             if (found.size() > 1) {\n-                LOG.warn(\"More than one {} found on {} with __NAME__ {} - taking first only\",\n-                        provision.get().getObjectClass(), resource, name);\n+                LOG.warn(\"More than one {} found on {} with {} {} - taking first only\",\n+                        provision.get().getObjectClass(), resource, Name.NAME, nameValue);\n             }\n \n             ConnectorObject connObj = found.iterator().next();\n@@ -166,15 +167,18 @@ public boolean handle(final ConnectorObject connectorObject) {\n                                 setDeltaType(SyncDeltaType.CREATE_OR_UPDATE).\n                                 setObject(connObj).\n                                 build(),\n-                        provision.get(), anyUtils);\n+                        provision.get());\n                 if (matches.isEmpty()) {\n-                    LOG.debug(\"No matching {} found for {}, aborting\", anyUtils.anyTypeKind(), connObj);\n+                    LOG.debug(\"No matching {} found for {}, aborting\", anyType.getKind(), connObj);\n                 } else {\n                     if (matches.size() > 1) {\n-                        LOG.warn(\"More than one {} found {} - taking first only\", anyUtils.anyTypeKind(), matches);\n+                        LOG.warn(\"More than one {} found {} - taking first only\", anyType.getKind(), matches);\n                     }\n \n-                    result = Optional.ofNullable(matches.iterator().next().getMatchingKey());\n+                    result = matches.stream().filter(match -> match.getAny() != null).findFirst();\n+                    if (result.isPresent()) {\n+                        virAttrHandler.setValues(result.get().getAny(), connObj);\n+                    }\n                 }\n             } catch (IllegalArgumentException e) {\n                 LOG.warn(e.getMessage());\n@@ -184,99 +188,71 @@ public boolean handle(final ConnectorObject connectorObject) {\n         return result;\n     }\n \n-    private List<PullMatch> findByConnObjectKey(\n-            final SyncDelta syncDelta, final Provision provision, final AnyUtils anyUtils) {\n-\n-        List<PullMatch> noMatchResult = List.of(PullCorrelationRule.NO_MATCH);\n-\n-        String connObjectKey = null;\n+    public List<PullMatch> matchByConnObjectKeyValue(\n+            final MappingItem connObjectKeyItem,\n+            final String connObjectKeyValue,\n+            final Provision provision) {\n \n-        Optional<? extends MappingItem> connObjectKeyItem = MappingUtils.getConnObjectKeyItem(provision);\n-        if (connObjectKeyItem.isPresent()) {\n-            Attribute connObjectKeyAttr = syncDelta.getObject().\n-                    getAttributeByName(connObjectKeyItem.get().getExtAttrName());\n-            if (connObjectKeyAttr != null) {\n-                connObjectKey = AttributeUtil.getStringValue(connObjectKeyAttr);\n-            }\n-        }\n-        if (connObjectKey == null) {\n-            return noMatchResult;\n-        }\n-\n-        for (ItemTransformer transformer : MappingUtils.getItemTransformers(connObjectKeyItem.get())) {\n+        String finalConnObjectKeyValue = connObjectKeyValue;\n+        for (ItemTransformer transformer : MappingUtils.getItemTransformers(connObjectKeyItem)) {\n             List<Object> output = transformer.beforePull(\n-                    connObjectKeyItem.get(),\n+                    connObjectKeyItem,\n                     null,\n-                    List.of(connObjectKey));\n-            if (output != null && !output.isEmpty()) {\n-                connObjectKey = output.get(0).toString();\n+                    Collections.<Object>singletonList(finalConnObjectKeyValue));\n+            if (!CollectionUtils.isEmpty(output)) {\n+                finalConnObjectKeyValue = output.get(0).toString();\n             }\n         }\n \n+        List<PullMatch> noMatchResult = Collections.singletonList(PullCorrelationRule.NO_MATCH);\n+\n         IntAttrName intAttrName;\n         try {\n             intAttrName = intAttrNameParser.parse(\n-                    connObjectKeyItem.get().getIntAttrName(),\n-                    provision.getAnyType().getKind());\n+                    connObjectKeyItem.getIntAttrName(), provision.getAnyType().getKind());\n         } catch (ParseException e) {\n-            LOG.error(\"Invalid intAttrName '{}' specified, ignoring\", connObjectKeyItem.get().getIntAttrName(), e);\n+            LOG.error(\"Invalid intAttrName '{}' specified, ignoring\", connObjectKeyItem.getIntAttrName(), e);\n             return noMatchResult;\n         }\n \n-        List<PullMatch> result = new ArrayList<>();\n+        AnyUtils anyUtils = anyUtilsFactory.getInstance(provision.getAnyType().getKind());\n+\n+        List<Any<?>> anys = new ArrayList<>();\n \n         if (intAttrName.getField() != null) {\n             switch (intAttrName.getField()) {\n                 case \"key\":\n-                    Any<?> any = anyUtils.dao().find(connObjectKey);\n-                    if (any != null) {\n-                        result.add(new PullMatch.Builder().matchingKey(any.getKey()).build());\n-                    }\n+                    Optional.ofNullable(anyUtils.dao().find(connObjectKeyValue)).ifPresent(anys::add);\n                     break;\n \n                 case \"username\":\n                     if (provision.getAnyType().getKind() == AnyTypeKind.USER && provision.isIgnoreCaseMatch()) {\n                         AnyCond cond = new AnyCond(AttributeCond.Type.IEQ);\n                         cond.setSchema(\"username\");\n-                        cond.setExpression(connObjectKey);\n-                        result.addAll(searchDAO.search(SearchCond.getLeafCond(cond), AnyTypeKind.USER).stream().\n-                                map(user -> new PullMatch.Builder().matchingKey(user.getKey()).build()).\n-                                collect(Collectors.toList()));\n+                        cond.setExpression(connObjectKeyValue);\n+                        anys.addAll(searchDAO.search(SearchCond.getLeafCond(cond), AnyTypeKind.USER));\n                     } else {\n-                        User user = userDAO.findByUsername(connObjectKey);\n-                        if (user != null) {\n-                            result.add(new PullMatch.Builder().matchingKey(user.getKey()).build());\n-                        }\n+                        Optional.ofNullable(userDAO.findByUsername(connObjectKeyValue)).ifPresent(anys::add);\n                     }\n                     break;\n \n                 case \"name\":\n                     if (provision.getAnyType().getKind() == AnyTypeKind.GROUP && provision.isIgnoreCaseMatch()) {\n                         AnyCond cond = new AnyCond(AttributeCond.Type.IEQ);\n                         cond.setSchema(\"name\");\n-                        cond.setExpression(connObjectKey);\n-                        result.addAll(searchDAO.search(SearchCond.getLeafCond(cond), AnyTypeKind.GROUP).stream().\n-                                map(group -> new PullMatch.Builder().matchingKey(group.getKey()).build()).\n-                                collect(Collectors.toList()));\n+                        cond.setExpression(connObjectKeyValue);\n+                        anys.addAll(searchDAO.search(SearchCond.getLeafCond(cond), AnyTypeKind.GROUP));\n                     } else {\n-                        Group group = groupDAO.findByName(connObjectKey);\n-                        if (group != null) {\n-                            result.add(new PullMatch.Builder().matchingKey(group.getKey()).build());\n-                        }\n+                        Optional.ofNullable(groupDAO.findByName(connObjectKeyValue)).ifPresent(anys::add);\n                     }\n \n                     if (provision.getAnyType().getKind() == AnyTypeKind.ANY_OBJECT && provision.isIgnoreCaseMatch()) {\n                         AnyCond cond = new AnyCond(AttributeCond.Type.IEQ);\n                         cond.setSchema(\"name\");\n-                        cond.setExpression(connObjectKey);\n-                        result.addAll(searchDAO.search(SearchCond.getLeafCond(cond), AnyTypeKind.ANY_OBJECT).stream().\n-                                map(anyObject -> new PullMatch.Builder().matchingKey(anyObject.getKey()).build()).\n-                                collect(Collectors.toList()));\n+                        cond.setExpression(connObjectKeyValue);\n+                        anys.addAll(searchDAO.search(SearchCond.getLeafCond(cond), AnyTypeKind.ANY_OBJECT));\n                     } else {\n-                        AnyObject anyObject = anyObjectDAO.findByName(connObjectKey);\n-                        if (anyObject != null) {\n-                            result.add(new PullMatch.Builder().matchingKey(anyObject.getKey()).build());\n-                        }\n+                        Optional.ofNullable(anyObjectDAO.findByName(connObjectKeyValue)).ifPresent(anys::add);\n                     }\n                     break;\n \n@@ -289,39 +265,43 @@ private List<PullMatch> findByConnObjectKey(\n                             ? anyUtils.newPlainAttrUniqueValue()\n                             : anyUtils.newPlainAttrValue();\n                     try {\n-                        value.parseValue((PlainSchema) intAttrName.getSchema(), connObjectKey);\n+                        value.parseValue((PlainSchema) intAttrName.getSchema(), connObjectKeyValue);\n                     } catch (ParsingValidationException e) {\n-                        LOG.error(\"While parsing provided __UID__ {}\", value, e);\n-                        value.setStringValue(connObjectKey);\n+                        LOG.error(\"While parsing provided {} {}\", Uid.NAME, value, e);\n+                        value.setStringValue(connObjectKeyValue);\n                     }\n \n                     if (intAttrName.getSchema().isUniqueConstraint()) {\n                         anyUtils.dao().findByPlainAttrUniqueValue((PlainSchema) intAttrName.getSchema(),\n                                 (PlainAttrUniqueValue) value, provision.isIgnoreCaseMatch()).\n-                                ifPresent(any -> result.add(new PullMatch.Builder().matchingKey(any.getKey()).build()));\n+                                ifPresent(anys::add);\n                     } else {\n-                        result.addAll(anyUtils.dao().findByPlainAttrValue((PlainSchema) intAttrName.getSchema(),\n-                                value, provision.isIgnoreCaseMatch()).stream().\n-                                map(any -> new PullMatch.Builder().matchingKey(any.getKey()).build()).\n-                                collect(Collectors.toList()));\n+                        anys.addAll(anyUtils.dao().findByPlainAttrValue((PlainSchema) intAttrName.getSchema(),\n+                                value, provision.isIgnoreCaseMatch()));\n                     }\n                     break;\n \n                 case DERIVED:\n-                    result.addAll(anyUtils.dao().findByDerAttrValue((DerSchema) intAttrName.getSchema(),\n-                            connObjectKey, provision.isIgnoreCaseMatch()).stream().\n-                            map(any -> new PullMatch.Builder().matchingKey(any.getKey()).build()).\n-                            collect(Collectors.toList()));\n+                    anys.addAll(anyUtils.dao().findByDerAttrValue((DerSchema) intAttrName.getSchema(),\n+                            connObjectKeyValue, provision.isIgnoreCaseMatch()));\n                     break;\n \n                 default:\n             }\n         }\n \n+        List<PullMatch> result = anys.stream().\n+                map(any -> new PullMatch(MatchType.ANY, any)).\n+                collect(Collectors.toList());\n+\n+        userDAO.findLinkedAccount(provision.getResource(), finalConnObjectKeyValue).\n+                map(account -> new PullMatch(MatchType.LINKED_ACCOUNT, account)).\n+                ifPresent(result::add);\n+\n         return result.isEmpty() ? noMatchResult : result;\n     }\n \n-    private List<PullMatch> findByCorrelationRule(\n+    private List<PullMatch> matchByCorrelationRule(\n             final SyncDelta syncDelta,\n             final Provision provision,\n             final PullCorrelationRule rule,\n@@ -345,14 +325,9 @@ private List<PullMatch> findByCorrelationRule(\n      *\n      * @param syncDelta change operation, including external attributes\n      * @param provision mapping\n-     * @param anyUtils any utils\n      * @return list of matching users' / groups' / any objects' keys\n      */\n-    public List<PullMatch> match(\n-            final SyncDelta syncDelta,\n-            final Provision provision,\n-            final AnyUtils anyUtils) {\n-\n+    public List<PullMatch> match(final SyncDelta syncDelta, final Provision provision) {\n         Optional<? extends PullCorrelationRuleEntity> correlationRule = provision.getResource().getPullPolicy() == null\n                 ? Optional.empty()\n                 : provision.getResource().getPullPolicy().getCorrelationRule(provision.getAnyType());\n@@ -366,14 +341,40 @@ public List<PullMatch> match(\n             }\n         }\n \n+        List<PullMatch> result = Collections.emptyList();\n         try {\n-            return rule.isPresent()\n-                    ? findByCorrelationRule(syncDelta, provision, rule.get(), anyUtils.anyTypeKind())\n-                    : findByConnObjectKey(syncDelta, provision, anyUtils);\n+            if (rule.isPresent()) {\n+                result = matchByCorrelationRule(syncDelta, provision, rule.get(), provision.getAnyType().getKind());\n+            } else {\n+                String connObjectKeyValue = null;\n+\n+                Optional<? extends MappingItem> connObjectKeyItem = MappingUtils.getConnObjectKeyItem(provision);\n+                if (connObjectKeyItem.isPresent()) {\n+                    Attribute connObjectKeyAttr = syncDelta.getObject().\n+                            getAttributeByName(connObjectKeyItem.get().getExtAttrName());\n+                    if (connObjectKeyAttr != null) {\n+                        connObjectKeyValue = AttributeUtil.getStringValue(connObjectKeyAttr);\n+                    }\n+                    // fallback to __UID__\n+                    if (connObjectKeyValue == null) {\n+                        connObjectKeyValue = syncDelta.getUid().getUidValue();\n+                    }\n+                }\n+                if (connObjectKeyValue == null) {\n+                    result = Collections.singletonList(PullCorrelationRule.NO_MATCH);\n+                } else {\n+                    result = matchByConnObjectKeyValue(connObjectKeyItem.get(), connObjectKeyValue, provision);\n+                }\n+            }\n         } catch (RuntimeException e) {\n             LOG.error(\"Could not match {} with any existing {}\", syncDelta, provision.getAnyType(), e);\n-            return List.of();\n         }\n+\n+        if (result.size() == 1 && result.get(0).getMatchTarget() == MatchType.ANY) {\n+            virAttrHandler.setValues(result.get(0).getAny(), syncDelta.getObject());\n+        }\n+\n+        return result;\n     }\n \n     /**\n@@ -383,10 +384,8 @@ public List<PullMatch> match(\n      * @param orgUnit mapping\n      * @return list of matching realms' keys.\n      */\n-    public List<String> match(\n-            final SyncDelta syncDelta,\n-            final OrgUnit orgUnit) {\n-\n+    @Transactional(readOnly = true)\n+    public List<Realm> match(final SyncDelta syncDelta, final OrgUnit orgUnit) {\n         String connObjectKey = null;\n \n         Optional<? extends OrgUnitItem> connObjectKeyItem = orgUnit.getConnObjectKeyItem();\n@@ -398,46 +397,44 @@ public List<String> match(\n             }\n         }\n         if (connObjectKey == null) {\n-            return List.of();\n+            return Collections.emptyList();\n         }\n \n         for (ItemTransformer transformer : MappingUtils.getItemTransformers(connObjectKeyItem.get())) {\n             List<Object> output = transformer.beforePull(\n                     connObjectKeyItem.get(),\n                     null,\n-                    List.of(connObjectKey));\n-            if (output != null && !output.isEmpty()) {\n+                    Collections.<Object>singletonList(connObjectKey));\n+            if (!CollectionUtils.isEmpty(output)) {\n                 connObjectKey = output.get(0).toString();\n             }\n         }\n \n-        List<String> result = new ArrayList<>();\n+        List<Realm> result = new ArrayList<>();\n \n         Realm realm;\n         switch (connObjectKeyItem.get().getIntAttrName()) {\n             case \"key\":\n                 realm = realmDAO.find(connObjectKey);\n                 if (realm != null) {\n-                    result.add(realm.getKey());\n+                    result.add(realm);\n                 }\n                 break;\n \n             case \"name\":\n                 if (orgUnit.isIgnoreCaseMatch()) {\n                     final String realmName = connObjectKey;\n                     result.addAll(realmDAO.findAll().stream().\n-                            filter(r -> r.getName().equalsIgnoreCase(realmName)).\n-                            map(Entity::getKey).collect(Collectors.toList()));\n+                            filter(r -> r.getName().equalsIgnoreCase(realmName)).collect(Collectors.toList()));\n                 } else {\n-                    result.addAll(realmDAO.findByName(connObjectKey).stream().\n-                            map(Entity::getKey).collect(Collectors.toList()));\n+                    result.addAll(realmDAO.findByName(connObjectKey).stream().collect(Collectors.toList()));\n                 }\n                 break;\n \n             case \"fullpath\":\n                 realm = realmDAO.findByFullPath(connObjectKey);\n                 if (realm != null) {\n-                    result.add(realm.getKey());\n+                    result.add(realm);\n                 }\n                 break;\n ","previous_filename":"core/provisioning-java/src/main/java/org/apache/syncope/core/provisioning/java/pushpull/PullUtils.java"},{"sha":"7b09175c035e99767b8a3ef10efc8083e74ee812","filename":"core/provisioning-java/src/main/java/org/apache/syncope/core/provisioning/java/pushpull/LDAPMembershipPullActions.java","status":"modified","additions":16,"deletions":17,"changes":33,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FLDAPMembershipPullActions.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FLDAPMembershipPullActions.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FLDAPMembershipPullActions.java?ref=64495efbbc906599bf3c7de1c0692a7c3139b024","patch":"@@ -27,12 +27,12 @@\n import org.apache.syncope.common.lib.request.AnyUR;\n import org.apache.syncope.common.lib.to.EntityTO;\n import org.apache.syncope.common.lib.to.GroupTO;\n-import org.apache.syncope.common.lib.types.ConnConfProperty;\n import org.apache.syncope.core.persistence.api.dao.GroupDAO;\n import org.apache.syncope.core.provisioning.api.Connector;\n import org.apache.syncope.core.provisioning.api.pushpull.ProvisioningProfile;\n import org.apache.syncope.core.provisioning.api.pushpull.ProvisioningReport;\n import org.apache.syncope.core.persistence.api.dao.AnyTypeDAO;\n+import org.apache.syncope.core.persistence.api.dao.PullMatch;\n import org.apache.syncope.core.persistence.api.entity.resource.Provision;\n import org.identityconnectors.framework.common.objects.Attribute;\n import org.identityconnectors.framework.common.objects.ConnectorObject;\n@@ -63,7 +63,7 @@ public class LDAPMembershipPullActions extends SchedulingPullActions {\n     protected GroupDAO groupDAO;\n \n     @Autowired\n-    private PullUtils pullUtils;\n+    private InboundMatcher inboundMatcher;\n \n     protected final Map<String, Set<String>> membershipsBefore = new HashMap<>();\n \n@@ -76,14 +76,11 @@ public class LDAPMembershipPullActions extends SchedulingPullActions {\n      * @return the name of the attribute used to keep track of group memberships\n      */\n     protected String getGroupMembershipAttrName(final Connector connector) {\n-        Optional<ConnConfProperty> groupMembership = connector.getConnInstance().getConf().stream().\n+        return connector.getConnInstance().getConf().stream().\n                 filter(property -> \"groupMemberAttribute\".equals(property.getSchema().getName())\n-                && !property.getValues().isEmpty()).\n-                findFirst();\n-\n-        return groupMembership.isPresent()\n-                ? (String) groupMembership.get().getValues().get(0)\n-                : \"uniquemember\";\n+                && !property.getValues().isEmpty()).findFirst().\n+                map(groupMembership -> (String) groupMembership.getValues().get(0)).\n+                orElse(\"uniquemember\");\n     }\n \n     /**\n@@ -102,8 +99,11 @@ protected List<Object> getMembAttrValues(final SyncDelta delta, final Connector\n         Attribute membAttr = delta.getObject().getAttributeByName(groupMemberName);\n         // if not found, perform an additional read on the underlying connector for the same connector object\n         if (membAttr == null) {\n-            OperationOptionsBuilder oob = new OperationOptionsBuilder().setAttributesToGet(groupMemberName);\n-            ConnectorObject remoteObj = connector.getObject(ObjectClass.GROUP, delta.getUid(), false, oob.build());\n+            ConnectorObject remoteObj = connector.getObject(\n+                    ObjectClass.GROUP,\n+                    delta.getUid(),\n+                    false,\n+                    new OperationOptionsBuilder().setAttributesToGet(groupMemberName).build());\n             if (remoteObj == null) {\n                 LOG.debug(\"Object for '{}' not found\", delta.getUid().getUidValue());\n             } else {\n@@ -170,17 +170,16 @@ public void after(\n         }\n \n         getMembAttrValues(delta, profile.getConnector()).forEach(membValue -> {\n-            Optional<String> userKey = pullUtils.match(\n+            Optional<PullMatch> match = inboundMatcher.match(\n                     anyTypeDAO.findUser(),\n                     membValue.toString(),\n                     profile.getTask().getResource(),\n-                    profile.getConnector(),\n-                    false);\n-            if (userKey.isPresent()) {\n-                Set<String> memb = membershipsAfter.get(userKey.get());\n+                    profile.getConnector());\n+            if (match.isPresent()) {\n+                Set<String> memb = membershipsAfter.get(match.get().getAny().getKey());\n                 if (memb == null) {\n                     memb = new HashSet<>();\n-                    membershipsAfter.put(userKey.get(), memb);\n+                    membershipsAfter.put(match.get().getAny().getKey(), memb);\n                 }\n                 memb.add(entity.getKey());\n             } else {"},{"sha":"e206ca8abd58d03f23d24ce0ef230a1dcdbbdd6d","filename":"core/provisioning-java/src/main/java/org/apache/syncope/core/provisioning/java/pushpull/OutboundMatcher.java","status":"added","additions":229,"deletions":0,"changes":229,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FOutboundMatcher.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FOutboundMatcher.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FOutboundMatcher.java?ref=64495efbbc906599bf3c7de1c0692a7c3139b024","patch":"@@ -0,0 +1,229 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.core.provisioning.java.pushpull;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.syncope.common.lib.types.AnyTypeKind;\n+import org.apache.syncope.core.persistence.api.dao.PushCorrelationRule;\n+import org.apache.syncope.core.persistence.api.dao.UserDAO;\n+import org.apache.syncope.core.persistence.api.dao.VirSchemaDAO;\n+import org.apache.syncope.core.persistence.api.entity.Any;\n+import org.apache.syncope.core.persistence.api.entity.AnyUtilsFactory;\n+import org.apache.syncope.core.persistence.api.entity.LinkingMappingItem;\n+import org.apache.syncope.core.persistence.api.entity.VirSchema;\n+import org.apache.syncope.core.persistence.api.entity.policy.PushCorrelationRuleEntity;\n+import org.apache.syncope.core.persistence.api.entity.resource.MappingItem;\n+import org.apache.syncope.core.persistence.api.entity.resource.Provision;\n+import org.apache.syncope.core.persistence.api.entity.task.PropagationTask;\n+import org.apache.syncope.core.provisioning.api.Connector;\n+import org.apache.syncope.core.provisioning.api.MappingManager;\n+import org.apache.syncope.core.provisioning.api.TimeoutException;\n+import org.apache.syncope.core.provisioning.api.VirAttrHandler;\n+import org.apache.syncope.core.provisioning.java.utils.MappingUtils;\n+import org.apache.syncope.core.spring.ImplementationManager;\n+import org.identityconnectors.framework.common.objects.AttributeBuilder;\n+import org.identityconnectors.framework.common.objects.ConnectorObject;\n+import org.identityconnectors.framework.common.objects.SearchResult;\n+import org.identityconnectors.framework.common.objects.filter.Filter;\n+import org.identityconnectors.framework.spi.SearchResultsHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Component;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+@Component\n+public class OutboundMatcher {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(OutboundMatcher.class);\n+\n+    @Autowired\n+    private MappingManager mappingManager;\n+\n+    @Autowired\n+    private UserDAO userDAO;\n+\n+    @Autowired\n+    private AnyUtilsFactory anyUtilsFactory;\n+\n+    @Autowired\n+    private VirSchemaDAO virSchemaDAO;\n+\n+    @Autowired\n+    private VirAttrHandler virAttrHandler;\n+\n+    private Optional<PushCorrelationRule> rule(final Provision provision) {\n+        Optional<? extends PushCorrelationRuleEntity> correlationRule = provision.getResource().getPushPolicy() == null\n+                ? Optional.empty()\n+                : provision.getResource().getPushPolicy().getCorrelationRule(provision.getAnyType());\n+\n+        Optional<PushCorrelationRule> rule = Optional.empty();\n+        if (correlationRule.isPresent()) {\n+            try {\n+                rule = ImplementationManager.buildPushCorrelationRule(correlationRule.get().getImplementation());\n+            } catch (Exception e) {\n+                LOG.error(\"While building {}\", correlationRule.get().getImplementation(), e);\n+            }\n+        }\n+\n+        return rule;\n+    }\n+\n+    public List<ConnectorObject> match(\n+            final PropagationTask task,\n+            final Connector connector,\n+            final Provision provision,\n+            final String connObjectKeyValue) {\n+\n+        Optional<PushCorrelationRule> rule = rule(provision);\n+\n+        boolean isLinkedAccount = task.getAnyTypeKind() == AnyTypeKind.USER\n+                && userDAO.linkedAccountExists(task.getEntityKey(), connObjectKeyValue);\n+        Any<?> any = null;\n+        if (!isLinkedAccount) {\n+            any = anyUtilsFactory.getInstance(task.getAnyTypeKind()).dao().find(task.getEntityKey());\n+        }\n+\n+        List<ConnectorObject> result = new ArrayList<>();\n+        try {\n+            if (any != null && rule.isPresent()) {\n+                result.addAll(matchByCorrelationRule(connector, rule.get().getFilter(any, provision), provision));\n+            } else {\n+                MappingUtils.getConnObjectKeyItem(provision).ifPresent(connObjectKeyItem\n+                        -> matchByConnObjectKeyValue(connector, connObjectKeyItem, connObjectKeyValue, provision).\n+                                ifPresent(result::add));\n+            }\n+        } catch (RuntimeException e) {\n+            LOG.error(\"Could not match {} with any existing {}\", any, provision.getObjectClass(), e);\n+        }\n+\n+        if (any != null && result.size() == 1) {\n+            virAttrHandler.setValues(any, result.get(0));\n+        }\n+\n+        return result;\n+    }\n+\n+    @Transactional(readOnly = true)\n+    public List<ConnectorObject> match(\n+            final Connector connector,\n+            final Any<?> any,\n+            final Provision provision,\n+            final LinkingMappingItem... linkingItems) {\n+\n+        Optional<PushCorrelationRule> rule = rule(provision);\n+\n+        List<ConnectorObject> result = new ArrayList<>();\n+        try {\n+            if (rule.isPresent()) {\n+                result.addAll(matchByCorrelationRule(\n+                        connector, rule.get().getFilter(any, provision), provision, linkingItems));\n+            } else {\n+                Optional<? extends MappingItem> connObjectKeyItem = MappingUtils.getConnObjectKeyItem(provision);\n+                Optional<String> connObjectKeyValue = mappingManager.getConnObjectKeyValue(any, provision);\n+\n+                if (connObjectKeyItem.isPresent() && connObjectKeyValue.isPresent()) {\n+                    matchByConnObjectKeyValue(\n+                            connector, connObjectKeyItem.get(), connObjectKeyValue.get(), provision, linkingItems).\n+                            ifPresent(result::add);\n+                }\n+            }\n+        } catch (RuntimeException e) {\n+            LOG.error(\"Could not match {} with any existing {}\", any, provision.getObjectClass(), e);\n+        }\n+\n+        if (result.size() == 1) {\n+            virAttrHandler.setValues(any, result.get(0));\n+        }\n+\n+        return result;\n+    }\n+\n+    private List<ConnectorObject> matchByCorrelationRule(\n+            final Connector connector,\n+            final Filter filter,\n+            final Provision provision,\n+            final LinkingMappingItem... linkingItems) {\n+\n+        Stream<MappingItem> items = Stream.concat(\n+                provision.getMapping().getItems().stream(),\n+                ArrayUtils.isEmpty(linkingItems)\n+                ? virSchemaDAO.findByProvision(provision).stream().map(VirSchema::asLinkingMappingItem)\n+                : Stream.of(linkingItems));\n+\n+        List<ConnectorObject> objs = new ArrayList<>();\n+        try {\n+            connector.search(provision.getObjectClass(), filter, new SearchResultsHandler() {\n+\n+                @Override\n+                public void handleResult(final SearchResult result) {\n+                    // nothing to do\n+                }\n+\n+                @Override\n+                public boolean handle(final ConnectorObject connectorObject) {\n+                    objs.add(connectorObject);\n+                    return true;\n+                }\n+            }, MappingUtils.buildOperationOptions(items));\n+        } catch (TimeoutException toe) {\n+            LOG.debug(\"Request timeout\", toe);\n+            throw toe;\n+        } catch (RuntimeException ignore) {\n+            LOG.debug(\"Unexpected exception\", ignore);\n+        }\n+\n+        return objs;\n+    }\n+\n+    @Transactional(readOnly = true)\n+    public Optional<ConnectorObject> matchByConnObjectKeyValue(\n+            final Connector connector,\n+            final MappingItem connObjectKeyItem,\n+            final String connObjectKeyValue,\n+            final Provision provision,\n+            final LinkingMappingItem... linkingItems) {\n+\n+        Stream<MappingItem> items = Stream.concat(\n+                provision.getMapping().getItems().stream(),\n+                ArrayUtils.isEmpty(linkingItems)\n+                ? virSchemaDAO.findByProvision(provision).stream().map(VirSchema::asLinkingMappingItem)\n+                : Stream.of(linkingItems));\n+\n+        ConnectorObject obj = null;\n+        try {\n+            obj = connector.getObject(\n+                    provision.getObjectClass(),\n+                    AttributeBuilder.build(connObjectKeyItem.getExtAttrName(), connObjectKeyValue),\n+                    provision.isIgnoreCaseMatch(),\n+                    MappingUtils.buildOperationOptions(items));\n+        } catch (TimeoutException toe) {\n+            LOG.debug(\"Request timeout\", toe);\n+            throw toe;\n+        } catch (RuntimeException ignore) {\n+            LOG.debug(\"While resolving {}\", connObjectKeyValue, ignore);\n+        }\n+\n+        return Optional.ofNullable(obj);\n+    }\n+}"},{"sha":"3f87d55572220890f0f5cd8b1dd7feac6062d81b","filename":"core/provisioning-java/src/main/java/org/apache/syncope/core/provisioning/java/pushpull/PullJobDelegate.java","status":"modified","additions":46,"deletions":67,"changes":113,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FPullJobDelegate.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FPullJobDelegate.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FPullJobDelegate.java?ref=64495efbbc906599bf3c7de1c0692a7c3139b024","patch":"@@ -20,72 +20,66 @@\n \n import java.util.ArrayList;\n import java.util.HashMap;\n-import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n import java.util.Optional;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n import org.apache.commons.lang3.StringUtils;\n-import org.apache.commons.lang3.tuple.MutablePair;\n-import org.apache.syncope.common.lib.collections.IteratorChain;\n-import org.apache.syncope.common.lib.types.AnyTypeKind;\n import org.apache.syncope.common.lib.types.ConflictResolutionAction;\n+import org.apache.commons.lang3.tuple.MutablePair;\n import org.apache.syncope.common.lib.types.ResourceOperation;\n+import org.apache.syncope.core.spring.ApplicationContextProvider;\n import org.apache.syncope.core.persistence.api.dao.GroupDAO;\n import org.apache.syncope.core.persistence.api.dao.NotFoundException;\n-import org.apache.syncope.core.persistence.api.dao.UserDAO;\n+import org.apache.syncope.core.persistence.api.dao.PullMatch;\n import org.apache.syncope.core.persistence.api.dao.VirSchemaDAO;\n import org.apache.syncope.core.persistence.api.entity.AnyUtils;\n import org.apache.syncope.core.persistence.api.entity.AnyUtilsFactory;\n import org.apache.syncope.core.persistence.api.entity.VirSchema;\n import org.apache.syncope.core.persistence.api.entity.group.Group;\n-import org.apache.syncope.core.persistence.api.entity.resource.MappingItem;\n+import org.apache.syncope.core.persistence.api.entity.resource.Item;\n import org.apache.syncope.core.persistence.api.entity.resource.OrgUnit;\n import org.apache.syncope.core.persistence.api.entity.resource.Provision;\n-import org.apache.syncope.core.persistence.api.entity.task.PullTask;\n import org.apache.syncope.core.provisioning.api.Connector;\n-import org.apache.syncope.core.provisioning.api.pushpull.AnyObjectPullResultHandler;\n-import org.apache.syncope.core.provisioning.api.pushpull.GroupPullResultHandler;\n import org.apache.syncope.core.provisioning.api.pushpull.ProvisioningProfile;\n+import org.quartz.JobExecutionException;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.support.AbstractBeanDefinition;\n+import org.apache.syncope.core.persistence.api.entity.task.PullTask;\n+import org.apache.syncope.core.persistence.api.entity.user.User;\n+import org.apache.syncope.core.provisioning.api.pushpull.AnyObjectPullResultHandler;\n import org.apache.syncope.core.provisioning.api.pushpull.PullActions;\n+import org.apache.syncope.core.provisioning.api.pushpull.GroupPullResultHandler;\n import org.apache.syncope.core.provisioning.api.pushpull.RealmPullResultHandler;\n-import org.apache.syncope.core.provisioning.api.pushpull.ReconFilterBuilder;\n import org.apache.syncope.core.provisioning.api.pushpull.SyncopePullExecutor;\n import org.apache.syncope.core.provisioning.api.pushpull.SyncopePullResultHandler;\n import org.apache.syncope.core.provisioning.api.pushpull.UserPullResultHandler;\n import org.apache.syncope.core.provisioning.java.utils.MappingUtils;\n-import org.apache.syncope.core.spring.ApplicationContextProvider;\n-import org.apache.syncope.core.spring.ImplementationManager;\n import org.identityconnectors.framework.common.objects.Name;\n import org.identityconnectors.framework.common.objects.ObjectClass;\n import org.identityconnectors.framework.common.objects.OperationOptions;\n import org.identityconnectors.framework.common.objects.SyncToken;\n-import org.quartz.JobExecutionException;\n-import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.beans.factory.support.AbstractBeanDefinition;\n+import org.apache.syncope.core.provisioning.api.pushpull.ReconFilterBuilder;\n+import org.apache.syncope.core.spring.ImplementationManager;\n \n public class PullJobDelegate extends AbstractProvisioningJobDelegate<PullTask> implements SyncopePullExecutor {\n \n-    protected final Map<ObjectClass, SyncToken> latestSyncTokens = new HashMap<>();\n-\n-    protected final Map<ObjectClass, MutablePair<Integer, String>> handled = new HashMap<>();\n-\n-    @Autowired\n-    protected UserDAO userDAO;\n-\n     @Autowired\n     protected GroupDAO groupDAO;\n \n     @Autowired\n     protected VirSchemaDAO virSchemaDAO;\n \n     @Autowired\n-    protected PullUtils pullUtils;\n+    protected InboundMatcher inboundMatcher;\n \n     @Autowired\n     protected AnyUtilsFactory anyUtilsFactory;\n \n+    protected final Map<ObjectClass, SyncToken> latestSyncTokens = new HashMap<>();\n+\n+    protected final Map<ObjectClass, MutablePair<Integer, String>> handled = new HashMap<>();\n+\n     protected ProvisioningProfile<PullTask, PullActions> profile;\n \n     @Override\n@@ -129,40 +123,35 @@ public String currentStatus() {\n         return status.get();\n     }\n \n-    protected void setGroupOwners(\n-            final GroupPullResultHandler ghandler,\n-            final boolean userIgnoreCaseMatch,\n-            final boolean groupIgnoreCaseMatch) {\n-\n-        ghandler.getGroupOwnerMap().entrySet().stream().map(entry -> {\n-            Group group = groupDAO.find(entry.getKey());\n+    protected void setGroupOwners(final GroupPullResultHandler ghandler) {\n+        ghandler.getGroupOwnerMap().forEach((groupKey, ownerKey) -> {\n+            Group group = groupDAO.find(groupKey);\n             if (group == null) {\n-                throw new NotFoundException(\"Group \" + entry.getKey());\n+                throw new NotFoundException(\"Group \" + groupKey);\n             }\n-            if (StringUtils.isBlank(entry.getValue())) {\n+            if (StringUtils.isBlank(ownerKey)) {\n                 group.setGroupOwner(null);\n                 group.setUserOwner(null);\n             } else {\n-                Optional<String> userKey = pullUtils.match(\n+                Optional<PullMatch> match = inboundMatcher.match(\n                         anyTypeDAO.findUser(),\n-                        entry.getValue(),\n+                        ownerKey,\n                         ghandler.getProfile().getTask().getResource(),\n-                        ghandler.getProfile().getConnector(),\n-                        userIgnoreCaseMatch);\n-                if (userKey.isPresent()) {\n-                    group.setUserOwner(userDAO.find(userKey.get()));\n+                        ghandler.getProfile().getConnector());\n+                if (match.isPresent()) {\n+                    group.setUserOwner((User) match.get().getAny());\n                 } else {\n-                    pullUtils.match(\n+                    inboundMatcher.match(\n                             anyTypeDAO.findGroup(),\n-                            entry.getValue(),\n+                            ownerKey,\n                             ghandler.getProfile().getTask().getResource(),\n-                            ghandler.getProfile().getConnector(),\n-                            groupIgnoreCaseMatch).\n-                            ifPresent(groupKey -> group.setGroupOwner(groupDAO.find(groupKey)));\n+                            ghandler.getProfile().getConnector()).\n+                            ifPresent(groupMatch -> group.setGroupOwner((Group) groupMatch.getAny()));\n                 }\n             }\n-            return group;\n-        }).forEachOrdered(group -> groupDAO.save(group));\n+\n+            groupDAO.save(group);\n+        });\n     }\n \n     protected static RealmPullResultHandler buildRealmHandler() {\n@@ -229,7 +218,7 @@ protected String doExecuteProvisioning(\n \n             OrgUnit orgUnit = pullTask.getResource().getOrgUnit();\n             OperationOptions options = MappingUtils.buildOperationOptions(\n-                    MappingUtils.getPullItems(orgUnit.getItems()).iterator());\n+                    MappingUtils.getPullItems(orgUnit.getItems().stream()));\n \n             RealmPullResultHandler handler = buildRealmHandler();\n             handler.setProfile(profile);\n@@ -278,16 +267,8 @@ protected String doExecuteProvisioning(\n         // ...then provisions for any types\n         SyncopePullResultHandler handler;\n         GroupPullResultHandler ghandler = buildGroupHandler();\n-        boolean userIgnoreCaseMatch = false;\n-        boolean groupIgnoreCaseMatch = false;\n         for (Provision provision : pullTask.getResource().getProvisions()) {\n             if (provision.getMapping() != null) {\n-                if (provision.getAnyType().getKind() == AnyTypeKind.USER) {\n-                    userIgnoreCaseMatch = provision.isIgnoreCaseMatch();\n-                } else if (provision.getAnyType().getKind() == AnyTypeKind.GROUP) {\n-                    groupIgnoreCaseMatch = provision.isIgnoreCaseMatch();\n-                }\n-\n                 status.set(\"Pulling \" + provision.getObjectClass().getObjectClassValue());\n \n                 switch (provision.getAnyType().getKind()) {\n@@ -307,11 +288,9 @@ protected String doExecuteProvisioning(\n                 handler.setPullExecutor(this);\n \n                 try {\n-                    Set<MappingItem> linkingMappingItems = virSchemaDAO.findByProvision(provision).stream().\n-                            map(VirSchema::asLinkingMappingItem).collect(Collectors.toSet());\n-                    Iterator<MappingItem> mapItems = new IteratorChain<>(\n-                            provision.getMapping().getItems().iterator(),\n-                            linkingMappingItems.iterator());\n+                    Stream<? extends Item> mapItems = Stream.concat(\n+                            MappingUtils.getPullItems(provision.getMapping().getItems().stream()),\n+                            virSchemaDAO.findByProvision(provision).stream().map(VirSchema::asLinkingMappingItem));\n                     OperationOptions options = MappingUtils.buildOperationOptions(mapItems);\n \n                     switch (pullTask.getPullMode()) {\n@@ -333,17 +312,17 @@ protected String doExecuteProvisioning(\n                             break;\n \n                         case FILTERED_RECONCILIATION:\n-                            ReconFilterBuilder filterBuilder =\n-                                    ImplementationManager.build(pullTask.getReconFilterBuilder());\n-                            connector.filteredReconciliation(provision.getObjectClass(),\n-                                    filterBuilder,\n+                            connector.filteredReconciliation(\n+                                    provision.getObjectClass(),\n+                                    ImplementationManager.build(pullTask.getReconFilterBuilder()),\n                                     handler,\n                                     options);\n                             break;\n \n                         case FULL_RECONCILIATION:\n                         default:\n-                            connector.fullReconciliation(provision.getObjectClass(),\n+                            connector.fullReconciliation(\n+                                    provision.getObjectClass(),\n                                     handler,\n                                     options);\n                             break;\n@@ -365,7 +344,7 @@ protected String doExecuteProvisioning(\n             }\n         }\n         try {\n-            setGroupOwners(ghandler, userIgnoreCaseMatch, groupIgnoreCaseMatch);\n+            setGroupOwners(ghandler);\n         } catch (Exception e) {\n             LOG.error(\"While setting group owners\", e);\n         }"},{"sha":"6db67f1d62d4d7757ed72c568c9147abaa827cf4","filename":"core/provisioning-java/src/main/java/org/apache/syncope/core/provisioning/java/pushpull/PushUtils.java","status":"removed","additions":0,"deletions":139,"changes":139,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/4b20e81b05948da257eded5601b5538cf92f919d/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FPushUtils.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/4b20e81b05948da257eded5601b5538cf92f919d/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FPushUtils.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FPushUtils.java?ref=4b20e81b05948da257eded5601b5538cf92f919d","patch":"@@ -1,139 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-package org.apache.syncope.core.provisioning.java.pushpull;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Optional;\n-import org.apache.syncope.core.persistence.api.dao.PushCorrelationRule;\n-import org.apache.syncope.core.persistence.api.entity.Any;\n-import org.apache.syncope.core.persistence.api.entity.policy.PushCorrelationRuleEntity;\n-import org.apache.syncope.core.persistence.api.entity.resource.MappingItem;\n-import org.apache.syncope.core.persistence.api.entity.resource.Provision;\n-import org.apache.syncope.core.provisioning.api.Connector;\n-import org.apache.syncope.core.provisioning.api.MappingManager;\n-import org.apache.syncope.core.provisioning.api.TimeoutException;\n-import org.apache.syncope.core.provisioning.java.utils.MappingUtils;\n-import org.apache.syncope.core.spring.ImplementationManager;\n-import org.identityconnectors.framework.common.objects.AttributeBuilder;\n-import org.identityconnectors.framework.common.objects.ConnectorObject;\n-import org.identityconnectors.framework.common.objects.SearchResult;\n-import org.identityconnectors.framework.spi.SearchResultsHandler;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.stereotype.Component;\n-import org.springframework.transaction.annotation.Transactional;\n-\n-@Transactional(readOnly = true)\n-@Component\n-public class PushUtils {\n-\n-    private static final Logger LOG = LoggerFactory.getLogger(PushUtils.class);\n-\n-    @Autowired\n-    private MappingManager mappingManager;\n-\n-    public List<ConnectorObject> match(\n-            final Connector connector,\n-            final Any<?> any,\n-            final Provision provision) {\n-\n-        Optional<? extends PushCorrelationRuleEntity> correlationRule = provision.getResource().getPushPolicy() == null\n-                ? Optional.empty()\n-                : provision.getResource().getPushPolicy().getCorrelationRule(provision.getAnyType());\n-\n-        Optional<PushCorrelationRule> rule = Optional.empty();\n-        if (correlationRule.isPresent()) {\n-            try {\n-                rule = ImplementationManager.buildPushCorrelationRule(correlationRule.get().getImplementation());\n-            } catch (Exception e) {\n-                LOG.error(\"While building {}\", correlationRule.get().getImplementation(), e);\n-            }\n-        }\n-\n-        try {\n-            return rule\n-                .map(pushCorrelationRule -> findByCorrelationRule(connector, any, provision, pushCorrelationRule))\n-                .orElseGet(() -> findByConnObjectKey(connector, any, provision));\n-        } catch (RuntimeException e) {\n-            LOG.error(\"Could not match {} with any existing {}\", any, provision.getObjectClass(), e);\n-            return List.of();\n-        }\n-    }\n-\n-    private static List<ConnectorObject> findByCorrelationRule(\n-        final Connector connector,\n-        final Any<?> any,\n-        final Provision provision,\n-        final PushCorrelationRule rule) {\n-\n-        List<ConnectorObject> objs = new ArrayList<>();\n-\n-        try {\n-            connector.search(provision.getObjectClass(), rule.getFilter(any, provision), new SearchResultsHandler() {\n-\n-                @Override\n-                public void handleResult(final SearchResult result) {\n-                    // nothing to do\n-                }\n-\n-                @Override\n-                public boolean handle(final ConnectorObject connectorObject) {\n-                    objs.add(connectorObject);\n-                    return true;\n-                }\n-            }, MappingUtils.buildOperationOptions(provision.getMapping().getItems().iterator()));\n-        } catch (TimeoutException toe) {\n-            LOG.debug(\"Request timeout\", toe);\n-            throw toe;\n-        } catch (RuntimeException ignore) {\n-            LOG.debug(\"Unexpected exception\", ignore);\n-        }\n-\n-        return objs;\n-    }\n-\n-    public List<ConnectorObject> findByConnObjectKey(\n-            final Connector connector,\n-            final Any<?> any,\n-            final Provision provision) {\n-\n-        Optional<? extends MappingItem> connObjectKey = MappingUtils.getConnObjectKeyItem(provision);\n-        Optional<String> connObjectKeyValue = mappingManager.getConnObjectKeyValue(any, provision);\n-\n-        ConnectorObject obj = null;\n-        if (connObjectKey.isPresent() && connObjectKeyValue.isPresent()) {\n-            try {\n-                obj = connector.getObject(\n-                        provision.getObjectClass(),\n-                        AttributeBuilder.build(connObjectKey.get().getExtAttrName(), connObjectKeyValue.get()),\n-                        provision.isIgnoreCaseMatch(),\n-                        MappingUtils.buildOperationOptions(provision.getMapping().getItems().iterator()));\n-            } catch (TimeoutException toe) {\n-                LOG.debug(\"Request timeout\", toe);\n-                throw toe;\n-            } catch (RuntimeException ignore) {\n-                LOG.debug(\"While resolving {}\", connObjectKeyValue.get(), ignore);\n-            }\n-        }\n-\n-        return obj == null ? List.of() : List.of(obj);\n-    }\n-}"},{"sha":"154fe5f43829b912e6d3b2305874a987b815d078","filename":"core/provisioning-java/src/main/java/org/apache/syncope/core/provisioning/java/pushpull/SinglePullJobDelegate.java","status":"modified","additions":11,"deletions":25,"changes":36,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FSinglePullJobDelegate.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FSinglePullJobDelegate.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FSinglePullJobDelegate.java?ref=64495efbbc906599bf3c7de1c0692a7c3139b024","patch":"@@ -19,12 +19,8 @@\n package org.apache.syncope.core.provisioning.java.pushpull;\n \n import java.util.ArrayList;\n-import java.util.Iterator;\n import java.util.List;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-import org.apache.syncope.common.lib.collections.IteratorChain;\n+import java.util.stream.Stream;\n import org.apache.syncope.common.lib.to.PullTaskTO;\n import org.apache.syncope.common.lib.types.ClientExceptionType;\n import org.apache.syncope.common.lib.types.ConflictResolutionAction;\n@@ -33,11 +29,11 @@\n import org.apache.syncope.common.lib.types.PullMode;\n import org.apache.syncope.common.lib.types.UnmatchingRule;\n import org.apache.syncope.core.persistence.api.dao.ImplementationDAO;\n+import org.apache.syncope.core.persistence.api.dao.RealmDAO;\n import org.apache.syncope.core.persistence.api.entity.Implementation;\n import org.apache.syncope.core.persistence.api.entity.AnyType;\n-import org.apache.syncope.core.persistence.api.entity.Realm;\n import org.apache.syncope.core.persistence.api.entity.VirSchema;\n-import org.apache.syncope.core.persistence.api.entity.resource.MappingItem;\n+import org.apache.syncope.core.persistence.api.entity.resource.Item;\n import org.apache.syncope.core.persistence.api.entity.resource.Provision;\n import org.apache.syncope.core.persistence.api.entity.task.AnyTemplatePullTask;\n import org.apache.syncope.core.persistence.api.entity.task.PullTask;\n@@ -53,7 +49,6 @@\n import org.apache.syncope.core.spring.ImplementationManager;\n import org.apache.syncope.core.provisioning.java.utils.TemplateUtils;\n import org.identityconnectors.framework.common.objects.AttributeBuilder;\n-import org.identityconnectors.framework.common.objects.OperationOptions;\n import org.identityconnectors.framework.common.objects.filter.Filter;\n import org.identityconnectors.framework.common.objects.filter.FilterBuilder;\n import org.quartz.JobExecutionException;\n@@ -67,15 +62,14 @@ public class SinglePullJobDelegate extends PullJobDelegate implements SyncopeSin\n     private ImplementationDAO implementationDAO;\n \n     @Autowired\n-    private TemplateUtils templateUtils;\n+    private RealmDAO realmDAO;\n \n     @Override\n     public List<ProvisioningReport> pull(\n             final Provision provision,\n             final Connector connector,\n             final String connObjectKey,\n             final String connObjectValue,\n-            final Realm realm,\n             final PullTaskTO pullTaskTO) throws JobExecutionException {\n \n         LOG.debug(\"Executing pull on {}\", provision.getResource());\n@@ -95,13 +89,6 @@ public List<ProvisioningReport> pull(\n         });\n \n         try {\n-            Set<MappingItem> linkinMappingItems = virSchemaDAO.findByProvision(provision).stream().\n-                    map(VirSchema::asLinkingMappingItem).collect(Collectors.toSet());\n-            Iterator<MappingItem> mapItems = new IteratorChain<>(\n-                    provision.getMapping().getItems().iterator(),\n-                    linkinMappingItems.iterator());\n-            OperationOptions options = MappingUtils.buildOperationOptions(mapItems);\n-\n             PullTask pullTask = entityFactory.newEntity(PullTask.class);\n             pullTask.setResource(provision.getResource());\n             pullTask.setMatchingRule(pullTaskTO.getMatchingRule() == null\n@@ -113,7 +100,7 @@ public List<ProvisioningReport> pull(\n             pullTask.setPerformUpdate(pullTaskTO.isPerformUpdate());\n             pullTask.setPerformDelete(pullTaskTO.isPerformDelete());\n             pullTask.setSyncStatus(pullTaskTO.isSyncStatus());\n-            pullTask.setDestinationRealm(realm);\n+            pullTask.setDestinationRealm(realmDAO.findByFullPath(pullTaskTO.getDestinationRealm()));\n             pullTask.setRemediation(pullTaskTO.isRemediation());\n             // validate JEXL expressions from templates and proceed if fine\n             TemplateUtils.check(pullTaskTO.getTemplates(), ClientExceptionType.InvalidPullTask);\n@@ -162,18 +149,17 @@ public List<ProvisioningReport> pull(\n             handler.setPullExecutor(this);\n \n             // execute filtered pull\n+            Stream<? extends Item> mapItems = Stream.concat(\n+                    MappingUtils.getPullItems(provision.getMapping().getItems().stream()),\n+                    virSchemaDAO.findByProvision(provision).stream().map(VirSchema::asLinkingMappingItem));\n             connector.filteredReconciliation(\n                     provision.getObjectClass(),\n-                new AccountReconciliationFilterBuilder(connObjectKey, connObjectValue),\n+                    new AccountReconciliationFilterBuilder(connObjectKey, connObjectValue),\n                     handler,\n-                    options);\n+                    MappingUtils.buildOperationOptions(mapItems));\n \n-            Optional<? extends Provision> userProvision = provision.getResource().getProvision(anyTypeDAO.findUser());\n-            boolean userIgnoreCaseMatch = userProvision.map(Provision::isIgnoreCaseMatch).orElse(false);\n-            Optional<? extends Provision> groupProvision = provision.getResource().getProvision(anyTypeDAO.findGroup());\n-            boolean groupIgnoreCaseMatch = groupProvision.map(Provision::isIgnoreCaseMatch).orElse(false);\n             try {\n-                setGroupOwners(ghandler, userIgnoreCaseMatch, groupIgnoreCaseMatch);\n+                setGroupOwners(ghandler);\n             } catch (Exception e) {\n                 LOG.error(\"While setting group owners\", e);\n             }"},{"sha":"48893111296611b3b684daa6249906eacda3cbab","filename":"core/provisioning-java/src/main/java/org/apache/syncope/core/provisioning/java/pushpull/SinglePushJobDelegate.java","status":"modified","additions":61,"deletions":22,"changes":83,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FSinglePushJobDelegate.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FSinglePushJobDelegate.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FSinglePushJobDelegate.java?ref=64495efbbc906599bf3c7de1c0692a7c3139b024","patch":"@@ -30,12 +30,14 @@\n import org.apache.syncope.core.persistence.api.entity.Implementation;\n import org.apache.syncope.core.persistence.api.entity.resource.Provision;\n import org.apache.syncope.core.persistence.api.entity.task.PushTask;\n+import org.apache.syncope.core.persistence.api.entity.user.LinkedAccount;\n import org.apache.syncope.core.provisioning.api.Connector;\n import org.apache.syncope.core.provisioning.api.pushpull.ProvisioningProfile;\n import org.apache.syncope.core.provisioning.api.pushpull.ProvisioningReport;\n import org.apache.syncope.core.provisioning.api.pushpull.PushActions;\n import org.apache.syncope.core.provisioning.api.pushpull.SyncopePushResultHandler;\n import org.apache.syncope.core.provisioning.api.pushpull.SyncopeSinglePushExecutor;\n+import org.apache.syncope.core.provisioning.api.pushpull.UserPushResultHandler;\n import org.apache.syncope.core.spring.ImplementationManager;\n import org.quartz.JobExecutionException;\n import org.springframework.beans.factory.annotation.Autowired;\n@@ -47,11 +49,9 @@ public class SinglePushJobDelegate extends PushJobDelegate implements SyncopeSin\n     @Autowired\n     private ImplementationDAO implementationDAO;\n \n-    @Override\n-    public List<ProvisioningReport> push(\n+    private List<PushActions> before(\n             final Provision provision,\n             final Connector connector,\n-            final Any<?> any,\n             final PushTaskTO pushTaskTO) throws JobExecutionException {\n \n         LOG.debug(\"Executing push on {}\", provision.getResource());\n@@ -70,25 +70,37 @@ public List<ProvisioningReport> push(\n             }\n         });\n \n-        try {\n-            PushTask pushTask = entityFactory.newEntity(PushTask.class);\n-            pushTask.setResource(provision.getResource());\n-            pushTask.setMatchingRule(pushTaskTO.getMatchingRule() == null\n-                    ? MatchingRule.LINK : pushTaskTO.getMatchingRule());\n-            pushTask.setUnmatchingRule(pushTaskTO.getUnmatchingRule() == null\n-                    ? UnmatchingRule.ASSIGN : pushTaskTO.getUnmatchingRule());\n-            pushTask.setPerformCreate(pushTaskTO.isPerformCreate());\n-            pushTask.setPerformUpdate(pushTaskTO.isPerformUpdate());\n-            pushTask.setPerformDelete(pushTaskTO.isPerformDelete());\n-            pushTask.setSyncStatus(pushTaskTO.isSyncStatus());\n-\n-            profile = new ProvisioningProfile<>(connector, pushTask);\n-            profile.getActions().addAll(actions);\n-            profile.setConflictResolutionAction(ConflictResolutionAction.FIRSTMATCH);\n+        PushTask pushTask = entityFactory.newEntity(PushTask.class);\n+        pushTask.setResource(provision.getResource());\n+        pushTask.setMatchingRule(pushTaskTO.getMatchingRule() == null\n+                ? MatchingRule.LINK : pushTaskTO.getMatchingRule());\n+        pushTask.setUnmatchingRule(pushTaskTO.getUnmatchingRule() == null\n+                ? UnmatchingRule.ASSIGN : pushTaskTO.getUnmatchingRule());\n+        pushTask.setPerformCreate(pushTaskTO.isPerformCreate());\n+        pushTask.setPerformUpdate(pushTaskTO.isPerformUpdate());\n+        pushTask.setPerformDelete(pushTaskTO.isPerformDelete());\n+        pushTask.setSyncStatus(pushTaskTO.isSyncStatus());\n \n-            for (PushActions action : actions) {\n-                action.beforeAll(profile);\n-            }\n+        profile = new ProvisioningProfile<>(connector, pushTask);\n+        profile.getActions().addAll(actions);\n+        profile.setConflictResolutionAction(ConflictResolutionAction.FIRSTMATCH);\n+\n+        for (PushActions action : actions) {\n+            action.beforeAll(profile);\n+        }\n+\n+        return actions;\n+    }\n+\n+    @Override\n+    public List<ProvisioningReport> push(\n+            final Provision provision,\n+            final Connector connector,\n+            final Any<?> any,\n+            final PushTaskTO pushTaskTO) throws JobExecutionException {\n+\n+        try {\n+            List<PushActions> actions = before(provision, connector, pushTaskTO);\n \n             SyncopePushResultHandler handler;\n             switch (provision.getAnyType().getKind()) {\n@@ -106,7 +118,7 @@ public List<ProvisioningReport> push(\n             }\n             handler.setProfile(profile);\n \n-            doHandle(List.of(any), handler, pushTask.getResource());\n+            doHandle(List.of(any), handler, provision.getResource());\n \n             for (PushActions action : actions) {\n                 action.afterAll(profile);\n@@ -119,4 +131,31 @@ public List<ProvisioningReport> push(\n                     : new JobExecutionException(\"While pushing to connector\", e);\n         }\n     }\n+\n+    @Override\n+    public ProvisioningReport push(\n+            final Provision provision,\n+            final Connector connector,\n+            final LinkedAccount account,\n+            final PushTaskTO pushTaskTO) throws JobExecutionException {\n+\n+        try {\n+            List<PushActions> actions = before(provision, connector, pushTaskTO);\n+\n+            UserPushResultHandler handler = buildUserHandler();\n+            handler.setProfile(profile);\n+\n+            handler.handle(account, provision);\n+\n+            for (PushActions action : actions) {\n+                action.afterAll(profile);\n+            }\n+\n+            return profile.getResults().get(0);\n+        } catch (Exception e) {\n+            throw e instanceof JobExecutionException\n+                    ? (JobExecutionException) e\n+                    : new JobExecutionException(\"While pushing to connector\", e);\n+        }\n+    }\n }"},{"sha":"3162765ad829ee432c74a595a7d8e0366d978339","filename":"core/provisioning-java/src/main/java/org/apache/syncope/core/provisioning/java/utils/ConnObjectUtils.java","status":"modified","additions":25,"deletions":25,"changes":50,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Futils%2FConnObjectUtils.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Futils%2FConnObjectUtils.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Futils%2FConnObjectUtils.java?ref=64495efbbc906599bf3c7de1c0692a7c3139b024","patch":"@@ -41,9 +41,9 @@\n import org.apache.syncope.common.lib.to.UserTO;\n import org.apache.syncope.core.persistence.api.dao.ExternalResourceDAO;\n import org.apache.syncope.core.persistence.api.dao.UserDAO;\n-import org.apache.syncope.core.persistence.api.entity.AnyUtils;\n import org.apache.syncope.core.persistence.api.entity.user.User;\n import org.apache.syncope.core.persistence.api.dao.RealmDAO;\n+import org.apache.syncope.core.persistence.api.entity.AnyUtilsFactory;\n import org.apache.syncope.core.persistence.api.entity.Realm;\n import org.apache.syncope.core.persistence.api.entity.policy.PasswordPolicy;\n import org.apache.syncope.core.persistence.api.entity.resource.OrgUnit;\n@@ -90,6 +90,9 @@ public class ConnObjectUtils {\n     @Autowired\n     private MappingManager mappingManager;\n \n+    @Autowired\n+    private AnyUtilsFactory anyUtilsFactory;\n+\n     /**\n      * Extract password value from passed value (if instance of GuardedString or GuardedByteArray).\n      *\n@@ -113,6 +116,7 @@ public static String getPassword(final Object pwd) {\n     }\n \n     /**\n+     * <<<<<<< HEAD\n      * Builds {@link ConnObjectTO} out of {@link ConnectorObject}.\n      *\n      * @param connObject connector object.\n@@ -124,6 +128,9 @@ public static ConnObjectTO getConnObjectTO(final ConnectorObject connObject) {\n     }\n \n     /**\n+     * =======\n+     * >>>>>>> 1b918568e... [SYNCOPE-1500] Reconciliation now supports single pull / push + [SYNCOPE-957] Reconciliation\n+     * now supports Linked Accounts + [SYNCOPE-1499] Use Push correlation rule wherever it makes sense\n      * Builds {@link ConnObjectTO} out of a collection of {@link Attribute} instances.\n      *\n      * @param attrs attributes\n@@ -160,7 +167,6 @@ public static ConnObjectTO getConnObjectTO(final Set<Attribute> attrs) {\n      * @param obj connector object\n      * @param pullTask pull task\n      * @param provision provision information\n-     * @param anyUtils utils\n      * @param generatePasswordIfPossible whether password value shall be generated, in case not found from\n      * connector object and allowed by resource configuration\n      * @param <C> create request type\n@@ -171,11 +177,10 @@ public <C extends AnyCR> C getAnyCR(\n             final ConnectorObject obj,\n             final PullTask pullTask,\n             final Provision provision,\n-            final AnyUtils anyUtils,\n             final boolean generatePasswordIfPossible) {\n \n-        AnyTO anyTO = getAnyTOFromConnObject(obj, pullTask, provision, anyUtils);\n-        C anyCR = anyUtils.newAnyCR();\n+        AnyTO anyTO = getAnyTOFromConnObject(obj, pullTask, provision);\n+        C anyCR = anyUtilsFactory.getInstance(provision.getAnyType().getKind()).newAnyCR();\n         EntityTOUtils.toAnyCR(anyTO, anyCR);\n \n         // (for users) if password was not set above, generate if resource is configured for that\n@@ -212,6 +217,15 @@ public <C extends AnyCR> C getAnyCR(\n         return anyCR;\n     }\n \n+    public RealmTO getRealmTO(final ConnectorObject obj, final PullTask task, final OrgUnit orgUnit) {\n+        RealmTO realmTO = new RealmTO();\n+\n+        MappingUtils.getPullItems(orgUnit.getItems().stream()).forEach(item\n+                -> mappingManager.setIntValues(item, obj.getAttributeByName(item.getExtAttrName()), realmTO));\n+\n+        return realmTO;\n+    }\n+\n     /**\n      * Build {@link AnyUR} out of connector object attributes and schema mapping.\n      *\n@@ -220,7 +234,6 @@ public <C extends AnyCR> C getAnyCR(\n      * @param original any object to get diff from\n      * @param pullTask pull task\n      * @param provision provision information\n-     * @param anyUtils utils\n      * @param <U> any object\n      * @return modifications for the any object to be updated\n      */\n@@ -231,14 +244,13 @@ public <U extends AnyUR> U getAnyUR(\n             final ConnectorObject obj,\n             final AnyTO original,\n             final PullTask pullTask,\n-            final Provision provision,\n-            final AnyUtils anyUtils) {\n+            final Provision provision) {\n \n-        AnyTO updated = getAnyTOFromConnObject(obj, pullTask, provision, anyUtils);\n+        AnyTO updated = getAnyTOFromConnObject(obj, pullTask, provision);\n         updated.setKey(key);\n \n         U anyUR = null;\n-        switch (anyUtils.anyTypeKind()) {\n+        switch (provision.getAnyType().getKind()) {\n             case USER:\n                 UserTO originalUser = (UserTO) original;\n                 UserTO updatedUser = (UserTO) updated;\n@@ -303,31 +315,19 @@ public <U extends AnyUR> U getAnyUR(\n     }\n \n     private <T extends AnyTO> T getAnyTOFromConnObject(\n-            final ConnectorObject obj,\n-            final PullTask pullTask,\n-            final Provision provision,\n-            final AnyUtils anyUtils) {\n+            final ConnectorObject obj, final PullTask pullTask, final Provision provision) {\n \n-        T anyTO = anyUtils.newAnyTO();\n+        T anyTO = anyUtilsFactory.getInstance(provision.getAnyType().getKind()).newAnyTO();\n         anyTO.setType(provision.getAnyType().getKey());\n \n         // 1. fill with data from connector object\n         anyTO.setRealm(pullTask.getDestinationRealm().getFullPath());\n-        MappingUtils.getPullItems(provision.getMapping().getItems()).forEach(\n+        MappingUtils.getPullItems(provision.getMapping().getItems().stream()).forEach(\n                 item -> mappingManager.setIntValues(item, obj.getAttributeByName(item.getExtAttrName()), anyTO));\n \n         // 2. add data from defined template (if any)\n         templateUtils.apply(anyTO, pullTask.getTemplate(provision.getAnyType()));\n \n         return anyTO;\n     }\n-\n-    public RealmTO getRealmTO(final ConnectorObject obj, final PullTask task, final OrgUnit orgUnit) {\n-        RealmTO realmTO = new RealmTO();\n-\n-        MappingUtils.getPullItems(orgUnit.getItems()).forEach(\n-                item -> mappingManager.setIntValues(item, obj.getAttributeByName(item.getExtAttrName()), realmTO));\n-\n-        return realmTO;\n-    }\n }"},{"sha":"c425d6eca8d8004998419c69b718aea5dd7d985a","filename":"core/provisioning-java/src/main/java/org/apache/syncope/core/provisioning/java/utils/MappingUtils.java","status":"modified","additions":14,"deletions":21,"changes":35,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Futils%2FMappingUtils.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/64495efbbc906599bf3c7de1c0692a7c3139b024/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Futils%2FMappingUtils.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Futils%2FMappingUtils.java?ref=64495efbbc906599bf3c7de1c0692a7c3139b024","patch":"@@ -20,11 +20,10 @@\n \n import java.util.ArrayList;\n import java.util.HashSet;\n-import java.util.Iterator;\n import java.util.List;\n import java.util.Optional;\n import java.util.Set;\n-import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n import org.apache.commons.jexl3.JexlContext;\n import org.apache.commons.jexl3.MapContext;\n import org.apache.commons.lang3.StringUtils;\n@@ -66,16 +65,14 @@ public static Optional<? extends MappingItem> getConnObjectKeyItem(final Provisi\n                 : mapping.getConnObjectKeyItem();\n     }\n \n-    public static List<? extends Item> getPropagationItems(final List<? extends Item> items) {\n-        return items.stream().\n-                filter(item -> item.getPurpose() == MappingPurpose.PROPAGATION\n-                || item.getPurpose() == MappingPurpose.BOTH).collect(Collectors.toList());\n+    public static Stream<? extends Item> getPropagationItems(final Stream<? extends Item> items) {\n+        return items.filter(\n+                item -> item.getPurpose() == MappingPurpose.PROPAGATION || item.getPurpose() == MappingPurpose.BOTH);\n     }\n \n-    public static List<? extends Item> getPullItems(final List<? extends Item> items) {\n-        return items.stream().\n-                filter(item -> item.getPurpose() == MappingPurpose.PULL\n-                || item.getPurpose() == MappingPurpose.BOTH).collect(Collectors.toList());\n+    public static Stream<? extends Item> getPullItems(final Stream<? extends Item> items) {\n+        return items.filter(\n+                item -> item.getPurpose() == MappingPurpose.PULL || item.getPurpose() == MappingPurpose.BOTH);\n     }\n \n     private static Name getName(final String evalConnObjectLink, final String connObjectKey) {\n@@ -84,14 +81,14 @@ private static Name getName(final String evalConnObjectLink, final String connOb\n         Name name;\n         if (StringUtils.isBlank(evalConnObjectLink)) {\n             // add connObjectKey as __NAME__ attribute ...\n-            LOG.debug(\"Add connObjectKey [{}] as __NAME__\", connObjectKey);\n+            LOG.debug(\"Add connObjectKey [{}] as {}\", connObjectKey, Name.NAME);\n             name = new Name(connObjectKey);\n         } else {\n-            LOG.debug(\"Add connObjectLink [{}] as __NAME__\", evalConnObjectLink);\n+            LOG.debug(\"Add connObjectLink [{}] as {}\", evalConnObjectLink, Name.NAME);\n             name = new Name(evalConnObjectLink);\n \n             // connObjectKey not propagated: it will be used to set the value for __UID__ attribute\n-            LOG.debug(\"connObjectKey will be used just as __UID__ attribute\");\n+            LOG.debug(\"connObjectKey will be used just as {} attribute\", Uid.NAME);\n         }\n \n         return name;\n@@ -187,24 +184,20 @@ public static List<ItemTransformer> getItemTransformers(final Item item) {\n     /**\n      * Build options for requesting all mapped connector attributes.\n      *\n-     * @param iterator items\n+     * @param items items\n      * @return options for requesting all mapped connector attributes\n      * @see OperationOptions\n      */\n-    public static OperationOptions buildOperationOptions(final Iterator<? extends Item> iterator) {\n+    public static OperationOptions buildOperationOptions(final Stream<? extends Item> items) {\n         OperationOptionsBuilder builder = new OperationOptionsBuilder();\n \n         Set<String> attrsToGet = new HashSet<>();\n         attrsToGet.add(Name.NAME);\n         attrsToGet.add(Uid.NAME);\n         attrsToGet.add(OperationalAttributes.ENABLE_NAME);\n \n-        while (iterator.hasNext()) {\n-            Item item = iterator.next();\n-            if (item.getPurpose() != MappingPurpose.NONE) {\n-                attrsToGet.add(item.getExtAttrName());\n-            }\n-        }\n+        items.filter(item -> item.getPurpose() != MappingPurpose.NONE).\n+                forEach(item -> attrsToGet.add(item.getExtAttrName()));\n \n         builder.setAttributesToGet(attrsToGet);\n         // -------------------------------------"},{"sha":"0e628e97ada0bc7bb88cf87f7d12fae239e42240","filename":"fit/core-reference/src/main/java/org/apache/syncope/fit/core/reference/LinkedAccountSamplePullCorrelationRule.java","status":"modified","additions":11,"deletions":6,"changes":17,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/64495efbbc906599bf3c7de1c0692a7c3139b024/fit%2Fcore-reference%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2Freference%2FLinkedAccountSamplePullCorrelationRule.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/64495efbbc906599bf3c7de1c0692a7c3139b024/fit%2Fcore-reference%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2Freference%2FLinkedAccountSamplePullCorrelationRule.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/fit%2Fcore-reference%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2Freference%2FLinkedAccountSamplePullCorrelationRule.java?ref=64495efbbc906599bf3c7de1c0692a7c3139b024","patch":"@@ -19,22 +19,29 @@\n package org.apache.syncope.fit.core.reference;\n \n import java.util.Optional;\n+import org.apache.syncope.common.lib.types.MatchType;\n import org.apache.syncope.core.persistence.api.dao.PullCorrelationRule;\n import org.apache.syncope.core.persistence.api.dao.PullCorrelationRuleConfClass;\n import org.apache.syncope.core.persistence.api.dao.PullMatch;\n+import org.apache.syncope.core.persistence.api.dao.UserDAO;\n import org.apache.syncope.core.persistence.api.dao.search.AttributeCond;\n import org.apache.syncope.core.persistence.api.dao.search.SearchCond;\n import org.apache.syncope.core.persistence.api.entity.Any;\n import org.apache.syncope.core.persistence.api.entity.resource.Provision;\n import org.identityconnectors.framework.common.objects.Attribute;\n import org.identityconnectors.framework.common.objects.SyncDelta;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.transaction.annotation.Transactional;\n import org.springframework.util.CollectionUtils;\n \n @PullCorrelationRuleConfClass(LinkedAccountSamplePullCorrelationRuleConf.class)\n public class LinkedAccountSamplePullCorrelationRule implements PullCorrelationRule {\n \n     public static final String VIVALDI_KEY = \"b3cbc78d-32e6-4bd4-92e0-bbe07566a2ee\";\n \n+    @Autowired\n+    private UserDAO userDAO;\n+\n     @Override\n     public SearchCond getSearchCond(final SyncDelta syncDelta, final Provision provision) {\n         AttributeCond cond = new AttributeCond();\n@@ -51,6 +58,7 @@ public SearchCond getSearchCond(final SyncDelta syncDelta, final Provision provi\n         return SearchCond.getLeafCond(cond);\n     }\n \n+    @Transactional(readOnly = true)\n     @Override\n     public PullMatch matching(final Any<?> any, final SyncDelta syncDelta, final Provision provision) {\n         // if match with internal user vivaldi was found but firstName is different, update linked account\n@@ -60,19 +68,16 @@ public PullMatch matching(final Any<?> any, final SyncDelta syncDelta, final Pro\n                 && firstName != null && !CollectionUtils.isEmpty(firstName.getValue())\n                 && !\"Antonio\".equals(firstName.getValue().get(0).toString())) {\n \n-            return new PullMatch.Builder().\n-                    linkingUserKey(VIVALDI_KEY).\n-                    matchTarget(PullMatch.MatchTarget.LINKED_ACCOUNT).build();\n+            return new PullMatch(MatchType.LINKED_ACCOUNT, any);\n         }\n \n         return PullCorrelationRule.super.matching(any, syncDelta, provision);\n     }\n \n+    @Transactional(readOnly = true)\n     @Override\n     public Optional<PullMatch> unmatching(final SyncDelta syncDelta, final Provision provision) {\n         // if no match with internal user was found, link account to vivaldi instead of creating new user\n-        return Optional.of(new PullMatch.Builder().\n-                linkingUserKey(VIVALDI_KEY).\n-                matchTarget(PullMatch.MatchTarget.LINKED_ACCOUNT).build());\n+        return Optional.of(new PullMatch(MatchType.LINKED_ACCOUNT, userDAO.find(VIVALDI_KEY)));\n     }\n }"},{"sha":"be5f0cb9267651257b969a2d771fc6d17330d100","filename":"fit/core-reference/src/test/java/org/apache/syncope/fit/AbstractITCase.java","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/64495efbbc906599bf3c7de1c0692a7c3139b024/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2FAbstractITCase.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/64495efbbc906599bf3c7de1c0692a7c3139b024/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2FAbstractITCase.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2FAbstractITCase.java?ref=64495efbbc906599bf3c7de1c0692a7c3139b024","patch":"@@ -198,6 +198,8 @@ public abstract class AbstractITCase {\n \n     protected static final String RESOURCE_LDAP_ADMIN_PWD = \"secret\";\n \n+    protected static final String PRINTER = \"PRINTER\";\n+\n     protected static String ANONYMOUS_UNAME;\n \n     protected static String ANONYMOUS_KEY;"},{"sha":"7eb3d5df9923f03907290e157feca592fc247469","filename":"fit/core-reference/src/test/java/org/apache/syncope/fit/core/AnyObjectITCase.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/64495efbbc906599bf3c7de1c0692a7c3139b024/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FAnyObjectITCase.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/64495efbbc906599bf3c7de1c0692a7c3139b024/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FAnyObjectITCase.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FAnyObjectITCase.java?ref=64495efbbc906599bf3c7de1c0692a7c3139b024","patch":"@@ -51,7 +51,7 @@\n public class AnyObjectITCase extends AbstractITCase {\n \n     public static AnyObjectCR getSample(final String location) {\n-        return new AnyObjectCR.Builder(SyncopeConstants.ROOT_REALM, \"PRINTER\", location + getUUIDString()).\n+        return new AnyObjectCR.Builder(SyncopeConstants.ROOT_REALM, PRINTER, location + getUUIDString()).\n                 plainAttr(attr(\"location\", location + getUUIDString())).\n                 resource(RESOURCE_NAME_DBSCRIPTED).\n                 build();\n@@ -122,7 +122,7 @@ public void delete() {\n     public void list() {\n         PagedResult<AnyObjectTO> anyObjectTOs = anyObjectService.search(\n                 new AnyQuery.Builder().realm(SyncopeConstants.ROOT_REALM).\n-                        fiql(SyncopeClient.getAnyObjectSearchConditionBuilder(\"PRINTER\").query()).\n+                        fiql(SyncopeClient.getAnyObjectSearchConditionBuilder(PRINTER).query()).\n                         build());\n         assertNotNull(anyObjectTOs);\n         assertTrue(anyObjectTOs.getResult().size() >= 2);"},{"sha":"33162df2babbca6e502ff612239a5a548b9af8d2","filename":"fit/core-reference/src/test/java/org/apache/syncope/fit/core/AnyTypeITCase.java","status":"modified","additions":6,"deletions":6,"changes":12,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/64495efbbc906599bf3c7de1c0692a7c3139b024/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FAnyTypeITCase.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/64495efbbc906599bf3c7de1c0692a7c3139b024/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FAnyTypeITCase.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FAnyTypeITCase.java?ref=64495efbbc906599bf3c7de1c0692a7c3139b024","patch":"@@ -52,10 +52,10 @@ public void read() {\n         assertEquals(AnyTypeKind.GROUP.name(), groupType.getKey());\n         assertFalse(groupType.getClasses().isEmpty());\n \n-        AnyTypeTO otherType = anyTypeService.read(\"PRINTER\");\n+        AnyTypeTO otherType = anyTypeService.read(PRINTER);\n         assertNotNull(otherType);\n         assertEquals(AnyTypeKind.ANY_OBJECT, otherType.getKind());\n-        assertEquals(\"PRINTER\", otherType.getKey());\n+        assertEquals(PRINTER, otherType.getKey());\n     }\n \n     @Test\n@@ -137,7 +137,7 @@ public void deleteTypeClass() {\n         newClass = getObject(response.getLocation(), AnyTypeClassService.class, AnyTypeClassTO.class);\n         assertNotNull(newClass);\n \n-        AnyTypeTO other = anyTypeService.read(\"PRINTER\");\n+        AnyTypeTO other = anyTypeService.read(PRINTER);\n         assertNotNull(other);\n \n         other.getClasses().add(newClass.getKey());\n@@ -182,19 +182,19 @@ public void issueSYNCOPE754() {\n     @Test\n     public void issueSYNCOPE1472() {\n         // 1. add any type class csv twice to PRINTER any type\n-        AnyTypeTO anyTypeTO = anyTypeService.read(\"PRINTER\");\n+        AnyTypeTO anyTypeTO = anyTypeService.read(PRINTER);\n         anyTypeTO.getClasses().clear();\n         anyTypeTO.getClasses().add(\"minimal printer\");\n         anyTypeTO.getClasses().add(\"csv\");\n         anyTypeTO.getClasses().add(\"csv\");\n         anyTypeService.update(anyTypeTO);\n \n         // 2. read again and remove any type class\n-        anyTypeTO = anyTypeService.read(\"PRINTER\");\n+        anyTypeTO = anyTypeService.read(PRINTER);\n         anyTypeTO.getClasses().remove(\"csv\");\n         anyTypeService.update(anyTypeTO);\n \n-        assertFalse(anyTypeService.read(\"PRINTER\").getClasses().contains(\"csv\"), \n+        assertFalse(anyTypeService.read(PRINTER).getClasses().contains(\"csv\"), \n                 \"Should not contain removed any type classes\");\n     }\n }"},{"sha":"fbebb214b2d1b39a897445804c27b089776b43db","filename":"fit/core-reference/src/test/java/org/apache/syncope/fit/core/GroupITCase.java","status":"modified","additions":13,"deletions":13,"changes":26,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/64495efbbc906599bf3c7de1c0692a7c3139b024/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FGroupITCase.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/64495efbbc906599bf3c7de1c0692a7c3139b024/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FGroupITCase.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FGroupITCase.java?ref=64495efbbc906599bf3c7de1c0692a7c3139b024","patch":"@@ -249,7 +249,7 @@ public void patch() {\n         GroupCR createReq = getBasicSample(\"patch\");\n         createReq.setUDynMembershipCond(\"(($groups==3;$resources!=ws-target-resource-1);aLong==1)\");\n         createReq.getADynMembershipConds().put(\n-                \"PRINTER\",\n+                PRINTER,\n                 \"(($groups==7;cool==ss);$resources==ws-target-resource-2);$type==PRINTER\");\n \n         GroupTO created = createGroup(createReq).getEntity();\n@@ -649,17 +649,17 @@ public void uDynMembership() {\n \n     @Test\n     public void aDynMembership() {\n-        String fiql = SyncopeClient.getAnyObjectSearchConditionBuilder(\"PRINTER\").is(\"location\").notNullValue().query();\n+        String fiql = SyncopeClient.getAnyObjectSearchConditionBuilder(PRINTER).is(\"location\").notNullValue().query();\n \n         // 1. create group with a given aDynMembership condition\n         GroupCR groupCR = getBasicSample(\"aDynMembership\");\n-        groupCR.getADynMembershipConds().put(\"PRINTER\", fiql);\n+        groupCR.getADynMembershipConds().put(PRINTER, fiql);\n         GroupTO group = createGroup(groupCR).getEntity();\n-        assertEquals(fiql, group.getADynMembershipConds().get(\"PRINTER\"));\n+        assertEquals(fiql, group.getADynMembershipConds().get(PRINTER));\n \n         group = groupService.read(group.getKey());\n         final String groupKey = group.getKey();\n-        assertEquals(fiql, group.getADynMembershipConds().get(\"PRINTER\"));\n+        assertEquals(fiql, group.getADynMembershipConds().get(PRINTER));\n \n         // verify that the condition is dynamically applied\n         AnyObjectCR newAnyCR = AnyObjectITCase.getSample(\"aDynMembership\");\n@@ -678,17 +678,17 @@ public void aDynMembership() {\n         assertTrue(memberships.stream().anyMatch(m -> m.getGroupKey().equals(groupKey)));\n \n         // 2. update group and change aDynMembership condition\n-        fiql = SyncopeClient.getAnyObjectSearchConditionBuilder(\"PRINTER\").is(\"location\").nullValue().query();\n+        fiql = SyncopeClient.getAnyObjectSearchConditionBuilder(PRINTER).is(\"location\").nullValue().query();\n \n         GroupUR groupUR = new GroupUR();\n         groupUR.setKey(group.getKey());\n-        groupUR.getADynMembershipConds().put(\"PRINTER\", fiql);\n+        groupUR.getADynMembershipConds().put(PRINTER, fiql);\n \n         group = updateGroup(groupUR).getEntity();\n-        assertEquals(fiql, group.getADynMembershipConds().get(\"PRINTER\"));\n+        assertEquals(fiql, group.getADynMembershipConds().get(PRINTER));\n \n         group = groupService.read(group.getKey());\n-        assertEquals(fiql, group.getADynMembershipConds().get(\"PRINTER\"));\n+        assertEquals(fiql, group.getADynMembershipConds().get(PRINTER));\n \n         // verify that the condition is dynamically applied\n         AnyObjectUR anyObjectUR = new AnyObjectUR();\n@@ -713,14 +713,14 @@ public void aDynMembership() {\n     public void aDynMembershipCount() {\n         // Create a new printer as a dynamic member of a new group\n         GroupCR groupCR = getBasicSample(\"aDynamicMembership\");\n-        String fiql = SyncopeClient.getAnyObjectSearchConditionBuilder(\"PRINTER\").is(\"location\").equalTo(\"home\").query();\n-        groupCR.getADynMembershipConds().put(\"PRINTER\", fiql);\n+        String fiql = SyncopeClient.getAnyObjectSearchConditionBuilder(PRINTER).is(\"location\").equalTo(\"home\").query();\n+        groupCR.getADynMembershipConds().put(PRINTER, fiql);\n         GroupTO group = createGroup(groupCR).getEntity();\n \n         AnyObjectCR printerCR = new AnyObjectCR();\n         printerCR.setRealm(SyncopeConstants.ROOT_REALM);\n         printerCR.setName(\"Printer_\" + getUUIDString());\n-        printerCR.setType(\"PRINTER\");\n+        printerCR.setType(PRINTER);\n         printerCR.getPlainAttrs().add(new Attr.Builder(\"location\").value(\"home\").build());\n         AnyObjectTO printer = createAnyObject(printerCR).getEntity();\n \n@@ -741,7 +741,7 @@ public void aStaticMembershipCount() {\n         AnyObjectCR printerCR = new AnyObjectCR();\n         printerCR.setRealm(SyncopeConstants.ROOT_REALM);\n         printerCR.setName(\"Printer_\" + getUUIDString());\n-        printerCR.setType(\"PRINTER\");\n+        printerCR.setType(PRINTER);\n         printerCR.getMemberships().add(new MembershipTO.Builder(group.getKey()).build());\n         AnyObjectTO printer = createAnyObject(printerCR).getEntity();\n "},{"sha":"4d18370d69d2ec49a9ffc6974ec4ade033879a13","filename":"fit/core-reference/src/test/java/org/apache/syncope/fit/core/LoggerITCase.java","status":"modified","additions":3,"deletions":2,"changes":5,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/64495efbbc906599bf3c7de1c0692a7c3139b024/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FLoggerITCase.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/64495efbbc906599bf3c7de1c0692a7c3139b024/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FLoggerITCase.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FLoggerITCase.java?ref=64495efbbc906599bf3c7de1c0692a7c3139b024","patch":"@@ -57,6 +57,7 @@\n import org.apache.syncope.common.lib.types.ResourceOperation;\n import org.apache.syncope.common.lib.types.UnmatchingRule;\n import org.apache.syncope.common.rest.api.LoggerWrapper;\n+import org.apache.syncope.common.rest.api.beans.ReconQuery;\n import org.apache.syncope.core.logic.ConnectorLogic;\n import org.apache.syncope.core.logic.ReportLogic;\n import org.apache.syncope.core.logic.ResourceLogic;\n@@ -421,8 +422,8 @@ public void issueSYNCOPE1446() {\n             pushTask.setPerformUpdate(true);\n             pushTask.setUnmatchingRule(UnmatchingRule.PROVISION);\n             pushTask.setMatchingRule(MatchingRule.UPDATE);\n-            reconciliationService.push(\n-                    AnyTypeKind.ANY_OBJECT, \"fc6dbc3a-6c07-4965-8781-921e7401a4a5\", RESOURCE_NAME_DBSCRIPTED, pushTask);\n+            reconciliationService.push(new ReconQuery.Builder(PRINTER, RESOURCE_NAME_DBSCRIPTED).\n+                    anyKey(\"fc6dbc3a-6c07-4965-8781-921e7401a4a5\").build(), pushTask);\n         } catch (Exception e) {\n             LOG.error(\"Unexpected exception\", e);\n             fail(e::getMessage);"},{"sha":"022247d634b526dca03ce36a1eec2f8e905dc06d","filename":"fit/core-reference/src/test/java/org/apache/syncope/fit/core/MultitenancyITCase.java","status":"modified","additions":3,"deletions":1,"changes":4,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/64495efbbc906599bf3c7de1c0692a7c3139b024/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FMultitenancyITCase.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/64495efbbc906599bf3c7de1c0692a7c3139b024/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FMultitenancyITCase.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FMultitenancyITCase.java?ref=64495efbbc906599bf3c7de1c0692a7c3139b024","patch":"@@ -58,6 +58,7 @@\n import org.apache.syncope.common.lib.types.SchemaType;\n import org.apache.syncope.common.lib.types.TaskType;\n import org.apache.syncope.common.rest.api.beans.AnyQuery;\n+import org.apache.syncope.common.rest.api.beans.ReconQuery;\n import org.apache.syncope.common.rest.api.beans.SchemaQuery;\n import org.apache.syncope.common.rest.api.beans.TaskQuery;\n import org.apache.syncope.common.rest.api.service.ConnectorService;\n@@ -240,7 +241,8 @@ public void createResourceAndPull() {\n             pushTask.setPerformUpdate(true);\n             pushTask.setMatchingRule(MatchingRule.UPDATE);\n             adminClient.getService(ReconciliationService.class).\n-                    push(AnyTypeKind.USER, pullFromLDAPKey, resource.getKey(), pushTask);\n+                    push(new ReconQuery.Builder(AnyTypeKind.USER.name(), resource.getKey()).\n+                            anyKey(pullFromLDAPKey).build(), pushTask);\n \n             assertEquals(1, adminClient.getService(TaskService.class).\n                     search(new TaskQuery.Builder(TaskType.PROPAGATION)."},{"sha":"95475fd37ad8149b8236bfa47189e6f7f7c9be44","filename":"fit/core-reference/src/test/java/org/apache/syncope/fit/core/PropagationTaskITCase.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/64495efbbc906599bf3c7de1c0692a7c3139b024/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FPropagationTaskITCase.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/64495efbbc906599bf3c7de1c0692a7c3139b024/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FPropagationTaskITCase.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FPropagationTaskITCase.java?ref=64495efbbc906599bf3c7de1c0692a7c3139b024","patch":"@@ -187,7 +187,7 @@ public void propagationJEXLTransformer() {\n         // 0. Set propagation JEXL MappingItemTransformer\n         ResourceTO resource = resourceService.read(RESOURCE_NAME_DBSCRIPTED);\n         ResourceTO originalResource = SerializationUtils.clone(resource);\n-        ProvisionTO provision = resource.getProvision(\"PRINTER\").get();\n+        ProvisionTO provision = resource.getProvision(PRINTER).get();\n         assertNotNull(provision);\n \n         Optional<ItemTO> mappingItem = provision.getMapping().getItems().stream()."},{"sha":"bfa56367ad2f7eb59e9eccfde07fc4d2e8cd707d","filename":"fit/core-reference/src/test/java/org/apache/syncope/fit/core/PullTaskITCase.java","status":"modified","additions":3,"deletions":3,"changes":6,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/64495efbbc906599bf3c7de1c0692a7c3139b024/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FPullTaskITCase.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/64495efbbc906599bf3c7de1c0692a7c3139b024/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FPullTaskITCase.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FPullTaskITCase.java?ref=64495efbbc906599bf3c7de1c0692a7c3139b024","patch":"@@ -479,7 +479,7 @@ public void reconcileFromScriptedSQL() throws IOException {\n         // 0. reset sync token and set MappingItemTransformer\n         ResourceTO resource = resourceService.read(RESOURCE_NAME_DBSCRIPTED);\n         ResourceTO originalResource = SerializationUtils.clone(resource);\n-        ProvisionTO provision = resource.getProvision(\"PRINTER\").get();\n+        ProvisionTO provision = resource.getProvision(PRINTER).get();\n         assertNotNull(provision);\n \n         ImplementationTO transformer = null;\n@@ -537,7 +537,7 @@ public void reconcileFromScriptedSQL() throws IOException {\n             // 3. unlink any existing printer and delete from Syncope (printer is now only on external resource)\n             PagedResult<AnyObjectTO> matchingPrinters = anyObjectService.search(\n                     new AnyQuery.Builder().realm(SyncopeConstants.ROOT_REALM).\n-                            fiql(SyncopeClient.getAnyObjectSearchConditionBuilder(\"PRINTER\").\n+                            fiql(SyncopeClient.getAnyObjectSearchConditionBuilder(PRINTER).\n                                     is(\"location\").equalTo(\"pull*\").query()).build());\n             assertTrue(matchingPrinters.getSize() > 0);\n             for (AnyObjectTO printer : matchingPrinters.getResult()) {\n@@ -557,7 +557,7 @@ public void reconcileFromScriptedSQL() throws IOException {\n             // 5. verify that printer was re-created in Syncope (implies that location does not start with given prefix,\n             // hence PrefixItemTransformer was applied during pull)\n             matchingPrinters = anyObjectService.search(new AnyQuery.Builder().realm(SyncopeConstants.ROOT_REALM).\n-                    fiql(SyncopeClient.getAnyObjectSearchConditionBuilder(\"PRINTER\").\n+                    fiql(SyncopeClient.getAnyObjectSearchConditionBuilder(PRINTER).\n                             is(\"location\").equalTo(\"pull*\").query()).build());\n             assertTrue(matchingPrinters.getSize() > 0);\n "},{"sha":"96347d5ec3c5921f4faaaf48729b8ff41a7d78de","filename":"fit/core-reference/src/test/java/org/apache/syncope/fit/core/PushTaskITCase.java","status":"modified","additions":49,"deletions":40,"changes":89,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/64495efbbc906599bf3c7de1c0692a7c3139b024/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FPushTaskITCase.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/64495efbbc906599bf3c7de1c0692a7c3139b024/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FPushTaskITCase.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FPushTaskITCase.java?ref=64495efbbc906599bf3c7de1c0692a7c3139b024","patch":"@@ -56,6 +56,7 @@\n import org.apache.syncope.common.lib.types.TaskType;\n import org.apache.syncope.common.lib.types.TraceLevel;\n import org.apache.syncope.common.lib.types.UnmatchingRule;\n+import org.apache.syncope.common.rest.api.beans.ReconQuery;\n import org.apache.syncope.common.rest.api.beans.TaskQuery;\n import org.apache.syncope.common.rest.api.service.NotificationService;\n import org.apache.syncope.common.rest.api.service.ResourceService;\n@@ -271,46 +272,54 @@ public void pushPolicy() {\n         ResourceTO ldap = resourceService.read(RESOURCE_NAME_LDAP);\n         assertNull(ldap.getPushPolicy());\n \n-        ldap.setPushPolicy(\"fb6530e5-892d-4f47-a46b-180c5b6c5c83\");\n-        resourceService.update(ldap);\n-\n-        // 2. create push task with sole scope as the user 'vivaldi'\n-        PushTaskTO sendVivaldi = new PushTaskTO();\n-        sendVivaldi.setName(\"Send Vivaldi\");\n-        sendVivaldi.setResource(RESOURCE_NAME_LDAP);\n-        sendVivaldi.setUnmatchingRule(UnmatchingRule.PROVISION);\n-        sendVivaldi.setMatchingRule(MatchingRule.UPDATE);\n-        sendVivaldi.setSourceRealm(SyncopeConstants.ROOT_REALM);\n-        sendVivaldi.getFilters().put(AnyTypeKind.GROUP.name(), \"name==$null\");\n-        sendVivaldi.getFilters().put(AnyTypeKind.USER.name(), \"username==vivaldi\");\n-        sendVivaldi.setPerformCreate(true);\n-        sendVivaldi.setPerformUpdate(true);\n-\n-        Response response = taskService.create(TaskType.PUSH, sendVivaldi);\n-        sendVivaldi = getObject(response.getLocation(), TaskService.class, PushTaskTO.class);\n-        assertNotNull(sendVivaldi);\n-\n-        // 3. execute push: vivaldi is found on ldap\n-        execProvisioningTask(taskService, TaskType.PUSH, sendVivaldi.getKey(), 50, false);\n-\n-        ReconStatus status = reconciliationService.status(AnyTypeKind.USER, \"vivaldi\", RESOURCE_NAME_LDAP);\n-        assertNotNull(status.getOnResource());\n-\n-        // 4. update vivaldi on ldap: reconciliation status does not find it anymore, as remote key was changed\n-        Map<String, String> attrs = new HashMap<>();\n-        attrs.put(\"cn\", \"vivaldiZZ\");\n-        attrs.put(\"mail\", \"vivaldi@syncope.org\");\n-        updateLdapRemoteObject(RESOURCE_LDAP_ADMIN_DN, RESOURCE_LDAP_ADMIN_PWD, \"uid=vivaldi,ou=People,o=isp\", attrs);\n-\n-        status = reconciliationService.status(AnyTypeKind.USER, \"vivaldi\", RESOURCE_NAME_LDAP);\n-        assertNull(status.getOnResource());\n-\n-        // 5. execute push again: the push policy will find anyway vivaldi because of the email attribute\n-        execProvisioningTask(taskService, TaskType.PUSH, sendVivaldi.getKey(), 50, false);\n-\n-        // 6. now the reconciliation status is fine again, as the push above did overwrite the entry on ldap\n-        status = reconciliationService.status(AnyTypeKind.USER, \"vivaldi\", RESOURCE_NAME_LDAP);\n-        assertNotNull(status.getOnResource());\n+        try {\n+            ldap.setPushPolicy(\"fb6530e5-892d-4f47-a46b-180c5b6c5c83\");\n+            resourceService.update(ldap);\n+\n+            // 2. create push task with sole scope as the user 'vivaldi'\n+            PushTaskTO sendVivaldi = new PushTaskTO();\n+            sendVivaldi.setName(\"Send Vivaldi\");\n+            sendVivaldi.setResource(RESOURCE_NAME_LDAP);\n+            sendVivaldi.setUnmatchingRule(UnmatchingRule.PROVISION);\n+            sendVivaldi.setMatchingRule(MatchingRule.UPDATE);\n+            sendVivaldi.setSourceRealm(SyncopeConstants.ROOT_REALM);\n+            sendVivaldi.getFilters().put(AnyTypeKind.GROUP.name(), \"name==$null\");\n+            sendVivaldi.getFilters().put(AnyTypeKind.USER.name(), \"username==vivaldi\");\n+            sendVivaldi.setPerformCreate(true);\n+            sendVivaldi.setPerformUpdate(true);\n+\n+            Response response = taskService.create(TaskType.PUSH, sendVivaldi);\n+            sendVivaldi = getObject(response.getLocation(), TaskService.class, PushTaskTO.class);\n+            assertNotNull(sendVivaldi);\n+\n+            // 3. execute push: vivaldi is found on ldap\n+            execProvisioningTask(taskService, TaskType.PUSH, sendVivaldi.getKey(), 50, false);\n+\n+            ReconStatus status = reconciliationService.status(\n+                    new ReconQuery.Builder(AnyTypeKind.USER.name(), RESOURCE_NAME_LDAP).anyKey(\"vivaldi\").build());\n+            assertNotNull(status.getOnResource());\n+\n+            // 4. update vivaldi on ldap: reconciliation status does not find it anymore, as remote key was changed\n+            Map<String, String> attrs = new HashMap<>();\n+            attrs.put(\"sn\", \"VivaldiZ\");\n+            updateLdapRemoteObject(\n+                    RESOURCE_LDAP_ADMIN_DN, RESOURCE_LDAP_ADMIN_PWD, \"uid=vivaldi,ou=People,o=isp\", attrs);\n+\n+            status = reconciliationService.status(\n+                    new ReconQuery.Builder(AnyTypeKind.USER.name(), RESOURCE_NAME_LDAP).anyKey(\"vivaldi\").build());\n+            assertNull(status.getOnResource());\n+\n+            // 5. execute push again: propagation task for CREATE will be generated, but that will fail\n+            // as task executor is not able any more to identify the entry to UPDATE\n+            execProvisioningTask(taskService, TaskType.PUSH, sendVivaldi.getKey(), 50, false);\n+\n+            status = reconciliationService.status(\n+                    new ReconQuery.Builder(AnyTypeKind.USER.name(), RESOURCE_NAME_LDAP).anyKey(\"vivaldi\").build());\n+            assertNull(status.getOnResource());\n+        } finally {\n+            ldap.setPushPolicy(null);\n+            resourceService.update(ldap);\n+        }\n     }\n \n     @Test"},{"sha":"1635f0243ceef250e43fe2f58acd6a92e34d7fd4","filename":"fit/core-reference/src/test/java/org/apache/syncope/fit/core/ReconciliationITCase.java","status":"modified","additions":55,"deletions":8,"changes":63,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/64495efbbc906599bf3c7de1c0692a7c3139b024/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FReconciliationITCase.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/64495efbbc906599bf3c7de1c0692a7c3139b024/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FReconciliationITCase.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FReconciliationITCase.java?ref=64495efbbc906599bf3c7de1c0692a7c3139b024","patch":"@@ -26,15 +26,20 @@\n \n import java.util.Date;\n import org.apache.syncope.common.lib.request.AnyObjectCR;\n+import java.util.UUID;\n+import org.apache.syncope.common.lib.SyncopeConstants;\n import org.apache.syncope.common.lib.to.AnyObjectTO;\n import org.apache.syncope.common.lib.Attr;\n import org.apache.syncope.common.lib.to.PullTaskTO;\n import org.apache.syncope.common.lib.to.PushTaskTO;\n import org.apache.syncope.common.lib.to.ReconStatus;\n import org.apache.syncope.common.lib.types.AnyTypeKind;\n+import org.apache.syncope.common.lib.types.MatchType;\n import org.apache.syncope.common.lib.types.UnmatchingRule;\n+import org.apache.syncope.common.rest.api.beans.ReconQuery;\n import org.apache.syncope.fit.AbstractITCase;\n import org.identityconnectors.framework.common.objects.OperationalAttributes;\n+import org.identityconnectors.framework.common.objects.Uid;\n import org.junit.jupiter.api.Test;\n import org.springframework.jdbc.core.JdbcTemplate;\n \n@@ -54,17 +59,21 @@ public void push() {\n                 \"SELECT id FROM testPRINTER WHERE printername=?\", printer.getName()).size());\n \n         // 3. verify reconciliation status\n-        ReconStatus status =\n-                reconciliationService.status(AnyTypeKind.ANY_OBJECT, printer.getName(), \"resource-db-scripted\");\n+        ReconStatus status = reconciliationService.status(\n+                new ReconQuery.Builder(PRINTER, RESOURCE_NAME_DBSCRIPTED).anyKey(printer.getName()).build());\n         assertNotNull(status);\n+        assertEquals(AnyTypeKind.ANY_OBJECT, status.getAnyTypeKind());\n+        assertEquals(printer.getKey(), status.getAnyKey());\n+        assertEquals(MatchType.ANY, status.getMatchType());\n         assertNotNull(status.getOnSyncope());\n         assertNull(status.getOnResource());\n \n         // 4. push\n         PushTaskTO pushTask = new PushTaskTO();\n         pushTask.setPerformCreate(true);\n         pushTask.setUnmatchingRule(UnmatchingRule.PROVISION);\n-        reconciliationService.push(AnyTypeKind.ANY_OBJECT, printer.getKey(), \"resource-db-scripted\", pushTask);\n+        reconciliationService.push(new ReconQuery.Builder(PRINTER, RESOURCE_NAME_DBSCRIPTED).\n+                anyKey(printer.getKey()).build(), pushTask);\n \n         // 5. verify that printer is now propagated\n         assertEquals(1, jdbcTemplate.queryForList(\n@@ -75,7 +84,8 @@ public void push() {\n         assertTrue(printer.getResources().isEmpty());\n \n         // 7. verify reconciliation status\n-        status = reconciliationService.status(AnyTypeKind.ANY_OBJECT, printer.getName(), \"resource-db-scripted\");\n+        status = reconciliationService.status(\n+                new ReconQuery.Builder(PRINTER, RESOURCE_NAME_DBSCRIPTED).anyKey(printer.getName()).build());\n         assertNotNull(status);\n         assertNotNull(status.getOnSyncope());\n         assertNotNull(status.getOnResource());\n@@ -97,28 +107,65 @@ public void pull() {\n         assertNotNull(printer.getKey());\n         assertNotEquals(\"Nowhere\", printer.getPlainAttr(\"location\").get().getValues().get(0));\n \n-        // 2. create table into the external resource's db, with same name\n+        // 2. add row into the external resource's table, with same name\n         JdbcTemplate jdbcTemplate = new JdbcTemplate(testDataSource);\n         jdbcTemplate.update(\n                 \"INSERT INTO TESTPRINTER (id, printername, location, deleted, lastmodification) VALUES (?,?,?,?,?)\",\n                 printer.getKey(), printer.getName(), \"Nowhere\", false, new Date());\n \n         // 3. verify reconciliation status\n-        ReconStatus status =\n-                reconciliationService.status(AnyTypeKind.ANY_OBJECT, printer.getName(), \"resource-db-scripted\");\n+        ReconStatus status = reconciliationService.status(\n+                new ReconQuery.Builder(PRINTER, RESOURCE_NAME_DBSCRIPTED).anyKey(printer.getName()).build());\n         assertNotNull(status);\n         assertNotNull(status.getOnSyncope());\n         assertNotNull(status.getOnResource());\n         assertNotEquals(status.getOnSyncope().getAttr(\"LOCATION\"), status.getOnResource().getAttr(\"LOCATION\"));\n \n         // 4. pull\n         PullTaskTO pullTask = new PullTaskTO();\n+        pullTask.setDestinationRealm(SyncopeConstants.ROOT_REALM);\n         pullTask.setPerformUpdate(true);\n-        reconciliationService.pull(AnyTypeKind.ANY_OBJECT, printer.getName(), \"resource-db-scripted\", pullTask);\n+        reconciliationService.pull(new ReconQuery.Builder(PRINTER, RESOURCE_NAME_DBSCRIPTED).\n+                anyKey(printer.getName()).build(), pullTask);\n \n         // 5. verify reconciliation result (and resource is still not assigned)\n         printer = anyObjectService.read(printer.getKey());\n         assertEquals(\"Nowhere\", printer.getPlainAttr(\"location\").get().getValues().get(0));\n         assertTrue(printer.getResources().isEmpty());\n     }\n+\n+    @Test\n+    public void importSingle() {\n+        // 1. add row into the external resource's table\n+        String externalKey = UUID.randomUUID().toString();\n+        String externalName = \"printer\" + getUUIDString();\n+\n+        JdbcTemplate jdbcTemplate = new JdbcTemplate(testDataSource);\n+        jdbcTemplate.update(\n+                \"INSERT INTO TESTPRINTER (id, printername, location, deleted, lastmodification) VALUES (?,?,?,?,?)\",\n+                externalKey, externalName, \"Nowhere\", false, new Date());\n+\n+        // 2. verify reconciliation status\n+        ReconStatus status = reconciliationService.status(\n+                new ReconQuery.Builder(PRINTER, RESOURCE_NAME_DBSCRIPTED).connObjectKeyValue(externalKey).build());\n+        assertNotNull(status);\n+        assertNull(status.getAnyTypeKind());\n+        assertNull(status.getAnyKey());\n+        assertNull(status.getMatchType());\n+        assertNull(status.getOnSyncope());\n+        assertNotNull(status.getOnResource());\n+        assertEquals(externalKey, status.getOnResource().getAttr(Uid.NAME).get().getValues().get(0));\n+        assertEquals(externalName, status.getOnResource().getAttr(\"PRINTERNAME\").get().getValues().get(0));\n+\n+        // 3. pull\n+        PullTaskTO pullTask = new PullTaskTO();\n+        pullTask.setDestinationRealm(SyncopeConstants.ROOT_REALM);\n+        pullTask.setPerformCreate(true);\n+        reconciliationService.pull(new ReconQuery.Builder(PRINTER, RESOURCE_NAME_DBSCRIPTED).\n+                connObjectKeyValue(externalKey).build(), pullTask);\n+\n+        // 4. verify reconciliation result\n+        AnyObjectTO printer = anyObjectService.read(externalName);\n+        assertNotNull(printer);\n+    }\n }"},{"sha":"7cdc78401c9936808048b957b081434f8805cc04","filename":"fit/core-reference/src/test/java/org/apache/syncope/fit/core/ResourceITCase.java","status":"modified","additions":5,"deletions":5,"changes":10,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/64495efbbc906599bf3c7de1c0692a7c3139b024/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FResourceITCase.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/64495efbbc906599bf3c7de1c0692a7c3139b024/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FResourceITCase.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FResourceITCase.java?ref=64495efbbc906599bf3c7de1c0692a7c3139b024","patch":"@@ -408,22 +408,22 @@ public void syncToken() {\n         try {\n             // create a new resource\n             resource = createResource(resource);\n-            assertNull(resource.getProvision(\"PRINTER\").get().getSyncToken());\n+            assertNull(resource.getProvision(PRINTER).get().getSyncToken());\n \n             // create some object on the new resource\n             anyObject = createAnyObject(anyObjectCR).getEntity();\n \n             // update sync token\n-            resourceService.setLatestSyncToken(resource.getKey(), \"PRINTER\");\n+            resourceService.setLatestSyncToken(resource.getKey(), PRINTER);\n \n             resource = resourceService.read(resource.getKey());\n-            assertNotNull(resource.getProvision(\"PRINTER\").get().getSyncToken());\n+            assertNotNull(resource.getProvision(PRINTER).get().getSyncToken());\n \n             // remove sync token\n-            resourceService.removeSyncToken(resource.getKey(), \"PRINTER\");\n+            resourceService.removeSyncToken(resource.getKey(), PRINTER);\n \n             resource = resourceService.read(resource.getKey());\n-            assertNull(resource.getProvision(\"PRINTER\").get().getSyncToken());\n+            assertNull(resource.getProvision(PRINTER).get().getSyncToken());\n         } finally {\n             if (anyObject != null) {\n                 anyObjectService.delete(anyObject.getKey());"},{"sha":"2a5d64f4d267a39a5cc2764c1b5ba780f13cf113","filename":"fit/core-reference/src/test/java/org/apache/syncope/fit/core/SearchITCase.java","status":"modified","additions":4,"deletions":4,"changes":8,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/64495efbbc906599bf3c7de1c0692a7c3139b024/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FSearchITCase.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/64495efbbc906599bf3c7de1c0692a7c3139b024/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FSearchITCase.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FSearchITCase.java?ref=64495efbbc906599bf3c7de1c0692a7c3139b024","patch":"@@ -337,7 +337,7 @@ public void nested() {\n     public void searchByType() {\n         PagedResult<AnyObjectTO> matching = anyObjectService.search(new AnyQuery.Builder().realm(\n                 SyncopeConstants.ROOT_REALM).\n-                fiql(SyncopeClient.getAnyObjectSearchConditionBuilder(\"PRINTER\").query()).build());\n+                fiql(SyncopeClient.getAnyObjectSearchConditionBuilder(PRINTER).query()).build());\n         assertNotNull(matching);\n \n         assertFalse(matching.getResult().isEmpty());\n@@ -356,7 +356,7 @@ public void searchByType() {\n     public void searchByRelationship() {\n         PagedResult<AnyObjectTO> anyObjects = anyObjectService.search(new AnyQuery.Builder().realm(\n                 SyncopeConstants.ROOT_REALM).\n-                fiql(SyncopeClient.getAnyObjectSearchConditionBuilder(\"PRINTER\").\n+                fiql(SyncopeClient.getAnyObjectSearchConditionBuilder(PRINTER).\n                         inRelationships(\"Canon MF 8030cn\").query()).\n                 build());\n         assertNotNull(anyObjects);\n@@ -375,7 +375,7 @@ public void searchByRelationship() {\n     public void searchByRelationshipType() {\n         PagedResult<AnyObjectTO> anyObjects = anyObjectService.search(new AnyQuery.Builder().realm(\n                 SyncopeConstants.ROOT_REALM).\n-                fiql(SyncopeClient.getAnyObjectSearchConditionBuilder(\"PRINTER\").\n+                fiql(SyncopeClient.getAnyObjectSearchConditionBuilder(PRINTER).\n                         inRelationshipTypes(\"neighborhood\").query()).\n                 build());\n         assertNotNull(anyObjects);\n@@ -423,7 +423,7 @@ public void assignable() {\n                 anyMatch(group -> \"e7ff94e8-19c9-4f0a-b8b7-28327edbf6ed\".equals(group.getKey())));\n \n         PagedResult<AnyObjectTO> anyObjects = anyObjectService.search(new AnyQuery.Builder().realm(\"/odd\").\n-                fiql(SyncopeClient.getAnyObjectSearchConditionBuilder(\"PRINTER\").isAssignable().\n+                fiql(SyncopeClient.getAnyObjectSearchConditionBuilder(PRINTER).isAssignable().\n                         and(\"name\").equalTo(\"*\").query()).\n                 build());\n         assertNotNull(anyObjects);"}]}