{"sha":"bffc69fd5518981ad384a4086dda4548e0ebcf4b","node_id":"MDY6Q29tbWl0NjM2ODc5MDYyOmJmZmM2OWZkNTUxODk4MWFkMzg0YTQwODZkZGE0NTQ4ZTBlYmNmNGI=","commit":{"author":{"name":"Francesco Chicchiriccò","email":"ilgrosso@apache.org","date":"2012-10-22T14:29:50Z"},"committer":{"name":"Francesco Chicchiriccò","email":"ilgrosso@apache.org","date":"2012-10-22T14:29:50Z"},"message":"[SYNCOPE-186] PropagationTaskExecutor (interface + default implementation) separated from PropagationManager\n\ngit-svn-id: https://svn.apache.org/repos/asf/incubator/syncope/trunk@1400893 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"d602c149c41a9848a96a8985fb650702f22b1ee9","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/git/trees/d602c149c41a9848a96a8985fb650702f22b1ee9"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/git/commits/bffc69fd5518981ad384a4086dda4548e0ebcf4b","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/bffc69fd5518981ad384a4086dda4548e0ebcf4b","html_url":"https://github.com/EnricoDAlessandro97UNI/syncope/commit/bffc69fd5518981ad384a4086dda4548e0ebcf4b","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/bffc69fd5518981ad384a4086dda4548e0ebcf4b/comments","author":{"login":"ilgrosso","id":1064664,"node_id":"MDQ6VXNlcjEwNjQ2NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/1064664?v=4","gravatar_id":"","url":"https://api.github.com/users/ilgrosso","html_url":"https://github.com/ilgrosso","followers_url":"https://api.github.com/users/ilgrosso/followers","following_url":"https://api.github.com/users/ilgrosso/following{/other_user}","gists_url":"https://api.github.com/users/ilgrosso/gists{/gist_id}","starred_url":"https://api.github.com/users/ilgrosso/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ilgrosso/subscriptions","organizations_url":"https://api.github.com/users/ilgrosso/orgs","repos_url":"https://api.github.com/users/ilgrosso/repos","events_url":"https://api.github.com/users/ilgrosso/events{/privacy}","received_events_url":"https://api.github.com/users/ilgrosso/received_events","type":"User","site_admin":false},"committer":{"login":"ilgrosso","id":1064664,"node_id":"MDQ6VXNlcjEwNjQ2NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/1064664?v=4","gravatar_id":"","url":"https://api.github.com/users/ilgrosso","html_url":"https://github.com/ilgrosso","followers_url":"https://api.github.com/users/ilgrosso/followers","following_url":"https://api.github.com/users/ilgrosso/following{/other_user}","gists_url":"https://api.github.com/users/ilgrosso/gists{/gist_id}","starred_url":"https://api.github.com/users/ilgrosso/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ilgrosso/subscriptions","organizations_url":"https://api.github.com/users/ilgrosso/orgs","repos_url":"https://api.github.com/users/ilgrosso/repos","events_url":"https://api.github.com/users/ilgrosso/events{/privacy}","received_events_url":"https://api.github.com/users/ilgrosso/received_events","type":"User","site_admin":false},"parents":[{"sha":"3c24e217b8ea6b8ca369320cd6c8e75f52b3caa9","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/3c24e217b8ea6b8ca369320cd6c8e75f52b3caa9","html_url":"https://github.com/EnricoDAlessandro97UNI/syncope/commit/3c24e217b8ea6b8ca369320cd6c8e75f52b3caa9"}],"stats":{"total":953,"additions":564,"deletions":389},"files":[{"sha":"13ae67f41b5556e63e2216cbe04c5fed3b1a251a","filename":"core/src/main/java/org/apache/syncope/core/audit/AuditManager.java","status":"modified","additions":3,"deletions":3,"changes":6,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/bffc69fd5518981ad384a4086dda4548e0ebcf4b/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Faudit%2FAuditManager.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/bffc69fd5518981ad384a4086dda4548e0ebcf4b/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Faudit%2FAuditManager.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Faudit%2FAuditManager.java?ref=bffc69fd5518981ad384a4086dda4548e0ebcf4b","patch":"@@ -18,13 +18,13 @@\n  */\n package org.apache.syncope.core.audit;\n \n+import org.apache.syncope.types.AuditElements.Category;\n+import org.apache.syncope.types.AuditElements.Result;\n+import org.apache.syncope.types.AuditLoggerName;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.springframework.security.core.context.SecurityContext;\n import org.springframework.security.core.context.SecurityContextHolder;\n-import org.apache.syncope.types.AuditLoggerName;\n-import org.apache.syncope.types.AuditElements.Category;\n-import org.apache.syncope.types.AuditElements.Result;\n \n public class AuditManager {\n "},{"sha":"33bf601ee6da0da907d7b47c1801afe9a5f9928e","filename":"core/src/main/java/org/apache/syncope/core/notification/NotificationManager.java","status":"modified","additions":0,"deletions":4,"changes":4,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/bffc69fd5518981ad384a4086dda4548e0ebcf4b/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fnotification%2FNotificationManager.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/bffc69fd5518981ad384a4086dda4548e0ebcf4b/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fnotification%2FNotificationManager.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fnotification%2FNotificationManager.java?ref=bffc69fd5518981ad384a4086dda4548e0ebcf4b","patch":"@@ -211,10 +211,6 @@ public void createTasks(final Long userId, final Set<String> performedTasks)\n         }\n     }\n \n-    public TaskExec execute(final NotificationTask task) {\n-        return notificationJob.executeSingle(task);\n-    }\n-\n     private String getRecipientEmail(\n             final IntMappingType recipientAttrType, final String recipientAttrName, final SyncopeUser user) {\n "},{"sha":"c36b2fd4a5d495d09697c05251c6be3d0093f464","filename":"core/src/main/java/org/apache/syncope/core/policy/AccountPolicyEnforcer.java","status":"modified","additions":11,"deletions":6,"changes":17,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/bffc69fd5518981ad384a4086dda4548e0ebcf4b/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpolicy%2FAccountPolicyEnforcer.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/bffc69fd5518981ad384a4086dda4548e0ebcf4b/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpolicy%2FAccountPolicyEnforcer.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpolicy%2FAccountPolicyEnforcer.java?ref=bffc69fd5518981ad384a4086dda4548e0ebcf4b","patch":"@@ -22,17 +22,18 @@\n import java.util.Map;\n import java.util.regex.Pattern;\n import org.apache.commons.collections.keyvalue.DefaultMapEntry;\n-import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.stereotype.Component;\n import org.apache.syncope.client.to.UserTO;\n import org.apache.syncope.core.persistence.beans.PropagationTask;\n import org.apache.syncope.core.persistence.beans.user.SyncopeUser;\n import org.apache.syncope.core.propagation.PropagationManager;\n+import org.apache.syncope.core.propagation.PropagationTaskExecutor;\n import org.apache.syncope.core.rest.data.UserDataBinder;\n import org.apache.syncope.core.workflow.UserWorkflowAdapter;\n import org.apache.syncope.core.workflow.WorkflowResult;\n import org.apache.syncope.types.AccountPolicySpec;\n import org.apache.syncope.types.PolicyType;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Component;\n \n @Component\n public class AccountPolicyEnforcer extends PolicyEnforcer<AccountPolicySpec, SyncopeUser> {\n@@ -43,6 +44,9 @@ public class AccountPolicyEnforcer extends PolicyEnforcer<AccountPolicySpec, Syn\n     @Autowired\n     private PropagationManager propagationManager;\n \n+    @Autowired\n+    private PropagationTaskExecutor taskExecutor;\n+\n     @Autowired\n     private UserDataBinder userDataBinder;\n \n@@ -116,11 +120,12 @@ public void enforce(final AccountPolicySpec policy, final PolicyType type, final\n \n                 // propagate suspension if and only if it is required by policy\n                 if (policy.isPropagateSuspension()) {\n-                    final List<PropagationTask> tasks = propagationManager\n-                            .getUpdateTaskIds(new WorkflowResult<Map.Entry<Long, Boolean>>(new DefaultMapEntry(updated\n-                                    .getResult(), Boolean.FALSE), updated.getPropByRes(), updated.getPerformedTasks()));\n+                    final List<PropagationTask> tasks = propagationManager.getUpdateTaskIds(\n+                            new WorkflowResult<Map.Entry<Long, Boolean>>(\n+                            new DefaultMapEntry(updated.getResult(), Boolean.FALSE),\n+                            updated.getPropByRes(), updated.getPerformedTasks()));\n \n-                    propagationManager.execute(tasks);\n+                    taskExecutor.execute(tasks);\n                 }\n \n                 if (LOG.isDebugEnabled()) {"},{"sha":"6ade3d73a8ceb941e93f55cc7a6869af4b3f4afc","filename":"core/src/main/java/org/apache/syncope/core/propagation/AbstractPropagationTaskExecutor.java","status":"added","additions":370,"deletions":0,"changes":370,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/bffc69fd5518981ad384a4086dda4548e0ebcf4b/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpropagation%2FAbstractPropagationTaskExecutor.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/bffc69fd5518981ad384a4086dda4548e0ebcf4b/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpropagation%2FAbstractPropagationTaskExecutor.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpropagation%2FAbstractPropagationTaskExecutor.java?ref=bffc69fd5518981ad384a4086dda4548e0ebcf4b","patch":"@@ -0,0 +1,370 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.core.propagation;\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashSet;\n+import java.util.Set;\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.syncope.core.init.ConnInstanceLoader;\n+import org.apache.syncope.core.persistence.beans.PropagationTask;\n+import org.apache.syncope.core.persistence.beans.TaskExec;\n+import org.apache.syncope.core.persistence.beans.user.SyncopeUser;\n+import org.apache.syncope.core.persistence.dao.TaskDAO;\n+import org.apache.syncope.core.persistence.dao.UserDAO;\n+import org.apache.syncope.core.util.NotFoundException;\n+import org.apache.syncope.types.PropagationMode;\n+import org.apache.syncope.types.PropagationTaskExecStatus;\n+import org.apache.syncope.types.TraceLevel;\n+import org.identityconnectors.framework.common.exceptions.ConnectorException;\n+import org.identityconnectors.framework.common.objects.Attribute;\n+import org.identityconnectors.framework.common.objects.AttributeBuilder;\n+import org.identityconnectors.framework.common.objects.AttributeUtil;\n+import org.identityconnectors.framework.common.objects.ConnectorObject;\n+import org.identityconnectors.framework.common.objects.Name;\n+import org.identityconnectors.framework.common.objects.ObjectClass;\n+import org.identityconnectors.framework.common.objects.Uid;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.NoSuchBeanDefinitionException;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+@Transactional(rollbackFor = {Throwable.class})\n+public abstract class AbstractPropagationTaskExecutor implements PropagationTaskExecutor {\n+\n+    /**\n+     * Logger.\n+     */\n+    protected static final Logger LOG = LoggerFactory.getLogger(AbstractPropagationTaskExecutor.class);\n+\n+    /**\n+     * Connector instance loader.\n+     */\n+    @Autowired\n+    protected ConnInstanceLoader connLoader;\n+\n+    /**\n+     * User DAO.\n+     */\n+    @Autowired\n+    protected UserDAO userDAO;\n+\n+    /**\n+     * Task DAO.\n+     */\n+    @Autowired\n+    protected TaskDAO taskDAO;\n+\n+    @Override\n+    public TaskExec execute(final PropagationTask task) {\n+        return execute(task, null);\n+    }\n+\n+    @Override\n+    public TaskExec execute(final PropagationTask task, final PropagationHandler handler) {\n+        final Date startDate = new Date();\n+\n+        TaskExec execution = new TaskExec();\n+        execution.setStatus(PropagationTaskExecStatus.CREATED.name());\n+\n+        String taskExecutionMessage = null;\n+\n+        // Flag to state whether any propagation has been attempted\n+        Set<String> propagationAttempted = new HashSet<String>();\n+\n+        ConnectorObject before = null;\n+        ConnectorObject after = null;\n+\n+        try {\n+            final ConnectorFacadeProxy connector = connLoader.getConnector(task.getResource());\n+            if (connector == null) {\n+                throw new NoSuchBeanDefinitionException(String.format(\n+                        \"Connector instance bean for resource %s not found\", task.getResource()));\n+            }\n+\n+            // Try to read user BEFORE any actual operation\n+            before = getRemoteObject(connector, task, false);\n+\n+            try {\n+                switch (task.getPropagationOperation()) {\n+                    case CREATE:\n+                    case UPDATE:\n+                        // set of attributes to be propagated\n+                        final Set<Attribute> attributes = new HashSet<Attribute>(task.getAttributes());\n+\n+                        if (before == null) {\n+                            // 1. get accountId\n+                            final String accountId = task.getAccountId();\n+\n+                            // 2. get name\n+                            final Name name = (Name) AttributeUtil.find(Name.NAME, attributes);\n+\n+                            // 3. check if:\n+                            //      * accountId is not blank;\n+                            //      * accountId is not equal to Name.\n+                            if (StringUtils.isNotBlank(accountId)\n+                                    && (name == null || !accountId.equals(name.getNameValue()))) {\n+\n+                                // 3.a retrieve uid\n+                                final Uid uid = (Uid) AttributeUtil.find(Uid.NAME, attributes);\n+\n+                                // 3.b add Uid if not provided\n+                                if (uid == null) {\n+                                    attributes.add(AttributeBuilder.build(Uid.NAME, Collections.singleton(accountId)));\n+                                }\n+                            }\n+\n+                            // 4. provision entry\n+                            connector.create(task.getPropagationMode(), ObjectClass.ACCOUNT, attributes, null,\n+                                    propagationAttempted);\n+                        } else {\n+\n+                            // 1. check if rename is really required\n+                            final Name newName = (Name) AttributeUtil.find(Name.NAME, attributes);\n+\n+                            LOG.debug(\"Rename required with value {}\", newName);\n+\n+                            if (newName != null && newName.equals(before.getName())\n+                                    && !before.getUid().getUidValue().equals(newName.getNameValue())) {\n+\n+                                LOG.debug(\"Remote object name unchanged\");\n+                                attributes.remove(newName);\n+                            }\n+\n+                            LOG.debug(\"Attributes to be replaced {}\", attributes);\n+\n+                            // 2. update with a new \"normalized\" attribute set\n+                            connector.update(task.getPropagationMode(), ObjectClass.ACCOUNT, before.getUid(),\n+                                    attributes, null, propagationAttempted);\n+                        }\n+                        break;\n+\n+                    case DELETE:\n+                        if (before == null) {\n+                            LOG.debug(\"{} not found on external resource: ignoring delete\", task.getAccountId());\n+                        } else {\n+                            /*\n+                             * We must choose here whether to\n+                             *  a. actually delete the provided user from the external resource\n+                             *  b. just update the provided user data onto the external resource\n+                             *\n+                             * (a) happens when either there is no user associated with the PropagationTask (this takes\n+                             * place when the task is generated via UserController.delete()) or the provided updated\n+                             * user hasn't the current resource assigned (when the task is generated via\n+                             * UserController.update()).\n+                             *\n+                             * (b) happens when the provided updated user does have the current resource assigned\n+                             * (when the task is generated via UserController.update()): this basically means that\n+                             * before such update, this user used to have the current resource assigned by more than\n+                             * one mean (for example, two different memberships with the same resource).\n+                             */\n+\n+                            SyncopeUser user = null;\n+                            if (task.getSyncopeUser() != null) {\n+                                try {\n+                                    user = getSyncopeUser(task.getSyncopeUser().getId());\n+                                } catch (NotFoundException e) {\n+                                    LOG.warn(\"Requesting to delete a non-existing user from {}\",\n+                                            task.getResource().getName(), e);\n+                                }\n+                            }\n+\n+                            if (user == null || !user.getResourceNames().contains(task.getResource().getName())) {\n+                                LOG.debug(\"Perform deprovisioning on {}\", task.getResource().getName());\n+\n+                                connector.delete(\n+                                        task.getPropagationMode(),\n+                                        ObjectClass.ACCOUNT,\n+                                        before.getUid(),\n+                                        null,\n+                                        propagationAttempted);\n+                            } else {\n+                                LOG.debug(\"Update remote object on {}\", task.getResource().getName());\n+\n+                                connector.update(\n+                                        task.getPropagationMode(),\n+                                        ObjectClass.ACCOUNT,\n+                                        before.getUid(),\n+                                        task.getAttributes(),\n+                                        null,\n+                                        propagationAttempted);\n+                            }\n+                        }\n+\n+                        break;\n+\n+                    default:\n+                }\n+\n+                execution.setStatus(task.getPropagationMode() == PropagationMode.ONE_PHASE\n+                        ? PropagationTaskExecStatus.SUCCESS.name()\n+                        : PropagationTaskExecStatus.SUBMITTED.name());\n+\n+                LOG.debug(\"Successfully propagated to {}\", task.getResource());\n+\n+                // Try to read user AFTER any actual operation\n+                after = getRemoteObject(connector, task, true);\n+            } catch (Exception e) {\n+                after = getRemoteObject(connector, task, false);\n+                throw e;\n+            }\n+        } catch (Exception e) {\n+            LOG.error(\"Exception during provision on resource \" + task.getResource().getName(), e);\n+\n+            if (e instanceof ConnectorException && e.getCause() != null) {\n+                taskExecutionMessage = e.getCause().getMessage();\n+            } else {\n+                StringWriter exceptionWriter = new StringWriter();\n+                exceptionWriter.write(e.getMessage() + \"\\n\\n\");\n+                e.printStackTrace(new PrintWriter(exceptionWriter));\n+                taskExecutionMessage = exceptionWriter.toString();\n+            }\n+\n+            try {\n+                execution.setStatus(task.getPropagationMode() == PropagationMode.ONE_PHASE\n+                        ? PropagationTaskExecStatus.FAILURE.name()\n+                        : PropagationTaskExecStatus.UNSUBMITTED.name());\n+            } catch (Exception wft) {\n+                LOG.error(\"While executing KO action on {}\", execution, wft);\n+            }\n+\n+            propagationAttempted.add(task.getPropagationOperation().name().toLowerCase());\n+        } finally {\n+            LOG.debug(\"Update execution for {}\", task);\n+\n+            execution.setStartDate(startDate);\n+            execution.setMessage(taskExecutionMessage);\n+            execution.setEndDate(new Date());\n+\n+            if (hasToBeregistered(task, execution)) {\n+                if (propagationAttempted.isEmpty()) {\n+                    LOG.debug(\"No propagation attempted for {}\", execution);\n+                } else {\n+                    execution.setTask(task);\n+                    task.addExec(execution);\n+\n+                    LOG.debug(\"Execution finished: {}\", execution);\n+                }\n+\n+                taskDAO.save(task);\n+\n+                // This flush call is needed to generate a value for the execution id\n+                // An alternative to this would be the following statement that might cause troubles with\n+                // concurrent calls.\n+                // taskExecDAO.findLatestStarted(task);\n+                taskDAO.flush();\n+            }\n+        }\n+\n+        if (handler != null) {\n+            handler.handle(\n+                    task.getResource().getName(),\n+                    PropagationTaskExecStatus.valueOf(execution.getStatus()),\n+                    before,\n+                    after);\n+        }\n+\n+        return execution;\n+    }\n+\n+    @Override\n+    public void execute(final Collection<PropagationTask> tasks) throws PropagationException {\n+        execute(tasks, null);\n+    }\n+\n+    @Override\n+    public abstract void execute(Collection<PropagationTask> tasks, PropagationHandler handler)\n+            throws PropagationException;\n+\n+    protected SyncopeUser getSyncopeUser(final Long userId)\n+            throws NotFoundException {\n+\n+        SyncopeUser user = userDAO.find(userId);\n+        if (user == null) {\n+            throw new NotFoundException(\"User \" + userId);\n+        }\n+\n+        return user;\n+    }\n+\n+    /**\n+     * Check whether an execution has to be stored, for a given task.\n+     *\n+     * @param task execution's task\n+     * @param execution to be decide whether to store or not\n+     * @return true if execution has to be store, false otherwise\n+     */\n+    protected boolean hasToBeregistered(final PropagationTask task, final TaskExec execution) {\n+\n+        boolean result;\n+\n+        final boolean failed = !PropagationTaskExecStatus.valueOf(execution.getStatus()).isSuccessful();\n+\n+        switch (task.getPropagationOperation()) {\n+\n+            case CREATE:\n+                result = (failed && task.getResource().getCreateTraceLevel().ordinal() >= TraceLevel.FAILURES.ordinal())\n+                        || task.getResource().getCreateTraceLevel() == TraceLevel.ALL;\n+                break;\n+\n+            case UPDATE:\n+                result = (failed && task.getResource().getUpdateTraceLevel().ordinal() >= TraceLevel.FAILURES.ordinal())\n+                        || task.getResource().getUpdateTraceLevel() == TraceLevel.ALL;\n+                break;\n+\n+            case DELETE:\n+                result = (failed && task.getResource().getDeleteTraceLevel().ordinal() >= TraceLevel.FAILURES.ordinal())\n+                        || task.getResource().getDeleteTraceLevel() == TraceLevel.ALL;\n+                break;\n+\n+            default:\n+                result = false;\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * Get remote object.\n+     *\n+     * @param connector connector facade proxy.\n+     * @param task current propagation task.\n+     * @param latest 'FALSE' to retrieve object using old accountId if not null.\n+     * @return remote connector object.\n+     */\n+    protected ConnectorObject getRemoteObject(final ConnectorFacadeProxy connector, final PropagationTask task,\n+            final boolean latest) {\n+        try {\n+\n+            return connector.getObject(task.getPropagationMode(), task.getPropagationOperation(), ObjectClass.ACCOUNT,\n+                    new Uid(latest || task.getOldAccountId() == null\n+                    ? task.getAccountId()\n+                    : task.getOldAccountId()), connector.getOperationOptions(task.getResource()));\n+\n+        } catch (RuntimeException ignore) {\n+            LOG.debug(\"Resolving username\", ignore);\n+            return null;\n+        }\n+    }\n+}"},{"sha":"6bfb63e8e1b536e9deef10a834d73c038c96e9f1","filename":"core/src/main/java/org/apache/syncope/core/propagation/PriorityPropagationTaskExecutor.java","status":"added","additions":75,"deletions":0,"changes":75,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/bffc69fd5518981ad384a4086dda4548e0ebcf4b/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpropagation%2FPriorityPropagationTaskExecutor.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/bffc69fd5518981ad384a4086dda4548e0ebcf4b/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpropagation%2FPriorityPropagationTaskExecutor.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpropagation%2FPriorityPropagationTaskExecutor.java?ref=bffc69fd5518981ad384a4086dda4548e0ebcf4b","patch":"@@ -0,0 +1,75 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.core.propagation;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import org.apache.syncope.core.persistence.beans.PropagationTask;\n+import org.apache.syncope.core.persistence.beans.TaskExec;\n+import org.apache.syncope.types.PropagationTaskExecStatus;\n+\n+public class PriorityPropagationTaskExecutor extends AbstractPropagationTaskExecutor {\n+\n+    /**\n+     * Sort the given collection by looking at related ExternalResource's priority, then execute.\n+     */\n+    @Override\n+    public void execute(final Collection<PropagationTask> tasks, final PropagationHandler handler)\n+            throws PropagationException {\n+\n+        final List<PropagationTask> prioritizedTasks = new ArrayList<PropagationTask>(tasks);\n+        Collections.sort(prioritizedTasks, new PriorityComparator());\n+\n+        for (PropagationTask task : prioritizedTasks) {\n+            LOG.debug(\"Execution started for {}\", task);\n+\n+            TaskExec execution = execute(task, handler);\n+\n+            LOG.debug(\"Execution finished for {}, {}\", task, execution);\n+\n+            // Propagation is interrupted as soon as the result of the\n+            // communication with a primary resource is in error\n+            PropagationTaskExecStatus execStatus;\n+            try {\n+                execStatus = PropagationTaskExecStatus.valueOf(execution.getStatus());\n+            } catch (IllegalArgumentException e) {\n+                LOG.error(\"Unexpected execution status found {}\", execution.getStatus());\n+                execStatus = PropagationTaskExecStatus.FAILURE;\n+            }\n+            if (task.getResource().isPropagationPrimary() && !execStatus.isSuccessful()) {\n+                throw new PropagationException(task.getResource().getName(), execution.getMessage());\n+            }\n+        }\n+    }\n+\n+    protected static class PriorityComparator implements Comparator<PropagationTask> {\n+\n+        @Override\n+        public int compare(final PropagationTask task1, final PropagationTask task2) {\n+            return task1.getResource().getPropagationPriority() > task2.getResource().getPropagationPriority()\n+                    ? -1\n+                    : task1.getResource().getPropagationPriority() == task2.getResource().getPropagationPriority()\n+                    ? 0\n+                    : 1;\n+        }\n+    }\n+}"},{"sha":"2c151f54b6a49c0e0e201be7693502659fc9d154","filename":"core/src/main/java/org/apache/syncope/core/propagation/PropagationManager.java","status":"modified","additions":11,"deletions":356,"changes":367,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/bffc69fd5518981ad384a4086dda4548e0ebcf4b/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpropagation%2FPropagationManager.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/bffc69fd5518981ad384a4086dda4548e0ebcf4b/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpropagation%2FPropagationManager.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpropagation%2FPropagationManager.java?ref=bffc69fd5518981ad384a4086dda4548e0ebcf4b","patch":"@@ -18,11 +18,8 @@\n  */\n package org.apache.syncope.core.propagation;\n \n-import java.io.PrintWriter;\n-import java.io.StringWriter;\n import java.util.ArrayList;\n import java.util.Collections;\n-import java.util.Date;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n@@ -34,19 +31,16 @@\n import org.apache.commons.lang.StringUtils;\n import org.apache.syncope.client.mod.AttributeMod;\n import org.apache.syncope.client.to.AttributeTO;\n-import org.apache.syncope.core.init.ConnInstanceLoader;\n import org.apache.syncope.core.persistence.beans.AbstractAttrValue;\n import org.apache.syncope.core.persistence.beans.AbstractAttributable;\n import org.apache.syncope.core.persistence.beans.AbstractSchema;\n import org.apache.syncope.core.persistence.beans.ExternalResource;\n import org.apache.syncope.core.persistence.beans.PropagationTask;\n import org.apache.syncope.core.persistence.beans.SchemaMapping;\n-import org.apache.syncope.core.persistence.beans.TaskExec;\n import org.apache.syncope.core.persistence.beans.membership.Membership;\n import org.apache.syncope.core.persistence.beans.user.SyncopeUser;\n import org.apache.syncope.core.persistence.dao.ResourceDAO;\n import org.apache.syncope.core.persistence.dao.SchemaDAO;\n-import org.apache.syncope.core.persistence.dao.TaskDAO;\n import org.apache.syncope.core.persistence.dao.UserDAO;\n import org.apache.syncope.core.rest.data.UserDataBinder;\n import org.apache.syncope.core.util.AttributableUtil;\n@@ -56,23 +50,15 @@\n import org.apache.syncope.core.workflow.WorkflowResult;\n import org.apache.syncope.types.AttributableType;\n import org.apache.syncope.types.IntMappingType;\n-import org.apache.syncope.types.PropagationMode;\n import org.apache.syncope.types.PropagationOperation;\n-import org.apache.syncope.types.PropagationTaskExecStatus;\n import org.apache.syncope.types.SchemaType;\n-import org.apache.syncope.types.TraceLevel;\n import org.identityconnectors.framework.common.FrameworkUtil;\n-import org.identityconnectors.framework.common.exceptions.ConnectorException;\n import org.identityconnectors.framework.common.objects.Attribute;\n import org.identityconnectors.framework.common.objects.AttributeBuilder;\n import org.identityconnectors.framework.common.objects.AttributeUtil;\n-import org.identityconnectors.framework.common.objects.ConnectorObject;\n import org.identityconnectors.framework.common.objects.Name;\n-import org.identityconnectors.framework.common.objects.ObjectClass;\n-import org.identityconnectors.framework.common.objects.Uid;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n-import org.springframework.beans.factory.NoSuchBeanDefinitionException;\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.transaction.annotation.Transactional;\n \n@@ -87,12 +73,6 @@ public class PropagationManager {\n      */\n     protected static final Logger LOG = LoggerFactory.getLogger(PropagationManager.class);\n \n-    /**\n-     * Connector instance loader.\n-     */\n-    @Autowired\n-    private ConnInstanceLoader connLoader;\n-\n     /**\n      * User DataBinder.\n      */\n@@ -117,19 +97,13 @@ public class PropagationManager {\n     @Autowired\n     private SchemaDAO schemaDAO;\n \n-    /**\n-     * Task DAO.\n-     */\n-    @Autowired\n-    private TaskDAO taskDAO;\n-\n     /**\n      * JEXL engine for evaluating connector's account link.\n      */\n     @Autowired\n     private JexlUtil jexlUtil;\n \n-    private SyncopeUser getSyncopeUser(final Long userId)\n+    protected SyncopeUser getSyncopeUser(final Long userId)\n             throws NotFoundException {\n \n         SyncopeUser user = userDAO.find(userId);\n@@ -184,7 +158,7 @@ public List<PropagationTask> getCreateTaskIds(final WorkflowResult<Map.Entry<Lon\n             propByRes.get(PropagationOperation.CREATE).removeAll(syncResourceNames);\n         }\n \n-        return provision(user, password, wfResult.getResult().getValue(), false, propByRes);\n+        return createTasks(user, password, wfResult.getResult().getValue(), false, propByRes);\n     }\n \n     /**\n@@ -286,7 +260,7 @@ private List<PropagationTask> getUpdateTaskIds(final SyncopeUser user, final Pro\n             localPropByRes.get(PropagationOperation.DELETE).removeAll(syncResourceNames);\n         }\n \n-        return provision(user, password, enable, false, localPropByRes);\n+        return createTasks(user, password, enable, false, localPropByRes);\n     }\n \n     /**\n@@ -325,7 +299,7 @@ public List<PropagationTask> getDeleteTaskIds(final Long userId, final String sy\n             propByRes.get(PropagationOperation.DELETE).remove(syncResourceName);\n         }\n \n-        return provision(user, null, false, true, propByRes);\n+        return createTasks(user, null, false, true, propByRes);\n     }\n \n     /**\n@@ -495,7 +469,7 @@ private Map.Entry<String, Set<Attribute>> prepareAttributes(final SyncopeUser us\n     }\n \n     /**\n-     * Implementation of the provisioning feature.\n+     * Create propagation tasks.\n      *\n      * @param user user to be provisioned\n      * @param password cleartext password to be provisioned\n@@ -504,7 +478,7 @@ private Map.Entry<String, Set<Attribute>> prepareAttributes(final SyncopeUser us\n      * @param propByRes operation to be performed per resource\n      * @return list of propagation tasks created\n      */\n-    protected List<PropagationTask> provision(final SyncopeUser user, final String password, final Boolean enable,\n+    protected List<PropagationTask> createTasks(final SyncopeUser user, final String password, final Boolean enable,\n             final boolean deleteOnResource, final PropagationByResource propByRes) {\n \n         LOG.debug(\"Provisioning with user {}:\\n{}\", user, propByRes);\n@@ -515,10 +489,12 @@ protected List<PropagationTask> provision(final SyncopeUser user, final String p\n \n         final List<PropagationTask> tasks = new ArrayList<PropagationTask>();\n \n-        final List<ExternalResource> allResByPriority = resourceDAO.findAllByPriority();\n         for (PropagationOperation operation : PropagationOperation.values()) {\n-            for (ExternalResource resource : allResByPriority) {\n-                if (propByRes.get(operation).contains(resource.getName())) {\n+            for (String resourceName : propByRes.get(operation)) {\n+                final ExternalResource resource = resourceDAO.find(resourceName);\n+                if (resource == null) {\n+                    LOG.error(\"Invalid resource name specified: {}, ignoring...\", resourceName);\n+                } else {\n                     PropagationTask task = new PropagationTask();\n                     task.setResource(resource);\n                     if (!deleteOnResource) {\n@@ -542,325 +518,4 @@ protected List<PropagationTask> provision(final SyncopeUser user, final String p\n \n         return tasks;\n     }\n-\n-    public void execute(final List<PropagationTask> tasks)\n-            throws PropagationException {\n-        execute(tasks, null);\n-    }\n-\n-    /**\n-     * Execute a list of PropagationTask, in given order.\n-     *\n-     * @param tasks to be execute, in given order\n-     * @param handler propagation handler\n-     * @throws PropagationException if propagation goes wrong: propagation is interrupted as soon as the result of the\n-     * communication with a primary resource is in error\n-     */\n-    public void execute(final List<PropagationTask> tasks, final PropagationHandler handler)\n-            throws PropagationException {\n-\n-        for (PropagationTask task : tasks) {\n-            LOG.debug(\"Execution started for {}\", task);\n-\n-            TaskExec execution = execute(task, handler);\n-\n-            LOG.debug(\"Execution finished for {}, {}\", task, execution);\n-\n-            // Propagation is interrupted as soon as the result of the\n-            // communication with a primary resource is in error\n-            PropagationTaskExecStatus execStatus;\n-            try {\n-                execStatus = PropagationTaskExecStatus.valueOf(execution.getStatus());\n-            } catch (IllegalArgumentException e) {\n-                LOG.error(\"Unexpected execution status found {}\", execution.getStatus());\n-                execStatus = PropagationTaskExecStatus.FAILURE;\n-            }\n-            if (task.getResource().isPropagationPrimary() && !execStatus.isSuccessful()) {\n-                throw new PropagationException(task.getResource().getName(), execution.getMessage());\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Check whether an execution has to be stored, for a given task.\n-     *\n-     * @param task execution's task\n-     * @param execution to be decide whether to store or not\n-     * @return true if execution has to be store, false otherwise\n-     */\n-    private boolean hasToBeregistered(final PropagationTask task, final TaskExec execution) {\n-\n-        boolean result;\n-\n-        final boolean failed = !PropagationTaskExecStatus.valueOf(execution.getStatus()).isSuccessful();\n-\n-        switch (task.getPropagationOperation()) {\n-\n-            case CREATE:\n-                result = (failed && task.getResource().getCreateTraceLevel().ordinal() >= TraceLevel.FAILURES.ordinal())\n-                        || task.getResource().getCreateTraceLevel() == TraceLevel.ALL;\n-                break;\n-\n-            case UPDATE:\n-                result = (failed && task.getResource().getUpdateTraceLevel().ordinal() >= TraceLevel.FAILURES.ordinal())\n-                        || task.getResource().getUpdateTraceLevel() == TraceLevel.ALL;\n-                break;\n-\n-            case DELETE:\n-                result = (failed && task.getResource().getDeleteTraceLevel().ordinal() >= TraceLevel.FAILURES.ordinal())\n-                        || task.getResource().getDeleteTraceLevel() == TraceLevel.ALL;\n-                break;\n-\n-            default:\n-                result = false;\n-        }\n-\n-        return result;\n-    }\n-\n-    /**\n-     * Execute a propagation task.\n-     *\n-     * @param task to execute\n-     * @return TaskExecution\n-     */\n-    public TaskExec execute(final PropagationTask task) {\n-        return execute(task, null);\n-    }\n-\n-    /**\n-     * Execute a propagation task.\n-     *\n-     * @param task to execute.\n-     * @param handler propagation handler.\n-     * @return TaskExecution.\n-     */\n-    public TaskExec execute(final PropagationTask task, final PropagationHandler handler) {\n-        final Date startDate = new Date();\n-\n-        TaskExec execution = new TaskExec();\n-        execution.setStatus(PropagationTaskExecStatus.CREATED.name());\n-\n-        String taskExecutionMessage = null;\n-\n-        // Flag to state whether any propagation has been attempted\n-        Set<String> propagationAttempted = new HashSet<String>();\n-\n-        ConnectorObject before = null;\n-        ConnectorObject after = null;\n-\n-        try {\n-            final ConnectorFacadeProxy connector = connLoader.getConnector(task.getResource());\n-            if (connector == null) {\n-                throw new NoSuchBeanDefinitionException(String.format(\n-                        \"Connector instance bean for resource %s not found\", task.getResource()));\n-            }\n-\n-            // Try to read user BEFORE any actual operation\n-            before = getRemoteObject(connector, task, false);\n-\n-            try {\n-                switch (task.getPropagationOperation()) {\n-                    case CREATE:\n-                    case UPDATE:\n-                        // set of attributes to be propagated\n-                        final Set<Attribute> attributes = new HashSet<Attribute>(task.getAttributes());\n-\n-                        if (before == null) {\n-                            // 1. get accountId\n-                            final String accountId = task.getAccountId();\n-\n-                            // 2. get name\n-                            final Name name = (Name) AttributeUtil.find(Name.NAME, attributes);\n-\n-                            // 3. check if:\n-                            //      * accountId is not blank;\n-                            //      * accountId is not equal to Name.\n-                            if (StringUtils.isNotBlank(accountId)\n-                                    && (name == null || !accountId.equals(name.getNameValue()))) {\n-\n-                                // 3.a retrieve uid\n-                                final Uid uid = (Uid) AttributeUtil.find(Uid.NAME, attributes);\n-\n-                                // 3.b add Uid if not provided\n-                                if (uid == null) {\n-                                    attributes.add(AttributeBuilder.build(Uid.NAME, Collections.singleton(accountId)));\n-                                }\n-                            }\n-\n-                            // 4. provision entry\n-                            connector.create(task.getPropagationMode(), ObjectClass.ACCOUNT, attributes, null,\n-                                    propagationAttempted);\n-                        } else {\n-\n-                            // 1. check if rename is really required\n-                            final Name newName = (Name) AttributeUtil.find(Name.NAME, attributes);\n-\n-                            LOG.debug(\"Rename required with value {}\", newName);\n-\n-                            if (newName != null && newName.equals(before.getName())\n-                                    && !before.getUid().getUidValue().equals(newName.getNameValue())) {\n-\n-                                LOG.debug(\"Remote object name unchanged\");\n-                                attributes.remove(newName);\n-                            }\n-\n-                            LOG.debug(\"Attributes to be replaced {}\", attributes);\n-\n-                            // 2. update with a new \"normalized\" attribute set\n-                            connector.update(task.getPropagationMode(), ObjectClass.ACCOUNT, before.getUid(),\n-                                    attributes, null, propagationAttempted);\n-                        }\n-                        break;\n-\n-                    case DELETE:\n-                        if (before == null) {\n-                            LOG.debug(\"{} not found on external resource: ignoring delete\", task.getAccountId());\n-                        } else {\n-                            /*\n-                             * We must choose here whether to\n-                             *  a. actually delete the provided user from the external resource\n-                             *  b. just update the provided user data onto the external resource\n-                             *\n-                             * (a) happens when either there is no user associated with the PropagationTask (this takes\n-                             * place when the task is generated via UserController.delete()) or the provided updated\n-                             * user hasn't the current resource assigned (when the task is generated via\n-                             * UserController.update()).\n-                             *\n-                             * (b) happens when the provided updated user does have the current resource assigned\n-                             * (when the task is generated via UserController.update()): this basically means that\n-                             * before such update, this user used to have the current resource assigned by more than\n-                             * one mean (for example, two different memberships with the same resource).\n-                             */\n-\n-                            SyncopeUser user = null;\n-                            if (task.getSyncopeUser() != null) {\n-                                try {\n-                                    user = getSyncopeUser(task.getSyncopeUser().getId());\n-                                } catch (NotFoundException e) {\n-                                    LOG.warn(\"Requesting to delete a non-existing user from {}\",\n-                                            task.getResource().getName(), e);\n-                                }\n-                            }\n-\n-                            if (user == null || !user.getResourceNames().contains(task.getResource().getName())) {\n-                                LOG.debug(\"Perform deprovisioning on {}\", task.getResource().getName());\n-\n-                                connector.delete(\n-                                        task.getPropagationMode(),\n-                                        ObjectClass.ACCOUNT,\n-                                        before.getUid(),\n-                                        null,\n-                                        propagationAttempted);\n-                            } else {\n-                                LOG.debug(\"Update remote object on {}\", task.getResource().getName());\n-\n-                                connector.update(\n-                                        task.getPropagationMode(),\n-                                        ObjectClass.ACCOUNT,\n-                                        before.getUid(),\n-                                        task.getAttributes(),\n-                                        null,\n-                                        propagationAttempted);\n-                            }\n-                        }\n-\n-                        break;\n-\n-                    default:\n-                }\n-\n-                execution.setStatus(task.getPropagationMode() == PropagationMode.ONE_PHASE\n-                        ? PropagationTaskExecStatus.SUCCESS.name()\n-                        : PropagationTaskExecStatus.SUBMITTED.name());\n-\n-                LOG.debug(\"Successfully propagated to {}\", task.getResource());\n-\n-                // Try to read user AFTER any actual operation\n-                after = getRemoteObject(connector, task, true);\n-            } catch (Exception e) {\n-                after = getRemoteObject(connector, task, false);\n-                throw e;\n-            }\n-        } catch (Exception e) {\n-            LOG.error(\"Exception during provision on resource \" + task.getResource().getName(), e);\n-\n-            if (e instanceof ConnectorException && e.getCause() != null) {\n-                taskExecutionMessage = e.getCause().getMessage();\n-            } else {\n-                StringWriter exceptionWriter = new StringWriter();\n-                exceptionWriter.write(e.getMessage() + \"\\n\\n\");\n-                e.printStackTrace(new PrintWriter(exceptionWriter));\n-                taskExecutionMessage = exceptionWriter.toString();\n-            }\n-\n-            try {\n-                execution.setStatus(task.getPropagationMode() == PropagationMode.ONE_PHASE\n-                        ? PropagationTaskExecStatus.FAILURE.name()\n-                        : PropagationTaskExecStatus.UNSUBMITTED.name());\n-            } catch (Exception wft) {\n-                LOG.error(\"While executing KO action on {}\", execution, wft);\n-            }\n-\n-            propagationAttempted.add(task.getPropagationOperation().name().toLowerCase());\n-        } finally {\n-            LOG.debug(\"Update execution for {}\", task);\n-\n-            execution.setStartDate(startDate);\n-            execution.setMessage(taskExecutionMessage);\n-            execution.setEndDate(new Date());\n-\n-            if (hasToBeregistered(task, execution)) {\n-                if (propagationAttempted.isEmpty()) {\n-                    LOG.debug(\"No propagation attempted for {}\", execution);\n-                } else {\n-                    execution.setTask(task);\n-                    task.addExec(execution);\n-\n-                    LOG.debug(\"Execution finished: {}\", execution);\n-                }\n-\n-                taskDAO.save(task);\n-\n-                // This flush call is needed to generate a value for the execution id\n-                // An alternative to this would be the following statement that might cause troubles with\n-                // concurrent calls.\n-                // taskExecDAO.findLatestStarted(task);\n-                taskDAO.flush();\n-            }\n-        }\n-\n-        if (handler != null) {\n-            handler.handle(\n-                    task.getResource().getName(),\n-                    PropagationTaskExecStatus.valueOf(execution.getStatus()),\n-                    before,\n-                    after);\n-        }\n-\n-        return execution;\n-    }\n-\n-    /**\n-     * Get remote object.\n-     *\n-     * @param connector connector facade proxy.\n-     * @param task current propagation task.\n-     * @param latest 'FALSE' to retrieve object using old accountId if not null.\n-     * @return remote connector object.\n-     */\n-    private ConnectorObject getRemoteObject(final ConnectorFacadeProxy connector, final PropagationTask task,\n-            final boolean latest) {\n-        try {\n-\n-            return connector.getObject(task.getPropagationMode(), task.getPropagationOperation(), ObjectClass.ACCOUNT,\n-                    new Uid(latest || task.getOldAccountId() == null\n-                    ? task.getAccountId()\n-                    : task.getOldAccountId()), connector.getOperationOptions(task.getResource()));\n-\n-        } catch (RuntimeException ignore) {\n-            LOG.debug(\"Resolving username\", ignore);\n-            return null;\n-        }\n-    }\n }"},{"sha":"18ef02b96e8f1f253eb0d17de92a9994e98a1c0d","filename":"core/src/main/java/org/apache/syncope/core/propagation/PropagationTaskExecutor.java","status":"added","additions":62,"deletions":0,"changes":62,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/bffc69fd5518981ad384a4086dda4548e0ebcf4b/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpropagation%2FPropagationTaskExecutor.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/bffc69fd5518981ad384a4086dda4548e0ebcf4b/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpropagation%2FPropagationTaskExecutor.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpropagation%2FPropagationTaskExecutor.java?ref=bffc69fd5518981ad384a4086dda4548e0ebcf4b","patch":"@@ -0,0 +1,62 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.core.propagation;\n+\n+import java.util.Collection;\n+import org.apache.syncope.core.persistence.beans.PropagationTask;\n+import org.apache.syncope.core.persistence.beans.TaskExec;\n+\n+public interface PropagationTaskExecutor {\n+\n+    /**\n+     * Execute the given PropagationTask and returns the generated TaskExec.\n+     *\n+     * @param task to be executed\n+     * @return the generated TaskExec\n+     */\n+    TaskExec execute(PropagationTask task);\n+\n+    /**\n+     * Execute the given PropagationTask, invoke the given handler and returns the generated TaskExec.\n+     *\n+     * @param task to be executed\n+     * @param handler to be invoked\n+     * @return the generated TaskExec\n+     */\n+    TaskExec execute(PropagationTask task, PropagationHandler handler);\n+\n+    /**\n+     * Execute a collection of PropagationTask objects.\n+     *\n+     * @param tasks to be executed\n+     * @throws PropagationException if propagation goes wrong: propagation is interrupted as soon as the result of the\n+     * communication with a primary resource is in error\n+     */\n+    void execute(Collection<PropagationTask> tasks) throws PropagationException;\n+\n+    /**\n+     * Execute a collection of PropagationTask objects and invoke the given handler on each of these.\n+     *\n+     * @param tasks to be execute, in given order\n+     * @param handler propagation handler\n+     * @throws PropagationException if propagation goes wrong: propagation is interrupted as soon as the result of the\n+     * communication with a primary resource is in error\n+     */\n+    void execute(Collection<PropagationTask> tasks, PropagationHandler handler) throws PropagationException;\n+}"},{"sha":"0152088b8c0e02cc3e28a6b37705834b857e7ee5","filename":"core/src/main/java/org/apache/syncope/core/rest/controller/TaskController.java","status":"modified","additions":6,"deletions":6,"changes":12,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/bffc69fd5518981ad384a4086dda4548e0ebcf4b/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Frest%2Fcontroller%2FTaskController.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/bffc69fd5518981ad384a4086dda4548e0ebcf4b/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Frest%2Fcontroller%2FTaskController.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Frest%2Fcontroller%2FTaskController.java?ref=bffc69fd5518981ad384a4086dda4548e0ebcf4b","patch":"@@ -32,17 +32,17 @@\n import org.apache.syncope.core.audit.AuditManager;\n import org.apache.syncope.core.init.ImplementationClassNamesLoader;\n import org.apache.syncope.core.init.JobInstanceLoader;\n-import org.apache.syncope.core.notification.NotificationManager;\n import org.apache.syncope.core.persistence.beans.NotificationTask;\n import org.apache.syncope.core.persistence.beans.PropagationTask;\n import org.apache.syncope.core.persistence.beans.SchedTask;\n import org.apache.syncope.core.persistence.beans.Task;\n import org.apache.syncope.core.persistence.beans.TaskExec;\n import org.apache.syncope.core.persistence.dao.TaskDAO;\n import org.apache.syncope.core.persistence.dao.TaskExecDAO;\n-import org.apache.syncope.core.propagation.PropagationManager;\n+import org.apache.syncope.core.propagation.PropagationTaskExecutor;\n import org.apache.syncope.core.rest.data.TaskDataBinder;\n import org.apache.syncope.core.scheduling.AbstractTaskJob;\n+import org.apache.syncope.core.scheduling.NotificationJob;\n import org.apache.syncope.core.util.NotFoundException;\n import org.apache.syncope.core.util.TaskUtil;\n import org.apache.syncope.types.AuditElements.Category;\n@@ -83,10 +83,10 @@ public class TaskController extends AbstractController {\n     private TaskDataBinder binder;\n \n     @Autowired\n-    private PropagationManager propagationManager;\n+    private PropagationTaskExecutor taskExecutor;\n \n     @Autowired\n-    private NotificationManager notificationManager;\n+    private NotificationJob notificationJob;\n \n     @Autowired\n     private JobInstanceLoader jobInstanceLoader;\n@@ -306,12 +306,12 @@ public TaskExecTO execute(@PathVariable(\"taskId\") final Long taskId,\n         LOG.debug(\"Execution started for {}\", task);\n         switch (taskUtil) {\n             case PROPAGATION:\n-                final TaskExec propExec = propagationManager.execute((PropagationTask) task);\n+                final TaskExec propExec = taskExecutor.execute((PropagationTask) task);\n                 result = binder.getTaskExecTO(propExec);\n                 break;\n \n             case NOTIFICATION:\n-                final TaskExec notExec = notificationManager.execute((NotificationTask) task);\n+                final TaskExec notExec = notificationJob.executeSingle((NotificationTask) task);\n                 result = binder.getTaskExecTO(notExec);\n                 break;\n "},{"sha":"901b1a0f664c84a22a49427b90b6a02072704cb3","filename":"core/src/main/java/org/apache/syncope/core/rest/controller/UserController.java","status":"modified","additions":13,"deletions":9,"changes":22,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/bffc69fd5518981ad384a4086dda4548e0ebcf4b/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Frest%2Fcontroller%2FUserController.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/bffc69fd5518981ad384a4086dda4548e0ebcf4b/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Frest%2Fcontroller%2FUserController.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Frest%2Fcontroller%2FUserController.java?ref=bffc69fd5518981ad384a4086dda4548e0ebcf4b","patch":"@@ -41,6 +41,7 @@\n import org.apache.syncope.core.propagation.PropagationException;\n import org.apache.syncope.core.propagation.PropagationHandler;\n import org.apache.syncope.core.propagation.PropagationManager;\n+import org.apache.syncope.core.propagation.PropagationTaskExecutor;\n import org.apache.syncope.core.rest.data.UserDataBinder;\n import org.apache.syncope.core.util.ConnObjectUtil;\n import org.apache.syncope.core.util.EntitlementUtil;\n@@ -100,6 +101,9 @@ public class UserController {\n     @Autowired\n     private PropagationManager propagationManager;\n \n+    @Autowired\n+    private PropagationTaskExecutor taskExecutor;\n+\n     @Autowired\n     private NotificationManager notificationManager;\n \n@@ -292,7 +296,7 @@ public UserTO create(final HttpServletResponse response, @RequestBody final User\n \n         final List<PropagationTO> propagations = new ArrayList<PropagationTO>();\n \n-        propagationManager.execute(tasks, new PropagationHandler() {\n+        taskExecutor.execute(tasks, new PropagationHandler() {\n \n             @Override\n             public void handle(final String resourceName, final PropagationTaskExecStatus executionStatus,\n@@ -342,7 +346,7 @@ public UserTO update(@RequestBody final UserMod userMod)\n \n         final List<PropagationTO> propagations = new ArrayList<PropagationTO>();\n \n-        propagationManager.execute(tasks, new PropagationHandler() {\n+        taskExecutor.execute(tasks, new PropagationHandler() {\n \n             @Override\n             public void handle(final String resourceName, final PropagationTaskExecStatus executionStatus,\n@@ -502,7 +506,7 @@ public UserTO delete(@PathVariable(\"userId\") final Long userId)\n             throws NotFoundException, WorkflowException, PropagationException, UnauthorizedRoleException {\n         LOG.debug(\"User delete called with {}\", userId);\n \n-        return deleteByUserId(userId);\n+        return doDelete(userId);\n     }\n \n     @PreAuthorize(\"hasRole('USER_DELETE')\")\n@@ -514,7 +518,7 @@ public UserTO delete(@PathVariable final String username)\n         UserTO result = userDataBinder.getUserTO(username);\n         long userId = result.getId();\n \n-        return deleteByUserId(userId);\n+        return doDelete(userId);\n     }\n \n     @PreAuthorize(\"hasRole('USER_UPDATE')\")\n@@ -529,7 +533,7 @@ public UserTO executeWorkflow(@RequestBody final UserTO userTO, @PathVariable(\"t\n         List<PropagationTask> tasks = propagationManager.getUpdateTaskIds(new WorkflowResult<Map.Entry<Long, Boolean>>(\n                 new DefaultMapEntry(updated.getResult(), null), updated.getPropByRes(), updated.getPerformedTasks()));\n \n-        propagationManager.execute(tasks);\n+        taskExecutor.execute(tasks);\n \n         notificationManager.createTasks(updated.getResult(), updated.getPerformedTasks());\n \n@@ -599,7 +603,7 @@ public UserTO submitForm(@RequestBody final WorkflowFormTO form)\n         List<PropagationTask> tasks = propagationManager.getUpdateTaskIds(new WorkflowResult<Map.Entry<Long, Boolean>>(\n                 new DefaultMapEntry(updated.getResult().getKey(), Boolean.TRUE), updated.getPropByRes(), updated.\n                 getPerformedTasks()), updated.getResult().getValue(), null, null);\n-        propagationManager.execute(tasks);\n+        taskExecutor.execute(tasks);\n \n         final UserTO savedTO = userDataBinder.getUserTO(updated.getResult().getKey());\n \n@@ -643,7 +647,7 @@ private UserTO setStatus(final SyncopeUser user, final String token, final Set<S\n \n         List<PropagationTask> tasks = propagationManager.getUpdateTaskIds(user, status, resources);\n \n-        propagationManager.execute(tasks);\n+        taskExecutor.execute(tasks);\n         notificationManager.createTasks(updated.getResult(), updated.getPerformedTasks());\n \n         final UserTO savedTO = userDataBinder.getUserTO(updated.getResult());\n@@ -656,7 +660,7 @@ private UserTO setStatus(final SyncopeUser user, final String token, final Set<S\n         return savedTO;\n     }\n \n-    private UserTO deleteByUserId(final Long userId)\n+    protected UserTO doDelete(final Long userId)\n             throws NotFoundException, WorkflowException, PropagationException, UnauthorizedRoleException {\n         // Note here that we can only notify about \"delete\", not any other\n         // task defined in workflow process definition: this because this\n@@ -670,7 +674,7 @@ private UserTO deleteByUserId(final Long userId)\n         final UserTO userTO = new UserTO();\n         userTO.setId(userId);\n \n-        propagationManager.execute(tasks, new PropagationHandler() {\n+        taskExecutor.execute(tasks, new PropagationHandler() {\n \n             @Override\n             public void handle(final String resourceName, final PropagationTaskExecStatus executionStatus,"},{"sha":"1b2808c64ffa38311e24f4133f3523c984b0be43","filename":"core/src/main/java/org/apache/syncope/core/scheduling/SyncJob.java","status":"modified","additions":10,"deletions":4,"changes":14,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/bffc69fd5518981ad384a4086dda4548e0ebcf4b/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fscheduling%2FSyncJob.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/bffc69fd5518981ad384a4086dda4548e0ebcf4b/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fscheduling%2FSyncJob.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fscheduling%2FSyncJob.java?ref=bffc69fd5518981ad384a4086dda4548e0ebcf4b","patch":"@@ -47,6 +47,7 @@\n import org.apache.syncope.core.propagation.ConnectorFacadeProxy;\n import org.apache.syncope.core.propagation.PropagationException;\n import org.apache.syncope.core.propagation.PropagationManager;\n+import org.apache.syncope.core.propagation.PropagationTaskExecutor;\n import org.apache.syncope.core.rest.controller.InvalidSearchConditionException;\n import org.apache.syncope.core.rest.controller.UnauthorizedRoleException;\n import org.apache.syncope.core.rest.data.UserDataBinder;\n@@ -125,6 +126,12 @@ public class SyncJob extends AbstractTaskJob {\n     @Autowired\n     private PropagationManager propagationManager;\n \n+    /**\n+     * PropagationTask executor.\n+     */\n+    @Autowired\n+    private PropagationTaskExecutor taskExecutor;\n+\n     /**\n      * User data binder.\n      */\n@@ -322,7 +329,7 @@ private List<SyncResult> createUser(SyncDelta delta, final boolean dryRun) throw\n                 List<PropagationTask> tasks = propagationManager.getCreateTaskIds(created, userTO.getPassword(), userTO\n                         .getVirtualAttributes(), Collections.singleton(((SyncTask) this.task).getResource().getName()));\n \n-                propagationManager.execute(tasks);\n+                taskExecutor.execute(tasks);\n \n                 notificationManager.createTasks(created.getResult().getKey(), created.getPerformedTasks());\n \n@@ -379,7 +386,7 @@ private List<SyncResult> updateUsers(SyncDelta delta, final List<Long> users, fi\n                                 .getVirtualAttributesToBeUpdated(), Collections.singleton(((SyncTask) this.task)\n                                 .getResource().getName()));\n \n-                        propagationManager.execute(tasks);\n+                        taskExecutor.execute(tasks);\n \n                         notificationManager.createTasks(updated.getResult().getKey(), updated.getPerformedTasks());\n \n@@ -432,10 +439,9 @@ private List<SyncResult> deleteUsers(SyncDelta delta, final List<Long> users, fi\n                     try {\n                         List<PropagationTask> tasks = propagationManager.getDeleteTaskIds(userId,\n                                 ((SyncTask) this.task).getResource().getName());\n-                        propagationManager.execute(tasks);\n+                        taskExecutor.execute(tasks);\n \n                         notificationManager.createTasks(userId, Collections.singleton(\"delete\"));\n-\n                     } catch (Exception e) {\n                         LOG.error(\"Could not propagate user \" + userId, e);\n                     }"},{"sha":"944c4ede7a7e7f152cf1a8d19538f3d71bcd941a","filename":"core/src/main/resources/syncopeContext.xml","status":"modified","additions":3,"deletions":1,"changes":4,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/bffc69fd5518981ad384a4086dda4548e0ebcf4b/core%2Fsrc%2Fmain%2Fresources%2FsyncopeContext.xml","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/bffc69fd5518981ad384a4086dda4548e0ebcf4b/core%2Fsrc%2Fmain%2Fresources%2FsyncopeContext.xml","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fresources%2FsyncopeContext.xml?ref=bffc69fd5518981ad384a4086dda4548e0ebcf4b","patch":"@@ -16,7 +16,6 @@ software distributed under the License is distributed on an\n KIND, either express or implied.  See the License for the\n specific language governing permissions and limitations\n under the License.\n-\n -->\n <beans xmlns=\"http://www.springframework.org/schema/beans\"\n        xmlns:context=\"http://www.springframework.org/schema/context\"\n@@ -67,7 +66,10 @@ under the License.\n   </bean>\n   \n   <bean id=\"propagationManager\" class=\"org.apache.syncope.core.propagation.PropagationManager\"/>\n+  <bean id=\"propagationTaskExecutor\" class=\"org.apache.syncope.core.propagation.PriorityPropagationTaskExecutor\"/>\n+    \n   <bean id=\"notificationManager\" class=\"org.apache.syncope.core.notification.NotificationManager\"/>\n+  \n   <bean id=\"auditManager\" class=\"org.apache.syncope.core.audit.AuditManager\"/>\n           \n   <bean id=\"jexlEngine\" class=\"org.apache.commons.jexl2.JexlEngine\">"}]}