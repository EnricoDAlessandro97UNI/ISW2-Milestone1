{"sha":"fb3794e3446b61c452ab452705243ec5a693bda0","node_id":"MDY6Q29tbWl0NjM2ODc5MDYyOmZiMzc5NGUzNDQ2YjYxYzQ1MmFiNDUyNzA1MjQzZWM1YTY5M2JkYTA=","commit":{"author":{"name":"Francesco Chicchiriccò","email":"ilgrosso@apache.org","date":"2020-08-18T14:48:04Z"},"committer":{"name":"Francesco Chicchiriccò","email":"ilgrosso@apache.org","date":"2020-08-18T14:48:04Z"},"message":"[SYNCOPE-1585] cxf-rt-rs-security-jose -> nimbus-jose-jwt","tree":{"sha":"82a9f0146979a130af4fbf22e3e37bb1afaeb7b5","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/git/trees/82a9f0146979a130af4fbf22e3e37bb1afaeb7b5"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/git/commits/fb3794e3446b61c452ab452705243ec5a693bda0","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/fb3794e3446b61c452ab452705243ec5a693bda0","html_url":"https://github.com/EnricoDAlessandro97UNI/syncope/commit/fb3794e3446b61c452ab452705243ec5a693bda0","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/fb3794e3446b61c452ab452705243ec5a693bda0/comments","author":{"login":"ilgrosso","id":1064664,"node_id":"MDQ6VXNlcjEwNjQ2NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/1064664?v=4","gravatar_id":"","url":"https://api.github.com/users/ilgrosso","html_url":"https://github.com/ilgrosso","followers_url":"https://api.github.com/users/ilgrosso/followers","following_url":"https://api.github.com/users/ilgrosso/following{/other_user}","gists_url":"https://api.github.com/users/ilgrosso/gists{/gist_id}","starred_url":"https://api.github.com/users/ilgrosso/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ilgrosso/subscriptions","organizations_url":"https://api.github.com/users/ilgrosso/orgs","repos_url":"https://api.github.com/users/ilgrosso/repos","events_url":"https://api.github.com/users/ilgrosso/events{/privacy}","received_events_url":"https://api.github.com/users/ilgrosso/received_events","type":"User","site_admin":false},"committer":{"login":"ilgrosso","id":1064664,"node_id":"MDQ6VXNlcjEwNjQ2NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/1064664?v=4","gravatar_id":"","url":"https://api.github.com/users/ilgrosso","html_url":"https://github.com/ilgrosso","followers_url":"https://api.github.com/users/ilgrosso/followers","following_url":"https://api.github.com/users/ilgrosso/following{/other_user}","gists_url":"https://api.github.com/users/ilgrosso/gists{/gist_id}","starred_url":"https://api.github.com/users/ilgrosso/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ilgrosso/subscriptions","organizations_url":"https://api.github.com/users/ilgrosso/orgs","repos_url":"https://api.github.com/users/ilgrosso/repos","events_url":"https://api.github.com/users/ilgrosso/events{/privacy}","received_events_url":"https://api.github.com/users/ilgrosso/received_events","type":"User","site_admin":false},"parents":[{"sha":"68151a717080f95aa3301002eac839061ec30008","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/68151a717080f95aa3301002eac839061ec30008","html_url":"https://github.com/EnricoDAlessandro97UNI/syncope/commit/68151a717080f95aa3301002eac839061ec30008"}],"stats":{"total":1174,"additions":559,"deletions":615},"files":[{"sha":"0b757a7a4dccf77cd044ce75a70696941d654511","filename":"client/idrepo/console/pom.xml","status":"modified","additions":5,"deletions":5,"changes":10,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fb3794e3446b61c452ab452705243ec5a693bda0/client%2Fidrepo%2Fconsole%2Fpom.xml","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fb3794e3446b61c452ab452705243ec5a693bda0/client%2Fidrepo%2Fconsole%2Fpom.xml","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/client%2Fidrepo%2Fconsole%2Fpom.xml?ref=fb3794e3446b61c452ab452705243ec5a693bda0","patch":"@@ -64,12 +64,12 @@ under the License.\n       <version>${project.version}</version>\n     </dependency>\n \n-    <dependency>\n-      <groupId>org.apache.cxf</groupId>\n-      <artifactId>cxf-rt-rs-security-jose</artifactId>\n-    </dependency>\n+      <dependency>\n+        <groupId>com.nimbusds</groupId>\n+        <artifactId>nimbus-jose-jwt</artifactId>\n+      </dependency>\n \n-    <dependency>\n+      <dependency>\n       <groupId>org.apache.pdfbox</groupId>\n       <artifactId>pdfbox</artifactId>\n     </dependency>"},{"sha":"16e2ef7d3678523da81036e62e956b584f25459d","filename":"client/idrepo/console/src/main/java/org/apache/syncope/client/console/panels/AccessTokenDirectoryPanel.java","status":"modified","additions":12,"deletions":7,"changes":19,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fb3794e3446b61c452ab452705243ec5a693bda0/client%2Fidrepo%2Fconsole%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fconsole%2Fpanels%2FAccessTokenDirectoryPanel.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fb3794e3446b61c452ab452705243ec5a693bda0/client%2Fidrepo%2Fconsole%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fconsole%2Fpanels%2FAccessTokenDirectoryPanel.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/client%2Fidrepo%2Fconsole%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fconsole%2Fpanels%2FAccessTokenDirectoryPanel.java?ref=fb3794e3446b61c452ab452705243ec5a693bda0","patch":"@@ -18,13 +18,14 @@\n  */\n package org.apache.syncope.client.console.panels;\n \n+import com.nimbusds.jwt.SignedJWT;\n import de.agilecoders.wicket.core.markup.html.bootstrap.dialog.Modal;\n+import java.text.ParseException;\n import java.util.ArrayList;\n import java.util.Collection;\n-import java.util.Date;\n import java.util.Iterator;\n import java.util.List;\n-import org.apache.cxf.rs.security.jose.jws.JwsJwtCompactConsumer;\n+import org.apache.commons.lang3.StringUtils;\n import org.apache.syncope.client.console.SyncopeConsoleSession;\n import org.apache.syncope.client.ui.commons.Constants;\n import org.apache.syncope.client.ui.commons.DirectoryDataProvider;\n@@ -98,14 +99,18 @@ public void populateItem(\n                     final String componentId,\n                     final IModel<AccessTokenTO> model) {\n \n-                JwsJwtCompactConsumer consumer = new JwsJwtCompactConsumer(model.getObject().getBody());\n-                cellItem.add(new Label(componentId,\n-                        SyncopeConsoleSession.get().getDateFormat().format(\n-                                new Date(consumer.getJwtClaims().getIssuedAt() * 1000))));\n+                try {\n+                    SignedJWT jwt = SignedJWT.parse(model.getObject().getBody());\n+                    cellItem.add(new Label(componentId,\n+                            SyncopeConsoleSession.get().getDateFormat().format(jwt.getJWTClaimsSet().getIssueTime())));\n+                } catch (ParseException e) {\n+                    LOG.error(\"Could not parse JWT {}\", model.getObject().getBody(), e);\n+                    cellItem.add(new Label(componentId, StringUtils.EMPTY));\n+                }\n             }\n         });\n \n-        columns.add(new DatePropertyColumn<>(new ResourceModel(\"expiryTime\"), \"expiryTime\", \"expiryTime\"));\n+        columns.add(new DatePropertyColumn<>(new ResourceModel(\"expirationTime\"), \"expirationTime\", \"expirationTime\"));\n \n         return columns;\n     }"},{"sha":"a46b957c8844e721b8f6ef3058fe513c6d3bb67d","filename":"client/idrepo/console/src/main/resources/org/apache/syncope/client/console/panels/AccessTokenDirectoryPanel.properties","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fb3794e3446b61c452ab452705243ec5a693bda0/client%2Fidrepo%2Fconsole%2Fsrc%2Fmain%2Fresources%2Forg%2Fapache%2Fsyncope%2Fclient%2Fconsole%2Fpanels%2FAccessTokenDirectoryPanel.properties","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fb3794e3446b61c452ab452705243ec5a693bda0/client%2Fidrepo%2Fconsole%2Fsrc%2Fmain%2Fresources%2Forg%2Fapache%2Fsyncope%2Fclient%2Fconsole%2Fpanels%2FAccessTokenDirectoryPanel.properties","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/client%2Fidrepo%2Fconsole%2Fsrc%2Fmain%2Fresources%2Forg%2Fapache%2Fsyncope%2Fclient%2Fconsole%2Fpanels%2FAccessTokenDirectoryPanel.properties?ref=fb3794e3446b61c452ab452705243ec5a693bda0","patch":"@@ -17,5 +17,5 @@\n any.edit=Edit access token ${accessTokenTO.owner}\n any.new=New access token\n owner=Owner\n-expiryTime=Expiry\n+expirationTime=Expiry\n issuedAt=Start"},{"sha":"e03de3d4e3e6007a33b8cbd0157064bfb684bc7e","filename":"client/idrepo/console/src/main/resources/org/apache/syncope/client/console/panels/AccessTokenDirectoryPanel_fr_CA.properties","status":"modified","additions":5,"deletions":5,"changes":10,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fb3794e3446b61c452ab452705243ec5a693bda0/client%2Fidrepo%2Fconsole%2Fsrc%2Fmain%2Fresources%2Forg%2Fapache%2Fsyncope%2Fclient%2Fconsole%2Fpanels%2FAccessTokenDirectoryPanel_fr_CA.properties","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fb3794e3446b61c452ab452705243ec5a693bda0/client%2Fidrepo%2Fconsole%2Fsrc%2Fmain%2Fresources%2Forg%2Fapache%2Fsyncope%2Fclient%2Fconsole%2Fpanels%2FAccessTokenDirectoryPanel_fr_CA.properties","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/client%2Fidrepo%2Fconsole%2Fsrc%2Fmain%2Fresources%2Forg%2Fapache%2Fsyncope%2Fclient%2Fconsole%2Fpanels%2FAccessTokenDirectoryPanel_fr_CA.properties?ref=fb3794e3446b61c452ab452705243ec5a693bda0","patch":"@@ -14,8 +14,8 @@\n # KIND, either express or implied.  See the License for the\n # specific language governing permissions and limitations\n # under the License.\n-any.edit=Jeton modification acc�s ${accessTokenTO.owner}\n-any.new=Jeton nouvel acc�s\n-owner=Propri�taire\n-expiryTime=Expiration\n-issuedAt=D�but\n+any.edit=Jeton modification acc\\u00e8s ${accessTokenTO.owner}\n+any.new=Jeton nouvel acc\\u00e8s\n+owner=Propri\\u00e9taire\n+expirationTime=Expiration\n+issuedAt=D\\u00e9but"},{"sha":"abd2ed82e69c536bddddec269fe0a253d4beff29","filename":"client/idrepo/console/src/main/resources/org/apache/syncope/client/console/panels/AccessTokenDirectoryPanel_it.properties","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fb3794e3446b61c452ab452705243ec5a693bda0/client%2Fidrepo%2Fconsole%2Fsrc%2Fmain%2Fresources%2Forg%2Fapache%2Fsyncope%2Fclient%2Fconsole%2Fpanels%2FAccessTokenDirectoryPanel_it.properties","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fb3794e3446b61c452ab452705243ec5a693bda0/client%2Fidrepo%2Fconsole%2Fsrc%2Fmain%2Fresources%2Forg%2Fapache%2Fsyncope%2Fclient%2Fconsole%2Fpanels%2FAccessTokenDirectoryPanel_it.properties","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/client%2Fidrepo%2Fconsole%2Fsrc%2Fmain%2Fresources%2Forg%2Fapache%2Fsyncope%2Fclient%2Fconsole%2Fpanels%2FAccessTokenDirectoryPanel_it.properties?ref=fb3794e3446b61c452ab452705243ec5a693bda0","patch":"@@ -17,5 +17,5 @@\n any.edit=Modifica ruolo ${roleTO.key}\n any.new=Nuovo token di accesso\n owner=Proprietario\n-expiryTime=Termine\n+expirationTime=Termine\n issuedAt=Inizio"},{"sha":"ea5b73e971b61b746b4494281abb2fb7d8a82657","filename":"client/idrepo/console/src/main/resources/org/apache/syncope/client/console/panels/AccessTokenDirectoryPanel_ja.properties","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fb3794e3446b61c452ab452705243ec5a693bda0/client%2Fidrepo%2Fconsole%2Fsrc%2Fmain%2Fresources%2Forg%2Fapache%2Fsyncope%2Fclient%2Fconsole%2Fpanels%2FAccessTokenDirectoryPanel_ja.properties","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fb3794e3446b61c452ab452705243ec5a693bda0/client%2Fidrepo%2Fconsole%2Fsrc%2Fmain%2Fresources%2Forg%2Fapache%2Fsyncope%2Fclient%2Fconsole%2Fpanels%2FAccessTokenDirectoryPanel_ja.properties","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/client%2Fidrepo%2Fconsole%2Fsrc%2Fmain%2Fresources%2Forg%2Fapache%2Fsyncope%2Fclient%2Fconsole%2Fpanels%2FAccessTokenDirectoryPanel_ja.properties?ref=fb3794e3446b61c452ab452705243ec5a693bda0","patch":"@@ -17,5 +17,5 @@\n any.edit=\\u30a2\\u30af\\u30bb\\u30b9\\u30c8\\u30fc\\u30af\\u30f3 ${accessTokenTO.owner} \\u3092\\u7de8\\u96c6\n any.new=\\u65b0\\u3057\\u3044\\u30a2\\u30af\\u30bb\\u30b9\\u30c8\\u30fc\\u30af\\u30f3\n owner=\\u30aa\\u30fc\\u30ca\\u30fc\n-expiryTime=\\u671f\\u9650\n+expirationTime=\\u671f\\u9650\n issuedAt=\\u958b\\u59cb"},{"sha":"34245133fa64b0740af0f305ab060c00c4a343ab","filename":"client/idrepo/console/src/main/resources/org/apache/syncope/client/console/panels/AccessTokenDirectoryPanel_pt_BR.properties","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fb3794e3446b61c452ab452705243ec5a693bda0/client%2Fidrepo%2Fconsole%2Fsrc%2Fmain%2Fresources%2Forg%2Fapache%2Fsyncope%2Fclient%2Fconsole%2Fpanels%2FAccessTokenDirectoryPanel_pt_BR.properties","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fb3794e3446b61c452ab452705243ec5a693bda0/client%2Fidrepo%2Fconsole%2Fsrc%2Fmain%2Fresources%2Forg%2Fapache%2Fsyncope%2Fclient%2Fconsole%2Fpanels%2FAccessTokenDirectoryPanel_pt_BR.properties","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/client%2Fidrepo%2Fconsole%2Fsrc%2Fmain%2Fresources%2Forg%2Fapache%2Fsyncope%2Fclient%2Fconsole%2Fpanels%2FAccessTokenDirectoryPanel_pt_BR.properties?ref=fb3794e3446b61c452ab452705243ec5a693bda0","patch":"@@ -17,5 +17,5 @@\n any.edit=Alterar fun\\u00e7\\u00e3o ${roleTO.key}\n any.new=Novo token de acesso\n owner=Propriet\\u00e1rio\n-expiryTime=Termo\n+expirationTime=Termo\n issuedAt=Iniciar"},{"sha":"d6ff9be93238a6a19048f17cdbaebd72dd539f2e","filename":"client/idrepo/console/src/main/resources/org/apache/syncope/client/console/panels/AccessTokenDirectoryPanel_ru.properties","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fb3794e3446b61c452ab452705243ec5a693bda0/client%2Fidrepo%2Fconsole%2Fsrc%2Fmain%2Fresources%2Forg%2Fapache%2Fsyncope%2Fclient%2Fconsole%2Fpanels%2FAccessTokenDirectoryPanel_ru.properties","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fb3794e3446b61c452ab452705243ec5a693bda0/client%2Fidrepo%2Fconsole%2Fsrc%2Fmain%2Fresources%2Forg%2Fapache%2Fsyncope%2Fclient%2Fconsole%2Fpanels%2FAccessTokenDirectoryPanel_ru.properties","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/client%2Fidrepo%2Fconsole%2Fsrc%2Fmain%2Fresources%2Forg%2Fapache%2Fsyncope%2Fclient%2Fconsole%2Fpanels%2FAccessTokenDirectoryPanel_ru.properties?ref=fb3794e3446b61c452ab452705243ec5a693bda0","patch":"@@ -18,5 +18,5 @@\n any.edit=\\u0418\\u0437\\u043c\\u0435\\u043d\\u0438\\u0442\\u044c \\u0440\\u043e\\u043b\\u044c ${roleTO.key}\n any.new=\\u041d\\u043e\\u0432\\u044b\\u0439 \\u043c\\u0430\\u0440\\u043a\\u0435\\u0440 \\u0434\\u043e\\u0441\\u0442\\u0443\\u043f\\u0430\n owner=\\u0412\\u043b\\u0430\\u0434\\u0435\\u043b\\u0435\\u0446\n-expiryTime=\\u0438\\u0441\\u0442\\u0435\\u0447\\u0435\\u043d\\u0438\\u0435 \\u0441\\u0440\\u043e\\u043a\\u0430\n+expirationTime=\\u0438\\u0441\\u0442\\u0435\\u0447\\u0435\\u043d\\u0438\\u0435 \\u0441\\u0440\\u043e\\u043a\\u0430\n issuedAt=\\u041d\\u0430\\u0447\\u0430\\u043b\\u043e"},{"sha":"c6ebf181d142a8587cc610aa374443071cb6d4df","filename":"client/idrepo/lib/src/main/java/org/apache/syncope/client/lib/JWTAuthenticationHandler.java","status":"modified","additions":0,"deletions":1,"changes":1,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fb3794e3446b61c452ab452705243ec5a693bda0/client%2Fidrepo%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Flib%2FJWTAuthenticationHandler.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fb3794e3446b61c452ab452705243ec5a693bda0/client%2Fidrepo%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Flib%2FJWTAuthenticationHandler.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/client%2Fidrepo%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Flib%2FJWTAuthenticationHandler.java?ref=fb3794e3446b61c452ab452705243ec5a693bda0","patch":"@@ -32,5 +32,4 @@ public JWTAuthenticationHandler(final String jwt) {\n     public String getJwt() {\n         return jwt;\n     }\n-\n }"},{"sha":"2080c87997c49e7e7e8d17176a128bbd47bc895f","filename":"common/idrepo/lib/src/main/java/org/apache/syncope/common/lib/to/AccessTokenTO.java","status":"modified","additions":7,"deletions":7,"changes":14,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fb3794e3446b61c452ab452705243ec5a693bda0/common%2Fidrepo%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FAccessTokenTO.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fb3794e3446b61c452ab452705243ec5a693bda0/common%2Fidrepo%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FAccessTokenTO.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/common%2Fidrepo%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FAccessTokenTO.java?ref=fb3794e3446b61c452ab452705243ec5a693bda0","patch":"@@ -31,7 +31,7 @@ public class AccessTokenTO implements EntityTO {\n \n     private String body;\n \n-    private Date expiryTime;\n+    private Date expirationTime;\n \n     private String owner;\n \n@@ -53,12 +53,12 @@ public void setBody(final String body) {\n         this.body = body;\n     }\n \n-    public Date getExpiryTime() {\n-        return Optional.ofNullable(expiryTime).map(time -> new Date(time.getTime())).orElse(null);\n+    public Date getExpirationTime() {\n+        return Optional.ofNullable(expirationTime).map(time -> new Date(time.getTime())).orElse(null);\n     }\n \n-    public void setExpiryTime(final Date expiryTime) {\n-        this.expiryTime = Optional.ofNullable(expiryTime).map(time -> new Date(time.getTime())).orElse(null);\n+    public void setExpirationTime(final Date expiryTime) {\n+        this.expirationTime = Optional.ofNullable(expiryTime).map(time -> new Date(time.getTime())).orElse(null);\n     }\n \n     public String getOwner() {\n@@ -84,7 +84,7 @@ public boolean equals(final Object obj) {\n         return new EqualsBuilder().\n                 append(key, other.key).\n                 append(body, other.body).\n-                append(expiryTime, other.expiryTime).\n+                append(expirationTime, other.expirationTime).\n                 append(owner, other.owner).\n                 build();\n     }\n@@ -94,7 +94,7 @@ public int hashCode() {\n         return new HashCodeBuilder().\n                 append(key).\n                 append(body).\n-                append(expiryTime).\n+                append(expirationTime).\n                 append(owner).\n                 build();\n     }"},{"sha":"0e170dc08933f5117fd7cae1af8386d6568b4fb9","filename":"common/idrepo/lib/src/main/java/org/apache/syncope/common/lib/types/ClientExceptionType.java","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fb3794e3446b61c452ab452705243ec5a693bda0/common%2Fidrepo%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Ftypes%2FClientExceptionType.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fb3794e3446b61c452ab452705243ec5a693bda0/common%2Fidrepo%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Ftypes%2FClientExceptionType.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/common%2Fidrepo%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Ftypes%2FClientExceptionType.java?ref=fb3794e3446b61c452ab452705243ec5a693bda0","patch":"@@ -31,6 +31,7 @@ public enum ClientExceptionType {\n     EntityExists(Response.Status.CONFLICT),\n     GenericPersistence(Response.Status.BAD_REQUEST),\n     HasChildren(Response.Status.BAD_REQUEST),\n+    InvalidAccessToken(Response.Status.INTERNAL_SERVER_ERROR),\n     InvalidPrivilege(Response.Status.BAD_REQUEST),\n     InvalidImplementation(Response.Status.BAD_REQUEST),\n     InvalidImplementationType(Response.Status.NOT_FOUND),"},{"sha":"3c2feeeb3a2c2e6b70dd8b9c32b31726b05b6a24","filename":"core/idrepo/logic/pom.xml","status":"modified","additions":0,"deletions":5,"changes":5,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fb3794e3446b61c452ab452705243ec5a693bda0/core%2Fidrepo%2Flogic%2Fpom.xml","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fb3794e3446b61c452ab452705243ec5a693bda0/core%2Fidrepo%2Flogic%2Fpom.xml","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fidrepo%2Flogic%2Fpom.xml?ref=fb3794e3446b61c452ab452705243ec5a693bda0","patch":"@@ -38,11 +38,6 @@ under the License.\n   </properties>\n \n   <dependencies>\n-    <dependency>\n-      <groupId>org.apache.cxf</groupId>\n-      <artifactId>cxf-rt-rs-security-jose</artifactId>\n-    </dependency>\n-\n     <dependency>\n       <groupId>org.springframework</groupId>\n       <artifactId>spring-context</artifactId>"},{"sha":"d956385d74c505218fa760cca484051ce5516d9a","filename":"core/persistence-api/src/main/java/org/apache/syncope/core/persistence/api/entity/AccessToken.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fb3794e3446b61c452ab452705243ec5a693bda0/core%2Fpersistence-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fapi%2Fentity%2FAccessToken.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fb3794e3446b61c452ab452705243ec5a693bda0/core%2Fpersistence-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fapi%2Fentity%2FAccessToken.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fpersistence-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fapi%2Fentity%2FAccessToken.java?ref=fb3794e3446b61c452ab452705243ec5a693bda0","patch":"@@ -26,9 +26,9 @@ public interface AccessToken extends ProvidedKeyEntity {\n \n     void setBody(String body);\n \n-    Date getExpiryTime();\n+    Date getExpirationTime();\n \n-    void setExpiryTime(Date expiryTime);\n+    void setExpirationTime(Date expirationTime);\n \n     String getOwner();\n "},{"sha":"83db64dd94909191256d87931d21fd85478f1ac1","filename":"core/persistence-jpa-json/pom.xml","status":"modified","additions":0,"deletions":5,"changes":5,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fb3794e3446b61c452ab452705243ec5a693bda0/core%2Fpersistence-jpa-json%2Fpom.xml","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fb3794e3446b61c452ab452705243ec5a693bda0/core%2Fpersistence-jpa-json%2Fpom.xml","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fpersistence-jpa-json%2Fpom.xml?ref=fb3794e3446b61c452ab452705243ec5a693bda0","patch":"@@ -86,11 +86,6 @@ under the License.\n       <artifactId>junit-jupiter</artifactId>\n       <scope>test</scope>\n     </dependency>\n-    <dependency>\n-      <groupId>com.nimbusds</groupId>\n-      <artifactId>nimbus-jose-jwt</artifactId>\n-      <scope>test</scope>\n-    </dependency>\n   </dependencies>\n \n   <build>"},{"sha":"0d6b81000200deb070bcbac5cc1139018f374b87","filename":"core/persistence-jpa/pom.xml","status":"modified","additions":0,"deletions":5,"changes":5,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fb3794e3446b61c452ab452705243ec5a693bda0/core%2Fpersistence-jpa%2Fpom.xml","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fb3794e3446b61c452ab452705243ec5a693bda0/core%2Fpersistence-jpa%2Fpom.xml","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fpersistence-jpa%2Fpom.xml?ref=fb3794e3446b61c452ab452705243ec5a693bda0","patch":"@@ -138,11 +138,6 @@ under the License.\n       <artifactId>bcprov-jdk15on</artifactId>\n       <scope>test</scope>\n     </dependency>\n-    <dependency>\n-      <groupId>com.nimbusds</groupId>\n-      <artifactId>nimbus-jose-jwt</artifactId>\n-      <scope>test</scope>\n-    </dependency>\n   </dependencies>\n \n   <build>"},{"sha":"fbe3852a09ab05b63398c3bfcf42b283bb13f182","filename":"core/persistence-jpa/src/main/java/org/apache/syncope/core/persistence/jpa/dao/JPAAccessTokenDAO.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fb3794e3446b61c452ab452705243ec5a693bda0/core%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fjpa%2Fdao%2FJPAAccessTokenDAO.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fb3794e3446b61c452ab452705243ec5a693bda0/core%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fjpa%2Fdao%2FJPAAccessTokenDAO.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fjpa%2Fdao%2FJPAAccessTokenDAO.java?ref=fb3794e3446b61c452ab452705243ec5a693bda0","patch":"@@ -135,7 +135,7 @@ public void delete(final AccessToken accessToken) {\n     public int deleteExpired() {\n         Query query = entityManager().createQuery(\n                 \"DELETE FROM \" + JPAAccessToken.class.getSimpleName() + \" e \"\n-                + \"WHERE e.expiryTime < :now\");\n+                + \"WHERE e.expirationTime < :now\");\n         query.setParameter(\"now\", new Date());\n         return query.executeUpdate();\n     }"},{"sha":"326c7025d201a42516550691e6d8710d9d1aa732","filename":"core/persistence-jpa/src/main/java/org/apache/syncope/core/persistence/jpa/entity/JPAAccessToken.java","status":"modified","additions":5,"deletions":5,"changes":10,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fb3794e3446b61c452ab452705243ec5a693bda0/core%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fjpa%2Fentity%2FJPAAccessToken.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fb3794e3446b61c452ab452705243ec5a693bda0/core%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fjpa%2Fentity%2FJPAAccessToken.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fjpa%2Fentity%2FJPAAccessToken.java?ref=fb3794e3446b61c452ab452705243ec5a693bda0","patch":"@@ -44,7 +44,7 @@ public class JPAAccessToken extends AbstractProvidedKeyEntity implements AccessT\n     private String body;\n \n     @Temporal(TemporalType.TIMESTAMP)\n-    private Date expiryTime;\n+    private Date expirationTime;\n \n     @Column(unique = true)\n     private String owner;\n@@ -63,13 +63,13 @@ public void setBody(final String body) {\n     }\n \n     @Override\n-    public Date getExpiryTime() {\n-        return Optional.ofNullable(expiryTime).map(time -> new Date(time.getTime())).orElse(null);\n+    public Date getExpirationTime() {\n+        return Optional.ofNullable(expirationTime).map(time -> new Date(time.getTime())).orElse(null);\n     }\n \n     @Override\n-    public void setExpiryTime(final Date expiryTime) {\n-        this.expiryTime = Optional.ofNullable(expiryTime).map(time -> new Date(time.getTime())).orElse(null);\n+    public void setExpirationTime(final Date expirationTime) {\n+        this.expirationTime = Optional.ofNullable(expirationTime).map(time -> new Date(time.getTime())).orElse(null);\n     }\n \n     @Override"},{"sha":"f36906fe2e58b1b4fd2a9d6077060f01ee87f43d","filename":"core/persistence-jpa/src/test/java/org/apache/syncope/core/persistence/jpa/outer/AccessTokenTest.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fb3794e3446b61c452ab452705243ec5a693bda0/core%2Fpersistence-jpa%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fjpa%2Fouter%2FAccessTokenTest.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fb3794e3446b61c452ab452705243ec5a693bda0/core%2Fpersistence-jpa%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fjpa%2Fouter%2FAccessTokenTest.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fpersistence-jpa%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fjpa%2Fouter%2FAccessTokenTest.java?ref=fb3794e3446b61c452ab452705243ec5a693bda0","patch":"@@ -42,7 +42,7 @@ public void crud() {\n         AccessToken accessToken = entityFactory.newEntity(AccessToken.class);\n         accessToken.setKey(UUID.randomUUID().toString());\n         accessToken.setBody(\"pointless body\");\n-        accessToken.setExpiryTime(new Date());\n+        accessToken.setExpirationTime(new Date());\n         accessToken.setOwner(\"bellini\");\n \n         accessToken = accessTokenDAO.save(accessToken);"},{"sha":"5a2211e285f52151ae2cb967e322b22f461617fc","filename":"core/provisioning-java/pom.xml","status":"modified","additions":0,"deletions":5,"changes":5,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fb3794e3446b61c452ab452705243ec5a693bda0/core%2Fprovisioning-java%2Fpom.xml","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fb3794e3446b61c452ab452705243ec5a693bda0/core%2Fprovisioning-java%2Fpom.xml","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-java%2Fpom.xml?ref=fb3794e3446b61c452ab452705243ec5a693bda0","patch":"@@ -96,11 +96,6 @@ under the License.\n       <artifactId>groovy-sql</artifactId>\n     </dependency>\n \n-    <dependency>\n-      <groupId>com.nimbusds</groupId>\n-      <artifactId>nimbus-jose-jwt</artifactId>\n-    </dependency>\n-\n     <dependency>\n       <groupId>org.apache.syncope.core</groupId>\n       <artifactId>syncope-core-workflow-api</artifactId>"},{"sha":"cb9ff1f7aef1362b48cc73e77946eebba9d84058","filename":"core/provisioning-java/src/main/java/org/apache/syncope/core/provisioning/java/data/AccessTokenDataBinderImpl.java","status":"modified","additions":61,"deletions":44,"changes":105,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fb3794e3446b61c452ab452705243ec5a693bda0/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fdata%2FAccessTokenDataBinderImpl.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fb3794e3446b61c452ab452705243ec5a693bda0/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fdata%2FAccessTokenDataBinderImpl.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fdata%2FAccessTokenDataBinderImpl.java?ref=fb3794e3446b61c452ab452705243ec5a693bda0","patch":"@@ -18,26 +18,28 @@\n  */\n package org.apache.syncope.core.provisioning.java.data;\n \n+import com.nimbusds.jose.JOSEException;\n+import com.nimbusds.jose.JWSHeader;\n+import com.nimbusds.jwt.JWTClaimsSet;\n+import com.nimbusds.jwt.SignedJWT;\n+import java.text.ParseException;\n+import java.util.Calendar;\n import java.util.Date;\n import java.util.Map;\n import javax.annotation.Resource;\n import org.apache.commons.lang3.tuple.Pair;\n-import org.apache.cxf.rs.security.jose.common.JoseType;\n-import org.apache.cxf.rs.security.jose.jws.JwsHeaders;\n-import org.apache.cxf.rs.security.jose.jws.JwsJwtCompactConsumer;\n-import org.apache.cxf.rs.security.jose.jws.JwsJwtCompactProducer;\n-import org.apache.cxf.rs.security.jose.jwt.JwtClaims;\n-import org.apache.cxf.rs.security.jose.jwt.JwtToken;\n import org.apache.syncope.common.keymaster.client.api.ConfParamOps;\n+import org.apache.syncope.common.lib.SyncopeClientException;\n import org.apache.syncope.common.lib.to.AccessTokenTO;\n+import org.apache.syncope.common.lib.types.ClientExceptionType;\n import org.apache.syncope.core.persistence.api.dao.AccessTokenDAO;\n import org.apache.syncope.core.persistence.api.entity.AccessToken;\n import org.apache.syncope.core.persistence.api.entity.EntityFactory;\n import org.apache.syncope.core.provisioning.api.data.AccessTokenDataBinder;\n import org.apache.syncope.core.spring.security.AuthContextUtils;\n import org.apache.syncope.core.spring.security.DefaultCredentialChecker;\n import org.apache.syncope.core.spring.security.SecureRandomUtils;\n-import org.apache.syncope.core.spring.security.jws.AccessTokenJwsSignatureProvider;\n+import org.apache.syncope.core.spring.security.jws.AccessTokenJWSSigner;\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.stereotype.Component;\n \n@@ -51,7 +53,7 @@ public class AccessTokenDataBinderImpl implements AccessTokenDataBinder {\n     private String jwtIssuer;\n \n     @Autowired\n-    private AccessTokenJwsSignatureProvider jwsSignatureProvider;\n+    private AccessTokenJWSSigner jwsSigner;\n \n     @Autowired\n     private AccessTokenDAO accessTokenDAO;\n@@ -74,25 +76,30 @@ public Pair<String, Date> generateJWT(\n \n         credentialChecker.checkIsDefaultJWSKeyInUse();\n \n-        long currentTime = new Date().getTime() / 1000L;\n-        long expiryTime = currentTime + 60L * duration;\n-\n-        JwtClaims jwtClaims = new JwtClaims();\n-        jwtClaims.setTokenId(tokenId);\n-        jwtClaims.setSubject(subject);\n-        jwtClaims.setIssuedAt(currentTime);\n-        jwtClaims.setIssuer(jwtIssuer);\n-        jwtClaims.setExpiryTime(expiryTime);\n-        jwtClaims.setNotBefore(currentTime);\n-        claims.forEach(jwtClaims::setClaim);\n-\n-        JwsHeaders jwsHeaders = new JwsHeaders(JoseType.JWT, jwsSignatureProvider.getAlgorithm());\n-        JwtToken token = new JwtToken(jwsHeaders, jwtClaims);\n-        JwsJwtCompactProducer producer = new JwsJwtCompactProducer(token);\n-\n-        String signed = producer.signWith(jwsSignatureProvider);\n-\n-        return Pair.of(signed, new Date(expiryTime * 1000L));\n+        Date currentTime = new Date();\n+\n+        Calendar expiration = Calendar.getInstance();\n+        expiration.setTime(currentTime);\n+        expiration.add(Calendar.MINUTE, (int) duration);\n+\n+        JWTClaimsSet.Builder claimsSet = new JWTClaimsSet.Builder().\n+                jwtID(tokenId).\n+                subject(subject).\n+                issueTime(currentTime).\n+                issuer(jwtIssuer).\n+                expirationTime(expiration.getTime()).\n+                notBeforeTime(currentTime);\n+        claims.forEach(claimsSet::claim);\n+\n+        SignedJWT jwt = new SignedJWT(new JWSHeader(jwsSigner.getJwsAlgorithm()), claimsSet.build());\n+        try {\n+            jwt.sign(jwsSigner);\n+        } catch (JOSEException e) {\n+            SyncopeClientException sce = SyncopeClientException.build(ClientExceptionType.InvalidAccessToken);\n+            sce.getElements().add(e.getMessage());\n+            throw sce;\n+        }\n+        return Pair.of(jwt.serialize(), expiration.getTime());\n     }\n \n     private AccessToken replace(\n@@ -108,7 +115,7 @@ private AccessToken replace(\n                 claims);\n \n         accessToken.setBody(generated.getLeft());\n-        accessToken.setExpiryTime(generated.getRight());\n+        accessToken.setExpirationTime(generated.getRight());\n         accessToken.setOwner(subject);\n \n         if (!adminUser.equals(accessToken.getOwner())) {\n@@ -132,51 +139,61 @@ public Pair<String, Date> create(\n             accessToken.setKey(SecureRandomUtils.generateRandomUUID().toString());\n \n             accessToken = replace(subject, claims, authorities, accessToken);\n-        } else if (replace || accessToken.getExpiryTime() == null || accessToken.getExpiryTime().before(new Date())) {\n+        } else if (replace || accessToken.getExpirationTime() == null\n+                || accessToken.getExpirationTime().before(new Date())) {\n+\n             // AccessToken found, but either replace was requested or it is expired: update existing\n             accessToken = replace(subject, claims, authorities, accessToken);\n         }\n \n-        return Pair.of(accessToken.getBody(), accessToken.getExpiryTime());\n+        return Pair.of(accessToken.getBody(), accessToken.getExpirationTime());\n     }\n \n     @Override\n     public Pair<String, Date> update(final AccessToken accessToken, final byte[] authorities) {\n-        JwsJwtCompactConsumer consumer = new JwsJwtCompactConsumer(accessToken.getBody());\n-\n         credentialChecker.checkIsDefaultJWSKeyInUse();\n \n         long duration = confParamOps.get(AuthContextUtils.getDomain(), \"jwt.lifetime.minutes\", 120L, Long.class);\n-        long currentTime = new Date().getTime() / 1000L;\n-        long expiry = currentTime + 60L * duration;\n-        consumer.getJwtClaims().setExpiryTime(expiry);\n-        Date expiryDate = new Date(expiry * 1000L);\n \n-        JwsHeaders jwsHeaders = new JwsHeaders(JoseType.JWT, jwsSignatureProvider.getAlgorithm());\n-        JwtToken token = new JwtToken(jwsHeaders, consumer.getJwtClaims());\n-        JwsJwtCompactProducer producer = new JwsJwtCompactProducer(token);\n+        Date currentTime = new Date();\n+\n+        Calendar expiration = Calendar.getInstance();\n+        expiration.setTime(currentTime);\n+        expiration.add(Calendar.MINUTE, (int) duration);\n \n-        String body = producer.signWith(jwsSignatureProvider);\n+        SignedJWT jwt;\n+        try {\n+            JWTClaimsSet.Builder claimsSet =\n+                    new JWTClaimsSet.Builder(SignedJWT.parse(accessToken.getBody()).getJWTClaimsSet()).\n+                            expirationTime(expiration.getTime());\n+\n+            jwt = new SignedJWT(new JWSHeader(jwsSigner.getJwsAlgorithm()), claimsSet.build());\n+            jwt.sign(jwsSigner);\n+        } catch (ParseException | JOSEException e) {\n+            SyncopeClientException sce = SyncopeClientException.build(ClientExceptionType.InvalidAccessToken);\n+            sce.getElements().add(e.getMessage());\n+            throw sce;\n+        }\n+        String body = jwt.serialize();\n \n         accessToken.setBody(body);\n-        // AccessToken stores expiry time in milliseconds, as opposed to seconds for the JWT tokens.\n-        accessToken.setExpiryTime(expiryDate);\n+        accessToken.setExpirationTime(expiration.getTime());\n \n         if (!adminUser.equals(accessToken.getOwner())) {\n             accessToken.setAuthorities(authorities);\n         }\n \n         accessTokenDAO.save(accessToken);\n \n-        return Pair.of(body, expiryDate);\n+        return Pair.of(body, expiration.getTime());\n     }\n \n     @Override\n     public AccessTokenTO getAccessTokenTO(final AccessToken accessToken) {\n         AccessTokenTO accessTokenTO = new AccessTokenTO();\n         accessTokenTO.setKey(accessToken.getKey());\n         accessTokenTO.setBody(accessToken.getBody());\n-        accessTokenTO.setExpiryTime(accessToken.getExpiryTime());\n+        accessTokenTO.setExpirationTime(accessToken.getExpirationTime());\n         accessTokenTO.setOwner(accessToken.getOwner());\n \n         return accessTokenTO;"},{"sha":"80dcd6b6b2b5f1e559a5603c9e45105f502c0646","filename":"core/spring/pom.xml","status":"modified","additions":6,"deletions":6,"changes":12,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fb3794e3446b61c452ab452705243ec5a693bda0/core%2Fspring%2Fpom.xml","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fb3794e3446b61c452ab452705243ec5a693bda0/core%2Fspring%2Fpom.xml","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fspring%2Fpom.xml?ref=fb3794e3446b61c452ab452705243ec5a693bda0","patch":"@@ -53,13 +53,13 @@ under the License.\n       <groupId>org.jasypt</groupId>\n       <artifactId>jasypt</artifactId>\n     </dependency>\n-    \n-    <dependency>\n-      <groupId>org.apache.cxf</groupId>\n-      <artifactId>cxf-rt-rs-security-jose</artifactId>\n-    </dependency>\n \n-    <dependency>\n+      <dependency>\n+        <groupId>com.nimbusds</groupId>\n+        <artifactId>nimbus-jose-jwt</artifactId>\n+      </dependency>\n+\n+      <dependency>\n       <groupId>org.springframework.boot</groupId>\n       <artifactId>spring-boot-autoconfigure</artifactId>\n     </dependency>"},{"sha":"43957ad8363b4ad7265c6b34a3a7e0a0ff293e83","filename":"core/spring/src/main/java/org/apache/syncope/core/spring/security/AuthDataAccessor.java","status":"modified","additions":4,"deletions":4,"changes":8,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fb3794e3446b61c452ab452705243ec5a693bda0/core%2Fspring%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fspring%2Fsecurity%2FAuthDataAccessor.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fb3794e3446b61c452ab452705243ec5a693bda0/core%2Fspring%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fspring%2Fsecurity%2FAuthDataAccessor.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fspring%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fspring%2Fsecurity%2FAuthDataAccessor.java?ref=fb3794e3446b61c452ab452705243ec5a693bda0","patch":"@@ -368,10 +368,10 @@ public Pair<String, Set<SyncopeGrantedAuthority>> authenticate(final JWTAuthenti\n         Set<SyncopeGrantedAuthority> authorities;\n \n         if (adminUser.equals(authentication.getClaims().getSubject())) {\n-            AccessToken accessToken = accessTokenDAO.find(authentication.getClaims().getTokenId());\n+            AccessToken accessToken = accessTokenDAO.find(authentication.getClaims().getJWTID());\n             if (accessToken == null) {\n                 throw new AuthenticationCredentialsNotFoundException(\n-                        \"Could not find an Access Token for JWT \" + authentication.getClaims().getTokenId());\n+                        \"Could not find an Access Token for JWT \" + authentication.getClaims().getJWTID());\n             }\n \n             username = adminUser;\n@@ -382,14 +382,14 @@ public Pair<String, Set<SyncopeGrantedAuthority>> authenticate(final JWTAuthenti\n             if (resolved == null || resolved.getLeft() == null) {\n                 throw new AuthenticationCredentialsNotFoundException(\n                         \"Could not find User \" + authentication.getClaims().getSubject()\n-                        + \" for JWT \" + authentication.getClaims().getTokenId());\n+                        + \" for JWT \" + authentication.getClaims().getJWTID());\n             }\n \n             User user = resolved.getLeft();\n             username = user.getUsername();\n             authorities = resolved.getRight() == null ? Set.of() : resolved.getRight();\n             LOG.debug(\"JWT {} issued by {} resolved to User {} with authorities {}\",\n-                    authentication.getClaims().getTokenId(),\n+                    authentication.getClaims().getJWTID(),\n                     authentication.getClaims().getIssuer(),\n                     username, authorities);\n "},{"sha":"314d2b5b71cddf5f29991c31b7aa9d4e331ee953","filename":"core/spring/src/main/java/org/apache/syncope/core/spring/security/JWTAuthentication.java","status":"modified","additions":4,"deletions":4,"changes":8,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fb3794e3446b61c452ab452705243ec5a693bda0/core%2Fspring%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fspring%2Fsecurity%2FJWTAuthentication.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fb3794e3446b61c452ab452705243ec5a693bda0/core%2Fspring%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fspring%2Fsecurity%2FJWTAuthentication.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fspring%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fspring%2Fsecurity%2FJWTAuthentication.java?ref=fb3794e3446b61c452ab452705243ec5a693bda0","patch":"@@ -18,6 +18,7 @@\n  */\n package org.apache.syncope.core.spring.security;\n \n+import com.nimbusds.jwt.JWTClaimsSet;\n import java.util.Collection;\n import java.util.HashSet;\n import java.util.Optional;\n@@ -26,7 +27,6 @@\n import org.apache.commons.lang3.StringUtils;\n import org.apache.commons.lang3.builder.EqualsBuilder;\n import org.apache.commons.lang3.builder.HashCodeBuilder;\n-import org.apache.cxf.rs.security.jose.jwt.JwtClaims;\n import org.springframework.security.core.Authentication;\n \n /**\n@@ -38,7 +38,7 @@ public class JWTAuthentication implements Authentication {\n \n     private static final long serialVersionUID = -2013733709281305394L;\n \n-    private final JwtClaims claims;\n+    private final JWTClaimsSet claims;\n \n     private final SyncopeAuthenticationDetails details;\n \n@@ -48,12 +48,12 @@ public class JWTAuthentication implements Authentication {\n \n     private boolean authenticated = false;\n \n-    public JWTAuthentication(final JwtClaims claims, final SyncopeAuthenticationDetails details) {\n+    public JWTAuthentication(final JWTClaimsSet claims, final SyncopeAuthenticationDetails details) {\n         this.claims = claims;\n         this.details = details;\n     }\n \n-    public JwtClaims getClaims() {\n+    public JWTClaimsSet getClaims() {\n         return claims;\n     }\n "},{"sha":"9a6eef9883ea165a47f854d668ed6f2ae39a9b09","filename":"core/spring/src/main/java/org/apache/syncope/core/spring/security/JWTAuthenticationFilter.java","status":"modified","additions":8,"deletions":7,"changes":15,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fb3794e3446b61c452ab452705243ec5a693bda0/core%2Fspring%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fspring%2Fsecurity%2FJWTAuthenticationFilter.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fb3794e3446b61c452ab452705243ec5a693bda0/core%2Fspring%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fspring%2Fsecurity%2FJWTAuthenticationFilter.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fspring%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fspring%2Fsecurity%2FJWTAuthenticationFilter.java?ref=fb3794e3446b61c452ab452705243ec5a693bda0","patch":"@@ -18,7 +18,10 @@\n  */\n package org.apache.syncope.core.spring.security;\n \n+import com.nimbusds.jose.JOSEException;\n+import com.nimbusds.jwt.SignedJWT;\n import java.io.IOException;\n+import java.text.ParseException;\n import java.util.Optional;\n import java.util.Set;\n import javax.servlet.FilterChain;\n@@ -27,8 +30,6 @@\n import javax.servlet.http.HttpServletResponse;\n import javax.ws.rs.core.HttpHeaders;\n import org.apache.commons.lang3.tuple.Pair;\n-import org.apache.cxf.rs.security.jose.jws.JwsException;\n-import org.apache.cxf.rs.security.jose.jws.JwsJwtCompactConsumer;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.springframework.security.authentication.AuthenticationManager;\n@@ -88,14 +89,14 @@ protected void doFilterInternal(\n         try {\n             credentialChecker.checkIsDefaultJWSKeyInUse();\n \n-            JwsJwtCompactConsumer consumer = new JwsJwtCompactConsumer(stringToken);\n-            JWTSSOProvider jwtSSOProvider = dataAccessor.getJWTSSOProvider(consumer.getJwtClaims().getIssuer());\n-            if (!consumer.verifySignatureWith(jwtSSOProvider)) {\n+            SignedJWT jwt = SignedJWT.parse(stringToken);\n+            JWTSSOProvider jwtSSOProvider = dataAccessor.getJWTSSOProvider(jwt.getJWTClaimsSet().getIssuer());\n+            if (!jwt.verify(jwtSSOProvider)) {\n                 throw new BadCredentialsException(\"Invalid signature found in JWT\");\n             }\n \n             JWTAuthentication jwtAuthentication =\n-                    new JWTAuthentication(consumer.getJwtClaims(), authenticationDetailsSource.buildDetails(request));\n+                    new JWTAuthentication(jwt.getJWTClaimsSet(), authenticationDetailsSource.buildDetails(request));\n             AuthContextUtils.callAsAdmin(jwtAuthentication.getDetails().getDomain(), () -> {\n                 Pair<String, Set<SyncopeGrantedAuthority>> authenticated = dataAccessor.authenticate(jwtAuthentication);\n                 jwtAuthentication.setUsername(authenticated.getLeft());\n@@ -105,7 +106,7 @@ protected void doFilterInternal(\n             SecurityContextHolder.getContext().setAuthentication(jwtAuthentication);\n \n             chain.doFilter(request, response);\n-        } catch (JwsException e) {\n+        } catch (ParseException | JOSEException e) {\n             SecurityContextHolder.clearContext();\n             this.authenticationEntryPoint.commence(\n                     request, response, new BadCredentialsException(\"Invalid JWT: \" + stringToken, e));"},{"sha":"2a5865d51441485266025c4a314aa4c9aba98bbc","filename":"core/spring/src/main/java/org/apache/syncope/core/spring/security/JWTAuthenticationProvider.java","status":"modified","additions":8,"deletions":7,"changes":15,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fb3794e3446b61c452ab452705243ec5a693bda0/core%2Fspring%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fspring%2Fsecurity%2FJWTAuthenticationProvider.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fb3794e3446b61c452ab452705243ec5a693bda0/core%2Fspring%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fspring%2Fsecurity%2FJWTAuthenticationProvider.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fspring%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fspring%2Fsecurity%2FJWTAuthenticationProvider.java?ref=fb3794e3446b61c452ab452705243ec5a693bda0","patch":"@@ -18,7 +18,8 @@\n  */\n package org.apache.syncope.core.spring.security;\n \n-import org.apache.cxf.rs.security.jose.jwt.JwtClaims;\n+import com.nimbusds.jwt.JWTClaimsSet;\n+import java.util.Date;\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.security.authentication.AuthenticationProvider;\n import org.springframework.security.authentication.CredentialsExpiredException;\n@@ -38,17 +39,17 @@ public class JWTAuthenticationProvider implements AuthenticationProvider {\n     public Authentication authenticate(final Authentication authentication) throws AuthenticationException {\n         JWTAuthentication jwtAuthentication = (JWTAuthentication) authentication;\n \n-        JwtClaims claims = jwtAuthentication.getClaims();\n+        JWTClaimsSet claims = jwtAuthentication.getClaims();\n         Long referenceTime = System.currentTimeMillis();\n \n-        Long expiryTime = claims.getExpiryTime();\n-        if (expiryTime == null || (expiryTime * 1000L) < referenceTime) {\n-            dataAccessor.removeExpired(claims.getTokenId());\n+        Date expiryTime = claims.getExpirationTime();\n+        if (expiryTime == null || expiryTime.getTime() < referenceTime) {\n+            dataAccessor.removeExpired(claims.getJWTID());\n             throw new CredentialsExpiredException(\"JWT is expired\");\n         }\n \n-        Long notBefore = claims.getNotBefore();\n-        if (notBefore == null || (notBefore * 1000L) > referenceTime) {\n+        Date notBefore = claims.getNotBeforeTime();\n+        if (notBefore == null || notBefore.getTime() > referenceTime) {\n             throw new CredentialsExpiredException(\"JWT not valid yet\");\n         }\n "},{"sha":"900aabb644b894afc0c09cc4ff94086066e6ceb1","filename":"core/spring/src/main/java/org/apache/syncope/core/spring/security/JWTSSOProvider.java","status":"modified","additions":4,"deletions":4,"changes":8,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fb3794e3446b61c452ab452705243ec5a693bda0/core%2Fspring%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fspring%2Fsecurity%2FJWTSSOProvider.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fb3794e3446b61c452ab452705243ec5a693bda0/core%2Fspring%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fspring%2Fsecurity%2FJWTSSOProvider.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fspring%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fspring%2Fsecurity%2FJWTSSOProvider.java?ref=fb3794e3446b61c452ab452705243ec5a693bda0","patch":"@@ -18,17 +18,17 @@\n  */\n package org.apache.syncope.core.spring.security;\n \n+import com.nimbusds.jose.JWSVerifier;\n+import com.nimbusds.jwt.JWTClaimsSet;\n import java.util.Set;\n import org.apache.commons.lang3.tuple.Pair;\n-import org.apache.cxf.rs.security.jose.jws.JwsSignatureVerifier;\n-import org.apache.cxf.rs.security.jose.jwt.JwtClaims;\n import org.apache.syncope.core.persistence.api.entity.user.User;\n \n /**\n  * Enables a generic mechanism for JWT validation and subject resolution which allows to plug in implementations\n  * recognizing JWT produced by third parties.\n  */\n-public interface JWTSSOProvider extends JwsSignatureVerifier {\n+public interface JWTSSOProvider extends JWSVerifier {\n \n     /**\n      * Gives the identifier for the JWT issuer verified by this instance.\n@@ -44,5 +44,5 @@ public interface JWTSSOProvider extends JwsSignatureVerifier {\n      * @param jwtClaims JWT claims\n      * @return internal User, with authorities, matching the provided JWT claims, if found; otherwise null\n      */\n-    Pair<User, Set<SyncopeGrantedAuthority>> resolve(JwtClaims jwtClaims);\n+    Pair<User, Set<SyncopeGrantedAuthority>> resolve(JWTClaimsSet jwtClaims);\n }"},{"sha":"1c71c05adecafdbee1f1c5c8c3e15ce4c4dd0832","filename":"core/spring/src/main/java/org/apache/syncope/core/spring/security/SecurityContext.java","status":"modified","additions":19,"deletions":13,"changes":32,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fb3794e3446b61c452ab452705243ec5a693bda0/core%2Fspring%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fspring%2Fsecurity%2FSecurityContext.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fb3794e3446b61c452ab452705243ec5a693bda0/core%2Fspring%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fspring%2Fsecurity%2FSecurityContext.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fspring%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fspring%2Fsecurity%2FSecurityContext.java?ref=fb3794e3446b61c452ab452705243ec5a693bda0","patch":"@@ -18,10 +18,14 @@\n  */\n package org.apache.syncope.core.spring.security;\n \n-import org.apache.cxf.rs.security.jose.jwa.SignatureAlgorithm;\n+import com.nimbusds.jose.JOSEException;\n+import com.nimbusds.jose.JWSAlgorithm;\n+import com.nimbusds.jose.KeyLengthException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.InvalidKeySpecException;\n import org.apache.syncope.core.spring.ApplicationContextProvider;\n-import org.apache.syncope.core.spring.security.jws.AccessTokenJwsSignatureProvider;\n-import org.apache.syncope.core.spring.security.jws.AccessTokenJwsSignatureVerifier;\n+import org.apache.syncope.core.spring.security.jws.AccessTokenJWSSigner;\n+import org.apache.syncope.core.spring.security.jws.AccessTokenJWSVerifier;\n import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\n import org.springframework.context.EnvironmentAware;\n import org.springframework.context.annotation.Bean;\n@@ -85,20 +89,22 @@ public DefaultCredentialChecker credentialChecker() {\n \n     @ConditionalOnMissingBean\n     @Bean\n-    public AccessTokenJwsSignatureVerifier accessTokenJwsSignatureVerifier() {\n-        AccessTokenJwsSignatureVerifier verifier = new AccessTokenJwsSignatureVerifier();\n-        verifier.setJwsAlgorithm(env.getProperty(\"jwsAlgorithm\", SignatureAlgorithm.class));\n-        verifier.setJwsKey(jwsKey());\n-        return verifier;\n+    public AccessTokenJWSVerifier accessTokenJWSVerifier()\n+            throws JOSEException, NoSuchAlgorithmException, InvalidKeySpecException {\n+\n+        return new AccessTokenJWSVerifier(\n+                JWSAlgorithm.parse(env.getProperty(\"jwsAlgorithm\")),\n+                jwsKey());\n     }\n \n     @ConditionalOnMissingBean\n     @Bean\n-    public AccessTokenJwsSignatureProvider accessTokenJwsSignatureProvider() {\n-        AccessTokenJwsSignatureProvider provider = new AccessTokenJwsSignatureProvider();\n-        provider.setJwsAlgorithm(env.getProperty(\"jwsAlgorithm\", SignatureAlgorithm.class));\n-        provider.setJwsKey(jwsKey());\n-        return provider;\n+    public AccessTokenJWSSigner accessTokenJWSSigner()\n+            throws KeyLengthException, NoSuchAlgorithmException, InvalidKeySpecException {\n+\n+        return new AccessTokenJWSSigner(\n+                JWSAlgorithm.parse(env.getProperty(\"jwsAlgorithm\")),\n+                jwsKey());\n     }\n \n     @ConditionalOnMissingBean"},{"sha":"2253b4aeb73107d902b6175f372662f06d3443ae","filename":"core/spring/src/main/java/org/apache/syncope/core/spring/security/SyncopeJWTSSOProvider.java","status":"modified","additions":20,"deletions":15,"changes":35,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fb3794e3446b61c452ab452705243ec5a693bda0/core%2Fspring%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fspring%2Fsecurity%2FSyncopeJWTSSOProvider.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fb3794e3446b61c452ab452705243ec5a693bda0/core%2Fspring%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fspring%2Fsecurity%2FSyncopeJWTSSOProvider.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fspring%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fspring%2Fsecurity%2FSyncopeJWTSSOProvider.java?ref=fb3794e3446b61c452ab452705243ec5a693bda0","patch":"@@ -19,21 +19,22 @@\n package org.apache.syncope.core.spring.security;\n \n import com.fasterxml.jackson.core.type.TypeReference;\n-\n+import com.nimbusds.jose.JOSEException;\n+import com.nimbusds.jose.JWSAlgorithm;\n+import com.nimbusds.jose.JWSHeader;\n+import com.nimbusds.jose.jca.JCAContext;\n+import com.nimbusds.jose.util.Base64URL;\n+import com.nimbusds.jwt.JWTClaimsSet;\n import java.util.Set;\n import javax.annotation.Resource;\n import org.apache.commons.lang3.tuple.Pair;\n-import org.apache.cxf.rs.security.jose.jwa.SignatureAlgorithm;\n-import org.apache.cxf.rs.security.jose.jws.JwsHeaders;\n-import org.apache.cxf.rs.security.jose.jws.JwsVerificationSignature;\n-import org.apache.cxf.rs.security.jose.jwt.JwtClaims;\n import org.apache.syncope.common.lib.types.CipherAlgorithm;\n import org.apache.syncope.core.persistence.api.dao.AccessTokenDAO;\n import org.apache.syncope.core.persistence.api.dao.UserDAO;\n import org.apache.syncope.core.persistence.api.entity.AccessToken;\n import org.apache.syncope.core.persistence.api.entity.user.User;\n import org.apache.syncope.core.provisioning.api.serialization.POJOHelper;\n-import org.apache.syncope.core.spring.security.jws.AccessTokenJwsSignatureVerifier;\n+import org.apache.syncope.core.spring.security.jws.AccessTokenJWSVerifier;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.springframework.beans.factory.annotation.Autowired;\n@@ -52,7 +53,7 @@ public class SyncopeJWTSSOProvider implements JWTSSOProvider {\n     private String jwtIssuer;\n \n     @Autowired\n-    private AccessTokenJwsSignatureVerifier delegate;\n+    private AccessTokenJWSVerifier delegate;\n \n     @Autowired\n     private UserDAO userDAO;\n@@ -66,27 +67,31 @@ public String getIssuer() {\n     }\n \n     @Override\n-    public SignatureAlgorithm getAlgorithm() {\n-        return delegate.getAlgorithm();\n+    public Set<JWSAlgorithm> supportedJWSAlgorithms() {\n+        return delegate.supportedJWSAlgorithms();\n     }\n \n     @Override\n-    public boolean verify(final JwsHeaders headers, final String unsignedText, final byte[] signature) {\n-        return delegate.verify(headers, unsignedText, signature);\n+    public JCAContext getJCAContext() {\n+        return delegate.getJCAContext();\n     }\n \n     @Override\n-    public JwsVerificationSignature createJwsVerificationSignature(final JwsHeaders headers) {\n-        return delegate.createJwsVerificationSignature(headers);\n+    public boolean verify(\n+            final JWSHeader header,\n+            final byte[] signingInput,\n+            final Base64URL signature) throws JOSEException {\n+\n+        return delegate.verify(header, signingInput, signature);\n     }\n \n     @Transactional(readOnly = true)\n     @Override\n-    public Pair<User, Set<SyncopeGrantedAuthority>> resolve(final JwtClaims jwtClaims) {\n+    public Pair<User, Set<SyncopeGrantedAuthority>> resolve(final JWTClaimsSet jwtClaims) {\n         User user = userDAO.findByUsername(jwtClaims.getSubject());\n         Set<SyncopeGrantedAuthority> authorities = Set.of();\n         if (user != null) {\n-            AccessToken accessToken = accessTokenDAO.find(jwtClaims.getTokenId());\n+            AccessToken accessToken = accessTokenDAO.find(jwtClaims.getJWTID());\n             if (accessToken != null && accessToken.getAuthorities() != null) {\n                 try {\n                     authorities = POJOHelper.deserialize("},{"sha":"b6f7da7ce1cff20de796eeeee88c13981c032ebb","filename":"core/spring/src/main/java/org/apache/syncope/core/spring/security/jws/AccessTokenJWSSigner.java","status":"renamed","additions":35,"deletions":36,"changes":71,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fb3794e3446b61c452ab452705243ec5a693bda0/core%2Fspring%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fspring%2Fsecurity%2Fjws%2FAccessTokenJWSSigner.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fb3794e3446b61c452ab452705243ec5a693bda0/core%2Fspring%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fspring%2Fsecurity%2Fjws%2FAccessTokenJWSSigner.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fspring%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fspring%2Fsecurity%2Fjws%2FAccessTokenJWSSigner.java?ref=fb3794e3446b61c452ab452705243ec5a693bda0","patch":"@@ -18,74 +18,73 @@\n  */\n package org.apache.syncope.core.spring.security.jws;\n \n+import com.nimbusds.jose.JOSEException;\n+import com.nimbusds.jose.JWSAlgorithm;\n+import com.nimbusds.jose.JWSHeader;\n+import com.nimbusds.jose.JWSSigner;\n+import com.nimbusds.jose.KeyLengthException;\n+import com.nimbusds.jose.crypto.MACSigner;\n+import com.nimbusds.jose.crypto.RSASSASigner;\n+import com.nimbusds.jose.jca.JCAContext;\n+import com.nimbusds.jose.util.Base64URL;\n import java.security.KeyFactory;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.InvalidKeySpecException;\n import java.security.spec.PKCS8EncodedKeySpec;\n import java.util.Base64;\n+import java.util.Set;\n import org.apache.commons.lang3.StringUtils;\n-import org.apache.cxf.rs.security.jose.jwa.SignatureAlgorithm;\n-import org.apache.cxf.rs.security.jose.jws.HmacJwsSignatureProvider;\n-import org.apache.cxf.rs.security.jose.jws.JwsHeaders;\n-import org.apache.cxf.rs.security.jose.jws.JwsSignature;\n-import org.apache.cxf.rs.security.jose.jws.JwsSignatureProvider;\n-import org.apache.cxf.rs.security.jose.jws.PrivateKeyJwsSignatureProvider;\n-import org.springframework.beans.factory.InitializingBean;\n \n-public class AccessTokenJwsSignatureProvider implements JwsSignatureProvider, InitializingBean {\n+public class AccessTokenJWSSigner implements JWSSigner {\n \n-    private SignatureAlgorithm jwsAlgorithm;\n+    private final JWSAlgorithm jwsAlgorithm;\n \n-    private String jwsKey;\n+    private final JWSSigner delegate;\n \n-    private JwsSignatureProvider delegate;\n+    public AccessTokenJWSSigner(final JWSAlgorithm jwsAlgorithm, final String jwsKey)\n+            throws KeyLengthException, NoSuchAlgorithmException, InvalidKeySpecException {\n \n-    public void setJwsAlgorithm(final SignatureAlgorithm jwsAlgorithm) {\n-        this.jwsAlgorithm = jwsAlgorithm;\n-    }\n-\n-    public void setJwsKey(final String jwsKey) {\n-        this.jwsKey = jwsKey;\n-    }\n-\n-    @Override\n-    public void afterPropertiesSet() throws Exception {\n         if (jwsAlgorithm == null) {\n-            throw new IllegalArgumentException(\"An instance of \" + SignatureAlgorithm.class + \" is required\");\n+            throw new IllegalArgumentException(\"An instance of \" + JWSAlgorithm.class + \" is required\");\n         }\n+        this.jwsAlgorithm = jwsAlgorithm;\n \n-        if (SignatureAlgorithm.isPublicKeyAlgorithm(jwsAlgorithm)) {\n-            if (!jwsAlgorithm.getJwaName().startsWith(\"RS\")) {\n-                throw new IllegalArgumentException(jwsAlgorithm.getJavaName() + \" not supported.\");\n-            }\n-\n+        if (JWSAlgorithm.Family.RSA.contains(jwsAlgorithm)) {\n             if (jwsKey == null || jwsKey.indexOf(':') == -1) {\n                 throw new IllegalArgumentException(\"A key pair is required, in the 'private:public' format\");\n             }\n \n             KeyFactory kf = KeyFactory.getInstance(\"RSA\");\n             PKCS8EncodedKeySpec keySpecPKCS8 = new PKCS8EncodedKeySpec(\n                     Base64.getDecoder().decode(StringUtils.substringBefore(jwsKey, \":\").getBytes()));\n-            delegate = new PrivateKeyJwsSignatureProvider(kf.generatePrivate(keySpecPKCS8), jwsAlgorithm);\n-        } else {\n+            delegate = new RSASSASigner(kf.generatePrivate(keySpecPKCS8));\n+        } else if (JWSAlgorithm.Family.HMAC_SHA.contains(jwsAlgorithm)) {\n             if (jwsKey == null) {\n                 throw new IllegalArgumentException(\"A shared key is required\");\n             }\n \n-            delegate = new HmacJwsSignatureProvider(jwsKey.getBytes(), jwsAlgorithm);\n+            delegate = new MACSigner(jwsKey);\n+        } else {\n+            throw new IllegalArgumentException(\"Unsupported JWS algorithm: \" + jwsAlgorithm.getName());\n         }\n     }\n \n+    public JWSAlgorithm getJwsAlgorithm() {\n+        return jwsAlgorithm;\n+    }\n+\n     @Override\n-    public SignatureAlgorithm getAlgorithm() {\n-        return delegate.getAlgorithm();\n+    public Set<JWSAlgorithm> supportedJWSAlgorithms() {\n+        return delegate.supportedJWSAlgorithms();\n     }\n \n     @Override\n-    public byte[] sign(final JwsHeaders headers, final byte[] content) {\n-        return delegate.sign(headers, content);\n+    public JCAContext getJCAContext() {\n+        return delegate.getJCAContext();\n     }\n \n     @Override\n-    public JwsSignature createJwsSignature(final JwsHeaders headers) {\n-        return delegate.createJwsSignature(headers);\n+    public Base64URL sign(final JWSHeader header, final byte[] signingInput) throws JOSEException {\n+        return delegate.sign(header, signingInput);\n     }\n }","previous_filename":"core/spring/src/main/java/org/apache/syncope/core/spring/security/jws/AccessTokenJwsSignatureProvider.java"},{"sha":"6fa22758e8ba860ed1acc9c638a9b0c7df9fdf6f","filename":"core/spring/src/main/java/org/apache/syncope/core/spring/security/jws/AccessTokenJWSVerifier.java","status":"added","additions":87,"deletions":0,"changes":87,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fb3794e3446b61c452ab452705243ec5a693bda0/core%2Fspring%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fspring%2Fsecurity%2Fjws%2FAccessTokenJWSVerifier.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fb3794e3446b61c452ab452705243ec5a693bda0/core%2Fspring%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fspring%2Fsecurity%2Fjws%2FAccessTokenJWSVerifier.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fspring%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fspring%2Fsecurity%2Fjws%2FAccessTokenJWSVerifier.java?ref=fb3794e3446b61c452ab452705243ec5a693bda0","patch":"@@ -0,0 +1,87 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.core.spring.security.jws;\n+\n+import com.nimbusds.jose.JOSEException;\n+import com.nimbusds.jose.JWSAlgorithm;\n+import com.nimbusds.jose.JWSHeader;\n+import com.nimbusds.jose.JWSVerifier;\n+import com.nimbusds.jose.crypto.MACVerifier;\n+import com.nimbusds.jose.crypto.RSASSAVerifier;\n+import com.nimbusds.jose.jca.JCAContext;\n+import com.nimbusds.jose.util.Base64URL;\n+import java.security.KeyFactory;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.interfaces.RSAPublicKey;\n+import java.security.spec.InvalidKeySpecException;\n+import java.security.spec.X509EncodedKeySpec;\n+import java.util.Base64;\n+import java.util.Set;\n+import org.apache.commons.lang3.StringUtils;\n+\n+public class AccessTokenJWSVerifier implements JWSVerifier {\n+\n+    private final JWSVerifier delegate;\n+\n+    public AccessTokenJWSVerifier(final JWSAlgorithm jwsAlgorithm, final String jwsKey)\n+            throws JOSEException, NoSuchAlgorithmException, InvalidKeySpecException {\n+\n+        if (jwsAlgorithm == null) {\n+            throw new IllegalArgumentException(\"An instance of \" + JWSAlgorithm.class + \" is required\");\n+        }\n+\n+        if (JWSAlgorithm.Family.RSA.contains(jwsAlgorithm)) {\n+            if (jwsKey == null || jwsKey.indexOf(':') == -1) {\n+                throw new IllegalArgumentException(\"A key pair is required, in the 'private:public' format\");\n+            }\n+\n+            KeyFactory kf = KeyFactory.getInstance(\"RSA\");\n+            X509EncodedKeySpec keySpecX509 = new X509EncodedKeySpec(\n+                    Base64.getDecoder().decode(StringUtils.substringAfter(jwsKey, \":\").getBytes()));\n+            delegate = new RSASSAVerifier((RSAPublicKey) kf.generatePublic(keySpecX509));\n+        } else if (JWSAlgorithm.Family.HMAC_SHA.contains(jwsAlgorithm)) {\n+            if (jwsKey == null) {\n+                throw new IllegalArgumentException(\"A shared key is required\");\n+            }\n+\n+            delegate = new MACVerifier(jwsKey);\n+        } else {\n+            throw new IllegalArgumentException(\"Unsupported JWS algorithm: \" + jwsAlgorithm.getName());\n+        }\n+    }\n+\n+    @Override\n+    public Set<JWSAlgorithm> supportedJWSAlgorithms() {\n+        return delegate.supportedJWSAlgorithms();\n+    }\n+\n+    @Override\n+    public JCAContext getJCAContext() {\n+        return delegate.getJCAContext();\n+    }\n+\n+    @Override\n+    public boolean verify(\n+            final JWSHeader header,\n+            final byte[] signingInput,\n+            final Base64URL signature) throws JOSEException {\n+\n+        return delegate.verify(header, signingInput, signature);\n+    }\n+}"},{"sha":"0a6f6b952c198696debbf39ab4cb0c28c853ede8","filename":"core/spring/src/main/java/org/apache/syncope/core/spring/security/jws/AccessTokenJwsSignatureVerifier.java","status":"removed","additions":0,"deletions":91,"changes":91,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/68151a717080f95aa3301002eac839061ec30008/core%2Fspring%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fspring%2Fsecurity%2Fjws%2FAccessTokenJwsSignatureVerifier.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/68151a717080f95aa3301002eac839061ec30008/core%2Fspring%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fspring%2Fsecurity%2Fjws%2FAccessTokenJwsSignatureVerifier.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fspring%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fspring%2Fsecurity%2Fjws%2FAccessTokenJwsSignatureVerifier.java?ref=68151a717080f95aa3301002eac839061ec30008","patch":"@@ -1,91 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-package org.apache.syncope.core.spring.security.jws;\n-\n-import java.security.KeyFactory;\n-import java.security.spec.X509EncodedKeySpec;\n-import java.util.Base64;\n-import org.apache.commons.lang3.StringUtils;\n-import org.apache.cxf.rs.security.jose.jwa.SignatureAlgorithm;\n-import org.apache.cxf.rs.security.jose.jws.HmacJwsSignatureVerifier;\n-import org.apache.cxf.rs.security.jose.jws.JwsHeaders;\n-import org.apache.cxf.rs.security.jose.jws.JwsSignatureVerifier;\n-import org.apache.cxf.rs.security.jose.jws.JwsVerificationSignature;\n-import org.apache.cxf.rs.security.jose.jws.PublicKeyJwsSignatureVerifier;\n-import org.springframework.beans.factory.InitializingBean;\n-\n-public class AccessTokenJwsSignatureVerifier implements JwsSignatureVerifier, InitializingBean {\n-\n-    private SignatureAlgorithm jwsAlgorithm;\n-\n-    private String jwsKey;\n-\n-    private JwsSignatureVerifier delegate;\n-\n-    public void setJwsAlgorithm(final SignatureAlgorithm jwsAlgorithm) {\n-        this.jwsAlgorithm = jwsAlgorithm;\n-    }\n-\n-    public void setJwsKey(final String jwsKey) {\n-        this.jwsKey = jwsKey;\n-    }\n-\n-    @Override\n-    public void afterPropertiesSet() throws Exception {\n-        if (jwsAlgorithm == null) {\n-            throw new IllegalArgumentException(\"An instance of \" + SignatureAlgorithm.class + \" is required\");\n-        }\n-\n-        if (SignatureAlgorithm.isPublicKeyAlgorithm(jwsAlgorithm)) {\n-            if (!jwsAlgorithm.getJwaName().startsWith(\"RS\")) {\n-                throw new IllegalArgumentException(jwsAlgorithm.getJavaName() + \" not supported.\");\n-            }\n-\n-            if (jwsKey == null || jwsKey.indexOf(':') == -1) {\n-                throw new IllegalArgumentException(\"A key pair is required, in the 'private:public' format\");\n-            }\n-\n-            KeyFactory kf = KeyFactory.getInstance(\"RSA\");\n-            X509EncodedKeySpec keySpecX509 = new X509EncodedKeySpec(\n-                    Base64.getDecoder().decode(StringUtils.substringAfter(jwsKey, \":\").getBytes()));\n-            delegate = new PublicKeyJwsSignatureVerifier(kf.generatePublic(keySpecX509), jwsAlgorithm);\n-        } else {\n-            if (jwsKey == null) {\n-                throw new IllegalArgumentException(\"A shared key is required\");\n-            }\n-\n-            delegate = new HmacJwsSignatureVerifier(jwsKey.getBytes(), jwsAlgorithm);\n-        }\n-    }\n-\n-    @Override\n-    public SignatureAlgorithm getAlgorithm() {\n-        return delegate.getAlgorithm();\n-    }\n-\n-    @Override\n-    public boolean verify(final JwsHeaders headers, final String unsignedText, final byte[] signature) {\n-        return delegate.verify(headers, unsignedText, signature);\n-    }\n-\n-    @Override\n-    public JwsVerificationSignature createJwsVerificationSignature(final JwsHeaders headers) {\n-        return delegate.createJwsVerificationSignature(headers);\n-    }\n-}"},{"sha":"59978adecab74ef8c408ccf4da546f3f5ed24e79","filename":"ext/saml2sp4ui/logic/src/main/java/org/apache/syncope/core/logic/SAML2SP4UILogic.java","status":"modified","additions":16,"deletions":14,"changes":30,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fb3794e3446b61c452ab452705243ec5a693bda0/ext%2Fsaml2sp4ui%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Flogic%2FSAML2SP4UILogic.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fb3794e3446b61c452ab452705243ec5a693bda0/ext%2Fsaml2sp4ui%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Flogic%2FSAML2SP4UILogic.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/ext%2Fsaml2sp4ui%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Flogic%2FSAML2SP4UILogic.java?ref=fb3794e3446b61c452ab452705243ec5a693bda0","patch":"@@ -18,21 +18,21 @@\n  */\n package org.apache.syncope.core.logic;\n \n+import com.nimbusds.jwt.JWTClaimsSet;\n+import com.nimbusds.jwt.SignedJWT;\n import java.io.OutputStream;\n import java.io.OutputStreamWriter;\n import java.lang.reflect.Method;\n+import java.text.ParseException;\n import java.util.Base64;\n import java.util.Date;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n import java.util.Optional;\n import java.util.concurrent.ConcurrentHashMap;\n-import javax.annotation.Resource;\n import org.apache.commons.lang3.StringUtils;\n import org.apache.commons.lang3.tuple.Pair;\n-import org.apache.cxf.rs.security.jose.jws.JwsJwtCompactConsumer;\n-import org.apache.cxf.rs.security.jose.jws.JwsSignatureVerifier;\n import org.apache.syncope.common.lib.Attr;\n import org.apache.syncope.common.lib.SyncopeClientException;\n import org.apache.syncope.common.lib.to.EntityTO;\n@@ -119,9 +119,6 @@ public class SAML2SP4UILogic extends AbstractTransactionalLogic<EntityTO> {\n     @Autowired\n     private AuthDataAccessor authDataAccessor;\n \n-    @Resource(name = \"accessTokenJwsSignatureVerifier\")\n-    private JwsSignatureVerifier jwsSignatureVerifier;\n-\n     private final Map<String, String> metadataCache = new ConcurrentHashMap<>();\n \n     private static String validateUrl(final String url) {\n@@ -425,14 +422,19 @@ public SAML2Request createLogoutRequest(\n             final String spEntityID,\n             final String urlContext) {\n \n-        // 1. fetch the current JWT used for Syncope authentication and destroy it\n-        JwsJwtCompactConsumer consumer = new JwsJwtCompactConsumer(accessToken);\n-        if (!consumer.verifySignatureWith(jwsSignatureVerifier)) {\n-            throw new IllegalArgumentException(\"Invalid signature found in Access Token\");\n+        // 1. fetch the current JWT used for Syncope authentication\n+        JWTClaimsSet claimsSet;\n+        try {\n+            SignedJWT jwt = SignedJWT.parse(accessToken);\n+            claimsSet = jwt.getJWTClaimsSet();\n+        } catch (ParseException e) {\n+            SyncopeClientException sce = SyncopeClientException.build(ClientExceptionType.InvalidAccessToken);\n+            sce.getElements().add(e.getMessage());\n+            throw sce;\n         }\n \n         // 2. look for SAML2Client\n-        String idpEntityID = (String) consumer.getJwtClaims().getClaim(JWT_CLAIM_IDP_ENTITYID);\n+        String idpEntityID = (String) claimsSet.getClaim(JWT_CLAIM_IDP_ENTITYID);\n         if (idpEntityID == null) {\n             throw new NotFoundException(\"No SAML 2.0 IdP information found in the access token\");\n         }\n@@ -444,13 +446,13 @@ public SAML2Request createLogoutRequest(\n \n         // 3. create LogoutRequest\n         SAML2Profile saml2Profile = new SAML2Profile();\n-        saml2Profile.setId((String) consumer.getJwtClaims().getClaim(JWT_CLAIM_NAMEID_VALUE));\n+        saml2Profile.setId((String) claimsSet.getClaim(JWT_CLAIM_NAMEID_VALUE));\n         saml2Profile.addAuthenticationAttribute(\n                 SAML2Authenticator.SAML_NAME_ID_FORMAT,\n-                consumer.getJwtClaims().getClaim(JWT_CLAIM_NAMEID_FORMAT));\n+                claimsSet.getClaim(JWT_CLAIM_NAMEID_FORMAT));\n         saml2Profile.addAuthenticationAttribute(\n                 SAML2Authenticator.SESSION_INDEX,\n-                consumer.getJwtClaims().getClaim(JWT_CLAIM_SESSIONINDEX));\n+                claimsSet.getClaim(JWT_CLAIM_SESSIONINDEX));\n \n         SAML2SP4UIContext ctx = new SAML2SP4UIContext(\n                 saml2Client.getConfiguration().getSpLogoutRequestBindingType(), null);"},{"sha":"8b2137af144b1ce27fa677ccba97a34c82d08af6","filename":"fit/core-reference/src/main/java/org/apache/syncope/fit/core/reference/CustomJWTSSOProvider.java","status":"modified","additions":28,"deletions":17,"changes":45,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fb3794e3446b61c452ab452705243ec5a693bda0/fit%2Fcore-reference%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2Freference%2FCustomJWTSSOProvider.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fb3794e3446b61c452ab452705243ec5a693bda0/fit%2Fcore-reference%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2Freference%2FCustomJWTSSOProvider.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/fit%2Fcore-reference%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2Freference%2FCustomJWTSSOProvider.java?ref=fb3794e3446b61c452ab452705243ec5a693bda0","patch":"@@ -18,15 +18,17 @@\n  */\n package org.apache.syncope.fit.core.reference;\n \n+import com.nimbusds.jose.JOSEException;\n+import com.nimbusds.jose.JWSAlgorithm;\n+import com.nimbusds.jose.JWSHeader;\n+import com.nimbusds.jose.JWSVerifier;\n+import com.nimbusds.jose.crypto.MACVerifier;\n+import com.nimbusds.jose.jca.JCAContext;\n+import com.nimbusds.jose.util.Base64URL;\n+import com.nimbusds.jwt.JWTClaimsSet;\n import java.util.List;\n import java.util.Set;\n import org.apache.commons.lang3.tuple.Pair;\n-import org.apache.cxf.rs.security.jose.jwa.SignatureAlgorithm;\n-import org.apache.cxf.rs.security.jose.jws.HmacJwsSignatureVerifier;\n-import org.apache.cxf.rs.security.jose.jws.JwsHeaders;\n-import org.apache.cxf.rs.security.jose.jws.JwsSignatureVerifier;\n-import org.apache.cxf.rs.security.jose.jws.JwsVerificationSignature;\n-import org.apache.cxf.rs.security.jose.jwt.JwtClaims;\n import org.apache.syncope.common.lib.types.AnyTypeKind;\n import org.apache.syncope.core.persistence.api.dao.AnySearchDAO;\n import org.apache.syncope.core.persistence.api.dao.search.AttrCond;\n@@ -45,18 +47,23 @@ public class CustomJWTSSOProvider implements JWTSSOProvider {\n \n     public static final String ISSUER = \"custom-issuer\";\n \n-    public static final String CUSTOM_KEY = \"12345678910987654321\";\n+    public static final String CUSTOM_KEY =\n+            \"XW3eTdntLa9Zsz2t4Vm6TNUya8xJEezFS7NVD3ZIZKOMdmSPMfi40rIvyBzXdbqD7TTsp6grcVW3AvRhZnFzZNaLdp6kJ2HXU9X9t2arVK\"\n+            + \"42bIAp7XOw6aZg8v4OOXReZ9YkuAKtGwKC1JvPMKCz0c28AhJWd3YX5MpG6prXExQpFFVuweA6xTPxf06nYEFSOmKJ9ddJAcIx4Z8qyY\"\n+            + \"mDJyNscMU8eVVM7aCR9zrCAHnjRZI2i6OnStAEVuqfGL25tK9AUKPVvyWljHNZ6ugXkstF873QaYJTBst1U2Zl9XsZnyeKrFEwwVHipp\"\n+            + \"vfHwo2xu6VKySyJpZtaqVrjXFqpgFGRwEm890tCm8JhEG6GgJPqcnFHrYC180LqBZSjnNQGvA7eCSFVrABWcWnXDJCIHWbn0Wv153Vf4\"\n+            + \"ZH75XEEYY53KsOS2T2GAmoqV3Izz7RL8O5dntgNLevl5gZb6MbYFURnQt0vALeObxMmv459FsXinzpAVihriOZWAudpN6Q\";\n \n-    private final JwsSignatureVerifier delegate;\n+    private final JWSVerifier delegate;\n \n     @Autowired\n     private AnySearchDAO searchDAO;\n \n     @Autowired\n     private AuthDataAccessor authDataAccessor;\n \n-    public CustomJWTSSOProvider() {\n-        delegate = new HmacJwsSignatureVerifier(CUSTOM_KEY.getBytes(), SignatureAlgorithm.HS512);\n+    public CustomJWTSSOProvider() throws JOSEException {\n+        delegate = new MACVerifier(CUSTOM_KEY);\n     }\n \n     @Override\n@@ -65,23 +72,27 @@ public String getIssuer() {\n     }\n \n     @Override\n-    public SignatureAlgorithm getAlgorithm() {\n-        return delegate.getAlgorithm();\n+    public Set<JWSAlgorithm> supportedJWSAlgorithms() {\n+        return delegate.supportedJWSAlgorithms();\n     }\n \n     @Override\n-    public boolean verify(final JwsHeaders headers, final String unsignedText, final byte[] signature) {\n-        return delegate.verify(headers, unsignedText, signature);\n+    public JCAContext getJCAContext() {\n+        return delegate.getJCAContext();\n     }\n \n     @Override\n-    public JwsVerificationSignature createJwsVerificationSignature(final JwsHeaders headers) {\n-        return delegate.createJwsVerificationSignature(headers);\n+    public boolean verify(\n+            final JWSHeader header,\n+            final byte[] signingInput,\n+            final Base64URL signature) throws JOSEException {\n+\n+        return delegate.verify(header, signingInput, signature);\n     }\n \n     @Transactional(readOnly = true)\n     @Override\n-    public Pair<User, Set<SyncopeGrantedAuthority>> resolve(final JwtClaims jwtClaims) {\n+    public Pair<User, Set<SyncopeGrantedAuthority>> resolve(final JWTClaimsSet jwtClaims) {\n         AttrCond userIdCond = new AttrCond();\n         userIdCond.setSchema(\"userId\");\n         userIdCond.setType(AttrCond.Type.EQ);"},{"sha":"7f2202ef32c7b509c2fe178825e77568789b537d","filename":"fit/core-reference/src/test/java/org/apache/syncope/fit/AbstractITCase.java","status":"modified","additions":3,"deletions":3,"changes":6,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fb3794e3446b61c452ab452705243ec5a693bda0/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2FAbstractITCase.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fb3794e3446b61c452ab452705243ec5a693bda0/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2FAbstractITCase.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2FAbstractITCase.java?ref=fb3794e3446b61c452ab452705243ec5a693bda0","patch":"@@ -25,6 +25,7 @@\n import com.fasterxml.jackson.databind.ObjectMapper;\n import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n import com.fasterxml.jackson.dataformat.yaml.YAMLMapper;\n+import com.nimbusds.jose.JWSAlgorithm;\n import java.io.IOException;\n import java.io.InputStream;\n import java.net.URI;\n@@ -50,7 +51,6 @@\n import org.apache.commons.lang3.StringUtils;\n import org.apache.commons.lang3.tuple.Pair;\n import org.apache.cxf.jaxrs.client.WebClient;\n-import org.apache.cxf.rs.security.jose.jwa.SignatureAlgorithm;\n import org.apache.syncope.client.lib.SyncopeClient;\n import org.apache.syncope.client.lib.SyncopeClientFactoryBean;\n import org.apache.syncope.common.keymaster.client.api.ConfParamOps;\n@@ -243,7 +243,7 @@ public abstract class AbstractITCase {\n \n     protected static String JWT_ISSUER;\n \n-    protected static SignatureAlgorithm JWS_ALGORITHM;\n+    protected static JWSAlgorithm JWS_ALGORITHM;\n \n     protected static SyncopeClientFactoryBean clientFactory;\n \n@@ -352,7 +352,7 @@ public static void securitySetup() {\n             ANONYMOUS_UNAME = props.getProperty(\"anonymousUser\");\n             ANONYMOUS_KEY = props.getProperty(\"anonymousKey\");\n             JWT_ISSUER = props.getProperty(\"jwtIssuer\");\n-            JWS_ALGORITHM = SignatureAlgorithm.valueOf(props.getProperty(\"jwsAlgorithm\"));\n+            JWS_ALGORITHM = JWSAlgorithm.parse(props.getProperty(\"jwsAlgorithm\"));\n             JWS_KEY = props.getProperty(\"jwsKey\");\n         } catch (Exception e) {\n             LOG.error(\"Could not read security.properties\", e);"},{"sha":"1ebefd7a6c0815dbe7a23a9e04932a415eb7e758","filename":"fit/core-reference/src/test/java/org/apache/syncope/fit/core/JWTITCase.java","status":"modified","additions":212,"deletions":286,"changes":498,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fb3794e3446b61c452ab452705243ec5a693bda0/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FJWTITCase.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fb3794e3446b61c452ab452705243ec5a693bda0/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FJWTITCase.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FJWTITCase.java?ref=fb3794e3446b61c452ab452705243ec5a693bda0","patch":"@@ -26,7 +26,18 @@\n import static org.junit.jupiter.api.Assertions.fail;\n import static org.junit.jupiter.api.Assumptions.assumeFalse;\n \n+import com.nimbusds.jose.JOSEException;\n+import com.nimbusds.jose.JWSAlgorithm;\n+import com.nimbusds.jose.JWSHeader;\n+import com.nimbusds.jose.KeyLengthException;\n+import com.nimbusds.jose.crypto.MACSigner;\n+import com.nimbusds.jwt.JWT;\n+import com.nimbusds.jwt.JWTClaimsSet;\n+import com.nimbusds.jwt.PlainJWT;\n+import com.nimbusds.jwt.SignedJWT;\n import java.security.AccessControlException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.InvalidKeySpecException;\n import java.text.ParseException;\n import java.text.SimpleDateFormat;\n import java.util.Calendar;\n@@ -35,99 +46,79 @@\n import java.util.Set;\n import java.util.UUID;\n import javax.ws.rs.core.Response;\n-import javax.xml.ws.WebServiceException;\n+import org.apache.commons.lang3.RandomStringUtils;\n import org.apache.commons.lang3.tuple.Pair;\n-import org.apache.cxf.rs.security.jose.common.JoseType;\n-import org.apache.cxf.rs.security.jose.jwa.SignatureAlgorithm;\n-import org.apache.cxf.rs.security.jose.jws.HmacJwsSignatureProvider;\n-import org.apache.cxf.rs.security.jose.jws.JwsHeaders;\n-import org.apache.cxf.rs.security.jose.jws.JwsJwtCompactConsumer;\n-import org.apache.cxf.rs.security.jose.jws.JwsJwtCompactProducer;\n-import org.apache.cxf.rs.security.jose.jws.JwsSignatureProvider;\n-import org.apache.cxf.rs.security.jose.jws.JwsSignatureVerifier;\n-import org.apache.cxf.rs.security.jose.jws.NoneJwsSignatureProvider;\n-import org.apache.cxf.rs.security.jose.jwt.JwtClaims;\n-import org.apache.cxf.rs.security.jose.jwt.JwtToken;\n import org.apache.syncope.client.lib.SyncopeClient;\n import org.apache.syncope.common.lib.SyncopeConstants;\n import org.apache.syncope.common.lib.request.UserCR;\n import org.apache.syncope.common.lib.to.UserTO;\n import org.apache.syncope.common.rest.api.RESTHeaders;\n import org.apache.syncope.common.rest.api.service.AccessTokenService;\n import org.apache.syncope.common.rest.api.service.UserSelfService;\n-import org.apache.syncope.core.spring.security.jws.AccessTokenJwsSignatureProvider;\n-import org.apache.syncope.core.spring.security.jws.AccessTokenJwsSignatureVerifier;\n+import org.apache.syncope.core.spring.security.jws.AccessTokenJWSSigner;\n+import org.apache.syncope.core.spring.security.jws.AccessTokenJWSVerifier;\n import org.apache.syncope.fit.AbstractITCase;\n import org.apache.syncope.fit.core.reference.CustomJWTSSOProvider;\n-import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.BeforeAll;\n import org.junit.jupiter.api.Test;\n \n /**\n  * Some tests for JWT Tokens.\n  */\n public class JWTITCase extends AbstractITCase {\n \n-    private JwsSignatureProvider jwsSignatureProvider;\n+    private static AccessTokenJWSSigner JWS_SIGNER;\n \n-    private JwsSignatureVerifier jwsSignatureVerifier;\n+    private static AccessTokenJWSVerifier JWS_VERIFIER;\n \n-    @BeforeEach\n-    public void setupVerifier() throws Exception {\n-        AccessTokenJwsSignatureProvider atjsp = new AccessTokenJwsSignatureProvider();\n-        atjsp.setJwsAlgorithm(JWS_ALGORITHM);\n-        atjsp.setJwsKey(JWS_KEY);\n-        atjsp.afterPropertiesSet();\n-        this.jwsSignatureProvider = atjsp;\n-\n-        AccessTokenJwsSignatureVerifier atjsv = new AccessTokenJwsSignatureVerifier();\n-        atjsv.setJwsAlgorithm(JWS_ALGORITHM);\n-        atjsv.setJwsKey(JWS_KEY);\n-        atjsv.afterPropertiesSet();\n-        this.jwsSignatureVerifier = atjsv;\n+    @BeforeAll\n+    public static void setupVerifier() throws Exception {\n+        JWS_SIGNER = new AccessTokenJWSSigner(JWS_ALGORITHM, JWS_KEY);\n+        JWS_VERIFIER = new AccessTokenJWSVerifier(JWS_ALGORITHM, JWS_KEY);\n     }\n \n     @Test\n-    public void getJWTToken() throws ParseException {\n+    public void getJWTToken() throws ParseException, JOSEException {\n         // Get the token\n         SyncopeClient localClient = clientFactory.create(ADMIN_UNAME, ADMIN_PWD);\n         AccessTokenService accessTokenService = localClient.getService(AccessTokenService.class);\n \n         Response response = accessTokenService.login();\n         String token = response.getHeaderString(RESTHeaders.TOKEN);\n         assertNotNull(token);\n-        String expiry = response.getHeaderString(RESTHeaders.TOKEN_EXPIRE);\n-        assertNotNull(expiry);\n+        String expiration = response.getHeaderString(RESTHeaders.TOKEN_EXPIRE);\n+        assertNotNull(expiration);\n \n         // Validate the signature\n-        JwsJwtCompactConsumer consumer = new JwsJwtCompactConsumer(token);\n-        assertTrue(consumer.verifySignatureWith(jwsSignatureVerifier));\n+        SignedJWT jwt = SignedJWT.parse(token);\n+        jwt.verify(JWS_VERIFIER);\n+        assertTrue(jwt.verify(JWS_VERIFIER));\n \n         Date now = new Date();\n \n         // Verify the expiry header matches that of the token\n-        Long expiryTime = consumer.getJwtClaims().getExpiryTime();\n-        assertNotNull(expiryTime);\n+        Date tokenDate = jwt.getJWTClaimsSet().getExpirationTime();\n+        assertNotNull(tokenDate);\n \n         SimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ssXXX\");\n-        Date tokenDate = dateFormat.parse(dateFormat.format(new Date(expiryTime * 1000L)));\n-        Date parsedDate = dateFormat.parse(expiry);\n+        Date parsedDate = dateFormat.parse(expiration);\n \n         assertEquals(tokenDate, parsedDate);\n         assertTrue(parsedDate.after(now));\n \n         // Verify issuedAt\n-        Long issuedAt = consumer.getJwtClaims().getIssuedAt();\n-        assertNotNull(issuedAt);\n-        assertTrue(new Date(issuedAt).before(now));\n+        Date issueTime = jwt.getJWTClaimsSet().getIssueTime();\n+        assertNotNull(issueTime);\n+        assertTrue(issueTime.before(now));\n \n         // Validate subject + issuer\n-        assertEquals(ADMIN_UNAME, consumer.getJwtClaims().getSubject());\n-        assertEquals(JWT_ISSUER, consumer.getJwtClaims().getIssuer());\n+        assertEquals(ADMIN_UNAME, jwt.getJWTClaimsSet().getSubject());\n+        assertEquals(JWT_ISSUER, jwt.getJWTClaimsSet().getIssuer());\n \n         // Verify NotBefore\n-        Long notBefore = consumer.getJwtClaims().getNotBefore();\n-        assertNotNull(notBefore);\n-        assertTrue(new Date(notBefore).before(now));\n+        Date notBeforeTime = jwt.getJWTClaimsSet().getNotBeforeTime();\n+        assertNotNull(notBeforeTime);\n+        assertTrue(notBeforeTime.before(now));\n     }\n \n     @Test\n@@ -151,289 +142,236 @@ public void queryUsingToken() throws ParseException {\n         try {\n             jwtUserSelfService.read();\n             fail(\"Failure expected on a modified token\");\n-        } catch (WebServiceException ex) {\n-            // expected\n+        } catch (AccessControlException e) {\n+            assertEquals(\"Invalid signature found in JWT\", e.getMessage());\n         }\n     }\n \n     @Test\n-    public void tokenValidation() throws ParseException {\n+    public void tokenValidation() throws ParseException, JOSEException {\n         // Get an initial token\n         SyncopeClient localClient = clientFactory.create(ADMIN_UNAME, ADMIN_PWD);\n         AccessTokenService accessTokenService = localClient.getService(AccessTokenService.class);\n \n         Response response = accessTokenService.login();\n         String token = response.getHeaderString(RESTHeaders.TOKEN);\n         assertNotNull(token);\n-        JwsJwtCompactConsumer consumer = new JwsJwtCompactConsumer(token);\n-        String tokenId = consumer.getJwtClaims().getTokenId();\n+        SignedJWT jwt = SignedJWT.parse(token);\n+        String tokenId = jwt.getJWTClaimsSet().getJWTID();\n \n         // Create a new token using the Id of the first token\n-        Date now = new Date();\n-        long currentTime = now.getTime() / 1000L;\n-\n-        Calendar expiry = Calendar.getInstance();\n-        expiry.setTime(now);\n-        expiry.add(Calendar.MINUTE, 5);\n-\n-        JwtClaims jwtClaims = new JwtClaims();\n-        jwtClaims.setTokenId(tokenId);\n-        jwtClaims.setSubject(ADMIN_UNAME);\n-        jwtClaims.setIssuedAt(currentTime);\n-        jwtClaims.setIssuer(JWT_ISSUER);\n-        jwtClaims.setExpiryTime(expiry.getTime().getTime() / 1000L);\n-        jwtClaims.setNotBefore(currentTime);\n-\n-        JwsHeaders jwsHeaders = new JwsHeaders(JoseType.JWT, JWS_ALGORITHM);\n-        JwtToken jwtToken = new JwtToken(jwsHeaders, jwtClaims);\n-        JwsJwtCompactProducer producer = new JwsJwtCompactProducer(jwtToken);\n-\n-        String signed = producer.signWith(jwsSignatureProvider);\n+        Date currentTime = new Date();\n+\n+        Calendar expiration = Calendar.getInstance();\n+        expiration.setTime(currentTime);\n+        expiration.add(Calendar.MINUTE, 5);\n+\n+        JWTClaimsSet.Builder claimsSet = new JWTClaimsSet.Builder().\n+                jwtID(tokenId).\n+                subject(ADMIN_UNAME).\n+                issueTime(currentTime).\n+                issuer(JWT_ISSUER).\n+                expirationTime(expiration.getTime()).\n+                notBeforeTime(currentTime);\n+        jwt = new SignedJWT(new JWSHeader(JWS_SIGNER.getJwsAlgorithm()), claimsSet.build());\n+        jwt.sign(JWS_SIGNER);\n+        String signed = jwt.serialize();\n \n         SyncopeClient jwtClient = clientFactory.create(signed);\n         UserSelfService jwtUserSelfService = jwtClient.getService(UserSelfService.class);\n         jwtUserSelfService.read();\n     }\n \n     @Test\n-    public void invalidIssuer() throws ParseException {\n+    public void invalidIssuer() throws ParseException, JOSEException {\n         // Get an initial token\n         SyncopeClient localClient = clientFactory.create(ADMIN_UNAME, ADMIN_PWD);\n         AccessTokenService accessTokenService = localClient.getService(AccessTokenService.class);\n \n         Response response = accessTokenService.login();\n         String token = response.getHeaderString(RESTHeaders.TOKEN);\n-        assertNotNull(token);\n-        JwsJwtCompactConsumer consumer = new JwsJwtCompactConsumer(token);\n-        String tokenId = consumer.getJwtClaims().getTokenId();\n+        SignedJWT jwt = SignedJWT.parse(token);\n+        String tokenId = jwt.getJWTClaimsSet().getJWTID();\n \n         // Create a new token using the Id of the first token\n-        Date now = new Date();\n-        long currentTime = now.getTime() / 1000L;\n-\n-        Calendar expiry = Calendar.getInstance();\n-        expiry.setTime(now);\n-        expiry.add(Calendar.MINUTE, 5);\n-\n-        JwtClaims jwtClaims = new JwtClaims();\n-        jwtClaims.setTokenId(tokenId);\n-        jwtClaims.setSubject(ADMIN_UNAME);\n-        jwtClaims.setIssuedAt(currentTime);\n-        jwtClaims.setIssuer(\"UnknownIssuer\");\n-        jwtClaims.setExpiryTime(expiry.getTime().getTime() / 1000L);\n-        jwtClaims.setNotBefore(currentTime);\n-\n-        JwsHeaders jwsHeaders = new JwsHeaders(JoseType.JWT, JWS_ALGORITHM);\n-        JwtToken jwtToken = new JwtToken(jwsHeaders, jwtClaims);\n-        JwsJwtCompactProducer producer = new JwsJwtCompactProducer(jwtToken);\n-\n-        String signed = producer.signWith(jwsSignatureProvider);\n+        Date currentTime = new Date();\n+\n+        Calendar expiration = Calendar.getInstance();\n+        expiration.setTime(currentTime);\n+        expiration.add(Calendar.MINUTE, 5);\n+\n+        JWTClaimsSet.Builder claimsSet = new JWTClaimsSet.Builder().\n+                jwtID(tokenId).\n+                subject(ADMIN_UNAME).\n+                issueTime(currentTime).\n+                issuer(\"UnknownIssuer\").\n+                expirationTime(expiration.getTime()).\n+                notBeforeTime(currentTime);\n+        jwt = new SignedJWT(new JWSHeader(JWS_SIGNER.getJwsAlgorithm()), claimsSet.build());\n+        jwt.sign(JWS_SIGNER);\n+        String signed = jwt.serialize();\n \n         SyncopeClient jwtClient = clientFactory.create(signed);\n         UserSelfService jwtUserSelfService = jwtClient.getService(UserSelfService.class);\n         try {\n             jwtUserSelfService.read();\n             fail(\"Failure expected on an invalid issuer\");\n-        } catch (AccessControlException ex) {\n+        } catch (AccessControlException e) {\n             // expected\n         }\n     }\n \n     @Test\n-    public void expiredToken() throws ParseException {\n+    public void expiredToken() throws ParseException, JOSEException {\n         // Get an initial token\n         SyncopeClient localClient = clientFactory.create(ADMIN_UNAME, ADMIN_PWD);\n         AccessTokenService accessTokenService = localClient.getService(AccessTokenService.class);\n \n         Response response = accessTokenService.login();\n         String token = response.getHeaderString(RESTHeaders.TOKEN);\n         assertNotNull(token);\n-        JwsJwtCompactConsumer consumer = new JwsJwtCompactConsumer(token);\n-        String tokenId = consumer.getJwtClaims().getTokenId();\n+        SignedJWT jwt = SignedJWT.parse(token);\n+        String tokenId = jwt.getJWTClaimsSet().getJWTID();\n \n         // Create a new token using the Id of the first token\n-        Date now = new Date();\n-        long currentTime = now.getTime() / 1000L;\n-\n-        Calendar expiry = Calendar.getInstance();\n-        expiry.setTime(now);\n-        expiry.add(Calendar.MINUTE, 5);\n-\n-        JwtClaims jwtClaims = new JwtClaims();\n-        jwtClaims.setTokenId(tokenId);\n-        jwtClaims.setSubject(ADMIN_UNAME);\n-        jwtClaims.setIssuedAt(currentTime);\n-        jwtClaims.setIssuer(JWT_ISSUER);\n-        jwtClaims.setExpiryTime((now.getTime() - 5000L) / 1000L);\n-        jwtClaims.setNotBefore(currentTime);\n-\n-        JwsHeaders jwsHeaders = new JwsHeaders(JoseType.JWT, JWS_ALGORITHM);\n-        JwtToken jwtToken = new JwtToken(jwsHeaders, jwtClaims);\n-        JwsJwtCompactProducer producer = new JwsJwtCompactProducer(jwtToken);\n-\n-        String signed = producer.signWith(jwsSignatureProvider);\n+        Date currentTime = new Date();\n+\n+        JWTClaimsSet.Builder claimsSet = new JWTClaimsSet.Builder().\n+                jwtID(tokenId).\n+                subject(ADMIN_UNAME).\n+                issueTime(currentTime).\n+                issuer(JWT_ISSUER).\n+                expirationTime(new Date(currentTime.getTime() - 5000L)).\n+                notBeforeTime(currentTime);\n+        jwt = new SignedJWT(new JWSHeader(JWS_SIGNER.getJwsAlgorithm()), claimsSet.build());\n+        jwt.sign(JWS_SIGNER);\n+        String signed = jwt.serialize();\n \n         SyncopeClient jwtClient = clientFactory.create(signed);\n         UserSelfService jwtUserSelfService = jwtClient.getService(UserSelfService.class);\n         try {\n             jwtUserSelfService.read();\n             fail(\"Failure expected on an expired token\");\n-        } catch (AccessControlException ex) {\n+        } catch (AccessControlException e) {\n             // expected\n         }\n     }\n \n     @Test\n-    public void notBefore() throws ParseException {\n+    public void notBefore() throws ParseException, JOSEException {\n         // Get an initial token\n         SyncopeClient localClient = clientFactory.create(ADMIN_UNAME, ADMIN_PWD);\n         AccessTokenService accessTokenService = localClient.getService(AccessTokenService.class);\n \n         Response response = accessTokenService.login();\n         String token = response.getHeaderString(RESTHeaders.TOKEN);\n         assertNotNull(token);\n-        JwsJwtCompactConsumer consumer = new JwsJwtCompactConsumer(token);\n-        String tokenId = consumer.getJwtClaims().getTokenId();\n+        SignedJWT jwt = SignedJWT.parse(token);\n+        String tokenId = jwt.getJWTClaimsSet().getJWTID();\n \n         // Create a new token using the Id of the first token\n-        Date now = new Date();\n-        long currentTime = now.getTime() / 1000L;\n-\n-        Calendar expiry = Calendar.getInstance();\n-        expiry.setTime(now);\n-        expiry.add(Calendar.MINUTE, 5);\n-\n-        JwtClaims jwtClaims = new JwtClaims();\n-        jwtClaims.setTokenId(tokenId);\n-        jwtClaims.setSubject(ADMIN_UNAME);\n-        jwtClaims.setIssuedAt(currentTime);\n-        jwtClaims.setIssuer(JWT_ISSUER);\n-        jwtClaims.setExpiryTime(expiry.getTime().getTime() / 1000L);\n-        jwtClaims.setNotBefore(currentTime + 60L);\n-\n-        JwsHeaders jwsHeaders = new JwsHeaders(JoseType.JWT, JWS_ALGORITHM);\n-        JwtToken jwtToken = new JwtToken(jwsHeaders, jwtClaims);\n-        JwsJwtCompactProducer producer = new JwsJwtCompactProducer(jwtToken);\n-\n-        String signed = producer.signWith(jwsSignatureProvider);\n+        Date currentTime = new Date();\n+\n+        Calendar expiration = Calendar.getInstance();\n+        expiration.setTime(currentTime);\n+        expiration.add(Calendar.MINUTE, 5);\n+\n+        JWTClaimsSet.Builder claimsSet = new JWTClaimsSet.Builder().\n+                jwtID(tokenId).\n+                subject(ADMIN_UNAME).\n+                issueTime(currentTime).\n+                issuer(JWT_ISSUER).\n+                expirationTime(expiration.getTime()).\n+                notBeforeTime(new Date(currentTime.getTime() + 60000L));\n+        jwt = new SignedJWT(new JWSHeader(JWS_SIGNER.getJwsAlgorithm()), claimsSet.build());\n+        jwt.sign(JWS_SIGNER);\n+        String signed = jwt.serialize();\n \n         SyncopeClient jwtClient = clientFactory.create(signed);\n         UserSelfService jwtUserSelfService = jwtClient.getService(UserSelfService.class);\n         try {\n             jwtUserSelfService.read();\n             fail(\"Failure expected on a token that is not valid yet\");\n-        } catch (AccessControlException ex) {\n+        } catch (AccessControlException e) {\n             // expected\n         }\n     }\n \n     @Test\n-    public void noneSignature() throws ParseException {\n+    public void noSignature() throws ParseException {\n         // Get an initial token\n         SyncopeClient localClient = clientFactory.create(ADMIN_UNAME, ADMIN_PWD);\n         AccessTokenService accessTokenService = localClient.getService(AccessTokenService.class);\n \n         Response response = accessTokenService.login();\n         String token = response.getHeaderString(RESTHeaders.TOKEN);\n         assertNotNull(token);\n-        JwsJwtCompactConsumer consumer = new JwsJwtCompactConsumer(token);\n-        String tokenId = consumer.getJwtClaims().getTokenId();\n+        JWT jwt = SignedJWT.parse(token);\n \n         // Create a new token using the Id of the first token\n-        JwtClaims jwtClaims = new JwtClaims();\n-        jwtClaims.setTokenId(tokenId);\n-        jwtClaims.setSubject(consumer.getJwtClaims().getSubject());\n-        jwtClaims.setIssuedAt(consumer.getJwtClaims().getIssuedAt());\n-        jwtClaims.setIssuer(consumer.getJwtClaims().getIssuer());\n-        jwtClaims.setExpiryTime(consumer.getJwtClaims().getExpiryTime());\n-        jwtClaims.setNotBefore(consumer.getJwtClaims().getNotBefore());\n-\n-        JwsHeaders jwsHeaders = new JwsHeaders(JoseType.JWT, SignatureAlgorithm.NONE);\n-        JwtToken jwtToken = new JwtToken(jwsHeaders, jwtClaims);\n-        JwsJwtCompactProducer producer = new JwsJwtCompactProducer(jwtToken);\n+        JWTClaimsSet.Builder claimsSet = new JWTClaimsSet.Builder(jwt.getJWTClaimsSet());\n+        jwt = new PlainJWT(claimsSet.build());\n+        String bearer = jwt.serialize();\n \n-        JwsSignatureProvider noneJwsSignatureProvider = new NoneJwsSignatureProvider();\n-        String signed = producer.signWith(noneJwsSignatureProvider);\n-\n-        SyncopeClient jwtClient = clientFactory.create(signed);\n+        SyncopeClient jwtClient = clientFactory.create(bearer);\n         UserSelfService jwtUserSelfService = jwtClient.getService(UserSelfService.class);\n         try {\n             jwtUserSelfService.read();\n             fail(\"Failure expected on no signature\");\n-        } catch (AccessControlException ex) {\n+        } catch (AccessControlException e) {\n             // expected\n         }\n     }\n \n     @Test\n-    public void unknownId() throws ParseException {\n+    public void unknownId() throws ParseException, JOSEException {\n         // Get an initial token\n         SyncopeClient localClient = clientFactory.create(ADMIN_UNAME, ADMIN_PWD);\n         AccessTokenService accessTokenService = localClient.getService(AccessTokenService.class);\n \n         Response response = accessTokenService.login();\n         String token = response.getHeaderString(RESTHeaders.TOKEN);\n         assertNotNull(token);\n+        SignedJWT jwt = SignedJWT.parse(token);\n \n         // Create a new token using an unknown Id\n-        Date now = new Date();\n-        long currentTime = now.getTime() / 1000L;\n-\n-        Calendar expiry = Calendar.getInstance();\n-        expiry.setTime(now);\n-        expiry.add(Calendar.MINUTE, 5);\n-\n-        JwtClaims jwtClaims = new JwtClaims();\n-        jwtClaims.setTokenId(UUID.randomUUID().toString());\n-        jwtClaims.setSubject(ADMIN_UNAME);\n-        jwtClaims.setIssuedAt(currentTime);\n-        jwtClaims.setIssuer(JWT_ISSUER);\n-        jwtClaims.setExpiryTime(expiry.getTime().getTime() / 1000L);\n-        jwtClaims.setNotBefore(currentTime);\n-\n-        JwsHeaders jwsHeaders = new JwsHeaders(JoseType.JWT, JWS_ALGORITHM);\n-        JwtToken jwtToken = new JwtToken(jwsHeaders, jwtClaims);\n-        JwsJwtCompactProducer producer = new JwsJwtCompactProducer(jwtToken);\n-\n-        String signed = producer.signWith(jwsSignatureProvider);\n+        JWTClaimsSet.Builder claimsSet = new JWTClaimsSet.Builder(jwt.getJWTClaimsSet()).\n+                jwtID(UUID.randomUUID().toString());\n+        jwt = new SignedJWT(new JWSHeader(JWS_SIGNER.getJwsAlgorithm()), claimsSet.build());\n+        jwt.sign(JWS_SIGNER);\n+        String signed = jwt.serialize();\n \n         SyncopeClient jwtClient = clientFactory.create(signed);\n         UserSelfService jwtUserSelfService = jwtClient.getService(UserSelfService.class);\n         try {\n             jwtUserSelfService.read();\n             fail(\"Failure expected on an unknown id\");\n-        } catch (AccessControlException ex) {\n+        } catch (AccessControlException e) {\n             // expected\n         }\n     }\n \n     @Test\n-    public void thirdPartyToken() throws ParseException {\n-        assumeFalse(SignatureAlgorithm.isPublicKeyAlgorithm(JWS_ALGORITHM));\n+    public void thirdPartyToken() throws ParseException, JOSEException {\n+        assumeFalse(JWSAlgorithm.Family.RSA.contains(JWS_ALGORITHM));\n \n         // Create a new token\n-        Date now = new Date();\n-        long currentTime = now.getTime() / 1000L;\n-\n-        Calendar expiry = Calendar.getInstance();\n-        expiry.setTime(now);\n-        expiry.add(Calendar.MINUTE, 5);\n-\n-        JwtClaims jwtClaims = new JwtClaims();\n-        jwtClaims.setTokenId(UUID.randomUUID().toString());\n-        jwtClaims.setSubject(\"puccini@apache.org\");\n-        jwtClaims.setIssuedAt(currentTime);\n-        jwtClaims.setIssuer(CustomJWTSSOProvider.ISSUER);\n-        jwtClaims.setExpiryTime(expiry.getTime().getTime() / 1000L);\n-        jwtClaims.setNotBefore(currentTime);\n-\n-        JwsHeaders jwsHeaders = new JwsHeaders(JoseType.JWT, JWS_ALGORITHM);\n-        JwtToken jwtToken = new JwtToken(jwsHeaders, jwtClaims);\n-        JwsJwtCompactProducer producer = new JwsJwtCompactProducer(jwtToken);\n-\n-        JwsSignatureProvider customSignatureProvider =\n-                new HmacJwsSignatureProvider(CustomJWTSSOProvider.CUSTOM_KEY.getBytes(), JWS_ALGORITHM);\n-        String signed = producer.signWith(customSignatureProvider);\n+        Date currentTime = new Date();\n+\n+        Calendar expiration = Calendar.getInstance();\n+        expiration.setTime(currentTime);\n+        expiration.add(Calendar.MINUTE, 5);\n+\n+        JWTClaimsSet.Builder claimsSet = new JWTClaimsSet.Builder().\n+                jwtID(UUID.randomUUID().toString()).\n+                subject(\"puccini@apache.org\").\n+                issueTime(currentTime).\n+                issuer(CustomJWTSSOProvider.ISSUER).\n+                expirationTime(expiration.getTime()).\n+                notBeforeTime(currentTime);\n+        SignedJWT jwt = new SignedJWT(new JWSHeader(JWS_ALGORITHM), claimsSet.build());\n+        jwt.sign(new MACSigner(CustomJWTSSOProvider.CUSTOM_KEY));\n+        String signed = jwt.serialize();\n \n         SyncopeClient jwtClient = clientFactory.create(signed);\n \n@@ -443,120 +381,110 @@ public void thirdPartyToken() throws ParseException {\n     }\n \n     @Test\n-    public void thirdPartyTokenUnknownUser() throws ParseException {\n-        assumeFalse(SignatureAlgorithm.isPublicKeyAlgorithm(JWS_ALGORITHM));\n+    public void thirdPartyTokenUnknownUser() throws ParseException, JOSEException {\n+        assumeFalse(JWSAlgorithm.Family.RSA.contains(JWS_ALGORITHM));\n \n         // Create a new token\n-        Date now = new Date();\n-        long currentTime = now.getTime() / 1000L;\n-\n-        Calendar expiry = Calendar.getInstance();\n-        expiry.setTime(now);\n-        expiry.add(Calendar.MINUTE, 5);\n-\n-        JwtClaims jwtClaims = new JwtClaims();\n-        jwtClaims.setTokenId(UUID.randomUUID().toString());\n-        jwtClaims.setSubject(\"strauss@apache.org\");\n-        jwtClaims.setIssuedAt(currentTime);\n-        jwtClaims.setIssuer(CustomJWTSSOProvider.ISSUER);\n-        jwtClaims.setExpiryTime(expiry.getTime().getTime() / 1000L);\n-        jwtClaims.setNotBefore(currentTime);\n-\n-        JwsHeaders jwsHeaders = new JwsHeaders(JoseType.JWT, JWS_ALGORITHM);\n-        JwtToken jwtToken = new JwtToken(jwsHeaders, jwtClaims);\n-        JwsJwtCompactProducer producer = new JwsJwtCompactProducer(jwtToken);\n-\n-        JwsSignatureProvider customSignatureProvider =\n-                new HmacJwsSignatureProvider(CustomJWTSSOProvider.CUSTOM_KEY.getBytes(), JWS_ALGORITHM);\n-        String signed = producer.signWith(customSignatureProvider);\n+        Date currentTime = new Date();\n+\n+        Calendar expiration = Calendar.getInstance();\n+        expiration.setTime(currentTime);\n+        expiration.add(Calendar.MINUTE, 5);\n+\n+        JWTClaimsSet.Builder claimsSet = new JWTClaimsSet.Builder().\n+                jwtID(UUID.randomUUID().toString()).\n+                subject(\"strauss@apache.org\").\n+                issueTime(currentTime).\n+                issuer(CustomJWTSSOProvider.ISSUER).\n+                expirationTime(expiration.getTime()).\n+                notBeforeTime(currentTime);\n+        SignedJWT jwt = new SignedJWT(new JWSHeader(JWS_SIGNER.getJwsAlgorithm()), claimsSet.build());\n+        jwt.sign(JWS_SIGNER);\n+        String signed = jwt.serialize();\n \n         SyncopeClient jwtClient = clientFactory.create(signed);\n \n         try {\n             jwtClient.self();\n             fail(\"Failure expected on an unknown subject\");\n-        } catch (AccessControlException ex) {\n+        } catch (AccessControlException e) {\n             // expected\n         }\n     }\n \n     @Test\n-    public void thirdPartyTokenUnknownIssuer() throws ParseException {\n-        assumeFalse(SignatureAlgorithm.isPublicKeyAlgorithm(JWS_ALGORITHM));\n+    public void thirdPartyTokenUnknownIssuer() throws ParseException, JOSEException {\n+        assumeFalse(JWSAlgorithm.Family.RSA.contains(JWS_ALGORITHM));\n \n         // Create a new token\n-        Date now = new Date();\n-        long currentTime = now.getTime() / 1000L;\n-\n-        Calendar expiry = Calendar.getInstance();\n-        expiry.setTime(now);\n-        expiry.add(Calendar.MINUTE, 5);\n-\n-        JwtClaims jwtClaims = new JwtClaims();\n-        jwtClaims.setTokenId(UUID.randomUUID().toString());\n-        jwtClaims.setSubject(\"puccini@apache.org\");\n-        jwtClaims.setIssuedAt(currentTime);\n-        jwtClaims.setIssuer(CustomJWTSSOProvider.ISSUER + '_');\n-        jwtClaims.setExpiryTime(expiry.getTime().getTime() / 1000L);\n-        jwtClaims.setNotBefore(currentTime);\n-\n-        JwsHeaders jwsHeaders = new JwsHeaders(JoseType.JWT, JWS_ALGORITHM);\n-        JwtToken jwtToken = new JwtToken(jwsHeaders, jwtClaims);\n-        JwsJwtCompactProducer producer = new JwsJwtCompactProducer(jwtToken);\n-\n-        JwsSignatureProvider customSignatureProvider =\n-                new HmacJwsSignatureProvider(CustomJWTSSOProvider.CUSTOM_KEY.getBytes(), JWS_ALGORITHM);\n-        String signed = producer.signWith(customSignatureProvider);\n+        Date currentTime = new Date();\n+\n+        Calendar expiration = Calendar.getInstance();\n+        expiration.setTime(currentTime);\n+        expiration.add(Calendar.MINUTE, 5);\n+\n+        JWTClaimsSet.Builder claimsSet = new JWTClaimsSet.Builder().\n+                jwtID(UUID.randomUUID().toString()).\n+                subject(\"puccini@apache.org\").\n+                issueTime(currentTime).\n+                issuer(CustomJWTSSOProvider.ISSUER + \"_\").\n+                expirationTime(expiration.getTime()).\n+                notBeforeTime(currentTime);\n+        SignedJWT jwt = new SignedJWT(new JWSHeader(JWS_SIGNER.getJwsAlgorithm()), claimsSet.build());\n+        jwt.sign(JWS_SIGNER);\n+        String signed = jwt.serialize();\n \n         SyncopeClient jwtClient = clientFactory.create(signed);\n \n         try {\n             jwtClient.self();\n             fail(\"Failure expected on an unknown issuer\");\n-        } catch (AccessControlException ex) {\n+        } catch (AccessControlException e) {\n             // expected\n         }\n     }\n \n     @Test\n-    public void thirdPartyTokenBadSignature() throws ParseException {\n-        assumeFalse(SignatureAlgorithm.isPublicKeyAlgorithm(JWS_ALGORITHM));\n+    public void thirdPartyTokenBadSignature()\n+            throws ParseException, KeyLengthException, NoSuchAlgorithmException,\n+            InvalidKeySpecException, JOSEException {\n+\n+        assumeFalse(JWSAlgorithm.Family.RSA.contains(JWS_ALGORITHM));\n \n         // Create a new token\n-        Date now = new Date();\n+        Date currentTime = new Date();\n \n-        Calendar expiry = Calendar.getInstance();\n-        expiry.setTime(now);\n-        expiry.add(Calendar.MINUTE, 5);\n+        Calendar expiration = Calendar.getInstance();\n+        expiration.setTime(currentTime);\n+        expiration.add(Calendar.MINUTE, 5);\n \n-        JwtClaims jwtClaims = new JwtClaims();\n-        jwtClaims.setTokenId(UUID.randomUUID().toString());\n-        jwtClaims.setSubject(\"puccini@apache.org\");\n-        jwtClaims.setIssuedAt(now.getTime());\n-        jwtClaims.setIssuer(CustomJWTSSOProvider.ISSUER);\n-        jwtClaims.setExpiryTime(expiry.getTime().getTime());\n-        jwtClaims.setNotBefore(now.getTime());\n+        JWTClaimsSet.Builder claimsSet = new JWTClaimsSet.Builder().\n+                jwtID(UUID.randomUUID().toString()).\n+                subject(\"puccini@apache.org\").\n+                issueTime(currentTime).\n+                issuer(CustomJWTSSOProvider.ISSUER).\n+                expirationTime(expiration.getTime()).\n+                notBeforeTime(currentTime);\n \n-        JwsHeaders jwsHeaders = new JwsHeaders(JoseType.JWT, JWS_ALGORITHM);\n-        JwtToken jwtToken = new JwtToken(jwsHeaders, jwtClaims);\n-        JwsJwtCompactProducer producer = new JwsJwtCompactProducer(jwtToken);\n+        AccessTokenJWSSigner customJWSSigner =\n+                new AccessTokenJWSSigner(JWS_ALGORITHM, RandomStringUtils.randomAlphanumeric(512));\n \n-        JwsSignatureProvider customSignatureProvider =\n-                new HmacJwsSignatureProvider((CustomJWTSSOProvider.CUSTOM_KEY + '_').getBytes(), JWS_ALGORITHM);\n-        String signed = producer.signWith(customSignatureProvider);\n+        SignedJWT jwt = new SignedJWT(new JWSHeader(customJWSSigner.getJwsAlgorithm()), claimsSet.build());\n+        jwt.sign(customJWSSigner);\n+        String signed = jwt.serialize();\n \n         SyncopeClient jwtClient = clientFactory.create(signed);\n \n         try {\n             jwtClient.self();\n             fail(\"Failure expected on a bad signature\");\n-        } catch (AccessControlException ex) {\n+        } catch (AccessControlException e) {\n             // expected\n         }\n     }\n \n     @Test\n-    public void issueSYNCOPE1420() {\n+    public void issueSYNCOPE1420() throws ParseException {\n         Long orig = confParamOps.get(SyncopeConstants.MASTER_DOMAIN, \"jwt.lifetime.minutes\", null, Long.class);\n         try {\n             // set for immediate JWT expiration\n@@ -569,18 +497,16 @@ public void issueSYNCOPE1420() {\n             // login, get JWT with  expiryTime\n             String jwt = clientFactory.create(user.getUsername(), \"password123\").getJWT();\n \n-            JwsJwtCompactConsumer consumer = new JwsJwtCompactConsumer(jwt);\n-            assertTrue(consumer.verifySignatureWith(jwsSignatureVerifier));\n-            Long expiryTime = consumer.getJwtClaims().getExpiryTime();\n-            assertNotNull(expiryTime);\n+            Date expirationTime = SignedJWT.parse(jwt).getJWTClaimsSet().getExpirationTime();\n+            assertNotNull(expirationTime);\n \n             // wait for 1 sec, check that JWT is effectively expired\n             try {\n                 Thread.sleep(1000L);\n             } catch (InterruptedException e) {\n                 // ignore\n             }\n-            assertTrue(expiryTime < System.currentTimeMillis());\n+            assertTrue(expirationTime.before(new Date()));\n \n             // login again, get new JWT\n             // (even if ExpiredAccessTokenCleanup did not run yet, as it is scheduled every 5 minutes)"},{"sha":"4b1a960e1dae97a319f8cba360e7973f3aaf0d94","filename":"pom.xml","status":"modified","additions":0,"deletions":5,"changes":5,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fb3794e3446b61c452ab452705243ec5a693bda0/pom.xml","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fb3794e3446b61c452ab452705243ec5a693bda0/pom.xml","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/pom.xml?ref=fb3794e3446b61c452ab452705243ec5a693bda0","patch":"@@ -616,11 +616,6 @@ under the License.\n         <artifactId>cxf-rt-rs-extension-search</artifactId>\n         <version>${cxf.version}</version>\n       </dependency>\n-      <dependency>\n-        <groupId>org.apache.cxf</groupId>\n-        <artifactId>cxf-rt-rs-security-jose</artifactId>\n-        <version>${cxf.version}</version>\n-      </dependency>\n       <dependency>\n         <groupId>org.apache.cxf</groupId>\n         <artifactId>cxf-rt-rs-service-description</artifactId>"}]}