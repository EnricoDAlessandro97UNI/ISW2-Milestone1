{"sha":"59d6d4a37b93757397f8e16da4bc2e7aa4fe3066","node_id":"MDY6Q29tbWl0NjM2ODc5MDYyOjU5ZDZkNGEzN2I5Mzc1NzM5N2Y4ZTE2ZGE0YmMyZTdhYTRmZTMwNjY=","commit":{"author":{"name":"Francesco Chicchiriccò","email":"ilgrosso@apache.org","date":"2017-06-19T14:19:14Z"},"committer":{"name":"Francesco Chicchiriccò","email":"ilgrosso@apache.org","date":"2017-06-19T14:20:30Z"},"message":"Reduce number of integration test cases executed by default build, moving time-consuming to full-it profile","tree":{"sha":"34267ed14580e255e9329a1ad802735790495ac3","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/git/trees/34267ed14580e255e9329a1ad802735790495ac3"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/git/commits/59d6d4a37b93757397f8e16da4bc2e7aa4fe3066","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/59d6d4a37b93757397f8e16da4bc2e7aa4fe3066","html_url":"https://github.com/EnricoDAlessandro97UNI/syncope/commit/59d6d4a37b93757397f8e16da4bc2e7aa4fe3066","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/59d6d4a37b93757397f8e16da4bc2e7aa4fe3066/comments","author":{"login":"ilgrosso","id":1064664,"node_id":"MDQ6VXNlcjEwNjQ2NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/1064664?v=4","gravatar_id":"","url":"https://api.github.com/users/ilgrosso","html_url":"https://github.com/ilgrosso","followers_url":"https://api.github.com/users/ilgrosso/followers","following_url":"https://api.github.com/users/ilgrosso/following{/other_user}","gists_url":"https://api.github.com/users/ilgrosso/gists{/gist_id}","starred_url":"https://api.github.com/users/ilgrosso/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ilgrosso/subscriptions","organizations_url":"https://api.github.com/users/ilgrosso/orgs","repos_url":"https://api.github.com/users/ilgrosso/repos","events_url":"https://api.github.com/users/ilgrosso/events{/privacy}","received_events_url":"https://api.github.com/users/ilgrosso/received_events","type":"User","site_admin":false},"committer":{"login":"ilgrosso","id":1064664,"node_id":"MDQ6VXNlcjEwNjQ2NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/1064664?v=4","gravatar_id":"","url":"https://api.github.com/users/ilgrosso","html_url":"https://github.com/ilgrosso","followers_url":"https://api.github.com/users/ilgrosso/followers","following_url":"https://api.github.com/users/ilgrosso/following{/other_user}","gists_url":"https://api.github.com/users/ilgrosso/gists{/gist_id}","starred_url":"https://api.github.com/users/ilgrosso/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ilgrosso/subscriptions","organizations_url":"https://api.github.com/users/ilgrosso/orgs","repos_url":"https://api.github.com/users/ilgrosso/repos","events_url":"https://api.github.com/users/ilgrosso/events{/privacy}","received_events_url":"https://api.github.com/users/ilgrosso/received_events","type":"User","site_admin":false},"parents":[{"sha":"71e676b3869f646805c8595ec00c96ebb59f16b6","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/71e676b3869f646805c8595ec00c96ebb59f16b6","html_url":"https://github.com/EnricoDAlessandro97UNI/syncope/commit/71e676b3869f646805c8595ec00c96ebb59f16b6"}],"stats":{"total":2420,"additions":1294,"deletions":1126},"files":[{"sha":"df2aa326f204259a8fc00cb5397df2772df9ada1","filename":"fit/core-reference/pom.xml","status":"modified","additions":3,"deletions":0,"changes":3,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/59d6d4a37b93757397f8e16da4bc2e7aa4fe3066/fit%2Fcore-reference%2Fpom.xml","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/59d6d4a37b93757397f8e16da4bc2e7aa4fe3066/fit%2Fcore-reference%2Fpom.xml","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/fit%2Fcore-reference%2Fpom.xml?ref=59d6d4a37b93757397f8e16da4bc2e7aa4fe3066","patch":"@@ -230,6 +230,9 @@ under the License.\n           <includes>\n             <include>**/org/apache/syncope/fit/core/*ITCase.java</include>\n           </includes>\n+          <excludes>\n+            <exclude>**/*IssuesITCase.java</exclude>\n+          </excludes>\n         </configuration>\n         <executions>\n           <execution>"},{"sha":"ba819af7b9023c0a57658bba5ba1b65941faa140","filename":"fit/core-reference/src/test/java/org/apache/syncope/fit/AbstractITCase.java","status":"modified","additions":60,"deletions":1,"changes":61,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/59d6d4a37b93757397f8e16da4bc2e7aa4fe3066/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2FAbstractITCase.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/59d6d4a37b93757397f8e16da4bc2e7aa4fe3066/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2FAbstractITCase.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2FAbstractITCase.java?ref=59d6d4a37b93757397f8e16da4bc2e7aa4fe3066","patch":"@@ -18,6 +18,7 @@\n  */\n package org.apache.syncope.fit;\n \n+import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertNotNull;\n import static org.junit.Assert.fail;\n \n@@ -36,6 +37,7 @@\n import javax.naming.directory.ModificationItem;\n import javax.ws.rs.core.GenericType;\n import javax.ws.rs.core.Response;\n+import org.apache.commons.collections4.CollectionUtils;\n import org.apache.commons.io.IOUtils;\n import org.apache.commons.lang3.StringUtils;\n import org.apache.commons.lang3.tuple.Pair;\n@@ -52,14 +54,18 @@\n import org.apache.syncope.common.lib.to.AttrTO;\n import org.apache.syncope.common.lib.to.ResourceTO;\n import org.apache.syncope.common.lib.to.GroupTO;\n+import org.apache.syncope.common.lib.to.MembershipTO;\n+import org.apache.syncope.common.lib.to.NotificationTO;\n import org.apache.syncope.common.lib.to.ProvisioningResult;\n+import org.apache.syncope.common.lib.to.ReportTO;\n import org.apache.syncope.common.lib.to.RoleTO;\n import org.apache.syncope.common.lib.to.UserTO;\n+import org.apache.syncope.common.lib.types.AnyTypeKind;\n import org.apache.syncope.common.lib.types.ConnConfProperty;\n import org.apache.syncope.common.lib.types.PatchOperation;\n import org.apache.syncope.common.lib.types.SchemaType;\n+import org.apache.syncope.common.lib.types.TraceLevel;\n import org.apache.syncope.common.rest.api.RESTHeaders;\n-import org.apache.syncope.common.rest.api.service.AccessTokenService;\n import org.apache.syncope.common.rest.api.service.AnyObjectService;\n import org.apache.syncope.common.rest.api.service.AnyTypeClassService;\n import org.apache.syncope.common.rest.api.service.AnyTypeService;\n@@ -89,6 +95,7 @@\n import org.apache.syncope.common.rest.api.service.UserService;\n import org.apache.syncope.common.rest.api.service.UserWorkflowService;\n import org.apache.syncope.common.rest.api.service.WorkflowService;\n+import org.apache.syncope.fit.core.UserITCase;\n import org.identityconnectors.common.security.Encryptor;\n import org.junit.BeforeClass;\n import org.slf4j.Logger;\n@@ -343,6 +350,58 @@ protected RoleTO createRole(final RoleTO roleTO) {\n         return getObject(response.getLocation(), RoleService.class, RoleTO.class);\n     }\n \n+    protected ReportTO createReport(final ReportTO report) {\n+        Response response = reportService.create(report);\n+        assertEquals(Response.Status.CREATED.getStatusCode(), response.getStatusInfo().getStatusCode());\n+        return getObject(response.getLocation(), ReportService.class, ReportTO.class);\n+    }\n+\n+    protected Pair<String, String> createNotificationTask(\n+            final boolean active,\n+            final boolean includeAbout,\n+            final TraceLevel traceLevel,\n+            final String sender,\n+            final String subject,\n+            final String... staticRecipients) {\n+\n+        // 1. Create notification\n+        NotificationTO notification = new NotificationTO();\n+        notification.setTraceLevel(traceLevel);\n+        notification.getEvents().add(\"[LOGIC]:[UserLogic]:[]:[create]:[SUCCESS]\");\n+\n+        if (includeAbout) {\n+            notification.getAbouts().put(AnyTypeKind.USER.name(),\n+                    SyncopeClient.getUserSearchConditionBuilder().\n+                            inGroups(\"bf825fe1-7320-4a54-bd64-143b5c18ab97\").query());\n+        }\n+\n+        notification.setRecipientsFIQL(SyncopeClient.getUserSearchConditionBuilder().\n+                inGroups(\"f779c0d4-633b-4be5-8f57-32eb478a3ca5\").query());\n+        notification.setSelfAsRecipient(true);\n+        notification.setRecipientAttrName(\"email\");\n+        if (staticRecipients != null) {\n+            CollectionUtils.addAll(notification.getStaticRecipients(), staticRecipients);\n+        }\n+\n+        notification.setSender(sender);\n+        notification.setSubject(subject);\n+        notification.setTemplate(\"optin\");\n+        notification.setActive(active);\n+\n+        Response response = notificationService.create(notification);\n+        notification = getObject(response.getLocation(), NotificationService.class, NotificationTO.class);\n+        assertNotNull(notification);\n+\n+        // 2. create user\n+        UserTO userTO = UserITCase.getUniqueSampleTO(\"notificationtest@syncope.apache.org\");\n+        userTO.getMemberships().add(\n+                new MembershipTO.Builder().group(\"bf825fe1-7320-4a54-bd64-143b5c18ab97\").build());\n+\n+        userTO = createUser(userTO).getEntity();\n+        assertNotNull(userTO);\n+        return Pair.of(notification.getKey(), userTO.getUsername());\n+    }\n+\n     protected ProvisioningResult<UserTO> createUser(final UserTO userTO) {\n         return createUser(userTO, true);\n     }"},{"sha":"41c7844e42595b9478b49ef7157fe013e132bdb0","filename":"fit/core-reference/src/test/java/org/apache/syncope/fit/core/AbstractNotificationTaskITCase.java","status":"added","additions":107,"deletions":0,"changes":107,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/59d6d4a37b93757397f8e16da4bc2e7aa4fe3066/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FAbstractNotificationTaskITCase.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/59d6d4a37b93757397f8e16da4bc2e7aa4fe3066/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FAbstractNotificationTaskITCase.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FAbstractNotificationTaskITCase.java?ref=59d6d4a37b93757397f8e16da4bc2e7aa4fe3066","patch":"@@ -0,0 +1,107 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.fit.core;\n+\n+import static org.junit.Assert.assertNotNull;\n+\n+import com.icegreen.greenmail.util.GreenMail;\n+import com.icegreen.greenmail.util.ServerSetup;\n+import java.io.InputStream;\n+import java.util.Properties;\n+import javax.mail.Flags;\n+import javax.mail.Folder;\n+import javax.mail.Message;\n+import javax.mail.Session;\n+import javax.mail.Store;\n+import org.apache.commons.io.IOUtils;\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+\n+public abstract class AbstractNotificationTaskITCase extends AbstractTaskITCase {\n+\n+    private static final String POP3_HOST = \"localhost\";\n+\n+    private static final int POP3_PORT = 1110;\n+\n+    private static String SMTP_HOST;\n+\n+    private static int SMTP_PORT;\n+\n+    private static GreenMail greenMail;\n+\n+    @BeforeClass\n+    public static void startGreenMail() {\n+        Properties props = new Properties();\n+        InputStream propStream = null;\n+        try {\n+            propStream = ExceptionMapperITCase.class.getResourceAsStream(\"/mail.properties\");\n+            props.load(propStream);\n+        } catch (Exception e) {\n+            LOG.error(\"Could not load /mail.properties\", e);\n+        } finally {\n+            IOUtils.closeQuietly(propStream);\n+        }\n+\n+        SMTP_HOST = props.getProperty(\"smtpHost\");\n+        assertNotNull(SMTP_HOST);\n+        SMTP_PORT = Integer.parseInt(props.getProperty(\"smtpPort\"));\n+        assertNotNull(SMTP_PORT);\n+\n+        ServerSetup[] config = new ServerSetup[2];\n+        config[0] = new ServerSetup(SMTP_PORT, SMTP_HOST, ServerSetup.PROTOCOL_SMTP);\n+        config[1] = new ServerSetup(POP3_PORT, POP3_HOST, ServerSetup.PROTOCOL_POP3);\n+        greenMail = new GreenMail(config);\n+        greenMail.start();\n+    }\n+\n+    @AfterClass\n+    public static void stopGreenMail() {\n+        if (greenMail != null) {\n+            greenMail.stop();\n+        }\n+    }\n+\n+    protected boolean verifyMail(final String sender, final String subject, final String mailAddress) throws Exception {\n+        LOG.info(\"Waiting for notification to be sent...\");\n+        greenMail.waitForIncomingEmail(1);\n+\n+        boolean found = false;\n+        Session session = Session.getDefaultInstance(System.getProperties());\n+        session.setDebug(true);\n+        Store store = session.getStore(\"pop3\");\n+        store.connect(POP3_HOST, POP3_PORT, mailAddress, mailAddress);\n+\n+        Folder inbox = store.getFolder(\"INBOX\");\n+        assertNotNull(inbox);\n+        inbox.open(Folder.READ_WRITE);\n+\n+        Message[] messages = inbox.getMessages();\n+        for (Message message : messages) {\n+            if (sender.equals(message.getFrom()[0].toString()) && subject.equals(message.getSubject())) {\n+                found = true;\n+                message.setFlag(Flags.Flag.DELETED, true);\n+            }\n+        }\n+\n+        inbox.close(true);\n+        store.close();\n+        return found;\n+    }\n+\n+}"},{"sha":"94dafbdd7f51032bbab3cf24184a00ae26d82b3f","filename":"fit/core-reference/src/test/java/org/apache/syncope/fit/core/AbstractTaskITCase.java","status":"modified","additions":41,"deletions":0,"changes":41,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/59d6d4a37b93757397f8e16da4bc2e7aa4fe3066/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FAbstractTaskITCase.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/59d6d4a37b93757397f8e16da4bc2e7aa4fe3066/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FAbstractTaskITCase.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FAbstractTaskITCase.java?ref=59d6d4a37b93757397f8e16da4bc2e7aa4fe3066","patch":"@@ -30,12 +30,18 @@\n import java.util.concurrent.Executors;\n import java.util.concurrent.Future;\n import java.util.concurrent.TimeUnit;\n+import org.apache.syncope.client.lib.SyncopeClient;\n+import org.apache.syncope.common.lib.SyncopeConstants;\n+import org.apache.syncope.common.lib.patch.DeassociationPatch;\n import org.apache.syncope.common.lib.to.AbstractTaskTO;\n import org.apache.syncope.common.lib.to.ExecTO;\n+import org.apache.syncope.common.lib.to.GroupTO;\n import org.apache.syncope.common.lib.to.NotificationTaskTO;\n import org.apache.syncope.common.lib.to.PagedResult;\n import org.apache.syncope.common.lib.to.UserTO;\n+import org.apache.syncope.common.lib.types.ResourceDeassociationAction;\n import org.apache.syncope.common.lib.types.TaskType;\n+import org.apache.syncope.common.rest.api.beans.AnyQuery;\n import org.apache.syncope.common.rest.api.beans.ExecuteQuery;\n import org.apache.syncope.common.rest.api.beans.TaskQuery;\n import org.apache.syncope.common.rest.api.service.TaskService;\n@@ -88,6 +94,41 @@ protected void removeTestUsers() {\n         }\n     }\n \n+    /**\n+     * Clean Syncope and LDAP resource status.\n+     */\n+    protected void ldapCleanup() {\n+        PagedResult<GroupTO> matchingGroups = groupService.search(new AnyQuery.Builder().realm(\n+                SyncopeConstants.ROOT_REALM).\n+                fiql(SyncopeClient.getGroupSearchConditionBuilder().is(\"name\").equalTo(\"testLDAPGroup\").query()).\n+                build());\n+        if (matchingGroups.getSize() > 0) {\n+            for (GroupTO group : matchingGroups.getResult()) {\n+                DeassociationPatch deassociationPatch = new DeassociationPatch();\n+                deassociationPatch.setKey(group.getKey());\n+                deassociationPatch.setAction(ResourceDeassociationAction.UNLINK);\n+                deassociationPatch.getResources().add(RESOURCE_NAME_LDAP);\n+                groupService.deassociate(deassociationPatch);\n+                groupService.delete(group.getKey());\n+            }\n+        }\n+        PagedResult<UserTO> matchingUsers = userService.search(\n+                new AnyQuery.Builder().realm(SyncopeConstants.ROOT_REALM).\n+                        fiql(SyncopeClient.getUserSearchConditionBuilder().is(\"username\").equalTo(\"pullFromLDAP\").\n+                                query()).\n+                        build());\n+        if (matchingUsers.getSize() > 0) {\n+            for (UserTO user : matchingUsers.getResult()) {\n+                DeassociationPatch deassociationPatch = new DeassociationPatch();\n+                deassociationPatch.setKey(user.getKey());\n+                deassociationPatch.setAction(ResourceDeassociationAction.UNLINK);\n+                deassociationPatch.getResources().add(RESOURCE_NAME_LDAP);\n+                userService.deassociate(deassociationPatch);\n+                userService.delete(user.getKey());\n+            }\n+        }\n+    }\n+\n     protected static ExecTO execTask(final TaskService taskService, final String taskKey, final String initialStatus,\n             final int maxWaitSeconds, final boolean dryRun) {\n "},{"sha":"e24fc66d6a41f3609dc7f0f987fc41e9d516c38f","filename":"fit/core-reference/src/test/java/org/apache/syncope/fit/core/GroupITCase.java","status":"modified","additions":0,"deletions":195,"changes":195,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/59d6d4a37b93757397f8e16da4bc2e7aa4fe3066/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FGroupITCase.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/59d6d4a37b93757397f8e16da4bc2e7aa4fe3066/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FGroupITCase.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FGroupITCase.java?ref=59d6d4a37b93757397f8e16da4bc2e7aa4fe3066","patch":"@@ -30,17 +30,11 @@\n import java.util.List;\n import java.util.Map;\n import java.util.UUID;\n-import javax.naming.NamingEnumeration;\n-import javax.naming.NamingException;\n-import javax.naming.directory.DirContext;\n-import javax.naming.directory.SearchControls;\n-import javax.naming.directory.SearchResult;\n import javax.ws.rs.ForbiddenException;\n import javax.ws.rs.core.GenericType;\n import javax.ws.rs.core.Response;\n import org.apache.commons.collections4.IterableUtils;\n import org.apache.commons.collections4.Predicate;\n-import org.apache.commons.lang3.SerializationUtils;\n import org.apache.syncope.client.lib.AnonymousAuthenticationHandler;\n import org.apache.syncope.client.lib.SyncopeClient;\n import org.apache.syncope.common.lib.AnyOperations;\n@@ -61,27 +55,21 @@\n import org.apache.syncope.common.lib.to.BulkActionResult;\n import org.apache.syncope.common.lib.to.ConnInstanceTO;\n import org.apache.syncope.common.lib.to.ConnObjectTO;\n-import org.apache.syncope.common.lib.to.DerSchemaTO;\n import org.apache.syncope.common.lib.to.ExecTO;\n-import org.apache.syncope.common.lib.to.MappingItemTO;\n import org.apache.syncope.common.lib.to.PagedResult;\n import org.apache.syncope.common.lib.to.PlainSchemaTO;\n import org.apache.syncope.common.lib.to.ResourceTO;\n import org.apache.syncope.common.lib.to.GroupTO;\n-import org.apache.syncope.common.lib.to.MappingTO;\n import org.apache.syncope.common.lib.to.MembershipTO;\n import org.apache.syncope.common.lib.to.PropagationStatus;\n-import org.apache.syncope.common.lib.to.ProvisionTO;\n import org.apache.syncope.common.lib.to.ProvisioningResult;\n import org.apache.syncope.common.lib.to.SchedTaskTO;\n import org.apache.syncope.common.lib.to.TypeExtensionTO;\n import org.apache.syncope.common.lib.to.UserTO;\n import org.apache.syncope.common.lib.types.AnyTypeKind;\n-import org.apache.syncope.common.lib.types.AttrSchemaType;\n import org.apache.syncope.common.lib.types.BulkMembersActionType;\n import org.apache.syncope.common.lib.types.ClientExceptionType;\n import org.apache.syncope.common.lib.types.ConnectorCapability;\n-import org.apache.syncope.common.lib.types.MappingPurpose;\n import org.apache.syncope.common.lib.types.PatchOperation;\n import org.apache.syncope.common.lib.types.PropagationTaskExecStatus;\n import org.apache.syncope.common.lib.types.ResourceAssociationAction;\n@@ -888,187 +876,4 @@ public void bulkMembersAction() throws InterruptedException {\n             userService.delete(userTO.getKey());\n         }\n     }\n-\n-    @Test\n-    public void issue178() {\n-        GroupTO groupTO = new GroupTO();\n-        String groupName = \"torename\" + getUUIDString();\n-        groupTO.setName(groupName);\n-        groupTO.setRealm(\"/\");\n-\n-        GroupTO actual = createGroup(groupTO).getEntity();\n-\n-        assertNotNull(actual);\n-        assertEquals(groupName, actual.getName());\n-\n-        GroupPatch groupPatch = new GroupPatch();\n-        groupPatch.setKey(actual.getKey());\n-        String renamedGroup = \"renamed\" + getUUIDString();\n-        groupPatch.setName(new StringReplacePatchItem.Builder().value(renamedGroup).build());\n-\n-        actual = updateGroup(groupPatch).getEntity();\n-        assertNotNull(actual);\n-        assertEquals(renamedGroup, actual.getName());\n-    }\n-\n-    @Test\n-    public void issueSYNCOPE632() {\n-        DerSchemaTO orig = schemaService.read(SchemaType.DERIVED, \"displayProperty\");\n-        DerSchemaTO modified = SerializationUtils.clone(orig);\n-        modified.setExpression(\"icon + '_' + show\");\n-\n-        GroupTO groupTO = getSampleTO(\"lastGroup\");\n-        try {\n-            schemaService.update(SchemaType.DERIVED, modified);\n-\n-            // 0. create group\n-            groupTO.getPlainAttrs().add(attrTO(\"icon\", \"anIcon\"));\n-            groupTO.getPlainAttrs().add(attrTO(\"show\", \"true\"));\n-            groupTO.getDerAttrs().add(attrTO(\"displayProperty\", null));\n-            groupTO.getResources().clear();\n-\n-            groupTO = createGroup(groupTO).getEntity();\n-            assertNotNull(groupTO);\n-\n-            // 1. create new LDAP resource having ConnObjectKey mapped to a derived attribute\n-            ResourceTO newLDAP = resourceService.read(RESOURCE_NAME_LDAP);\n-            newLDAP.setKey(\"new-ldap\");\n-            newLDAP.setPropagationPriority(0);\n-\n-            for (ProvisionTO provision : newLDAP.getProvisions()) {\n-                provision.getVirSchemas().clear();\n-            }\n-\n-            MappingTO mapping = newLDAP.getProvision(AnyTypeKind.GROUP.name()).getMapping();\n-\n-            MappingItemTO connObjectKey = mapping.getConnObjectKeyItem();\n-            connObjectKey.setIntAttrName(\"displayProperty\");\n-            connObjectKey.setPurpose(MappingPurpose.PROPAGATION);\n-            mapping.setConnObjectKeyItem(connObjectKey);\n-            mapping.setConnObjectLink(\"'cn=' + displayProperty + ',ou=groups,o=isp'\");\n-\n-            MappingItemTO description = new MappingItemTO();\n-            description.setIntAttrName(\"key\");\n-            description.setExtAttrName(\"description\");\n-            description.setPurpose(MappingPurpose.PROPAGATION);\n-            mapping.add(description);\n-\n-            newLDAP = createResource(newLDAP);\n-            assertNotNull(newLDAP);\n-\n-            // 2. update group and give the resource created above\n-            GroupPatch patch = new GroupPatch();\n-            patch.setKey(groupTO.getKey());\n-            patch.getResources().add(new StringPatchItem.Builder().\n-                    operation(PatchOperation.ADD_REPLACE).\n-                    value(\"new-ldap\").build());\n-\n-            groupTO = updateGroup(patch).getEntity();\n-            assertNotNull(groupTO);\n-\n-            // 3. update the group\n-            GroupPatch groupPatch = new GroupPatch();\n-            groupPatch.setKey(groupTO.getKey());\n-            groupPatch.getPlainAttrs().add(attrAddReplacePatch(\"icon\", \"anotherIcon\"));\n-\n-            groupTO = updateGroup(groupPatch).getEntity();\n-            assertNotNull(groupTO);\n-\n-            // 4. check that a single group exists in LDAP for the group created and updated above\n-            int entries = 0;\n-            DirContext ctx = null;\n-            try {\n-                ctx = getLdapResourceDirContext(null, null);\n-\n-                SearchControls ctls = new SearchControls();\n-                ctls.setReturningAttributes(new String[] { \"*\", \"+\" });\n-                ctls.setSearchScope(SearchControls.SUBTREE_SCOPE);\n-\n-                NamingEnumeration<SearchResult> result =\n-                        ctx.search(\"ou=groups,o=isp\", \"(description=\" + groupTO.getKey() + \")\", ctls);\n-                while (result.hasMore()) {\n-                    result.next();\n-                    entries++;\n-                }\n-            } catch (Exception e) {\n-                // ignore\n-            } finally {\n-                if (ctx != null) {\n-                    try {\n-                        ctx.close();\n-                    } catch (NamingException e) {\n-                        // ignore\n-                    }\n-                }\n-            }\n-\n-            assertEquals(1, entries);\n-        } finally {\n-            schemaService.update(SchemaType.DERIVED, orig);\n-            if (groupTO.getKey() != null) {\n-                groupService.delete(groupTO.getKey());\n-            }\n-            resourceService.delete(\"new-ldap\");\n-        }\n-    }\n-\n-    @Test\n-    public void issueSYNCOPE717() {\n-        String doubleSchemaName = \"double\" + getUUIDString();\n-\n-        // 1. create double schema without conversion pattern\n-        PlainSchemaTO schema = new PlainSchemaTO();\n-        schema.setKey(doubleSchemaName);\n-        schema.setType(AttrSchemaType.Double);\n-\n-        schema = createSchema(SchemaType.PLAIN, schema);\n-        assertNotNull(schema);\n-        assertNull(schema.getConversionPattern());\n-\n-        AnyTypeClassTO minimalGroup = anyTypeClassService.read(\"minimal group\");\n-        assertNotNull(minimalGroup);\n-        minimalGroup.getPlainSchemas().add(doubleSchemaName);\n-        anyTypeClassService.update(minimalGroup);\n-\n-        // 2. create group, provide valid input value\n-        GroupTO groupTO = getBasicSampleTO(\"syncope717\");\n-        groupTO.getPlainAttrs().add(attrTO(doubleSchemaName, \"11.23\"));\n-\n-        groupTO = createGroup(groupTO).getEntity();\n-        assertNotNull(groupTO);\n-        assertEquals(\"11.23\", groupTO.getPlainAttr(doubleSchemaName).getValues().get(0));\n-\n-        // 3. update schema, set conversion pattern\n-        schema = schemaService.read(SchemaType.PLAIN, schema.getKey());\n-        schema.setConversionPattern(\"0.000\");\n-        schemaService.update(SchemaType.PLAIN, schema);\n-\n-        // 4. re-read group, verify that pattern was applied\n-        groupTO = groupService.read(groupTO.getKey());\n-        assertNotNull(groupTO);\n-        assertEquals(\"11.230\", groupTO.getPlainAttr(doubleSchemaName).getValues().get(0));\n-\n-        // 5. modify group with new double value\n-        GroupPatch patch = new GroupPatch();\n-        patch.setKey(groupTO.getKey());\n-        patch.getPlainAttrs().add(new AttrPatch.Builder().attrTO(attrTO(doubleSchemaName, \"11.257\")).build());\n-\n-        groupTO = updateGroup(patch).getEntity();\n-        assertNotNull(groupTO);\n-        assertEquals(\"11.257\", groupTO.getPlainAttr(doubleSchemaName).getValues().get(0));\n-\n-        // 6. update schema, unset conversion pattern\n-        schema.setConversionPattern(null);\n-        schemaService.update(SchemaType.PLAIN, schema);\n-\n-        // 7. modify group with new double value, verify that no pattern is applied\n-        patch = new GroupPatch();\n-        patch.setKey(groupTO.getKey());\n-        patch.getPlainAttrs().add(new AttrPatch.Builder().attrTO(attrTO(doubleSchemaName, \"11.23\")).build());\n-\n-        groupTO = updateGroup(patch).getEntity();\n-        assertNotNull(groupTO);\n-        assertEquals(\"11.23\", groupTO.getPlainAttr(doubleSchemaName).getValues().get(0));\n-    }\n-\n }"},{"sha":"7f1a03d204f0c8d30288dd557ba1082748086cc9","filename":"fit/core-reference/src/test/java/org/apache/syncope/fit/core/GroupIssuesITCase.java","status":"added","additions":235,"deletions":0,"changes":235,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/59d6d4a37b93757397f8e16da4bc2e7aa4fe3066/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FGroupIssuesITCase.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/59d6d4a37b93757397f8e16da4bc2e7aa4fe3066/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FGroupIssuesITCase.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FGroupIssuesITCase.java?ref=59d6d4a37b93757397f8e16da4bc2e7aa4fe3066","patch":"@@ -0,0 +1,235 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.fit.core;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+\n+import javax.naming.NamingEnumeration;\n+import javax.naming.NamingException;\n+import javax.naming.directory.DirContext;\n+import javax.naming.directory.SearchControls;\n+import javax.naming.directory.SearchResult;\n+import org.apache.commons.lang3.SerializationUtils;\n+import org.apache.syncope.common.lib.patch.AttrPatch;\n+import org.apache.syncope.common.lib.patch.GroupPatch;\n+import org.apache.syncope.common.lib.patch.StringPatchItem;\n+import org.apache.syncope.common.lib.patch.StringReplacePatchItem;\n+import org.apache.syncope.common.lib.to.AnyTypeClassTO;\n+import org.apache.syncope.common.lib.to.DerSchemaTO;\n+import org.apache.syncope.common.lib.to.MappingItemTO;\n+import org.apache.syncope.common.lib.to.PlainSchemaTO;\n+import org.apache.syncope.common.lib.to.ResourceTO;\n+import org.apache.syncope.common.lib.to.GroupTO;\n+import org.apache.syncope.common.lib.to.MappingTO;\n+import org.apache.syncope.common.lib.to.ProvisionTO;\n+import org.apache.syncope.common.lib.types.AnyTypeKind;\n+import org.apache.syncope.common.lib.types.AttrSchemaType;\n+import org.apache.syncope.common.lib.types.MappingPurpose;\n+import org.apache.syncope.common.lib.types.PatchOperation;\n+import org.apache.syncope.common.lib.types.SchemaType;\n+import org.apache.syncope.fit.AbstractITCase;\n+import org.junit.Test;\n+\n+public class GroupIssuesITCase extends AbstractITCase {\n+\n+    @Test\n+    public void issue178() {\n+        GroupTO groupTO = new GroupTO();\n+        String groupName = \"torename\" + getUUIDString();\n+        groupTO.setName(groupName);\n+        groupTO.setRealm(\"/\");\n+\n+        GroupTO actual = createGroup(groupTO).getEntity();\n+\n+        assertNotNull(actual);\n+        assertEquals(groupName, actual.getName());\n+\n+        GroupPatch groupPatch = new GroupPatch();\n+        groupPatch.setKey(actual.getKey());\n+        String renamedGroup = \"renamed\" + getUUIDString();\n+        groupPatch.setName(new StringReplacePatchItem.Builder().value(renamedGroup).build());\n+\n+        actual = updateGroup(groupPatch).getEntity();\n+        assertNotNull(actual);\n+        assertEquals(renamedGroup, actual.getName());\n+    }\n+\n+    @Test\n+    public void issueSYNCOPE632() {\n+        DerSchemaTO orig = schemaService.read(SchemaType.DERIVED, \"displayProperty\");\n+        DerSchemaTO modified = SerializationUtils.clone(orig);\n+        modified.setExpression(\"icon + '_' + show\");\n+\n+        GroupTO groupTO = GroupITCase.getSampleTO(\"lastGroup\");\n+        try {\n+            schemaService.update(SchemaType.DERIVED, modified);\n+\n+            // 0. create group\n+            groupTO.getPlainAttrs().add(attrTO(\"icon\", \"anIcon\"));\n+            groupTO.getPlainAttrs().add(attrTO(\"show\", \"true\"));\n+            groupTO.getDerAttrs().add(attrTO(\"displayProperty\", null));\n+            groupTO.getResources().clear();\n+\n+            groupTO = createGroup(groupTO).getEntity();\n+            assertNotNull(groupTO);\n+\n+            // 1. create new LDAP resource having ConnObjectKey mapped to a derived attribute\n+            ResourceTO newLDAP = resourceService.read(RESOURCE_NAME_LDAP);\n+            newLDAP.setKey(\"new-ldap\");\n+            newLDAP.setPropagationPriority(0);\n+\n+            for (ProvisionTO provision : newLDAP.getProvisions()) {\n+                provision.getVirSchemas().clear();\n+            }\n+\n+            MappingTO mapping = newLDAP.getProvision(AnyTypeKind.GROUP.name()).getMapping();\n+\n+            MappingItemTO connObjectKey = mapping.getConnObjectKeyItem();\n+            connObjectKey.setIntAttrName(\"displayProperty\");\n+            connObjectKey.setPurpose(MappingPurpose.PROPAGATION);\n+            mapping.setConnObjectKeyItem(connObjectKey);\n+            mapping.setConnObjectLink(\"'cn=' + displayProperty + ',ou=groups,o=isp'\");\n+\n+            MappingItemTO description = new MappingItemTO();\n+            description.setIntAttrName(\"key\");\n+            description.setExtAttrName(\"description\");\n+            description.setPurpose(MappingPurpose.PROPAGATION);\n+            mapping.add(description);\n+\n+            newLDAP = createResource(newLDAP);\n+            assertNotNull(newLDAP);\n+\n+            // 2. update group and give the resource created above\n+            GroupPatch patch = new GroupPatch();\n+            patch.setKey(groupTO.getKey());\n+            patch.getResources().add(new StringPatchItem.Builder().\n+                    operation(PatchOperation.ADD_REPLACE).\n+                    value(\"new-ldap\").build());\n+\n+            groupTO = updateGroup(patch).getEntity();\n+            assertNotNull(groupTO);\n+\n+            // 3. update the group\n+            GroupPatch groupPatch = new GroupPatch();\n+            groupPatch.setKey(groupTO.getKey());\n+            groupPatch.getPlainAttrs().add(attrAddReplacePatch(\"icon\", \"anotherIcon\"));\n+\n+            groupTO = updateGroup(groupPatch).getEntity();\n+            assertNotNull(groupTO);\n+\n+            // 4. check that a single group exists in LDAP for the group created and updated above\n+            int entries = 0;\n+            DirContext ctx = null;\n+            try {\n+                ctx = getLdapResourceDirContext(null, null);\n+\n+                SearchControls ctls = new SearchControls();\n+                ctls.setReturningAttributes(new String[] { \"*\", \"+\" });\n+                ctls.setSearchScope(SearchControls.SUBTREE_SCOPE);\n+\n+                NamingEnumeration<SearchResult> result =\n+                        ctx.search(\"ou=groups,o=isp\", \"(description=\" + groupTO.getKey() + \")\", ctls);\n+                while (result.hasMore()) {\n+                    result.next();\n+                    entries++;\n+                }\n+            } catch (Exception e) {\n+                // ignore\n+            } finally {\n+                if (ctx != null) {\n+                    try {\n+                        ctx.close();\n+                    } catch (NamingException e) {\n+                        // ignore\n+                    }\n+                }\n+            }\n+\n+            assertEquals(1, entries);\n+        } finally {\n+            schemaService.update(SchemaType.DERIVED, orig);\n+            if (groupTO.getKey() != null) {\n+                groupService.delete(groupTO.getKey());\n+            }\n+            resourceService.delete(\"new-ldap\");\n+        }\n+    }\n+\n+    @Test\n+    public void issueSYNCOPE717() {\n+        String doubleSchemaName = \"double\" + getUUIDString();\n+\n+        // 1. create double schema without conversion pattern\n+        PlainSchemaTO schema = new PlainSchemaTO();\n+        schema.setKey(doubleSchemaName);\n+        schema.setType(AttrSchemaType.Double);\n+\n+        schema = createSchema(SchemaType.PLAIN, schema);\n+        assertNotNull(schema);\n+        assertNull(schema.getConversionPattern());\n+\n+        AnyTypeClassTO minimalGroup = anyTypeClassService.read(\"minimal group\");\n+        assertNotNull(minimalGroup);\n+        minimalGroup.getPlainSchemas().add(doubleSchemaName);\n+        anyTypeClassService.update(minimalGroup);\n+\n+        // 2. create group, provide valid input value\n+        GroupTO groupTO = GroupITCase.getBasicSampleTO(\"syncope717\");\n+        groupTO.getPlainAttrs().add(attrTO(doubleSchemaName, \"11.23\"));\n+\n+        groupTO = createGroup(groupTO).getEntity();\n+        assertNotNull(groupTO);\n+        assertEquals(\"11.23\", groupTO.getPlainAttr(doubleSchemaName).getValues().get(0));\n+\n+        // 3. update schema, set conversion pattern\n+        schema = schemaService.read(SchemaType.PLAIN, schema.getKey());\n+        schema.setConversionPattern(\"0.000\");\n+        schemaService.update(SchemaType.PLAIN, schema);\n+\n+        // 4. re-read group, verify that pattern was applied\n+        groupTO = groupService.read(groupTO.getKey());\n+        assertNotNull(groupTO);\n+        assertEquals(\"11.230\", groupTO.getPlainAttr(doubleSchemaName).getValues().get(0));\n+\n+        // 5. modify group with new double value\n+        GroupPatch patch = new GroupPatch();\n+        patch.setKey(groupTO.getKey());\n+        patch.getPlainAttrs().add(new AttrPatch.Builder().attrTO(attrTO(doubleSchemaName, \"11.257\")).build());\n+\n+        groupTO = updateGroup(patch).getEntity();\n+        assertNotNull(groupTO);\n+        assertEquals(\"11.257\", groupTO.getPlainAttr(doubleSchemaName).getValues().get(0));\n+\n+        // 6. update schema, unset conversion pattern\n+        schema.setConversionPattern(null);\n+        schemaService.update(SchemaType.PLAIN, schema);\n+\n+        // 7. modify group with new double value, verify that no pattern is applied\n+        patch = new GroupPatch();\n+        patch.setKey(groupTO.getKey());\n+        patch.getPlainAttrs().add(new AttrPatch.Builder().attrTO(attrTO(doubleSchemaName, \"11.23\")).build());\n+\n+        groupTO = updateGroup(patch).getEntity();\n+        assertNotNull(groupTO);\n+        assertEquals(\"11.23\", groupTO.getPlainAttr(doubleSchemaName).getValues().get(0));\n+    }\n+\n+}"},{"sha":"421dab7de2fc48b4318ec874835d955f109db0ba","filename":"fit/core-reference/src/test/java/org/apache/syncope/fit/core/NotificationTaskITCase.java","status":"modified","additions":1,"deletions":308,"changes":309,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/59d6d4a37b93757397f8e16da4bc2e7aa4fe3066/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FNotificationTaskITCase.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/59d6d4a37b93757397f8e16da4bc2e7aa4fe3066/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FNotificationTaskITCase.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FNotificationTaskITCase.java?ref=59d6d4a37b93757397f8e16da4bc2e7aa4fe3066","patch":"@@ -23,113 +23,15 @@\n import static org.junit.Assert.assertNotNull;\n import static org.junit.Assert.assertTrue;\n \n-import com.icegreen.greenmail.util.GreenMail;\n-import com.icegreen.greenmail.util.ServerSetup;\n-import java.io.InputStream;\n-import java.util.Properties;\n-import javax.mail.Flags;\n-import javax.mail.Folder;\n-import javax.mail.Message;\n-import javax.mail.Session;\n-import javax.mail.Store;\n-import javax.ws.rs.core.Response;\n-import org.apache.commons.collections4.CollectionUtils;\n-import org.apache.commons.io.IOUtils;\n-import org.apache.commons.lang3.StringUtils;\n import org.apache.commons.lang3.tuple.Pair;\n-import org.apache.syncope.client.lib.SyncopeClient;\n import org.apache.syncope.common.lib.to.AttrTO;\n-import org.apache.syncope.common.lib.to.GroupTO;\n-import org.apache.syncope.common.lib.to.MembershipTO;\n-import org.apache.syncope.common.lib.to.NotificationTO;\n import org.apache.syncope.common.lib.to.NotificationTaskTO;\n import org.apache.syncope.common.lib.to.ExecTO;\n-import org.apache.syncope.common.lib.to.PagedResult;\n-import org.apache.syncope.common.lib.to.UserTO;\n-import org.apache.syncope.common.lib.types.AnyTypeKind;\n-import org.apache.syncope.common.lib.types.TaskType;\n import org.apache.syncope.common.lib.types.TraceLevel;\n-import org.apache.syncope.common.rest.api.beans.ExecuteQuery;\n-import org.apache.syncope.common.rest.api.beans.TaskQuery;\n-import org.apache.syncope.common.rest.api.service.NotificationService;\n import org.apache.syncope.core.provisioning.java.job.notification.NotificationJob;\n-import org.apache.syncope.fit.core.reference.TestNotificationRecipientsProvider;\n-import org.junit.AfterClass;\n-import org.junit.BeforeClass;\n import org.junit.Test;\n \n-public class NotificationTaskITCase extends AbstractTaskITCase {\n-\n-    private static final String MAIL_ADDRESS = \"notificationtest@syncope.apache.org\";\n-\n-    private static final String POP3_HOST = \"localhost\";\n-\n-    private static final int POP3_PORT = 1110;\n-\n-    private static String SMTP_HOST;\n-\n-    private static int SMTP_PORT;\n-\n-    private static GreenMail greenMail;\n-\n-    @BeforeClass\n-    public static void startGreenMail() {\n-        Properties props = new Properties();\n-        InputStream propStream = null;\n-        try {\n-            propStream = ExceptionMapperITCase.class.getResourceAsStream(\"/mail.properties\");\n-            props.load(propStream);\n-        } catch (Exception e) {\n-            LOG.error(\"Could not load /mail.properties\", e);\n-        } finally {\n-            IOUtils.closeQuietly(propStream);\n-        }\n-\n-        SMTP_HOST = props.getProperty(\"smtpHost\");\n-        assertNotNull(SMTP_HOST);\n-        SMTP_PORT = Integer.parseInt(props.getProperty(\"smtpPort\"));\n-        assertNotNull(SMTP_PORT);\n-\n-        ServerSetup[] config = new ServerSetup[2];\n-        config[0] = new ServerSetup(SMTP_PORT, SMTP_HOST, ServerSetup.PROTOCOL_SMTP);\n-        config[1] = new ServerSetup(POP3_PORT, POP3_HOST, ServerSetup.PROTOCOL_POP3);\n-        greenMail = new GreenMail(config);\n-        greenMail.start();\n-    }\n-\n-    @AfterClass\n-    public static void stopGreenMail() {\n-        if (greenMail != null) {\n-            greenMail.stop();\n-        }\n-    }\n-\n-    private boolean verifyMail(final String sender, final String subject, final String mailAddress) throws Exception {\n-        LOG.info(\"Waiting for notification to be sent...\");\n-        greenMail.waitForIncomingEmail(1);\n-\n-        boolean found = false;\n-        Session session = Session.getDefaultInstance(System.getProperties());\n-        session.setDebug(true);\n-        Store store = session.getStore(\"pop3\");\n-        store.connect(POP3_HOST, POP3_PORT, mailAddress, mailAddress);\n-\n-        Folder inbox = store.getFolder(\"INBOX\");\n-        assertNotNull(inbox);\n-        inbox.open(Folder.READ_WRITE);\n-\n-        Message[] messages = inbox.getMessages();\n-        for (Message message : messages) {\n-            if (sender.equals(message.getFrom()[0].toString()) && subject.equals(message.getSubject())) {\n-                found = true;\n-                message.setFlag(Flags.Flag.DELETED, true);\n-            }\n-        }\n-\n-        inbox.close(true);\n-        store.close();\n-        return found;\n-    }\n+public class NotificationTaskITCase extends AbstractNotificationTaskITCase {\n \n     @Test\n     public void notifyByMail() throws Exception {\n@@ -208,213 +110,4 @@ public void notifyByMailWithRetry() throws Exception {\n             configurationService.set(origMaxRetries);\n         }\n     }\n-\n-    @Test\n-    public void issueSYNCOPE81() {\n-        String sender = \"syncope81@syncope.apache.org\";\n-        Pair<String, String> created = createNotificationTask(true, true, TraceLevel.ALL, sender, \"Test notification\");\n-        NotificationTaskTO taskTO = findNotificationTask(created.getLeft(), 50);\n-        assertNotNull(taskTO);\n-        assertNotNull(taskTO.getNotification());\n-        assertTrue(taskTO.getExecutions().isEmpty());\n-\n-        // generate an execution in order to verify the deletion of a notification task with one or more executions\n-        execNotificationTask(taskService, taskTO.getKey(), 50);\n-\n-        taskTO = taskService.read(taskTO.getKey(), true);\n-        assertTrue(taskTO.isExecuted());\n-        assertFalse(taskTO.getExecutions().isEmpty());\n-\n-        taskService.delete(taskTO.getKey());\n-    }\n-\n-    @Test\n-    public void issueSYNCOPE86() {\n-        // 1. create notification task\n-        String sender = \"syncope86@syncope.apache.org\";\n-        Pair<String, String> created = createNotificationTask(true, true, TraceLevel.ALL, sender, \"Test notification\");\n-\n-        // 2. get NotificationTaskTO for user just created\n-        NotificationTaskTO taskTO = findNotificationTask(created.getLeft(), 50);\n-        assertNotNull(taskTO);\n-        assertNotNull(taskTO.getNotification());\n-        assertTrue(taskTO.getExecutions().isEmpty());\n-\n-        try {\n-            // 3. execute the generated NotificationTask\n-            execNotificationTask(taskService, taskTO.getKey(), 50);\n-\n-            // 4. verify\n-            taskTO = taskService.read(taskTO.getKey(), true);\n-            assertNotNull(taskTO);\n-            assertTrue(taskTO.isExecuted());\n-            assertEquals(1, taskTO.getExecutions().size());\n-        } finally {\n-            // Remove execution to make test re-runnable\n-            taskService.deleteExecution(taskTO.getExecutions().get(0).getKey());\n-        }\n-    }\n-\n-    @Test\n-    public void issueSYNCOPE192() throws Exception {\n-        String sender = \"syncopetest-\" + getUUIDString() + \"@syncope.apache.org\";\n-        String subject = \"Test notification \" + getUUIDString();\n-        Pair<String, String> created = createNotificationTask(true, true, TraceLevel.NONE, sender, subject);\n-        NotificationTaskTO taskTO = findNotificationTask(created.getLeft(), 50);\n-        assertNotNull(taskTO);\n-        assertNotNull(taskTO.getNotification());\n-        assertTrue(taskTO.getExecutions().isEmpty());\n-\n-        taskService.execute(new ExecuteQuery.Builder().key(taskTO.getKey()).build());\n-\n-        try {\n-            Thread.sleep(5);\n-        } catch (InterruptedException e) {\n-        }\n-\n-        assertTrue(verifyMail(sender, subject, created.getRight()));\n-\n-        // verify that last exec status was updated\n-        taskTO = taskService.read(taskTO.getKey(), true);\n-        assertNotNull(taskTO);\n-        assertTrue(taskTO.isExecuted());\n-        assertTrue(taskTO.getExecutions().isEmpty());\n-        assertTrue(StringUtils.isNotBlank(taskTO.getLatestExecStatus()));\n-    }\n-\n-    @Test\n-    public void issueSYNCOPE445() throws Exception {\n-        String sender = \"syncopetest-\" + getUUIDString() + \"@syncope.apache.org\";\n-        String subject = \"Test notification \" + getUUIDString();\n-        Pair<String, String> created = createNotificationTask(\n-                true, true, TraceLevel.ALL, sender, subject, \"syncope445@syncope.apache.org\");\n-        NotificationTaskTO taskTO = findNotificationTask(created.getLeft(), 50);\n-        assertNotNull(taskTO);\n-        assertNotNull(taskTO.getNotification());\n-        assertTrue(taskTO.getExecutions().isEmpty());\n-\n-        execNotificationTask(taskService, taskTO.getKey(), 50);\n-\n-        assertTrue(verifyMail(sender, subject, created.getRight()));\n-\n-        // verify task\n-        taskTO = taskService.read(taskTO.getKey(), true);\n-        assertTrue(taskTO.isExecuted());\n-        assertNotNull(taskTO);\n-        assertTrue(taskTO.getRecipients().contains(\"syncope445@syncope.apache.org\"));\n-    }\n-\n-    @Test\n-    public void issueSYNCOPE446() throws Exception {\n-        // 1. Create notification\n-        NotificationTO notification = new NotificationTO();\n-        notification.setTraceLevel(TraceLevel.ALL);\n-        notification.getEvents().add(\"[LOGIC]:[GroupLogic]:[]:[create]:[SUCCESS]\");\n-\n-        String groupName = \"group\" + getUUIDString();\n-        notification.getAbouts().put(AnyTypeKind.GROUP.name(),\n-                SyncopeClient.getGroupSearchConditionBuilder().is(\"name\").equalTo(groupName).query());\n-\n-        notification.setRecipientsFIQL(SyncopeClient.getUserSearchConditionBuilder().\n-                inGroups(\"f779c0d4-633b-4be5-8f57-32eb478a3ca5\").query());\n-        notification.setSelfAsRecipient(false);\n-        notification.setRecipientAttrName(\"email\");\n-        notification.getStaticRecipients().add(MAIL_ADDRESS);\n-        notification.setRecipientsProviderClassName(TestNotificationRecipientsProvider.class.getName());\n-\n-        String sender = \"syncopetest-\" + getUUIDString() + \"@syncope.apache.org\";\n-        notification.setSender(sender);\n-        String subject = \"Test notification \" + getUUIDString();\n-        notification.setSubject(subject);\n-        notification.setTemplate(\"optin\");\n-        notification.setActive(true);\n-\n-        Response response = notificationService.create(notification);\n-        notification = getObject(response.getLocation(), NotificationService.class, NotificationTO.class);\n-        assertNotNull(notification);\n-        assertEquals(TestNotificationRecipientsProvider.class.getName(), notification.getRecipientsProviderClassName());\n-\n-        // 2. create group\n-        GroupTO groupTO = new GroupTO();\n-        groupTO.setName(groupName);\n-        groupTO.setRealm(\"/even/two\");\n-        groupTO = createGroup(groupTO).getEntity();\n-        assertNotNull(groupTO);\n-\n-        // 3. verify\n-        NotificationTaskTO taskTO = findNotificationTask(notification.getKey(), 50);\n-        assertNotNull(taskTO);\n-        assertNotNull(taskTO.getNotification());\n-        assertTrue(taskTO.getRecipients().containsAll(\n-                new TestNotificationRecipientsProvider().provideRecipients(null)));\n-\n-        NotificationTaskTO foundViaList = taskService.<NotificationTaskTO>list(\n-                new TaskQuery.Builder(TaskType.NOTIFICATION).notification(notification.getKey()).build()).\n-                getResult().get(0);\n-        assertEquals(taskTO, foundViaList);\n-\n-        execNotificationTask(taskService, taskTO.getKey(), 50);\n-\n-        assertTrue(verifyMail(sender, subject, MAIL_ADDRESS));\n-    }\n-\n-    @Test\n-    public void issueSYNCOPE492() throws Exception {\n-        String sender = \"syncopetest-\" + getUUIDString() + \"@syncope.apache.org\";\n-        String subject = \"Test notification \" + getUUIDString();\n-        Pair<String, String> created =\n-                createNotificationTask(false, true, TraceLevel.NONE, sender, subject, \"syncope445@syncope.apache.org\");\n-\n-        // verify that no task was created for disabled notification\n-        PagedResult<NotificationTaskTO> tasks =\n-                taskService.list(new TaskQuery.Builder(TaskType.NOTIFICATION).notification(created.getLeft()).build());\n-        assertEquals(0, tasks.getSize());\n-    }\n-\n-    private Pair<String, String> createNotificationTask(\n-            final boolean active,\n-            final boolean includeAbout,\n-            final TraceLevel traceLevel,\n-            final String sender,\n-            final String subject,\n-            final String... staticRecipients) {\n-\n-        // 1. Create notification\n-        NotificationTO notification = new NotificationTO();\n-        notification.setTraceLevel(traceLevel);\n-        notification.getEvents().add(\"[LOGIC]:[UserLogic]:[]:[create]:[SUCCESS]\");\n-\n-        if (includeAbout) {\n-            notification.getAbouts().put(AnyTypeKind.USER.name(),\n-                    SyncopeClient.getUserSearchConditionBuilder().\n-                            inGroups(\"bf825fe1-7320-4a54-bd64-143b5c18ab97\").query());\n-        }\n-\n-        notification.setRecipientsFIQL(SyncopeClient.getUserSearchConditionBuilder().\n-                inGroups(\"f779c0d4-633b-4be5-8f57-32eb478a3ca5\").query());\n-        notification.setSelfAsRecipient(true);\n-        notification.setRecipientAttrName(\"email\");\n-        if (staticRecipients != null) {\n-            CollectionUtils.addAll(notification.getStaticRecipients(), staticRecipients);\n-        }\n-\n-        notification.setSender(sender);\n-        notification.setSubject(subject);\n-        notification.setTemplate(\"optin\");\n-        notification.setActive(active);\n-\n-        Response response = notificationService.create(notification);\n-        notification = getObject(response.getLocation(), NotificationService.class, NotificationTO.class);\n-        assertNotNull(notification);\n-\n-        // 2. create user\n-        UserTO userTO = UserITCase.getUniqueSampleTO(MAIL_ADDRESS);\n-        userTO.getMemberships().add(\n-                new MembershipTO.Builder().group(\"bf825fe1-7320-4a54-bd64-143b5c18ab97\").build());\n-\n-        userTO = createUser(userTO).getEntity();\n-        assertNotNull(userTO);\n-        return Pair.of(notification.getKey(), userTO.getUsername());\n-    }\n-\n }"},{"sha":"a695eb745bcc09ba9c7ee2cc4f02f855eb03198e","filename":"fit/core-reference/src/test/java/org/apache/syncope/fit/core/NotificationTaskIssuesITCase.java","status":"added","additions":207,"deletions":0,"changes":207,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/59d6d4a37b93757397f8e16da4bc2e7aa4fe3066/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FNotificationTaskIssuesITCase.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/59d6d4a37b93757397f8e16da4bc2e7aa4fe3066/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FNotificationTaskIssuesITCase.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FNotificationTaskIssuesITCase.java?ref=59d6d4a37b93757397f8e16da4bc2e7aa4fe3066","patch":"@@ -0,0 +1,207 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.fit.core;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import javax.ws.rs.core.Response;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.apache.syncope.client.lib.SyncopeClient;\n+import org.apache.syncope.common.lib.to.GroupTO;\n+import org.apache.syncope.common.lib.to.NotificationTO;\n+import org.apache.syncope.common.lib.to.NotificationTaskTO;\n+import org.apache.syncope.common.lib.to.PagedResult;\n+import org.apache.syncope.common.lib.types.AnyTypeKind;\n+import org.apache.syncope.common.lib.types.TaskType;\n+import org.apache.syncope.common.lib.types.TraceLevel;\n+import org.apache.syncope.common.rest.api.beans.ExecuteQuery;\n+import org.apache.syncope.common.rest.api.beans.TaskQuery;\n+import org.apache.syncope.common.rest.api.service.NotificationService;\n+import org.apache.syncope.fit.core.reference.TestNotificationRecipientsProvider;\n+import org.junit.Test;\n+\n+public class NotificationTaskIssuesITCase extends AbstractNotificationTaskITCase {\n+\n+    @Test\n+    public void issueSYNCOPE81() {\n+        String sender = \"syncope81@syncope.apache.org\";\n+        Pair<String, String> created = createNotificationTask(true, true, TraceLevel.ALL, sender, \"Test notification\");\n+        NotificationTaskTO taskTO = findNotificationTask(created.getLeft(), 50);\n+        assertNotNull(taskTO);\n+        assertNotNull(taskTO.getNotification());\n+        assertTrue(taskTO.getExecutions().isEmpty());\n+\n+        // generate an execution in order to verify the deletion of a notification task with one or more executions\n+        execNotificationTask(taskService, taskTO.getKey(), 50);\n+\n+        taskTO = taskService.read(taskTO.getKey(), true);\n+        assertTrue(taskTO.isExecuted());\n+        assertFalse(taskTO.getExecutions().isEmpty());\n+\n+        taskService.delete(taskTO.getKey());\n+    }\n+\n+    @Test\n+    public void issueSYNCOPE86() {\n+        // 1. create notification task\n+        String sender = \"syncope86@syncope.apache.org\";\n+        Pair<String, String> created = createNotificationTask(true, true, TraceLevel.ALL, sender, \"Test notification\");\n+\n+        // 2. get NotificationTaskTO for user just created\n+        NotificationTaskTO taskTO = findNotificationTask(created.getLeft(), 50);\n+        assertNotNull(taskTO);\n+        assertNotNull(taskTO.getNotification());\n+        assertTrue(taskTO.getExecutions().isEmpty());\n+\n+        try {\n+            // 3. execute the generated NotificationTask\n+            execNotificationTask(taskService, taskTO.getKey(), 50);\n+\n+            // 4. verify\n+            taskTO = taskService.read(taskTO.getKey(), true);\n+            assertNotNull(taskTO);\n+            assertTrue(taskTO.isExecuted());\n+            assertEquals(1, taskTO.getExecutions().size());\n+        } finally {\n+            // Remove execution to make test re-runnable\n+            taskService.deleteExecution(taskTO.getExecutions().get(0).getKey());\n+        }\n+    }\n+\n+    @Test\n+    public void issueSYNCOPE192() throws Exception {\n+        String sender = \"syncopetest-\" + getUUIDString() + \"@syncope.apache.org\";\n+        String subject = \"Test notification \" + getUUIDString();\n+        Pair<String, String> created = createNotificationTask(true, true, TraceLevel.NONE, sender, subject);\n+        NotificationTaskTO taskTO = findNotificationTask(created.getLeft(), 50);\n+        assertNotNull(taskTO);\n+        assertNotNull(taskTO.getNotification());\n+        assertTrue(taskTO.getExecutions().isEmpty());\n+\n+        taskService.execute(new ExecuteQuery.Builder().key(taskTO.getKey()).build());\n+\n+        try {\n+            Thread.sleep(5);\n+        } catch (InterruptedException e) {\n+        }\n+\n+        assertTrue(verifyMail(sender, subject, created.getRight()));\n+\n+        // verify that last exec status was updated\n+        taskTO = taskService.read(taskTO.getKey(), true);\n+        assertNotNull(taskTO);\n+        assertTrue(taskTO.isExecuted());\n+        assertTrue(taskTO.getExecutions().isEmpty());\n+        assertTrue(StringUtils.isNotBlank(taskTO.getLatestExecStatus()));\n+    }\n+\n+    @Test\n+    public void issueSYNCOPE445() throws Exception {\n+        String sender = \"syncopetest-\" + getUUIDString() + \"@syncope.apache.org\";\n+        String subject = \"Test notification \" + getUUIDString();\n+        Pair<String, String> created = createNotificationTask(\n+                true, true, TraceLevel.ALL, sender, subject, \"syncope445@syncope.apache.org\");\n+        NotificationTaskTO taskTO = findNotificationTask(created.getLeft(), 50);\n+        assertNotNull(taskTO);\n+        assertNotNull(taskTO.getNotification());\n+        assertTrue(taskTO.getExecutions().isEmpty());\n+\n+        execNotificationTask(taskService, taskTO.getKey(), 50);\n+\n+        assertTrue(verifyMail(sender, subject, created.getRight()));\n+\n+        // verify task\n+        taskTO = taskService.read(taskTO.getKey(), true);\n+        assertTrue(taskTO.isExecuted());\n+        assertNotNull(taskTO);\n+        assertTrue(taskTO.getRecipients().contains(\"syncope445@syncope.apache.org\"));\n+    }\n+\n+    @Test\n+    public void issueSYNCOPE446() throws Exception {\n+        // 1. Create notification\n+        NotificationTO notification = new NotificationTO();\n+        notification.setTraceLevel(TraceLevel.ALL);\n+        notification.getEvents().add(\"[LOGIC]:[GroupLogic]:[]:[create]:[SUCCESS]\");\n+\n+        String groupName = \"group\" + getUUIDString();\n+        notification.getAbouts().put(AnyTypeKind.GROUP.name(),\n+                SyncopeClient.getGroupSearchConditionBuilder().is(\"name\").equalTo(groupName).query());\n+\n+        notification.setRecipientsFIQL(SyncopeClient.getUserSearchConditionBuilder().\n+                inGroups(\"f779c0d4-633b-4be5-8f57-32eb478a3ca5\").query());\n+        notification.setSelfAsRecipient(false);\n+        notification.setRecipientAttrName(\"email\");\n+        notification.getStaticRecipients().add(\"notificationtest@syncope.apache.org\");\n+        notification.setRecipientsProviderClassName(TestNotificationRecipientsProvider.class.getName());\n+\n+        String sender = \"syncopetest-\" + getUUIDString() + \"@syncope.apache.org\";\n+        notification.setSender(sender);\n+        String subject = \"Test notification \" + getUUIDString();\n+        notification.setSubject(subject);\n+        notification.setTemplate(\"optin\");\n+        notification.setActive(true);\n+\n+        Response response = notificationService.create(notification);\n+        notification = getObject(response.getLocation(), NotificationService.class, NotificationTO.class);\n+        assertNotNull(notification);\n+        assertEquals(TestNotificationRecipientsProvider.class.getName(), notification.getRecipientsProviderClassName());\n+\n+        // 2. create group\n+        GroupTO groupTO = new GroupTO();\n+        groupTO.setName(groupName);\n+        groupTO.setRealm(\"/even/two\");\n+        groupTO = createGroup(groupTO).getEntity();\n+        assertNotNull(groupTO);\n+\n+        // 3. verify\n+        NotificationTaskTO taskTO = findNotificationTask(notification.getKey(), 50);\n+        assertNotNull(taskTO);\n+        assertNotNull(taskTO.getNotification());\n+        assertTrue(taskTO.getRecipients().containsAll(\n+                new TestNotificationRecipientsProvider().provideRecipients(null)));\n+\n+        NotificationTaskTO foundViaList = taskService.<NotificationTaskTO>list(\n+                new TaskQuery.Builder(TaskType.NOTIFICATION).notification(notification.getKey()).build()).\n+                getResult().get(0);\n+        assertEquals(taskTO, foundViaList);\n+\n+        execNotificationTask(taskService, taskTO.getKey(), 50);\n+\n+        assertTrue(verifyMail(sender, subject, \"notificationtest@syncope.apache.org\"));\n+    }\n+\n+    @Test\n+    public void issueSYNCOPE492() throws Exception {\n+        String sender = \"syncopetest-\" + getUUIDString() + \"@syncope.apache.org\";\n+        String subject = \"Test notification \" + getUUIDString();\n+        Pair<String, String> created =\n+                createNotificationTask(false, true, TraceLevel.NONE, sender, subject, \"syncope445@syncope.apache.org\");\n+\n+        // verify that no task was created for disabled notification\n+        PagedResult<NotificationTaskTO> tasks =\n+                taskService.list(new TaskQuery.Builder(TaskType.NOTIFICATION).notification(created.getLeft()).build());\n+        assertEquals(0, tasks.getSize());\n+    }\n+\n+}"},{"sha":"67d8f7806378cb4425a69f48a00df7c9d74a603a","filename":"fit/core-reference/src/test/java/org/apache/syncope/fit/core/PullTaskITCase.java","status":"modified","additions":0,"deletions":558,"changes":558,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/59d6d4a37b93757397f8e16da4bc2e7aa4fe3066/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FPullTaskITCase.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/59d6d4a37b93757397f8e16da4bc2e7aa4fe3066/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FPullTaskITCase.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FPullTaskITCase.java?ref=59d6d4a37b93757397f8e16da4bc2e7aa4fe3066","patch":"@@ -32,9 +32,6 @@\n import java.io.OutputStream;\n import java.util.Date;\n import java.util.HashSet;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Map;\n import java.util.Properties;\n import java.util.Set;\n import java.util.UUID;\n@@ -44,13 +41,10 @@\n import org.apache.commons.collections4.Predicate;\n import org.apache.commons.io.IOUtils;\n import org.apache.commons.lang3.SerializationUtils;\n-import org.apache.commons.lang3.tuple.Pair;\n import org.apache.syncope.client.lib.SyncopeClient;\n import org.apache.syncope.common.lib.SyncopeClientException;\n import org.apache.syncope.common.lib.SyncopeConstants;\n import org.apache.syncope.common.lib.patch.DeassociationPatch;\n-import org.apache.syncope.common.lib.patch.PasswordPatch;\n-import org.apache.syncope.common.lib.patch.UserPatch;\n import org.apache.syncope.common.lib.to.AbstractTaskTO;\n import org.apache.syncope.common.lib.to.AnyObjectTO;\n import org.apache.syncope.common.lib.to.AttrTO;\n@@ -61,15 +55,11 @@\n import org.apache.syncope.common.lib.to.ResourceTO;\n import org.apache.syncope.common.lib.to.GroupTO;\n import org.apache.syncope.common.lib.to.ProvisionTO;\n-import org.apache.syncope.common.lib.policy.PullPolicyTO;\n import org.apache.syncope.common.lib.to.MappingItemTO;\n-import org.apache.syncope.common.lib.to.ProvisioningResult;\n import org.apache.syncope.common.lib.to.PullTaskTO;\n import org.apache.syncope.common.lib.to.ExecTO;\n-import org.apache.syncope.common.lib.to.RealmTO;\n import org.apache.syncope.common.lib.to.UserTO;\n import org.apache.syncope.common.lib.types.AnyTypeKind;\n-import org.apache.syncope.common.lib.types.CipherAlgorithm;\n import org.apache.syncope.common.lib.types.ClientExceptionType;\n import org.apache.syncope.common.lib.types.ConnConfProperty;\n import org.apache.syncope.common.lib.types.ConnectorCapability;\n@@ -81,15 +71,10 @@\n import org.apache.syncope.common.rest.api.beans.TaskQuery;\n import org.apache.syncope.common.rest.api.service.ConnectorService;\n import org.apache.syncope.common.rest.api.service.TaskService;\n-import org.apache.syncope.core.spring.security.Encryptor;\n-import org.apache.syncope.core.provisioning.java.pushpull.DBPasswordPullActions;\n-import org.apache.syncope.core.provisioning.java.pushpull.LDAPPasswordPullActions;\n import org.apache.syncope.fit.ActivitiDetector;\n import org.apache.syncope.fit.core.reference.PrefixMappingItemTransformer;\n import org.apache.syncope.fit.core.reference.TestReconciliationFilterBuilder;\n import org.apache.syncope.fit.core.reference.TestPullActions;\n-import org.apache.syncope.fit.core.reference.TestPullRule;\n-import org.identityconnectors.framework.common.objects.Name;\n import org.junit.BeforeClass;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n@@ -337,41 +322,6 @@ public void reconcileFromDB() {\n         }\n     }\n \n-    /**\n-     * Clean Syncope and LDAP resource status.\n-     */\n-    private void ldapCleanup() {\n-        PagedResult<GroupTO> matchingGroups = groupService.search(new AnyQuery.Builder().realm(\n-                SyncopeConstants.ROOT_REALM).\n-                fiql(SyncopeClient.getGroupSearchConditionBuilder().is(\"name\").equalTo(\"testLDAPGroup\").query()).\n-                build());\n-        if (matchingGroups.getSize() > 0) {\n-            for (GroupTO group : matchingGroups.getResult()) {\n-                DeassociationPatch deassociationPatch = new DeassociationPatch();\n-                deassociationPatch.setKey(group.getKey());\n-                deassociationPatch.setAction(ResourceDeassociationAction.UNLINK);\n-                deassociationPatch.getResources().add(RESOURCE_NAME_LDAP);\n-                groupService.deassociate(deassociationPatch);\n-                groupService.delete(group.getKey());\n-            }\n-        }\n-        PagedResult<UserTO> matchingUsers = userService.search(\n-                new AnyQuery.Builder().realm(SyncopeConstants.ROOT_REALM).\n-                        fiql(SyncopeClient.getUserSearchConditionBuilder().is(\"username\").equalTo(\"pullFromLDAP\").\n-                                query()).\n-                        build());\n-        if (matchingUsers.getSize() > 0) {\n-            for (UserTO user : matchingUsers.getResult()) {\n-                DeassociationPatch deassociationPatch = new DeassociationPatch();\n-                deassociationPatch.setKey(user.getKey());\n-                deassociationPatch.setAction(ResourceDeassociationAction.UNLINK);\n-                deassociationPatch.getResources().add(RESOURCE_NAME_LDAP);\n-                userService.deassociate(deassociationPatch);\n-                userService.delete(user.getKey());\n-            }\n-        }\n-    }\n-\n     @Test\n     public void reconcileFromLDAP() {\n         // First of all, clear any potential conflict with existing user / group\n@@ -667,512 +617,4 @@ public void syncTokenWithErrors() {\n             jdbcTemplate.execute(\"DELETE FROM testpull WHERE ID=1041\");\n         }\n     }\n-\n-    @Test\n-    public void orgUnit() {\n-        // 0. initial realms\n-        List<RealmTO> realms = realmService.list(\"/odd\");\n-        int pre = realms.size();\n-\n-        // 1. create task for pulling org units\n-        PullTaskTO pullTask = new PullTaskTO();\n-        pullTask.setActive(true);\n-        pullTask.setName(\"For orgUnit\");\n-        pullTask.setResource(RESOURCE_NAME_LDAP_ORGUNIT);\n-        pullTask.setDestinationRealm(\"/odd\");\n-        pullTask.setPullMode(PullMode.FULL_RECONCILIATION);\n-        pullTask.setPerformCreate(true);\n-        pullTask.setPerformUpdate(true);\n-        pullTask.setPerformDelete(true);\n-\n-        Response response = taskService.create(pullTask);\n-        if (response.getStatusInfo().getStatusCode() != Response.Status.CREATED.getStatusCode()) {\n-            throw (RuntimeException) clientFactory.getExceptionMapper().fromResponse(response);\n-        }\n-        pullTask = getObject(response.getLocation(), TaskService.class, PullTaskTO.class);\n-        assertNotNull(pullTask);\n-\n-        ExecTO exec = execProvisioningTask(taskService, pullTask.getKey(), 50, false);\n-        assertEquals(PropagationTaskExecStatus.SUCCESS, PropagationTaskExecStatus.valueOf(exec.getStatus()));\n-\n-        // 2. check\n-        realms = realmService.list(\"/odd\");\n-        int post = realms.size();\n-        assertEquals(pre + 2, post);\n-    }\n-\n-    @Test\n-    public void issueSYNCOPE68() {\n-        //-----------------------------\n-        // Create a new user ... it should be updated applying pull policy\n-        //-----------------------------\n-        UserTO userTO = new UserTO();\n-        userTO.setRealm(SyncopeConstants.ROOT_REALM);\n-        userTO.setPassword(\"password123\");\n-        userTO.setUsername(\"testuser2\");\n-\n-        userTO.getPlainAttrs().add(attrTO(\"firstname\", \"testuser2\"));\n-        userTO.getPlainAttrs().add(attrTO(\"surname\", \"testuser2\"));\n-        userTO.getPlainAttrs().add(attrTO(\"ctype\", \"a type\"));\n-        userTO.getPlainAttrs().add(attrTO(\"fullname\", \"a type\"));\n-        userTO.getPlainAttrs().add(attrTO(\"userId\", \"testuser2@syncope.apache.org\"));\n-        userTO.getPlainAttrs().add(attrTO(\"email\", \"testuser2@syncope.apache.org\"));\n-\n-        userTO.getResources().add(RESOURCE_NAME_NOPROPAGATION2);\n-        userTO.getResources().add(RESOURCE_NAME_NOPROPAGATION4);\n-\n-        userTO.getMemberships().add(\n-                new MembershipTO.Builder().group(\"bf825fe1-7320-4a54-bd64-143b5c18ab97\").build());\n-\n-        userTO = createUser(userTO).getEntity();\n-        assertNotNull(userTO);\n-        assertEquals(\"testuser2\", userTO.getUsername());\n-        assertEquals(1, userTO.getMemberships().size());\n-        assertEquals(3, userTO.getResources().size());\n-        //-----------------------------\n-\n-        try {\n-            //-----------------------------\n-            //  add user template\n-            //-----------------------------\n-            UserTO template = new UserTO();\n-\n-            template.getMemberships().add(\n-                    new MembershipTO.Builder().group(\"b8d38784-57e7-4595-859a-076222644b55\").build());\n-\n-            template.getResources().add(RESOURCE_NAME_NOPROPAGATION4);\n-            //-----------------------------\n-\n-            // Update pull task\n-            PullTaskTO task = taskService.read(\"81d88f73-d474-4450-9031-605daa4e313f\", true);\n-            assertNotNull(task);\n-\n-            task.getTemplates().put(AnyTypeKind.USER.name(), template);\n-\n-            taskService.update(task);\n-            PullTaskTO actual = taskService.read(task.getKey(), true);\n-            assertNotNull(actual);\n-            assertEquals(task.getKey(), actual.getKey());\n-            assertFalse(actual.getTemplates().get(AnyTypeKind.USER.name()).getResources().isEmpty());\n-            assertFalse(((UserTO) actual.getTemplates().get(AnyTypeKind.USER.name())).getMemberships().isEmpty());\n-\n-            ExecTO execution = execProvisioningTask(taskService, actual.getKey(), 50, false);\n-            assertEquals(PropagationTaskExecStatus.SUCCESS, PropagationTaskExecStatus.valueOf(execution.getStatus()));\n-\n-            userTO = userService.read(\"testuser2\");\n-            assertNotNull(userTO);\n-            assertEquals(\"testuser2@syncope.apache.org\", userTO.getPlainAttr(\"userId\").getValues().get(0));\n-            assertEquals(2, userTO.getMemberships().size());\n-            assertEquals(4, userTO.getResources().size());\n-        } finally {\n-            UserTO dUserTO = deleteUser(userTO.getKey()).getEntity();\n-            assertNotNull(dUserTO);\n-        }\n-    }\n-\n-    @Test\n-    public void issueSYNCOPE230() {\n-        JdbcTemplate jdbcTemplate = new JdbcTemplate(testDataSource);\n-\n-        // 1. populate the external table\n-        jdbcTemplate.execute(\"INSERT INTO testpull VALUES\"\n-                + \"('a54b3794-b231-47be-b24a-11e1a42949f6', 'issuesyncope230', 'Surname', 'syncope230@syncope.apache.org', NULL)\");\n-\n-        // 2. execute PullTask for resource-db-pull (table TESTPULL on external H2)\n-        execProvisioningTask(taskService, \"7c2242f4-14af-4ab5-af31-cdae23783655\", 50, false);\n-\n-        // 3. read e-mail address for user created by the PullTask first execution\n-        UserTO userTO = userService.read(\"issuesyncope230\");\n-        assertNotNull(userTO);\n-        String email = userTO.getPlainAttr(\"email\").getValues().iterator().next();\n-        assertNotNull(email);\n-\n-        // 4. update TESTPULL on external H2 by changing e-mail address\n-        jdbcTemplate.execute(\"UPDATE TESTPULL SET email='updatedSYNCOPE230@syncope.apache.org'\");\n-\n-        // 5. re-execute the PullTask\n-        execProvisioningTask(taskService, \"7c2242f4-14af-4ab5-af31-cdae23783655\", 50, false);\n-\n-        // 6. verify that the e-mail was updated\n-        userTO = userService.read(\"issuesyncope230\");\n-        assertNotNull(userTO);\n-        email = userTO.getPlainAttr(\"email\").getValues().iterator().next();\n-        assertNotNull(email);\n-        assertEquals(\"updatedSYNCOPE230@syncope.apache.org\", email);\n-    }\n-\n-    @Test\n-    public void issueSYNCOPE258() {\n-        // -----------------------------\n-        // Add a custom correlation rule\n-        // -----------------------------\n-        PullPolicyTO policyTO = policyService.read(\"9454b0d7-2610-400a-be82-fc23cf553dd6\");\n-        policyTO.getSpecification().getCorrelationRules().put(AnyTypeKind.USER.name(), TestPullRule.class.getName());\n-        policyService.update(policyTO);\n-        // -----------------------------\n-\n-        PullTaskTO task = new PullTaskTO();\n-        task.setDestinationRealm(SyncopeConstants.ROOT_REALM);\n-        task.setName(\"Test Pull Rule\");\n-        task.setActive(true);\n-        task.setResource(RESOURCE_NAME_WS2);\n-        task.setPullMode(PullMode.FULL_RECONCILIATION);\n-        task.setPerformCreate(true);\n-        task.setPerformDelete(true);\n-        task.setPerformUpdate(true);\n-\n-        Response response = taskService.create(task);\n-        task = getObject(response.getLocation(), TaskService.class, PullTaskTO.class);\n-\n-        UserTO userTO = UserITCase.getUniqueSampleTO(\"s258_1@apache.org\");\n-        userTO.getResources().clear();\n-        userTO.getResources().add(RESOURCE_NAME_WS2);\n-\n-        createUser(userTO);\n-\n-        userTO = UserITCase.getUniqueSampleTO(\"s258_2@apache.org\");\n-        userTO.getResources().clear();\n-        userTO.getResources().add(RESOURCE_NAME_WS2);\n-\n-        userTO = createUser(userTO).getEntity();\n-\n-        // change email in order to unmatch the second user\n-        UserPatch userPatch = new UserPatch();\n-        userPatch.setKey(userTO.getKey());\n-        userPatch.getPlainAttrs().add(attrAddReplacePatch(\"email\", \"s258@apache.org\"));\n-\n-        userService.update(userPatch);\n-\n-        execProvisioningTask(taskService, task.getKey(), 50, false);\n-\n-        PullTaskTO executed = taskService.read(task.getKey(), true);\n-        assertEquals(1, executed.getExecutions().size());\n-\n-        // asser for just one match\n-        assertTrue(executed.getExecutions().get(0).getMessage().substring(0, 55) + \"...\",\n-                executed.getExecutions().get(0).getMessage().contains(\"[updated/failures]: 1/0\"));\n-    }\n-\n-    @Test\n-    public void issueSYNCOPE272() {\n-        removeTestUsers();\n-\n-        // create user with testdb resource\n-        UserTO userTO = UserITCase.getUniqueSampleTO(\"syncope272@syncope.apache.org\");\n-        userTO.getResources().add(RESOURCE_NAME_TESTDB);\n-\n-        ProvisioningResult<UserTO> result = createUser(userTO);\n-        userTO = result.getEntity();\n-        try {\n-            assertNotNull(userTO);\n-            assertEquals(1, result.getPropagationStatuses().size());\n-            assertEquals(PropagationTaskExecStatus.SUCCESS, result.getPropagationStatuses().get(0).getStatus());\n-\n-            ExecTO taskExecTO = execProvisioningTask(\n-                    taskService, \"986867e2-993b-430e-8feb-aa9abb4c1dcd\", 50, false);\n-\n-            assertNotNull(taskExecTO.getStatus());\n-            assertEquals(PropagationTaskExecStatus.SUCCESS, PropagationTaskExecStatus.valueOf(taskExecTO.getStatus()));\n-\n-            userTO = userService.read(userTO.getKey());\n-            assertNotNull(userTO);\n-            assertNotNull(userTO.getPlainAttr(\"firstname\").getValues().get(0));\n-        } finally {\n-            removeTestUsers();\n-        }\n-    }\n-\n-    @Test\n-    public void issueSYNCOPE307() {\n-        UserTO userTO = UserITCase.getUniqueSampleTO(\"s307@apache.org\");\n-        userTO.setUsername(\"test0\");\n-        userTO.getPlainAttr(\"firstname\").getValues().clear();\n-        userTO.getPlainAttr(\"firstname\").getValues().add(\"nome0\");\n-        userTO.getAuxClasses().add(\"csv\");\n-\n-        AttrTO csvuserid = new AttrTO();\n-        csvuserid.setSchema(\"csvuserid\");\n-        userTO.getDerAttrs().add(csvuserid);\n-\n-        userTO.getResources().clear();\n-        userTO.getResources().add(RESOURCE_NAME_WS2);\n-\n-        userTO = createUser(userTO).getEntity();\n-        assertNotNull(userTO);\n-\n-        userTO = userService.read(userTO.getKey());\n-        assertTrue(userTO.getVirAttrs().isEmpty());\n-\n-        // Update pull task\n-        PullTaskTO task = taskService.read(\"38abbf9e-a1a3-40a1-a15f-7d0ac02f47f1\", true);\n-        assertNotNull(task);\n-\n-        UserTO template = new UserTO();\n-        template.setPassword(\"'password123'\");\n-        template.getResources().add(RESOURCE_NAME_DBVIRATTR);\n-        template.getVirAttrs().add(attrTO(\"virtualdata\", \"'virtualvalue'\"));\n-\n-        task.getTemplates().put(AnyTypeKind.USER.name(), template);\n-\n-        taskService.update(task);\n-\n-        // exec task: one user from CSV will match the user created above and template will be applied\n-        execProvisioningTask(taskService, task.getKey(), 50, false);\n-\n-        // check that template was successfully applied...\n-        userTO = userService.read(userTO.getKey());\n-        assertEquals(\"virtualvalue\", userTO.getVirAttr(\"virtualdata\").getValues().get(0));\n-\n-        // ...and that propagation to db succeeded\n-        JdbcTemplate jdbcTemplate = new JdbcTemplate(testDataSource);\n-        String value = queryForObject(\n-                jdbcTemplate, 50, \"SELECT USERNAME FROM testpull WHERE ID=?\", String.class, userTO.getKey());\n-        assertEquals(\"virtualvalue\", value);\n-    }\n-\n-    @Test\n-    public void issueSYNCOPE313DB() throws Exception {\n-        // 1. create user in DB\n-        UserTO user = UserITCase.getUniqueSampleTO(\"syncope313-db@syncope.apache.org\");\n-        user.setPassword(\"security123\");\n-        user.getResources().add(RESOURCE_NAME_TESTDB);\n-        user = createUser(user).getEntity();\n-        assertNotNull(user);\n-        assertFalse(user.getResources().isEmpty());\n-\n-        // 2. Check that the DB resource has the correct password\n-        JdbcTemplate jdbcTemplate = new JdbcTemplate(testDataSource);\n-        String value = queryForObject(\n-                jdbcTemplate, 50, \"SELECT PASSWORD FROM test WHERE ID=?\", String.class, user.getUsername());\n-        assertEquals(Encryptor.getInstance().encode(\"security123\", CipherAlgorithm.SHA1), value.toUpperCase());\n-\n-        // 3. Update the password in the DB\n-        String newCleanPassword = \"new-security\";\n-        String newPassword = Encryptor.getInstance().encode(newCleanPassword, CipherAlgorithm.SHA1);\n-        jdbcTemplate.execute(\"UPDATE test set PASSWORD='\" + newPassword + \"' where ID='\" + user.getUsername() + \"'\");\n-\n-        // 4. Pull the user from the resource\n-        PullTaskTO pullTask = new PullTaskTO();\n-        pullTask.setDestinationRealm(SyncopeConstants.ROOT_REALM);\n-        pullTask.setName(\"DB Pull Task\");\n-        pullTask.setActive(true);\n-        pullTask.setPerformCreate(true);\n-        pullTask.setPerformUpdate(true);\n-        pullTask.setPullMode(PullMode.FULL_RECONCILIATION);\n-        pullTask.setResource(RESOURCE_NAME_TESTDB);\n-        pullTask.getActionsClassNames().add(DBPasswordPullActions.class.getName());\n-        Response taskResponse = taskService.create(pullTask);\n-\n-        PullTaskTO actual = getObject(taskResponse.getLocation(), TaskService.class, PullTaskTO.class);\n-        assertNotNull(actual);\n-\n-        pullTask = taskService.read(actual.getKey(), true);\n-        assertNotNull(pullTask);\n-        assertEquals(actual.getKey(), pullTask.getKey());\n-        assertEquals(actual.getJobDelegateClassName(), pullTask.getJobDelegateClassName());\n-\n-        ExecTO execution = execProvisioningTask(taskService, pullTask.getKey(), 50, false);\n-        assertEquals(PropagationTaskExecStatus.SUCCESS, PropagationTaskExecStatus.valueOf(execution.getStatus()));\n-\n-        // 5. Test the pulled user\n-        Pair<Map<String, Set<String>>, UserTO> self = clientFactory.create(user.getUsername(), newCleanPassword).self();\n-        assertNotNull(self);\n-\n-        // 6. Delete PullTask + user\n-        taskService.delete(pullTask.getKey());\n-        deleteUser(user.getKey());\n-    }\n-\n-    @Test\n-    public void issueSYNCOPE313LDAP() throws Exception {\n-        // First of all, clear any potential conflict with existing user / group\n-        ldapCleanup();\n-\n-        UserTO user = null;\n-        PullTaskTO pullTask = null;\n-        ConnInstanceTO resourceConnector = null;\n-        ConnConfProperty property = null;\n-        try {\n-            // 1. create user in LDAP\n-            String oldCleanPassword = \"security123\";\n-            user = UserITCase.getUniqueSampleTO(\"syncope313-ldap@syncope.apache.org\");\n-            user.setPassword(oldCleanPassword);\n-            user.getResources().add(RESOURCE_NAME_LDAP);\n-            user = createUser(user).getEntity();\n-            assertNotNull(user);\n-            assertFalse(user.getResources().isEmpty());\n-\n-            // 2. request to change password only on Syncope and not on LDAP\n-            String newCleanPassword = \"new-security123\";\n-            UserPatch userPatch = new UserPatch();\n-            userPatch.setKey(user.getKey());\n-            userPatch.setPassword(new PasswordPatch.Builder().value(newCleanPassword).build());\n-            user = updateUser(userPatch).getEntity();\n-\n-            // 3. Check that the Syncope user now has the changed password\n-            Pair<Map<String, Set<String>>, UserTO> self =\n-                    clientFactory.create(user.getUsername(), newCleanPassword).self();\n-            assertNotNull(self);\n-\n-            // 4. Check that the LDAP resource has the old password\n-            ConnObjectTO connObject =\n-                    resourceService.readConnObject(RESOURCE_NAME_LDAP, AnyTypeKind.USER.name(), user.getKey());\n-            assertNotNull(getLdapRemoteObject(\n-                    connObject.getAttr(Name.NAME).getValues().get(0),\n-                    oldCleanPassword,\n-                    connObject.getAttr(Name.NAME).getValues().get(0)));\n-\n-            // 5. Update the LDAP Connector to retrieve passwords\n-            ResourceTO ldapResource = resourceService.read(RESOURCE_NAME_LDAP);\n-            resourceConnector = connectorService.read(\n-                    ldapResource.getConnector(), Locale.ENGLISH.getLanguage());\n-            property = resourceConnector.getConfMap().get(\"retrievePasswordsWithSearch\");\n-            property.getValues().clear();\n-            property.getValues().add(Boolean.TRUE);\n-            connectorService.update(resourceConnector);\n-\n-            // 6. Pull the user from the resource\n-            pullTask = new PullTaskTO();\n-            pullTask.setDestinationRealm(SyncopeConstants.ROOT_REALM);\n-            pullTask.setName(\"LDAP Pull Task\");\n-            pullTask.setActive(true);\n-            pullTask.setPerformCreate(true);\n-            pullTask.setPerformUpdate(true);\n-            pullTask.setPullMode(PullMode.FULL_RECONCILIATION);\n-            pullTask.setResource(RESOURCE_NAME_LDAP);\n-            pullTask.getActionsClassNames().add(LDAPPasswordPullActions.class.getName());\n-            Response taskResponse = taskService.create(pullTask);\n-\n-            pullTask = getObject(taskResponse.getLocation(), TaskService.class, PullTaskTO.class);\n-            assertNotNull(pullTask);\n-\n-            ExecTO execution = execProvisioningTask(taskService, pullTask.getKey(), 50, false);\n-            assertEquals(PropagationTaskExecStatus.SUCCESS, PropagationTaskExecStatus.valueOf(execution.getStatus()));\n-\n-            // 7. Test the pulled user\n-            self = clientFactory.create(user.getUsername(), oldCleanPassword).self();\n-            assertNotNull(self);\n-        } catch (Exception e) {\n-            fail(e.getMessage());\n-        } finally {\n-            // Delete PullTask + user + reset the connector\n-            if (pullTask != null) {\n-                taskService.delete(pullTask.getKey());\n-            }\n-\n-            if (resourceConnector != null && property != null) {\n-                property.getValues().clear();\n-                property.getValues().add(Boolean.FALSE);\n-                connectorService.update(resourceConnector);\n-            }\n-\n-            if (user != null) {\n-                deleteUser(user.getKey());\n-            }\n-        }\n-    }\n-\n-    @Test\n-    public void issueSYNCOPE1062() {\n-        GroupTO propagationGroup = null;\n-        PullTaskTO pullTask = null;\n-        UserTO user = null;\n-        GroupTO group = null;\n-        try {\n-            // 1. create group with resource for propagation\n-            propagationGroup = GroupITCase.getBasicSampleTO(\"SYNCOPE1062\");\n-            propagationGroup.getResources().add(RESOURCE_NAME_DBPULL);\n-            propagationGroup = createGroup(propagationGroup).getEntity();\n-\n-            // 2. create pull task for another resource, with user template assigning the group above\n-            pullTask = new PullTaskTO();\n-            pullTask.setDestinationRealm(SyncopeConstants.ROOT_REALM);\n-            pullTask.setName(\"SYNCOPE1062\");\n-            pullTask.setActive(true);\n-            pullTask.setPerformCreate(true);\n-            pullTask.setPerformUpdate(true);\n-            pullTask.setPullMode(PullMode.FULL_RECONCILIATION);\n-            pullTask.setResource(RESOURCE_NAME_LDAP);\n-\n-            UserTO template = new UserTO();\n-            template.getAuxClasses().add(\"minimal group\");\n-            template.getMemberships().add(new MembershipTO.Builder().group(propagationGroup.getKey()).build());\n-            template.getPlainAttrs().add(attrTO(\"firstname\", \"'fixed'\"));\n-            pullTask.getTemplates().put(AnyTypeKind.USER.name(), template);\n-\n-            Response taskResponse = taskService.create(pullTask);\n-            pullTask = getObject(taskResponse.getLocation(), TaskService.class, PullTaskTO.class);\n-            assertNotNull(pullTask);\n-            assertFalse(pullTask.getTemplates().isEmpty());\n-\n-            // 3. exec the pull task\n-            ExecTO execution = execProvisioningTask(taskService, pullTask.getKey(), 50, false);\n-            assertEquals(PropagationTaskExecStatus.SUCCESS, PropagationTaskExecStatus.valueOf(execution.getStatus()));\n-\n-            // the user is successfully pulled...\n-            user = userService.read(\"pullFromLDAP\");\n-            assertNotNull(user);\n-            assertEquals(\"pullFromLDAP@syncope.apache.org\", user.getPlainAttr(\"email\").getValues().get(0));\n-\n-            group = groupService.read(\"testLDAPGroup\");\n-            assertNotNull(group);\n-\n-            ConnObjectTO connObject =\n-                    resourceService.readConnObject(RESOURCE_NAME_LDAP, AnyTypeKind.USER.name(), user.getKey());\n-            assertNotNull(connObject);\n-            assertEquals(\"pullFromLDAP@syncope.apache.org\", connObject.getAttr(\"mail\").getValues().get(0));\n-            AttrTO userDn = connObject.getAttr(Name.NAME);\n-            assertNotNull(userDn);\n-            assertEquals(1, userDn.getValues().size());\n-            assertNotNull(\n-                    getLdapRemoteObject(RESOURCE_LDAP_ADMIN_DN, RESOURCE_LDAP_ADMIN_PWD, userDn.getValues().get(0)));\n-\n-            // ...and propagated\n-            PagedResult<AbstractTaskTO> propagationTasks = taskService.list(new TaskQuery.Builder(TaskType.PROPAGATION).\n-                    resource(RESOURCE_NAME_DBPULL).\n-                    anyTypeKind(AnyTypeKind.USER).entityKey(user.getKey()).build());\n-            assertEquals(1, propagationTasks.getSize());\n-\n-            // 4. update the user on the external resource\n-            updateLdapRemoteObject(RESOURCE_LDAP_ADMIN_DN, RESOURCE_LDAP_ADMIN_PWD,\n-                    userDn.getValues().get(0), Pair.of(\"mail\", \"pullFromLDAP2@syncope.apache.org\"));\n-\n-            connObject = resourceService.readConnObject(RESOURCE_NAME_LDAP, AnyTypeKind.USER.name(), user.getKey());\n-            assertNotNull(connObject);\n-            assertEquals(\"pullFromLDAP2@syncope.apache.org\", connObject.getAttr(\"mail\").getValues().get(0));\n-\n-            // 5. exec the pull task again\n-            execution = execProvisioningTask(taskService, pullTask.getKey(), 50, false);\n-            assertEquals(PropagationTaskExecStatus.SUCCESS, PropagationTaskExecStatus.valueOf(execution.getStatus()));\n-\n-            // the internal is updated...\n-            user = userService.read(\"pullFromLDAP\");\n-            assertNotNull(user);\n-            assertEquals(\"pullFromLDAP2@syncope.apache.org\", user.getPlainAttr(\"email\").getValues().get(0));\n-\n-            // ...and propagated\n-            propagationTasks = taskService.list(new TaskQuery.Builder(TaskType.PROPAGATION).\n-                    resource(RESOURCE_NAME_DBPULL).\n-                    anyTypeKind(AnyTypeKind.USER).entityKey(user.getKey()).build());\n-            assertEquals(2, propagationTasks.getSize());\n-        } catch (Exception e) {\n-            LOG.error(\"Unexpected during issueSYNCOPE1062()\", e);\n-            fail(e.getMessage());\n-        } finally {\n-            if (pullTask != null) {\n-                taskService.delete(pullTask.getKey());\n-            }\n-\n-            if (propagationGroup != null) {\n-                groupService.delete(propagationGroup.getKey());\n-            }\n-\n-            if (group != null) {\n-                groupService.delete(group.getKey());\n-            }\n-            if (user != null) {\n-                userService.delete(user.getKey());\n-            }\n-        }\n-    }\n }"},{"sha":"59110f6f308f04b1bcc434f8c045aa030e1615b0","filename":"fit/core-reference/src/test/java/org/apache/syncope/fit/core/PullTaskIssuesITCase.java","status":"added","additions":550,"deletions":0,"changes":550,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/59d6d4a37b93757397f8e16da4bc2e7aa4fe3066/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FPullTaskIssuesITCase.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/59d6d4a37b93757397f8e16da4bc2e7aa4fe3066/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FPullTaskIssuesITCase.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FPullTaskIssuesITCase.java?ref=59d6d4a37b93757397f8e16da4bc2e7aa4fe3066","patch":"@@ -0,0 +1,550 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.fit.core;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import javax.sql.DataSource;\n+import javax.ws.rs.core.Response;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.apache.syncope.common.lib.SyncopeConstants;\n+import org.apache.syncope.common.lib.patch.PasswordPatch;\n+import org.apache.syncope.common.lib.patch.UserPatch;\n+import org.apache.syncope.common.lib.to.AbstractTaskTO;\n+import org.apache.syncope.common.lib.to.AttrTO;\n+import org.apache.syncope.common.lib.to.ConnInstanceTO;\n+import org.apache.syncope.common.lib.to.ConnObjectTO;\n+import org.apache.syncope.common.lib.to.MembershipTO;\n+import org.apache.syncope.common.lib.to.PagedResult;\n+import org.apache.syncope.common.lib.to.ResourceTO;\n+import org.apache.syncope.common.lib.to.GroupTO;\n+import org.apache.syncope.common.lib.policy.PullPolicyTO;\n+import org.apache.syncope.common.lib.to.ProvisioningResult;\n+import org.apache.syncope.common.lib.to.PullTaskTO;\n+import org.apache.syncope.common.lib.to.ExecTO;\n+import org.apache.syncope.common.lib.to.UserTO;\n+import org.apache.syncope.common.lib.types.AnyTypeKind;\n+import org.apache.syncope.common.lib.types.CipherAlgorithm;\n+import org.apache.syncope.common.lib.types.ConnConfProperty;\n+import org.apache.syncope.common.lib.types.PropagationTaskExecStatus;\n+import org.apache.syncope.common.lib.types.PullMode;\n+import org.apache.syncope.common.lib.types.TaskType;\n+import org.apache.syncope.common.rest.api.beans.TaskQuery;\n+import org.apache.syncope.common.rest.api.service.TaskService;\n+import org.apache.syncope.core.spring.security.Encryptor;\n+import org.apache.syncope.core.provisioning.java.pushpull.DBPasswordPullActions;\n+import org.apache.syncope.core.provisioning.java.pushpull.LDAPPasswordPullActions;\n+import org.apache.syncope.fit.core.reference.TestPullRule;\n+import org.identityconnectors.framework.common.objects.Name;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.jdbc.core.JdbcTemplate;\n+import org.springframework.test.context.ContextConfiguration;\n+import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n+\n+@RunWith(SpringJUnit4ClassRunner.class)\n+@ContextConfiguration(locations = { \"classpath:testJDBCEnv.xml\" })\n+public class PullTaskIssuesITCase extends AbstractTaskITCase {\n+\n+    @Autowired\n+    private DataSource testDataSource;\n+\n+    @Test\n+    public void issueSYNCOPE68() {\n+        //-----------------------------\n+        // Create a new user ... it should be updated applying pull policy\n+        //-----------------------------\n+        UserTO userTO = new UserTO();\n+        userTO.setRealm(SyncopeConstants.ROOT_REALM);\n+        userTO.setPassword(\"password123\");\n+        userTO.setUsername(\"testuser2\");\n+\n+        userTO.getPlainAttrs().add(attrTO(\"firstname\", \"testuser2\"));\n+        userTO.getPlainAttrs().add(attrTO(\"surname\", \"testuser2\"));\n+        userTO.getPlainAttrs().add(attrTO(\"ctype\", \"a type\"));\n+        userTO.getPlainAttrs().add(attrTO(\"fullname\", \"a type\"));\n+        userTO.getPlainAttrs().add(attrTO(\"userId\", \"testuser2@syncope.apache.org\"));\n+        userTO.getPlainAttrs().add(attrTO(\"email\", \"testuser2@syncope.apache.org\"));\n+\n+        userTO.getResources().add(RESOURCE_NAME_NOPROPAGATION2);\n+        userTO.getResources().add(RESOURCE_NAME_NOPROPAGATION4);\n+\n+        userTO.getMemberships().add(\n+                new MembershipTO.Builder().group(\"bf825fe1-7320-4a54-bd64-143b5c18ab97\").build());\n+\n+        userTO = createUser(userTO).getEntity();\n+        assertNotNull(userTO);\n+        assertEquals(\"testuser2\", userTO.getUsername());\n+        assertEquals(1, userTO.getMemberships().size());\n+        assertEquals(3, userTO.getResources().size());\n+        //-----------------------------\n+\n+        try {\n+            //-----------------------------\n+            //  add user template\n+            //-----------------------------\n+            UserTO template = new UserTO();\n+\n+            template.getMemberships().add(\n+                    new MembershipTO.Builder().group(\"b8d38784-57e7-4595-859a-076222644b55\").build());\n+\n+            template.getResources().add(RESOURCE_NAME_NOPROPAGATION4);\n+            //-----------------------------\n+\n+            // Update pull task\n+            PullTaskTO task = taskService.read(\"81d88f73-d474-4450-9031-605daa4e313f\", true);\n+            assertNotNull(task);\n+\n+            task.getTemplates().put(AnyTypeKind.USER.name(), template);\n+\n+            taskService.update(task);\n+            PullTaskTO actual = taskService.read(task.getKey(), true);\n+            assertNotNull(actual);\n+            assertEquals(task.getKey(), actual.getKey());\n+            assertFalse(actual.getTemplates().get(AnyTypeKind.USER.name()).getResources().isEmpty());\n+            assertFalse(((UserTO) actual.getTemplates().get(AnyTypeKind.USER.name())).getMemberships().isEmpty());\n+\n+            ExecTO execution = execProvisioningTask(taskService, actual.getKey(), 50, false);\n+            assertEquals(PropagationTaskExecStatus.SUCCESS, PropagationTaskExecStatus.valueOf(execution.getStatus()));\n+\n+            userTO = userService.read(\"testuser2\");\n+            assertNotNull(userTO);\n+            assertEquals(\"testuser2@syncope.apache.org\", userTO.getPlainAttr(\"userId\").getValues().get(0));\n+            assertEquals(2, userTO.getMemberships().size());\n+            assertEquals(4, userTO.getResources().size());\n+        } finally {\n+            UserTO dUserTO = deleteUser(userTO.getKey()).getEntity();\n+            assertNotNull(dUserTO);\n+        }\n+    }\n+\n+    @Test\n+    public void issueSYNCOPE230() {\n+        JdbcTemplate jdbcTemplate = new JdbcTemplate(testDataSource);\n+\n+        // 1. populate the external table\n+        jdbcTemplate.execute(\"INSERT INTO testpull VALUES\"\n+                + \"('a54b3794-b231-47be-b24a-11e1a42949f6', 'issuesyncope230', 'Surname', 'syncope230@syncope.apache.org', NULL)\");\n+\n+        // 2. execute PullTask for resource-db-pull (table TESTPULL on external H2)\n+        execProvisioningTask(taskService, \"7c2242f4-14af-4ab5-af31-cdae23783655\", 50, false);\n+\n+        // 3. read e-mail address for user created by the PullTask first execution\n+        UserTO userTO = userService.read(\"issuesyncope230\");\n+        assertNotNull(userTO);\n+        String email = userTO.getPlainAttr(\"email\").getValues().iterator().next();\n+        assertNotNull(email);\n+\n+        // 4. update TESTPULL on external H2 by changing e-mail address\n+        jdbcTemplate.execute(\"UPDATE TESTPULL SET email='updatedSYNCOPE230@syncope.apache.org'\");\n+\n+        // 5. re-execute the PullTask\n+        execProvisioningTask(taskService, \"7c2242f4-14af-4ab5-af31-cdae23783655\", 50, false);\n+\n+        // 6. verify that the e-mail was updated\n+        userTO = userService.read(\"issuesyncope230\");\n+        assertNotNull(userTO);\n+        email = userTO.getPlainAttr(\"email\").getValues().iterator().next();\n+        assertNotNull(email);\n+        assertEquals(\"updatedSYNCOPE230@syncope.apache.org\", email);\n+    }\n+\n+    @Test\n+    public void issueSYNCOPE258() {\n+        // -----------------------------\n+        // Add a custom correlation rule\n+        // -----------------------------\n+        PullPolicyTO policyTO = policyService.read(\"9454b0d7-2610-400a-be82-fc23cf553dd6\");\n+        policyTO.getSpecification().getCorrelationRules().put(AnyTypeKind.USER.name(), TestPullRule.class.getName());\n+        policyService.update(policyTO);\n+        // -----------------------------\n+\n+        PullTaskTO task = new PullTaskTO();\n+        task.setDestinationRealm(SyncopeConstants.ROOT_REALM);\n+        task.setName(\"Test Pull Rule\");\n+        task.setActive(true);\n+        task.setResource(RESOURCE_NAME_WS2);\n+        task.setPullMode(PullMode.FULL_RECONCILIATION);\n+        task.setPerformCreate(true);\n+        task.setPerformDelete(true);\n+        task.setPerformUpdate(true);\n+\n+        Response response = taskService.create(task);\n+        task = getObject(response.getLocation(), TaskService.class, PullTaskTO.class);\n+\n+        UserTO userTO = UserITCase.getUniqueSampleTO(\"s258_1@apache.org\");\n+        userTO.getResources().clear();\n+        userTO.getResources().add(RESOURCE_NAME_WS2);\n+\n+        createUser(userTO);\n+\n+        userTO = UserITCase.getUniqueSampleTO(\"s258_2@apache.org\");\n+        userTO.getResources().clear();\n+        userTO.getResources().add(RESOURCE_NAME_WS2);\n+\n+        userTO = createUser(userTO).getEntity();\n+\n+        // change email in order to unmatch the second user\n+        UserPatch userPatch = new UserPatch();\n+        userPatch.setKey(userTO.getKey());\n+        userPatch.getPlainAttrs().add(attrAddReplacePatch(\"email\", \"s258@apache.org\"));\n+\n+        userService.update(userPatch);\n+\n+        execProvisioningTask(taskService, task.getKey(), 50, false);\n+\n+        PullTaskTO executed = taskService.read(task.getKey(), true);\n+        assertEquals(1, executed.getExecutions().size());\n+\n+        // asser for just one match\n+        assertTrue(executed.getExecutions().get(0).getMessage().substring(0, 55) + \"...\",\n+                executed.getExecutions().get(0).getMessage().contains(\"[updated/failures]: 1/0\"));\n+    }\n+\n+    @Test\n+    public void issueSYNCOPE272() {\n+        removeTestUsers();\n+\n+        // create user with testdb resource\n+        UserTO userTO = UserITCase.getUniqueSampleTO(\"syncope272@syncope.apache.org\");\n+        userTO.getResources().add(RESOURCE_NAME_TESTDB);\n+\n+        ProvisioningResult<UserTO> result = createUser(userTO);\n+        userTO = result.getEntity();\n+        try {\n+            assertNotNull(userTO);\n+            assertEquals(1, result.getPropagationStatuses().size());\n+            assertEquals(PropagationTaskExecStatus.SUCCESS, result.getPropagationStatuses().get(0).getStatus());\n+\n+            ExecTO taskExecTO = execProvisioningTask(\n+                    taskService, \"986867e2-993b-430e-8feb-aa9abb4c1dcd\", 50, false);\n+\n+            assertNotNull(taskExecTO.getStatus());\n+            assertEquals(PropagationTaskExecStatus.SUCCESS, PropagationTaskExecStatus.valueOf(taskExecTO.getStatus()));\n+\n+            userTO = userService.read(userTO.getKey());\n+            assertNotNull(userTO);\n+            assertNotNull(userTO.getPlainAttr(\"firstname\").getValues().get(0));\n+        } finally {\n+            removeTestUsers();\n+        }\n+    }\n+\n+    @Test\n+    public void issueSYNCOPE307() {\n+        UserTO userTO = UserITCase.getUniqueSampleTO(\"s307@apache.org\");\n+        userTO.setUsername(\"test0\");\n+        userTO.getPlainAttr(\"firstname\").getValues().clear();\n+        userTO.getPlainAttr(\"firstname\").getValues().add(\"nome0\");\n+        userTO.getAuxClasses().add(\"csv\");\n+\n+        AttrTO csvuserid = new AttrTO();\n+        csvuserid.setSchema(\"csvuserid\");\n+        userTO.getDerAttrs().add(csvuserid);\n+\n+        userTO.getResources().clear();\n+        userTO.getResources().add(RESOURCE_NAME_WS2);\n+\n+        userTO = createUser(userTO).getEntity();\n+        assertNotNull(userTO);\n+\n+        userTO = userService.read(userTO.getKey());\n+        assertTrue(userTO.getVirAttrs().isEmpty());\n+\n+        // Update pull task\n+        PullTaskTO task = taskService.read(\"38abbf9e-a1a3-40a1-a15f-7d0ac02f47f1\", true);\n+        assertNotNull(task);\n+\n+        UserTO template = new UserTO();\n+        template.setPassword(\"'password123'\");\n+        template.getResources().add(RESOURCE_NAME_DBVIRATTR);\n+        template.getVirAttrs().add(attrTO(\"virtualdata\", \"'virtualvalue'\"));\n+\n+        task.getTemplates().put(AnyTypeKind.USER.name(), template);\n+\n+        taskService.update(task);\n+\n+        // exec task: one user from CSV will match the user created above and template will be applied\n+        execProvisioningTask(taskService, task.getKey(), 50, false);\n+\n+        // check that template was successfully applied...\n+        userTO = userService.read(userTO.getKey());\n+        assertEquals(\"virtualvalue\", userTO.getVirAttr(\"virtualdata\").getValues().get(0));\n+\n+        // ...and that propagation to db succeeded\n+        JdbcTemplate jdbcTemplate = new JdbcTemplate(testDataSource);\n+        String value = queryForObject(\n+                jdbcTemplate, 50, \"SELECT USERNAME FROM testpull WHERE ID=?\", String.class, userTO.getKey());\n+        assertEquals(\"virtualvalue\", value);\n+    }\n+\n+    @Test\n+    public void issueSYNCOPE313DB() throws Exception {\n+        // 1. create user in DB\n+        UserTO user = UserITCase.getUniqueSampleTO(\"syncope313-db@syncope.apache.org\");\n+        user.setPassword(\"security123\");\n+        user.getResources().add(RESOURCE_NAME_TESTDB);\n+        user = createUser(user).getEntity();\n+        assertNotNull(user);\n+        assertFalse(user.getResources().isEmpty());\n+\n+        // 2. Check that the DB resource has the correct password\n+        JdbcTemplate jdbcTemplate = new JdbcTemplate(testDataSource);\n+        String value = queryForObject(\n+                jdbcTemplate, 50, \"SELECT PASSWORD FROM test WHERE ID=?\", String.class, user.getUsername());\n+        assertEquals(Encryptor.getInstance().encode(\"security123\", CipherAlgorithm.SHA1), value.toUpperCase());\n+\n+        // 3. Update the password in the DB\n+        String newCleanPassword = \"new-security\";\n+        String newPassword = Encryptor.getInstance().encode(newCleanPassword, CipherAlgorithm.SHA1);\n+        jdbcTemplate.execute(\"UPDATE test set PASSWORD='\" + newPassword + \"' where ID='\" + user.getUsername() + \"'\");\n+\n+        // 4. Pull the user from the resource\n+        PullTaskTO pullTask = new PullTaskTO();\n+        pullTask.setDestinationRealm(SyncopeConstants.ROOT_REALM);\n+        pullTask.setName(\"DB Pull Task\");\n+        pullTask.setActive(true);\n+        pullTask.setPerformCreate(true);\n+        pullTask.setPerformUpdate(true);\n+        pullTask.setPullMode(PullMode.FULL_RECONCILIATION);\n+        pullTask.setResource(RESOURCE_NAME_TESTDB);\n+        pullTask.getActionsClassNames().add(DBPasswordPullActions.class.getName());\n+        Response taskResponse = taskService.create(pullTask);\n+\n+        PullTaskTO actual = getObject(taskResponse.getLocation(), TaskService.class, PullTaskTO.class);\n+        assertNotNull(actual);\n+\n+        pullTask = taskService.read(actual.getKey(), true);\n+        assertNotNull(pullTask);\n+        assertEquals(actual.getKey(), pullTask.getKey());\n+        assertEquals(actual.getJobDelegateClassName(), pullTask.getJobDelegateClassName());\n+\n+        ExecTO execution = execProvisioningTask(taskService, pullTask.getKey(), 50, false);\n+        assertEquals(PropagationTaskExecStatus.SUCCESS, PropagationTaskExecStatus.valueOf(execution.getStatus()));\n+\n+        // 5. Test the pulled user\n+        Pair<Map<String, Set<String>>, UserTO> self = clientFactory.create(user.getUsername(), newCleanPassword).self();\n+        assertNotNull(self);\n+\n+        // 6. Delete PullTask + user\n+        taskService.delete(pullTask.getKey());\n+        deleteUser(user.getKey());\n+    }\n+\n+    @Test\n+    public void issueSYNCOPE313LDAP() throws Exception {\n+        // First of all, clear any potential conflict with existing user / group\n+        ldapCleanup();\n+\n+        UserTO user = null;\n+        PullTaskTO pullTask = null;\n+        ConnInstanceTO resourceConnector = null;\n+        ConnConfProperty property = null;\n+        try {\n+            // 1. create user in LDAP\n+            String oldCleanPassword = \"security123\";\n+            user = UserITCase.getUniqueSampleTO(\"syncope313-ldap@syncope.apache.org\");\n+            user.setPassword(oldCleanPassword);\n+            user.getResources().add(RESOURCE_NAME_LDAP);\n+            user = createUser(user).getEntity();\n+            assertNotNull(user);\n+            assertFalse(user.getResources().isEmpty());\n+\n+            // 2. request to change password only on Syncope and not on LDAP\n+            String newCleanPassword = \"new-security123\";\n+            UserPatch userPatch = new UserPatch();\n+            userPatch.setKey(user.getKey());\n+            userPatch.setPassword(new PasswordPatch.Builder().value(newCleanPassword).build());\n+            user = updateUser(userPatch).getEntity();\n+\n+            // 3. Check that the Syncope user now has the changed password\n+            Pair<Map<String, Set<String>>, UserTO> self =\n+                    clientFactory.create(user.getUsername(), newCleanPassword).self();\n+            assertNotNull(self);\n+\n+            // 4. Check that the LDAP resource has the old password\n+            ConnObjectTO connObject =\n+                    resourceService.readConnObject(RESOURCE_NAME_LDAP, AnyTypeKind.USER.name(), user.getKey());\n+            assertNotNull(getLdapRemoteObject(\n+                    connObject.getAttr(Name.NAME).getValues().get(0),\n+                    oldCleanPassword,\n+                    connObject.getAttr(Name.NAME).getValues().get(0)));\n+\n+            // 5. Update the LDAP Connector to retrieve passwords\n+            ResourceTO ldapResource = resourceService.read(RESOURCE_NAME_LDAP);\n+            resourceConnector = connectorService.read(\n+                    ldapResource.getConnector(), Locale.ENGLISH.getLanguage());\n+            property = resourceConnector.getConfMap().get(\"retrievePasswordsWithSearch\");\n+            property.getValues().clear();\n+            property.getValues().add(Boolean.TRUE);\n+            connectorService.update(resourceConnector);\n+\n+            // 6. Pull the user from the resource\n+            pullTask = new PullTaskTO();\n+            pullTask.setDestinationRealm(SyncopeConstants.ROOT_REALM);\n+            pullTask.setName(\"LDAP Pull Task\");\n+            pullTask.setActive(true);\n+            pullTask.setPerformCreate(true);\n+            pullTask.setPerformUpdate(true);\n+            pullTask.setPullMode(PullMode.FULL_RECONCILIATION);\n+            pullTask.setResource(RESOURCE_NAME_LDAP);\n+            pullTask.getActionsClassNames().add(LDAPPasswordPullActions.class.getName());\n+            Response taskResponse = taskService.create(pullTask);\n+\n+            pullTask = getObject(taskResponse.getLocation(), TaskService.class, PullTaskTO.class);\n+            assertNotNull(pullTask);\n+\n+            ExecTO execution = execProvisioningTask(taskService, pullTask.getKey(), 50, false);\n+            assertEquals(PropagationTaskExecStatus.SUCCESS, PropagationTaskExecStatus.valueOf(execution.getStatus()));\n+\n+            // 7. Test the pulled user\n+            self = clientFactory.create(user.getUsername(), oldCleanPassword).self();\n+            assertNotNull(self);\n+        } catch (Exception e) {\n+            fail(e.getMessage());\n+        } finally {\n+            // Delete PullTask + user + reset the connector\n+            if (pullTask != null) {\n+                taskService.delete(pullTask.getKey());\n+            }\n+\n+            if (resourceConnector != null && property != null) {\n+                property.getValues().clear();\n+                property.getValues().add(Boolean.FALSE);\n+                connectorService.update(resourceConnector);\n+            }\n+\n+            if (user != null) {\n+                deleteUser(user.getKey());\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void issueSYNCOPE1062() {\n+        GroupTO propagationGroup = null;\n+        PullTaskTO pullTask = null;\n+        UserTO user = null;\n+        GroupTO group = null;\n+        try {\n+            // 1. create group with resource for propagation\n+            propagationGroup = GroupITCase.getBasicSampleTO(\"SYNCOPE1062\");\n+            propagationGroup.getResources().add(RESOURCE_NAME_DBPULL);\n+            propagationGroup = createGroup(propagationGroup).getEntity();\n+\n+            // 2. create pull task for another resource, with user template assigning the group above\n+            pullTask = new PullTaskTO();\n+            pullTask.setDestinationRealm(SyncopeConstants.ROOT_REALM);\n+            pullTask.setName(\"SYNCOPE1062\");\n+            pullTask.setActive(true);\n+            pullTask.setPerformCreate(true);\n+            pullTask.setPerformUpdate(true);\n+            pullTask.setPullMode(PullMode.FULL_RECONCILIATION);\n+            pullTask.setResource(RESOURCE_NAME_LDAP);\n+\n+            UserTO template = new UserTO();\n+            template.getAuxClasses().add(\"minimal group\");\n+            template.getMemberships().add(new MembershipTO.Builder().group(propagationGroup.getKey()).build());\n+            template.getPlainAttrs().add(attrTO(\"firstname\", \"'fixed'\"));\n+            pullTask.getTemplates().put(AnyTypeKind.USER.name(), template);\n+\n+            Response taskResponse = taskService.create(pullTask);\n+            pullTask = getObject(taskResponse.getLocation(), TaskService.class, PullTaskTO.class);\n+            assertNotNull(pullTask);\n+            assertFalse(pullTask.getTemplates().isEmpty());\n+\n+            // 3. exec the pull task\n+            ExecTO execution = execProvisioningTask(taskService, pullTask.getKey(), 50, false);\n+            assertEquals(PropagationTaskExecStatus.SUCCESS, PropagationTaskExecStatus.valueOf(execution.getStatus()));\n+\n+            // the user is successfully pulled...\n+            user = userService.read(\"pullFromLDAP\");\n+            assertNotNull(user);\n+            assertEquals(\"pullFromLDAP@syncope.apache.org\", user.getPlainAttr(\"email\").getValues().get(0));\n+\n+            group = groupService.read(\"testLDAPGroup\");\n+            assertNotNull(group);\n+\n+            ConnObjectTO connObject =\n+                    resourceService.readConnObject(RESOURCE_NAME_LDAP, AnyTypeKind.USER.name(), user.getKey());\n+            assertNotNull(connObject);\n+            assertEquals(\"pullFromLDAP@syncope.apache.org\", connObject.getAttr(\"mail\").getValues().get(0));\n+            AttrTO userDn = connObject.getAttr(Name.NAME);\n+            assertNotNull(userDn);\n+            assertEquals(1, userDn.getValues().size());\n+            assertNotNull(\n+                    getLdapRemoteObject(RESOURCE_LDAP_ADMIN_DN, RESOURCE_LDAP_ADMIN_PWD, userDn.getValues().get(0)));\n+\n+            // ...and propagated\n+            PagedResult<AbstractTaskTO> propagationTasks = taskService.list(new TaskQuery.Builder(TaskType.PROPAGATION).\n+                    resource(RESOURCE_NAME_DBPULL).\n+                    anyTypeKind(AnyTypeKind.USER).entityKey(user.getKey()).build());\n+            assertEquals(1, propagationTasks.getSize());\n+\n+            // 4. update the user on the external resource\n+            updateLdapRemoteObject(RESOURCE_LDAP_ADMIN_DN, RESOURCE_LDAP_ADMIN_PWD,\n+                    userDn.getValues().get(0), Pair.of(\"mail\", \"pullFromLDAP2@syncope.apache.org\"));\n+\n+            connObject = resourceService.readConnObject(RESOURCE_NAME_LDAP, AnyTypeKind.USER.name(), user.getKey());\n+            assertNotNull(connObject);\n+            assertEquals(\"pullFromLDAP2@syncope.apache.org\", connObject.getAttr(\"mail\").getValues().get(0));\n+\n+            // 5. exec the pull task again\n+            execution = execProvisioningTask(taskService, pullTask.getKey(), 50, false);\n+            assertEquals(PropagationTaskExecStatus.SUCCESS, PropagationTaskExecStatus.valueOf(execution.getStatus()));\n+\n+            // the internal is updated...\n+            user = userService.read(\"pullFromLDAP\");\n+            assertNotNull(user);\n+            assertEquals(\"pullFromLDAP2@syncope.apache.org\", user.getPlainAttr(\"email\").getValues().get(0));\n+\n+            // ...and propagated\n+            propagationTasks = taskService.list(new TaskQuery.Builder(TaskType.PROPAGATION).\n+                    resource(RESOURCE_NAME_DBPULL).\n+                    anyTypeKind(AnyTypeKind.USER).entityKey(user.getKey()).build());\n+            assertEquals(2, propagationTasks.getSize());\n+        } catch (Exception e) {\n+            LOG.error(\"Unexpected during issueSYNCOPE1062()\", e);\n+            fail(e.getMessage());\n+        } finally {\n+            if (pullTask != null) {\n+                taskService.delete(pullTask.getKey());\n+            }\n+\n+            if (propagationGroup != null) {\n+                groupService.delete(propagationGroup.getKey());\n+            }\n+\n+            if (group != null) {\n+                groupService.delete(group.getKey());\n+            }\n+            if (user != null) {\n+                userService.delete(user.getKey());\n+            }\n+        }\n+    }\n+}"},{"sha":"abd746c9ec31cf5760c84b5b2a3633daa920c667","filename":"fit/core-reference/src/test/java/org/apache/syncope/fit/core/ReportITCase.java","status":"modified","additions":0,"deletions":64,"changes":64,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/59d6d4a37b93757397f8e16da4bc2e7aa4fe3066/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FReportITCase.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/59d6d4a37b93757397f8e16da4bc2e7aa4fe3066/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FReportITCase.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FReportITCase.java?ref=59d6d4a37b93757397f8e16da4bc2e7aa4fe3066","patch":"@@ -49,18 +49,11 @@\n import org.apache.syncope.common.lib.types.ReportExecStatus;\n import org.apache.syncope.common.rest.api.beans.BulkExecDeleteQuery;\n import org.apache.syncope.common.rest.api.beans.ExecuteQuery;\n-import org.apache.syncope.common.rest.api.service.ReportService;\n import org.apache.syncope.fit.AbstractITCase;\n import org.junit.Test;\n \n public class ReportITCase extends AbstractITCase {\n \n-    private ReportTO createReport(final ReportTO report) {\n-        Response response = reportService.create(report);\n-        assertEquals(Response.Status.CREATED.getStatusCode(), response.getStatusInfo().getStatusCode());\n-        return getObject(response.getLocation(), ReportService.class, ReportTO.class);\n-    }\n-\n     @Test\n     public void getReportletConfs() {\n         Set<String> reportletConfs = syncopeService.platform().getReportletConfs();\n@@ -282,61 +275,4 @@ public void auditReport() throws IOException {\n             loggerService.delete(LoggerType.AUDIT, auditLoggerName.toLoggerName());\n         }\n     }\n-\n-    @Test\n-    public void issueSYNCOPE43() {\n-        ReportTO reportTO = new ReportTO();\n-        reportTO.setName(\"issueSYNCOPE43\" + getUUIDString());\n-        reportTO.setActive(true);\n-        reportTO.setTemplate(\"sample\");\n-        reportTO = createReport(reportTO);\n-        assertNotNull(reportTO);\n-\n-        ExecTO execution = reportService.execute(new ExecuteQuery.Builder().key(reportTO.getKey()).build());\n-        assertNotNull(execution);\n-\n-        int maxit = 50;\n-        do {\n-            try {\n-                Thread.sleep(1000);\n-            } catch (InterruptedException e) {\n-            }\n-\n-            reportTO = reportService.read(reportTO.getKey());\n-\n-            maxit--;\n-        } while (reportTO.getExecutions().isEmpty() && maxit > 0);\n-\n-        assertEquals(1, reportTO.getExecutions().size());\n-    }\n-\n-    @Test\n-    public void issueSYNCOPE102() throws IOException {\n-        // Create\n-        ReportTO reportTO = reportService.read(\"0062ea9c-924d-4ecf-9961-4492a8cc6d1b\");\n-        reportTO.setKey(null);\n-        reportTO.setName(\"issueSYNCOPE102\" + getUUIDString());\n-        reportTO = createReport(reportTO);\n-        assertNotNull(reportTO);\n-\n-        // Execute (multiple requests)\n-        for (int i = 0; i < 10; i++) {\n-            ExecTO execution = reportService.execute(new ExecuteQuery.Builder().key(reportTO.getKey()).build());\n-            assertNotNull(execution);\n-        }\n-\n-        // Wait for one execution\n-        int maxit = 50;\n-        do {\n-            try {\n-                Thread.sleep(1000);\n-            } catch (InterruptedException e) {\n-            }\n-\n-            reportTO = reportService.read(reportTO.getKey());\n-\n-            maxit--;\n-        } while (reportTO.getExecutions().isEmpty() && maxit > 0);\n-        assertFalse(reportTO.getExecutions().isEmpty());\n-    }\n }"},{"sha":"fb0d84595883c9c6649c3c292aabc887f4768fb3","filename":"fit/core-reference/src/test/java/org/apache/syncope/fit/core/ReportIssuesITCase.java","status":"added","additions":90,"deletions":0,"changes":90,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/59d6d4a37b93757397f8e16da4bc2e7aa4fe3066/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FReportIssuesITCase.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/59d6d4a37b93757397f8e16da4bc2e7aa4fe3066/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FReportIssuesITCase.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FReportIssuesITCase.java?ref=59d6d4a37b93757397f8e16da4bc2e7aa4fe3066","patch":"@@ -0,0 +1,90 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.fit.core;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+\n+import java.io.IOException;\n+import org.apache.syncope.common.lib.to.ExecTO;\n+import org.apache.syncope.common.lib.to.ReportTO;\n+import org.apache.syncope.common.rest.api.beans.ExecuteQuery;\n+import org.apache.syncope.fit.AbstractITCase;\n+import org.junit.Test;\n+\n+public class ReportIssuesITCase extends AbstractITCase {\n+\n+    @Test\n+    public void issueSYNCOPE43() {\n+        ReportTO reportTO = new ReportTO();\n+        reportTO.setName(\"issueSYNCOPE43\" + getUUIDString());\n+        reportTO.setActive(true);\n+        reportTO.setTemplate(\"sample\");\n+        reportTO = createReport(reportTO);\n+        assertNotNull(reportTO);\n+\n+        ExecTO execution = reportService.execute(new ExecuteQuery.Builder().key(reportTO.getKey()).build());\n+        assertNotNull(execution);\n+\n+        int maxit = 50;\n+        do {\n+            try {\n+                Thread.sleep(1000);\n+            } catch (InterruptedException e) {\n+            }\n+\n+            reportTO = reportService.read(reportTO.getKey());\n+\n+            maxit--;\n+        } while (reportTO.getExecutions().isEmpty() && maxit > 0);\n+\n+        assertEquals(1, reportTO.getExecutions().size());\n+    }\n+\n+    @Test\n+    public void issueSYNCOPE102() throws IOException {\n+        // Create\n+        ReportTO reportTO = reportService.read(\"0062ea9c-924d-4ecf-9961-4492a8cc6d1b\");\n+        reportTO.setKey(null);\n+        reportTO.setName(\"issueSYNCOPE102\" + getUUIDString());\n+        reportTO = createReport(reportTO);\n+        assertNotNull(reportTO);\n+\n+        // Execute (multiple requests)\n+        for (int i = 0; i < 10; i++) {\n+            ExecTO execution = reportService.execute(new ExecuteQuery.Builder().key(reportTO.getKey()).build());\n+            assertNotNull(execution);\n+        }\n+\n+        // Wait for one execution\n+        int maxit = 50;\n+        do {\n+            try {\n+                Thread.sleep(1000);\n+            } catch (InterruptedException e) {\n+            }\n+\n+            reportTO = reportService.read(reportTO.getKey());\n+\n+            maxit--;\n+        } while (reportTO.getExecutions().isEmpty() && maxit > 0);\n+        assertFalse(reportTO.getExecutions().isEmpty());\n+    }\n+}"}]}