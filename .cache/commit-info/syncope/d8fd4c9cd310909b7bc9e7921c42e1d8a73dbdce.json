{"sha":"d8fd4c9cd310909b7bc9e7921c42e1d8a73dbdce","node_id":"MDY6Q29tbWl0NjM2ODc5MDYyOmQ4ZmQ0YzljZDMxMDkwOWI3YmM5ZTc5MjFjNDJlMWQ4YTczZGJkY2U=","commit":{"author":{"name":"Francesco Chicchiriccò","email":"ilgrosso@apache.org","date":"2019-07-03T08:48:56Z"},"committer":{"name":"Francesco Chicchiriccò","email":"ilgrosso@apache.org","date":"2019-07-03T08:48:56Z"},"message":"Fixing tests after last Spring Cloud Gateway version upgrade","tree":{"sha":"a399f3fb937cc83a5674c61a0ab1df1c866e93ce","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/git/trees/a399f3fb937cc83a5674c61a0ab1df1c866e93ce"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/git/commits/d8fd4c9cd310909b7bc9e7921c42e1d8a73dbdce","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/d8fd4c9cd310909b7bc9e7921c42e1d8a73dbdce","html_url":"https://github.com/EnricoDAlessandro97UNI/syncope/commit/d8fd4c9cd310909b7bc9e7921c42e1d8a73dbdce","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/d8fd4c9cd310909b7bc9e7921c42e1d8a73dbdce/comments","author":{"login":"ilgrosso","id":1064664,"node_id":"MDQ6VXNlcjEwNjQ2NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/1064664?v=4","gravatar_id":"","url":"https://api.github.com/users/ilgrosso","html_url":"https://github.com/ilgrosso","followers_url":"https://api.github.com/users/ilgrosso/followers","following_url":"https://api.github.com/users/ilgrosso/following{/other_user}","gists_url":"https://api.github.com/users/ilgrosso/gists{/gist_id}","starred_url":"https://api.github.com/users/ilgrosso/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ilgrosso/subscriptions","organizations_url":"https://api.github.com/users/ilgrosso/orgs","repos_url":"https://api.github.com/users/ilgrosso/repos","events_url":"https://api.github.com/users/ilgrosso/events{/privacy}","received_events_url":"https://api.github.com/users/ilgrosso/received_events","type":"User","site_admin":false},"committer":{"login":"ilgrosso","id":1064664,"node_id":"MDQ6VXNlcjEwNjQ2NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/1064664?v=4","gravatar_id":"","url":"https://api.github.com/users/ilgrosso","html_url":"https://github.com/ilgrosso","followers_url":"https://api.github.com/users/ilgrosso/followers","following_url":"https://api.github.com/users/ilgrosso/following{/other_user}","gists_url":"https://api.github.com/users/ilgrosso/gists{/gist_id}","starred_url":"https://api.github.com/users/ilgrosso/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ilgrosso/subscriptions","organizations_url":"https://api.github.com/users/ilgrosso/orgs","repos_url":"https://api.github.com/users/ilgrosso/repos","events_url":"https://api.github.com/users/ilgrosso/events{/privacy}","received_events_url":"https://api.github.com/users/ilgrosso/received_events","type":"User","site_admin":false},"parents":[{"sha":"4eccdae867a056514ddcc3e8c57668f537fcdb86","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/4eccdae867a056514ddcc3e8c57668f537fcdb86","html_url":"https://github.com/EnricoDAlessandro97UNI/syncope/commit/4eccdae867a056514ddcc3e8c57668f537fcdb86"}],"stats":{"total":193,"additions":62,"deletions":131},"files":[{"sha":"635242521f72c877547a6f9d52cf1718361bfa15","filename":"sra/src/test/java/org/apache/syncope/sra/BodyPropertyAddingGatewayFilterFactory.java","status":"modified","additions":54,"deletions":100,"changes":154,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/d8fd4c9cd310909b7bc9e7921c42e1d8a73dbdce/sra%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fsra%2FBodyPropertyAddingGatewayFilterFactory.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/d8fd4c9cd310909b7bc9e7921c42e1d8a73dbdce/sra%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fsra%2FBodyPropertyAddingGatewayFilterFactory.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/sra%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fsra%2FBodyPropertyAddingGatewayFilterFactory.java?ref=d8fd4c9cd310909b7bc9e7921c42e1d8a73dbdce","patch":"@@ -37,13 +37,8 @@\n import org.springframework.core.Ordered;\n import org.springframework.core.io.buffer.DataBuffer;\n import org.springframework.core.io.buffer.DataBufferFactory;\n-import org.springframework.http.HttpHeaders;\n-import org.springframework.http.HttpStatus;\n-import org.springframework.http.ResponseCookie;\n-import org.springframework.http.client.reactive.ClientHttpResponse;\n import org.springframework.http.server.reactive.ServerHttpResponse;\n import org.springframework.http.server.reactive.ServerHttpResponseDecorator;\n-import org.springframework.util.MultiValueMap;\n import org.springframework.web.server.ServerWebExchange;\n import reactor.core.publisher.Flux;\n import reactor.core.publisher.Mono;\n@@ -81,121 +76,80 @@ public ModifyResponseGatewayFilter(final Config config) {\n \n         @Override\n         public Mono<Void> filter(final ServerWebExchange exchange, final GatewayFilterChain chain) {\n+            return chain.filter(exchange.mutate().response(decorate(exchange)).build());\n+        }\n+\n+        private ServerHttpResponse decorate(final ServerWebExchange exchange) {\n             ServerHttpResponse originalResponse = exchange.getResponse();\n \n             DataBufferFactory bufferFactory = originalResponse.bufferFactory();\n-            ServerHttpResponseDecorator responseDecorator = new ServerHttpResponseDecorator(originalResponse) {\n+            return new ServerHttpResponseDecorator(originalResponse) {\n \n                 @Override\n                 public Mono<Void> writeWith(Publisher<? extends DataBuffer> body) {\n-                    if (body instanceof Flux) {\n-                        Flux<? extends DataBuffer> flux = (Flux<? extends DataBuffer>) body;\n-\n-                        return super.writeWith(flux.buffer().map(dataBuffers -> {\n-                            ByteArrayOutputStream payload = new ByteArrayOutputStream();\n-                            dataBuffers.forEach(buffer -> {\n-                                byte[] array = new byte[buffer.readableByteCount()];\n-                                buffer.read(array);\n-                                try {\n-                                    payload.write(array);\n-                                } catch (IOException e) {\n-                                    LOG.error(\"While reading original body content\", e);\n-                                }\n-                            });\n-\n-                            byte[] input = payload.toByteArray();\n-\n-                            InputStream is = null;\n-                            boolean compressed = false;\n-                            byte[] output;\n+                    return super.writeWith(Flux.from(body).buffer().map(dataBuffers -> {\n+                        ByteArrayOutputStream payload = new ByteArrayOutputStream();\n+                        dataBuffers.forEach(buffer -> {\n+                            byte[] array = new byte[buffer.readableByteCount()];\n+                            buffer.read(array);\n                             try {\n-                                if (isCompressed(input)) {\n-                                    compressed = true;\n-                                    is = new GZIPInputStream(new ByteArrayInputStream(input));\n-                                } else {\n-                                    is = new ByteArrayInputStream(input);\n-                                }\n-\n-                                ObjectNode content = (ObjectNode) MAPPER.readTree(is);\n-                                String[] kv = config.getData().split(\"=\");\n-                                content.put(kv[0], kv[1]);\n-\n-                                output = MAPPER.writeValueAsBytes(content);\n+                                payload.write(array);\n                             } catch (IOException e) {\n-                                LOG.error(\"While (de)serializing as JSON\", e);\n-                                output = ArrayUtils.clone(input);\n-                            } finally {\n-                                IOUtils.closeStream(is);\n+                                LOG.error(\"While reading original body content\", e);\n+                            }\n+                        });\n+\n+                        byte[] input = payload.toByteArray();\n+\n+                        InputStream is = null;\n+                        boolean compressed = false;\n+                        byte[] output;\n+                        try {\n+                            if (isCompressed(input)) {\n+                                compressed = true;\n+                                is = new GZIPInputStream(new ByteArrayInputStream(input));\n+                            } else {\n+                                is = new ByteArrayInputStream(input);\n                             }\n \n-                            if (compressed) {\n-                                try (ByteArrayOutputStream baos = new ByteArrayOutputStream(output.length);\n-                                        GZIPOutputStream gzipos = new GZIPOutputStream(baos)) {\n-\n-                                    gzipos.write(output);\n-                                    gzipos.close();\n-                                    output = baos.toByteArray();\n-                                } catch (IOException e) {\n-                                    LOG.error(\"While GZIP-encoding output\", e);\n-                                }\n+                            ObjectNode content = (ObjectNode) MAPPER.readTree(is);\n+                            String[] kv = config.getData().split(\"=\");\n+                            content.put(kv[0], kv[1]);\n+\n+                            output = MAPPER.writeValueAsBytes(content);\n+                        } catch (IOException e) {\n+                            LOG.error(\"While (de)serializing as JSON\", e);\n+                            output = ArrayUtils.clone(input);\n+                        } finally {\n+                            IOUtils.closeStream(is);\n+                        }\n+\n+                        if (compressed) {\n+                            try (ByteArrayOutputStream baos = new ByteArrayOutputStream(output.length);\n+                                    GZIPOutputStream gzipos = new GZIPOutputStream(baos)) {\n+\n+                                gzipos.write(output);\n+                                gzipos.close();\n+                                output = baos.toByteArray();\n+                            } catch (IOException e) {\n+                                LOG.error(\"While GZIP-encoding output\", e);\n                             }\n+                        }\n \n-                            return bufferFactory.wrap(output);\n-                        }));\n-                    }\n+                        return bufferFactory.wrap(output);\n+                    }));\n+                }\n \n-                    return super.writeWith(body);\n+                @Override\n+                public Mono<Void> writeAndFlushWith(final Publisher<? extends Publisher<? extends DataBuffer>> body) {\n+                    return writeWith(Flux.from(body).flatMapSequential(p -> p));\n                 }\n             };\n-\n-            return chain.filter(exchange.mutate().response(responseDecorator).build());\n         }\n \n         @Override\n         public int getOrder() {\n             return NettyWriteResponseFilter.WRITE_RESPONSE_FILTER_ORDER - 1;\n         }\n     }\n-\n-    public class ResponseAdapter implements ClientHttpResponse {\n-\n-        private final Flux<DataBuffer> flux;\n-\n-        private final HttpHeaders headers;\n-\n-        @SuppressWarnings(\"unchecked\")\n-        public ResponseAdapter(final Publisher<? extends DataBuffer> body, final HttpHeaders headers) {\n-            this.headers = headers;\n-            if (body instanceof Flux) {\n-                flux = (Flux) body;\n-            } else {\n-                flux = ((Mono) body).flux();\n-            }\n-        }\n-\n-        @Override\n-        public Flux<DataBuffer> getBody() {\n-            return flux;\n-        }\n-\n-        @Override\n-        public HttpHeaders getHeaders() {\n-            return headers;\n-        }\n-\n-        @Override\n-        public HttpStatus getStatusCode() {\n-            return null;\n-        }\n-\n-        @Override\n-        public int getRawStatusCode() {\n-            return 0;\n-        }\n-\n-        @Override\n-        public MultiValueMap<String, ResponseCookie> getCookies() {\n-            return null;\n-        }\n-    }\n }"},{"sha":"9be1ab8b31881550392846efc1abb83ae4b1f4d7","filename":"sra/src/test/java/org/apache/syncope/sra/BodyPropertyMatchingRoutePredicateFactory.java","status":"modified","additions":8,"deletions":31,"changes":39,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/d8fd4c9cd310909b7bc9e7921c42e1d8a73dbdce/sra%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fsra%2FBodyPropertyMatchingRoutePredicateFactory.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/d8fd4c9cd310909b7bc9e7921c42e1d8a73dbdce/sra%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fsra%2FBodyPropertyMatchingRoutePredicateFactory.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/sra%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fsra%2FBodyPropertyMatchingRoutePredicateFactory.java?ref=d8fd4c9cd310909b7bc9e7921c42e1d8a73dbdce","patch":"@@ -20,17 +20,12 @@\n \n import com.fasterxml.jackson.databind.JsonNode;\n import java.util.List;\n-import org.springframework.cloud.gateway.filter.AdaptCachedBodyGlobalFilter;\n import org.springframework.cloud.gateway.handler.AsyncPredicate;\n-import org.springframework.core.io.buffer.DataBuffer;\n-import org.springframework.core.io.buffer.DataBufferUtils;\n+import org.springframework.cloud.gateway.support.ServerWebExchangeUtils;\n import org.springframework.http.codec.HttpMessageReader;\n-import org.springframework.http.server.reactive.ServerHttpRequest;\n-import org.springframework.http.server.reactive.ServerHttpRequestDecorator;\n import org.springframework.web.reactive.function.server.HandlerStrategies;\n import org.springframework.web.reactive.function.server.ServerRequest;\n import org.springframework.web.server.ServerWebExchange;\n-import reactor.core.publisher.Flux;\n import reactor.core.publisher.Mono;\n \n /**\n@@ -48,31 +43,13 @@ public AsyncPredicate<ServerWebExchange> applyAsync(final Config config) {\n         return exchange -> {\n             JsonNode cachedBody = exchange.getAttribute(CACHE_REQUEST_BODY_OBJECT_KEY);\n             if (cachedBody == null) {\n-                // Join all the DataBuffers so we have a single DataBuffer for the body\n-                return DataBufferUtils.join(exchange.getRequest().getBody()).flatMap(dataBuffer -> {\n-                    // Update the retain counts so we can read the body twice, once to parse into an object\n-                    // that we can test the predicate against and a second time when the HTTP client sends\n-                    // the request downstream \n-                    // Note: if we end up reading the body twice we will run into a problem, but as of right\n-                    // now there is no good use case for doing this\n-                    DataBufferUtils.retain(dataBuffer);\n-                    // Make a slice for each read so each read has its own read/write indexes\n-                    Flux<DataBuffer> cachedFlux = Flux.defer(() -> Flux.just(\n-                            dataBuffer.slice(0, dataBuffer.readableByteCount())));\n-\n-                    ServerHttpRequest mutatedRequest = new ServerHttpRequestDecorator(exchange.getRequest()) {\n-\n-                        @Override\n-                        public Flux<DataBuffer> getBody() {\n-                            return cachedFlux;\n-                        }\n-                    };\n-                    return ServerRequest.create(exchange.mutate().request(mutatedRequest).build(), MESSAGE_READERS).\n-                            bodyToMono(JsonNode.class).doOnNext(value -> {\n-                        exchange.getAttributes().put(CACHE_REQUEST_BODY_OBJECT_KEY, value);\n-                        exchange.getAttributes().put(AdaptCachedBodyGlobalFilter.CACHED_REQUEST_BODY_KEY, cachedFlux);\n-                    }).map(objectValue -> objectValue.has(config.getData()));\n-                });\n+                return ServerWebExchangeUtils.cacheRequestBodyAndRequest(\n+                        exchange, serverHttpRequest -> ServerRequest.create(\n+                                exchange.mutate().request(serverHttpRequest).build(), MESSAGE_READERS).\n+                                bodyToMono(JsonNode.class).\n+                                doOnNext(objectValue -> exchange.getAttributes().\n+                                put(CACHE_REQUEST_BODY_OBJECT_KEY, objectValue)).\n+                                map(objectValue -> objectValue.has(config.getData())));\n             } else {\n                 return Mono.just(cachedBody.has(config.getData()));\n             }"}]}