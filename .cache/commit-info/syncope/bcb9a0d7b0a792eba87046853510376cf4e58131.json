{"sha":"bcb9a0d7b0a792eba87046853510376cf4e58131","node_id":"MDY6Q29tbWl0NjM2ODc5MDYyOmJjYjlhMGQ3YjBhNzkyZWJhODcwNDY4NTM1MTAzNzZjZjRlNTgxMzE=","commit":{"author":{"name":"Francesco Chicchiriccò","email":"ilgrosso@apache.org","date":"2015-08-11T10:51:57Z"},"committer":{"name":"Francesco Chicchiriccò","email":"ilgrosso@apache.org","date":"2015-08-13T15:16:51Z"},"message":"[SYNCOPE-119] Adding test for delegated admin (user) CRUD","tree":{"sha":"cbca32c4cb2f7919840f6a142db83c5f6074f182","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/git/trees/cbca32c4cb2f7919840f6a142db83c5f6074f182"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/git/commits/bcb9a0d7b0a792eba87046853510376cf4e58131","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/bcb9a0d7b0a792eba87046853510376cf4e58131","html_url":"https://github.com/EnricoDAlessandro97UNI/syncope/commit/bcb9a0d7b0a792eba87046853510376cf4e58131","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/bcb9a0d7b0a792eba87046853510376cf4e58131/comments","author":{"login":"ilgrosso","id":1064664,"node_id":"MDQ6VXNlcjEwNjQ2NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/1064664?v=4","gravatar_id":"","url":"https://api.github.com/users/ilgrosso","html_url":"https://github.com/ilgrosso","followers_url":"https://api.github.com/users/ilgrosso/followers","following_url":"https://api.github.com/users/ilgrosso/following{/other_user}","gists_url":"https://api.github.com/users/ilgrosso/gists{/gist_id}","starred_url":"https://api.github.com/users/ilgrosso/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ilgrosso/subscriptions","organizations_url":"https://api.github.com/users/ilgrosso/orgs","repos_url":"https://api.github.com/users/ilgrosso/repos","events_url":"https://api.github.com/users/ilgrosso/events{/privacy}","received_events_url":"https://api.github.com/users/ilgrosso/received_events","type":"User","site_admin":false},"committer":{"login":"ilgrosso","id":1064664,"node_id":"MDQ6VXNlcjEwNjQ2NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/1064664?v=4","gravatar_id":"","url":"https://api.github.com/users/ilgrosso","html_url":"https://github.com/ilgrosso","followers_url":"https://api.github.com/users/ilgrosso/followers","following_url":"https://api.github.com/users/ilgrosso/following{/other_user}","gists_url":"https://api.github.com/users/ilgrosso/gists{/gist_id}","starred_url":"https://api.github.com/users/ilgrosso/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ilgrosso/subscriptions","organizations_url":"https://api.github.com/users/ilgrosso/orgs","repos_url":"https://api.github.com/users/ilgrosso/repos","events_url":"https://api.github.com/users/ilgrosso/events{/privacy}","received_events_url":"https://api.github.com/users/ilgrosso/received_events","type":"User","site_admin":false},"parents":[{"sha":"5cf6aae8274d8e10b884ec9faeca54f623234836","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/5cf6aae8274d8e10b884ec9faeca54f623234836","html_url":"https://github.com/EnricoDAlessandro97UNI/syncope/commit/5cf6aae8274d8e10b884ec9faeca54f623234836"}],"stats":{"total":531,"additions":426,"deletions":105},"files":[{"sha":"bf87c8927f347e4aef5b795bc1e559900291b1bd","filename":"common/lib/src/main/java/org/apache/syncope/common/lib/types/Entitlement.java","status":"modified","additions":0,"deletions":2,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/bcb9a0d7b0a792eba87046853510376cf4e58131/common%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Ftypes%2FEntitlement.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/bcb9a0d7b0a792eba87046853510376cf4e58131/common%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Ftypes%2FEntitlement.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/common%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Ftypes%2FEntitlement.java?ref=bcb9a0d7b0a792eba87046853510376cf4e58131","patch":"@@ -108,8 +108,6 @@ public final class Entitlement {\n \n     public static final String USER_DELETE = \"USER_DELETE\";\n \n-    public static final String USER_VIEW = \"USER_VIEW\";\n-\n     public static final String GROUP_SEARCH = \"GROUP_SEARCH\";\n \n     public static final String GROUP_CREATE = \"GROUP_CREATE\";"},{"sha":"7a6cfddd5a9199d140d21485003eb7da6341ff21","filename":"core/logic/src/main/java/org/apache/syncope/core/logic/AbstractAnyLogic.java","status":"modified","additions":23,"deletions":2,"changes":25,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/bcb9a0d7b0a792eba87046853510376cf4e58131/core%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Flogic%2FAbstractAnyLogic.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/bcb9a0d7b0a792eba87046853510376cf4e58131/core%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Flogic%2FAbstractAnyLogic.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Flogic%2FAbstractAnyLogic.java?ref=bcb9a0d7b0a792eba87046853510376cf4e58131","patch":"@@ -26,7 +26,9 @@\n import org.apache.commons.collections4.Predicate;\n import org.apache.syncope.common.lib.mod.AnyMod;\n import org.apache.syncope.common.lib.to.AnyTO;\n+import org.apache.syncope.common.lib.types.AnyTypeKind;\n import org.apache.syncope.core.misc.RealmUtils;\n+import org.apache.syncope.core.misc.security.UnauthorizedException;\n import org.apache.syncope.core.persistence.api.dao.search.OrderByClause;\n import org.apache.syncope.core.persistence.api.dao.search.SearchCond;\n \n@@ -57,8 +59,8 @@ public boolean evaluate(final String target) {\n     protected Set<String> getEffectiveRealms(\n             final Set<String> allowedRealms, final Collection<String> requestedRealms) {\n \n-        final Set<String> allowed = RealmUtils.normalize(allowedRealms);\n-        final Set<String> requested = RealmUtils.normalize(requestedRealms);\n+        Set<String> allowed = RealmUtils.normalize(allowedRealms);\n+        Set<String> requested = RealmUtils.normalize(requestedRealms);\n \n         Set<String> effective = new HashSet<>();\n         CollectionUtils.select(requested, new StartsWithPredicate(allowed), effective);\n@@ -67,6 +69,25 @@ protected Set<String> getEffectiveRealms(\n         return effective;\n     }\n \n+    protected void securityChecks(final Set<String> effectiveRealms, final String realm, final Long key) {\n+        if (!CollectionUtils.exists(effectiveRealms, new Predicate<String>() {\n+\n+            @Override\n+            public boolean evaluate(final String ownedRealm) {\n+                return realm.startsWith(ownedRealm);\n+            }\n+        })) {\n+\n+            throw new UnauthorizedException(\n+                    this instanceof UserLogic\n+                            ? AnyTypeKind.USER\n+                            : this instanceof GroupLogic\n+                                    ? AnyTypeKind.GROUP\n+                                    : AnyTypeKind.ANY_OBJECT,\n+                    key);\n+        }\n+    }\n+\n     public abstract TO read(Long key);\n \n     public abstract int count(List<String> realms);"},{"sha":"0b0cb74a78f3b7315e093e24951457017889bed2","filename":"core/logic/src/main/java/org/apache/syncope/core/logic/AnyObjectLogic.java","status":"modified","additions":76,"deletions":38,"changes":114,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/bcb9a0d7b0a792eba87046853510376cf4e58131/core%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Flogic%2FAnyObjectLogic.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/bcb9a0d7b0a792eba87046853510376cf4e58131/core%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Flogic%2FAnyObjectLogic.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Flogic%2FAnyObjectLogic.java?ref=bcb9a0d7b0a792eba87046853510376cf4e58131","patch":"@@ -22,6 +22,7 @@\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n+import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n@@ -46,9 +47,7 @@\n import org.apache.syncope.core.provisioning.api.propagation.PropagationManager;\n import org.apache.syncope.core.provisioning.api.propagation.PropagationTaskExecutor;\n import org.apache.syncope.core.misc.security.AuthContextUtils;\n-import org.apache.syncope.core.misc.security.UnauthorizedException;\n import org.apache.syncope.core.persistence.api.dao.AnySearchDAO;\n-import org.apache.syncope.core.persistence.api.dao.NotFoundException;\n import org.apache.syncope.core.persistence.api.entity.anyobject.AnyObject;\n import org.apache.syncope.core.provisioning.api.AnyTransformer;\n import org.springframework.beans.factory.annotation.Autowired;\n@@ -90,8 +89,8 @@ public class AnyObjectLogic extends AbstractAnyLogic<AnyObjectTO, AnyObjectMod>\n     @PreAuthorize(\"hasRole('\" + Entitlement.ANY_OBJECT_READ + \"')\")\n     @Transactional(readOnly = true)\n     @Override\n-    public AnyObjectTO read(final Long anyObjectKey) {\n-        return binder.getAnyObjectTO(anyObjectKey);\n+    public AnyObjectTO read(final Long key) {\n+        return binder.getAnyObjectTO(key);\n     }\n \n     @PreAuthorize(\"isAuthenticated()\")\n@@ -164,12 +163,11 @@ public AnyObjectTO create(final AnyObjectTO anyObjectTO) {\n         if (anyObjectTO.getRealm() == null) {\n             throw SyncopeClientException.build(ClientExceptionType.InvalidRealm);\n         }\n+        // security checks\n         Set<String> effectiveRealms = getEffectiveRealms(\n                 AuthContextUtils.getAuthorizations().get(Entitlement.ANY_OBJECT_CREATE),\n                 Collections.singleton(anyObjectTO.getRealm()));\n-        if (effectiveRealms.isEmpty()) {\n-            throw new UnauthorizedException(AnyTypeKind.ANY_OBJECT, null);\n-        }\n+        securityChecks(effectiveRealms, anyObjectTO.getRealm(), null);\n \n         // Any transformation (if configured)\n         AnyObjectTO actual = attrTransformer.transform(anyObjectTO);\n@@ -191,21 +189,25 @@ public AnyObjectTO create(final AnyObjectTO anyObjectTO) {\n     @PreAuthorize(\"hasRole('\" + Entitlement.ANY_OBJECT_UPDATE + \"')\")\n     @Override\n     public AnyObjectTO update(final AnyObjectMod anyObjectMod) {\n-        AnyObject anyObject = anyObjectDAO.authFind(anyObjectMod.getKey());\n-        if (anyObject == null) {\n-            throw new NotFoundException(\"AnyObject with key \" + anyObjectMod.getKey());\n+        // Any transformation (if configured)\n+        AnyObjectMod actual = attrTransformer.transform(anyObjectMod);\n+        LOG.debug(\"Transformed: {}\", actual);\n+\n+        // security checks\n+        AnyObjectTO toUpdate = binder.getAnyObjectTO(anyObjectMod.getKey());\n+        Set<String> requestedRealms = new HashSet<>();\n+        requestedRealms.add(toUpdate.getRealm());\n+        if (StringUtils.isNotBlank(actual.getRealm())) {\n+            requestedRealms.add(actual.getRealm());\n         }\n         Set<String> effectiveRealms = getEffectiveRealms(\n                 AuthContextUtils.getAuthorizations().get(Entitlement.ANY_OBJECT_UPDATE),\n-                Collections.singleton(anyObject.getRealm().getFullPath()));\n-        if (effectiveRealms.isEmpty()) {\n-            throw new UnauthorizedException(AnyTypeKind.ANY_OBJECT, anyObject.getKey());\n+                requestedRealms);\n+        securityChecks(effectiveRealms, toUpdate.getRealm(), toUpdate.getKey());\n+        if (StringUtils.isNotBlank(actual.getRealm())) {\n+            securityChecks(effectiveRealms, actual.getRealm(), toUpdate.getKey());\n         }\n \n-        // Any transformation (if configured)\n-        AnyObjectMod actual = attrTransformer.transform(anyObjectMod);\n-        LOG.debug(\"Transformed: {}\", actual);\n-\n         Map.Entry<Long, List<PropagationStatus>> updated = provisioningManager.update(anyObjectMod);\n \n         AnyObjectTO updatedTO = binder.getAnyObjectTO(updated.getKey());\n@@ -215,22 +217,18 @@ public AnyObjectTO update(final AnyObjectMod anyObjectMod) {\n \n     @PreAuthorize(\"hasRole('\" + Entitlement.ANY_OBJECT_DELETE + \"')\")\n     @Override\n-    public AnyObjectTO delete(final Long anyObjectKey) {\n-        AnyObject anyObject = anyObjectDAO.authFind(anyObjectKey);\n-        if (anyObject == null) {\n-            throw new NotFoundException(\"AnyObject with key \" + anyObjectKey);\n-        }\n+    public AnyObjectTO delete(final Long key) {\n+        // security checks\n+        AnyObjectTO toDelete = binder.getAnyObjectTO(key);\n         Set<String> effectiveRealms = getEffectiveRealms(\n-                AuthContextUtils.getAuthorizations().get(Entitlement.ANY_OBJECT_UPDATE),\n-                Collections.singleton(anyObject.getRealm().getFullPath()));\n-        if (effectiveRealms.isEmpty()) {\n-            throw new UnauthorizedException(AnyTypeKind.ANY_OBJECT, anyObject.getKey());\n-        }\n+                AuthContextUtils.getAuthorizations().get(Entitlement.ANY_OBJECT_DELETE),\n+                Collections.singleton(toDelete.getRealm()));\n+        securityChecks(effectiveRealms, toDelete.getRealm(), toDelete.getKey());\n \n-        List<PropagationStatus> statuses = provisioningManager.delete(anyObjectKey);\n+        List<PropagationStatus> statuses = provisioningManager.delete(key);\n \n         AnyObjectTO anyObjectTO = new AnyObjectTO();\n-        anyObjectTO.setKey(anyObjectKey);\n+        anyObjectTO.setKey(key);\n \n         anyObjectTO.getPropagationStatusTOs().addAll(statuses);\n \n@@ -239,29 +237,50 @@ public AnyObjectTO delete(final Long anyObjectKey) {\n \n     @PreAuthorize(\"hasRole('\" + Entitlement.ANY_OBJECT_UPDATE + \"')\")\n     @Override\n-    public AnyObjectTO unlink(final Long anyObjectKey, final Collection<String> resources) {\n+    public AnyObjectTO unlink(final Long key, final Collection<String> resources) {\n+        // security checks\n+        AnyObjectTO anyObject = binder.getAnyObjectTO(key);\n+        Set<String> effectiveRealms = getEffectiveRealms(\n+                AuthContextUtils.getAuthorizations().get(Entitlement.ANY_OBJECT_UPDATE),\n+                Collections.singleton(anyObject.getRealm()));\n+        securityChecks(effectiveRealms, anyObject.getRealm(), anyObject.getKey());\n+\n         AnyObjectMod anyObjectMod = new AnyObjectMod();\n-        anyObjectMod.setKey(anyObjectKey);\n+        anyObjectMod.setKey(key);\n         anyObjectMod.getResourcesToRemove().addAll(resources);\n \n         return binder.getAnyObjectTO(provisioningManager.unlink(anyObjectMod));\n     }\n \n     @PreAuthorize(\"hasRole('\" + Entitlement.ANY_OBJECT_UPDATE + \"')\")\n     @Override\n-    public AnyObjectTO link(final Long anyObjectKey, final Collection<String> resources) {\n+    public AnyObjectTO link(final Long key, final Collection<String> resources) {\n+        // security checks\n+        AnyObjectTO anyObject = binder.getAnyObjectTO(key);\n+        Set<String> effectiveRealms = getEffectiveRealms(\n+                AuthContextUtils.getAuthorizations().get(Entitlement.ANY_OBJECT_UPDATE),\n+                Collections.singleton(anyObject.getRealm()));\n+        securityChecks(effectiveRealms, anyObject.getRealm(), anyObject.getKey());\n+\n         AnyObjectMod anyObjectMod = new AnyObjectMod();\n-        anyObjectMod.setKey(anyObjectKey);\n+        anyObjectMod.setKey(key);\n         anyObjectMod.getResourcesToAdd().addAll(resources);\n \n         return binder.getAnyObjectTO(provisioningManager.link(anyObjectMod));\n     }\n \n     @PreAuthorize(\"hasRole('\" + Entitlement.ANY_OBJECT_UPDATE + \"')\")\n     @Override\n-    public AnyObjectTO unassign(final Long anyObjectKey, final Collection<String> resources) {\n+    public AnyObjectTO unassign(final Long key, final Collection<String> resources) {\n+        // security checks\n+        AnyObjectTO anyObject = binder.getAnyObjectTO(key);\n+        Set<String> effectiveRealms = getEffectiveRealms(\n+                AuthContextUtils.getAuthorizations().get(Entitlement.ANY_OBJECT_UPDATE),\n+                Collections.singleton(anyObject.getRealm()));\n+        securityChecks(effectiveRealms, anyObject.getRealm(), anyObject.getKey());\n+\n         AnyObjectMod anyObjectMod = new AnyObjectMod();\n-        anyObjectMod.setKey(anyObjectKey);\n+        anyObjectMod.setKey(key);\n         anyObjectMod.getResourcesToRemove().addAll(resources);\n         return update(anyObjectMod);\n     }\n@@ -274,6 +293,13 @@ public AnyObjectTO assign(\n             final boolean changepwd,\n             final String password) {\n \n+        // security checks\n+        AnyObjectTO anyObject = binder.getAnyObjectTO(key);\n+        Set<String> effectiveRealms = getEffectiveRealms(\n+                AuthContextUtils.getAuthorizations().get(Entitlement.ANY_OBJECT_UPDATE),\n+                Collections.singleton(anyObject.getRealm()));\n+        securityChecks(effectiveRealms, anyObject.getRealm(), anyObject.getKey());\n+\n         AnyObjectMod anyObjectMod = new AnyObjectMod();\n         anyObjectMod.setKey(key);\n         anyObjectMod.getResourcesToAdd().addAll(resources);\n@@ -284,6 +310,13 @@ public AnyObjectTO assign(\n     @PreAuthorize(\"hasRole('\" + Entitlement.ANY_OBJECT_UPDATE + \"')\")\n     @Override\n     public AnyObjectTO deprovision(final Long key, final Collection<String> resources) {\n+        // security checks\n+        AnyObjectTO anyObject = binder.getAnyObjectTO(key);\n+        Set<String> effectiveRealms = getEffectiveRealms(\n+                AuthContextUtils.getAuthorizations().get(Entitlement.ANY_OBJECT_UPDATE),\n+                Collections.singleton(anyObject.getRealm()));\n+        securityChecks(effectiveRealms, anyObject.getRealm(), anyObject.getKey());\n+\n         List<PropagationStatus> statuses = provisioningManager.deprovision(key, resources);\n \n         AnyObjectTO updatedTO = binder.getAnyObjectTO(key);\n@@ -299,10 +332,15 @@ public AnyObjectTO provision(\n             final boolean changePwd,\n             final String password) {\n \n-        AnyObjectTO original = binder.getAnyObjectTO(key);\n-        original.getPropagationStatusTOs().addAll(provisioningManager.provision(key, resources));\n+        // security checks\n+        AnyObjectTO anyObject = binder.getAnyObjectTO(key);\n+        Set<String> effectiveRealms = getEffectiveRealms(\n+                AuthContextUtils.getAuthorizations().get(Entitlement.ANY_OBJECT_UPDATE),\n+                Collections.singleton(anyObject.getRealm()));\n+        securityChecks(effectiveRealms, anyObject.getRealm(), anyObject.getKey());\n \n-        return original;\n+        anyObject.getPropagationStatusTOs().addAll(provisioningManager.provision(key, resources));\n+        return anyObject;\n     }\n \n     @Override"},{"sha":"1c3d7f5cb80b9c34ba15d5da5b3a17ee16ebb1b2","filename":"core/logic/src/main/java/org/apache/syncope/core/logic/GroupLogic.java","status":"modified","additions":94,"deletions":40,"changes":134,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/bcb9a0d7b0a792eba87046853510376cf4e58131/core%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Flogic%2FGroupLogic.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/bcb9a0d7b0a792eba87046853510376cf4e58131/core%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Flogic%2FGroupLogic.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Flogic%2FGroupLogic.java?ref=bcb9a0d7b0a792eba87046853510376cf4e58131","patch":"@@ -22,13 +22,16 @@\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n+import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n import javax.annotation.Resource;\n import org.apache.commons.collections4.CollectionUtils;\n+import org.apache.commons.collections4.Predicate;\n import org.apache.commons.collections4.Transformer;\n import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.commons.lang3.StringUtils;\n import org.apache.syncope.common.lib.SyncopeClientException;\n import org.apache.syncope.common.lib.SyncopeConstants;\n import org.apache.syncope.common.lib.mod.GroupMod;\n@@ -50,7 +53,6 @@\n import org.apache.syncope.core.misc.security.AuthContextUtils;\n import org.apache.syncope.core.misc.security.UnauthorizedException;\n import org.apache.syncope.core.persistence.api.dao.AnySearchDAO;\n-import org.apache.syncope.core.persistence.api.dao.NotFoundException;\n import org.apache.syncope.core.provisioning.api.AnyTransformer;\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.security.access.prepost.PreAuthorize;\n@@ -91,11 +93,25 @@ public class GroupLogic extends AbstractAnyLogic<GroupTO, GroupMod> {\n     @Autowired\n     protected GroupProvisioningManager provisioningManager;\n \n+    @Override\n+    protected void securityChecks(final Set<String> effectiveRealms, final String realm, final Long key) {\n+        if (!CollectionUtils.exists(effectiveRealms, new Predicate<String>() {\n+\n+            @Override\n+            public boolean evaluate(final String ownedRealm) {\n+                return realm.startsWith(ownedRealm) || ownedRealm.equals(RealmUtils.getGroupOwnerRealm(realm, key));\n+            }\n+        })) {\n+\n+            throw new UnauthorizedException(AnyTypeKind.GROUP, key);\n+        }\n+    }\n+\n     @PreAuthorize(\"hasRole('\" + Entitlement.GROUP_READ + \"')\")\n     @Transactional(readOnly = true)\n     @Override\n-    public GroupTO read(final Long groupKey) {\n-        return binder.getGroupTO(groupKey);\n+    public GroupTO read(final Long key) {\n+        return binder.getGroupTO(key);\n     }\n \n     @PreAuthorize(\"isAuthenticated() and not(hasRole('\" + Entitlement.ANONYMOUS + \"'))\")\n@@ -153,7 +169,7 @@ public int searchCount(final SearchCond searchCondition, final List<String> real\n     public List<GroupTO> search(final SearchCond searchCondition, final int page, final int size,\n             final List<OrderByClause> orderBy, final List<String> realms, final boolean details) {\n \n-        final List<Group> matchingGroups = searchDAO.search(\n+        List<Group> matchingGroups = searchDAO.search(\n                 getEffectiveRealms(AuthContextUtils.getAuthorizations().get(Entitlement.GROUP_SEARCH), realms),\n                 searchCondition, page, size, orderBy, AnyTypeKind.GROUP);\n         return CollectionUtils.collect(matchingGroups, new Transformer<Group, GroupTO>() {\n@@ -169,15 +185,13 @@ public GroupTO transform(final Group input) {\n     @Override\n     public GroupTO create(final GroupTO groupTO) {\n         if (groupTO.getRealm() == null) {\n-            SyncopeClientException sce = SyncopeClientException.build(ClientExceptionType.InvalidRealm);\n-            throw sce;\n+            throw SyncopeClientException.build(ClientExceptionType.InvalidRealm);\n         }\n+        // security checks\n         Set<String> effectiveRealms = getEffectiveRealms(\n                 AuthContextUtils.getAuthorizations().get(Entitlement.GROUP_CREATE),\n                 Collections.singleton(groupTO.getRealm()));\n-        if (effectiveRealms.isEmpty()) {\n-            throw new UnauthorizedException(AnyTypeKind.GROUP, null);\n-        }\n+        securityChecks(effectiveRealms, groupTO.getRealm(), null);\n \n         // Any transformation (if configured)\n         GroupTO actual = attrTransformer.transform(groupTO);\n@@ -195,21 +209,25 @@ public GroupTO create(final GroupTO groupTO) {\n     @PreAuthorize(\"hasRole('\" + Entitlement.GROUP_UPDATE + \"')\")\n     @Override\n     public GroupTO update(final GroupMod groupMod) {\n-        Group group = groupDAO.authFind(groupMod.getKey());\n-        if (group == null) {\n-            throw new NotFoundException(\"Group with key \" + groupMod.getKey());\n+        // Any transformation (if configured)\n+        GroupMod actual = attrTransformer.transform(groupMod);\n+        LOG.debug(\"Transformed: {}\", actual);\n+\n+        // security checks\n+        GroupTO toUpdate = binder.getGroupTO(groupMod.getKey());\n+        Set<String> requestedRealms = new HashSet<>();\n+        requestedRealms.add(toUpdate.getRealm());\n+        if (StringUtils.isNotBlank(actual.getRealm())) {\n+            requestedRealms.add(actual.getRealm());\n         }\n         Set<String> effectiveRealms = getEffectiveRealms(\n                 AuthContextUtils.getAuthorizations().get(Entitlement.GROUP_UPDATE),\n-                Collections.singleton(RealmUtils.getGroupOwnerRealm(group.getRealm().getFullPath(), group.getKey())));\n-        if (effectiveRealms.isEmpty()) {\n-            throw new UnauthorizedException(AnyTypeKind.GROUP, group.getKey());\n+                requestedRealms);\n+        securityChecks(effectiveRealms, toUpdate.getRealm(), toUpdate.getKey());\n+        if (StringUtils.isNotBlank(actual.getRealm())) {\n+            securityChecks(effectiveRealms, actual.getRealm(), toUpdate.getKey());\n         }\n \n-        // Any transformation (if configured)\n-        GroupMod actual = attrTransformer.transform(groupMod);\n-        LOG.debug(\"Transformed: {}\", actual);\n-\n         Map.Entry<Long, List<PropagationStatus>> updated = provisioningManager.update(groupMod);\n \n         GroupTO updatedTO = binder.getGroupTO(updated.getKey());\n@@ -219,19 +237,15 @@ public GroupTO update(final GroupMod groupMod) {\n \n     @PreAuthorize(\"hasRole('\" + Entitlement.GROUP_DELETE + \"')\")\n     @Override\n-    public GroupTO delete(final Long groupKey) {\n-        Group group = groupDAO.authFind(groupKey);\n-        if (group == null) {\n-            throw new NotFoundException(\"Group with key \" + groupKey);\n-        }\n+    public GroupTO delete(final Long key) {\n+        // security checks\n+        GroupTO toDelete = binder.getGroupTO(key);\n         Set<String> effectiveRealms = getEffectiveRealms(\n                 AuthContextUtils.getAuthorizations().get(Entitlement.GROUP_DELETE),\n-                Collections.singleton(RealmUtils.getGroupOwnerRealm(group.getRealm().getFullPath(), group.getKey())));\n-        if (effectiveRealms.isEmpty()) {\n-            throw new UnauthorizedException(AnyTypeKind.GROUP, group.getKey());\n-        }\n+                Collections.singleton(toDelete.getRealm()));\n+        securityChecks(effectiveRealms, toDelete.getRealm(), toDelete.getKey());\n \n-        List<Group> ownedGroups = groupDAO.findOwnedByGroup(groupKey);\n+        List<Group> ownedGroups = groupDAO.findOwnedByGroup(key);\n         if (!ownedGroups.isEmpty()) {\n             SyncopeClientException sce = SyncopeClientException.build(ClientExceptionType.GroupOwnership);\n             sce.getElements().addAll(CollectionUtils.collect(ownedGroups, new Transformer<Group, String>() {\n@@ -244,10 +258,10 @@ public String transform(final Group group) {\n             throw sce;\n         }\n \n-        List<PropagationStatus> statuses = provisioningManager.delete(groupKey);\n+        List<PropagationStatus> statuses = provisioningManager.delete(key);\n \n         GroupTO groupTO = new GroupTO();\n-        groupTO.setKey(groupKey);\n+        groupTO.setKey(key);\n \n         groupTO.getPropagationStatusTOs().addAll(statuses);\n \n@@ -256,29 +270,50 @@ public String transform(final Group group) {\n \n     @PreAuthorize(\"hasRole('\" + Entitlement.GROUP_UPDATE + \"')\")\n     @Override\n-    public GroupTO unlink(final Long groupKey, final Collection<String> resources) {\n+    public GroupTO unlink(final Long key, final Collection<String> resources) {\n+        // security checks\n+        GroupTO group = binder.getGroupTO(key);\n+        Set<String> effectiveRealms = getEffectiveRealms(\n+                AuthContextUtils.getAuthorizations().get(Entitlement.GROUP_UPDATE),\n+                Collections.singleton(group.getRealm()));\n+        securityChecks(effectiveRealms, group.getRealm(), group.getKey());\n+\n         GroupMod groupMod = new GroupMod();\n-        groupMod.setKey(groupKey);\n+        groupMod.setKey(key);\n         groupMod.getResourcesToRemove().addAll(resources);\n \n         return binder.getGroupTO(provisioningManager.unlink(groupMod));\n     }\n \n     @PreAuthorize(\"hasRole('\" + Entitlement.GROUP_UPDATE + \"')\")\n     @Override\n-    public GroupTO link(final Long groupKey, final Collection<String> resources) {\n+    public GroupTO link(final Long key, final Collection<String> resources) {\n+        // security checks\n+        GroupTO group = binder.getGroupTO(key);\n+        Set<String> effectiveRealms = getEffectiveRealms(\n+                AuthContextUtils.getAuthorizations().get(Entitlement.GROUP_UPDATE),\n+                Collections.singleton(group.getRealm()));\n+        securityChecks(effectiveRealms, group.getRealm(), group.getKey());\n+\n         GroupMod groupMod = new GroupMod();\n-        groupMod.setKey(groupKey);\n+        groupMod.setKey(key);\n         groupMod.getResourcesToAdd().addAll(resources);\n \n         return binder.getGroupTO(provisioningManager.link(groupMod));\n     }\n \n     @PreAuthorize(\"hasRole('\" + Entitlement.GROUP_UPDATE + \"')\")\n     @Override\n-    public GroupTO unassign(final Long groupKey, final Collection<String> resources) {\n+    public GroupTO unassign(final Long key, final Collection<String> resources) {\n+        // security checks\n+        GroupTO group = binder.getGroupTO(key);\n+        Set<String> effectiveRealms = getEffectiveRealms(\n+                AuthContextUtils.getAuthorizations().get(Entitlement.GROUP_UPDATE),\n+                Collections.singleton(group.getRealm()));\n+        securityChecks(effectiveRealms, group.getRealm(), group.getKey());\n+\n         GroupMod groupMod = new GroupMod();\n-        groupMod.setKey(groupKey);\n+        groupMod.setKey(key);\n         groupMod.getResourcesToRemove().addAll(resources);\n         return update(groupMod);\n     }\n@@ -291,6 +326,13 @@ public GroupTO assign(\n             final boolean changepwd,\n             final String password) {\n \n+        // security checks\n+        GroupTO group = binder.getGroupTO(key);\n+        Set<String> effectiveRealms = getEffectiveRealms(\n+                AuthContextUtils.getAuthorizations().get(Entitlement.GROUP_UPDATE),\n+                Collections.singleton(group.getRealm()));\n+        securityChecks(effectiveRealms, group.getRealm(), group.getKey());\n+\n         GroupMod groupMod = new GroupMod();\n         groupMod.setKey(key);\n         groupMod.getResourcesToAdd().addAll(resources);\n@@ -301,6 +343,13 @@ public GroupTO assign(\n     @PreAuthorize(\"hasRole('\" + Entitlement.GROUP_UPDATE + \"')\")\n     @Override\n     public GroupTO deprovision(final Long key, final Collection<String> resources) {\n+        // security checks\n+        GroupTO group = binder.getGroupTO(key);\n+        Set<String> effectiveRealms = getEffectiveRealms(\n+                AuthContextUtils.getAuthorizations().get(Entitlement.GROUP_UPDATE),\n+                Collections.singleton(group.getRealm()));\n+        securityChecks(effectiveRealms, group.getRealm(), group.getKey());\n+\n         List<PropagationStatus> statuses = provisioningManager.deprovision(key, resources);\n \n         GroupTO updatedTO = binder.getGroupTO(key);\n@@ -316,10 +365,15 @@ public GroupTO provision(\n             final boolean changePwd,\n             final String password) {\n \n-        GroupTO original = binder.getGroupTO(key);\n-        original.getPropagationStatusTOs().addAll(provisioningManager.provision(key, resources));\n+        // security checks\n+        GroupTO group = binder.getGroupTO(key);\n+        Set<String> effectiveRealms = getEffectiveRealms(\n+                AuthContextUtils.getAuthorizations().get(Entitlement.GROUP_UPDATE),\n+                Collections.singleton(group.getRealm()));\n+        securityChecks(effectiveRealms, group.getRealm(), group.getKey());\n \n-        return original;\n+        group.getPropagationStatusTOs().addAll(provisioningManager.provision(key, resources));\n+        return group;\n     }\n \n     @Override"},{"sha":"ff87d6b2ed07517982ca2d41efc7198b097e1f65","filename":"core/logic/src/main/java/org/apache/syncope/core/logic/UserLogic.java","status":"modified","additions":92,"deletions":16,"changes":108,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/bcb9a0d7b0a792eba87046853510376cf4e58131/core%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Flogic%2FUserLogic.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/bcb9a0d7b0a792eba87046853510376cf4e58131/core%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Flogic%2FUserLogic.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Flogic%2FUserLogic.java?ref=bcb9a0d7b0a792eba87046853510376cf4e58131","patch":"@@ -23,12 +23,14 @@\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n+import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n import org.apache.commons.collections4.CollectionUtils;\n import org.apache.commons.collections4.Transformer;\n import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.commons.lang3.StringUtils;\n import org.apache.commons.lang3.tuple.ImmutablePair;\n import org.apache.commons.lang3.tuple.Pair;\n import org.apache.syncope.common.lib.SyncopeClientException;\n@@ -51,7 +53,6 @@\n import org.apache.syncope.core.provisioning.api.propagation.PropagationManager;\n import org.apache.syncope.core.provisioning.api.propagation.PropagationTaskExecutor;\n import org.apache.syncope.core.misc.security.AuthContextUtils;\n-import org.apache.syncope.core.misc.security.UnauthorizedException;\n import org.apache.syncope.core.misc.serialization.POJOHelper;\n import org.apache.syncope.core.persistence.api.dao.AnySearchDAO;\n import org.apache.syncope.core.provisioning.api.AnyTransformer;\n@@ -180,7 +181,7 @@ public UserTO transform(final User input) {\n     }\n \n     @PreAuthorize(\"isAnonymous() or hasRole('\" + Entitlement.ANONYMOUS + \"')\")\n-    public UserTO createSelf(final UserTO userTO, final boolean storePassword) {\n+    public UserTO selfCreate(final UserTO userTO, final boolean storePassword) {\n         return doCreate(userTO, storePassword);\n     }\n \n@@ -193,15 +194,13 @@ public UserTO create(final UserTO userTO) {\n     @PreAuthorize(\"hasRole('\" + Entitlement.USER_CREATE + \"')\")\n     public UserTO create(final UserTO userTO, final boolean storePassword) {\n         if (userTO.getRealm() == null) {\n-            SyncopeClientException sce = SyncopeClientException.build(ClientExceptionType.InvalidRealm);\n-            throw sce;\n+            throw SyncopeClientException.build(ClientExceptionType.InvalidRealm);\n         }\n+        // security checks\n         Set<String> effectiveRealms = getEffectiveRealms(\n                 AuthContextUtils.getAuthorizations().get(Entitlement.USER_CREATE),\n                 Collections.singleton(userTO.getRealm()));\n-        if (effectiveRealms.isEmpty()) {\n-            throw new UnauthorizedException(AnyTypeKind.USER, null);\n-        }\n+        securityChecks(effectiveRealms, userTO.getRealm(), null);\n \n         return doCreate(userTO, storePassword);\n     }\n@@ -219,14 +218,14 @@ protected UserTO doCreate(final UserTO userTO, final boolean storePassword) {\n     }\n \n     @PreAuthorize(\"isAuthenticated() and not(hasRole('\" + Entitlement.ANONYMOUS + \"'))\")\n-    public UserTO updateSelf(final UserMod userMod) {\n+    public UserTO selfUpdate(final UserMod userMod) {\n         UserTO userTO = binder.getAuthenticatedUserTO();\n \n         if (userTO.getKey() != userMod.getKey()) {\n             throw new AccessControlException(\"Not allowed for user with key \" + userMod.getKey());\n         }\n \n-        return update(userMod);\n+        return doUpdate(userMod);\n     }\n \n     @PreAuthorize(\"hasRole('\" + Entitlement.USER_UPDATE + \"')\")\n@@ -236,7 +235,26 @@ public UserTO update(final UserMod userMod) {\n         UserMod actual = anyTransformer.transform(userMod);\n         LOG.debug(\"Transformed: {}\", actual);\n \n-        Map.Entry<Long, List<PropagationStatus>> updated = provisioningManager.update(actual);\n+        // security checks\n+        UserTO toUpdate = binder.getUserTO(userMod.getKey());\n+        Set<String> requestedRealms = new HashSet<>();\n+        requestedRealms.add(toUpdate.getRealm());\n+        if (StringUtils.isNotBlank(actual.getRealm())) {\n+            requestedRealms.add(actual.getRealm());\n+        }\n+        Set<String> effectiveRealms = getEffectiveRealms(\n+                AuthContextUtils.getAuthorizations().get(Entitlement.USER_UPDATE),\n+                requestedRealms);\n+        securityChecks(effectiveRealms, toUpdate.getRealm(), toUpdate.getKey());\n+        if (StringUtils.isNotBlank(actual.getRealm())) {\n+            securityChecks(effectiveRealms, actual.getRealm(), toUpdate.getKey());\n+        }\n+\n+        return doUpdate(actual);\n+    }\n+\n+    protected UserTO doUpdate(final UserMod userMod) {\n+        Map.Entry<Long, List<PropagationStatus>> updated = provisioningManager.update(userMod);\n \n         UserTO updatedTO = binder.getUserTO(updated.getKey());\n         updatedTO.getPropagationStatusTOs().addAll(updated.getValue());\n@@ -267,8 +285,15 @@ protected Map.Entry<Long, List<PropagationStatus>> setStatusOnWfAdapter(final St\n \n     @PreAuthorize(\"hasRole('\" + Entitlement.USER_UPDATE + \"')\")\n     public UserTO status(final StatusMod statusMod) {\n+        // security checks\n+        UserTO toUpdate = binder.getUserTO(statusMod.getKey());\n+        Set<String> effectiveRealms = getEffectiveRealms(\n+                AuthContextUtils.getAuthorizations().get(Entitlement.USER_UPDATE),\n+                Collections.singleton(toUpdate.getRealm()));\n+        securityChecks(effectiveRealms, toUpdate.getRealm(), toUpdate.getKey());\n+\n         Map.Entry<Long, List<PropagationStatus>> updated = setStatusOnWfAdapter(statusMod);\n-        final UserTO savedTO = binder.getUserTO(updated.getKey());\n+        UserTO savedTO = binder.getUserTO(updated.getKey());\n         savedTO.getPropagationStatusTOs().addAll(updated.getValue());\n         return savedTO;\n     }\n@@ -305,15 +330,26 @@ public void confirmPasswordReset(final String token, final String password) {\n     }\n \n     @PreAuthorize(\"isAuthenticated() and not(hasRole('\" + Entitlement.ANONYMOUS + \"'))\")\n-    public UserTO deleteSelf() {\n+    public UserTO selfDelete() {\n         UserTO userTO = binder.getAuthenticatedUserTO();\n \n-        return delete(userTO.getKey());\n+        return doDelete(userTO.getKey());\n     }\n \n     @PreAuthorize(\"hasRole('\" + Entitlement.USER_DELETE + \"')\")\n     @Override\n     public UserTO delete(final Long key) {\n+        // security checks\n+        UserTO toDelete = binder.getUserTO(key);\n+        Set<String> effectiveRealms = getEffectiveRealms(\n+                AuthContextUtils.getAuthorizations().get(Entitlement.USER_DELETE),\n+                Collections.singleton(toDelete.getRealm()));\n+        securityChecks(effectiveRealms, toDelete.getRealm(), toDelete.getKey());\n+\n+        return doDelete(key);\n+    }\n+\n+    protected UserTO doDelete(final Long key) {\n         List<Group> ownedGroups = groupDAO.findOwnedByUser(key);\n         if (!ownedGroups.isEmpty()) {\n             SyncopeClientException sce = SyncopeClientException.build(ClientExceptionType.GroupOwnership);\n@@ -344,6 +380,13 @@ public String transform(final Group group) {\n     @PreAuthorize(\"hasRole('\" + Entitlement.USER_UPDATE + \"')\")\n     @Override\n     public UserTO unlink(final Long key, final Collection<String> resources) {\n+        // security checks\n+        UserTO user = binder.getUserTO(key);\n+        Set<String> effectiveRealms = getEffectiveRealms(\n+                AuthContextUtils.getAuthorizations().get(Entitlement.USER_UPDATE),\n+                Collections.singleton(user.getRealm()));\n+        securityChecks(effectiveRealms, user.getRealm(), user.getKey());\n+\n         UserMod userMod = new UserMod();\n         userMod.setKey(key);\n         userMod.getResourcesToRemove().addAll(resources);\n@@ -354,6 +397,13 @@ public UserTO unlink(final Long key, final Collection<String> resources) {\n     @PreAuthorize(\"hasRole('\" + Entitlement.USER_UPDATE + \"')\")\n     @Override\n     public UserTO link(final Long key, final Collection<String> resources) {\n+        // security checks\n+        UserTO user = binder.getUserTO(key);\n+        Set<String> effectiveRealms = getEffectiveRealms(\n+                AuthContextUtils.getAuthorizations().get(Entitlement.USER_UPDATE),\n+                Collections.singleton(user.getRealm()));\n+        securityChecks(effectiveRealms, user.getRealm(), user.getKey());\n+\n         UserMod userMod = new UserMod();\n         userMod.setKey(key);\n         userMod.getResourcesToAdd().addAll(resources);\n@@ -364,6 +414,13 @@ public UserTO link(final Long key, final Collection<String> resources) {\n     @PreAuthorize(\"hasRole('\" + Entitlement.USER_UPDATE + \"')\")\n     @Override\n     public UserTO unassign(final Long key, final Collection<String> resources) {\n+        // security checks\n+        UserTO user = binder.getUserTO(key);\n+        Set<String> effectiveRealms = getEffectiveRealms(\n+                AuthContextUtils.getAuthorizations().get(Entitlement.USER_UPDATE),\n+                Collections.singleton(user.getRealm()));\n+        securityChecks(effectiveRealms, user.getRealm(), user.getKey());\n+\n         UserMod userMod = new UserMod();\n         userMod.setKey(key);\n         userMod.getResourcesToRemove().addAll(resources);\n@@ -378,6 +435,13 @@ public UserTO assign(\n             final boolean changepwd,\n             final String password) {\n \n+        // security checks\n+        UserTO user = binder.getUserTO(key);\n+        Set<String> effectiveRealms = getEffectiveRealms(\n+                AuthContextUtils.getAuthorizations().get(Entitlement.USER_UPDATE),\n+                Collections.singleton(user.getRealm()));\n+        securityChecks(effectiveRealms, user.getRealm(), user.getKey());\n+\n         UserMod userMod = new UserMod();\n         userMod.setKey(key);\n         userMod.getResourcesToAdd().addAll(resources);\n@@ -396,6 +460,13 @@ public UserTO assign(\n     @PreAuthorize(\"hasRole('\" + Entitlement.USER_UPDATE + \"')\")\n     @Override\n     public UserTO deprovision(final Long key, final Collection<String> resources) {\n+        // security checks\n+        UserTO user = binder.getUserTO(key);\n+        Set<String> effectiveRealms = getEffectiveRealms(\n+                AuthContextUtils.getAuthorizations().get(Entitlement.USER_UPDATE),\n+                Collections.singleton(user.getRealm()));\n+        securityChecks(effectiveRealms, user.getRealm(), user.getKey());\n+\n         List<PropagationStatus> statuses = provisioningManager.deprovision(key, resources);\n \n         UserTO updatedTO = binder.getUserTO(key);\n@@ -411,10 +482,15 @@ public UserTO provision(\n             final boolean changePwd,\n             final String password) {\n \n-        UserTO original = binder.getUserTO(key);\n-        original.getPropagationStatusTOs().addAll(provisioningManager.provision(key, changePwd, password, resources));\n+        // security checks\n+        UserTO user = binder.getUserTO(key);\n+        Set<String> effectiveRealms = getEffectiveRealms(\n+                AuthContextUtils.getAuthorizations().get(Entitlement.USER_UPDATE),\n+                Collections.singleton(user.getRealm()));\n+        securityChecks(effectiveRealms, user.getRealm(), user.getKey());\n \n-        return original;\n+        user.getPropagationStatusTOs().addAll(provisioningManager.provision(key, changePwd, password, resources));\n+        return user;\n     }\n \n     @Override"},{"sha":"d8bacdbdc36fc04f24a622004189a055937e6bdf","filename":"core/misc/src/main/java/org/apache/syncope/core/misc/RealmUtils.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/bcb9a0d7b0a792eba87046853510376cf4e58131/core%2Fmisc%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fmisc%2FRealmUtils.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/bcb9a0d7b0a792eba87046853510376cf4e58131/core%2Fmisc%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fmisc%2FRealmUtils.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fmisc%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fmisc%2FRealmUtils.java?ref=bcb9a0d7b0a792eba87046853510376cf4e58131","patch":"@@ -24,8 +24,8 @@\n \n public final class RealmUtils {\n \n-    public static String getGroupOwnerRealm(final String realmPath, final Long groupId) {\n-        return realmPath + \"@\" + groupId;\n+    public static String getGroupOwnerRealm(final String realmPath, final Long groupKey) {\n+        return realmPath + \"@\" + groupKey;\n     }\n \n     public static boolean normalizingAddTo(final Set<String> realms, final String newRealm) {"},{"sha":"b2054cb953c7d25019837874bd2a9d2a490759cf","filename":"core/misc/src/main/java/org/apache/syncope/core/misc/security/UnauthorizedException.java","status":"modified","additions":4,"deletions":1,"changes":5,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/bcb9a0d7b0a792eba87046853510376cf4e58131/core%2Fmisc%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fmisc%2Fsecurity%2FUnauthorizedException.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/bcb9a0d7b0a792eba87046853510376cf4e58131/core%2Fmisc%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fmisc%2Fsecurity%2FUnauthorizedException.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fmisc%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fmisc%2Fsecurity%2FUnauthorizedException.java?ref=bcb9a0d7b0a792eba87046853510376cf4e58131","patch":"@@ -25,6 +25,9 @@ public class UnauthorizedException extends RuntimeException {\n     private static final long serialVersionUID = 7540587364235915081L;\n \n     public UnauthorizedException(final AnyTypeKind type, final Long key) {\n-        super(\"Missing entitlement or realm administration for \" + type + \" \" + key);\n+        super(\"Missing entitlement or realm administration for \"\n+                + (key == null\n+                        ? \"new \" + type\n+                        : type + \" \" + key));\n     }\n }"},{"sha":"168241fb236f04cc90455df5a93df588239941b3","filename":"core/persistence-jpa/src/main/java/org/apache/syncope/core/persistence/jpa/dao/JPARoleDAO.java","status":"modified","additions":9,"deletions":0,"changes":9,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/bcb9a0d7b0a792eba87046853510376cf4e58131/core%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fjpa%2Fdao%2FJPARoleDAO.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/bcb9a0d7b0a792eba87046853510376cf4e58131/core%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fjpa%2Fdao%2FJPARoleDAO.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fjpa%2Fdao%2FJPARoleDAO.java?ref=bcb9a0d7b0a792eba87046853510376cf4e58131","patch":"@@ -30,6 +30,7 @@\n import org.apache.syncope.core.persistence.api.entity.Role;\n import org.apache.syncope.core.persistence.api.entity.user.User;\n import org.apache.syncope.core.persistence.jpa.entity.JPARole;\n+import org.apache.syncope.core.persistence.jpa.entity.user.JPAUser;\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.stereotype.Repository;\n import org.springframework.transaction.annotation.Propagation;\n@@ -95,6 +96,14 @@ public Role save(final Role role) {\n \n     @Override\n     public void delete(final Role role) {\n+        TypedQuery<User> query = entityManager().createQuery(\n+                \"SELECT e FROM \" + JPAUser.class.getSimpleName() + \" e WHERE :role MEMBER OF e.roles\", User.class);\n+        query.setParameter(\"role\", role);\n+\n+        for (User user : query.getResultList()) {\n+            user.remove(role);\n+        }\n+\n         entityManager().remove(role);\n     }\n "},{"sha":"9764e07e28559101e33d21cac66f5f1b4c167fa8","filename":"core/persistence-jpa/src/test/java/org/apache/syncope/core/persistence/jpa/outer/RoleTest.java","status":"modified","additions":33,"deletions":0,"changes":33,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/bcb9a0d7b0a792eba87046853510376cf4e58131/core%2Fpersistence-jpa%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fjpa%2Fouter%2FRoleTest.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/bcb9a0d7b0a792eba87046853510376cf4e58131/core%2Fpersistence-jpa%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fjpa%2Fouter%2FRoleTest.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fpersistence-jpa%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fjpa%2Fouter%2FRoleTest.java?ref=bcb9a0d7b0a792eba87046853510376cf4e58131","patch":"@@ -160,4 +160,37 @@ public Long transform(final User input) {\n         dynRoleMemberships = findDynRoleMemberships(user);\n         assertTrue(dynRoleMemberships.isEmpty());\n     }\n+\n+    @Test\n+    public void delete() {\n+        // 0. create role\n+        Role role = entityFactory.newEntity(Role.class);\n+        role.setName(\"new\");\n+        role.addRealm(realmDAO.getRoot());\n+        role.addRealm(realmDAO.find(\"/even/two\"));\n+        role.getEntitlements().add(Entitlement.LOG_LIST);\n+        role.getEntitlements().add(Entitlement.LOG_SET_LEVEL);\n+\n+        role = roleDAO.save(role);\n+        assertNotNull(role);\n+\n+        // 1. create user and assign that role\n+        User user = entityFactory.newEntity(User.class);\n+        user.setUsername(\"username\");\n+        user.setRealm(realmDAO.find(\"/even/two\"));\n+        user.add(role);\n+\n+        user = userDAO.save(user);\n+        assertNotNull(user);\n+\n+        // 2. remove role\n+        roleDAO.delete(role);\n+\n+        userDAO.flush();\n+\n+        // 3. verify that role was removed from user\n+        user = userDAO.find(user.getKey());\n+        assertNotNull(user);\n+        assertTrue(user.getRoles().isEmpty());\n+    }\n }"},{"sha":"4930bbb9baa64a762bd015ab1a0a6d82f6834679","filename":"core/rest-cxf/src/main/java/org/apache/syncope/core/rest/cxf/service/UserSelfServiceImpl.java","status":"modified","additions":3,"deletions":3,"changes":6,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/bcb9a0d7b0a792eba87046853510376cf4e58131/core%2Frest-cxf%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Frest%2Fcxf%2Fservice%2FUserSelfServiceImpl.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/bcb9a0d7b0a792eba87046853510376cf4e58131/core%2Frest-cxf%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Frest%2Fcxf%2Fservice%2FUserSelfServiceImpl.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Frest-cxf%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Frest%2Fcxf%2Fservice%2FUserSelfServiceImpl.java?ref=bcb9a0d7b0a792eba87046853510376cf4e58131","patch":"@@ -48,7 +48,7 @@ public Response create(final UserTO userTO, final boolean storePassword) {\n             throw sce;\n         }\n \n-        UserTO created = logic.createSelf(userTO, storePassword);\n+        UserTO created = logic.selfCreate(userTO, storePassword);\n         return createResponse(created.getKey(), created);\n     }\n \n@@ -64,13 +64,13 @@ public Response read() {\n \n     @Override\n     public Response update(final UserMod userMod) {\n-        UserTO updated = logic.updateSelf(userMod);\n+        UserTO updated = logic.selfUpdate(userMod);\n         return modificationResponse(updated);\n     }\n \n     @Override\n     public Response delete() {\n-        UserTO deleted = logic.deleteSelf();\n+        UserTO deleted = logic.selfDelete();\n         return modificationResponse(deleted);\n     }\n "},{"sha":"cdfd1b11f2ea360c3ed2a9e49d52433241b6a670","filename":"fit/core-reference/src/test/java/org/apache/syncope/fit/core/reference/AuthenticationITCase.java","status":"modified","additions":90,"deletions":1,"changes":91,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/bcb9a0d7b0a792eba87046853510376cf4e58131/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2Freference%2FAuthenticationITCase.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/bcb9a0d7b0a792eba87046853510376cf4e58131/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2Freference%2FAuthenticationITCase.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2Freference%2FAuthenticationITCase.java?ref=bcb9a0d7b0a792eba87046853510376cf4e58131","patch":"@@ -28,7 +28,7 @@\n import java.util.HashSet;\n import java.util.Map;\n import java.util.Set;\n-\n+import javax.ws.rs.core.Response;\n import org.apache.commons.collections4.CollectionUtils;\n import org.apache.commons.collections4.Predicate;\n import org.apache.commons.collections4.Transformer;\n@@ -54,6 +54,7 @@\n import org.apache.syncope.common.lib.types.SchemaType;\n import org.apache.syncope.common.lib.wrap.ResourceKey;\n import org.apache.syncope.common.rest.api.CollectionWrapper;\n+import org.apache.syncope.common.rest.api.RESTHeaders;\n import org.apache.syncope.common.rest.api.service.SchemaService;\n import org.apache.syncope.common.rest.api.service.UserService;\n import org.apache.syncope.core.misc.security.Encryptor;\n@@ -233,6 +234,94 @@ public boolean evaluate(final UserTO matched) {\n         }));\n     }\n \n+    @Test\n+    public void delegatedUserCRUD() {\n+        Long roleKey = null;\n+        Long delegatedAdminKey = null;\n+        try {\n+            // 1. create role for full user administration, under realm /even/two\n+            RoleTO role = new RoleTO();\n+            role.setName(\"Delegated user admin\");\n+            role.getEntitlements().add(Entitlement.USER_CREATE);\n+            role.getEntitlements().add(Entitlement.USER_UPDATE);\n+            role.getEntitlements().add(Entitlement.USER_DELETE);\n+            role.getEntitlements().add(Entitlement.USER_LIST);\n+            role.getEntitlements().add(Entitlement.USER_READ);\n+            role.getRealms().add(\"/even/two\");\n+\n+            roleKey = Long.valueOf(roleService.create(role).getHeaderString(RESTHeaders.RESOURCE_KEY));\n+            assertNotNull(roleKey);\n+\n+            // 2. as admin, create delegated admin user, and assign the role just created\n+            UserTO delegatedAdmin = UserITCase.getUniqueSampleTO(\"admin@syncope.apache.org\");\n+            delegatedAdmin.getRoles().add(roleKey);\n+            delegatedAdmin = createUser(delegatedAdmin);\n+            delegatedAdminKey = delegatedAdmin.getKey();\n+\n+            // 3. instantiate a delegate user service client, for further operatins\n+            UserService delegatedUserService =\n+                    clientFactory.create(delegatedAdmin.getUsername(), \"password123\").getService(UserService.class);\n+\n+            // 4. as delegated, create user under realm / -> fail\n+            UserTO user = UserITCase.getUniqueSampleTO(\"delegated@syncope.apache.org\");\n+            try {\n+                delegatedUserService.create(user);\n+                fail();\n+            } catch (SyncopeClientException e) {\n+                assertEquals(ClientExceptionType.Unauthorized, e.getType());\n+            }\n+\n+            // 5. set realm to /even/two -> succeed\n+            user.setRealm(\"/even/two\");\n+\n+            Response response = delegatedUserService.create(user);\n+            assertEquals(Response.Status.CREATED.getStatusCode(), response.getStatus());\n+\n+            user = response.readEntity(UserTO.class);\n+            assertEquals(\"surname\", user.getPlainAttrMap().get(\"surname\").getValues().get(0));\n+\n+            // 5. as delegated, update user attempting to move under realm / -> fail\n+            UserMod userMod = new UserMod();\n+            userMod.setKey(user.getKey());\n+            userMod.setRealm(\"/odd\");\n+            userMod.getPlainAttrsToRemove().add(\"surname\");\n+            userMod.getPlainAttrsToUpdate().add(attrMod(\"surname\", \"surname2\"));\n+\n+            try {\n+                delegatedUserService.update(userMod);\n+                fail();\n+            } catch (SyncopeClientException e) {\n+                assertEquals(ClientExceptionType.Unauthorized, e.getType());\n+            }\n+\n+            // 6. revert realm change -> succeed\n+            userMod.setRealm(null);\n+\n+            response = delegatedUserService.update(userMod);\n+            assertEquals(Response.Status.OK.getStatusCode(), response.getStatus());\n+\n+            user = response.readEntity(UserTO.class);\n+            assertEquals(\"surname2\", user.getPlainAttrMap().get(\"surname\").getValues().get(0));\n+\n+            // 7. as delegated, delete user\n+            delegatedUserService.delete(user.getKey());\n+\n+            try {\n+                userService.read(user.getKey());\n+                fail();\n+            } catch (SyncopeClientException e) {\n+                assertEquals(ClientExceptionType.NotFound, e.getType());\n+            }\n+        } finally {\n+            if (roleKey != null) {\n+                roleService.delete(roleKey);\n+            }\n+            if (delegatedAdminKey != null) {\n+                userService.delete(delegatedAdminKey);\n+            }\n+        }\n+    }\n+\n     @Test\n     public void checkFailedLogins() {\n         UserTO userTO = UserITCase.getUniqueSampleTO(\"checkFailedLogin@syncope.apache.org\");"}]}