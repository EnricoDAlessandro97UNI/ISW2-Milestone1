{"sha":"00b70d8526cd6b6771b3fedadc34e9174c30733c","node_id":"MDY6Q29tbWl0NjM2ODc5MDYyOjAwYjcwZDg1MjZjZDZiNjc3MWIzZmVkYWRjMzRlOTE3NGMzMDczM2M=","commit":{"author":{"name":"Francesco Chicchiriccò","email":"ilgrosso@apache.org","date":"2019-02-26T08:54:07Z"},"committer":{"name":"Francesco Chicchiriccò","email":"ilgrosso@apache.org","date":"2019-02-26T10:16:02Z"},"message":"[SYNCOPE-1441] Extracted the matches() method from AnySearchDAO and created AnyMatchDAO which does in-memory checks only","tree":{"sha":"88840540163f31154fa8f24ea17b91b41afccee8","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/git/trees/88840540163f31154fa8f24ea17b91b41afccee8"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/git/commits/00b70d8526cd6b6771b3fedadc34e9174c30733c","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/00b70d8526cd6b6771b3fedadc34e9174c30733c","html_url":"https://github.com/EnricoDAlessandro97UNI/syncope/commit/00b70d8526cd6b6771b3fedadc34e9174c30733c","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/00b70d8526cd6b6771b3fedadc34e9174c30733c/comments","author":{"login":"ilgrosso","id":1064664,"node_id":"MDQ6VXNlcjEwNjQ2NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/1064664?v=4","gravatar_id":"","url":"https://api.github.com/users/ilgrosso","html_url":"https://github.com/ilgrosso","followers_url":"https://api.github.com/users/ilgrosso/followers","following_url":"https://api.github.com/users/ilgrosso/following{/other_user}","gists_url":"https://api.github.com/users/ilgrosso/gists{/gist_id}","starred_url":"https://api.github.com/users/ilgrosso/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ilgrosso/subscriptions","organizations_url":"https://api.github.com/users/ilgrosso/orgs","repos_url":"https://api.github.com/users/ilgrosso/repos","events_url":"https://api.github.com/users/ilgrosso/events{/privacy}","received_events_url":"https://api.github.com/users/ilgrosso/received_events","type":"User","site_admin":false},"committer":{"login":"ilgrosso","id":1064664,"node_id":"MDQ6VXNlcjEwNjQ2NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/1064664?v=4","gravatar_id":"","url":"https://api.github.com/users/ilgrosso","html_url":"https://github.com/ilgrosso","followers_url":"https://api.github.com/users/ilgrosso/followers","following_url":"https://api.github.com/users/ilgrosso/following{/other_user}","gists_url":"https://api.github.com/users/ilgrosso/gists{/gist_id}","starred_url":"https://api.github.com/users/ilgrosso/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ilgrosso/subscriptions","organizations_url":"https://api.github.com/users/ilgrosso/orgs","repos_url":"https://api.github.com/users/ilgrosso/repos","events_url":"https://api.github.com/users/ilgrosso/events{/privacy}","received_events_url":"https://api.github.com/users/ilgrosso/received_events","type":"User","site_admin":false},"parents":[{"sha":"9fc6c19691495d52a2cc62641da536d29ebaada7","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/9fc6c19691495d52a2cc62641da536d29ebaada7","html_url":"https://github.com/EnricoDAlessandro97UNI/syncope/commit/9fc6c19691495d52a2cc62641da536d29ebaada7"}],"stats":{"total":1071,"additions":778,"deletions":293},"files":[{"sha":"dd72fa4033fdf2025c356b5dded3c0f06330a781","filename":"core/persistence-api/src/main/java/org/apache/syncope/core/persistence/api/dao/AnyMatchDAO.java","status":"added","additions":35,"deletions":0,"changes":35,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/00b70d8526cd6b6771b3fedadc34e9174c30733c/core%2Fpersistence-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fapi%2Fdao%2FAnyMatchDAO.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/00b70d8526cd6b6771b3fedadc34e9174c30733c/core%2Fpersistence-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fapi%2Fdao%2FAnyMatchDAO.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fpersistence-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fapi%2Fdao%2FAnyMatchDAO.java?ref=00b70d8526cd6b6771b3fedadc34e9174c30733c","patch":"@@ -0,0 +1,35 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.core.persistence.api.dao;\n+\n+import org.apache.syncope.core.persistence.api.dao.search.SearchCond;\n+import org.apache.syncope.core.persistence.api.entity.Any;\n+\n+public interface AnyMatchDAO extends DAO<Any<?>> {\n+\n+    /**\n+     * Verify if any matches the given search condition.\n+     *\n+     * @param any to be checked\n+     * @param cond to be verified\n+     * @param <T> any\n+     * @return true if any matches cond\n+     */\n+    <T extends Any<?>> boolean matches(T any, SearchCond cond);\n+}"},{"sha":"8d0de626a98c16832eeef0672932fab7909056c8","filename":"core/persistence-api/src/main/java/org/apache/syncope/core/persistence/api/dao/AnySearchDAO.java","status":"modified","additions":0,"deletions":10,"changes":10,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/00b70d8526cd6b6771b3fedadc34e9174c30733c/core%2Fpersistence-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fapi%2Fdao%2FAnySearchDAO.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/00b70d8526cd6b6771b3fedadc34e9174c30733c/core%2Fpersistence-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fapi%2Fdao%2FAnySearchDAO.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fpersistence-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fapi%2Fdao%2FAnySearchDAO.java?ref=00b70d8526cd6b6771b3fedadc34e9174c30733c","patch":"@@ -65,14 +65,4 @@ public interface AnySearchDAO extends DAO<Any<?>> {\n     <T extends Any<?>> List<T> search(\n             Set<String> adminRealms, SearchCond searchCondition, int page, int itemsPerPage,\n             List<OrderByClause> orderBy, AnyTypeKind kind);\n-\n-    /**\n-     * Verify if any matches the given search condition.\n-     *\n-     * @param any to be checked\n-     * @param searchCondition to be verified\n-     * @param <T> any\n-     * @return true if any matches searchCondition\n-     */\n-    <T extends Any<?>> boolean matches(T any, SearchCond searchCondition);\n }"},{"sha":"6268318f66de5c524ace2cad2dc1fc193566d626","filename":"core/persistence-api/src/main/java/org/apache/syncope/core/persistence/api/dao/DynRealmDAO.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/00b70d8526cd6b6771b3fedadc34e9174c30733c/core%2Fpersistence-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fapi%2Fdao%2FDynRealmDAO.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/00b70d8526cd6b6771b3fedadc34e9174c30733c/core%2Fpersistence-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fapi%2Fdao%2FDynRealmDAO.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fpersistence-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fapi%2Fdao%2FDynRealmDAO.java?ref=00b70d8526cd6b6771b3fedadc34e9174c30733c","patch":"@@ -38,6 +38,6 @@ public interface DynRealmDAO extends DAO<DynRealm> {\n \n     void refreshDynMemberships(Any<?> any);\n \n-    void removeDynMemberships(String key);\n+    void removeDynMemberships(String anyKey);\n \n }"},{"sha":"cc17e32512da5c95c900d1b6c7e450a695409ffc","filename":"core/persistence-jpa/src/main/java/org/apache/syncope/core/persistence/jpa/dao/AbstractAnySearchDAO.java","status":"modified","additions":0,"deletions":8,"changes":8,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/00b70d8526cd6b6771b3fedadc34e9174c30733c/core%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fjpa%2Fdao%2FAbstractAnySearchDAO.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/00b70d8526cd6b6771b3fedadc34e9174c30733c/core%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fjpa%2Fdao%2FAbstractAnySearchDAO.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fjpa%2Fdao%2FAbstractAnySearchDAO.java?ref=00b70d8526cd6b6771b3fedadc34e9174c30733c","patch":"@@ -353,12 +353,4 @@ public <T extends Any<?>> List<T> search(\n \n         return doSearch(adminRealms, cond, page, itemsPerPage, effectiveOrderBy, kind);\n     }\n-\n-    @Override\n-    public <T extends Any<?>> boolean matches(final T any, final SearchCond cond) {\n-        AnyCond keycond = new AnyCond(AttributeCond.Type.EQ);\n-        keycond.setSchema(\"key\");\n-        keycond.setExpression(any.getKey());\n-        return !search(SearchCond.getAndCond(SearchCond.getLeafCond(keycond), cond), any.getType().getKind()).isEmpty();\n-    }\n }"},{"sha":"1905dc08f348a71a6b9afdd5c64c8d1f7cb94599","filename":"core/persistence-jpa/src/main/java/org/apache/syncope/core/persistence/jpa/dao/JPAAnyMatchDAO.java","status":"added","additions":440,"deletions":0,"changes":440,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/00b70d8526cd6b6771b3fedadc34e9174c30733c/core%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fjpa%2Fdao%2FJPAAnyMatchDAO.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/00b70d8526cd6b6771b3fedadc34e9174c30733c/core%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fjpa%2Fdao%2FJPAAnyMatchDAO.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fjpa%2Fdao%2FJPAAnyMatchDAO.java?ref=00b70d8526cd6b6771b3fedadc34e9174c30733c","patch":"@@ -0,0 +1,440 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.core.persistence.jpa.dao;\n+\n+import java.beans.PropertyDescriptor;\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.regex.Pattern;\n+import javax.persistence.Entity;\n+import javax.validation.ValidationException;\n+import javax.validation.constraints.Max;\n+import javax.validation.constraints.Min;\n+import org.apache.commons.lang3.ClassUtils;\n+import org.apache.syncope.common.lib.SyncopeConstants;\n+import org.apache.syncope.common.lib.types.AnyTypeKind;\n+import org.apache.syncope.common.lib.types.AttrSchemaType;\n+import org.apache.syncope.core.persistence.api.dao.AnyObjectDAO;\n+import org.apache.syncope.core.persistence.api.dao.GroupDAO;\n+import org.apache.syncope.core.persistence.api.dao.RealmDAO;\n+import org.apache.syncope.core.persistence.api.dao.UserDAO;\n+import org.apache.syncope.core.persistence.api.dao.search.AnyCond;\n+import org.apache.syncope.core.persistence.api.dao.search.AnyTypeCond;\n+import org.apache.syncope.core.persistence.api.dao.search.AssignableCond;\n+import org.apache.syncope.core.persistence.api.dao.search.AttributeCond;\n+import org.apache.syncope.core.persistence.api.dao.search.DynRealmCond;\n+import org.apache.syncope.core.persistence.api.dao.search.MemberCond;\n+import org.apache.syncope.core.persistence.api.dao.search.MembershipCond;\n+import org.apache.syncope.core.persistence.api.dao.search.RelationshipCond;\n+import org.apache.syncope.core.persistence.api.dao.search.RelationshipTypeCond;\n+import org.apache.syncope.core.persistence.api.dao.search.ResourceCond;\n+import org.apache.syncope.core.persistence.api.dao.search.RoleCond;\n+import org.apache.syncope.core.persistence.api.dao.search.SearchCond;\n+import org.apache.syncope.core.persistence.api.entity.Any;\n+import org.apache.syncope.core.persistence.api.entity.AnyUtils;\n+import org.apache.syncope.core.persistence.api.entity.AnyUtilsFactory;\n+import org.apache.syncope.core.persistence.api.entity.GroupableRelatable;\n+import org.apache.syncope.core.persistence.api.entity.PlainAttr;\n+import org.apache.syncope.core.persistence.api.entity.Realm;\n+import org.apache.syncope.core.persistence.api.entity.group.Group;\n+import org.apache.syncope.core.persistence.api.entity.user.User;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Component;\n+import org.springframework.transaction.annotation.Transactional;\n+import org.apache.syncope.core.persistence.api.dao.AnyMatchDAO;\n+import org.apache.syncope.core.persistence.api.dao.PlainSchemaDAO;\n+import org.apache.syncope.core.persistence.api.entity.PlainAttrValue;\n+import org.apache.syncope.core.persistence.api.entity.PlainSchema;\n+import org.apache.syncope.core.persistence.jpa.entity.JPAPlainSchema;\n+import org.springframework.beans.BeanUtils;\n+\n+@Component\n+public class JPAAnyMatchDAO extends AbstractDAO<Any<?>> implements AnyMatchDAO {\n+\n+    @Autowired\n+    private UserDAO userDAO;\n+\n+    @Autowired\n+    private GroupDAO groupDAO;\n+\n+    @Autowired\n+    private AnyObjectDAO anyObjectDAO;\n+\n+    @Autowired\n+    private RealmDAO realmDAO;\n+\n+    @Autowired\n+    private PlainSchemaDAO plainSchemaDAO;\n+\n+    @Autowired\n+    private AnyUtilsFactory anyUtilsFactory;\n+\n+    /**\n+     * Verify if any matches the given search condition.\n+     *\n+     * @param any to be checked\n+     * @param cond to be verified\n+     * @param <T> any\n+     * @return true if any matches cond\n+     */\n+    @Transactional(readOnly = true)\n+    @Override\n+    public <T extends Any<?>> boolean matches(final T any, final SearchCond cond) {\n+        boolean not = cond.getType() == SearchCond.Type.NOT_LEAF;\n+        switch (cond.getType()) {\n+            case LEAF:\n+            case NOT_LEAF:\n+                if (cond.getAnyTypeCond() != null && AnyTypeKind.ANY_OBJECT == any.getType().getKind()) {\n+                    return matches(any, cond.getAnyTypeCond(), not);\n+                } else if (cond.getRelationshipTypeCond() != null && any instanceof GroupableRelatable) {\n+                    return matches((GroupableRelatable) any, cond.getRelationshipTypeCond(), not);\n+                } else if (cond.getRelationshipCond() != null && any instanceof GroupableRelatable) {\n+                    return matches((GroupableRelatable) any, cond.getRelationshipCond(), not);\n+                } else if (cond.getMembershipCond() != null && any instanceof GroupableRelatable) {\n+                    return matches((GroupableRelatable) any, cond.getMembershipCond(), not);\n+                } else if (cond.getAssignableCond() != null) {\n+                    return matches(any, cond.getAssignableCond(), not);\n+                } else if (cond.getRoleCond() != null && any instanceof User) {\n+                    return matches((User) any, cond.getRoleCond(), not);\n+                } else if (cond.getDynRealmCond() != null) {\n+                    return matches(any, cond.getDynRealmCond(), not);\n+                } else if (cond.getMemberCond() != null && any instanceof Group) {\n+                    return matches((Group) any, cond.getMemberCond(), not);\n+                } else if (cond.getResourceCond() != null) {\n+                    return matches(any, cond.getResourceCond(), not);\n+                } else if (cond.getAttributeCond() != null) {\n+                    return matches(any, cond.getAttributeCond(), not);\n+                } else if (cond.getAnyCond() != null) {\n+                    return matches(any, cond.getAnyCond(), not);\n+                }\n+                break;\n+\n+            case AND:\n+                return matches(any, cond.getLeftSearchCond()) && matches(any, cond.getRightSearchCond());\n+\n+            case OR:\n+                return matches(any, cond.getLeftSearchCond()) || matches(any, cond.getRightSearchCond());\n+\n+            default:\n+        }\n+\n+        return false;\n+    }\n+\n+    private boolean matches(final Any<?> any, final AnyTypeCond cond, final boolean not) {\n+        boolean equals = any.getType().getKey().equals(cond.getAnyTypeKey());\n+        return not ? !equals : equals;\n+    }\n+\n+    private boolean matches(\n+            final GroupableRelatable<?, ?, ?, ?, ?> any, final RelationshipTypeCond cond, final boolean not) {\n+\n+        boolean found = any.getRelationships().stream().\n+                anyMatch(rel -> rel.getType().getKey().equals(cond.getRelationshipTypeKey()));\n+        return not ? !found : found;\n+    }\n+\n+    private boolean matches(\n+            final GroupableRelatable<?, ?, ?, ?, ?> any, final RelationshipCond cond, final boolean not) {\n+\n+        String anyObject = cond.getAnyObject();\n+        if (!SyncopeConstants.UUID_PATTERN.matcher(cond.getAnyObject()).matches()) {\n+            anyObject = anyObjectDAO.findKey(anyObject);\n+        }\n+\n+        boolean found = !any.getRelationships(anyObject).isEmpty();\n+        return not ? !found : found;\n+    }\n+\n+    private boolean matches(\n+            final GroupableRelatable<?, ?, ?, ?, ?> any, final MembershipCond cond, final boolean not) {\n+\n+        final String group = SyncopeConstants.UUID_PATTERN.matcher(cond.getGroup()).matches()\n+                ? cond.getGroup()\n+                : groupDAO.findKey(cond.getGroup());\n+\n+        boolean found = any.getMembership(group).isPresent()\n+                || (any instanceof User\n+                        ? userDAO.findDynGroups(any.getKey())\n+                        : anyObjectDAO.findDynGroups(any.getKey())).stream().\n+                        anyMatch(item -> item.getKey().equals(group));\n+        return not ? !found : found;\n+    }\n+\n+    private boolean matches(final Any<?> any, final AssignableCond cond, final boolean not) {\n+        Realm realm = realmDAO.findByFullPath(cond.getRealmFullPath());\n+        boolean found = realm == null\n+                ? false\n+                : (cond.isFromGroup() ? realmDAO.findDescendants(realm) : realmDAO.findAncestors(realm)).\n+                        stream().anyMatch(item -> item.equals(any.getRealm()));\n+        return not ? !found : found;\n+    }\n+\n+    private boolean matches(final User user, final RoleCond cond, final boolean not) {\n+        boolean found = userDAO.findAllRoles(user).stream().anyMatch(role -> role.getKey().equals(cond.getRole()));\n+        return not ? !found : found;\n+    }\n+\n+    private boolean matches(final Any<?> any, final DynRealmCond cond, final boolean not) {\n+        boolean found = anyUtilsFactory.getInstance(any).dao().findDynRealms(any.getKey()).stream().\n+                anyMatch(dynRealm -> dynRealm.equals(cond.getDynRealm()));\n+        return not ? !found : found;\n+    }\n+\n+    private boolean matches(final Group group, final MemberCond cond, final boolean not) {\n+        boolean found = false;\n+\n+        GroupableRelatable<?, ?, ?, ?, ?> any = userDAO.find(cond.getMember());\n+        if (any == null) {\n+            any = anyObjectDAO.find(cond.getMember());\n+            if (any != null) {\n+                found = groupDAO.findAMemberships(group).stream().\n+                        anyMatch(memb -> memb.getLeftEnd().getKey().equals(cond.getMember()))\n+                        || groupDAO.findADynMembers(group).contains(cond.getMember());\n+            }\n+        } else {\n+            found = groupDAO.findUMemberships(group).stream().\n+                    anyMatch(memb -> memb.getLeftEnd().getKey().equals(cond.getMember()))\n+                    || groupDAO.findUDynMembers(group).contains(cond.getMember());\n+        }\n+\n+        return not ? !found : found;\n+    }\n+\n+    private boolean matches(final Any<?> any, final ResourceCond cond, final boolean not) {\n+        boolean found = anyUtilsFactory.getInstance(any).getAllResources(any).stream().\n+                anyMatch(resource -> resource.getKey().equals(cond.getResourceKey()));\n+        return not ? !found : found;\n+    }\n+\n+    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+    private boolean matches(\n+            final List<? extends PlainAttrValue> anyAttrValues,\n+            final PlainAttrValue attrValue,\n+            final PlainSchema schema,\n+            final AttributeCond cond) {\n+\n+        return anyAttrValues.stream().anyMatch(item -> {\n+            switch (cond.getType()) {\n+                case EQ:\n+                    return attrValue.getValue().equals(item.getValue());\n+\n+                case IEQ:\n+                    if (schema.getType() == AttrSchemaType.String || schema.getType() == AttrSchemaType.Enum) {\n+                        return attrValue.getStringValue().equalsIgnoreCase(item.getStringValue());\n+                    } else {\n+                        LOG.error(\"IEQ is only compatible with string or enum schemas\");\n+                        return false;\n+                    }\n+\n+                case LIKE:\n+                case ILIKE:\n+                    if (schema.getType() == AttrSchemaType.String || schema.getType() == AttrSchemaType.Enum) {\n+                        StringBuilder output = new StringBuilder();\n+                        for (char c : cond.getExpression().toLowerCase().toCharArray()) {\n+                            if (c == '%') {\n+                                output.append(\".*\");\n+                            } else if (Character.isLetter(c)) {\n+                                output.append('[').\n+                                        append(c).\n+                                        append(Character.toUpperCase(c)).\n+                                        append(']');\n+                            } else {\n+                                output.append(c);\n+                            }\n+                        }\n+                        return (cond.getType() == AttributeCond.Type.LIKE\n+                                ? Pattern.compile(output.toString())\n+                                : Pattern.compile(output.toString(), Pattern.CASE_INSENSITIVE)).\n+                                matcher(item.getStringValue()).matches();\n+                    } else {\n+                        LOG.error(\"LIKE is only compatible with string or enum schemas\");\n+                        return false;\n+                    }\n+\n+                case GT:\n+                    return item.<Comparable>getValue().compareTo(attrValue.getValue()) > 0;\n+\n+                case GE:\n+                    return item.<Comparable>getValue().compareTo(attrValue.getValue()) >= 0;\n+\n+                case LT:\n+                    return item.<Comparable>getValue().compareTo(attrValue.getValue()) < 0;\n+\n+                case LE:\n+                    return item.<Comparable>getValue().compareTo(attrValue.getValue()) <= 0;\n+\n+                default:\n+                    return false;\n+            }\n+        });\n+    }\n+\n+    private boolean matches(final Any<?> any, final AttributeCond cond, final boolean not) {\n+        PlainSchema schema = plainSchemaDAO.find(cond.getSchema());\n+        if (schema == null) {\n+            LOG.warn(\"Ignoring invalid schema '{}'\", cond.getSchema());\n+            return false;\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        Optional<PlainAttr<?>> attr = (Optional<PlainAttr<?>>) any.getPlainAttr(cond.getSchema());\n+\n+        boolean found;\n+        switch (cond.getType()) {\n+            case ISNULL:\n+                found = attr.isEmpty();\n+                break;\n+\n+            case ISNOTNULL:\n+                found = attr.isPresent();\n+                break;\n+\n+            default:\n+                PlainAttrValue attrValue = anyUtilsFactory.getInstance(any).newPlainAttrValue();\n+                try {\n+                    if (cond.getType() != AttributeCond.Type.LIKE\n+                            && cond.getType() != AttributeCond.Type.ILIKE\n+                            && cond.getType() != AttributeCond.Type.ISNULL\n+                            && cond.getType() != AttributeCond.Type.ISNOTNULL) {\n+\n+                        ((JPAPlainSchema) schema).validator().validate(cond.getExpression(), attrValue);\n+                    }\n+                } catch (ValidationException e) {\n+                    LOG.error(\"Could not validate expression '\" + cond.getExpression() + \"'\", e);\n+                    return false;\n+                }\n+\n+                found = attr.isPresent() && matches(attr.get().getValues(), attrValue, schema, cond);\n+        }\n+        return not ? !found : found;\n+    }\n+\n+    private boolean matches(final Any<?> any, final AnyCond cond, final boolean not) {\n+        // Keeps track of difference between entity's getKey() and JPA @Id fields\n+        if (\"key\".equals(cond.getSchema())) {\n+            cond.setSchema(\"id\");\n+        }\n+\n+        PropertyDescriptor pd;\n+        Object anyAttrValue;\n+        try {\n+            pd = BeanUtils.getPropertyDescriptor(any.getClass(), cond.getSchema());\n+            if (pd == null) {\n+                LOG.warn(\"Ignoring invalid schema '{}'\", cond.getSchema());\n+                return false;\n+            }\n+\n+            anyAttrValue = pd.getReadMethod().invoke(any);\n+        } catch (Exception e) {\n+            LOG.error(\"While accessing {}.{}\", any, cond.getSchema(), e);\n+            return false;\n+        }\n+\n+        boolean found;\n+        switch (cond.getType()) {\n+            case ISNULL:\n+                found = anyAttrValue == null;\n+                break;\n+\n+            case ISNOTNULL:\n+                found = anyAttrValue != null;\n+                break;\n+\n+            default:\n+                PlainSchema schema = new JPAPlainSchema();\n+                schema.setKey(pd.getName());\n+                for (AttrSchemaType attrSchemaType : AttrSchemaType.values()) {\n+                    if (pd.getPropertyType().isAssignableFrom(attrSchemaType.getType())) {\n+                        schema.setType(attrSchemaType);\n+                    }\n+                }\n+\n+                // Deal with any Integer fields logically mapping to boolean values\n+                boolean foundBooleanMin = false;\n+                boolean foundBooleanMax = false;\n+                if (Integer.class.equals(pd.getPropertyType())) {\n+                    for (Annotation annotation : pd.getPropertyType().getAnnotations()) {\n+                        if (Min.class.equals(annotation.annotationType())) {\n+                            foundBooleanMin = ((Min) annotation).value() == 0;\n+                        } else if (Max.class.equals(annotation.annotationType())) {\n+                            foundBooleanMax = ((Max) annotation).value() == 1;\n+                        }\n+                    }\n+                }\n+                if (foundBooleanMin && foundBooleanMax) {\n+                    schema.setType(AttrSchemaType.Boolean);\n+                }\n+\n+                // Deal with any fields representing relationships to other entities\n+                if (pd.getPropertyType().getAnnotation(Entity.class) != null) {\n+                    Method relMethod = null;\n+                    try {\n+                        relMethod = ClassUtils.getPublicMethod(pd.getPropertyType(), \"getKey\", new Class<?>[0]);\n+                    } catch (Exception e) {\n+                        LOG.error(\"Could not find {}#getKey\", pd.getPropertyType(), e);\n+                    }\n+\n+                    if (relMethod != null && String.class.isAssignableFrom(relMethod.getReturnType())) {\n+                        cond.setSchema(cond.getSchema() + \"_id\");\n+                        schema.setType(AttrSchemaType.String);\n+                    }\n+                }\n+\n+                AnyUtils anyUtils = anyUtilsFactory.getInstance(any);\n+\n+                PlainAttrValue attrValue = anyUtils.newPlainAttrValue();\n+                if (cond.getType() != AttributeCond.Type.LIKE\n+                        && cond.getType() != AttributeCond.Type.ILIKE\n+                        && cond.getType() != AttributeCond.Type.ISNULL\n+                        && cond.getType() != AttributeCond.Type.ISNOTNULL) {\n+\n+                    try {\n+                        ((JPAPlainSchema) schema).validator().validate(cond.getExpression(), attrValue);\n+                    } catch (ValidationException e) {\n+                        LOG.error(\"Could not validate expression '\" + cond.getExpression() + \"'\", e);\n+                        return false;\n+                    }\n+                }\n+\n+                List<PlainAttrValue> anyAttrValues = new ArrayList<>();\n+                anyAttrValues.add(anyUtils.newPlainAttrValue());\n+                if (anyAttrValue instanceof String) {\n+                    anyAttrValues.get(0).setStringValue((String) anyAttrValue);\n+                } else if (anyAttrValue instanceof Long) {\n+                    anyAttrValues.get(0).setLongValue((Long) anyAttrValue);\n+                } else if (anyAttrValue instanceof Double) {\n+                    anyAttrValues.get(0).setDoubleValue((Double) anyAttrValue);\n+                } else if (anyAttrValue instanceof Boolean) {\n+                    anyAttrValues.get(0).setBooleanValue((Boolean) anyAttrValue);\n+                } else if (anyAttrValue instanceof Date) {\n+                    anyAttrValues.get(0).setDateValue((Date) anyAttrValue);\n+                } else if (anyAttrValue instanceof byte[]) {\n+                    anyAttrValues.get(0).setBinaryValue((byte[]) anyAttrValue);\n+                }\n+\n+                found = matches(anyAttrValues, attrValue, schema, cond);\n+        }\n+        return not ? !found : found;\n+    }\n+}"},{"sha":"f519536ebcffaa154bf9ebf01a3e2a9140ed2d9b","filename":"core/persistence-jpa/src/main/java/org/apache/syncope/core/persistence/jpa/dao/JPAAnySearchDAO.java","status":"modified","additions":14,"deletions":23,"changes":37,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/00b70d8526cd6b6771b3fedadc34e9174c30733c/core%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fjpa%2Fdao%2FJPAAnySearchDAO.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/00b70d8526cd6b6771b3fedadc34e9174c30733c/core%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fjpa%2Fdao%2FJPAAnySearchDAO.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fjpa%2Fdao%2FJPAAnySearchDAO.java?ref=00b70d8526cd6b6771b3fedadc34e9174c30733c","patch":"@@ -422,58 +422,49 @@ private OrderBySupport parseOrderBy(\n     private Pair<StringBuilder, Set<String>> getQuery(\n             final SearchCond cond, final List<Object> parameters, final SearchSupport svs) {\n \n+        boolean not = cond.getType() == SearchCond.Type.NOT_LEAF;\n+\n         StringBuilder query = new StringBuilder();\n         Set<String> involvedPlainAttrs = new HashSet<>();\n \n         switch (cond.getType()) {\n             case LEAF:\n             case NOT_LEAF:\n                 if (cond.getAnyTypeCond() != null && AnyTypeKind.ANY_OBJECT == svs.anyTypeKind) {\n-                    query.append(getQuery(cond.getAnyTypeCond(),\n-                            cond.getType() == SearchCond.Type.NOT_LEAF, parameters, svs));\n+                    query.append(getQuery(cond.getAnyTypeCond(), not, parameters, svs));\n                 } else if (cond.getRelationshipTypeCond() != null\n                         && (AnyTypeKind.USER == svs.anyTypeKind || AnyTypeKind.ANY_OBJECT == svs.anyTypeKind)) {\n \n-                    query.append(getQuery(cond.getRelationshipTypeCond(),\n-                            cond.getType() == SearchCond.Type.NOT_LEAF, parameters, svs));\n+                    query.append(getQuery(cond.getRelationshipTypeCond(), not, parameters, svs));\n                 } else if (cond.getRelationshipCond() != null\n                         && (AnyTypeKind.USER == svs.anyTypeKind || AnyTypeKind.ANY_OBJECT == svs.anyTypeKind)) {\n \n-                    query.append(getQuery(cond.getRelationshipCond(),\n-                            cond.getType() == SearchCond.Type.NOT_LEAF, parameters, svs));\n+                    query.append(getQuery(cond.getRelationshipCond(), not, parameters, svs));\n                 } else if (cond.getMembershipCond() != null\n                         && (AnyTypeKind.USER == svs.anyTypeKind || AnyTypeKind.ANY_OBJECT == svs.anyTypeKind)) {\n \n-                    query.append(getQuery(cond.getMembershipCond(),\n-                            cond.getType() == SearchCond.Type.NOT_LEAF, parameters, svs));\n+                    query.append(getQuery(cond.getMembershipCond(), not, parameters, svs));\n                 } else if (cond.getAssignableCond() != null) {\n                     query.append(getQuery(cond.getAssignableCond(), parameters, svs));\n                 } else if (cond.getRoleCond() != null && AnyTypeKind.USER == svs.anyTypeKind) {\n-                    query.append(getQuery(cond.getRoleCond(),\n-                            cond.getType() == SearchCond.Type.NOT_LEAF, parameters, svs));\n+                    query.append(getQuery(cond.getRoleCond(), not, parameters, svs));\n                 } else if (cond.getPrivilegeCond() != null && AnyTypeKind.USER == svs.anyTypeKind) {\n-                    query.append(getQuery(cond.getPrivilegeCond(),\n-                            cond.getType() == SearchCond.Type.NOT_LEAF, parameters, svs));\n+                    query.append(getQuery(cond.getPrivilegeCond(), not, parameters, svs));\n                 } else if (cond.getDynRealmCond() != null) {\n-                    query.append(getQuery(cond.getDynRealmCond(),\n-                            cond.getType() == SearchCond.Type.NOT_LEAF, parameters, svs));\n+                    query.append(getQuery(cond.getDynRealmCond(), not, parameters, svs));\n                 } else if (cond.getMemberCond() != null && AnyTypeKind.GROUP == svs.anyTypeKind) {\n-                    query.append(getQuery(cond.getMemberCond(),\n-                            cond.getType() == SearchCond.Type.NOT_LEAF, parameters, svs));\n+                    query.append(getQuery(cond.getMemberCond(), not, parameters, svs));\n                 } else if (cond.getResourceCond() != null) {\n-                    query.append(getQuery(cond.getResourceCond(),\n-                            cond.getType() == SearchCond.Type.NOT_LEAF, parameters, svs));\n+                    query.append(getQuery(cond.getResourceCond(), not, parameters, svs));\n                 } else if (cond.getAttributeCond() != null) {\n-                    query.append(getQuery(cond.getAttributeCond(),\n-                            cond.getType() == SearchCond.Type.NOT_LEAF, parameters, svs));\n+                    query.append(getQuery(cond.getAttributeCond(), not, parameters, svs));\n                     try {\n                         involvedPlainAttrs.add(check(cond.getAttributeCond(), svs.anyTypeKind).getLeft().getKey());\n                     } catch (IllegalArgumentException e) {\n                         // ignore\n                     }\n                 } else if (cond.getAnyCond() != null) {\n-                    query.append(getQuery(cond.getAnyCond(),\n-                            cond.getType() == SearchCond.Type.NOT_LEAF, parameters, svs));\n+                    query.append(getQuery(cond.getAnyCond(), not, parameters, svs));\n                 }\n                 break;\n \n@@ -743,7 +734,7 @@ protected String getQuery(\n                 append(\" WHERE resource_id=?\").\n                 append(setParameter(parameters, cond.getResourceKey()));\n \n-        if (svs.anyTypeKind == AnyTypeKind.USER) {\n+        if (svs.anyTypeKind == AnyTypeKind.USER || svs.anyTypeKind == AnyTypeKind.ANY_OBJECT) {\n             query.append(\" UNION SELECT DISTINCT any_id FROM \").\n                     append(svs.groupResource().name).\n                     append(\" WHERE resource_id=?\")."},{"sha":"c093591c9e6c3ae2ba03d627ff0c6de68377cbbe","filename":"core/persistence-jpa/src/main/java/org/apache/syncope/core/persistence/jpa/dao/JPADynRealmDAO.java","status":"modified","additions":23,"deletions":38,"changes":61,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/00b70d8526cd6b6771b3fedadc34e9174c30733c/core%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fjpa%2Fdao%2FJPADynRealmDAO.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/00b70d8526cd6b6771b3fedadc34e9174c30733c/core%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fjpa%2Fdao%2FJPADynRealmDAO.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fjpa%2Fdao%2FJPADynRealmDAO.java?ref=00b70d8526cd6b6771b3fedadc34e9174c30733c","patch":"@@ -19,26 +19,21 @@\n package org.apache.syncope.core.persistence.jpa.dao;\n \n import java.util.List;\n-import java.util.Optional;\n import javax.persistence.Query;\n import javax.persistence.TypedQuery;\n import org.apache.syncope.core.persistence.api.dao.AnySearchDAO;\n import org.apache.syncope.core.persistence.api.dao.DynRealmDAO;\n import org.apache.syncope.core.persistence.api.entity.Any;\n import org.apache.syncope.core.persistence.api.entity.DynRealm;\n-import org.apache.syncope.core.persistence.api.entity.DynRealmMembership;\n-import org.apache.syncope.core.persistence.api.entity.EntityFactory;\n import org.apache.syncope.core.persistence.api.search.SearchCondConverter;\n import org.apache.syncope.core.persistence.jpa.entity.JPADynRealm;\n import org.apache.syncope.core.provisioning.api.event.AnyCreatedUpdatedEvent;\n-import org.apache.syncope.core.spring.ApplicationContextProvider;\n import org.apache.syncope.core.spring.security.AuthContextUtils;\n-import org.springframework.aop.support.AopUtils;\n import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.beans.factory.support.AbstractBeanDefinition;\n import org.springframework.context.ApplicationEventPublisher;\n import org.springframework.stereotype.Repository;\n import org.springframework.transaction.annotation.Transactional;\n+import org.apache.syncope.core.persistence.api.dao.AnyMatchDAO;\n \n @Repository\n public class JPADynRealmDAO extends AbstractDAO<DynRealm> implements DynRealmDAO {\n@@ -48,27 +43,11 @@ public class JPADynRealmDAO extends AbstractDAO<DynRealm> implements DynRealmDAO\n     @Autowired\n     private ApplicationEventPublisher publisher;\n \n-    @Autowired\n-    private EntityFactory entityFactory;\n-\n     @Autowired\n     private AnySearchDAO searchDAO;\n \n-    private AnySearchDAO jpaAnySearchDAO;\n-\n-    private AnySearchDAO jpaAnySearchDAO() {\n-        synchronized (this) {\n-            if (jpaAnySearchDAO == null) {\n-                if (AopUtils.getTargetClass(searchDAO).equals(entityFactory.anySearchDAOClass())) {\n-                    jpaAnySearchDAO = searchDAO;\n-                } else {\n-                    jpaAnySearchDAO = (AnySearchDAO) ApplicationContextProvider.getBeanFactory().createBean(\n-                            entityFactory.anySearchDAOClass(), AbstractBeanDefinition.AUTOWIRE_BY_TYPE, true);\n-                }\n-            }\n-        }\n-        return jpaAnySearchDAO;\n-    }\n+    @Autowired\n+    private AnyMatchDAO anyMatchDAO;\n \n     @Override\n     public DynRealm find(final String key) {\n@@ -94,9 +73,9 @@ public DynRealm saveAndRefreshDynMemberships(final DynRealm dynRealm) {\n         // refresh dynamic memberships\n         clearDynMembers(merged);\n \n-        merged.getDynMemberships().stream().map(memb -> jpaAnySearchDAO().search(\n+        merged.getDynMemberships().stream().map(memb -> searchDAO.search(\n                 SearchCondConverter.convert(memb.getFIQLCond()), memb.getAnyType().getKind())).\n-                forEachOrdered(matching -> {\n+                forEach(matching -> {\n                     matching.forEach(any -> {\n                         Query insert = entityManager().createNativeQuery(\n                                 \"INSERT INTO \" + DYNMEMB_TABLE + \" VALUES(?, ?)\");\n@@ -133,28 +112,34 @@ public void clearDynMembers(final DynRealm dynRealm) {\n     @Transactional\n     @Override\n     public void refreshDynMemberships(final Any<?> any) {\n-        findAll().forEach(dynRealm -> {\n-            Optional<? extends DynRealmMembership> memb = dynRealm.getDynMembership(any.getType());\n-            if (memb.isPresent()) {\n+        findAll().forEach(dynRealm -> dynRealm.getDynMembership(any.getType()).ifPresent(memb -> {\n+            boolean matches = anyMatchDAO.matches(any, SearchCondConverter.convert(memb.getFIQLCond()));\n+\n+            Query find = entityManager().createNativeQuery(\n+                    \"SELECT dynRealm_id FROM \" + JPADynRealmDAO.DYNMEMB_TABLE + \" WHERE any_id=?\");\n+            find.setParameter(1, any.getKey());\n+            boolean existing = !find.getResultList().isEmpty();\n+\n+            if (matches && !existing) {\n+                Query insert = entityManager().\n+                        createNativeQuery(\"INSERT INTO \" + DYNMEMB_TABLE + \" VALUES(?, ?)\");\n+                insert.setParameter(1, any.getKey());\n+                insert.setParameter(2, dynRealm.getKey());\n+                insert.executeUpdate();\n+            } else if (!matches && existing) {\n                 Query delete = entityManager().createNativeQuery(\n                         \"DELETE FROM \" + DYNMEMB_TABLE + \" WHERE dynRealm_id=? AND any_id=?\");\n                 delete.setParameter(1, dynRealm.getKey());\n                 delete.setParameter(2, any.getKey());\n                 delete.executeUpdate();\n-                if (jpaAnySearchDAO().matches(any, SearchCondConverter.convert(memb.get().getFIQLCond()))) {\n-                    Query insert = entityManager().createNativeQuery(\"INSERT INTO \" + DYNMEMB_TABLE + \" VALUES(?, ?)\");\n-                    insert.setParameter(1, any.getKey());\n-                    insert.setParameter(2, dynRealm.getKey());\n-                    insert.executeUpdate();\n-                }\n             }\n-        });\n+        }));\n     }\n \n     @Override\n-    public void removeDynMemberships(final String key) {\n+    public void removeDynMemberships(final String anyKey) {\n         Query delete = entityManager().createNativeQuery(\"DELETE FROM \" + DYNMEMB_TABLE + \" WHERE any_id=?\");\n-        delete.setParameter(1, key);\n+        delete.setParameter(1, anyKey);\n         delete.executeUpdate();\n     }\n }"},{"sha":"7909022acb978ed5e7ba238c17f9a1980ad6c86f","filename":"core/persistence-jpa/src/main/java/org/apache/syncope/core/persistence/jpa/dao/JPAGroupDAO.java","status":"modified","additions":74,"deletions":94,"changes":168,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/00b70d8526cd6b6771b3fedadc34e9174c30733c/core%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fjpa%2Fdao%2FJPAGroupDAO.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/00b70d8526cd6b6771b3fedadc34e9174c30733c/core%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fjpa%2Fdao%2FJPAGroupDAO.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fjpa%2Fdao%2FJPAGroupDAO.java?ref=00b70d8526cd6b6771b3fedadc34e9174c30733c","patch":"@@ -27,52 +27,48 @@\n import java.util.Map;\n import java.util.Set;\n import java.util.stream.Collectors;\n-\n import javax.persistence.NoResultException;\n import javax.persistence.Query;\n import javax.persistence.TypedQuery;\n import org.apache.commons.lang3.tuple.Pair;\n import org.apache.syncope.common.lib.types.AnyTypeKind;\n-import org.apache.syncope.core.persistence.api.dao.GroupDAO;\n-import org.apache.syncope.core.persistence.api.dao.UserDAO;\n-import org.apache.syncope.core.persistence.api.entity.group.Group;\n-import org.apache.syncope.core.persistence.api.entity.user.User;\n-import org.apache.syncope.core.persistence.jpa.entity.group.JPAGroup;\n import org.apache.syncope.common.lib.types.StandardEntitlement;\n import org.apache.syncope.core.persistence.api.dao.AnyDAO;\n-import org.apache.syncope.core.provisioning.api.utils.RealmUtils;\n-import org.apache.syncope.core.persistence.api.search.SearchCondConverter;\n-import org.apache.syncope.core.spring.security.AuthContextUtils;\n-import org.apache.syncope.core.spring.security.DelegatedAdministrationException;\n+import org.apache.syncope.core.persistence.api.dao.AnyMatchDAO;\n import org.apache.syncope.core.persistence.api.dao.AnyObjectDAO;\n import org.apache.syncope.core.persistence.api.dao.AnySearchDAO;\n+import org.apache.syncope.core.persistence.api.dao.GroupDAO;\n import org.apache.syncope.core.persistence.api.dao.PlainAttrDAO;\n+import org.apache.syncope.core.persistence.api.dao.UserDAO;\n import org.apache.syncope.core.persistence.api.dao.search.AssignableCond;\n import org.apache.syncope.core.persistence.api.dao.search.OrderByClause;\n import org.apache.syncope.core.persistence.api.dao.search.SearchCond;\n import org.apache.syncope.core.persistence.api.entity.AnyType;\n import org.apache.syncope.core.persistence.api.entity.AnyTypeClass;\n import org.apache.syncope.core.persistence.api.entity.AnyUtils;\n import org.apache.syncope.core.persistence.api.entity.Entity;\n-import org.apache.syncope.core.persistence.api.entity.EntityFactory;\n import org.apache.syncope.core.persistence.api.entity.Realm;\n import org.apache.syncope.core.persistence.api.entity.anyobject.ADynGroupMembership;\n import org.apache.syncope.core.persistence.api.entity.anyobject.AMembership;\n import org.apache.syncope.core.persistence.api.entity.anyobject.AnyObject;\n+import org.apache.syncope.core.persistence.api.entity.group.Group;\n import org.apache.syncope.core.persistence.api.entity.group.TypeExtension;\n import org.apache.syncope.core.persistence.api.entity.user.UDynGroupMembership;\n import org.apache.syncope.core.persistence.api.entity.user.UMembership;\n+import org.apache.syncope.core.persistence.api.entity.user.User;\n+import org.apache.syncope.core.persistence.api.search.SearchCondConverter;\n import org.apache.syncope.core.persistence.jpa.entity.anyobject.JPAADynGroupMembership;\n import org.apache.syncope.core.persistence.jpa.entity.anyobject.JPAAMembership;\n+import org.apache.syncope.core.persistence.jpa.entity.group.JPAGroup;\n import org.apache.syncope.core.persistence.jpa.entity.group.JPATypeExtension;\n import org.apache.syncope.core.persistence.jpa.entity.user.JPAUDynGroupMembership;\n import org.apache.syncope.core.persistence.jpa.entity.user.JPAUMembership;\n import org.apache.syncope.core.provisioning.api.event.AnyCreatedUpdatedEvent;\n import org.apache.syncope.core.provisioning.api.event.AnyDeletedEvent;\n-import org.apache.syncope.core.spring.ApplicationContextProvider;\n-import org.springframework.aop.support.AopUtils;\n+import org.apache.syncope.core.provisioning.api.utils.RealmUtils;\n+import org.apache.syncope.core.spring.security.AuthContextUtils;\n+import org.apache.syncope.core.spring.security.DelegatedAdministrationException;\n import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.beans.factory.support.AbstractBeanDefinition;\n import org.springframework.transaction.annotation.Transactional;\n \n public class JPAGroupDAO extends AbstractAnyDAO<Group> implements GroupDAO {\n@@ -82,7 +78,7 @@ public class JPAGroupDAO extends AbstractAnyDAO<Group> implements GroupDAO {\n     public static final String ADYNMEMB_TABLE = \"ADynGroupMembers\";\n \n     @Autowired\n-    private EntityFactory entityFactory;\n+    private AnyMatchDAO anyMatchDAO;\n \n     @Autowired\n     private PlainAttrDAO plainAttrDAO;\n@@ -96,22 +92,6 @@ public class JPAGroupDAO extends AbstractAnyDAO<Group> implements GroupDAO {\n     @Autowired\n     private AnySearchDAO searchDAO;\n \n-    private AnySearchDAO jpaAnySearchDAO;\n-\n-    private AnySearchDAO jpaAnySearchDAO() {\n-        synchronized (this) {\n-            if (jpaAnySearchDAO == null) {\n-                if (AopUtils.getTargetClass(searchDAO).equals(entityFactory.anySearchDAOClass())) {\n-                    jpaAnySearchDAO = searchDAO;\n-                } else {\n-                    jpaAnySearchDAO = (AnySearchDAO) ApplicationContextProvider.getBeanFactory().createBean(\n-                            entityFactory.anySearchDAOClass(), AbstractBeanDefinition.AUTOWIRE_BY_TYPE, true);\n-                }\n-            }\n-        }\n-        return jpaAnySearchDAO;\n-    }\n-\n     @Override\n     protected AnyUtils init() {\n         return anyUtilsFactory.getInstance(AnyTypeKind.GROUP);\n@@ -452,46 +432,46 @@ private List<ADynGroupMembership> findWithADynMemberships(final AnyType anyType)\n \n     @Transactional\n     @Override\n-    @SuppressWarnings(\"unchecked\")\n     public Pair<Set<String>, Set<String>> refreshDynMemberships(final AnyObject anyObject) {\n         Query query = entityManager().createNativeQuery(\n                 \"SELECT group_id FROM \" + JPAGroupDAO.ADYNMEMB_TABLE + \" WHERE any_id=?\");\n         query.setParameter(1, anyObject.getKey());\n \n         Set<String> before = new HashSet<>();\n-        query.getResultList().stream().\n-                map(resultKey -> resultKey instanceof Object[]\n-                ? (String) ((Object[]) resultKey)[0]\n-                : ((String) resultKey)).\n-                forEach(group -> before.add((String) group));\n-\n         Set<String> after = new HashSet<>();\n-        findWithADynMemberships(anyObject.getType()).stream().\n-                filter(membCond -> jpaAnySearchDAO().matches(\n-                anyObject,\n-                buildDynMembershipCond(membCond.getFIQLCond(), membCond.getGroup().getRealm()))).\n-                forEach(membCond -> {\n-                    if (!before.contains(membCond.getGroup().getKey())) {\n-                        Query insert = entityManager().createNativeQuery(\n-                                \"INSERT INTO \" + ADYNMEMB_TABLE + \" VALUES(?, ?, ?)\");\n-                        insert.setParameter(1, anyObject.getType().getKey());\n-                        insert.setParameter(2, anyObject.getKey());\n-                        insert.setParameter(3, membCond.getGroup().getKey());\n-                        insert.executeUpdate();\n-                    }\n-\n-                    after.add(membCond.getGroup().getKey());\n-\n-                    publisher.publishEvent(\n-                            new AnyCreatedUpdatedEvent<>(this, membCond.getGroup(), AuthContextUtils.getDomain()));\n-                });\n+        findWithADynMemberships(anyObject.getType()).forEach(memb -> {\n+            boolean matches = anyMatchDAO.matches(\n+                    anyObject,\n+                    buildDynMembershipCond(memb.getFIQLCond(), memb.getGroup().getRealm()));\n+            if (matches) {\n+                after.add(memb.getGroup().getKey());\n+            }\n \n-        before.stream().filter(group -> !after.contains(group)).forEach(group -> {\n-            Query delete = entityManager().createNativeQuery(\n-                    \"DELETE FROM \" + ADYNMEMB_TABLE + \" WHERE group_id=? AND any_id=?\");\n-            delete.setParameter(1, group);\n-            delete.setParameter(2, anyObject.getKey());\n-            delete.executeUpdate();\n+            Query find = entityManager().createNativeQuery(\n+                    \"SELECT any_id FROM \" + ADYNMEMB_TABLE + \" WHERE group_id=? AND any_id=?\");\n+            find.setParameter(1, memb.getGroup().getKey());\n+            find.setParameter(2, anyObject.getKey());\n+            boolean existing = !find.getResultList().isEmpty();\n+            if (existing) {\n+                before.add(memb.getGroup().getKey());\n+            }\n+\n+            if (matches && !existing) {\n+                Query insert = entityManager().createNativeQuery(\n+                        \"INSERT INTO \" + ADYNMEMB_TABLE + \" VALUES(?, ?, ?)\");\n+                insert.setParameter(1, anyObject.getType().getKey());\n+                insert.setParameter(2, anyObject.getKey());\n+                insert.setParameter(3, memb.getGroup().getKey());\n+                insert.executeUpdate();\n+            } else if (!matches && existing) {\n+                Query delete = entityManager().createNativeQuery(\n+                        \"DELETE FROM \" + ADYNMEMB_TABLE + \" WHERE group_id=? AND any_id=?\");\n+                delete.setParameter(1, memb.getGroup().getKey());\n+                delete.setParameter(2, anyObject.getKey());\n+                delete.executeUpdate();\n+            }\n+\n+            publisher.publishEvent(new AnyCreatedUpdatedEvent<>(this, memb.getGroup(), AuthContextUtils.getDomain()));\n         });\n \n         return Pair.of(before, after);\n@@ -551,45 +531,45 @@ private List<UDynGroupMembership> findWithUDynMemberships() {\n \n     @Transactional\n     @Override\n-    @SuppressWarnings(\"unchecked\")\n     public Pair<Set<String>, Set<String>> refreshDynMemberships(final User user) {\n         Query query = entityManager().createNativeQuery(\n                 \"SELECT group_id FROM \" + JPAGroupDAO.UDYNMEMB_TABLE + \" WHERE any_id=?\");\n         query.setParameter(1, user.getKey());\n \n         Set<String> before = new HashSet<>();\n-        query.getResultList().stream().\n-                map(resultKey -> resultKey instanceof Object[]\n-                ? (String) ((Object[]) resultKey)[0]\n-                : ((String) resultKey)).\n-                forEach(group -> before.add((String) group));\n-\n         Set<String> after = new HashSet<>();\n-        findWithUDynMemberships().stream().\n-                filter(membCond -> jpaAnySearchDAO().matches(\n-                user,\n-                buildDynMembershipCond(membCond.getFIQLCond(), membCond.getGroup().getRealm()))).\n-                forEach(membCond -> {\n-                    if (!before.contains(membCond.getGroup().getKey())) {\n-                        Query insert = entityManager().createNativeQuery(\n-                                \"INSERT INTO \" + UDYNMEMB_TABLE + \" VALUES(?, ?)\");\n-                        insert.setParameter(1, user.getKey());\n-                        insert.setParameter(2, membCond.getGroup().getKey());\n-                        insert.executeUpdate();\n-                    }\n-\n-                    after.add(membCond.getGroup().getKey());\n-\n-                    publisher.publishEvent(\n-                            new AnyCreatedUpdatedEvent<>(this, membCond.getGroup(), AuthContextUtils.getDomain()));\n-                });\n+        findWithUDynMemberships().forEach(memb -> {\n+            boolean matches = anyMatchDAO.matches(\n+                    user,\n+                    buildDynMembershipCond(memb.getFIQLCond(), memb.getGroup().getRealm()));\n+            if (matches) {\n+                after.add(memb.getGroup().getKey());\n+            }\n+\n+            Query find = entityManager().createNativeQuery(\n+                    \"SELECT any_id FROM \" + UDYNMEMB_TABLE + \" WHERE group_id=? AND any_id=?\");\n+            find.setParameter(1, memb.getGroup().getKey());\n+            find.setParameter(2, user.getKey());\n+            boolean existing = !find.getResultList().isEmpty();\n+            if (existing) {\n+                before.add(memb.getGroup().getKey());\n+            }\n+\n+            if (matches && !existing) {\n+                Query insert = entityManager().createNativeQuery(\n+                        \"INSERT INTO \" + UDYNMEMB_TABLE + \" VALUES(?, ?)\");\n+                insert.setParameter(1, user.getKey());\n+                insert.setParameter(2, memb.getGroup().getKey());\n+                insert.executeUpdate();\n+            } else if (!matches && existing) {\n+                Query delete = entityManager().createNativeQuery(\n+                        \"DELETE FROM \" + UDYNMEMB_TABLE + \" WHERE group_id=? AND any_id=?\");\n+                delete.setParameter(1, memb.getGroup().getKey());\n+                delete.setParameter(2, user.getKey());\n+                delete.executeUpdate();\n+            }\n \n-        before.stream().filter(group -> !after.contains(group)).forEach(group -> {\n-            Query delete = entityManager().createNativeQuery(\n-                    \"DELETE FROM \" + UDYNMEMB_TABLE + \" WHERE group_id=? AND any_id=?\");\n-            delete.setParameter(1, group);\n-            delete.setParameter(2, user.getKey());\n-            delete.executeUpdate();\n+            publisher.publishEvent(new AnyCreatedUpdatedEvent<>(this, memb.getGroup(), AuthContextUtils.getDomain()));\n         });\n \n         return Pair.of(before, after);"},{"sha":"83a1825548d534b895a4469380c8f88fede7cfa0","filename":"core/persistence-jpa/src/main/java/org/apache/syncope/core/persistence/jpa/dao/JPARoleDAO.java","status":"modified","additions":26,"deletions":30,"changes":56,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/00b70d8526cd6b6771b3fedadc34e9174c30733c/core%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fjpa%2Fdao%2FJPARoleDAO.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/00b70d8526cd6b6771b3fedadc34e9174c30733c/core%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fjpa%2Fdao%2FJPARoleDAO.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fjpa%2Fdao%2FJPARoleDAO.java?ref=00b70d8526cd6b6771b3fedadc34e9174c30733c","patch":"@@ -20,12 +20,11 @@\n \n import java.util.ArrayList;\n import java.util.Collections;\n-import java.util.HashSet;\n import java.util.List;\n-import java.util.Set;\n import javax.persistence.Query;\n import javax.persistence.TypedQuery;\n import org.apache.syncope.common.lib.types.AnyTypeKind;\n+import org.apache.syncope.core.persistence.api.dao.AnyMatchDAO;\n import org.apache.syncope.core.persistence.api.search.SearchCondConverter;\n import org.apache.syncope.core.persistence.api.dao.RoleDAO;\n import org.apache.syncope.core.persistence.api.dao.AnySearchDAO;\n@@ -47,6 +46,9 @@ public class JPARoleDAO extends AbstractDAO<Role> implements RoleDAO {\n \n     public static final String DYNMEMB_TABLE = \"DynRoleMembers\";\n \n+    @Autowired\n+    private AnyMatchDAO anyMatchDAO;\n+\n     @Autowired\n     private ApplicationEventPublisher publisher;\n \n@@ -170,39 +172,33 @@ public void clearDynMembers(final Role role) {\n \n     @Transactional\n     @Override\n-    @SuppressWarnings(\"unchecked\")\n     public void refreshDynMemberships(final User user) {\n         Query query = entityManager().createNativeQuery(\n                 \"SELECT role_id FROM \" + DYNMEMB_TABLE + \" WHERE any_id=?\");\n         query.setParameter(1, user.getKey());\n \n-        Set<String> before = new HashSet<>();\n-        query.getResultList().stream().\n-                map(resultKey -> resultKey instanceof Object[]\n-                ? (String) ((Object[]) resultKey)[0]\n-                : ((String) resultKey)).\n-                forEach(role -> before.add((String) role));\n-\n-        Set<String> after = new HashSet<>();\n-        findAll().stream().\n-                filter(role -> role.getDynMembership() != null\n-                && searchDAO.matches(user, SearchCondConverter.convert(role.getDynMembership().getFIQLCond()))\n-                && !before.contains(role.getKey())).\n-                forEach(role -> {\n-                    Query insert = entityManager().createNativeQuery(\"INSERT INTO \" + DYNMEMB_TABLE + \" VALUES(?, ?)\");\n-                    insert.setParameter(1, user.getKey());\n-                    insert.setParameter(2, role.getKey());\n-                    insert.executeUpdate();\n-\n-                    after.add(role.getKey());\n-                });\n-\n-        before.stream().filter(role -> !after.contains(role)).forEach(role -> {\n-            Query delete = entityManager().createNativeQuery(\n-                    \"DELETE FROM \" + DYNMEMB_TABLE + \" WHERE role_id=? AND any_id=?\");\n-            delete.setParameter(1, role);\n-            delete.setParameter(2, user.getKey());\n-            delete.executeUpdate();\n+        findAll().stream().filter(role -> role.getDynMembership() != null).forEach(role -> {\n+            boolean matches =\n+                    anyMatchDAO.matches(user, SearchCondConverter.convert(role.getDynMembership().getFIQLCond()));\n+\n+            Query find = entityManager().createNativeQuery(\n+                    \"SELECT any_id FROM \" + DYNMEMB_TABLE + \" WHERE role_id=?\");\n+            find.setParameter(1, role.getKey());\n+            boolean existing = !find.getResultList().isEmpty();\n+\n+            if (matches && !existing) {\n+                Query insert = entityManager().createNativeQuery(\n+                        \"INSERT INTO \" + DYNMEMB_TABLE + \" VALUES(?, ?)\");\n+                insert.setParameter(1, user.getKey());\n+                insert.setParameter(2, role.getKey());\n+                insert.executeUpdate();\n+            } else if (!matches && existing) {\n+                Query delete = entityManager().createNativeQuery(\n+                        \"DELETE FROM \" + DYNMEMB_TABLE + \" WHERE role_id=? AND any_id=?\");\n+                delete.setParameter(1, role.getKey());\n+                delete.setParameter(2, user.getKey());\n+                delete.executeUpdate();\n+            }\n         });\n     }\n "},{"sha":"512538cc0562fa3bafd86e4a6af518c244e79c0c","filename":"core/persistence-jpa/src/test/java/org/apache/syncope/core/persistence/jpa/inner/AnyMatchTest.java","status":"added","additions":131,"deletions":0,"changes":131,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/00b70d8526cd6b6771b3fedadc34e9174c30733c/core%2Fpersistence-jpa%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fjpa%2Finner%2FAnyMatchTest.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/00b70d8526cd6b6771b3fedadc34e9174c30733c/core%2Fpersistence-jpa%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fjpa%2Finner%2FAnyMatchTest.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fpersistence-jpa%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fjpa%2Finner%2FAnyMatchTest.java?ref=00b70d8526cd6b6771b3fedadc34e9174c30733c","patch":"@@ -0,0 +1,131 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.core.persistence.jpa.inner;\n+\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import org.apache.syncope.core.persistence.api.dao.AnyObjectDAO;\n+import org.apache.syncope.core.persistence.api.dao.GroupDAO;\n+import org.apache.syncope.core.persistence.api.dao.UserDAO;\n+import org.apache.syncope.core.persistence.api.dao.search.AttributeCond;\n+import org.apache.syncope.core.persistence.api.dao.search.MembershipCond;\n+import org.apache.syncope.core.persistence.api.dao.search.RelationshipCond;\n+import org.apache.syncope.core.persistence.api.dao.search.RelationshipTypeCond;\n+import org.apache.syncope.core.persistence.api.dao.search.ResourceCond;\n+import org.apache.syncope.core.persistence.api.dao.search.RoleCond;\n+import org.apache.syncope.core.persistence.api.dao.search.SearchCond;\n+import org.apache.syncope.core.persistence.api.entity.anyobject.AnyObject;\n+import org.apache.syncope.core.persistence.api.entity.group.Group;\n+import org.apache.syncope.core.persistence.api.entity.user.User;\n+import org.apache.syncope.core.persistence.jpa.AbstractTest;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.transaction.annotation.Transactional;\n+import org.apache.syncope.core.persistence.api.dao.AnyMatchDAO;\n+import org.apache.syncope.core.persistence.api.dao.search.AnyCond;\n+import org.junit.jupiter.api.Test;\n+\n+@Transactional(\"Master\")\n+public class AnyMatchTest extends AbstractTest {\n+\n+    @Autowired\n+    private UserDAO userDAO;\n+\n+    @Autowired\n+    private GroupDAO groupDAO;\n+\n+    @Autowired\n+    private AnyObjectDAO anyObjectDAO;\n+\n+    @Autowired\n+    private AnyMatchDAO anyMatcher;\n+\n+    @Test\n+    public void byResourceCond() {\n+        User user = userDAO.find(\"1417acbe-cbf6-4277-9372-e75e04f97000\");\n+        assertNotNull(user);\n+\n+        ResourceCond resourceCond = new ResourceCond();\n+        resourceCond.setResourceKey(\"resource-testdb2\");\n+        assertTrue(anyMatcher.matches(user, SearchCond.getLeafCond(resourceCond)));\n+\n+        resourceCond.setResourceKey(\"ws-target-resource-delete\");\n+        assertFalse(anyMatcher.matches(user, SearchCond.getLeafCond(resourceCond)));\n+    }\n+\n+    @Test\n+    public void anyObjectMatch() {\n+        AnyObject anyObject = anyObjectDAO.find(\"fc6dbc3a-6c07-4965-8781-921e7401a4a5\");\n+        assertNotNull(anyObject);\n+\n+        RelationshipCond relationshipCond = new RelationshipCond();\n+        relationshipCond.setAnyObject(\"Canon MF 8030cn\");\n+        assertTrue(anyMatcher.matches(anyObject, SearchCond.getLeafCond(relationshipCond)));\n+\n+        RelationshipTypeCond relationshipTypeCond = new RelationshipTypeCond();\n+        relationshipTypeCond.setRelationshipTypeKey(\"neighborhood\");\n+        assertTrue(anyMatcher.matches(anyObject, SearchCond.getLeafCond(relationshipTypeCond)));\n+    }\n+\n+    @Test\n+    public void userMatch() {\n+        User user = userDAO.find(\"1417acbe-cbf6-4277-9372-e75e04f97000\");\n+        assertNotNull(user);\n+\n+        MembershipCond groupCond = new MembershipCond();\n+        groupCond.setGroup(\"secretary\");\n+        assertFalse(anyMatcher.matches(user, SearchCond.getLeafCond(groupCond)));\n+\n+        groupCond.setGroup(\"root\");\n+        assertTrue(anyMatcher.matches(user, SearchCond.getLeafCond(groupCond)));\n+\n+        RoleCond roleCond = new RoleCond();\n+        roleCond.setRole(\"Other\");\n+        assertTrue(anyMatcher.matches(user, SearchCond.getLeafCond(roleCond)));\n+\n+        user = userDAO.find(\"c9b2dec2-00a7-4855-97c0-d854842b4b24\");\n+        assertNotNull(user);\n+\n+        RelationshipCond relationshipCond = new RelationshipCond();\n+        relationshipCond.setAnyObject(\"fc6dbc3a-6c07-4965-8781-921e7401a4a5\");\n+        assertTrue(anyMatcher.matches(user, SearchCond.getLeafCond(relationshipCond)));\n+\n+        RelationshipTypeCond relationshipTypeCond = new RelationshipTypeCond();\n+        relationshipTypeCond.setRelationshipTypeKey(\"neighborhood\");\n+        assertTrue(anyMatcher.matches(user, SearchCond.getLeafCond(relationshipTypeCond)));\n+    }\n+\n+    @Test\n+    public void groupMatch() {\n+        Group group = groupDAO.find(\"37d15e4c-cdc1-460b-a591-8505c8133806\");\n+        assertNotNull(group);\n+\n+        AnyCond anyCond = new AnyCond();\n+        anyCond.setSchema(\"name\");\n+        anyCond.setExpression(\"root\");\n+        anyCond.setType(AttributeCond.Type.EQ);\n+        assertTrue(anyMatcher.matches(group, SearchCond.getLeafCond(anyCond)));\n+\n+        AttributeCond attrCond = new AttributeCond();\n+        attrCond.setSchema(\"show\");\n+        attrCond.setType(AttributeCond.Type.ISNOTNULL);\n+        assertTrue(anyMatcher.matches(group, SearchCond.getLeafCond(attrCond)));\n+    }\n+}"},{"sha":"65a8b557201bd1417004ef8c221543e350ebb0a6","filename":"core/persistence-jpa/src/test/java/org/apache/syncope/core/persistence/jpa/inner/AnySearchTest.java","status":"modified","additions":2,"deletions":65,"changes":67,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/00b70d8526cd6b6771b3fedadc34e9174c30733c/core%2Fpersistence-jpa%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fjpa%2Finner%2FAnySearchTest.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/00b70d8526cd6b6771b3fedadc34e9174c30733c/core%2Fpersistence-jpa%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fjpa%2Finner%2FAnySearchTest.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fpersistence-jpa%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fjpa%2Finner%2FAnySearchTest.java?ref=00b70d8526cd6b6771b3fedadc34e9174c30733c","patch":"@@ -35,7 +35,6 @@\n import org.apache.syncope.core.persistence.api.dao.AnySearchDAO;\n import org.apache.syncope.core.persistence.api.dao.AnyTypeDAO;\n import org.apache.syncope.core.persistence.api.dao.RealmDAO;\n-import org.apache.syncope.core.persistence.api.dao.UserDAO;\n import org.apache.syncope.core.persistence.api.dao.search.AttributeCond;\n import org.apache.syncope.core.persistence.api.dao.search.MembershipCond;\n import org.apache.syncope.core.persistence.api.dao.search.OrderByClause;\n@@ -47,7 +46,6 @@\n import org.apache.syncope.core.persistence.api.dao.search.AssignableCond;\n import org.apache.syncope.core.persistence.api.dao.search.MemberCond;\n import org.apache.syncope.core.persistence.api.dao.search.PrivilegeCond;\n-import org.apache.syncope.core.persistence.api.dao.search.RelationshipCond;\n import org.apache.syncope.core.persistence.api.dao.search.RelationshipTypeCond;\n import org.apache.syncope.core.persistence.api.entity.AnyType;\n import org.apache.syncope.core.persistence.api.entity.Entity;\n@@ -66,9 +64,6 @@ public class AnySearchTest extends AbstractTest {\n     @Autowired\n     private AnyObjectDAO anyObjectDAO;\n \n-    @Autowired\n-    private UserDAO userDAO;\n-\n     @Autowired\n     private GroupDAO groupDAO;\n \n@@ -81,64 +76,6 @@ public class AnySearchTest extends AbstractTest {\n     @Autowired\n     private RealmDAO realmDAO;\n \n-    @Test\n-    public void anyObjectMatch() {\n-        AnyObject anyObject = anyObjectDAO.find(\"fc6dbc3a-6c07-4965-8781-921e7401a4a5\");\n-        assertNotNull(anyObject);\n-\n-        RelationshipCond relationshipCond = new RelationshipCond();\n-        relationshipCond.setAnyObject(\"Canon MF 8030cn\");\n-        assertTrue(searchDAO.matches(anyObject, SearchCond.getLeafCond(relationshipCond)));\n-\n-        RelationshipTypeCond relationshipTypeCond = new RelationshipTypeCond();\n-        relationshipTypeCond.setRelationshipTypeKey(\"neighborhood\");\n-        assertTrue(searchDAO.matches(anyObject, SearchCond.getLeafCond(relationshipTypeCond)));\n-    }\n-\n-    @Test\n-    public void userMatch() {\n-        User user = userDAO.find(\"1417acbe-cbf6-4277-9372-e75e04f97000\");\n-        assertNotNull(user);\n-\n-        MembershipCond groupCond = new MembershipCond();\n-        groupCond.setGroup(\"secretary\");\n-        assertFalse(searchDAO.matches(user, SearchCond.getLeafCond(groupCond)));\n-\n-        groupCond.setGroup(\"root\");\n-        assertTrue(searchDAO.matches(user, SearchCond.getLeafCond(groupCond)));\n-\n-        RoleCond roleCond = new RoleCond();\n-        roleCond.setRole(\"Other\");\n-        assertTrue(searchDAO.matches(user, SearchCond.getLeafCond(roleCond)));\n-\n-        PrivilegeCond privilegeCond = new PrivilegeCond();\n-        privilegeCond.setPrivilege(\"postMighty\");\n-        assertTrue(searchDAO.matches(user, SearchCond.getLeafCond(privilegeCond)));\n-\n-        user = userDAO.find(\"c9b2dec2-00a7-4855-97c0-d854842b4b24\");\n-        assertNotNull(user);\n-\n-        RelationshipCond relationshipCond = new RelationshipCond();\n-        relationshipCond.setAnyObject(\"fc6dbc3a-6c07-4965-8781-921e7401a4a5\");\n-        assertTrue(searchDAO.matches(user, SearchCond.getLeafCond(relationshipCond)));\n-\n-        RelationshipTypeCond relationshipTypeCond = new RelationshipTypeCond();\n-        relationshipTypeCond.setRelationshipTypeKey(\"neighborhood\");\n-        assertTrue(searchDAO.matches(user, SearchCond.getLeafCond(relationshipTypeCond)));\n-    }\n-\n-    @Test\n-    public void groupMatch() {\n-        Group group = groupDAO.find(\"37d15e4c-cdc1-460b-a591-8505c8133806\");\n-        assertNotNull(group);\n-\n-        AttributeCond attrCond = new AttributeCond();\n-        attrCond.setSchema(\"show\");\n-        attrCond.setType(AttributeCond.Type.ISNOTNULL);\n-\n-        assertTrue(searchDAO.matches(group, SearchCond.getLeafCond(attrCond)));\n-    }\n-\n     @Test\n     public void searchWithLikeCondition() {\n         AttributeCond fullnameLeafCond = new AttributeCond(AttributeCond.Type.LIKE);\n@@ -769,7 +706,7 @@ public void issueSYNCOPE1416() {\n         assertEquals(\n                 searchDAO.count(SyncopeConstants.FULL_ADMIN_REALMS, searchCondition, AnyTypeKind.USER),\n                 users.size());\n-        \n+\n         // search by attribute with unique constraint\n         AttributeCond fullnameCond = new AttributeCond(AttributeCond.Type.ISNOTNULL);\n         fullnameCond.setSchema(\"fullname\");\n@@ -779,7 +716,7 @@ public void issueSYNCOPE1416() {\n \n         users = searchDAO.search(cond, AnyTypeKind.USER);\n         assertEquals(5, users.size());\n-        \n+\n         fullnameCond = new AttributeCond(AttributeCond.Type.ISNULL);\n         fullnameCond.setSchema(\"fullname\");\n "},{"sha":"69f36e72b61e270405e88c524369bd972b668d97","filename":"core/persistence-jpa/src/test/java/org/apache/syncope/core/persistence/jpa/outer/DynRealmTest.java","status":"modified","additions":5,"deletions":1,"changes":6,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/00b70d8526cd6b6771b3fedadc34e9174c30733c/core%2Fpersistence-jpa%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fjpa%2Fouter%2FDynRealmTest.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/00b70d8526cd6b6771b3fedadc34e9174c30733c/core%2Fpersistence-jpa%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fjpa%2Fouter%2FDynRealmTest.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fpersistence-jpa%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fjpa%2Fouter%2FDynRealmTest.java?ref=00b70d8526cd6b6771b3fedadc34e9174c30733c","patch":"@@ -38,10 +38,14 @@\n import org.junit.jupiter.api.Test;\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.transaction.annotation.Transactional;\n+import org.apache.syncope.core.persistence.api.dao.AnyMatchDAO;\n \n @Transactional(\"Master\")\n public class DynRealmTest extends AbstractTest {\n \n+    @Autowired\n+    private AnyMatchDAO anyMatcher;\n+\n     @Autowired\n     private AnyTypeDAO anyTypeDAO;\n \n@@ -88,7 +92,7 @@ public void misc() {\n         assertFalse(matching.isEmpty());\n \n         User user = matching.get(0);\n-        assertTrue(searchDAO.matches(user, SearchCond.getLeafCond(dynRealmCond)));\n+        assertTrue(anyMatcher.matches(user, SearchCond.getLeafCond(dynRealmCond)));\n \n         assertTrue(userDAO.findDynRealms(user.getKey()).contains(actual.getKey()));\n     }"},{"sha":"8a2b9f004c48d4810d9ad8d2f81251e650be823c","filename":"core/provisioning-java/src/main/java/org/apache/syncope/core/provisioning/java/data/AnyObjectDataBinderImpl.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/00b70d8526cd6b6771b3fedadc34e9174c30733c/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fdata%2FAnyObjectDataBinderImpl.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/00b70d8526cd6b6771b3fedadc34e9174c30733c/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fdata%2FAnyObjectDataBinderImpl.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fdata%2FAnyObjectDataBinderImpl.java?ref=00b70d8526cd6b6771b3fedadc34e9174c30733c","patch":"@@ -97,7 +97,7 @@ public AnyObjectTO getAnyObjectTO(final AnyObject anyObject, final boolean detai\n \n         if (details) {\n             // dynamic realms\n-            anyObjectTO.getDynRealms().addAll(userDAO.findDynRealms(anyObject.getKey()));\n+            anyObjectTO.getDynRealms().addAll(anyObjectDAO.findDynRealms(anyObject.getKey()));\n \n             // relationships\n             anyObjectTO.getRelationships().addAll("},{"sha":"83be112bfd69a35d5fc69f7edcc9c61277774599","filename":"core/provisioning-java/src/main/java/org/apache/syncope/core/provisioning/java/notification/DefaultNotificationManager.java","status":"modified","additions":26,"deletions":22,"changes":48,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/00b70d8526cd6b6771b3fedadc34e9174c30733c/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fnotification%2FDefaultNotificationManager.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/00b70d8526cd6b6771b3fedadc34e9174c30733c/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fnotification%2FDefaultNotificationManager.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fnotification%2FDefaultNotificationManager.java?ref=00b70d8526cd6b6771b3fedadc34e9174c30733c","patch":"@@ -32,54 +32,55 @@\n import org.apache.commons.jexl3.MapContext;\n import org.apache.commons.lang3.StringUtils;\n import org.apache.commons.lang3.tuple.Pair;\n+import org.apache.syncope.common.lib.to.AnyObjectTO;\n import org.apache.syncope.common.lib.to.GroupTO;\n+import org.apache.syncope.common.lib.to.ProvisioningResult;\n import org.apache.syncope.common.lib.to.UserTO;\n+import org.apache.syncope.common.lib.types.AnyTypeKind;\n import org.apache.syncope.common.lib.types.AuditElements;\n import org.apache.syncope.common.lib.types.AuditElements.Result;\n import org.apache.syncope.common.lib.types.AuditLoggerName;\n-import org.apache.syncope.common.lib.to.AnyObjectTO;\n-import org.apache.syncope.common.lib.to.ProvisioningResult;\n-import org.apache.syncope.common.lib.types.AnyTypeKind;\n-import org.apache.syncope.core.provisioning.java.jexl.JexlUtils;\n+import org.apache.syncope.core.persistence.api.dao.AnyMatchDAO;\n+import org.apache.syncope.core.persistence.api.dao.AnyObjectDAO;\n+import org.apache.syncope.core.persistence.api.dao.AnySearchDAO;\n import org.apache.syncope.core.persistence.api.dao.ConfDAO;\n-import org.apache.syncope.core.persistence.api.dao.NotificationDAO;\n+import org.apache.syncope.core.persistence.api.dao.DerSchemaDAO;\n import org.apache.syncope.core.persistence.api.dao.GroupDAO;\n+import org.apache.syncope.core.persistence.api.dao.NotificationDAO;\n import org.apache.syncope.core.persistence.api.dao.TaskDAO;\n import org.apache.syncope.core.persistence.api.dao.UserDAO;\n+import org.apache.syncope.core.persistence.api.dao.VirSchemaDAO;\n import org.apache.syncope.core.persistence.api.dao.search.OrderByClause;\n+import org.apache.syncope.core.persistence.api.entity.Any;\n+import org.apache.syncope.core.persistence.api.entity.AnyType;\n+import org.apache.syncope.core.persistence.api.entity.DerSchema;\n import org.apache.syncope.core.persistence.api.entity.EntityFactory;\n import org.apache.syncope.core.persistence.api.entity.Notification;\n+import org.apache.syncope.core.persistence.api.entity.VirSchema;\n+import org.apache.syncope.core.persistence.api.entity.anyobject.AnyObject;\n import org.apache.syncope.core.persistence.api.entity.group.Group;\n import org.apache.syncope.core.persistence.api.entity.task.NotificationTask;\n import org.apache.syncope.core.persistence.api.entity.task.TaskExec;\n+import org.apache.syncope.core.persistence.api.entity.user.UMembership;\n import org.apache.syncope.core.persistence.api.entity.user.UPlainAttr;\n import org.apache.syncope.core.persistence.api.entity.user.User;\n-import org.apache.syncope.core.provisioning.api.data.GroupDataBinder;\n-import org.apache.syncope.core.provisioning.api.data.UserDataBinder;\n import org.apache.syncope.core.persistence.api.search.SearchCondConverter;\n-import org.apache.syncope.core.persistence.api.dao.AnyObjectDAO;\n-import org.apache.syncope.core.persistence.api.dao.AnySearchDAO;\n-import org.apache.syncope.core.persistence.api.dao.DerSchemaDAO;\n-import org.apache.syncope.core.persistence.api.dao.VirSchemaDAO;\n-import org.apache.syncope.core.persistence.api.entity.Any;\n-import org.apache.syncope.core.persistence.api.entity.AnyType;\n-import org.apache.syncope.core.persistence.api.entity.DerSchema;\n-import org.apache.syncope.core.persistence.api.entity.VirSchema;\n-import org.apache.syncope.core.persistence.api.entity.anyobject.AnyObject;\n-import org.apache.syncope.core.persistence.api.entity.user.UMembership;\n import org.apache.syncope.core.provisioning.api.DerAttrHandler;\n-import org.apache.syncope.core.provisioning.java.IntAttrNameParser;\n import org.apache.syncope.core.provisioning.api.IntAttrName;\n import org.apache.syncope.core.provisioning.api.VirAttrHandler;\n import org.apache.syncope.core.provisioning.api.data.AnyObjectDataBinder;\n-import org.apache.syncope.core.provisioning.api.notification.NotificationManager;\n+import org.apache.syncope.core.provisioning.api.data.GroupDataBinder;\n+import org.apache.syncope.core.provisioning.api.data.UserDataBinder;\n import org.apache.syncope.core.provisioning.api.event.AfterHandlingEvent;\n+import org.apache.syncope.core.provisioning.api.notification.NotificationManager;\n+import org.apache.syncope.core.provisioning.api.notification.RecipientsProvider;\n+import org.apache.syncope.core.provisioning.java.IntAttrNameParser;\n+import org.apache.syncope.core.provisioning.java.jexl.JexlUtils;\n+import org.apache.syncope.core.spring.ImplementationManager;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.transaction.annotation.Transactional;\n-import org.apache.syncope.core.provisioning.api.notification.RecipientsProvider;\n-import org.apache.syncope.core.spring.ImplementationManager;\n \n @Transactional(rollbackFor = { Throwable.class })\n public class DefaultNotificationManager implements NotificationManager {\n@@ -128,6 +129,9 @@ public class DefaultNotificationManager implements NotificationManager {\n     @Autowired\n     private AnySearchDAO searchDAO;\n \n+    @Autowired\n+    private AnyMatchDAO anyMatchDAO;\n+\n     /**\n      * Task DAO.\n      */\n@@ -341,7 +345,7 @@ public List<NotificationTask> createTasks(\n                     LOG.debug(\"No events found about {}\", any);\n                 } else if (anyType == null || any == null\n                         || !notification.getAbout(anyType).isPresent()\n-                        || searchDAO.matches(\n+                        || anyMatchDAO.matches(\n                                 any, SearchCondConverter.convert(notification.getAbout(anyType).get().get()))) {\n \n                     LOG.debug(\"Creating notification task for event {} about {}\", currentEvent, any);"}]}