{"sha":"f171ed2aeb6de42a5f0f2430d073fe2d9fb0af16","node_id":"MDY6Q29tbWl0NjM2ODc5MDYyOmYxNzFlZDJhZWI2ZGU0MmE1ZjBmMjQzMGQwNzNmZTJkOWZiMGFmMTY=","commit":{"author":{"name":"Francesco Chicchiriccò","email":"ilgrosso@apache.org","date":"2018-04-04T08:29:29Z"},"committer":{"name":"Francesco Chicchiriccò","email":"ilgrosso@apache.org","date":"2018-04-04T09:09:59Z"},"message":"[SYNCOPE-1292] Implementation provided","tree":{"sha":"4c0281481275c2dacbbbee8b9f8cc05455546849","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/git/trees/4c0281481275c2dacbbbee8b9f8cc05455546849"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/git/commits/f171ed2aeb6de42a5f0f2430d073fe2d9fb0af16","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/f171ed2aeb6de42a5f0f2430d073fe2d9fb0af16","html_url":"https://github.com/EnricoDAlessandro97UNI/syncope/commit/f171ed2aeb6de42a5f0f2430d073fe2d9fb0af16","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/f171ed2aeb6de42a5f0f2430d073fe2d9fb0af16/comments","author":{"login":"ilgrosso","id":1064664,"node_id":"MDQ6VXNlcjEwNjQ2NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/1064664?v=4","gravatar_id":"","url":"https://api.github.com/users/ilgrosso","html_url":"https://github.com/ilgrosso","followers_url":"https://api.github.com/users/ilgrosso/followers","following_url":"https://api.github.com/users/ilgrosso/following{/other_user}","gists_url":"https://api.github.com/users/ilgrosso/gists{/gist_id}","starred_url":"https://api.github.com/users/ilgrosso/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ilgrosso/subscriptions","organizations_url":"https://api.github.com/users/ilgrosso/orgs","repos_url":"https://api.github.com/users/ilgrosso/repos","events_url":"https://api.github.com/users/ilgrosso/events{/privacy}","received_events_url":"https://api.github.com/users/ilgrosso/received_events","type":"User","site_admin":false},"committer":{"login":"ilgrosso","id":1064664,"node_id":"MDQ6VXNlcjEwNjQ2NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/1064664?v=4","gravatar_id":"","url":"https://api.github.com/users/ilgrosso","html_url":"https://github.com/ilgrosso","followers_url":"https://api.github.com/users/ilgrosso/followers","following_url":"https://api.github.com/users/ilgrosso/following{/other_user}","gists_url":"https://api.github.com/users/ilgrosso/gists{/gist_id}","starred_url":"https://api.github.com/users/ilgrosso/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ilgrosso/subscriptions","organizations_url":"https://api.github.com/users/ilgrosso/orgs","repos_url":"https://api.github.com/users/ilgrosso/repos","events_url":"https://api.github.com/users/ilgrosso/events{/privacy}","received_events_url":"https://api.github.com/users/ilgrosso/received_events","type":"User","site_admin":false},"parents":[{"sha":"a346bbf6abeb25923fe780bbae0df29735d80f28","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/a346bbf6abeb25923fe780bbae0df29735d80f28","html_url":"https://github.com/EnricoDAlessandro97UNI/syncope/commit/a346bbf6abeb25923fe780bbae0df29735d80f28"}],"stats":{"total":285,"additions":162,"deletions":123},"files":[{"sha":"3243cf2f493c54c1e01d7e390ae2bc69ee1ef468","filename":"core/persistence-jpa/src/test/resources/domains/MasterContent.xml","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/f171ed2aeb6de42a5f0f2430d073fe2d9fb0af16/core%2Fpersistence-jpa%2Fsrc%2Ftest%2Fresources%2Fdomains%2FMasterContent.xml","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/f171ed2aeb6de42a5f0f2430d073fe2d9fb0af16/core%2Fpersistence-jpa%2Fsrc%2Ftest%2Fresources%2Fdomains%2FMasterContent.xml","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fpersistence-jpa%2Fsrc%2Ftest%2Fresources%2Fdomains%2FMasterContent.xml?ref=f171ed2aeb6de42a5f0f2430d073fe2d9fb0af16","patch":"@@ -711,7 +711,7 @@ under the License.\n                 location=\"${connid.location}\"\n                 connectorName=\"net.tirasa.connid.bundles.ldap.LdapConnector\"\n                 version=\"${connid.ldap.version}\" \n-                jsonConf='[{\"schema\":{\"name\":\"synchronizePasswords\",\"displayName\":\"Enable Password Synchronization\",\"helpMessage\":\"If true, the connector will synchronize passwords. The Password Capture Plugin needs to be installed for password synchronization to work.\",\"type\":\"boolean\",\"required\":false,\"order\":0,\"confidential\":false,\"defaultValues\":null},\"overridable\":false,\"values\":[\"false\"]},{\"schema\":{\"name\":\"maintainLdapGroupMembership\",\"displayName\":\"Maintain LDAP Group Membership\",\"helpMessage\":\"When enabled and a user is renamed or deleted, update any LDAP groups to which the user belongs to reflect the new name. Otherwise, the LDAP resource must maintain referential integrity with respect to group membership.\",\"type\":\"boolean\",\"required\":false,\"order\":0,\"confidential\":false,\"defaultValues\":null},\"overridable\":false,\"values\":[\"true\"]},{\"schema\":{\"name\":\"host\",\"displayName\":\"Host\",\"helpMessage\":\"The name or IP address of the host where the LDAP server is running.\",\"type\":\"java.lang.String\",\"required\":false,\"order\":0,\"confidential\":false,\"defaultValues\":null},\"overridable\":false,\"values\":[\"localhost\"]},{\"schema\":{\"name\":\"passwordHashAlgorithm\",\"displayName\":\"Password Hash Algorithm\",\"helpMessage\":\"Indicates the algorithm that the Identity system should use to hash the password. Currently supported values are SSHA, SHA, SSHA1, and SHA1. A blank value indicates that the system will not hash passwords. This will cause cleartext passwords to be stored in LDAP unless the LDAP server performs the hash (Netscape Directory Server and iPlanet Directory Server do).\",\"type\":\"java.lang.String\",\"required\":false,\"order\":0,\"confidential\":false,\"defaultValues\":null},\"overridable\":false,\"values\":[\"SHA\"]},{\"schema\":{\"name\":\"port\",\"displayName\":\"TCP Port\",\"helpMessage\":\"TCP/IP port number used to communicate with the LDAP server.\",\"type\":\"int\",\"required\":false,\"order\":0,\"confidential\":false,\"defaultValues\":null},\"overridable\":false,\"values\":[1389]},{\"schema\":{\"name\":\"vlvSortAttribute\",\"displayName\":\"VLV Sort Attribute\",\"helpMessage\":\"Specify the sort attribute to use for VLV indexes on the resource.\",\"type\":\"java.lang.String\",\"required\":false,\"order\":0,\"confidential\":false,\"defaultValues\":null},\"overridable\":false,\"values\":[]},{\"schema\":{\"name\":\"statusManagementClass\",\"displayName\":\"Status management class \",\"helpMessage\":\"Class to be used to manage enabled/disabled status. If no class is specified then identity status management wont be possible.\",\"type\":\"java.lang.String\",\"required\":false,\"order\":0,\"confidential\":false,\"defaultValues\":null},\"overridable\":false,\"values\":[\"net.tirasa.connid.bundles.ldap.commons.AttributeStatusManagement\"]},{\"schema\":{\"name\":\"accountObjectClasses\",\"displayName\":\"Account Object Classes\",\"helpMessage\":\"The object class or classes that will be used when creating new user objects in the LDAP tree. When entering more than one object class, each entry should be on its own line; do not use commas or semi-colons to separate multiple object classes. Some object classes may require that you specify all object classes in the class hierarchy.\",\"type\":\"[Ljava.lang.String;\",\"required\":false,\"order\":0,\"confidential\":false,\"defaultValues\":null},\"overridable\":false,\"values\":[\"inetOrgPerson\"]},{\"schema\":{\"name\":\"accountUserNameAttributes\",\"displayName\":\"Account User Name Attributes\",\"helpMessage\":\"Attribute or attributes which holds the account user name. They will be used when authenticating to find the LDAP entry for the user name to authenticate.\",\"type\":\"[Ljava.lang.String;\",\"required\":false,\"order\":0,\"confidential\":false,\"defaultValues\":null},\"overridable\":false,\"values\":[\"uid\"]},{\"schema\":{\"name\":\"baseContextsToSynchronize\",\"displayName\":\"Base Contexts to Synchronize\",\"helpMessage\":\"One or more starting points in the LDAP tree that will be used to determine if a change should be synchronized. The base contexts attribute will be used to synchronize a change if this property is not set.\",\"type\":\"[Ljava.lang.String;\",\"required\":false,\"order\":0,\"confidential\":false,\"defaultValues\":null},\"overridable\":false,\"values\":[\"ou=people,o=isp\",\"ou=groups,o=isp\"]},{\"schema\":{\"name\":\"accountSynchronizationFilter\",\"displayName\":\"LDAP Filter for Accounts to Synchronize\",\"helpMessage\":\"An optional LDAP filter for the objects to synchronize. Because the change log is for all objects, this filter updates only objects that match the specified filter. If you specify a filter, an object will be synchronized only if it matches the filter and includes a synchronized object class.\",\"type\":\"java.lang.String\",\"required\":false,\"order\":0,\"confidential\":false,\"defaultValues\":null},\"overridable\":false,\"values\":[]},{\"schema\":{\"name\":\"removeLogEntryObjectClassFromFilter\",\"displayName\":\"Remove Log Entry Object Class from Filter\",\"helpMessage\":\"If this property is set (the default), the filter used to fetch change log entries does not contain the \\\"changeLogEntry\\\" object class, expecting that there are no entries of other object types in the change log.\",\"type\":\"boolean\",\"required\":false,\"order\":0,\"confidential\":false,\"defaultValues\":null},\"overridable\":false,\"values\":[\"false\"]},{\"schema\":{\"name\":\"passwordDecryptionKey\",\"displayName\":\"Password Decryption Key\",\"helpMessage\":\"The key to decrypt passwords with when performing password synchronization.\",\"type\":\"org.identityconnectors.common.security.GuardedByteArray\",\"required\":false,\"order\":0,\"confidential\":false,\"defaultValues\":null},\"overridable\":false,\"values\":[]},{\"schema\":{\"name\":\"readSchema\",\"displayName\":\"Read Schema\",\"helpMessage\":\"If true, the connector will read the schema from the server. If false, the connector will provide a default schema based on the object classes in the configuration. This property must be true in order to use extended object classes.\",\"type\":\"boolean\",\"required\":false,\"order\":0,\"confidential\":false,\"defaultValues\":null},\"overridable\":false,\"values\":[\"true\"]},{\"schema\":{\"name\":\"ssl\",\"displayName\":\"SSL\",\"helpMessage\":\"Select the check box to connect to the LDAP server using SSL.\",\"type\":\"boolean\",\"required\":false,\"order\":0,\"confidential\":false,\"defaultValues\":null},\"overridable\":false,\"values\":[\"false\"]},{\"schema\":{\"name\":\"passwordAttributeToSynchronize\",\"displayName\":\"Password Attribute to Synchronize\",\"helpMessage\":\"The name of the password attribute to synchronize when performing password synchronization.\",\"type\":\"java.lang.String\",\"required\":false,\"order\":0,\"confidential\":false,\"defaultValues\":null},\"overridable\":false,\"values\":[]},{\"schema\":{\"name\":\"accountSearchFilter\",\"displayName\":\"LDAP Filter for Retrieving Accounts\",\"helpMessage\":\"An optional LDAP filter to control which accounts are returned from the LDAP resource. If no filter is specified, only accounts that include all specified object classes are returned.\",\"type\":\"java.lang.String\",\"required\":false,\"order\":0,\"confidential\":false,\"defaultValues\":null},\"overridable\":false,\"values\":[\"uid=*\"]},{\"schema\":{\"name\":\"passwordDecryptionInitializationVector\",\"displayName\":\"Password Decryption Initialization Vector\",\"helpMessage\":\"The initialization vector to decrypt passwords with when performing password synchronization.\",\"type\":\"org.identityconnectors.common.security.GuardedByteArray\",\"required\":false,\"order\":0,\"confidential\":false,\"defaultValues\":null},\"overridable\":false,\"values\":[]},{\"schema\":{\"name\":\"groupMemberAttribute\",\"displayName\":\"Group Member Attribute\",\"helpMessage\":\"The name of the group attribute that will be updated with the distinguished name of the user when the user is added to the group.\",\"type\":\"java.lang.String\",\"required\":false,\"order\":0,\"confidential\":false,\"defaultValues\":null},\"overridable\":false,\"values\":[]},{\"schema\":{\"name\":\"failover\",\"displayName\":\"Failover Servers\",\"helpMessage\":\"List all servers that should be used for failover in case the preferred server fails. If the preferred server fails, JNDI will connect to the next available server in the list. List all servers in the form of \\\"ldap://ldap.example.com:389/\\\", which follows the standard LDAP v3 URLs described in RFC 2255. Only the host and port parts of the URL are relevant in this setting.\",\"type\":\"[Ljava.lang.String;\",\"required\":false,\"order\":0,\"confidential\":false,\"defaultValues\":null},\"overridable\":false,\"values\":[]},{\"schema\":{\"name\":\"modifiersNamesToFilterOut\",\"displayName\":\"Filter Out Changes By\",\"helpMessage\":\"The names (DNs) of directory administrators to filter from the changes. Changes with the attribute \\\"modifiersName\\\" that match entries in this list will be filtered out. The standard value is the administrator name used by this adapter, to prevent loops. Entries should be of the format \\\"cn=Directory Manager\\\".\",\"type\":\"[Ljava.lang.String;\",\"required\":false,\"order\":0,\"confidential\":false,\"defaultValues\":null},\"overridable\":false,\"values\":[]},{\"schema\":{\"name\":\"groupNameAttributes\",\"displayName\":\"Group Name Attributes\",\"helpMessage\":\"Attribute or attributes which holds the group name.\",\"type\":\"[Ljava.lang.String;\",\"required\":false,\"order\":0,\"confidential\":false,\"defaultValues\":null},\"overridable\":false,\"values\":[\"cn\"]},{\"schema\":{\"name\":\"uidAttribute\",\"displayName\":\"Uid Attribute\",\"helpMessage\":\"The name of the LDAP attribute which is mapped to the Uid attribute.\",\"type\":\"java.lang.String\",\"required\":false,\"order\":0,\"confidential\":false,\"defaultValues\":null},\"overridable\":true,\"values\":[\"cn\"]},{\"schema\":{\"name\":\"respectResourcePasswordPolicyChangeAfterReset\",\"displayName\":\"Respect Resource Password Policy Change-After-Reset\",\"helpMessage\":\"When this resource is specified in a Login Module (i.e., this resource is a pass-through authentication target) and the resource password policy is configured for change-after-reset, a user whose resource account password has been administratively reset will be required to change that password after successfully authenticating.\",\"type\":\"boolean\",\"required\":false,\"order\":0,\"confidential\":false,\"defaultValues\":null},\"overridable\":false,\"values\":[\"false\"]},{\"schema\":{\"name\":\"filterWithOrInsteadOfAnd\",\"displayName\":\"Filter with Or Instead of And\",\"helpMessage\":\"Normally the the filter used to fetch change log entries is an and-based filter retrieving an interval of change entries. If this property is set, the filter will or together the required change numbers instead.\",\"type\":\"boolean\",\"required\":false,\"order\":0,\"confidential\":false,\"defaultValues\":null},\"overridable\":false,\"values\":[\"false\"]},{\"schema\":{\"name\":\"principal\",\"displayName\":\"Principal\",\"helpMessage\":\"The distinguished name with which to authenticate to the LDAP server.\",\"type\":\"java.lang.String\",\"required\":false,\"order\":0,\"confidential\":false,\"defaultValues\":null},\"overridable\":false,\"values\":[\"uid=admin,ou=system\"]},{\"schema\":{\"name\":\"changeLogBlockSize\",\"displayName\":\"Change Log Block Size\",\"helpMessage\":\"The number of change log entries to fetch per query.\",\"type\":\"int\",\"required\":true,\"order\":0,\"confidential\":false,\"defaultValues\":null},\"overridable\":false,\"values\":[100]},{\"schema\":{\"name\":\"baseContexts\",\"displayName\":\"Base Contexts\",\"helpMessage\":\"One or more starting points in the LDAP tree that will be used when searching the tree. Searches are performed when discovering users from the LDAP server or when looking for the groups of which a user is a member.\",\"type\":\"[Ljava.lang.String;\",\"required\":false,\"order\":0,\"confidential\":false,\"defaultValues\":null},\"overridable\":true,\"values\":[\"ou=people,o=isp\",\"ou=groups,o=isp\"]},{\"schema\":{\"name\":\"passwordAttribute\",\"displayName\":\"Password Attribute\",\"helpMessage\":\"The name of the LDAP attribute which holds the password. When changing an user password, the new password is set to this attribute.\",\"type\":\"java.lang.String\",\"required\":false,\"order\":0,\"confidential\":false,\"defaultValues\":null},\"overridable\":false,\"values\":[\"userpassword\"]},{\"schema\":{\"name\":\"changeNumberAttribute\",\"displayName\":\"Change Number Attribute\",\"helpMessage\":\"The name of the change number attribute in the change log entry.\",\"type\":\"java.lang.String\",\"required\":true,\"order\":0,\"confidential\":false,\"defaultValues\":null},\"overridable\":false,\"values\":[\"changeNumber\"]},{\"schema\":{\"name\":\"objectClassesToSynchronize\",\"displayName\":\"Object Classes to Synchronize\",\"helpMessage\":\"The object classes to synchronize. The change log is for all objects; this filters updates to just the listed object classes. You should not list the superclasses of an object class unless you intend to synchronize objects with any of the superclass values. For example, if only \\\"inetOrgPerson\\\" objects should be synchronized, but the superclasses of \\\"inetOrgPerson\\\" (\\\"person\\\", \\\"organizationalperson\\\" and \\\"top\\\") should be filtered out, then list only \\\"inetOrgPerson\\\" here. All objects in LDAP are subclassed from \\\"top\\\". For this reason, you should never list \\\"top\\\", otherwise no object would be filtered.\",\"type\":\"[Ljava.lang.String;\",\"required\":true,\"order\":0,\"confidential\":false,\"defaultValues\":null},\"overridable\":false,\"values\":[\"inetOrgPerson\",\"groupOfUniqueNames\"]},{\"schema\":{\"name\":\"credentials\",\"displayName\":\"Password\",\"helpMessage\":\"Password for the principal.\",\"type\":\"org.identityconnectors.common.security.GuardedString\",\"required\":false,\"order\":0,\"confidential\":false,\"defaultValues\":null},\"overridable\":false,\"values\":[\"secret\"]},{\"schema\":{\"name\":\"attributesToSynchronize\",\"displayName\":\"Attributes to Synchronize\",\"helpMessage\":\"The names of the attributes to synchronize. This ignores updates from the change log if they do not update any of the named attributes. For example, if only \\\"department\\\" is listed, then only changes that affect \\\"department\\\" will be processed. All other updates are ignored. If blank (the default), then all changes are processed.\",\"type\":\"[Ljava.lang.String;\",\"required\":false,\"order\":0,\"confidential\":false,\"defaultValues\":null},\"overridable\":false,\"values\":[]},{\"schema\":{\"name\":\"maintainPosixGroupMembership\",\"displayName\":\"Maintain POSIX Group Membership\",\"helpMessage\":\"When enabled and a user is renamed or deleted, update any POSIX groups to which the user belongs to reflect the new name. Otherwise, the LDAP resource must maintain referential integrity with respect to group membership.\",\"type\":\"boolean\",\"required\":false,\"order\":0,\"confidential\":false,\"defaultValues\":null},\"overridable\":false,\"values\":[\"false\"]}]'/>\n+                jsonConf='[{\"schema\":{\"name\":\"synchronizePasswords\",\"displayName\":\"Enable Password Synchronization\",\"helpMessage\":\"If true, the connector will synchronize passwords. The Password Capture Plugin needs to be installed for password synchronization to work.\",\"type\":\"boolean\",\"required\":false,\"order\":0,\"confidential\":false,\"defaultValues\":null},\"overridable\":false,\"values\":[\"false\"]},{\"schema\":{\"name\":\"maintainLdapGroupMembership\",\"displayName\":\"Maintain LDAP Group Membership\",\"helpMessage\":\"When enabled and a user is renamed or deleted, update any LDAP groups to which the user belongs to reflect the new name. Otherwise, the LDAP resource must maintain referential integrity with respect to group membership.\",\"type\":\"boolean\",\"required\":false,\"order\":0,\"confidential\":false,\"defaultValues\":null},\"overridable\":false,\"values\":[\"true\"]},{\"schema\":{\"name\":\"host\",\"displayName\":\"Host\",\"helpMessage\":\"The name or IP address of the host where the LDAP server is running.\",\"type\":\"java.lang.String\",\"required\":false,\"order\":0,\"confidential\":false,\"defaultValues\":null},\"overridable\":false,\"values\":[\"localhost\"]},{\"schema\":{\"name\":\"passwordHashAlgorithm\",\"displayName\":\"Password Hash Algorithm\",\"helpMessage\":\"Indicates the algorithm that the Identity system should use to hash the password. Currently supported values are SSHA, SHA, SSHA1, and SHA1. A blank value indicates that the system will not hash passwords. This will cause cleartext passwords to be stored in LDAP unless the LDAP server performs the hash (Netscape Directory Server and iPlanet Directory Server do).\",\"type\":\"java.lang.String\",\"required\":false,\"order\":0,\"confidential\":false,\"defaultValues\":null},\"overridable\":false,\"values\":[\"SHA\"]},{\"schema\":{\"name\":\"port\",\"displayName\":\"TCP Port\",\"helpMessage\":\"TCP/IP port number used to communicate with the LDAP server.\",\"type\":\"int\",\"required\":false,\"order\":0,\"confidential\":false,\"defaultValues\":null},\"overridable\":false,\"values\":[1389]},{\"schema\":{\"name\":\"vlvSortAttribute\",\"displayName\":\"VLV Sort Attribute\",\"helpMessage\":\"Specify the sort attribute to use for VLV indexes on the resource.\",\"type\":\"java.lang.String\",\"required\":false,\"order\":0,\"confidential\":false,\"defaultValues\":null},\"overridable\":false,\"values\":[]},{\"schema\":{\"name\":\"statusManagementClass\",\"displayName\":\"Status management class \",\"helpMessage\":\"Class to be used to manage enabled/disabled status. If no class is specified then identity status management wont be possible.\",\"type\":\"java.lang.String\",\"required\":false,\"order\":0,\"confidential\":false,\"defaultValues\":null},\"overridable\":false,\"values\":[\"net.tirasa.connid.bundles.ldap.commons.AttributeStatusManagement\"]},{\"schema\":{\"name\":\"accountObjectClasses\",\"displayName\":\"Account Object Classes\",\"helpMessage\":\"The object class or classes that will be used when creating new user objects in the LDAP tree. When entering more than one object class, each entry should be on its own line; do not use commas or semi-colons to separate multiple object classes. Some object classes may require that you specify all object classes in the class hierarchy.\",\"type\":\"[Ljava.lang.String;\",\"required\":false,\"order\":0,\"confidential\":false,\"defaultValues\":null},\"overridable\":false,\"values\":[\"inetOrgPerson\"]},{\"schema\":{\"name\":\"accountUserNameAttributes\",\"displayName\":\"Account User Name Attributes\",\"helpMessage\":\"Attribute or attributes which holds the account user name. They will be used when authenticating to find the LDAP entry for the user name to authenticate.\",\"type\":\"[Ljava.lang.String;\",\"required\":false,\"order\":0,\"confidential\":false,\"defaultValues\":null},\"overridable\":false,\"values\":[\"uid\"]},{\"schema\":{\"name\":\"baseContextsToSynchronize\",\"displayName\":\"Base Contexts to Synchronize\",\"helpMessage\":\"One or more starting points in the LDAP tree that will be used to determine if a change should be synchronized. The base contexts attribute will be used to synchronize a change if this property is not set.\",\"type\":\"[Ljava.lang.String;\",\"required\":false,\"order\":0,\"confidential\":false,\"defaultValues\":null},\"overridable\":false,\"values\":[\"ou=people,o=isp\",\"ou=groups,o=isp\"]},{\"schema\":{\"name\":\"accountSynchronizationFilter\",\"displayName\":\"LDAP Filter for Accounts to Synchronize\",\"helpMessage\":\"An optional LDAP filter for the objects to synchronize. Because the change log is for all objects, this filter updates only objects that match the specified filter. If you specify a filter, an object will be synchronized only if it matches the filter and includes a synchronized object class.\",\"type\":\"java.lang.String\",\"required\":false,\"order\":0,\"confidential\":false,\"defaultValues\":null},\"overridable\":false,\"values\":[]},{\"schema\":{\"name\":\"removeLogEntryObjectClassFromFilter\",\"displayName\":\"Remove Log Entry Object Class from Filter\",\"helpMessage\":\"If this property is set (the default), the filter used to fetch change log entries does not contain the \\\"changeLogEntry\\\" object class, expecting that there are no entries of other object types in the change log.\",\"type\":\"boolean\",\"required\":false,\"order\":0,\"confidential\":false,\"defaultValues\":null},\"overridable\":false,\"values\":[\"false\"]},{\"schema\":{\"name\":\"passwordDecryptionKey\",\"displayName\":\"Password Decryption Key\",\"helpMessage\":\"The key to decrypt passwords with when performing password synchronization.\",\"type\":\"org.identityconnectors.common.security.GuardedByteArray\",\"required\":false,\"order\":0,\"confidential\":false,\"defaultValues\":null},\"overridable\":false,\"values\":[]},{\"schema\":{\"name\":\"readSchema\",\"displayName\":\"Read Schema\",\"helpMessage\":\"If true, the connector will read the schema from the server. If false, the connector will provide a default schema based on the object classes in the configuration. This property must be true in order to use extended object classes.\",\"type\":\"boolean\",\"required\":false,\"order\":0,\"confidential\":false,\"defaultValues\":null},\"overridable\":false,\"values\":[\"true\"]},{\"schema\":{\"name\":\"ssl\",\"displayName\":\"SSL\",\"helpMessage\":\"Select the check box to connect to the LDAP server using SSL.\",\"type\":\"boolean\",\"required\":false,\"order\":0,\"confidential\":false,\"defaultValues\":null},\"overridable\":false,\"values\":[\"false\"]},{\"schema\":{\"name\":\"passwordAttributeToSynchronize\",\"displayName\":\"Password Attribute to Synchronize\",\"helpMessage\":\"The name of the password attribute to synchronize when performing password synchronization.\",\"type\":\"java.lang.String\",\"required\":false,\"order\":0,\"confidential\":false,\"defaultValues\":null},\"overridable\":false,\"values\":[]},{\"schema\":{\"name\":\"accountSearchFilter\",\"displayName\":\"LDAP Filter for Retrieving Accounts\",\"helpMessage\":\"An optional LDAP filter to control which accounts are returned from the LDAP resource. If no filter is specified, only accounts that include all specified object classes are returned.\",\"type\":\"java.lang.String\",\"required\":false,\"order\":0,\"confidential\":false,\"defaultValues\":null},\"overridable\":false,\"values\":[\"uid=*\"]},{\"schema\":{\"name\":\"passwordDecryptionInitializationVector\",\"displayName\":\"Password Decryption Initialization Vector\",\"helpMessage\":\"The initialization vector to decrypt passwords with when performing password synchronization.\",\"type\":\"org.identityconnectors.common.security.GuardedByteArray\",\"required\":false,\"order\":0,\"confidential\":false,\"defaultValues\":null},\"overridable\":false,\"values\":[]},{\"schema\":{\"name\":\"groupMemberAttribute\",\"displayName\":\"Group Member Attribute\",\"helpMessage\":\"The name of the group attribute that will be updated with the distinguished name of the user when the user is added to the group.\",\"type\":\"java.lang.String\",\"required\":false,\"order\":0,\"confidential\":false,\"defaultValues\":null},\"overridable\":false,\"values\":[]},{\"schema\":{\"name\":\"failover\",\"displayName\":\"Failover Servers\",\"helpMessage\":\"List all servers that should be used for failover in case the preferred server fails. If the preferred server fails, JNDI will connect to the next available server in the list. List all servers in the form of \\\"ldap://ldap.example.com:389/\\\", which follows the standard LDAP v3 URLs described in RFC 2255. Only the host and port parts of the URL are relevant in this setting.\",\"type\":\"[Ljava.lang.String;\",\"required\":false,\"order\":0,\"confidential\":false,\"defaultValues\":null},\"overridable\":false,\"values\":[]},{\"schema\":{\"name\":\"modifiersNamesToFilterOut\",\"displayName\":\"Filter Out Changes By\",\"helpMessage\":\"The names (DNs) of directory administrators to filter from the changes. Changes with the attribute \\\"modifiersName\\\" that match entries in this list will be filtered out. The standard value is the administrator name used by this adapter, to prevent loops. Entries should be of the format \\\"cn=Directory Manager\\\".\",\"type\":\"[Ljava.lang.String;\",\"required\":false,\"order\":0,\"confidential\":false,\"defaultValues\":null},\"overridable\":false,\"values\":[]},{\"schema\":{\"name\":\"groupNameAttributes\",\"displayName\":\"Group Name Attributes\",\"helpMessage\":\"Attribute or attributes which holds the group name.\",\"type\":\"[Ljava.lang.String;\",\"required\":false,\"order\":0,\"confidential\":false,\"defaultValues\":null},\"overridable\":false,\"values\":[\"cn\"]},{\"schema\":{\"name\":\"uidAttribute\",\"displayName\":\"Uid Attribute\",\"helpMessage\":\"The name of the LDAP attribute which is mapped to the Uid attribute.\",\"type\":\"java.lang.String\",\"required\":false,\"order\":0,\"confidential\":false,\"defaultValues\":null},\"overridable\":true,\"values\":[\"cn\"]},{\"schema\":{\"name\":\"gidAttribute\",\"displayName\":\"Uid Attribute for groups\",\"helpMessage\":\"The name of the LDAP attribute which is mapped to the Uid attribute for groups.\",\"type\":\"java.lang.String\",\"required\":false,\"order\":0,\"confidential\":false,\"defaultValues\":null},\"overridable\":true,\"values\":[\"cn\"]},{\"schema\":{\"name\":\"respectResourcePasswordPolicyChangeAfterReset\",\"displayName\":\"Respect Resource Password Policy Change-After-Reset\",\"helpMessage\":\"When this resource is specified in a Login Module (i.e., this resource is a pass-through authentication target) and the resource password policy is configured for change-after-reset, a user whose resource account password has been administratively reset will be required to change that password after successfully authenticating.\",\"type\":\"boolean\",\"required\":false,\"order\":0,\"confidential\":false,\"defaultValues\":null},\"overridable\":false,\"values\":[\"false\"]},{\"schema\":{\"name\":\"filterWithOrInsteadOfAnd\",\"displayName\":\"Filter with Or Instead of And\",\"helpMessage\":\"Normally the the filter used to fetch change log entries is an and-based filter retrieving an interval of change entries. If this property is set, the filter will or together the required change numbers instead.\",\"type\":\"boolean\",\"required\":false,\"order\":0,\"confidential\":false,\"defaultValues\":null},\"overridable\":false,\"values\":[\"false\"]},{\"schema\":{\"name\":\"principal\",\"displayName\":\"Principal\",\"helpMessage\":\"The distinguished name with which to authenticate to the LDAP server.\",\"type\":\"java.lang.String\",\"required\":false,\"order\":0,\"confidential\":false,\"defaultValues\":null},\"overridable\":false,\"values\":[\"uid=admin,ou=system\"]},{\"schema\":{\"name\":\"changeLogBlockSize\",\"displayName\":\"Change Log Block Size\",\"helpMessage\":\"The number of change log entries to fetch per query.\",\"type\":\"int\",\"required\":true,\"order\":0,\"confidential\":false,\"defaultValues\":null},\"overridable\":false,\"values\":[100]},{\"schema\":{\"name\":\"baseContexts\",\"displayName\":\"Base Contexts\",\"helpMessage\":\"One or more starting points in the LDAP tree that will be used when searching the tree. Searches are performed when discovering users from the LDAP server or when looking for the groups of which a user is a member.\",\"type\":\"[Ljava.lang.String;\",\"required\":false,\"order\":0,\"confidential\":false,\"defaultValues\":null},\"overridable\":true,\"values\":[\"ou=people,o=isp\",\"ou=groups,o=isp\"]},{\"schema\":{\"name\":\"passwordAttribute\",\"displayName\":\"Password Attribute\",\"helpMessage\":\"The name of the LDAP attribute which holds the password. When changing an user password, the new password is set to this attribute.\",\"type\":\"java.lang.String\",\"required\":false,\"order\":0,\"confidential\":false,\"defaultValues\":null},\"overridable\":false,\"values\":[\"userpassword\"]},{\"schema\":{\"name\":\"changeNumberAttribute\",\"displayName\":\"Change Number Attribute\",\"helpMessage\":\"The name of the change number attribute in the change log entry.\",\"type\":\"java.lang.String\",\"required\":true,\"order\":0,\"confidential\":false,\"defaultValues\":null},\"overridable\":false,\"values\":[\"changeNumber\"]},{\"schema\":{\"name\":\"objectClassesToSynchronize\",\"displayName\":\"Object Classes to Synchronize\",\"helpMessage\":\"The object classes to synchronize. The change log is for all objects; this filters updates to just the listed object classes. You should not list the superclasses of an object class unless you intend to synchronize objects with any of the superclass values. For example, if only \\\"inetOrgPerson\\\" objects should be synchronized, but the superclasses of \\\"inetOrgPerson\\\" (\\\"person\\\", \\\"organizationalperson\\\" and \\\"top\\\") should be filtered out, then list only \\\"inetOrgPerson\\\" here. All objects in LDAP are subclassed from \\\"top\\\". For this reason, you should never list \\\"top\\\", otherwise no object would be filtered.\",\"type\":\"[Ljava.lang.String;\",\"required\":true,\"order\":0,\"confidential\":false,\"defaultValues\":null},\"overridable\":false,\"values\":[\"inetOrgPerson\",\"groupOfUniqueNames\"]},{\"schema\":{\"name\":\"credentials\",\"displayName\":\"Password\",\"helpMessage\":\"Password for the principal.\",\"type\":\"org.identityconnectors.common.security.GuardedString\",\"required\":false,\"order\":0,\"confidential\":false,\"defaultValues\":null},\"overridable\":false,\"values\":[\"secret\"]},{\"schema\":{\"name\":\"attributesToSynchronize\",\"displayName\":\"Attributes to Synchronize\",\"helpMessage\":\"The names of the attributes to synchronize. This ignores updates from the change log if they do not update any of the named attributes. For example, if only \\\"department\\\" is listed, then only changes that affect \\\"department\\\" will be processed. All other updates are ignored. If blank (the default), then all changes are processed.\",\"type\":\"[Ljava.lang.String;\",\"required\":false,\"order\":0,\"confidential\":false,\"defaultValues\":null},\"overridable\":false,\"values\":[]},{\"schema\":{\"name\":\"maintainPosixGroupMembership\",\"displayName\":\"Maintain POSIX Group Membership\",\"helpMessage\":\"When enabled and a user is renamed or deleted, update any POSIX groups to which the user belongs to reflect the new name. Otherwise, the LDAP resource must maintain referential integrity with respect to group membership.\",\"type\":\"boolean\",\"required\":false,\"order\":0,\"confidential\":false,\"defaultValues\":null},\"overridable\":false,\"values\":[\"false\"]}]'/>\n   <ConnInstance_capabilities connInstance_id=\"74141a3b-0762-4720-a4aa-fc3e374ef3ef\" capability=\"CREATE\"/>\n   <ConnInstance_capabilities connInstance_id=\"74141a3b-0762-4720-a4aa-fc3e374ef3ef\" capability=\"UPDATE\"/>\n   <ConnInstance_capabilities connInstance_id=\"74141a3b-0762-4720-a4aa-fc3e374ef3ef\" capability=\"DELETE\"/>"},{"sha":"e5d23a9f9bc179bac77c16df21c7b6c346ed07c4","filename":"core/provisioning-api/src/main/java/org/apache/syncope/core/provisioning/api/MappingManager.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/f171ed2aeb6de42a5f0f2430d073fe2d9fb0af16/core%2Fprovisioning-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fapi%2FMappingManager.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/f171ed2aeb6de42a5f0f2430d073fe2d9fb0af16/core%2Fprovisioning-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fapi%2FMappingManager.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fapi%2FMappingManager.java?ref=f171ed2aeb6de42a5f0f2430d073fe2d9fb0af16","patch":"@@ -51,7 +51,7 @@ public interface MappingManager {\n      * @param orgUnit orgUnit information\n      * @return connObjectKey internal value\n      */\n-    String getConnObjectKeyValue(Realm realm, OrgUnit orgUnit);\n+    Optional<String> getConnObjectKeyValue(Realm realm, OrgUnit orgUnit);\n \n     /**\n      * Get attribute values for the given {@link Item} and any object."},{"sha":"70a8647de976272e8a0ed7e87764baa4fd12f90b","filename":"core/provisioning-java/src/main/java/org/apache/syncope/core/provisioning/java/MappingManagerImpl.java","status":"modified","additions":16,"deletions":11,"changes":27,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/f171ed2aeb6de42a5f0f2430d073fe2d9fb0af16/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2FMappingManagerImpl.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/f171ed2aeb6de42a5f0f2430d073fe2d9fb0af16/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2FMappingManagerImpl.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2FMappingManagerImpl.java?ref=f171ed2aeb6de42a5f0f2430d073fe2d9fb0af16","patch":"@@ -282,14 +282,15 @@ public Pair<String, Set<Attribute>> prepareAttrs(final Realm realm, final OrgUni\n             }\n         }\n \n-        Attribute connObjectKeyExtAttr =\n-                AttributeUtil.find(orgUnit.getConnObjectKeyItem().get().getExtAttrName(), attributes);\n-        if (connObjectKeyExtAttr != null) {\n-            attributes.remove(connObjectKeyExtAttr);\n-            attributes.add(\n-                    AttributeBuilder.build(orgUnit.getConnObjectKeyItem().get().getExtAttrName(), connObjectKey));\n+        Optional<? extends OrgUnitItem> connObjectKeyItem = orgUnit.getConnObjectKeyItem();\n+        if (connObjectKeyItem.isPresent()) {\n+            Attribute connObjectKeyExtAttr = AttributeUtil.find(connObjectKeyItem.get().getExtAttrName(), attributes);\n+            if (connObjectKeyExtAttr != null) {\n+                attributes.remove(connObjectKeyExtAttr);\n+                attributes.add(AttributeBuilder.build(connObjectKeyItem.get().getExtAttrName(), connObjectKey));\n+            }\n+            attributes.add(MappingUtils.evaluateNAME(realm, orgUnit, connObjectKey));\n         }\n-        attributes.add(MappingUtils.evaluateNAME(realm, orgUnit, connObjectKey));\n \n         return Pair.of(connObjectKey, attributes);\n     }\n@@ -619,8 +620,12 @@ public List<PlainAttrValue> getIntValues(\n     }\n \n     private String getGroupOwnerValue(final Provision provision, final Any<?> any) {\n-        Pair<String, Attribute> preparedAttr =\n-                prepareAttr(provision, MappingUtils.getConnObjectKeyItem(provision).get(), any, null);\n+        Optional<MappingItem> connObjectKeyItem = MappingUtils.getConnObjectKeyItem(provision);\n+\n+        Pair<String, Attribute> preparedAttr = null;\n+        if (connObjectKeyItem.isPresent()) {\n+            preparedAttr = prepareAttr(provision, connObjectKeyItem.get(), any, null);\n+        }\n \n         return preparedAttr == null\n                 ? null\n@@ -649,10 +654,10 @@ public Optional<String> getConnObjectKeyValue(final Any<?> any, final Provision\n \n     @Transactional(readOnly = true)\n     @Override\n-    public String getConnObjectKeyValue(final Realm realm, final OrgUnit orgUnit) {\n+    public Optional<String> getConnObjectKeyValue(final Realm realm, final OrgUnit orgUnit) {\n         OrgUnitItem orgUnitItem = orgUnit.getConnObjectKeyItem().get();\n \n-        return getIntValue(realm, orgUnitItem);\n+        return Optional.ofNullable(orgUnitItem == null ? null : getIntValue(realm, orgUnitItem));\n     }\n \n     @Transactional(readOnly = true)"},{"sha":"4a4301941e45aaab9b8000a8186b10f2b57f5ba5","filename":"core/provisioning-java/src/main/java/org/apache/syncope/core/provisioning/java/propagation/AbstractPropagationTaskExecutor.java","status":"modified","additions":39,"deletions":32,"changes":71,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/f171ed2aeb6de42a5f0f2430d073fe2d9fb0af16/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpropagation%2FAbstractPropagationTaskExecutor.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/f171ed2aeb6de42a5f0f2430d073fe2d9fb0af16/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpropagation%2FAbstractPropagationTaskExecutor.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpropagation%2FAbstractPropagationTaskExecutor.java?ref=f171ed2aeb6de42a5f0f2430d073fe2d9fb0af16","patch":"@@ -26,6 +26,7 @@\n import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n+import java.util.Optional;\n import java.util.Set;\n import java.util.stream.Collectors;\n import java.util.concurrent.atomic.AtomicReference;\n@@ -58,6 +59,7 @@\n import org.apache.syncope.core.persistence.api.entity.resource.ExternalResource;\n import org.apache.syncope.core.persistence.api.entity.resource.MappingItem;\n import org.apache.syncope.core.persistence.api.entity.resource.OrgUnit;\n+import org.apache.syncope.core.persistence.api.entity.resource.OrgUnitItem;\n import org.apache.syncope.core.persistence.api.entity.resource.Provision;\n import org.apache.syncope.core.persistence.api.entity.task.TaskUtilsFactory;\n import org.apache.syncope.core.provisioning.api.AuditManager;\n@@ -598,30 +600,32 @@ protected ConnectorObject getRemoteObject(\n                 map(schema -> schema.asLinkingMappingItem()).collect(Collectors.toSet());\n \n         ConnectorObject obj = null;\n-        try {\n-            obj = connector.getObject(\n-                    new ObjectClass(task.getObjectClassName()),\n-                    AttributeBuilder.build(\n-                            MappingUtils.getConnObjectKeyItem(provision).get().getExtAttrName(), connObjectKey),\n-                    MappingUtils.buildOperationOptions(new IteratorChain<>(\n-                            MappingUtils.getPropagationItems(provision.getMapping().getItems()).iterator(),\n-                            linkingMappingItems.iterator())));\n-\n-            for (MappingItem item : linkingMappingItems) {\n-                Attribute attr = obj.getAttributeByName(item.getExtAttrName());\n-                if (attr == null) {\n-                    virAttrCache.expire(task.getAnyType(), task.getEntityKey(), item.getIntAttrName());\n-                } else {\n-                    VirAttrCacheValue cacheValue = new VirAttrCacheValue();\n-                    cacheValue.setValues(attr.getValue());\n-                    virAttrCache.put(task.getAnyType(), task.getEntityKey(), item.getIntAttrName(), cacheValue);\n+        Optional<MappingItem> connObjectKeyItem = MappingUtils.getConnObjectKeyItem(provision);\n+        if (connObjectKeyItem.isPresent()) {\n+            try {\n+                obj = connector.getObject(\n+                        new ObjectClass(task.getObjectClassName()),\n+                        AttributeBuilder.build(connObjectKeyItem.get().getExtAttrName(), connObjectKey),\n+                        MappingUtils.buildOperationOptions(new IteratorChain<>(\n+                                MappingUtils.getPropagationItems(provision.getMapping().getItems()).iterator(),\n+                                linkingMappingItems.iterator())));\n+\n+                for (MappingItem item : linkingMappingItems) {\n+                    Attribute attr = obj.getAttributeByName(item.getExtAttrName());\n+                    if (attr == null) {\n+                        virAttrCache.expire(task.getAnyType(), task.getEntityKey(), item.getIntAttrName());\n+                    } else {\n+                        VirAttrCacheValue cacheValue = new VirAttrCacheValue();\n+                        cacheValue.setValues(attr.getValue());\n+                        virAttrCache.put(task.getAnyType(), task.getEntityKey(), item.getIntAttrName(), cacheValue);\n+                    }\n                 }\n+            } catch (TimeoutException toe) {\n+                LOG.debug(\"Request timeout\", toe);\n+                throw toe;\n+            } catch (RuntimeException ignore) {\n+                LOG.debug(\"While resolving {}\", connObjectKey, ignore);\n             }\n-        } catch (TimeoutException toe) {\n-            LOG.debug(\"Request timeout\", toe);\n-            throw toe;\n-        } catch (RuntimeException ignore) {\n-            LOG.debug(\"While resolving {}\", connObjectKey, ignore);\n         }\n \n         return obj;\n@@ -647,16 +651,19 @@ protected ConnectorObject getRemoteObject(\n                 : task.getOldConnObjectKey();\n \n         ConnectorObject obj = null;\n-        try {\n-            obj = connector.getObject(new ObjectClass(task.getObjectClassName()),\n-                    AttributeBuilder.build(orgUnit.getConnObjectKeyItem().get().getExtAttrName(), connObjectKey),\n-                    MappingUtils.buildOperationOptions(\n-                            MappingUtils.getPropagationItems(orgUnit.getItems()).iterator()));\n-        } catch (TimeoutException toe) {\n-            LOG.debug(\"Request timeout\", toe);\n-            throw toe;\n-        } catch (RuntimeException ignore) {\n-            LOG.debug(\"While resolving {}\", connObjectKey, ignore);\n+        Optional<? extends OrgUnitItem> connObjectKeyItem = orgUnit.getConnObjectKeyItem();\n+        if (connObjectKeyItem.isPresent()) {\n+            try {\n+                obj = connector.getObject(new ObjectClass(task.getObjectClassName()),\n+                        AttributeBuilder.build(connObjectKeyItem.get().getExtAttrName(), connObjectKey),\n+                        MappingUtils.buildOperationOptions(\n+                                MappingUtils.getPropagationItems(orgUnit.getItems()).iterator()));\n+            } catch (TimeoutException toe) {\n+                LOG.debug(\"Request timeout\", toe);\n+                throw toe;\n+            } catch (RuntimeException ignore) {\n+                LOG.debug(\"While resolving {}\", connObjectKey, ignore);\n+            }\n         }\n \n         return obj;"},{"sha":"5efe18c5271f56d7a60849f80435f658a530145a","filename":"core/provisioning-java/src/main/java/org/apache/syncope/core/provisioning/java/pushpull/AbstractPullResultHandler.java","status":"modified","additions":1,"deletions":5,"changes":6,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/f171ed2aeb6de42a5f0f2430d073fe2d9fb0af16/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FAbstractPullResultHandler.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/f171ed2aeb6de42a5f0f2430d073fe2d9fb0af16/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FAbstractPullResultHandler.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FAbstractPullResultHandler.java?ref=f171ed2aeb6de42a5f0f2430d073fe2d9fb0af16","patch":"@@ -795,12 +795,8 @@ protected void doHandle(final SyncDelta delta, final Provision provision) throws\n         LOG.debug(\"Transformed {} for {} as {}\",\n                 processed.getDeltaType(), processed.getUid().getUidValue(), processed.getObject().getObjectClass());\n \n-        String uid = processed.getPreviousUid() == null\n-                ? processed.getUid().getUidValue()\n-                : processed.getPreviousUid().getUidValue();\n-\n         try {\n-            List<String> anyKeys = pullUtils.findExisting(uid, processed.getObject(), provision, anyUtils);\n+            List<String> anyKeys = pullUtils.match(processed.getObject(), provision, anyUtils);\n             LOG.debug(\"Match(es) found for {} as {}: {}\",\n                     processed.getUid().getUidValue(), processed.getObject().getObjectClass(), anyKeys);\n "},{"sha":"5f743885addfdadd78d7a853f559243e5c88050b","filename":"core/provisioning-java/src/main/java/org/apache/syncope/core/provisioning/java/pushpull/AbstractPushResultHandler.java","status":"modified","additions":17,"deletions":10,"changes":27,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/f171ed2aeb6de42a5f0f2430d073fe2d9fb0af16/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FAbstractPushResultHandler.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/f171ed2aeb6de42a5f0f2430d073fe2d9fb0af16/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FAbstractPushResultHandler.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FAbstractPushResultHandler.java?ref=f171ed2aeb6de42a5f0f2430d073fe2d9fb0af16","patch":"@@ -266,11 +266,16 @@ protected void doHandle(final Any<?> any) throws JobExecutionException {\n         Optional<MappingItem> connObjectKey = MappingUtils.getConnObjectKeyItem(provision.get());\n         Optional<String> connObjecKeyValue = mappingManager.getConnObjectKeyValue(any, provision.get());\n \n-        ConnectorObject beforeObj = getRemoteObject(\n-                provision.get().getObjectClass(),\n-                connObjectKey.get().getExtAttrName(),\n-                connObjecKeyValue.get(),\n-                provision.get().getMapping().getItems().iterator());\n+        ConnectorObject beforeObj = null;\n+        if (connObjectKey.isPresent() && connObjecKeyValue.isPresent()) {\n+            beforeObj = getRemoteObject(\n+                    provision.get().getObjectClass(),\n+                    connObjectKey.get().getExtAttrName(),\n+                    connObjecKeyValue.get(),\n+                    provision.get().getMapping().getItems().iterator());\n+        } else {\n+            LOG.debug(\"ConnObjectKeyItem {} or its value {} are null\", connObjectKey, connObjecKeyValue);\n+        }\n \n         Boolean status = profile.getTask().isSyncStatus() ? enabled : null;\n \n@@ -435,11 +440,13 @@ protected void doHandle(final Any<?> any) throws JobExecutionException {\n                     result.setStatus(ProvisioningReport.Status.SUCCESS);\n                 }\n                 resultStatus = AuditElements.Result.SUCCESS;\n-                output = getRemoteObject(\n-                        provision.get().getObjectClass(),\n-                        connObjectKey.get().getExtAttrName(),\n-                        connObjecKeyValue.get(),\n-                        provision.get().getMapping().getItems().iterator());\n+                if (connObjectKey.isPresent() && connObjecKeyValue.isPresent()) {\n+                    output = getRemoteObject(\n+                            provision.get().getObjectClass(),\n+                            connObjectKey.get().getExtAttrName(),\n+                            connObjecKeyValue.get(),\n+                            provision.get().getMapping().getItems().iterator());\n+                }\n             } catch (IgnoreProvisionException e) {\n                 throw e;\n             } catch (Exception e) {"},{"sha":"b1dcf3dbf1fce9ed761b06982382e72190704d2a","filename":"core/provisioning-java/src/main/java/org/apache/syncope/core/provisioning/java/pushpull/DefaultRealmPullResultHandler.java","status":"modified","additions":1,"deletions":5,"changes":6,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/f171ed2aeb6de42a5f0f2430d073fe2d9fb0af16/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FDefaultRealmPullResultHandler.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/f171ed2aeb6de42a5f0f2430d073fe2d9fb0af16/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FDefaultRealmPullResultHandler.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FDefaultRealmPullResultHandler.java?ref=f171ed2aeb6de42a5f0f2430d073fe2d9fb0af16","patch":"@@ -679,11 +679,7 @@ private void doHandle(final SyncDelta delta, final OrgUnit orgUnit) throws JobEx\n         LOG.debug(\"Transformed {} for {} as {}\",\n                 processed.getDeltaType(), processed.getUid().getUidValue(), processed.getObject().getObjectClass());\n \n-        String uid = processed.getPreviousUid() == null\n-                ? processed.getUid().getUidValue()\n-                : processed.getPreviousUid().getUidValue();\n-\n-        List<String> keys = pullUtils.findExisting(uid, processed.getObject(), orgUnit);\n+        List<String> keys = pullUtils.match(processed.getObject(), orgUnit);\n         LOG.debug(\"Match found for {} as {}: {}\",\n                 processed.getUid().getUidValue(), processed.getObject().getObjectClass(), keys);\n "},{"sha":"434d275d17ae667bea1cdb924d6f81aea30fafb8","filename":"core/provisioning-java/src/main/java/org/apache/syncope/core/provisioning/java/pushpull/DefaultRealmPushResultHandler.java","status":"modified","additions":19,"deletions":12,"changes":31,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/f171ed2aeb6de42a5f0f2430d073fe2d9fb0af16/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FDefaultRealmPushResultHandler.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/f171ed2aeb6de42a5f0f2430d073fe2d9fb0af16/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FDefaultRealmPushResultHandler.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FDefaultRealmPushResultHandler.java?ref=f171ed2aeb6de42a5f0f2430d073fe2d9fb0af16","patch":"@@ -197,13 +197,18 @@ private void doHandle(final Realm realm) throws JobExecutionException {\n         // Try to read remote object BEFORE any actual operation\n         OrgUnit orgUnit = profile.getTask().getResource().getOrgUnit();\n         Optional<? extends OrgUnitItem> connObjectKey = orgUnit.getConnObjectKeyItem();\n-        String connObjecKeyValue = mappingManager.getConnObjectKeyValue(realm, orgUnit);\n-\n-        ConnectorObject beforeObj = getRemoteObject(\n-                orgUnit.getObjectClass(),\n-                connObjectKey.get().getExtAttrName(),\n-                connObjecKeyValue,\n-                orgUnit.getItems().iterator());\n+        Optional<String> connObjecKeyValue = mappingManager.getConnObjectKeyValue(realm, orgUnit);\n+\n+        ConnectorObject beforeObj = null;\n+        if (connObjectKey.isPresent() && connObjecKeyValue.isPresent()) {\n+            beforeObj = getRemoteObject(\n+                    orgUnit.getObjectClass(),\n+                    connObjectKey.get().getExtAttrName(),\n+                    connObjecKeyValue.get(),\n+                    orgUnit.getItems().iterator());\n+        } else {\n+            LOG.debug(\"OrgUnitItem {} or its value {} are null\", connObjectKey, connObjecKeyValue);\n+        }\n \n         if (profile.isDryRun()) {\n             if (beforeObj == null) {\n@@ -373,11 +378,13 @@ private void doHandle(final Realm realm) throws JobExecutionException {\n                     result.setStatus(ProvisioningReport.Status.SUCCESS);\n                 }\n                 resultStatus = AuditElements.Result.SUCCESS;\n-                output = getRemoteObject(\n-                        orgUnit.getObjectClass(),\n-                        connObjectKey.get().getExtAttrName(),\n-                        connObjecKeyValue,\n-                        orgUnit.getItems().iterator());\n+                if (connObjectKey.isPresent() && connObjecKeyValue.isPresent()) {\n+                    output = getRemoteObject(\n+                            orgUnit.getObjectClass(),\n+                            connObjectKey.get().getExtAttrName(),\n+                            connObjecKeyValue.get(),\n+                            orgUnit.getItems().iterator());\n+                }\n             } catch (IgnoreProvisionException e) {\n                 throw e;\n             } catch (Exception e) {"},{"sha":"fd66d1f3dd536a54a7510c61bdd6d99534858418","filename":"core/provisioning-java/src/main/java/org/apache/syncope/core/provisioning/java/pushpull/LDAPMembershipPullActions.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/f171ed2aeb6de42a5f0f2430d073fe2d9fb0af16/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FLDAPMembershipPullActions.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/f171ed2aeb6de42a5f0f2430d073fe2d9fb0af16/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FLDAPMembershipPullActions.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FLDAPMembershipPullActions.java?ref=f171ed2aeb6de42a5f0f2430d073fe2d9fb0af16","patch":"@@ -173,7 +173,7 @@ public void after(\n     public void afterAll(final ProvisioningProfile<?, ?> profile) throws JobExecutionException {\n         Map<String, Set<String>> resolvedMemberships = new HashMap<>();\n         this.memberships.forEach((name, memb) -> {\n-            Optional<String> userKey = pullUtils.findMatchingAnyKey(\n+            Optional<String> userKey = pullUtils.match(\n                     anyTypeDAO.findUser(),\n                     name,\n                     profile.getTask().getResource(),"},{"sha":"9edfd6b2b80418b1906d3c4bc2b0a9775f74a83d","filename":"core/provisioning-java/src/main/java/org/apache/syncope/core/provisioning/java/pushpull/PullJobDelegate.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/f171ed2aeb6de42a5f0f2430d073fe2d9fb0af16/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FPullJobDelegate.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/f171ed2aeb6de42a5f0f2430d073fe2d9fb0af16/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FPullJobDelegate.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FPullJobDelegate.java?ref=f171ed2aeb6de42a5f0f2430d073fe2d9fb0af16","patch":"@@ -141,7 +141,7 @@ protected void setGroupOwners(final GroupPullResultHandler ghandler) {\n                 group.setGroupOwner(null);\n                 group.setUserOwner(null);\n             } else {\n-                Optional<String> userKey = pullUtils.findMatchingAnyKey(\n+                Optional<String> userKey = pullUtils.match(\n                         anyTypeDAO.findUser(),\n                         entry.getValue(),\n                         ghandler.getProfile().getTask().getResource(),\n@@ -150,7 +150,7 @@ protected void setGroupOwners(final GroupPullResultHandler ghandler) {\n                 if (userKey.isPresent()) {\n                     group.setUserOwner(userDAO.find(userKey.get()));\n                 } else {\n-                    Optional<String> groupKey = pullUtils.findMatchingAnyKey(\n+                    Optional<String> groupKey = pullUtils.match(\n                             anyTypeDAO.findGroup(),\n                             entry.getValue(),\n                             ghandler.getProfile().getTask().getResource(),"},{"sha":"77ca4e1a76bd1b4712d4675225b1d495efd8c995","filename":"core/provisioning-java/src/main/java/org/apache/syncope/core/provisioning/java/pushpull/PullUtils.java","status":"modified","additions":64,"deletions":43,"changes":107,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/f171ed2aeb6de42a5f0f2430d073fe2d9fb0af16/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FPullUtils.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/f171ed2aeb6de42a5f0f2430d073fe2d9fb0af16/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FPullUtils.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpushpull%2FPullUtils.java?ref=f171ed2aeb6de42a5f0f2430d073fe2d9fb0af16","patch":"@@ -115,7 +115,7 @@ public class PullUtils {\n     @Autowired\n     private IntAttrNameParser intAttrNameParser;\n \n-    public Optional<String> findMatchingAnyKey(\n+    public Optional<String> match(\n             final AnyType anyType,\n             final String name,\n             final ExternalResource resource,\n@@ -146,7 +146,7 @@ public Optional<String> findMatchingAnyKey(\n \n             ConnectorObject connObj = found.iterator().next();\n             try {\n-                List<String> anyKeys = findExisting(connObj.getUid().getUidValue(), connObj, provision.get(), anyUtils);\n+                List<String> anyKeys = match(connObj, provision.get(), anyUtils);\n                 if (anyKeys.isEmpty()) {\n                     LOG.debug(\"No matching {} found for {}, aborting\", anyUtils.getAnyTypeKind(), connObj);\n                 } else {\n@@ -172,19 +172,29 @@ private AnyDAO<?> getAnyDAO(final AnyTypeKind anyTypeKind) {\n                         : groupDAO;\n     }\n \n-    private List<String> findByConnObjectKeyItem(\n-            final String uid, final Provision provision, final AnyUtils anyUtils) {\n+    private List<String> findByConnObjectKey(\n+            final ConnectorObject connObj, final Provision provision, final AnyUtils anyUtils) {\n+\n+        String connObjectKey = null;\n \n         Optional<MappingItem> connObjectKeyItem = MappingUtils.getConnObjectKeyItem(provision);\n+        if (connObjectKeyItem.isPresent()) {\n+            Attribute connObjectKeyAttr = connObj.getAttributeByName(connObjectKeyItem.get().getExtAttrName());\n+            if (connObjectKeyAttr != null) {\n+                connObjectKey = AttributeUtil.getStringValue(connObjectKeyAttr);\n+            }\n+        }\n+        if (connObjectKey == null) {\n+            return Collections.emptyList();\n+        }\n \n-        String transfUid = uid;\n         for (ItemTransformer transformer : MappingUtils.getItemTransformers(connObjectKeyItem.get())) {\n             List<Object> output = transformer.beforePull(\n                     connObjectKeyItem.get(),\n                     null,\n-                    Collections.<Object>singletonList(transfUid));\n+                    Collections.<Object>singletonList(connObjectKey));\n             if (output != null && !output.isEmpty()) {\n-                transfUid = output.get(0).toString();\n+                connObjectKey = output.get(0).toString();\n             }\n         }\n \n@@ -203,25 +213,25 @@ private List<String> findByConnObjectKeyItem(\n         if (intAttrName.getField() != null) {\n             switch (intAttrName.getField()) {\n                 case \"key\":\n-                    Any<?> any = getAnyDAO(provision.getAnyType().getKind()).find(transfUid);\n+                    Any<?> any = getAnyDAO(provision.getAnyType().getKind()).find(connObjectKey);\n                     if (any != null) {\n                         result.add(any.getKey());\n                     }\n                     break;\n \n                 case \"username\":\n-                    User user = userDAO.findByUsername(transfUid);\n+                    User user = userDAO.findByUsername(connObjectKey);\n                     if (user != null) {\n                         result.add(user.getKey());\n                     }\n                     break;\n \n                 case \"name\":\n-                    Group group = groupDAO.findByName(transfUid);\n+                    Group group = groupDAO.findByName(connObjectKey);\n                     if (group != null) {\n                         result.add(group.getKey());\n                     }\n-                    AnyObject anyObject = anyObjectDAO.findByName(transfUid);\n+                    AnyObject anyObject = anyObjectDAO.findByName(connObjectKey);\n                     if (anyObject != null) {\n                         result.add(anyObject.getKey());\n                     }\n@@ -236,29 +246,25 @@ private List<String> findByConnObjectKeyItem(\n \n                     PlainSchema schema = plainSchemaDAO.find(intAttrName.getSchemaName());\n                     if (schema == null) {\n-                        value.setStringValue(transfUid);\n+                        value.setStringValue(connObjectKey);\n                     } else {\n                         try {\n-                            value.parseValue(schema, transfUid);\n+                            value.parseValue(schema, connObjectKey);\n                         } catch (ParsingValidationException e) {\n-                            LOG.error(\"While parsing provided __UID__ {}\", transfUid, e);\n-                            value.setStringValue(transfUid);\n+                            LOG.error(\"While parsing provided __UID__ {}\", value, e);\n+                            value.setStringValue(connObjectKey);\n                         }\n                     }\n \n-                    List<? extends Any<?>> anys = getAnyDAO(provision.getAnyType().getKind()).\n-                            findByPlainAttrValue(intAttrName.getSchemaName(), value);\n-                    anys.forEach(any -> {\n-                        result.add(any.getKey());\n-                    });\n+                    result.addAll(getAnyDAO(provision.getAnyType().getKind()).\n+                            findByPlainAttrValue(intAttrName.getSchemaName(), value).stream().\n+                            map(Entity::getKey).collect(Collectors.toList()));\n                     break;\n \n                 case DERIVED:\n-                    anys = getAnyDAO(provision.getAnyType().getKind()).\n-                            findByDerAttrValue(intAttrName.getSchemaName(), transfUid);\n-                    anys.forEach(any -> {\n-                        result.add(any.getKey());\n-                    });\n+                    result.addAll(getAnyDAO(provision.getAnyType().getKind()).\n+                            findByDerAttrValue(intAttrName.getSchemaName(), connObjectKey).stream().\n+                            map(Entity::getKey).collect(Collectors.toList()));\n                     break;\n \n                 default:\n@@ -279,16 +285,14 @@ private List<String> findByCorrelationRule(\n     }\n \n     /**\n-     * Find any objects based on mapped uid value (or previous uid value, if updated).\n+     * Finds internal entities based on external attributes and mapping.\n      *\n-     * @param uid for finding by connObjectKey\n-     * @param connObj for finding by attribute value\n-     * @param provision external resource\n-     * @param anyUtils any util\n-     * @return list of matching users / groups\n+     * @param connObj external attributes\n+     * @param provision mapping\n+     * @param anyUtils any utils\n+     * @return list of matching users' / groups' / any objects' keys\n      */\n-    public List<String> findExisting(\n-            final String uid,\n+    public List<String> match(\n             final ConnectorObject connObj,\n             final Provision provision,\n             final AnyUtils anyUtils) {\n@@ -309,27 +313,44 @@ public List<String> findExisting(\n         try {\n             return rule.isPresent()\n                     ? findByCorrelationRule(connObj, provision, rule.get(), anyUtils.getAnyTypeKind())\n-                    : findByConnObjectKeyItem(uid, provision, anyUtils);\n+                    : findByConnObjectKey(connObj, provision, anyUtils);\n         } catch (RuntimeException e) {\n+            LOG.error(\"Could not match {} with any existing {}\", connObj, provision.getAnyType(), e);\n             return Collections.<String>emptyList();\n         }\n     }\n \n-    public List<String> findExisting(\n-            final String uid,\n+    /**\n+     * Finds internal realms based on external attributes and mapping.\n+     *\n+     * @param connObj external attributes\n+     * @param orgUnit mapping\n+     * @return list of matching realms' keys.\n+     */\n+    public List<String> match(\n             final ConnectorObject connObj,\n             final OrgUnit orgUnit) {\n \n+        String connObjectKey = null;\n+\n         Optional<? extends OrgUnitItem> connObjectKeyItem = orgUnit.getConnObjectKeyItem();\n+        if (connObjectKeyItem != null) {\n+            Attribute connObjectKeyAttr = connObj.getAttributeByName(connObjectKeyItem.get().getExtAttrName());\n+            if (connObjectKeyAttr != null) {\n+                connObjectKey = AttributeUtil.getStringValue(connObjectKeyAttr);\n+            }\n+        }\n+        if (connObjectKey == null) {\n+            return Collections.emptyList();\n+        }\n \n-        String transfUid = uid;\n         for (ItemTransformer transformer : MappingUtils.getItemTransformers(connObjectKeyItem.get())) {\n             List<Object> output = transformer.beforePull(\n                     connObjectKeyItem.get(),\n                     null,\n-                    Collections.<Object>singletonList(transfUid));\n+                    Collections.<Object>singletonList(connObjectKey));\n             if (output != null && !output.isEmpty()) {\n-                transfUid = output.get(0).toString();\n+                connObjectKey = output.get(0).toString();\n             }\n         }\n \n@@ -338,19 +359,19 @@ public List<String> findExisting(\n         Realm realm;\n         switch (connObjectKeyItem.get().getIntAttrName()) {\n             case \"key\":\n-                realm = realmDAO.find(transfUid);\n+                realm = realmDAO.find(connObjectKey);\n                 if (realm != null) {\n                     result.add(realm.getKey());\n                 }\n                 break;\n \n             case \"name\":\n-                result.addAll(realmDAO.findByName(transfUid).stream().\n-                        map(r -> r.getKey()).collect(Collectors.toList()));\n+                result.addAll(realmDAO.findByName(connObjectKey).stream().\n+                        map(Entity::getKey).collect(Collectors.toList()));\n                 break;\n \n             case \"fullpath\":\n-                realm = realmDAO.findByFullPath(transfUid);\n+                realm = realmDAO.findByFullPath(connObjectKey);\n                 if (realm != null) {\n                     result.add(realm.getKey());\n                 }"}]}