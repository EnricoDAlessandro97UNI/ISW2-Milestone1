{"sha":"73f73f20692910e6f0c2acf27d5d8bd7982e6b6c","node_id":"MDY6Q29tbWl0NjM2ODc5MDYyOjczZjczZjIwNjkyOTEwZTZmMGMyYWNmMjdkNWQ4YmQ3OTgyZTZiNmM=","commit":{"author":{"name":"massi","email":"massimiliano.perrone@tirasa.net","date":"2015-10-22T15:36:58Z"},"committer":{"name":"massi","email":"massimiliano.perrone@tirasa.net","date":"2015-10-22T15:37:31Z"},"message":"refactoring of the task stack , SYNCOPE-158","tree":{"sha":"5f5dd633e7466d1d9800914aac214477b2ca970f","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/git/trees/5f5dd633e7466d1d9800914aac214477b2ca970f"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/git/commits/73f73f20692910e6f0c2acf27d5d8bd7982e6b6c","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/73f73f20692910e6f0c2acf27d5d8bd7982e6b6c","html_url":"https://github.com/EnricoDAlessandro97UNI/syncope/commit/73f73f20692910e6f0c2acf27d5d8bd7982e6b6c","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/73f73f20692910e6f0c2acf27d5d8bd7982e6b6c/comments","author":{"login":"massx1","id":1792923,"node_id":"MDQ6VXNlcjE3OTI5MjM=","avatar_url":"https://avatars.githubusercontent.com/u/1792923?v=4","gravatar_id":"","url":"https://api.github.com/users/massx1","html_url":"https://github.com/massx1","followers_url":"https://api.github.com/users/massx1/followers","following_url":"https://api.github.com/users/massx1/following{/other_user}","gists_url":"https://api.github.com/users/massx1/gists{/gist_id}","starred_url":"https://api.github.com/users/massx1/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/massx1/subscriptions","organizations_url":"https://api.github.com/users/massx1/orgs","repos_url":"https://api.github.com/users/massx1/repos","events_url":"https://api.github.com/users/massx1/events{/privacy}","received_events_url":"https://api.github.com/users/massx1/received_events","type":"User","site_admin":false},"committer":{"login":"massx1","id":1792923,"node_id":"MDQ6VXNlcjE3OTI5MjM=","avatar_url":"https://avatars.githubusercontent.com/u/1792923?v=4","gravatar_id":"","url":"https://api.github.com/users/massx1","html_url":"https://github.com/massx1","followers_url":"https://api.github.com/users/massx1/followers","following_url":"https://api.github.com/users/massx1/following{/other_user}","gists_url":"https://api.github.com/users/massx1/gists{/gist_id}","starred_url":"https://api.github.com/users/massx1/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/massx1/subscriptions","organizations_url":"https://api.github.com/users/massx1/orgs","repos_url":"https://api.github.com/users/massx1/repos","events_url":"https://api.github.com/users/massx1/events{/privacy}","received_events_url":"https://api.github.com/users/massx1/received_events","type":"User","site_admin":false},"parents":[{"sha":"23d8047389206d870450ab73e0f7bf24c3d65e2e","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/23d8047389206d870450ab73e0f7bf24c3d65e2e","html_url":"https://github.com/EnricoDAlessandro97UNI/syncope/commit/23d8047389206d870450ab73e0f7bf24c3d65e2e"}],"stats":{"total":1408,"additions":823,"deletions":585},"files":[{"sha":"931418770622a52177c11aacb218dfb931cb0519","filename":"client/cli/src/main/java/org/apache/syncope/client/cli/Input.java","status":"modified","additions":4,"deletions":0,"changes":4,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/73f73f20692910e6f0c2acf27d5d8bd7982e6b6c/client%2Fcli%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fcli%2FInput.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/73f73f20692910e6f0c2acf27d5d8bd7982e6b6c/client%2Fcli%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fcli%2FInput.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/client%2Fcli%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fcli%2FInput.java?ref=73f73f20692910e6f0c2acf27d5d8bd7982e6b6c","patch":"@@ -67,6 +67,10 @@ public String[] getParameters() {\n     public String firstParameter() {\n         return parameters[0];\n     }\n+    \n+    public String secondParameter() {\n+        return parameters[1];\n+    }\n \n     public String lastParameter() {\n         return parameters[parameters.length - 1];"},{"sha":"deb00bf6fa1c4757f827cc3ec53cfcb2b26b4592","filename":"client/cli/src/main/java/org/apache/syncope/client/cli/commands/TaskCommand.java","status":"removed","additions":0,"deletions":585,"changes":585,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/23d8047389206d870450ab73e0f7bf24c3d65e2e/client%2Fcli%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fcli%2Fcommands%2FTaskCommand.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/23d8047389206d870450ab73e0f7bf24c3d65e2e/client%2Fcli%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fcli%2Fcommands%2FTaskCommand.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/client%2Fcli%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fcli%2Fcommands%2FTaskCommand.java?ref=23d8047389206d870450ab73e0f7bf24c3d65e2e","patch":"@@ -1,585 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-package org.apache.syncope.client.cli.commands;\n-\n-import org.apache.syncope.client.cli.commands.logger.LoggerCommand;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Map;\n-import javax.xml.ws.WebServiceException;\n-import org.apache.commons.lang3.StringUtils;\n-import org.apache.syncope.client.cli.Command;\n-import org.apache.syncope.client.cli.Input;\n-import org.apache.syncope.client.cli.SyncopeServices;\n-import org.apache.syncope.client.cli.messages.Messages;\n-import org.apache.syncope.client.cli.util.CommandUtils;\n-import org.apache.syncope.common.lib.SyncopeClientException;\n-import org.apache.syncope.common.lib.to.AbstractTaskTO;\n-import org.apache.syncope.common.lib.to.AnyTO;\n-import org.apache.syncope.common.lib.to.NotificationTaskTO;\n-import org.apache.syncope.common.lib.to.PropagationTaskTO;\n-import org.apache.syncope.common.lib.to.PushTaskTO;\n-import org.apache.syncope.common.lib.to.SchedTaskTO;\n-import org.apache.syncope.common.lib.to.SyncTaskTO;\n-import org.apache.syncope.common.lib.to.TaskExecTO;\n-import org.apache.syncope.common.lib.types.JobStatusType;\n-import org.apache.syncope.common.lib.types.TaskType;\n-import org.apache.syncope.common.rest.api.beans.TaskQuery;\n-import org.apache.syncope.common.rest.api.service.TaskService;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-@Command(name = \"task\")\n-public class TaskCommand extends AbstractCommand {\n-\n-    private static final Logger LOG = LoggerFactory.getLogger(LoggerCommand.class);\n-\n-    private static final String HELP_MESSAGE = \"Usage: task [options]\\n\"\n-            + \"  Options:\\n\"\n-            + \"    --help \\n\"\n-            + \"    --list-task \\n\"\n-            + \"       Syntax: --list-task {TASK-TYPE} \\n\"\n-            + \"          Task type: NOTIFICATION / PROPAGATION / PUSH / SCHEDULED / SYNCHRONIZATION\\n\"\n-            + \"    --list-running-jobs \\n\"\n-            + \"    --list-scheduled-jobs \\n\"\n-            + \"    --read \\n\"\n-            + \"       Syntax: --read {TASK-ID} {TASK-ID} [...]\\n\"\n-            + \"    --read-execution \\n\"\n-            + \"       Syntax: --read-execution {TASK-EXEC-ID} {TASK-EXEC-ID} [...]\\n\"\n-            + \"    --delete \\n\"\n-            + \"       Syntax: --delete {TASK-ID} {TASK-ID} [...]\\n\"\n-            + \"    --delete-execution \\n\"\n-            + \"       Syntax: --delete-execution {TASK-EXEC-ID} {TASK-EXEC-ID} [...]\\n\"\n-            + \"    --execute \\n\"\n-            + \"       Syntax: --execute {TASK-ID} {DRY-RUN}\"\n-            + \"          Dry run: true / false\";\n-    \n-    @Override\n-    public void execute(final Input input) {\n-        LOG.debug(\"Option: {}\", input.getOption());\n-        LOG.debug(\"Parameters:\");\n-        for (final String parameter : input.getParameters()) {\n-            LOG.debug(\"   > \" + parameter);\n-        }\n-\n-        final String[] parameters = input.getParameters();\n-\n-        if (StringUtils.isBlank(input.getOption())) {\n-            input.setOption(Options.HELP.getOptionName());\n-        }\n-\n-        final TaskService taskService = SyncopeServices.get(TaskService.class);\n-        switch (Options.fromName(input.getOption())) {\n-            case LIST_TASK:\n-                final String listTaskErrorMessage = \"task --list-task {TASK-TYPE}\\n\"\n-                        + \"   Task type: NOTIFICATION / PROPAGATION / PUSH / SCHEDULED / SYNCHRONIZATION\";\n-                if (parameters.length == 1) {\n-                    try {\n-                        final TaskType taskType = TaskType.valueOf(parameters[0]);\n-                        for (final AbstractTaskTO taskTO : taskService.list(taskType, new TaskQuery()).getResult()) {\n-                            switch (taskType) {\n-                                case NOTIFICATION:\n-                                    final NotificationTaskTO notificationTaskTO = (NotificationTaskTO) taskTO;\n-                                    System.out.println(\"\");\n-                                    System.out.println(\" - Notification task key: \" + notificationTaskTO.getKey());\n-                                    System.out.println(\"     executed: \" + notificationTaskTO.isExecuted());\n-                                    System.out.println(\"     sender: \" + notificationTaskTO.getSender());\n-                                    System.out.println(\"     subjetc: \" + notificationTaskTO.getSubject());\n-                                    System.out.println(\"     text body: \" + notificationTaskTO.getTextBody());\n-                                    System.out.println(\"     html body: \" + notificationTaskTO.getHtmlBody());\n-                                    System.out.println(\"     latest execution status: \"\n-                                            + notificationTaskTO.getLatestExecStatus());\n-                                    System.out.println(\"     start date: \" + notificationTaskTO.getStartDate());\n-                                    System.out.println(\"     end date: \" + notificationTaskTO.getEndDate());\n-                                    System.out.println(\"     recipients: \" + notificationTaskTO.getRecipients());\n-                                    System.out.println(\"     trace level: \" + notificationTaskTO.getTraceLevel());\n-                                    for (final TaskExecTO taskExecTO : notificationTaskTO.getExecutions()) {\n-                                        printTaskExecTO(taskExecTO);\n-                                    }\n-                                    System.out.println(\"\");\n-                                    break;\n-                                case PROPAGATION:\n-                                    final PropagationTaskTO propagationTaskTO = (PropagationTaskTO) taskTO;\n-                                    System.out.println(\"\");\n-                                    System.out.println(\" - Propagation task key: \" + propagationTaskTO.getKey());\n-                                    System.out.println(\"     resource: \" + propagationTaskTO.getResource());\n-                                    System.out.println(\"     any key: \" + propagationTaskTO.getAnyKey());\n-                                    System.out.println(\"     any type kind: \" + propagationTaskTO.getAnyTypeKind());\n-                                    System.out.println(\"     connector object key: \"\n-                                            + propagationTaskTO.getConnObjectKey());\n-                                    System.out.println(\"     old connector object key: \"\n-                                            + propagationTaskTO.getOldConnObjectKey());\n-                                    System.out.println(\"     latest execution status: \"\n-                                            + propagationTaskTO.getLatestExecStatus());\n-                                    System.out.println(\"     class name: \" + propagationTaskTO.getObjectClassName());\n-                                    System.out.println(\"     xml attribute: \" + propagationTaskTO.getXmlAttributes());\n-                                    System.out.println(\"     start date: \" + propagationTaskTO.getStartDate());\n-                                    System.out.println(\"     end date: \" + propagationTaskTO.getEndDate());\n-                                    System.out.println(\"     operation: \" + propagationTaskTO.getOperation());\n-                                    for (final TaskExecTO taskExecTO : propagationTaskTO.getExecutions()) {\n-                                        printTaskExecTO(taskExecTO);\n-                                    }\n-                                    System.out.println(\"\");\n-                                    break;\n-                                case PUSH:\n-                                    final PushTaskTO pushTaskTO = (PushTaskTO) taskTO;\n-                                    System.out.println(\"\");\n-                                    System.out.println(\" - Push task key: \" + pushTaskTO.getKey());\n-                                    System.out.println(\"     name: \" + pushTaskTO.getName());\n-                                    System.out.println(\"     resource: \" + pushTaskTO.getResource());\n-                                    System.out.println(\"     cron expression: \" + pushTaskTO.getCronExpression());\n-                                    System.out.println(\"     description: \" + pushTaskTO.getDescription());\n-                                    System.out.println(\"     is perform create: \" + pushTaskTO.isPerformCreate());\n-                                    System.out.println(\"     is perform delete: \" + pushTaskTO.isPerformDelete());\n-                                    System.out.println(\"     is perform update: \" + pushTaskTO.isPerformUpdate());\n-                                    System.out.println(\"     is sync status: \" + pushTaskTO.isSyncStatus());\n-                                    System.out.println(\"     start date: \" + pushTaskTO.getStartDate());\n-                                    System.out.println(\"     end date: \" + pushTaskTO.getEndDate());\n-                                    System.out.println(\"     last execution: \" + pushTaskTO.getLastExec());\n-                                    System.out.println(\"     next execution: \" + pushTaskTO.getNextExec());\n-                                    System.out.println(\"     latest execution status: \"\n-                                            + pushTaskTO.getLatestExecStatus());\n-                                    System.out.println(\"     filters: \" + pushTaskTO.getFilters());\n-                                    System.out.println(\"     delegate class: \" + pushTaskTO.getJobDelegateClassName());\n-                                    System.out.println(\"     action class: \" + pushTaskTO.getActionsClassNames());\n-                                    System.out.println(\"     matching rule: \" + pushTaskTO.getMatchingRule());\n-                                    System.out.println(\"     not matching rule: \" + pushTaskTO.getUnmatchingRule());\n-                                    for (final TaskExecTO taskExecTO : pushTaskTO.getExecutions()) {\n-                                        printTaskExecTO(taskExecTO);\n-                                    }\n-                                    System.out.println(\"\");\n-                                    break;\n-                                case SCHEDULED:\n-                                    final SchedTaskTO schedTaskTO = (SchedTaskTO) taskTO;\n-                                    System.out.println(\"\");\n-                                    System.out.println(\" - Scheduled task key: \" + schedTaskTO.getKey());\n-                                    System.out.println(\"     name: \" + schedTaskTO.getName());\n-                                    System.out.println(\"     cron expression: \" + schedTaskTO.getCronExpression());\n-                                    System.out.println(\"     description: \" + schedTaskTO.getDescription());\n-                                    System.out.println(\"     start date: \" + schedTaskTO.getStartDate());\n-                                    System.out.println(\"     end date: \" + schedTaskTO.getEndDate());\n-                                    System.out.println(\"     last execution: \" + schedTaskTO.getLastExec());\n-                                    System.out.println(\"     next execution: \" + schedTaskTO.getNextExec());\n-                                    System.out.println(\"     latest execution status: \"\n-                                            + schedTaskTO.getLatestExecStatus());\n-                                    System.out.println(\"     job delegate class: \"\n-                                            + schedTaskTO.getJobDelegateClassName());\n-                                    for (final TaskExecTO taskExecTO : schedTaskTO.getExecutions()) {\n-                                        printTaskExecTO(taskExecTO);\n-                                    }\n-                                    System.out.println(\"\");\n-                                    break;\n-                                case SYNCHRONIZATION:\n-                                    final SyncTaskTO syncTaskTO = (SyncTaskTO) taskTO;\n-                                    System.out.println(\"\");\n-                                    System.out.println(\" - Sync task key: \" + syncTaskTO.getKey());\n-                                    System.out.println(\"     name: \" + syncTaskTO.getName());\n-                                    System.out.println(\"     resource: \" + syncTaskTO.getResource());\n-                                    System.out.println(\"     realm destination: \" + syncTaskTO.getDestinationRealm());\n-                                    System.out.println(\"     cron expression: \" + syncTaskTO.getCronExpression());\n-                                    System.out.println(\"     description: \" + syncTaskTO.getDescription());\n-                                    System.out.println(\"     is full reconciliation: \"\n-                                            + syncTaskTO.isFullReconciliation());\n-                                    System.out.println(\"     is perform create: \" + syncTaskTO.isPerformCreate());\n-                                    System.out.println(\"     is perform delete: \" + syncTaskTO.isPerformDelete());\n-                                    System.out.println(\"     is perform update: \" + syncTaskTO.isPerformUpdate());\n-                                    System.out.println(\"     is sync status: \" + syncTaskTO.isSyncStatus());\n-                                    System.out.println(\"     templates:\");\n-                                    for (Map.Entry<String, AnyTO> entrySet : syncTaskTO.getTemplates().entrySet()) {\n-                                        final String key = entrySet.getKey();\n-                                        final AnyTO value = entrySet.getValue();\n-                                        System.out.println(\"        \" + key + \" key: \" + value.getKey()\n-                                                + \" of realm\" + value.getRealm()\n-                                                + \" on resource \" + value.getResources());\n-\n-                                    }\n-                                    System.out.println(\"     start date: \" + syncTaskTO.getStartDate());\n-                                    System.out.println(\"     end date: \" + syncTaskTO.getEndDate());\n-                                    System.out.println(\"     next execution: \" + syncTaskTO.getNextExec());\n-                                    System.out.println(\"     last execution: \" + syncTaskTO.getLastExec());\n-                                    System.out.println(\"     latest execution status: \"\n-                                            + syncTaskTO.getLatestExecStatus());\n-                                    System.out.println(\"     job delegate class: \"\n-                                            + syncTaskTO.getJobDelegateClassName());\n-                                    System.out.println(\"     action class name: \" + syncTaskTO.getActionsClassNames());\n-                                    System.out.println(\"     matching rule: \" + syncTaskTO.getMatchingRule());\n-                                    System.out.println(\"     unmatching rule: \" + syncTaskTO.getUnmatchingRule());\n-                                    for (final TaskExecTO taskExecTO : syncTaskTO.getExecutions()) {\n-                                        printTaskExecTO(taskExecTO);\n-                                    }\n-                                    System.out.println(\"\");\n-                                    break;\n-                                default:\n-                                    break;\n-                            }\n-                        }\n-                    } catch (final SyncopeClientException ex) {\n-                        Messages.printMessage(ex.getMessage());\n-                    } catch (final IllegalArgumentException ex) {\n-                        Messages.printTypeNotValidMessage(\n-                                \"task\", parameters[0], CommandUtils.fromEnumToArray(TaskType.class));\n-                    }\n-                } else {\n-                    Messages.printCommandOptionMessage(listTaskErrorMessage);\n-                }\n-                break;\n-            case LIST_RUNNING_JOBS:\n-                try {\n-                    for (final TaskExecTO taskExecTO : taskService.listJobs(JobStatusType.RUNNING)) {\n-                        printTaskExecTO(taskExecTO);\n-                    }\n-                } catch (final SyncopeClientException ex) {\n-                    Messages.printMessage(ex.getMessage());\n-                }\n-                break;\n-            case LIST_SCHEDULED_JOBS:\n-                try {\n-                    for (final TaskExecTO taskExecTO : taskService.listJobs(JobStatusType.SCHEDULED)) {\n-                        printTaskExecTO(taskExecTO);\n-                    }\n-                } catch (final SyncopeClientException ex) {\n-                    Messages.printMessage(ex.getMessage());\n-                }\n-                break;\n-            case READ:\n-                final String readErrorMessage = \"task --read {TASK-ID} {TASK-ID} [...]\";\n-                if (parameters.length >= 1) {\n-                    for (final String parameter : parameters) {\n-                        try {\n-                            final AbstractTaskTO taskTO = taskService.read(Long.valueOf(parameter));\n-                            if (taskTO instanceof NotificationTaskTO) {\n-                                final NotificationTaskTO notificationTaskTO = (NotificationTaskTO) taskTO;\n-                                System.out.println(\"\");\n-                                System.out.println(\" - Notification task key: \" + notificationTaskTO.getKey());\n-                                System.out.println(\"     executed: \" + notificationTaskTO.isExecuted());\n-                                System.out.println(\"     sender: \" + notificationTaskTO.getSender());\n-                                System.out.println(\"     subjetc: \" + notificationTaskTO.getSubject());\n-                                System.out.println(\"     text body: \" + notificationTaskTO.getTextBody());\n-                                System.out.println(\"     html body: \" + notificationTaskTO.getHtmlBody());\n-                                System.out.println(\"     latest execution status: \"\n-                                        + notificationTaskTO.getLatestExecStatus());\n-                                System.out.println(\"     start date: \" + notificationTaskTO.getStartDate());\n-                                System.out.println(\"     end date: \" + notificationTaskTO.getEndDate());\n-                                System.out.println(\"     recipients: \" + notificationTaskTO.getRecipients());\n-                                System.out.println(\"     trace level: \" + notificationTaskTO.getTraceLevel());\n-                                for (final TaskExecTO taskExecTO : notificationTaskTO.getExecutions()) {\n-                                    printTaskExecTO(taskExecTO);\n-                                }\n-                                System.out.println(\"\");\n-                            } else if (taskTO instanceof PropagationTaskTO) {\n-                                final PropagationTaskTO propagationTaskTO = (PropagationTaskTO) taskTO;\n-                                System.out.println(\"\");\n-                                System.out.println(\" - Propagation task key: \" + propagationTaskTO.getKey());\n-                                System.out.println(\"     resource: \" + propagationTaskTO.getResource());\n-                                System.out.println(\"     any key: \" + propagationTaskTO.getAnyKey());\n-                                System.out.println(\"     any type kind: \" + propagationTaskTO.getAnyTypeKind());\n-                                System.out.println(\"     connector object key: \"\n-                                        + propagationTaskTO.getConnObjectKey());\n-                                System.out.println(\"     old connector object key: \"\n-                                        + propagationTaskTO.getOldConnObjectKey());\n-                                System.out.println(\"     latest execution status: \"\n-                                        + propagationTaskTO.getLatestExecStatus());\n-                                System.out.println(\"     class name: \" + propagationTaskTO.getObjectClassName());\n-                                System.out.println(\"     xml attribute: \" + propagationTaskTO.getXmlAttributes());\n-                                System.out.println(\"     start date: \" + propagationTaskTO.getStartDate());\n-                                System.out.println(\"     end date: \" + propagationTaskTO.getEndDate());\n-                                System.out.println(\"     operation: \" + propagationTaskTO.getOperation());\n-                                for (final TaskExecTO taskExecTO : propagationTaskTO.getExecutions()) {\n-                                    printTaskExecTO(taskExecTO);\n-                                }\n-                                System.out.println(\"\");\n-                            } else if (taskTO instanceof PushTaskTO) {\n-                                final PushTaskTO pushTaskTO = (PushTaskTO) taskTO;\n-                                System.out.println(\"\");\n-                                System.out.println(\" - Push task key: \" + pushTaskTO.getKey());\n-                                System.out.println(\"     name: \" + pushTaskTO.getName());\n-                                System.out.println(\"     resource: \" + pushTaskTO.getResource());\n-                                System.out.println(\"     cron expression: \" + pushTaskTO.getCronExpression());\n-                                System.out.println(\"     description: \" + pushTaskTO.getDescription());\n-                                System.out.println(\"     is perform create: \" + pushTaskTO.isPerformCreate());\n-                                System.out.println(\"     is perform delete: \" + pushTaskTO.isPerformDelete());\n-                                System.out.println(\"     is perform update: \" + pushTaskTO.isPerformUpdate());\n-                                System.out.println(\"     is sync status: \" + pushTaskTO.isSyncStatus());\n-                                System.out.println(\"     start date: \" + pushTaskTO.getStartDate());\n-                                System.out.println(\"     end date: \" + pushTaskTO.getEndDate());\n-                                System.out.println(\"     last execution: \" + pushTaskTO.getLastExec());\n-                                System.out.println(\"     next execution: \" + pushTaskTO.getNextExec());\n-                                System.out.println(\"     latest execution status: \"\n-                                        + pushTaskTO.getLatestExecStatus());\n-                                System.out.println(\"     filters: \" + pushTaskTO.getFilters());\n-                                System.out.println(\"     delegate class: \" + pushTaskTO.getJobDelegateClassName());\n-                                System.out.println(\"     action class: \" + pushTaskTO.getActionsClassNames());\n-                                System.out.println(\"     matching rule: \" + pushTaskTO.getMatchingRule());\n-                                System.out.println(\"     not matching rule: \" + pushTaskTO.getUnmatchingRule());\n-                                for (final TaskExecTO taskExecTO : pushTaskTO.getExecutions()) {\n-                                    printTaskExecTO(taskExecTO);\n-                                }\n-                                System.out.println(\"\");\n-                            } else if (taskTO instanceof SchedTaskTO) {\n-                                final SchedTaskTO schedTaskTO = (SchedTaskTO) taskTO;\n-                                System.out.println(\"\");\n-                                System.out.println(\" - Scheduled task key: \" + schedTaskTO.getKey());\n-                                System.out.println(\"     name: \" + schedTaskTO.getName());\n-                                System.out.println(\"     cron expression: \" + schedTaskTO.getCronExpression());\n-                                System.out.println(\"     description: \" + schedTaskTO.getDescription());\n-                                System.out.println(\"     start date: \" + schedTaskTO.getStartDate());\n-                                System.out.println(\"     end date: \" + schedTaskTO.getEndDate());\n-                                System.out.println(\"     last execution: \" + schedTaskTO.getLastExec());\n-                                System.out.println(\"     next execution: \" + schedTaskTO.getNextExec());\n-                                System.out.println(\"     latest execution status: \"\n-                                        + schedTaskTO.getLatestExecStatus());\n-                                System.out.println(\"     job delegate class: \"\n-                                        + schedTaskTO.getJobDelegateClassName());\n-                                for (final TaskExecTO taskExecTO : schedTaskTO.getExecutions()) {\n-                                    printTaskExecTO(taskExecTO);\n-                                }\n-                                System.out.println(\"\");\n-                            } else if (taskTO instanceof SyncTaskTO) {\n-                                final SyncTaskTO syncTaskTO = (SyncTaskTO) taskTO;\n-                                System.out.println(\"\");\n-                                System.out.println(\" - Sync task key: \" + syncTaskTO.getKey());\n-                                System.out.println(\"     name: \" + syncTaskTO.getName());\n-                                System.out.println(\"     resource: \" + syncTaskTO.getResource());\n-                                System.out.println(\"     realm destination: \" + syncTaskTO.getDestinationRealm());\n-                                System.out.println(\"     cron expression: \" + syncTaskTO.getCronExpression());\n-                                System.out.println(\"     description: \" + syncTaskTO.getDescription());\n-                                System.out.println(\"     is full reconciliation: \"\n-                                        + syncTaskTO.isFullReconciliation());\n-                                System.out.println(\"     is perform create: \" + syncTaskTO.isPerformCreate());\n-                                System.out.println(\"     is perform delete: \" + syncTaskTO.isPerformDelete());\n-                                System.out.println(\"     is perform update: \" + syncTaskTO.isPerformUpdate());\n-                                System.out.println(\"     is sync status: \" + syncTaskTO.isSyncStatus());\n-                                System.out.println(\"     templates:\");\n-                                for (Map.Entry<String, AnyTO> entrySet : syncTaskTO.getTemplates().entrySet()) {\n-                                    final String key = entrySet.getKey();\n-                                    final AnyTO value = entrySet.getValue();\n-                                    System.out.println(\"        \" + key + \"key : \" + value.getKey()\n-                                            + \" of realm\" + value.getRealm()\n-                                            + \" on resource \" + value.getResources());\n-\n-                                }\n-                                System.out.println(\"     start date: \" + syncTaskTO.getStartDate());\n-                                System.out.println(\"     end date: \" + syncTaskTO.getEndDate());\n-                                System.out.println(\"     next execution: \" + syncTaskTO.getNextExec());\n-                                System.out.println(\"     last execution: \" + syncTaskTO.getLastExec());\n-                                System.out.println(\"     latest execution status: \"\n-                                        + syncTaskTO.getLatestExecStatus());\n-                                System.out.println(\"     job delegate class: \"\n-                                        + syncTaskTO.getJobDelegateClassName());\n-                                System.out.println(\"     action class name: \" + syncTaskTO.getActionsClassNames());\n-                                System.out.println(\"     matching rule: \" + syncTaskTO.getMatchingRule());\n-                                System.out.println(\"     unmatching rule: \" + syncTaskTO.getUnmatchingRule());\n-                                for (final TaskExecTO taskExecTO : syncTaskTO.getExecutions()) {\n-                                    printTaskExecTO(taskExecTO);\n-                                }\n-                                System.out.println(\"\");\n-                            }\n-                        } catch (final NumberFormatException ex) {\n-                            Messages.printIdNotNumberDeletedMessage(\"task\", parameter);\n-                        } catch (final SyncopeClientException | WebServiceException ex) {\n-                            if (ex.getMessage().startsWith(\"NotFound\")) {\n-                                Messages.printNofFoundMessage(\"Task\", parameter);\n-                            } else {\n-                                Messages.printMessage(\"Error: \" + ex.getMessage());\n-                            }\n-                            break;\n-                        }\n-                    }\n-                } else {\n-                    Messages.printCommandOptionMessage(readErrorMessage);\n-                }\n-                break;\n-            case READ_EXECUTION:\n-                final String readExecutionErrorMessage = \"task --read-execution {TASK-ID} {TASK-ID} [...]\";\n-                if (parameters.length >= 1) {\n-                    for (final String parameter : parameters) {\n-                        try {\n-                            final TaskExecTO taskExecTO = taskService.readExecution(Long.valueOf(parameter));\n-                            printTaskExecTO(taskExecTO);\n-                        } catch (final NumberFormatException ex) {\n-                            Messages.printIdNotNumberDeletedMessage(\"task execution\", parameter);\n-                        } catch (final SyncopeClientException | WebServiceException ex) {\n-                            if (ex.getMessage().startsWith(\"NotFound\")) {\n-                                Messages.printNofFoundMessage(\"Task execution\", parameter);\n-                            } else {\n-                                Messages.printMessage(\"Error: \" + ex.getMessage());\n-                            }\n-                            break;\n-                        }\n-                    }\n-                } else {\n-                    Messages.printCommandOptionMessage(readExecutionErrorMessage);\n-                }\n-                break;\n-            case DELETE:\n-                final String deleteErrorMessage = \"task --delete {TASK-ID} {TASK-ID} [...]\";\n-\n-                if (parameters.length >= 1) {\n-                    for (final String parameter : parameters) {\n-                        try {\n-                            taskService.delete(Long.valueOf(parameter));\n-                            Messages.printDeletedMessage(\"Task\", parameter);\n-                        } catch (final WebServiceException | SyncopeClientException ex) {\n-                            if (ex.getMessage().startsWith(\"NotFound\")) {\n-                                Messages.printNofFoundMessage(\"Task\", parameter);\n-                            } else if (ex.getMessage().startsWith(\"DataIntegrityViolation\")) {\n-                                Messages.printMessage(\"You cannot delete task \" + parameter);\n-                            } else {\n-                                Messages.printMessage(ex.getMessage());\n-                            }\n-                        } catch (final NumberFormatException ex) {\n-                            Messages.printIdNotNumberDeletedMessage(\"task\", parameter);\n-                        }\n-                    }\n-                } else {\n-                    Messages.printCommandOptionMessage(deleteErrorMessage);\n-                }\n-                break;\n-            case DELETE_EXECUTION:\n-                final String deleteExecutionErrorMessage = \"task --delete-execution \"\n-                        + \"{TASK-EXEC-ID} {TASK-EXEC-ID} [...]\";\n-\n-                if (parameters.length >= 1) {\n-                    for (final String parameter : parameters) {\n-                        try {\n-                            taskService.deleteExecution(Long.valueOf(parameter));\n-                            Messages.printDeletedMessage(\"Task execution\", parameter);\n-                        } catch (final WebServiceException | SyncopeClientException ex) {\n-                            if (ex.getMessage().startsWith(\"NotFound\")) {\n-                                Messages.printNofFoundMessage(\"Task execution\", parameter);\n-                            } else if (ex.getMessage().startsWith(\"DataIntegrityViolation\")) {\n-                                Messages.printMessage(\"You cannot delete task execution\" + parameter);\n-                            } else {\n-                                Messages.printMessage(ex.getMessage());\n-                            }\n-                        } catch (final NumberFormatException ex) {\n-                            Messages.printIdNotNumberDeletedMessage(\"task execution\", parameter);\n-                        }\n-                    }\n-                } else {\n-                    Messages.printCommandOptionMessage(deleteExecutionErrorMessage);\n-                }\n-                break;\n-            case EXECUTE:\n-                final String executeErrorMessage = \"task --execute {TASK-ID} {DRY-RUN}\\n\"\n-                        + \"          Dry run: true / false\";\n-\n-                if (parameters.length == 2) {\n-\n-                    try {\n-                        final Long taskIdToExecute = Long.valueOf(parameters[0]);\n-                        boolean dryRun;\n-                        if (\"false\".equalsIgnoreCase(parameters[1])) {\n-                            dryRun = false;\n-                        } else if (\"true\".equalsIgnoreCase(parameters[1])) {\n-                            dryRun = true;\n-                        } else {\n-                            Messages.printNotBooleanDeletedMessage(\"dry run\", parameters[1]);\n-                            break;\n-                        }\n-                        final TaskExecTO taskExecTO = taskService.execute(taskIdToExecute, dryRun);\n-                        printTaskExecTO(taskExecTO);\n-                    } catch (final WebServiceException | SyncopeClientException ex) {\n-                        if (ex.getMessage().startsWith(\"NotFound\")) {\n-                            Messages.printNofFoundMessage(\"Task\", parameters[0]);\n-                        } else if (ex.getMessage().startsWith(\"DataIntegrityViolation\")) {\n-                            Messages.printMessage(\"You cannot delete task \" + parameters[0]);\n-                        } else {\n-                            Messages.printMessage(ex.getMessage());\n-                        }\n-                    } catch (final NumberFormatException ex) {\n-                        Messages.printIdNotNumberDeletedMessage(\"task\", parameters[0]);\n-                    }\n-                } else {\n-                    Messages.printCommandOptionMessage(executeErrorMessage);\n-                }\n-                break;\n-            case HELP:\n-                System.out.println(HELP_MESSAGE);\n-                break;\n-            default:\n-                Messages.printDefaultMessage(input.getOption(), HELP_MESSAGE);\n-        }\n-\n-    }\n-\n-    private void printTaskExecTO(final TaskExecTO taskExecTO) {\n-        System.out.println(\"     EXECUTIONS: \");\n-        System.out.println(\"     - task execution key: \" + taskExecTO.getKey());\n-        System.out.println(\"       task: \" + taskExecTO.getTask());\n-        System.out.println(\"       message: \");\n-        System.out.println(\"       ###############     <BEGIN MESSAGE>     ###############\");\n-        System.out.println(\"       message: \" + taskExecTO.getMessage());\n-        System.out.println(\"       ###############     <END   MESSAGE>     ###############\");\n-        System.out.println(\"       status: \" + taskExecTO.getStatus());\n-        System.out.println(\"       start date: \" + taskExecTO.getStartDate());\n-        System.out.println(\"       end date: \" + taskExecTO.getEndDate());\n-        System.out.println(\"\");\n-    }\n-\n-    @Override\n-    public String getHelpMessage() {\n-        return HELP_MESSAGE;\n-    }\n-\n-    private enum Options {\n-\n-        HELP(\"--help\"),\n-        LIST_TASK(\"--list-task\"),\n-        LIST_RUNNING_JOBS(\"--list-running-jobs\"),\n-        LIST_SCHEDULED_JOBS(\"--list-scheduled-jobs\"),\n-        READ(\"--read\"),\n-        READ_EXECUTION(\"--read-execution\"),\n-        DELETE(\"--delete\"),\n-        DELETE_EXECUTION(\"--delete-execution\"),\n-        EXECUTE(\"--execute\");\n-\n-        private final String optionName;\n-\n-        Options(final String optionName) {\n-            this.optionName = optionName;\n-        }\n-\n-        public String getOptionName() {\n-            return optionName;\n-        }\n-\n-        public boolean equalsOptionName(final String otherName) {\n-            return (otherName == null) ? false : optionName.equals(otherName);\n-        }\n-\n-        public static Options fromName(final String name) {\n-            Options optionToReturn = HELP;\n-            for (final Options option : Options.values()) {\n-                if (option.equalsOptionName(name)) {\n-                    optionToReturn = option;\n-                }\n-            }\n-            return optionToReturn;\n-        }\n-\n-        public static List<String> toList() {\n-            final List<String> options = new ArrayList<>();\n-            for (final Options value : values()) {\n-                options.add(value.getOptionName());\n-            }\n-            return options;\n-        }\n-    }\n-}"},{"sha":"18e877af132e26d521f1706f653de5f5622d56be","filename":"client/cli/src/main/java/org/apache/syncope/client/cli/commands/task/AbstractTaskCommand.java","status":"added","additions":30,"deletions":0,"changes":30,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/73f73f20692910e6f0c2acf27d5d8bd7982e6b6c/client%2Fcli%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fcli%2Fcommands%2Ftask%2FAbstractTaskCommand.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/73f73f20692910e6f0c2acf27d5d8bd7982e6b6c/client%2Fcli%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fcli%2Fcommands%2Ftask%2FAbstractTaskCommand.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/client%2Fcli%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fcli%2Fcommands%2Ftask%2FAbstractTaskCommand.java?ref=73f73f20692910e6f0c2acf27d5d8bd7982e6b6c","patch":"@@ -0,0 +1,30 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.client.cli.commands.task;\n+\n+import org.apache.syncope.client.cli.SyncopeServices;\n+import org.apache.syncope.common.rest.api.service.TaskService;\n+\n+public abstract class AbstractTaskCommand {\n+\n+    protected final TaskService taskService = SyncopeServices.get(TaskService.class);\n+\n+    protected final TaskResultManager taskResultManager = new TaskResultManager();\n+\n+}"},{"sha":"a6166921293cc1cfe79f7af5a3ab023b8d87e24c","filename":"client/cli/src/main/java/org/apache/syncope/client/cli/commands/task/TaskCommand.java","status":"added","additions":140,"deletions":0,"changes":140,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/73f73f20692910e6f0c2acf27d5d8bd7982e6b6c/client%2Fcli%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fcli%2Fcommands%2Ftask%2FTaskCommand.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/73f73f20692910e6f0c2acf27d5d8bd7982e6b6c/client%2Fcli%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fcli%2Fcommands%2Ftask%2FTaskCommand.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/client%2Fcli%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fcli%2Fcommands%2Ftask%2FTaskCommand.java?ref=73f73f20692910e6f0c2acf27d5d8bd7982e6b6c","patch":"@@ -0,0 +1,140 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.client.cli.commands.task;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.syncope.client.cli.Command;\n+import org.apache.syncope.client.cli.Input;\n+import org.apache.syncope.client.cli.commands.AbstractCommand;\n+\n+@Command(name = \"task\")\n+public class TaskCommand extends AbstractCommand {\n+\n+    private static final String HELP_MESSAGE = \"Usage: task [options]\\n\"\n+            + \"  Options:\\n\"\n+            + \"    --help \\n\"\n+            + \"    --list-task \\n\"\n+            + \"       Syntax: --list-task {TASK-TYPE} \\n\"\n+            + \"          Task type: NOTIFICATION / PROPAGATION / PUSH / SCHEDULED / SYNCHRONIZATION\\n\"\n+            + \"    --list-running-jobs \\n\"\n+            + \"    --list-scheduled-jobs \\n\"\n+            + \"    --read \\n\"\n+            + \"       Syntax: --read {TASK-ID} {TASK-ID} [...]\\n\"\n+            + \"    --read-execution \\n\"\n+            + \"       Syntax: --read-execution {TASK-EXEC-ID} {TASK-EXEC-ID} [...]\\n\"\n+            + \"    --delete \\n\"\n+            + \"       Syntax: --delete {TASK-ID} {TASK-ID} [...]\\n\"\n+            + \"    --delete-execution \\n\"\n+            + \"       Syntax: --delete-execution {TASK-EXEC-ID} {TASK-EXEC-ID} [...]\\n\"\n+            + \"    --execute \\n\"\n+            + \"       Syntax: --execute {TASK-ID} {DRY-RUN}\"\n+            + \"          Dry run: true / false\";\n+\n+    @Override\n+    public void execute(final Input input) {\n+        if (StringUtils.isBlank(input.getOption())) {\n+            input.setOption(Options.HELP.getOptionName());\n+        }\n+\n+        switch (Options.fromName(input.getOption())) {\n+            case LIST_TASK:\n+                new TaskList(input).list();\n+                break;\n+            case LIST_RUNNING_JOBS:\n+                new TaskRunningJobs().list();\n+                break;\n+            case LIST_SCHEDULED_JOBS:\n+                new TaskScheduledJobs().list();\n+                break;\n+            case READ:\n+                new TaskRead(input).read();\n+                break;\n+            case READ_EXECUTION:\n+                new TaskExecutionRead(input).read();\n+                break;\n+            case DELETE:\n+                new TaskDelete(input).delete();\n+                break;\n+            case DELETE_EXECUTION:\n+                new TaskExecutionDelete(input).delete();\n+                break;\n+            case EXECUTE:\n+                new TaskExecute(input).execute();\n+                break;\n+            case HELP:\n+                System.out.println(HELP_MESSAGE);\n+                break;\n+            default:\n+                new TaskResultManager().defaultError(input.getOption(), HELP_MESSAGE);\n+        }\n+\n+    }\n+\n+    @Override\n+    public String getHelpMessage() {\n+        return HELP_MESSAGE;\n+    }\n+\n+    private enum Options {\n+\n+        HELP(\"--help\"),\n+        LIST_TASK(\"--list-task\"),\n+        LIST_RUNNING_JOBS(\"--list-running-jobs\"),\n+        LIST_SCHEDULED_JOBS(\"--list-scheduled-jobs\"),\n+        READ(\"--read\"),\n+        READ_EXECUTION(\"--read-execution\"),\n+        DELETE(\"--delete\"),\n+        DELETE_EXECUTION(\"--delete-execution\"),\n+        EXECUTE(\"--execute\");\n+\n+        private final String optionName;\n+\n+        Options(final String optionName) {\n+            this.optionName = optionName;\n+        }\n+\n+        public String getOptionName() {\n+            return optionName;\n+        }\n+\n+        public boolean equalsOptionName(final String otherName) {\n+            return (otherName == null) ? false : optionName.equals(otherName);\n+        }\n+\n+        public static Options fromName(final String name) {\n+            Options optionToReturn = HELP;\n+            for (final Options option : Options.values()) {\n+                if (option.equalsOptionName(name)) {\n+                    optionToReturn = option;\n+                }\n+            }\n+            return optionToReturn;\n+        }\n+\n+        public static List<String> toList() {\n+            final List<String> options = new ArrayList<>();\n+            for (final Options value : values()) {\n+                options.add(value.getOptionName());\n+            }\n+            return options;\n+        }\n+    }\n+}"},{"sha":"655e112d9d8a40e75876ab75a3162cade721569e","filename":"client/cli/src/main/java/org/apache/syncope/client/cli/commands/task/TaskDelete.java","status":"added","additions":58,"deletions":0,"changes":58,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/73f73f20692910e6f0c2acf27d5d8bd7982e6b6c/client%2Fcli%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fcli%2Fcommands%2Ftask%2FTaskDelete.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/73f73f20692910e6f0c2acf27d5d8bd7982e6b6c/client%2Fcli%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fcli%2Fcommands%2Ftask%2FTaskDelete.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/client%2Fcli%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fcli%2Fcommands%2Ftask%2FTaskDelete.java?ref=73f73f20692910e6f0c2acf27d5d8bd7982e6b6c","patch":"@@ -0,0 +1,58 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.client.cli.commands.task;\n+\n+import javax.xml.ws.WebServiceException;\n+import org.apache.syncope.client.cli.Input;\n+import org.apache.syncope.common.lib.SyncopeClientException;\n+\n+public class TaskDelete extends AbstractTaskCommand {\n+\n+    private static final String DELETE_HELP_MESSAGE = \"task --delete {TASK-ID} {TASK-ID} [...]\";\n+\n+    private final Input input;\n+\n+    public TaskDelete(final Input input) {\n+        this.input = input;\n+    }\n+\n+    public void delete() {\n+\n+        if (input.parameterNumber() >= 1) {\n+            for (final String parameter : input.getParameters()) {\n+                try {\n+                    taskService.delete(Long.valueOf(parameter));\n+                    taskResultManager.deletedMessage(\"Task\", parameter);\n+                } catch (final WebServiceException | SyncopeClientException ex) {\n+                    if (ex.getMessage().startsWith(\"NotFound\")) {\n+                        taskResultManager.notFoundError(\"Task\", parameter);\n+                    } else if (ex.getMessage().startsWith(\"DataIntegrityViolation\")) {\n+                        taskResultManager.generic(\"You cannot delete task \" + parameter);\n+                    } else {\n+                        taskResultManager.generic(ex.getMessage());\n+                    }\n+                } catch (final NumberFormatException ex) {\n+                    taskResultManager.notBooleanDeletedError(\"task\", parameter);\n+                }\n+            }\n+        } else {\n+            taskResultManager.commandOptionError(DELETE_HELP_MESSAGE);\n+        }\n+    }\n+}"},{"sha":"9f53ece87f04078b4273de77bf8da81fb38811a5","filename":"client/cli/src/main/java/org/apache/syncope/client/cli/commands/task/TaskExecute.java","status":"added","additions":66,"deletions":0,"changes":66,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/73f73f20692910e6f0c2acf27d5d8bd7982e6b6c/client%2Fcli%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fcli%2Fcommands%2Ftask%2FTaskExecute.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/73f73f20692910e6f0c2acf27d5d8bd7982e6b6c/client%2Fcli%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fcli%2Fcommands%2Ftask%2FTaskExecute.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/client%2Fcli%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fcli%2Fcommands%2Ftask%2FTaskExecute.java?ref=73f73f20692910e6f0c2acf27d5d8bd7982e6b6c","patch":"@@ -0,0 +1,66 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.client.cli.commands.task;\n+\n+import java.util.Arrays;\n+import javax.xml.ws.WebServiceException;\n+import org.apache.syncope.client.cli.Input;\n+import org.apache.syncope.common.lib.SyncopeClientException;\n+\n+public class TaskExecute extends AbstractTaskCommand {\n+\n+    private static final String EXECUTE_HELP_MESSAGE = \"task --execute {TASK-ID} {DRY-RUN}\\n\"\n+            + \"          Dry run: true / false\";\n+\n+    private final Input input;\n+\n+    public TaskExecute(final Input input) {\n+        this.input = input;\n+    }\n+\n+    public void execute() {\n+        if (input.parameterNumber() == 2) {\n+            try {\n+                final Long taskIdToExecute = Long.valueOf(input.firstParameter());\n+                boolean dryRun = true;\n+                if (\"false\".equalsIgnoreCase(input.secondParameter())) {\n+                    dryRun = false;\n+                } else if (\"true\".equalsIgnoreCase(input.secondParameter())) {\n+                    dryRun = true;\n+                } else {\n+                    taskResultManager.notBooleanDeletedError(\"dry run\", input.secondParameter());\n+                }\n+                taskResultManager.printTaskExecTO(Arrays.asList(taskService.execute(taskIdToExecute, dryRun)));\n+            } catch (final WebServiceException | SyncopeClientException ex) {\n+                if (ex.getMessage().startsWith(\"NotFound\")) {\n+                    taskResultManager.notFoundError(\"Task\", input.firstParameter());\n+                } else if (ex.getMessage().startsWith(\"DataIntegrityViolation\")) {\n+                    taskResultManager.generic(\"You cannot delete task \" + input.firstParameter());\n+                } else {\n+                    taskResultManager.generic(ex.getMessage());\n+                }\n+            } catch (final NumberFormatException ex) {\n+                taskResultManager.notBooleanDeletedError(\"task\", input.firstParameter());\n+            }\n+        } else {\n+            taskResultManager.commandOptionError(EXECUTE_HELP_MESSAGE);\n+        }\n+    }\n+\n+}"},{"sha":"a107716512c5f12a4563035441fa1b6f6a50f202","filename":"client/cli/src/main/java/org/apache/syncope/client/cli/commands/task/TaskExecutionDelete.java","status":"added","additions":58,"deletions":0,"changes":58,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/73f73f20692910e6f0c2acf27d5d8bd7982e6b6c/client%2Fcli%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fcli%2Fcommands%2Ftask%2FTaskExecutionDelete.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/73f73f20692910e6f0c2acf27d5d8bd7982e6b6c/client%2Fcli%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fcli%2Fcommands%2Ftask%2FTaskExecutionDelete.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/client%2Fcli%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fcli%2Fcommands%2Ftask%2FTaskExecutionDelete.java?ref=73f73f20692910e6f0c2acf27d5d8bd7982e6b6c","patch":"@@ -0,0 +1,58 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.client.cli.commands.task;\n+\n+import javax.xml.ws.WebServiceException;\n+import org.apache.syncope.client.cli.Input;\n+import org.apache.syncope.common.lib.SyncopeClientException;\n+\n+public class TaskExecutionDelete extends AbstractTaskCommand {\n+\n+    private static final String DELETE_HELP_MESSAGE = \"task --delete-execution \"\n+            + \"{TASK-EXEC-ID} {TASK-EXEC-ID} [...]\";\n+\n+    private final Input input;\n+\n+    public TaskExecutionDelete(final Input input) {\n+        this.input = input;\n+    }\n+\n+    public void delete() {\n+        if (input.parameterNumber() >= 1) {\n+            for (final String parameter : input.getParameters()) {\n+                try {\n+                    taskService.deleteExecution(Long.valueOf(parameter));\n+                    taskResultManager.deletedMessage(\"Task execution\", parameter);\n+                } catch (final WebServiceException | SyncopeClientException ex) {\n+                    if (ex.getMessage().startsWith(\"NotFound\")) {\n+                        taskResultManager.notFoundError(\"Task execution\", parameter);\n+                    } else if (ex.getMessage().startsWith(\"DataIntegrityViolation\")) {\n+                        taskResultManager.generic(\"You cannot delete task execution\" + parameter);\n+                    } else {\n+                        taskResultManager.generic(ex.getMessage());\n+                    }\n+                } catch (final NumberFormatException ex) {\n+                    taskResultManager.notBooleanDeletedError(\"task execution\", parameter);\n+                }\n+            }\n+        } else {\n+            taskResultManager.commandOptionError(DELETE_HELP_MESSAGE);\n+        }\n+    }\n+}"},{"sha":"d24641de8e4fa137545119340d2f8c5b98c7d35b","filename":"client/cli/src/main/java/org/apache/syncope/client/cli/commands/task/TaskExecutionRead.java","status":"added","additions":58,"deletions":0,"changes":58,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/73f73f20692910e6f0c2acf27d5d8bd7982e6b6c/client%2Fcli%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fcli%2Fcommands%2Ftask%2FTaskExecutionRead.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/73f73f20692910e6f0c2acf27d5d8bd7982e6b6c/client%2Fcli%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fcli%2Fcommands%2Ftask%2FTaskExecutionRead.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/client%2Fcli%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fcli%2Fcommands%2Ftask%2FTaskExecutionRead.java?ref=73f73f20692910e6f0c2acf27d5d8bd7982e6b6c","patch":"@@ -0,0 +1,58 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.client.cli.commands.task;\n+\n+import java.util.Arrays;\n+import javax.xml.ws.WebServiceException;\n+import org.apache.syncope.client.cli.Input;\n+import org.apache.syncope.common.lib.SyncopeClientException;\n+\n+public class TaskExecutionRead extends AbstractTaskCommand {\n+\n+    private static final String EXECUTION_READ_HELP_MESSAGE = \"task --read-execution {TASK-ID} {TASK-ID} [...]\";\n+\n+    private final Input input;\n+\n+    public TaskExecutionRead(final Input input) {\n+        this.input = input;\n+    }\n+\n+    public void read() {\n+        if (input.parameterNumber() >= 1) {\n+            for (final String parameter : input.getParameters()) {\n+                try {\n+                    taskResultManager.printTaskExecTO(\n+                            Arrays.asList(taskService.readExecution(Long.valueOf(parameter))));\n+                } catch (final NumberFormatException ex) {\n+                    taskResultManager.notBooleanDeletedError(\"task execution\", parameter);\n+                } catch (final SyncopeClientException | WebServiceException ex) {\n+                    if (ex.getMessage().startsWith(\"NotFound\")) {\n+                        taskResultManager.notFoundError(\"Task execution\", parameter);\n+                    } else {\n+                        taskResultManager.generic(\"Error: \" + ex.getMessage());\n+                    }\n+                    break;\n+                }\n+            }\n+        } else {\n+            taskResultManager.commandOptionError(EXECUTION_READ_HELP_MESSAGE);\n+        }\n+    }\n+\n+}"},{"sha":"203dbcb7ef0ee47b13ff805a0c30f47c1518c671","filename":"client/cli/src/main/java/org/apache/syncope/client/cli/commands/task/TaskList.java","status":"added","additions":59,"deletions":0,"changes":59,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/73f73f20692910e6f0c2acf27d5d8bd7982e6b6c/client%2Fcli%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fcli%2Fcommands%2Ftask%2FTaskList.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/73f73f20692910e6f0c2acf27d5d8bd7982e6b6c/client%2Fcli%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fcli%2Fcommands%2Ftask%2FTaskList.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/client%2Fcli%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fcli%2Fcommands%2Ftask%2FTaskList.java?ref=73f73f20692910e6f0c2acf27d5d8bd7982e6b6c","patch":"@@ -0,0 +1,59 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.client.cli.commands.task;\n+\n+import java.util.LinkedList;\n+import org.apache.syncope.client.cli.Input;\n+import org.apache.syncope.client.cli.util.CommandUtils;\n+import org.apache.syncope.common.lib.SyncopeClientException;\n+import org.apache.syncope.common.lib.to.AbstractTaskTO;\n+import org.apache.syncope.common.lib.types.TaskType;\n+import org.apache.syncope.common.rest.api.beans.TaskQuery;\n+\n+public class TaskList extends AbstractTaskCommand {\n+\n+    private static final String LIST_HELP_MESSAGE = \"task --list-task {TASK-TYPE}\\n\"\n+            + \"   Task type: NOTIFICATION / PROPAGATION / PUSH / SCHEDULED / SYNCHRONIZATION\";\n+\n+    private final Input input;\n+\n+    public TaskList(final Input input) {\n+        this.input = input;\n+    }\n+\n+    public void list() {\n+        if (input.parameterNumber() == 1) {\n+            try {\n+                final TaskType taskType = TaskType.valueOf(input.firstParameter());\n+                final LinkedList<AbstractTaskTO> taskTOs = new LinkedList<>();\n+                for (final AbstractTaskTO taskTO : taskService.list(taskType, new TaskQuery()).getResult()) {\n+                    taskTOs.add(taskTO);\n+                }\n+                taskResultManager.fromList(taskType, taskTOs);\n+            } catch (final SyncopeClientException ex) {\n+                taskResultManager.generic(ex.getMessage());\n+            } catch (final IllegalArgumentException ex) {\n+                taskResultManager.typeNotValidError(\n+                        \"task\", input.firstParameter(), CommandUtils.fromEnumToArray(TaskType.class));\n+            }\n+        } else {\n+            taskResultManager.commandOptionError(LIST_HELP_MESSAGE);\n+        }\n+    }\n+}"},{"sha":"253825457eeb0fd67cdd61adc31140ee530978cf","filename":"client/cli/src/main/java/org/apache/syncope/client/cli/commands/task/TaskRead.java","status":"added","additions":60,"deletions":0,"changes":60,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/73f73f20692910e6f0c2acf27d5d8bd7982e6b6c/client%2Fcli%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fcli%2Fcommands%2Ftask%2FTaskRead.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/73f73f20692910e6f0c2acf27d5d8bd7982e6b6c/client%2Fcli%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fcli%2Fcommands%2Ftask%2FTaskRead.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/client%2Fcli%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fcli%2Fcommands%2Ftask%2FTaskRead.java?ref=73f73f20692910e6f0c2acf27d5d8bd7982e6b6c","patch":"@@ -0,0 +1,60 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.client.cli.commands.task;\n+\n+import java.util.LinkedList;\n+import javax.xml.ws.WebServiceException;\n+import org.apache.syncope.client.cli.Input;\n+import org.apache.syncope.common.lib.SyncopeClientException;\n+import org.apache.syncope.common.lib.to.AbstractTaskTO;\n+\n+public class TaskRead extends AbstractTaskCommand {\n+\n+    private static final String READ_HELP_MESSAGE = \"task --read {TASK-ID} {TASK-ID} [...]\";\n+\n+    private final Input input;\n+\n+    public TaskRead(final Input input) {\n+        this.input = input;\n+    }\n+\n+    public void read() {\n+        if (input.parameterNumber() >= 1) {\n+            final LinkedList<AbstractTaskTO> taskTOs = new LinkedList<>();\n+            for (final String parameter : input.getParameters()) {\n+                try {\n+                    taskTOs.add(taskService.read(Long.valueOf(parameter)));\n+                } catch (final NumberFormatException ex) {\n+                    taskResultManager.notBooleanDeletedError(\"task\", parameter);\n+                } catch (final SyncopeClientException | WebServiceException ex) {\n+                    if (ex.getMessage().startsWith(\"NotFound\")) {\n+                        taskResultManager.notFoundError(\"Task\", parameter);\n+                    } else {\n+                        taskResultManager.generic(\"Error: \" + ex.getMessage());\n+                    }\n+                    break;\n+                }\n+            }\n+            taskResultManager.fromRead(taskTOs);\n+        } else {\n+            taskResultManager.commandOptionError(READ_HELP_MESSAGE);\n+        }\n+    }\n+\n+}"},{"sha":"6075be76da37c8bed725c848d602ef91e4ad24ad","filename":"client/cli/src/main/java/org/apache/syncope/client/cli/commands/task/TaskResultManager.java","status":"added","additions":222,"deletions":0,"changes":222,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/73f73f20692910e6f0c2acf27d5d8bd7982e6b6c/client%2Fcli%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fcli%2Fcommands%2Ftask%2FTaskResultManager.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/73f73f20692910e6f0c2acf27d5d8bd7982e6b6c/client%2Fcli%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fcli%2Fcommands%2Ftask%2FTaskResultManager.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/client%2Fcli%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fcli%2Fcommands%2Ftask%2FTaskResultManager.java?ref=73f73f20692910e6f0c2acf27d5d8bd7982e6b6c","patch":"@@ -0,0 +1,222 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.client.cli.commands.task;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.syncope.client.cli.commands.CommonsResultManager;\n+import org.apache.syncope.common.lib.to.AbstractTaskTO;\n+import org.apache.syncope.common.lib.to.AnyTO;\n+import org.apache.syncope.common.lib.to.NotificationTaskTO;\n+import org.apache.syncope.common.lib.to.PropagationTaskTO;\n+import org.apache.syncope.common.lib.to.PushTaskTO;\n+import org.apache.syncope.common.lib.to.SchedTaskTO;\n+import org.apache.syncope.common.lib.to.SyncTaskTO;\n+import org.apache.syncope.common.lib.to.TaskExecTO;\n+import org.apache.syncope.common.lib.types.TaskType;\n+\n+public class TaskResultManager extends CommonsResultManager {\n+\n+    public void fromRead(final LinkedList<AbstractTaskTO> taskTOs) {\n+        for (final AbstractTaskTO taskTO : taskTOs) {\n+            if (taskTO instanceof NotificationTaskTO) {\n+                printNotificationTask((NotificationTaskTO) taskTO);\n+            } else if (taskTO instanceof PropagationTaskTO) {\n+                printPropagationTask((PropagationTaskTO) taskTO);\n+            } else if (taskTO instanceof PushTaskTO) {\n+                printPushTask((PushTaskTO) taskTO);\n+            } else if (taskTO instanceof SchedTaskTO) {\n+                printScheduledTask((SchedTaskTO) taskTO);\n+            } else if (taskTO instanceof SyncTaskTO) {\n+                printSyncTask((SyncTaskTO) taskTO);\n+            }\n+        }\n+    }\n+\n+    public void fromList(final TaskType taskType, final LinkedList<AbstractTaskTO> taskTOs) {\n+        switch (taskType) {\n+            case NOTIFICATION:\n+                for (final AbstractTaskTO taskTO : taskTOs) {\n+                    printNotificationTask(((NotificationTaskTO) taskTO));\n+                }\n+                break;\n+            case PROPAGATION:\n+                for (final AbstractTaskTO taskTO : taskTOs) {\n+                    printPropagationTask((PropagationTaskTO) taskTO);\n+                }\n+                break;\n+            case PUSH:\n+                for (final AbstractTaskTO taskTO : taskTOs) {\n+                    printPushTask((PushTaskTO) taskTO);\n+                }\n+                break;\n+            case SCHEDULED:\n+                for (final AbstractTaskTO taskTO : taskTOs) {\n+                    printScheduledTask((SchedTaskTO) taskTO);\n+                }\n+                break;\n+            case SYNCHRONIZATION:\n+                for (final AbstractTaskTO taskTO : taskTOs) {\n+                    printSyncTask((SyncTaskTO) taskTO);\n+                }\n+                break;\n+            default:\n+                break;\n+        }\n+    }\n+\n+    private void printNotificationTask(final NotificationTaskTO notificationTaskTO) {\n+        System.out.println(\"\");\n+        System.out.println(\" - Notification task key: \" + notificationTaskTO.getKey());\n+        System.out.println(\"     executed: \" + notificationTaskTO.isExecuted());\n+        System.out.println(\"     sender: \" + notificationTaskTO.getSender());\n+        System.out.println(\"     subjetc: \" + notificationTaskTO.getSubject());\n+        System.out.println(\"     text body: \" + notificationTaskTO.getTextBody());\n+        System.out.println(\"     html body: \" + notificationTaskTO.getHtmlBody());\n+        System.out.println(\"     latest execution status: \"\n+                + notificationTaskTO.getLatestExecStatus());\n+        System.out.println(\"     start date: \" + notificationTaskTO.getStartDate());\n+        System.out.println(\"     end date: \" + notificationTaskTO.getEndDate());\n+        System.out.println(\"     recipients: \" + notificationTaskTO.getRecipients());\n+        System.out.println(\"     trace level: \" + notificationTaskTO.getTraceLevel());\n+        printTaskExecTO(notificationTaskTO.getExecutions());\n+        System.out.println(\"\");\n+    }\n+\n+    private void printPropagationTask(final PropagationTaskTO propagationTaskTO) {\n+        System.out.println(\"\");\n+        System.out.println(\" - Propagation task key: \" + propagationTaskTO.getKey());\n+        System.out.println(\"     resource: \" + propagationTaskTO.getResource());\n+        System.out.println(\"     any key: \" + propagationTaskTO.getAnyKey());\n+        System.out.println(\"     any type kind: \" + propagationTaskTO.getAnyTypeKind());\n+        System.out.println(\"     connector object key: \"\n+                + propagationTaskTO.getConnObjectKey());\n+        System.out.println(\"     old connector object key: \"\n+                + propagationTaskTO.getOldConnObjectKey());\n+        System.out.println(\"     latest execution status: \"\n+                + propagationTaskTO.getLatestExecStatus());\n+        System.out.println(\"     class name: \" + propagationTaskTO.getObjectClassName());\n+        System.out.println(\"     xml attribute: \" + propagationTaskTO.getXmlAttributes());\n+        System.out.println(\"     start date: \" + propagationTaskTO.getStartDate());\n+        System.out.println(\"     end date: \" + propagationTaskTO.getEndDate());\n+        System.out.println(\"     operation: \" + propagationTaskTO.getOperation());\n+        printTaskExecTO(propagationTaskTO.getExecutions());\n+        System.out.println(\"\");\n+    }\n+\n+    private void printPushTask(final PushTaskTO pushTaskTO) {\n+        System.out.println(\"\");\n+        System.out.println(\" - Push task key: \" + pushTaskTO.getKey());\n+        System.out.println(\"     name: \" + pushTaskTO.getName());\n+        System.out.println(\"     resource: \" + pushTaskTO.getResource());\n+        System.out.println(\"     cron expression: \" + pushTaskTO.getCronExpression());\n+        System.out.println(\"     description: \" + pushTaskTO.getDescription());\n+        System.out.println(\"     is perform create: \" + pushTaskTO.isPerformCreate());\n+        System.out.println(\"     is perform delete: \" + pushTaskTO.isPerformDelete());\n+        System.out.println(\"     is perform update: \" + pushTaskTO.isPerformUpdate());\n+        System.out.println(\"     is sync status: \" + pushTaskTO.isSyncStatus());\n+        System.out.println(\"     start date: \" + pushTaskTO.getStartDate());\n+        System.out.println(\"     end date: \" + pushTaskTO.getEndDate());\n+        System.out.println(\"     last execution: \" + pushTaskTO.getLastExec());\n+        System.out.println(\"     next execution: \" + pushTaskTO.getNextExec());\n+        System.out.println(\"     latest execution status: \"\n+                + pushTaskTO.getLatestExecStatus());\n+        System.out.println(\"     filters: \" + pushTaskTO.getFilters());\n+        System.out.println(\"     delegate class: \" + pushTaskTO.getJobDelegateClassName());\n+        System.out.println(\"     action class: \" + pushTaskTO.getActionsClassNames());\n+        System.out.println(\"     matching rule: \" + pushTaskTO.getMatchingRule());\n+        System.out.println(\"     not matching rule: \" + pushTaskTO.getUnmatchingRule());\n+        printTaskExecTO(pushTaskTO.getExecutions());\n+\n+        System.out.println(\"\");\n+    }\n+\n+    private void printScheduledTask(final SchedTaskTO schedTaskTO) {\n+        System.out.println(\"\");\n+        System.out.println(\" - Scheduled task key: \" + schedTaskTO.getKey());\n+        System.out.println(\"     name: \" + schedTaskTO.getName());\n+        System.out.println(\"     cron expression: \" + schedTaskTO.getCronExpression());\n+        System.out.println(\"     description: \" + schedTaskTO.getDescription());\n+        System.out.println(\"     start date: \" + schedTaskTO.getStartDate());\n+        System.out.println(\"     end date: \" + schedTaskTO.getEndDate());\n+        System.out.println(\"     last execution: \" + schedTaskTO.getLastExec());\n+        System.out.println(\"     next execution: \" + schedTaskTO.getNextExec());\n+        System.out.println(\"     latest execution status: \"\n+                + schedTaskTO.getLatestExecStatus());\n+        System.out.println(\"     job delegate class: \"\n+                + schedTaskTO.getJobDelegateClassName());\n+        printTaskExecTO(schedTaskTO.getExecutions());\n+        System.out.println(\"\");\n+    }\n+\n+    private void printSyncTask(final SyncTaskTO syncTaskTO) {\n+        System.out.println(\"\");\n+        System.out.println(\" - Sync task key: \" + syncTaskTO.getKey());\n+        System.out.println(\"     name: \" + syncTaskTO.getName());\n+        System.out.println(\"     resource: \" + syncTaskTO.getResource());\n+        System.out.println(\"     realm destination: \" + syncTaskTO.getDestinationRealm());\n+        System.out.println(\"     cron expression: \" + syncTaskTO.getCronExpression());\n+        System.out.println(\"     description: \" + syncTaskTO.getDescription());\n+        System.out.println(\"     is full reconciliation: \"\n+                + syncTaskTO.isFullReconciliation());\n+        System.out.println(\"     is perform create: \" + syncTaskTO.isPerformCreate());\n+        System.out.println(\"     is perform delete: \" + syncTaskTO.isPerformDelete());\n+        System.out.println(\"     is perform update: \" + syncTaskTO.isPerformUpdate());\n+        System.out.println(\"     is sync status: \" + syncTaskTO.isSyncStatus());\n+        System.out.println(\"     templates:\");\n+        for (Map.Entry<String, AnyTO> entrySet : syncTaskTO.getTemplates().entrySet()) {\n+            final String key = entrySet.getKey();\n+            final AnyTO value = entrySet.getValue();\n+            System.out.println(\"        \" + key + \" key: \" + value.getKey()\n+                    + \" of realm\" + value.getRealm()\n+                    + \" on resource \" + value.getResources());\n+\n+        }\n+        System.out.println(\"     start date: \" + syncTaskTO.getStartDate());\n+        System.out.println(\"     end date: \" + syncTaskTO.getEndDate());\n+        System.out.println(\"     next execution: \" + syncTaskTO.getNextExec());\n+        System.out.println(\"     last execution: \" + syncTaskTO.getLastExec());\n+        System.out.println(\"     latest execution status: \"\n+                + syncTaskTO.getLatestExecStatus());\n+        System.out.println(\"     job delegate class: \"\n+                + syncTaskTO.getJobDelegateClassName());\n+        System.out.println(\"     action class name: \" + syncTaskTO.getActionsClassNames());\n+        System.out.println(\"     matching rule: \" + syncTaskTO.getMatchingRule());\n+        System.out.println(\"     unmatching rule: \" + syncTaskTO.getUnmatchingRule());\n+        printTaskExecTO(syncTaskTO.getExecutions());\n+        System.out.println(\"\");\n+    }\n+\n+    public void printTaskExecTO(final List<TaskExecTO> taskExecTOs) {\n+        for (final TaskExecTO taskExecTO : taskExecTOs) {\n+            System.out.println(\"     EXECUTIONS: \");\n+            System.out.println(\"     - task execution key: \" + taskExecTO.getKey());\n+            System.out.println(\"       task: \" + taskExecTO.getTask());\n+            System.out.println(\"       message: \");\n+            System.out.println(\"       ###############     <BEGIN MESSAGE>     ###############\");\n+            System.out.println(\"       message: \" + taskExecTO.getMessage());\n+            System.out.println(\"       ###############     <END   MESSAGE>     ###############\");\n+            System.out.println(\"       status: \" + taskExecTO.getStatus());\n+            System.out.println(\"       start date: \" + taskExecTO.getStartDate());\n+            System.out.println(\"       end date: \" + taskExecTO.getEndDate());\n+            System.out.println(\"\");\n+        }\n+    }\n+}"},{"sha":"fdb886f787ef8504e02fc7259be7f98e2834e897","filename":"client/cli/src/main/java/org/apache/syncope/client/cli/commands/task/TaskRunningJobs.java","status":"added","additions":34,"deletions":0,"changes":34,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/73f73f20692910e6f0c2acf27d5d8bd7982e6b6c/client%2Fcli%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fcli%2Fcommands%2Ftask%2FTaskRunningJobs.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/73f73f20692910e6f0c2acf27d5d8bd7982e6b6c/client%2Fcli%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fcli%2Fcommands%2Ftask%2FTaskRunningJobs.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/client%2Fcli%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fcli%2Fcommands%2Ftask%2FTaskRunningJobs.java?ref=73f73f20692910e6f0c2acf27d5d8bd7982e6b6c","patch":"@@ -0,0 +1,34 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.client.cli.commands.task;\n+\n+import org.apache.syncope.common.lib.SyncopeClientException;\n+import org.apache.syncope.common.lib.types.JobStatusType;\n+\n+public class TaskRunningJobs extends AbstractTaskCommand {\n+\n+    public void list() {\n+        try {\n+            taskResultManager.printTaskExecTO(taskService.listJobs(JobStatusType.RUNNING));\n+        } catch (final SyncopeClientException ex) {\n+            taskResultManager.generic(ex.getMessage());\n+        }\n+    }\n+\n+}"},{"sha":"d95f1223137e1e952d31e8208d9ad7d6174fa4dc","filename":"client/cli/src/main/java/org/apache/syncope/client/cli/commands/task/TaskScheduledJobs.java","status":"added","additions":34,"deletions":0,"changes":34,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/73f73f20692910e6f0c2acf27d5d8bd7982e6b6c/client%2Fcli%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fcli%2Fcommands%2Ftask%2FTaskScheduledJobs.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/73f73f20692910e6f0c2acf27d5d8bd7982e6b6c/client%2Fcli%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fcli%2Fcommands%2Ftask%2FTaskScheduledJobs.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/client%2Fcli%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2Fcli%2Fcommands%2Ftask%2FTaskScheduledJobs.java?ref=73f73f20692910e6f0c2acf27d5d8bd7982e6b6c","patch":"@@ -0,0 +1,34 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.client.cli.commands.task;\n+\n+import org.apache.syncope.common.lib.SyncopeClientException;\n+import org.apache.syncope.common.lib.types.JobStatusType;\n+\n+public class TaskScheduledJobs extends AbstractTaskCommand {\n+\n+    public void list() {\n+        try {\n+            taskResultManager.printTaskExecTO(taskService.listJobs(JobStatusType.SCHEDULED));\n+        } catch (final SyncopeClientException ex) {\n+            taskResultManager.generic(ex.getMessage());\n+        }\n+    }\n+\n+}"}]}