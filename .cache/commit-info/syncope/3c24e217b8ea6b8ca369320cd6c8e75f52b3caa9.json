{"sha":"3c24e217b8ea6b8ca369320cd6c8e75f52b3caa9","node_id":"MDY6Q29tbWl0NjM2ODc5MDYyOjNjMjRlMjE3YjhlYTZiOGNhMzY5MzIwY2Q2YzhlNzVmNTJiM2NhYTk=","commit":{"author":{"name":"Francesco Chicchiriccò","email":"ilgrosso@apache.org","date":"2012-10-22T13:20:53Z"},"committer":{"name":"Francesco Chicchiriccò","email":"ilgrosso@apache.org","date":"2012-10-22T13:20:53Z"},"message":"[SYNCOPE-186] More preliminary refactoring and cleaning\n\ngit-svn-id: https://svn.apache.org/repos/asf/incubator/syncope/trunk@1400870 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"72a9ee7252433868cda773b672772f87a5fddb7f","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/git/trees/72a9ee7252433868cda773b672772f87a5fddb7f"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/git/commits/3c24e217b8ea6b8ca369320cd6c8e75f52b3caa9","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/3c24e217b8ea6b8ca369320cd6c8e75f52b3caa9","html_url":"https://github.com/EnricoDAlessandro97UNI/syncope/commit/3c24e217b8ea6b8ca369320cd6c8e75f52b3caa9","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/3c24e217b8ea6b8ca369320cd6c8e75f52b3caa9/comments","author":{"login":"ilgrosso","id":1064664,"node_id":"MDQ6VXNlcjEwNjQ2NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/1064664?v=4","gravatar_id":"","url":"https://api.github.com/users/ilgrosso","html_url":"https://github.com/ilgrosso","followers_url":"https://api.github.com/users/ilgrosso/followers","following_url":"https://api.github.com/users/ilgrosso/following{/other_user}","gists_url":"https://api.github.com/users/ilgrosso/gists{/gist_id}","starred_url":"https://api.github.com/users/ilgrosso/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ilgrosso/subscriptions","organizations_url":"https://api.github.com/users/ilgrosso/orgs","repos_url":"https://api.github.com/users/ilgrosso/repos","events_url":"https://api.github.com/users/ilgrosso/events{/privacy}","received_events_url":"https://api.github.com/users/ilgrosso/received_events","type":"User","site_admin":false},"committer":{"login":"ilgrosso","id":1064664,"node_id":"MDQ6VXNlcjEwNjQ2NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/1064664?v=4","gravatar_id":"","url":"https://api.github.com/users/ilgrosso","html_url":"https://github.com/ilgrosso","followers_url":"https://api.github.com/users/ilgrosso/followers","following_url":"https://api.github.com/users/ilgrosso/following{/other_user}","gists_url":"https://api.github.com/users/ilgrosso/gists{/gist_id}","starred_url":"https://api.github.com/users/ilgrosso/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ilgrosso/subscriptions","organizations_url":"https://api.github.com/users/ilgrosso/orgs","repos_url":"https://api.github.com/users/ilgrosso/repos","events_url":"https://api.github.com/users/ilgrosso/events{/privacy}","received_events_url":"https://api.github.com/users/ilgrosso/received_events","type":"User","site_admin":false},"parents":[{"sha":"49d7b31404823bdd6cbe1db2b27f7a50be6df928","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/49d7b31404823bdd6cbe1db2b27f7a50be6df928","html_url":"https://github.com/EnricoDAlessandro97UNI/syncope/commit/49d7b31404823bdd6cbe1db2b27f7a50be6df928"}],"stats":{"total":316,"additions":156,"deletions":160},"files":[{"sha":"f3ce478647ac903f0b62b4e42b822f3be1247094","filename":"core/src/main/java/org/apache/syncope/core/propagation/ConnectorFacadeProxy.java","status":"modified","additions":18,"deletions":16,"changes":34,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/3c24e217b8ea6b8ca369320cd6c8e75f52b3caa9/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpropagation%2FConnectorFacadeProxy.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/3c24e217b8ea6b8ca369320cd6c8e75f52b3caa9/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpropagation%2FConnectorFacadeProxy.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpropagation%2FConnectorFacadeProxy.java?ref=3c24e217b8ea6b8ca369320cd6c8e75f52b3caa9","patch":"@@ -256,13 +256,15 @@ public void delete(final PropagationMode propagationMode, final ObjectClass obje\n     /**\n      * Sync users from a connector instance.\n      *\n+     * @param objectClass ConnId's object class.\n      * @param token to be passed to the underlying connector\n      * @param handler to be used to handle deltas.\n      */\n-    public void sync(final SyncToken token, final SyncResultsHandler handler, final OperationOptions options) {\n+    public void sync(final ObjectClass objectClass, final SyncToken token, final SyncResultsHandler handler,\n+            final OperationOptions options) {\n \n         if (activeConnInstance.getCapabilities().contains(ConnectorCapability.SYNC)) {\n-            connector.sync(ObjectClass.ACCOUNT, token, handler, options);\n+            connector.sync(objectClass, token, handler, options);\n         } else {\n             LOG.info(\"Sync was attempted, although the connector only has these capabilities: {}. No action.\",\n                     activeConnInstance.getCapabilities());\n@@ -272,13 +274,14 @@ public void sync(final SyncToken token, final SyncResultsHandler handler, final\n     /**\n      * Read latest sync token from a connector instance.\n      *\n+     * @param objectClass ConnId's object class.\n      * @return latest sync token\n      */\n-    public SyncToken getLatestSyncToken() {\n+    public SyncToken getLatestSyncToken(final ObjectClass objectClass) {\n         SyncToken result = null;\n \n         if (activeConnInstance.getCapabilities().contains(ConnectorCapability.SYNC)) {\n-            result = connector.getLatestSyncToken(ObjectClass.ACCOUNT);\n+            result = connector.getLatestSyncToken(objectClass);\n         } else {\n             LOG.info(\"getLatestSyncToken was attempted, although the \"\n                     + \"connector only has these capabilities: {}. No action.\", activeConnInstance.getCapabilities());\n@@ -296,7 +299,6 @@ public SyncToken getLatestSyncToken() {\n      * @return ConnId's connector object for given uid\n      */\n     public ConnectorObject getObject(final ObjectClass objectClass, final Uid uid, final OperationOptions options) {\n-\n         return getObject(null, null, objectClass, uid, options);\n     }\n \n@@ -448,11 +450,7 @@ public Set<String> getSchema(final boolean showall) {\n         try {\n             for (ObjectClassInfo info : schema.getObjectClassInfo()) {\n                 for (AttributeInfo attrInfo : info.getAttributeInfo()) {\n-                    if (showall\n-                            || (!Name.NAME.equals(attrInfo.getName())\n-                            && !OperationalAttributes.PASSWORD_NAME.equals(attrInfo.getName()) && !OperationalAttributes.ENABLE_NAME.\n-                            equals(attrInfo.getName()))) {\n-\n+                    if (showall || !isSpecialName(attrInfo.getName())) {\n                         resourceSchemaNames.add(attrInfo.getName());\n                     }\n                 }\n@@ -479,12 +477,6 @@ public void test() {\n         connector.test();\n     }\n \n-    @Override\n-    public String toString() {\n-        return \"ConnectorFacadeProxy{connector=\" + connector + \"capabitilies=\"\n-                + activeConnInstance.getCapabilities() + '}';\n-    }\n-\n     /**\n      * Getter for active connector instance.\n      *\n@@ -562,4 +554,14 @@ private Object getPropertyValue(final ConnConfProperty property) {\n \n         return value;\n     }\n+\n+    private boolean isSpecialName(final String name) {\n+        return (name.startsWith(\"__\") && name.endsWith(\"__\"));\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"ConnectorFacadeProxy{\"\n+                + \"connector=\" + connector + \"\\n\" + \"capabitilies=\" + activeConnInstance.getCapabilities() + '}';\n+    }\n }"},{"sha":"4376cf58989b12bad50d4dd22a8f4b2e7531380e","filename":"core/src/main/java/org/apache/syncope/core/scheduling/SyncJob.java","status":"modified","additions":138,"deletions":144,"changes":282,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/3c24e217b8ea6b8ca369320cd6c8e75f52b3caa9/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fscheduling%2FSyncJob.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/3c24e217b8ea6b8ca369320cd6c8e75f52b3caa9/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fscheduling%2FSyncJob.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fscheduling%2FSyncJob.java?ref=3c24e217b8ea6b8ca369320cd6c8e75f52b3caa9","patch":"@@ -19,6 +19,7 @@\n package org.apache.syncope.core.scheduling;\n \n import java.util.ArrayList;\n+import java.util.Collection;\n import java.util.Collections;\n import java.util.HashMap;\n import java.util.List;\n@@ -61,7 +62,6 @@\n import org.apache.syncope.types.TraceLevel;\n import org.identityconnectors.framework.common.objects.Attribute;\n import org.identityconnectors.framework.common.objects.AttributeUtil;\n-import org.identityconnectors.framework.common.objects.ConnectorObject;\n import org.identityconnectors.framework.common.objects.ObjectClass;\n import org.identityconnectors.framework.common.objects.OperationalAttributes;\n import org.identityconnectors.framework.common.objects.SyncDelta;\n@@ -168,29 +168,70 @@ private List<Long> findExistingUsers(final SyncDelta delta) {\n         // ---------------------------------\n         // Get sync policy specification\n         // ---------------------------------\n-        final SyncPolicy policy = syncTask.getResource().getSyncPolicy();\n-        final SyncPolicySpec policySpec = policy != null\n-                ? (SyncPolicySpec) policy.getSpecification()\n-                : null;\n+        SyncPolicySpec policySpec = null;\n+        if (syncTask.getResource().getSyncPolicy() != null) {\n+            policySpec = (SyncPolicySpec) syncTask.getResource().getSyncPolicy().getSpecification();\n+        }\n         // ---------------------------------\n \n         final List<Long> result = new ArrayList<Long>();\n \n-        if (policySpec != null && !policySpec.getAlternativeSearchAttrs().isEmpty()) {\n+        if (policySpec == null || policySpec.getAlternativeSearchAttrs().isEmpty()) {\n+            SyncopeUser found;\n+            List<SyncopeUser> users;\n+\n+            final SchemaMapping accountIdMap =\n+                    SchemaMappingUtil.getAccountIdMapping(syncTask.getResource().getMappings());\n+            switch (accountIdMap.getIntMappingType()) {\n+                case Username:\n+                    found = userDAO.find(uid);\n+                    if (found != null) {\n+                        result.add(found.getId());\n+                    }\n+                    break;\n \n-            // search external attribute name/value\n-            // about each specified name\n-            final ConnectorObject object = delta.getObject();\n+                case SyncopeUserId:\n+                    found = userDAO.find(Long.parseLong(uid));\n+                    if (found != null) {\n+                        result.add(found.getId());\n+                    }\n+                    break;\n+\n+                case UserSchema:\n+                    final UAttrValue value = new UAttrValue();\n+                    value.setStringValue(uid);\n+                    users = userDAO.findByAttrValue(accountIdMap.getIntAttrName(), value);\n+                    for (SyncopeUser user : users) {\n+                        result.add(user.getId());\n+                    }\n+                    break;\n+\n+                case UserDerivedSchema:\n+                    try {\n+                        users = userDAO.findByDerAttrValue(accountIdMap.getIntAttrName(), uid);\n+                        for (SyncopeUser user : users) {\n+                            result.add(user.getId());\n+                        }\n+                    } catch (InvalidSearchConditionException e) {\n+                        LOG.error(\"Could not search for matching users\", e);\n+                    }\n+                    break;\n+\n+                default:\n+                    LOG.error(\"Invalid accountId type '{}'\", accountIdMap.getIntMappingType());\n+            }\n+        } else {\n+            // search for external attribute's name/value of each specified name\n \n             final Map<String, Attribute> extValues = new HashMap<String, Attribute>();\n \n             for (SchemaMapping mapping : syncTask.getResource().getMappings()) {\n-                extValues.put(SchemaMappingUtil.getIntAttrName(mapping), object.getAttributeByName(SchemaMappingUtil\n-                        .getExtAttrName(mapping)));\n+                extValues.put(SchemaMappingUtil.getIntAttrName(mapping),\n+                        delta.getObject().getAttributeByName(SchemaMappingUtil.getExtAttrName(mapping)));\n             }\n \n-            // search user by attributes specified into the policy\n-            NodeCond searchCondition = null;\n+            // search for user by attribute(s) specified in the policy\n+            NodeCond searchCond = null;\n \n             for (String schema : policySpec.getAlternativeSearchAttrs()) {\n                 Attribute value = extValues.get(schema);\n@@ -208,95 +249,43 @@ private List<Long> findExistingUsers(final SyncDelta delta) {\n                 }\n \n                 NodeCond nodeCond;\n-\n                 // just Username or SyncopeUserId can be selected to be used\n                 if (\"id\".equalsIgnoreCase(schema) || \"username\".equalsIgnoreCase(schema)) {\n-\n-                    final SyncopeUserCond cond = new SyncopeUserCond();\n+                    SyncopeUserCond cond = new SyncopeUserCond();\n                     cond.setSchema(schema);\n                     cond.setType(type);\n                     cond.setExpression(expression);\n \n                     nodeCond = NodeCond.getLeafCond(cond);\n-\n                 } else {\n-                    final AttributeCond cond = new AttributeCond();\n+                    AttributeCond cond = new AttributeCond();\n                     cond.setSchema(schema);\n                     cond.setType(type);\n                     cond.setExpression(expression);\n \n                     nodeCond = NodeCond.getLeafCond(cond);\n                 }\n \n-                searchCondition = searchCondition != null\n-                        ? NodeCond.getAndCond(searchCondition, nodeCond)\n-                        : nodeCond;\n+                searchCond = searchCond == null\n+                        ? nodeCond\n+                        : NodeCond.getAndCond(searchCond, nodeCond);\n             }\n \n-            List<SyncopeUser> users = userSearchDAO.search(EntitlementUtil.getRoleIds(entitlementDAO.findAll()),\n-                    searchCondition);\n+            final List<SyncopeUser> users =\n+                    userSearchDAO.search(EntitlementUtil.getRoleIds(entitlementDAO.findAll()), searchCond);\n             for (SyncopeUser user : users) {\n                 result.add(user.getId());\n             }\n-        } else {\n-            final SyncopeUser found;\n-            List<SyncopeUser> users;\n-\n-            final SchemaMapping accountIdMap = SchemaMappingUtil.getAccountIdMapping(syncTask.getResource()\n-                    .getMappings());\n-\n-            switch (accountIdMap.getIntMappingType()) {\n-                case Username:\n-                    found = userDAO.find(uid);\n-                    if (found != null) {\n-                        result.add(found.getId());\n-                    }\n-                    break;\n-\n-                case SyncopeUserId:\n-                    found = userDAO.find(Long.parseLong(uid));\n-                    if (found != null) {\n-                        result.add(found.getId());\n-                    }\n-                    break;\n-\n-                case UserSchema:\n-                    final UAttrValue value = new UAttrValue();\n-                    value.setStringValue(uid);\n-                    users = userDAO.findByAttrValue(accountIdMap.getIntAttrName(), value);\n-                    for (SyncopeUser user : users) {\n-                        result.add(user.getId());\n-                    }\n-                    break;\n-\n-                case UserDerivedSchema:\n-                    try {\n-                        users = userDAO.findByDerAttrValue(accountIdMap.getIntAttrName(), uid);\n-                        for (SyncopeUser user : users) {\n-                            result.add(user.getId());\n-                        }\n-                    } catch (InvalidSearchConditionException e) {\n-                        LOG.error(\"Could not search for matching users\", e);\n-                    }\n-                    break;\n-\n-                default:\n-                    LOG.error(\"Invalid accountId type '{}'\", accountIdMap.getIntMappingType());\n-            }\n         }\n \n         return result;\n     }\n \n-    /**\n-     * Creates user and stores the result in parameter delta (!)\n-     *\n-     * @param delta\n-     * @param dryRun\n-     * @return\n-     * @throws JobExecutionException\n-     */\n-    private SyncResult createUser(SyncDelta delta, final boolean dryRun) throws JobExecutionException {\n+    private List<SyncResult> createUser(SyncDelta delta, final boolean dryRun) throws JobExecutionException {\n+        if (!((SyncTask) task).isPerformCreate()) {\n+            LOG.debug(\"SyncTask not configured for create\");\n+            return Collections.EMPTY_LIST;\n+        }\n \n         final SyncResult result = new SyncResult();\n         result.setOperation(Operation.CREATE);\n@@ -352,20 +341,21 @@ private SyncResult createUser(SyncDelta delta, final boolean dryRun) throws JobE\n         }\n \n         actions.after(delta, userTO, result);\n-\n-        return result;\n+        return Collections.singletonList(result);\n     }\n \n-    private void updateUsers(SyncDelta delta, final List<Long> users, final boolean dryRun,\n-            final List<SyncResult> results) throws JobExecutionException {\n+    private List<SyncResult> updateUsers(SyncDelta delta, final List<Long> users, final boolean dryRun)\n+            throws JobExecutionException {\n \n         if (!((SyncTask) task).isPerformUpdate()) {\n             LOG.debug(\"SyncTask not configured for update\");\n-            return;\n+            return Collections.EMPTY_LIST;\n         }\n \n         LOG.debug(\"About to update {}\", users);\n \n+        List<SyncResult> results = new ArrayList<SyncResult>();\n+\n         for (Long userId : users) {\n             final SyncResult result = new SyncResult();\n             result.setOperation(Operation.UPDATE);\n@@ -411,18 +401,22 @@ private void updateUsers(SyncDelta delta, final List<Long> users, final boolean\n                 LOG.error(\"Not allowed to read user {}\", userId, e);\n             }\n         }\n+\n+        return results;\n     }\n \n-    private void deleteUsers(SyncDelta delta, final List<Long> users, final boolean dryRun,\n-            final List<SyncResult> results) throws JobExecutionException {\n+    private List<SyncResult> deleteUsers(SyncDelta delta, final List<Long> users, final boolean dryRun)\n+            throws JobExecutionException {\n \n         if (!((SyncTask) task).isPerformDelete()) {\n             LOG.debug(\"SyncTask not configured for delete\");\n-            return;\n+            return Collections.EMPTY_LIST;\n         }\n \n         LOG.debug(\"About to delete {}\", users);\n \n+        List<SyncResult> results = new ArrayList<SyncResult>();\n+\n         for (Long userId : users) {\n             try {\n                 UserTO userTO = userDataBinder.getUserTO(userId);\n@@ -463,6 +457,8 @@ private void deleteUsers(SyncDelta delta, final List<Long> users, final boolean\n                 LOG.error(\"Not allowed to read user {}\", userId, e);\n             }\n         }\n+\n+        return results;\n     }\n \n     /**\n@@ -535,8 +531,7 @@ private String createReport(final List<SyncResult> syncResults, final TraceLevel\n             }\n         }\n \n-        // Summary, also to be included for FAILURE and ALL, so create it\n-        // anyway.\n+        // Summary, also to be included for FAILURE and ALL, so create it anyway.\n         report.append(\"Users [created/failures]: \").append(created.size()).append('/').append(createdFailed.size())\n                 .append(' ').append(\"[updated/failures]: \").append(updated.size()).append('/').append(\n                 updatedFailed.size()).append(' ').append(\"[deleted/ failures]: \").append(deleted.size())\n@@ -629,48 +624,24 @@ protected String doExecute(final boolean dryRun) throws JobExecutionException {\n         try {\n             final SyncPolicy syncPolicy = syncTask.getResource().getSyncPolicy();\n \n-            final ConflictResolutionAction conflictResolutionAction = syncPolicy != null\n-                    && syncPolicy.getSpecification() != null\n-                    ? ((SyncPolicySpec) syncPolicy.getSpecification()).getConflictResolutionAction()\n-                    : ConflictResolutionAction.IGNORE;\n+            final ConflictResolutionAction resAct = syncPolicy == null || syncPolicy.getSpecification() == null\n+                    ? ConflictResolutionAction.IGNORE\n+                    : ((SyncPolicySpec) syncPolicy.getSpecification()).getConflictResolutionAction();\n \n+            final SyncJobResultsHandler handler = new SyncJobResultsHandler(results, syncTask, resAct, dryRun);\n             if (syncTask.isFullReconciliation()) {\n-                connector.getAllObjects(ObjectClass.ACCOUNT, new SyncResultsHandler() {\n-\n-                    @Override\n-                    public boolean handle(final SyncDelta delta) {\n-                        try {\n-                            results.addAll(handleDelta(syncTask, delta, conflictResolutionAction, dryRun));\n-                            return true;\n-                        } catch (JobExecutionException e) {\n-                            LOG.error(\"Reconciliation failed\", e);\n-                            return false;\n-                        }\n-                    }\n-                }, connector.getOperationOptions(syncTask.getResource()));\n+                connector.getAllObjects(ObjectClass.ACCOUNT, handler,\n+                        connector.getOperationOptions(syncTask.getResource()));\n             } else {\n-                connector.sync(syncTask.getResource().getSyncToken(), new SyncResultsHandler() {\n-\n-                    @Override\n-                    public boolean handle(final SyncDelta delta) {\n-                        try {\n-\n-                            results.addAll(handleDelta(syncTask, delta, conflictResolutionAction, dryRun));\n-                            return true;\n-                        } catch (JobExecutionException e) {\n-                            LOG.error(\"Synchronization failed\", e);\n-                            return false;\n-                        }\n-                    }\n-                }, connector.getOperationOptions(syncTask.getResource()));\n+                connector.sync(ObjectClass.ACCOUNT, syncTask.getResource().getSyncToken(), handler,\n+                        connector.getOperationOptions(syncTask.getResource()));\n             }\n \n             if (!dryRun && !syncTask.isFullReconciliation()) {\n                 try {\n                     ExternalResource resource = resourceDAO.find(syncTask.getResource().getName());\n-                    resource.setSyncToken(connector.getLatestSyncToken());\n+                    resource.setSyncToken(connector.getLatestSyncToken(ObjectClass.ACCOUNT));\n                     resourceDAO.save(resource);\n-\n                 } catch (Exception e) {\n                     throw new JobExecutionException(\"While updating SyncToken\", e);\n                 }\n@@ -693,13 +664,13 @@ public boolean handle(final SyncDelta delta) {\n      *\n      * @param syncTask sync task.\n      * @param delta delta.\n-     * @param conflictResolutionAction conflict resolution action.\n+     * @param resAct conflict resolution action.\n      * @param dryRun dry run.\n      * @return list of synchronization results.\n      * @throws JobExecutionException in case of synchronization failure.\n      */\n     protected final List<SyncResult> handleDelta(final SyncTask syncTask, final SyncDelta delta,\n-            final ConflictResolutionAction conflictResolutionAction, final boolean dryRun) throws JobExecutionException {\n+            final ConflictResolutionAction resAct, final boolean dryRun) throws JobExecutionException {\n \n         final List<SyncResult> results = new ArrayList<SyncResult>();\n \n@@ -710,29 +681,25 @@ protected final List<SyncResult> handleDelta(final SyncTask syncTask, final Sync\n         switch (delta.getDeltaType()) {\n             case CREATE_OR_UPDATE:\n                 if (users.isEmpty()) {\n-                    if (syncTask.isPerformCreate()) {\n-                        results.add(createUser(delta, dryRun));\n-                    } else {\n-                        LOG.debug(\"SyncTask not configured for create\");\n-                    }\n+                    results.addAll(createUser(delta, dryRun));\n                 } else if (users.size() == 1) {\n-                    updateUsers(delta, users.subList(0, 1), dryRun, results);\n+                    results.addAll(updateUsers(delta, users.subList(0, 1), dryRun));\n                 } else {\n-                    switch (conflictResolutionAction) {\n+                    switch (resAct) {\n                         case IGNORE:\n                             LOG.error(\"More than one match {}\", users);\n                             break;\n \n                         case FIRSTMATCH:\n-                            updateUsers(delta, users.subList(0, 1), dryRun, results);\n+                            results.addAll(updateUsers(delta, users.subList(0, 1), dryRun));\n                             break;\n \n                         case LASTMATCH:\n-                            updateUsers(delta, users.subList(users.size() - 1, users.size()), dryRun, results);\n+                            results.addAll(updateUsers(delta, users.subList(users.size() - 1, users.size()), dryRun));\n                             break;\n \n                         case ALL:\n-                            updateUsers(delta, users, dryRun, results);\n+                            results.addAll(updateUsers(delta, users, dryRun));\n                             break;\n \n                         default:\n@@ -744,23 +711,23 @@ protected final List<SyncResult> handleDelta(final SyncTask syncTask, final Sync\n                 if (users.isEmpty()) {\n                     LOG.debug(\"No match found for deletion\");\n                 } else if (users.size() == 1) {\n-                    deleteUsers(delta, users, dryRun, results);\n+                    results.addAll(deleteUsers(delta, users, dryRun));\n                 } else {\n-                    switch (conflictResolutionAction) {\n+                    switch (resAct) {\n                         case IGNORE:\n                             LOG.error(\"More than one match {}\", users);\n                             break;\n \n                         case FIRSTMATCH:\n-                            deleteUsers(delta, users.subList(0, 1), dryRun, results);\n+                            results.addAll(deleteUsers(delta, users.subList(0, 1), dryRun));\n                             break;\n \n                         case LASTMATCH:\n-                            deleteUsers(delta, users.subList(users.size() - 1, users.size()), dryRun, results);\n+                            results.addAll(deleteUsers(delta, users.subList(users.size() - 1, users.size()), dryRun));\n                             break;\n \n                         case ALL:\n-                            deleteUsers(delta, users, dryRun, results);\n+                            results.addAll(deleteUsers(delta, users, dryRun));\n                             break;\n \n                         default:\n@@ -775,17 +742,44 @@ protected final List<SyncResult> handleDelta(final SyncTask syncTask, final Sync\n         return results;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     @Override\n     protected boolean hasToBeRegistered(final TaskExec execution) {\n         SyncTask syncTask = (SyncTask) task;\n \n-        // True if either failed and failures have to be registered, or if ALL\n-        // has to be registered.\n-        return (Status.valueOf(execution.getStatus()) == Status.FAILURE && syncTask.getResource().getSyncTraceLevel()\n-                .ordinal() >= TraceLevel.FAILURES.ordinal())\n+        // True if either failed and failures have to be registered, or if ALL has to be registered.\n+        return (Status.valueOf(execution.getStatus()) == Status.FAILURE\n+                && syncTask.getResource().getSyncTraceLevel().ordinal() >= TraceLevel.FAILURES.ordinal())\n                 || syncTask.getResource().getSyncTraceLevel() == TraceLevel.ALL;\n     }\n+\n+    private class SyncJobResultsHandler implements SyncResultsHandler {\n+\n+        private final Collection<SyncResult> results;\n+\n+        private final SyncTask syncTask;\n+\n+        private final ConflictResolutionAction resAct;\n+\n+        private final boolean dryRun;\n+\n+        public SyncJobResultsHandler(final Collection<SyncResult> results, final SyncTask syncTask,\n+                final ConflictResolutionAction resAct, final boolean dryRun) {\n+\n+            this.results = results;\n+            this.syncTask = syncTask;\n+            this.resAct = resAct;\n+            this.dryRun = dryRun;\n+        }\n+\n+        @Override\n+        public boolean handle(final SyncDelta delta) {\n+            try {\n+                results.addAll(handleDelta(syncTask, delta, resAct, dryRun));\n+                return true;\n+            } catch (JobExecutionException e) {\n+                LOG.error(\"Synchronization failed\", e);\n+                return false;\n+            }\n+        }\n+    }\n }"}]}