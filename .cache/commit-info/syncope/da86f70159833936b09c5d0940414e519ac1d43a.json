{"sha":"da86f70159833936b09c5d0940414e519ac1d43a","node_id":"MDY6Q29tbWl0NjM2ODc5MDYyOmRhODZmNzAxNTk4MzM5MzZiMDljNWQwOTQwNDE0ZTUxOWFjMWQ0M2E=","commit":{"author":{"name":"Fabio Martelli","email":"fmartelli@apache.org","date":"2012-03-02T14:28:31Z"},"committer":{"name":"Fabio Martelli","email":"fmartelli@apache.org","date":"2012-03-02T14:28:31Z"},"message":"missed class\n\ngit-svn-id: https://svn.apache.org/repos/asf/incubator/syncope/trunk@1296225 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"0c73fea9ce7cc2368a28e4e392b73d1659800399","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/git/trees/0c73fea9ce7cc2368a28e4e392b73d1659800399"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/git/commits/da86f70159833936b09c5d0940414e519ac1d43a","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/da86f70159833936b09c5d0940414e519ac1d43a","html_url":"https://github.com/EnricoDAlessandro97UNI/syncope/commit/da86f70159833936b09c5d0940414e519ac1d43a","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/da86f70159833936b09c5d0940414e519ac1d43a/comments","author":{"login":"fmartelli","id":1791932,"node_id":"MDQ6VXNlcjE3OTE5MzI=","avatar_url":"https://avatars.githubusercontent.com/u/1791932?v=4","gravatar_id":"","url":"https://api.github.com/users/fmartelli","html_url":"https://github.com/fmartelli","followers_url":"https://api.github.com/users/fmartelli/followers","following_url":"https://api.github.com/users/fmartelli/following{/other_user}","gists_url":"https://api.github.com/users/fmartelli/gists{/gist_id}","starred_url":"https://api.github.com/users/fmartelli/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fmartelli/subscriptions","organizations_url":"https://api.github.com/users/fmartelli/orgs","repos_url":"https://api.github.com/users/fmartelli/repos","events_url":"https://api.github.com/users/fmartelli/events{/privacy}","received_events_url":"https://api.github.com/users/fmartelli/received_events","type":"User","site_admin":false},"committer":{"login":"fmartelli","id":1791932,"node_id":"MDQ6VXNlcjE3OTE5MzI=","avatar_url":"https://avatars.githubusercontent.com/u/1791932?v=4","gravatar_id":"","url":"https://api.github.com/users/fmartelli","html_url":"https://github.com/fmartelli","followers_url":"https://api.github.com/users/fmartelli/followers","following_url":"https://api.github.com/users/fmartelli/following{/other_user}","gists_url":"https://api.github.com/users/fmartelli/gists{/gist_id}","starred_url":"https://api.github.com/users/fmartelli/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fmartelli/subscriptions","organizations_url":"https://api.github.com/users/fmartelli/orgs","repos_url":"https://api.github.com/users/fmartelli/repos","events_url":"https://api.github.com/users/fmartelli/events{/privacy}","received_events_url":"https://api.github.com/users/fmartelli/received_events","type":"User","site_admin":false},"parents":[{"sha":"945a38fffc703177403ffb0ab17fe4059477a31c","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/945a38fffc703177403ffb0ab17fe4059477a31c","html_url":"https://github.com/EnricoDAlessandro97UNI/syncope/commit/945a38fffc703177403ffb0ab17fe4059477a31c"}],"stats":{"total":361,"additions":361,"deletions":0},"files":[{"sha":"edba242455d8a8f1359c01d07b20f8dcb689f0ac","filename":"core/src/main/java/org/syncope/core/util/ConnObjectUtil.java","status":"added","additions":361,"deletions":0,"changes":361,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/da86f70159833936b09c5d0940414e519ac1d43a/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Futil%2FConnObjectUtil.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/da86f70159833936b09c5d0940414e519ac1d43a/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Futil%2FConnObjectUtil.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Futil%2FConnObjectUtil.java?ref=da86f70159833936b09c5d0940414e519ac1d43a","patch":"@@ -0,0 +1,361 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.syncope.core.util;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import javassist.NotFoundException;\n+import org.apache.commons.lang.RandomStringUtils;\n+import org.apache.commons.lang.StringUtils;\n+import org.identityconnectors.common.security.GuardedByteArray;\n+import org.identityconnectors.common.security.GuardedString;\n+import org.identityconnectors.framework.common.objects.Attribute;\n+import org.identityconnectors.framework.common.objects.ConnectorObject;\n+import org.identityconnectors.framework.common.objects.OperationalAttributes;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Component;\n+import org.syncope.client.mod.AttributeMod;\n+import org.syncope.client.mod.UserMod;\n+import org.syncope.client.to.AbstractAttributableTO;\n+import org.syncope.client.to.AttributeTO;\n+import org.syncope.client.to.ConnObjectTO;\n+import org.syncope.client.to.MembershipTO;\n+import org.syncope.client.to.UserTO;\n+import org.syncope.core.persistence.beans.SchemaMapping;\n+import org.syncope.core.persistence.beans.SyncTask;\n+import org.syncope.core.rest.controller.UnauthorizedRoleException;\n+import org.syncope.core.rest.data.UserDataBinder;\n+\n+@Component\n+public class ConnObjectUtil {\n+\n+    /**\n+     * Logger.\n+     */\n+    protected static final Logger LOG = LoggerFactory.getLogger(ConnObjectUtil.class);\n+\n+    /**\n+     * JEXL engine for evaluating connector's account link.\n+     */\n+    @Autowired\n+    private JexlUtil jexlUtil;\n+\n+    /**\n+     * User data binder.\n+     */\n+    @Autowired\n+    private UserDataBinder userDataBinder;\n+\n+    /**\n+     * Build an UserTO out of connector object attributes and schema mapping.\n+     *\n+     * @param obj connector object\n+     * @return UserTO for the user to be created\n+     */\n+    public UserTO getUserTO(final ConnectorObject obj, final SyncTask syncTask) {\n+\n+        final UserTO userTO = new UserTO();\n+\n+        // 1. fill with data from connector object\n+        for (SchemaMapping mapping : syncTask.getResource().getMappings()) {\n+            Attribute attribute = obj.getAttributeByName(SchemaMappingUtil.getExtAttrName(mapping));\n+\n+            AttributeTO attributeTO;\n+            switch (mapping.getIntMappingType()) {\n+                case SyncopeUserId:\n+                    break;\n+\n+                case Password:\n+                    if (attribute != null && attribute.getValue() != null && !attribute.getValue().isEmpty()) {\n+                        userTO.setPassword(getPassword(attribute.getValue().get(0)));\n+                    }\n+                    break;\n+\n+                case Username:\n+                    userTO.setUsername(attribute == null || attribute.getValue().isEmpty()\n+                            ? null : attribute.getValue().get(0).toString());\n+                    break;\n+\n+                case UserSchema:\n+                    attributeTO = new AttributeTO();\n+                    attributeTO.setSchema(mapping.getIntAttrName());\n+\n+                    for (Object value : attribute == null ? Collections.EMPTY_LIST : attribute.getValue()) {\n+                        attributeTO.addValue(value.toString());\n+                    }\n+\n+                    userTO.addAttribute(attributeTO);\n+                    break;\n+\n+                case UserDerivedSchema:\n+                    attributeTO = new AttributeTO();\n+                    attributeTO.setSchema(mapping.getIntAttrName());\n+                    userTO.addDerivedAttribute(attributeTO);\n+                    break;\n+\n+                case UserVirtualSchema:\n+                    attributeTO = new AttributeTO();\n+                    attributeTO.setSchema(mapping.getIntAttrName());\n+                    userTO.addVirtualAttribute(attributeTO);\n+                    break;\n+\n+                default:\n+            }\n+        }\n+\n+        // 2. add data from defined template (if any)\n+        UserTO template = syncTask.getUserTemplate();\n+        if (template != null) {\n+            if (StringUtils.isBlank(userTO.getUsername()) && StringUtils.isNotBlank(template.getUsername())) {\n+                String evaluated = jexlUtil.evaluate(template.getUsername(), userTO);\n+                if (StringUtils.isNotBlank(evaluated)) {\n+                    userTO.setUsername(template.getUsername());\n+                }\n+            }\n+\n+            if (StringUtils.isBlank(userTO.getPassword()) && StringUtils.isNotBlank(template.getPassword())) {\n+                String evaluated = jexlUtil.evaluate(template.getPassword(), userTO);\n+                if (StringUtils.isNotBlank(evaluated)) {\n+                    userTO.setPassword(template.getPassword());\n+                }\n+            }\n+\n+            fillFromTemplate(userTO, template);\n+\n+            for (String resource : template.getResources()) {\n+                userTO.addResource(resource);\n+            }\n+\n+            Map<Long, MembershipTO> currentMembs = userTO.getMembershipMap();\n+            for (MembershipTO membTO : template.getMemberships()) {\n+                MembershipTO membTBU;\n+                if (currentMembs.containsKey(membTO.getRoleId())) {\n+                    membTBU = currentMembs.get(membTO.getRoleId());\n+                } else {\n+                    membTBU = new MembershipTO();\n+                    membTBU.setRoleId(membTO.getRoleId());\n+                    userTO.addMembership(membTBU);\n+                }\n+                fillFromTemplate(membTBU, membTO);\n+            }\n+        }\n+\n+        // 3. if password was not set above, generate a random string\n+        if (StringUtils.isBlank(userTO.getPassword())) {\n+            userTO.setPassword(RandomStringUtils.randomAlphanumeric(16));\n+        }\n+\n+        return userTO;\n+    }\n+\n+    /**\n+     * Build an UserMod out of connector object attributes and schema mapping.\n+     *\n+     * @param userId user to be updated\n+     * @param obj connector object\n+     * @return UserMod for the user to be updated\n+     */\n+    public UserMod getUserMod(final Long userId, final ConnectorObject obj, final SyncTask syncTask) {\n+\n+        final UserMod userMod = new UserMod();\n+        userMod.setId(userId);\n+\n+        for (SchemaMapping mapping : syncTask.getResource().getMappings()) {\n+            Attribute attribute = obj.getAttributeByName(SchemaMappingUtil.getExtAttrName(mapping));\n+\n+            List<Object> values = attribute == null\n+                    ? Collections.EMPTY_LIST : attribute.getValue();\n+\n+            AttributeMod attributeMod;\n+            switch (mapping.getIntMappingType()) {\n+                case SyncopeUserId:\n+                    break;\n+\n+                case Password:\n+                    attribute = obj.getAttributeByName(\n+                            OperationalAttributes.PASSWORD_NAME);\n+\n+                    if (attribute != null && attribute.getValue() != null\n+                            && !attribute.getValue().isEmpty()) {\n+\n+                        String password =\n+                                getPassword(attribute.getValue().get(0));\n+                        // update password if and only if password has really \n+                        // changed\n+                        try {\n+                            if (!userDataBinder.verifyPassword(userId,\n+                                    password)) {\n+\n+                                userMod.setPassword(password);\n+                            }\n+                        } catch (NotFoundException e) {\n+                            LOG.error(\"Could not find user {}\", userId, e);\n+                        } catch (UnauthorizedRoleException e) {\n+                            LOG.error(\"Not allowed to read user {}\", userId, e);\n+                        }\n+                    }\n+                    break;\n+\n+                case Username:\n+                    if (values != null && !values.isEmpty()) {\n+                        userMod.setUsername(values.get(0).toString());\n+                    }\n+                    break;\n+\n+                case UserSchema:\n+                    userMod.addAttributeToBeRemoved(mapping.getIntAttrName());\n+\n+                    attributeMod = new AttributeMod();\n+                    attributeMod.setSchema(mapping.getIntAttrName());\n+                    for (Object value : values) {\n+                        attributeMod.addValueToBeAdded(value.toString());\n+                    }\n+                    userMod.addAttributeToBeUpdated(attributeMod);\n+                    break;\n+\n+                case UserDerivedSchema:\n+                    userMod.addDerivedAttributeToBeAdded(mapping.getIntAttrName());\n+                    break;\n+\n+                case UserVirtualSchema:\n+                    userMod.addVirtualAttributeToBeRemoved(mapping.getIntAttrName());\n+\n+                    attributeMod = new AttributeMod();\n+                    attributeMod.setSchema(mapping.getIntAttrName());\n+                    for (Object value : values) {\n+                        attributeMod.addValueToBeAdded(value.toString());\n+                    }\n+                    userMod.addVirtualAttributeToBeUpdated(attributeMod);\n+                    break;\n+\n+                default:\n+            }\n+        }\n+\n+        return userMod;\n+    }\n+\n+    /**\n+     * Extract password value from passed value (if instance of GuardedString or GuardedByteArray).\n+     *\n+     * @param pwd received from the underlying connector\n+     * @return password value\n+     */\n+    public String getPassword(final Object pwd) {\n+        final StringBuilder result = new StringBuilder();\n+\n+        if (pwd instanceof GuardedString) {\n+            ((GuardedString) pwd).access(new GuardedString.Accessor() {\n+\n+                @Override\n+                public void access(final char[] clearChars) {\n+                    result.append(clearChars);\n+                }\n+            });\n+        } else if (pwd instanceof GuardedByteArray) {\n+            ((GuardedByteArray) pwd).access(new GuardedByteArray.Accessor() {\n+\n+                @Override\n+                public void access(final byte[] clearBytes) {\n+                    result.append(new String(clearBytes));\n+                }\n+            });\n+        } else if (pwd instanceof String) {\n+            result.append((String) pwd);\n+        } else {\n+            result.append(pwd.toString());\n+        }\n+\n+        return result.toString();\n+    }\n+\n+    /**\n+     * Get connector object TO from a connector object.\n+     *\n+     * @param connObject connector object.\n+     * @return connector object TO.\n+     */\n+    public ConnObjectTO getConnObjectTO(final ConnectorObject connObject) {\n+        final ConnObjectTO connObjectTO = new ConnObjectTO();\n+\n+        for (Attribute attr : connObject.getAttributes()) {\n+            AttributeTO attrTO = new AttributeTO();\n+            attrTO.setSchema(attr.getName());\n+\n+            if (attr.getValue() != null) {\n+                for (Object value : attr.getValue()) {\n+                    if (value != null) {\n+                        attrTO.addValue(value.toString());\n+                    }\n+                }\n+            }\n+\n+            connObjectTO.addAttribute(attrTO);\n+        }\n+\n+        return connObjectTO;\n+    }\n+\n+    private void fillFromTemplate(final AbstractAttributableTO attributableTO, final AbstractAttributableTO template) {\n+\n+        Map<String, AttributeTO> currentAttrMap =\n+                attributableTO.getAttributeMap();\n+        for (AttributeTO attrTO : template.getAttributes()) {\n+            if (!currentAttrMap.containsKey(attrTO.getSchema())) {\n+                attributableTO.addAttribute(evaluateAttrTemplate(attributableTO, attrTO));\n+            }\n+        }\n+\n+        currentAttrMap = attributableTO.getDerivedAttributeMap();\n+        for (AttributeTO attrTO : template.getDerivedAttributes()) {\n+            if (!currentAttrMap.containsKey(attrTO.getSchema())) {\n+                attributableTO.addDerivedAttribute(attrTO);\n+            }\n+        }\n+\n+        currentAttrMap = attributableTO.getVirtualAttributeMap();\n+        for (AttributeTO attrTO : template.getDerivedAttributes()) {\n+            if (!currentAttrMap.containsKey(attrTO.getSchema())) {\n+                attributableTO.addVirtualAttribute(evaluateAttrTemplate(attributableTO, attrTO));\n+            }\n+        }\n+    }\n+\n+    private AttributeTO evaluateAttrTemplate(\n+            final AbstractAttributableTO attributableTO,\n+            final AttributeTO template) {\n+\n+        AttributeTO result = new AttributeTO();\n+        result.setSchema(template.getSchema());\n+\n+        if (template.getValues() != null && !template.getValues().isEmpty()) {\n+            for (String value : template.getValues()) {\n+                String evaluated = jexlUtil.evaluate(value, attributableTO);\n+                if (StringUtils.isNotBlank(evaluated)) {\n+                    result.addValue(evaluated);\n+                }\n+            }\n+        }\n+\n+        return result;\n+    }\n+}"}]}