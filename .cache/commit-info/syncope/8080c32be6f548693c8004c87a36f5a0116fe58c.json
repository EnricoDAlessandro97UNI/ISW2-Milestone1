{"sha":"8080c32be6f548693c8004c87a36f5a0116fe58c","node_id":"MDY6Q29tbWl0NjM2ODc5MDYyOjgwODBjMzJiZTZmNTQ4NjkzYzgwMDRjODdhMzZmNWEwMTE2ZmU1OGM=","commit":{"author":{"name":"Fabio Martelli","email":"fmartelli@apache.org","date":"2013-02-13T11:51:21Z"},"committer":{"name":"Fabio Martelli","email":"fmartelli@apache.org","date":"2013-02-13T11:51:21Z"},"message":"SYNCOPE-154 merged from the branch 1_0_X and fixed\n\ngit-svn-id: https://svn.apache.org/repos/asf/syncope/trunk@1445561 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"d3c3d31af547817d2ba2af1778065148beaf4b45","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/git/trees/d3c3d31af547817d2ba2af1778065148beaf4b45"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/git/commits/8080c32be6f548693c8004c87a36f5a0116fe58c","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/8080c32be6f548693c8004c87a36f5a0116fe58c","html_url":"https://github.com/EnricoDAlessandro97UNI/syncope/commit/8080c32be6f548693c8004c87a36f5a0116fe58c","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/8080c32be6f548693c8004c87a36f5a0116fe58c/comments","author":{"login":"fmartelli","id":1791932,"node_id":"MDQ6VXNlcjE3OTE5MzI=","avatar_url":"https://avatars.githubusercontent.com/u/1791932?v=4","gravatar_id":"","url":"https://api.github.com/users/fmartelli","html_url":"https://github.com/fmartelli","followers_url":"https://api.github.com/users/fmartelli/followers","following_url":"https://api.github.com/users/fmartelli/following{/other_user}","gists_url":"https://api.github.com/users/fmartelli/gists{/gist_id}","starred_url":"https://api.github.com/users/fmartelli/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fmartelli/subscriptions","organizations_url":"https://api.github.com/users/fmartelli/orgs","repos_url":"https://api.github.com/users/fmartelli/repos","events_url":"https://api.github.com/users/fmartelli/events{/privacy}","received_events_url":"https://api.github.com/users/fmartelli/received_events","type":"User","site_admin":false},"committer":{"login":"fmartelli","id":1791932,"node_id":"MDQ6VXNlcjE3OTE5MzI=","avatar_url":"https://avatars.githubusercontent.com/u/1791932?v=4","gravatar_id":"","url":"https://api.github.com/users/fmartelli","html_url":"https://github.com/fmartelli","followers_url":"https://api.github.com/users/fmartelli/followers","following_url":"https://api.github.com/users/fmartelli/following{/other_user}","gists_url":"https://api.github.com/users/fmartelli/gists{/gist_id}","starred_url":"https://api.github.com/users/fmartelli/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fmartelli/subscriptions","organizations_url":"https://api.github.com/users/fmartelli/orgs","repos_url":"https://api.github.com/users/fmartelli/repos","events_url":"https://api.github.com/users/fmartelli/events{/privacy}","received_events_url":"https://api.github.com/users/fmartelli/received_events","type":"User","site_admin":false},"parents":[{"sha":"c489e8cc2562c4af3caa9aba77297ce6cdc161da","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/c489e8cc2562c4af3caa9aba77297ce6cdc161da","html_url":"https://github.com/EnricoDAlessandro97UNI/syncope/commit/c489e8cc2562c4af3caa9aba77297ce6cdc161da"}],"stats":{"total":544,"additions":496,"deletions":48},"files":[{"sha":"2ece7067c189f6bab105f11aff2aed41d5066f68","filename":"core/src/main/java/org/apache/syncope/core/connid/ConnObjectUtil.java","status":"modified","additions":91,"deletions":48,"changes":139,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/8080c32be6f548693c8004c87a36f5a0116fe58c/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fconnid%2FConnObjectUtil.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/8080c32be6f548693c8004c87a36f5a0116fe58c/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fconnid%2FConnObjectUtil.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fconnid%2FConnObjectUtil.java?ref=8080c32be6f548693c8004c87a36f5a0116fe58c","patch":"@@ -60,6 +60,7 @@\n import org.apache.syncope.core.util.InvalidPasswordPolicySpecException;\n import org.apache.syncope.core.util.JexlUtil;\n import org.apache.syncope.core.util.MappingUtil;\n+import org.apache.syncope.core.util.VirAttrCache;\n import org.identityconnectors.common.security.GuardedByteArray;\n import org.identityconnectors.common.security.GuardedString;\n import org.identityconnectors.framework.common.objects.Attribute;\n@@ -106,6 +107,12 @@ public class ConnObjectUtil {\n     @Autowired\n     private PasswordGenerator pwdGen;\n \n+    /**\n+     * Virtual attribute cache.\n+     */\n+    @Autowired\n+    private VirAttrCache virAttrCache;\n+\n     public ObjectClass fromAttributable(final AbstractAttributable attributable) {\n         if (attributable == null\n                 || (!(attributable instanceof SyncopeUser) && !(attributable instanceof SyncopeRole))) {\n@@ -467,70 +474,106 @@ public void retrieveVirAttrValues(final AbstractAttributable owner, final Attrib\n         final ConfigurableApplicationContext context = ApplicationContextProvider.getApplicationContext();\n         final ConnectorFactory connInstanceLoader = context.getBean(ConnectorFactory.class);\n \n-        final Map<ConnectorObject, Set<AbstractMappingItem>> connObj2MapItems =\n-                new HashMap<ConnectorObject, Set<AbstractMappingItem>>();\n+        final IntMappingType type = owner instanceof SyncopeUser\n+                ? IntMappingType.UserVirtualSchema : IntMappingType.RoleVirtualSchema;\n \n-        for (ExternalResource resource : owner.getResources()) {\n-            LOG.debug(\"Retrieve remote object from '{}'\", resource.getName());\n-            try {\n-                final String accountId = attrUtil.getAccountIdItem(resource) == null\n-                        ? null : MappingUtil.getAccountIdValue(owner, resource, attrUtil.getAccountIdItem(resource));\n+        final Map<String, ConnectorObject> externalResources = new HashMap<String, ConnectorObject>();\n \n-                LOG.debug(\"Search for object with accountId '{}'\", accountId);\n+        // -----------------------\n+        // Retrieve virtual attribute values\n+        // -----------------------\n+        for (AbstractVirAttr virAttr : owner.getVirtualAttributes()) {\n+            final String schemaName = virAttr.getVirtualSchema().getName();\n+            final List<String> values = virAttrCache.get(attrUtil.getType(), owner.getId(), schemaName);\n \n-                if (StringUtils.isNotBlank(accountId)) {\n-                    // Retrieve attributes to get\n-                    final Set<AbstractMappingItem> virMapItems = new HashSet<AbstractMappingItem>();\n-                    final Set<String> extAttrNames = new HashSet<String>();\n+            LOG.debug(\"Retrieve values for virtual attribute {}\", schemaName);\n \n-                    for (AbstractMappingItem item : attrUtil.getMappingItems(resource)) {\n-                        if ((AttributableType.USER == attrUtil.getType()\n-                                && item.getIntMappingType() == IntMappingType.UserVirtualSchema)\n-                                || (AttributableType.ROLE == attrUtil.getType()\n-                                && item.getIntMappingType() == IntMappingType.RoleVirtualSchema)) {\n+            if (values == null) {\n+                // non cached ...\n+                LOG.debug(\"Need one or more remote connections\");\n+                for (ExternalResource resource : getTargetResource(virAttr, type, attrUtil)) {\n+                    LOG.debug(\"Seach values into {}\", resource.getName());\n+                    try {\n+                        final ConnectorObject connectorObject;\n \n-                            virMapItems.add(item);\n-                            extAttrNames.add(item.getExtAttrName());\n-                        }\n-                    }\n+                        if (externalResources.containsKey(resource.getName())) {\n+                            connectorObject = externalResources.get(resource.getName());\n+                        } else {\n+                            LOG.debug(\"Perform connection to {}\", resource.getName());\n+                            final String accountId = attrUtil.getAccountIdItem(resource) == null\n+                                    ? null\n+                                    : MappingUtil.getAccountIdValue(\n+                                    owner, resource, attrUtil.getAccountIdItem(resource));\n+\n+                            if (StringUtils.isBlank(accountId)) {\n+                                throw new IllegalArgumentException(\"No AccountId found for \" + resource.getName());\n+                            }\n \n-                    // Search for remote object\n-                    final OperationOptionsBuilder oob = new OperationOptionsBuilder();\n-                    oob.setAttributesToGet(extAttrNames);\n+                            final Set<String> extAttrNames = new HashSet<String>();\n \n-                    final SyncopeConnector connector = connInstanceLoader.getConnector(resource);\n-                    final ConnectorObject connObj =\n-                            connector.getObject(fromAttributable(owner), new Uid(accountId), oob.build());\n-                    if (connObj != null) {\n-                        connObj2MapItems.put(connObj, virMapItems);\n-                    }\n+                            // retrieve all mapped virtual attribute values\n+                            for (AbstractMappingItem item :\n+                                    MappingUtil.getMatchingMappingItems(attrUtil.getMappingItems(resource), type)) {\n+                                extAttrNames.add(item.getExtAttrName());\n+                            }\n \n-                    LOG.debug(\"Retrieved remote object {}\", connObj);\n-                }\n-            } catch (Exception e) {\n-                LOG.error(\"Unable to retrieve virtual attribute values on '{}'\", resource.getName(), e);\n-            }\n-        }\n+                            LOG.debug(\"External attribute ({}) names to get '{}'\", type, extAttrNames);\n \n-        for (AbstractVirAttr virAttr : owner.getVirtualAttributes()) {\n-            LOG.debug(\"Provide value for virtual attribute '{}'\", virAttr.getVirtualSchema().getName());\n-\n-            for (Map.Entry<ConnectorObject, Set<AbstractMappingItem>> entry : connObj2MapItems.entrySet()) {\n-                for (AbstractMappingItem vAttrMapItem : entry.getValue()) {\n-                    final String extAttrName = vAttrMapItem.getExtAttrName();\n-                    final Attribute extAttr = entry.getKey().getAttributeByName(extAttrName);\n-                    if (extAttr != null && extAttr.getValue() != null && !extAttr.getValue().isEmpty()) {\n-                        for (Object obj : extAttr.getValue()) {\n-                            if (obj != null) {\n-                                virAttr.addValue(obj.toString());\n+                            final OperationOptionsBuilder oob = new OperationOptionsBuilder();\n+                            oob.setAttributesToGet(extAttrNames);\n+\n+                            final SyncopeConnector connector = connInstanceLoader.getConnector(resource);\n+                            connectorObject = connector.getObject(ObjectClass.ACCOUNT, new Uid(accountId), oob.build());\n+                            externalResources.put(resource.getName(), connectorObject);\n+                        }\n+\n+                        // ask for searched virtual attribute value\n+                        final List<AbstractMappingItem> mappings = MappingUtil.getMatchingMappingItems(\n+                                attrUtil.getMappingItems(resource), schemaName, type);\n+\n+                        // the same virtual attribute could be mapped with one or more external attribute \n+                        for (AbstractMappingItem mapping : mappings) {\n+                            final Attribute attribute = connectorObject.getAttributeByName(mapping.getExtAttrName());\n+\n+                            if (attribute != null && attribute.getValue() != null) {\n+                                for (Object obj : attribute.getValue()) {\n+                                    if (obj != null) {\n+                                        virAttr.addValue(obj.toString());\n+                                    }\n+                                }\n                             }\n                         }\n+\n+                        LOG.debug(\"Retrieved values {}\", virAttr.getValues());\n+                    } catch (Exception e) {\n+                        LOG.error(\"Error reading connector object from {}\", resource.getName(), e);\n                     }\n                 }\n+\n+                virAttrCache.put(attrUtil.getType(), owner.getId(), schemaName, virAttr.getValues());\n+            } else {\n+                // cached ...\n+                LOG.debug(\"Values found in cache {}\", values);\n+                virAttr.setValues(values);\n+            }\n+        }\n+        // -----------------------\n+    }\n+\n+    private Set<ExternalResource> getTargetResource(\n+            final AbstractVirAttr attr, final IntMappingType type, final AttributableUtil attrUtil) {\n+\n+        final Set<ExternalResource> resources = new HashSet<ExternalResource>();\n+\n+        for (ExternalResource res : attr.getOwner().getResources()) {\n+            if (!MappingUtil.getMatchingMappingItems(\n+                    attrUtil.getMappingItems(res), attr.getVirtualSchema().getName(), type).isEmpty()) {\n+\n+                resources.add(res);\n             }\n         }\n \n-        LOG.debug(\"Virtual attribute evaluation ended\");\n+        return resources;\n     }\n \n     private void fillFromTemplate(final AbstractAttributableTO attributableTO, final AbstractAttributableTO template) {"},{"sha":"d73aab7b4639172ce6a89bae0b5cbd680d40387d","filename":"core/src/main/java/org/apache/syncope/core/propagation/impl/PropagationManager.java","status":"modified","additions":16,"deletions":0,"changes":16,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/8080c32be6f548693c8004c87a36f5a0116fe58c/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpropagation%2Fimpl%2FPropagationManager.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/8080c32be6f548693c8004c87a36f5a0116fe58c/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpropagation%2Fimpl%2FPropagationManager.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpropagation%2Fimpl%2FPropagationManager.java?ref=8080c32be6f548693c8004c87a36f5a0116fe58c","patch":"@@ -29,6 +29,7 @@\n import org.apache.syncope.common.mod.AttributeMod;\n import org.apache.syncope.common.to.AttributeTO;\n import org.apache.syncope.common.types.AttributableType;\n+import org.apache.syncope.common.types.IntMappingType;\n import org.apache.syncope.common.types.ResourceOperation;\n import org.apache.syncope.core.connid.ConnObjectUtil;\n import org.apache.syncope.core.connid.PasswordGenerator;\n@@ -47,6 +48,7 @@\n import org.apache.syncope.core.rest.data.UserDataBinder;\n import org.apache.syncope.core.util.AttributableUtil;\n import org.apache.syncope.core.util.MappingUtil;\n+import org.apache.syncope.core.util.VirAttrCache;\n import org.apache.syncope.core.workflow.WorkflowResult;\n import org.identityconnectors.framework.common.objects.Attribute;\n import org.identityconnectors.framework.common.objects.AttributeBuilder;\n@@ -94,6 +96,12 @@ public class PropagationManager {\n     @Autowired\n     private PasswordGenerator passwordGenerator;\n \n+    /**\n+     * Virtual attribute cache.\n+     */\n+    @Autowired\n+    private VirAttrCache virAttrCache;\n+\n     /**\n      * Create the user on every associated resource.\n      *\n@@ -445,6 +453,14 @@ protected <T extends AbstractAttributable> Map.Entry<String, Set<Attribute>> pre\n             LOG.debug(\"Processing schema {}\", mapping.getIntAttrName());\n \n             try {\n+                if ((attrUtil.getType() == AttributableType.USER\n+                        && mapping.getIntMappingType() == IntMappingType.UserVirtualSchema)\n+                        || (attrUtil.getType() == AttributableType.ROLE\n+                        && mapping.getIntMappingType() == IntMappingType.RoleVirtualSchema)) {\n+                    LOG.debug(\"Expire entry cache {}-{}\", subject.getId(), mapping.getIntAttrName());\n+                    virAttrCache.expire(attrUtil.getType(), subject.getId(), mapping.getIntAttrName());\n+                }\n+\n                 Map.Entry<String, Attribute> preparedAttribute = MappingUtil.prepareAttribute(\n                         resource, mapping, subject, password, passwordGenerator, vAttrsToBeRemoved, vAttrsToBeUpdated);\n "},{"sha":"a9dc148010cfc9a26b97f140edaec58e685f3917","filename":"core/src/main/java/org/apache/syncope/core/util/MappingUtil.java","status":"modified","additions":14,"deletions":0,"changes":14,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/8080c32be6f548693c8004c87a36f5a0116fe58c/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Futil%2FMappingUtil.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/8080c32be6f548693c8004c87a36f5a0116fe58c/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Futil%2FMappingUtil.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Futil%2FMappingUtil.java?ref=8080c32be6f548693c8004c87a36f5a0116fe58c","patch":"@@ -71,6 +71,20 @@ public final class MappingUtil {\n      */\n     private static final Logger LOG = LoggerFactory.getLogger(MappingUtil.class);\n \n+    public static <T extends AbstractMappingItem> List<T> getMatchingMappingItems(\n+            final Collection<T> items, final IntMappingType type) {\n+\n+        final List<T> result = new ArrayList<T>();\n+\n+        for (T mapItem : items) {\n+            if (mapItem.getIntMappingType() == type) {\n+                result.add(mapItem);\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n     public static <T extends AbstractMappingItem> List<T> getMatchingMappingItems(final Collection<T> items,\n             final String intAttrName, final IntMappingType type) {\n "},{"sha":"f79f97b0baeb506efd9b79ec74bfc2943e38b9b4","filename":"core/src/main/java/org/apache/syncope/core/util/VirAttrCache.java","status":"added","additions":161,"deletions":0,"changes":161,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/8080c32be6f548693c8004c87a36f5a0116fe58c/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Futil%2FVirAttrCache.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/8080c32be6f548693c8004c87a36f5a0116fe58c/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Futil%2FVirAttrCache.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Futil%2FVirAttrCache.java?ref=8080c32be6f548693c8004c87a36f5a0116fe58c","patch":"@@ -0,0 +1,161 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.core.util;\n+\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.syncope.common.types.AttributableType;\n+\n+/**\n+ * Virtual Attribute Value cache.\n+ */\n+public final class VirAttrCache {\n+\n+    /**\n+     * Elapsed time in seconds.\n+     */\n+    private final int ttl;\n+\n+    /**\n+     * Max cache size.\n+     */\n+    private final int maxCacheSize;\n+\n+    /**\n+     * Clean period.\n+     */\n+    private final int cleanPeriod;\n+\n+    /**\n+     * Cache entries.\n+     */\n+    private final Map<VirAttrCacheKey, VirAttrCacheValue> cache = new HashMap<VirAttrCacheKey, VirAttrCacheValue>();\n+\n+    public VirAttrCache(final int ttl, final int maxCacheSize, final int cleanPeriod) {\n+        this.ttl = ttl;\n+        this.maxCacheSize = maxCacheSize;\n+        this.cleanPeriod = cleanPeriod;\n+\n+        Executors.newScheduledThreadPool(1).scheduleWithFixedDelay(\n+                new Runnable() {\n+\n+                    @Override\n+                    public void run() {\n+                        synchronized (cache) {\n+                            freeCacheSpace(false);\n+                        }\n+                    }\n+                }, cleanPeriod, cleanPeriod, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Cache virtual attribute values.\n+     *\n+     * @param userId user id.\n+     * @param schemaName virtual attribute name.\n+     * @param values virtual attribute values.\n+     */\n+    public void put(\n+            final AttributableType type, final Long userId, final String schemaName, final List<String> values) {\n+        synchronized (cache) {\n+            // this operations (retrieve cache space and put entry on) have to be thread safe.\n+\n+            if (cache.size() >= maxCacheSize) {\n+                freeCacheSpace(true);\n+            }\n+\n+            cache.put(new VirAttrCacheKey(type, userId, schemaName), new VirAttrCacheValue(values));\n+        }\n+    }\n+\n+    /**\n+     * Retrieve cached value. Return null in case of virtual attribute not cached.\n+     *\n+     * @param userId user id.\n+     * @param schemaName virtual attribute schema name.\n+     * @return cached values or null in case of virtual attribute not found.\n+     */\n+    public List<String> get(final AttributableType type, final Long userId, final String schemaName) {\n+        final VirAttrCacheValue value = cache.get(new VirAttrCacheKey(type, userId, schemaName));\n+        return isValidEntry(value) ? value.getValues() : null;\n+    }\n+\n+    /**\n+     * Force entry expiring.\n+     *\n+     * @param userId user id.\n+     * @param schemaName virtual attribute schema name.\n+     */\n+    public void expire(final AttributableType type, final Long userId, final String schemaName) {\n+        final VirAttrCacheValue value = cache.get(new VirAttrCacheKey(type, userId, schemaName));\n+        if (isValidEntry(value)) {\n+            synchronized (cache) {\n+                value.forceExpiring();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Remove expired entries if exist. If required, one entry at least (the latest recently used) will be taken off.\n+     * This method is not thread safe: the caller have to take care to synchronize the call.\n+     *\n+     * @param forceEscape if TRUE the latest recently used entry at least will be taken off.\n+     */\n+    private void freeCacheSpace(final boolean forceEscape) {\n+        final Set<VirAttrCacheKey> toBeRemoved = new HashSet<VirAttrCacheKey>();\n+\n+        Map.Entry<VirAttrCacheKey, VirAttrCacheValue> latest = null;\n+\n+        for (Map.Entry<VirAttrCacheKey, VirAttrCacheValue> entry : cache.entrySet()) {\n+            if (isValidEntry(entry.getValue())) {\n+                final Date date = entry.getValue().getLastAccessDate();\n+                if (latest == null || latest.getValue().getLastAccessDate().after(date)) {\n+                    latest = entry;\n+                }\n+            } else {\n+                toBeRemoved.add(entry.getKey());\n+            }\n+        }\n+\n+        if (toBeRemoved.isEmpty() && forceEscape) {\n+            // remove the oldest entry.\n+            cache.remove(latest.getKey());\n+        } else {\n+            // remove expired entries.\n+            cache.keySet().removeAll(toBeRemoved);\n+        }\n+    }\n+\n+    /**\n+     * Cache entry is valid if and only if value exist and it is not expired.\n+     *\n+     * @param value cache entry value.\n+     * @return TRUE if the value is valid; FALSE otherwise.\n+     */\n+    private boolean isValidEntry(final VirAttrCacheValue value) {\n+        final Date expiringDate = new Date(value == null ? 0 : value.getCreationDate().getTime() + ttl * 1000);\n+        return expiringDate.after(new Date());\n+    }\n+}"},{"sha":"8d3a25edc3c48bb0259b2014edac1fc4a86e2b5c","filename":"core/src/main/java/org/apache/syncope/core/util/VirAttrCacheKey.java","status":"added","additions":73,"deletions":0,"changes":73,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/8080c32be6f548693c8004c87a36f5a0116fe58c/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Futil%2FVirAttrCacheKey.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/8080c32be6f548693c8004c87a36f5a0116fe58c/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Futil%2FVirAttrCacheKey.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Futil%2FVirAttrCacheKey.java?ref=8080c32be6f548693c8004c87a36f5a0116fe58c","patch":"@@ -0,0 +1,73 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.core.util;\n+\n+import org.apache.syncope.common.types.AttributableType;\n+\n+/**\n+ * Ccahe entry key.\n+ */\n+public class VirAttrCacheKey {\n+\n+    /**\n+     * Subject type.\n+     */\n+    private final AttributableType type;\n+\n+    /**\n+     * Subject ID.\n+     */\n+    private final transient Long id;\n+\n+    /**\n+     * Virtual attribute schema name.\n+     */\n+    private final transient String virAttrSchema;\n+\n+    public VirAttrCacheKey(final AttributableType type, final Long id, final String virAttrSchema) {\n+        this.type = type;\n+        this.id = id;\n+        this.virAttrSchema = virAttrSchema;\n+    }\n+\n+    public Long getId() {\n+        return id;\n+    }\n+\n+    public String getVirAttrSchema() {\n+        return virAttrSchema;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return 31 * (31 * (31\n+                + (id == null ? 0 : id.hashCode()))\n+                + (virAttrSchema == null ? 0 : virAttrSchema.hashCode()))\n+                + (type == null ? 0 : type.hashCode());\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        return o != null && o instanceof VirAttrCacheKey\n+                && ((id == null && ((VirAttrCacheKey) o).getId() == null)\n+                || id.equals(((VirAttrCacheKey) o).getId()))\n+                && ((virAttrSchema == null && ((VirAttrCacheKey) o).getVirAttrSchema() == null)\n+                || virAttrSchema.equals(((VirAttrCacheKey) o).getVirAttrSchema()));\n+    }\n+}"},{"sha":"9b52a0ca22202ef13593d43681fbbefacd4dd10e","filename":"core/src/main/java/org/apache/syncope/core/util/VirAttrCacheValue.java","status":"added","additions":69,"deletions":0,"changes":69,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/8080c32be6f548693c8004c87a36f5a0116fe58c/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Futil%2FVirAttrCacheValue.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/8080c32be6f548693c8004c87a36f5a0116fe58c/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Futil%2FVirAttrCacheValue.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Futil%2FVirAttrCacheValue.java?ref=8080c32be6f548693c8004c87a36f5a0116fe58c","patch":"@@ -0,0 +1,69 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.core.util;\n+\n+import java.util.Date;\n+import java.util.List;\n+\n+/**\n+ * Cache entry value.\n+ */\n+public class VirAttrCacheValue {\n+\n+    /**\n+     * Virtual attribute values.\n+     */\n+    private final List<String> values;\n+\n+    /**\n+     * Entry creation date.\n+     */\n+    private Date creationDate;\n+\n+    /**\n+     * Entry access date.\n+     */\n+    private Date lastAccessDate;\n+\n+    public VirAttrCacheValue(final List<String> values) {\n+        this.values = values;\n+        this.creationDate = new Date();\n+        this.lastAccessDate = new Date();\n+    }\n+\n+    public Date getCreationDate() {\n+        return creationDate;\n+    }\n+\n+    public void forceExpiring() {\n+        creationDate = new Date(0);\n+    }\n+\n+    public List<String> getValues() {\n+        return values;\n+    }\n+\n+    public Date getLastAccessDate() {\n+        return lastAccessDate;\n+    }\n+\n+    void setLastAccessDate(Date lastAccessDate) {\n+        this.lastAccessDate = lastAccessDate;\n+    }\n+}"},{"sha":"fed3bcd7542a8e3115e071cfe838bb33c901043f","filename":"core/src/main/resources/syncopeContext.xml","status":"modified","additions":7,"deletions":0,"changes":7,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/8080c32be6f548693c8004c87a36f5a0116fe58c/core%2Fsrc%2Fmain%2Fresources%2FsyncopeContext.xml","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/8080c32be6f548693c8004c87a36f5a0116fe58c/core%2Fsrc%2Fmain%2Fresources%2FsyncopeContext.xml","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fresources%2FsyncopeContext.xml?ref=8080c32be6f548693c8004c87a36f5a0116fe58c","patch":"@@ -88,5 +88,12 @@ under the License.\n     <property name=\"lenient\" value=\"true\"/>\n     <property name=\"silent\" value=\"false\"/>\n   </bean>\n+  \n   <bean id=\"jexlUtil\" class=\"org.apache.syncope.core.util.JexlUtil\"/>\n+  \n+  <bean id=\"virAttrCache\" class=\"org.apache.syncope.core.util.VirAttrCache\" scope=\"singleton\">\n+    <constructor-arg value=\"60\"/>\n+    <constructor-arg value=\"5000\"/>\n+    <constructor-arg value=\"5\"/>\n+  </bean>\n </beans>"},{"sha":"d9588506a9c2eb6f1cca66a53d622e143005280d","filename":"core/src/test/java/org/apache/syncope/core/rest/UserTestITCase.java","status":"modified","additions":65,"deletions":0,"changes":65,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/8080c32be6f548693c8004c87a36f5a0116fe58c/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Frest%2FUserTestITCase.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/8080c32be6f548693c8004c87a36f5a0116fe58c/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Frest%2FUserTestITCase.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Frest%2FUserTestITCase.java?ref=8080c32be6f548693c8004c87a36f5a0116fe58c","patch":"@@ -1958,6 +1958,71 @@ public void isseSYNCOPE136Random() {\n         assertEquals(PropagationTaskExecStatus.SUCCESS, prop.getStatus());\n     }\n \n+    @Test\n+    public void virAttrCache() {\n+        UserTO userTO = getUniqueSampleTO(\"virattrcache@apache.org\");\n+        userTO.getVirtualAttributes().clear();\n+\n+        AttributeTO virAttrTO = new AttributeTO();\n+        virAttrTO.setSchema(\"virtualdata\");\n+        virAttrTO.addValue(\"virattrcache\");\n+        userTO.addVirtualAttribute(virAttrTO);\n+\n+        userTO.getMemberships().clear();\n+        userTO.getResources().clear();\n+        userTO.addResource(\"resource-db-virattr\");\n+\n+        // 1. create user\n+        UserTO actual = createUser(userTO);\n+        assertNotNull(actual);\n+\n+        // 2. check for virtual attribute value\n+        actual = userService.read(actual.getId());\n+        assertEquals(\"virattrcache\", actual.getVirtualAttributeMap().get(\"virtualdata\").getValues().get(0));\n+\n+        Exception exception = null;\n+        try {\n+            final JdbcTemplate jdbcTemplate = new JdbcTemplate(testDataSource);\n+\n+            String value = jdbcTemplate.queryForObject(\n+                    \"SELECT USERNAME FROM testsync WHERE ID=?\", String.class, actual.getId());\n+            assertEquals(\"virattrcache\", value);\n+\n+            jdbcTemplate.update(\"UPDATE testsync set USERNAME='virattrcache2' WHERE ID=?\", userTO.getId());\n+\n+            value = jdbcTemplate.queryForObject(\n+                    \"SELECT USERNAME FROM testsync WHERE ID=?\", String.class, userTO.getId());\n+            assertEquals(\"virattrcache2\", value);\n+\n+        } catch (EmptyResultDataAccessException e) {\n+            exception = e;\n+        }\n+        assertNotNull(exception);\n+\n+        // 2. check for cached attribute value\n+        actual = userService.read(actual.getId());\n+        assertEquals(\"virattrcache\", actual.getVirtualAttributeMap().get(\"virtualdata\").getValues().get(0));\n+\n+        UserMod userMod = new UserMod();\n+        userMod.setId(actual.getId());\n+\n+        AttributeMod virtualdata = new AttributeMod();\n+        virtualdata.setSchema(\"virtualdata\");\n+        virtualdata.addValueToBeAdded(\"virtualupdated\");\n+\n+        userMod.addVirtualAttributeToBeRemoved(\"virtualdata\");\n+        userMod.addVirtualAttributeToBeUpdated(virtualdata);\n+\n+        // 3. update virtual attribute\n+        actual = userService.update(actual.getId(), userMod);\n+        assertNotNull(actual);\n+\n+        // 4. check for virtual attribute value\n+        actual = userService.read(actual.getId());\n+        assertNotNull(actual);\n+        assertEquals(\"virtualupdated\", actual.getVirtualAttributeMap().get(\"virtualdata\").getValues().get(0));\n+    }\n+\n     private boolean getBooleanAttribute(ConnObjectTO connObjectTO, String attrName) {\n         return Boolean.parseBoolean(getStringAttribute(connObjectTO, attrName));\n     }"}]}