{"sha":"bdb3257c8f227716fe52d950aa6626e9bab84478","node_id":"MDY6Q29tbWl0NjM2ODc5MDYyOmJkYjMyNTdjOGYyMjc3MTZmZTUyZDk1MGFhNjYyNmU5YmFiODQ0Nzg=","commit":{"author":{"name":"giacomolm","email":"giacomolm@hotmail.it","date":"2015-06-22T14:14:10Z"},"committer":{"name":"giacomolm","email":"giacomolm@hotmail.it","date":"2015-06-22T14:14:10Z"},"message":"[SYNCOPE-660]Forcing interrupt for heavy tasks - minor improvement","tree":{"sha":"63e0a6c2535992f9c1f53d5ab272b2c377902b65","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/git/trees/63e0a6c2535992f9c1f53d5ab272b2c377902b65"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/git/commits/bdb3257c8f227716fe52d950aa6626e9bab84478","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/bdb3257c8f227716fe52d950aa6626e9bab84478","html_url":"https://github.com/EnricoDAlessandro97UNI/syncope/commit/bdb3257c8f227716fe52d950aa6626e9bab84478","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/bdb3257c8f227716fe52d950aa6626e9bab84478/comments","author":{"login":"giacomolm","id":4027829,"node_id":"MDQ6VXNlcjQwMjc4Mjk=","avatar_url":"https://avatars.githubusercontent.com/u/4027829?v=4","gravatar_id":"","url":"https://api.github.com/users/giacomolm","html_url":"https://github.com/giacomolm","followers_url":"https://api.github.com/users/giacomolm/followers","following_url":"https://api.github.com/users/giacomolm/following{/other_user}","gists_url":"https://api.github.com/users/giacomolm/gists{/gist_id}","starred_url":"https://api.github.com/users/giacomolm/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/giacomolm/subscriptions","organizations_url":"https://api.github.com/users/giacomolm/orgs","repos_url":"https://api.github.com/users/giacomolm/repos","events_url":"https://api.github.com/users/giacomolm/events{/privacy}","received_events_url":"https://api.github.com/users/giacomolm/received_events","type":"User","site_admin":false},"committer":{"login":"giacomolm","id":4027829,"node_id":"MDQ6VXNlcjQwMjc4Mjk=","avatar_url":"https://avatars.githubusercontent.com/u/4027829?v=4","gravatar_id":"","url":"https://api.github.com/users/giacomolm","html_url":"https://github.com/giacomolm","followers_url":"https://api.github.com/users/giacomolm/followers","following_url":"https://api.github.com/users/giacomolm/following{/other_user}","gists_url":"https://api.github.com/users/giacomolm/gists{/gist_id}","starred_url":"https://api.github.com/users/giacomolm/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/giacomolm/subscriptions","organizations_url":"https://api.github.com/users/giacomolm/orgs","repos_url":"https://api.github.com/users/giacomolm/repos","events_url":"https://api.github.com/users/giacomolm/events{/privacy}","received_events_url":"https://api.github.com/users/giacomolm/received_events","type":"User","site_admin":false},"parents":[{"sha":"fed10a7a779b22cbb58ed824f4b386c2ec19f667","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/fed10a7a779b22cbb58ed824f4b386c2ec19f667","html_url":"https://github.com/EnricoDAlessandro97UNI/syncope/commit/fed10a7a779b22cbb58ed824f4b386c2ec19f667"}],"stats":{"total":29,"additions":13,"deletions":16},"files":[{"sha":"2fcef9edc8114840996a6ef9c524e72b12b6fb5a","filename":"core/src/main/java/org/apache/syncope/core/quartz/AbstractTaskJob.java","status":"modified","additions":13,"deletions":16,"changes":29,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/bdb3257c8f227716fe52d950aa6626e9bab84478/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fquartz%2FAbstractTaskJob.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/bdb3257c8f227716fe52d950aa6626e9bab84478/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fquartz%2FAbstractTaskJob.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fquartz%2FAbstractTaskJob.java?ref=bdb3257c8f227716fe52d950aa6626e9bab84478","patch":"@@ -18,11 +18,8 @@\n  */\n package org.apache.syncope.core.quartz;\n \n-import java.text.SimpleDateFormat;\n import java.util.Date;\n-import java.util.Locale;\n import java.util.concurrent.atomic.AtomicReference;\n-import org.apache.syncope.common.SyncopeConstants;\n import org.apache.syncope.common.types.AuditElements;\n import org.apache.syncope.common.types.AuditElements.Result;\n import org.apache.syncope.core.audit.AuditManager;\n@@ -32,6 +29,7 @@\n import org.apache.syncope.core.persistence.dao.ConfDAO;\n import org.apache.syncope.core.persistence.dao.TaskDAO;\n import org.apache.syncope.core.persistence.dao.TaskExecDAO;\n+import org.apache.syncope.core.util.DataFormat;\n import org.apache.syncope.core.util.ExceptionUtil;\n import org.quartz.DisallowConcurrentExecution;\n import org.quartz.JobExecutionContext;\n@@ -197,20 +195,19 @@ protected boolean hasToBeRegistered(final TaskExec execution) {\n     @Override\n     public void interrupt() throws UnableToInterruptJobException {\n         Thread thread = this.runningThread.getAndSet(null);\n-        if (thread != null) {\n-            LOG.info(\"Interrupting job time {} \", (new SimpleDateFormat(SyncopeConstants.DEFAULT_DATE_PATTERN, Locale.\n-                    getDefault())).format(new Date()));\n-            thread.interrupt();\n-            if (thread.isAlive()) {                \n-                long maxRetry = confDAO.find(\"tasks.interruptMaxRetries\", \"0\").getValues().get(0).getLongValue();\n-                for (int i = 0; i <= maxRetry && thread.isAlive(); i++) {\n-                    thread.interrupt();\n-                }\n-                //if the thread is still alive, it should be available in the next stop\n-                if(thread.isAlive()) this.runningThread.set(thread);\n-            }\n+        if (thread == null) {\n+            LOG.warn(\"Unable to retrieve the thread of the current job execution\");\n         } else {\n-            LOG.warn(\"Unable to retrieve the right thread related to the current job execution\");\n+            LOG.info(\"Interrupting job from thread {} at {} \", thread.getId(), DataFormat.format(new Date()));\n+\n+            long maxRetry = confDAO.find(\"tasks.interruptMaxRetries\", \"1\").getValues().get(0).getLongValue();\n+            for (int i = 0; i < maxRetry && thread.isAlive(); i++) {\n+                thread.interrupt();\n+            }\n+            // if the thread is still alive, it should be available in the next stop\n+            if (thread.isAlive()) {\n+                this.runningThread.set(thread);\n+            }\n         }\n     }\n }"}]}