{"sha":"591abc8ad4b8c9b3318d2bdd4ed152ff589c2eaf","node_id":"MDY6Q29tbWl0NjM2ODc5MDYyOjU5MWFiYzhhZDRiOGM5YjMzMThkMmJkZDRlZDE1MmZmNTg5YzJlYWY=","commit":{"author":{"name":"Francesco Chicchiriccò","email":"ilgrosso@apache.org","date":"2019-01-28T08:16:18Z"},"committer":{"name":"Francesco Chicchiriccò","email":"ilgrosso@apache.org","date":"2019-01-28T08:33:08Z"},"message":"More robust test handling","tree":{"sha":"b7f62505c2e180ba5d705a4eb39b9de25b2180ac","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/git/trees/b7f62505c2e180ba5d705a4eb39b9de25b2180ac"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/git/commits/591abc8ad4b8c9b3318d2bdd4ed152ff589c2eaf","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/591abc8ad4b8c9b3318d2bdd4ed152ff589c2eaf","html_url":"https://github.com/EnricoDAlessandro97UNI/syncope/commit/591abc8ad4b8c9b3318d2bdd4ed152ff589c2eaf","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/591abc8ad4b8c9b3318d2bdd4ed152ff589c2eaf/comments","author":{"login":"ilgrosso","id":1064664,"node_id":"MDQ6VXNlcjEwNjQ2NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/1064664?v=4","gravatar_id":"","url":"https://api.github.com/users/ilgrosso","html_url":"https://github.com/ilgrosso","followers_url":"https://api.github.com/users/ilgrosso/followers","following_url":"https://api.github.com/users/ilgrosso/following{/other_user}","gists_url":"https://api.github.com/users/ilgrosso/gists{/gist_id}","starred_url":"https://api.github.com/users/ilgrosso/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ilgrosso/subscriptions","organizations_url":"https://api.github.com/users/ilgrosso/orgs","repos_url":"https://api.github.com/users/ilgrosso/repos","events_url":"https://api.github.com/users/ilgrosso/events{/privacy}","received_events_url":"https://api.github.com/users/ilgrosso/received_events","type":"User","site_admin":false},"committer":{"login":"ilgrosso","id":1064664,"node_id":"MDQ6VXNlcjEwNjQ2NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/1064664?v=4","gravatar_id":"","url":"https://api.github.com/users/ilgrosso","html_url":"https://github.com/ilgrosso","followers_url":"https://api.github.com/users/ilgrosso/followers","following_url":"https://api.github.com/users/ilgrosso/following{/other_user}","gists_url":"https://api.github.com/users/ilgrosso/gists{/gist_id}","starred_url":"https://api.github.com/users/ilgrosso/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ilgrosso/subscriptions","organizations_url":"https://api.github.com/users/ilgrosso/orgs","repos_url":"https://api.github.com/users/ilgrosso/repos","events_url":"https://api.github.com/users/ilgrosso/events{/privacy}","received_events_url":"https://api.github.com/users/ilgrosso/received_events","type":"User","site_admin":false},"parents":[{"sha":"22221e7701dec17517bbbb0d5e250b91b6675204","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/22221e7701dec17517bbbb0d5e250b91b6675204","html_url":"https://github.com/EnricoDAlessandro97UNI/syncope/commit/22221e7701dec17517bbbb0d5e250b91b6675204"}],"stats":{"total":109,"additions":68,"deletions":41},"files":[{"sha":"e6f4a14f97c54bbaf71f7499cddf7bf3f5980250","filename":"fit/core-reference/src/test/java/org/apache/syncope/fit/core/LoggerITCase.java","status":"modified","additions":68,"deletions":41,"changes":109,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/591abc8ad4b8c9b3318d2bdd4ed152ff589c2eaf/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FLoggerITCase.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/591abc8ad4b8c9b3318d2bdd4ed152ff589c2eaf/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FLoggerITCase.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2FLoggerITCase.java?ref=591abc8ad4b8c9b3318d2bdd4ed152ff589c2eaf","patch":"@@ -27,13 +27,16 @@\n import java.io.File;\n import java.io.IOException;\n import java.io.InputStream;\n-import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardOpenOption;\n import java.text.ParseException;\n import java.util.List;\n import java.util.Properties;\n import javax.ws.rs.core.Response;\n import javax.xml.ws.WebServiceException;\n-import org.apache.commons.io.FileUtils;\n import org.apache.commons.lang3.StringUtils;\n import org.apache.syncope.common.lib.SyncopeClientException;\n import org.apache.syncope.common.lib.log.EventCategory;\n@@ -243,41 +246,64 @@ public void listAuditEvents() {\n         assertTrue(found);\n     }\n \n+    private boolean logFileContains(final Path path, final String message, final int maxWaitSeconds)\n+            throws IOException {\n+\n+        int i = 0;\n+        boolean messagePresent = false;\n+        do {\n+            try {\n+                Thread.sleep(1000);\n+            } catch (InterruptedException e) {\n+            }\n+\n+            String auditLog = Files.readString(path, StandardCharsets.UTF_8);\n+            messagePresent = auditLog.contains(message);\n+\n+            i++;\n+        } while (!messagePresent && i < maxWaitSeconds);\n+        return messagePresent;\n+    }\n+\n     @Test\n     public void customAuditAppender() throws IOException, InterruptedException {\n+        AuditLoggerName auditLoggerResUpd = new AuditLoggerName(\n+                EventCategoryType.LOGIC,\n+                ResourceLogic.class.getSimpleName(),\n+                null,\n+                \"update\",\n+                AuditElements.Result.SUCCESS);\n+        LoggerTO resUpd = new LoggerTO();\n+        resUpd.setKey(auditLoggerResUpd.toLoggerName());\n+\n+        AuditLoggerName auditLoggerConnUpd = new AuditLoggerName(\n+                EventCategoryType.LOGIC,\n+                ConnectorLogic.class.getSimpleName(),\n+                null,\n+                \"update\",\n+                AuditElements.Result.SUCCESS);\n+        LoggerTO connUpd = new LoggerTO();\n+        connUpd.setKey(auditLoggerConnUpd.toLoggerName());\n+\n         try (InputStream propStream = getClass().getResourceAsStream(\"/core-test.properties\")) {\n             Properties props = new Properties();\n             props.load(propStream);\n \n-            String auditFilePath = props.getProperty(\"test.log.dir\")\n-                    + File.separator + \"audit_for_Master_file.log\";\n-            String auditNoRewriteFilePath = props.getProperty(\"test.log.dir\")\n-                    + File.separator + \"audit_for_Master_norewrite_file.log\";\n+            Path auditFilePath = Paths.get(props.getProperty(\"test.log.dir\")\n+                    + File.separator + \"audit_for_Master_file.log\");\n+            Files.write(auditFilePath, new byte[0], StandardOpenOption.TRUNCATE_EXISTING);\n+\n+            Path auditNoRewriteFilePath = Paths.get(props.getProperty(\"test.log.dir\")\n+                    + File.separator + \"audit_for_Master_norewrite_file.log\");\n+            Files.write(auditNoRewriteFilePath, new byte[0], StandardOpenOption.TRUNCATE_EXISTING);\n+\n             // 1. Enable audit for resource update -> catched by FileRewriteAuditAppender\n-            AuditLoggerName auditLoggerResUpd = new AuditLoggerName(\n-                    EventCategoryType.LOGIC,\n-                    ResourceLogic.class.getSimpleName(),\n-                    null,\n-                    \"update\",\n-                    AuditElements.Result.SUCCESS);\n-\n-            LoggerTO loggerTOUpd = new LoggerTO();\n-            loggerTOUpd.setKey(auditLoggerResUpd.toLoggerName());\n-            loggerTOUpd.setLevel(LoggerLevel.DEBUG);\n-            loggerService.update(LoggerType.AUDIT, loggerTOUpd);\n+            resUpd.setLevel(LoggerLevel.DEBUG);\n+            loggerService.update(LoggerType.AUDIT, resUpd);\n \n             // 2. Enable audit for connector update -> NOT catched by FileRewriteAuditAppender\n-            AuditLoggerName auditLoggerConnUpd = new AuditLoggerName(\n-                    EventCategoryType.LOGIC,\n-                    ConnectorLogic.class.getSimpleName(),\n-                    null,\n-                    \"update\",\n-                    AuditElements.Result.SUCCESS);\n-\n-            LoggerTO loggerTOConnUpd = new LoggerTO();\n-            loggerTOConnUpd.setKey(auditLoggerConnUpd.toLoggerName());\n-            loggerTOConnUpd.setLevel(LoggerLevel.DEBUG);\n-            loggerService.update(LoggerType.AUDIT, loggerTOConnUpd);\n+            connUpd.setLevel(LoggerLevel.DEBUG);\n+            loggerService.update(LoggerType.AUDIT, connUpd);\n \n             // 3. check that resource update is transformed and logged onto an audit file.\n             ResourceTO resource = resourceService.read(RESOURCE_NAME_CSV);\n@@ -290,23 +316,18 @@ public void customAuditAppender() throws IOException, InterruptedException {\n             connector.setPoolConf(new ConnPoolConfTO());\n             connectorService.update(connector);\n \n-            File auditTempFile = new File(auditFilePath);\n             // check audit_for_Master_file.log, it should contain only a static message\n-            String auditLog = FileUtils.readFileToString(auditTempFile, Charset.defaultCharset());\n-\n-            assertTrue(StringUtils.contains(auditLog,\n+            assertTrue(logFileContains(auditFilePath,\n                     \"DEBUG Master.syncope.audit.[LOGIC]:[ResourceLogic]:[]:[update]:[SUCCESS]\"\n-                    + \" - This is a static test message\"));\n-            File auditNoRewriteTempFile = new File(auditNoRewriteFilePath);\n-            // check audit_for_Master_file.log, it should contain only a static message\n-            String auditLogNoRewrite = FileUtils.readFileToString(auditNoRewriteTempFile, Charset.defaultCharset());\n+                    + \" - This is a static test message\", 10));\n \n-            assertFalse(StringUtils.contains(auditLogNoRewrite,\n+            // nothing expected in audit_for_Master_norewrite_file.log instead\n+            assertFalse(logFileContains(auditNoRewriteFilePath,\n                     \"DEBUG Master.syncope.audit.[LOGIC]:[ResourceLogic]:[]:[update]:[SUCCESS]\"\n-                    + \" - This is a static test message\"));\n+                    + \" - This is a static test message\", 10));\n \n             // clean audit_for_Master_file.log\n-            FileUtils.writeStringToFile(auditTempFile, StringUtils.EMPTY, Charset.defaultCharset());\n+            Files.write(auditFilePath, new byte[0], StandardOpenOption.TRUNCATE_EXISTING);\n             loggerService.delete(LoggerType.AUDIT, \"syncope.audit.[LOGIC]:[ResourceLogic]:[]:[update]:[SUCCESS]\");\n \n             resource = resourceService.read(RESOURCE_NAME_CSV);\n@@ -315,9 +336,15 @@ public void customAuditAppender() throws IOException, InterruptedException {\n             resourceService.update(resource);\n \n             // check that nothing has been written to audit_for_Master_file.log\n-            assertTrue(StringUtils.isEmpty(FileUtils.readFileToString(auditTempFile, Charset.defaultCharset())));\n+            assertTrue(StringUtils.isEmpty(Files.readString(auditFilePath, StandardCharsets.UTF_8)));\n         } catch (IOException e) {\n-            fail(\"Unable to read/write log files\" + e.getMessage());\n+            fail(\"Unable to read/write log files\", e);\n+        } finally {\n+            resUpd.setLevel(LoggerLevel.ERROR);\n+            loggerService.update(LoggerType.AUDIT, resUpd);\n+\n+            connUpd.setLevel(LoggerLevel.ERROR);\n+            loggerService.update(LoggerType.AUDIT, connUpd);\n         }\n     }\n "}]}