{"sha":"72e6ceb0624a90a9b63bafce37c04104c7391d79","node_id":"MDY6Q29tbWl0NjM2ODc5MDYyOjcyZTZjZWIwNjI0YTkwYTliNjNiYWZjZTM3YzA0MTA0YzczOTFkNzk=","commit":{"author":{"name":"Francesco Chicchiriccò","email":"ilgrosso@apache.org","date":"2015-09-25T14:43:23Z"},"committer":{"name":"Francesco Chicchiriccò","email":"ilgrosso@apache.org","date":"2015-09-25T14:43:23Z"},"message":"[SYNCOPE-698] Implementation completed","tree":{"sha":"3cdea3c488afeaf306f6952082595a42cb08a962","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/git/trees/3cdea3c488afeaf306f6952082595a42cb08a962"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/git/commits/72e6ceb0624a90a9b63bafce37c04104c7391d79","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/72e6ceb0624a90a9b63bafce37c04104c7391d79","html_url":"https://github.com/EnricoDAlessandro97UNI/syncope/commit/72e6ceb0624a90a9b63bafce37c04104c7391d79","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/72e6ceb0624a90a9b63bafce37c04104c7391d79/comments","author":{"login":"ilgrosso","id":1064664,"node_id":"MDQ6VXNlcjEwNjQ2NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/1064664?v=4","gravatar_id":"","url":"https://api.github.com/users/ilgrosso","html_url":"https://github.com/ilgrosso","followers_url":"https://api.github.com/users/ilgrosso/followers","following_url":"https://api.github.com/users/ilgrosso/following{/other_user}","gists_url":"https://api.github.com/users/ilgrosso/gists{/gist_id}","starred_url":"https://api.github.com/users/ilgrosso/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ilgrosso/subscriptions","organizations_url":"https://api.github.com/users/ilgrosso/orgs","repos_url":"https://api.github.com/users/ilgrosso/repos","events_url":"https://api.github.com/users/ilgrosso/events{/privacy}","received_events_url":"https://api.github.com/users/ilgrosso/received_events","type":"User","site_admin":false},"committer":{"login":"ilgrosso","id":1064664,"node_id":"MDQ6VXNlcjEwNjQ2NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/1064664?v=4","gravatar_id":"","url":"https://api.github.com/users/ilgrosso","html_url":"https://github.com/ilgrosso","followers_url":"https://api.github.com/users/ilgrosso/followers","following_url":"https://api.github.com/users/ilgrosso/following{/other_user}","gists_url":"https://api.github.com/users/ilgrosso/gists{/gist_id}","starred_url":"https://api.github.com/users/ilgrosso/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ilgrosso/subscriptions","organizations_url":"https://api.github.com/users/ilgrosso/orgs","repos_url":"https://api.github.com/users/ilgrosso/repos","events_url":"https://api.github.com/users/ilgrosso/events{/privacy}","received_events_url":"https://api.github.com/users/ilgrosso/received_events","type":"User","site_admin":false},"parents":[{"sha":"5537d29e9dc96990113b4333ae95c332218018cd","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/5537d29e9dc96990113b4333ae95c332218018cd","html_url":"https://github.com/EnricoDAlessandro97UNI/syncope/commit/5537d29e9dc96990113b4333ae95c332218018cd"}],"stats":{"total":1306,"additions":824,"deletions":482},"files":[{"sha":"b838f6e4be69e179a5740e4fc277c81825907290","filename":"common/lib/src/main/java/org/apache/syncope/common/lib/to/MappingItemTO.java","status":"modified","additions":10,"deletions":1,"changes":11,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/72e6ceb0624a90a9b63bafce37c04104c7391d79/common%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FMappingItemTO.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/72e6ceb0624a90a9b63bafce37c04104c7391d79/common%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FMappingItemTO.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/common%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FMappingItemTO.java?ref=72e6ceb0624a90a9b63bafce37c04104c7391d79","patch":"@@ -18,6 +18,8 @@\n  */\n package org.apache.syncope.common.lib.to;\n \n+import java.util.ArrayList;\n+import java.util.List;\n import javax.xml.bind.annotation.XmlRootElement;\n import javax.xml.bind.annotation.XmlType;\n import org.apache.syncope.common.lib.AbstractBaseBean;\n@@ -64,10 +66,12 @@ public class MappingItemTO extends AbstractBaseBean {\n     private String mandatoryCondition = \"false\";\n \n     /**\n-     * Mapping purposes: SYNCHRONIZATION, PROPAGATION, BOTH, NONE.\n+     * Mapping purposes.\n      */\n     private MappingPurpose purpose;\n \n+    private final List<String> mappingItemTransformerClassNames = new ArrayList<>();\n+\n     public boolean isConnObjectKey() {\n         return connObjectKey;\n     }\n@@ -131,4 +135,9 @@ public MappingPurpose getPurpose() {\n     public void setPurpose(final MappingPurpose purpose) {\n         this.purpose = purpose;\n     }\n+\n+    public List<String> getMappingItemTransformerClassNames() {\n+        return mappingItemTransformerClassNames;\n+    }\n+\n }"},{"sha":"f65badca990e7b7d9faf94b4b846f167bd647285","filename":"common/lib/src/main/java/org/apache/syncope/common/lib/to/SyncopeTO.java","status":"modified","additions":9,"deletions":0,"changes":9,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/72e6ceb0624a90a9b63bafce37c04104c7391d79/common%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FSyncopeTO.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/72e6ceb0624a90a9b63bafce37c04104c7391d79/common%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FSyncopeTO.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/common%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FSyncopeTO.java?ref=72e6ceb0624a90a9b63bafce37c04104c7391d79","patch":"@@ -65,6 +65,8 @@ public class SyncopeTO extends AbstractBaseBean {\n \n     private final List<String> passwordRules = new ArrayList<>();\n \n+    private final List<String> mappingItemTransformers = new ArrayList<>();\n+\n     private final List<String> taskJobs = new ArrayList<>();\n \n     private final List<String> logicActions = new ArrayList<>();\n@@ -163,6 +165,13 @@ public List<String> getPasswordRules() {\n         return passwordRules;\n     }\n \n+    @XmlElementWrapper(name = \"mappingItemTransformers\")\n+    @XmlElement(name = \"mappingItemTransformer\")\n+    @JsonProperty(\"mappingItemTransformers\")\n+    public List<String> getMappingItemTransformers() {\n+        return mappingItemTransformers;\n+    }\n+\n     @XmlElementWrapper(name = \"taskJobs\")\n     @XmlElement(name = \"taskJob\")\n     @JsonProperty(\"taskJobs\")"},{"sha":"c3ce0c696be55e51284f194b74e0dfdee1531a14","filename":"core/logic/src/main/java/org/apache/syncope/core/logic/ResourceLogic.java","status":"modified","additions":5,"deletions":3,"changes":8,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/72e6ceb0624a90a9b63bafce37c04104c7391d79/core%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Flogic%2FResourceLogic.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/72e6ceb0624a90a9b63bafce37c04104c7391d79/core%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Flogic%2FResourceLogic.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Flogic%2FResourceLogic.java?ref=72e6ceb0624a90a9b63bafce37c04104c7391d79","patch":"@@ -36,7 +36,6 @@\n import org.apache.syncope.common.lib.types.AnyTypeKind;\n import org.apache.syncope.common.lib.types.ClientExceptionType;\n import org.apache.syncope.common.lib.types.Entitlement;\n-import org.apache.syncope.common.lib.types.MappingPurpose;\n import org.apache.syncope.core.persistence.api.dao.DuplicateException;\n import org.apache.syncope.core.persistence.api.dao.ExternalResourceDAO;\n import org.apache.syncope.core.persistence.api.dao.NotFoundException;\n@@ -92,6 +91,9 @@ public class ResourceLogic extends AbstractTransactionalLogic<ResourceTO> {\n     @Autowired\n     private ConnObjectUtils connObjectUtils;\n \n+    @Autowired\n+    private MappingUtils mappingUtils;\n+\n     @Autowired\n     private ConnectorFactory connFactory;\n \n@@ -216,13 +218,13 @@ public ConnObjectTO readConnObject(final String key, final String anyTypeKey, fi\n             throw new NotFoundException(\n                     \"ConnObjectKey mapping for \" + init.getMiddle() + \" \" + anyKey + \" on resource '\" + key + \"'\");\n         }\n-        String connObjectKeyValue = MappingUtils.getConnObjectKeyValue(any, init.getRight());\n+        String connObjectKeyValue = mappingUtils.getConnObjectKeyValue(any, init.getRight());\n \n         Connector connector = connFactory.getConnector(init.getLeft());\n         ConnectorObject connectorObject = connector.getObject(\n                 init.getRight().getObjectClass(),\n                 new Uid(connObjectKeyValue),\n-                connector.getOperationOptions(MappingUtils.getMappingItems(init.getRight(), MappingPurpose.BOTH)));\n+                connector.getOperationOptions(MappingUtils.getBothMappingItems(init.getRight())));\n         if (connectorObject == null) {\n             throw new NotFoundException(\n                     \"Object \" + connObjectKeyValue + \" with class \" + init.getRight().getObjectClass()"},{"sha":"480efc159335b9300ddf8dfd9e443f465a798732","filename":"core/logic/src/main/java/org/apache/syncope/core/logic/SyncopeLogic.java","status":"modified","additions":13,"deletions":12,"changes":25,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/72e6ceb0624a90a9b63bafce37c04104c7391d79/core%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Flogic%2FSyncopeLogic.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/72e6ceb0624a90a9b63bafce37c04104c7391d79/core%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Flogic%2FSyncopeLogic.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Flogic%2FSyncopeLogic.java?ref=72e6ceb0624a90a9b63bafce37c04104c7391d79","patch":"@@ -82,7 +82,7 @@ public class SyncopeLogic extends AbstractLogic<SyncopeTO> {\n     private PasswordGenerator passwordGenerator;\n \n     @Autowired\n-    private ImplementationLookup implementationLookup;\n+    private ImplementationLookup implLookup;\n \n     @Resource(name = \"velocityResourceLoader\")\n     private ResourceWithFallbackLoader resourceLoader;\n@@ -128,17 +128,18 @@ public SyncopeTO info() {\n         syncopeTO.setVirAttrCache(virAttrCache.getClass().getName());\n         syncopeTO.setPasswordGenerator(passwordGenerator.getClass().getName());\n \n-        syncopeTO.getReportlets().addAll(implementationLookup.getClassNames(Type.REPORTLET));\n-        syncopeTO.getAccountRules().addAll(implementationLookup.getClassNames(Type.ACCOUNT_RULE));\n-        syncopeTO.getPasswordRules().addAll(implementationLookup.getClassNames(Type.PASSWORD_RULE));\n-        syncopeTO.getTaskJobs().addAll(implementationLookup.getClassNames(Type.TASKJOBDELEGATE));\n-        syncopeTO.getLogicActions().addAll(implementationLookup.getClassNames(Type.LOGIC_ACTIONS));\n-        syncopeTO.getPropagationActions().addAll(implementationLookup.getClassNames(Type.PROPAGATION_ACTIONS));\n-        syncopeTO.getSyncActions().addAll(implementationLookup.getClassNames(Type.SYNC_ACTIONS));\n-        syncopeTO.getPushActions().addAll(implementationLookup.getClassNames(Type.PUSH_ACTIONS));\n-        syncopeTO.getSyncCorrelationRules().addAll(implementationLookup.getClassNames(Type.SYNC_CORRELATION_RULE));\n-        syncopeTO.getPushCorrelationRules().addAll(implementationLookup.getClassNames(Type.PUSH_CORRELATION_RULE));\n-        syncopeTO.getValidators().addAll(implementationLookup.getClassNames(Type.VALIDATOR));\n+        syncopeTO.getReportlets().addAll(implLookup.getClassNames(Type.REPORTLET));\n+        syncopeTO.getAccountRules().addAll(implLookup.getClassNames(Type.ACCOUNT_RULE));\n+        syncopeTO.getPasswordRules().addAll(implLookup.getClassNames(Type.PASSWORD_RULE));\n+        syncopeTO.getMappingItemTransformers().addAll(implLookup.getClassNames(Type.MAPPING_ITEM_TRANSFORMER));\n+        syncopeTO.getTaskJobs().addAll(implLookup.getClassNames(Type.TASKJOBDELEGATE));\n+        syncopeTO.getLogicActions().addAll(implLookup.getClassNames(Type.LOGIC_ACTIONS));\n+        syncopeTO.getPropagationActions().addAll(implLookup.getClassNames(Type.PROPAGATION_ACTIONS));\n+        syncopeTO.getSyncActions().addAll(implLookup.getClassNames(Type.SYNC_ACTIONS));\n+        syncopeTO.getPushActions().addAll(implLookup.getClassNames(Type.PUSH_ACTIONS));\n+        syncopeTO.getSyncCorrelationRules().addAll(implLookup.getClassNames(Type.SYNC_CORRELATION_RULE));\n+        syncopeTO.getPushCorrelationRules().addAll(implLookup.getClassNames(Type.PUSH_CORRELATION_RULE));\n+        syncopeTO.getValidators().addAll(implLookup.getClassNames(Type.VALIDATOR));\n \n         Set<String> htmlTemplates = new HashSet<>();\n         Set<String> textTemplates = new HashSet<>();"},{"sha":"5147a392cf0b82811961066cfebf5ffbce792f03","filename":"core/logic/src/main/java/org/apache/syncope/core/logic/init/ClassPathScanImplementationLookup.java","status":"modified","additions":6,"deletions":0,"changes":6,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/72e6ceb0624a90a9b63bafce37c04104c7391d79/core%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Flogic%2Finit%2FClassPathScanImplementationLookup.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/72e6ceb0624a90a9b63bafce37c04104c7391d79/core%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Flogic%2Finit%2FClassPathScanImplementationLookup.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Flogic%2Finit%2FClassPathScanImplementationLookup.java?ref=72e6ceb0624a90a9b63bafce37c04104c7391d79","patch":"@@ -38,6 +38,7 @@\n import org.apache.syncope.core.persistence.api.dao.PasswordRule;\n import org.apache.syncope.core.persistence.api.dao.PasswordRuleConfClass;\n import org.apache.syncope.core.provisioning.api.LogicActions;\n+import org.apache.syncope.core.provisioning.api.data.MappingItemTransformer;\n import org.apache.syncope.core.provisioning.api.job.SchedTaskJobDelegate;\n import org.apache.syncope.core.provisioning.api.propagation.PropagationActions;\n import org.apache.syncope.core.provisioning.api.sync.PushActions;\n@@ -90,6 +91,7 @@ public void load() {\n         scanner.addIncludeFilter(new AssignableTypeFilter(Reportlet.class));\n         scanner.addIncludeFilter(new AssignableTypeFilter(AccountRule.class));\n         scanner.addIncludeFilter(new AssignableTypeFilter(PasswordRule.class));\n+        scanner.addIncludeFilter(new AssignableTypeFilter(MappingItemTransformer.class));\n         scanner.addIncludeFilter(new AssignableTypeFilter(SchedTaskJobDelegate.class));\n         scanner.addIncludeFilter(new AssignableTypeFilter(LogicActions.class));\n         scanner.addIncludeFilter(new AssignableTypeFilter(PropagationActions.class));\n@@ -131,6 +133,10 @@ public void load() {\n                     }\n                 }\n \n+                if (MappingItemTransformer.class.isAssignableFrom(clazz) && !isAbsractClazz) {\n+                    classNames.get(Type.MAPPING_ITEM_TRANSFORMER).add(clazz.getName());\n+                }\n+\n                 if (SchedTaskJobDelegate.class.isAssignableFrom(clazz) && !isAbsractClazz\n                         && !SyncJobDelegate.class.isAssignableFrom(clazz)\n                         && !PushJobDelegate.class.isAssignableFrom(clazz)) {"},{"sha":"f78cc3163310c2d4b84146e36df2e877af4b2b56","filename":"core/misc/src/main/java/org/apache/syncope/core/misc/ConnObjectUtils.java","status":"modified","additions":41,"deletions":191,"changes":232,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/72e6ceb0624a90a9b63bafce37c04104c7391d79/core%2Fmisc%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fmisc%2FConnObjectUtils.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/72e6ceb0624a90a9b63bafce37c04104c7391d79/core%2Fmisc%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fmisc%2FConnObjectUtils.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fmisc%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fmisc%2FConnObjectUtils.java?ref=72e6ceb0624a90a9b63bafce37c04104c7391d79","patch":"@@ -21,11 +21,7 @@\n import org.apache.syncope.core.misc.policy.InvalidPasswordRuleConf;\n import org.apache.syncope.core.misc.security.SecureRandomUtils;\n import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.Collections;\n-import java.util.HashMap;\n import java.util.List;\n-import java.util.Map;\n import org.apache.commons.lang3.StringUtils;\n import org.apache.syncope.common.lib.AnyOperations;\n import org.apache.syncope.common.lib.patch.AnyPatch;\n@@ -37,17 +33,11 @@\n import org.apache.syncope.common.lib.to.GroupTO;\n import org.apache.syncope.common.lib.to.UserTO;\n import org.apache.syncope.common.lib.types.AnyTypeKind;\n-import org.apache.syncope.common.lib.types.AttrSchemaType;\n-import org.apache.syncope.common.lib.types.MappingPurpose;\n-import org.apache.syncope.core.persistence.api.attrvalue.validation.ParsingValidationException;\n import org.apache.syncope.core.persistence.api.dao.ExternalResourceDAO;\n-import org.apache.syncope.core.persistence.api.dao.PlainSchemaDAO;\n import org.apache.syncope.core.persistence.api.dao.UserDAO;\n import org.apache.syncope.core.persistence.api.entity.AnyUtils;\n import org.apache.syncope.core.persistence.api.entity.resource.ExternalResource;\n import org.apache.syncope.core.persistence.api.entity.resource.MappingItem;\n-import org.apache.syncope.core.persistence.api.entity.PlainAttrValue;\n-import org.apache.syncope.core.persistence.api.entity.PlainSchema;\n import org.apache.syncope.core.persistence.api.entity.task.SyncTask;\n import org.apache.syncope.core.persistence.api.entity.user.User;\n import org.apache.syncope.core.misc.security.Encryptor;\n@@ -71,6 +61,8 @@ public class ConnObjectUtils {\n \n     private static final Logger LOG = LoggerFactory.getLogger(ConnObjectUtils.class);\n \n+    private static final Encryptor ENCRYPTOR = Encryptor.getInstance();\n+\n     @Autowired\n     private TemplateUtils templateUtils;\n \n@@ -84,12 +76,44 @@ public class ConnObjectUtils {\n     private ExternalResourceDAO resourceDAO;\n \n     @Autowired\n-    private PlainSchemaDAO plainSchemaDAO;\n+    private PasswordGenerator passwordGenerator;\n \n     @Autowired\n-    private PasswordGenerator pwdGen;\n+    private MappingUtils mappingUtils;\n+\n+    /**\n+     * Extract password value from passed value (if instance of GuardedString or GuardedByteArray).\n+     *\n+     * @param pwd received from the underlying connector\n+     * @return password value\n+     */\n+    public static String getPassword(final Object pwd) {\n+        final StringBuilder result = new StringBuilder();\n+\n+        if (pwd instanceof GuardedString) {\n+            ((GuardedString) pwd).access(new GuardedString.Accessor() {\n+\n+                @Override\n+                public void access(final char[] clearChars) {\n+                    result.append(clearChars);\n+                }\n+            });\n+        } else if (pwd instanceof GuardedByteArray) {\n+            ((GuardedByteArray) pwd).access(new GuardedByteArray.Accessor() {\n+\n+                @Override\n+                public void access(final byte[] clearBytes) {\n+                    result.append(new String(clearBytes));\n+                }\n+            });\n+        } else if (pwd instanceof String) {\n+            result.append((String) pwd);\n+        } else {\n+            result.append(pwd.toString());\n+        }\n \n-    private final Encryptor encryptor = Encryptor.getInstance();\n+        return result.toString();\n+    }\n \n     /**\n      * Build a UserTO / GroupTO / AnyObjectTO out of connector object attributes and schema mapping.\n@@ -131,7 +155,7 @@ public <T extends AnyTO> T getAnyTO(\n \n             String password;\n             try {\n-                password = pwdGen.generate(ruleConfs);\n+                password = passwordGenerator.generate(ruleConfs);\n             } catch (InvalidPasswordRuleConf e) {\n                 LOG.error(\"Could not generate policy-compliant random password for {}\", userTO, e);\n \n@@ -167,7 +191,7 @@ public <T extends AnyPatch> T getAnyPatch(final Long key, final ConnectorObject\n             // update password if and only if password is really changed\n             User user = userDAO.authFind(key);\n             if (StringUtils.isBlank(((UserTO) updated).getPassword())\n-                    || encryptor.verify(((UserTO) updated).getPassword(),\n+                    || ENCRYPTOR.verify(((UserTO) updated).getPassword(),\n                             user.getCipherAlgorithm(), user.getPassword())) {\n \n                 ((UserTO) updated).setPassword(null);\n@@ -190,127 +214,8 @@ private <T extends AnyTO> T getAnyTOFromConnObject(final ConnectorObject obj,\n \n         // 1. fill with data from connector object\n         anyTO.setRealm(syncTask.getDestinatioRealm().getFullPath());\n-        for (MappingItem item : MappingUtils.getMappingItems(provision, MappingPurpose.SYNCHRONIZATION)) {\n-            Attribute attr = obj.getAttributeByName(item.getExtAttrName());\n-\n-            AttrTO attrTO;\n-            switch (item.getIntMappingType()) {\n-                case UserKey:\n-                case GroupKey:\n-                case AnyObjectKey:\n-                    break;\n-\n-                case Password:\n-                    if (anyTO instanceof UserTO && attr != null && attr.getValue() != null\n-                            && !attr.getValue().isEmpty()) {\n-\n-                        ((UserTO) anyTO).setPassword(getPassword(attr.getValue().get(0)));\n-                    }\n-                    break;\n-\n-                case Username:\n-                    if (anyTO instanceof UserTO) {\n-                        ((UserTO) anyTO).setUsername(attr == null || attr.getValue().isEmpty()\n-                                || attr.getValue().get(0) == null\n-                                        ? null\n-                                        : attr.getValue().get(0).toString());\n-                    }\n-                    break;\n-\n-                case GroupName:\n-                    if (anyTO instanceof GroupTO) {\n-                        ((GroupTO) anyTO).setName(attr == null || attr.getValue().isEmpty()\n-                                || attr.getValue().get(0) == null\n-                                        ? null\n-                                        : attr.getValue().get(0).toString());\n-                    }\n-                    break;\n-\n-                case GroupOwnerSchema:\n-                    if (anyTO instanceof GroupTO && attr != null) {\n-                        // using a special attribute (with schema \"\", that will be ignored) for carrying the\n-                        // GroupOwnerSchema value\n-                        attrTO = new AttrTO();\n-                        attrTO.setSchema(StringUtils.EMPTY);\n-                        if (attr.getValue().isEmpty() || attr.getValue().get(0) == null) {\n-                            attrTO.getValues().add(StringUtils.EMPTY);\n-                        } else {\n-                            attrTO.getValues().add(attr.getValue().get(0).toString());\n-                        }\n-\n-                        ((GroupTO) anyTO).getPlainAttrs().add(attrTO);\n-                    }\n-                    break;\n-\n-                case UserPlainSchema:\n-                case GroupPlainSchema:\n-                case AnyObjectPlainSchema:\n-                    attrTO = new AttrTO();\n-                    attrTO.setSchema(item.getIntAttrName());\n-\n-                    PlainSchema schema = plainSchemaDAO.find(item.getIntAttrName());\n-\n-                    for (Object value : attr == null || attr.getValue() == null\n-                            ? Collections.emptyList()\n-                            : attr.getValue()) {\n-\n-                        AttrSchemaType schemaType = schema == null ? AttrSchemaType.String : schema.getType();\n-                        if (value != null) {\n-                            final PlainAttrValue attrValue = anyUtils.newPlainAttrValue();\n-                            switch (schemaType) {\n-                                case String:\n-                                    attrValue.setStringValue(value.toString());\n-                                    break;\n-\n-                                case Binary:\n-                                    attrValue.setBinaryValue((byte[]) value);\n-                                    break;\n-\n-                                default:\n-                                    try {\n-                                        attrValue.parseValue(schema, value.toString());\n-                                    } catch (ParsingValidationException e) {\n-                                        LOG.error(\"While parsing provided value {}\", value, e);\n-                                        attrValue.setStringValue(value.toString());\n-                                        schemaType = AttrSchemaType.String;\n-                                    }\n-                                    break;\n-                            }\n-                            attrTO.getValues().add(attrValue.getValueAsString(schemaType));\n-                        }\n-                    }\n-\n-                    anyTO.getPlainAttrs().add(attrTO);\n-                    break;\n-\n-                case UserDerivedSchema:\n-                case GroupDerivedSchema:\n-                case AnyObjectDerivedSchema:\n-                    attrTO = new AttrTO();\n-                    attrTO.setSchema(item.getIntAttrName());\n-                    anyTO.getDerAttrs().add(attrTO);\n-                    break;\n-\n-                case UserVirtualSchema:\n-                case GroupVirtualSchema:\n-                case AnyObjectVirtualSchema:\n-                    attrTO = new AttrTO();\n-                    attrTO.setSchema(item.getIntAttrName());\n-\n-                    for (Object value : attr == null || attr.getValue() == null\n-                            ? Collections.emptyList()\n-                            : attr.getValue()) {\n-\n-                        if (value != null) {\n-                            attrTO.getValues().add(value.toString());\n-                        }\n-                    }\n-\n-                    anyTO.getVirAttrs().add(attrTO);\n-                    break;\n-\n-                default:\n-            }\n+        for (MappingItem item : MappingUtils.getSyncMappingItems(provision)) {\n+            mappingUtils.setIntValues(item, obj.getAttributeByName(item.getExtAttrName()), anyTO, anyUtils);\n         }\n \n         // 2. add data from defined template (if any)\n@@ -319,40 +224,6 @@ private <T extends AnyTO> T getAnyTOFromConnObject(final ConnectorObject obj,\n         return anyTO;\n     }\n \n-    /**\n-     * Extract password value from passed value (if instance of GuardedString or GuardedByteArray).\n-     *\n-     * @param pwd received from the underlying connector\n-     * @return password value\n-     */\n-    public String getPassword(final Object pwd) {\n-        final StringBuilder result = new StringBuilder();\n-\n-        if (pwd instanceof GuardedString) {\n-            ((GuardedString) pwd).access(new GuardedString.Accessor() {\n-\n-                @Override\n-                public void access(final char[] clearChars) {\n-                    result.append(clearChars);\n-                }\n-            });\n-        } else if (pwd instanceof GuardedByteArray) {\n-            ((GuardedByteArray) pwd).access(new GuardedByteArray.Accessor() {\n-\n-                @Override\n-                public void access(final byte[] clearBytes) {\n-                    result.append(new String(clearBytes));\n-                }\n-            });\n-        } else if (pwd instanceof String) {\n-            result.append((String) pwd);\n-        } else {\n-            result.append(pwd.toString());\n-        }\n-\n-        return result.toString();\n-    }\n-\n     /**\n      * Get connector object TO from a connector object.\n      *\n@@ -385,25 +256,4 @@ public ConnObjectTO getConnObjectTO(final ConnectorObject connObject) {\n \n         return connObjectTO;\n     }\n-\n-    /**\n-     * Transform a\n-     * <code>Collection</code> of {@link Attribute} instances into a {@link Map}. The key to each element in the map is\n-     * the <i>name</i> of an\n-     * <code>Attribute</code>. The value of each element in the map is the\n-     * <code>Attribute</code> instance with that name. <br/> Different from the original because: <ul> <li>map keys are\n-     * transformed toUpperCase()</li> <li>returned map is mutable</li> </ul>\n-     *\n-     * @param attributes set of attribute to transform to a map.\n-     * @return a map of string and attribute.\n-     *\n-     * @see org.identityconnectors.framework.common.objects.AttributeUtil#toMap(java.util.Collection)\n-     */\n-    public Map<String, Attribute> toMap(final Collection<? extends Attribute> attributes) {\n-        final Map<String, Attribute> map = new HashMap<>();\n-        for (Attribute attr : attributes) {\n-            map.put(attr.getName().toUpperCase(), attr);\n-        }\n-        return map;\n-    }\n }"},{"sha":"085f07d9549c2a9c11c00d8264a1e6718d72b8f8","filename":"core/misc/src/main/java/org/apache/syncope/core/misc/MappingUtils.java","status":"modified","additions":352,"deletions":149,"changes":501,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/72e6ceb0624a90a9b63bafce37c04104c7391d79/core%2Fmisc%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fmisc%2FMappingUtils.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/72e6ceb0624a90a9b63bafce37c04104c7391d79/core%2Fmisc%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fmisc%2FMappingUtils.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fmisc%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fmisc%2FMappingUtils.java?ref=72e6ceb0624a90a9b63bafce37c04104c7391d79","patch":"@@ -18,7 +18,6 @@\n  */\n package org.apache.syncope.core.misc;\n \n-import org.apache.syncope.core.misc.policy.InvalidPasswordRuleConf;\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n@@ -27,16 +26,24 @@\n import java.util.Map;\n import java.util.Set;\n import org.apache.commons.collections4.CollectionUtils;\n+import org.apache.commons.collections4.ListUtils;\n import org.apache.commons.collections4.Predicate;\n import org.apache.commons.jexl2.JexlContext;\n import org.apache.commons.jexl2.MapContext;\n+import org.apache.commons.lang3.ClassUtils;\n+import org.apache.commons.lang3.SerializationUtils;\n import org.apache.commons.lang3.StringUtils;\n import org.apache.commons.lang3.tuple.ImmutablePair;\n import org.apache.commons.lang3.tuple.Pair;\n import org.apache.syncope.common.lib.patch.AttrPatch;\n+import org.apache.syncope.common.lib.to.AnyTO;\n+import org.apache.syncope.common.lib.to.AttrTO;\n+import org.apache.syncope.common.lib.to.GroupTO;\n+import org.apache.syncope.common.lib.to.UserTO;\n import org.apache.syncope.common.lib.types.AttrSchemaType;\n import org.apache.syncope.common.lib.types.IntMappingType;\n import org.apache.syncope.common.lib.types.MappingPurpose;\n+import org.apache.syncope.core.misc.policy.InvalidPasswordRuleConf;\n import org.apache.syncope.core.persistence.api.dao.PlainSchemaDAO;\n import org.apache.syncope.core.persistence.api.dao.VirSchemaDAO;\n import org.apache.syncope.core.persistence.api.entity.AnyUtils;\n@@ -53,17 +60,21 @@\n import org.apache.syncope.core.persistence.api.entity.user.User;\n import org.apache.syncope.core.provisioning.api.cache.VirAttrCache;\n import org.apache.syncope.core.misc.security.Encryptor;\n-import org.apache.syncope.core.misc.spring.ApplicationContextProvider;\n import org.apache.syncope.core.misc.jexl.JexlUtils;\n import org.apache.syncope.core.misc.security.PasswordGenerator;\n+import org.apache.syncope.core.misc.spring.ApplicationContextProvider;\n+import org.apache.syncope.core.persistence.api.attrvalue.validation.ParsingValidationException;\n import org.apache.syncope.core.persistence.api.dao.AnyTypeDAO;\n import org.apache.syncope.core.persistence.api.dao.UserDAO;\n import org.apache.syncope.core.persistence.api.entity.Any;\n+import org.apache.syncope.core.persistence.api.entity.PlainAttrUniqueValue;\n+import org.apache.syncope.core.persistence.api.entity.PlainSchema;\n import org.apache.syncope.core.persistence.api.entity.Schema;\n import org.apache.syncope.core.persistence.api.entity.anyobject.AnyObject;\n import org.apache.syncope.core.persistence.api.entity.resource.Mapping;\n import org.apache.syncope.core.persistence.api.entity.resource.Provision;\n import org.apache.syncope.core.provisioning.api.VirAttrHandler;\n+import org.apache.syncope.core.provisioning.api.data.MappingItemTransformer;\n import org.identityconnectors.framework.common.FrameworkUtil;\n import org.identityconnectors.framework.common.objects.Attribute;\n import org.identityconnectors.framework.common.objects.AttributeBuilder;\n@@ -72,14 +83,45 @@\n import org.identityconnectors.framework.common.objects.OperationalAttributes;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n-import org.springframework.beans.factory.support.DefaultListableBeanFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.support.AbstractBeanDefinition;\n+import org.springframework.stereotype.Component;\n+import org.springframework.transaction.annotation.Transactional;\n \n-public final class MappingUtils {\n+@Component\n+public class MappingUtils {\n \n     private static final Logger LOG = LoggerFactory.getLogger(MappingUtils.class);\n \n     private static final Encryptor ENCRYPTOR = Encryptor.getInstance();\n \n+    @Autowired\n+    private UserDAO userDAO;\n+\n+    @Autowired\n+    private AnyTypeDAO anyTypeDAO;\n+\n+    @Autowired\n+    private PlainSchemaDAO plainSchemaDAO;\n+\n+    @Autowired\n+    private VirSchemaDAO virSchemaDAO;\n+\n+    @Autowired\n+    private VirAttrHandler virAttrHandler;\n+\n+    @Autowired\n+    private VirAttrCache virAttrCache;\n+\n+    @Autowired\n+    private PasswordGenerator passwordGenerator;\n+\n+    @Autowired\n+    private EntityFactory entityFactory;\n+\n+    @Autowired\n+    private AnyUtilsFactory anyUtilsFactory;\n+\n     public static <T extends MappingItem> Collection<T> getMatchingMappingItems(\n             final Collection<T> items, final IntMappingType type) {\n \n@@ -116,6 +158,144 @@ public boolean evaluate(final T item) {\n         });\n     }\n \n+    public static MappingItem getConnObjectKeyItem(final Provision provision) {\n+        Mapping mapping = null;\n+        if (provision != null) {\n+            mapping = provision.getMapping();\n+        }\n+\n+        return mapping == null\n+                ? null\n+                : mapping.getConnObjectKeyItem();\n+    }\n+\n+    private static List<MappingItem> getMappingItems(final Provision provision, final MappingPurpose purpose) {\n+        List<? extends MappingItem> items = Collections.<MappingItem>emptyList();\n+        if (provision != null) {\n+            items = provision.getMapping().getItems();\n+        }\n+\n+        List<MappingItem> result = new ArrayList<>();\n+\n+        switch (purpose) {\n+            case SYNCHRONIZATION:\n+                for (MappingItem item : items) {\n+                    if (MappingPurpose.PROPAGATION != item.getPurpose()\n+                            && MappingPurpose.NONE != item.getPurpose()) {\n+\n+                        result.add(item);\n+                    }\n+                }\n+                break;\n+\n+            case PROPAGATION:\n+                for (MappingItem item : items) {\n+                    if (MappingPurpose.SYNCHRONIZATION != item.getPurpose()\n+                            && MappingPurpose.NONE != item.getPurpose()) {\n+\n+                        result.add(item);\n+                    }\n+                }\n+                break;\n+\n+            case BOTH:\n+                for (MappingItem item : items) {\n+                    if (MappingPurpose.NONE != item.getPurpose()) {\n+                        result.add(item);\n+                    }\n+                }\n+                break;\n+\n+            case NONE:\n+                for (MappingItem item : items) {\n+                    if (MappingPurpose.NONE == item.getPurpose()) {\n+                        result.add(item);\n+                    }\n+                }\n+                break;\n+\n+            default:\n+        }\n+\n+        return result;\n+    }\n+\n+    public static List<MappingItem> getBothMappingItems(final Provision provision) {\n+        return getMappingItems(provision, MappingPurpose.BOTH);\n+    }\n+\n+    public static List<MappingItem> getPropagationMappingItems(final Provision provision) {\n+        return getMappingItems(provision, MappingPurpose.PROPAGATION);\n+    }\n+\n+    public static List<MappingItem> getSyncMappingItems(final Provision provision) {\n+        return getMappingItems(provision, MappingPurpose.SYNCHRONIZATION);\n+    }\n+\n+    /**\n+     * Build __NAME__ for propagation. First look if there ia a defined connObjectLink for the given resource (and in\n+     * this case evaluate as JEXL); otherwise, take given connObjectKey.\n+     *\n+     * @param any given any object\n+     * @param provision external resource\n+     * @param connObjectKey connector object key\n+     * @return the value to be propagated as __NAME__\n+     */\n+    public static Name evaluateNAME(final Any<?, ?, ?> any, final Provision provision, final String connObjectKey) {\n+        if (StringUtils.isBlank(connObjectKey)) {\n+            // LOG error but avoid to throw exception: leave it to the external resource\n+            LOG.error(\"Missing ConnObjectKey for '{}': \", provision.getResource());\n+        }\n+\n+        // Evaluate connObjectKey expression\n+        String connObjectLink = provision == null || provision.getMapping() == null\n+                ? null\n+                : provision.getMapping().getConnObjectLink();\n+        String evalConnObjectLink = null;\n+        if (StringUtils.isNotBlank(connObjectLink)) {\n+            JexlContext jexlContext = new MapContext();\n+            JexlUtils.addFieldsToContext(any, jexlContext);\n+            JexlUtils.addPlainAttrsToContext(any.getPlainAttrs(), jexlContext);\n+            JexlUtils.addDerAttrsToContext(any.getDerAttrs(), any.getPlainAttrs(), jexlContext);\n+            evalConnObjectLink = JexlUtils.evaluate(connObjectLink, jexlContext);\n+        }\n+\n+        // If connObjectLink evaluates to an empty string, just use the provided connObjectKey as Name(),\n+        // otherwise evaluated connObjectLink expression is taken as Name().\n+        Name name;\n+        if (StringUtils.isBlank(evalConnObjectLink)) {\n+            // add connObjectKey as __NAME__ attribute ...\n+            LOG.debug(\"Add connObjectKey [{}] as __NAME__\", connObjectKey);\n+            name = new Name(connObjectKey);\n+        } else {\n+            LOG.debug(\"Add connObjectLink [{}] as __NAME__\", evalConnObjectLink);\n+            name = new Name(evalConnObjectLink);\n+\n+            // connObjectKey not propagated: it will be used to set the value for __UID__ attribute\n+            LOG.debug(\"connObjectKey will be used just as __UID__ attribute\");\n+        }\n+\n+        return name;\n+    }\n+\n+    public static List<MappingItemTransformer> getMappingItemTransformers(final MappingItem mappingItem) {\n+        List<MappingItemTransformer> result = new ArrayList<>();\n+\n+        for (String className : mappingItem.getMappingItemTransformerClassNames()) {\n+            try {\n+                Class<?> transformerClass = ClassUtils.getClass(className);\n+\n+                result.add((MappingItemTransformer) ApplicationContextProvider.\n+                        getBeanFactory().\n+                        createBean(transformerClass, AbstractBeanDefinition.AUTOWIRE_BY_NAME, false));\n+            } catch (Exception e) {\n+                LOG.error(\"Could not instantiate {}, ignoring...\", className, e);\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n     /**\n      * Prepare attributes for sending to a connector instance.\n      *\n@@ -127,7 +307,8 @@ public boolean evaluate(final T item) {\n      * @param provision provision information\n      * @return connObjectLink + prepared attributes\n      */\n-    public static Pair<String, Set<Attribute>> prepareAttrs(\n+    @Transactional(readOnly = true)\n+    public Pair<String, Set<Attribute>> prepareAttrs(\n             final Any<?, ?, ?> any,\n             final String password,\n             final boolean changePwd,\n@@ -138,10 +319,6 @@ public static Pair<String, Set<Attribute>> prepareAttrs(\n         LOG.debug(\"Preparing resource attributes for {} with provision {} for attributes {}\",\n                 any, provision, any.getPlainAttrs());\n \n-        DefaultListableBeanFactory beanFactory = ApplicationContextProvider.getBeanFactory();\n-        VirAttrCache virAttrCache = beanFactory.getBean(VirAttrCache.class);\n-        PasswordGenerator passwordGenerator = beanFactory.getBean(PasswordGenerator.class);\n-\n         Set<Attribute> attributes = new HashSet<>();\n         String connObjectKey = null;\n \n@@ -157,8 +334,7 @@ public static Pair<String, Set<Attribute>> prepareAttrs(\n                     virAttrCache.expire(any.getType().getKey(), any.getKey(), mapping.getIntAttrName());\n                 }\n \n-                Pair<String, Attribute> preparedAttr = prepareAttr(\n-                        provision, mapping, any, password, passwordGenerator, vAttrs);\n+                Pair<String, Attribute> preparedAttr = prepareAttr(provision, mapping, any, password, vAttrs);\n \n                 if (preparedAttr != null && preparedAttr.getKey() != null) {\n                     connObjectKey = preparedAttr.getKey();\n@@ -211,22 +387,16 @@ public static Pair<String, Set<Attribute>> prepareAttrs(\n      * @param mapItem mapping item for the given attribute\n      * @param any any object\n      * @param password clear-text password\n-     * @param passwordGenerator password generator\n      * @param vAttrs virtual attributes to be managed\n      * @return connObjectLink + prepared attribute\n      */\n-    @SuppressWarnings(\"unchecked\")\n-    private static Pair<String, Attribute> prepareAttr(\n+    private Pair<String, Attribute> prepareAttr(\n             final Provision provision, final MappingItem mapItem,\n-            final Any<?, ?, ?> any, final String password, final PasswordGenerator passwordGenerator,\n+            final Any<?, ?, ?> any, final String password,\n             final Map<String, AttrPatch> vAttrs) {\n \n         List<Any<?, ?, ?>> anys = new ArrayList<>();\n \n-        DefaultListableBeanFactory beanFactory = ApplicationContextProvider.getBeanFactory();\n-        AnyUtilsFactory anyUtilsFactory = beanFactory.getBean(AnyUtilsFactory.class);\n-        VirAttrHandler virAttrHandler = beanFactory.getBean(VirAttrHandler.class);\n-\n         switch (mapItem.getIntMappingType().getAnyTypeKind()) {\n             case USER:\n                 if (any instanceof User) {\n@@ -236,7 +406,6 @@ private static Pair<String, Attribute> prepareAttr(\n \n             case GROUP:\n                 if (any instanceof User) {\n-                    UserDAO userDAO = beanFactory.getBean(UserDAO.class);\n                     for (Group group : userDAO.findAllGroups((User) any)) {\n                         virAttrHandler.retrieveVirAttrValues(group);\n                         anys.add(group);\n@@ -266,15 +435,13 @@ private static Pair<String, Attribute> prepareAttr(\n             case UserPlainSchema:\n             case GroupPlainSchema:\n             case AnyObjectPlainSchema:\n-                PlainSchemaDAO plainSchemaDAO = beanFactory.getBean(PlainSchemaDAO.class);\n                 schema = plainSchemaDAO.find(mapItem.getIntAttrName());\n                 schemaType = schema == null ? AttrSchemaType.String : schema.getType();\n                 break;\n \n             case UserVirtualSchema:\n             case GroupVirtualSchema:\n             case AnyObjectVirtualSchema:\n-                VirSchemaDAO virSchemaDAO = beanFactory.getBean(VirSchemaDAO.class);\n                 schema = virSchemaDAO.find(mapItem.getIntAttrName());\n                 readOnlyVirSchema = (schema != null && schema.isReadonly());\n                 schemaType = AttrSchemaType.String;\n@@ -357,81 +524,32 @@ private static Pair<String, Attribute> prepareAttr(\n         return result;\n     }\n \n-    /**\n-     * Build __NAME__ for propagation. First look if there ia a defined connObjectLink for the given resource (and in\n-     * this case evaluate as JEXL); otherwise, take given connObjectKey.\n-     *\n-     * @param any given any object\n-     * @param provision external resource\n-     * @param connObjectKey connector object key\n-     * @return the value to be propagated as __NAME__\n-     */\n-    public static Name evaluateNAME(final Any<?, ?, ?> any, final Provision provision, final String connObjectKey) {\n-        if (StringUtils.isBlank(connObjectKey)) {\n-            // LOG error but avoid to throw exception: leave it to the external resource\n-            LOG.error(\"Missing ConnObjectKey for '{}': \", provision.getResource());\n-        }\n-\n-        // Evaluate connObjectKey expression\n-        String connObjectLink = provision == null || provision.getMapping() == null\n-                ? null\n-                : provision.getMapping().getConnObjectLink();\n-        String evalConnObjectLink = null;\n-        if (StringUtils.isNotBlank(connObjectLink)) {\n-            JexlContext jexlContext = new MapContext();\n-            JexlUtils.addFieldsToContext(any, jexlContext);\n-            JexlUtils.addPlainAttrsToContext(any.getPlainAttrs(), jexlContext);\n-            JexlUtils.addDerAttrsToContext(any.getDerAttrs(), any.getPlainAttrs(), jexlContext);\n-            evalConnObjectLink = JexlUtils.evaluate(connObjectLink, jexlContext);\n-        }\n-\n-        // If connObjectLink evaluates to an empty string, just use the provided connObjectKey as Name(),\n-        // otherwise evaluated connObjectLink expression is taken as Name().\n-        Name name;\n-        if (StringUtils.isBlank(evalConnObjectLink)) {\n-            // add connObjectKey as __NAME__ attribute ...\n-            LOG.debug(\"Add connObjectKey [{}] as __NAME__\", connObjectKey);\n-            name = new Name(connObjectKey);\n-        } else {\n-            LOG.debug(\"Add connObjectLink [{}] as __NAME__\", evalConnObjectLink);\n-            name = new Name(evalConnObjectLink);\n-\n-            // connObjectKey not propagated: it will be used to set the value for __UID__ attribute\n-            LOG.debug(\"connObjectKey will be used just as __UID__ attribute\");\n-        }\n-\n-        return name;\n-    }\n-\n-    private static String getGroupOwnerValue(final Provision provision, final Any<?, ?, ?> any) {\n-        Pair<String, Attribute> preparedAttr = prepareAttr(provision, getConnObjectKeyItem(provision),\n-                any, null, null, Collections.<String, AttrPatch>emptyMap());\n+    private String getGroupOwnerValue(final Provision provision, final Any<?, ?, ?> any) {\n+        Pair<String, Attribute> preparedAttr = prepareAttr(\n+                provision, getConnObjectKeyItem(provision), any, null, Collections.<String, AttrPatch>emptyMap());\n         String connObjectKey = preparedAttr.getKey();\n \n-        final Name groupOwnerName = evaluateNAME(any, provision, connObjectKey);\n-        return groupOwnerName.getNameValue();\n+        return evaluateNAME(any, provision, connObjectKey).getNameValue();\n     }\n \n     /**\n-     * Get attribute values.\n+     * Get attribute values for the given {@link MappingItem} and any objects.\n      *\n      * @param provision provision information\n      * @param mappingItem mapping item\n      * @param anys any objects\n      * @param vAttrs virtual attributes to be managed\n      * @return attribute values.\n      */\n-    public static List<PlainAttrValue> getIntValues(final Provision provision,\n+    @Transactional(readOnly = true)\n+    public List<PlainAttrValue> getIntValues(final Provision provision,\n             final MappingItem mappingItem, final List<Any<?, ?, ?>> anys, final Map<String, AttrPatch> vAttrs) {\n \n         LOG.debug(\"Get attributes for '{}' and mapping type '{}'\", anys, mappingItem.getIntMappingType());\n \n-        EntityFactory entityFactory =\n-                ApplicationContextProvider.getBeanFactory().getBean(EntityFactory.class);\n-        AnyUtilsFactory anyUtilsFactory =\n-                ApplicationContextProvider.getBeanFactory().getBean(AnyUtilsFactory.class);\n+        boolean transform = true;\n+\n         List<PlainAttrValue> values = new ArrayList<>();\n-        PlainAttrValue attrValue;\n         switch (mappingItem.getIntMappingType()) {\n             case UserPlainSchema:\n             case GroupPlainSchema:\n@@ -440,9 +558,15 @@ public static List<PlainAttrValue> getIntValues(final Provision provision,\n                     PlainAttr<?> attr = any.getPlainAttr(mappingItem.getIntAttrName());\n                     if (attr != null) {\n                         if (attr.getUniqueValue() != null) {\n-                            values.add(attr.getUniqueValue());\n+                            PlainAttrUniqueValue value = SerializationUtils.clone(attr.getUniqueValue());\n+                            value.setAttr(null);\n+                            values.add(value);\n                         } else if (attr.getValues() != null) {\n-                            values.addAll(attr.getValues());\n+                            for (PlainAttrValue value : attr.getValues()) {\n+                                PlainAttrValue shadow = SerializationUtils.clone(value);\n+                                shadow.setAttr(null);\n+                                values.add(shadow);\n+                            }\n                         }\n                     }\n \n@@ -458,26 +582,27 @@ public static List<PlainAttrValue> getIntValues(final Provision provision,\n             case UserVirtualSchema:\n             case GroupVirtualSchema:\n             case AnyObjectVirtualSchema:\n+                // virtual attributes don't get transformed\n+                transform = false;\n+\n                 for (Any<?, ?, ?> any : anys) {\n                     AnyUtils anyUtils = anyUtilsFactory.getInstance(any);\n-                    VirAttr<?> virAttr = any.getVirAttr(mappingItem.getIntAttrName());\n-                    if (virAttr != null) {\n+                    VirAttr<?> attr = any.getVirAttr(mappingItem.getIntAttrName());\n+                    if (attr != null) {\n                         if (vAttrs != null) {\n                             if (vAttrs.containsKey(mappingItem.getIntAttrName())) {\n-                                virAttr.getValues().clear();\n-                                virAttr.getValues().addAll(\n+                                attr.getValues().clear();\n+                                attr.getValues().addAll(\n                                         vAttrs.get(mappingItem.getIntAttrName()).getAttrTO().getValues());\n                             } else {\n                                 throw new IllegalArgumentException(\"Don't need to update virtual attribute '\"\n                                         + mappingItem.getIntAttrName() + \"'\");\n                             }\n                         }\n-                        if (virAttr.getValues() != null) {\n-                            for (String value : virAttr.getValues()) {\n-                                attrValue = anyUtils.newPlainAttrValue();\n-                                attrValue.setStringValue(value);\n-                                values.add(attrValue);\n-                            }\n+                        for (String value : attr.getValues()) {\n+                            PlainAttrValue attrValue = anyUtils.newPlainAttrValue();\n+                            attrValue.setStringValue(value);\n+                            values.add(attrValue);\n                         }\n                     }\n \n@@ -486,7 +611,7 @@ public static List<PlainAttrValue> getIntValues(final Provision provision,\n                             + \"\\n* IntMappingType {}\"\n                             + \"\\n* Attribute values {}\",\n                             any.getClass().getSimpleName(),\n-                            virAttr, mappingItem.getIntAttrName(), mappingItem.getIntMappingType(), values);\n+                            attr, mappingItem.getIntAttrName(), mappingItem.getIntMappingType(), values);\n                 }\n                 break;\n \n@@ -495,18 +620,18 @@ public static List<PlainAttrValue> getIntValues(final Provision provision,\n             case AnyObjectDerivedSchema:\n                 for (Any<?, ?, ?> any : anys) {\n                     AnyUtils anyUtils = anyUtilsFactory.getInstance(any);\n-                    DerAttr<?> derAttr = any.getDerAttr(mappingItem.getIntAttrName());\n-                    if (derAttr != null) {\n-                        attrValue = anyUtils.newPlainAttrValue();\n-                        attrValue.setStringValue(derAttr.getValue(any.getPlainAttrs()));\n+                    DerAttr<?> attr = any.getDerAttr(mappingItem.getIntAttrName());\n+                    if (attr != null) {\n+                        PlainAttrValue attrValue = anyUtils.newPlainAttrValue();\n+                        attrValue.setStringValue(attr.getValue(any.getPlainAttrs()));\n                         values.add(attrValue);\n                     }\n \n                     LOG.debug(\"Retrieved attribute {}\"\n                             + \"\\n* IntAttrName {}\"\n                             + \"\\n* IntMappingType {}\"\n                             + \"\\n* Attribute values {}\",\n-                            derAttr, mappingItem.getIntAttrName(), mappingItem.getIntMappingType(), values);\n+                            attr, mappingItem.getIntAttrName(), mappingItem.getIntMappingType(), values);\n                 }\n                 break;\n \n@@ -515,7 +640,7 @@ public static List<PlainAttrValue> getIntValues(final Provision provision,\n             case AnyObjectKey:\n                 for (Any<?, ?, ?> any : anys) {\n                     AnyUtils anyUtils = anyUtilsFactory.getInstance(any);\n-                    attrValue = anyUtils.newPlainAttrValue();\n+                    PlainAttrValue attrValue = anyUtils.newPlainAttrValue();\n                     attrValue.setStringValue(any.getKey().toString());\n                     values.add(attrValue);\n                 }\n@@ -524,7 +649,7 @@ public static List<PlainAttrValue> getIntValues(final Provision provision,\n             case Username:\n                 for (Any<?, ?, ?> any : anys) {\n                     if (any instanceof User) {\n-                        attrValue = entityFactory.newEntity(UPlainAttrValue.class);\n+                        UPlainAttrValue attrValue = entityFactory.newEntity(UPlainAttrValue.class);\n                         attrValue.setStringValue(((User) any).getUsername());\n                         values.add(attrValue);\n                     }\n@@ -534,15 +659,14 @@ public static List<PlainAttrValue> getIntValues(final Provision provision,\n             case GroupName:\n                 for (Any<?, ?, ?> any : anys) {\n                     if (any instanceof Group) {\n-                        attrValue = entityFactory.newEntity(GPlainAttrValue.class);\n+                        GPlainAttrValue attrValue = entityFactory.newEntity(GPlainAttrValue.class);\n                         attrValue.setStringValue(((Group) any).getName());\n                         values.add(attrValue);\n                     }\n                 }\n                 break;\n \n             case GroupOwnerSchema:\n-                AnyTypeDAO anyTypeDAO = ApplicationContextProvider.getBeanFactory().getBean(AnyTypeDAO.class);\n                 Mapping uMapping = provision.getAnyType().equals(anyTypeDAO.findUser())\n                         ? null\n                         : provision.getMapping();\n@@ -562,7 +686,7 @@ public static List<PlainAttrValue> getIntValues(final Provision provision,\n                         }\n \n                         if (StringUtils.isNotBlank(groupOwnerValue)) {\n-                            attrValue = entityFactory.newEntity(GPlainAttrValue.class);\n+                            GPlainAttrValue attrValue = entityFactory.newEntity(GPlainAttrValue.class);\n                             attrValue.setStringValue(groupOwnerValue);\n                             values.add(attrValue);\n                         }\n@@ -573,9 +697,19 @@ public static List<PlainAttrValue> getIntValues(final Provision provision,\n             default:\n         }\n \n-        LOG.debug(\"Retrieved values '{}'\", values);\n+        LOG.debug(\"Values for propagation: {}\", values);\n \n-        return values;\n+        List<PlainAttrValue> transformed = values;\n+        if (transform) {\n+            for (MappingItemTransformer transformer : getMappingItemTransformers(mappingItem)) {\n+                transformed = transformer.beforePropagation(transformed);\n+            }\n+            LOG.debug(\"Transformed values for propagation: {}\", values);\n+        } else {\n+            LOG.debug(\"No transformation occurred\");\n+        }\n+\n+        return transformed;\n     }\n \n     /**\n@@ -585,79 +719,148 @@ public static List<PlainAttrValue> getIntValues(final Provision provision,\n      * @param provision provision information\n      * @return connObjectKey internal value\n      */\n-    public static String getConnObjectKeyValue(final Any<?, ?, ?> any, final Provision provision) {\n+    @Transactional(readOnly = true)\n+    public String getConnObjectKeyValue(final Any<?, ?, ?> any, final Provision provision) {\n         List<PlainAttrValue> values = getIntValues(provision, provision.getMapping().getConnObjectKeyItem(),\n                 Collections.<Any<?, ?, ?>>singletonList(any), null);\n         return values == null || values.isEmpty()\n                 ? null\n                 : values.get(0).getValueAsString();\n     }\n \n-    public static MappingItem getConnObjectKeyItem(final Provision provision) {\n-        Mapping mapping = null;\n-        if (provision != null) {\n-            mapping = provision.getMapping();\n-        }\n-\n-        return mapping == null\n-                ? null\n-                : mapping.getConnObjectKeyItem();\n-    }\n-\n-    public static List<MappingItem> getMappingItems(final Provision provision, final MappingPurpose purpose) {\n-        List<? extends MappingItem> items = Collections.<MappingItem>emptyList();\n-        if (provision != null) {\n-            items = provision.getMapping().getItems();\n+    /**\n+     * Set attribute values, according to the given {@link MappingItem}, to any object from attribute received from\n+     * connector.\n+     *\n+     * @param <T> any object\n+     * @param mappingItem mapping item\n+     * @param attr attribute received from connector\n+     * @param anyTO any object\n+     * @param anyUtils any utils\n+     */\n+    @Transactional(readOnly = true)\n+    public <T extends AnyTO> void setIntValues(\n+            final MappingItem mappingItem, final Attribute attr, final T anyTO, final AnyUtils anyUtils) {\n+\n+        List<Object> values = null;\n+        if (attr != null) {\n+            values = attr.getValue();\n+            for (MappingItemTransformer transformer : getMappingItemTransformers(mappingItem)) {\n+                values = transformer.beforeSync(values);\n+            }\n         }\n+        values = ListUtils.emptyIfNull(values);\n \n-        List<MappingItem> result = new ArrayList<>();\n+        switch (mappingItem.getIntMappingType()) {\n+            case UserKey:\n+            case GroupKey:\n+            case AnyObjectKey:\n+                break;\n \n-        switch (purpose) {\n-            case SYNCHRONIZATION:\n-                for (MappingItem item : items) {\n-                    if (MappingPurpose.PROPAGATION != item.getPurpose()\n-                            && MappingPurpose.NONE != item.getPurpose()) {\n+            case Password:\n+                if (anyTO instanceof UserTO && !values.isEmpty()) {\n+                    ((UserTO) anyTO).setPassword(ConnObjectUtils.getPassword(values.get(0)));\n+                }\n+                break;\n \n-                        result.add(item);\n-                    }\n+            case Username:\n+                if (anyTO instanceof UserTO) {\n+                    ((UserTO) anyTO).setUsername(values.isEmpty() || values.get(0) == null\n+                            ? null\n+                            : values.get(0).toString());\n                 }\n                 break;\n \n-            case PROPAGATION:\n-                for (MappingItem item : items) {\n-                    if (MappingPurpose.SYNCHRONIZATION != item.getPurpose()\n-                            && MappingPurpose.NONE != item.getPurpose()) {\n+            case GroupName:\n+                if (anyTO instanceof GroupTO) {\n+                    ((GroupTO) anyTO).setName(values.isEmpty() || values.get(0) == null\n+                            ? null\n+                            : values.get(0).toString());\n+                }\n+                break;\n \n-                        result.add(item);\n+            case GroupOwnerSchema:\n+                if (anyTO instanceof GroupTO && attr != null) {\n+                    // using a special attribute (with schema \"\", that will be ignored) for carrying the\n+                    // GroupOwnerSchema value\n+                    AttrTO attrTO = new AttrTO();\n+                    attrTO.setSchema(StringUtils.EMPTY);\n+                    if (values.isEmpty() || values.get(0) == null) {\n+                        attrTO.getValues().add(StringUtils.EMPTY);\n+                    } else {\n+                        attrTO.getValues().add(values.get(0).toString());\n                     }\n+\n+                    ((GroupTO) anyTO).getPlainAttrs().add(attrTO);\n                 }\n                 break;\n \n-            case BOTH:\n-                for (MappingItem item : items) {\n-                    if (MappingPurpose.NONE != item.getPurpose()) {\n-                        result.add(item);\n+            case UserPlainSchema:\n+            case GroupPlainSchema:\n+            case AnyObjectPlainSchema:\n+                AttrTO attrTO = new AttrTO();\n+                attrTO.setSchema(mappingItem.getIntAttrName());\n+\n+                PlainSchema schema = plainSchemaDAO.find(mappingItem.getIntAttrName());\n+\n+                for (Object value : values) {\n+                    AttrSchemaType schemaType = schema == null ? AttrSchemaType.String : schema.getType();\n+                    if (value != null) {\n+                        PlainAttrValue attrValue = anyUtils.newPlainAttrValue();\n+                        switch (schemaType) {\n+                            case String:\n+                                attrValue.setStringValue(value.toString());\n+                                break;\n+\n+                            case Binary:\n+                                attrValue.setBinaryValue((byte[]) value);\n+                                break;\n+\n+                            default:\n+                                try {\n+                                    attrValue.parseValue(schema, value.toString());\n+                                } catch (ParsingValidationException e) {\n+                                    LOG.error(\"While parsing provided value {}\", value, e);\n+                                    attrValue.setStringValue(value.toString());\n+                                    schemaType = AttrSchemaType.String;\n+                                }\n+                                break;\n+                        }\n+                        attrTO.getValues().add(attrValue.getValueAsString(schemaType));\n                     }\n                 }\n+\n+                anyTO.getPlainAttrs().add(attrTO);\n                 break;\n \n-            case NONE:\n-                for (MappingItem item : items) {\n-                    if (MappingPurpose.NONE == item.getPurpose()) {\n-                        result.add(item);\n+            case UserDerivedSchema:\n+            case GroupDerivedSchema:\n+            case AnyObjectDerivedSchema:\n+                attrTO = new AttrTO();\n+                attrTO.setSchema(mappingItem.getIntAttrName());\n+                anyTO.getDerAttrs().add(attrTO);\n+                break;\n+\n+            case UserVirtualSchema:\n+            case GroupVirtualSchema:\n+            case AnyObjectVirtualSchema:\n+                attrTO = new AttrTO();\n+                attrTO.setSchema(mappingItem.getIntAttrName());\n+\n+                // virtual attributes don't get transformed, iterate over original attr.getValue()\n+                for (Object value : (attr == null || attr.getValue() == null)\n+                        ? Collections.emptyList() : attr.getValue()) {\n+\n+                    if (value != null) {\n+                        attrTO.getValues().add(value.toString());\n                     }\n                 }\n+\n+                anyTO.getVirAttrs().add(attrTO);\n                 break;\n \n             default:\n         }\n-\n-        return result;\n     }\n \n-    /**\n-     * Private default constructor, for static-only classes.\n-     */\n-    private MappingUtils() {\n-    }\n }"},{"sha":"10eb23576fb3d5b580b79ff3dc2e99d9a37ca1df","filename":"core/misc/src/main/java/org/apache/syncope/core/misc/security/AuthDataAccessor.java","status":"modified","additions":6,"deletions":3,"changes":9,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/72e6ceb0624a90a9b63bafce37c04104c7391d79/core%2Fmisc%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fmisc%2Fsecurity%2FAuthDataAccessor.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/72e6ceb0624a90a9b63bafce37c04104c7391d79/core%2Fmisc%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fmisc%2Fsecurity%2FAuthDataAccessor.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fmisc%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fmisc%2Fsecurity%2FAuthDataAccessor.java?ref=72e6ceb0624a90a9b63bafce37c04104c7391d79","patch":"@@ -72,6 +72,8 @@ public class AuthDataAccessor {\n \n     protected static final Logger LOG = LoggerFactory.getLogger(AuthDataAccessor.class);\n \n+    protected static final Encryptor ENCRYPTOR = Encryptor.getInstance();\n+\n     @Resource(name = \"adminUser\")\n     protected String adminUser;\n \n@@ -102,7 +104,8 @@ public class AuthDataAccessor {\n     @Autowired\n     protected AuditManager auditManager;\n \n-    protected final Encryptor encryptor = Encryptor.getInstance();\n+    @Autowired\n+    protected MappingUtils mappingUtils;\n \n     @Transactional(readOnly = true)\n     public Domain findDomain(final String key) {\n@@ -158,7 +161,7 @@ public Pair<Long, Boolean> authenticate(final Authentication authentication) {\n     }\n \n     protected boolean authenticate(final User user, final String password) {\n-        boolean authenticated = encryptor.verify(password, user.getCipherAlgorithm(), user.getPassword());\n+        boolean authenticated = ENCRYPTOR.verify(password, user.getCipherAlgorithm(), user.getPassword());\n         LOG.debug(\"{} authenticated on internal storage: {}\", user.getUsername(), authenticated);\n \n         for (Iterator<? extends ExternalResource> itor = getPassthroughResources(user).iterator();\n@@ -167,7 +170,7 @@ protected boolean authenticate(final User user, final String password) {\n             ExternalResource resource = itor.next();\n             String connObjectKey = null;\n             try {\n-                connObjectKey = MappingUtils.getConnObjectKeyValue(user, resource.getProvision(anyTypeDAO.findUser()));\n+                connObjectKey = mappingUtils.getConnObjectKeyValue(user, resource.getProvision(anyTypeDAO.findUser()));\n                 Uid uid = connFactory.getConnector(resource).authenticate(connObjectKey, password, null);\n                 if (uid != null) {\n                     authenticated = true;"},{"sha":"5c780f0167955f440b12df654d44df1dbdd5e3d0","filename":"core/misc/src/main/java/org/apache/syncope/core/misc/serialization/GuardedStringSerializer.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/72e6ceb0624a90a9b63bafce37c04104c7391d79/core%2Fmisc%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fmisc%2Fserialization%2FGuardedStringSerializer.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/72e6ceb0624a90a9b63bafce37c04104c7391d79/core%2Fmisc%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fmisc%2Fserialization%2FGuardedStringSerializer.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fmisc%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fmisc%2Fserialization%2FGuardedStringSerializer.java?ref=72e6ceb0624a90a9b63bafce37c04104c7391d79","patch":"@@ -60,14 +60,14 @@ public void serialize(final GuardedString source, final JsonGenerator jgen, fina\n         jgen.writeBooleanField(\"disposed\", disposed);\n \n         final StringBuilder cleartext = new StringBuilder();\n-        ((GuardedString) source).access(new GuardedString.Accessor() {\n+        source.access(new GuardedString.Accessor() {\n \n             @Override\n             public void access(final char[] clearChars) {\n                 cleartext.append(clearChars);\n             }\n         });\n-        final byte[] encryptedBytes =\n+        byte[] encryptedBytes =\n                 EncryptorFactory.getInstance().getDefaultEncryptor().encrypt(cleartext.toString().getBytes());\n         jgen.writeStringField(\"encryptedBytes\", Base64.encode(encryptedBytes));\n "},{"sha":"fd349a910fd805e405dafcc61c2775371e81e3a6","filename":"core/persistence-api/src/main/java/org/apache/syncope/core/persistence/api/ImplementationLookup.java","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/72e6ceb0624a90a9b63bafce37c04104c7391d79/core%2Fpersistence-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fapi%2FImplementationLookup.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/72e6ceb0624a90a9b63bafce37c04104c7391d79/core%2Fpersistence-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fapi%2FImplementationLookup.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fpersistence-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fapi%2FImplementationLookup.java?ref=72e6ceb0624a90a9b63bafce37c04104c7391d79","patch":"@@ -33,6 +33,7 @@ public enum Type {\n         REPORTLET,\n         ACCOUNT_RULE,\n         PASSWORD_RULE,\n+        MAPPING_ITEM_TRANSFORMER,\n         TASKJOBDELEGATE,\n         LOGIC_ACTIONS,\n         PROPAGATION_ACTIONS,"},{"sha":"9f515edac1e055076894c30c7db44fa41cf808b7","filename":"core/persistence-api/src/main/java/org/apache/syncope/core/persistence/api/entity/resource/MappingItem.java","status":"modified","additions":3,"deletions":0,"changes":3,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/72e6ceb0624a90a9b63bafce37c04104c7391d79/core%2Fpersistence-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fapi%2Fentity%2Fresource%2FMappingItem.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/72e6ceb0624a90a9b63bafce37c04104c7391d79/core%2Fpersistence-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fapi%2Fentity%2Fresource%2FMappingItem.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fpersistence-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fapi%2Fentity%2Fresource%2FMappingItem.java?ref=72e6ceb0624a90a9b63bafce37c04104c7391d79","patch":"@@ -18,6 +18,7 @@\n  */\n package org.apache.syncope.core.persistence.api.entity.resource;\n \n+import java.util.List;\n import org.apache.syncope.common.lib.types.IntMappingType;\n import org.apache.syncope.common.lib.types.MappingPurpose;\n import org.apache.syncope.core.persistence.api.entity.Entity;\n@@ -56,4 +57,6 @@ public interface MappingItem extends Entity<Long> {\n \n     void setPassword(boolean password);\n \n+    List<String> getMappingItemTransformerClassNames();\n+\n }"},{"sha":"8dba286d32348d237c8e2344e1309a9dcf904a02","filename":"core/persistence-jpa/src/main/java/org/apache/syncope/core/persistence/jpa/entity/resource/JPAMappingItem.java","status":"modified","additions":22,"deletions":0,"changes":22,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/72e6ceb0624a90a9b63bafce37c04104c7391d79/core%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fjpa%2Fentity%2Fresource%2FJPAMappingItem.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/72e6ceb0624a90a9b63bafce37c04104c7391d79/core%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fjpa%2Fentity%2Fresource%2FJPAMappingItem.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fjpa%2Fentity%2Fresource%2FJPAMappingItem.java?ref=72e6ceb0624a90a9b63bafce37c04104c7391d79","patch":"@@ -18,13 +18,19 @@\n  */\n package org.apache.syncope.core.persistence.jpa.entity.resource;\n \n+import java.util.ArrayList;\n+import java.util.List;\n import javax.persistence.Basic;\n import javax.persistence.Cacheable;\n+import javax.persistence.CollectionTable;\n import javax.persistence.Column;\n+import javax.persistence.ElementCollection;\n import javax.persistence.Entity;\n import javax.persistence.EnumType;\n import javax.persistence.Enumerated;\n+import javax.persistence.FetchType;\n import javax.persistence.Id;\n+import javax.persistence.JoinColumn;\n import javax.persistence.ManyToOne;\n import javax.persistence.Table;\n import javax.validation.constraints.Max;\n@@ -91,6 +97,16 @@ public class JPAMappingItem extends AbstractEntity<Long> implements MappingItem\n     @Enumerated(EnumType.STRING)\n     private MappingPurpose purpose;\n \n+    /**\n+     * (Optional) classes for MappingItem transformation.\n+     */\n+    @ElementCollection(fetch = FetchType.EAGER)\n+    @Column(name = \"transformerClassName\")\n+    @CollectionTable(name = \"MappingItem_Transformer\",\n+            joinColumns =\n+            @JoinColumn(name = \"mappingItem_id\", referencedColumnName = \"id\"))\n+    private List<String> mappingItemTransformerClassNames = new ArrayList<>();\n+\n     public JPAMappingItem() {\n         super();\n \n@@ -214,4 +230,10 @@ public MappingPurpose getPurpose() {\n     public void setPurpose(final MappingPurpose purpose) {\n         this.purpose = purpose;\n     }\n+\n+    @Override\n+    public List<String> getMappingItemTransformerClassNames() {\n+        return mappingItemTransformerClassNames;\n+    }\n+\n }"},{"sha":"78796612ccf7b741594cbb088e1673f6bc8bbcbd","filename":"core/persistence-jpa/src/main/java/org/apache/syncope/core/persistence/jpa/validation/entity/ExternalResourceValidator.java","status":"modified","additions":22,"deletions":0,"changes":22,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/72e6ceb0624a90a9b63bafce37c04104c7391d79/core%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fjpa%2Fvalidation%2Fentity%2FExternalResourceValidator.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/72e6ceb0624a90a9b63bafce37c04104c7391d79/core%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fjpa%2Fvalidation%2Fentity%2FExternalResourceValidator.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fpersistence%2Fjpa%2Fvalidation%2Fentity%2FExternalResourceValidator.java?ref=72e6ceb0624a90a9b63bafce37c04104c7391d79","patch":"@@ -30,6 +30,7 @@\n import org.apache.syncope.core.persistence.api.entity.resource.Mapping;\n import org.apache.syncope.core.persistence.api.entity.resource.MappingItem;\n import org.apache.syncope.core.persistence.api.entity.resource.Provision;\n+import org.apache.syncope.core.provisioning.api.data.MappingItemTransformer;\n import org.apache.syncope.core.provisioning.api.propagation.PropagationActions;\n \n public class ExternalResourceValidator extends AbstractValidator<ExternalResourceCheck, ExternalResource> {\n@@ -106,6 +107,27 @@ public boolean evaluate(final MappingItem item) {\n             isValid = false;\n         }\n \n+        for (MappingItem item : mapping.getItems()) {\n+            for (String className : item.getMappingItemTransformerClassNames()) {\n+                Class<?> actionsClass = null;\n+                boolean isAssignable = false;\n+                try {\n+                    actionsClass = Class.forName(className);\n+                    isAssignable = MappingItemTransformer.class.isAssignableFrom(actionsClass);\n+                } catch (Exception e) {\n+                    LOG.error(\"Invalid MappingItemTransformer specified: {}\", className, e);\n+                }\n+\n+                if (actionsClass == null || !isAssignable) {\n+                    context.buildConstraintViolationWithTemplate(\n+                            getTemplate(EntityViolationType.InvalidMapping,\n+                                    \"Invalid mapping item trasformer class name\")).\n+                            addPropertyNode(\"mappingItemTransformerClassName\").addConstraintViolation();\n+                    isValid = false;\n+                }\n+            }\n+        }\n+\n         return isValid;\n     }\n "},{"sha":"ae11199045ea497003bf047cfffe3153912c7827","filename":"core/provisioning-api/src/main/java/org/apache/syncope/core/provisioning/api/data/MappingItemTransformer.java","status":"added","additions":47,"deletions":0,"changes":47,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/72e6ceb0624a90a9b63bafce37c04104c7391d79/core%2Fprovisioning-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fapi%2Fdata%2FMappingItemTransformer.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/72e6ceb0624a90a9b63bafce37c04104c7391d79/core%2Fprovisioning-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fapi%2Fdata%2FMappingItemTransformer.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fapi%2Fdata%2FMappingItemTransformer.java?ref=72e6ceb0624a90a9b63bafce37c04104c7391d79","patch":"@@ -0,0 +1,47 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.core.provisioning.api.data;\n+\n+import java.util.List;\n+import org.apache.syncope.core.persistence.api.entity.PlainAttrValue;\n+\n+/**\n+ * Transforms values to be propagated to (or synchronizing from) external resources right before they leave (or enter)\n+ * the Syncope internal storage.\n+ *\n+ * These transformations are not applied to virtual attribute values.\n+ */\n+public interface MappingItemTransformer {\n+\n+    /**\n+     * Invoked while preparing attribute values to be sent out to external resource during propagation.\n+     *\n+     * @param values original values\n+     * @return transformed values\n+     */\n+    List<PlainAttrValue> beforePropagation(List<PlainAttrValue> values);\n+\n+    /**\n+     * Invoked while reading attribute values from external resource during synchronization.\n+     *\n+     * @param values original values\n+     * @return transformed values\n+     */\n+    List<Object> beforeSync(List<Object> values);\n+}"},{"sha":"0b4340e3fbcd83d1b24a9e8ae7b09af24133a5c1","filename":"core/provisioning-java/src/main/java/org/apache/syncope/core/provisioning/java/AsyncConnectorFacade.java","status":"modified","additions":7,"deletions":7,"changes":14,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/72e6ceb0624a90a9b63bafce37c04104c7391d79/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2FAsyncConnectorFacade.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/72e6ceb0624a90a9b63bafce37c04104c7391d79/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2FAsyncConnectorFacade.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2FAsyncConnectorFacade.java?ref=72e6ceb0624a90a9b63bafce37c04104c7391d79","patch":"@@ -120,7 +120,7 @@ public Future<Attribute> getObjectAttribute(\n \n         Attribute attribute = null;\n \n-        final ConnectorObject object = connector.getObject(objectClass, uid, options);\n+        ConnectorObject object = connector.getObject(objectClass, uid, options);\n         if (object == null) {\n             LOG.debug(\"Object for '{}' not found\", uid.getUidValue());\n         } else {\n@@ -137,9 +137,9 @@ public Future<Set<Attribute>> getObjectAttributes(\n             final Uid uid,\n             final OperationOptions options) {\n \n-        final Set<Attribute> attributes = new HashSet<>();\n+        Set<Attribute> attributes = new HashSet<>();\n \n-        final ConnectorObject object = connector.getObject(objectClass, uid, options);\n+        ConnectorObject object = connector.getObject(objectClass, uid, options);\n \n         if (object == null) {\n             LOG.debug(\"Object for '{}' not found\", uid.getUidValue());\n@@ -154,10 +154,10 @@ public Future<Set<Attribute>> getObjectAttributes(\n \n     @Async\n     public Future<Set<String>> getSchemaNames(final ConnectorFacade connector, final boolean includeSpecial) {\n-        final Set<String> schemaNames = new HashSet<>();\n+        Set<String> schemaNames = new HashSet<>();\n \n         try {\n-            final Schema schema = connector.schema();\n+            Schema schema = connector.schema();\n             for (ObjectClassInfo info : schema.getObjectClassInfo()) {\n                 for (AttributeInfo attrInfo : info.getAttributeInfo()) {\n                     if (includeSpecial || !AttributeUtil.isSpecialName(attrInfo.getName())) {\n@@ -175,10 +175,10 @@ public Future<Set<String>> getSchemaNames(final ConnectorFacade connector, final\n \n     @Async\n     public Future<Set<ObjectClass>> getSupportedObjectClasses(final ConnectorFacade connector) {\n-        final Set<ObjectClass> objectClasses = new HashSet<>();\n+        Set<ObjectClass> objectClasses = new HashSet<>();\n \n         try {\n-            final Schema schema = connector.schema();\n+            Schema schema = connector.schema();\n             for (ObjectClassInfo info : schema.getObjectClassInfo()) {\n                 objectClasses.add(new ObjectClass(info.getType()));\n             }"},{"sha":"3d600893aa5f3d63b15dc399ad93cff9487b9032","filename":"core/provisioning-java/src/main/java/org/apache/syncope/core/provisioning/java/VirAttrHandlerImpl.java","status":"modified","additions":19,"deletions":25,"changes":44,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/72e6ceb0624a90a9b63bafce37c04104c7391d79/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2FVirAttrHandlerImpl.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/72e6ceb0624a90a9b63bafce37c04104c7391d79/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2FVirAttrHandlerImpl.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2FVirAttrHandlerImpl.java?ref=72e6ceb0624a90a9b63bafce37c04104c7391d79","patch":"@@ -34,7 +34,6 @@\n import org.apache.syncope.common.lib.to.AttrTO;\n import org.apache.syncope.common.lib.types.AnyTypeKind;\n import org.apache.syncope.common.lib.types.IntMappingType;\n-import org.apache.syncope.common.lib.types.MappingPurpose;\n import org.apache.syncope.common.lib.types.PropagationByResource;\n import org.apache.syncope.common.lib.types.ResourceOperation;\n import org.apache.syncope.core.misc.MappingUtils;\n@@ -61,7 +60,6 @@\n import org.apache.syncope.core.provisioning.api.cache.VirAttrCacheValue;\n import org.identityconnectors.framework.common.objects.Attribute;\n import org.identityconnectors.framework.common.objects.ConnectorObject;\n-import org.identityconnectors.framework.common.objects.OperationOptions;\n import org.identityconnectors.framework.common.objects.Uid;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -102,6 +100,9 @@ public class VirAttrHandlerImpl implements VirAttrHandler {\n     @Autowired\n     private VirAttrCache virAttrCache;\n \n+    @Autowired\n+    private MappingUtils mappingUtils;\n+\n     @Override\n     public VirSchema getVirSchema(final String virSchemaName) {\n         VirSchema virtualSchema = null;\n@@ -122,8 +123,8 @@ public void updateOnResourcesIfMappingMatches(final Any<?, ?, ?> any, final Stri\n             final PropagationByResource propByRes) {\n \n         for (ExternalResource resource : resources) {\n-            for (MappingItem mapItem : MappingUtils.getMappingItems(\n-                    resource.getProvision(any.getType()), MappingPurpose.PROPAGATION)) {\n+            for (MappingItem mapItem\n+                    : MappingUtils.getPropagationMappingItems(resource.getProvision(any.getType()))) {\n \n                 if (schemaKey.equals(mapItem.getIntAttrName()) && mapItem.getIntMappingType() == mappingType) {\n                     propByRes.add(ResourceOperation.UPDATE, resource.getKey());\n@@ -232,8 +233,8 @@ public PropagationByResource updateVirtual(final Any any, final Collection<AttrP\n                         }\n \n                         for (ExternalResource resource : externalResources) {\n-                            for (MappingItem mapItem : MappingUtils.getMappingItems(\n-                                    resource.getProvision(any.getType()), MappingPurpose.PROPAGATION)) {\n+                            for (MappingItem mapItem\n+                                    : MappingUtils.getPropagationMappingItems(resource.getProvision(any.getType()))) {\n \n                                 if (virSchema.getKey().equals(mapItem.getIntAttrName())\n                                         && mapItem.getIntMappingType() == anyUtils.virIntMappingType()) {\n@@ -314,7 +315,7 @@ private void retrieveVirAttrValue(\n                 LOG.debug(\"Search values into {},{}\", resource, provision);\n \n                 try {\n-                    List<MappingItem> mappings = MappingUtils.getMappingItems(provision, MappingPurpose.BOTH);\n+                    List<MappingItem> mapItems = MappingUtils.getBothMappingItems(provision);\n \n                     ConnectorObject connectorObject;\n                     if (externalResources.containsKey(resource.getKey())) {\n@@ -323,33 +324,26 @@ private void retrieveVirAttrValue(\n                         LOG.debug(\"Perform connection to {}\", resource.getKey());\n                         String connObjectKey = MappingUtils.getConnObjectKeyItem(provision) == null\n                                 ? null\n-                                : MappingUtils.getConnObjectKeyValue(any, provision);\n+                                : mappingUtils.getConnObjectKeyValue(any, provision);\n \n                         if (StringUtils.isBlank(connObjectKey)) {\n                             throw new IllegalArgumentException(\"No ConnObjectKey found for \" + resource.getKey());\n                         }\n \n                         Connector connector = connFactory.getConnector(resource);\n-\n-                        OperationOptions oo =\n-                                connector.getOperationOptions(MappingUtils.getMatchingMappingItems(mappings, type));\n-\n-                        connectorObject =\n-                                connector.getObject(provision.getObjectClass(), new Uid(connObjectKey), oo);\n+                        connectorObject = connector.getObject(\n+                                provision.getObjectClass(),\n+                                new Uid(connObjectKey),\n+                                connector.getOperationOptions(MappingUtils.getMatchingMappingItems(mapItems, type)));\n                         externalResources.put(resource.getKey(), connectorObject);\n                     }\n \n                     if (connectorObject != null) {\n-                        // ask for searched virtual attribute value\n-                        Collection<MappingItem> virAttrMappings =\n-                                MappingUtils.getMatchingMappingItems(mappings, schemaName, type);\n-\n-                        // the same virtual attribute could be mapped with one or more external attribute \n-                        for (MappingItem mapping : virAttrMappings) {\n-                            Attribute attribute = connectorObject.getAttributeByName(mapping.getExtAttrName());\n-\n-                            if (attribute != null && attribute.getValue() != null) {\n-                                for (Object obj : attribute.getValue()) {\n+                        // the same virtual attribute could be mapped with one or more external attributes\n+                        for (MappingItem mapItem : MappingUtils.getMatchingMappingItems(mapItems, schemaName, type)) {\n+                            Attribute attr = connectorObject.getAttributeByName(mapItem.getExtAttrName());\n+                            if (attr != null && attr.getValue() != null) {\n+                                for (Object obj : attr.getValue()) {\n                                     if (obj != null) {\n                                         virAttr.getValues().add(obj.toString());\n                                     }\n@@ -390,7 +384,7 @@ private Collection<ExternalResource> getTargetResources(\n             public boolean evaluate(final ExternalResource resource) {\n                 return resource.getProvision(anyType) != null\n                         && !MappingUtils.getMatchingMappingItems(\n-                                MappingUtils.getMappingItems(resource.getProvision(anyType), MappingPurpose.BOTH),\n+                                MappingUtils.getBothMappingItems(resource.getProvision(anyType)),\n                                 attr.getSchema().getKey(), type).isEmpty();\n             }\n         });"},{"sha":"4a203f9c94160edba9253437b29766c9c9af7100","filename":"core/provisioning-java/src/main/java/org/apache/syncope/core/provisioning/java/data/AbstractAnyDataBinder.java","status":"modified","additions":10,"deletions":9,"changes":19,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/72e6ceb0624a90a9b63bafce37c04104c7391d79/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fdata%2FAbstractAnyDataBinder.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/72e6ceb0624a90a9b63bafce37c04104c7391d79/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fdata%2FAbstractAnyDataBinder.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fdata%2FAbstractAnyDataBinder.java?ref=72e6ceb0624a90a9b63bafce37c04104c7391d79","patch":"@@ -156,6 +156,9 @@ abstract class AbstractAnyDataBinder {\n     @Autowired\n     protected ConnObjectUtils connObjectUtils;\n \n+    @Autowired\n+    protected MappingUtils mappingUtils;\n+\n     protected void setRealm(final Any<?, ?, ?> any, final AnyPatch anyPatch) {\n         if (anyPatch.getRealm() != null && StringUtils.isNotBlank(anyPatch.getRealm().getValue())) {\n             Realm newRealm = realmDAO.find(anyPatch.getRealm().getValue());\n@@ -231,11 +234,9 @@ private List<String> evaluateMandatoryCondition(final Provision provision, final\n                         && (item.getPurpose() == MappingPurpose.PROPAGATION\n                         || item.getPurpose() == MappingPurpose.BOTH)) {\n \n-                    List<PlainAttrValue> values = MappingUtils.getIntValues(\n+                    List<PlainAttrValue> values = mappingUtils.getIntValues(\n                             provision, item, Collections.<Any<?, ?, ?>>singletonList(any), null);\n-                    if ((values == null || values.isEmpty())\n-                            && JexlUtils.evaluateMandatoryCondition(item.getMandatoryCondition(), any)) {\n-\n+                    if (values.isEmpty() && JexlUtils.evaluateMandatoryCondition(item.getMandatoryCondition(), any)) {\n                         missingAttrNames.add(item.getIntAttrName());\n                     }\n                 }\n@@ -360,8 +361,8 @@ public Long transform(final PlainAttrValue input) {\n                 plainAttrDAO.delete(attr.getKey(), anyUtils.plainAttrClass());\n \n                 for (ExternalResource resource : resources) {\n-                    for (MappingItem mapItem : MappingUtils.getMappingItems(\n-                            resource.getProvision(any.getType()), MappingPurpose.PROPAGATION)) {\n+                    for (MappingItem mapItem\n+                            : MappingUtils.getPropagationMappingItems(resource.getProvision(any.getType()))) {\n \n                         if (schema.getKey().equals(mapItem.getIntAttrName())\n                                 && mapItem.getIntMappingType() == anyUtils.plainIntMappingType()) {\n@@ -410,8 +411,8 @@ private void processAttrPatch(final Any any, final AttrPatch patch, final DerSch\n                 derAttrDAO.delete(attr);\n \n                 for (ExternalResource resource : resources) {\n-                    for (MappingItem mapItem : MappingUtils.getMappingItems(\n-                            resource.getProvision(any.getType()), MappingPurpose.PROPAGATION)) {\n+                    for (MappingItem mapItem\n+                            : MappingUtils.getPropagationMappingItems(resource.getProvision(any.getType()))) {\n \n                         if (schema.getKey().equals(mapItem.getIntAttrName())\n                                 && mapItem.getIntMappingType() == anyUtils.derIntMappingType()) {\n@@ -704,7 +705,7 @@ protected Map<String, String> getConnObjectKeys(final Any<?, ?, ?> any) {\n                             + \" on resource '\" + resource.getKey() + \"'\");\n                 }\n \n-                connObjectKeys.put(resource.getKey(), MappingUtils.getConnObjectKeyValue(any, provision));\n+                connObjectKeys.put(resource.getKey(), mappingUtils.getConnObjectKeyValue(any, provision));\n             }\n         }\n "},{"sha":"3810a879fc479fd17666d4e99121c1628fd62428","filename":"core/provisioning-java/src/main/java/org/apache/syncope/core/provisioning/java/data/DefaultMappingItemTransformer.java","status":"added","additions":40,"deletions":0,"changes":40,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/72e6ceb0624a90a9b63bafce37c04104c7391d79/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fdata%2FDefaultMappingItemTransformer.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/72e6ceb0624a90a9b63bafce37c04104c7391d79/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fdata%2FDefaultMappingItemTransformer.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fdata%2FDefaultMappingItemTransformer.java?ref=72e6ceb0624a90a9b63bafce37c04104c7391d79","patch":"@@ -0,0 +1,40 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.core.provisioning.java.data;\n+\n+import java.util.List;\n+import org.apache.syncope.core.persistence.api.entity.PlainAttrValue;\n+import org.apache.syncope.core.provisioning.api.data.MappingItemTransformer;\n+\n+/**\n+ * Default (empty) implementation of {@link MappingItemTransformer}.\n+ */\n+public class DefaultMappingItemTransformer implements MappingItemTransformer {\n+\n+    @Override\n+    public List<PlainAttrValue> beforePropagation(final List<PlainAttrValue> values) {\n+        return values;\n+    }\n+\n+    @Override\n+    public List<Object> beforeSync(final List<Object> values) {\n+        return values;\n+    }\n+\n+}"},{"sha":"69a2e9da325085689fefc27f5bb5be47810bfbb1","filename":"core/provisioning-java/src/main/java/org/apache/syncope/core/provisioning/java/propagation/AbstractPropagationTaskExecutor.java","status":"modified","additions":27,"deletions":6,"changes":33,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/72e6ceb0624a90a9b63bafce37c04104c7391d79/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpropagation%2FAbstractPropagationTaskExecutor.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/72e6ceb0624a90a9b63bafce37c04104c7391d79/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpropagation%2FAbstractPropagationTaskExecutor.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpropagation%2FAbstractPropagationTaskExecutor.java?ref=72e6ceb0624a90a9b63bafce37c04104c7391d79","patch":"@@ -22,13 +22,13 @@\n import java.util.Collection;\n import java.util.Collections;\n import java.util.Date;\n+import java.util.HashMap;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n import org.apache.syncope.common.lib.types.AuditElements;\n import org.apache.syncope.common.lib.types.AuditElements.Result;\n-import org.apache.syncope.common.lib.types.MappingPurpose;\n import org.apache.syncope.common.lib.types.PropagationTaskExecStatus;\n import org.apache.syncope.common.lib.types.TraceLevel;\n import org.apache.syncope.core.persistence.api.dao.GroupDAO;\n@@ -148,17 +148,38 @@ protected List<PropagationActions> getPropagationActions(final ExternalResource\n         return result;\n     }\n \n+    /**\n+     * Transform a\n+     * <code>Collection</code> of {@link Attribute} instances into a {@link Map}. The key to each element in the map is\n+     * the <i>name</i> of an\n+     * <code>Attribute</code>. The value of each element in the map is the\n+     * <code>Attribute</code> instance with that name. <br/> Different from the original because: <ul> <li>map keys are\n+     * transformed toUpperCase()</li> <li>returned map is mutable</li> </ul>\n+     *\n+     * @param attributes set of attribute to transform to a map.\n+     * @return a map of string and attribute.\n+     *\n+     * @see org.identityconnectors.framework.common.objects.AttributeUtil#toMap(java.util.Collection)\n+     */\n+    private Map<String, Attribute> toMap(final Collection<? extends Attribute> attributes) {\n+        Map<String, Attribute> map = new HashMap<>();\n+        for (Attribute attr : attributes) {\n+            map.put(attr.getName().toUpperCase(), attr);\n+        }\n+        return map;\n+    }\n+\n     protected void createOrUpdate(\n             final PropagationTask task,\n             final ConnectorObject beforeObj,\n             final Connector connector,\n             final Set<String> propagationAttempted) {\n \n         // set of attributes to be propagated\n-        final Set<Attribute> attributes = new HashSet<>(task.getAttributes());\n+        Set<Attribute> attributes = new HashSet<>(task.getAttributes());\n \n         // check if there is any missing or null / empty mandatory attribute\n-        List<Object> mandatoryAttrNames = new ArrayList<>();\n+        Set<Object> mandatoryAttrNames = new HashSet<>();\n         Attribute mandatoryMissing = AttributeUtil.find(MANDATORY_MISSING_ATTR_NAME, task.getAttributes());\n         if (mandatoryMissing != null) {\n             attributes.remove(mandatoryMissing);\n@@ -200,8 +221,8 @@ protected void createOrUpdate(\n \n             // 2. check wether anything is actually needing to be propagated, i.e. if there is attribute\n             // difference between beforeObj - just read above from the connector - and the values to be propagated\n-            Map<String, Attribute> originalAttrMap = connObjectUtils.toMap(beforeObj.getAttributes());\n-            Map<String, Attribute> updateAttrMap = connObjectUtils.toMap(attributes);\n+            Map<String, Attribute> originalAttrMap = toMap(beforeObj.getAttributes());\n+            Map<String, Attribute> updateAttrMap = toMap(attributes);\n \n             // Only compare attribute from beforeObj that are also being updated\n             Set<String> skipAttrNames = originalAttrMap.keySet();\n@@ -527,7 +548,7 @@ protected ConnectorObject getRemoteObject(final PropagationTask task, final Conn\n                     task.getOperation(),\n                     new ObjectClass(task.getObjectClassName()),\n                     new Uid(connObjectKey),\n-                    connector.getOperationOptions(MappingUtils.getMappingItems(provision, MappingPurpose.PROPAGATION)));\n+                    connector.getOperationOptions(MappingUtils.getPropagationMappingItems(provision)));\n         } catch (TimeoutException toe) {\n             LOG.debug(\"Request timeout\", toe);\n             throw toe;"},{"sha":"157fdc14ec59bc3adb99409f1794f9cc4f0142ef","filename":"core/provisioning-java/src/main/java/org/apache/syncope/core/provisioning/java/propagation/DefaultPropagationActions.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/72e6ceb0624a90a9b63bafce37c04104c7391d79/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpropagation%2FDefaultPropagationActions.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/72e6ceb0624a90a9b63bafce37c04104c7391d79/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpropagation%2FDefaultPropagationActions.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpropagation%2FDefaultPropagationActions.java?ref=72e6ceb0624a90a9b63bafce37c04104c7391d79","patch":"@@ -24,7 +24,7 @@\n import org.identityconnectors.framework.common.objects.ConnectorObject;\n \n /**\n- * Default (empty) implementation of PropagationActions.\n+ * Default (empty) implementation of {@link PropagationActions}.\n  */\n public abstract class DefaultPropagationActions implements PropagationActions {\n "},{"sha":"22feb44a3831053ea78f93fbdd00d70da944af58","filename":"core/provisioning-java/src/main/java/org/apache/syncope/core/provisioning/java/propagation/DefaultPropagationReporter.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/72e6ceb0624a90a9b63bafce37c04104c7391d79/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpropagation%2FDefaultPropagationReporter.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/72e6ceb0624a90a9b63bafce37c04104c7391d79/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpropagation%2FDefaultPropagationReporter.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpropagation%2FDefaultPropagationReporter.java?ref=72e6ceb0624a90a9b63bafce37c04104c7391d79","patch":"@@ -77,7 +77,7 @@ public void onPrimaryResourceFailure(final List<PropagationTask> tasks) {\n \n         for (PropagationTask propagationTask : tasks) {\n             if (!containsPropagationStatusTO(propagationTask.getResource().getKey())) {\n-                final PropagationStatus propagationStatusTO = new PropagationStatus();\n+                PropagationStatus propagationStatusTO = new PropagationStatus();\n                 propagationStatusTO.setResource(propagationTask.getResource().getKey());\n                 propagationStatusTO.setStatus(PropagationTaskExecStatus.FAILURE);\n                 propagationStatusTO.setFailureReason("},{"sha":"ebf9c99fbd5d7bb97f3f7fe8fb42802f81ef6d78","filename":"core/provisioning-java/src/main/java/org/apache/syncope/core/provisioning/java/propagation/PropagationManagerImpl.java","status":"modified","additions":6,"deletions":4,"changes":10,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/72e6ceb0624a90a9b63bafce37c04104c7391d79/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpropagation%2FPropagationManagerImpl.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/72e6ceb0624a90a9b63bafce37c04104c7391d79/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpropagation%2FPropagationManagerImpl.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fpropagation%2FPropagationManagerImpl.java?ref=72e6ceb0624a90a9b63bafce37c04104c7391d79","patch":"@@ -34,7 +34,6 @@\n import org.apache.syncope.common.lib.patch.UserPatch;\n import org.apache.syncope.common.lib.to.AttrTO;\n import org.apache.syncope.common.lib.types.AnyTypeKind;\n-import org.apache.syncope.common.lib.types.MappingPurpose;\n import org.apache.syncope.common.lib.types.PropagationByResource;\n import org.apache.syncope.common.lib.types.ResourceOperation;\n import org.apache.syncope.core.persistence.api.dao.ExternalResourceDAO;\n@@ -106,6 +105,9 @@ public class PropagationManagerImpl implements PropagationManager {\n     @Autowired\n     protected VirAttrHandler virAttrHandler;\n \n+    @Autowired\n+    protected MappingUtils mappingUtils;\n+\n     protected Any<?, ?, ?> find(final AnyTypeKind kind, final Long key) {\n         AnyDAO<? extends Any<?, ?, ?>> dao;\n         switch (kind) {\n@@ -367,7 +369,7 @@ protected List<PropagationTask> createTasks(final Any<?, ?, ?> any,\n                 } else if (provision == null) {\n                     LOG.error(\"No provision specified on resource {} for type {}, ignoring...\",\n                             resource, any.getType());\n-                } else if (MappingUtils.getMappingItems(provision, MappingPurpose.PROPAGATION).isEmpty()) {\n+                } else if (MappingUtils.getPropagationMappingItems(provision).isEmpty()) {\n                     LOG.warn(\"Requesting propagation for {} but no propagation mapping provided for {}\",\n                             any.getType(), resource);\n                 } else {\n@@ -382,15 +384,15 @@ protected List<PropagationTask> createTasks(final Any<?, ?, ?> any,\n                     task.setOperation(operation);\n                     task.setOldConnObjectKey(propByRes.getOldConnObjectKey(resource.getKey()));\n \n-                    Pair<String, Set<Attribute>> preparedAttrs = MappingUtils.prepareAttrs(\n+                    Pair<String, Set<Attribute>> preparedAttrs = mappingUtils.prepareAttrs(\n                             any, password, changePwd, vAttrs, enable, provision);\n                     task.setConnObjectKey(preparedAttrs.getKey());\n \n                     // Check if any of mandatory attributes (in the mapping) is missing or not received any value: \n                     // if so, add special attributes that will be evaluated by PropagationTaskExecutor\n                     List<String> mandatoryMissing = new ArrayList<>();\n                     List<String> mandatoryNullOrEmpty = new ArrayList<>();\n-                    for (MappingItem item : MappingUtils.getMappingItems(provision, MappingPurpose.PROPAGATION)) {\n+                    for (MappingItem item : MappingUtils.getPropagationMappingItems(provision)) {\n                         if (!item.isConnObjectKey()\n                                 && JexlUtils.evaluateMandatoryCondition(item.getMandatoryCondition(), any)) {\n "},{"sha":"94936eb2a09a0cc48156aa136367907f3a318a27","filename":"core/provisioning-java/src/main/java/org/apache/syncope/core/provisioning/java/sync/AbstractPushResultHandler.java","status":"modified","additions":5,"deletions":1,"changes":6,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/72e6ceb0624a90a9b63bafce37c04104c7391d79/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fsync%2FAbstractPushResultHandler.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/72e6ceb0624a90a9b63bafce37c04104c7391d79/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fsync%2FAbstractPushResultHandler.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fsync%2FAbstractPushResultHandler.java?ref=72e6ceb0624a90a9b63bafce37c04104c7391d79","patch":"@@ -58,12 +58,16 @@\n import org.identityconnectors.framework.common.objects.ObjectClass;\n import org.identityconnectors.framework.common.objects.Uid;\n import org.quartz.JobExecutionException;\n+import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.transaction.annotation.Propagation;\n import org.springframework.transaction.annotation.Transactional;\n \n public abstract class AbstractPushResultHandler extends AbstractSyncopeResultHandler<PushTask, PushActions>\n         implements SyncopePushResultHandler {\n \n+    @Autowired\n+    protected MappingUtils mappingUtils;\n+\n     protected abstract String getName(Any<?, ?, ?> any);\n \n     protected void deprovision(final Any<?, ?, ?> any) {\n@@ -195,7 +199,7 @@ protected final void doHandle(final Any<?, ?, ?> any) throws JobExecutionExcepti\n \n         // Try to read remote object BEFORE any actual operation\n         Provision provision = profile.getTask().getResource().getProvision(any.getType());\n-        String connObjecKey = MappingUtils.getConnObjectKeyValue(any, provision);\n+        String connObjecKey = mappingUtils.getConnObjectKeyValue(any, provision);\n \n         ConnectorObject beforeObj = getRemoteObject(connObjecKey, provision.getObjectClass());\n "},{"sha":"2ca7eaa66ce4ae741dabd18eabd784875abdfe58","filename":"core/provisioning-java/src/main/java/org/apache/syncope/core/provisioning/java/sync/AbstractSyncResultHandler.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/72e6ceb0624a90a9b63bafce37c04104c7391d79/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fsync%2FAbstractSyncResultHandler.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/72e6ceb0624a90a9b63bafce37c04104c7391d79/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fsync%2FAbstractSyncResultHandler.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fsync%2FAbstractSyncResultHandler.java?ref=72e6ceb0624a90a9b63bafce37c04104c7391d79","patch":"@@ -201,7 +201,7 @@ protected List<ProvisioningResult> provision(\n             create(anyTO, actionedDelta, UnmatchingRule.toEventName(UnmatchingRule.PROVISION), result);\n         }\n \n-        return Collections.<ProvisioningResult>singletonList(result);\n+        return Collections.singletonList(result);\n     }\n \n     private void create("},{"sha":"1ed0d2c4804269e063c1d3875c184ae0a7415134","filename":"core/provisioning-java/src/main/java/org/apache/syncope/core/provisioning/java/sync/PlainAttrsSyncCorrelationRule.java","status":"modified","additions":23,"deletions":18,"changes":41,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/72e6ceb0624a90a9b63bafce37c04104c7391d79/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fsync%2FPlainAttrsSyncCorrelationRule.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/72e6ceb0624a90a9b63bafce37c04104c7391d79/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fsync%2FPlainAttrsSyncCorrelationRule.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fsync%2FPlainAttrsSyncCorrelationRule.java?ref=72e6ceb0624a90a9b63bafce37c04104c7391d79","patch":"@@ -18,17 +18,19 @@\n  */\n package org.apache.syncope.core.provisioning.java.sync;\n \n+import static org.apache.syncope.core.misc.MappingUtils.getMappingItemTransformers;\n+\n import java.util.Arrays;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n-import org.apache.syncope.common.lib.types.MappingPurpose;\n import org.apache.syncope.core.misc.MappingUtils;\n import org.apache.syncope.core.persistence.api.dao.search.AnyCond;\n import org.apache.syncope.core.persistence.api.dao.search.AttributeCond;\n import org.apache.syncope.core.persistence.api.dao.search.SearchCond;\n import org.apache.syncope.core.persistence.api.entity.resource.MappingItem;\n import org.apache.syncope.core.persistence.api.entity.resource.Provision;\n+import org.apache.syncope.core.provisioning.api.data.MappingItemTransformer;\n import org.apache.syncope.core.provisioning.api.sync.SyncCorrelationRule;\n import org.identityconnectors.framework.common.objects.Attribute;\n import org.identityconnectors.framework.common.objects.ConnectorObject;\n@@ -46,41 +48,44 @@ public PlainAttrsSyncCorrelationRule(final String[] plainSchemaNames, final Prov\n \n     @Override\n     public SearchCond getSearchCond(final ConnectorObject connObj) {\n-        // search for external attribute's name/value of each specified name\n-        Map<String, Attribute> extValues = new HashMap<>();\n-\n-        for (MappingItem item : MappingUtils.getMappingItems(provision, MappingPurpose.SYNCHRONIZATION)) {\n-            extValues.put(item.getIntAttrName(), connObj.getAttributeByName(item.getExtAttrName()));\n+        Map<String, MappingItem> mappingItems = new HashMap<>();\n+        for (MappingItem item : MappingUtils.getSyncMappingItems(provision)) {\n+            mappingItems.put(item.getIntAttrName(), item);\n         }\n \n-        // search for user/group by attribute(s) specified in the policy\n+        // search for anys by attribute(s) specified in the policy\n         SearchCond searchCond = null;\n \n         for (String schema : plainSchemaNames) {\n-            Attribute value = extValues.get(schema);\n-\n-            if (value == null) {\n+            Attribute attr = mappingItems.get(schema) == null\n+                    ? null\n+                    : connObj.getAttributeByName(mappingItems.get(schema).getExtAttrName());\n+            if (attr == null) {\n                 throw new IllegalArgumentException(\n                         \"Connector object does not contains the attributes to perform the search: \" + schema);\n             }\n \n+            List<Object> values = attr.getValue();\n+            for (MappingItemTransformer transformer : getMappingItemTransformers(mappingItems.get(schema))) {\n+                values = transformer.beforeSync(values);\n+            }\n+\n             AttributeCond.Type type;\n             String expression = null;\n \n-            if (value.getValue() == null || value.getValue().isEmpty()\n-                    || (value.getValue().size() == 1 && value.getValue().get(0) == null)) {\n-\n+            if (values == null || values.isEmpty() || (values.size() == 1 && values.get(0) == null)) {\n                 type = AttributeCond.Type.ISNULL;\n             } else {\n                 type = AttributeCond.Type.EQ;\n-                expression = value.getValue().size() > 1\n-                        ? value.getValue().toString()\n-                        : value.getValue().get(0).toString();\n+                expression = values.size() > 1\n+                        ? values.toString()\n+                        : values.get(0).toString();\n             }\n \n             SearchCond nodeCond;\n-            // users: just id or username can be selected to be used\n-            // groups: just id or name can be selected to be used\n+            // users: just key or username can be selected\n+            // groups: just key or name can be selected\n+            // any objects: just key can be selected\n             if (\"key\".equalsIgnoreCase(schema)\n                     || \"username\".equalsIgnoreCase(schema) || \"name\".equalsIgnoreCase(schema)) {\n "},{"sha":"0c01254ae33844026ce3d6f7b733396eaad5075a","filename":"core/provisioning-java/src/main/java/org/apache/syncope/core/provisioning/java/sync/SyncUtils.java","status":"modified","additions":23,"deletions":14,"changes":37,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/72e6ceb0624a90a9b63bafce37c04104c7391d79/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fsync%2FSyncUtils.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/72e6ceb0624a90a9b63bafce37c04104c7391d79/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fsync%2FSyncUtils.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fprovisioning-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fprovisioning%2Fjava%2Fsync%2FSyncUtils.java?ref=72e6ceb0624a90a9b63bafce37c04104c7391d79","patch":"@@ -24,7 +24,6 @@\n import org.apache.commons.lang3.StringUtils;\n import org.apache.syncope.common.lib.SyncopeConstants;\n import org.apache.syncope.common.lib.types.AnyTypeKind;\n-import org.apache.syncope.common.lib.types.MappingPurpose;\n import org.apache.syncope.common.lib.policy.SyncPolicySpec;\n import org.apache.syncope.core.misc.MappingUtils;\n import org.apache.syncope.core.misc.serialization.POJOHelper;\n@@ -49,6 +48,7 @@\n import org.apache.syncope.core.persistence.api.entity.task.ProvisioningTask;\n import org.apache.syncope.core.persistence.api.entity.user.User;\n import org.apache.syncope.core.provisioning.api.Connector;\n+import org.apache.syncope.core.provisioning.api.data.MappingItemTransformer;\n import org.apache.syncope.core.provisioning.api.sync.SyncCorrelationRule;\n import org.identityconnectors.framework.common.objects.Attribute;\n import org.identityconnectors.framework.common.objects.AttributeUtil;\n@@ -128,7 +128,7 @@ public boolean handle(final ConnectorObject obj) {\n                         return found.add(obj);\n                     }\n                 },\n-                connector.getOperationOptions(MappingUtils.getMappingItems(provision, MappingPurpose.SYNCHRONIZATION)));\n+                connector.getOperationOptions(MappingUtils.getSyncMappingItems(provision)));\n \n         if (found.isEmpty()) {\n             LOG.debug(\"No {} found on {} with __NAME__ {}\", provision.getObjectClass(), resource, name);\n@@ -172,6 +172,15 @@ private List<Long> findByConnObjectKeyItem(\n         List<Long> result = new ArrayList<>();\n \n         MappingItem connObjectKeyItem = MappingUtils.getConnObjectKeyItem(provision);\n+\n+        String transfUid = uid;\n+        for (MappingItemTransformer transformer : MappingUtils.getMappingItemTransformers(connObjectKeyItem)) {\n+            List<Object> output = transformer.beforeSync(Collections.<Object>singletonList(transfUid));\n+            if (output != null && !output.isEmpty()) {\n+                transfUid = output.get(0).toString();\n+            }\n+        }\n+\n         switch (connObjectKeyItem.getIntMappingType()) {\n             case UserPlainSchema:\n             case GroupPlainSchema:\n@@ -180,13 +189,13 @@ private List<Long> findByConnObjectKeyItem(\n \n                 PlainSchema schema = plainSchemaDAO.find(connObjectKeyItem.getIntAttrName());\n                 if (schema == null) {\n-                    value.setStringValue(uid);\n+                    value.setStringValue(transfUid);\n                 } else {\n                     try {\n-                        value.parseValue(schema, uid);\n+                        value.parseValue(schema, transfUid);\n                     } catch (ParsingValidationException e) {\n-                        LOG.error(\"While parsing provided __UID__ {}\", uid, e);\n-                        value.setStringValue(uid);\n+                        LOG.error(\"While parsing provided __UID__ {}\", transfUid, e);\n+                        value.setStringValue(transfUid);\n                     }\n                 }\n \n@@ -200,7 +209,7 @@ private List<Long> findByConnObjectKeyItem(\n             case UserDerivedSchema:\n             case GroupDerivedSchema:\n             case AnyObjectDerivedSchema:\n-                anys = getAnyDAO(connObjectKeyItem).findByDerAttrValue(connObjectKeyItem.getIntAttrName(), uid);\n+                anys = getAnyDAO(connObjectKeyItem).findByDerAttrValue(connObjectKeyItem.getIntAttrName(), transfUid);\n                 for (Any<?, ?, ?> any : anys) {\n                     result.add(any.getKey());\n                 }\n@@ -209,21 +218,21 @@ private List<Long> findByConnObjectKeyItem(\n             case UserKey:\n             case GroupKey:\n             case AnyObjectKey:\n-                Any<?, ?, ?> any = getAnyDAO(connObjectKeyItem).find(Long.parseLong(uid));\n+                Any<?, ?, ?> any = getAnyDAO(connObjectKeyItem).find(Long.parseLong(transfUid));\n                 if (any != null) {\n                     result.add(any.getKey());\n                 }\n                 break;\n \n             case Username:\n-                User user = userDAO.find(uid);\n+                User user = userDAO.find(transfUid);\n                 if (user != null) {\n                     result.add(user.getKey());\n                 }\n                 break;\n \n             case GroupName:\n-                Group group = groupDAO.find(uid);\n+                Group group = groupDAO.find(transfUid);\n                 if (group != null) {\n                     result.add(group.getKey());\n                 }\n@@ -240,12 +249,12 @@ private List<Long> findByCorrelationRule(\n             final ConnectorObject connObj, final SyncCorrelationRule rule, final AnyTypeKind type) {\n \n         List<Long> result = new ArrayList<>();\n-\n-        List<Any<?, ?, ?>> anys = searchDAO.search(\n+        for (Any<?, ?, ?> any : searchDAO.search(\n                 SyncopeConstants.FULL_ADMIN_REALMS,\n                 rule.getSearchCond(connObj),\n-                Collections.<OrderByClause>emptyList(), type);\n-        for (Any<?, ?, ?> any : anys) {\n+                Collections.<OrderByClause>emptyList(),\n+                type)) {\n+\n             result.add(any.getKey());\n         }\n "},{"sha":"c620541b67369f18f3299b1ee53b6b29b73c1852","filename":"fit/core-reference/src/main/java/org/apache/syncope/fit/core/reference/PrefixMappingItemTransformer.java","status":"added","additions":55,"deletions":0,"changes":55,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/72e6ceb0624a90a9b63bafce37c04104c7391d79/fit%2Fcore-reference%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2Freference%2FPrefixMappingItemTransformer.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/72e6ceb0624a90a9b63bafce37c04104c7391d79/fit%2Fcore-reference%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2Freference%2FPrefixMappingItemTransformer.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/fit%2Fcore-reference%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2Freference%2FPrefixMappingItemTransformer.java?ref=72e6ceb0624a90a9b63bafce37c04104c7391d79","patch":"@@ -0,0 +1,55 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.fit.core.reference;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.syncope.core.persistence.api.entity.PlainAttrValue;\n+import org.apache.syncope.core.provisioning.java.data.DefaultMappingItemTransformer;\n+\n+public class PrefixMappingItemTransformer extends DefaultMappingItemTransformer {\n+\n+    public static final String PREFIX = \"PREFIX_\";\n+\n+    @Override\n+    public List<PlainAttrValue> beforePropagation(final List<PlainAttrValue> values) {\n+        if (values == null || values.isEmpty() || values.get(0).getStringValue() == null) {\n+            return super.beforePropagation(values);\n+        } else {\n+            String value = values.get(0).getStringValue();\n+            values.get(0).setStringValue(PREFIX + value);\n+\n+            return values;\n+        }\n+    }\n+\n+    @Override\n+    public List<Object> beforeSync(final List<Object> values) {\n+        if (values == null || values.isEmpty() || values.get(0) == null) {\n+            return super.beforeSync(values);\n+        } else {\n+            List<Object> newValues = new ArrayList<>(values);\n+            newValues.set(0, StringUtils.substringAfter(values.get(0).toString(), PREFIX));\n+\n+            return newValues;\n+        }\n+    }\n+\n+}"},{"sha":"75049da04384d681e8b53a3916863ecdfbf17477","filename":"fit/core-reference/src/test/java/org/apache/syncope/fit/core/reference/SyncTaskITCase.java","status":"modified","additions":67,"deletions":34,"changes":101,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/72e6ceb0624a90a9b63bafce37c04104c7391d79/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2Freference%2FSyncTaskITCase.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/72e6ceb0624a90a9b63bafce37c04104c7391d79/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2Freference%2FSyncTaskITCase.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/fit%2Fcore-reference%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Ffit%2Fcore%2Freference%2FSyncTaskITCase.java?ref=72e6ceb0624a90a9b63bafce37c04104c7391d79","patch":"@@ -32,6 +32,7 @@\n import javax.ws.rs.core.Response;\n import org.apache.commons.collections4.CollectionUtils;\n import org.apache.commons.collections4.Predicate;\n+import org.apache.commons.lang3.SerializationUtils;\n import org.apache.syncope.client.lib.SyncopeClient;\n import org.apache.syncope.common.lib.SyncopeClientException;\n import org.apache.syncope.common.lib.SyncopeConstants;\n@@ -49,6 +50,7 @@\n import org.apache.syncope.common.lib.to.GroupTO;\n import org.apache.syncope.common.lib.to.ProvisionTO;\n import org.apache.syncope.common.lib.policy.SyncPolicyTO;\n+import org.apache.syncope.common.lib.to.MappingItemTO;\n import org.apache.syncope.common.lib.to.SyncTaskTO;\n import org.apache.syncope.common.lib.to.TaskExecTO;\n import org.apache.syncope.common.lib.to.UserTO;\n@@ -356,47 +358,78 @@ public void reconcileFromLDAP() {\n \n     @Test\n     public void reconcileFromScriptedSQL() {\n-        // 0. reset sync token\n+        // 0. reset sync token and set MappingItemTransformer\n         ResourceTO resource = resourceService.read(RESOURCE_NAME_DBSCRIPTED);\n+        ResourceTO originalResource = SerializationUtils.clone(resource);\n         ProvisionTO provision = resource.getProvision(\"PRINTER\");\n         assertNotNull(provision);\n \n-        provision.setSyncToken(null);\n-        resourceService.update(resource);\n-\n-        // 1. create printer on external resource\n-        AnyObjectTO anyObjectTO = AnyObjectITCase.getSampleTO(\"sync\");\n-        anyObjectTO = createAnyObject(anyObjectTO);\n-        assertNotNull(anyObjectTO);\n-\n-        // 2. unlink any existing printer and delete from Syncope (printer is now only on external resource)\n-        PagedResult<AnyObjectTO> matchingPrinters = anyObjectService.search(\n-                SyncopeClient.getAnySearchQueryBuilder().realm(SyncopeConstants.ROOT_REALM).\n-                fiql(SyncopeClient.getAnyObjectSearchConditionBuilder().type(\"PRINTER\").and().\n-                        is(\"location\").equalTo(\"sync*\").query()).build());\n-        assertTrue(matchingPrinters.getSize() > 0);\n-        for (AnyObjectTO printer : matchingPrinters.getResult()) {\n-            DeassociationPatch deassociationPatch = new DeassociationPatch();\n-            deassociationPatch.setKey(printer.getKey());\n-            deassociationPatch.setAction(ResourceDeassociationAction.UNLINK);\n-            deassociationPatch.getResources().add(RESOURCE_NAME_DBSCRIPTED);\n-            anyObjectService.deassociate(deassociationPatch);\n-            anyObjectService.delete(printer.getKey());\n-        }\n+        try {\n+            provision.setSyncToken(null);\n+\n+            MappingItemTO mappingItem = CollectionUtils.find(\n+                    provision.getMapping().getItems(), new Predicate<MappingItemTO>() {\n+\n+                        @Override\n+                        public boolean evaluate(final MappingItemTO object) {\n+                            return \"location\".equals(object.getIntAttrName());\n+                        }\n+                    });\n+            assertNotNull(mappingItem);\n+            mappingItem.getMappingItemTransformerClassNames().clear();\n+            mappingItem.getMappingItemTransformerClassNames().add(PrefixMappingItemTransformer.class.getName());\n+\n+            resourceService.update(resource);\n+\n+            // 1. create printer on external resource\n+            AnyObjectTO anyObjectTO = AnyObjectITCase.getSampleTO(\"sync\");\n+            String originalLocation = anyObjectTO.getPlainAttrMap().get(\"location\").getValues().get(0);\n+            assertFalse(originalLocation.startsWith(PrefixMappingItemTransformer.PREFIX));\n+\n+            anyObjectTO = createAnyObject(anyObjectTO);\n+            assertNotNull(anyObjectTO);\n+\n+            // 2. verify that PrefixMappingItemTransformer was applied during propagation\n+            // (location starts with given prefix on external resource)\n+            ConnObjectTO connObjectTO = resourceService.\n+                    readConnObject(RESOURCE_NAME_DBSCRIPTED, anyObjectTO.getType(), anyObjectTO.getKey());\n+            assertFalse(anyObjectTO.getPlainAttrMap().get(\"location\").getValues().get(0).\n+                    startsWith(PrefixMappingItemTransformer.PREFIX));\n+            assertTrue(connObjectTO.getPlainAttrMap().get(\"location\").getValues().get(0).\n+                    startsWith(PrefixMappingItemTransformer.PREFIX));\n+\n+            // 3. unlink any existing printer and delete from Syncope (printer is now only on external resource)\n+            PagedResult<AnyObjectTO> matchingPrinters = anyObjectService.search(\n+                    SyncopeClient.getAnySearchQueryBuilder().realm(SyncopeConstants.ROOT_REALM).\n+                    fiql(SyncopeClient.getAnyObjectSearchConditionBuilder().type(\"PRINTER\").and().\n+                            is(\"location\").equalTo(\"sync*\").query()).build());\n+            assertTrue(matchingPrinters.getSize() > 0);\n+            for (AnyObjectTO printer : matchingPrinters.getResult()) {\n+                DeassociationPatch deassociationPatch = new DeassociationPatch();\n+                deassociationPatch.setKey(printer.getKey());\n+                deassociationPatch.setAction(ResourceDeassociationAction.UNLINK);\n+                deassociationPatch.getResources().add(RESOURCE_NAME_DBSCRIPTED);\n+                anyObjectService.deassociate(deassociationPatch);\n+                anyObjectService.delete(printer.getKey());\n+            }\n \n-        // 3. synchronize\n-        execProvisioningTask(taskService, 28L, 50, false);\n+            // 4. synchronize\n+            execProvisioningTask(taskService, 28L, 50, false);\n \n-        // 4. verify that printer was re-created in Syncope\n-        matchingPrinters = anyObjectService.search(\n-                SyncopeClient.getAnySearchQueryBuilder().realm(SyncopeConstants.ROOT_REALM).\n-                fiql(SyncopeClient.getAnyObjectSearchConditionBuilder().type(\"PRINTER\").and().\n-                        is(\"location\").equalTo(\"sync*\").query()).build());\n-        assertTrue(matchingPrinters.getSize() > 0);\n+            // 5. verify that printer was re-created in Syncope (implies that location does not start with given prefix,\n+            // hence PrefixMappingItemTransformer was applied during sync)\n+            matchingPrinters = anyObjectService.search(\n+                    SyncopeClient.getAnySearchQueryBuilder().realm(SyncopeConstants.ROOT_REALM).\n+                    fiql(SyncopeClient.getAnyObjectSearchConditionBuilder().type(\"PRINTER\").and().\n+                            is(\"location\").equalTo(\"sync*\").query()).build());\n+            assertTrue(matchingPrinters.getSize() > 0);\n \n-        // 5. verify that synctoken was updated\n-        assertNotNull(\n-                resourceService.read(RESOURCE_NAME_DBSCRIPTED).getProvision(anyObjectTO.getType()).getSyncToken());\n+            // 6. verify that synctoken was updated\n+            assertNotNull(\n+                    resourceService.read(RESOURCE_NAME_DBSCRIPTED).getProvision(anyObjectTO.getType()).getSyncToken());\n+        } finally {\n+            resourceService.update(originalResource);\n+        }\n     }\n \n     @Test"}]}