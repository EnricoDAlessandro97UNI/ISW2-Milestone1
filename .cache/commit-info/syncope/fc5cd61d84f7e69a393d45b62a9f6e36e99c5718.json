{"sha":"fc5cd61d84f7e69a393d45b62a9f6e36e99c5718","node_id":"MDY6Q29tbWl0NjM2ODc5MDYyOmZjNWNkNjFkODRmN2U2OWEzOTNkNDViNjJhOWY2ZTM2ZTk5YzU3MTg=","commit":{"author":{"name":"Unknown","email":"unknown@apache.org","date":"2011-07-27T09:50:09Z"},"committer":{"name":"Unknown","email":"unknown@apache.org","date":"2011-07-27T09:50:09Z"},"message":"Preparing environment for (issue #73)\n\ngit-svn-id: https://svn.apache.org/repos/asf/incubator/syncope/trunk@1247049 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"4160c76db2076f61327d112efe8e7f3e1d693840","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/git/trees/4160c76db2076f61327d112efe8e7f3e1d693840"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/git/commits/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718","html_url":"https://github.com/EnricoDAlessandro97UNI/syncope/commit/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/comments","author":null,"committer":null,"parents":[{"sha":"b9bb64fe180a0f28ade487385cf48a1f9da6f919","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/b9bb64fe180a0f28ade487385cf48a1f9da6f919","html_url":"https://github.com/EnricoDAlessandro97UNI/syncope/commit/b9bb64fe180a0f28ade487385cf48a1f9da6f919"}],"stats":{"total":2164,"additions":2006,"deletions":158},"files":[{"sha":"9b25e1bb95816cacbbbf1daa78fa80ded09fe38d","filename":"archetype/src/main/resources/archetype-resources/core/src/test/resources/content.xml","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/archetype%2Fsrc%2Fmain%2Fresources%2Farchetype-resources%2Fcore%2Fsrc%2Ftest%2Fresources%2Fcontent.xml","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/archetype%2Fsrc%2Fmain%2Fresources%2Farchetype-resources%2Fcore%2Fsrc%2Ftest%2Fresources%2Fcontent.xml","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/archetype%2Fsrc%2Fmain%2Fresources%2Farchetype-resources%2Fcore%2Fsrc%2Ftest%2Fresources%2Fcontent.xml?ref=fc5cd61d84f7e69a393d45b62a9f6e36e99c5718","patch":"@@ -397,6 +397,7 @@\n     <Entitlement name=\"TASK_LIST\"/>\n     <Entitlement name=\"TASK_EXECUTE\"/>\n     <Entitlement name=\"TASK_READ\"/>\n+    <Entitlement name=\"TASK_UPDATE\"/>\n     <Entitlement name=\"TASK_DELETE\"/>\n     <Entitlement name=\"LOG_LIST\"/>\n     <Entitlement name=\"LOG_SET_LEVEL\"/>"},{"sha":"619007977cbc91d224eac25eb78e59423efacca9","filename":"client/src/main/java/org/syncope/client/mod/AbstractAttributableMod.java","status":"modified","additions":8,"deletions":2,"changes":10,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/client%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fclient%2Fmod%2FAbstractAttributableMod.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/client%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fclient%2Fmod%2FAbstractAttributableMod.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/client%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fclient%2Fmod%2FAbstractAttributableMod.java?ref=fc5cd61d84f7e69a393d45b62a9f6e36e99c5718","patch":"@@ -20,6 +20,8 @@\n \n public abstract class AbstractAttributableMod extends AbstractBaseBean {\n \n+    private static final long serialVersionUID = 3241118574016303198L;\n+\n     protected long id;\n \n     protected Set<AttributeMod> attributesToBeUpdated;\n@@ -39,6 +41,8 @@ public abstract class AbstractAttributableMod extends AbstractBaseBean {\n     protected Set<String> resourcesToBeRemoved;\n \n     public AbstractAttributableMod() {\n+        super();\n+\n         attributesToBeUpdated = new HashSet<AttributeMod>();\n         attributesToBeRemoved = new HashSet<String>();\n         derivedAttributesToBeAdded = new HashSet<String>();\n@@ -171,15 +175,17 @@ public Set<String> getVirtualAttributesToBeAdded() {\n         return virtualAttributesToBeAdded;\n     }\n \n-    public void setVirtualAttributesToBeAdded(Set<String> virtualAttributesToBeAdded) {\n+    public void setVirtualAttributesToBeAdded(\n+            Set<String> virtualAttributesToBeAdded) {\n         this.virtualAttributesToBeAdded = virtualAttributesToBeAdded;\n     }\n \n     public Set<String> getVirtualAttributesToBeRemoved() {\n         return virtualAttributesToBeRemoved;\n     }\n \n-    public void setVirtualAttributesToBeRemoved(Set<String> virtualAttributesToBeRemoved) {\n+    public void setVirtualAttributesToBeRemoved(\n+            Set<String> virtualAttributesToBeRemoved) {\n         this.virtualAttributesToBeRemoved = virtualAttributesToBeRemoved;\n     }\n }"},{"sha":"f67fe249d020c4a37652618d28dd20eb761cb51a","filename":"client/src/main/java/org/syncope/client/mod/AttributeMod.java","status":"modified","additions":6,"deletions":0,"changes":6,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/client%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fclient%2Fmod%2FAttributeMod.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/client%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fclient%2Fmod%2FAttributeMod.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/client%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fclient%2Fmod%2FAttributeMod.java?ref=fc5cd61d84f7e69a393d45b62a9f6e36e99c5718","patch":"@@ -20,11 +20,17 @@\n \n public class AttributeMod extends AbstractBaseBean {\n \n+    private static final long serialVersionUID = -913573979137431406L;\n+\n     private String schema;\n+\n     private List<String> valuesToBeAdded;\n+\n     private List<String> valuesToBeRemoved;\n \n     public AttributeMod() {\n+        super();\n+\n         valuesToBeAdded = new ArrayList<String>();\n         valuesToBeRemoved = new ArrayList<String>();\n     }"},{"sha":"833966abbabebdda69f806438d0ea7776fc83491","filename":"client/src/main/java/org/syncope/client/mod/MembershipMod.java","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/client%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fclient%2Fmod%2FMembershipMod.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/client%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fclient%2Fmod%2FMembershipMod.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/client%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fclient%2Fmod%2FMembershipMod.java?ref=fc5cd61d84f7e69a393d45b62a9f6e36e99c5718","patch":"@@ -19,6 +19,8 @@\n \n public class MembershipMod extends AbstractAttributableMod {\n \n+    private static final long serialVersionUID = 2511869129977331525L;\n+\n     private long role;\n \n     public long getRole() {"},{"sha":"1f85cebee6de6a3d5539937914448458e8de72c4","filename":"client/src/main/java/org/syncope/client/mod/RoleMod.java","status":"modified","additions":4,"deletions":0,"changes":4,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/client%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fclient%2Fmod%2FRoleMod.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/client%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fclient%2Fmod%2FRoleMod.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/client%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fclient%2Fmod%2FRoleMod.java?ref=fc5cd61d84f7e69a393d45b62a9f6e36e99c5718","patch":"@@ -19,6 +19,8 @@\n \n public class RoleMod extends AbstractAttributableMod {\n \n+    private static final long serialVersionUID = 7455805264680210747L;\n+\n     private String name;\n \n     private boolean changeInheritAttributes;\n@@ -30,6 +32,8 @@ public class RoleMod extends AbstractAttributableMod {\n     private List<String> entitlements;\n \n     public RoleMod() {\n+        super();\n+\n         entitlements = new ArrayList<String>();\n     }\n "},{"sha":"30a47dcb63380d71818d8b0a643c82e790b2b786","filename":"client/src/main/java/org/syncope/client/mod/SchedTaskMod.java","status":"added","additions":42,"deletions":0,"changes":42,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/client%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fclient%2Fmod%2FSchedTaskMod.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/client%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fclient%2Fmod%2FSchedTaskMod.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/client%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fclient%2Fmod%2FSchedTaskMod.java?ref=fc5cd61d84f7e69a393d45b62a9f6e36e99c5718","patch":"@@ -0,0 +1,42 @@\n+/*\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ * \n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *  under the License.\n+ */\n+package org.syncope.client.mod;\n+\n+import org.syncope.client.AbstractBaseBean;\n+\n+public class SchedTaskMod extends AbstractBaseBean {\n+\n+    private static final long serialVersionUID = 6022252641152525953L;\n+\n+    private long id;\n+\n+    private String cronExpression;\n+\n+    public long getId() {\n+        return id;\n+    }\n+\n+    public void setId(long id) {\n+        this.id = id;\n+    }\n+\n+    public String getCronExpression() {\n+        return cronExpression;\n+    }\n+\n+    public void setCronExpression(String cronExpression) {\n+        this.cronExpression = cronExpression;\n+    }\n+}"},{"sha":"6b99f023ed2a70557dc0a613cab9512239e1195e","filename":"client/src/main/java/org/syncope/client/mod/SyncTaskMod.java","status":"added","additions":60,"deletions":0,"changes":60,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/client%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fclient%2Fmod%2FSyncTaskMod.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/client%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fclient%2Fmod%2FSyncTaskMod.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/client%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fclient%2Fmod%2FSyncTaskMod.java?ref=fc5cd61d84f7e69a393d45b62a9f6e36e99c5718","patch":"@@ -0,0 +1,60 @@\n+/*\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ * \n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *  under the License.\n+ */\n+package org.syncope.client.mod;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class SyncTaskMod extends SchedTaskMod {\n+\n+    private static final long serialVersionUID = 2194093947655403368L;\n+\n+    private List<String> defaultResources;\n+\n+    private List<Long> defaultRoles;\n+\n+    private boolean updateIdentities;\n+\n+    public SyncTaskMod() {\n+        super();\n+\n+        defaultResources = new ArrayList<String>();\n+        defaultRoles = new ArrayList<Long>();\n+    }\n+\n+    public List<String> getDefaultResources() {\n+        return defaultResources;\n+    }\n+\n+    public void setDefaultResources(List<String> defaultResources) {\n+        this.defaultResources = defaultResources;\n+    }\n+\n+    public List<Long> getDefaultRoles() {\n+        return defaultRoles;\n+    }\n+\n+    public void setDefaultRoles(List<Long> defaultRoles) {\n+        this.defaultRoles = defaultRoles;\n+    }\n+\n+    public boolean isUpdateIdentities() {\n+        return updateIdentities;\n+    }\n+\n+    public void setUpdateIdentities(boolean updateIdentities) {\n+        this.updateIdentities = updateIdentities;\n+    }\n+}"},{"sha":"efc7f9b147667f9f84b855ed5ce0a8a6038163bd","filename":"client/src/main/java/org/syncope/client/mod/UserMod.java","status":"modified","additions":6,"deletions":0,"changes":6,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/client%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fclient%2Fmod%2FUserMod.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/client%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fclient%2Fmod%2FUserMod.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/client%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fclient%2Fmod%2FUserMod.java?ref=fc5cd61d84f7e69a393d45b62a9f6e36e99c5718","patch":"@@ -19,11 +19,17 @@\n \n public class UserMod extends AbstractAttributableMod {\n \n+    private static final long serialVersionUID = 3081848906558106204L;\n+\n     private String password;\n+\n     private Set<MembershipMod> membershipsToBeAddeded;\n+\n     private Set<Long> membershipsToBeRemoved;\n \n     public UserMod() {\n+        super();\n+\n         membershipsToBeAddeded = new HashSet<MembershipMod>();\n         membershipsToBeRemoved = new HashSet<Long>();\n     }"},{"sha":"6f0e2a0851721dc522f95b0f85833c0191e3d37e","filename":"client/src/main/java/org/syncope/client/to/SchedTaskTO.java","status":"modified","additions":8,"deletions":4,"changes":12,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/client%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fclient%2Fto%2FSchedTaskTO.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/client%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fclient%2Fto%2FSchedTaskTO.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/client%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fclient%2Fto%2FSchedTaskTO.java?ref=fc5cd61d84f7e69a393d45b62a9f6e36e99c5718","patch":"@@ -45,18 +45,22 @@ public void setJobClassName(String jobClassName) {\n     }\n \n     public Date getLastExec() {\n-        return new Date(lastExec.getTime());\n+        return lastExec == null ? null : new Date(lastExec.getTime());\n     }\n \n     public void setLastExec(Date lastExec) {\n-        this.lastExec = new Date(lastExec.getTime());\n+        if (lastExec != null) {\n+            this.lastExec = new Date(lastExec.getTime());\n+        }\n     }\n \n     public Date getNextExec() {\n-        return new Date(nextExec.getTime());\n+        return nextExec == null ? null : new Date(nextExec.getTime());\n     }\n \n     public void setNextExec(Date nextExec) {\n-        this.nextExec = new Date(nextExec.getTime());\n+        if (nextExec != null) {\n+            this.nextExec = new Date(nextExec.getTime());\n+        }\n     }\n }"},{"sha":"918521530f6788ff4d95c78f9e22c68eb7ab8184","filename":"client/src/main/java/org/syncope/client/to/SyncTaskTO.java","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/client%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fclient%2Fto%2FSyncTaskTO.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/client%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fclient%2Fto%2FSyncTaskTO.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/client%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fclient%2Fto%2FSyncTaskTO.java?ref=fc5cd61d84f7e69a393d45b62a9f6e36e99c5718","patch":"@@ -19,6 +19,8 @@\n \n public class SyncTaskTO extends SchedTaskTO {\n \n+    private static final long serialVersionUID = -2143537546915809016L;\n+\n     private String resource;\n \n     private List<String> defaultResources;"},{"sha":"7867bb2070235e4dee1c3e2ba1e87f58bd99ad0d","filename":"client/src/main/java/org/syncope/client/to/TaskExecTO.java","status":"modified","additions":8,"deletions":4,"changes":12,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/client%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fclient%2Fto%2FTaskExecTO.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/client%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fclient%2Fto%2FTaskExecTO.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/client%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fclient%2Fto%2FTaskExecTO.java?ref=fc5cd61d84f7e69a393d45b62a9f6e36e99c5718","patch":"@@ -34,11 +34,13 @@ public class TaskExecTO extends AbstractBaseBean {\n     private long task;\n \n     public Date getEndDate() {\n-        return endDate;\n+        return endDate == null ? null : new Date(endDate.getTime());\n     }\n \n     public void setEndDate(Date endDate) {\n-        this.endDate = endDate;\n+        if (endDate != null) {\n+            this.endDate = new Date(endDate.getTime());\n+        }\n     }\n \n     public long getId() {\n@@ -58,11 +60,13 @@ public void setMessage(String message) {\n     }\n \n     public Date getStartDate() {\n-        return startDate;\n+        return startDate == null ? null : new Date(startDate.getTime());\n     }\n \n     public void setStartDate(Date startDate) {\n-        this.startDate = startDate;\n+        if (startDate != null) {\n+            this.startDate = new Date(startDate.getTime());\n+        }\n     }\n \n     public String getStatus() {"},{"sha":"e155e20010d37d7fa5b0363433978a4a7c039d95","filename":"client/src/main/java/org/syncope/types/SyncopeClientExceptionType.java","status":"modified","additions":6,"deletions":0,"changes":6,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/client%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Ftypes%2FSyncopeClientExceptionType.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/client%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Ftypes%2FSyncopeClientExceptionType.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/client%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Ftypes%2FSyncopeClientExceptionType.java?ref=fc5cd61d84f7e69a393d45b62a9f6e36e99c5718","patch":"@@ -49,6 +49,9 @@ public enum SyncopeClientExceptionType {\n     InvalidSchemaMapping(\n     \"Syncope.InvalidSchemaMapping\",\n     \"\"),\n+    InvalidTask(\n+    \"Syncope.InvalidTask\",\n+    \"Syncope.InvalidTask.element\"),\n     InvalidUpdate(\n     \"Syncope.InvalidUpdate\",\n     \"Syncope.InvalidUpdate.name\"),\n@@ -67,6 +70,9 @@ public enum SyncopeClientExceptionType {\n     RequiredValuesMissing(\n     \"Syncope.RequiredValuesMissing\",\n     \"Syncope.RequiredValuesMissing.attributeName\"),\n+    Scheduling(\n+    \"Syncope.Scheduling\",\n+    \"Syncope.Scheduling.message\"),\n     UnauthorizedRole(\n     \"Syncope.UnauthorizedRole\",\n     \"Syncope.UnauthorizedRole.id\"),"},{"sha":"115eea9c2e0c1ee110954e146c5a3e4ef0f353c6","filename":"core/pom.xml","status":"modified","additions":7,"deletions":0,"changes":7,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/core%2Fpom.xml","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/core%2Fpom.xml","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fpom.xml?ref=fc5cd61d84f7e69a393d45b62a9f6e36e99c5718","patch":"@@ -144,6 +144,12 @@\n             <groupId>org.springframework.security</groupId>\n             <artifactId>spring-security-config</artifactId>\n         </dependency>\n+        <dependency>\n+            <groupId>javax.inject</groupId>\n+            <artifactId>inject-api</artifactId>\n+            <version>1.0.0-PRD</version>\n+            <scope>compile</scope>\n+        </dependency>\n \n         <dependency>\n             <groupId>cglib</groupId>\n@@ -530,6 +536,7 @@\n                         <type>standalone</type>\n                         <properties>\n                             <cargo.servlet.port>${cargo.servlet.port}</cargo.servlet.port>\n+<!--                            <cargo.jvmargs>-Xdebug -Xrunjdwp:transport=dt_socket,address=8000,server=y,suspend=n</cargo.jvmargs>-->\n                         </properties>\n                         <deployables>\n                             <deployable>"},{"sha":"0a08d13af753ee364c5f4bb4fc680022f1fba077","filename":"core/src/main/java/org/springframework/beans/factory/support/DefaultListableBeanFactory.java","status":"added","additions":1059,"deletions":0,"changes":1059,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fbeans%2Ffactory%2Fsupport%2FDefaultListableBeanFactory.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fbeans%2Ffactory%2Fsupport%2FDefaultListableBeanFactory.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fbeans%2Ffactory%2Fsupport%2FDefaultListableBeanFactory.java?ref=fc5cd61d84f7e69a393d45b62a9f6e36e99c5718","patch":"@@ -0,0 +1,1059 @@\n+/*\n+ * Copyright 2002-2010 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.beans.factory.support;\n+\n+import java.io.NotSerializableException;\n+import java.io.ObjectStreamException;\n+import java.io.Serializable;\n+import java.lang.annotation.Annotation;\n+import java.lang.ref.Reference;\n+import java.lang.ref.WeakReference;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import javax.inject.Provider;\n+\n+import org.springframework.beans.BeansException;\n+import org.springframework.beans.FatalBeanException;\n+import org.springframework.beans.TypeConverter;\n+import org.springframework.beans.factory.BeanCreationException;\n+import org.springframework.beans.factory.BeanCurrentlyInCreationException;\n+import org.springframework.beans.factory.BeanDefinitionStoreException;\n+import org.springframework.beans.factory.BeanFactory;\n+import org.springframework.beans.factory.BeanFactoryAware;\n+import org.springframework.beans.factory.BeanFactoryUtils;\n+import org.springframework.beans.factory.CannotLoadBeanClassException;\n+import org.springframework.beans.factory.FactoryBean;\n+import org.springframework.beans.factory.NoSuchBeanDefinitionException;\n+import org.springframework.beans.factory.ObjectFactory;\n+import org.springframework.beans.factory.SmartFactoryBean;\n+import org.springframework.beans.factory.config.BeanDefinition;\n+import org.springframework.beans.factory.config.BeanDefinitionHolder;\n+import org.springframework.beans.factory.config.ConfigurableBeanFactory;\n+import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;\n+import org.springframework.beans.factory.config.DependencyDescriptor;\n+import org.springframework.core.annotation.AnnotationUtils;\n+import org.springframework.util.Assert;\n+import org.springframework.util.ObjectUtils;\n+import org.springframework.util.StringUtils;\n+\n+/*\n+ * Variant of standard DefaultListableBeanFactory (Spring 3.0.5-RELEASE) where\n+ * \n+ * private final List<String> beanDefinitionNames = new ArrayList<String>();\n+ * \n+ * is replaced by\n+ * \n+ * private final List<String> beanDefinitionNames = new CopyOnWriteArrayList<String>();\n+ * \n+ * @see https://jira.springsource.org/browse/SPR-7757\n+ */\n+/**\n+ * Default implementation of the\n+ * {@link org.springframework.beans.factory.ListableBeanFactory} and\n+ * {@link BeanDefinitionRegistry} interfaces: a full-fledged bean factory\n+ * based on bean definition objects.\n+ *\n+ * <p>Typical usage is registering all bean definitions first (possibly read\n+ * from a bean definition file), before accessing beans. Bean definition lookup\n+ * is therefore an inexpensive operation in a local bean definition table,\n+ * operating on pre-built bean definition metadata objects.\n+ *\n+ * <p>Can be used as a standalone bean factory, or as a superclass for custom\n+ * bean factories. Note that readers for specific bean definition formats are\n+ * typically implemented separately rather than as bean factory subclasses:\n+ * see for example {@link PropertiesBeanDefinitionReader} and\n+ * {@link org.springframework.beans.factory.xml.XmlBeanDefinitionReader}.\n+ *\n+ * <p>For an alternative implementation of the\n+ * {@link org.springframework.beans.factory.ListableBeanFactory} interface,\n+ * have a look at {@link StaticListableBeanFactory}, which manages existing\n+ * bean instances rather than creating new ones based on bean definitions.\n+ *\n+ * @author Rod Johnson\n+ * @author Juergen Hoeller\n+ * @author Sam Brannen\n+ * @author Costin Leau\n+ * @since 16 April 2001\n+ * @see StaticListableBeanFactory\n+ * @see PropertiesBeanDefinitionReader\n+ * @see org.springframework.beans.factory.xml.XmlBeanDefinitionReader\n+ */\n+public class DefaultListableBeanFactory extends AbstractAutowireCapableBeanFactory\n+\t\timplements ConfigurableListableBeanFactory, BeanDefinitionRegistry, Serializable {\n+\n+\tprivate static Class javaxInjectProviderClass = null;\n+\n+\tstatic {\n+\t\tClassLoader cl = DefaultListableBeanFactory.class.getClassLoader();\n+\t\ttry {\n+\t\t\tjavaxInjectProviderClass = cl.loadClass(\"javax.inject.Provider\");\n+\t\t}\n+\t\tcatch (ClassNotFoundException ex) {\n+\t\t\t// JSR-330 API not available - Provider interface simply not supported then.\n+\t\t}\n+\t}\n+\n+\n+\t/** Map from serialized id to factory instance */\n+\tprivate static final Map<String, Reference<DefaultListableBeanFactory>> serializableFactories =\n+\t\t\tnew ConcurrentHashMap<String, Reference<DefaultListableBeanFactory>>();\n+\n+\t/** Optional id for this factory, for serialization purposes */\n+\tprivate String serializationId;\n+\n+\t/** Whether to allow re-registration of a different definition with the same name */\n+\tprivate boolean allowBeanDefinitionOverriding = true;\n+\n+\t/** Whether to allow eager class loading even for lazy-init beans */\n+\tprivate boolean allowEagerClassLoading = true;\n+\n+\t/** Resolver to use for checking if a bean definition is an autowire candidate */\n+\tprivate AutowireCandidateResolver autowireCandidateResolver = new SimpleAutowireCandidateResolver();\n+\n+\t/** Map from dependency type to corresponding autowired value */\n+\tprivate final Map<Class, Object> resolvableDependencies = new HashMap<Class, Object>();\n+\n+\t/** Map of bean definition objects, keyed by bean name */\n+\tprivate final Map<String, BeanDefinition> beanDefinitionMap = new ConcurrentHashMap<String, BeanDefinition>();\n+\n+\t/** List of bean definition names, in registration order */\n+\tprivate final List<String> beanDefinitionNames = new CopyOnWriteArrayList<String>();\n+\n+\t/** Whether bean definition metadata may be cached for all beans */\n+\tprivate boolean configurationFrozen = false;\n+\n+\t/** Cached array of bean definition names in case of frozen configuration */\n+\tprivate String[] frozenBeanDefinitionNames;\n+\n+\n+\t/**\n+\t * Create a new DefaultListableBeanFactory.\n+\t */\n+\tpublic DefaultListableBeanFactory() {\n+\t\tsuper();\n+\t}\n+\n+\t/**\n+\t * Create a new DefaultListableBeanFactory with the given parent.\n+\t * @param parentBeanFactory the parent BeanFactory\n+\t */\n+\tpublic DefaultListableBeanFactory(BeanFactory parentBeanFactory) {\n+\t\tsuper(parentBeanFactory);\n+\t}\n+\n+\n+\t/**\n+\t * Specify an id for serialization purposes, allowing this BeanFactory to be\n+\t * deserialized from this id back into the BeanFactory object, if needed.\n+\t */\n+\tpublic void setSerializationId(String serializationId) {\n+\t\tif (serializationId != null) {\n+\t\t\tserializableFactories.put(serializationId, new WeakReference<DefaultListableBeanFactory>(this));\n+\t\t}\n+\t\telse if (this.serializationId != null) {\n+\t\t\tserializableFactories.remove(this.serializationId);\n+\t\t}\n+\t\tthis.serializationId = serializationId;\n+\t}\n+\n+\t/**\n+\t * Set whether it should be allowed to override bean definitions by registering\n+\t * a different definition with the same name, automatically replacing the former.\n+\t * If not, an exception will be thrown. This also applies to overriding aliases.\n+\t * <p>Default is \"true\".\n+\t * @see #registerBeanDefinition\n+\t */\n+\tpublic void setAllowBeanDefinitionOverriding(boolean allowBeanDefinitionOverriding) {\n+\t\tthis.allowBeanDefinitionOverriding = allowBeanDefinitionOverriding;\n+\t}\n+\n+\t/**\n+\t * Set whether the factory is allowed to eagerly load bean classes\n+\t * even for bean definitions that are marked as \"lazy-init\".\n+\t * <p>Default is \"true\". Turn this flag off to suppress class loading\n+\t * for lazy-init beans unless such a bean is explicitly requested.\n+\t * In particular, by-type lookups will then simply ignore bean definitions\n+\t * without resolved class name, instead of loading the bean classes on\n+\t * demand just to perform a type check.\n+\t * @see AbstractBeanDefinition#setLazyInit\n+\t */\n+\tpublic void setAllowEagerClassLoading(boolean allowEagerClassLoading) {\n+\t\tthis.allowEagerClassLoading = allowEagerClassLoading;\n+\t}\n+\n+\t/**\n+\t * Set a custom autowire candidate resolver for this BeanFactory to use\n+\t * when deciding whether a bean definition should be considered as a\n+\t * candidate for autowiring.\n+\t */\n+\tpublic void setAutowireCandidateResolver(final AutowireCandidateResolver autowireCandidateResolver) {\n+\t\tAssert.notNull(autowireCandidateResolver, \"AutowireCandidateResolver must not be null\");\n+\t\tif (autowireCandidateResolver instanceof BeanFactoryAware) {\n+\t\t\tif (System.getSecurityManager() != null) {\n+\t\t\t\tfinal BeanFactory target = this;\n+\t\t\t\tAccessController.doPrivileged(new PrivilegedAction<Object>() {\n+\t\t\t\t\tpublic Object run() {\n+\t\t\t\t\t\t((BeanFactoryAware) autowireCandidateResolver).setBeanFactory(target);\n+\t\t\t\t\t\treturn null;\n+\t\t\t\t\t}\n+\t\t\t\t}, getAccessControlContext());\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\t((BeanFactoryAware) autowireCandidateResolver).setBeanFactory(this);\n+\t\t\t}\n+\t\t}\n+\t\tthis.autowireCandidateResolver = autowireCandidateResolver;\n+\t}\n+\n+\t/**\n+\t * Return the autowire candidate resolver for this BeanFactory (never <code>null</code>).\n+\t */\n+\tpublic AutowireCandidateResolver getAutowireCandidateResolver() {\n+\t\treturn this.autowireCandidateResolver;\n+\t}\n+\n+\n+\t@Override\n+\tpublic void copyConfigurationFrom(ConfigurableBeanFactory otherFactory) {\n+\t\tsuper.copyConfigurationFrom(otherFactory);\n+\t\tif (otherFactory instanceof DefaultListableBeanFactory) {\n+\t\t\tDefaultListableBeanFactory otherListableFactory = (DefaultListableBeanFactory) otherFactory;\n+\t\t\tthis.allowBeanDefinitionOverriding = otherListableFactory.allowBeanDefinitionOverriding;\n+\t\t\tthis.allowEagerClassLoading = otherListableFactory.allowEagerClassLoading;\n+\t\t\tthis.autowireCandidateResolver = otherListableFactory.autowireCandidateResolver;\n+\t\t\tthis.resolvableDependencies.putAll(otherListableFactory.resolvableDependencies);\n+\t\t}\n+\t}\n+\n+\n+\t//---------------------------------------------------------------------\n+\t// Implementation of ListableBeanFactory interface\n+\t//---------------------------------------------------------------------\n+\n+\tpublic <T> T getBean(Class<T> requiredType) throws BeansException {\n+\t\tAssert.notNull(requiredType, \"Required type must not be null\");\n+\t\tString[] beanNames = getBeanNamesForType(requiredType);\n+\t\tif (beanNames.length > 1) {\n+\t\t\tArrayList<String> autowireCandidates = new ArrayList<String>();\n+\t\t\tfor (String beanName : beanNames) {\n+\t\t\t\tif (getBeanDefinition(beanName).isAutowireCandidate()) {\n+\t\t\t\t\tautowireCandidates.add(beanName);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif (autowireCandidates.size() > 0) {\n+\t\t\t\tbeanNames = autowireCandidates.toArray(new String[autowireCandidates.size()]);\n+\t\t\t}\n+\t\t}\n+\t\tif (beanNames.length == 1) {\n+\t\t\treturn getBean(beanNames[0], requiredType);\n+\t\t}\n+\t\telse if (beanNames.length == 0 && getParentBeanFactory() != null) {\n+\t\t\treturn getParentBeanFactory().getBean(requiredType);\n+\t\t}\n+\t\telse {\n+\t\t\tthrow new NoSuchBeanDefinitionException(requiredType, \"expected single bean but found \" +\n+\t\t\t\t\tbeanNames.length + \": \" + StringUtils.arrayToCommaDelimitedString(beanNames));\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic boolean containsBeanDefinition(String beanName) {\n+\t\tAssert.notNull(beanName, \"Bean name must not be null\");\n+\t\treturn this.beanDefinitionMap.containsKey(beanName);\n+\t}\n+\n+\tpublic int getBeanDefinitionCount() {\n+\t\treturn this.beanDefinitionMap.size();\n+\t}\n+\n+\tpublic String[] getBeanDefinitionNames() {\n+\t\tsynchronized (this.beanDefinitionMap) {\n+\t\t\tif (this.frozenBeanDefinitionNames != null) {\n+\t\t\t\treturn this.frozenBeanDefinitionNames;\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\treturn StringUtils.toStringArray(this.beanDefinitionNames);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic String[] getBeanNamesForType(Class type) {\n+\t\treturn getBeanNamesForType(type, true, true);\n+\t}\n+\n+\tpublic String[] getBeanNamesForType(Class type, boolean includeNonSingletons, boolean allowEagerInit) {\n+\t\tList<String> result = new ArrayList<String>();\n+\n+\t\t// Check all bean definitions.\n+\t\tString[] beanDefinitionNames = getBeanDefinitionNames();\n+\t\tfor (String beanName : beanDefinitionNames) {\n+\t\t\t// Only consider bean as eligible if the bean name\n+\t\t\t// is not defined as alias for some other bean.\n+\t\t\tif (!isAlias(beanName)) {\n+\t\t\t\ttry {\n+\t\t\t\t\tRootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);\n+\t\t\t\t\t// Only check bean definition if it is complete.\n+\t\t\t\t\tif (!mbd.isAbstract() && (allowEagerInit ||\n+\t\t\t\t\t\t\t((mbd.hasBeanClass() || !mbd.isLazyInit() || this.allowEagerClassLoading)) &&\n+\t\t\t\t\t\t\t\t\t!requiresEagerInitForType(mbd.getFactoryBeanName()))) {\n+\t\t\t\t\t\t// In case of FactoryBean, match object created by FactoryBean.\n+\t\t\t\t\t\tboolean isFactoryBean = isFactoryBean(beanName, mbd);\n+\t\t\t\t\t\tboolean matchFound = (allowEagerInit || !isFactoryBean || containsSingleton(beanName)) &&\n+\t\t\t\t\t\t\t\t(includeNonSingletons || isSingleton(beanName)) && isTypeMatch(beanName, type);\n+\t\t\t\t\t\tif (!matchFound && isFactoryBean) {\n+\t\t\t\t\t\t\t// In case of FactoryBean, try to match FactoryBean instance itself next.\n+\t\t\t\t\t\t\tbeanName = FACTORY_BEAN_PREFIX + beanName;\n+\t\t\t\t\t\t\tmatchFound = (includeNonSingletons || mbd.isSingleton()) && isTypeMatch(beanName, type);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tif (matchFound) {\n+\t\t\t\t\t\t\tresult.add(beanName);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tcatch (CannotLoadBeanClassException ex) {\n+\t\t\t\t\tif (allowEagerInit) {\n+\t\t\t\t\t\tthrow ex;\n+\t\t\t\t\t}\n+\t\t\t\t\t// Probably contains a placeholder: let's ignore it for type matching purposes.\n+\t\t\t\t\tif (this.logger.isDebugEnabled()) {\n+\t\t\t\t\t\tthis.logger.debug(\"Ignoring bean class loading failure for bean '\" + beanName + \"'\", ex);\n+\t\t\t\t\t}\n+\t\t\t\t\tonSuppressedException(ex);\n+\t\t\t\t}\n+\t\t\t\tcatch (BeanDefinitionStoreException ex) {\n+\t\t\t\t\tif (allowEagerInit) {\n+\t\t\t\t\t\tthrow ex;\n+\t\t\t\t\t}\n+\t\t\t\t\t// Probably contains a placeholder: let's ignore it for type matching purposes.\n+\t\t\t\t\tif (this.logger.isDebugEnabled()) {\n+\t\t\t\t\t\tthis.logger.debug(\"Ignoring unresolvable metadata in bean definition '\" + beanName + \"'\", ex);\n+\t\t\t\t\t}\n+\t\t\t\t\tonSuppressedException(ex);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Check singletons too, to catch manually registered singletons.\n+\t\tString[] singletonNames = getSingletonNames();\n+\t\tfor (String beanName : singletonNames) {\n+\t\t\t// Only check if manually registered.\n+\t\t\tif (!containsBeanDefinition(beanName)) {\n+\t\t\t\t// In case of FactoryBean, match object created by FactoryBean.\n+\t\t\t\tif (isFactoryBean(beanName)) {\n+\t\t\t\t\tif ((includeNonSingletons || isSingleton(beanName)) && isTypeMatch(beanName, type)) {\n+\t\t\t\t\t\tresult.add(beanName);\n+\t\t\t\t\t\t// Match found for this bean: do not match FactoryBean itself anymore.\n+\t\t\t\t\t\tcontinue;\n+\t\t\t\t\t}\n+\t\t\t\t\t// In case of FactoryBean, try to match FactoryBean itself next.\n+\t\t\t\t\tbeanName = FACTORY_BEAN_PREFIX + beanName;\n+\t\t\t\t}\n+\t\t\t\t// Match raw bean instance (might be raw FactoryBean).\n+\t\t\t\tif (isTypeMatch(beanName, type)) {\n+\t\t\t\t\tresult.add(beanName);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn StringUtils.toStringArray(result);\n+\t}\n+\n+\t/**\n+\t * Check whether the specified bean would need to be eagerly initialized\n+\t * in order to determine its type.\n+\t * @param factoryBeanName a factory-bean reference that the bean definition\n+\t * defines a factory method for\n+\t * @return whether eager initialization is necessary\n+\t */\n+\tprivate boolean requiresEagerInitForType(String factoryBeanName) {\n+\t\treturn (factoryBeanName != null && isFactoryBean(factoryBeanName) && !containsSingleton(factoryBeanName));\n+\t}\n+\n+\tpublic <T> Map<String, T> getBeansOfType(Class<T> type) throws BeansException {\n+\t\treturn getBeansOfType(type, true, true);\n+\t}\n+\n+\tpublic <T> Map<String, T> getBeansOfType(Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)\n+\t\t\tthrows BeansException {\n+\n+\t\tString[] beanNames = getBeanNamesForType(type, includeNonSingletons, allowEagerInit);\n+\t\tMap<String, T> result = new LinkedHashMap<String, T>(beanNames.length);\n+\t\tfor (String beanName : beanNames) {\n+\t\t\ttry {\n+\t\t\t\tresult.put(beanName, getBean(beanName, type));\n+\t\t\t}\n+\t\t\tcatch (BeanCreationException ex) {\n+\t\t\t\tThrowable rootCause = ex.getMostSpecificCause();\n+\t\t\t\tif (rootCause instanceof BeanCurrentlyInCreationException) {\n+\t\t\t\t\tBeanCreationException bce = (BeanCreationException) rootCause;\n+\t\t\t\t\tif (isCurrentlyInCreation(bce.getBeanName())) {\n+\t\t\t\t\t\tif (this.logger.isDebugEnabled()) {\n+\t\t\t\t\t\t\tthis.logger.debug(\"Ignoring match to currently created bean '\" + beanName + \"': \" +\n+\t\t\t\t\t\t\t\t\tex.getMessage());\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tonSuppressedException(ex);\n+\t\t\t\t\t\t// Ignore: indicates a circular reference when autowiring constructors.\n+\t\t\t\t\t\t// We want to find matches other than the currently created bean itself.\n+\t\t\t\t\t\tcontinue;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tthrow ex;\n+\t\t\t}\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tpublic Map<String, Object> getBeansWithAnnotation(Class<? extends Annotation> annotationType) {\n+\t\tSet<String> beanNames = new LinkedHashSet<String>(getBeanDefinitionCount());\n+\t\tbeanNames.addAll(Arrays.asList(getBeanDefinitionNames()));\n+\t\tbeanNames.addAll(Arrays.asList(getSingletonNames()));\n+\t\tMap<String, Object> results = new LinkedHashMap<String, Object>();\n+\t\tfor (String beanName : beanNames) {\n+\t\t\tif (findAnnotationOnBean(beanName, annotationType) != null) {\n+\t\t\t\tresults.put(beanName, getBean(beanName));\n+\t\t\t}\n+\t\t}\n+\t\treturn results;\n+\t}\n+\n+\t/**\n+\t * Find a {@link Annotation} of <code>annotationType</code> on the specified\n+\t * bean, traversing its interfaces and super classes if no annotation can be\n+\t * found on the given class itself, as well as checking its raw bean class\n+\t * if not found on the exposed bean reference (e.g. in case of a proxy).\n+\t */\n+\tpublic <A extends Annotation> A findAnnotationOnBean(String beanName, Class<A> annotationType) {\n+\t\tA ann = null;\n+\t\tClass beanType = getType(beanName);\n+\t\tif (beanType != null) {\n+\t\t\tann = AnnotationUtils.findAnnotation(beanType, annotationType);\n+\t\t}\n+\t\tif (ann == null && containsBeanDefinition(beanName)) {\n+\t\t\tBeanDefinition bd = getMergedBeanDefinition(beanName);\n+\t\t\tif (bd instanceof AbstractBeanDefinition) {\n+\t\t\t\tAbstractBeanDefinition abd = (AbstractBeanDefinition) bd;\n+\t\t\t\tif (abd.hasBeanClass()) {\n+\t\t\t\t\tann = AnnotationUtils.findAnnotation(abd.getBeanClass(), annotationType);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn ann;\n+\t}\n+\n+\n+\t//---------------------------------------------------------------------\n+\t// Implementation of ConfigurableListableBeanFactory interface\n+\t//---------------------------------------------------------------------\n+\n+\tpublic void registerResolvableDependency(Class dependencyType, Object autowiredValue) {\n+\t\tAssert.notNull(dependencyType, \"Type must not be null\");\n+\t\tif (autowiredValue != null) {\n+\t\t\tAssert.isTrue((autowiredValue instanceof ObjectFactory || dependencyType.isInstance(autowiredValue)),\n+\t\t\t\t\t\"Value [\" + autowiredValue + \"] does not implement specified type [\" + dependencyType.getName() + \"]\");\n+\t\t\tthis.resolvableDependencies.put(dependencyType, autowiredValue);\n+\t\t}\n+\t}\n+\n+\tpublic boolean isAutowireCandidate(String beanName, DependencyDescriptor descriptor)\n+\t\t\tthrows NoSuchBeanDefinitionException {\n+\n+\t\t// Consider FactoryBeans as autowiring candidates.\n+\t\tboolean isFactoryBean = (descriptor != null && descriptor.getDependencyType() != null &&\n+\t\t\t\tFactoryBean.class.isAssignableFrom(descriptor.getDependencyType()));\n+\t\tif (isFactoryBean) {\n+\t\t\tbeanName = BeanFactoryUtils.transformedBeanName(beanName);\n+\t\t}\n+\n+\t\tif (containsBeanDefinition(beanName)) {\n+\t\t\treturn isAutowireCandidate(beanName, getMergedLocalBeanDefinition(beanName), descriptor);\n+\t\t}\n+\t\telse if (containsSingleton(beanName)) {\n+\t\t\treturn isAutowireCandidate(beanName, new RootBeanDefinition(getType(beanName)), descriptor);\n+\t\t}\n+\t\telse if (getParentBeanFactory() instanceof ConfigurableListableBeanFactory) {\n+\t\t\t// No bean definition found in this factory -> delegate to parent.\n+\t\t\treturn ((ConfigurableListableBeanFactory) getParentBeanFactory()).isAutowireCandidate(beanName, descriptor);\n+\t\t}\n+\t\telse {\n+\t\t\treturn true;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Determine whether the specified bean definition qualifies as an autowire candidate,\n+\t * to be injected into other beans which declare a dependency of matching type.\n+\t * @param beanName the name of the bean definition to check\n+\t * @param mbd the merged bean definition to check\n+\t * @param descriptor the descriptor of the dependency to resolve\n+\t * @return whether the bean should be considered as autowire candidate\n+\t */\n+\tprotected boolean isAutowireCandidate(String beanName, RootBeanDefinition mbd, DependencyDescriptor descriptor) {\n+\t\tresolveBeanClass(mbd, beanName);\n+\t\tif (mbd.isFactoryMethodUnique) {\n+\t\t\tboolean resolve;\n+\t\t\tsynchronized (mbd.constructorArgumentLock) {\n+\t\t\t\tresolve = (mbd.resolvedConstructorOrFactoryMethod == null);\n+\t\t\t}\n+\t\t\tif (resolve) {\n+\t\t\t\tnew ConstructorResolver(this).resolveFactoryMethodIfPossible(mbd);\n+\t\t\t}\n+\t\t}\n+\t\treturn getAutowireCandidateResolver().isAutowireCandidate(\n+\t\t\t\tnew BeanDefinitionHolder(mbd, beanName, getAliases(beanName)), descriptor);\n+\t}\n+\n+\t@Override\n+\tpublic BeanDefinition getBeanDefinition(String beanName) throws NoSuchBeanDefinitionException {\n+\t\tBeanDefinition bd = this.beanDefinitionMap.get(beanName);\n+\t\tif (bd == null) {\n+\t\t\tif (this.logger.isTraceEnabled()) {\n+\t\t\t\tthis.logger.trace(\"No bean named '\" + beanName + \"' found in \" + this);\n+\t\t\t}\n+\t\t\tthrow new NoSuchBeanDefinitionException(beanName);\n+\t\t}\n+\t\treturn bd;\n+\t}\n+\n+\tpublic void freezeConfiguration() {\n+\t\tthis.configurationFrozen = true;\n+\t\tsynchronized (this.beanDefinitionMap) {\n+\t\t\tthis.frozenBeanDefinitionNames = StringUtils.toStringArray(this.beanDefinitionNames);\n+\t\t}\n+\t}\n+\n+\tpublic boolean isConfigurationFrozen() {\n+\t\treturn this.configurationFrozen;\n+\t}\n+\n+\t/**\n+\t * Considers all beans as eligible for metdata caching\n+\t * if the factory's configuration has been marked as frozen.\n+\t * @see #freezeConfiguration()\n+\t */\n+\t@Override\n+\tprotected boolean isBeanEligibleForMetadataCaching(String beanName) {\n+\t\treturn (this.configurationFrozen || super.isBeanEligibleForMetadataCaching(beanName));\n+\t}\n+\n+\tpublic void preInstantiateSingletons() throws BeansException {\n+\t\tif (this.logger.isInfoEnabled()) {\n+\t\t\tthis.logger.info(\"Pre-instantiating singletons in \" + this);\n+\t\t}\n+\n+\t\tsynchronized (this.beanDefinitionMap) {\n+\t\t\tfor (String beanName : this.beanDefinitionNames) {\n+\t\t\t\tRootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);\n+\t\t\t\tif (!bd.isAbstract() && bd.isSingleton() && !bd.isLazyInit()) {\n+\t\t\t\t\tif (isFactoryBean(beanName)) {\n+\t\t\t\t\t\tfinal FactoryBean factory = (FactoryBean) getBean(FACTORY_BEAN_PREFIX + beanName);\n+\t\t\t\t\t\tboolean isEagerInit;\n+\t\t\t\t\t\tif (System.getSecurityManager() != null && factory instanceof SmartFactoryBean) {\n+\t\t\t\t\t\t\tisEagerInit = AccessController.doPrivileged(new PrivilegedAction<Boolean>() {\n+\t\t\t\t\t\t\t\tpublic Boolean run() {\n+\t\t\t\t\t\t\t\t\treturn ((SmartFactoryBean) factory).isEagerInit();\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}, getAccessControlContext());\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\telse {\n+\t\t\t\t\t\t\tisEagerInit = factory instanceof SmartFactoryBean && ((SmartFactoryBean) factory).isEagerInit(); \n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tif (isEagerInit) {\n+\t\t\t\t\t\t\tgetBean(beanName);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\telse {\n+\t\t\t\t\t\tgetBean(beanName);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\n+\t//---------------------------------------------------------------------\n+\t// Implementation of BeanDefinitionRegistry interface\n+\t//---------------------------------------------------------------------\n+\n+\tpublic void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)\n+\t\t\tthrows BeanDefinitionStoreException {\n+\n+\t\tAssert.hasText(beanName, \"Bean name must not be empty\");\n+\t\tAssert.notNull(beanDefinition, \"BeanDefinition must not be null\");\n+\n+\t\tif (beanDefinition instanceof AbstractBeanDefinition) {\n+\t\t\ttry {\n+\t\t\t\t((AbstractBeanDefinition) beanDefinition).validate();\n+\t\t\t}\n+\t\t\tcatch (BeanDefinitionValidationException ex) {\n+\t\t\t\tthrow new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,\n+\t\t\t\t\t\t\"Validation of bean definition failed\", ex);\n+\t\t\t}\n+\t\t}\n+\n+\t\tsynchronized (this.beanDefinitionMap) {\n+\t\t\tObject oldBeanDefinition = this.beanDefinitionMap.get(beanName);\n+\t\t\tif (oldBeanDefinition != null) {\n+\t\t\t\tif (!this.allowBeanDefinitionOverriding) {\n+\t\t\t\t\tthrow new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,\n+\t\t\t\t\t\t\t\"Cannot register bean definition [\" + beanDefinition + \"] for bean '\" + beanName +\n+\t\t\t\t\t\t\t\"': There is already [\" + oldBeanDefinition + \"] bound.\");\n+\t\t\t\t}\n+\t\t\t\telse {\n+\t\t\t\t\tif (this.logger.isInfoEnabled()) {\n+\t\t\t\t\t\tthis.logger.info(\"Overriding bean definition for bean '\" + beanName +\n+\t\t\t\t\t\t\t\t\"': replacing [\" + oldBeanDefinition + \"] with [\" + beanDefinition + \"]\");\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tthis.beanDefinitionNames.add(beanName);\n+\t\t\t\tthis.frozenBeanDefinitionNames = null;\n+\t\t\t}\n+\t\t\tthis.beanDefinitionMap.put(beanName, beanDefinition);\n+\n+\t\t\tresetBeanDefinition(beanName);\n+\t\t}\n+\t}\n+\n+\tpublic void removeBeanDefinition(String beanName) throws NoSuchBeanDefinitionException {\n+\t\tAssert.hasText(beanName, \"'beanName' must not be empty\");\n+\n+\t\tsynchronized (this.beanDefinitionMap) {\n+\t\t\tBeanDefinition bd = this.beanDefinitionMap.remove(beanName);\n+\t\t\tif (bd == null) {\n+\t\t\t\tif (this.logger.isTraceEnabled()) {\n+\t\t\t\t\tthis.logger.trace(\"No bean named '\" + beanName + \"' found in \" + this);\n+\t\t\t\t}\n+\t\t\t\tthrow new NoSuchBeanDefinitionException(beanName);\n+\t\t\t}\n+\t\t\tthis.beanDefinitionNames.remove(beanName);\n+\t\t\tthis.frozenBeanDefinitionNames = null;\n+\n+\t\t\tresetBeanDefinition(beanName);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Reset all bean definition caches for the given bean,\n+\t * including the caches of beans that are derived from it.\n+\t * @param beanName the name of the bean to reset\n+\t */\n+\tprotected void resetBeanDefinition(String beanName) {\n+\t\t// Remove the merged bean definition for the given bean, if already created.\n+\t\tclearMergedBeanDefinition(beanName);\n+\n+\t\t// Remove corresponding bean from singleton cache, if any. Shouldn't usually\n+\t\t// be necessary, rather just meant for overriding a context's default beans\n+\t\t// (e.g. the default StaticMessageSource in a StaticApplicationContext).\n+\t\tsynchronized (getSingletonMutex()) {\n+\t\t\tdestroySingleton(beanName);\n+\t\t}\n+\n+\t\t// Reset all bean definitions that have the given bean as parent\n+\t\t// (recursively).\n+\t\tfor (String bdName : this.beanDefinitionNames) {\n+\t\t\tif (!beanName.equals(bdName)) {\n+\t\t\t\tBeanDefinition bd = this.beanDefinitionMap.get(bdName);\n+\t\t\t\tif (beanName.equals(bd.getParentName())) {\n+\t\t\t\t\tresetBeanDefinition(bdName);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Only allows alias overriding if bean definition overriding is allowed.\n+\t */\n+\t@Override\n+\tprotected boolean allowAliasOverriding() {\n+\t\treturn this.allowBeanDefinitionOverriding;\n+\t}\n+\n+\n+\t//---------------------------------------------------------------------\n+\t// Dependency resolution functionality\n+\t//---------------------------------------------------------------------\n+\n+\tpublic Object resolveDependency(DependencyDescriptor descriptor, String beanName,\n+\t\t\tSet<String> autowiredBeanNames, TypeConverter typeConverter) throws BeansException  {\n+\n+\t\tdescriptor.initParameterNameDiscovery(getParameterNameDiscoverer());\n+\t\tif (descriptor.getDependencyType().equals(ObjectFactory.class)) {\n+\t\t\treturn new DependencyObjectFactory(descriptor, beanName);\n+\t\t}\n+\t\telse if (descriptor.getDependencyType().equals(javaxInjectProviderClass)) {\n+\t\t\treturn new DependencyProviderFactory().createDependencyProvider(descriptor, beanName);\n+\t\t}\n+\t\telse {\n+\t\t\treturn doResolveDependency(descriptor, descriptor.getDependencyType(), beanName, autowiredBeanNames, typeConverter);\n+\t\t}\n+\t}\n+\n+\tprotected Object doResolveDependency(DependencyDescriptor descriptor, Class<?> type, String beanName,\n+\t\t\tSet<String> autowiredBeanNames, TypeConverter typeConverter) throws BeansException  {\n+\n+\t\tObject value = getAutowireCandidateResolver().getSuggestedValue(descriptor);\n+\t\tif (value != null) {\n+\t\t\tif (value instanceof String) {\n+\t\t\t\tString strVal = resolveEmbeddedValue((String) value);\n+\t\t\t\tBeanDefinition bd = (containsBean(beanName) ? getMergedBeanDefinition(beanName) : null);\n+\t\t\t\tvalue = evaluateBeanDefinitionString(strVal, bd);\n+\t\t\t}\n+\t\t\tTypeConverter converter = (typeConverter != null ? typeConverter : getTypeConverter());\n+\t\t\treturn converter.convertIfNecessary(value, type);\n+\t\t}\n+\n+\t\tif (type.isArray()) {\n+\t\t\tClass componentType = type.getComponentType();\n+\t\t\tMap<String, Object> matchingBeans = findAutowireCandidates(beanName, componentType, descriptor);\n+\t\t\tif (matchingBeans.isEmpty()) {\n+\t\t\t\tif (descriptor.isRequired()) {\n+\t\t\t\t\traiseNoSuchBeanDefinitionException(componentType, \"array of \" + componentType.getName(), descriptor);\n+\t\t\t\t}\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\tif (autowiredBeanNames != null) {\n+\t\t\t\tautowiredBeanNames.addAll(matchingBeans.keySet());\n+\t\t\t}\n+\t\t\tTypeConverter converter = (typeConverter != null ? typeConverter : getTypeConverter());\n+\t\t\treturn converter.convertIfNecessary(matchingBeans.values(), type);\n+\t\t}\n+\t\telse if (Collection.class.isAssignableFrom(type) && type.isInterface()) {\n+\t\t\tClass elementType = descriptor.getCollectionType();\n+\t\t\tif (elementType == null) {\n+\t\t\t\tif (descriptor.isRequired()) {\n+\t\t\t\t\tthrow new FatalBeanException(\"No element type declared for collection [\" + type.getName() + \"]\");\n+\t\t\t\t}\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\tMap<String, Object> matchingBeans = findAutowireCandidates(beanName, elementType, descriptor);\n+\t\t\tif (matchingBeans.isEmpty()) {\n+\t\t\t\tif (descriptor.isRequired()) {\n+\t\t\t\t\traiseNoSuchBeanDefinitionException(elementType, \"collection of \" + elementType.getName(), descriptor);\n+\t\t\t\t}\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\tif (autowiredBeanNames != null) {\n+\t\t\t\tautowiredBeanNames.addAll(matchingBeans.keySet());\n+\t\t\t}\n+\t\t\tTypeConverter converter = (typeConverter != null ? typeConverter : getTypeConverter());\n+\t\t\treturn converter.convertIfNecessary(matchingBeans.values(), type);\n+\t\t}\n+\t\telse if (Map.class.isAssignableFrom(type) && type.isInterface()) {\n+\t\t\tClass keyType = descriptor.getMapKeyType();\n+\t\t\tif (keyType == null || !String.class.isAssignableFrom(keyType)) {\n+\t\t\t\tif (descriptor.isRequired()) {\n+\t\t\t\t\tthrow new FatalBeanException(\"Key type [\" + keyType + \"] of map [\" + type.getName() +\n+\t\t\t\t\t\t\t\"] must be assignable to [java.lang.String]\");\n+\t\t\t\t}\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\tClass valueType = descriptor.getMapValueType();\n+\t\t\tif (valueType == null) {\n+\t\t\t\tif (descriptor.isRequired()) {\n+\t\t\t\t\tthrow new FatalBeanException(\"No value type declared for map [\" + type.getName() + \"]\");\n+\t\t\t\t}\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\tMap<String, Object> matchingBeans = findAutowireCandidates(beanName, valueType, descriptor);\n+\t\t\tif (matchingBeans.isEmpty()) {\n+\t\t\t\tif (descriptor.isRequired()) {\n+\t\t\t\t\traiseNoSuchBeanDefinitionException(valueType, \"map with value type \" + valueType.getName(), descriptor);\n+\t\t\t\t}\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\tif (autowiredBeanNames != null) {\n+\t\t\t\tautowiredBeanNames.addAll(matchingBeans.keySet());\n+\t\t\t}\n+\t\t\treturn matchingBeans;\n+\t\t}\n+\t\telse {\n+\t\t\tMap<String, Object> matchingBeans = findAutowireCandidates(beanName, type, descriptor);\n+\t\t\tif (matchingBeans.isEmpty()) {\n+\t\t\t\tif (descriptor.isRequired()) {\n+\t\t\t\t\traiseNoSuchBeanDefinitionException(type, \"\", descriptor);\n+\t\t\t\t}\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\tif (matchingBeans.size() > 1) {\n+\t\t\t\tString primaryBeanName = determinePrimaryCandidate(matchingBeans, descriptor);\n+\t\t\t\tif (primaryBeanName == null) {\n+\t\t\t\t\tthrow new NoSuchBeanDefinitionException(type, \"expected single matching bean but found \" +\n+\t\t\t\t\t\t\tmatchingBeans.size() + \": \" + matchingBeans.keySet());\n+\t\t\t\t}\n+\t\t\t\tif (autowiredBeanNames != null) {\n+\t\t\t\t\tautowiredBeanNames.add(primaryBeanName);\n+\t\t\t\t}\n+\t\t\t\treturn matchingBeans.get(primaryBeanName);\n+\t\t\t}\n+\t\t\t// We have exactly one match.\n+\t\t\tMap.Entry<String, Object> entry = matchingBeans.entrySet().iterator().next();\n+\t\t\tif (autowiredBeanNames != null) {\n+\t\t\t\tautowiredBeanNames.add(entry.getKey());\n+\t\t\t}\n+\t\t\treturn entry.getValue();\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Find bean instances that match the required type.\n+\t * Called during autowiring for the specified bean.\n+\t * @param beanName the name of the bean that is about to be wired\n+\t * @param requiredType the actual type of bean to look for\n+\t * (may be an array component type or collection element type)\n+\t * @param descriptor the descriptor of the dependency to resolve\n+\t * @return a Map of candidate names and candidate instances that match\n+\t * the required type (never <code>null</code>)\n+\t * @throws BeansException in case of errors\n+\t * @see #autowireByType\n+\t * @see #autowireConstructor\n+\t */\n+\tprotected Map<String, Object> findAutowireCandidates(\n+\t\t\tString beanName, Class requiredType, DependencyDescriptor descriptor) {\n+\n+\t\tString[] candidateNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(\n+\t\t\t\tthis, requiredType, true, descriptor.isEager());\n+\t\tMap<String, Object> result = new LinkedHashMap<String, Object>(candidateNames.length);\n+\t\tfor (Class autowiringType : this.resolvableDependencies.keySet()) {\n+\t\t\tif (autowiringType.isAssignableFrom(requiredType)) {\n+\t\t\t\tObject autowiringValue = this.resolvableDependencies.get(autowiringType);\n+\t\t\t\tautowiringValue = AutowireUtils.resolveAutowiringValue(autowiringValue, requiredType);\n+\t\t\t\tif (requiredType.isInstance(autowiringValue)) {\n+\t\t\t\t\tresult.put(ObjectUtils.identityToString(autowiringValue), autowiringValue);\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tfor (String candidateName : candidateNames) {\n+\t\t\tif (!candidateName.equals(beanName) && isAutowireCandidate(candidateName, descriptor)) {\n+\t\t\t\tresult.put(candidateName, getBean(candidateName));\n+\t\t\t}\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\t/**\n+\t * Determine the primary autowire candidate in the given set of beans.\n+\t * @param candidateBeans a Map of candidate names and candidate instances\n+\t * that match the required type, as returned by {@link #findAutowireCandidates}\n+\t * @param descriptor the target dependency to match against\n+\t * @return the name of the primary candidate, or <code>null</code> if none found\n+\t */\n+\tprotected String determinePrimaryCandidate(Map<String, Object> candidateBeans, DependencyDescriptor descriptor) {\n+\t\tString primaryBeanName = null;\n+\t\tString fallbackBeanName = null;\n+\t\tfor (Map.Entry<String, Object> entry : candidateBeans.entrySet()) {\n+\t\t\tString candidateBeanName = entry.getKey();\n+\t\t\tObject beanInstance = entry.getValue();\n+\t\t\tif (isPrimary(candidateBeanName, beanInstance)) {\n+\t\t\t\tif (primaryBeanName != null) {\n+\t\t\t\t\tboolean candidateLocal = containsBeanDefinition(candidateBeanName);\n+\t\t\t\t\tboolean primaryLocal = containsBeanDefinition(primaryBeanName);\n+\t\t\t\t\tif (candidateLocal == primaryLocal) {\n+\t\t\t\t\t\tthrow new NoSuchBeanDefinitionException(descriptor.getDependencyType(),\n+\t\t\t\t\t\t\t\t\"more than one 'primary' bean found among candidates: \" + candidateBeans.keySet());\n+\t\t\t\t\t}\n+\t\t\t\t\telse if (candidateLocal && !primaryLocal) {\n+\t\t\t\t\t\tprimaryBeanName = candidateBeanName;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\telse {\n+\t\t\t\t\tprimaryBeanName = candidateBeanName;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif (primaryBeanName == null &&\n+\t\t\t\t\t(this.resolvableDependencies.values().contains(beanInstance) ||\n+\t\t\t\t\t\t\tmatchesBeanName(candidateBeanName, descriptor.getDependencyName()))) {\n+\t\t\t\tfallbackBeanName = candidateBeanName;\n+\t\t\t}\n+\t\t}\n+\t\treturn (primaryBeanName != null ? primaryBeanName : fallbackBeanName);\n+\t}\n+\n+\t/**\n+\t * Return whether the bean definition for the given bean name has been\n+\t * marked as a primary bean.\n+\t * @param beanName the name of the bean\n+\t * @param beanInstance the corresponding bean instance\n+\t * @return whether the given bean qualifies as primary\n+\t */\n+\tprotected boolean isPrimary(String beanName, Object beanInstance) {\n+\t\tif (containsBeanDefinition(beanName)) {\n+\t\t\treturn getMergedLocalBeanDefinition(beanName).isPrimary();\n+\t\t}\n+\t\tBeanFactory parentFactory = getParentBeanFactory();\n+\t\treturn (parentFactory instanceof DefaultListableBeanFactory &&\n+\t\t\t\t((DefaultListableBeanFactory) parentFactory).isPrimary(beanName, beanInstance));\n+\t}\n+\n+\t/**\n+\t * Determine whether the given candidate name matches the bean name or the aliases\n+\t * stored in this bean definition.\n+\t */\n+\tprotected boolean matchesBeanName(String beanName, String candidateName) {\n+\t\treturn (candidateName != null &&\n+\t\t\t\t(candidateName.equals(beanName) || ObjectUtils.containsElement(getAliases(beanName), candidateName)));\n+\t}\n+\n+\t/**\n+\t * Raise a NoSuchBeanDefinitionException for an unresolvable dependency.\n+\t */\n+\tprivate void raiseNoSuchBeanDefinitionException(\n+\t\t\tClass type, String dependencyDescription, DependencyDescriptor descriptor)\n+\t\t\tthrows NoSuchBeanDefinitionException {\n+\n+\t\tthrow new NoSuchBeanDefinitionException(type, dependencyDescription,\n+\t\t\t\t\"expected at least 1 bean which qualifies as autowire candidate for this dependency. \" +\n+\t\t\t\t\"Dependency annotations: \" + ObjectUtils.nullSafeToString(descriptor.getAnnotations()));\n+\t}\n+\n+\n+\t@Override\n+\tpublic String toString() {\n+\t\tStringBuilder sb = new StringBuilder(ObjectUtils.identityToString(this));\n+\t\tsb.append(\": defining beans [\");\n+\t\tsb.append(StringUtils.arrayToCommaDelimitedString(getBeanDefinitionNames()));\n+\t\tsb.append(\"]; \");\n+\t\tBeanFactory parent = getParentBeanFactory();\n+\t\tif (parent == null) {\n+\t\t\tsb.append(\"root of factory hierarchy\");\n+\t\t}\n+\t\telse {\n+\t\t\tsb.append(\"parent: \").append(ObjectUtils.identityToString(parent));\n+\t\t}\n+\t\treturn sb.toString();\n+\t}\n+\n+\n+\t//---------------------------------------------------------------------\n+\t// Serialization support\n+\t//---------------------------------------------------------------------\n+\n+\tprotected Object writeReplace() throws ObjectStreamException {\n+\t\tif (this.serializationId != null) {\n+\t\t\treturn new SerializedBeanFactoryReference(this.serializationId);\n+\t\t}\n+\t\telse {\n+\t\t\tthrow new NotSerializableException(\"DefaultListableBeanFactory has no serialization id\");\n+\t\t}\n+\t}\n+\n+\n+\t/**\n+\t * Minimal id reference to the factory.\n+\t * Resolved to the actual factory instance on deserialization.\n+\t */\n+\tprivate static class SerializedBeanFactoryReference implements Serializable {\n+\n+\t\tprivate final String id;\n+\n+\t\tpublic SerializedBeanFactoryReference(String id) {\n+\t\t\tthis.id = id;\n+\t\t}\n+\n+\t\tprivate Object readResolve() {\n+\t\t\tReference ref = serializableFactories.get(this.id);\n+\t\t\tif (ref == null) {\n+\t\t\t\tthrow new IllegalStateException(\n+\t\t\t\t\t\t\"Cannot deserialize BeanFactory with id \" + this.id + \": no factory registered for this id\");\n+\t\t\t}\n+\t\t\tObject result = ref.get();\n+\t\t\tif (result == null) {\n+\t\t\t\tthrow new IllegalStateException(\n+\t\t\t\t\t\t\"Cannot deserialize BeanFactory with id \" + this.id + \": factory has been garbage-collected\");\n+\t\t\t}\n+\t\t\treturn result;\n+\t\t}\n+\t}\n+\n+\n+\t/**\n+\t * Serializable ObjectFactory for lazy resolution of a dependency.\n+\t */\n+\tprivate class DependencyObjectFactory implements ObjectFactory, Serializable {\n+\n+\t\tprivate final DependencyDescriptor descriptor;\n+\n+\t\tprivate final String beanName;\n+\n+\t\tprivate final Class type;\n+\n+\t\tpublic DependencyObjectFactory(DependencyDescriptor descriptor, String beanName) {\n+\t\t\tthis.descriptor = descriptor;\n+\t\t\tthis.beanName = beanName;\n+\t\t\tthis.type = determineObjectFactoryType();\n+\t\t}\n+\n+\t\tprivate Class determineObjectFactoryType() {\n+\t\t\tType type = this.descriptor.getGenericDependencyType();\n+\t\t\tif (type instanceof ParameterizedType) {\n+\t\t\t\tType arg = ((ParameterizedType) type).getActualTypeArguments()[0];\n+\t\t\t\tif (arg instanceof Class) {\n+\t\t\t\t\treturn (Class) arg;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn Object.class;\n+\t\t}\n+\n+\t\tpublic Object getObject() throws BeansException {\n+\t\t\treturn doResolveDependency(this.descriptor, this.type, this.beanName, null, null);\n+\t\t}\n+\t}\n+\n+\n+\t/**\n+\t * Serializable ObjectFactory for lazy resolution of a dependency.\n+\t */\n+\tprivate class DependencyProvider extends DependencyObjectFactory implements Provider {\n+\n+\t\tpublic DependencyProvider(DependencyDescriptor descriptor, String beanName) {\n+\t\t\tsuper(descriptor, beanName);\n+\t\t}\n+\n+\t\tpublic Object get() throws BeansException {\n+\t\t\treturn getObject();\n+\t\t}\n+\t}\n+\n+\n+\t/**\n+\t * Separate inner class for avoiding a hard dependency on the <code>javax.inject</code> API.\n+\t */\n+\tprivate class DependencyProviderFactory {\n+\n+\t\tpublic Object createDependencyProvider(DependencyDescriptor descriptor, String beanName) {\n+\t\t\treturn new DependencyProvider(descriptor, beanName);\n+\t\t}\n+\t}\n+\n+}\n+"},{"sha":"47c962803f956f50f3e083fc2483fad89e920f66","filename":"core/src/main/java/org/syncope/core/init/AbstractLoader.java","status":"added","additions":38,"deletions":0,"changes":38,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Finit%2FAbstractLoader.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Finit%2FAbstractLoader.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Finit%2FAbstractLoader.java?ref=fc5cd61d84f7e69a393d45b62a9f6e36e99c5718","patch":"@@ -0,0 +1,38 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.syncope.core.init;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.support.DefaultListableBeanFactory;\n+import org.springframework.context.ConfigurableApplicationContext;\n+import org.syncope.core.util.ApplicationContextManager;\n+\n+public abstract class AbstractLoader {\n+\n+    /**\n+     * Logger.\n+     */\n+    protected static final Logger LOG = LoggerFactory.getLogger(\n+            AbstractLoader.class);\n+\n+    protected DefaultListableBeanFactory getBeanFactory() {\n+        ConfigurableApplicationContext context =\n+                ApplicationContextManager.getApplicationContext();\n+\n+        return (DefaultListableBeanFactory) context.getBeanFactory();\n+    }\n+\n+    public abstract void load();\n+}"},{"sha":"7a4cc5db3b8b999820ea298035e28b08f5531631","filename":"core/src/main/java/org/syncope/core/init/ConnInstanceLoader.java","status":"modified","additions":11,"deletions":26,"changes":37,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Finit%2FConnInstanceLoader.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Finit%2FConnInstanceLoader.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Finit%2FConnInstanceLoader.java?ref=fc5cd61d84f7e69a393d45b62a9f6e36e99c5718","patch":"@@ -23,12 +23,8 @@\n import org.identityconnectors.common.l10n.CurrentLocale;\n import org.identityconnectors.framework.api.ConnectorInfoManager;\n import org.identityconnectors.framework.api.ConnectorInfoManagerFactory;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n import org.springframework.beans.BeansException;\n import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.beans.factory.support.DefaultListableBeanFactory;\n-import org.springframework.context.ConfigurableApplicationContext;\n import org.springframework.stereotype.Component;\n import org.springframework.transaction.annotation.Transactional;\n import org.syncope.core.persistence.beans.ConnInstance;\n@@ -37,33 +33,19 @@\n import org.syncope.core.persistence.dao.ConnInstanceDAO;\n import org.syncope.core.persistence.dao.MissingConfKeyException;\n import org.syncope.core.persistence.propagation.ConnectorFacadeProxy;\n-import org.syncope.core.util.ApplicationContextManager;\n \n /**\n- * Load ConnId connectos instances.\n+ * Load ConnId connector instances.\n  */\n @Component\n-public class ConnInstanceLoader {\n-\n-    /**\n-     * Logger.\n-     */\n-    private static final Logger LOG = LoggerFactory.getLogger(\n-            ConnInstanceLoader.class);\n+public class ConnInstanceLoader extends AbstractLoader {\n \n     @Autowired\n     private ConnInstanceDAO connInstanceDAO;\n \n     @Autowired\n     private ConfDAO confDAO;\n \n-    private DefaultListableBeanFactory getBeanFactory() {\n-        ConfigurableApplicationContext context =\n-                ApplicationContextManager.getApplicationContext();\n-\n-        return (DefaultListableBeanFactory) context.getBeanFactory();\n-    }\n-\n     public ConnectorInfoManager getConnectorManager()\n             throws NotFoundException, MissingConfKeyException {\n \n@@ -117,26 +99,29 @@ public ConnectorFacadeProxy getConnector(final String id)\n     public void registerConnector(final ConnInstance instance)\n             throws NotFoundException {\n \n-        if (getBeanFactory().containsSingleton(instance.getId().toString())) {\n-            unregisterConnector(instance.getId().toString());\n+        if (getBeanFactory().containsSingleton(\n+                \"connInstance\" + instance.getId())) {\n+\n+            unregisterConnector(\"connInstance\" + instance.getId());\n         }\n \n         ConnectorFacadeProxy connector =\n                 new ConnectorFacadeProxy(instance, this);\n         LOG.debug(\"Connector to be registered: {}\", connector);\n \n-        getBeanFactory().registerSingleton(\n-                instance.getId().toString(), connector);\n+        getBeanFactory().registerSingleton(\"connInstance\" + instance.getId(),\n+                connector);\n         LOG.debug(\"Successfully registered bean {}\",\n-                instance.getId().toString());\n+                \"connInstance\" + instance.getId());\n     }\n \n     public void unregisterConnector(final String id) {\n         getBeanFactory().destroySingleton(id);\n     }\n \n+    @Override\n     @Transactional(readOnly = true)\n-    public void loadAllConnInstances() {\n+    public void load() {\n         // This is needed to avoid encoding problems when sending error\n         // messages via REST\n         CurrentLocale.set(Locale.ENGLISH);"},{"sha":"00df0c859b9e31ed835699863b3cd146ad161fd1","filename":"core/src/main/java/org/syncope/core/init/JobInstanceLoader.java","status":"added","additions":148,"deletions":0,"changes":148,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Finit%2FJobInstanceLoader.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Finit%2FJobInstanceLoader.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Finit%2FJobInstanceLoader.java?ref=fc5cd61d84f7e69a393d45b62a9f6e36e99c5718","patch":"@@ -0,0 +1,148 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.syncope.core.init;\n+\n+import java.util.List;\n+import org.quartz.JobDetail;\n+import org.quartz.Scheduler;\n+import org.quartz.SchedulerException;\n+import org.springframework.aop.framework.ProxyFactoryBean;\n+import org.springframework.beans.MutablePropertyValues;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.support.AbstractBeanDefinition;\n+import org.springframework.beans.factory.support.GenericBeanDefinition;\n+import org.springframework.context.ConfigurableApplicationContext;\n+import org.springframework.scheduling.quartz.CronTriggerBean;\n+import org.springframework.scheduling.quartz.SchedulerFactoryBean;\n+import org.springframework.stereotype.Component;\n+import org.springframework.transaction.annotation.Transactional;\n+import org.syncope.core.persistence.beans.SchedTask;\n+import org.syncope.core.persistence.beans.SyncTask;\n+import org.syncope.core.persistence.dao.TaskDAO;\n+import org.syncope.core.scheduling.AppContextMethodInvokingJobDetailFactoryBean;\n+import org.syncope.core.scheduling.Job;\n+import org.syncope.core.util.ApplicationContextManager;\n+\n+@Component\n+public class JobInstanceLoader extends AbstractLoader {\n+\n+    @Autowired\n+    private SchedulerFactoryBean scheduler;\n+\n+    @Autowired\n+    private TaskDAO taskDAO;\n+\n+    public static String getJobName(final Long taskId) {\n+        return \"job\" + taskId;\n+    }\n+\n+    public static String getJobProxyName(final Long taskId) {\n+        return \"jobProxy\" + taskId;\n+    }\n+\n+    public static String getJobDetailName(final Long taskId) {\n+        return \"jobDetail\" + taskId;\n+    }\n+\n+    public static String getTriggerName(final Long taskId) {\n+        return \"Trigger_\" + getJobDetailName(taskId);\n+    }\n+\n+    public void registerJob(final SchedTask task)\n+            throws Exception {\n+\n+        unregisterJob(task.getId());\n+\n+        ConfigurableApplicationContext ctx =\n+                ApplicationContextManager.getApplicationContext();\n+\n+        MutablePropertyValues mpv = new MutablePropertyValues();\n+        mpv.add(\"taskId\", task.getId());\n+        GenericBeanDefinition bd = new GenericBeanDefinition();\n+        bd.setBeanClassName(task.getJobClassName());\n+        bd.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE);\n+        bd.setPropertyValues(mpv);\n+        getBeanFactory().registerBeanDefinition(getJobName(task.getId()), bd);\n+\n+        mpv = new MutablePropertyValues();\n+        mpv.add(\"target\", ctx.getBean(getJobName(task.getId())));\n+        mpv.add(\"proxyInterfaces\", Job.class.getName());\n+        mpv.add(\"interceptorNames\", \"jpaInterceptor\");\n+        bd = new GenericBeanDefinition();\n+        bd.setBeanClass(ProxyFactoryBean.class);\n+        bd.setPropertyValues(mpv);\n+        getBeanFactory().registerBeanDefinition(\n+                getJobProxyName(task.getId()), bd);\n+\n+        AppContextMethodInvokingJobDetailFactoryBean jobDetailFactory =\n+                (AppContextMethodInvokingJobDetailFactoryBean) getBeanFactory().\n+                autowire(AppContextMethodInvokingJobDetailFactoryBean.class,\n+                AbstractBeanDefinition.AUTOWIRE_BY_TYPE, true);\n+        jobDetailFactory.setTargetBeanName(getJobProxyName(task.getId()));\n+        jobDetailFactory.setTargetMethod(\"execute\");\n+        jobDetailFactory.afterPropertiesSet();\n+        getBeanFactory().registerSingleton(getJobDetailName(task.getId()),\n+                jobDetailFactory);\n+\n+        if (task.getCronExpression() != null) {\n+            JobDetail jobDetail = (JobDetail) ctx.getBean(\n+                    getJobDetailName(task.getId()));\n+            jobDetail.setName(getJobDetailName(task.getId()));\n+            jobDetail.setGroup(Scheduler.DEFAULT_GROUP);\n+\n+            CronTriggerBean cronTrigger = new CronTriggerBean();\n+            cronTrigger.setName(getTriggerName(task.getId()));\n+            cronTrigger.setCronExpression(task.getCronExpression());\n+\n+            scheduler.getScheduler().scheduleJob(jobDetail, cronTrigger);\n+        }\n+    }\n+\n+    public void unregisterJob(final Long taskId) {\n+        try {\n+            scheduler.getScheduler().unscheduleJob(\n+                    getJobDetailName(taskId), Scheduler.DEFAULT_GROUP);\n+            scheduler.getScheduler().deleteJob(\n+                    getJobDetailName(taskId), Scheduler.DEFAULT_GROUP);\n+        } catch (SchedulerException e) {\n+            LOG.error(\"Could not remove job \" + getJobDetailName(taskId), e);\n+        }\n+\n+        if (getBeanFactory().containsSingleton(getJobDetailName(taskId))) {\n+            getBeanFactory().destroySingleton(getJobDetailName(taskId));\n+        }\n+        if (getBeanFactory().containsBeanDefinition(getJobProxyName(taskId))) {\n+\n+            getBeanFactory().removeBeanDefinition(getJobProxyName(taskId));\n+        }\n+        if (getBeanFactory().containsBeanDefinition(getJobName(taskId))) {\n+            getBeanFactory().removeBeanDefinition(getJobName(taskId));\n+        }\n+    }\n+\n+    @Override\n+    @Transactional(readOnly = true)\n+    public void load() {\n+        List<SchedTask> tasks = taskDAO.findAll(SchedTask.class);\n+        tasks.addAll(taskDAO.findAll(SyncTask.class));\n+        for (SchedTask task : tasks) {\n+            try {\n+                registerJob(task);\n+            } catch (Exception e) {\n+                LOG.error(\"While loading job instance for task \"\n+                        + task.getId(), e);\n+            }\n+        }\n+    }\n+}"},{"sha":"3b7470cc9956bfc6121a7024aa0bdfe1aac08624","filename":"core/src/main/java/org/syncope/core/init/SpringContextInitializer.java","status":"modified","additions":5,"deletions":1,"changes":6,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Finit%2FSpringContextInitializer.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Finit%2FSpringContextInitializer.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Finit%2FSpringContextInitializer.java?ref=fc5cd61d84f7e69a393d45b62a9f6e36e99c5718","patch":"@@ -35,6 +35,9 @@ public class SpringContextInitializer implements ServletContextAware,\n     @Autowired\n     private ContentLoader contentLoader;\n \n+    @Autowired\n+    private JobInstanceLoader jobInstanceLoader;\n+\n     @Override\n     public void setServletContext(final ServletContext servletContext) {\n     }\n@@ -48,7 +51,8 @@ public void setBeanFactory(final BeanFactory beanFactory)\n     public void afterPropertiesSet()\n             throws Exception {\n \n-        connInstanceLoader.loadAllConnInstances();\n         contentLoader.load();\n+        connInstanceLoader.load();\n+        jobInstanceLoader.load();\n     }\n }"},{"sha":"1be385430ba573dc69dddc9ca966da45c63f4e91","filename":"core/src/main/java/org/syncope/core/persistence/beans/AbstractVirAttr.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Fpersistence%2Fbeans%2FAbstractVirAttr.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Fpersistence%2Fbeans%2FAbstractVirAttr.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Fpersistence%2Fbeans%2FAbstractVirAttr.java?ref=fc5cd61d84f7e69a393d45b62a9f6e36e99c5718","patch":"@@ -129,7 +129,7 @@ protected <T extends AbstractAttributable> List<Object> retrieveValues(\n                 connectorInstance = resource.getConnector();\n \n                 connector = connInstanceLoader.getConnector(\n-                        connectorInstance.getId().toString());\n+                        \"connInstance\" + connectorInstance.getId());\n \n                 try {\n                     attributes = connector.getObjectAttributes("},{"sha":"dd6b4ca03af4d13f511d1fbd5d3cbfa8b755d6c7","filename":"core/src/main/java/org/syncope/core/persistence/beans/TaskExec.java","status":"modified","additions":8,"deletions":4,"changes":12,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Fpersistence%2Fbeans%2FTaskExec.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Fpersistence%2Fbeans%2FTaskExec.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Fpersistence%2Fbeans%2FTaskExec.java?ref=fc5cd61d84f7e69a393d45b62a9f6e36e99c5718","patch":"@@ -70,11 +70,13 @@ public Long getId() {\n     }\n \n     public Date getEndDate() {\n-        return endDate;\n+        return endDate == null ? null : new Date(endDate.getTime());\n     }\n \n     public void setEndDate(Date endDate) {\n-        this.endDate = endDate;\n+        if (endDate != null) {\n+            this.endDate = new Date(endDate.getTime());\n+        }\n     }\n \n     public String getMessage() {\n@@ -86,11 +88,13 @@ public void setMessage(String message) {\n     }\n \n     public Date getStartDate() {\n-        return startDate;\n+        return startDate == null ? null : new Date(startDate.getTime());\n     }\n \n     public void setStartDate(Date startDate) {\n-        this.startDate = startDate;\n+        if (startDate != null) {\n+            this.startDate = new Date(startDate.getTime());\n+        }\n     }\n \n     public Task getTask() {"},{"sha":"f6d22f36a78ded4a7b889be5a3507199d07850be","filename":"core/src/main/java/org/syncope/core/persistence/dao/TaskExecDAO.java","status":"modified","additions":4,"deletions":0,"changes":4,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2FTaskExecDAO.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2FTaskExecDAO.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2FTaskExecDAO.java?ref=fc5cd61d84f7e69a393d45b62a9f6e36e99c5718","patch":"@@ -23,6 +23,10 @@ public interface TaskExecDAO extends DAO {\n \n     TaskExec find(Long id);\n \n+     <T extends Task> TaskExec findLatestStarted(T task);\n+\n+     <T extends Task> TaskExec findLatestEnded(T task);\n+\n      <T extends Task> List<TaskExec> findAll(Class<T> reference);\n \n     TaskExec save(TaskExec execution)"},{"sha":"6b8430437197943cbdf70f572cdc55fa0f1a4346","filename":"core/src/main/java/org/syncope/core/persistence/dao/impl/TaskExecDAOImpl.java","status":"modified","additions":27,"deletions":0,"changes":27,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2Fimpl%2FTaskExecDAOImpl.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2Fimpl%2FTaskExecDAOImpl.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2Fimpl%2FTaskExecDAOImpl.java?ref=fc5cd61d84f7e69a393d45b62a9f6e36e99c5718","patch":"@@ -30,6 +30,33 @@ public TaskExec find(final Long id) {\n         return entityManager.find(TaskExec.class, id);\n     }\n \n+    private <T extends Task> TaskExec findLatest(final T task,\n+            final String field) {\n+\n+        Query query = entityManager.createQuery(\"SELECT e \"\n+                + \"FROM \" + TaskExec.class.getSimpleName() + \" e \"\n+                + \"WHERE e.task=:task \"\n+                + \"ORDER BY e.\" + field + \" DESC\");\n+        query.setParameter(\"task\", task);\n+        query.setMaxResults(1);\n+\n+        List<TaskExec> result = query.getResultList();\n+        return result == null || result.isEmpty()\n+                ? null : result.iterator().next();\n+    }\n+\n+    @Override\n+    public <T extends Task> TaskExec findLatestStarted(final T task) {\n+\n+        return findLatest(task, \"startDate\");\n+    }\n+\n+    @Override\n+    public <T extends Task> TaskExec findLatestEnded(final T task) {\n+\n+        return findLatest(task, \"endDate\");\n+    }\n+\n     @Override\n     public <T extends Task> List<TaskExec> findAll(Class<T> reference) {\n         Query query = entityManager.createQuery(\"SELECT e \""},{"sha":"283233f5ed5c604026490f7e8fd4090b15fe70b6","filename":"core/src/main/java/org/syncope/core/persistence/propagation/ConnectorFacadeProxy.java","status":"modified","additions":6,"deletions":6,"changes":12,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Fpersistence%2Fpropagation%2FConnectorFacadeProxy.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Fpersistence%2Fpropagation%2FConnectorFacadeProxy.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Fpersistence%2Fpropagation%2FConnectorFacadeProxy.java?ref=fc5cd61d84f7e69a393d45b62a9f6e36e99c5718","patch":"@@ -232,7 +232,7 @@ public Uid create(\n             final ObjectClass oclass,\n             final Set<Attribute> attrs,\n             final OperationOptions options,\n-            final Set<String> triedPropagationRequests) {\n+            final Set<String> propagationAttempted) {\n \n         Uid result = null;\n \n@@ -242,7 +242,7 @@ public Uid create(\n                 : capabitilies.contains(\n                 ConnectorCapability.ASYNC_CREATE)) {\n \n-            triedPropagationRequests.add(\"create\");\n+            propagationAttempted.add(\"create\");\n \n             result = connector.create(oclass, attrs, options);\n         }\n@@ -255,7 +255,7 @@ public Uid update(final PropagationMode propagationMode,\n             final Uid uid,\n             final Set<Attribute> replaceAttributes,\n             final OperationOptions options,\n-            final Set<String> triedPropagationRequests) {\n+            final Set<String> propagationAttempted) {\n \n         Uid result = null;\n \n@@ -265,7 +265,7 @@ public Uid update(final PropagationMode propagationMode,\n                 : capabitilies.contains(\n                 ConnectorCapability.ASYNC_UPDATE)) {\n \n-            triedPropagationRequests.add(\"update\");\n+            propagationAttempted.add(\"update\");\n \n             result = connector.update(\n                     objclass, uid, replaceAttributes, options);\n@@ -278,15 +278,15 @@ public void delete(final PropagationMode propagationMode,\n             final ObjectClass objClass,\n             final Uid uid,\n             final OperationOptions options,\n-            final Set<String> triedPropagationRequests) {\n+            final Set<String> propagationAttempted) {\n \n         if (propagationMode == PropagationMode.SYNC\n                 ? capabitilies.contains(\n                 ConnectorCapability.SYNC_DELETE)\n                 : capabitilies.contains(\n                 ConnectorCapability.ASYNC_DELETE)) {\n \n-            triedPropagationRequests.add(\"delete\");\n+            propagationAttempted.add(\"delete\");\n \n             connector.delete(objClass, uid, options);\n         }"},{"sha":"45dcb3c9969413471dc4241def937c93a41ad370","filename":"core/src/main/java/org/syncope/core/persistence/propagation/PropagationManager.java","status":"modified","additions":26,"deletions":30,"changes":56,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Fpersistence%2Fpropagation%2FPropagationManager.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Fpersistence%2Fpropagation%2FPropagationManager.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Fpersistence%2Fpropagation%2FPropagationManager.java?ref=fc5cd61d84f7e69a393d45b62a9f6e36e99c5718","patch":"@@ -250,24 +250,13 @@ protected void provision(\n                         resourceOperations.getOldAccountId(resource.getName()));\n                 task.setAttributes(\n                         preparedAttributes.values().iterator().next());\n-\n-                execution = new TaskExec();\n-                execution.setTask(task);\n-                execution.setStatus(\n-                        PropagationTaskExecStatus.CREATED.toString());\n-\n-                task.addExec(execution);\n                 task = taskDAO.save(task);\n \n-                // Re-read execution to get the unique id\n-                execution = (TaskExec) task.getExecs().\n-                        iterator().next();\n-\n                 LOG.debug(\"Execution started for {}\", task);\n \n-                propagate(execution);\n+                execution = propagate(task, new Date());\n \n-                LOG.debug(\"Execution finished for {}\", task);\n+                LOG.debug(\"Execution finished for {}, {}\", task, execution);\n \n                 // Propagation is interrupted as soon as the result of the\n                 // communication with a mandatory resource is in error\n@@ -586,22 +575,27 @@ private Map<String, Set<Attribute>> prepareAttributes(SyncopeUser user,\n \n     }\n \n-    public void propagate(final TaskExec execution) {\n-        final Date startDate = new Date();\n-        String taskExecutionMessage = null;\n+    public TaskExec propagate(final PropagationTask task,\n+            final Date startDate) {\n \n-        final PropagationTask task = (PropagationTask) execution.getTask();\n+        TaskExec execution = new TaskExec();\n+        execution.setTask(task);\n+        execution.setStatus(\n+                PropagationTaskExecStatus.CREATED.toString());\n+        execution = taskExecDAO.save(execution);\n \n-        // Output parameter to verify the propagation request tryed\n-        final Set<String> triedPropagationRequests = new HashSet<String>();\n+        String taskExecutionMessage = null;\n+\n+        // Flag to state wether any propagation has been attempted\n+        Set<String> propagationAttempted = new HashSet<String>();\n \n         try {\n             ConnInstance connectorInstance =\n                     task.getResource().getConnector();\n \n             ConnectorFacadeProxy connector =\n                     connInstanceLoader.getConnector(\n-                    connectorInstance.getId().toString());\n+                    \"connInstance\" + connectorInstance.getId());\n \n             if (connector == null) {\n                 LOG.error(\"Connector instance bean \"\n@@ -643,11 +637,11 @@ public void propagate(final TaskExec execution) {\n \n                         LOG.debug(\"Rename required with value {}\", newName);\n \n-                        if (newName != null) {\n-                            if (newName.equals(remoteObject.getName())) {\n-                                LOG.debug(\"Remote object name unchanged\");\n-                                attributes.remove(newName);\n-                            }\n+                        if (newName != null\n+                                && newName.equals(remoteObject.getName())) {\n+\n+                            LOG.debug(\"Remote object name unchanged\");\n+                            attributes.remove(newName);\n                         }\n \n                         LOG.debug(\"Attributes to be replaced {}\", attributes);\n@@ -659,14 +653,14 @@ public void propagate(final TaskExec execution) {\n                                 remoteObject.getUid(),\n                                 attributes,\n                                 null,\n-                                triedPropagationRequests);\n+                                propagationAttempted);\n                     } else {\n                         connector.create(\n                                 task.getPropagationMode(),\n                                 ObjectClass.ACCOUNT,\n                                 task.getAttributes(),\n                                 null,\n-                                triedPropagationRequests);\n+                                propagationAttempted);\n                     }\n                     break;\n \n@@ -675,7 +669,7 @@ public void propagate(final TaskExec execution) {\n                             ObjectClass.ACCOUNT,\n                             new Uid(task.getAccountId()),\n                             null,\n-                            triedPropagationRequests);\n+                            propagationAttempted);\n                     break;\n \n                 default:\n@@ -710,12 +704,12 @@ public void propagate(final TaskExec execution) {\n                 LOG.error(\"While executing KO action on {}\", execution, wft);\n             }\n \n-            triedPropagationRequests.add(\n+            propagationAttempted.add(\n                     task.getResourceOperationType().toString().toLowerCase());\n         } finally {\n             LOG.debug(\"Update execution for {}\", task);\n \n-            if (!triedPropagationRequests.isEmpty()) {\n+            if (!propagationAttempted.isEmpty()) {\n                 execution.setStartDate(startDate);\n                 execution.setMessage(taskExecutionMessage);\n                 execution.setEndDate(new Date());\n@@ -729,5 +723,7 @@ public void propagate(final TaskExec execution) {\n                 LOG.debug(\"Execution removed: {}\", execution);\n             }\n         }\n+\n+        return execution;\n     }\n }"},{"sha":"2c240beb03384239882535f738af37c3af1206fd","filename":"core/src/main/java/org/syncope/core/persistence/validation/entity/SchedTaskValidator.java","status":"modified","additions":16,"deletions":2,"changes":18,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Fpersistence%2Fvalidation%2Fentity%2FSchedTaskValidator.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Fpersistence%2Fvalidation%2Fentity%2FSchedTaskValidator.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Fpersistence%2Fvalidation%2Fentity%2FSchedTaskValidator.java?ref=fc5cd61d84f7e69a393d45b62a9f6e36e99c5718","patch":"@@ -15,10 +15,13 @@\n package org.syncope.core.persistence.validation.entity;\n \n import java.text.ParseException;\n+import java.util.Arrays;\n import javax.validation.ConstraintValidator;\n import javax.validation.ConstraintValidatorContext;\n import org.quartz.CronExpression;\n import org.syncope.core.persistence.beans.SchedTask;\n+import org.syncope.core.scheduling.AbstractJob;\n+import org.syncope.core.scheduling.Job;\n import org.syncope.types.EntityViolationType;\n \n public class SchedTaskValidator extends AbstractValidator\n@@ -47,8 +50,8 @@ public boolean isValid(final SchedTask object,\n                         addConstraintViolation();\n             } else {\n                 try {\n-                    Class.forName(object.getJobClassName());\n-                    isValid = true;\n+                    Class jobClass = Class.forName(object.getJobClassName());\n+                    isValid = AbstractJob.class.isAssignableFrom(jobClass);\n                 } catch (ClassNotFoundException e) {\n                     LOG.error(\"Job class \" + object.getJobClassName()\n                             + \" not found\", e);\n@@ -61,6 +64,17 @@ public boolean isValid(final SchedTask object,\n                             + object.getJobClassName()).\n                             addConstraintViolation();\n                 }\n+                if (!isValid) {\n+                    LOG.error(\"Job class \" + object.getJobClassName()\n+                            + \"does not implement \" + Job.class.getName());\n+\n+                    context.disableDefaultConstraintViolation();\n+                    context.buildConstraintViolationWithTemplate(\n+                            EntityViolationType.InvalidSchedTask.toString()).\n+                            addNode(object + \".jobClassName does not implement \"\n+                            + Job.class.getName()).\n+                            addConstraintViolation();\n+                }\n \n                 if (isValid && object.getCronExpression() != null) {\n                     try {"},{"sha":"f32c3fc802655f4ecaff5e364772f1987c0a0f36","filename":"core/src/main/java/org/syncope/core/rest/controller/AbstractController.java","status":"modified","additions":23,"deletions":0,"changes":23,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Frest%2Fcontroller%2FAbstractController.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Frest%2Fcontroller%2FAbstractController.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Frest%2Fcontroller%2FAbstractController.java?ref=fc5cd61d84f7e69a393d45b62a9f6e36e99c5718","patch":"@@ -20,6 +20,10 @@\n import org.slf4j.LoggerFactory;\n import org.springframework.beans.TypeMismatchException;\n import org.springframework.transaction.annotation.Transactional;\n+import org.syncope.client.to.PropagationTaskTO;\n+import org.syncope.client.to.SchedTaskTO;\n+import org.syncope.client.to.SyncTaskTO;\n+import org.syncope.client.to.TaskTO;\n import org.syncope.core.persistence.beans.PropagationTask;\n import org.syncope.core.persistence.beans.SchedTask;\n import org.syncope.core.persistence.beans.SyncTask;\n@@ -83,4 +87,23 @@ protected TaskUtil getTaskUtil(final Task task) {\n \n         return result;\n     }\n+\n+    protected TaskUtil getTaskUtil(final TaskTO taskTO) {\n+        TaskUtil result = (taskTO instanceof PropagationTaskTO)\n+                ? TaskUtil.PROPAGATION\n+                : (taskTO instanceof SchedTaskTO)\n+                ? TaskUtil.SCHED\n+                : (taskTO instanceof SyncTaskTO)\n+                ? TaskUtil.SYNC\n+                : null;\n+\n+        if (result == null) {\n+            LOG.error(\"Task not supported: \" + taskTO.getClass().getName());\n+\n+            throw new TypeMismatchException(taskTO.getClass().getName(),\n+                    TaskUtil.class);\n+        }\n+\n+        return result;\n+    }\n }"},{"sha":"9cdd7aa01ffbf9077532bf094a16404b988ba5e5","filename":"core/src/main/java/org/syncope/core/rest/controller/TaskController.java","status":"modified","additions":169,"deletions":20,"changes":189,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Frest%2Fcontroller%2FTaskController.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Frest%2Fcontroller%2FTaskController.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Frest%2Fcontroller%2FTaskController.java?ref=fc5cd61d84f7e69a393d45b62a9f6e36e99c5718","patch":"@@ -16,35 +16,50 @@\n \n import com.opensymphony.workflow.WorkflowException;\n import java.lang.reflect.Modifier;\n+import org.quartz.SchedulerException;\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.stereotype.Controller;\n import org.springframework.web.bind.annotation.PathVariable;\n import org.springframework.web.bind.annotation.RequestMapping;\n import org.springframework.web.bind.annotation.RequestMethod;\n import java.util.ArrayList;\n+import java.util.Date;\n import java.util.HashSet;\n import java.util.List;\n+import java.util.Map;\n import java.util.Set;\n import javassist.NotFoundException;\n+import javax.servlet.http.HttpServletResponse;\n+import org.quartz.JobDetail;\n+import org.quartz.Scheduler;\n import org.reflections.Reflections;\n import org.springframework.http.HttpStatus;\n+import org.springframework.scheduling.quartz.SchedulerFactoryBean;\n import org.springframework.security.access.prepost.PreAuthorize;\n+import org.springframework.web.bind.annotation.RequestBody;\n import org.springframework.web.bind.annotation.RequestParam;\n import org.springframework.web.servlet.ModelAndView;\n+import org.syncope.client.mod.SchedTaskMod;\n+import org.syncope.client.to.SchedTaskTO;\n import org.syncope.client.to.TaskExecTO;\n import org.syncope.client.to.TaskTO;\n import org.syncope.client.validation.SyncopeClientCompositeErrorException;\n import org.syncope.client.validation.SyncopeClientException;\n+import org.syncope.core.init.JobInstanceLoader;\n import org.syncope.core.persistence.beans.PropagationTask;\n+import org.syncope.core.persistence.beans.SchedTask;\n import org.syncope.core.persistence.beans.Task;\n import org.syncope.core.persistence.beans.TaskExec;\n import org.syncope.core.persistence.dao.TaskDAO;\n import org.syncope.core.persistence.dao.TaskExecDAO;\n import org.syncope.core.persistence.propagation.PropagationManager;\n+import org.syncope.core.persistence.validation.entity.InvalidEntityException;\n import org.syncope.core.rest.data.TaskDataBinder;\n import org.syncope.core.scheduling.Job;\n import org.syncope.core.scheduling.SyncJob;\n+import org.syncope.core.util.ApplicationContextManager;\n import org.syncope.core.util.TaskUtil;\n+import org.syncope.types.EntityViolationType;\n import org.syncope.types.PropagationMode;\n import org.syncope.types.PropagationTaskExecStatus;\n import org.syncope.types.SyncopeClientExceptionType;\n@@ -60,11 +75,125 @@ public class TaskController extends AbstractController {\n     private TaskExecDAO taskExecDAO;\n \n     @Autowired\n-    private TaskDataBinder taskDataBinder;\n+    private TaskDataBinder binder;\n \n     @Autowired\n     private PropagationManager propagationManager;\n \n+    @Autowired\n+    private JobInstanceLoader jobInstanceLoader;\n+\n+    @Autowired\n+    private SchedulerFactoryBean scheduler;\n+\n+    @PreAuthorize(\"hasRole('TASK_CREATE')\")\n+    @RequestMapping(method = RequestMethod.POST,\n+    value = \"/create\")\n+    public TaskTO create(final HttpServletResponse response,\n+            final @RequestBody SchedTaskTO taskTO)\n+            throws NotFoundException {\n+\n+        LOG.debug(\"Creating task \" + taskTO);\n+\n+        SyncopeClientCompositeErrorException scce =\n+                new SyncopeClientCompositeErrorException(\n+                HttpStatus.BAD_REQUEST);\n+\n+        TaskUtil taskUtil = getTaskUtil(taskTO);\n+\n+        SchedTask task = binder.createSchedTask(taskTO, taskUtil);\n+        try {\n+            task = taskDAO.save(task);\n+        } catch (InvalidEntityException e) {\n+            SyncopeClientException sce = new SyncopeClientException(\n+                    SyncopeClientExceptionType.InvalidTask);\n+\n+            for (Map.Entry<Class, Set<EntityViolationType>> violation :\n+                    e.getViolations().entrySet()) {\n+\n+                for (EntityViolationType violationType : violation.getValue()) {\n+                    sce.addElement(violation.getClass().getSimpleName() + \": \"\n+                            + violationType);\n+                }\n+            }\n+\n+            scce.addException(sce);\n+            throw scce;\n+        }\n+\n+        try {\n+            jobInstanceLoader.registerJob(task);\n+        } catch (Exception e) {\n+            LOG.error(\"While registering quartz job for task \"\n+                    + task.getId(), e);\n+\n+            SyncopeClientException sce = new SyncopeClientException(\n+                    SyncopeClientExceptionType.Scheduling);\n+            sce.addElement(e.getMessage());\n+            scce.addException(sce);\n+            throw scce;\n+        }\n+\n+        response.setStatus(HttpServletResponse.SC_CREATED);\n+        return binder.getTaskTO(task, taskUtil);\n+    }\n+\n+    @PreAuthorize(\"hasRole('TASK_UPDATE')\")\n+    @RequestMapping(method = RequestMethod.POST,\n+    value = \"/update\")\n+    public TaskTO update(@RequestBody SchedTaskMod taskMod)\n+            throws NotFoundException {\n+\n+        LOG.debug(\"Task update called with parameter {}\", taskMod);\n+\n+        SchedTask task = taskDAO.find(taskMod.getId());\n+        if (task == null) {\n+            throw new NotFoundException(\n+                    \"Task \" + String.valueOf(taskMod.getId()));\n+        }\n+\n+        TaskUtil taskUtil = getTaskUtil(task);\n+\n+        SyncopeClientCompositeErrorException scce =\n+                new SyncopeClientCompositeErrorException(\n+                HttpStatus.BAD_REQUEST);\n+\n+        binder.updateSchedTask(task, taskMod, taskUtil);\n+        try {\n+            task = taskDAO.save(task);\n+        } catch (InvalidEntityException e) {\n+            SyncopeClientException sce = new SyncopeClientException(\n+                    SyncopeClientExceptionType.InvalidTask);\n+\n+            for (Map.Entry<Class, Set<EntityViolationType>> violation :\n+                    e.getViolations().entrySet()) {\n+\n+                for (EntityViolationType violationType : violation.getValue()) {\n+                    sce.addElement(violation.getClass().getSimpleName() + \": \"\n+                            + violationType);\n+                }\n+            }\n+\n+            scce.addException(sce);\n+            throw scce;\n+        }\n+\n+        try {\n+            jobInstanceLoader.registerJob(task);\n+        } catch (Exception e) {\n+            LOG.error(\"While registering quartz job for task \"\n+                    + task.getId(), e);\n+\n+            SyncopeClientException sce = new SyncopeClientException(\n+                    SyncopeClientExceptionType.Scheduling);\n+            sce.addElement(e.getMessage());\n+            scce.addException(sce);\n+            throw scce;\n+        }\n+\n+        return binder.getTaskTO(task, taskUtil);\n+    }\n+\n     @PreAuthorize(\"hasRole('TASK_LIST')\")\n     @RequestMapping(method = RequestMethod.GET,\n     value = \"/{kind}/count\")\n@@ -82,7 +211,7 @@ public List<TaskTO> list(@PathVariable(\"kind\") final String kind) {\n         List<Task> tasks = taskDAO.findAll(taskUtil.taskClass());\n         List<TaskTO> taskTOs = new ArrayList<TaskTO>(tasks.size());\n         for (Task task : tasks) {\n-            taskTOs.add(taskDataBinder.getTaskTO(task, taskUtil));\n+            taskTOs.add(binder.getTaskTO(task, taskUtil));\n         }\n \n         return taskTOs;\n@@ -101,7 +230,7 @@ public List<TaskTO> list(\n         List<Task> tasks = taskDAO.findAll(page, size, taskUtil.taskClass());\n         List<TaskTO> taskTOs = new ArrayList<TaskTO>(tasks.size());\n         for (Task task : tasks) {\n-            taskTOs.add(taskDataBinder.getTaskTO(task, taskUtil));\n+            taskTOs.add(binder.getTaskTO(task, taskUtil));\n         }\n \n         return taskTOs;\n@@ -118,8 +247,7 @@ public List<TaskExecTO> listExecutions(\n         List<TaskExecTO> executionTOs =\n                 new ArrayList<TaskExecTO>(executions.size());\n         for (TaskExec execution : executions) {\n-            executionTOs.add(\n-                    taskDataBinder.getTaskExecutionTO(execution));\n+            executionTOs.add(binder.getTaskExecutionTO(execution));\n         }\n \n         return executionTOs;\n@@ -160,7 +288,7 @@ public TaskTO read(@PathVariable(\"taskId\") final Long taskId)\n             throw new NotFoundException(\"Task \" + taskId);\n         }\n \n-        return taskDataBinder.getTaskTO(task, getTaskUtil(task));\n+        return binder.getTaskTO(task, getTaskUtil(task));\n     }\n \n     @PreAuthorize(\"hasRole('TASK_READ')\")\n@@ -175,7 +303,7 @@ public TaskExecTO readExecution(\n             throw new NotFoundException(\"Task execution \" + executionId);\n         }\n \n-        return taskDataBinder.getTaskExecutionTO(execution);\n+        return binder.getTaskExecutionTO(execution);\n     }\n \n     @PreAuthorize(\"hasRole('TASK_EXECUTE')\")\n@@ -190,27 +318,48 @@ public TaskExecTO execute(\n             throw new NotFoundException(\"Task \" + taskId);\n         }\n \n-        TaskExec execution = new TaskExec();\n-        execution.setTask(task);\n+        TaskExec execution = null;\n+        LOG.debug(\"Execution started for {}\", task);\n         switch (getTaskUtil(task)) {\n             case PROPAGATION:\n-                execution.setStatus(\n-                        PropagationTaskExecStatus.CREATED.toString());\n-                execution = taskExecDAO.save(execution);\n-\n-                LOG.debug(\"Execution started for {}\", task);\n-                propagationManager.propagate(execution);\n-                LOG.debug(\"Execution finished for {}, {}\", task, execution);\n+                execution = propagationManager.propagate(\n+                        (PropagationTask) task, new Date());\n+                execution = taskExecDAO.find(execution.getId());\n                 break;\n \n             case SCHED:\n-                break;\n-\n             case SYNC:\n+                JobDetail jobDetail = (JobDetail) ApplicationContextManager.\n+                        getApplicationContext().getBean(\n+                        JobInstanceLoader.getJobDetailName(task.getId()));\n+                jobDetail.setName(\n+                        JobInstanceLoader.getJobDetailName(task.getId()));\n+                jobDetail.setGroup(Scheduler.DEFAULT_GROUP);\n+                try {\n+                    scheduler.getScheduler().triggerJob(\n+                            JobInstanceLoader.getJobDetailName(task.getId()),\n+                            Scheduler.DEFAULT_GROUP);\n+                } catch (SchedulerException e) {\n+                    LOG.error(\"While executing task {}\", task, e);\n+\n+                    SyncopeClientCompositeErrorException scce =\n+                            new SyncopeClientCompositeErrorException(\n+                            HttpStatus.BAD_REQUEST);\n+                    SyncopeClientException sce = new SyncopeClientException(\n+                            SyncopeClientExceptionType.Scheduling);\n+                    sce.addElement(e.getMessage());\n+                    scce.addException(sce);\n+                    throw scce;\n+                }\n+\n+                // Re-read to get the latest execution started\n+                task = taskDAO.find(taskId);\n+                execution = taskExecDAO.findLatestStarted(task);\n                 break;\n         }\n+        LOG.debug(\"Execution finished for {}, {}\", task, execution);\n \n-        return taskDataBinder.getTaskExecutionTO(execution);\n+        return binder.getTaskExecutionTO(execution);\n     }\n \n     @PreAuthorize(\"hasRole('TASK_READ')\")\n@@ -271,7 +420,7 @@ public TaskExecTO report(\n         exec.setMessage(message);\n         exec = taskExecDAO.save(exec);\n \n-        return taskDataBinder.getTaskExecutionTO(exec);\n+        return binder.getTaskExecutionTO(exec);\n     }\n \n     @PreAuthorize(\"hasRole('TASK_DELETE')\")"},{"sha":"20235daf6bb7067fe1bb2efdcdefd544ce2b92bb","filename":"core/src/main/java/org/syncope/core/rest/data/TaskDataBinder.java","status":"modified","additions":94,"deletions":35,"changes":129,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Frest%2Fdata%2FTaskDataBinder.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Frest%2Fdata%2FTaskDataBinder.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Frest%2Fdata%2FTaskDataBinder.java?ref=fc5cd61d84f7e69a393d45b62a9f6e36e99c5718","patch":"@@ -14,19 +14,25 @@\n  */\n package org.syncope.core.rest.data;\n \n-import java.util.Date;\n import java.util.List;\n import javassist.NotFoundException;\n+import org.quartz.Scheduler;\n+import org.quartz.SchedulerException;\n+import org.quartz.Trigger;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.springframework.beans.BeanUtils;\n import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.scheduling.quartz.SchedulerFactoryBean;\n import org.springframework.stereotype.Component;\n+import org.syncope.client.mod.SchedTaskMod;\n+import org.syncope.client.mod.SyncTaskMod;\n import org.syncope.client.to.PropagationTaskTO;\n import org.syncope.client.to.SchedTaskTO;\n import org.syncope.client.to.SyncTaskTO;\n import org.syncope.client.to.TaskExecTO;\n import org.syncope.client.to.TaskTO;\n+import org.syncope.core.init.JobInstanceLoader;\n import org.syncope.core.persistence.beans.PropagationTask;\n import org.syncope.core.persistence.beans.SchedTask;\n import org.syncope.core.persistence.beans.SyncTask;\n@@ -60,52 +66,88 @@ public class TaskDataBinder {\n     @Autowired\n     private RoleDAO roleDAO;\n \n-    public SchedTask getSchedTask(final SchedTaskTO taskTO,\n+    @Autowired\n+    private SchedulerFactoryBean scheduler;\n+\n+    private void fill(final SyncTask task, final List<String> resources,\n+            final List<Long> roles, boolean updateIndentities) {\n+\n+        TargetResource resource;\n+        for (String resourceName : resources) {\n+            resource = resourceDAO.find(resourceName);\n+            if (resource == null) {\n+                LOG.warn(\"Ignoring invalid resource \" + resourceName);\n+            } else {\n+                ((SyncTask) task).addDefaultResource(resource);\n+            }\n+        }\n+\n+        SyncopeRole role;\n+        for (Long roleId : roles) {\n+            role = roleDAO.find(roleId);\n+            if (role == null) {\n+                LOG.warn(\"Ignoring invalid role \" + roleId);\n+            } else {\n+                ((SyncTask) task).addDefaultRole(role);\n+            }\n+        }\n+\n+        ((SyncTask) task).setUpdateIdentities(updateIndentities);\n+    }\n+\n+    public SchedTask createSchedTask(final SchedTaskTO taskTO,\n             final TaskUtil taskUtil)\n             throws NotFoundException {\n \n         SchedTask task = taskUtil.newTask();\n         task.setCronExpression(taskTO.getCronExpression());\n \n-        if (task instanceof SchedTask) {\n-            task.setJobClassName(taskTO.getJobClassName());\n-        }\n-        if (task instanceof SyncTask) {\n-            SyncTaskTO syncTaskTO = (SyncTaskTO) taskTO;\n+        switch (taskUtil) {\n+            case SCHED:\n+                task.setJobClassName(taskTO.getJobClassName());\n+                break;\n \n-            TargetResource resource = resourceDAO.find(syncTaskTO.getResource());\n-            if (resource == null) {\n-                throw new NotFoundException(\"Resource \"\n-                        + syncTaskTO.getResource());\n-            }\n-            ((SyncTask) task).setResource(resource);\n+            case SYNC:\n+                SyncTaskTO syncTaskTO = (SyncTaskTO) taskTO;\n \n-            for (String resourceName : syncTaskTO.getDefaultResources()) {\n-                resource = resourceDAO.find(resourceName);\n+                TargetResource resource = resourceDAO.find(syncTaskTO.\n+                        getResource());\n                 if (resource == null) {\n-                    LOG.warn(\"Ignoring invalid resource \" + resourceName);\n-                } else {\n-                    ((SyncTask) task).addDefaultResource(resource);\n-                }\n-            }\n-\n-            SyncopeRole role;\n-            for (Long roleId : syncTaskTO.getDefaultRoles()) {\n-                role = roleDAO.find(roleId);\n-                if (role == null) {\n-                    LOG.warn(\"Ignoring invalid role \" + roleId);\n-                } else {\n-                    ((SyncTask) task).addDefaultRole(role);\n+                    throw new NotFoundException(\"Resource \"\n+                            + syncTaskTO.getResource());\n                 }\n-            }\n+                ((SyncTask) task).setResource(resource);\n \n-            ((SyncTask) task).setUpdateIdentities(\n-                    syncTaskTO.isUpdateIdentities());\n+                fill((SyncTask) task, syncTaskTO.getDefaultResources(),\n+                        syncTaskTO.getDefaultRoles(),\n+                        syncTaskTO.isUpdateIdentities());\n+                break;\n         }\n \n         return task;\n     }\n \n+    public void updateSchedTask(final SchedTask task, final SchedTaskMod taskMod,\n+            final TaskUtil taskUtil) {\n+\n+        switch (taskUtil) {\n+            case SCHED:\n+                task.setCronExpression(taskMod.getCronExpression());\n+                break;\n+\n+            case SYNC:\n+                task.setCronExpression(taskMod.getCronExpression());\n+\n+                SyncTaskMod syncTaskMod = (SyncTaskMod) taskMod;\n+                fill((SyncTask) task, syncTaskMod.getDefaultResources(),\n+                        syncTaskMod.getDefaultRoles(),\n+                        syncTaskMod.isUpdateIdentities());\n+                ((SyncTask) task).setUpdateIdentities(\n+                        ((SyncTaskMod) taskMod).isUpdateIdentities());\n+                break;\n+        }\n+    }\n+\n     public TaskExecTO getTaskExecutionTO(final TaskExec execution) {\n         TaskExecTO executionTO = new TaskExecTO();\n         BeanUtils.copyProperties(execution, executionTO,\n@@ -115,7 +157,26 @@ public TaskExecTO getTaskExecutionTO(final TaskExec execution) {\n         return executionTO;\n     }\n \n+    private void setExecTime(final SchedTaskTO taskTO) {\n+        Trigger trigger;\n+        try {\n+            trigger = scheduler.getScheduler().getTrigger(\n+                    JobInstanceLoader.getTriggerName(taskTO.getId()),\n+                    Scheduler.DEFAULT_GROUP);\n+        } catch (SchedulerException e) {\n+            LOG.warn(\"While trying to get to \" + JobInstanceLoader.\n+                    getTriggerName(taskTO.getId()), e);\n+            trigger = null;\n+        }\n+\n+        if (trigger != null) {\n+            taskTO.setLastExec(trigger.getPreviousFireTime());\n+            taskTO.setNextExec(trigger.getNextFireTime());\n+        }\n+    }\n+\n     public TaskTO getTaskTO(final Task task, final TaskUtil taskUtil) {\n+\n         TaskTO taskTO = taskUtil.newTaskTO();\n         BeanUtils.copyProperties(task, taskTO, IGNORE_TASK_PROPERTIES);\n \n@@ -131,13 +192,11 @@ public TaskTO getTaskTO(final Task task, final TaskUtil taskUtil) {\n                 break;\n \n             case SCHED:\n-                ((SchedTaskTO) taskTO).setLastExec(new Date());\n-                ((SchedTaskTO) taskTO).setNextExec(new Date());\n+                setExecTime((SchedTaskTO) taskTO);\n                 break;\n \n             case SYNC:\n-                ((SyncTaskTO) taskTO).setLastExec(new Date());\n-                ((SyncTaskTO) taskTO).setNextExec(new Date());\n+                setExecTime((SchedTaskTO) taskTO);\n \n                 ((SyncTaskTO) taskTO).setResource(\n                         ((SyncTask) task).getResource().getName());"},{"sha":"4b59fbd7428b4d90b5a1022fae2ee48f720a7942","filename":"core/src/main/java/org/syncope/core/scheduling/AbstractJob.java","status":"added","additions":90,"deletions":0,"changes":90,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Fscheduling%2FAbstractJob.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Fscheduling%2FAbstractJob.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Fscheduling%2FAbstractJob.java?ref=fc5cd61d84f7e69a393d45b62a9f6e36e99c5718","patch":"@@ -0,0 +1,90 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.syncope.core.scheduling;\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.util.Date;\n+import org.quartz.JobExecutionException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.transaction.annotation.Transactional;\n+import org.syncope.core.persistence.beans.Task;\n+import org.syncope.core.persistence.beans.TaskExec;\n+import org.syncope.core.persistence.dao.TaskDAO;\n+import org.syncope.core.persistence.dao.TaskExecDAO;\n+\n+public abstract class AbstractJob implements Job {\n+\n+    /**\n+     * Logger.\n+     */\n+    protected static final Logger LOG = LoggerFactory.getLogger(\n+            AbstractJob.class);\n+\n+    protected static final String SUCCESS = \"SUCCESS\";\n+\n+    protected static final String FAILURE = \"FAILURE\";\n+\n+    @Autowired\n+    private TaskDAO taskDAO;\n+\n+    @Autowired\n+    private TaskExecDAO taskExecDAO;\n+\n+    private Long taskId;\n+\n+    public void setTaskId(Long taskId) {\n+        this.taskId = taskId;\n+    }\n+\n+    @Override\n+    @Transactional(rollbackFor = Throwable.class)\n+    public final void execute()\n+            throws JobExecutionException {\n+\n+        final Task task = taskDAO.find(taskId);\n+        if (task == null) {\n+            throw new JobExecutionException(\"Task \" + taskId + \" not found\");\n+        }\n+\n+        TaskExec execution = new TaskExec();\n+        execution.setStartDate(new Date());\n+        execution.setTask(task);\n+\n+        String message;\n+        try {\n+            message = doExecute();\n+\n+            execution.setStatus(SUCCESS);\n+        } catch (JobExecutionException e) {\n+            LOG.error(\"While executing task \" + taskId, e);\n+\n+            StringWriter exceptionWriter = new StringWriter();\n+            exceptionWriter.write(e.getMessage() + \"\\n\\n\");\n+            e.printStackTrace(new PrintWriter(exceptionWriter));\n+            message = exceptionWriter.toString();\n+\n+            execution.setStatus(FAILURE);\n+        }\n+        execution.setMessage(message);\n+        execution.setEndDate(new Date());\n+\n+        taskExecDAO.save(execution);\n+    }\n+\n+    protected abstract String doExecute()\n+            throws JobExecutionException;\n+}"},{"sha":"d771023ad655790308519d0a07d7a2bf20e385fc","filename":"core/src/main/java/org/syncope/core/scheduling/SampleJob.java","status":"modified","additions":4,"deletions":10,"changes":14,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Fscheduling%2FSampleJob.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Fscheduling%2FSampleJob.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Fscheduling%2FSampleJob.java?ref=fc5cd61d84f7e69a393d45b62a9f6e36e99c5718","patch":"@@ -14,21 +14,15 @@\n package org.syncope.core.scheduling;\n \n import org.quartz.JobExecutionException;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n \n-public class SampleJob implements Job {\n-\n-    /**\n-     * Logger.\n-     */\n-    private static final Logger LOG =\n-            LoggerFactory.getLogger(SampleJob.class);\n+public class SampleJob extends AbstractJob {\n \n     @Override\n-    public void execute()\n+    protected String doExecute()\n             throws JobExecutionException {\n \n         LOG.info(\"SampleJob running\");\n+\n+        return \"RUNNING\";\n     }\n }"},{"sha":"cb6177e9b45158ec9502614c3bcc021f1122a289","filename":"core/src/main/java/org/syncope/core/scheduling/SyncJob.java","status":"modified","additions":4,"deletions":10,"changes":14,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Fscheduling%2FSyncJob.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Fscheduling%2FSyncJob.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Fscheduling%2FSyncJob.java?ref=fc5cd61d84f7e69a393d45b62a9f6e36e99c5718","patch":"@@ -14,21 +14,15 @@\n package org.syncope.core.scheduling;\n \n import org.quartz.JobExecutionException;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n \n-public class SyncJob implements Job {\n-\n-    /**\n-     * Logger.\n-     */\n-    private static final Logger LOG =\n-            LoggerFactory.getLogger(SyncJob.class);\n+public class SyncJob extends AbstractJob {\n \n     @Override\n-    public void execute()\n+    protected String doExecute()\n             throws JobExecutionException {\n \n         LOG.info(\"SyncJob running\");\n+\n+        return \"MO SCI\";\n     }\n }"},{"sha":"0cd352286e85f932f2802849154f7d80bca8a2ca","filename":"core/src/main/java/org/syncope/core/util/TaskUtil.java","status":"modified","additions":18,"deletions":0,"changes":18,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Futil%2FTaskUtil.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Futil%2FTaskUtil.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Futil%2FTaskUtil.java?ref=fc5cd61d84f7e69a393d45b62a9f6e36e99c5718","patch":"@@ -47,6 +47,24 @@ public <T extends Task> Class<T> taskClass() {\n         return result;\n     }\n \n+    public <T extends Task> T newTask() {\n+        T result = null;\n+\n+        switch (this) {\n+            case PROPAGATION:\n+                result = (T) new PropagationTask();\n+                break;\n+            case SCHED:\n+                result = (T) new SchedTask();\n+                break;\n+            case SYNC:\n+                result = (T) new SyncTask();\n+                break;\n+        }\n+\n+        return result;\n+    }\n+\n     public <T extends TaskTO> Class<T> taskTOClass() {\n         Class result = null;\n "},{"sha":"62366b473ee336dacf8718a61bb4bda7544c1937","filename":"core/src/main/resources/content.xml","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/core%2Fsrc%2Fmain%2Fresources%2Fcontent.xml","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/core%2Fsrc%2Fmain%2Fresources%2Fcontent.xml","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fresources%2Fcontent.xml?ref=fc5cd61d84f7e69a393d45b62a9f6e36e99c5718","patch":"@@ -97,6 +97,7 @@\n     <Entitlement name=\"TASK_LIST\"/>\n     <Entitlement name=\"TASK_EXECUTE\"/>\n     <Entitlement name=\"TASK_READ\"/>\n+    <Entitlement name=\"TASK_UPDATE\"/>\n     <Entitlement name=\"TASK_DELETE\"/>\n     <Entitlement name=\"LOG_LIST\"/>\n     <Entitlement name=\"LOG_SET_LEVEL\"/>"},{"sha":"2b5d92b64be7c001993c3dce87630910fb9a95a9","filename":"core/src/test/java/jpasymphony/dao/JPAWorkflowEntryTest.java","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/core%2Fsrc%2Ftest%2Fjava%2Fjpasymphony%2Fdao%2FJPAWorkflowEntryTest.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/core%2Fsrc%2Ftest%2Fjava%2Fjpasymphony%2Fdao%2FJPAWorkflowEntryTest.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Ftest%2Fjava%2Fjpasymphony%2Fdao%2FJPAWorkflowEntryTest.java?ref=fc5cd61d84f7e69a393d45b62a9f6e36e99c5718","patch":"@@ -30,6 +30,7 @@\n @ContextConfiguration(locations = {\n     \"classpath:syncopeContext.xml\",\n     \"classpath:persistenceContext.xml\",\n+    \"classpath:schedulingContext.xml\",\n     \"classpath:workflowContext.xml\"\n })\n public class JPAWorkflowEntryTest {"},{"sha":"a23bc3c97ebf12615eed18c75f1f99f6c8ef8e86","filename":"core/src/test/java/jpasymphony/relationships/JPAWorkflowEntryTest.java","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/core%2Fsrc%2Ftest%2Fjava%2Fjpasymphony%2Frelationships%2FJPAWorkflowEntryTest.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/core%2Fsrc%2Ftest%2Fjava%2Fjpasymphony%2Frelationships%2FJPAWorkflowEntryTest.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Ftest%2Fjava%2Fjpasymphony%2Frelationships%2FJPAWorkflowEntryTest.java?ref=fc5cd61d84f7e69a393d45b62a9f6e36e99c5718","patch":"@@ -36,6 +36,7 @@\n @ContextConfiguration(locations = {\n     \"classpath:syncopeContext.xml\",\n     \"classpath:persistenceContext.xml\",\n+    \"classpath:schedulingContext.xml\",\n     \"classpath:workflowContext.xml\"\n })\n public class JPAWorkflowEntryTest {"},{"sha":"a2fbb7fc394344d13966752ac9634a656e2a9938","filename":"core/src/test/java/org/syncope/core/persistence/AbstractTest.java","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fsyncope%2Fcore%2Fpersistence%2FAbstractTest.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fsyncope%2Fcore%2Fpersistence%2FAbstractTest.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fsyncope%2Fcore%2Fpersistence%2FAbstractTest.java?ref=fc5cd61d84f7e69a393d45b62a9f6e36e99c5718","patch":"@@ -33,6 +33,7 @@\n @ContextConfiguration(locations = {\n     \"classpath:syncopeContext.xml\",\n     \"classpath:persistenceContext.xml\",\n+    \"classpath:schedulingContext.xml\",\n     \"classpath:workflowContext.xml\"\n })\n public abstract class AbstractTest {"},{"sha":"3433e1769671190c674beb3cee419dbe96fd3d75","filename":"core/src/test/java/org/syncope/core/persistence/dao/EntitlementTest.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2FEntitlementTest.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2FEntitlementTest.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2FEntitlementTest.java?ref=fc5cd61d84f7e69a393d45b62a9f6e36e99c5718","patch":"@@ -36,7 +36,7 @@ public final void findAll() {\n         List<Entitlement> list = entitlementDAO.findAll();\n         // 41 real entitlements + 8 role entitlements\n         assertEquals(\"did not get expected number of entitlements \",\n-                49, list.size());\n+                50, list.size());\n     }\n \n     @Test"},{"sha":"23b03b201a5fa8087ed8dcf14a383808118244d1","filename":"core/src/test/java/org/syncope/core/persistence/dao/TaskExecTest.java","status":"modified","additions":13,"deletions":0,"changes":13,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2FTaskExecTest.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2FTaskExecTest.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2FTaskExecTest.java?ref=fc5cd61d84f7e69a393d45b62a9f6e36e99c5718","patch":"@@ -30,9 +30,22 @@ public class TaskExecTest extends AbstractTest {\n     @Autowired\n     private TaskExecDAO taskExecDAO;\n \n+    @Autowired\n+    private TaskDAO taskDAO;\n+\n     @Test\n     public final void findAll() {\n         List<TaskExec> list = taskExecDAO.findAll(PropagationTask.class);\n         assertEquals(1, list.size());\n     }\n+\n+    @Test\n+    public final void findLatestStarted() {\n+        PropagationTask task = taskDAO.find(1L);\n+        assertNotNull(task);\n+\n+        TaskExec latestStarted = taskExecDAO.findLatestStarted(task);\n+        assertNotNull(latestStarted);\n+        assertEquals(Long.valueOf(1L), latestStarted.getId());\n+    }\n }"},{"sha":"e7923805d1dcfbe15418657ef4ceacd985794659","filename":"core/src/test/java/org/syncope/core/persistence/dao/TaskTest.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2FTaskTest.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2FTaskTest.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2FTaskTest.java?ref=fc5cd61d84f7e69a393d45b62a9f6e36e99c5718","patch":"@@ -107,8 +107,8 @@ public final void saveSyncTask() {\n         }\n         assertNotNull(exception);\n \n-        // this save() finally works\n         task.setResource(resource);\n+        // this save() finally works\n         task = taskDAO.save(task);\n         assertNotNull(task);\n "},{"sha":"5411d86306fa25bad9729c1a9613a3625d3bdf3c","filename":"core/src/test/java/org/syncope/core/persistence/dao/UserSearchTest.java","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2FUserSearchTest.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2FUserSearchTest.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2FUserSearchTest.java?ref=fc5cd61d84f7e69a393d45b62a9f6e36e99c5718","patch":"@@ -35,6 +35,7 @@\n @ContextConfiguration(locations = {\n     \"classpath:syncopeContext.xml\",\n     \"classpath:persistenceContext.xml\",\n+    \"classpath:schedulingContext.xml\",\n     \"classpath:workflowContext.xml\"\n })\n @Transactional"},{"sha":"ce7fd5d1a6b8f839ac877d8006193123f1eda0c1","filename":"core/src/test/java/org/syncope/core/rest/AbstractTest.java","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fsyncope%2Fcore%2Frest%2FAbstractTest.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fsyncope%2Fcore%2Frest%2FAbstractTest.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fsyncope%2Fcore%2Frest%2FAbstractTest.java?ref=fc5cd61d84f7e69a393d45b62a9f6e36e99c5718","patch":"@@ -31,6 +31,7 @@\n     \"classpath:syncopeContext.xml\",\n     \"classpath:persistenceContext.xml\",\n     \"classpath:workflowContext.xml\",\n+    \"classpath:schedulingContext.xml\",\n     \"classpath:restContext.xml\"\n })\n public abstract class AbstractTest {"},{"sha":"b5c8c9754588ff20301d81dbbdd6f4bba74d5be0","filename":"core/src/test/java/org/syncope/core/rest/ConnInstanceTestITCase.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fsyncope%2Fcore%2Frest%2FConnInstanceTestITCase.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fsyncope%2Fcore%2Frest%2FConnInstanceTestITCase.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fsyncope%2Fcore%2Frest%2FConnInstanceTestITCase.java?ref=fc5cd61d84f7e69a393d45b62a9f6e36e99c5718","patch":"@@ -261,7 +261,7 @@ public void read() {\n     public void check() {\n         Boolean verify = restTemplate.getForObject(\n                 BASE_URL + \"connector/check/{connectorId}.json\",\n-                Boolean.class, 100L);\n+                Boolean.class, \"connInstance100\");\n \n         assertTrue(verify);\n     }"},{"sha":"a9fe8506f5a6cea3400201f4ec64ab7692123216","filename":"core/src/test/java/org/syncope/core/rest/TaskTestITCase.java","status":"modified","additions":40,"deletions":0,"changes":40,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fsyncope%2Fcore%2Frest%2FTaskTestITCase.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fsyncope%2Fcore%2Frest%2FTaskTestITCase.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fsyncope%2Fcore%2Frest%2FTaskTestITCase.java?ref=fc5cd61d84f7e69a393d45b62a9f6e36e99c5718","patch":"@@ -21,15 +21,55 @@\n import org.junit.Test;\n import org.springframework.http.HttpStatus;\n import org.springframework.web.client.HttpStatusCodeException;\n+import org.syncope.client.mod.SchedTaskMod;\n import org.syncope.client.to.TaskExecTO;\n import org.syncope.client.to.PropagationTaskTO;\n+import org.syncope.client.to.SchedTaskTO;\n import org.syncope.client.to.TaskTO;\n import org.syncope.client.validation.SyncopeClientCompositeErrorException;\n+import org.syncope.core.scheduling.SampleJob;\n import org.syncope.types.PropagationTaskExecStatus;\n import org.syncope.types.SyncopeClientExceptionType;\n \n public class TaskTestITCase extends AbstractTest {\n \n+    @Test\n+    public final void create() {\n+        SchedTaskTO task = new SchedTaskTO();\n+        task.setJobClassName(SampleJob.class.getName());\n+\n+        SchedTaskTO actual = restTemplate.postForObject(\n+                BASE_URL + \"task/create\",\n+                task, SchedTaskTO.class);\n+        assertNotNull(actual);\n+\n+        task = restTemplate.getForObject(\n+                BASE_URL + \"task/read/{taskId}\", SchedTaskTO.class,\n+                actual.getId());\n+        assertNotNull(task);\n+        assertEquals(actual.getId(), task.getId());\n+        assertEquals(actual.getJobClassName(), task.getJobClassName());\n+    }\n+\n+    @Test\n+    public final void update() {\n+        SchedTaskTO task = restTemplate.getForObject(\n+                BASE_URL + \"task/read/{taskId}\", SchedTaskTO.class,\n+                4);\n+        assertNotNull(task);\n+\n+        SchedTaskMod taskMod = new SchedTaskMod();\n+        taskMod.setId(4);\n+        taskMod.setCronExpression(null);\n+\n+        SchedTaskTO actual = restTemplate.postForObject(\n+                BASE_URL + \"task/update\",\n+                taskMod, SchedTaskTO.class);\n+        assertNotNull(actual);\n+        assertEquals(task.getId(), actual.getId());\n+        assertNull(actual.getCronExpression());\n+    }\n+\n     @Test\n     public final void count() {\n         Integer count = restTemplate.getForObject("},{"sha":"9b25e1bb95816cacbbbf1daa78fa80ded09fe38d","filename":"core/src/test/resources/content.xml","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/core%2Fsrc%2Ftest%2Fresources%2Fcontent.xml","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/core%2Fsrc%2Ftest%2Fresources%2Fcontent.xml","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Ftest%2Fresources%2Fcontent.xml?ref=fc5cd61d84f7e69a393d45b62a9f6e36e99c5718","patch":"@@ -397,6 +397,7 @@\n     <Entitlement name=\"TASK_LIST\"/>\n     <Entitlement name=\"TASK_EXECUTE\"/>\n     <Entitlement name=\"TASK_READ\"/>\n+    <Entitlement name=\"TASK_UPDATE\"/>\n     <Entitlement name=\"TASK_DELETE\"/>\n     <Entitlement name=\"LOG_LIST\"/>\n     <Entitlement name=\"LOG_SET_LEVEL\"/>"},{"sha":"979f70f4d74515d39beb083b2bb7f96401891432","filename":"core/src/test/resources/spring.jsp","status":"added","additions":32,"deletions":0,"changes":32,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/core%2Fsrc%2Ftest%2Fresources%2Fspring.jsp","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718/core%2Fsrc%2Ftest%2Fresources%2Fspring.jsp","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Ftest%2Fresources%2Fspring.jsp?ref=fc5cd61d84f7e69a393d45b62a9f6e36e99c5718","patch":"@@ -0,0 +1,32 @@\n+<%@page import=\"org.syncope.core.util.ApplicationContextManager\"%>\n+<%@page import=\"org.springframework.context.ConfigurableApplicationContext\"%>\n+<%@page contentType=\"text/html\" pageEncoding=\"UTF-8\"%>\n+<html>\n+    <head>\n+        <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n+        <title>Spring beans</title>\n+    </head>\n+    <body>\n+        <h1>Spring beans</h1>\n+        <%\n+                    ConfigurableApplicationContext context =\n+                            ApplicationContextManager.getApplicationContext();\n+        %>\n+        <h2>Singletons</h2>\n+        <ul><%\n+        String[] singletons = context.getBeanFactory().getSingletonNames();\n+        for (String bean: singletons) {\n+            %><li><%=bean%></li><%\n+        }\n+            %>\n+        </ul>\n+        <h2>Bean definitions</h2>\n+            <ul><%\n+        String[] prototypes = context.getBeanFactory().getBeanDefinitionNames();\n+        for (String bean: prototypes) {\n+            %><li><%=bean%></li><%\n+        }\n+            %>\n+        </ul>\n+    </body>\n+</html>"}]}