{"sha":"751cf78a522213d1af8d616492a223a32f37cbf8","node_id":"MDY6Q29tbWl0NjM2ODc5MDYyOjc1MWNmNzhhNTIyMjEzZDFhZjhkNjE2NDkyYTIyM2EzMmYzN2NiZjg=","commit":{"author":{"name":"Francesco Chicchiriccò","email":"ilgrosso@apache.org","date":"2013-10-01T14:35:11Z"},"committer":{"name":"Francesco Chicchiriccò","email":"ilgrosso@apache.org","date":"2013-10-01T14:35:11Z"},"message":"[SYNCOPE-419] Providing dedicated exception type + audit message in case of user delete failure\n\ngit-svn-id: https://svn.apache.org/repos/asf/syncope/branches/1_1_X@1528106 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"b200261cc314a4b16b6061beecfd2b9d5287ab9a","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/git/trees/b200261cc314a4b16b6061beecfd2b9d5287ab9a"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/git/commits/751cf78a522213d1af8d616492a223a32f37cbf8","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/751cf78a522213d1af8d616492a223a32f37cbf8","html_url":"https://github.com/EnricoDAlessandro97UNI/syncope/commit/751cf78a522213d1af8d616492a223a32f37cbf8","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/751cf78a522213d1af8d616492a223a32f37cbf8/comments","author":{"login":"ilgrosso","id":1064664,"node_id":"MDQ6VXNlcjEwNjQ2NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/1064664?v=4","gravatar_id":"","url":"https://api.github.com/users/ilgrosso","html_url":"https://github.com/ilgrosso","followers_url":"https://api.github.com/users/ilgrosso/followers","following_url":"https://api.github.com/users/ilgrosso/following{/other_user}","gists_url":"https://api.github.com/users/ilgrosso/gists{/gist_id}","starred_url":"https://api.github.com/users/ilgrosso/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ilgrosso/subscriptions","organizations_url":"https://api.github.com/users/ilgrosso/orgs","repos_url":"https://api.github.com/users/ilgrosso/repos","events_url":"https://api.github.com/users/ilgrosso/events{/privacy}","received_events_url":"https://api.github.com/users/ilgrosso/received_events","type":"User","site_admin":false},"committer":{"login":"ilgrosso","id":1064664,"node_id":"MDQ6VXNlcjEwNjQ2NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/1064664?v=4","gravatar_id":"","url":"https://api.github.com/users/ilgrosso","html_url":"https://github.com/ilgrosso","followers_url":"https://api.github.com/users/ilgrosso/followers","following_url":"https://api.github.com/users/ilgrosso/following{/other_user}","gists_url":"https://api.github.com/users/ilgrosso/gists{/gist_id}","starred_url":"https://api.github.com/users/ilgrosso/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ilgrosso/subscriptions","organizations_url":"https://api.github.com/users/ilgrosso/orgs","repos_url":"https://api.github.com/users/ilgrosso/repos","events_url":"https://api.github.com/users/ilgrosso/events{/privacy}","received_events_url":"https://api.github.com/users/ilgrosso/received_events","type":"User","site_admin":false},"parents":[{"sha":"99604ad4eb54d7d5e2df1a2d0862d30c203b7ee0","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/99604ad4eb54d7d5e2df1a2d0862d30c203b7ee0","html_url":"https://github.com/EnricoDAlessandro97UNI/syncope/commit/99604ad4eb54d7d5e2df1a2d0862d30c203b7ee0"}],"stats":{"total":337,"additions":183,"deletions":154},"files":[{"sha":"f1621af45f65176c09bd586a0d915e3407eda902","filename":"common/src/main/java/org/apache/syncope/common/types/SyncopeClientExceptionType.java","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/751cf78a522213d1af8d616492a223a32f37cbf8/common%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Ftypes%2FSyncopeClientExceptionType.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/751cf78a522213d1af8d616492a223a32f37cbf8/common%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Ftypes%2FSyncopeClientExceptionType.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/common%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Ftypes%2FSyncopeClientExceptionType.java?ref=751cf78a522213d1af8d616492a223a32f37cbf8","patch":"@@ -63,6 +63,7 @@ public enum SyncopeClientExceptionType {\n     NotFound(\"Syncope.NotFound\", \"Syncope.NotFound.entity\"),\r\n     RejectedUserCreate(\"Syncope.RejectUserCreate\", \"Syncope.RejectUserCreate.userId\"),\r\n     RequiredValuesMissing(\"Syncope.RequiredValuesMissing\", \"Syncope.RequiredValuesMissing.attributeName\"),\r\n+    RoleOwnership(\"Syncope.RoleOwnership\", \"Syncope.RoleOwnership.role\"),\r\n     Scheduling(\"Syncope.Scheduling\", \"Syncope.Scheduling.message\"),\r\n     UnauthorizedRole(\"Syncope.UnauthorizedRole\", \"Syncope.UnauthorizedRole.id\"),\r\n     Unknown(\"Syncope.Unknown\", \"\"),\r"},{"sha":"41c72b4d01d8fbba2100835ea07b3e8688c52f9d","filename":"core/src/main/java/org/apache/syncope/core/rest/controller/UserController.java","status":"modified","additions":182,"deletions":154,"changes":336,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/751cf78a522213d1af8d616492a223a32f37cbf8/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Frest%2Fcontroller%2FUserController.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/751cf78a522213d1af8d616492a223a32f37cbf8/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Frest%2Fcontroller%2FUserController.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Frest%2Fcontroller%2FUserController.java?ref=751cf78a522213d1af8d616492a223a32f37cbf8","patch":"@@ -42,12 +42,17 @@\n import org.apache.syncope.common.types.AuditElements.Result;\n import org.apache.syncope.common.types.AuditElements.UserSubCategory;\n import org.apache.syncope.common.types.ResourceOperation;\n+import org.apache.syncope.common.types.SyncopeClientExceptionType;\n+import org.apache.syncope.common.validation.SyncopeClientCompositeErrorException;\n+import org.apache.syncope.common.validation.SyncopeClientException;\n import org.apache.syncope.core.audit.AuditManager;\n import org.apache.syncope.core.connid.ConnObjectUtil;\n import org.apache.syncope.core.notification.NotificationManager;\n import org.apache.syncope.core.persistence.beans.PropagationTask;\n+import org.apache.syncope.core.persistence.beans.role.SyncopeRole;\n import org.apache.syncope.core.persistence.beans.user.SyncopeUser;\n import org.apache.syncope.core.persistence.dao.AttributableSearchDAO;\n+import org.apache.syncope.core.persistence.dao.RoleDAO;\n import org.apache.syncope.core.persistence.dao.UserDAO;\n import org.apache.syncope.core.propagation.PropagationByResource;\n import org.apache.syncope.core.propagation.PropagationException;\n@@ -62,6 +67,7 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.http.HttpStatus;\n import org.springframework.security.access.prepost.PreAuthorize;\n import org.springframework.security.core.context.SecurityContextHolder;\n import org.springframework.stereotype.Controller;\n@@ -87,28 +93,31 @@ public class UserController {\n      * Logger.\n      */\n     protected static final Logger LOG = LoggerFactory.getLogger(UserController.class);\n-\n+    \n     @Autowired\n     protected AuditManager auditManager;\n-\n+    \n     @Autowired\n     protected UserDAO userDAO;\n-\n+    \n+    @Autowired\n+    protected RoleDAO roleDAO;\n+    \n     @Autowired\n     protected AttributableSearchDAO searchDAO;\n-\n+    \n     @Autowired\n     protected UserDataBinder binder;\n-\n+    \n     @Autowired\n     protected UserWorkflowAdapter uwfAdapter;\n-\n+    \n     @Autowired\n     protected PropagationManager propagationManager;\n-\n+    \n     @Autowired\n     protected PropagationTaskExecutor taskExecutor;\n-\n+    \n     @Autowired\n     protected NotificationManager notificationManager;\n \n@@ -117,189 +126,189 @@ public class UserController {\n      */\n     @Autowired\n     protected ConnObjectUtil connObjectUtil;\n-\n+    \n     @RequestMapping(method = RequestMethod.GET, value = \"/verifyPassword/{username}\")\n     public ModelAndView verifyPassword(@PathVariable(\"username\") String username,\n             @RequestParam(\"password\") final String password) {\n-\n+        \n         return new ModelAndView().addObject(verifyPasswordInternal(username, password));\n     }\n-\n+    \n     @PreAuthorize(\"hasRole('USER_READ')\")\n     @Transactional(readOnly = true)\n     public Boolean verifyPasswordInternal(final String username, final String password) {\n         auditManager.audit(Category.user, UserSubCategory.create, Result.success,\n                 \"Verified password for: \" + username);\n         return binder.verifyPassword(username, password);\n     }\n-\n+    \n     @RequestMapping(method = RequestMethod.GET, value = \"/count\")\n     public ModelAndView count() {\n         return new ModelAndView().addObject(countInternal());\n     }\n-\n+    \n     @PreAuthorize(\"hasRole('USER_LIST')\")\n     @Transactional(readOnly = true, rollbackFor = {Throwable.class})\n     public int countInternal() {\n         return userDAO.count(EntitlementUtil.getRoleIds(EntitlementUtil.getOwnedEntitlementNames()));\n     }\n-\n+    \n     @RequestMapping(method = RequestMethod.POST, value = \"/search/count\")\n     public ModelAndView searchCount(@RequestBody final NodeCond searchCondition)\n             throws InvalidSearchConditionException {\n-\n+        \n         return new ModelAndView().addObject(searchCountInternal(searchCondition));\n     }\n-\n+    \n     @PreAuthorize(\"hasRole('USER_READ')\")\n     @Transactional(readOnly = true, rollbackFor = {Throwable.class})\n     public int searchCountInternal(final NodeCond searchCondition) throws InvalidSearchConditionException {\n         if (!searchCondition.isValid()) {\n             LOG.error(\"Invalid search condition: {}\", searchCondition);\n             throw new InvalidSearchConditionException();\n         }\n-\n+        \n         return searchDAO.count(EntitlementUtil.getRoleIds(EntitlementUtil.getOwnedEntitlementNames()),\n                 searchCondition, AttributableUtil.getInstance(AttributableType.USER));\n     }\n-\n+    \n     @PreAuthorize(\"hasRole('USER_LIST')\")\n     @RequestMapping(method = RequestMethod.GET, value = \"/list\")\n     @Transactional(readOnly = true, rollbackFor = {Throwable.class})\n     public List<UserTO> list() {\n         List<SyncopeUser> users =\n                 userDAO.findAll(EntitlementUtil.getRoleIds(EntitlementUtil.getOwnedEntitlementNames()));\n-\n+        \n         List<UserTO> userTOs = new ArrayList<UserTO>(users.size());\n         for (SyncopeUser user : users) {\n             userTOs.add(binder.getUserTO(user));\n         }\n-\n+        \n         auditManager.audit(Category.user, UserSubCategory.list, Result.success,\n                 \"Successfully listed all users: \" + userTOs.size());\n-\n+        \n         return userTOs;\n     }\n-\n+    \n     @PreAuthorize(\"hasRole('USER_LIST')\")\n     @RequestMapping(method = RequestMethod.GET, value = \"/list/{page}/{size}\")\n     @Transactional(readOnly = true, rollbackFor = {Throwable.class})\n     public List<UserTO> list(@PathVariable(\"page\") final int page, @PathVariable(\"size\") final int size) {\n         Set<Long> adminRoleIds = EntitlementUtil.getRoleIds(EntitlementUtil.getOwnedEntitlementNames());\n-\n+        \n         List<SyncopeUser> users = userDAO.findAll(adminRoleIds, page, size);\n         List<UserTO> userTOs = new ArrayList<UserTO>(users.size());\n         for (SyncopeUser user : users) {\n             userTOs.add(binder.getUserTO(user));\n         }\n-\n+        \n         auditManager.audit(Category.user, UserSubCategory.list, Result.success,\n                 \"Successfully listed all users (page=\" + page + \", size=\" + size + \"): \" + userTOs.size());\n-\n+        \n         return userTOs;\n     }\n-\n+    \n     @PreAuthorize(\"hasRole('USER_READ')\")\n     @RequestMapping(method = RequestMethod.GET, value = \"/read/{userId}\")\n     @Transactional(readOnly = true, rollbackFor = {Throwable.class})\n     public UserTO read(@PathVariable(\"userId\") final Long userId) {\n         UserTO result = binder.getUserTO(userId);\n-\n+        \n         auditManager.audit(Category.user, UserSubCategory.read, Result.success,\n                 \"Successfully read user: \" + userId);\n-\n+        \n         return result;\n     }\n-\n+    \n     @PreAuthorize(\"#username == authentication.name or hasRole('USER_READ')\")\n     @RequestMapping(method = RequestMethod.GET, value = \"/readByUsername/{username}\")\n     @Transactional(readOnly = true, rollbackFor = {Throwable.class})\n     public UserTO read(@PathVariable final String username) {\n         UserTO result = binder.getUserTO(username);\n-\n+        \n         auditManager.audit(Category.user, UserSubCategory.read, Result.success,\n                 \"Successfully read user: \" + username);\n-\n+        \n         return result;\n     }\n-\n+    \n     @PreAuthorize(\"isAuthenticated()\")\n     @RequestMapping(method = RequestMethod.GET, value = \"/read/self\")\n     @Transactional(readOnly = true)\n     public UserTO read() {\n         UserTO userTO = binder.getAuthenticatedUserTO();\n-\n+        \n         auditManager.audit(Category.user, UserSubCategory.read, Result.success,\n                 \"Successfully read own data: \" + userTO.getUsername());\n-\n+        \n         return userTO;\n     }\n-\n+    \n     @PreAuthorize(\"hasRole('USER_READ')\")\n     @RequestMapping(method = RequestMethod.POST, value = \"/search\")\n     @Transactional(readOnly = true, rollbackFor = {Throwable.class})\n     public List<UserTO> search(@RequestBody final NodeCond searchCondition)\n             throws InvalidSearchConditionException {\n-\n+        \n         return search(searchCondition, -1, -1);\n     }\n-\n+    \n     @PreAuthorize(\"hasRole('USER_READ')\")\n     @RequestMapping(method = RequestMethod.POST, value = \"/search/{page}/{size}\")\n     @Transactional(readOnly = true, rollbackFor = {Throwable.class})\n     public List<UserTO> search(@RequestBody final NodeCond searchCondition, @PathVariable(\"page\") final int page,\n             @PathVariable(\"size\") final int size)\n             throws InvalidSearchConditionException {\n-\n+        \n         LOG.debug(\"User search called with condition {}\", searchCondition);\n-\n+        \n         if (!searchCondition.isValid()) {\n             LOG.error(\"Invalid search condition: {}\", searchCondition);\n             throw new InvalidSearchConditionException();\n         }\n-\n+        \n         final List<SyncopeUser> matchingUsers = searchDAO.search(EntitlementUtil.getRoleIds(EntitlementUtil.\n                 getOwnedEntitlementNames()), searchCondition, page, size,\n                 AttributableUtil.getInstance(AttributableType.USER));\n-\n+        \n         final List<UserTO> result = new ArrayList<UserTO>(matchingUsers.size());\n         for (SyncopeUser user : matchingUsers) {\n             result.add(binder.getUserTO(user));\n         }\n-\n+        \n         auditManager.audit(Category.user, UserSubCategory.read, Result.success,\n                 \"Successfully searched for users (page=\" + page + \", size=\" + size + \"): \" + result.size());\n-\n+        \n         return result;\n     }\n-\n+    \n     @RequestMapping(method = RequestMethod.POST, value = \"/create\")\n     public UserTO create(final HttpServletResponse response, @RequestBody final UserTO userTO) {\n         UserTO savedTO = createInternal(userTO);\n         response.setStatus(HttpServletResponse.SC_CREATED);\n         return savedTO;\n     }\n-\n+    \n     @PreAuthorize(\"hasRole('USER_CREATE')\")\n     public UserTO createInternal(final UserTO userTO) {\n         LOG.debug(\"User create called with {}\", userTO);\n-\n+        \n         Set<Long> requestRoleIds = new HashSet<Long>(userTO.getMemberships().size());\n         for (MembershipTO membership : userTO.getMemberships()) {\n             requestRoleIds.add(membership.getRoleId());\n         }\n-\n+        \n         Set<Long> adminRoleIds = EntitlementUtil.getRoleIds(EntitlementUtil.getOwnedEntitlementNames());\n         requestRoleIds.removeAll(adminRoleIds);\n         if (!requestRoleIds.isEmpty()) {\n             throw new UnauthorizedRoleException(requestRoleIds);\n         }\n-\n+        \n         WorkflowResult<Map.Entry<Long, Boolean>> created = uwfAdapter.create(userTO);\n-\n+        \n         List<PropagationTask> tasks = propagationManager.getUserCreateTaskIds(\n                 created, userTO.getPassword(), userTO.getVirtualAttributes());\n-\n+        \n         final List<PropagationStatusTO> propagations = new ArrayList<PropagationStatusTO>();\n         final DefaultPropagationHandler propHanlder = new DefaultPropagationHandler(connObjectUtil, propagations);\n         try {\n@@ -308,25 +317,25 @@ public UserTO createInternal(final UserTO userTO) {\n             LOG.error(\"Error propagation primary resource\", e);\n             propHanlder.completeWhenPrimaryResourceErrored(propagations, tasks);\n         }\n-\n+        \n         notificationManager.createTasks(created.getResult().getKey(), created.getPerformedTasks());\n-\n+        \n         final UserTO savedTO = binder.getUserTO(created.getResult().getKey());\n         savedTO.setPropagationStatusTOs(propagations);\n-\n+        \n         LOG.debug(\"About to return created user\\n{}\", savedTO);\n-\n+        \n         auditManager.audit(Category.user, UserSubCategory.create, Result.success,\n                 \"Successfully created user: \" + savedTO.getUsername());\n-\n+        \n         return savedTO;\n     }\n-\n+    \n     @PreAuthorize(\"hasRole('USER_UPDATE')\")\n     @RequestMapping(method = RequestMethod.POST, value = \"/update\")\n     public UserTO update(@RequestBody final UserMod userMod) {\n         LOG.debug(\"User update called with {}\", userMod);\n-\n+        \n         final String changedPwd = userMod.getPassword();\n \n         // 1. update password internally only if required\n@@ -346,14 +355,14 @@ public UserTO update(@RequestBody final UserMod userMod) {\n             // the the rest (with no password)\n             final PropagationByResource origPropByRes = new PropagationByResource();\n             origPropByRes.merge(updated.getPropByRes());\n-\n+            \n             Set<String> pwdResourceNames = userMod.getPwdPropRequest().getResources();\n             SyncopeUser user = binder.getUserFromId(updated.getResult().getKey());\n             pwdResourceNames.retainAll(user.getResourceNames());\n             final PropagationByResource pwdPropByRes = new PropagationByResource();\n             pwdPropByRes.addAll(ResourceOperation.UPDATE, pwdResourceNames);\n             updated.setPropByRes(pwdPropByRes);\n-\n+            \n             if (!pwdPropByRes.isEmpty()) {\n                 Set<String> toBeExcluded = new HashSet<String>(user.getResourceNames());\n                 toBeExcluded.addAll(userMod.getResourcesToBeAdded());\n@@ -365,13 +374,13 @@ public UserTO update(@RequestBody final UserMod userMod) {\n                         userMod.getVirtualAttributesToBeUpdated(),\n                         toBeExcluded));\n             }\n-\n+            \n             final PropagationByResource nonPwdPropByRes = new PropagationByResource();\n             nonPwdPropByRes.merge(origPropByRes);\n             nonPwdPropByRes.removeAll(pwdResourceNames);\n             nonPwdPropByRes.purge();\n             updated.setPropByRes(nonPwdPropByRes);\n-\n+            \n             if (!nonPwdPropByRes.isEmpty()) {\n                 tasks.addAll(propagationManager.getUserUpdateTaskIds(\n                         updated,\n@@ -380,10 +389,10 @@ public UserTO update(@RequestBody final UserMod userMod) {\n                         userMod.getVirtualAttributesToBeUpdated(),\n                         pwdResourceNames));\n             }\n-\n+            \n             updated.setPropByRes(origPropByRes);\n         }\n-\n+        \n         final List<PropagationStatusTO> propagations = new ArrayList<PropagationStatusTO>();\n         final DefaultPropagationHandler propHanlder = new DefaultPropagationHandler(connObjectUtil, propagations);\n         try {\n@@ -399,232 +408,231 @@ public UserTO update(@RequestBody final UserMod userMod) {\n         // 4. prepare result, including propagation status on external resources\n         final UserTO updatedTO = binder.getUserTO(updated.getResult().getKey());\n         updatedTO.setPropagationStatusTOs(propagations);\n-\n+        \n         auditManager.audit(Category.user, UserSubCategory.update, Result.success,\n                 \"Successfully updated user: \" + updatedTO.getUsername());\n-\n+        \n         LOG.debug(\"About to return updated user\\n{}\", updatedTO);\n-\n+        \n         return updatedTO;\n     }\n-\n+    \n     @PreAuthorize(\"hasRole('USER_UPDATE')\")\n     @RequestMapping(method = RequestMethod.GET, value = \"/activate/{userId}\")\n     @Transactional(rollbackFor = {Throwable.class})\n     public UserTO activate(@PathVariable(\"userId\") final Long userId,\n             @RequestParam(required = true) final String token) {\n-\n+        \n         return activate(userId, token, null);\n     }\n-\n+    \n     @PreAuthorize(\"hasRole('USER_UPDATE')\")\n     @RequestMapping(method = RequestMethod.POST, value = \"/activate/{userId}\")\n     @Transactional(rollbackFor = {Throwable.class})\n     public UserTO activate(@PathVariable(\"userId\") final Long userId,\n             @RequestParam(required = true) final String token,\n             @RequestBody final PropagationRequestTO propagationRequestTO) {\n-\n+        \n         LOG.debug(\"About to activate \" + userId);\n-\n+        \n         SyncopeUser user = binder.getUserFromId(userId);\n-\n+        \n         return setStatus(user, token, propagationRequestTO, true, \"activate\");\n     }\n-\n+    \n     @PreAuthorize(\"hasRole('USER_UPDATE')\")\n     @RequestMapping(method = RequestMethod.GET, value = \"/activateByUsername/{username}\")\n     @Transactional(rollbackFor = {Throwable.class})\n     public UserTO activate(@PathVariable(\"username\") final String username,\n             @RequestParam(required = true) final String token) {\n-\n+        \n         return activate(username, token, null);\n     }\n-\n+    \n     @PreAuthorize(\"hasRole('USER_UPDATE')\")\n     @RequestMapping(method = RequestMethod.POST, value = \"/activateByUsername/{username}\")\n     @Transactional(rollbackFor = {Throwable.class})\n     public UserTO activate(@PathVariable(\"username\") final String username,\n             @RequestParam(required = true) final String token,\n             @RequestBody final PropagationRequestTO propagationRequestTO) {\n-\n+        \n         LOG.debug(\"About to activate \" + username);\n-\n+        \n         SyncopeUser user = binder.getUserFromUsername(username);\n-\n+        \n         return setStatus(user, token, propagationRequestTO, true, \"activate\");\n     }\n-\n+    \n     @PreAuthorize(\"hasRole('USER_UPDATE')\")\n     @RequestMapping(method = RequestMethod.GET, value = \"/suspend/{userId}\")\n     @Transactional(rollbackFor = {Throwable.class})\n     public UserTO suspend(@PathVariable(\"userId\") final Long userId) {\n-\n+        \n         return suspend(userId, null);\n     }\n-\n+    \n     @PreAuthorize(\"hasRole('USER_UPDATE')\")\n     @RequestMapping(method = RequestMethod.POST, value = \"/suspend/{userId}\")\n     @Transactional(rollbackFor = {Throwable.class})\n     public UserTO suspend(@PathVariable(\"userId\") final Long userId,\n             @RequestBody final PropagationRequestTO propagationRequestTO) {\n-\n+        \n         LOG.debug(\"About to suspend \" + userId);\n-\n+        \n         SyncopeUser user = binder.getUserFromId(userId);\n-\n+        \n         return setStatus(user, null, propagationRequestTO, false, \"suspend\");\n     }\n-\n+    \n     @PreAuthorize(\"hasRole('USER_UPDATE')\")\n     @RequestMapping(method = RequestMethod.GET, value = \"/suspendByUsername/{username}\")\n     @Transactional(rollbackFor = {Throwable.class})\n     public UserTO suspend(@PathVariable(\"username\") final String username) {\n-\n+        \n         return suspend(username, null);\n     }\n-\n+    \n     @PreAuthorize(\"hasRole('USER_UPDATE')\")\n     @RequestMapping(method = RequestMethod.POST, value = \"/suspendByUsername/{username}\")\n     @Transactional(rollbackFor = {Throwable.class})\n     public UserTO suspend(@PathVariable(\"username\") final String username,\n             @RequestBody final PropagationRequestTO propagationRequestTO) {\n-\n+        \n         LOG.debug(\"About to suspend \" + username);\n-\n+        \n         SyncopeUser user = binder.getUserFromUsername(username);\n-\n+        \n         return setStatus(user, null, propagationRequestTO, false, \"suspend\");\n     }\n-\n+    \n     @PreAuthorize(\"hasRole('USER_UPDATE')\")\n     @RequestMapping(method = RequestMethod.GET, value = \"/reactivate/{userId}\")\n     @Transactional(rollbackFor = {Throwable.class})\n     public UserTO reactivate(@PathVariable(\"userId\") final Long userId) {\n-\n+        \n         return reactivate(userId, null);\n     }\n-\n+    \n     @PreAuthorize(\"hasRole('USER_UPDATE')\")\n     @RequestMapping(method = RequestMethod.POST, value = \"/reactivate/{userId}\")\n     @Transactional(rollbackFor = {Throwable.class})\n     public UserTO reactivate(@PathVariable(\"userId\") final Long userId,\n             @RequestBody final PropagationRequestTO propagationRequestTO) {\n-\n+        \n         LOG.debug(\"About to reactivate \" + userId);\n-\n+        \n         SyncopeUser user = binder.getUserFromId(userId);\n-\n+        \n         return setStatus(user, null, propagationRequestTO, true, \"reactivate\");\n     }\n-\n+    \n     @RequestMapping(method = RequestMethod.GET, value = \"/reactivateByUsername/{username}\")\n     @Transactional(rollbackFor = {Throwable.class})\n     public UserTO reactivate(@PathVariable(\"username\") final String username) {\n-\n         return reactivate(username, null);\n     }\n-\n+    \n     @PreAuthorize(\"hasRole('USER_UPDATE')\")\n     @RequestMapping(method = RequestMethod.POST, value = \"/reactivateByUsername/{username}\")\n     @Transactional(rollbackFor = {Throwable.class})\n     public UserTO reactivate(@PathVariable(\"username\") final String username,\n             @RequestBody final PropagationRequestTO propagationRequestTO) {\n-\n+        \n         LOG.debug(\"About to reactivate \" + username);\n-\n+        \n         SyncopeUser user = binder.getUserFromUsername(username);\n-\n+        \n         return setStatus(user, null, propagationRequestTO, true, \"reactivate\");\n     }\n-\n+    \n     @PreAuthorize(\"hasRole('USER_DELETE')\")\n     @RequestMapping(method = RequestMethod.GET, value = \"/delete/{userId}\")\n     public UserTO delete(@PathVariable(\"userId\") final Long userId) {\n         LOG.debug(\"User delete called with {}\", userId);\n-\n+        \n         return doDelete(userId);\n     }\n-\n+    \n     @PreAuthorize(\"hasRole('USER_DELETE')\")\n     @RequestMapping(method = RequestMethod.GET, value = \"/deleteByUsername/{username}\")\n     public UserTO delete(@PathVariable final String username) {\n         LOG.debug(\"User delete called with {}\", username);\n-\n+        \n         UserTO result = binder.getUserTO(username);\n         long userId = result.getId();\n-\n+        \n         return doDelete(userId);\n     }\n-\n+    \n     @PreAuthorize(\"hasRole('USER_UPDATE')\")\n     @RequestMapping(method = RequestMethod.POST, value = \"/execute/workflow/{taskId}\")\n     public UserTO executeWorkflow(@RequestBody final UserTO userTO, @PathVariable(\"taskId\") final String taskId) {\n         LOG.debug(\"About to execute {} on {}\", taskId, userTO.getId());\n-\n+        \n         WorkflowResult<Long> updated = uwfAdapter.execute(userTO, taskId);\n-\n+        \n         List<PropagationTask> tasks = propagationManager.getUserUpdateTaskIds(\n                 new WorkflowResult<Map.Entry<Long, Boolean>>(new SimpleEntry<Long, Boolean>(updated.getResult(), null),\n                 updated.getPropByRes(), updated.getPerformedTasks()));\n-\n+        \n         taskExecutor.execute(tasks);\n-\n+        \n         notificationManager.createTasks(updated.getResult(), updated.getPerformedTasks());\n-\n+        \n         final UserTO savedTO = binder.getUserTO(updated.getResult());\n-\n+        \n         LOG.debug(\"About to return updated user\\n{}\", savedTO);\n-\n+        \n         auditManager.audit(Category.user, UserSubCategory.executeWorkflow, Result.success,\n                 \"Successfully executed workflow action \" + taskId + \" on user: \" + userTO.getUsername());\n-\n+        \n         return savedTO;\n     }\n-\n+    \n     @PreAuthorize(\"hasRole('WORKFLOW_FORM_LIST')\")\n     @RequestMapping(method = RequestMethod.GET, value = \"/workflow/form/list\")\n     @Transactional(rollbackFor = {Throwable.class})\n     public List<WorkflowFormTO> getForms() {\n         List<WorkflowFormTO> forms = uwfAdapter.getForms();\n-\n+        \n         auditManager.audit(Category.user, UserSubCategory.getForms, Result.success,\n                 \"Successfully list workflow forms: \" + forms.size());\n-\n+        \n         return forms;\n     }\n-\n+    \n     @PreAuthorize(\"hasRole('WORKFLOW_FORM_READ') and hasRole('USER_READ')\")\n     @RequestMapping(method = RequestMethod.GET, value = \"/workflow/form/{userId}\")\n     @Transactional(rollbackFor = {Throwable.class})\n     public WorkflowFormTO getFormForUser(@PathVariable(\"userId\") final Long userId) {\n         SyncopeUser user = binder.getUserFromId(userId);\n         WorkflowFormTO result = uwfAdapter.getForm(user.getWorkflowId());\n-\n+        \n         auditManager.audit(Category.user, UserSubCategory.getFormForUser, Result.success,\n                 \"Successfully read workflow form for user: \" + user.getUsername());\n-\n+        \n         return result;\n     }\n-\n+    \n     @PreAuthorize(\"hasRole('WORKFLOW_FORM_CLAIM')\")\n     @RequestMapping(method = RequestMethod.GET, value = \"/workflow/form/claim/{taskId}\")\n     @Transactional(rollbackFor = {Throwable.class})\n     public WorkflowFormTO claimForm(@PathVariable(\"taskId\") final String taskId) {\n         WorkflowFormTO result = uwfAdapter.claimForm(taskId,\n                 SecurityContextHolder.getContext().getAuthentication().getName());\n-\n+        \n         auditManager.audit(Category.user, UserSubCategory.claimForm, Result.success,\n                 \"Successfully claimed workflow form: \" + taskId);\n-\n+        \n         return result;\n     }\n-\n+    \n     @PreAuthorize(\"hasRole('WORKFLOW_FORM_SUBMIT')\")\n     @RequestMapping(method = RequestMethod.POST, value = \"/workflow/form/submit\")\n     @Transactional(rollbackFor = {Throwable.class})\n     public UserTO submitForm(@RequestBody final WorkflowFormTO form) {\n         LOG.debug(\"About to process form {}\", form);\n-\n+        \n         WorkflowResult<Map.Entry<Long, String>> updated = uwfAdapter.submitForm(form,\n                 SecurityContextHolder.getContext().getAuthentication().getName());\n \n@@ -642,22 +650,22 @@ public UserTO submitForm(@RequestBody final WorkflowFormTO form) {\n                     null);\n             taskExecutor.execute(tasks);\n         }\n-\n+        \n         final UserTO savedTO = binder.getUserTO(updated.getResult().getKey());\n-\n+        \n         auditManager.audit(Category.user, UserSubCategory.submitForm, Result.success,\n                 \"Successfully submitted workflow form for user: \" + savedTO.getUsername());\n-\n+        \n         LOG.debug(\"About to return user after form processing\\n{}\", savedTO);\n-\n+        \n         return savedTO;\n     }\n-\n+    \n     protected UserTO setStatus(final SyncopeUser user, final String token,\n             final PropagationRequestTO propagationRequestTO, final boolean status, final String task) {\n-\n+        \n         LOG.debug(\"About to set status of {}\" + user);\n-\n+        \n         WorkflowResult<Long> updated;\n         if (propagationRequestTO == null || propagationRequestTO.isOnSyncope()) {\n             updated = setStatusOnWfAdapter(user, token, task);\n@@ -670,22 +678,22 @@ protected UserTO setStatus(final SyncopeUser user, final String token,\n         if (propagationRequestTO != null) {\n             resourcesToBeExcluded.removeAll(propagationRequestTO.getResources());\n         }\n-\n+        \n         List<PropagationTask> tasks = propagationManager.getUserUpdateTaskIds(user, status, resourcesToBeExcluded);\n         taskExecutor.execute(tasks);\n-\n+        \n         notificationManager.createTasks(updated.getResult(), updated.getPerformedTasks());\n-\n+        \n         final UserTO savedTO = binder.getUserTO(updated.getResult());\n-\n+        \n         auditManager.audit(Category.user, UserSubCategory.setStatus, Result.success,\n                 \"Successfully changed status to \" + savedTO.getStatus() + \" for user: \" + savedTO.getUsername());\n-\n+        \n         LOG.debug(\"About to return updated user\\n{}\", savedTO);\n-\n+        \n         return savedTO;\n     }\n-\n+    \n     protected WorkflowResult<Long> setStatusOnWfAdapter(final SyncopeUser user, final String token, final String task) {\n         WorkflowResult<Long> updated;\n         if (\"suspend\".equals(task)) {\n@@ -697,20 +705,40 @@ protected WorkflowResult<Long> setStatusOnWfAdapter(final SyncopeUser user, fina\n         }\n         return updated;\n     }\n-\n+    \n     protected UserTO doDelete(final Long userId) {\n+        List<SyncopeRole> ownedRoles = roleDAO.findOwned(binder.getUserFromId(userId));\n+        if (!ownedRoles.isEmpty()) {\n+            List<String> owned = new ArrayList<String>(ownedRoles.size());\n+            for (SyncopeRole role : ownedRoles) {\n+                owned.add(role.getId() + \" \" + role.getName());\n+            }\n+            \n+            auditManager.audit(Category.user, UserSubCategory.delete, Result.failure,\n+                    \"Could not delete user: \" + userId + \" because of role(s) ownership \" + owned);\n+            \n+            SyncopeClientCompositeErrorException sccee =\n+                    new SyncopeClientCompositeErrorException(HttpStatus.BAD_REQUEST);\n+            \n+            SyncopeClientException sce = new SyncopeClientException(SyncopeClientExceptionType.RoleOwnership);\n+            sce.setElements(owned);\n+            sccee.addException(sce);\n+            \n+            throw sccee;\n+        }\n+\n         // Note here that we can only notify about \"delete\", not any other\n         // task defined in workflow process definition: this because this\n         // information could only be available after uwfAdapter.delete(), which\n         // will also effectively remove user from db, thus making virtually\n         // impossible by NotificationManager to fetch required user information\n         notificationManager.createTasks(userId, Collections.singleton(\"delete\"));\n-\n+        \n         List<PropagationTask> tasks = propagationManager.getUserDeleteTaskIds(userId);\n-\n+        \n         final UserTO userTO = new UserTO();\n         userTO.setId(userId);\n-\n+        \n         final List<PropagationStatusTO> propagations = new ArrayList<PropagationStatusTO>();\n         final DefaultPropagationHandler propHanlder = new DefaultPropagationHandler(connObjectUtil, propagations);\n         try {\n@@ -719,29 +747,29 @@ protected UserTO doDelete(final Long userId) {\n             LOG.error(\"Error propagation primary resource\", e);\n             propHanlder.completeWhenPrimaryResourceErrored(propagations, tasks);\n         }\n-\n+        \n         userTO.setPropagationStatusTOs(propagations);\n-\n+        \n         uwfAdapter.delete(userId);\n-\n+        \n         auditManager.audit(Category.user, UserSubCategory.delete, Result.success,\n                 \"Successfully deleted user: \" + userId);\n-\n+        \n         LOG.debug(\"User successfully deleted: {}\", userId);\n-\n+        \n         return userTO;\n     }\n-\n+    \n     @PreAuthorize(\"(hasRole('USER_DELETE') and #bulkAction.operation == #bulkAction.operation.DELETE) or \"\n             + \"(hasRole('USER_UPDATE') and \"\n             + \"(#bulkAction.operation == #bulkAction.operation.REACTIVATE or \"\n             + \"#bulkAction.operation == #bulkAction.operation.SUSPEND))\")\n     @RequestMapping(method = RequestMethod.POST, value = \"/bulk\")\n     public BulkActionRes bulkAction(@RequestBody final BulkAction bulkAction) {\n         LOG.debug(\"Bulk action '{}' called on '{}'\", bulkAction.getOperation(), bulkAction.getTargets());\n-\n+        \n         BulkActionRes res = new BulkActionRes();\n-\n+        \n         switch (bulkAction.getOperation()) {\n             case DELETE:\n                 for (String userId : bulkAction.getTargets()) {\n@@ -775,7 +803,7 @@ public BulkActionRes bulkAction(@RequestBody final BulkAction bulkAction) {\n                 break;\n             default:\n         }\n-\n+        \n         return res;\n     }\n }"}]}