{"sha":"2eb202c9e0bebcfb64083d05104608f136bc9b38","node_id":"MDY6Q29tbWl0NjM2ODc5MDYyOjJlYjIwMmM5ZTBiZWJjZmI2NDA4M2QwNTEwNDYwOGYxMzZiYzliMzg=","commit":{"author":{"name":"Fabio Martelli","email":"fmartelli@apache.org","date":"2012-05-02T10:21:38Z"},"committer":{"name":"Fabio Martelli","email":"fmartelli@apache.org","date":"2012-05-02T10:21:38Z"},"message":"SYNCOPE-65 #comment added the possibility to export from a supported dbms and import into another one\n\ngit-svn-id: https://svn.apache.org/repos/asf/incubator/syncope/trunk@1332978 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"eb81315a1b7a562387a2fa5e860451dd95ffc407","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/git/trees/eb81315a1b7a562387a2fa5e860451dd95ffc407"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/git/commits/2eb202c9e0bebcfb64083d05104608f136bc9b38","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/2eb202c9e0bebcfb64083d05104608f136bc9b38","html_url":"https://github.com/EnricoDAlessandro97UNI/syncope/commit/2eb202c9e0bebcfb64083d05104608f136bc9b38","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/2eb202c9e0bebcfb64083d05104608f136bc9b38/comments","author":{"login":"fmartelli","id":1791932,"node_id":"MDQ6VXNlcjE3OTE5MzI=","avatar_url":"https://avatars.githubusercontent.com/u/1791932?v=4","gravatar_id":"","url":"https://api.github.com/users/fmartelli","html_url":"https://github.com/fmartelli","followers_url":"https://api.github.com/users/fmartelli/followers","following_url":"https://api.github.com/users/fmartelli/following{/other_user}","gists_url":"https://api.github.com/users/fmartelli/gists{/gist_id}","starred_url":"https://api.github.com/users/fmartelli/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fmartelli/subscriptions","organizations_url":"https://api.github.com/users/fmartelli/orgs","repos_url":"https://api.github.com/users/fmartelli/repos","events_url":"https://api.github.com/users/fmartelli/events{/privacy}","received_events_url":"https://api.github.com/users/fmartelli/received_events","type":"User","site_admin":false},"committer":{"login":"fmartelli","id":1791932,"node_id":"MDQ6VXNlcjE3OTE5MzI=","avatar_url":"https://avatars.githubusercontent.com/u/1791932?v=4","gravatar_id":"","url":"https://api.github.com/users/fmartelli","html_url":"https://github.com/fmartelli","followers_url":"https://api.github.com/users/fmartelli/followers","following_url":"https://api.github.com/users/fmartelli/following{/other_user}","gists_url":"https://api.github.com/users/fmartelli/gists{/gist_id}","starred_url":"https://api.github.com/users/fmartelli/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fmartelli/subscriptions","organizations_url":"https://api.github.com/users/fmartelli/orgs","repos_url":"https://api.github.com/users/fmartelli/repos","events_url":"https://api.github.com/users/fmartelli/events{/privacy}","received_events_url":"https://api.github.com/users/fmartelli/received_events","type":"User","site_admin":false},"parents":[{"sha":"306f0168849ef2f38f01f6cb15e449f31717b3b2","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/306f0168849ef2f38f01f6cb15e449f31717b3b2","html_url":"https://github.com/EnricoDAlessandro97UNI/syncope/commit/306f0168849ef2f38f01f6cb15e449f31717b3b2"}],"stats":{"total":419,"additions":272,"deletions":147},"files":[{"sha":"1c5dc048f31e6e803d24aef0bb479f46496bfec9","filename":"client/src/main/java/org/apache/syncope/client/SyncopeConstants.java","status":"modified","additions":7,"deletions":3,"changes":10,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/2eb202c9e0bebcfb64083d05104608f136bc9b38/client%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2FSyncopeConstants.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/2eb202c9e0bebcfb64083d05104608f136bc9b38/client%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2FSyncopeConstants.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/client%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fclient%2FSyncopeConstants.java?ref=2eb202c9e0bebcfb64083d05104608f136bc9b38","patch":"@@ -20,9 +20,13 @@\n \n public class SyncopeConstants {\n \n-    public final static String[] DATE_PATTERNS = { \"yyyy-MM-dd'T'HH:mm:ssZ\", \"EEE, dd MMM yyyy HH:mm:ss z\",\n-            \"yyyy-MM-dd'T'HH:mm:ssz\", \"yyyy-MM-dd HH:mm:ss\", \"yyyy-MM-dd\" };\n+    public final static String[] DATE_PATTERNS = {\n+        \"yyyy-MM-dd'T'HH:mm:ssZ\",\n+        \"EEE, dd MMM yyyy HH:mm:ss z\",\n+        \"yyyy-MM-dd'T'HH:mm:ssz\",\n+        \"yyyy-MM-dd HH:mm:ss\", \n+        \"yyyy-MM-dd HH:mm:ss.S\", // explicitly added to import date into MySql repository\n+        \"yyyy-MM-dd\"};\n \n     public static String DEFAULT_DATE_PATTERN = \"yyyy-MM-dd'T'HH:mm:ssZ\";\n-\n }"},{"sha":"9b86538b07c188320b553e39afbe3968de053183","filename":"core/src/main/java/org/apache/syncope/core/init/ContentLoader.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/2eb202c9e0bebcfb64083d05104608f136bc9b38/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Finit%2FContentLoader.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/2eb202c9e0bebcfb64083d05104608f136bc9b38/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Finit%2FContentLoader.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Finit%2FContentLoader.java?ref=2eb202c9e0bebcfb64083d05104608f136bc9b38","patch":"@@ -27,14 +27,14 @@\n import javax.sql.DataSource;\n import javax.xml.parsers.SAXParser;\n import javax.xml.parsers.SAXParserFactory;\n+import org.apache.syncope.core.persistence.beans.SyncopeConf;\n+import org.apache.syncope.core.util.ImportExport;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.jdbc.datasource.DataSourceUtils;\n import org.springframework.stereotype.Component;\n import org.springframework.transaction.annotation.Transactional;\n-import org.apache.syncope.core.persistence.beans.SyncopeConf;\n-import org.apache.syncope.core.util.ImportExport;\n \n /**\n  * If empty, load default content to Syncope database by reading from"},{"sha":"cfa38ecfe362d2eb1430f0e76b1559124ed35a0e","filename":"core/src/main/java/org/apache/syncope/core/util/ImportExport.java","status":"modified","additions":230,"deletions":73,"changes":303,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/2eb202c9e0bebcfb64083d05104608f136bc9b38/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Futil%2FImportExport.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/2eb202c9e0bebcfb64083d05104608f136bc9b38/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Futil%2FImportExport.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Futil%2FImportExport.java?ref=2eb202c9e0bebcfb64083d05104608f136bc9b38","patch":"@@ -21,21 +21,28 @@\n import java.io.IOException;\n import java.io.InputStream;\n import java.io.OutputStream;\n+import java.sql.Blob;\n import java.sql.Connection;\n+import java.sql.DatabaseMetaData;\n import java.sql.PreparedStatement;\n import java.sql.ResultSet;\n import java.sql.ResultSetMetaData;\n import java.sql.SQLException;\n import java.sql.Statement;\n+import java.sql.Timestamp;\n import java.sql.Types;\n import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n import java.util.HashMap;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Properties;\n import java.util.Set;\n+import java.util.TreeMap;\n import javax.persistence.EntityManager;\n import javax.persistence.Query;\n import javax.persistence.TemporalType;\n@@ -46,16 +53,17 @@\n import javax.xml.transform.sax.SAXTransformerFactory;\n import javax.xml.transform.sax.TransformerHandler;\n import javax.xml.transform.stream.StreamResult;\n+import org.apache.commons.io.IOUtils;\n import org.apache.commons.lang.time.DateUtils;\n+import org.apache.syncope.client.SyncopeConstants;\n+import org.apache.syncope.core.util.multiparent.MultiParentNode;\n+import org.apache.syncope.core.util.multiparent.MultiParentNodeOp;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.jdbc.datasource.DataSourceUtils;\n+import org.springframework.security.crypto.codec.Hex;\n import org.springframework.stereotype.Component;\n-import org.apache.syncope.client.SyncopeConstants;\n-import org.apache.syncope.core.util.multiparent.CycleInMultiParentTreeException;\n-import org.apache.syncope.core.util.multiparent.MultiParentNode;\n-import org.apache.syncope.core.util.multiparent.MultiParentNodeOp;\n import org.xml.sax.Attributes;\n import org.xml.sax.SAXException;\n import org.xml.sax.helpers.AttributesImpl;\n@@ -71,6 +79,14 @@ public class ImportExport extends DefaultHandler {\n \n     private final static String ROOT_ELEMENT = \"dataset\";\n \n+    protected static final ThreadLocal<SimpleDateFormat> DATE_FORMAT = new ThreadLocal<SimpleDateFormat>() {\n+\n+        @Override\n+        protected SimpleDateFormat initialValue() {\n+            return new SimpleDateFormat(SyncopeConstants.DEFAULT_DATE_PATTERN);\n+        }\n+    };\n+\n     @Autowired\n     private EntityManager entityManager;\n \n@@ -105,19 +121,19 @@ private String readSchema() {\n         return schema;\n     }\n \n-    private void setParameters(final String tableName, final Attributes atts, final Query query) {\n+    private void setParameters(final String tableName, final Attributes attrs, final Query query) {\n \n         Map<String, Integer> colTypes = new HashMap<String, Integer>();\n \n         Connection conn = DataSourceUtils.getConnection(dataSource);\n         ResultSet rs = null;\n         Statement stmt = null;\n+\n         try {\n             stmt = conn.createStatement();\n             rs = stmt.executeQuery(\"SELECT * FROM \" + tableName);\n             for (int i = 0; i < rs.getMetaData().getColumnCount(); i++) {\n-                colTypes\n-                        .put(rs.getMetaData().getColumnName(i + 1).toUpperCase(), rs.getMetaData().getColumnType(i + 1));\n+                colTypes.put(rs.getMetaData().getColumnName(i + 1).toUpperCase(), rs.getMetaData().getColumnType(i + 1));\n             }\n         } catch (SQLException e) {\n             LOG.error(\"While\", e);\n@@ -139,77 +155,95 @@ private void setParameters(final String tableName, final Attributes atts, final\n             DataSourceUtils.releaseConnection(conn, dataSource);\n         }\n \n-        for (int i = 0; i < atts.getLength(); i++) {\n-            Integer colType = colTypes.get(atts.getQName(i).toUpperCase());\n+        for (int i = 0; i < attrs.getLength(); i++) {\n+            Integer colType = colTypes.get(attrs.getQName(i).toUpperCase());\n             if (colType == null) {\n-                LOG.warn(\"No column type found for {}\", atts.getQName(i).toUpperCase());\n+                LOG.warn(\"No column type found for {}\", attrs.getQName(i).toUpperCase());\n                 colType = Types.VARCHAR;\n             }\n \n             switch (colType) {\n-                case Types.NUMERIC:\n-                case Types.REAL:\n                 case Types.INTEGER:\n                 case Types.TINYINT:\n                 case Types.SMALLINT:\n                     try {\n-                        query.setParameter(i + 1, Integer.valueOf(atts.getValue(i)));\n+                        query.setParameter(i + 1, Integer.valueOf(attrs.getValue(i)));\n                     } catch (NumberFormatException e) {\n-                        LOG.error(\"Unparsable Integer '{}'\", atts.getValue(i));\n-                        query.setParameter(i + 1, atts.getValue(i));\n+                        LOG.error(\"Unparsable Integer '{}'\", attrs.getValue(i));\n+                        query.setParameter(i + 1, attrs.getValue(i));\n                     }\n                     break;\n \n+                case Types.NUMERIC:\n                 case Types.DECIMAL:\n                 case Types.BIGINT:\n                     try {\n-                        query.setParameter(i + 1, Long.valueOf(atts.getValue(i)));\n+                        query.setParameter(i + 1, Long.valueOf(attrs.getValue(i)));\n                     } catch (NumberFormatException e) {\n-                        LOG.error(\"Unparsable Long '{}'\", atts.getValue(i));\n-                        query.setParameter(i + 1, atts.getValue(i));\n+                        LOG.error(\"Unparsable Long '{}'\", attrs.getValue(i));\n+                        query.setParameter(i + 1, attrs.getValue(i));\n                     }\n                     break;\n \n                 case Types.DOUBLE:\n                     try {\n-                        query.setParameter(i + 1, Double.valueOf(atts.getValue(i)));\n+                        query.setParameter(i + 1, Double.valueOf(attrs.getValue(i)));\n                     } catch (NumberFormatException e) {\n-                        LOG.error(\"Unparsable Double '{}'\", atts.getValue(i));\n-                        query.setParameter(i + 1, atts.getValue(i));\n+                        LOG.error(\"Unparsable Double '{}'\", attrs.getValue(i));\n+                        query.setParameter(i + 1, attrs.getValue(i));\n                     }\n                     break;\n \n+                case Types.REAL:\n                 case Types.FLOAT:\n                     try {\n-                        query.setParameter(i + 1, Float.valueOf(atts.getValue(i)));\n+                        query.setParameter(i + 1, Float.valueOf(attrs.getValue(i)));\n                     } catch (NumberFormatException e) {\n-                        LOG.error(\"Unparsable Float '{}'\", atts.getValue(i));\n-                        query.setParameter(i + 1, atts.getValue(i));\n+                        LOG.error(\"Unparsable Float '{}'\", attrs.getValue(i));\n+                        query.setParameter(i + 1, attrs.getValue(i));\n                     }\n                     break;\n \n                 case Types.DATE:\n                 case Types.TIME:\n                 case Types.TIMESTAMP:\n                     try {\n-                        query.setParameter(i + 1,\n-                                DateUtils.parseDate(atts.getValue(i), SyncopeConstants.DATE_PATTERNS),\n-                                TemporalType.TIMESTAMP);\n+                        query.setParameter(i + 1, DateUtils.parseDate(\n+                                attrs.getValue(i), SyncopeConstants.DATE_PATTERNS), TemporalType.TIMESTAMP);\n                     } catch (ParseException e) {\n-                        LOG.error(\"Unparsable Date '{}'\", atts.getValue(i));\n-                        query.setParameter(i + 1, atts.getValue(i));\n+                        LOG.error(\"Unparsable Date '{}'\", attrs.getValue(i));\n+                        query.setParameter(i + 1, attrs.getValue(i));\n                     }\n                     break;\n \n                 case Types.BIT:\n                 case Types.BOOLEAN:\n-                    query.setParameter(i + 1, \"1\".equals(atts.getValue(i))\n-                            ? Boolean.TRUE\n-                            : Boolean.FALSE);\n+                    query.setParameter(i + 1, \"1\".equals(attrs.getValue(i)) ? Boolean.TRUE : Boolean.FALSE);\n+                    break;\n+\n+                case Types.BINARY:\n+                case Types.VARBINARY:\n+                case Types.LONGVARBINARY:\n+                    try {\n+                        query.setParameter(i + 1, Hex.decode(attrs.getValue(i)));\n+                    } catch (IllegalArgumentException e) {\n+                        query.setParameter(i + 1, attrs.getValue(i));\n+                    }\n+                    break;\n+\n+                case Types.BLOB:\n+                    try {\n+                        query.setParameter(i + 1, Hex.decode(attrs.getValue(i)));\n+                    } catch (IllegalArgumentException e) {\n+                        LOG.warn(\"Error decoding hex string to specify a blob parameter\", e);\n+                        query.setParameter(i + 1, attrs.getValue(i));\n+                    } catch (Exception e) {\n+                        LOG.warn(\"Error creating a new blob parameter\", e);\n+                    }\n                     break;\n \n                 default:\n-                    query.setParameter(i + 1, atts.getValue(i));\n+                    query.setParameter(i + 1, attrs.getValue(i));\n             }\n         }\n     }\n@@ -239,32 +273,63 @@ public void startElement(final String uri, final String localName, final String\n \n         Query query = entityManager.createNativeQuery(queryString.toString());\n         setParameters(qName, atts, query);\n+\n         query.executeUpdate();\n     }\n \n     private void doExportTable(final TransformerHandler handler, final Connection conn, final String tableName)\n             throws SQLException, SAXException {\n \n-        AttributesImpl atts = new AttributesImpl();\n+        AttributesImpl attrs = new AttributesImpl();\n \n         PreparedStatement stmt = null;\n         ResultSet rs = null;\n+        ResultSet pkeyRS = null;\n+\n         try {\n-            stmt = conn.prepareStatement(\"SELECT * FROM \" + tableName + \" a\");\n+            // ------------------------------------\n+            // retrieve primary keys to perform an ordered select\n+\n+            final DatabaseMetaData meta = conn.getMetaData();\n+            pkeyRS = meta.getPrimaryKeys(null, null, tableName);\n+\n+            final StringBuilder orderBy = new StringBuilder();\n+\n+            while (pkeyRS.next()) {\n+                final String columnName = pkeyRS.getString(\"COLUMN_NAME\");\n+\n+                if (columnName != null) {\n+                    if (orderBy.length() > 0) {\n+                        orderBy.append(\",\");\n+                    }\n+\n+                    orderBy.append(columnName);\n+                }\n+            }\n+\n+            // ------------------------------------\n+            stmt = conn.prepareStatement(\n+                    \"SELECT * FROM \" + tableName + \" a\" + (orderBy.length() > 0 ? \" ORDER BY \" + orderBy : \"\"));\n+\n             rs = stmt.executeQuery();\n             for (int rowNo = 0; rs.next(); rowNo++) {\n-                atts.clear();\n+                attrs.clear();\n+\n+                final ResultSetMetaData rsMeta = rs.getMetaData();\n+\n+                for (int i = 0; i < rsMeta.getColumnCount(); i++) {\n+                    final String columnName = rsMeta.getColumnName(i + 1);\n+                    final Integer columnType = rsMeta.getColumnType(i + 1);\n+\n+                    // Retrieve value taking care of binary values.\n+                    String value = getValues(rs, columnName, columnType);\n \n-                ResultSetMetaData metaData = rs.getMetaData();\n-                for (int i = 0; i < metaData.getColumnCount(); i++) {\n-                    String columnName = metaData.getColumnName(i + 1);\n-                    String value = rs.getString(columnName);\n                     if (value != null) {\n-                        atts.addAttribute(\"\", \"\", columnName, \"CDATA\", value);\n+                        attrs.addAttribute(\"\", \"\", columnName, \"CDATA\", value);\n                     }\n                 }\n \n-                handler.startElement(\"\", \"\", tableName, atts);\n+                handler.startElement(\"\", \"\", tableName, attrs);\n                 handler.endElement(\"\", \"\", tableName);\n             }\n         } finally {\n@@ -275,6 +340,13 @@ private void doExportTable(final TransformerHandler handler, final Connection co\n                     LOG.error(\"While closing result set\", e);\n                 }\n             }\n+            if (pkeyRS != null) {\n+                try {\n+                    pkeyRS.close();\n+                } catch (SQLException e) {\n+                    LOG.error(\"While closing result set\", e);\n+                }\n+            }\n             if (stmt != null) {\n                 try {\n                     stmt.close();\n@@ -285,35 +357,40 @@ private void doExportTable(final TransformerHandler handler, final Connection co\n         }\n     }\n \n-    private List<String> sortByForeignKeys(final Connection conn, final Set<String> tableNames)\n-            throws SQLException, CycleInMultiParentTreeException {\n+    private List<String> sortByForeignKeys(final Connection conn, final Set<String> tableNames, final String schema)\n+            throws SQLException {\n+\n+        Set<MultiParentNode<String>> roots = new HashSet<MultiParentNode<String>>();\n+\n+        final DatabaseMetaData meta = conn.getMetaData();\n \n-        MultiParentNode<String> root = new MultiParentNode<String>(ROOT_ELEMENT);\n+        final Map<String, MultiParentNode<String>> exploited =\n+                new TreeMap<String, MultiParentNode<String>>(String.CASE_INSENSITIVE_ORDER);\n+\n+        final Set<String> pkTableNames = new HashSet<String>();\n \n         for (String tableName : tableNames) {\n-            MultiParentNode<String> node = MultiParentNodeOp.findInTree(root, tableName);\n+\n+            MultiParentNode<String> node = exploited.get(tableName);\n+\n             if (node == null) {\n                 node = new MultiParentNode<String>(tableName);\n-                root.addChild(node);\n+                roots.add(node);\n+                exploited.put(tableName, node);\n             }\n \n             ResultSet rs = null;\n+\n+            pkTableNames.clear();\n+\n             try {\n-                rs = conn.getMetaData().getExportedKeys(conn.getCatalog(), readSchema(), tableName);\n+                rs = meta.getImportedKeys(conn.getCatalog(), readSchema(), tableName);\n+\n+                // this is to avoid repetition\n                 while (rs.next()) {\n-                    String fkTableName = rs.getString(\"FKTABLE_NAME\");\n-                    if (!tableName.equals(fkTableName)) {\n-                        MultiParentNode<String> fkNode = MultiParentNodeOp.findInTree(root, fkTableName);\n-                        if (fkNode == null) {\n-                            fkNode = new MultiParentNode<String>(fkTableName);\n-                            root.addChild(fkNode);\n-                        }\n-                        fkNode.addChild(node);\n-                        if (root.isParent(node)) {\n-                            root.removeChild(node);\n-                        }\n-                    }\n+                    pkTableNames.add(rs.getString(\"PKTABLE_NAME\"));\n                 }\n+\n             } finally {\n                 if (rs != null) {\n                     try {\n@@ -323,18 +400,40 @@ private List<String> sortByForeignKeys(final Connection conn, final Set<String>\n                     }\n                 }\n             }\n+\n+            for (String pkTableName : pkTableNames) {\n+\n+                if (!tableName.equalsIgnoreCase(pkTableName)) {\n+\n+                    MultiParentNode<String> pkNode = exploited.get(pkTableName);\n+\n+                    if (pkNode == null) {\n+                        pkNode = new MultiParentNode<String>(pkTableName);\n+                        roots.add(pkNode);\n+                        exploited.put(pkTableName, pkNode);\n+                    }\n+\n+                    pkNode.addChild(node);\n+\n+                    if (roots.contains(node)) {\n+                        roots.remove(node);\n+                    }\n+                }\n+            }\n         }\n \n-        List<String> sortedTableNames = new ArrayList<String>(tableNames.size());\n-        MultiParentNodeOp.traverseTree(root, sortedTableNames);\n-        return sortedTableNames.subList(0, sortedTableNames.size() - 1);\n+        final List<String> sortedTableNames = new ArrayList<String>(tableNames.size());\n+        MultiParentNodeOp.traverseTree(roots, sortedTableNames);\n+\n+        Collections.reverse(sortedTableNames);\n+        return sortedTableNames;\n     }\n \n     public void export(final OutputStream os)\n-            throws SAXException, TransformerConfigurationException, CycleInMultiParentTreeException {\n+            throws SAXException, TransformerConfigurationException {\n \n         StreamResult streamResult = new StreamResult(os);\n-        SAXTransformerFactory transformerFactory = (SAXTransformerFactory) SAXTransformerFactory.newInstance();\n+        final SAXTransformerFactory transformerFactory = (SAXTransformerFactory) SAXTransformerFactory.newInstance();\n \n         TransformerHandler handler = transformerFactory.newTransformerHandler();\n         Transformer serializer = handler.getTransformer();\n@@ -344,23 +443,30 @@ public void export(final OutputStream os)\n         handler.startDocument();\n         handler.startElement(\"\", \"\", ROOT_ELEMENT, new AttributesImpl());\n \n-        Connection conn = DataSourceUtils.getConnection(dataSource);\n+        final Connection conn = DataSourceUtils.getConnection(dataSource);\n+\n         ResultSet rs = null;\n+\n         try {\n-            // first read all tables...\n-            rs = conn.getMetaData().getTables(null, null, null, new String[] { \"TABLE\" });\n-            Set<String> tableNames = new HashSet<String>();\n+            final DatabaseMetaData meta = conn.getMetaData();\n+\n+            final String schema = readSchema();\n+\n+            rs = meta.getTables(null, schema, null, new String[]{\"TABLE\"});\n+\n+            final Set<String> tableNames = new HashSet<String>();\n+\n             while (rs.next()) {\n                 String tableName = rs.getString(\"TABLE_NAME\");\n-                // these tables must be ignored\n-                if (!tableName.toUpperCase().startsWith(\"QRTZ_\")) {\n \n+                // these tables must be ignored\n+                if (!tableName.toUpperCase().startsWith(\"QRTZ_\") && !tableName.toUpperCase().startsWith(\"LOGGING_\")) {\n                     tableNames.add(tableName);\n                 }\n             }\n-            // then sort tables based on foreign keys and dump\n-            for (String tableName : sortByForeignKeys(conn, tableNames)) {\n \n+            // then sort tables based on foreign keys and dump\n+            for (String tableName : sortByForeignKeys(conn, tableNames, schema)) {\n                 doExportTable(handler, conn, tableName);\n             }\n         } catch (SQLException e) {\n@@ -379,4 +485,55 @@ public void export(final OutputStream os)\n         handler.endElement(\"\", \"\", ROOT_ELEMENT);\n         handler.endDocument();\n     }\n+\n+    private String getValues(final ResultSet rs, final String columnName, final Integer columnType)\n+            throws SQLException {\n+\n+        String res = null;\n+\n+        try {\n+            switch (columnType) {\n+                case Types.BINARY:\n+                case Types.VARBINARY:\n+                case Types.LONGVARBINARY:\n+                    final InputStream is = rs.getBinaryStream(columnName);\n+                    if (is != null) {\n+                        res = new String(Hex.encode(IOUtils.toByteArray(is)));\n+                    }\n+                    break;\n+\n+                case Types.BLOB:\n+                    final Blob blob = rs.getBlob(columnName);\n+                    if (blob != null) {\n+                        res = new String(Hex.encode(IOUtils.toByteArray(blob.getBinaryStream())));\n+                    }\n+                    break;\n+\n+                case Types.BIT:\n+                case Types.BOOLEAN:\n+                    if (rs.getBoolean(columnName)) {\n+                        res = \"1\";\n+                    } else {\n+                        res = \"0\";\n+                    }\n+                    break;\n+\n+                case Types.DATE:\n+                case Types.TIME:\n+                case Types.TIMESTAMP:\n+                    final Timestamp timestamp = rs.getTimestamp(columnName);\n+                    if (timestamp != null) {\n+                        res = DATE_FORMAT.get().format(new Date(timestamp.getTime()));\n+                    }\n+                    break;\n+\n+                default:\n+                    res = rs.getString(columnName);\n+            }\n+        } catch (IOException e) {\n+            LOG.error(\"Error retrieving hexadecimal string\", e);\n+        }\n+\n+        return res;\n+    }\n }"},{"sha":"1357caf08c5e470810d01416004728b9f9197a49","filename":"core/src/main/java/org/apache/syncope/core/util/multiparent/CycleInMultiParentTreeException.java","status":"removed","additions":0,"deletions":28,"changes":28,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/306f0168849ef2f38f01f6cb15e449f31717b3b2/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Futil%2Fmultiparent%2FCycleInMultiParentTreeException.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/306f0168849ef2f38f01f6cb15e449f31717b3b2/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Futil%2Fmultiparent%2FCycleInMultiParentTreeException.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Futil%2Fmultiparent%2FCycleInMultiParentTreeException.java?ref=306f0168849ef2f38f01f6cb15e449f31717b3b2","patch":"@@ -1,28 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-package org.apache.syncope.core.util.multiparent;\n-\n-public class CycleInMultiParentTreeException extends Exception {\n-\n-    private static final long serialVersionUID = -741534138630944574L;\n-\n-    public CycleInMultiParentTreeException(final String message) {\n-        super(message);\n-    }\n-}"},{"sha":"b4383d5ca4d78256682904b251eb430a4718b659","filename":"core/src/main/java/org/apache/syncope/core/util/multiparent/MultiParentNode.java","status":"modified","additions":19,"deletions":23,"changes":42,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/2eb202c9e0bebcfb64083d05104608f136bc9b38/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Futil%2Fmultiparent%2FMultiParentNode.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/2eb202c9e0bebcfb64083d05104608f136bc9b38/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Futil%2Fmultiparent%2FMultiParentNode.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Futil%2Fmultiparent%2FMultiParentNode.java?ref=2eb202c9e0bebcfb64083d05104608f136bc9b38","patch":"@@ -27,74 +27,70 @@\n \n     private final T object;\n \n-    private Set<MultiParentNode<T>> parents;\n-\n     private Set<MultiParentNode<T>> children;\n \n+    private int level = 0;\n+\n+    private boolean exploited = false;\n+\n     public MultiParentNode(final T object) {\n         this.object = object;\n-        parents = new HashSet<MultiParentNode<T>>();\n         children = new HashSet<MultiParentNode<T>>();\n     }\n \n-    public boolean isRoot() {\n-        return parents.isEmpty();\n+    public int getLevel() {\n+        return level;\n     }\n \n-    public boolean isLeaf() {\n-        return children.isEmpty();\n+    public void setLevel(int level) {\n+        this.level = level;\n+    }\n+\n+    boolean isExploited() {\n+        return exploited;\n+    }\n+\n+    void setExploited(boolean exploited) {\n+        this.exploited = exploited;\n     }\n \n     public T getObject() {\n         return object;\n     }\n \n     public boolean isParent(final MultiParentNode<T> child) {\n-        return children.contains(child) && child.isChild(this);\n+        return children.contains(child);\n     }\n \n     public boolean isChild(final MultiParentNode<T> parent) {\n-        return parents.contains(parent) && parent.isParent(this);\n+        return parent.isParent(this);\n     }\n \n     public Set<MultiParentNode<T>> getChildren() {\n         return children;\n     }\n \n-    public Set<MultiParentNode<T>> getParents() {\n-        return parents;\n-    }\n-\n     public void addParent(final MultiParentNode<T> parent) {\n         if (parent != null) {\n-            parents.add(parent);\n             parent.children.add(this);\n         }\n     }\n \n     public void removeParent(final MultiParentNode<T> parent) {\n         if (parent != null) {\n-            parents.remove(parent);\n             parent.children.remove(this);\n         }\n     }\n \n-    public void addChild(final MultiParentNode<T> child) throws CycleInMultiParentTreeException {\n-\n+    public void addChild(final MultiParentNode<T> child) {\n         if (child != null) {\n-            if (MultiParentNodeOp.findInTree(child, getObject()) != null) {\n-                throw new CycleInMultiParentTreeException(\"This node is descendant of given child node\");\n-            }\n-\n             children.add(child);\n-            child.parents.add(this);\n         }\n     }\n \n     public void removeChild(final MultiParentNode<T> child) {\n         if (child != null) {\n             children.remove(child);\n-            child.parents.remove(this);\n         }\n     }\n "},{"sha":"1d8cda9027e451771a7f81dc59f8288e35f0d447","filename":"core/src/main/java/org/apache/syncope/core/util/multiparent/MultiParentNodeOp.java","status":"modified","additions":13,"deletions":18,"changes":31,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/2eb202c9e0bebcfb64083d05104608f136bc9b38/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Futil%2Fmultiparent%2FMultiParentNodeOp.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/2eb202c9e0bebcfb64083d05104608f136bc9b38/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Futil%2Fmultiparent%2FMultiParentNodeOp.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Futil%2Fmultiparent%2FMultiParentNodeOp.java?ref=2eb202c9e0bebcfb64083d05104608f136bc9b38","patch":"@@ -19,36 +19,31 @@\n package org.apache.syncope.core.util.multiparent;\n \n import java.util.List;\n+import java.util.Set;\n \n public class MultiParentNodeOp {\n \n     private MultiParentNodeOp() {\n     }\n \n-    public static <T> MultiParentNode<T> findInTree(final MultiParentNode<T> parent, final T object) {\n-\n-        if (parent.getObject().equals(object)) {\n-            return parent;\n-        }\n-\n-        for (MultiParentNode<T> child : parent.getChildren()) {\n-            MultiParentNode<T> found = findInTree(child, object);\n-            if (found != null) {\n-                return found;\n-            }\n+    public static <T> void traverseTree(final Set<MultiParentNode<T>> roots, final List<T> objects) {\n+        for (MultiParentNode<T> root : roots) {\n+            traverseTree(root, objects);\n         }\n-\n-        return null;\n     }\n \n-    public static <T> void traverseTree(final MultiParentNode<T> parent, final List<T> objects) {\n+    public static <T> void traverseTree(final MultiParentNode<T> root, final List<T> objects) {\n+\n+        root.setExploited(true);\n \n-        for (MultiParentNode<T> child : parent.getChildren()) {\n-            traverseTree(child, objects);\n+        for (MultiParentNode<T> child : root.getChildren()) {\n+            if (!child.isExploited()) {\n+                traverseTree(child, objects);\n+            }\n         }\n \n-        if (!objects.contains(parent.getObject())) {\n-            objects.add(parent.getObject());\n+        if (!objects.contains(root.getObject())) {\n+            objects.add(root.getObject());\n         }\n     }\n }"},{"sha":"6246ff00040c760cdfe0075c57d9791218281864","filename":"core/src/test/resources/oracle/persistence.properties","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/2eb202c9e0bebcfb64083d05104608f136bc9b38/core%2Fsrc%2Ftest%2Fresources%2Foracle%2Fpersistence.properties","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/2eb202c9e0bebcfb64083d05104608f136bc9b38/core%2Fsrc%2Ftest%2Fresources%2Foracle%2Fpersistence.properties","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Ftest%2Fresources%2Foracle%2Fpersistence.properties?ref=2eb202c9e0bebcfb64083d05104608f136bc9b38","patch":"@@ -22,3 +22,4 @@ jpa.dialect=org.apache.openjpa.jdbc.sql.OracleDictionary\n quartz.jobstore=org.quartz.impl.jdbcjobstore.oracle.OracleDelegate\n quartz.sql=tables_oracle.sql\n logback.sql=oracle.sql\n+database.schema=SYNCOPE"}]}