{"sha":"dd02660c060fac2fe5b668394c34a73f9714452d","node_id":"MDY6Q29tbWl0NjM2ODc5MDYyOmRkMDI2NjBjMDYwZmFjMmZlNWI2NjgzOTRjMzRhNzNmOTcxNDQ1MmQ=","commit":{"author":{"name":"Francesco Chicchiriccò","email":"ilgrosso@apache.org","date":"2012-03-07T14:57:57Z"},"committer":{"name":"Francesco Chicchiriccò","email":"ilgrosso@apache.org","date":"2012-03-07T14:57:57Z"},"message":"[SYNCOPE-27] Using Spring's ClassUtils.getAllInterfacesForClassAsSet() in order to get all interfaces implemented, including ones implemented by superclasses\n\ngit-svn-id: https://svn.apache.org/repos/asf/incubator/syncope/trunk@1297984 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"1e05a8f7a4152f59088d5465fb0833cfda335256","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/git/trees/1e05a8f7a4152f59088d5465fb0833cfda335256"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/git/commits/dd02660c060fac2fe5b668394c34a73f9714452d","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/dd02660c060fac2fe5b668394c34a73f9714452d","html_url":"https://github.com/EnricoDAlessandro97UNI/syncope/commit/dd02660c060fac2fe5b668394c34a73f9714452d","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/dd02660c060fac2fe5b668394c34a73f9714452d/comments","author":{"login":"ilgrosso","id":1064664,"node_id":"MDQ6VXNlcjEwNjQ2NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/1064664?v=4","gravatar_id":"","url":"https://api.github.com/users/ilgrosso","html_url":"https://github.com/ilgrosso","followers_url":"https://api.github.com/users/ilgrosso/followers","following_url":"https://api.github.com/users/ilgrosso/following{/other_user}","gists_url":"https://api.github.com/users/ilgrosso/gists{/gist_id}","starred_url":"https://api.github.com/users/ilgrosso/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ilgrosso/subscriptions","organizations_url":"https://api.github.com/users/ilgrosso/orgs","repos_url":"https://api.github.com/users/ilgrosso/repos","events_url":"https://api.github.com/users/ilgrosso/events{/privacy}","received_events_url":"https://api.github.com/users/ilgrosso/received_events","type":"User","site_admin":false},"committer":{"login":"ilgrosso","id":1064664,"node_id":"MDQ6VXNlcjEwNjQ2NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/1064664?v=4","gravatar_id":"","url":"https://api.github.com/users/ilgrosso","html_url":"https://github.com/ilgrosso","followers_url":"https://api.github.com/users/ilgrosso/followers","following_url":"https://api.github.com/users/ilgrosso/following{/other_user}","gists_url":"https://api.github.com/users/ilgrosso/gists{/gist_id}","starred_url":"https://api.github.com/users/ilgrosso/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ilgrosso/subscriptions","organizations_url":"https://api.github.com/users/ilgrosso/orgs","repos_url":"https://api.github.com/users/ilgrosso/repos","events_url":"https://api.github.com/users/ilgrosso/events{/privacy}","received_events_url":"https://api.github.com/users/ilgrosso/received_events","type":"User","site_admin":false},"parents":[{"sha":"2311a2e0bfc8073c5f7424fb73dc24b24cbab2c6","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/2311a2e0bfc8073c5f7424fb73dc24b24cbab2c6","html_url":"https://github.com/EnricoDAlessandro97UNI/syncope/commit/2311a2e0bfc8073c5f7424fb73dc24b24cbab2c6"}],"stats":{"total":353,"additions":123,"deletions":230},"files":[{"sha":"38458653f505a06c758d1472c57c306107af2fce","filename":"core/src/main/java/org/syncope/core/rest/controller/ConfigurationController.java","status":"modified","additions":33,"deletions":64,"changes":97,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/dd02660c060fac2fe5b668394c34a73f9714452d/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Frest%2Fcontroller%2FConfigurationController.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/dd02660c060fac2fe5b668394c34a73f9714452d/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Frest%2Fcontroller%2FConfigurationController.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Frest%2Fcontroller%2FConfigurationController.java?ref=dd02660c060fac2fe5b668394c34a73f9714452d","patch":"@@ -19,14 +19,12 @@\n package org.syncope.core.rest.controller;\n \n import java.io.IOException;\n-import java.lang.reflect.Modifier;\n import java.util.ArrayList;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Set;\n import javax.servlet.http.HttpServletRequest;\n import javax.servlet.http.HttpServletResponse;\n-import org.apache.commons.lang.ArrayUtils;\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.core.io.Resource;\n import org.springframework.core.io.support.ResourcePatternResolver;\n@@ -36,6 +34,7 @@\n import org.springframework.security.access.prepost.PreAuthorize;\n import org.springframework.stereotype.Controller;\n import org.springframework.transaction.annotation.Transactional;\n+import org.springframework.util.ClassUtils;\n import org.springframework.web.bind.annotation.PathVariable;\n import org.springframework.web.bind.annotation.RequestBody;\n import org.springframework.web.bind.annotation.RequestMapping;\n@@ -45,7 +44,6 @@\n import org.syncope.core.persistence.beans.SyncopeConf;\n import org.syncope.core.persistence.dao.ConfDAO;\n import org.syncope.core.persistence.dao.MissingConfKeyException;\n-import org.syncope.core.persistence.validation.attrvalue.AbstractValidator;\n import org.syncope.core.persistence.validation.attrvalue.Validator;\n import org.syncope.core.rest.data.ConfigurationDataBinder;\n import org.syncope.core.util.ImportExport;\n@@ -67,16 +65,13 @@ public class ConfigurationController extends AbstractController {\n     private ResourcePatternResolver resResolver;\n \n     @PreAuthorize(\"hasRole('CONFIGURATION_CREATE')\")\n-    @RequestMapping(method = RequestMethod.POST,\n-    value = \"/create\")\n+    @RequestMapping(method = RequestMethod.POST, value = \"/create\")\n     public ConfigurationTO create(final HttpServletResponse response,\n             @RequestBody final ConfigurationTO configurationTO) {\n \n-        LOG.debug(\"Configuration create called with parameters {}\",\n-                configurationTO);\n+        LOG.debug(\"Configuration create called with parameters {}\", configurationTO);\n \n-        SyncopeConf conf = configurationDataBinder.createSyncopeConfiguration(\n-                configurationTO);\n+        SyncopeConf conf = configurationDataBinder.createSyncopeConfiguration(configurationTO);\n         conf = confDAO.save(conf);\n \n         response.setStatus(HttpServletResponse.SC_CREATED);\n@@ -85,8 +80,7 @@ public ConfigurationTO create(final HttpServletResponse response,\n     }\n \n     @PreAuthorize(\"hasRole('CONFIGURATION_DELETE')\")\n-    @RequestMapping(method = RequestMethod.DELETE,\n-    value = \"/delete/{key}\")\n+    @RequestMapping(method = RequestMethod.DELETE, value = \"/delete/{key}\")\n     public void delete(@PathVariable(\"key\") final String key)\n             throws MissingConfKeyException {\n \n@@ -95,16 +89,13 @@ public void delete(@PathVariable(\"key\") final String key)\n     }\n \n     @PreAuthorize(\"hasRole('CONFIGURATION_LIST')\")\n-    @RequestMapping(method = RequestMethod.GET,\n-    value = \"/list\")\n-    public List<ConfigurationTO> list(HttpServletRequest request) {\n+    @RequestMapping(method = RequestMethod.GET, value = \"/list\")\n+    public List<ConfigurationTO> list(final HttpServletRequest request) {\n         List<SyncopeConf> configurations = confDAO.findAll();\n-        List<ConfigurationTO> configurationTOs =\n-                new ArrayList<ConfigurationTO>(configurations.size());\n+        List<ConfigurationTO> configurationTOs = new ArrayList<ConfigurationTO>(configurations.size());\n \n         for (SyncopeConf configuration : configurations) {\n-            configurationTOs.add(\n-                    configurationDataBinder.getConfigurationTO(configuration));\n+            configurationTOs.add(configurationDataBinder.getConfigurationTO(configuration));\n         }\n \n         return configurationTOs;\n@@ -113,17 +104,15 @@ public List<ConfigurationTO> list(HttpServletRequest request) {\n     @PreAuthorize(\"hasRole('CONFIGURATION_READ')\")\n     @RequestMapping(method = RequestMethod.GET,\n     value = \"/read/{key}\")\n-    public ConfigurationTO read(HttpServletResponse response,\n-            @PathVariable(\"key\") String key)\n+    public ConfigurationTO read(final HttpServletResponse response, @PathVariable(\"key\") final String key)\n             throws MissingConfKeyException {\n \n         ConfigurationTO result;\n         try {\n             SyncopeConf conf = confDAO.find(key);\n             result = configurationDataBinder.getConfigurationTO(conf);\n         } catch (MissingConfKeyException e) {\n-            LOG.error(\"Could not find configuration key '\" + key\n-                    + \"', returning null\");\n+            LOG.error(\"Could not find configuration key '\" + key + \"', returning null\");\n \n             result = new ConfigurationTO();\n             result.setKey(key);\n@@ -139,67 +128,51 @@ public ConfigurationTO update(final HttpServletResponse response,\n             @RequestBody final ConfigurationTO configurationTO)\n             throws MissingConfKeyException {\n \n-        SyncopeConf syncopeConfiguration =\n-                confDAO.find(configurationTO.getKey());\n+        SyncopeConf syncopeConfiguration = confDAO.find(configurationTO.getKey());\n \n         syncopeConfiguration.setValue(configurationTO.getValue());\n \n         return configurationDataBinder.getConfigurationTO(syncopeConfiguration);\n     }\n \n     @PreAuthorize(\"hasRole('CONFIGURATION_LIST')\")\n-    @RequestMapping(method = RequestMethod.GET,\n-    value = \"/validators\")\n+    @RequestMapping(method = RequestMethod.GET, value = \"/validators\")\n     public ModelAndView getValidators() {\n-        CachingMetadataReaderFactory cachingMetadataReaderFactory =\n-                new CachingMetadataReaderFactory();\n+        CachingMetadataReaderFactory cachingMetadataReaderFactory = new CachingMetadataReaderFactory();\n \n         Set<String> validators = new HashSet<String>();\n         try {\n             for (Resource resource : resResolver.getResources(\n-                    \"classpath:org/syncope/core/persistence/validation/\"\n-                    + \"attrvalue/*.class\")) {\n-\n-                ClassMetadata metadata =\n-                        cachingMetadataReaderFactory.getMetadataReader(\n-                        resource).getClassMetadata();\n-                if (ArrayUtils.contains(metadata.getInterfaceNames(),\n-                        Validator.class.getName())\n-                        || AbstractValidator.class.getName().equals(\n-                        metadata.getSuperClassName())) {\n-\n-                    try {\n-                        Class jobClass = Class.forName(metadata.getClassName());\n-                        if (!Modifier.isAbstract(jobClass.getModifiers())) {\n-                            validators.add(jobClass.getName());\n-                        }\n-                    } catch (ClassNotFoundException e) {\n-                        LOG.error(\"Could not load class {}\",\n-                                metadata.getClassName(), e);\n+                    \"classpath:org/syncope/core/persistence/validation/attrvalue/*.class\")) {\n+\n+                ClassMetadata metadata = cachingMetadataReaderFactory.getMetadataReader(resource).getClassMetadata();\n+\n+                try {\n+                    Set<Class> interfaces = ClassUtils.getAllInterfacesForClassAsSet(\n+                            ClassUtils.forName(metadata.getClassName(), ClassUtils.getDefaultClassLoader()));\n+\n+                    if (interfaces.contains(Validator.class) && !metadata.isAbstract()) {\n+                        validators.add(metadata.getClassName());\n                     }\n+                } catch (ClassNotFoundException e) {\n+                    LOG.error(\"Could not load class {}\", metadata.getClassName(), e);\n                 }\n             }\n         } catch (IOException e) {\n-            LOG.error(\"While searching for class implementing {}\",\n-                    Validator.class.getName(), e);\n+            LOG.error(\"While searching for class implementing {}\", Validator.class.getName(), e);\n         }\n \n         return new ModelAndView().addObject(validators);\n     }\n \n     @PreAuthorize(\"hasRole('CONFIGURATION_LIST')\")\n-    @RequestMapping(method = RequestMethod.GET,\n-    value = \"/mailTemplates\")\n+    @RequestMapping(method = RequestMethod.GET, value = \"/mailTemplates\")\n     public ModelAndView getMailTemplates() {\n-        CachingMetadataReaderFactory cachingMetadataReaderFactory =\n-                new CachingMetadataReaderFactory();\n-\n         Set<String> htmlTemplates = new HashSet<String>();\n         Set<String> textTemplates = new HashSet<String>();\n \n         try {\n-            for (Resource resource : resResolver.getResources(\n-                    \"classpath:/mailTemplates/*.vm\")) {\n+            for (Resource resource : resResolver.getResources(\"classpath:/mailTemplates/*.vm\")) {\n \n                 String template = resource.getURL().toExternalForm();\n                 if (template.endsWith(\".html.vm\")) {\n@@ -211,13 +184,11 @@ public ModelAndView getMailTemplates() {\n                             template.indexOf(\"mailTemplates/\") + 14,\n                             template.indexOf(\".txt.vm\")));\n                 } else {\n-                    LOG.warn(\"Unexpected template found: {}, ignoring...\",\n-                            template);\n+                    LOG.warn(\"Unexpected template found: {}, ignoring...\", template);\n                 }\n             }\n         } catch (IOException e) {\n-            LOG.error(\"While searching for class implementing {}\",\n-                    Validator.class.getName(), e);\n+            LOG.error(\"While searching for class implementing {}\", Validator.class.getName(), e);\n         }\n \n         // Only templates available both as HTML and TEXT are considered\n@@ -227,13 +198,11 @@ public ModelAndView getMailTemplates() {\n     }\n \n     @PreAuthorize(\"hasRole('CONFIGURATION_READ')\")\n-    @RequestMapping(method = RequestMethod.GET,\n-    value = \"/dbexport\")\n+    @RequestMapping(method = RequestMethod.GET, value = \"/dbexport\")\n     @Transactional(readOnly = true)\n     public void dbExport(final HttpServletResponse response) {\n         response.setContentType(MediaType.TEXT_XML_VALUE);\n-        response.setHeader(\"Content-Disposition\",\n-                \"attachment; filename=content.xml\");\n+        response.setHeader(\"Content-Disposition\", \"attachment; filename=content.xml\");\n \n         try {\n             importExport.export(response.getOutputStream());"},{"sha":"38a5a300a616e7ab4e771c0efb40bddc740c423a","filename":"core/src/main/java/org/syncope/core/rest/controller/TaskController.java","status":"modified","additions":73,"deletions":136,"changes":209,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/dd02660c060fac2fe5b668394c34a73f9714452d/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Frest%2Fcontroller%2FTaskController.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/dd02660c060fac2fe5b668394c34a73f9714452d/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Frest%2Fcontroller%2FTaskController.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Frest%2Fcontroller%2FTaskController.java?ref=dd02660c060fac2fe5b668394c34a73f9714452d","patch":"@@ -19,15 +19,13 @@\n package org.syncope.core.rest.controller;\n \n import java.io.IOException;\n-import java.lang.reflect.Modifier;\n import java.util.ArrayList;\n import java.util.Date;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Set;\n import javassist.NotFoundException;\n import javax.servlet.http.HttpServletResponse;\n-import org.apache.commons.lang.ArrayUtils;\n import org.quartz.Job;\n import org.quartz.JobDataMap;\n import org.quartz.Scheduler;\n@@ -41,6 +39,7 @@\n import org.springframework.scheduling.quartz.SchedulerFactoryBean;\n import org.springframework.security.access.prepost.PreAuthorize;\n import org.springframework.stereotype.Controller;\n+import org.springframework.util.ClassUtils;\n import org.springframework.web.bind.annotation.PathVariable;\n import org.springframework.web.bind.annotation.RequestBody;\n import org.springframework.web.bind.annotation.RequestMapping;\n@@ -103,21 +102,16 @@ public class TaskController extends AbstractController {\n     private ResourcePatternResolver resResolver;\n \n     @PreAuthorize(\"hasRole('TASK_CREATE')\")\n-    @RequestMapping(method = RequestMethod.POST,\n-    value = \"/create/sync\")\n-    public TaskTO createSyncTask(final HttpServletResponse response,\n-            @RequestBody final SyncTaskTO taskTO)\n+    @RequestMapping(method = RequestMethod.POST, value = \"/create/sync\")\n+    public TaskTO createSyncTask(final HttpServletResponse response, @RequestBody final SyncTaskTO taskTO)\n             throws NotFoundException {\n \n         return createSchedTask(response, taskTO);\n     }\n \n     @PreAuthorize(\"hasRole('TASK_CREATE')\")\n-    @RequestMapping(method = RequestMethod.POST,\n-    value = \"/create/sched\")\n-    public TaskTO createSchedTask(\n-            final HttpServletResponse response,\n-            @RequestBody final SchedTaskTO taskTO)\n+    @RequestMapping(method = RequestMethod.POST, value = \"/create/sched\")\n+    public TaskTO createSchedTask(final HttpServletResponse response, @RequestBody final SchedTaskTO taskTO)\n             throws NotFoundException {\n \n         LOG.debug(\"Creating task \" + taskTO);\n@@ -128,17 +122,13 @@ public TaskTO createSchedTask(\n         task = taskDAO.save(task);\n \n         try {\n-            jobInstanceLoader.registerJob(task, task.getJobClassName(),\n-                    task.getCronExpression());\n+            jobInstanceLoader.registerJob(task, task.getJobClassName(), task.getCronExpression());\n         } catch (Exception e) {\n-            LOG.error(\"While registering quartz job for task \"\n-                    + task.getId(), e);\n+            LOG.error(\"While registering quartz job for task \" + task.getId(), e);\n \n             SyncopeClientCompositeErrorException scce =\n-                    new SyncopeClientCompositeErrorException(\n-                    HttpStatus.BAD_REQUEST);\n-            SyncopeClientException sce = new SyncopeClientException(\n-                    SyncopeClientExceptionType.Scheduling);\n+                    new SyncopeClientCompositeErrorException(HttpStatus.BAD_REQUEST);\n+            SyncopeClientException sce = new SyncopeClientException(SyncopeClientExceptionType.Scheduling);\n             sce.addElement(e.getMessage());\n             scce.addException(sce);\n             throw scce;\n@@ -149,46 +139,38 @@ public TaskTO createSchedTask(\n     }\n \n     @PreAuthorize(\"hasRole('TASK_UPDATE')\")\n-    @RequestMapping(method = RequestMethod.POST,\n-    value = \"/update/sync\")\n+    @RequestMapping(method = RequestMethod.POST, value = \"/update/sync\")\n     public TaskTO updateSync(@RequestBody final SyncTaskTO taskTO)\n             throws NotFoundException {\n \n         return updateSched(taskTO);\n     }\n \n     @PreAuthorize(\"hasRole('TASK_UPDATE')\")\n-    @RequestMapping(method = RequestMethod.POST,\n-    value = \"/update/sched\")\n+    @RequestMapping(method = RequestMethod.POST, value = \"/update/sched\")\n     public TaskTO updateSched(@RequestBody final SchedTaskTO taskTO)\n             throws NotFoundException {\n \n         LOG.debug(\"Task update called with parameter {}\", taskTO);\n \n         SchedTask task = taskDAO.find(taskTO.getId());\n         if (task == null) {\n-            throw new NotFoundException(\n-                    \"Task \" + String.valueOf(taskTO.getId()));\n+            throw new NotFoundException(\"Task \" + String.valueOf(taskTO.getId()));\n         }\n \n         TaskUtil taskUtil = getTaskUtil(task);\n \n-        SyncopeClientCompositeErrorException scce =\n-                new SyncopeClientCompositeErrorException(\n-                HttpStatus.BAD_REQUEST);\n+        SyncopeClientCompositeErrorException scce = new SyncopeClientCompositeErrorException(HttpStatus.BAD_REQUEST);\n \n         binder.updateSchedTask(task, taskTO, taskUtil);\n         task = taskDAO.save(task);\n \n         try {\n-            jobInstanceLoader.registerJob(task, task.getJobClassName(),\n-                    task.getCronExpression());\n+            jobInstanceLoader.registerJob(task, task.getJobClassName(), task.getCronExpression());\n         } catch (Exception e) {\n-            LOG.error(\"While registering quartz job for task \"\n-                    + task.getId(), e);\n+            LOG.error(\"While registering quartz job for task \" + task.getId(), e);\n \n-            SyncopeClientException sce = new SyncopeClientException(\n-                    SyncopeClientExceptionType.Scheduling);\n+            SyncopeClientException sce = new SyncopeClientException(SyncopeClientExceptionType.Scheduling);\n             sce.addElement(e.getMessage());\n             scce.addException(sce);\n             throw scce;\n@@ -198,16 +180,13 @@ public TaskTO updateSched(@RequestBody final SchedTaskTO taskTO)\n     }\n \n     @PreAuthorize(\"hasRole('TASK_LIST')\")\n-    @RequestMapping(method = RequestMethod.GET,\n-    value = \"/{kind}/count\")\n+    @RequestMapping(method = RequestMethod.GET, value = \"/{kind}/count\")\n     public ModelAndView count(@PathVariable(\"kind\") final String kind) {\n-        return new ModelAndView().addObject(\n-                taskDAO.count(getTaskUtil(kind).taskClass()));\n+        return new ModelAndView().addObject(taskDAO.count(getTaskUtil(kind).taskClass()));\n     }\n \n     @PreAuthorize(\"hasRole('TASK_LIST')\")\n-    @RequestMapping(method = RequestMethod.GET,\n-    value = \"/{kind}/list\")\n+    @RequestMapping(method = RequestMethod.GET, value = \"/{kind}/list\")\n     public List<TaskTO> list(@PathVariable(\"kind\") final String kind) {\n         TaskUtil taskUtil = getTaskUtil(kind);\n \n@@ -221,8 +200,7 @@ public List<TaskTO> list(@PathVariable(\"kind\") final String kind) {\n     }\n \n     @PreAuthorize(\"hasRole('TASK_LIST')\")\n-    @RequestMapping(method = RequestMethod.GET,\n-    value = \"/{kind}/list/{page}/{size}\")\n+    @RequestMapping(method = RequestMethod.GET, value = \"/{kind}/list/{page}/{size}\")\n     public List<TaskTO> list(\n             @PathVariable(\"kind\") final String kind,\n             @PathVariable(\"page\") final int page,\n@@ -242,13 +220,10 @@ public List<TaskTO> list(\n     @PreAuthorize(\"hasRole('TASK_LIST')\")\n     @RequestMapping(method = RequestMethod.GET,\n     value = \"/{kind}/execution/list\")\n-    public List<TaskExecTO> listExecutions(\n-            @PathVariable(\"kind\") final String kind) {\n+    public List<TaskExecTO> listExecutions(@PathVariable(\"kind\") final String kind) {\n \n-        List<TaskExec> executions = taskExecDAO.findAll(\n-                getTaskUtil(kind).taskClass());\n-        List<TaskExecTO> executionTOs =\n-                new ArrayList<TaskExecTO>(executions.size());\n+        List<TaskExec> executions = taskExecDAO.findAll(getTaskUtil(kind).taskClass());\n+        List<TaskExecTO> executionTOs = new ArrayList<TaskExecTO>(executions.size());\n         for (TaskExec execution : executions) {\n             executionTOs.add(binder.getTaskExecTO(execution));\n         }\n@@ -257,46 +232,34 @@ public List<TaskExecTO> listExecutions(\n     }\n \n     @PreAuthorize(\"hasRole('TASK_LIST')\")\n-    @RequestMapping(method = RequestMethod.GET,\n-    value = \"/jobClasses\")\n+    @RequestMapping(method = RequestMethod.GET, value = \"/jobClasses\")\n     public ModelAndView getJobClasses() {\n-        CachingMetadataReaderFactory cachingMetadataReaderFactory =\n-                new CachingMetadataReaderFactory();\n+        CachingMetadataReaderFactory cachingMetadataReaderFactory = new CachingMetadataReaderFactory();\n \n         Set<String> jobClasses = new HashSet<String>();\n         try {\n-            for (Resource resource : resResolver.getResources(\n-                    \"classpath*:**/*.class\")) {\n-\n-                ClassMetadata metadata =\n-                        cachingMetadataReaderFactory.getMetadataReader(\n-                        resource).getClassMetadata();\n-                if (ArrayUtils.contains(metadata.getInterfaceNames(),\n-                        Job.class.getName())\n-                        || AbstractTaskJob.class.getName().equals(\n-                        metadata.getSuperClassName())\n-                        || ArrayUtils.contains(metadata.getInterfaceNames(),\n-                        StatefulJob.class.getName())) {\n-\n-                    try {\n-                        Class jobClass = Class.forName(metadata.getClassName());\n-                        if (!Modifier.isAbstract(jobClass.getModifiers())\n-                                && !metadata.hasEnclosingClass()\n-                                && !jobClass.equals(SyncJob.class)\n-                                && !jobClass.equals(ReportJob.class)\n-                                && !jobClass.equals(NotificationJob.class)) {\n-\n-                            jobClasses.add(jobClass.getName());\n-                        }\n-                    } catch (ClassNotFoundException e) {\n-                        LOG.error(\"Could not load class {}\",\n-                                metadata.getClassName(), e);\n+            for (Resource resource : resResolver.getResources(\"classpath*:**/*.class\")) {\n+\n+                ClassMetadata metadata = cachingMetadataReaderFactory.getMetadataReader(resource).getClassMetadata();\n+\n+                try {\n+                    Set<Class> interfaces = ClassUtils.getAllInterfacesForClassAsSet(\n+                            ClassUtils.forName(metadata.getClassName(), ClassUtils.getDefaultClassLoader()));\n+\n+                    if ((interfaces.contains(Job.class) || interfaces.contains(StatefulJob.class))\n+                            && !metadata.isAbstract()\n+                            && !SyncJob.class.getName().equals(metadata.getClassName())\n+                            && !ReportJob.class.getName().equals(metadata.getClassName())\n+                            && !NotificationJob.class.getName().equals(metadata.getClassName())) {\n+\n+                        jobClasses.add(metadata.getClassName());\n                     }\n+                } catch (ClassNotFoundException e) {\n+                    LOG.error(\"Could not load class {}\", metadata.getClassName(), e);\n                 }\n             }\n         } catch (IOException e) {\n-            LOG.error(\"While searching for class implementing {}\",\n-                    Job.class.getName(), e);\n+            LOG.error(\"While searching for class implementing {}\", Job.class.getName(), e);\n         }\n \n         ModelAndView result = new ModelAndView();\n@@ -305,37 +268,28 @@ public ModelAndView getJobClasses() {\n     }\n \n     @PreAuthorize(\"hasRole('TASK_LIST')\")\n-    @RequestMapping(method = RequestMethod.GET,\n-    value = \"/jobActionsClasses\")\n+    @RequestMapping(method = RequestMethod.GET, value = \"/jobActionsClasses\")\n     public ModelAndView getJobActionClasses() {\n-        CachingMetadataReaderFactory cachingMetadataReaderFactory =\n-                new CachingMetadataReaderFactory();\n+        CachingMetadataReaderFactory cachingMetadataReaderFactory = new CachingMetadataReaderFactory();\n \n         Set<String> jobActionsClasses = new HashSet<String>();\n         try {\n-            for (Resource resource : resResolver.getResources(\n-                    \"classpath*:**/*.class\")) {\n-\n-                ClassMetadata metadata =\n-                        cachingMetadataReaderFactory.getMetadataReader(\n-                        resource).getClassMetadata();\n-                if (ArrayUtils.contains(metadata.getInterfaceNames(),\n-                        SyncJobActions.class.getName())) {\n-\n-                    try {\n-                        Class jobClass = Class.forName(metadata.getClassName());\n-                        if (!Modifier.isAbstract(jobClass.getModifiers())) {\n-                            jobActionsClasses.add(jobClass.getName());\n-                        }\n-                    } catch (ClassNotFoundException e) {\n-                        LOG.error(\"Could not load class {}\",\n-                                metadata.getClassName(), e);\n+            for (Resource resource : resResolver.getResources(\"classpath*:**/*.class\")) {\n+                ClassMetadata metadata = cachingMetadataReaderFactory.getMetadataReader(resource).getClassMetadata();\n+\n+                try {\n+                    Set<Class> interfaces = ClassUtils.getAllInterfacesForClassAsSet(\n+                            ClassUtils.forName(metadata.getClassName(), ClassUtils.getDefaultClassLoader()));\n+\n+                    if (interfaces.contains(SyncJobActions.class) && !metadata.isAbstract()) {\n+                        jobActionsClasses.add(metadata.getClassName());\n                     }\n+                } catch (ClassNotFoundException e) {\n+                    LOG.error(\"Could not load class {}\", metadata.getClassName(), e);\n                 }\n             }\n         } catch (IOException e) {\n-            LOG.error(\"While searching for class implementing {}\",\n-                    SyncJobActions.class.getName(), e);\n+            LOG.error(\"While searching for class implementing {}\", SyncJobActions.class.getName(), e);\n         }\n \n         ModelAndView result = new ModelAndView();\n@@ -344,8 +298,7 @@ public ModelAndView getJobActionClasses() {\n     }\n \n     @PreAuthorize(\"hasRole('TASK_READ')\")\n-    @RequestMapping(method = RequestMethod.GET,\n-    value = \"/read/{taskId}\")\n+    @RequestMapping(method = RequestMethod.GET, value = \"/read/{taskId}\")\n     public TaskTO read(@PathVariable(\"taskId\") final Long taskId)\n             throws NotFoundException {\n \n@@ -358,8 +311,7 @@ public TaskTO read(@PathVariable(\"taskId\") final Long taskId)\n     }\n \n     @PreAuthorize(\"hasRole('TASK_READ')\")\n-    @RequestMapping(method = RequestMethod.GET,\n-    value = \"/execution/read/{executionId}\")\n+    @RequestMapping(method = RequestMethod.GET, value = \"/execution/read/{executionId}\")\n     public TaskExecTO readExecution(\n             @PathVariable(\"executionId\") final Long executionId)\n             throws NotFoundException {\n@@ -373,8 +325,7 @@ public TaskExecTO readExecution(\n     }\n \n     @PreAuthorize(\"hasRole('TASK_EXECUTE')\")\n-    @RequestMapping(method = RequestMethod.POST,\n-    value = \"/execute/{taskId}\")\n+    @RequestMapping(method = RequestMethod.POST, value = \"/execute/{taskId}\")\n     public TaskExecTO execute(@PathVariable(\"taskId\") final Long taskId,\n             @RequestParam(value = \"dryRun\", defaultValue = \"false\") final boolean dryRun)\n             throws NotFoundException {\n@@ -388,14 +339,12 @@ public TaskExecTO execute(@PathVariable(\"taskId\") final Long taskId,\n         LOG.debug(\"Execution started for {}\", task);\n         switch (getTaskUtil(task)) {\n             case PROPAGATION:\n-                final TaskExec propExec = propagationManager.execute(\n-                        (PropagationTask) task);\n+                final TaskExec propExec = propagationManager.execute((PropagationTask) task);\n                 result = binder.getTaskExecTO(propExec);\n                 break;\n \n             case NOTIFICATION:\n-                final TaskExec notExec = notificationManager.execute(\n-                        (NotificationTask) task);\n+                final TaskExec notExec = notificationManager.execute((NotificationTask) task);\n                 result = binder.getTaskExecTO(notExec);\n                 break;\n \n@@ -415,10 +364,8 @@ public TaskExecTO execute(@PathVariable(\"taskId\") final Long taskId,\n                     LOG.error(\"While executing task {}\", task, e);\n \n                     SyncopeClientCompositeErrorException scce =\n-                            new SyncopeClientCompositeErrorException(\n-                            HttpStatus.BAD_REQUEST);\n-                    SyncopeClientException sce = new SyncopeClientException(\n-                            SyncopeClientExceptionType.Scheduling);\n+                            new SyncopeClientCompositeErrorException(HttpStatus.BAD_REQUEST);\n+                    SyncopeClientException sce = new SyncopeClientException(SyncopeClientExceptionType.Scheduling);\n                     sce.addElement(e.getMessage());\n                     scce.addException(sce);\n                     throw scce;\n@@ -439,12 +386,10 @@ public TaskExecTO execute(@PathVariable(\"taskId\") final Long taskId,\n     }\n \n     @PreAuthorize(\"hasRole('TASK_READ')\")\n-    @RequestMapping(method = RequestMethod.GET,\n-    value = \"/execution/report/{executionId}\")\n+    @RequestMapping(method = RequestMethod.GET, value = \"/execution/report/{executionId}\")\n     public TaskExecTO report(\n             @PathVariable(\"executionId\") final Long executionId,\n-            @RequestParam(\"executionStatus\")\n-            final PropagationTaskExecStatus status,\n+            @RequestParam(\"executionStatus\") final PropagationTaskExecStatus status,\n             @RequestParam(\"message\") final String message)\n             throws NotFoundException, SyncopeClientCompositeErrorException {\n \n@@ -454,17 +399,15 @@ public TaskExecTO report(\n         }\n \n         SyncopeClientException invalidReportException =\n-                new SyncopeClientException(\n-                SyncopeClientExceptionType.InvalidPropagationTaskExecReport);\n+                new SyncopeClientException(SyncopeClientExceptionType.InvalidPropagationTaskExecReport);\n \n         TaskUtil taskUtil = getTaskUtil(exec.getTask());\n         if (taskUtil != TaskUtil.PROPAGATION) {\n             invalidReportException.addElement(\"Task type: \" + taskUtil);\n         } else {\n             PropagationTask task = (PropagationTask) exec.getTask();\n             if (task.getPropagationMode() != PropagationMode.TWO_PHASES) {\n-                invalidReportException.addElement(\n-                        \"Propagation mode: \" + task.getPropagationMode());\n+                invalidReportException.addElement(\"Propagation mode: \" + task.getPropagationMode());\n             }\n         }\n \n@@ -476,17 +419,15 @@ public TaskExecTO report(\n             case CREATED:\n             case SUBMITTED:\n             case UNSUBMITTED:\n-                invalidReportException.addElement(\n-                        \"Execution status to be set: \" + status);\n+                invalidReportException.addElement(\"Execution status to be set: \" + status);\n                 break;\n \n             default:\n         }\n \n         if (!invalidReportException.isEmpty()) {\n             SyncopeClientCompositeErrorException scce =\n-                    new SyncopeClientCompositeErrorException(\n-                    HttpStatus.BAD_REQUEST);\n+                    new SyncopeClientCompositeErrorException(HttpStatus.BAD_REQUEST);\n             scce.addException(invalidReportException);\n             throw scce;\n         }\n@@ -499,8 +440,7 @@ public TaskExecTO report(\n     }\n \n     @PreAuthorize(\"hasRole('TASK_DELETE')\")\n-    @RequestMapping(method = RequestMethod.DELETE,\n-    value = \"/delete/{taskId}\")\n+    @RequestMapping(method = RequestMethod.DELETE, value = \"/delete/{taskId}\")\n     public void delete(@PathVariable(\"taskId\") Long taskId)\n             throws NotFoundException, SyncopeClientCompositeErrorException {\n \n@@ -509,18 +449,15 @@ public void delete(@PathVariable(\"taskId\") Long taskId)\n             throw new NotFoundException(\"Task \" + taskId);\n         }\n \n-        if (TaskUtil.SCHED == getTaskUtil(task)\n-                || TaskUtil.SYNC == getTaskUtil(task)) {\n-\n+        if (TaskUtil.SCHED == getTaskUtil(task) || TaskUtil.SYNC == getTaskUtil(task)) {\n             jobInstanceLoader.unregisterJob(task);\n         }\n \n         taskDAO.delete(task);\n     }\n \n     @PreAuthorize(\"hasRole('TASK_DELETE')\")\n-    @RequestMapping(method = RequestMethod.DELETE,\n-    value = \"/execution/delete/{executionId}\")\n+    @RequestMapping(method = RequestMethod.DELETE, value = \"/execution/delete/{executionId}\")\n     public void deleteExecution(@PathVariable(\"executionId\") Long executionId)\n             throws NotFoundException, SyncopeClientCompositeErrorException {\n "},{"sha":"80e57a066e7379460dc7398b8c6d5161e96d860b","filename":"core/src/main/java/org/syncope/core/rest/data/ReportDataBinder.java","status":"modified","additions":10,"deletions":13,"changes":23,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/dd02660c060fac2fe5b668394c34a73f9714452d/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Frest%2Fdata%2FReportDataBinder.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/dd02660c060fac2fe5b668394c34a73f9714452d/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Frest%2Fdata%2FReportDataBinder.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Frest%2Fdata%2FReportDataBinder.java?ref=dd02660c060fac2fe5b668394c34a73f9714452d","patch":"@@ -19,10 +19,8 @@\n package org.syncope.core.rest.data;\n \n import java.io.IOException;\n-import java.lang.reflect.Modifier;\n import java.util.HashSet;\n import java.util.Set;\n-import org.apache.commons.lang.ArrayUtils;\n import org.quartz.Scheduler;\n import org.quartz.SchedulerException;\n import org.quartz.Trigger;\n@@ -36,14 +34,14 @@\n import org.springframework.core.type.classreading.CachingMetadataReaderFactory;\n import org.springframework.scheduling.quartz.SchedulerFactoryBean;\n import org.springframework.stereotype.Component;\n+import org.springframework.util.ClassUtils;\n import org.syncope.client.report.ReportletConf;\n import org.syncope.client.to.ReportExecTO;\n import org.syncope.client.to.ReportTO;\n import org.syncope.core.init.JobInstanceLoader;\n import org.syncope.core.persistence.beans.Report;\n import org.syncope.core.persistence.beans.ReportExec;\n import org.syncope.core.persistence.dao.ReportExecDAO;\n-import org.syncope.core.report.AbstractReportlet;\n import org.syncope.core.report.Reportlet;\n import org.syncope.core.report.ReportletConfClass;\n \n@@ -78,17 +76,16 @@ public Set<Class<Reportlet>> getAllReportletClasses() {\n         try {\n             for (Resource resource : resResolver.getResources(\"classpath*:**/*.class\")) {\n                 ClassMetadata metadata = cachingMetadataReaderFactory.getMetadataReader(resource).getClassMetadata();\n-                if (ArrayUtils.contains(metadata.getInterfaceNames(), Reportlet.class.getName())\n-                        || AbstractReportlet.class.getName().equals(metadata.getSuperClassName())) {\n-\n-                    try {\n-                        Class jobClass = Class.forName(metadata.getClassName());\n-                        if (!Modifier.isAbstract(jobClass.getModifiers())) {\n-                            reportletClasses.add(jobClass);\n-                        }\n-                    } catch (ClassNotFoundException e) {\n-                        LOG.error(\"Could not load class {}\", metadata.getClassName(), e);\n+\n+                try {\n+                    Class reportletClass =\n+                            ClassUtils.forName(metadata.getClassName(), ClassUtils.getDefaultClassLoader());\n+                    Set<Class> interfaces = ClassUtils.getAllInterfacesForClassAsSet(reportletClass);\n+                    if (interfaces.contains(Reportlet.class) && !metadata.isAbstract()) {\n+                        reportletClasses.add(reportletClass);\n                     }\n+                } catch (ClassNotFoundException e) {\n+                    LOG.error(\"Could not load class {}\", metadata.getClassName(), e);\n                 }\n             }\n         } catch (IOException e) {"},{"sha":"186ee28432609d69b8386a32014b3c1173236b83","filename":"core/src/main/java/org/syncope/core/util/SpringPersistenceUnitPostProcessor.java","status":"modified","additions":7,"deletions":17,"changes":24,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/dd02660c060fac2fe5b668394c34a73f9714452d/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Futil%2FSpringPersistenceUnitPostProcessor.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/dd02660c060fac2fe5b668394c34a73f9714452d/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Futil%2FSpringPersistenceUnitPostProcessor.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Futil%2FSpringPersistenceUnitPostProcessor.java?ref=dd02660c060fac2fe5b668394c34a73f9714452d","patch":"@@ -31,19 +31,16 @@\n import org.springframework.orm.jpa.persistenceunit.PersistenceUnitPostProcessor;\n \n /**\n- * Add to JPA persistence context all beans labeled as @Entity from given\n- * location.\n- * This is needed only when using LocalContainerEntityManagerFactoryBean with\n- * non-standard persistence.xml (currently JBoss-only).\n+ * Add to JPA persistence context all beans labeled as @Entity from given location. This is needed only when using\n+ * LocalContainerEntityManagerFactoryBean with non-standard persistence.xml (currently JBoss-only).\n  */\n public class SpringPersistenceUnitPostProcessor\n         implements PersistenceUnitPostProcessor {\n \n     /**\n      * Logger.\n      */\n-    private static final Logger LOG = LoggerFactory.getLogger(\n-            SpringPersistenceUnitPostProcessor.class);\n+    private static final Logger LOG = LoggerFactory.getLogger(SpringPersistenceUnitPostProcessor.class);\n \n     @Autowired\n     private ResourcePatternResolver resResolver;\n@@ -62,21 +59,14 @@ public void postProcessPersistenceUnitInfo(\n             LOG.warn(\"No locations provided\");\n         }\n \n-        CachingMetadataReaderFactory cachingMetadataReaderFactory =\n-                new CachingMetadataReaderFactory();\n+        CachingMetadataReaderFactory cachingMetadataReaderFactory = new CachingMetadataReaderFactory();\n \n         try {\n             for (String location : locations) {\n                 for (Resource resource : resResolver.getResources(location)) {\n-                    MetadataReader metadataReader =\n-                            cachingMetadataReaderFactory.getMetadataReader(\n-                            resource);\n-                    if (metadataReader.getAnnotationMetadata().\n-                            isAnnotated(Entity.class.getName())) {\n-\n-                        mpui.addManagedClassName(\n-                                metadataReader.getClassMetadata().\n-                                getClassName());\n+                    MetadataReader metadataReader = cachingMetadataReaderFactory.getMetadataReader(resource);\n+                    if (metadataReader.getAnnotationMetadata().isAnnotated(Entity.class.getName())) {\n+                        mpui.addManagedClassName(metadataReader.getClassMetadata().getClassName());\n                     }\n                 }\n             }"}]}