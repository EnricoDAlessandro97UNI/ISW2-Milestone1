{"sha":"f3a8653a8be30f80efa0908ce677abc753624d1e","node_id":"MDY6Q29tbWl0NjM2ODc5MDYyOmYzYTg2NTNhOGJlMzBmODBlZmEwOTA4Y2U2NzdhYmM3NTM2MjRkMWU=","commit":{"author":{"name":"Massimiliano Perrone","email":"massi@apache.org","date":"2012-10-26T11:19:20Z"},"committer":{"name":"Massimiliano Perrone","email":"massi@apache.org","date":"2012-10-26T11:19:20Z"},"message":"Fixes Sporadically failing test\n\ngit-svn-id: https://svn.apache.org/repos/asf/incubator/syncope/trunk@1402467 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"4ad4b5b6da246c8edc3f8a2252242167dbaa8dd0","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/git/trees/4ad4b5b6da246c8edc3f8a2252242167dbaa8dd0"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/git/commits/f3a8653a8be30f80efa0908ce677abc753624d1e","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/f3a8653a8be30f80efa0908ce677abc753624d1e","html_url":"https://github.com/EnricoDAlessandro97UNI/syncope/commit/f3a8653a8be30f80efa0908ce677abc753624d1e","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/f3a8653a8be30f80efa0908ce677abc753624d1e/comments","author":null,"committer":null,"parents":[{"sha":"1e1eeb5b5dda2371d2f1137401b15bca89b8fbb7","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/1e1eeb5b5dda2371d2f1137401b15bca89b8fbb7","html_url":"https://github.com/EnricoDAlessandro97UNI/syncope/commit/1e1eeb5b5dda2371d2f1137401b15bca89b8fbb7"}],"stats":{"total":147,"additions":78,"deletions":69},"files":[{"sha":"b1461fd83ab1a3de8201940b392dce5b7fceb7a1","filename":"core/src/main/java/org/apache/syncope/core/util/PasswordGenerator.java","status":"modified","additions":78,"deletions":69,"changes":147,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/f3a8653a8be30f80efa0908ce677abc753624d1e/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Futil%2FPasswordGenerator.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/f3a8653a8be30f80efa0908ce677abc753624d1e/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Futil%2FPasswordGenerator.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Futil%2FPasswordGenerator.java?ref=f3a8653a8be30f80efa0908ce677abc753624d1e","patch":"@@ -22,6 +22,7 @@\n import java.util.Iterator;\n import java.util.List;\n import org.apache.commons.lang.RandomStringUtils;\n+import org.apache.commons.lang.StringUtils;\n import org.apache.syncope.core.persistence.beans.ExternalResource;\n import org.apache.syncope.core.persistence.beans.role.SyncopeRole;\n import org.apache.syncope.core.persistence.beans.user.SyncopeUser;\n@@ -38,7 +39,7 @@ public class PasswordGenerator {\n \n     private static final Logger LOG = LoggerFactory.getLogger(PasswordGenerator.class);\n \n-    private static final String[] SPECIAL_CHAR = {\"!\", \"£\", \"%\", \"&\", \"(\", \")\", \"?\", \"#\", \"_\", \"$\"};\n+    private static final String[] SPECIAL_CHAR = {\"\", \"!\", \"£\", \"%\", \"&\", \"(\", \")\", \"?\", \"#\", \"_\", \"$\"};\n \n     @Autowired\n     private PolicyDAO policyDAO;\n@@ -49,6 +50,7 @@ public String generatePasswordFromPwdSpec(final List<PasswordPolicySpec> passwor\n         PasswordPolicySpec policySpec = mergePolicySpecs(passwordPolicySpecs);\n \n         evaluateFinalPolicySpec(policySpec);\n+\n         return generatePassword(policySpec);\n     }\n \n@@ -83,7 +85,6 @@ public String generateUserPassword(final SyncopeUser user)\n         }\n \n         PasswordPolicySpec policySpec = mergePolicySpecs(userPasswordPolicies);\n-\n         evaluateFinalPolicySpec(policySpec);\n         return generatePassword(policySpec);\n     }\n@@ -164,7 +165,7 @@ private PasswordPolicySpec mergePolicySpecs(final List<PasswordPolicySpec> userP\n \n     private void evaluateFinalPolicySpec(final PasswordPolicySpec policySpec)\n             throws IncompatiblePolicyException {\n-        \n+\n         if (policySpec.getMinLength() == 0) {\n             LOG.error(\"Minimum lenght given is zero\");\n             throw new IncompatiblePolicyException(\"Minimum lenght given is zero\");\n@@ -226,111 +227,119 @@ private void evaluateFinalPolicySpec(final PasswordPolicySpec policySpec)\n     }\n \n     private String generatePassword(final PasswordPolicySpec policySpec) {\n-        StringBuilder generatedPassword = new StringBuilder(policySpec.getMinLength());\n-\n-        if (policySpec.isDigitRequired() || policySpec.isAlphanumericRequired()) {\n-            generatedPassword.append(RandomStringUtils.randomAlphanumeric(policySpec.getMinLength()));\n-        }\n-\n-        if (policySpec.isDigitRequired() && !PolicyPattern.DIGIT.matcher(generatedPassword.toString()).matches()) {\n-            int where = randomNumber(policySpec.getMinLength());\n-            generatedPassword.deleteCharAt(where);\n-            generatedPassword.insert(where, RandomStringUtils.randomNumeric(1));\n-        }\n-\n-        if (!policySpec.isAlphanumericRequired() && !policySpec.isDigitRequired()) {\n-            generatedPassword.append(RandomStringUtils.randomAlphabetic(policySpec.getMinLength()));\n-        }\n \n-        if (policySpec.isUppercaseRequired() && !PolicyPattern.ALPHA_UPPERCASE\n-                .matcher(generatedPassword.toString()).matches()) {\n-            int where = randomNumber(policySpec.getMinLength());\n-            generatedPassword.deleteCharAt(where);\n-            generatedPassword.insert(where, RandomStringUtils.randomAlphabetic(1));\n-        }\n+        String[] generatedPassword = new String[policySpec.getMinLength()];\n \n-        if (policySpec.isLowercaseRequired() && !PolicyPattern.ALPHA_LOWERCASE.\n-                matcher(generatedPassword.toString()).matches()) {\n-            int where = randomNumber(policySpec.getMinLength());\n-            generatedPassword.deleteCharAt(where);\n-            generatedPassword.insert(where, RandomStringUtils.randomAlphabetic(1).toLowerCase());\n+        for (int i = 0; i < generatedPassword.length; i++) {\n+            generatedPassword[i] = \"\";\n         }\n \n-        if (policySpec.isNonAlphanumericRequired()) {\n-            int where = randomNumber(policySpec.getMinLength());\n-            generatedPassword.deleteCharAt(where);\n-            generatedPassword.insert(where, SPECIAL_CHAR[randomNumber(SPECIAL_CHAR.length - 1)]);\n-        }\n+        checkStartChar(generatedPassword, policySpec);\n \n         checkEndChar(generatedPassword, policySpec);\n \n-        checkstartChar(generatedPassword, policySpec);\n+        checkRequired(generatedPassword, policySpec);\n \n-        for (Iterator<String> it = policySpec.getPrefixesNotPermitted().iterator(); it.hasNext();) {\n-            String prefix = it.next();\n-            if (generatedPassword.toString().startsWith(prefix)) {\n-                checkstartChar(generatedPassword, policySpec);\n-            }\n+        //filled empty chars\n+        for (int firstEmptyChar = firstEmptyChar(generatedPassword);\n+                firstEmptyChar < generatedPassword.length - 1; firstEmptyChar++) {\n+            generatedPassword[firstEmptyChar] = RandomStringUtils.randomAlphabetic(1);\n         }\n \n-        for (Iterator<String> it = policySpec.getSuffixesNotPermitted().iterator(); it.hasNext();) {\n-            String suffix = it.next();\n-            if (generatedPassword.toString().endsWith(suffix)) {\n-                checkEndChar(generatedPassword, policySpec);\n-            }\n-        }\n-        return generatedPassword.toString();\n+        checkPrefixAndSuffix(generatedPassword, policySpec);\n+\n+        return StringUtils.join(generatedPassword);\n     }\n \n     private int randomNumber(final int range) {\n         int randomNumber = (int) (Math.random() * (range - 1));\n         return randomNumber == 0 ? 1 : randomNumber;\n     }\n \n-    private void checkstartChar(final StringBuilder generatedPassword, final PasswordPolicySpec policySpec) {\n+    private void checkStartChar(final String[] generatedPassword, final PasswordPolicySpec policySpec) {\n         if (policySpec.isMustStartWithAlpha()) {\n-            generatedPassword.deleteCharAt(0);\n-            generatedPassword.insert(0, RandomStringUtils.randomAlphabetic(1));\n+            generatedPassword[0] = RandomStringUtils.randomAlphabetic(1);\n         }\n         if (policySpec.isMustStartWithNonAlpha() || policySpec.isMustStartWithDigit()) {\n-            generatedPassword.deleteCharAt(0);\n-            generatedPassword.insert(0, RandomStringUtils.randomNumeric(1));\n+            generatedPassword[0] = RandomStringUtils.randomNumeric(1);\n         }\n         if (policySpec.isMustntStartWithAlpha()) {\n-            generatedPassword.deleteCharAt(0);\n-            generatedPassword.insert(0, RandomStringUtils.randomNumeric(1));\n+            generatedPassword[0] = RandomStringUtils.randomNumeric(1);\n+\n         }\n         if (policySpec.isMustntStartWithDigit()) {\n-            generatedPassword.deleteCharAt(0);\n-            generatedPassword.insert(0, RandomStringUtils.randomAlphabetic(1));\n+            generatedPassword[0] = RandomStringUtils.randomAlphabetic(1);\n+\n         }\n         if (policySpec.isMustntStartWithNonAlpha()) {\n-            generatedPassword.deleteCharAt(0);\n-            generatedPassword.insert(0, RandomStringUtils.randomAlphanumeric(1));\n+            generatedPassword[0] = RandomStringUtils.randomAlphabetic(1);\n+\n         }\n     }\n \n-    private void checkEndChar(final StringBuilder generatedPassword, final PasswordPolicySpec policySpec) {\n+    private void checkEndChar(final String[] generatedPassword, final PasswordPolicySpec policySpec) {\n         if (policySpec.isMustEndWithAlpha()) {\n-            generatedPassword.deleteCharAt(policySpec.getMinLength() - 1);\n-            generatedPassword.insert(policySpec.getMinLength() - 1, RandomStringUtils.randomAlphabetic(1));\n+            generatedPassword[policySpec.getMinLength() - 1] = RandomStringUtils.randomAlphabetic(1);\n         }\n         if (policySpec.isMustEndWithNonAlpha() || policySpec.isMustEndWithDigit()) {\n-            generatedPassword.deleteCharAt(policySpec.getMinLength() - 1);\n-            generatedPassword.insert(policySpec.getMinLength() - 1, RandomStringUtils.randomNumeric(1));\n+            generatedPassword[policySpec.getMinLength() - 1] = RandomStringUtils.randomNumeric(1);\n         }\n \n         if (policySpec.isMustntEndWithAlpha()) {\n-            generatedPassword.deleteCharAt(policySpec.getMinLength() - 1);\n-            generatedPassword.insert(policySpec.getMinLength() - 1, RandomStringUtils.randomNumeric(1));\n+            generatedPassword[policySpec.getMinLength() - 1] = RandomStringUtils.randomNumeric(1);\n         }\n         if (policySpec.isMustntEndWithDigit()) {\n-            generatedPassword.deleteCharAt(policySpec.getMinLength() - 1);\n-            generatedPassword.insert(policySpec.getMinLength() - 1, RandomStringUtils.randomAlphabetic(1));\n+            generatedPassword[policySpec.getMinLength() - 1] = RandomStringUtils.randomAlphabetic(1);\n         }\n         if (policySpec.isMustntEndWithNonAlpha()) {\n-            generatedPassword.deleteCharAt(policySpec.getMinLength() - 1);\n-            generatedPassword.insert(policySpec.getMinLength() - 1, RandomStringUtils.randomAlphabetic(1));\n+            generatedPassword[policySpec.getMinLength() - 1] = RandomStringUtils.randomAlphabetic(1);\n+\n+        }\n+    }\n+    \n+    private int firstEmptyChar(String[] generatedPStrings) {\n+        int index = 0;\n+        while (!generatedPStrings[index].isEmpty()) {\n+            index++;\n+        }\n+        return index;\n+    }\n+\n+    private void checkRequired(String[] generatedPassword, final PasswordPolicySpec policySpec) {\n+        if (policySpec.isDigitRequired()\n+                && !PolicyPattern.DIGIT.matcher(StringUtils.join(generatedPassword)).matches()) {\n+            generatedPassword[firstEmptyChar(generatedPassword)] = RandomStringUtils.randomNumeric(1);\n+        }\n+\n+        if (policySpec.isUppercaseRequired()\n+                && !PolicyPattern.ALPHA_UPPERCASE.matcher(StringUtils.join(generatedPassword)).matches()) {\n+            generatedPassword[firstEmptyChar(generatedPassword)] = RandomStringUtils.randomAlphabetic(1).toUpperCase();\n+        }\n+\n+        if (policySpec.isLowercaseRequired()\n+                && !PolicyPattern.ALPHA_LOWERCASE.matcher(StringUtils.join(generatedPassword)).matches()) {\n+            generatedPassword[firstEmptyChar(generatedPassword)] = RandomStringUtils.randomAlphabetic(1).toLowerCase();\n+        }\n+\n+        if (policySpec.isNonAlphanumericRequired()\n+                && !PolicyPattern.NON_ALPHANUMERIC.matcher(StringUtils.join(generatedPassword)).matches()) {\n+            generatedPassword[firstEmptyChar(generatedPassword)] = SPECIAL_CHAR[randomNumber(SPECIAL_CHAR.length - 1)];\n+        }\n+    }\n+\n+    private void checkPrefixAndSuffix(String[] generatedPassword, final PasswordPolicySpec policySpec) {\n+        for (Iterator<String> it = policySpec.getPrefixesNotPermitted().iterator(); it.hasNext();) {\n+            String prefix = it.next();\n+            if (StringUtils.join(generatedPassword).startsWith(prefix)) {\n+                checkStartChar(generatedPassword, policySpec);\n+            }\n+        }\n+\n+        for (Iterator<String> it = policySpec.getSuffixesNotPermitted().iterator(); it.hasNext();) {\n+            String suffix = it.next();\n+            if (StringUtils.join(generatedPassword).endsWith(suffix)) {\n+                checkEndChar(generatedPassword, policySpec);\n+            }\n         }\n     }\n }"}]}