{"sha":"fc739b5ae16f10bc9ca952c1b97cd1420fbae5d6","node_id":"MDY6Q29tbWl0NjM2ODc5MDYyOmZjNzM5YjVhZTE2ZjEwYmM5Y2E5NTJjMWI5N2NkMTQyMGZiYWU1ZDY=","commit":{"author":{"name":"Unknown","email":"unknown@apache.org","date":"2011-10-26T15:37:55Z"},"committer":{"name":"Unknown","email":"unknown@apache.org","date":"2011-10-26T15:37:55Z"},"message":"Worklflow definition XML editor in console\n\ngit-svn-id: https://svn.apache.org/repos/asf/incubator/syncope/trunk@1247169 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"3b651b2f9705762dc6adfee4d56b88a5088e343b","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/git/trees/3b651b2f9705762dc6adfee4d56b88a5088e343b"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/git/commits/fc739b5ae16f10bc9ca952c1b97cd1420fbae5d6","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/fc739b5ae16f10bc9ca952c1b97cd1420fbae5d6","html_url":"https://github.com/EnricoDAlessandro97UNI/syncope/commit/fc739b5ae16f10bc9ca952c1b97cd1420fbae5d6","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/fc739b5ae16f10bc9ca952c1b97cd1420fbae5d6/comments","author":null,"committer":null,"parents":[{"sha":"515416a17be573325124b4eb6da6161742102870","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/515416a17be573325124b4eb6da6161742102870","html_url":"https://github.com/EnricoDAlessandro97UNI/syncope/commit/515416a17be573325124b4eb6da6161742102870"}],"stats":{"total":2949,"additions":2918,"deletions":31},"files":[{"sha":"ffa906fb58bdc8a8257de640d2cac3043d55a8cc","filename":"console/src/main/java/org/syncope/console/pages/Configuration.java","status":"modified","additions":61,"deletions":3,"changes":64,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fc739b5ae16f10bc9ca952c1b97cd1420fbae5d6/console%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fconsole%2Fpages%2FConfiguration.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fc739b5ae16f10bc9ca952c1b97cd1420fbae5d6/console%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fconsole%2Fpages%2FConfiguration.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/console%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fconsole%2Fpages%2FConfiguration.java?ref=fc739b5ae16f10bc9ca952c1b97cd1420fbae5d6","patch":"@@ -15,7 +15,6 @@\n package org.syncope.console.pages;\n \n import java.io.Serializable;\n-import java.io.UnsupportedEncodingException;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collections;\n@@ -63,10 +62,16 @@\n import ch.qos.logback.classic.Level;\n import ch.qos.logback.classic.Logger;\n import ch.qos.logback.classic.LoggerContext;\n+import org.apache.wicket.extensions.ajax.markup.html.IndicatingAjaxButton;\n+import org.apache.wicket.markup.html.form.TextArea;\n import org.apache.wicket.markup.html.link.Link;\n+import org.apache.wicket.model.CompoundPropertyModel;\n+import org.apache.wicket.model.Model;\n import org.apache.wicket.request.handler.resource.ResourceStreamRequestHandler;\n import org.apache.wicket.request.resource.ContentDisposition;\n import org.apache.wicket.util.resource.StringResourceStream;\n+import org.syncope.client.to.WorkflowDefinitionTO;\n+import org.syncope.client.validation.SyncopeClientCompositeErrorException;\n \n /**\n  * Configurations WebPage.\n@@ -191,7 +196,7 @@ public void onClick(final AjaxRequestTarget target) {\n                         try {\n                             restClient.deleteConfiguration(configurationTO.\n                                     getKey());\n-                        } catch (UnsupportedEncodingException e) {\n+                        } catch (SyncopeClientCompositeErrorException e) {\n                             LOG.error(\"While deleting a conf key\", e);\n                             error(e.getMessage());\n                             return;\n@@ -242,6 +247,8 @@ public void onClick(final AjaxRequestTarget target) {\n         AjaxLink createConfigurationLink = new AjaxLink(\n                 \"createConfigurationLink\") {\n \n+            private static final long serialVersionUID = -7978723352517770644L;\n+\n             @Override\n             public void onClick(final AjaxRequestTarget target) {\n \n@@ -317,6 +324,58 @@ protected void onUpdate(final AjaxRequestTarget target) {\n \n         add(new PasswordPoliciesPanel(\"passwordPoliciesPanel\"));\n \n+        // Workflow definition stuff\n+        final WorkflowDefinitionTO workflowDef =\n+                restClient.getWorkflowDefinition();\n+\n+        WebMarkupContainer workflowDefContainer =\n+                new WebMarkupContainer(\"workflowDefContainer\");\n+\n+        Form wfForm = new Form(\"workflowDefForm\",\n+                new CompoundPropertyModel(workflowDef));\n+\n+        TextArea<WorkflowDefinitionTO> workflowDefArea =\n+                new TextArea<WorkflowDefinitionTO>(\"workflowDefArea\",\n+                new PropertyModel<WorkflowDefinitionTO>(\n+                workflowDef, \"xmlDefinition\"));\n+        wfForm.add(workflowDefArea);\n+\n+        IndicatingAjaxButton submit = new IndicatingAjaxButton(\n+                \"apply\", new Model<String>(getString(\"submit\"))) {\n+\n+            private static final long serialVersionUID = -958724007591692537L;\n+\n+            @Override\n+            protected void onSubmit(final AjaxRequestTarget target,\n+                    final Form form) {\n+\n+                try {\n+                    restClient.updateWorkflowDefinition(workflowDef);\n+                } catch (SyncopeClientCompositeErrorException scee) {\n+                    error(getString(\"error\") + \":\" + scee.getMessage());\n+                }\n+            }\n+\n+            @Override\n+            protected void onError(final AjaxRequestTarget target,\n+                    final Form form) {\n+\n+                target.add(feedbackPanel);\n+            }\n+        };\n+\n+        MetaDataRoleAuthorizationStrategy.authorize(\n+                submit, ENABLE, xmlRolesReader.getAllAllowedRoles(\n+                \"Configuration\", \"workflowDefUpdate\"));\n+        wfForm.add(submit);\n+\n+        workflowDefContainer.add(wfForm);\n+\n+        MetaDataRoleAuthorizationStrategy.authorize(\n+                workflowDefContainer, ENABLE, xmlRolesReader.getAllAllowedRoles(\n+                \"Configuration\", \"workflowDefRead\"));\n+        add(workflowDefContainer);\n+\n         // Logger stuff\n         PropertyListView coreLoggerList =\n                 new LoggerPropertyList(null,\n@@ -328,7 +387,6 @@ protected void onUpdate(final AjaxRequestTarget target) {\n         coreLoggerContainer.setOutputMarkupId(true);\n         add(coreLoggerContainer);\n \n-\n         ConsoleLoggerController consoleLoggerController =\n                 new ConsoleLoggerController();\n         PropertyListView consoleLoggerList ="},{"sha":"873d86afc0dfc30c8ff3bda5909b97c10cc65317","filename":"console/src/main/java/org/syncope/console/rest/ConfigurationRestClient.java","status":"modified","additions":18,"deletions":4,"changes":22,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fc739b5ae16f10bc9ca952c1b97cd1420fbae5d6/console%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fconsole%2Frest%2FConfigurationRestClient.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fc739b5ae16f10bc9ca952c1b97cd1420fbae5d6/console%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fconsole%2Frest%2FConfigurationRestClient.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/console%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fconsole%2Frest%2FConfigurationRestClient.java?ref=fc739b5ae16f10bc9ca952c1b97cd1420fbae5d6","patch":"@@ -18,9 +18,9 @@\n import java.util.Arrays;\n import java.util.List;\n import org.springframework.stereotype.Component;\n-import org.springframework.web.client.HttpStatusCodeException;\n import org.syncope.client.to.ConfigurationTO;\n import org.syncope.client.to.LoggerTO;\n+import org.syncope.client.to.WorkflowDefinitionTO;\n import org.syncope.client.validation.SyncopeClientCompositeErrorException;\n \n /**\n@@ -104,18 +104,32 @@ public boolean updateConfiguration(ConfigurationTO configurationTO) {\n     }\n \n     /**\n-     * Deelete a configuration by key\n+     * Deelete a configuration by key.\n      * @throws UnsupportedEncodingException\n      */\n     public void deleteConfiguration(String key)\n-            throws\n-            UnsupportedEncodingException, HttpStatusCodeException {\n+            throws SyncopeClientCompositeErrorException {\n \n         restTemplate.delete(baseURL\n                 + \"configuration/delete/{key}.json\",\n                 key);\n     }\n \n+    public WorkflowDefinitionTO getWorkflowDefinition()\n+            throws SyncopeClientCompositeErrorException {\n+\n+        return restTemplate.getForObject(baseURL\n+                + \"configuration/workflow/definition.json\",\n+                WorkflowDefinitionTO.class);\n+    }\n+\n+    public void updateWorkflowDefinition(final WorkflowDefinitionTO workflowDef)\n+            throws SyncopeClientCompositeErrorException {\n+\n+        restTemplate.put(baseURL\n+                + \"configuration/workflow/definition.json\", workflowDef);\n+    }\n+\n     /**\n      * Get all loggers.\n      * @return LoggerTOs"},{"sha":"ee904899ff0e6262cd7f84fbf0016fa9814658de","filename":"console/src/main/resources/authorizations.xml","status":"modified","additions":8,"deletions":0,"changes":8,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fc739b5ae16f10bc9ca952c1b97cd1420fbae5d6/console%2Fsrc%2Fmain%2Fresources%2Fauthorizations.xml","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fc739b5ae16f10bc9ca952c1b97cd1420fbae5d6/console%2Fsrc%2Fmain%2Fresources%2Fauthorizations.xml","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/console%2Fsrc%2Fmain%2Fresources%2Fauthorizations.xml?ref=fc739b5ae16f10bc9ca952c1b97cd1420fbae5d6","patch":"@@ -162,6 +162,14 @@ page@id= Schema|Users|Roles|Resources|Connectors|Report|Configuration|Task\n         <action id=\"delete\">\n             <entitlement>CONFIGURATION_DELETE</entitlement>\n         </action>\n+\n+        <action id=\"workflowDefRead\">\n+            <entitlement>WORKFLOW_DEF_READ</entitlement>\n+        </action>\n+        \n+        <action id=\"workflowDefUpdate\">\n+            <entitlement>WORKFLOW_DEF_UPDATE</entitlement>\n+        </action>\n     </page>\n \n     <page id=\"Tasks\">"},{"sha":"26226f0eadb355e6aae22a0fe87a06534f401d22","filename":"console/src/main/resources/org/syncope/console/pages/Configuration.html","status":"modified","additions":36,"deletions":2,"changes":38,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fc739b5ae16f10bc9ca952c1b97cd1420fbae5d6/console%2Fsrc%2Fmain%2Fresources%2Forg%2Fsyncope%2Fconsole%2Fpages%2FConfiguration.html","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fc739b5ae16f10bc9ca952c1b97cd1420fbae5d6/console%2Fsrc%2Fmain%2Fresources%2Forg%2Fsyncope%2Fconsole%2Fpages%2FConfiguration.html","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/console%2Fsrc%2Fmain%2Fresources%2Forg%2Fsyncope%2Fconsole%2Fpages%2FConfiguration.html?ref=fc739b5ae16f10bc9ca952c1b97cd1420fbae5d6","patch":"@@ -12,6 +12,19 @@\n  limitations under the License.\n  under the License.\n -->\n+<wicket:head>\n+    <link rel=\"stylesheet\" type=\"text/css\" href=\"css/codemirror.css\" />\n+    <link rel=\"stylesheet\" type=\"text/css\" href=\"css/codemirror_default_theme.css\" />\n+\n+    <script type=\"text/javascript\" src=\"scripts/codemirror.js\"></script>\n+    <script type=\"text/javascript\" src=\"scripts/xmlpure.js\"></script>\n+    <script type=\"text/javascript\">\n+        function updateTextArea(editor) {\n+            document.getElementById(\"workflowDefArea\").value = editor.getValue();\n+        }\n+    </script>\n+</wicket:head>\n+\n <wicket:extend>\n \n     <div id=\"tabs\">\n@@ -22,6 +35,7 @@\n             <li><a href=\"#tabs-2\"><span><wicket:message key=\"tab2\"/></span></a></li>\n             <li><a href=\"#tabs-3\"><span><wicket:message key=\"tab3\"/></span></a></li>\n             <li><a href=\"#tabs-4\"><span><wicket:message key=\"tab4\"/></span></a></li>\n+            <li><a href=\"#tabs-5\"><span><wicket:message key=\"tab5\"/></span></a></li>\n         </ul>\n         <div id=\"tabs-1\">\n \n@@ -49,10 +63,30 @@\n             </a>\n         </div>\n         <div id=\"tabs-2\">\n-            <span wicket:id=\"passwordPoliciesPanel\">[synchronization tasks]</span>\n+            <span wicket:id=\"passwordPoliciesPanel\">[passwordPolicies]</span>\n         </div>\n         <div id=\"tabs-3\">\n \n+            <div id=\"users-contain\" class=\"ui-widget\" style=\"width:inherit\">\n+                <span wicket:id=\"workflowDefContainer\">\n+                    <form wicket:id=\"workflowDefForm\">\n+                        <textarea wicket:id=\"workflowDefArea\" id=\"workflowDefArea\" style=\"width:100%;height:350px;\">\n+                        </textarea>\n+                        <div style=\"margin: 10px 0px 0\">\n+                            <input type=\"submit\"\n+                                   class=\"ui-button ui-widget ui-state-default ui-corner-all ui-button-text-only\"\n+                                   wicket:id=\"apply\"/>\n+                        </div>\n+                    </form>\n+                    <script>\n+                        var editor = CodeMirror.fromTextArea(document.getElementById(\"workflowDefArea\"), \n+                        {mode: {name: \"xmlpure\"}, lineNumbers: true, onChange: updateTextArea});\n+                    </script>\n+                </span>\n+            </div>\n+        </div>\n+        <div id=\"tabs-4\">\n+\n             <div id=\"users-contain\" class=\"ui-widget\" style=\"width:inherit\">\n                 <span wicket:id=\"coreLoggerContainer\">\n                     <table class=\"ui-widget ui-widget-content table-hover\">\n@@ -72,7 +106,7 @@\n                 </span>\n             </div>\n         </div>\n-        <div id=\"tabs-4\">\n+        <div id=\"tabs-5\">\n \n             <div id=\"users-contain\" class=\"ui-widget\" style=\"width:inherit\">\n                 <span wicket:id=\"consoleLoggerContainer\">"},{"sha":"5450e773dd753dae2e9de36ca48d1191574cb57a","filename":"console/src/main/resources/org/syncope/console/pages/Configuration.properties","status":"modified","additions":4,"deletions":2,"changes":6,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fc739b5ae16f10bc9ca952c1b97cd1420fbae5d6/console%2Fsrc%2Fmain%2Fresources%2Forg%2Fsyncope%2Fconsole%2Fpages%2FConfiguration.properties","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fc739b5ae16f10bc9ca952c1b97cd1420fbae5d6/console%2Fsrc%2Fmain%2Fresources%2Forg%2Fsyncope%2Fconsole%2Fpages%2FConfiguration.properties","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/console%2Fsrc%2Fmain%2Fresources%2Forg%2Fsyncope%2Fconsole%2Fpages%2FConfiguration.properties?ref=fc739b5ae16f10bc9ca952c1b97cd1420fbae5d6","patch":"@@ -2,11 +2,13 @@ key=Key\n value=Value\n tab1=Parameters\n tab2=Password Policy\n-tab3=Core Log\n-tab4=Console Log\n+tab3=Workflow\n+tab4=Core Log\n edit=Edit\n delete=Delete\n create_configuration=Create new configuration\n db_export=DB export\n logger=Logger\n level=Level\n+tab5=Console Log\n+submit=Save"},{"sha":"69302b872f7ccdf99fd4b04e3fe74b30f47f6b31","filename":"console/src/main/resources/org/syncope/console/pages/Configuration_it.properties","status":"modified","additions":4,"deletions":2,"changes":6,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fc739b5ae16f10bc9ca952c1b97cd1420fbae5d6/console%2Fsrc%2Fmain%2Fresources%2Forg%2Fsyncope%2Fconsole%2Fpages%2FConfiguration_it.properties","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fc739b5ae16f10bc9ca952c1b97cd1420fbae5d6/console%2Fsrc%2Fmain%2Fresources%2Forg%2Fsyncope%2Fconsole%2Fpages%2FConfiguration_it.properties","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/console%2Fsrc%2Fmain%2Fresources%2Forg%2Fsyncope%2Fconsole%2Fpages%2FConfiguration_it.properties?ref=fc739b5ae16f10bc9ca952c1b97cd1420fbae5d6","patch":"@@ -2,11 +2,13 @@ key=Chiave\n value=Valore\n tab1=Parametri\n tab2=Password Policy\n-tab3=Log Core\n-tab4=Log Console\n+tab3=Workflow\n+tab4=Log Core\n edit=Modifica\n delete=Elimina\n create_configuration=Crea nuova configurazione\n db_export=Esportazione DB\n logger=Logger\n level=Livello\n+tab5=Log Console\n+submit=Salva"},{"sha":"aea15743c57aa9d836394372c6923158de7a7c33","filename":"console/src/main/webapp/css/codemirror.css","status":"added","additions":68,"deletions":0,"changes":68,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fc739b5ae16f10bc9ca952c1b97cd1420fbae5d6/console%2Fsrc%2Fmain%2Fwebapp%2Fcss%2Fcodemirror.css","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fc739b5ae16f10bc9ca952c1b97cd1420fbae5d6/console%2Fsrc%2Fmain%2Fwebapp%2Fcss%2Fcodemirror.css","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/console%2Fsrc%2Fmain%2Fwebapp%2Fcss%2Fcodemirror.css?ref=fc739b5ae16f10bc9ca952c1b97cd1420fbae5d6","patch":"@@ -0,0 +1,68 @@\n+.CodeMirror {\n+  line-height: 1em;\n+  font-family: monospace;\n+}\n+\n+.CodeMirror-scroll {\n+  overflow: auto;\n+  height: 300px;\n+  /* This is needed to prevent an IE[67] bug where the scrolled content\n+     is visible outside of the scrolling box. */\n+  position: relative;\n+}\n+\n+.CodeMirror-gutter {\n+  position: absolute; left: 0; top: 0;\n+  z-index: 10;\n+  background-color: #f7f7f7;\n+  border-right: 1px solid #eee;\n+  min-width: 2em;\n+  height: 100%;\n+}\n+.CodeMirror-gutter-text {\n+  color: #aaa;\n+  text-align: right;\n+  padding: .4em .2em .4em .4em;\n+}\n+.CodeMirror-lines {\n+  padding: .4em;\n+}\n+\n+.CodeMirror pre {\n+  -moz-border-radius: 0;\n+  -webkit-border-radius: 0;\n+  -o-border-radius: 0;\n+  border-radius: 0;\n+  border-width: 0; margin: 0; padding: 0; background: transparent;\n+  font-family: inherit;\n+  font-size: inherit;\n+  padding: 0; margin: 0;\n+  white-space: pre;\n+  word-wrap: normal;\n+}\n+\n+.CodeMirror textarea {\n+  font-family: inherit !important;\n+  font-size: inherit !important;\n+}\n+\n+.CodeMirror-cursor {\n+  z-index: 10;\n+  position: absolute;\n+  visibility: hidden;\n+  border-left: 1px solid black !important;\n+}\n+.CodeMirror-focused .CodeMirror-cursor {\n+  visibility: visible;\n+}\n+\n+span.CodeMirror-selected {\n+  background: #ccc !important;\n+  color: HighlightText !important;\n+}\n+.CodeMirror-focused span.CodeMirror-selected {\n+  background: Highlight !important;\n+}\n+\n+.CodeMirror-matchingbracket {color: #0f0 !important;}\n+.CodeMirror-nonmatchingbracket {color: #f22 !important;}"},{"sha":"e68f0fb378c2c942f3cbfe30915a52378624d587","filename":"console/src/main/webapp/css/codemirror_default_theme.css","status":"added","additions":19,"deletions":0,"changes":19,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fc739b5ae16f10bc9ca952c1b97cd1420fbae5d6/console%2Fsrc%2Fmain%2Fwebapp%2Fcss%2Fcodemirror_default_theme.css","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fc739b5ae16f10bc9ca952c1b97cd1420fbae5d6/console%2Fsrc%2Fmain%2Fwebapp%2Fcss%2Fcodemirror_default_theme.css","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/console%2Fsrc%2Fmain%2Fwebapp%2Fcss%2Fcodemirror_default_theme.css?ref=fc739b5ae16f10bc9ca952c1b97cd1420fbae5d6","patch":"@@ -0,0 +1,19 @@\n+.cm-s-default span.cm-keyword {color: #708;}\n+.cm-s-default span.cm-atom {color: #219;}\n+.cm-s-default span.cm-number {color: #164;}\n+.cm-s-default span.cm-def {color: #00f;}\n+.cm-s-default span.cm-variable {color: black;}\n+.cm-s-default span.cm-variable-2 {color: #05a;}\n+.cm-s-default span.cm-variable-3 {color: #0a5;}\n+.cm-s-default span.cm-property {color: black;}\n+.cm-s-default span.cm-operator {color: black;}\n+.cm-s-default span.cm-comment {color: #a50;}\n+.cm-s-default span.cm-string {color: #a11;}\n+.cm-s-default span.cm-string-2 {color: #f50;}\n+.cm-s-default span.cm-meta {color: #555;}\n+.cm-s-default span.cm-error {color: #f00;}\n+.cm-s-default span.cm-qualifier {color: #555;}\n+.cm-s-default span.cm-builtin {color: #30a;}\n+.cm-s-default span.cm-bracket {color: #cc7;}\n+.cm-s-default span.cm-tag {color: #170;}\n+.cm-s-default span.cm-attribute {color: #00c;}"},{"sha":"b92493bae10e9fb844f71f714951c64bdc71fad4","filename":"console/src/main/webapp/css/stile_sy.css","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fc739b5ae16f10bc9ca952c1b97cd1420fbae5d6/console%2Fsrc%2Fmain%2Fwebapp%2Fcss%2Fstile_sy.css","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fc739b5ae16f10bc9ca952c1b97cd1420fbae5d6/console%2Fsrc%2Fmain%2Fwebapp%2Fcss%2Fstile_sy.css","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/console%2Fsrc%2Fmain%2Fwebapp%2Fcss%2Fstile_sy.css?ref=fc739b5ae16f10bc9ca952c1b97cd1420fbae5d6","patch":"@@ -213,7 +213,7 @@ div#dialog-form span.radio label, div#dialog-form span.radio input { margin-top:\n div#dialog-form input.text { margin-bottom:12px; width: 95%; padding: .4em; }\n div#dialog-form select.text { margin-bottom:12px; width: auto; padding: .4em; }\n div#dialog-form fieldset { padding:0; border:0; margin-top:25px; }\n-div#users-contain { width: 570px; margin: 20px 0; }/*width: 350px*/\n+div#users-contain { width: 570px; margin: 0px; }/*width: 350px*/\n div#users-contain table { margin: 1em 0; border-collapse: collapse; width: 100%; }\n div#users-contain table td, div#users-contain table th { border: 1px solid #eee; padding: .6em 10px; text-align: left; }\n .ui-dialog .ui-state-error { padding: .3em; }"},{"sha":"e5ae81e469a9ea30ea8afc677d83a70695f6d9ee","filename":"console/src/main/webapp/scripts/codemirror.js","status":"added","additions":2197,"deletions":0,"changes":2197,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fc739b5ae16f10bc9ca952c1b97cd1420fbae5d6/console%2Fsrc%2Fmain%2Fwebapp%2Fscripts%2Fcodemirror.js","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fc739b5ae16f10bc9ca952c1b97cd1420fbae5d6/console%2Fsrc%2Fmain%2Fwebapp%2Fscripts%2Fcodemirror.js","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/console%2Fsrc%2Fmain%2Fwebapp%2Fscripts%2Fcodemirror.js?ref=fc739b5ae16f10bc9ca952c1b97cd1420fbae5d6","patch":"@@ -0,0 +1,2197 @@\n+// All functions that need access to the editor's state live inside\n+// the CodeMirror function. Below that, at the bottom of the file,\n+// some utilities are defined.\n+\n+// CodeMirror is the only global var we claim\n+var CodeMirror = (function() {\n+  // This is the function that produces an editor instance. It's\n+  // closure is used to store the editor state.\n+  function CodeMirror(place, givenOptions) {\n+    // Determine effective options based on given values and defaults.\n+    var options = {}, defaults = CodeMirror.defaults;\n+    for (var opt in defaults)\n+      if (defaults.hasOwnProperty(opt))\n+        options[opt] = (givenOptions && givenOptions.hasOwnProperty(opt) ? givenOptions : defaults)[opt];\n+\n+    var targetDocument = options[\"document\"];\n+    // The element in which the editor lives.\n+    var wrapper = targetDocument.createElement(\"div\");\n+    wrapper.className = \"CodeMirror\";\n+    // This mess creates the base DOM structure for the editor.\n+    wrapper.innerHTML =\n+      '<div style=\"overflow: hidden; position: relative; width: 1px; height: 0px;\">' + // Wraps and hides input textarea\n+        '<textarea style=\"position: absolute; width: 2px;\" wrap=\"off\" ' +\n+          'autocorrect=\"off\" autocapitalize=\"off\"></textarea></div>' +\n+      '<div class=\"CodeMirror-scroll cm-s-' + options.theme + '\">' +\n+        '<div style=\"position: relative\">' + // Set to the height of the text, causes scrolling\n+          '<div style=\"position: absolute; height: 0; width: 0; overflow: hidden;\"></div>' +\n+          '<div style=\"position: relative\">' + // Moved around its parent to cover visible view\n+            '<div class=\"CodeMirror-gutter\"><div class=\"CodeMirror-gutter-text\"></div></div>' +\n+            // Provides positioning relative to (visible) text origin\n+            '<div class=\"CodeMirror-lines\"><div style=\"position: relative\" draggable=\"true\">' +\n+              '<pre class=\"CodeMirror-cursor\">&#160;</pre>' + // Absolutely positioned blinky cursor\n+              '<div></div>' + // This DIV contains the actual code\n+            '</div></div></div></div></div>';\n+    if (place.appendChild) place.appendChild(wrapper); else place(wrapper);\n+    // I've never seen more elegant code in my life.\n+    var inputDiv = wrapper.firstChild, input = inputDiv.firstChild,\n+        scroller = wrapper.lastChild, code = scroller.firstChild,\n+        measure = code.firstChild, mover = measure.nextSibling,\n+        gutter = mover.firstChild, gutterText = gutter.firstChild,\n+        lineSpace = gutter.nextSibling.firstChild,\n+        cursor = lineSpace.firstChild, lineDiv = cursor.nextSibling;\n+    if (options.tabindex != null) input.tabindex = options.tabindex;\n+    if (!options.gutter && !options.lineNumbers) gutter.style.display = \"none\";\n+\n+    // Delayed object wrap timeouts, making sure only one is active. blinker holds an interval.\n+    var poll = new Delayed(), highlight = new Delayed(), blinker;\n+\n+    // mode holds a mode API object. lines an array of Line objects\n+    // (see Line constructor), work an array of lines that should be\n+    // parsed, and history the undo history (instance of History\n+    // constructor).\n+    var mode, lines = [new Line(\"\")], work, history = new History(), focused;\n+    loadMode();\n+    // The selection. These are always maintained to point at valid\n+    // positions. Inverted is used to remember that the user is\n+    // selecting bottom-to-top.\n+    var sel = {from: {line: 0, ch: 0}, to: {line: 0, ch: 0}, inverted: false};\n+    // Selection-related flags. shiftSelecting obviously tracks\n+    // whether the user is holding shift. reducedSelection is a hack\n+    // to get around the fact that we can't create inverted\n+    // selections. See below.\n+    var shiftSelecting, reducedSelection, lastClick, lastDoubleClick;\n+    // Variables used by startOperation/endOperation to track what\n+    // happened during the operation.\n+    var updateInput, changes, textChanged, selectionChanged, leaveInputAlone, gutterDirty;\n+    // Current visible range (may be bigger than the view window).\n+    var showingFrom = 0, showingTo = 0, lastHeight = 0, curKeyId = null;\n+    // editing will hold an object describing the things we put in the\n+    // textarea, to help figure out whether something changed.\n+    // bracketHighlighted is used to remember that a backet has been\n+    // marked.\n+    var editing, bracketHighlighted;\n+    // Tracks the maximum line length so that the horizontal scrollbar\n+    // can be kept static when scrolling.\n+    var maxLine = \"\", maxWidth;\n+\n+    // Initialize the content.\n+    operation(function(){setValue(options.value || \"\"); updateInput = false;})();\n+\n+    // Register our event handlers.\n+    connect(scroller, \"mousedown\", operation(onMouseDown));\n+    connect(lineSpace, \"dragstart\", onDragStart);\n+    // Gecko browsers fire contextmenu *after* opening the menu, at\n+    // which point we can't mess with it anymore. Context menu is\n+    // handled in onMouseDown for Gecko.\n+    if (!gecko) connect(scroller, \"contextmenu\", onContextMenu);\n+    connect(scroller, \"scroll\", function() {\n+      updateDisplay([]);\n+      if (options.fixedGutter) gutter.style.left = scroller.scrollLeft + \"px\";\n+      if (options.onScroll) options.onScroll(instance);\n+    });\n+    connect(window, \"resize\", function() {updateDisplay(true);});\n+    connect(input, \"keyup\", operation(onKeyUp));\n+    connect(input, \"keydown\", operation(onKeyDown));\n+    connect(input, \"keypress\", operation(onKeyPress));\n+    connect(input, \"focus\", onFocus);\n+    connect(input, \"blur\", onBlur);\n+\n+    connect(scroller, \"dragenter\", e_stop);\n+    connect(scroller, \"dragover\", e_stop);\n+    connect(scroller, \"drop\", operation(onDrop));\n+    connect(scroller, \"paste\", function(){focusInput(); fastPoll();});\n+    connect(input, \"paste\", function(){fastPoll();});\n+    connect(input, \"cut\", function(){fastPoll();});\n+    \n+    // IE throws unspecified error in certain cases, when \n+    // trying to access activeElement before onload\n+    var hasFocus; try { hasFocus = (targetDocument.activeElement == input); } catch(e) { }\n+    if (hasFocus) setTimeout(onFocus, 20);\n+    else onBlur();\n+\n+    function isLine(l) {return l >= 0 && l < lines.length;}\n+    // The instance object that we'll return. Mostly calls out to\n+    // local functions in the CodeMirror function. Some do some extra\n+    // range checking and/or clipping. operation is used to wrap the\n+    // call so that changes it makes are tracked, and the display is\n+    // updated afterwards.\n+    var instance = wrapper.CodeMirror = {\n+      getValue: getValue,\n+      setValue: operation(setValue),\n+      getSelection: getSelection,\n+      replaceSelection: operation(replaceSelection),\n+      focus: function(){focusInput(); onFocus(); fastPoll();},\n+      setOption: function(option, value) {\n+        options[option] = value;\n+        if (option == \"lineNumbers\" || option == \"gutter\" || option == \"firstLineNumber\")\n+          operation(gutterChanged)();\n+        else if (option == \"mode\" || option == \"indentUnit\") loadMode();\n+        else if (option == \"readOnly\" && value == \"nocursor\") input.blur();\n+        else if (option == \"theme\") scroller.className = scroller.className.replace(/cm-s-\\w+/, \"cm-s-\" + value);\n+      },\n+      getOption: function(option) {return options[option];},\n+      undo: operation(undo),\n+      redo: operation(redo),\n+      indentLine: operation(function(n, dir) {\n+        if (isLine(n)) indentLine(n, dir == null ? \"smart\" : dir ? \"add\" : \"subtract\");\n+      }),\n+      historySize: function() {return {undo: history.done.length, redo: history.undone.length};},\n+      matchBrackets: operation(function(){matchBrackets(true);}),\n+      getTokenAt: function(pos) {\n+        pos = clipPos(pos);\n+        return lines[pos.line].getTokenAt(mode, getStateBefore(pos.line), pos.ch);\n+      },\n+      getStateAfter: function(line) {\n+        line = clipLine(line == null ? lines.length - 1: line);\n+        return getStateBefore(line + 1);\n+      },\n+      cursorCoords: function(start){\n+        if (start == null) start = sel.inverted;\n+        return pageCoords(start ? sel.from : sel.to);\n+      },\n+      charCoords: function(pos){return pageCoords(clipPos(pos));},\n+      coordsChar: function(coords) {\n+        var off = eltOffset(lineSpace);\n+        var line = clipLine(Math.min(lines.length - 1, showingFrom + Math.floor((coords.y - off.top) / lineHeight())));\n+        return clipPos({line: line, ch: charFromX(clipLine(line), coords.x - off.left)});\n+      },\n+      getSearchCursor: function(query, pos, caseFold) {return new SearchCursor(query, pos, caseFold);},\n+      markText: operation(function(a, b, c){return operation(markText(a, b, c));}),\n+      setMarker: operation(addGutterMarker),\n+      clearMarker: operation(removeGutterMarker),\n+      setLineClass: operation(setLineClass),\n+      lineInfo: lineInfo,\n+      addWidget: function(pos, node, scroll, vert, horiz) {\n+        pos = localCoords(clipPos(pos));\n+        var top = pos.yBot, left = pos.x;\n+        node.style.position = \"absolute\";\n+        code.appendChild(node);\n+        if (vert == \"over\") top = pos.y;\n+        else if (vert == \"near\") {\n+          var vspace = Math.max(scroller.offsetHeight, lines.length * lineHeight()),\n+              hspace = Math.max(code.clientWidth, lineSpace.clientWidth) - paddingLeft();\n+          if (pos.yBot + node.offsetHeight > vspace && pos.y > node.offsetHeight)\n+            top = pos.y - node.offsetHeight;\n+          if (left + node.offsetWidth > hspace)\n+            left = hspace - node.offsetWidth;\n+        }\n+        node.style.top = (top + paddingTop()) + \"px\";\n+        node.style.left = node.style.right = \"\";\n+        if (horiz == \"right\") {\n+          left = code.clientWidth - node.offsetWidth;\n+          node.style.right = \"0px\";\n+        } else {\n+          if (horiz == \"left\") left = 0;\n+          else if (horiz == \"middle\") left = (code.clientWidth - node.offsetWidth) / 2;\n+          node.style.left = (left + paddingLeft()) + \"px\";\n+        }\n+        if (scroll)\n+          scrollIntoView(left, top, left + node.offsetWidth, top + node.offsetHeight);\n+      },\n+\n+      lineCount: function() {return lines.length;},\n+      getCursor: function(start) {\n+        if (start == null) start = sel.inverted;\n+        return copyPos(start ? sel.from : sel.to);\n+      },\n+      somethingSelected: function() {return !posEq(sel.from, sel.to);},\n+      setCursor: operation(function(line, ch) {\n+        if (ch == null && typeof line.line == \"number\") setCursor(line.line, line.ch);\n+        else setCursor(line, ch);\n+      }),\n+      setSelection: operation(function(from, to) {setSelection(clipPos(from), clipPos(to || from));}),\n+      getLine: function(line) {if (isLine(line)) return lines[line].text;},\n+      setLine: operation(function(line, text) {\n+        if (isLine(line)) replaceRange(text, {line: line, ch: 0}, {line: line, ch: lines[line].text.length});\n+      }),\n+      removeLine: operation(function(line) {\n+        if (isLine(line)) replaceRange(\"\", {line: line, ch: 0}, clipPos({line: line+1, ch: 0}));\n+      }),\n+      replaceRange: operation(replaceRange),\n+      getRange: function(from, to) {return getRange(clipPos(from), clipPos(to));},\n+\n+      operation: function(f){return operation(f)();},\n+      refresh: function(){updateDisplay(true);},\n+      getInputField: function(){return input;},\n+      getWrapperElement: function(){return wrapper;},\n+      getScrollerElement: function(){return scroller;},\n+      getGutterElement: function(){return gutter;}\n+    };\n+\n+    function setValue(code) {\n+      history = null;\n+      var top = {line: 0, ch: 0};\n+      updateLines(top, {line: lines.length - 1, ch: lines[lines.length-1].text.length},\n+                  splitLines(code), top, top);\n+      history = new History();\n+      updateInput = true;\n+    }\n+    function getValue(code) {\n+      var text = [];\n+      for (var i = 0, l = lines.length; i < l; ++i)\n+        text.push(lines[i].text);\n+      return text.join(\"\\n\");\n+    }\n+\n+    function onMouseDown(e) {\n+      // Check whether this is a click in a widget\n+      for (var n = e_target(e); n != wrapper; n = n.parentNode)\n+        if (n.parentNode == code && n != mover) return;\n+\n+      // First, see if this is a click in the gutter\n+      for (var n = e_target(e); n != wrapper; n = n.parentNode)\n+        if (n.parentNode == gutterText) {\n+          if (options.onGutterClick)\n+            options.onGutterClick(instance, indexOf(gutterText.childNodes, n) + showingFrom, e);\n+          return e_preventDefault(e);\n+        }\n+\n+      var start = posFromMouse(e);\n+      \n+      switch (e_button(e)) {\n+      case 3:\n+        if (gecko && !mac) onContextMenu(e);\n+        return;\n+      case 2:\n+        if (start) setCursor(start.line, start.ch, true);\n+        return;\n+      }\n+      // For button 1, if it was clicked inside the editor\n+      // (posFromMouse returning non-null), we have to adjust the\n+      // selection.\n+      if (!start) {if (e_target(e) == scroller) e_preventDefault(e); return;}\n+\n+      if (!focused) onFocus();\n+      \n+      var now = +new Date;\n+      if (lastDoubleClick > now - 400) {\n+        e_preventDefault(e);\n+        return selectLine(start.line);\n+      } else if (lastClick > now - 400) {\n+        lastDoubleClick = now;\n+        e_preventDefault(e);\n+        return selectWordAt(start);\n+      } else { lastClick = now; }\n+\n+      var last = start, going;\n+      if (dragAndDrop && !posEq(sel.from, sel.to) &&\n+          !posLess(start, sel.from) && !posLess(sel.to, start)) {\n+        // Let the drag handler handle this.\n+        return;\n+      }\n+      e_preventDefault(e);\n+      setCursor(start.line, start.ch, true);\n+\n+      function extend(e) {\n+        var cur = posFromMouse(e, true);\n+        if (cur && !posEq(cur, last)) {\n+          if (!focused) onFocus();\n+          last = cur;\n+          setSelectionUser(start, cur);\n+          updateInput = false;\n+          var visible = visibleLines();\n+          if (cur.line >= visible.to || cur.line < visible.from)\n+            going = setTimeout(operation(function(){extend(e);}), 150);\n+        }\n+      }\n+\n+      var move = connect(targetDocument, \"mousemove\", operation(function(e) {\n+        clearTimeout(going);\n+        e_preventDefault(e);\n+        extend(e);\n+      }), true);\n+      var up = connect(targetDocument, \"mouseup\", operation(function(e) {\n+        clearTimeout(going);\n+        var cur = posFromMouse(e);\n+        if (cur) setSelectionUser(start, cur);\n+        e_preventDefault(e);\n+        focusInput();\n+        updateInput = true;\n+        move(); up();\n+      }), true);\n+    }\n+    function onDrop(e) {\n+      e.preventDefault();\n+      var pos = posFromMouse(e, true), files = e.dataTransfer.files;\n+      if (!pos || options.readOnly) return;\n+      if (files && files.length && window.FileReader && window.File) {\n+        function loadFile(file, i) {\n+          var reader = new FileReader;\n+          reader.onload = function() {\n+            text[i] = reader.result;\n+            if (++read == n) replaceRange(text.join(\"\"), clipPos(pos), clipPos(pos));\n+          };\n+          reader.readAsText(file);\n+        }\n+        var n = files.length, text = Array(n), read = 0;\n+        for (var i = 0; i < n; ++i) loadFile(files[i], i);\n+      }\n+      else {\n+        try {\n+          var text = e.dataTransfer.getData(\"Text\");\n+          if (text) replaceRange(text, pos, pos);\n+        }\n+        catch(e){}\n+      }\n+    }\n+    function onDragStart(e) {\n+      var txt = getSelection();\n+      // This will reset escapeElement\n+      htmlEscape(txt);\n+      e.dataTransfer.setDragImage(escapeElement, 0, 0);\n+      e.dataTransfer.setData(\"Text\", txt);\n+    }\n+    function onKeyDown(e) {\n+      if (!focused) onFocus();\n+\n+      var code = e.keyCode;\n+      // IE does strange things with escape.\n+      if (ie && code == 27) { e.returnValue = false; }\n+      // Tries to detect ctrl on non-mac, cmd on mac.\n+      var mod = (mac ? e.metaKey : e.ctrlKey) && !e.altKey, anyMod = e.ctrlKey || e.altKey || e.metaKey;\n+      if (code == 16 || e.shiftKey) shiftSelecting = shiftSelecting || (sel.inverted ? sel.to : sel.from);\n+      else shiftSelecting = null;\n+      // First give onKeyEvent option a chance to handle this.\n+      if (options.onKeyEvent && options.onKeyEvent(instance, addStop(e))) return;\n+\n+      if (code == 33 || code == 34) {scrollPage(code == 34); return e_preventDefault(e);} // page up/down\n+      if (mod && ((code == 36 || code == 35) || // ctrl-home/end\n+                  mac && (code == 38 || code == 40))) { // cmd-up/down\n+        scrollEnd(code == 36 || code == 38); return e_preventDefault(e);\n+      }\n+      if (mod && code == 65) {selectAll(); return e_preventDefault(e);} // ctrl-a\n+      if (!options.readOnly) {\n+        if (!anyMod && code == 13) {return;} // enter\n+        if (!anyMod && code == 9 && handleTab(e.shiftKey)) return e_preventDefault(e); // tab\n+        if (mod && code == 90) {undo(); return e_preventDefault(e);} // ctrl-z\n+        if (mod && ((e.shiftKey && code == 90) || code == 89)) {redo(); return e_preventDefault(e);} // ctrl-shift-z, ctrl-y\n+      }\n+      if (code == 36) { if (options.smartHome) { smartHome(); return e_preventDefault(e); } }\n+\n+      // Key id to use in the movementKeys map. We also pass it to\n+      // fastPoll in order to 'self learn'. We need this because\n+      // reducedSelection, the hack where we collapse the selection to\n+      // its start when it is inverted and a movement key is pressed\n+      // (and later restore it again), shouldn't be used for\n+      // non-movement keys.\n+      curKeyId = (mod ? \"c\" : \"\") + (e.altKey ? \"a\" : \"\") + code;\n+      if (sel.inverted && movementKeys[curKeyId] === true) {\n+        var range = selRange(input);\n+        if (range) {\n+          reducedSelection = {anchor: range.start};\n+          setSelRange(input, range.start, range.start);\n+        }\n+      }\n+      // Don't save the key as a movementkey unless it had a modifier\n+      if (!mod && !e.altKey) curKeyId = null;\n+      fastPoll(curKeyId);\n+    }\n+    function onKeyUp(e) {\n+      if (options.onKeyEvent && options.onKeyEvent(instance, addStop(e))) return;\n+      if (reducedSelection) {\n+        reducedSelection = null;\n+        updateInput = true;\n+      }\n+      if (e.keyCode == 16) shiftSelecting = null;\n+    }\n+    function onKeyPress(e) {\n+      if (options.onKeyEvent && options.onKeyEvent(instance, addStop(e))) return;\n+      if (options.electricChars && mode.electricChars) {\n+        var ch = String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode);\n+        if (mode.electricChars.indexOf(ch) > -1)\n+          setTimeout(operation(function() {indentLine(sel.to.line, \"smart\");}), 50);\n+      }\n+      var code = e.keyCode;\n+      // Re-stop tab and enter. Necessary on some browsers.\n+      if (code == 13) {if (!options.readOnly) handleEnter(); e_preventDefault(e);}\n+      else if (!e.ctrlKey && !e.altKey && !e.metaKey && code == 9 && options.tabMode != \"default\") e_preventDefault(e);\n+      else fastPoll(curKeyId);\n+    }\n+\n+    function onFocus() {\n+      if (options.readOnly == \"nocursor\") return;\n+      if (!focused) {\n+        if (options.onFocus) options.onFocus(instance);\n+        focused = true;\n+        if (wrapper.className.search(/\\bCodeMirror-focused\\b/) == -1)\n+          wrapper.className += \" CodeMirror-focused\";\n+        if (!leaveInputAlone) prepareInput();\n+      }\n+      slowPoll();\n+      restartBlink();\n+    }\n+    function onBlur() {\n+      if (focused) {\n+        if (options.onBlur) options.onBlur(instance);\n+        focused = false;\n+        wrapper.className = wrapper.className.replace(\" CodeMirror-focused\", \"\");\n+      }\n+      clearInterval(blinker);\n+      setTimeout(function() {if (!focused) shiftSelecting = null;}, 150);\n+    }\n+\n+    // Replace the range from from to to by the strings in newText.\n+    // Afterwards, set the selection to selFrom, selTo.\n+    function updateLines(from, to, newText, selFrom, selTo) {\n+      if (history) {\n+        var old = [];\n+        for (var i = from.line, e = to.line + 1; i < e; ++i) old.push(lines[i].text);\n+        history.addChange(from.line, newText.length, old);\n+        while (history.done.length > options.undoDepth) history.done.shift();\n+      }\n+      updateLinesNoUndo(from, to, newText, selFrom, selTo);\n+    }\n+    function unredoHelper(from, to) {\n+      var change = from.pop();\n+      if (change) {\n+        var replaced = [], end = change.start + change.added;\n+        for (var i = change.start; i < end; ++i) replaced.push(lines[i].text);\n+        to.push({start: change.start, added: change.old.length, old: replaced});\n+        var pos = clipPos({line: change.start + change.old.length - 1,\n+                           ch: editEnd(replaced[replaced.length-1], change.old[change.old.length-1])});\n+        updateLinesNoUndo({line: change.start, ch: 0}, {line: end - 1, ch: lines[end-1].text.length}, change.old, pos, pos);\n+        updateInput = true;\n+      }\n+    }\n+    function undo() {unredoHelper(history.done, history.undone);}\n+    function redo() {unredoHelper(history.undone, history.done);}\n+\n+    function updateLinesNoUndo(from, to, newText, selFrom, selTo) {\n+      var recomputeMaxLength = false, maxLineLength = maxLine.length;\n+      for (var i = from.line; i <= to.line; ++i) {\n+        if (lines[i].text.length == maxLineLength) {recomputeMaxLength = true; break;}\n+      }\n+\n+      var nlines = to.line - from.line, firstLine = lines[from.line], lastLine = lines[to.line];\n+      // First adjust the line structure, taking some care to leave highlighting intact.\n+      if (firstLine == lastLine) {\n+        if (newText.length == 1)\n+          firstLine.replace(from.ch, to.ch, newText[0]);\n+        else {\n+          lastLine = firstLine.split(to.ch, newText[newText.length-1]);\n+          var spliceargs = [from.line + 1, nlines];\n+          firstLine.replace(from.ch, firstLine.text.length, newText[0]);\n+          for (var i = 1, e = newText.length - 1; i < e; ++i) spliceargs.push(new Line(newText[i]));\n+          spliceargs.push(lastLine);\n+          lines.splice.apply(lines, spliceargs);\n+        }\n+      }\n+      else if (newText.length == 1) {\n+        firstLine.replace(from.ch, firstLine.text.length, newText[0] + lastLine.text.slice(to.ch));\n+        lines.splice(from.line + 1, nlines);\n+      }\n+      else {\n+        var spliceargs = [from.line + 1, nlines - 1];\n+        firstLine.replace(from.ch, firstLine.text.length, newText[0]);\n+        lastLine.replace(0, to.ch, newText[newText.length-1]);\n+        for (var i = 1, e = newText.length - 1; i < e; ++i) spliceargs.push(new Line(newText[i]));\n+        lines.splice.apply(lines, spliceargs);\n+      }\n+\n+\n+      for (var i = from.line, e = i + newText.length; i < e; ++i) {\n+        var l = lines[i].text;\n+        if (l.length > maxLineLength) {\n+          maxLine = l; maxLineLength = l.length; maxWidth = null;\n+          recomputeMaxLength = false;\n+        }\n+      }\n+      if (recomputeMaxLength) {\n+        maxLineLength = 0; maxLine = \"\"; maxWidth = null;\n+        for (var i = 0, e = lines.length; i < e; ++i) {\n+          var l = lines[i].text;\n+          if (l.length > maxLineLength) {\n+            maxLineLength = l.length; maxLine = l;\n+          }\n+        }\n+      }\n+\n+      // Add these lines to the work array, so that they will be\n+      // highlighted. Adjust work lines if lines were added/removed.\n+      var newWork = [], lendiff = newText.length - nlines - 1;\n+      for (var i = 0, l = work.length; i < l; ++i) {\n+        var task = work[i];\n+        if (task < from.line) newWork.push(task);\n+        else if (task > to.line) newWork.push(task + lendiff);\n+      }\n+      if (newText.length < 5) {\n+        highlightLines(from.line, from.line + newText.length);\n+        newWork.push(from.line + newText.length);\n+      } else {\n+        newWork.push(from.line);\n+      }\n+      work = newWork;\n+      startWorker(100);\n+      // Remember that these lines changed, for updating the display\n+      changes.push({from: from.line, to: to.line + 1, diff: lendiff});\n+      textChanged = {from: from, to: to, text: newText};\n+\n+      // Update the selection\n+      function updateLine(n) {return n <= Math.min(to.line, to.line + lendiff) ? n : n + lendiff;}\n+      setSelection(selFrom, selTo, updateLine(sel.from.line), updateLine(sel.to.line));\n+\n+      // Make sure the scroll-size div has the correct height.\n+      code.style.height = (lines.length * lineHeight() + 2 * paddingTop()) + \"px\";\n+    }\n+\n+    function replaceRange(code, from, to) {\n+      from = clipPos(from);\n+      if (!to) to = from; else to = clipPos(to);\n+      code = splitLines(code);\n+      function adjustPos(pos) {\n+        if (posLess(pos, from)) return pos;\n+        if (!posLess(to, pos)) return end;\n+        var line = pos.line + code.length - (to.line - from.line) - 1;\n+        var ch = pos.ch;\n+        if (pos.line == to.line)\n+          ch += code[code.length-1].length - (to.ch - (to.line == from.line ? from.ch : 0));\n+        return {line: line, ch: ch};\n+      }\n+      var end;\n+      replaceRange1(code, from, to, function(end1) {\n+        end = end1;\n+        return {from: adjustPos(sel.from), to: adjustPos(sel.to)};\n+      });\n+      return end;\n+    }\n+    function replaceSelection(code, collapse) {\n+      replaceRange1(splitLines(code), sel.from, sel.to, function(end) {\n+        if (collapse == \"end\") return {from: end, to: end};\n+        else if (collapse == \"start\") return {from: sel.from, to: sel.from};\n+        else return {from: sel.from, to: end};\n+      });\n+    }\n+    function replaceRange1(code, from, to, computeSel) {\n+      var endch = code.length == 1 ? code[0].length + from.ch : code[code.length-1].length;\n+      var newSel = computeSel({line: from.line + code.length - 1, ch: endch});\n+      updateLines(from, to, code, newSel.from, newSel.to);\n+    }\n+\n+    function getRange(from, to) {\n+      var l1 = from.line, l2 = to.line;\n+      if (l1 == l2) return lines[l1].text.slice(from.ch, to.ch);\n+      var code = [lines[l1].text.slice(from.ch)];\n+      for (var i = l1 + 1; i < l2; ++i) code.push(lines[i].text);\n+      code.push(lines[l2].text.slice(0, to.ch));\n+      return code.join(\"\\n\");\n+    }\n+    function getSelection() {\n+      return getRange(sel.from, sel.to);\n+    }\n+\n+    var pollingFast = false; // Ensures slowPoll doesn't cancel fastPoll\n+    function slowPoll() {\n+      if (pollingFast) return;\n+      poll.set(2000, function() {\n+        startOperation();\n+        readInput();\n+        if (focused) slowPoll();\n+        endOperation();\n+      });\n+    }\n+    function fastPoll(keyId) {\n+      var missed = false;\n+      pollingFast = true;\n+      function p() {\n+        startOperation();\n+        var changed = readInput();\n+        if (changed && keyId) {\n+          if (changed == \"moved\" && movementKeys[keyId] == null) movementKeys[keyId] = true;\n+          if (changed == \"changed\") movementKeys[keyId] = false;\n+        }\n+        if (!changed && !missed) {missed = true; poll.set(80, p);}\n+        else {pollingFast = false; slowPoll();}\n+        endOperation();\n+      }\n+      poll.set(20, p);\n+    }\n+\n+    // Inspects the textarea, compares its state (content, selection)\n+    // to the data in the editing variable, and updates the editor\n+    // content or cursor if something changed.\n+    function readInput() {\n+      if (leaveInputAlone || !focused) return;\n+      var changed = false, text = input.value, sr = selRange(input);\n+      if (!sr) return false;\n+      var changed = editing.text != text, rs = reducedSelection;\n+      var moved = changed || sr.start != editing.start || sr.end != (rs ? editing.start : editing.end);\n+      if (!moved && !rs) return false;\n+      if (changed) {\n+        shiftSelecting = reducedSelection = null;\n+        if (options.readOnly) {updateInput = true; return \"changed\";}\n+      }\n+\n+      // Compute selection start and end based on start/end offsets in textarea\n+      function computeOffset(n, startLine) {\n+        var pos = 0;\n+        for (;;) {\n+          var found = text.indexOf(\"\\n\", pos);\n+          if (found == -1 || (text.charAt(found-1) == \"\\r\" ? found - 1 : found) >= n)\n+            return {line: startLine, ch: n - pos};\n+          ++startLine;\n+          pos = found + 1;\n+        }\n+      }\n+      var from = computeOffset(sr.start, editing.from),\n+          to = computeOffset(sr.end, editing.from);\n+      // Here we have to take the reducedSelection hack into account,\n+      // so that you can, for example, press shift-up at the start of\n+      // your selection and have the right thing happen.\n+      if (rs) {\n+        var head = sr.start == rs.anchor ? to : from;\n+        var tail = shiftSelecting ? sel.to : sr.start == rs.anchor ? from : to;\n+        if (sel.inverted = posLess(head, tail)) { from = head; to = tail; }\n+        else { reducedSelection = null; from = tail; to = head; }\n+      }\n+\n+      // In some cases (cursor on same line as before), we don't have\n+      // to update the textarea content at all.\n+      if (from.line == to.line && from.line == sel.from.line && from.line == sel.to.line && !shiftSelecting)\n+        updateInput = false;\n+\n+      // Magic mess to extract precise edited range from the changed\n+      // string.\n+      if (changed) {\n+        var start = 0, end = text.length, len = Math.min(end, editing.text.length);\n+        var c, line = editing.from, nl = -1;\n+        while (start < len && (c = text.charAt(start)) == editing.text.charAt(start)) {\n+          ++start;\n+          if (c == \"\\n\") {line++; nl = start;}\n+        }\n+        var ch = nl > -1 ? start - nl : start, endline = editing.to - 1, edend = editing.text.length;\n+        for (;;) {\n+          c = editing.text.charAt(edend);\n+          if (text.charAt(end) != c) {++end; ++edend; break;}\n+          if (c == \"\\n\") endline--;\n+          if (edend <= start || end <= start) break;\n+          --end; --edend;\n+        }\n+        var nl = editing.text.lastIndexOf(\"\\n\", edend - 1), endch = nl == -1 ? edend : edend - nl - 1;\n+        updateLines({line: line, ch: ch}, {line: endline, ch: endch}, splitLines(text.slice(start, end)), from, to);\n+        if (line != endline || from.line != line) updateInput = true;\n+      }\n+      else setSelection(from, to);\n+\n+      editing.text = text; editing.start = sr.start; editing.end = sr.end;\n+      return changed ? \"changed\" : moved ? \"moved\" : false;\n+    }\n+\n+    // Set the textarea content and selection range to match the\n+    // editor state.\n+    function prepareInput() {\n+      var text = [];\n+      var from = Math.max(0, sel.from.line - 1), to = Math.min(lines.length, sel.to.line + 2);\n+      for (var i = from; i < to; ++i) text.push(lines[i].text);\n+      text = input.value = text.join(lineSep);\n+      var startch = sel.from.ch, endch = sel.to.ch;\n+      for (var i = from; i < sel.from.line; ++i)\n+        startch += lineSep.length + lines[i].text.length;\n+      for (var i = from; i < sel.to.line; ++i)\n+        endch += lineSep.length + lines[i].text.length;\n+      editing = {text: text, from: from, to: to, start: startch, end: endch};\n+      setSelRange(input, startch, reducedSelection ? startch : endch);\n+    }\n+    function focusInput() {\n+      if (options.readOnly != \"nocursor\") input.focus();\n+    }\n+\n+    function scrollEditorIntoView() {\n+      if (!cursor.getBoundingClientRect) return;\n+      var rect = cursor.getBoundingClientRect();\n+      var winH = window.innerHeight || document.body.offsetHeight || document.documentElement.offsetHeight;\n+      if (rect.top < 0 || rect.bottom > winH) cursor.scrollIntoView();\n+    }\n+    function scrollCursorIntoView() {\n+      var cursor = localCoords(sel.inverted ? sel.from : sel.to);\n+      return scrollIntoView(cursor.x, cursor.y, cursor.x, cursor.yBot);\n+    }\n+    function scrollIntoView(x1, y1, x2, y2) {\n+      var pl = paddingLeft(), pt = paddingTop(), lh = lineHeight();\n+      y1 += pt; y2 += pt; x1 += pl; x2 += pl;\n+      var screen = scroller.clientHeight, screentop = scroller.scrollTop, scrolled = false, result = true;\n+      if (y1 < screentop) {scroller.scrollTop = Math.max(0, y1 - 2*lh); scrolled = true;}\n+      else if (y2 > screentop + screen) {scroller.scrollTop = y2 + lh - screen; scrolled = true;}\n+\n+      var screenw = scroller.clientWidth, screenleft = scroller.scrollLeft;\n+      var gutterw = options.fixedGutter ? gutter.clientWidth : 0;\n+      if (x1 < screenleft + gutterw) {\n+        if (x1 < 50) x1 = 0;\n+        scroller.scrollLeft = Math.max(0, x1 - 10 - gutterw);\n+        scrolled = true;\n+      }\n+      else if (x2 > screenw + screenleft) {\n+        scroller.scrollLeft = x2 + 10 - screenw;\n+        scrolled = true;\n+        if (x2 > code.clientWidth) result = false;\n+      }\n+      if (scrolled && options.onScroll) options.onScroll(instance);\n+      return result;\n+    }\n+\n+    function visibleLines() {\n+      var lh = lineHeight(), top = scroller.scrollTop - paddingTop();\n+      return {from: Math.min(lines.length, Math.max(0, Math.floor(top / lh))),\n+              to: Math.min(lines.length, Math.ceil((top + scroller.clientHeight) / lh))};\n+    }\n+    // Uses a set of changes plus the current scroll position to\n+    // determine which DOM updates have to be made, and makes the\n+    // updates.\n+    function updateDisplay(changes) {\n+      if (!scroller.clientWidth) {\n+        showingFrom = showingTo = 0;\n+        return;\n+      }\n+      // First create a range of theoretically intact lines, and punch\n+      // holes in that using the change info.\n+      var intact = changes === true ? [] : [{from: showingFrom, to: showingTo, domStart: 0}];\n+      for (var i = 0, l = changes.length || 0; i < l; ++i) {\n+        var change = changes[i], intact2 = [], diff = change.diff || 0;\n+        for (var j = 0, l2 = intact.length; j < l2; ++j) {\n+          var range = intact[j];\n+          if (change.to <= range.from)\n+            intact2.push({from: range.from + diff, to: range.to + diff, domStart: range.domStart});\n+          else if (range.to <= change.from)\n+            intact2.push(range);\n+          else {\n+            if (change.from > range.from)\n+              intact2.push({from: range.from, to: change.from, domStart: range.domStart})\n+            if (change.to < range.to)\n+              intact2.push({from: change.to + diff, to: range.to + diff,\n+                            domStart: range.domStart + (change.to - range.from)});\n+          }\n+        }\n+        intact = intact2;\n+      }\n+\n+      // Then, determine which lines we'd want to see, and which\n+      // updates have to be made to get there.\n+      var visible = visibleLines();\n+      var from = Math.min(showingFrom, Math.max(visible.from - 3, 0)),\n+          to = Math.min(lines.length, Math.max(showingTo, visible.to + 3)),\n+          updates = [], domPos = 0, domEnd = showingTo - showingFrom, pos = from, changedLines = 0;\n+\n+      for (var i = 0, l = intact.length; i < l; ++i) {\n+        var range = intact[i];\n+        if (range.to <= from) continue;\n+        if (range.from >= to) break;\n+        if (range.domStart > domPos || range.from > pos) {\n+          updates.push({from: pos, to: range.from, domSize: range.domStart - domPos, domStart: domPos});\n+          changedLines += range.from - pos;\n+        }\n+        pos = range.to;\n+        domPos = range.domStart + (range.to - range.from);\n+      }\n+      if (domPos != domEnd || pos != to) {\n+        changedLines += Math.abs(to - pos);\n+        updates.push({from: pos, to: to, domSize: domEnd - domPos, domStart: domPos});\n+        if (to - pos != domEnd - domPos) gutterDirty = true;\n+      }\n+\n+      if (!updates.length) return;\n+      lineDiv.style.display = \"none\";\n+      // If more than 30% of the screen needs update, just do a full\n+      // redraw (which is quicker than patching)\n+      if (changedLines > (visible.to - visible.from) * .3)\n+        refreshDisplay(from = Math.max(visible.from - 10, 0), to = Math.min(visible.to + 7, lines.length));\n+      // Otherwise, only update the stuff that needs updating.\n+      else\n+        patchDisplay(updates);\n+      lineDiv.style.display = \"\";\n+\n+      // Position the mover div to align with the lines it's supposed\n+      // to be showing (which will cover the visible display)\n+      var different = from != showingFrom || to != showingTo || lastHeight != scroller.clientHeight;\n+      showingFrom = from; showingTo = to;\n+      mover.style.top = (from * lineHeight()) + \"px\";\n+      if (different) {\n+        lastHeight = scroller.clientHeight;\n+        code.style.height = (lines.length * lineHeight() + 2 * paddingTop()) + \"px\";\n+      }\n+      if (different || gutterDirty) updateGutter();\n+\n+      if (maxWidth == null) maxWidth = stringWidth(maxLine);\n+      if (maxWidth > scroller.clientWidth) {\n+        lineSpace.style.width = maxWidth + \"px\";\n+        // Needed to prevent odd wrapping/hiding of widgets placed in here.\n+        code.style.width = \"\";\n+        code.style.width = scroller.scrollWidth + \"px\";\n+      } else {\n+        lineSpace.style.width = code.style.width = \"\";\n+      }\n+\n+      // Since this is all rather error prone, it is honoured with the\n+      // only assertion in the whole file.\n+      if (lineDiv.childNodes.length != showingTo - showingFrom)\n+        throw new Error(\"BAD PATCH! \" + JSON.stringify(updates) + \" size=\" + (showingTo - showingFrom) +\n+                        \" nodes=\" + lineDiv.childNodes.length);\n+      updateCursor();\n+    }\n+\n+    function refreshDisplay(from, to) {\n+      var html = [], start = {line: from, ch: 0}, inSel = posLess(sel.from, start) && !posLess(sel.to, start);\n+      for (var i = from; i < to; ++i) {\n+        var ch1 = null, ch2 = null;\n+        if (inSel) {\n+          ch1 = 0;\n+          if (sel.to.line == i) {inSel = false; ch2 = sel.to.ch;}\n+        }\n+        else if (sel.from.line == i) {\n+          if (sel.to.line == i) {ch1 = sel.from.ch; ch2 = sel.to.ch;}\n+          else {inSel = true; ch1 = sel.from.ch;}\n+        }\n+        html.push(lines[i].getHTML(ch1, ch2, true));\n+      }\n+      lineDiv.innerHTML = html.join(\"\");\n+    }\n+    function patchDisplay(updates) {\n+      // Slightly different algorithm for IE (badInnerHTML), since\n+      // there .innerHTML on PRE nodes is dumb, and discards\n+      // whitespace.\n+      var sfrom = sel.from.line, sto = sel.to.line, off = 0,\n+          scratch = badInnerHTML && targetDocument.createElement(\"div\");\n+      for (var i = 0, e = updates.length; i < e; ++i) {\n+        var rec = updates[i];\n+        var extra = (rec.to - rec.from) - rec.domSize;\n+        var nodeAfter = lineDiv.childNodes[rec.domStart + rec.domSize + off] || null;\n+        if (badInnerHTML)\n+          for (var j = Math.max(-extra, rec.domSize); j > 0; --j)\n+            lineDiv.removeChild(nodeAfter ? nodeAfter.previousSibling : lineDiv.lastChild);\n+        else if (extra) {\n+          for (var j = Math.max(0, extra); j > 0; --j)\n+            lineDiv.insertBefore(targetDocument.createElement(\"pre\"), nodeAfter);\n+          for (var j = Math.max(0, -extra); j > 0; --j)\n+            lineDiv.removeChild(nodeAfter ? nodeAfter.previousSibling : lineDiv.lastChild);\n+        }\n+        var node = lineDiv.childNodes[rec.domStart + off], inSel = sfrom < rec.from && sto >= rec.from;\n+        for (var j = rec.from; j < rec.to; ++j) {\n+          var ch1 = null, ch2 = null;\n+          if (inSel) {\n+            ch1 = 0;\n+            if (sto == j) {inSel = false; ch2 = sel.to.ch;}\n+          }\n+          else if (sfrom == j) {\n+            if (sto == j) {ch1 = sel.from.ch; ch2 = sel.to.ch;}\n+            else {inSel = true; ch1 = sel.from.ch;}\n+          }\n+          if (badInnerHTML) {\n+            scratch.innerHTML = lines[j].getHTML(ch1, ch2, true);\n+            lineDiv.insertBefore(scratch.firstChild, nodeAfter);\n+          }\n+          else {\n+            node.innerHTML = lines[j].getHTML(ch1, ch2, false);\n+            node.className = lines[j].className || \"\";\n+            node = node.nextSibling;\n+          }\n+        }\n+        off += extra;\n+      }\n+    }\n+\n+    function updateGutter() {\n+      if (!options.gutter && !options.lineNumbers) return;\n+      var hText = mover.offsetHeight, hEditor = scroller.clientHeight;\n+      gutter.style.height = (hText - hEditor < 2 ? hEditor : hText) + \"px\";\n+      var html = [];\n+      for (var i = showingFrom; i < Math.max(showingTo, showingFrom + 1); ++i) {\n+        var marker = lines[i].gutterMarker;\n+        var text = options.lineNumbers ? i + options.firstLineNumber : null;\n+        if (marker && marker.text)\n+          text = marker.text.replace(\"%N%\", text != null ? text : \"\");\n+        else if (text == null)\n+          text = \"\\u00a0\";\n+        html.push((marker && marker.style ? '<pre class=\"' + marker.style + '\">' : \"<pre>\"), text, \"</pre>\");\n+      }\n+      gutter.style.display = \"none\";\n+      gutterText.innerHTML = html.join(\"\");\n+      var minwidth = String(lines.length).length, firstNode = gutterText.firstChild, val = eltText(firstNode), pad = \"\";\n+      while (val.length + pad.length < minwidth) pad += \"\\u00a0\";\n+      if (pad) firstNode.insertBefore(targetDocument.createTextNode(pad), firstNode.firstChild);\n+      gutter.style.display = \"\";\n+      lineSpace.style.marginLeft = gutter.offsetWidth + \"px\";\n+      gutterDirty = false;\n+    }\n+    function updateCursor() {\n+      var head = sel.inverted ? sel.from : sel.to, lh = lineHeight();\n+      var x = charX(head.line, head.ch);\n+      var top = head.line * lh - scroller.scrollTop;\n+      inputDiv.style.top = Math.max(Math.min(top, scroller.offsetHeight), 0) + \"px\";\n+      inputDiv.style.left = (x - scroller.scrollLeft) + \"px\";\n+      if (posEq(sel.from, sel.to)) {\n+        cursor.style.top = (head.line - showingFrom) * lh + \"px\";\n+        cursor.style.left = x + \"px\";\n+        cursor.style.display = \"\";\n+      }\n+      else cursor.style.display = \"none\";\n+    }\n+\n+    function setSelectionUser(from, to) {\n+      var sh = shiftSelecting && clipPos(shiftSelecting);\n+      if (sh) {\n+        if (posLess(sh, from)) from = sh;\n+        else if (posLess(to, sh)) to = sh;\n+      }\n+      setSelection(from, to);\n+    }\n+    // Update the selection. Last two args are only used by\n+    // updateLines, since they have to be expressed in the line\n+    // numbers before the update.\n+    function setSelection(from, to, oldFrom, oldTo) {\n+      if (posEq(sel.from, from) && posEq(sel.to, to)) return;\n+      if (posLess(to, from)) {var tmp = to; to = from; from = tmp;}\n+\n+      if (posEq(from, to)) sel.inverted = false;\n+      else if (posEq(from, sel.to)) sel.inverted = false;\n+      else if (posEq(to, sel.from)) sel.inverted = true;\n+\n+      // Some ugly logic used to only mark the lines that actually did\n+      // see a change in selection as changed, rather than the whole\n+      // selected range.\n+      if (oldFrom == null) {oldFrom = sel.from.line; oldTo = sel.to.line;}\n+      if (posEq(from, to)) {\n+        if (!posEq(sel.from, sel.to))\n+          changes.push({from: oldFrom, to: oldTo + 1});\n+      }\n+      else if (posEq(sel.from, sel.to)) {\n+        changes.push({from: from.line, to: to.line + 1});\n+      }\n+      else {\n+        if (!posEq(from, sel.from)) {\n+          if (from.line < oldFrom)\n+            changes.push({from: from.line, to: Math.min(to.line, oldFrom) + 1});\n+          else\n+            changes.push({from: oldFrom, to: Math.min(oldTo, from.line) + 1});\n+        }\n+        if (!posEq(to, sel.to)) {\n+          if (to.line < oldTo)\n+            changes.push({from: Math.max(oldFrom, from.line), to: oldTo + 1});\n+          else\n+            changes.push({from: Math.max(from.line, oldTo), to: to.line + 1});\n+        }\n+      }\n+      sel.from = from; sel.to = to;\n+      selectionChanged = true;\n+    }\n+    function setCursor(line, ch, user) {\n+      var pos = clipPos({line: line, ch: ch || 0});\n+      (user ? setSelectionUser : setSelection)(pos, pos);\n+    }\n+\n+    function clipLine(n) {return Math.max(0, Math.min(n, lines.length-1));}\n+    function clipPos(pos) {\n+      if (pos.line < 0) return {line: 0, ch: 0};\n+      if (pos.line >= lines.length) return {line: lines.length-1, ch: lines[lines.length-1].text.length};\n+      var ch = pos.ch, linelen = lines[pos.line].text.length;\n+      if (ch == null || ch > linelen) return {line: pos.line, ch: linelen};\n+      else if (ch < 0) return {line: pos.line, ch: 0};\n+      else return pos;\n+    }\n+\n+    function scrollPage(down) {\n+      var linesPerPage = Math.floor(scroller.clientHeight / lineHeight()), head = sel.inverted ? sel.from : sel.to;\n+      setCursor(head.line + (Math.max(linesPerPage - 1, 1) * (down ? 1 : -1)), head.ch, true);\n+    }\n+    function scrollEnd(top) {\n+      var pos = top ? {line: 0, ch: 0} : {line: lines.length - 1, ch: lines[lines.length-1].text.length};\n+      setSelectionUser(pos, pos);\n+    }\n+    function selectAll() {\n+      var endLine = lines.length - 1;\n+      setSelection({line: 0, ch: 0}, {line: endLine, ch: lines[endLine].text.length});\n+    }\n+    function selectWordAt(pos) {\n+      var line = lines[pos.line].text;\n+      var start = pos.ch, end = pos.ch;\n+      while (start > 0 && /\\w/.test(line.charAt(start - 1))) --start;\n+      while (end < line.length && /\\w/.test(line.charAt(end))) ++end;\n+      setSelectionUser({line: pos.line, ch: start}, {line: pos.line, ch: end});\n+    }\n+    function selectLine(line) {\n+      setSelectionUser({line: line, ch: 0}, {line: line, ch: lines[line].text.length});\n+    }\n+    function handleEnter() {\n+      replaceSelection(\"\\n\", \"end\");\n+      if (options.enterMode != \"flat\")\n+        indentLine(sel.from.line, options.enterMode == \"keep\" ? \"prev\" : \"smart\");\n+    }\n+    function handleTab(shift) {\n+      function indentSelected(mode) {\n+        if (posEq(sel.from, sel.to)) return indentLine(sel.from.line, mode);\n+        var e = sel.to.line - (sel.to.ch ? 0 : 1);\n+        for (var i = sel.from.line; i <= e; ++i) indentLine(i, mode);\n+      }\n+      shiftSelecting = null;\n+      switch (options.tabMode) {\n+      case \"default\":\n+        return false;\n+      case \"indent\":\n+        indentSelected(\"smart\");\n+        break;\n+      case \"classic\":\n+        if (posEq(sel.from, sel.to)) {\n+          if (shift) indentLine(sel.from.line, \"smart\");\n+          else replaceSelection(\"\\t\", \"end\");\n+          break;\n+        }\n+      case \"shift\":\n+        indentSelected(shift ? \"subtract\" : \"add\");\n+        break;\n+      }\n+      return true;\n+    }\n+    function smartHome() {\n+      var firstNonWS = Math.max(0, lines[sel.from.line].text.search(/\\S/));\n+      setCursor(sel.from.line, sel.from.ch <= firstNonWS && sel.from.ch ? 0 : firstNonWS, true);\n+    }\n+\n+    function indentLine(n, how) {\n+      if (how == \"smart\") {\n+        if (!mode.indent) how = \"prev\";\n+        else var state = getStateBefore(n);\n+      }\n+\n+      var line = lines[n], curSpace = line.indentation(), curSpaceString = line.text.match(/^\\s*/)[0], indentation;\n+      if (how == \"prev\") {\n+        if (n) indentation = lines[n-1].indentation();\n+        else indentation = 0;\n+      }\n+      else if (how == \"smart\") indentation = mode.indent(state, line.text.slice(curSpaceString.length));\n+      else if (how == \"add\") indentation = curSpace + options.indentUnit;\n+      else if (how == \"subtract\") indentation = curSpace - options.indentUnit;\n+      indentation = Math.max(0, indentation);\n+      var diff = indentation - curSpace;\n+\n+      if (!diff) {\n+        if (sel.from.line != n && sel.to.line != n) return;\n+        var indentString = curSpaceString;\n+      }\n+      else {\n+        var indentString = \"\", pos = 0;\n+        if (options.indentWithTabs)\n+          for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += \"\\t\";}\n+        while (pos < indentation) {++pos; indentString += \" \";}\n+      }\n+\n+      replaceRange(indentString, {line: n, ch: 0}, {line: n, ch: curSpaceString.length});\n+    }\n+\n+    function loadMode() {\n+      mode = CodeMirror.getMode(options, options.mode);\n+      for (var i = 0, l = lines.length; i < l; ++i)\n+        lines[i].stateAfter = null;\n+      work = [0];\n+      startWorker();\n+    }\n+    function gutterChanged() {\n+      var visible = options.gutter || options.lineNumbers;\n+      gutter.style.display = visible ? \"\" : \"none\";\n+      if (visible) gutterDirty = true;\n+      else lineDiv.parentNode.style.marginLeft = 0;\n+    }\n+\n+    function markText(from, to, className) {\n+      from = clipPos(from); to = clipPos(to);\n+      var accum = [];\n+      function add(line, from, to, className) {\n+        var line = lines[line], mark = line.addMark(from, to, className);\n+        mark.line = line;\n+        accum.push(mark);\n+      }\n+      if (from.line == to.line) add(from.line, from.ch, to.ch, className);\n+      else {\n+        add(from.line, from.ch, null, className);\n+        for (var i = from.line + 1, e = to.line; i < e; ++i)\n+          add(i, 0, null, className);\n+        add(to.line, 0, to.ch, className);\n+      }\n+      changes.push({from: from.line, to: to.line + 1});\n+      return function() {\n+        var start, end;\n+        for (var i = 0; i < accum.length; ++i) {\n+          var mark = accum[i], found = indexOf(lines, mark.line);\n+          mark.line.removeMark(mark);\n+          if (found > -1) {\n+            if (start == null) start = found;\n+            end = found;\n+          }\n+        }\n+        if (start != null) changes.push({from: start, to: end + 1});\n+      };\n+    }\n+\n+    function addGutterMarker(line, text, className) {\n+      if (typeof line == \"number\") line = lines[clipLine(line)];\n+      line.gutterMarker = {text: text, style: className};\n+      gutterDirty = true;\n+      return line;\n+    }\n+    function removeGutterMarker(line) {\n+      if (typeof line == \"number\") line = lines[clipLine(line)];\n+      line.gutterMarker = null;\n+      gutterDirty = true;\n+    }\n+    function setLineClass(line, className) {\n+      if (typeof line == \"number\") {\n+        var no = line;\n+        line = lines[clipLine(line)];\n+      }\n+      else {\n+        var no = indexOf(lines, line);\n+        if (no == -1) return null;\n+      }\n+      if (line.className != className) {\n+        line.className = className;\n+        changes.push({from: no, to: no + 1});\n+      }\n+      return line;\n+    }\n+\n+    function lineInfo(line) {\n+      if (typeof line == \"number\") {\n+        var n = line;\n+        line = lines[line];\n+        if (!line) return null;\n+      }\n+      else {\n+        var n = indexOf(lines, line);\n+        if (n == -1) return null;\n+      }\n+      var marker = line.gutterMarker;\n+      return {line: n, text: line.text, markerText: marker && marker.text, markerClass: marker && marker.style};\n+    }\n+\n+    function stringWidth(str) {\n+      measure.innerHTML = \"<pre><span>x</span></pre>\";\n+      measure.firstChild.firstChild.firstChild.nodeValue = str;\n+      return measure.firstChild.firstChild.offsetWidth || 10;\n+    }\n+    // These are used to go from pixel positions to character\n+    // positions, taking varying character widths into account.\n+    function charX(line, pos) {\n+      if (pos == 0) return 0;\n+      measure.innerHTML = \"<pre><span>\" + lines[line].getHTML(null, null, false, pos) + \"</span></pre>\";\n+      return measure.firstChild.firstChild.offsetWidth;\n+    }\n+    function charFromX(line, x) {\n+      if (x <= 0) return 0;\n+      var lineObj = lines[line], text = lineObj.text;\n+      function getX(len) {\n+        measure.innerHTML = \"<pre><span>\" + lineObj.getHTML(null, null, false, len) + \"</span></pre>\";\n+        return measure.firstChild.firstChild.offsetWidth;\n+      }\n+      var from = 0, fromX = 0, to = text.length, toX;\n+      // Guess a suitable upper bound for our search.\n+      var estimated = Math.min(to, Math.ceil(x / stringWidth(\"x\")));\n+      for (;;) {\n+        var estX = getX(estimated);\n+        if (estX <= x && estimated < to) estimated = Math.min(to, Math.ceil(estimated * 1.2));\n+        else {toX = estX; to = estimated; break;}\n+      }\n+      if (x > toX) return to;\n+      // Try to guess a suitable lower bound as well.\n+      estimated = Math.floor(to * 0.8); estX = getX(estimated);\n+      if (estX < x) {from = estimated; fromX = estX;}\n+      // Do a binary search between these bounds.\n+      for (;;) {\n+        if (to - from <= 1) return (toX - x > x - fromX) ? from : to;\n+        var middle = Math.ceil((from + to) / 2), middleX = getX(middle);\n+        if (middleX > x) {to = middle; toX = middleX;}\n+        else {from = middle; fromX = middleX;}\n+      }\n+    }\n+\n+    function localCoords(pos, inLineWrap) {\n+      var lh = lineHeight(), line = pos.line - (inLineWrap ? showingFrom : 0);\n+      return {x: charX(pos.line, pos.ch), y: line * lh, yBot: (line + 1) * lh};\n+    }\n+    function pageCoords(pos) {\n+      var local = localCoords(pos, true), off = eltOffset(lineSpace);\n+      return {x: off.left + local.x, y: off.top + local.y, yBot: off.top + local.yBot};\n+    }\n+\n+    function lineHeight() {\n+      var nlines = lineDiv.childNodes.length;\n+      if (nlines) return (lineDiv.offsetHeight / nlines) || 1;\n+      measure.innerHTML = \"<pre>x</pre>\";\n+      return measure.firstChild.offsetHeight || 1;\n+    }\n+    function paddingTop() {return lineSpace.offsetTop;}\n+    function paddingLeft() {return lineSpace.offsetLeft;}\n+\n+    function posFromMouse(e, liberal) {\n+      var offW = eltOffset(scroller, true), x, y;\n+      // Fails unpredictably on IE[67] when mouse is dragged around quickly.\n+      try { x = e.clientX; y = e.clientY; } catch (e) { return null; }\n+      // This is a mess of a heuristic to try and determine whether a\n+      // scroll-bar was clicked or not, and to return null if one was\n+      // (and !liberal).\n+      if (!liberal && (x - offW.left > scroller.clientWidth || y - offW.top > scroller.clientHeight))\n+        return null;\n+      var offL = eltOffset(lineSpace, true);\n+      var line = showingFrom + Math.floor((y - offL.top) / lineHeight());\n+      return clipPos({line: line, ch: charFromX(clipLine(line), x - offL.left)});\n+    }\n+    function onContextMenu(e) {\n+      var pos = posFromMouse(e);\n+      if (!pos || window.opera) return; // Opera is difficult.\n+      if (posEq(sel.from, sel.to) || posLess(pos, sel.from) || !posLess(pos, sel.to))\n+        operation(setCursor)(pos.line, pos.ch);\n+\n+      var oldCSS = input.style.cssText;\n+      inputDiv.style.position = \"absolute\";\n+      input.style.cssText = \"position: fixed; width: 30px; height: 30px; top: \" + (e.clientY - 5) +\n+        \"px; left: \" + (e.clientX - 5) + \"px; z-index: 1000; background: white; \" +\n+        \"border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);\";\n+      leaveInputAlone = true;\n+      var val = input.value = getSelection();\n+      focusInput();\n+      setSelRange(input, 0, input.value.length);\n+      function rehide() {\n+        var newVal = splitLines(input.value).join(\"\\n\");\n+        if (newVal != val) operation(replaceSelection)(newVal, \"end\");\n+        inputDiv.style.position = \"relative\";\n+        input.style.cssText = oldCSS;\n+        leaveInputAlone = false;\n+        prepareInput();\n+        slowPoll();\n+      }\n+      \n+      if (gecko) {\n+        e_stop(e);\n+        var mouseup = connect(window, \"mouseup\", function() {\n+          mouseup();\n+          setTimeout(rehide, 20);\n+        }, true);\n+      }\n+      else {\n+        setTimeout(rehide, 50);\n+      }\n+    }\n+\n+    // Cursor-blinking\n+    function restartBlink() {\n+      clearInterval(blinker);\n+      var on = true;\n+      cursor.style.visibility = \"\";\n+      blinker = setInterval(function() {\n+        cursor.style.visibility = (on = !on) ? \"\" : \"hidden\";\n+      }, 650);\n+    }\n+\n+    var matching = {\"(\": \")>\", \")\": \"(<\", \"[\": \"]>\", \"]\": \"[<\", \"{\": \"}>\", \"}\": \"{<\"};\n+    function matchBrackets(autoclear) {\n+      var head = sel.inverted ? sel.from : sel.to, line = lines[head.line], pos = head.ch - 1;\n+      var match = (pos >= 0 && matching[line.text.charAt(pos)]) || matching[line.text.charAt(++pos)];\n+      if (!match) return;\n+      var ch = match.charAt(0), forward = match.charAt(1) == \">\", d = forward ? 1 : -1, st = line.styles;\n+      for (var off = pos + 1, i = 0, e = st.length; i < e; i+=2)\n+        if ((off -= st[i].length) <= 0) {var style = st[i+1]; break;}\n+\n+      var stack = [line.text.charAt(pos)], re = /[(){}[\\]]/;\n+      function scan(line, from, to) {\n+        if (!line.text) return;\n+        var st = line.styles, pos = forward ? 0 : line.text.length - 1, cur;\n+        for (var i = forward ? 0 : st.length - 2, e = forward ? st.length : -2; i != e; i += 2*d) {\n+          var text = st[i];\n+          if (st[i+1] != null && st[i+1] != style) {pos += d * text.length; continue;}\n+          for (var j = forward ? 0 : text.length - 1, te = forward ? text.length : -1; j != te; j += d, pos+=d) {\n+            if (pos >= from && pos < to && re.test(cur = text.charAt(j))) {\n+              var match = matching[cur];\n+              if (match.charAt(1) == \">\" == forward) stack.push(cur);\n+              else if (stack.pop() != match.charAt(0)) return {pos: pos, match: false};\n+              else if (!stack.length) return {pos: pos, match: true};\n+            }\n+          }\n+        }\n+      }\n+      for (var i = head.line, e = forward ? Math.min(i + 100, lines.length) : Math.max(-1, i - 100); i != e; i+=d) {\n+        var line = lines[i], first = i == head.line;\n+        var found = scan(line, first && forward ? pos + 1 : 0, first && !forward ? pos : line.text.length);\n+        if (found) break;\n+      }\n+      if (!found) found = {pos: null, match: false};\n+      var style = found.match ? \"CodeMirror-matchingbracket\" : \"CodeMirror-nonmatchingbracket\";\n+      var one = markText({line: head.line, ch: pos}, {line: head.line, ch: pos+1}, style),\n+          two = found.pos != null\n+            ? markText({line: i, ch: found.pos}, {line: i, ch: found.pos + 1}, style)\n+            : function() {};\n+      var clear = operation(function(){one(); two();});\n+      if (autoclear) setTimeout(clear, 800);\n+      else bracketHighlighted = clear;\n+    }\n+\n+    // Finds the line to start with when starting a parse. Tries to\n+    // find a line with a stateAfter, so that it can start with a\n+    // valid state. If that fails, it returns the line with the\n+    // smallest indentation, which tends to need the least context to\n+    // parse correctly.\n+    function findStartLine(n) {\n+      var minindent, minline;\n+      for (var search = n, lim = n - 40; search > lim; --search) {\n+        if (search == 0) return 0;\n+        var line = lines[search-1];\n+        if (line.stateAfter) return search;\n+        var indented = line.indentation();\n+        if (minline == null || minindent > indented) {\n+          minline = search - 1;\n+          minindent = indented;\n+        }\n+      }\n+      return minline;\n+    }\n+    function getStateBefore(n) {\n+      var start = findStartLine(n), state = start && lines[start-1].stateAfter;\n+      if (!state) state = startState(mode);\n+      else state = copyState(mode, state);\n+      for (var i = start; i < n; ++i) {\n+        var line = lines[i];\n+        line.highlight(mode, state);\n+        line.stateAfter = copyState(mode, state);\n+      }\n+      if (n < lines.length && !lines[n].stateAfter) work.push(n);\n+      return state;\n+    }\n+    function highlightLines(start, end) {\n+      var state = getStateBefore(start);\n+      for (var i = start; i < end; ++i) {\n+        var line = lines[i];\n+        line.highlight(mode, state);\n+        line.stateAfter = copyState(mode, state);\n+      }\n+    }\n+    function highlightWorker() {\n+      var end = +new Date + options.workTime;\n+      var foundWork = work.length;\n+      while (work.length) {\n+        if (!lines[showingFrom].stateAfter) var task = showingFrom;\n+        else var task = work.pop();\n+        if (task >= lines.length) continue;\n+        var start = findStartLine(task), state = start && lines[start-1].stateAfter;\n+        if (state) state = copyState(mode, state);\n+        else state = startState(mode);\n+\n+        var unchanged = 0, compare = mode.compareStates, realChange = false;\n+        for (var i = start, l = lines.length; i < l; ++i) {\n+          var line = lines[i], hadState = line.stateAfter;\n+          if (+new Date > end) {\n+            work.push(i);\n+            startWorker(options.workDelay);\n+            if (realChange) changes.push({from: task, to: i + 1});\n+            return;\n+          }\n+          var changed = line.highlight(mode, state);\n+          if (changed) realChange = true;\n+          line.stateAfter = copyState(mode, state);\n+          if (compare) {\n+            if (hadState && compare(hadState, state)) break;\n+          } else {\n+            if (changed !== false || !hadState) unchanged = 0;\n+            else if (++unchanged > 3) break;\n+          }\n+        }\n+        if (realChange) changes.push({from: task, to: i + 1});\n+      }\n+      if (foundWork && options.onHighlightComplete)\n+        options.onHighlightComplete(instance);\n+    }\n+    function startWorker(time) {\n+      if (!work.length) return;\n+      highlight.set(time, operation(highlightWorker));\n+    }\n+\n+    // Operations are used to wrap changes in such a way that each\n+    // change won't have to update the cursor and display (which would\n+    // be awkward, slow, and error-prone), but instead updates are\n+    // batched and then all combined and executed at once.\n+    function startOperation() {\n+      updateInput = null; changes = []; textChanged = selectionChanged = false;\n+    }\n+    function endOperation() {\n+      var reScroll = false;\n+      if (selectionChanged) reScroll = !scrollCursorIntoView();\n+      if (changes.length) updateDisplay(changes);\n+      else {\n+        if (selectionChanged) updateCursor();\n+        if (gutterDirty) updateGutter();\n+      }\n+      if (reScroll) scrollCursorIntoView();\n+      if (selectionChanged) {scrollEditorIntoView(); restartBlink();}\n+\n+      // updateInput can be set to a boolean value to force/prevent an\n+      // update.\n+      if (focused && !leaveInputAlone &&\n+          (updateInput === true || (updateInput !== false && selectionChanged)))\n+        prepareInput();\n+\n+      if (selectionChanged && options.matchBrackets)\n+        setTimeout(operation(function() {\n+          if (bracketHighlighted) {bracketHighlighted(); bracketHighlighted = null;}\n+          matchBrackets(false);\n+        }), 20);\n+      var tc = textChanged; // textChanged can be reset by cursoractivity callback\n+      if (selectionChanged && options.onCursorActivity)\n+        options.onCursorActivity(instance);\n+      if (tc && options.onChange && instance)\n+        options.onChange(instance, tc);\n+    }\n+    var nestedOperation = 0;\n+    function operation(f) {\n+      return function() {\n+        if (!nestedOperation++) startOperation();\n+        try {var result = f.apply(this, arguments);}\n+        finally {if (!--nestedOperation) endOperation();}\n+        return result;\n+      };\n+    }\n+\n+    function SearchCursor(query, pos, caseFold) {\n+      this.atOccurrence = false;\n+      if (caseFold == null) caseFold = typeof query == \"string\" && query == query.toLowerCase();\n+\n+      if (pos && typeof pos == \"object\") pos = clipPos(pos);\n+      else pos = {line: 0, ch: 0};\n+      this.pos = {from: pos, to: pos};\n+\n+      // The matches method is filled in based on the type of query.\n+      // It takes a position and a direction, and returns an object\n+      // describing the next occurrence of the query, or null if no\n+      // more matches were found.\n+      if (typeof query != \"string\") // Regexp match\n+        this.matches = function(reverse, pos) {\n+          if (reverse) {\n+            var line = lines[pos.line].text.slice(0, pos.ch), match = line.match(query), start = 0;\n+            while (match) {\n+              var ind = line.indexOf(match[0]);\n+              start += ind;\n+              line = line.slice(ind + 1);\n+              var newmatch = line.match(query);\n+              if (newmatch) match = newmatch;\n+              else break;\n+              start++;\n+            }\n+          }\n+          else {\n+            var line = lines[pos.line].text.slice(pos.ch), match = line.match(query),\n+                start = match && pos.ch + line.indexOf(match[0]);\n+          }\n+          if (match)\n+            return {from: {line: pos.line, ch: start},\n+                    to: {line: pos.line, ch: start + match[0].length},\n+                    match: match};\n+        };\n+      else { // String query\n+        if (caseFold) query = query.toLowerCase();\n+        var fold = caseFold ? function(str){return str.toLowerCase();} : function(str){return str;};\n+        var target = query.split(\"\\n\");\n+        // Different methods for single-line and multi-line queries\n+        if (target.length == 1)\n+          this.matches = function(reverse, pos) {\n+            var line = fold(lines[pos.line].text), len = query.length, match;\n+            if (reverse ? (pos.ch >= len && (match = line.lastIndexOf(query, pos.ch - len)) != -1)\n+                        : (match = line.indexOf(query, pos.ch)) != -1)\n+              return {from: {line: pos.line, ch: match},\n+                      to: {line: pos.line, ch: match + len}};\n+          };\n+        else\n+          this.matches = function(reverse, pos) {\n+            var ln = pos.line, idx = (reverse ? target.length - 1 : 0), match = target[idx], line = fold(lines[ln].text);\n+            var offsetA = (reverse ? line.indexOf(match) + match.length : line.lastIndexOf(match));\n+            if (reverse ? offsetA >= pos.ch || offsetA != match.length\n+                        : offsetA <= pos.ch || offsetA != line.length - match.length)\n+              return;\n+            for (;;) {\n+              if (reverse ? !ln : ln == lines.length - 1) return;\n+              line = fold(lines[ln += reverse ? -1 : 1].text);\n+              match = target[reverse ? --idx : ++idx];\n+              if (idx > 0 && idx < target.length - 1) {\n+                if (line != match) return;\n+                else continue;\n+              }\n+              var offsetB = (reverse ? line.lastIndexOf(match) : line.indexOf(match) + match.length);\n+              if (reverse ? offsetB != line.length - match.length : offsetB != match.length)\n+                return;\n+              var start = {line: pos.line, ch: offsetA}, end = {line: ln, ch: offsetB};\n+              return {from: reverse ? end : start, to: reverse ? start : end};\n+            }\n+          };\n+      }\n+    }\n+\n+    SearchCursor.prototype = {\n+      findNext: function() {return this.find(false);},\n+      findPrevious: function() {return this.find(true);},\n+\n+      find: function(reverse) {\n+        var self = this, pos = clipPos(reverse ? this.pos.from : this.pos.to);\n+        function savePosAndFail(line) {\n+          var pos = {line: line, ch: 0};\n+          self.pos = {from: pos, to: pos};\n+          self.atOccurrence = false;\n+          return false;\n+        }\n+\n+        for (;;) {\n+          if (this.pos = this.matches(reverse, pos)) {\n+            this.atOccurrence = true;\n+            return this.pos.match || true;\n+          }\n+          if (reverse) {\n+            if (!pos.line) return savePosAndFail(0);\n+            pos = {line: pos.line-1, ch: lines[pos.line-1].text.length};\n+          }\n+          else {\n+            if (pos.line == lines.length - 1) return savePosAndFail(lines.length);\n+            pos = {line: pos.line+1, ch: 0};\n+          }\n+        }\n+      },\n+\n+      from: function() {if (this.atOccurrence) return copyPos(this.pos.from);},\n+      to: function() {if (this.atOccurrence) return copyPos(this.pos.to);},\n+\n+      replace: function(newText) {\n+        var self = this;\n+        if (this.atOccurrence)\n+          operation(function() {\n+            self.pos.to = replaceRange(newText, self.pos.from, self.pos.to);\n+          })();\n+      }\n+    };\n+\n+    for (var ext in extensions)\n+      if (extensions.propertyIsEnumerable(ext) &&\n+          !instance.propertyIsEnumerable(ext))\n+        instance[ext] = extensions[ext];\n+    return instance;\n+  } // (end of function CodeMirror)\n+\n+  // The default configuration options.\n+  CodeMirror.defaults = {\n+    value: \"\",\n+    mode: null,\n+    theme: \"default\",\n+    indentUnit: 2,\n+    indentWithTabs: false,\n+    tabMode: \"classic\",\n+    enterMode: \"indent\",\n+    electricChars: true,\n+    onKeyEvent: null,\n+    lineNumbers: false,\n+    gutter: false,\n+    fixedGutter: false,\n+    firstLineNumber: 1,\n+    readOnly: false,\n+    smartHome: true,\n+    onChange: null,\n+    onCursorActivity: null,\n+    onGutterClick: null,\n+    onHighlightComplete: null,\n+    onFocus: null, onBlur: null, onScroll: null,\n+    matchBrackets: false,\n+    workTime: 100,\n+    workDelay: 200,\n+    undoDepth: 40,\n+    tabindex: null,\n+    document: window.document\n+  };\n+\n+  // Known modes, by name and by MIME\n+  var modes = {}, mimeModes = {};\n+  CodeMirror.defineMode = function(name, mode) {\n+    if (!CodeMirror.defaults.mode && name != \"null\") CodeMirror.defaults.mode = name;\n+    modes[name] = mode;\n+  };\n+  CodeMirror.defineMIME = function(mime, spec) {\n+    mimeModes[mime] = spec;\n+  };\n+  CodeMirror.getMode = function(options, spec) {\n+    if (typeof spec == \"string\" && mimeModes.hasOwnProperty(spec))\n+      spec = mimeModes[spec];\n+    if (typeof spec == \"string\")\n+      var mname = spec, config = {};\n+    else if (spec != null)\n+      var mname = spec.name, config = spec;\n+    var mfactory = modes[mname];\n+    if (!mfactory) {\n+      if (window.console) console.warn(\"No mode \" + mname + \" found, falling back to plain text.\");\n+      return CodeMirror.getMode(options, \"text/plain\");\n+    }\n+    return mfactory(options, config || {});\n+  };\n+  CodeMirror.listModes = function() {\n+    var list = [];\n+    for (var m in modes)\n+      if (modes.propertyIsEnumerable(m)) list.push(m);\n+    return list;\n+  };\n+  CodeMirror.listMIMEs = function() {\n+    var list = [];\n+    for (var m in mimeModes)\n+      if (mimeModes.propertyIsEnumerable(m)) list.push({mime: m, mode: mimeModes[m]});\n+    return list;\n+  };\n+\n+  var extensions = {};\n+  CodeMirror.defineExtension = function(name, func) {\n+    extensions[name] = func;\n+  };\n+\n+  CodeMirror.fromTextArea = function(textarea, options) {\n+    if (!options) options = {};\n+    options.value = textarea.value;\n+    if (!options.tabindex && textarea.tabindex)\n+      options.tabindex = textarea.tabindex;\n+\n+    function save() {textarea.value = instance.getValue();}\n+    if (textarea.form) {\n+      // Deplorable hack to make the submit method do the right thing.\n+      var rmSubmit = connect(textarea.form, \"submit\", save, true);\n+      if (typeof textarea.form.submit == \"function\") {\n+        var realSubmit = textarea.form.submit;\n+        function wrappedSubmit() {\n+          save();\n+          textarea.form.submit = realSubmit;\n+          textarea.form.submit();\n+          textarea.form.submit = wrappedSubmit;\n+        }\n+        textarea.form.submit = wrappedSubmit;\n+      }\n+    }\n+\n+    textarea.style.display = \"none\";\n+    var instance = CodeMirror(function(node) {\n+      textarea.parentNode.insertBefore(node, textarea.nextSibling);\n+    }, options);\n+    instance.save = save;\n+    instance.toTextArea = function() {\n+      save();\n+      textarea.parentNode.removeChild(instance.getWrapperElement());\n+      textarea.style.display = \"\";\n+      if (textarea.form) {\n+        rmSubmit();\n+        if (typeof textarea.form.submit == \"function\")\n+          textarea.form.submit = realSubmit;\n+      }\n+    };\n+    return instance;\n+  };\n+\n+  // Utility functions for working with state. Exported because modes\n+  // sometimes need to do this.\n+  function copyState(mode, state) {\n+    if (state === true) return state;\n+    if (mode.copyState) return mode.copyState(state);\n+    var nstate = {};\n+    for (var n in state) {\n+      var val = state[n];\n+      if (val instanceof Array) val = val.concat([]);\n+      nstate[n] = val;\n+    }\n+    return nstate;\n+  }\n+  CodeMirror.startState = startState;\n+  function startState(mode, a1, a2) {\n+    return mode.startState ? mode.startState(a1, a2) : true;\n+  }\n+  CodeMirror.copyState = copyState;\n+\n+  // The character stream used by a mode's parser.\n+  function StringStream(string) {\n+    this.pos = this.start = 0;\n+    this.string = string;\n+  }\n+  StringStream.prototype = {\n+    eol: function() {return this.pos >= this.string.length;},\n+    sol: function() {return this.pos == 0;},\n+    peek: function() {return this.string.charAt(this.pos);},\n+    next: function() {\n+      if (this.pos < this.string.length)\n+        return this.string.charAt(this.pos++);\n+    },\n+    eat: function(match) {\n+      var ch = this.string.charAt(this.pos);\n+      if (typeof match == \"string\") var ok = ch == match;\n+      else var ok = ch && (match.test ? match.test(ch) : match(ch));\n+      if (ok) {++this.pos; return ch;}\n+    },\n+    eatWhile: function(match) {\n+      var start = this.pos;\n+      while (this.eat(match)){}\n+      return this.pos > start;\n+    },\n+    eatSpace: function() {\n+      var start = this.pos;\n+      while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos))) ++this.pos;\n+      return this.pos > start;\n+    },\n+    skipToEnd: function() {this.pos = this.string.length;},\n+    skipTo: function(ch) {\n+      var found = this.string.indexOf(ch, this.pos);\n+      if (found > -1) {this.pos = found; return true;}\n+    },\n+    backUp: function(n) {this.pos -= n;},\n+    column: function() {return countColumn(this.string, this.start);},\n+    indentation: function() {return countColumn(this.string);},\n+    match: function(pattern, consume, caseInsensitive) {\n+      if (typeof pattern == \"string\") {\n+        function cased(str) {return caseInsensitive ? str.toLowerCase() : str;}\n+        if (cased(this.string).indexOf(cased(pattern), this.pos) == this.pos) {\n+          if (consume !== false) this.pos += pattern.length;\n+          return true;\n+        }\n+      }\n+      else {\n+        var match = this.string.slice(this.pos).match(pattern);\n+        if (match && consume !== false) this.pos += match[0].length;\n+        return match;\n+      }\n+    },\n+    current: function(){return this.string.slice(this.start, this.pos);}\n+  };\n+  CodeMirror.StringStream = StringStream;\n+\n+  // Line objects. These hold state related to a line, including\n+  // highlighting info (the styles array).\n+  function Line(text, styles) {\n+    this.styles = styles || [text, null];\n+    this.stateAfter = null;\n+    this.text = text;\n+    this.marked = this.gutterMarker = this.className = null;\n+  }\n+  Line.prototype = {\n+    // Replace a piece of a line, keeping the styles around it intact.\n+    replace: function(from, to, text) {\n+      var st = [], mk = this.marked;\n+      copyStyles(0, from, this.styles, st);\n+      if (text) st.push(text, null);\n+      copyStyles(to, this.text.length, this.styles, st);\n+      this.styles = st;\n+      this.text = this.text.slice(0, from) + text + this.text.slice(to);\n+      this.stateAfter = null;\n+      if (mk) {\n+        var diff = text.length - (to - from), end = this.text.length;\n+        function fix(n) {return n <= Math.min(to, to + diff) ? n : n + diff;}\n+        for (var i = 0; i < mk.length; ++i) {\n+          var mark = mk[i], del = false;\n+          if (mark.from >= end) del = true;\n+          else {mark.from = fix(mark.from); if (mark.to != null) mark.to = fix(mark.to);}\n+          if (del || mark.from >= mark.to) {mk.splice(i, 1); i--;}\n+        }\n+      }\n+    },\n+    // Split a line in two, again keeping styles intact.\n+    split: function(pos, textBefore) {\n+      var st = [textBefore, null];\n+      copyStyles(pos, this.text.length, this.styles, st);\n+      return new Line(textBefore + this.text.slice(pos), st);\n+    },\n+    addMark: function(from, to, style) {\n+      var mk = this.marked, mark = {from: from, to: to, style: style};\n+      if (this.marked == null) this.marked = [];\n+      this.marked.push(mark);\n+      this.marked.sort(function(a, b){return a.from - b.from;});\n+      return mark;\n+    },\n+    removeMark: function(mark) {\n+      var mk = this.marked;\n+      if (!mk) return;\n+      for (var i = 0; i < mk.length; ++i)\n+        if (mk[i] == mark) {mk.splice(i, 1); break;}\n+    },\n+    // Run the given mode's parser over a line, update the styles\n+    // array, which contains alternating fragments of text and CSS\n+    // classes.\n+    highlight: function(mode, state) {\n+      var stream = new StringStream(this.text), st = this.styles, pos = 0;\n+      var changed = false, curWord = st[0], prevWord;\n+      if (this.text == \"\" && mode.blankLine) mode.blankLine(state);\n+      while (!stream.eol()) {\n+        var style = mode.token(stream, state);\n+        var substr = this.text.slice(stream.start, stream.pos);\n+        stream.start = stream.pos;\n+        if (pos && st[pos-1] == style)\n+          st[pos-2] += substr;\n+        else if (substr) {\n+          if (!changed && (st[pos+1] != style || (pos && st[pos-2] != prevWord))) changed = true;\n+          st[pos++] = substr; st[pos++] = style;\n+          prevWord = curWord; curWord = st[pos];\n+        }\n+        // Give up when line is ridiculously long\n+        if (stream.pos > 5000) {\n+          st[pos++] = this.text.slice(stream.pos); st[pos++] = null;\n+          break;\n+        }\n+      }\n+      if (st.length != pos) {st.length = pos; changed = true;}\n+      if (pos && st[pos-2] != prevWord) changed = true;\n+      // Short lines with simple highlights return null, and are\n+      // counted as changed by the driver because they are likely to\n+      // highlight the same way in various contexts.\n+      return changed || (st.length < 5 && this.text.length < 10 ? null : false);\n+    },\n+    // Fetch the parser token for a given character. Useful for hacks\n+    // that want to inspect the mode state (say, for completion).\n+    getTokenAt: function(mode, state, ch) {\n+      var txt = this.text, stream = new StringStream(txt);\n+      while (stream.pos < ch && !stream.eol()) {\n+        stream.start = stream.pos;\n+        var style = mode.token(stream, state);\n+      }\n+      return {start: stream.start,\n+              end: stream.pos,\n+              string: stream.current(),\n+              className: style || null,\n+              state: state};\n+    },\n+    indentation: function() {return countColumn(this.text);},\n+    // Produces an HTML fragment for the line, taking selection,\n+    // marking, and highlighting into account.\n+    getHTML: function(sfrom, sto, includePre, endAt) {\n+      var html = [];\n+      if (includePre)\n+        html.push(this.className ? '<pre class=\"' + this.className + '\">': \"<pre>\");\n+      function span(text, style) {\n+        if (!text) return;\n+        if (style) html.push('<span class=\"', style, '\">', htmlEscape(text), \"</span>\");\n+        else html.push(htmlEscape(text));\n+      }\n+      var st = this.styles, allText = this.text, marked = this.marked;\n+      if (sfrom == sto) sfrom = null;\n+      var len = allText.length;\n+      if (endAt != null) len = Math.min(endAt, len);\n+\n+      if (!allText && endAt == null)\n+        span(\" \", sfrom != null && sto == null ? \"CodeMirror-selected\" : null);\n+      else if (!marked && sfrom == null)\n+        for (var i = 0, ch = 0; ch < len; i+=2) {\n+          var str = st[i], l = str.length;\n+          if (ch + l > len) str = str.slice(0, len - ch);\n+          ch += l;\n+          span(str, \"cm-\" + st[i+1]);\n+        }\n+      else {\n+        var pos = 0, i = 0, text = \"\", style, sg = 0;\n+        var markpos = -1, mark = null;\n+        function nextMark() {\n+          if (marked) {\n+            markpos += 1;\n+            mark = (markpos < marked.length) ? marked[markpos] : null;\n+          }\n+        }\n+        nextMark();\n+        while (pos < len) {\n+          var upto = len;\n+          var extraStyle = \"\";\n+          if (sfrom != null) {\n+            if (sfrom > pos) upto = sfrom;\n+            else if (sto == null || sto > pos) {\n+              extraStyle = \" CodeMirror-selected\";\n+              if (sto != null) upto = Math.min(upto, sto);\n+            }\n+          }\n+          while (mark && mark.to != null && mark.to <= pos) nextMark();\n+          if (mark) {\n+            if (mark.from > pos) upto = Math.min(upto, mark.from);\n+            else {\n+              extraStyle += \" \" + mark.style;\n+              if (mark.to != null) upto = Math.min(upto, mark.to);\n+            }\n+          }\n+          for (;;) {\n+            var end = pos + text.length;\n+            var appliedStyle = style;\n+            if (extraStyle) appliedStyle = style ? style + extraStyle : extraStyle;\n+            span(end > upto ? text.slice(0, upto - pos) : text, appliedStyle);\n+            if (end >= upto) {text = text.slice(upto - pos); pos = upto; break;}\n+            pos = end;\n+            text = st[i++]; style = \"cm-\" + st[i++];\n+          }\n+        }\n+        if (sfrom != null && sto == null) span(\" \", \"CodeMirror-selected\");\n+      }\n+      if (includePre) html.push(\"</pre>\");\n+      return html.join(\"\");\n+    }\n+  };\n+  // Utility used by replace and split above\n+  function copyStyles(from, to, source, dest) {\n+    for (var i = 0, pos = 0, state = 0; pos < to; i+=2) {\n+      var part = source[i], end = pos + part.length;\n+      if (state == 0) {\n+        if (end > from) dest.push(part.slice(from - pos, Math.min(part.length, to - pos)), source[i+1]);\n+        if (end >= from) state = 1;\n+      }\n+      else if (state == 1) {\n+        if (end > to) dest.push(part.slice(0, to - pos), source[i+1]);\n+        else dest.push(part, source[i+1]);\n+      }\n+      pos = end;\n+    }\n+  }\n+\n+  // The history object 'chunks' changes that are made close together\n+  // and at almost the same time into bigger undoable units.\n+  function History() {\n+    this.time = 0;\n+    this.done = []; this.undone = [];\n+  }\n+  History.prototype = {\n+    addChange: function(start, added, old) {\n+      this.undone.length = 0;\n+      var time = +new Date, last = this.done[this.done.length - 1];\n+      if (time - this.time > 400 || !last ||\n+          last.start > start + added || last.start + last.added < start - last.added + last.old.length)\n+        this.done.push({start: start, added: added, old: old});\n+      else {\n+        var oldoff = 0;\n+        if (start < last.start) {\n+          for (var i = last.start - start - 1; i >= 0; --i)\n+            last.old.unshift(old[i]);\n+          last.added += last.start - start;\n+          last.start = start;\n+        }\n+        else if (last.start < start) {\n+          oldoff = start - last.start;\n+          added += oldoff;\n+        }\n+        for (var i = last.added - oldoff, e = old.length; i < e; ++i)\n+          last.old.push(old[i]);\n+        if (last.added < added) last.added = added;\n+      }\n+      this.time = time;\n+    }\n+  };\n+\n+  function stopMethod() {e_stop(this);}\n+  // Ensure an event has a stop method.\n+  function addStop(event) {\n+    if (!event.stop) event.stop = stopMethod;\n+    return event;\n+  }\n+\n+  function e_preventDefault(e) {\n+    if (e.preventDefault) e.preventDefault();\n+    else e.returnValue = false;\n+  }\n+  function e_stopPropagation(e) {\n+    if (e.stopPropagation) e.stopPropagation();\n+    else e.cancelBubble = true;\n+  }\n+  function e_stop(e) {e_preventDefault(e); e_stopPropagation(e);}\n+  function e_target(e) {return e.target || e.srcElement;}\n+  function e_button(e) {\n+    if (e.which) return e.which;\n+    else if (e.button & 1) return 1;\n+    else if (e.button & 2) return 3;\n+    else if (e.button & 4) return 2;\n+  }\n+\n+  // Event handler registration. If disconnect is true, it'll return a\n+  // function that unregisters the handler.\n+  function connect(node, type, handler, disconnect) {\n+    function wrapHandler(event) {handler(event || window.event);}\n+    if (typeof node.addEventListener == \"function\") {\n+      node.addEventListener(type, wrapHandler, false);\n+      if (disconnect) return function() {node.removeEventListener(type, wrapHandler, false);};\n+    }\n+    else {\n+      node.attachEvent(\"on\" + type, wrapHandler);\n+      if (disconnect) return function() {node.detachEvent(\"on\" + type, wrapHandler);};\n+    }\n+  }\n+\n+  function Delayed() {this.id = null;}\n+  Delayed.prototype = {set: function(ms, f) {clearTimeout(this.id); this.id = setTimeout(f, ms);}};\n+\n+  // Some IE versions don't preserve whitespace when setting the\n+  // innerHTML of a PRE tag.\n+  var badInnerHTML = (function() {\n+    var pre = document.createElement(\"pre\");\n+    pre.innerHTML = \" \"; return !pre.innerHTML;\n+  })();\n+\n+  // Detect drag-and-drop\n+  var dragAndDrop = (function() {\n+    // IE8 has ondragstart and ondrop properties, but doesn't seem to\n+    // actually support ondragstart the way it's supposed to work.\n+    if (/MSIE [1-8]\\b/.test(navigator.userAgent)) return false;\n+    var div = document.createElement('div');\n+    return \"ondragstart\" in div && \"ondrop\" in div;\n+  })();\n+\n+  var gecko = /gecko\\/\\d{7}/i.test(navigator.userAgent);\n+  var ie = /MSIE \\d/.test(navigator.userAgent);\n+  var safari = /Apple Computer/.test(navigator.vendor);\n+\n+  var lineSep = \"\\n\";\n+  // Feature-detect whether newlines in textareas are converted to \\r\\n\n+  (function () {\n+    var te = document.createElement(\"textarea\");\n+    te.value = \"foo\\nbar\";\n+    if (te.value.indexOf(\"\\r\") > -1) lineSep = \"\\r\\n\";\n+  }());\n+\n+  var tabSize = 8;\n+  var mac = /Mac/.test(navigator.platform);\n+  var movementKeys = {};\n+  for (var i = 35; i <= 40; ++i)\n+    movementKeys[i] = movementKeys[\"c\" + i] = true;\n+\n+  // Counts the column offset in a string, taking tabs into account.\n+  // Used mostly to find indentation.\n+  function countColumn(string, end) {\n+    if (end == null) {\n+      end = string.search(/[^\\s\\u00a0]/);\n+      if (end == -1) end = string.length;\n+    }\n+    for (var i = 0, n = 0; i < end; ++i) {\n+      if (string.charAt(i) == \"\\t\") n += tabSize - (n % tabSize);\n+      else ++n;\n+    }\n+    return n;\n+  }\n+\n+  function computedStyle(elt) {\n+    if (elt.currentStyle) return elt.currentStyle;\n+    return window.getComputedStyle(elt, null);\n+  }\n+  // Find the position of an element by following the offsetParent chain.\n+  // If screen==true, it returns screen (rather than page) coordinates.\n+  function eltOffset(node, screen) {\n+    var doc = node.ownerDocument.body;\n+    var x = 0, y = 0, skipDoc = false;\n+    for (var n = node; n; n = n.offsetParent) {\n+      x += n.offsetLeft; y += n.offsetTop;\n+      if (screen && computedStyle(n).position == \"fixed\")\n+        skipDoc = true;\n+    }\n+    var e = screen && !skipDoc ? null : doc;\n+    for (var n = node.parentNode; n != e; n = n.parentNode)\n+      if (n.scrollLeft != null) { x -= n.scrollLeft; y -= n.scrollTop;}\n+    return {left: x, top: y};\n+  }\n+  // Get a node's text content.\n+  function eltText(node) {\n+    return node.textContent || node.innerText || node.nodeValue || \"\";\n+  }\n+\n+  // Operations on {line, ch} objects.\n+  function posEq(a, b) {return a.line == b.line && a.ch == b.ch;}\n+  function posLess(a, b) {return a.line < b.line || (a.line == b.line && a.ch < b.ch);}\n+  function copyPos(x) {return {line: x.line, ch: x.ch};}\n+\n+  var escapeElement = document.createElement(\"div\");\n+  function htmlEscape(str) {\n+    escapeElement.innerText = escapeElement.textContent = str;\n+    return escapeElement.innerHTML;\n+  }\n+  CodeMirror.htmlEscape = htmlEscape;\n+\n+  // Used to position the cursor after an undo/redo by finding the\n+  // last edited character.\n+  function editEnd(from, to) {\n+    if (!to) return from ? from.length : 0;\n+    if (!from) return to.length;\n+    for (var i = from.length, j = to.length; i >= 0 && j >= 0; --i, --j)\n+      if (from.charAt(i) != to.charAt(j)) break;\n+    return j + 1;\n+  }\n+\n+  function indexOf(collection, elt) {\n+    if (collection.indexOf) return collection.indexOf(elt);\n+    for (var i = 0, e = collection.length; i < e; ++i)\n+      if (collection[i] == elt) return i;\n+    return -1;\n+  }\n+\n+  // See if \"\".split is the broken IE version, if so, provide an\n+  // alternative way to split lines.\n+  var splitLines, selRange, setSelRange;\n+  if (\"\\n\\nb\".split(/\\n/).length != 3)\n+    splitLines = function(string) {\n+      var pos = 0, nl, result = [];\n+      while ((nl = string.indexOf(\"\\n\", pos)) > -1) {\n+        result.push(string.slice(pos, string.charAt(nl-1) == \"\\r\" ? nl - 1 : nl));\n+        pos = nl + 1;\n+      }\n+      result.push(string.slice(pos));\n+      return result;\n+    };\n+  else\n+    splitLines = function(string){return string.split(/\\r?\\n/);};\n+  CodeMirror.splitLines = splitLines;\n+\n+  // Sane model of finding and setting the selection in a textarea\n+  if (window.getSelection) {\n+    selRange = function(te) {\n+      try {return {start: te.selectionStart, end: te.selectionEnd};}\n+      catch(e) {return null;}\n+    };\n+    if (safari)\n+      // On Safari, selection set with setSelectionRange are in a sort\n+      // of limbo wrt their anchor. If you press shift-left in them,\n+      // the anchor is put at the end, and the selection expanded to\n+      // the left. If you press shift-right, the anchor ends up at the\n+      // front. This is not what CodeMirror wants, so it does a\n+      // spurious modify() call to get out of limbo.\n+      setSelRange = function(te, start, end) {\n+        if (start == end)\n+          te.setSelectionRange(start, end);\n+        else {\n+          te.setSelectionRange(start, end - 1);\n+          window.getSelection().modify(\"extend\", \"forward\", \"character\");\n+        }\n+      };\n+    else\n+      setSelRange = function(te, start, end) {\n+        try {te.setSelectionRange(start, end);}\n+        catch(e) {} // Fails on Firefox when textarea isn't part of the document\n+      };\n+  }\n+  // IE model. Don't ask.\n+  else {\n+    selRange = function(te) {\n+      try {var range = te.ownerDocument.selection.createRange();}\n+      catch(e) {return null;}\n+      if (!range || range.parentElement() != te) return null;\n+      var val = te.value, len = val.length, localRange = te.createTextRange();\n+      localRange.moveToBookmark(range.getBookmark());\n+      var endRange = te.createTextRange();\n+      endRange.collapse(false);\n+\n+      if (localRange.compareEndPoints(\"StartToEnd\", endRange) > -1)\n+        return {start: len, end: len};\n+\n+      var start = -localRange.moveStart(\"character\", -len);\n+      for (var i = val.indexOf(\"\\r\"); i > -1 && i < start; i = val.indexOf(\"\\r\", i+1), start++) {}\n+\n+      if (localRange.compareEndPoints(\"EndToEnd\", endRange) > -1)\n+        return {start: start, end: len};\n+\n+      var end = -localRange.moveEnd(\"character\", -len);\n+      for (var i = val.indexOf(\"\\r\"); i > -1 && i < end; i = val.indexOf(\"\\r\", i+1), end++) {}\n+      return {start: start, end: end};\n+    };\n+    setSelRange = function(te, start, end) {\n+      var range = te.createTextRange();\n+      range.collapse(true);\n+      var endrange = range.duplicate();\n+      var newlines = 0, txt = te.value;\n+      for (var pos = txt.indexOf(\"\\n\"); pos > -1 && pos < start; pos = txt.indexOf(\"\\n\", pos + 1))\n+        ++newlines;\n+      range.move(\"character\", start - newlines);\n+      for (; pos > -1 && pos < end; pos = txt.indexOf(\"\\n\", pos + 1))\n+        ++newlines;\n+      endrange.move(\"character\", end - newlines);\n+      range.setEndPoint(\"EndToEnd\", endrange);\n+      range.select();\n+    };\n+  }\n+\n+  CodeMirror.defineMode(\"null\", function() {\n+    return {token: function(stream) {stream.skipToEnd();}};\n+  });\n+  CodeMirror.defineMIME(\"text/plain\", \"null\");\n+\n+  return CodeMirror;\n+})();"},{"sha":"c55a7179fe4991dfefcb9d6df894e8016159edc1","filename":"console/src/main/webapp/scripts/xmlpure.js","status":"added","additions":481,"deletions":0,"changes":481,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fc739b5ae16f10bc9ca952c1b97cd1420fbae5d6/console%2Fsrc%2Fmain%2Fwebapp%2Fscripts%2Fxmlpure.js","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fc739b5ae16f10bc9ca952c1b97cd1420fbae5d6/console%2Fsrc%2Fmain%2Fwebapp%2Fscripts%2Fxmlpure.js","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/console%2Fsrc%2Fmain%2Fwebapp%2Fscripts%2Fxmlpure.js?ref=fc739b5ae16f10bc9ca952c1b97cd1420fbae5d6","patch":"@@ -0,0 +1,481 @@\n+/**\n+ * xmlpure.js\n+ * \n+ * Building upon and improving the CodeMirror 2 XML parser\n+ * @author: Dror BG (deebug.dev@gmail.com)\n+ * @date: August, 2011\n+ */\n+\n+CodeMirror.defineMode(\"xmlpure\", function(config, parserConfig) {\n+    // constants\n+    var STYLE_ERROR = \"error\";\n+    var STYLE_INSTRUCTION = \"comment\";\n+    var STYLE_COMMENT = \"comment\";\n+    var STYLE_ELEMENT_NAME = \"tag\";\n+    var STYLE_ATTRIBUTE = \"attribute\";\n+    var STYLE_WORD = \"string\";\n+    var STYLE_TEXT = \"atom\";\n+\n+    var TAG_INSTRUCTION = \"!instruction\";\n+    var TAG_CDATA = \"!cdata\";\n+    var TAG_COMMENT = \"!comment\";\n+    var TAG_TEXT = \"!text\";\n+    \n+    var doNotIndent = {\n+        \"!cdata\": true,\n+        \"!comment\": true,\n+        \"!text\": true,\n+        \"!instruction\": true\n+    };\n+\n+    // options\n+    var indentUnit = config.indentUnit;\n+\n+    ///////////////////////////////////////////////////////////////////////////\n+    // helper functions\n+    \n+    // chain a parser to another parser\n+    function chain(stream, state, parser) {\n+        state.tokenize = parser;\n+        return parser(stream, state);\n+    }\n+    \n+    // parse a block (comment, CDATA or text)\n+    function inBlock(style, terminator, nextTokenize) {\n+        return function(stream, state) {\n+            while (!stream.eol()) {\n+                if (stream.match(terminator)) {\n+                    popContext(state);\n+                    state.tokenize = nextTokenize;\n+                    break;\n+                }\n+                stream.next();\n+            }\n+            return style;\n+        };\n+    }\n+    \n+    // go down a level in the document\n+    // (hint: look at who calls this function to know what the contexts are)\n+    function pushContext(state, tagName) {\n+        var noIndent = doNotIndent.hasOwnProperty(tagName) || (state.context && state.context.doIndent);\n+        var newContext = {\n+            tagName: tagName,\n+            prev: state.context,\n+            indent: state.context ? state.context.indent + indentUnit : 0,\n+            lineNumber: state.lineNumber,\n+            indented: state.indented,\n+            noIndent: noIndent\n+        };\n+        state.context = newContext;\n+    }\n+    \n+    // go up a level in the document\n+    function popContext(state) {\n+        if (state.context) {\n+            var oldContext = state.context;\n+            state.context = oldContext.prev;\n+            return oldContext;\n+        }\n+        \n+        // we shouldn't be here - it means we didn't have a context to pop\n+        return null;\n+    }\n+    \n+    // return true if the current token is seperated from the tokens before it\n+    // which means either this is the start of the line, or there is at least\n+    // one space or tab character behind the token\n+    // otherwise returns false\n+    function isTokenSeparated(stream) {\n+        return stream.sol() ||\n+            stream.string.charAt(stream.start - 1) == \" \" ||\n+            stream.string.charAt(stream.start - 1) == \"\\t\";\n+    }\n+    \n+    ///////////////////////////////////////////////////////////////////////////\n+    // context: document\n+    // \n+    // an XML document can contain:\n+    // - a single declaration (if defined, it must be the very first line)\n+    // - exactly one root element\n+    // @todo try to actually limit the number of root elements to 1\n+    // - zero or more comments\n+    function parseDocument(stream, state) {\n+        if(stream.eat(\"<\")) {\n+            if(stream.eat(\"?\")) {\n+                // processing instruction\n+                pushContext(state, TAG_INSTRUCTION);\n+                state.tokenize = parseProcessingInstructionStartTag;\n+                return STYLE_INSTRUCTION;\n+            } else if(stream.match(\"!--\")) {\n+                // new context: comment\n+                pushContext(state, TAG_COMMENT);\n+                return chain(stream, state, inBlock(STYLE_COMMENT, \"-->\", parseDocument));\n+            } else if(stream.eatSpace() || stream.eol() ) {\n+                stream.skipToEnd();\n+                return STYLE_ERROR;\n+            } else {\n+                // element\n+                state.tokenize = parseElementTagName;\n+                return STYLE_ELEMENT_NAME;\n+            }\n+        }\n+        \n+        // error on line\n+        stream.skipToEnd();\n+        return STYLE_ERROR;\n+    }\n+\n+    ///////////////////////////////////////////////////////////////////////////\n+    // context: XML element start-tag or end-tag\n+    //\n+    // - element start-tag can contain attributes\n+    // - element start-tag may self-close (or start an element block if it doesn't)\n+    // - element end-tag can contain only the tag name\n+    function parseElementTagName(stream, state) {\n+        // get the name of the tag\n+        var startPos = stream.pos;\n+        if(stream.match(/^[a-zA-Z_:][-a-zA-Z0-9_:.]*/)) {\n+            // element start-tag\n+            var tagName = stream.string.substring(startPos, stream.pos);\n+            pushContext(state, tagName);\n+            state.tokenize = parseElement;\n+            return STYLE_ELEMENT_NAME;\n+        } else if(stream.match(/^\\/[a-zA-Z_:][-a-zA-Z0-9_:.]*( )*>/)) {\n+            // element end-tag\n+            var endTagName = stream.string.substring(startPos + 1, stream.pos - 1).trim();\n+            var oldContext = popContext(state);\n+            state.tokenize = state.context == null ? parseDocument : parseElementBlock;\n+            if(oldContext == null || endTagName != oldContext.tagName) {\n+                // the start and end tag names should match - error\n+                return STYLE_ERROR;\n+            }\n+            return STYLE_ELEMENT_NAME;\n+        } else {\n+            // no tag name - error\n+            state.tokenize = state.context == null ? parseDocument : parseElementBlock;\n+            stream.eatWhile(/[^>]/);\n+            stream.eat(\">\");\n+            return STYLE_ERROR;\n+        }\n+        \n+        stream.skipToEnd();\n+        return null;\n+    }\n+    \n+    function parseElement(stream, state) {\n+        if(stream.match(/^\\/>/)) {\n+            // self-closing tag\n+            popContext(state);\n+            state.tokenize = state.context == null ? parseDocument : parseElementBlock;\n+            return STYLE_ELEMENT_NAME;\n+        } else if(stream.eat(/^>/)) {\n+            state.tokenize = parseElementBlock;\n+            return STYLE_ELEMENT_NAME;\n+        } else if(isTokenSeparated(stream) && stream.match(/^[a-zA-Z_:][-a-zA-Z0-9_:.]*( )*=/)) {\n+            // attribute\n+            state.tokenize = parseAttribute;\n+            return STYLE_ATTRIBUTE;\n+        }\n+        \n+        // no other options - this is an error\n+        state.tokenize = state.context == null ? parseDocument : parseDocument;\n+        stream.eatWhile(/[^>]/);\n+        stream.eat(\">\");\n+        return STYLE_ERROR;\n+    }\n+    \n+    ///////////////////////////////////////////////////////////////////////////\n+    // context: attribute\n+    // \n+    // attribute values may contain everything, except:\n+    // - the ending quote (with ' or \") - this marks the end of the value\n+    // - the character \"<\" - should never appear\n+    // - ampersand (\"&\") - unless it starts a reference: a string that ends with a semi-colon (\";\")\n+    // ---> note: this parser is lax in what may be put into a reference string,\n+    // ---> consult http://www.w3.org/TR/REC-xml/#NT-Reference if you want to make it tighter\n+    function parseAttribute(stream, state) {\n+        var quote = stream.next();\n+        if(quote != \"\\\"\" && quote != \"'\") {\n+            // attribute must be quoted\n+            stream.skipToEnd();\n+            state.tokenize = parseElement;\n+            return STYLE_ERROR;\n+        }\n+        \n+        state.tokParams.quote = quote;    \n+        state.tokenize = parseAttributeValue;\n+        return STYLE_WORD;\n+    }\n+\n+    // @todo: find out whether this attribute value spans multiple lines,\n+    //        and if so, push a context for it in order not to indent it\n+    //        (or something of the sort..)\n+    function parseAttributeValue(stream, state) {\n+        var ch = \"\";\n+        while(!stream.eol()) {\n+            ch = stream.next();\n+            if(ch == state.tokParams.quote) {\n+                // end quote found\n+                state.tokenize = parseElement;\n+                return STYLE_WORD;\n+            } else if(ch == \"<\") {\n+                // can't have less-than signs in an attribute value, ever\n+                stream.skipToEnd()\n+                state.tokenize = parseElement;\n+                return STYLE_ERROR;\n+            } else if(ch == \"&\") {\n+                // reference - look for a semi-colon, or return error if none found\n+                ch = stream.next();\n+                \n+                // make sure that semi-colon isn't right after the ampersand\n+                if(ch == ';') {\n+                    stream.skipToEnd()\n+                    state.tokenize = parseElement;\n+                    return STYLE_ERROR;\n+                }\n+                \n+                // make sure no less-than characters slipped in\n+                while(!stream.eol() && ch != \";\") {\n+                    if(ch == \"<\") {\n+                        // can't have less-than signs in an attribute value, ever\n+                        stream.skipToEnd()\n+                        state.tokenize = parseElement;\n+                        return STYLE_ERROR;\n+                    }\n+                    ch = stream.next();\n+                }\n+                if(stream.eol() && ch != \";\") {\n+                    // no ampersand found - error\n+                    stream.skipToEnd();\n+                    state.tokenize = parseElement;\n+                    return STYLE_ERROR;\n+                }                \n+            }\n+        }\n+        \n+        // attribute value continues to next line\n+        return STYLE_WORD;\n+    }\n+    \n+    ///////////////////////////////////////////////////////////////////////////\n+    // context: element block\n+    //\n+    // a block can contain:\n+    // - elements\n+    // - text\n+    // - CDATA sections\n+    // - comments\n+    function parseElementBlock(stream, state) {\n+        if(stream.eat(\"<\")) {\n+            if(stream.match(\"?\")) {\n+                pushContext(state, TAG_INSTRUCTION);\n+                state.tokenize = parseProcessingInstructionStartTag;\n+                return STYLE_INSTRUCTION;\n+            } else if(stream.match(\"!--\")) {\n+                // new context: comment\n+                pushContext(state, TAG_COMMENT);\n+                return chain(stream, state, inBlock(STYLE_COMMENT, \"-->\",\n+                    state.context == null ? parseDocument : parseElementBlock));\n+            } else if(stream.match(\"![CDATA[\")) {\n+                // new context: CDATA section\n+                pushContext(state, TAG_CDATA);\n+                return chain(stream, state, inBlock(STYLE_TEXT, \"]]>\",\n+                    state.context == null ? parseDocument : parseElementBlock));\n+            } else if(stream.eatSpace() || stream.eol() ) {\n+                stream.skipToEnd();\n+                return STYLE_ERROR;\n+            } else {\n+                // element\n+                state.tokenize = parseElementTagName;\n+                return STYLE_ELEMENT_NAME;\n+            }\n+        } else {\n+            // new context: text\n+            pushContext(state, TAG_TEXT);\n+            state.tokenize = parseText;\n+            return null;\n+        }\n+        \n+        state.tokenize = state.context == null ? parseDocument : parseElementBlock;\n+        stream.skipToEnd();\n+        return null;\n+    }\n+    \n+    function parseText(stream, state) {\n+        stream.eatWhile(/[^<]/);\n+        if(!stream.eol()) {\n+            // we cannot possibly be in the document context,\n+            // just inside an element block\n+            popContext(state);\n+            state.tokenize = parseElementBlock;\n+        }\n+        return STYLE_TEXT;\n+    }\n+\n+    ///////////////////////////////////////////////////////////////////////////\n+    // context: XML processing instructions\n+    //\n+    // XML processing instructions (PIs) allow documents to contain instructions for applications.\n+    // PI format: <?name data?>\n+    // - 'name' can be anything other than 'xml' (case-insensitive)\n+    // - 'data' can be anything which doesn't contain '?>'\n+    // XML declaration is a special PI (see XML declaration context below)\n+    function parseProcessingInstructionStartTag(stream, state) {\n+        if(stream.match(\"xml\", true, true)) {\n+            // xml declaration\n+            if(state.lineNumber > 1 || stream.pos > 5) {\n+                state.tokenize = parseDocument;\n+                stream.skipToEnd();\n+                return STYLE_ERROR;\n+            } else {\n+                state.tokenize = parseDeclarationVersion;\n+                return STYLE_INSTRUCTION;\n+            }\n+        }\n+\n+        // regular processing instruction\n+        if(isTokenSeparated(stream) || stream.match(\"?>\")) {\n+            // we have a space after the start-tag, or nothing but the end-tag\n+            // either way - error!\n+            state.tokenize = parseDocument;\n+            stream.skipToEnd();\n+            return STYLE_ERROR;\n+        }\n+\n+        state.tokenize = parseProcessingInstructionBody;\n+        return STYLE_INSTRUCTION;\n+    }\n+\n+    function parseProcessingInstructionBody(stream, state) {\n+        stream.eatWhile(/[^?]/);\n+        if(stream.eat(\"?\")) {\n+            if(stream.eat(\">\")) {\n+                popContext(state);\n+                state.tokenize = state.context == null ? parseDocument : parseElementBlock;\n+            }\n+        }\n+        return STYLE_INSTRUCTION;\n+    }\n+\n+    \n+    ///////////////////////////////////////////////////////////////////////////\n+    // context: XML declaration\n+    //\n+    // XML declaration is of the following format:\n+    // <?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\" ?>\n+    // - must start at the first character of the first line\n+    // - may span multiple lines\n+    // - must include 'version'\n+    // - may include 'encoding' and 'standalone' (in that order after 'version')\n+    // - attribute names must be lowercase\n+    // - cannot contain anything else on the line\n+    function parseDeclarationVersion(stream, state) {\n+        state.tokenize = parseDeclarationEncoding;\n+        \n+        if(isTokenSeparated(stream) && stream.match(/^version( )*=( )*\"([a-zA-Z0-9_.:]|\\-)+\"/)) {\n+            return STYLE_INSTRUCTION;\n+        }\n+        stream.skipToEnd();\n+        return STYLE_ERROR;\n+    }\n+\n+    function parseDeclarationEncoding(stream, state) {\n+        state.tokenize = parseDeclarationStandalone;\n+        \n+        if(isTokenSeparated(stream) && stream.match(/^encoding( )*=( )*\"[A-Za-z]([A-Za-z0-9._]|\\-)*\"/)) {\n+            return STYLE_INSTRUCTION;\n+        }\n+        return null;\n+    }\n+\n+    function parseDeclarationStandalone(stream, state) {\n+        state.tokenize = parseDeclarationEndTag;\n+        \n+        if(isTokenSeparated(stream) && stream.match(/^standalone( )*=( )*\"(yes|no)\"/)) {\n+            return STYLE_INSTRUCTION;\n+        }\n+        return null;\n+    }\n+\n+    function parseDeclarationEndTag(stream, state) {\n+        state.tokenize = parseDocument;\n+        \n+        if(stream.match(\"?>\") && stream.eol()) {\n+            popContext(state);\n+            return STYLE_INSTRUCTION;\n+        }\n+        stream.skipToEnd();\n+        return STYLE_ERROR;\n+    }\n+\n+    ///////////////////////////////////////////////////////////////////////////\n+    // returned object\n+    return {\n+        electricChars: \"/\",\n+        \n+        startState: function() {\n+            return {\n+                tokenize: parseDocument,\n+                tokParams: {},\n+                lineNumber: 0,\n+                lineError: false,\n+                context: null,\n+                indented: 0\n+            };\n+        },\n+\n+        token: function(stream, state) {\n+            if(stream.sol()) {\n+                // initialize a new line\n+                state.lineNumber++;\n+                state.lineError = false;\n+                state.indented = stream.indentation();\n+            }\n+\n+            // eat all (the spaces) you can\n+            if(stream.eatSpace()) return null;\n+\n+            // run the current tokenize function, according to the state\n+            var style = state.tokenize(stream, state);\n+            \n+            // is there an error somewhere in the line?\n+            state.lineError = (state.lineError || style == \"error\");\n+\n+            return style;\n+        },\n+        \n+        blankLine: function(state) {\n+            // blank lines are lines too!\n+            state.lineNumber++;\n+            state.lineError = false;\n+        },\n+        \n+        indent: function(state, textAfter) {\n+            if(state.context) {\n+                if(state.context.noIndent == true) {\n+                    // do not indent - no return value at all\n+                    return;\n+                }\n+                if(textAfter.match(/^<\\/.*/)) {\n+                    // eng-tag - indent back to last context\n+                    return state.context.indent;\n+                }\n+                // indent to last context + regular indent unit\n+                return state.context.indent + indentUnit;\n+            }\n+            return 0;\n+        },\n+        \n+        compareStates: function(a, b) {\n+            if (a.indented != b.indented) return false;\n+            for (var ca = a.context, cb = b.context; ; ca = ca.prev, cb = cb.prev) {\n+                if (!ca || !cb) return ca == cb;\n+                if (ca.tagName != cb.tagName) return false;\n+            }\n+        }\n+    };\n+});\n+\n+CodeMirror.defineMIME(\"application/xml\", \"purexml\");\n+CodeMirror.defineMIME(\"text/xml\", \"purexml\");"},{"sha":"f15d1d8cf12812993a9c1dabe52243122e9a1cff","filename":"console/src/test/java/org/syncope/console/ConfigurationTestITCase.java","status":"modified","additions":12,"deletions":2,"changes":14,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fc739b5ae16f10bc9ca952c1b97cd1420fbae5d6/console%2Fsrc%2Ftest%2Fjava%2Forg%2Fsyncope%2Fconsole%2FConfigurationTestITCase.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fc739b5ae16f10bc9ca952c1b97cd1420fbae5d6/console%2Fsrc%2Ftest%2Fjava%2Forg%2Fsyncope%2Fconsole%2FConfigurationTestITCase.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/console%2Fsrc%2Ftest%2Fjava%2Forg%2Fsyncope%2Fconsole%2FConfigurationTestITCase.java?ref=fc739b5ae16f10bc9ca952c1b97cd1420fbae5d6","patch":"@@ -60,6 +60,16 @@ public void browsePasswordPolicy() {\n         assertTrue(selenium.isTextPresent(\"new description\"));\n     }\n \n+    @Test\n+    public void browseWorkflowDef() {\n+        selenium.setSpeed(\"1000\");\n+\n+        selenium.click(\"css=img[alt=\\\"Configuration\\\"]\");\n+        selenium.waitForPageToLoad(\"30000\");\n+        selenium.click(\"//div[@id='tabs']/ul/li[3]/a/span\");\n+        assertTrue(selenium.isElementPresent(\"//*[@id=\\\"workflowDefArea\\\"]\"));\n+    }\n+\n     @Test\n     public void delete() {\n         selenium.click(\"css=img[alt=\\\"Configuration\\\"]\");\n@@ -80,8 +90,8 @@ public void setLogLevel() {\n \n         selenium.click(\"css=img[alt=\\\"Configuration\\\"]\");\n         selenium.waitForPageToLoad(\"30000\");\n-        selenium.click(\"//div[@id='tabs']/ul/li[3]/a/span\");\n-        selenium.select(\"//div[3]/div/span/table/tbody/tr/td[2]/select\",\n+        selenium.click(\"//div[@id='tabs']/ul/li[4]/a/span\");\n+        selenium.select(\"//div[4]/div/span/table/tbody/tr/td[2]/select\",\n                 \"label=ERROR\");\n         assertTrue(selenium.isTextPresent(\"Operation executed successfully\"));\n     }"},{"sha":"dfaaf6f32dc5b67487c10306c00f775665c6d4dd","filename":"core/src/main/java/org/syncope/core/rest/controller/ConfigurationController.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fc739b5ae16f10bc9ca952c1b97cd1420fbae5d6/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Frest%2Fcontroller%2FConfigurationController.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fc739b5ae16f10bc9ca952c1b97cd1420fbae5d6/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Frest%2Fcontroller%2FConfigurationController.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Frest%2Fcontroller%2FConfigurationController.java?ref=fc739b5ae16f10bc9ca952c1b97cd1420fbae5d6","patch":"@@ -194,7 +194,7 @@ public WorkflowDefinitionTO getDefinition()\n     }\n \n     @PreAuthorize(\"hasRole('WORKFLOW_DEF_UPDATE')\")\n-    @RequestMapping(method = RequestMethod.POST,\n+    @RequestMapping(method = RequestMethod.PUT,\n     value = \"/workflow/definition\")\n     @Transactional(rollbackFor = {Throwable.class})\n     public void updateDefinition("},{"sha":"843ae8e83c1397a982478649204eb9a93478e1fb","filename":"core/src/main/resources/content.xml","status":"modified","additions":3,"deletions":3,"changes":6,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fc739b5ae16f10bc9ca952c1b97cd1420fbae5d6/core%2Fsrc%2Fmain%2Fresources%2Fcontent.xml","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fc739b5ae16f10bc9ca952c1b97cd1420fbae5d6/core%2Fsrc%2Fmain%2Fresources%2Fcontent.xml","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fresources%2Fcontent.xml?ref=fc739b5ae16f10bc9ca952c1b97cd1420fbae5d6","patch":"@@ -15,9 +15,9 @@\n <dataset>\n     <SyncopeConf confKey=\"token.length\" confValue=\"256\"/>\n     <SyncopeConf confKey=\"token.expireTime\" confValue=\"60\"/>\n-    <SyncopeConf confKey=\"smtp.host\" confValue=\"${smtp.host}\"/>\n-    <SyncopeConf confKey=\"smtp.port\" confValue=\"${smtp.port}\"/>\n-    <SyncopeConf confKey=\"optin.email.from\" confValue=\"syncope@googlecode.com\"/>\n+    <SyncopeConf confKey=\"smtp.host\" confValue=\"smtp.ngi.it\"/>\n+    <SyncopeConf confKey=\"smtp.port\" confValue=\"25\"/>\n+    <SyncopeConf confKey=\"optin.email.from\" confValue=\"syncope@syncope-idm.org\"/>\n     <SyncopeConf confKey=\"optin.email.subject\" confValue=\"Welcome to Syncope!\"/>\n     <SyncopeConf confKey=\"connid.bundles.directory\" confValue=\"${bundles.directory}\"/>\n     <SyncopeConf confKey=\"password.cipher.algorithm\" confValue=\"MD5\"/>"},{"sha":"a31f07c25187dba9ccaeb519b015062ced0a92dd","filename":"core/src/main/resources/workflow.properties","status":"modified","additions":1,"deletions":4,"changes":5,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fc739b5ae16f10bc9ca952c1b97cd1420fbae5d6/core%2Fsrc%2Fmain%2Fresources%2Fworkflow.properties","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fc739b5ae16f10bc9ca952c1b97cd1420fbae5d6/core%2Fsrc%2Fmain%2Fresources%2Fworkflow.properties","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fresources%2Fworkflow.properties?ref=fc739b5ae16f10bc9ca952c1b97cd1420fbae5d6","patch":"@@ -1,5 +1,2 @@\n wfAdapter=org.syncope.core.workflow.ActivitiUserWorkflowAdapter\n-jobExecutorActivate=true\n-\n-smtp.host=smtp.ngi.it\n-smtp.port=25\n\\ No newline at end of file\n+jobExecutorActivate=true\n\\ No newline at end of file"},{"sha":"16be5a922a8f6d56a0933913aaaebbaf16b417f4","filename":"core/src/test/resources/content.xml","status":"modified","additions":3,"deletions":3,"changes":6,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fc739b5ae16f10bc9ca952c1b97cd1420fbae5d6/core%2Fsrc%2Ftest%2Fresources%2Fcontent.xml","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fc739b5ae16f10bc9ca952c1b97cd1420fbae5d6/core%2Fsrc%2Ftest%2Fresources%2Fcontent.xml","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Ftest%2Fresources%2Fcontent.xml?ref=fc739b5ae16f10bc9ca952c1b97cd1420fbae5d6","patch":"@@ -15,9 +15,9 @@\n <dataset>\n     <SyncopeConf confKey=\"token.length\" confValue=\"256\"/>\n     <SyncopeConf confKey=\"token.expireTime\" confValue=\"60\"/>\n-    <SyncopeConf confKey=\"smtp.host\" confValue=\"${smtp.host}\"/>\n-    <SyncopeConf confKey=\"smtp.port\" confValue=\"${smtp.port}\"/>\n-    <SyncopeConf confKey=\"optin.email.from\" confValue=\"syncope@googlecode.com\"/>\n+    <SyncopeConf confKey=\"smtp.host\" confValue=\"not-existing\"/>\n+    <SyncopeConf confKey=\"smtp.port\" confValue=\"25\"/>\n+    <SyncopeConf confKey=\"optin.email.from\" confValue=\"syncope@syncope-idm.org\"/>\n     <SyncopeConf confKey=\"optin.email.subject\" confValue=\"Welcome to Syncope!\"/>\n     <SyncopeConf confKey=\"connid.bundles.directory\" confValue=\"${bundles.directory}\"/>\n     <SyncopeConf confKey=\"password.cipher.algorithm\" confValue=\"MD5\"/>"},{"sha":"a95183230ab8451fd212d407d56747160ca4d1ef","filename":"core/src/test/resources/workflow.properties","status":"modified","additions":1,"deletions":4,"changes":5,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/fc739b5ae16f10bc9ca952c1b97cd1420fbae5d6/core%2Fsrc%2Ftest%2Fresources%2Fworkflow.properties","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/fc739b5ae16f10bc9ca952c1b97cd1420fbae5d6/core%2Fsrc%2Ftest%2Fresources%2Fworkflow.properties","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Ftest%2Fresources%2Fworkflow.properties?ref=fc739b5ae16f10bc9ca952c1b97cd1420fbae5d6","patch":"@@ -1,5 +1,2 @@\n wfAdapter=org.syncope.core.workflow.ActivitiUserWorkflowAdapter\n-jobExecutorActivate=false\n-\n-smtp.host=not-existing\n-smtp.port=25\n\\ No newline at end of file\n+jobExecutorActivate=false\n\\ No newline at end of file"}]}