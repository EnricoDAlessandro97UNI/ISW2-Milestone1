{"sha":"9894d78d3a18c7465657815890161bb2968c5b4f","node_id":"MDY6Q29tbWl0NjM2ODc5MDYyOjk4OTRkNzhkM2ExOGM3NDY1NjU3ODE1ODkwMTYxYmIyOTY4YzViNGY=","commit":{"author":{"name":"Unknown","email":"unknown@apache.org","date":"2011-07-27T14:59:24Z"},"committer":{"name":"Unknown","email":"unknown@apache.org","date":"2011-07-27T14:59:24Z"},"message":"the possibility to search users by derived attribute valu has been added\n\ngit-svn-id: https://svn.apache.org/repos/asf/incubator/syncope/trunk@1247050 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"a992339a2a14a9a985206fa9fb742fb8c1f04645","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/git/trees/a992339a2a14a9a985206fa9fb742fb8c1f04645"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/git/commits/9894d78d3a18c7465657815890161bb2968c5b4f","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/9894d78d3a18c7465657815890161bb2968c5b4f","html_url":"https://github.com/EnricoDAlessandro97UNI/syncope/commit/9894d78d3a18c7465657815890161bb2968c5b4f","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/9894d78d3a18c7465657815890161bb2968c5b4f/comments","author":null,"committer":null,"parents":[{"sha":"fc5cd61d84f7e69a393d45b62a9f6e36e99c5718","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718","html_url":"https://github.com/EnricoDAlessandro97UNI/syncope/commit/fc5cd61d84f7e69a393d45b62a9f6e36e99c5718"}],"stats":{"total":305,"additions":295,"deletions":10},"files":[{"sha":"c5de7072b73d5d64e3c62cd7944dbfb337e6e646","filename":"core/src/main/java/org/syncope/core/persistence/dao/UserDAO.java","status":"modified","additions":4,"deletions":0,"changes":4,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/9894d78d3a18c7465657815890161bb2968c5b4f/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2FUserDAO.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/9894d78d3a18c7465657815890161bb2968c5b4f/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2FUserDAO.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2FUserDAO.java?ref=9894d78d3a18c7465657815890161bb2968c5b4f","patch":"@@ -19,13 +19,17 @@\n import org.syncope.core.persistence.beans.user.SyncopeUser;\n import org.syncope.core.persistence.beans.user.UAttrValue;\n import org.syncope.core.persistence.validation.entity.InvalidEntityException;\n+import org.syncope.core.rest.controller.InvalidSearchConditionException;\n \n public interface UserDAO extends DAO {\n \n     SyncopeUser find(Long id);\n \n     SyncopeUser findByWorkflowId(Long workflowId);\n \n+    List<SyncopeUser> findByDerAttrValue(String schemaName, String value)\n+            throws InvalidSearchConditionException;\n+\n     List<SyncopeUser> findByAttrValue(String schemaName, UAttrValue attrValue);\n \n     SyncopeUser findByAttrUniqueValue(String schemaName,"},{"sha":"49ab1e19cfaec81fa23b32f39c45f4e7f225dbd0","filename":"core/src/main/java/org/syncope/core/persistence/dao/impl/UserDAOImpl.java","status":"modified","additions":256,"deletions":6,"changes":262,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/9894d78d3a18c7465657815890161bb2968c5b4f/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2Fimpl%2FUserDAOImpl.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/9894d78d3a18c7465657815890161bb2968c5b4f/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2Fimpl%2FUserDAOImpl.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2Fimpl%2FUserDAOImpl.java?ref=9894d78d3a18c7465657815890161bb2968c5b4f","patch":"@@ -14,33 +14,48 @@\n  */\n package org.syncope.core.persistence.dao.impl;\n \n+import java.io.StringReader;\n import java.util.ArrayList;\n import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n import java.util.List;\n import java.util.Set;\n+import java.util.regex.Pattern;\n import javax.persistence.CacheRetrieveMode;\n import javax.persistence.NoResultException;\n import javax.persistence.Query;\n import javax.persistence.TemporalType;\n+import org.apache.commons.jexl2.parser.Parser;\n+import org.apache.commons.jexl2.parser.ParserConstants;\n+import org.apache.commons.jexl2.parser.Token;\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.stereotype.Repository;\n+import org.springframework.util.StringUtils;\n import org.syncope.core.persistence.beans.AbstractAttrValue;\n import org.syncope.core.persistence.beans.AbstractVirAttr;\n import org.syncope.core.persistence.beans.membership.Membership;\n import org.syncope.core.persistence.beans.user.SyncopeUser;\n import org.syncope.core.persistence.beans.user.UAttrUniqueValue;\n import org.syncope.core.persistence.beans.user.UAttrValue;\n+import org.syncope.core.persistence.beans.user.UDerSchema;\n import org.syncope.core.persistence.beans.user.USchema;\n+import org.syncope.core.persistence.dao.DerSchemaDAO;\n import org.syncope.core.persistence.dao.SchemaDAO;\n import org.syncope.core.persistence.dao.RoleDAO;\n import org.syncope.core.persistence.dao.UserDAO;\n+import org.syncope.core.rest.controller.InvalidSearchConditionException;\n \n @Repository\n public class UserDAOImpl extends AbstractDAOImpl\n         implements UserDAO {\n \n     @Autowired\n     private SchemaDAO schemaDAO;\n+\n+    @Autowired\n+    private DerSchemaDAO derSchemaDAO;\n+\n     @Autowired\n     private RoleDAO roleDAO;\n \n@@ -55,8 +70,7 @@ public SyncopeUser find(final Long id) {\n \n         try {\n             return (SyncopeUser) query.getSingleResult();\n-        }\n-        catch (NoResultException e) {\n+        } catch (NoResultException e) {\n             return null;\n         }\n     }\n@@ -73,6 +87,66 @@ public SyncopeUser findByWorkflowId(final Long workflowId) {\n         return (SyncopeUser) query.getSingleResult();\n     }\n \n+    /**\n+     * Find users by derived attribute value.\n+     * This method could fail if one or more string literals contained into the\n+     * derived attribute value provided derive from identifier (schema name)\n+     * replacement. When you are going to specify a derived attribute expression\n+     * you must be quite sure that string literals used to build the expression\n+     * cannot be found into the attribute values used to replace attribute\n+     * schema names used as identifiers.\n+     * @param schemaName derived schema name.\n+     * @param value derived attribute value.\n+     * @return list of users.\n+     * @throws InvalidSearchConditionException in case of errors retrieving\n+     * schema names used to buid the derived schema expression.\n+     */\n+    @Override\n+    public List<SyncopeUser> findByDerAttrValue(\n+            final String schemaName, final String value)\n+            throws InvalidSearchConditionException {\n+\n+        UDerSchema schema = derSchemaDAO.find(schemaName, UDerSchema.class);\n+        if (schema == null) {\n+            LOG.error(\"Invalid schema name '{}'\", schemaName);\n+            return Collections.EMPTY_LIST;\n+        }\n+\n+        // query string\n+        final StringBuilder querystring = new StringBuilder();\n+\n+        for (String clause : getWhereClause(schema.getExpression(), value)) {\n+\n+            if (querystring.length() > 0) {\n+                querystring.append(\" INTERSECT \");\n+            }\n+\n+            querystring.append(\"SELECT a.owner_id \").\n+                    append(\"FROM uattr a, uattrvalue v, uschema s \").\n+                    append(\"WHERE \").append(clause);\n+\n+\n+        }\n+\n+        LOG.debug(\"Execute query {}\", querystring);\n+\n+        final Query query = entityManager.createNativeQuery(\n+                querystring.toString());\n+\n+        final List<SyncopeUser> result = new ArrayList<SyncopeUser>();\n+\n+        SyncopeUser user;\n+\n+        for (Object userId : query.getResultList()) {\n+            user = find(Long.parseLong(userId.toString()));\n+            if (!result.contains(user)) {\n+                result.add(user);\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n     @Override\n     public List<SyncopeUser> findByAttrValue(final String schemaName,\n             final UAttrValue attrValue) {\n@@ -189,7 +263,7 @@ public final List<SyncopeUser> findAll(final Set<Long> adminRoles,\n         final Query query = entityManager.createNativeQuery(\n                 getFindAllQuery(adminRoles).toString());\n \n-        query.setFirstResult(itemsPerPage * ( page <= 0 ? 0 : page - 1 ));\n+        query.setFirstResult(itemsPerPage * (page <= 0 ? 0 : page - 1));\n \n         if (itemsPerPage > 0) {\n             query.setMaxResults(itemsPerPage);\n@@ -202,7 +276,7 @@ public final List<SyncopeUser> findAll(final Set<Long> adminRoles,\n         if (resultList != null) {\n             for (Object userId : resultList) {\n                 if (userId instanceof Object[]) {\n-                    userIds.add((Number) ( (Object[]) userId )[0]);\n+                    userIds.add((Number) ((Object[]) userId)[0]);\n                 } else {\n                     userIds.add((Number) userId);\n                 }\n@@ -214,7 +288,7 @@ public final List<SyncopeUser> findAll(final Set<Long> adminRoles,\n \n         SyncopeUser user;\n         for (Object userId : userIds) {\n-            user = find(( (Number) userId ).longValue());\n+            user = find(((Number) userId).longValue());\n             if (user == null) {\n                 LOG.error(\"Could not find user with id {}, \"\n                         + \"even though returned by the native query\", userId);\n@@ -235,7 +309,7 @@ public final Integer count(final Set<Long> adminRoles) {\n         Query countQuery =\n                 entityManager.createNativeQuery(queryString.toString());\n \n-        return ( (Number) countQuery.getSingleResult() ).intValue();\n+        return ((Number) countQuery.getSingleResult()).intValue();\n     }\n \n     @Override\n@@ -278,4 +352,180 @@ public void delete(final SyncopeUser user) {\n \n         entityManager.remove(user);\n     }\n+\n+    /**\n+     * Generate one where clause for each different attribute schema into the\n+     * derived schema expression provided.\n+     * @param expression derived schema expression.\n+     * @param value derived attribute value.\n+     * @return where clauses to use to build the query.\n+     * @throws InvalidSearchConditionException in case of errors retrieving\n+     * identifiers.\n+     */\n+    private Set<String> getWhereClause(\n+            final String expression, final String value)\n+            throws InvalidSearchConditionException {\n+        final Parser parser = new Parser(new StringReader(expression));\n+\n+        // Schema names\n+        final List<String> identifiers = new ArrayList<String>();\n+\n+        // Literals\n+        final List<String> literals = new ArrayList<String>();\n+\n+        // Get schema names and literals\n+        Token token;\n+        while ((token = parser.getNextToken()) != null\n+                && StringUtils.hasText(token.toString())) {\n+\n+            if (token.kind == ParserConstants.STRING_LITERAL) {\n+                literals.add(token.toString().\n+                        substring(1, token.toString().length() - 1));\n+            }\n+\n+            if (token.kind == ParserConstants.IDENTIFIER) {\n+                identifiers.add(token.toString());\n+            }\n+        }\n+\n+        // Sort literals in order to process later literals included into others\n+        Collections.sort(literals, new Comparator<String>() {\n+\n+            @Override\n+            public int compare(String t, String t1) {\n+                if (t == null && t1 == null) {\n+                    return 0;\n+                }\n+\n+                if (t != null && t1 == null) {\n+                    return -1;\n+                }\n+\n+                if (t == null && t1 != null) {\n+                    return 1;\n+                }\n+\n+                if (t.length() == t1.length()) {\n+                    return 0;\n+                }\n+\n+                if (t.length() > t1.length()) {\n+                    return -1;\n+                } else {\n+                    return 1;\n+                }\n+            }\n+        });\n+\n+        // Split value on provided literals\n+        final List<String> attrValues = split(value, literals);\n+\n+        if (attrValues.size() != identifiers.size()) {\n+            LOG.error(\"Ambiguous jexl expression resolution.\");\n+            throw new InvalidSearchConditionException(\n+                    \"literals and values have different size\");\n+        }\n+\n+        // clauses to be used with INTERSECTed queries\n+        final Set<String> clauses = new HashSet<String>();\n+\n+        // builder to build the clauses\n+        final StringBuilder bld = new StringBuilder();\n+\n+        // Contains used identifiers in order to avoid replications\n+        final Set<String> used = new HashSet<String>();\n+\n+        USchema schema;\n+\n+        // Create several clauses: one for eanch identifiers\n+        for (int i = 0; i < identifiers.size(); i++) {\n+            if (!used.contains(identifiers.get(i))) {\n+\n+                // verify schema existence and get schema type\n+                schema = schemaDAO.find(identifiers.get(i), USchema.class);\n+                if (schema == null) {\n+                    LOG.error(\"Invalid schema name '{}'\", identifiers.get(i));\n+                    throw new InvalidSearchConditionException(\n+                            \"Invalid schema name \" + identifiers.get(i));\n+                }\n+\n+                // clear builder\n+                bld.delete(0, bld.length());\n+\n+                bld.append(\"(\");\n+\n+                // set schema name\n+                bld.append(\"s.name = '\").\n+                        append(identifiers.get(i)).append(\"'\");\n+\n+                bld.append(\" AND \");\n+\n+                bld.append(\"s.name = a.schema_name\").append(\" AND \");\n+\n+                bld.append(\"a.id = v.attribute_id\");\n+\n+                bld.append(\" AND \");\n+\n+                // use a value clause different for eanch different schema type\n+                switch (schema.getType()) {\n+                    case Boolean:\n+                        bld.append(\"v.booleanValue = '\").\n+                                append(attrValues.get(i)).append(\"'\");\n+                        break;\n+                    case Long:\n+                        bld.append(\"v.longValue = \").\n+                                append(attrValues.get(i));\n+                        break;\n+                    case Double:\n+                        bld.append(\"v.doubleValue = \").\n+                                append(attrValues.get(i));\n+                        break;\n+                    case Date:\n+                        bld.append(\"v.dateValue = '\").\n+                                append(attrValues.get(i)).append(\"'\");\n+                        break;\n+                    default:\n+                        bld.append(\"v.stringValue = '\").\n+                                append(attrValues.get(i)).append(\"'\");\n+                }\n+\n+                bld.append(\")\");\n+\n+                used.add(identifiers.get(i));\n+\n+                clauses.add(bld.toString());\n+            }\n+        }\n+\n+        LOG.debug(\"Generated where clauses {}\", clauses);\n+\n+        return clauses;\n+    }\n+\n+    /**\n+     * Split an attribute value recurring on provided literals/tokens.\n+     * @param attrValue value to be splitted.\n+     * @param literals literals/tokens.\n+     * @return\n+     */\n+    private List<String> split(\n+            final String attrValue,\n+            final List<String> literals) {\n+\n+        final List<String> attrValues = new ArrayList<String>();\n+\n+        if (literals.isEmpty()) {\n+            attrValues.add(attrValue);\n+        } else {\n+\n+            for (String token :\n+                    attrValue.split(Pattern.quote(literals.get(0)))) {\n+\n+                attrValues.addAll(\n+                        split(token, literals.subList(1, literals.size())));\n+            }\n+        }\n+\n+        return attrValues;\n+    }\n }"},{"sha":"72dca39afb786a454dfa0877c14bd8faba47607f","filename":"core/src/main/java/org/syncope/core/rest/controller/InvalidSearchConditionException.java","status":"modified","additions":7,"deletions":0,"changes":7,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/9894d78d3a18c7465657815890161bb2968c5b4f/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Frest%2Fcontroller%2FInvalidSearchConditionException.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/9894d78d3a18c7465657815890161bb2968c5b4f/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Frest%2Fcontroller%2FInvalidSearchConditionException.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Frest%2Fcontroller%2FInvalidSearchConditionException.java?ref=9894d78d3a18c7465657815890161bb2968c5b4f","patch":"@@ -15,4 +15,11 @@\n package org.syncope.core.rest.controller;\n \n public class InvalidSearchConditionException extends Exception {\n+\n+    public InvalidSearchConditionException() {\n+    }\n+\n+    public InvalidSearchConditionException(String string) {\n+        super(string);\n+    }\n }"},{"sha":"c0029d234111941db2ce6c8b4af2678e4f0699ef","filename":"core/src/main/java/org/syncope/core/rest/controller/UserController.java","status":"modified","additions":1,"deletions":2,"changes":3,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/9894d78d3a18c7465657815890161bb2968c5b4f/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Frest%2Fcontroller%2FUserController.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/9894d78d3a18c7465657815890161bb2968c5b4f/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Frest%2Fcontroller%2FUserController.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fsyncope%2Fcore%2Frest%2Fcontroller%2FUserController.java?ref=9894d78d3a18c7465657815890161bb2968c5b4f","patch":"@@ -343,8 +343,7 @@ public List<UserTO> search(@RequestBody NodeCond searchCondition)\n         }\n \n         List<SyncopeUser> matchingUsers = userSearchDAO.search(\n-                EntitlementUtil.getRoleIds(EntitlementUtil.\n-                getOwnedEntitlementNames()), searchCondition);\n+                EntitlementUtil.getRoleIds(EntitlementUtil.getOwnedEntitlementNames()), searchCondition);\n         List<UserTO> result = new ArrayList<UserTO>(matchingUsers.size());\n         for (SyncopeUser user : matchingUsers) {\n             result.add(userDataBinder.getUserTO(user, workflow));"},{"sha":"9089e84effe94d8e4baf333d85ba41e058d95082","filename":"core/src/test/java/org/syncope/core/persistence/dao/DerSchemaTest.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/9894d78d3a18c7465657815890161bb2968c5b4f/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2FDerSchemaTest.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/9894d78d3a18c7465657815890161bb2968c5b4f/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2FDerSchemaTest.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2FDerSchemaTest.java?ref=9894d78d3a18c7465657815890161bb2968c5b4f","patch":"@@ -37,7 +37,7 @@ public class DerSchemaTest extends AbstractTest {\n     public final void findAll() {\n         List<UDerSchema> list =\n                 derSchemaDAO.findAll(UDerSchema.class);\n-        assertEquals(1, list.size());\n+        assertEquals(2, list.size());\n     }\n \n     @Test"},{"sha":"655a6668a71573e7fd9b8922689adc38e0d89a8a","filename":"core/src/test/java/org/syncope/core/persistence/dao/UserTest.java","status":"modified","additions":24,"deletions":0,"changes":24,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/9894d78d3a18c7465657815890161bb2968c5b4f/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2FUserTest.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/9894d78d3a18c7465657815890161bb2968c5b4f/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2FUserTest.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fsyncope%2Fcore%2Fpersistence%2Fdao%2FUserTest.java?ref=9894d78d3a18c7465657815890161bb2968c5b4f","patch":"@@ -20,10 +20,12 @@\n import java.util.Set;\n import org.junit.Test;\n import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.test.annotation.ExpectedException;\n import org.springframework.transaction.annotation.Transactional;\n import org.syncope.core.persistence.beans.user.SyncopeUser;\n import org.syncope.core.persistence.AbstractTest;\n import org.syncope.core.persistence.beans.user.UAttrValue;\n+import org.syncope.core.rest.controller.InvalidSearchConditionException;\n import org.syncope.core.util.EntitlementUtil;\n import org.syncope.types.CipherAlgorithm;\n \n@@ -73,6 +75,28 @@ public final void findAllByPageAndSize() {\n         assertEquals(\"did not get expected number of users \", 0, list.size());\n     }\n \n+    @Test\n+    public final void findByDerAttributeValue()\n+            throws InvalidSearchConditionException {\n+        final List<SyncopeUser> list = userDAO.findByDerAttrValue(\n+                \"cn\", \"Doe, John\");\n+        assertEquals(\"did not get expected number of users \", 1, list.size());\n+    }\n+\n+    @Test\n+    @ExpectedException(value = InvalidSearchConditionException.class)\n+    public final void findByInvalidDerAttrValue()\n+            throws InvalidSearchConditionException {\n+        userDAO.findByDerAttrValue(\"cn\", \"Antonio, Maria, Rossi\");\n+    }\n+\n+    @Test\n+    @ExpectedException(value = InvalidSearchConditionException.class)\n+    public final void findByInvalidDerAttrExpression()\n+            throws InvalidSearchConditionException {\n+        userDAO.findByDerAttrValue(\"noschema\", \"Antonio, Maria\");\n+    }\n+\n     @Test\n     public final void findByAttributeValue() {\n         final UAttrValue usernameValue = new UAttrValue();"},{"sha":"e0601d9278fa3a2142d34e424fa5603fd20e77fe","filename":"core/src/test/java/org/syncope/core/rest/UserTestITCase.java","status":"modified","additions":0,"deletions":1,"changes":1,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/9894d78d3a18c7465657815890161bb2968c5b4f/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fsyncope%2Fcore%2Frest%2FUserTestITCase.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/9894d78d3a18c7465657815890161bb2968c5b4f/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fsyncope%2Fcore%2Frest%2FUserTestITCase.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fsyncope%2Fcore%2Frest%2FUserTestITCase.java?ref=9894d78d3a18c7465657815890161bb2968c5b4f","patch":"@@ -24,7 +24,6 @@\n import java.util.HashSet;\n import java.util.List;\n import java.util.Set;\n-import org.junit.Ignore;\n import org.junit.Test;\n import org.springframework.http.HttpStatus;\n import org.springframework.test.annotation.ExpectedException;"},{"sha":"e26a7e27570b4e0b3f6842457f146cbd3c21f66d","filename":"core/src/test/resources/content.xml","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/9894d78d3a18c7465657815890161bb2968c5b4f/core%2Fsrc%2Ftest%2Fresources%2Fcontent.xml","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/9894d78d3a18c7465657815890161bb2968c5b4f/core%2Fsrc%2Ftest%2Fresources%2Fcontent.xml","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Ftest%2Fresources%2Fcontent.xml?ref=9894d78d3a18c7465657815890161bb2968c5b4f","patch":"@@ -180,6 +180,8 @@\n     <UDerSchema name=\"cn\" expression=\"surname + ', ' + firstname\"/>\n     <UDerAttr id=\"1000\" derivedSchema_name=\"cn\" owner_id=\"3\"/>\n \n+    <UDerSchema name=\"noschema\" expression=\"surname + ', ' + notfound\"/>\n+\n     <MVirSchema name=\"mvirtualdata\"/>\n     <RVirSchema name=\"rvirtualdata\"/>\n     <RVirAttr id=\"1000\" virtualSchema_name=\"rvirtualdata\" owner_id=\"4\"/>"}]}