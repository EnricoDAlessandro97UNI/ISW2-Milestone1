{"sha":"99369c3115b9feec77bebff5fbbb2813d72aedf5","node_id":"MDY6Q29tbWl0NjM2ODc5MDYyOjk5MzY5YzMxMTViOWZlZWM3N2JlYmZmNWZiYmIyODEzZDcyYWVkZjU=","commit":{"author":{"name":"Francesco Chicchiriccò","email":"ilgrosso@apache.org","date":"2015-01-08T13:16:57Z"},"committer":{"name":"Francesco Chicchiriccò","email":"ilgrosso@apache.org","date":"2015-01-08T13:16:57Z"},"message":"[SYNCOPE-620] server logic in, tests missing","tree":{"sha":"606bf484885bf985a939be83a2615345544de197","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/git/trees/606bf484885bf985a939be83a2615345544de197"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/git/commits/99369c3115b9feec77bebff5fbbb2813d72aedf5","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/99369c3115b9feec77bebff5fbbb2813d72aedf5","html_url":"https://github.com/EnricoDAlessandro97UNI/syncope/commit/99369c3115b9feec77bebff5fbbb2813d72aedf5","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/99369c3115b9feec77bebff5fbbb2813d72aedf5/comments","author":{"login":"ilgrosso","id":1064664,"node_id":"MDQ6VXNlcjEwNjQ2NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/1064664?v=4","gravatar_id":"","url":"https://api.github.com/users/ilgrosso","html_url":"https://github.com/ilgrosso","followers_url":"https://api.github.com/users/ilgrosso/followers","following_url":"https://api.github.com/users/ilgrosso/following{/other_user}","gists_url":"https://api.github.com/users/ilgrosso/gists{/gist_id}","starred_url":"https://api.github.com/users/ilgrosso/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ilgrosso/subscriptions","organizations_url":"https://api.github.com/users/ilgrosso/orgs","repos_url":"https://api.github.com/users/ilgrosso/repos","events_url":"https://api.github.com/users/ilgrosso/events{/privacy}","received_events_url":"https://api.github.com/users/ilgrosso/received_events","type":"User","site_admin":false},"committer":{"login":"ilgrosso","id":1064664,"node_id":"MDQ6VXNlcjEwNjQ2NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/1064664?v=4","gravatar_id":"","url":"https://api.github.com/users/ilgrosso","html_url":"https://github.com/ilgrosso","followers_url":"https://api.github.com/users/ilgrosso/followers","following_url":"https://api.github.com/users/ilgrosso/following{/other_user}","gists_url":"https://api.github.com/users/ilgrosso/gists{/gist_id}","starred_url":"https://api.github.com/users/ilgrosso/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ilgrosso/subscriptions","organizations_url":"https://api.github.com/users/ilgrosso/orgs","repos_url":"https://api.github.com/users/ilgrosso/repos","events_url":"https://api.github.com/users/ilgrosso/events{/privacy}","received_events_url":"https://api.github.com/users/ilgrosso/received_events","type":"User","site_admin":false},"parents":[{"sha":"fc8761c33fd8bc9aebd77ff48516b94d981db4f4","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/fc8761c33fd8bc9aebd77ff48516b94d981db4f4","html_url":"https://github.com/EnricoDAlessandro97UNI/syncope/commit/fc8761c33fd8bc9aebd77ff48516b94d981db4f4"}],"stats":{"total":22773,"additions":22591,"deletions":182},"files":[{"sha":"9b1220e71cdbddb5856ae0ebcb1fb2d2165ae646","filename":"core/src/main/java/org/apache/syncope/core/rest/controller/RoleController.java","status":"modified","additions":2,"deletions":10,"changes":12,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Frest%2Fcontroller%2FRoleController.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Frest%2Fcontroller%2FRoleController.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Frest%2Fcontroller%2FRoleController.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -18,13 +18,10 @@\n  */\n package org.apache.syncope.core.rest.controller;\n \n-import static org.apache.syncope.core.rest.controller.AbstractController.LOG;\n-\n import java.lang.reflect.Method;\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n-import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n@@ -36,26 +33,21 @@\n import org.apache.syncope.common.types.ClientExceptionType;\n import org.apache.syncope.common.SyncopeClientException;\n import org.apache.syncope.common.to.PropagationStatus;\n-import org.apache.syncope.core.provisioning.ProvisioningManager;\n import org.apache.syncope.core.provisioning.RoleProvisioningManager;\n import org.apache.syncope.common.reqres.BulkAction;\n import org.apache.syncope.common.reqres.BulkActionResult;\n import org.apache.syncope.common.types.SubjectType;\n-import org.apache.syncope.core.persistence.beans.PropagationTask;\n import org.apache.syncope.core.persistence.beans.role.SyncopeRole;\n import org.apache.syncope.core.persistence.beans.user.SyncopeUser;\n import org.apache.syncope.core.persistence.dao.SubjectSearchDAO;\n import org.apache.syncope.core.persistence.dao.NotFoundException;\n import org.apache.syncope.core.persistence.dao.RoleDAO;\n import org.apache.syncope.core.persistence.dao.UserDAO;\n import org.apache.syncope.core.persistence.dao.search.OrderByClause;\n-import org.apache.syncope.core.propagation.PropagationException;\n-import org.apache.syncope.core.propagation.PropagationReporter;\n import org.apache.syncope.core.propagation.PropagationTaskExecutor;\n import org.apache.syncope.core.propagation.impl.PropagationManager;\n import org.apache.syncope.core.rest.data.AttributableTransformer;\n import org.apache.syncope.core.rest.data.RoleDataBinder;\n-import org.apache.syncope.core.util.ApplicationContextProvider;\n import org.apache.syncope.core.util.EntitlementUtil;\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.security.access.prepost.PreAuthorize;\n@@ -94,9 +86,9 @@ public class RoleController extends AbstractSubjectController<RoleTO, RoleMod> {\n     protected AttributableTransformer attrTransformer;\n \n     @Resource(name = \"anonymousUser\")\n-    private String anonymousUser;\n+    protected String anonymousUser;\n \n-    @Resource(name = \"roleProvisioningManager\")\n+    @Autowired\n     protected RoleProvisioningManager provisioningManager;\n \n     @PreAuthorize(\"hasAnyRole('ROLE_READ', T(org.apache.syncope.common.SyncopeConstants).ANONYMOUS_ENTITLEMENT)\")"},{"sha":"ad51d98206bcad72a74a1a947a530a216c34f03b","filename":"syncope620/common/lib/pom.xml","status":"modified","additions":10,"deletions":0,"changes":10,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fpom.xml","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fpom.xml","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fcommon%2Flib%2Fpom.xml?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -34,6 +34,16 @@ under the License.\n   <packaging>jar</packaging>\n \n   <dependencies>\n+    <dependency>\n+      <groupId>javax.ws.rs</groupId>\n+      <artifactId>javax.ws.rs-api</artifactId>\n+    </dependency>\n+    \n+    <dependency>\n+      <groupId>org.apache.cxf</groupId>\n+      <artifactId>cxf-rt-rs-extension-search</artifactId>\n+    </dependency>\n+\n     <dependency>\n       <groupId>com.fasterxml.jackson.core</groupId>\n       <artifactId>jackson-annotations</artifactId>"},{"sha":"8a6d9c4cf2ebac4684c3ff3b64a4e8d3746fb363","filename":"syncope620/common/lib/src/main/java/org/apache/syncope/common/lib/AbstractBaseBean.java","status":"modified","additions":6,"deletions":1,"changes":7,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2FAbstractBaseBean.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2FAbstractBaseBean.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2FAbstractBaseBean.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -19,15 +19,20 @@\n package org.apache.syncope.common.lib;\n \n import java.io.Serializable;\n+import javax.xml.bind.annotation.XmlSeeAlso;\n import javax.xml.bind.annotation.XmlType;\n import org.apache.commons.lang3.builder.EqualsBuilder;\n import org.apache.commons.lang3.builder.HashCodeBuilder;\n import org.apache.commons.lang3.builder.ReflectionToStringBuilder;\n import org.apache.commons.lang3.builder.ToStringStyle;\n+import org.apache.syncope.common.lib.to.AbstractTaskTO;\n+import org.apache.syncope.common.lib.to.ReportTO;\n+import org.apache.syncope.common.lib.to.RoleTO;\n+import org.apache.syncope.common.lib.to.UserTO;\n \n @XmlType\n // Reporting here only classes used via PagedResult\n-//@XmlSeeAlso({ AbstractTaskTO.class, ReportTO.class, RoleTO.class, UserTO.class })\n+@XmlSeeAlso({ AbstractTaskTO.class, ReportTO.class, RoleTO.class, UserTO.class })\n public abstract class AbstractBaseBean implements Serializable {\n \n     private static final long serialVersionUID = 3119542005279892164L;"},{"sha":"983cee42e28730e45b06bbfd564df3f5719350d1","filename":"syncope620/common/lib/src/main/java/org/apache/syncope/common/lib/AttributableOperations.java","status":"added","additions":508,"deletions":0,"changes":508,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2FAttributableOperations.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2FAttributableOperations.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2FAttributableOperations.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,508 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.common.lib;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.apache.commons.lang3.SerializationUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.syncope.common.lib.mod.AbstractAttributableMod;\n+import org.apache.syncope.common.lib.mod.AbstractSubjectMod;\n+import org.apache.syncope.common.lib.mod.AttrMod;\n+import org.apache.syncope.common.lib.mod.MembershipMod;\n+import org.apache.syncope.common.lib.mod.ReferenceMod;\n+import org.apache.syncope.common.lib.mod.RoleMod;\n+import org.apache.syncope.common.lib.mod.UserMod;\n+import org.apache.syncope.common.lib.to.AbstractAttributableTO;\n+import org.apache.syncope.common.lib.to.AbstractSubjectTO;\n+import org.apache.syncope.common.lib.to.AttrTO;\n+import org.apache.syncope.common.lib.to.MembershipTO;\n+import org.apache.syncope.common.lib.to.RoleTO;\n+import org.apache.syncope.common.lib.to.UserTO;\n+\n+/**\n+ * Utility class for manipulating classes extending AbstractAttributableTO and AbstractAttributableMod.\n+ *\n+ * @see AbstractAttributableTO\n+ * @see AbstractAttributableMod\n+ */\n+public final class AttributableOperations {\n+\n+    private AttributableOperations() {\n+        // empty constructor for static utility classes\n+    }\n+\n+    private static void populate(final Map<String, AttrTO> updatedAttrs,\n+            final Map<String, AttrTO> originalAttrs, final AbstractAttributableMod result) {\n+\n+        populate(updatedAttrs, originalAttrs, result, false);\n+    }\n+\n+    private static void populate(final Map<String, AttrTO> updatedAttrs,\n+            final Map<String, AttrTO> originalAttrs, final AbstractAttributableMod result,\n+            final boolean virtuals) {\n+\n+        for (Map.Entry<String, AttrTO> entry : updatedAttrs.entrySet()) {\n+            AttrMod mod = new AttrMod();\n+            mod.setSchema(entry.getKey());\n+\n+            Set<String> updatedValues = new HashSet<String>(entry.getValue().getValues());\n+\n+            Set<String> originalValues = originalAttrs.containsKey(entry.getKey())\n+                    ? new HashSet<String>(originalAttrs.get(entry.getKey()).getValues())\n+                    : Collections.<String>emptySet();\n+\n+            if (!originalAttrs.containsKey(entry.getKey())) {\n+                // SYNCOPE-459: take care of user virtual attributes without any value\n+                updatedValues.remove(\"\");\n+                mod.getValuesToBeAdded().addAll(new ArrayList<String>(updatedValues));\n+\n+                if (virtuals) {\n+                    result.getVirAttrsToUpdate().add(mod);\n+                } else {\n+                    result.getAttrsToUpdate().add(mod);\n+                }\n+            } else if (!updatedValues.equals(originalValues)) {\n+                // avoid unwanted inputs\n+                updatedValues.remove(\"\");\n+                if (!entry.getValue().isReadonly()) {\n+                    mod.getValuesToBeAdded().addAll(updatedValues);\n+\n+                    if (!mod.isEmpty()) {\n+                        if (virtuals) {\n+                            result.getVirAttrsToRemove().add(mod.getSchema());\n+                        } else {\n+                            result.getAttrsToRemove().add(mod.getSchema());\n+                        }\n+                    }\n+                }\n+\n+                mod.getValuesToBeRemoved().addAll(originalValues);\n+\n+                if (!mod.isEmpty()) {\n+                    if (virtuals) {\n+                        result.getVirAttrsToUpdate().add(mod);\n+                    } else {\n+                        result.getAttrsToUpdate().add(mod);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void diff(\n+            final AbstractAttributableTO updated,\n+            final AbstractAttributableTO original,\n+            final AbstractAttributableMod result,\n+            final boolean incremental) {\n+\n+        // 1. check same id\n+        if (updated.getKey() != original.getKey()) {\n+            throw new IllegalArgumentException(\"AttributableTO's id must be the same\");\n+        }\n+        result.setKey(updated.getKey());\n+\n+        // 2. attributes\n+        Map<String, AttrTO> updatedAttrs = new HashMap<>(updated.getAttrMap());\n+        Map<String, AttrTO> originalAttrs = new HashMap<>(original.getAttrMap());\n+\n+        Set<String> originalAttrNames = new HashSet<>(originalAttrs.keySet());\n+        originalAttrNames.removeAll(updatedAttrs.keySet());\n+\n+        if (!incremental) {\n+            result.getAttrsToRemove().clear();\n+            result.getAttrsToRemove().addAll(originalAttrNames);\n+        }\n+\n+        Set<String> emptyUpdatedAttrs = new HashSet<>();\n+        for (Map.Entry<String, AttrTO> entry : updatedAttrs.entrySet()) {\n+            if (entry.getValue().getValues() == null || entry.getValue().getValues().isEmpty()) {\n+\n+                emptyUpdatedAttrs.add(entry.getKey());\n+            }\n+        }\n+        for (String emptyUpdatedAttr : emptyUpdatedAttrs) {\n+            updatedAttrs.remove(emptyUpdatedAttr);\n+            result.getAttrsToRemove().add(emptyUpdatedAttr);\n+        }\n+\n+        populate(updatedAttrs, originalAttrs, result);\n+\n+        // 3. derived attributes\n+        updatedAttrs = updated.getDerAttrMap();\n+        originalAttrs = original.getDerAttrMap();\n+\n+        originalAttrNames = new HashSet<>(originalAttrs.keySet());\n+        originalAttrNames.removeAll(updatedAttrs.keySet());\n+\n+        if (!incremental) {\n+            result.getDerAttrsToRemove().clear();\n+            result.getDerAttrsToRemove().addAll(originalAttrNames);\n+        }\n+\n+        Set<String> updatedAttrNames = new HashSet<>(updatedAttrs.keySet());\n+        updatedAttrNames.removeAll(originalAttrs.keySet());\n+        result.getDerAttrsToAdd().clear();\n+        result.getDerAttrsToAdd().addAll(updatedAttrNames);\n+\n+        // 4. virtual attributes\n+        updatedAttrs = updated.getVirAttrMap();\n+        originalAttrs = original.getVirAttrMap();\n+\n+        originalAttrNames = new HashSet<>(originalAttrs.keySet());\n+        originalAttrNames.removeAll(updatedAttrs.keySet());\n+\n+        if (!incremental) {\n+            result.getVirAttrsToRemove().clear();\n+            result.getVirAttrsToRemove().addAll(originalAttrNames);\n+        }\n+\n+        populate(updatedAttrs, originalAttrs, result, true);\n+\n+        // 5. resources\n+        if (original instanceof AbstractSubjectTO && updated instanceof AbstractSubjectTO\n+                && result instanceof AbstractSubjectMod) {\n+\n+            Set<String> updatedRes = new HashSet<>(((AbstractSubjectTO) updated).getResources());\n+            Set<String> originalRes = new HashSet<>(((AbstractSubjectTO) original).getResources());\n+\n+            updatedRes.removeAll(originalRes);\n+            ((AbstractSubjectMod) result).getResourcesToAdd().clear();\n+            ((AbstractSubjectMod) result).getResourcesToAdd().addAll(updatedRes);\n+\n+            originalRes.removeAll(((AbstractSubjectTO) updated).getResources());\n+\n+            if (!incremental) {\n+                ((AbstractSubjectMod) result).getResourcesToRemove().clear();\n+                ((AbstractSubjectMod) result).getResourcesToRemove().addAll(originalRes);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Calculate modifications needed by first in order to be equal to second.\n+     *\n+     * @param updated updated UserTO\n+     * @param original original UserTO\n+     * @return UserMod containing differences\n+     */\n+    public static UserMod diff(final UserTO updated, final UserTO original) {\n+        return diff(updated, original, false);\n+    }\n+\n+    /**\n+     * Calculate modifications needed by first in order to be equal to second.\n+     *\n+     * @param updated updated UserTO\n+     * @param original original UserTO\n+     * @param incremental perform incremental diff (without removing existing info)\n+     * @return UserMod containing differences\n+     */\n+    public static UserMod diff(final UserTO updated, final UserTO original, final boolean incremental) {\n+        UserMod result = new UserMod();\n+\n+        diff(updated, original, result, incremental);\n+\n+        // 1. password\n+        if (updated.getPassword() != null && (original.getPassword() == null\n+                || !original.getPassword().equals(updated.getPassword()))) {\n+\n+            result.setPassword(updated.getPassword());\n+        }\n+\n+        // 2. username\n+        if (original.getUsername() != null && !original.getUsername().equals(updated.getUsername())) {\n+            result.setUsername(updated.getUsername());\n+        }\n+\n+        // 3. security question / answer\n+        if (updated.getSecurityQuestion() == null) {\n+            result.setSecurityQuestion(null);\n+            result.setSecurityAnswer(null);\n+        } else if (!updated.getSecurityQuestion().equals(original.getSecurityQuestion())\n+                || StringUtils.isNotBlank(updated.getSecurityAnswer())) {\n+\n+            result.setSecurityQuestion(updated.getSecurityQuestion());\n+            result.setSecurityAnswer(updated.getSecurityAnswer());\n+        }\n+\n+        // 4. memberships\n+        Map<Long, MembershipTO> updatedMembs = updated.getMembershipMap();\n+        Map<Long, MembershipTO> originalMembs = original.getMembershipMap();\n+\n+        for (Map.Entry<Long, MembershipTO> entry : updatedMembs.entrySet()) {\n+            MembershipMod membMod = new MembershipMod();\n+            membMod.setRole(entry.getValue().getRoleId());\n+\n+            if (originalMembs.containsKey(entry.getKey())) {\n+                // if memberships are actually same, just make the isEmpty() call below succeed\n+                if (entry.getValue().equals(originalMembs.get(entry.getKey()))) {\n+                    membMod.setRole(0);\n+                } else {\n+                    diff(entry.getValue(), originalMembs.get(entry.getKey()), membMod, false);\n+                }\n+            } else {\n+                for (AttrTO attr : entry.getValue().getPlainAttrs()) {\n+                    AttrMod attrMod = new AttrMod();\n+                    attrMod.setSchema(attr.getSchema());\n+                    attrMod.getValuesToBeAdded().addAll(attr.getValues());\n+\n+                    if (!attrMod.isEmpty()) {\n+                        membMod.getAttrsToUpdate().add(attrMod);\n+                        membMod.getAttrsToRemove().add(attrMod.getSchema());\n+                    }\n+                }\n+                for (AttrTO attr : entry.getValue().getDerAttrs()) {\n+                    membMod.getDerAttrsToAdd().add(attr.getSchema());\n+                }\n+                for (AttrTO attr : entry.getValue().getVirAttrs()) {\n+                    AttrMod attrMod = new AttrMod();\n+                    attrMod.setSchema(attr.getSchema());\n+                    attrMod.getValuesToBeAdded().addAll(attr.getValues());\n+\n+                    if (!attrMod.isEmpty()) {\n+                        membMod.getVirAttrsToUpdate().add(attrMod);\n+                        membMod.getAttrsToRemove().add(attrMod.getSchema());\n+                    }\n+                }\n+            }\n+\n+            if (!membMod.isEmpty()) {\n+                result.getMembershipsToAdd().add(membMod);\n+            }\n+        }\n+\n+        if (!incremental) {\n+            Set<Long> originalRoles = new HashSet<>(originalMembs.keySet());\n+            originalRoles.removeAll(updatedMembs.keySet());\n+            for (Long roleId : originalRoles) {\n+                result.getMembershipsToRemove().add(originalMembs.get(roleId).getKey());\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * Calculate modifications needed by first in order to be equal to second.\n+     *\n+     * @param updated updated RoleTO\n+     * @param original original RoleTO\n+     * @return RoleMod containing differences\n+     */\n+    public static RoleMod diff(final RoleTO updated, final RoleTO original) {\n+        return diff(updated, original, false);\n+    }\n+\n+    /**\n+     * Calculate modifications needed by first in order to be equal to second.\n+     *\n+     * @param updated updated RoleTO\n+     * @param original original RoleTO\n+     * @param incremental perform incremental diff (without removing existing info)\n+     * @return RoleMod containing differences\n+     */\n+    public static RoleMod diff(final RoleTO updated, final RoleTO original, final boolean incremental) {\n+        RoleMod result = new RoleMod();\n+\n+        diff(updated, original, result, incremental);\n+\n+        // 1. inheritance\n+        result.setInheritOwner(updated.isInheritOwner());\n+        result.setInheritTemplates(updated.isInheritTemplates());\n+        result.setInheritAccountPolicy(updated.isInheritAccountPolicy());\n+        result.setInheritPasswordPolicy(updated.isInheritPasswordPolicy());\n+        result.setInheritPlainAttrs(updated.isInheritAttrs());\n+        result.setInheritDerAttrs(updated.isInheritDerAttrs());\n+        result.setInheritVirAttrs(updated.isInheritVirAttrs());\n+\n+        // 2. policies\n+        result.setAccountPolicy(new ReferenceMod(updated.getAccountPolicy()));\n+        result.setPasswordPolicy(new ReferenceMod(updated.getPasswordPolicy()));\n+\n+        // 3. name\n+        if (!original.getName().equals(updated.getName())) {\n+            result.setName(updated.getName());\n+        }\n+\n+        // 4. entitlements\n+        Set<String> updatedEnts = new HashSet<>(updated.getEntitlements());\n+        Set<String> originalEnts = new HashSet<>(original.getEntitlements());\n+        if (updatedEnts.equals(originalEnts)) {\n+            result.setModEntitlements(false);\n+            result.getEntitlements().clear();\n+        } else {\n+            result.setModEntitlements(true);\n+            result.getEntitlements().addAll(updated.getEntitlements());\n+        }\n+\n+        // 5. templates\n+        Set<String> updatedTemplates = new HashSet<>(updated.getRAttrTemplates());\n+        Set<String> originalTemplates = new HashSet<>(original.getRAttrTemplates());\n+        if (updatedTemplates.equals(originalTemplates)) {\n+            result.setModRAttrTemplates(false);\n+            result.getRPlainAttrTemplates().clear();\n+        } else {\n+            result.setModRAttrTemplates(true);\n+            result.getRPlainAttrTemplates().addAll(updated.getRAttrTemplates());\n+        }\n+        updatedTemplates = new HashSet<>(updated.getRDerAttrTemplates());\n+        originalTemplates = new HashSet<>(original.getRDerAttrTemplates());\n+        if (updatedTemplates.equals(originalTemplates)) {\n+            result.setModRDerAttrTemplates(false);\n+            result.getRDerAttrTemplates().clear();\n+        } else {\n+            result.setModRDerAttrTemplates(true);\n+            result.getRDerAttrTemplates().addAll(updated.getRDerAttrTemplates());\n+        }\n+        updatedTemplates = new HashSet<>(updated.getRVirAttrTemplates());\n+        originalTemplates = new HashSet<>(original.getRVirAttrTemplates());\n+        if (updatedTemplates.equals(originalTemplates)) {\n+            result.setModRVirAttrTemplates(false);\n+            result.getRVirAttrTemplates().clear();\n+        } else {\n+            result.setModRVirAttrTemplates(true);\n+            result.getRVirAttrTemplates().addAll(updated.getRVirAttrTemplates());\n+        }\n+        updatedTemplates = new HashSet<>(updated.getMAttrTemplates());\n+        originalTemplates = new HashSet<>(original.getMAttrTemplates());\n+        if (updatedTemplates.equals(originalTemplates)) {\n+            result.setModMAttrTemplates(false);\n+            result.getMPlainAttrTemplates().clear();\n+        } else {\n+            result.setModMAttrTemplates(true);\n+            result.getMPlainAttrTemplates().addAll(updated.getMAttrTemplates());\n+        }\n+        updatedTemplates = new HashSet<>(updated.getMDerAttrTemplates());\n+        originalTemplates = new HashSet<>(original.getMDerAttrTemplates());\n+        if (updatedTemplates.equals(originalTemplates)) {\n+            result.setModMDerAttrTemplates(false);\n+            result.getMDerAttrTemplates().clear();\n+        } else {\n+            result.setModMDerAttrTemplates(true);\n+            result.getMDerAttrTemplates().addAll(updated.getMDerAttrTemplates());\n+        }\n+        updatedTemplates = new HashSet<>(updated.getMVirAttrTemplates());\n+        originalTemplates = new HashSet<>(original.getMVirAttrTemplates());\n+        if (updatedTemplates.equals(originalTemplates)) {\n+            result.setModMVirAttrTemplates(false);\n+            result.getMVirAttrTemplates().clear();\n+        } else {\n+            result.setModMVirAttrTemplates(true);\n+            result.getMVirAttrTemplates().addAll(updated.getMVirAttrTemplates());\n+        }\n+\n+        // 6. owner\n+        result.setUserOwner(new ReferenceMod(updated.getUserOwner()));\n+        result.setRoleOwner(new ReferenceMod(updated.getRoleOwner()));\n+\n+        return result;\n+    }\n+\n+    private static List<AttrTO> getUpdateValues(final Map<String, AttrTO> attrs,\n+            final Set<String> attrsToBeRemoved, final Set<AttrMod> attrsToBeUpdated) {\n+\n+        Map<String, AttrTO> rwattrs = new HashMap<>(attrs);\n+        for (String attrName : attrsToBeRemoved) {\n+            rwattrs.remove(attrName);\n+        }\n+        for (AttrMod attrMod : attrsToBeUpdated) {\n+            if (rwattrs.containsKey(attrMod.getSchema())) {\n+                AttrTO attrTO = rwattrs.get(attrMod.getSchema());\n+                attrTO.getValues().removeAll(attrMod.getValuesToBeRemoved());\n+                attrTO.getValues().addAll(attrMod.getValuesToBeAdded());\n+            } else {\n+                AttrTO attrTO = new AttrTO();\n+                attrTO.setSchema(attrMod.getSchema());\n+                attrTO.getValues().addAll(attrMod.getValuesToBeAdded());\n+\n+                rwattrs.put(attrMod.getSchema(), attrTO);\n+            }\n+        }\n+\n+        return new ArrayList<>(rwattrs.values());\n+    }\n+\n+    private static <T extends AbstractAttributableTO, K extends AbstractAttributableMod> void apply(final T to,\n+            final K mod, final T result) {\n+\n+        // 1. attributes\n+        result.getPlainAttrs().addAll(getUpdateValues(to.getAttrMap(),\n+                mod.getAttrsToRemove(), mod.getAttrsToUpdate()));\n+\n+        // 2. derived attributes\n+        Map<String, AttrTO> attrs = to.getDerAttrMap();\n+        for (String attrName : mod.getDerAttrsToRemove()) {\n+            attrs.remove(attrName);\n+        }\n+        for (String attrName : mod.getDerAttrsToAdd()) {\n+            AttrTO attrTO = new AttrTO();\n+            attrTO.setSchema(attrName);\n+\n+            attrs.put(attrName, attrTO);\n+        }\n+        result.getDerAttrs().addAll(attrs.values());\n+\n+        // 3. virtual attributes\n+        result.getVirAttrs().addAll(getUpdateValues(to.getVirAttrMap(),\n+                mod.getVirAttrsToRemove(), mod.getVirAttrsToUpdate()));\n+\n+        // 4. resources\n+        if (result instanceof AbstractSubjectTO && mod instanceof AbstractSubjectMod) {\n+            ((AbstractSubjectTO) result).getResources().removeAll(((AbstractSubjectMod) mod).getResourcesToRemove());\n+            ((AbstractSubjectTO) result).getResources().addAll(((AbstractSubjectMod) mod).getResourcesToAdd());\n+        }\n+    }\n+\n+    public static UserTO apply(final UserTO userTO, final UserMod userMod) {\n+        // 1. check same id\n+        if (userTO.getKey() != userMod.getKey()) {\n+            throw new IllegalArgumentException(\"UserTO and UserMod ids must be the same\");\n+        }\n+\n+        UserTO result = SerializationUtils.clone(userTO);\n+        apply(userTO, userMod, result);\n+\n+        // 1. password\n+        result.setPassword(userMod.getPassword());\n+\n+        // 2. username\n+        if (userMod.getUsername() != null) {\n+            result.setUsername(userMod.getUsername());\n+        }\n+        // 3. memberships\n+        Map<Long, MembershipTO> membs = result.getMembershipMap();\n+        for (Long membId : userMod.getMembershipsToRemove()) {\n+            result.getMemberships().remove(membs.get(membId));\n+        }\n+        for (MembershipMod membMod : userMod.getMembershipsToAdd()) {\n+            MembershipTO membTO = new MembershipTO();\n+            membTO.setRoleId(membMod.getRole());\n+\n+            apply(membTO, membMod, membTO);\n+        }\n+\n+        return result;\n+    }\n+}"},{"sha":"7322cc83cb48382685cd431704a926867f5b174a","filename":"syncope620/common/lib/src/main/java/org/apache/syncope/common/lib/SyncopeClientCompositeException.java","status":"added","additions":96,"deletions":0,"changes":96,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2FSyncopeClientCompositeException.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2FSyncopeClientCompositeException.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2FSyncopeClientCompositeException.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,96 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.common.lib;\n+\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Set;\n+import org.apache.syncope.common.lib.types.ClientExceptionType;\n+\n+public class SyncopeClientCompositeException extends SyncopeClientException {\n+\n+    private static final long serialVersionUID = 7882118041134372129L;\n+\n+    private final Set<SyncopeClientException> exceptions = new HashSet<>();\n+\n+    protected SyncopeClientCompositeException() {\n+        super(ClientExceptionType.Composite);\n+    }\n+\n+    public boolean hasExceptions() {\n+        return !exceptions.isEmpty();\n+    }\n+\n+    public boolean hasException(final ClientExceptionType exceptionType) {\n+        return getException(exceptionType) != null;\n+    }\n+\n+    public SyncopeClientException getException(final ClientExceptionType exceptionType) {\n+        boolean found = false;\n+        SyncopeClientException syncopeClientException = null;\n+        for (Iterator<SyncopeClientException> itor = exceptions.iterator(); itor.hasNext() && !found;) {\n+            syncopeClientException = itor.next();\n+            if (syncopeClientException.getType().equals(exceptionType)) {\n+                found = true;\n+            }\n+        }\n+\n+        return found\n+                ? syncopeClientException\n+                : null;\n+    }\n+\n+    public Set<SyncopeClientException> getExceptions() {\n+        return exceptions;\n+    }\n+\n+    public boolean addException(final SyncopeClientException exception) {\n+        if (exception.getType() == null) {\n+            throw new IllegalArgumentException(exception + \" does not have the right \"\n+                    + ClientExceptionType.class.getName() + \" set\");\n+        }\n+\n+        return exceptions.add(exception);\n+    }\n+\n+    @Override\n+    public String getMessage() {\n+        StringBuilder message = new StringBuilder();\n+\n+        message.append(\"{\");\n+        Iterator<SyncopeClientException> iter = getExceptions().iterator();\n+        while (iter.hasNext()) {\n+            SyncopeClientException e = iter.next();\n+            message.append(\"[\");\n+            message.append(e.getMessage());\n+            message.append(\"]\");\n+            if (iter.hasNext()) {\n+                message.append(\", \");\n+            }\n+        }\n+        message.append(\"}\");\n+\n+        return message.toString();\n+    }\n+\n+    @Override\n+    public String getLocalizedMessage() {\n+        return getMessage();\n+    }\n+}"},{"sha":"2243835a316e7804d6a154b332fdc603fbfbf2c0","filename":"syncope620/common/lib/src/main/java/org/apache/syncope/common/lib/SyncopeClientException.java","status":"added","additions":97,"deletions":0,"changes":97,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2FSyncopeClientException.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2FSyncopeClientException.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2FSyncopeClientException.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,97 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.common.lib;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.syncope.common.lib.types.ClientExceptionType;\n+\n+public class SyncopeClientException extends RuntimeException {\n+\n+    private static final long serialVersionUID = 3380920886511913475L;\n+\n+    private ClientExceptionType type;\n+\n+    private final List<String> elements = new ArrayList<>();\n+\n+    public static SyncopeClientException build(final ClientExceptionType type) {\n+        if (type == ClientExceptionType.Composite) {\n+            throw new IllegalArgumentException(\"Composite exceptions must be obtained via buildComposite()\");\n+        }\n+        return new SyncopeClientException(type);\n+    }\n+\n+    public static SyncopeClientCompositeException buildComposite() {\n+        return new SyncopeClientCompositeException();\n+    }\n+\n+    protected SyncopeClientException(final ClientExceptionType type) {\n+        super();\n+        setType(type);\n+    }\n+\n+    public boolean isComposite() {\n+        return getType() == ClientExceptionType.Composite;\n+    }\n+\n+    public SyncopeClientCompositeException asComposite() {\n+        if (!isComposite()) {\n+            throw new IllegalArgumentException(\"This is not a composite exception\");\n+        }\n+\n+        return (SyncopeClientCompositeException) this;\n+    }\n+\n+    public ClientExceptionType getType() {\n+        return type;\n+    }\n+\n+    public final void setType(final ClientExceptionType type) {\n+        this.type = type;\n+    }\n+\n+    public List<String> getElements() {\n+        return elements;\n+    }\n+\n+    public boolean isEmpty() {\n+        return elements.isEmpty();\n+    }\n+\n+    public int size() {\n+        return elements.size();\n+    }\n+\n+    @Override\n+    public String getMessage() {\n+        StringBuilder message = new StringBuilder();\n+\n+        message.append(getType());\n+        message.append(\" \");\n+        message.append(getElements());\n+\n+        return message.toString();\n+    }\n+\n+    @Override\n+    public String getLocalizedMessage() {\n+        return getMessage();\n+    }\n+\n+}"},{"sha":"5d6b982337ddb698c6384d04822929cba7fa8476","filename":"syncope620/common/lib/src/main/java/org/apache/syncope/common/lib/mod/AbstractAttributableMod.java","status":"modified","additions":9,"deletions":9,"changes":18,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fmod%2FAbstractAttributableMod.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fmod%2FAbstractAttributableMod.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fmod%2FAbstractAttributableMod.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -38,9 +38,9 @@ public abstract class AbstractAttributableMod extends AbstractBaseBean {\n \n     protected long key;\n \n-    protected final Set<AttrMod> attrsToUpdate = new HashSet<>();\n+    protected final Set<AttrMod> plainAttrsToUpdate = new HashSet<>();\n \n-    protected final Set<String> attrsToRemove = new HashSet<>();\n+    protected final Set<String> plainAttrsToRemove = new HashSet<>();\n \n     protected final Set<String> derAttrsToAdd = new HashSet<>();\n \n@@ -58,18 +58,18 @@ public void setKey(final long key) {\n         this.key = key;\n     }\n \n-    @XmlElementWrapper(name = \"attributesToRemove\")\n+    @XmlElementWrapper(name = \"plainAttrsToRemove\")\n     @XmlElement(name = \"attribute\")\n-    @JsonProperty(\"attributesToRemove\")\n+    @JsonProperty(\"plainAttrsToRemove\")\n     public Set<String> getAttrsToRemove() {\n-        return attrsToRemove;\n+        return plainAttrsToRemove;\n     }\n \n-    @XmlElementWrapper(name = \"attributesToUpdate\")\n+    @XmlElementWrapper(name = \"plainAttrsToUpdate\")\n     @XmlElement(name = \"attributeMod\")\n-    @JsonProperty(\"attributesToUpdate\")\n+    @JsonProperty(\"plainAttrsToUpdate\")\n     public Set<AttrMod> getAttrsToUpdate() {\n-        return attrsToUpdate;\n+        return plainAttrsToUpdate;\n     }\n \n     @XmlElementWrapper(name = \"derAttrsToAdd\")\n@@ -104,7 +104,7 @@ public Set<AttrMod> getVirAttrsToUpdate() {\n      * @return true is all backing Sets are empty.\n      */\n     public boolean isEmpty() {\n-        return attrsToUpdate.isEmpty() && attrsToRemove.isEmpty()\n+        return plainAttrsToUpdate.isEmpty() && plainAttrsToRemove.isEmpty()\n                 && derAttrsToAdd.isEmpty() && derAttrsToRemove.isEmpty()\n                 && virAttrsToUpdate.isEmpty() && virAttrsToRemove.isEmpty();\n     }"},{"sha":"bdcfcbf6f27ea89b733c9a11221216c99bfd75c7","filename":"syncope620/common/lib/src/main/java/org/apache/syncope/common/lib/mod/MembershipMod.java","status":"added","additions":46,"deletions":0,"changes":46,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fmod%2FMembershipMod.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fmod%2FMembershipMod.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fmod%2FMembershipMod.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,46 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.common.lib.mod;\n+\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.bind.annotation.XmlType;\n+\n+@XmlRootElement\n+@XmlType\n+public class MembershipMod extends AbstractAttributableMod {\n+\n+    private static final long serialVersionUID = 2511869129977331525L;\n+\n+    private long role;\n+\n+    public long getRole() {\n+        return role;\n+    }\n+\n+    public void setRole(final long role) {\n+        this.role = role;\n+    }\n+\n+    @JsonIgnore\n+    @Override\n+    public boolean isEmpty() {\n+        return super.isEmpty() && role == 0;\n+    }\n+}"},{"sha":"e8356c270228b25c1cccc8ee3f4b836987072535","filename":"syncope620/common/lib/src/main/java/org/apache/syncope/common/lib/mod/ReferenceMod.java","status":"added","additions":53,"deletions":0,"changes":53,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fmod%2FReferenceMod.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fmod%2FReferenceMod.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fmod%2FReferenceMod.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,53 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.common.lib.mod;\n+\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.bind.annotation.XmlType;\n+import org.apache.syncope.common.lib.AbstractBaseBean;\n+\n+/**\n+ * This class is used to specify the willing to modify an external reference id. Use 'null' ReferenceMod to keep the\n+ * current reference id; use a ReferenceMod with a null id to try to reset the reference id; use a ReferenceMod with a\n+ * not null id to specify a new reference id.\n+ */\n+@XmlRootElement(name = \"referenceMod\")\n+@XmlType\n+public class ReferenceMod extends AbstractBaseBean {\n+\n+    private static final long serialVersionUID = -4188817853738067677L;\n+\n+    private Long key;\n+\n+    public ReferenceMod() {\n+        this.key = null;\n+    }\n+\n+    public ReferenceMod(final Long key) {\n+        this.key = key;\n+    }\n+\n+    public Long getKey() {\n+        return key;\n+    }\n+\n+    public void setKey(final Long key) {\n+        this.key = key;\n+    }\n+}"},{"sha":"63123497832402d7278cccb2c8a689e1d33e0631","filename":"syncope620/common/lib/src/main/java/org/apache/syncope/common/lib/mod/ResourceAssociationMod.java","status":"added","additions":80,"deletions":0,"changes":80,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fmod%2FResourceAssociationMod.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fmod%2FResourceAssociationMod.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fmod%2FResourceAssociationMod.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,80 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.common.lib.mod;\n+\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlElementWrapper;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.bind.annotation.XmlType;\n+import org.apache.syncope.common.lib.AbstractBaseBean;\n+import org.apache.syncope.common.lib.wrap.ResourceName;\n+\n+/**\n+ * This class is used to specify the willing to create associations between user and external references.\n+ * Password can be provided if required by an assign or provisioning operation.\n+ *\n+ * @see org.apache.syncope.common.types.ResourceAssociationActionType\n+ */\n+@XmlRootElement(name = \"resourceAssociationMod\")\n+@XmlType\n+public class ResourceAssociationMod extends AbstractBaseBean {\n+\n+    private static final long serialVersionUID = -4188817853738067678L;\n+\n+    /**\n+     * Target external resources.\n+     */\n+    private final List<ResourceName> targetResources = new ArrayList<ResourceName>();\n+\n+    /**\n+     * Indicate the willing to change password on target external resources.\n+     */\n+    private boolean changePwd;\n+\n+    /**\n+     * Indicate the new password to be provisioned on target external resources.\n+     */\n+    private String password;\n+\n+    @XmlElementWrapper(name = \"resources\")\n+    @XmlElement(name = \"resource\")\n+    @JsonProperty(\"resources\")\n+    public List<ResourceName> getTargetResources() {\n+        return targetResources;\n+    }\n+\n+    public boolean isChangePwd() {\n+        return changePwd;\n+    }\n+\n+    public void setChangePwd(boolean changePwd) {\n+        this.changePwd = changePwd;\n+    }\n+\n+    public String getPassword() {\n+        return password;\n+    }\n+\n+    public void setPassword(String password) {\n+        this.password = password;\n+    }\n+}"},{"sha":"b1b8f4fa851b7058842a243b0689293a4810286a","filename":"syncope620/common/lib/src/main/java/org/apache/syncope/common/lib/mod/RoleMod.java","status":"added","additions":300,"deletions":0,"changes":300,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fmod%2FRoleMod.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fmod%2FRoleMod.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fmod%2FRoleMod.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,300 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.common.lib.mod;\n+\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlElementWrapper;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.bind.annotation.XmlType;\n+\n+@XmlRootElement(name = \"roleMod\")\n+@XmlType\n+public class RoleMod extends AbstractSubjectMod {\n+\n+    private static final long serialVersionUID = 7455805264680210747L;\n+\n+    private String name;\n+\n+    private ReferenceMod userOwner;\n+\n+    private ReferenceMod roleOwner;\n+\n+    private Boolean inheritOwner;\n+\n+    private Boolean inheritTemplates;\n+\n+    private Boolean inheritPlainAttrs;\n+\n+    private Boolean inheritDerAttrs;\n+\n+    private Boolean inheritVirAttrs;\n+\n+    private Boolean inheritAccountPolicy;\n+\n+    private Boolean inheritPasswordPolicy;\n+\n+    private boolean modEntitlements;\n+\n+    private final List<String> entitlements = new ArrayList<>();\n+\n+    private boolean modRAttrTemplates;\n+\n+    private final List<String> rPlainAttrTemplates = new ArrayList<>();\n+\n+    private boolean modRDerAttrTemplates;\n+\n+    private final List<String> rDerAttrTemplates = new ArrayList<>();\n+\n+    private boolean modRVirAttrTemplates;\n+\n+    private final List<String> rVirAttrTemplates = new ArrayList<>();\n+\n+    private boolean modMAttrTemplates;\n+\n+    private final List<String> mPlainAttrTemplates = new ArrayList<>();\n+\n+    private boolean modMDerAttrTemplates;\n+\n+    private final List<String> mDerAttrTemplates = new ArrayList<>();\n+\n+    private boolean modMVirAttrTemplates;\n+\n+    private final List<String> mVirAttrTemplates = new ArrayList<>();\n+\n+    private ReferenceMod passwordPolicy;\n+\n+    private ReferenceMod accountPolicy;\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public void setName(final String name) {\n+        this.name = name;\n+    }\n+\n+    public ReferenceMod getUserOwner() {\n+        return userOwner;\n+    }\n+\n+    public void setUserOwner(final ReferenceMod userOwner) {\n+        this.userOwner = userOwner;\n+    }\n+\n+    public ReferenceMod getRoleOwner() {\n+        return roleOwner;\n+    }\n+\n+    public void setRoleOwner(final ReferenceMod roleOwner) {\n+        this.roleOwner = roleOwner;\n+    }\n+\n+    public Boolean getInheritOwner() {\n+        return inheritOwner;\n+    }\n+\n+    public void setInheritOwner(final Boolean inheritOwner) {\n+        this.inheritOwner = inheritOwner;\n+    }\n+\n+    public Boolean getInheritTemplates() {\n+        return inheritTemplates;\n+    }\n+\n+    public void setInheritTemplates(final Boolean inheritTemplates) {\n+        this.inheritTemplates = inheritTemplates;\n+    }\n+\n+    public Boolean getInheritPlainAttrs() {\n+        return inheritPlainAttrs;\n+    }\n+\n+    public void setInheritPlainAttrs(final Boolean inheritAttrs) {\n+        this.inheritPlainAttrs = inheritAttrs;\n+    }\n+\n+    public Boolean getInheritDerAttrs() {\n+        return inheritDerAttrs;\n+    }\n+\n+    public void setInheritDerAttrs(final Boolean inheritDerAttrs) {\n+        this.inheritDerAttrs = inheritDerAttrs;\n+    }\n+\n+    public Boolean getInheritVirAttrs() {\n+        return inheritVirAttrs;\n+    }\n+\n+    public void setInheritVirAttrs(final Boolean inheritVirAttrs) {\n+        this.inheritVirAttrs = inheritVirAttrs;\n+    }\n+\n+    public boolean isModEntitlements() {\n+        return modEntitlements;\n+    }\n+\n+    public void setModEntitlements(final boolean modEntitlements) {\n+        this.modEntitlements = modEntitlements;\n+    }\n+\n+    @XmlElementWrapper(name = \"entitlements\")\n+    @XmlElement(name = \"entitlement\")\n+    @JsonProperty(\"entitlements\")\n+    public List<String> getEntitlements() {\n+        return entitlements;\n+    }\n+\n+    public boolean isModRAttrTemplates() {\n+        return modRAttrTemplates;\n+    }\n+\n+    public void setModRAttrTemplates(final boolean modRAttrTemplates) {\n+        this.modRAttrTemplates = modRAttrTemplates;\n+    }\n+\n+    @XmlElementWrapper(name = \"rPlainAttrTemplates\")\n+    @XmlElement(name = \"rAttrTemplate\")\n+    @JsonProperty(\"rPlainAttrTemplates\")\n+    public List<String> getRPlainAttrTemplates() {\n+        return rPlainAttrTemplates;\n+    }\n+\n+    public boolean isModRDerAttrTemplates() {\n+        return modRDerAttrTemplates;\n+    }\n+\n+    public void setModRDerAttrTemplates(final boolean modRDerAttrTemplates) {\n+        this.modRDerAttrTemplates = modRDerAttrTemplates;\n+    }\n+\n+    @XmlElementWrapper(name = \"rDerAttrTemplates\")\n+    @XmlElement(name = \"rDerAttrTemplate\")\n+    @JsonProperty(\"rDerAttrTemplates\")\n+    public List<String> getRDerAttrTemplates() {\n+        return rDerAttrTemplates;\n+    }\n+\n+    public boolean isModRVirAttrTemplates() {\n+        return modRVirAttrTemplates;\n+    }\n+\n+    public void setModRVirAttrTemplates(final boolean modRVirAttrTemplates) {\n+        this.modRVirAttrTemplates = modRVirAttrTemplates;\n+    }\n+\n+    @XmlElementWrapper(name = \"rVirAttrTemplates\")\n+    @XmlElement(name = \"rVirAttrTemplate\")\n+    @JsonProperty(\"rVirAttrTemplates\")\n+    public List<String> getRVirAttrTemplates() {\n+        return rVirAttrTemplates;\n+    }\n+\n+    public boolean isModMAttrTemplates() {\n+        return modMAttrTemplates;\n+    }\n+\n+    public void setModMAttrTemplates(final boolean modMAttrTemplates) {\n+        this.modMAttrTemplates = modMAttrTemplates;\n+    }\n+\n+    @XmlElementWrapper(name = \"mPlainAttrTemplates\")\n+    @XmlElement(name = \"mAttrTemplate\")\n+    @JsonProperty(\"mPlainAttrTemplates\")\n+    public List<String> getMPlainAttrTemplates() {\n+        return mPlainAttrTemplates;\n+    }\n+\n+    public boolean isModMDerAttrTemplates() {\n+        return modMDerAttrTemplates;\n+    }\n+\n+    public void setModMDerAttrTemplates(final boolean modMDerAttrTemplates) {\n+        this.modMDerAttrTemplates = modMDerAttrTemplates;\n+    }\n+\n+    @XmlElementWrapper(name = \"mDerAttrTemplates\")\n+    @XmlElement(name = \"mDerAttrTemplate\")\n+    @JsonProperty(\"mDerAttrTemplates\")\n+    public List<String> getMDerAttrTemplates() {\n+        return mDerAttrTemplates;\n+    }\n+\n+    public boolean isModMVirAttrTemplates() {\n+        return modMVirAttrTemplates;\n+    }\n+\n+    public void setModMVirAttrTemplates(final boolean modMVirAttrTemplates) {\n+        this.modMVirAttrTemplates = modMVirAttrTemplates;\n+    }\n+\n+    @XmlElementWrapper(name = \"mVirAttrTemplates\")\n+    @XmlElement(name = \"mVirAttrTemplate\")\n+    @JsonProperty(\"mVirAttrTemplates\")\n+    public List<String> getMVirAttrTemplates() {\n+        return mVirAttrTemplates;\n+    }\n+\n+    public ReferenceMod getPasswordPolicy() {\n+        return passwordPolicy;\n+    }\n+\n+    public void setPasswordPolicy(final ReferenceMod passwordPolicy) {\n+        this.passwordPolicy = passwordPolicy;\n+    }\n+\n+    public Boolean getInheritPasswordPolicy() {\n+        return inheritPasswordPolicy;\n+    }\n+\n+    public void setInheritPasswordPolicy(final Boolean inheritPasswordPolicy) {\n+        this.inheritPasswordPolicy = inheritPasswordPolicy;\n+    }\n+\n+    public ReferenceMod getAccountPolicy() {\n+        return accountPolicy;\n+    }\n+\n+    public void setAccountPolicy(final ReferenceMod accountPolicy) {\n+        this.accountPolicy = accountPolicy;\n+    }\n+\n+    public Boolean getInheritAccountPolicy() {\n+        return inheritAccountPolicy;\n+    }\n+\n+    public void setInheritAccountPolicy(final Boolean inheritAccountPolicy) {\n+        this.inheritAccountPolicy = inheritAccountPolicy;\n+    }\n+\n+    @JsonIgnore\n+    @Override\n+    public boolean isEmpty() {\n+        return super.isEmpty() && name == null && userOwner == null && roleOwner == null\n+                && inheritTemplates == null && inheritOwner == null\n+                && inheritAccountPolicy == null && inheritPasswordPolicy == null\n+                && inheritPlainAttrs == null && inheritDerAttrs == null && inheritVirAttrs == null\n+                && accountPolicy == null && passwordPolicy == null && entitlements.isEmpty()\n+                && rPlainAttrTemplates.isEmpty() && rDerAttrTemplates.isEmpty() && rVirAttrTemplates.isEmpty()\n+                && mPlainAttrTemplates.isEmpty() && mDerAttrTemplates.isEmpty() && mVirAttrTemplates.isEmpty();\n+    }\n+}"},{"sha":"3ddf2633f2fc2260387fdac5dc9c41f06a21354a","filename":"syncope620/common/lib/src/main/java/org/apache/syncope/common/lib/mod/StatusMod.java","status":"added","additions":108,"deletions":0,"changes":108,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fmod%2FStatusMod.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fmod%2FStatusMod.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fmod%2FStatusMod.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,108 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.common.lib.mod;\n+\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlElementWrapper;\n+import javax.xml.bind.annotation.XmlEnum;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.bind.annotation.XmlType;\n+import org.apache.syncope.common.lib.AbstractBaseBean;\n+\n+@XmlRootElement(name = \"statusMod\")\n+@XmlType\n+public class StatusMod extends AbstractBaseBean {\n+\n+    private static final long serialVersionUID = 3230910033784302656L;\n+\n+    @XmlEnum\n+    @XmlType(name = \"statusModType\")\n+    public enum ModType {\n+\n+        ACTIVATE,\n+        SUSPEND,\n+        REACTIVATE;\n+\n+    }\n+\n+    /**\n+     * Id of user to for which status update is requested.\n+     */\n+    private long id;\n+\n+    private ModType type;\n+\n+    /**\n+     * Update token (if required).\n+     */\n+    private String token;\n+\n+    /**\n+     * Whether update should be performed on internal storage.\n+     */\n+    private boolean onSyncope = true;\n+\n+    /**\n+     * External resources for which update is needed to be propagated.\n+     */\n+    private final List<String> resourceNames = new ArrayList<>();\n+\n+    public long getId() {\n+        return id;\n+    }\n+\n+    public void setId(long id) {\n+        this.id = id;\n+    }\n+\n+    public ModType getType() {\n+        return type;\n+    }\n+\n+    public void setType(final ModType type) {\n+        this.type = type;\n+    }\n+\n+    public String getToken() {\n+        return token;\n+    }\n+\n+    public void setToken(final String token) {\n+        this.token = token;\n+    }\n+\n+    public boolean isOnSyncope() {\n+        return onSyncope;\n+    }\n+\n+    public void setOnSyncope(final boolean onSyncope) {\n+        this.onSyncope = onSyncope;\n+    }\n+\n+    @XmlElementWrapper(name = \"resources\")\n+    @XmlElement(name = \"resource\")\n+    @JsonProperty(\"resources\")\n+    public List<String> getResourceNames() {\n+        return resourceNames;\n+    }\n+\n+}"},{"sha":"0f421be691d269c01d4958c8b9e942669f1e2f19","filename":"syncope620/common/lib/src/main/java/org/apache/syncope/common/lib/mod/UserMod.java","status":"added","additions":123,"deletions":0,"changes":123,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fmod%2FUserMod.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fmod%2FUserMod.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fmod%2FUserMod.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,123 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.common.lib.mod;\n+\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import java.util.HashSet;\n+import java.util.Set;\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlElementWrapper;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.bind.annotation.XmlType;\n+\n+@XmlRootElement(name = \"userMod\")\n+@XmlType\n+public class UserMod extends AbstractSubjectMod {\n+\n+    private static final long serialVersionUID = 3081848906558106204L;\n+\n+    private String password;\n+\n+    private String username;\n+\n+    private final Set<MembershipMod> membershipsToAdd;\n+\n+    private final Set<Long> membershipsToRemove;\n+\n+    private StatusMod pwdPropRequest;\n+\n+    private Long securityQuestion;\n+\n+    private String securityAnswer;\n+\n+    public UserMod() {\n+        super();\n+\n+        membershipsToAdd = new HashSet<>();\n+        membershipsToRemove = new HashSet<>();\n+    }\n+\n+    public String getUsername() {\n+        return username;\n+    }\n+\n+    public void setUsername(final String username) {\n+        this.username = username;\n+    }\n+\n+    public String getPassword() {\n+        return password;\n+    }\n+\n+    public void setPassword(final String password) {\n+        this.password = password;\n+    }\n+\n+    @XmlElementWrapper(name = \"membershipsToAdd\")\n+    @XmlElement(name = \"membership\")\n+    @JsonProperty(\"membershipsToAdd\")\n+    public Set<MembershipMod> getMembershipsToAdd() {\n+        return membershipsToAdd;\n+    }\n+\n+    @XmlElementWrapper(name = \"membershipsToRemove\")\n+    @XmlElement(name = \"membership\")\n+    @JsonProperty(\"membershipsToRemove\")\n+    public Set<Long> getMembershipsToRemove() {\n+        return membershipsToRemove;\n+    }\n+\n+    public StatusMod getPwdPropRequest() {\n+        return pwdPropRequest;\n+    }\n+\n+    public void setPwdPropRequest(final StatusMod pwdPropRequest) {\n+        this.pwdPropRequest = pwdPropRequest;\n+    }\n+\n+    public Long getSecurityQuestion() {\n+        return securityQuestion;\n+    }\n+\n+    public void setSecurityQuestion(final Long securityQuestion) {\n+        this.securityQuestion = securityQuestion;\n+    }\n+\n+    public String getSecurityAnswer() {\n+        return securityAnswer;\n+    }\n+\n+    public void setSecurityAnswer(final String securityAnswer) {\n+        this.securityAnswer = securityAnswer;\n+    }\n+\n+    @JsonIgnore\n+    @Override\n+    public boolean isEmpty() {\n+        return super.isEmpty()\n+                && password == null\n+                && username == null\n+                && membershipsToAdd.isEmpty()\n+                && membershipsToRemove.isEmpty()\n+                && pwdPropRequest == null\n+                && securityQuestion == null\n+                && securityAnswer == null;\n+    }\n+}"},{"sha":"866b2758096f5ba699345fcac65a6d87440167ac","filename":"syncope620/common/lib/src/main/java/org/apache/syncope/common/lib/mod/package-info.java","status":"added","additions":23,"deletions":0,"changes":23,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fmod%2Fpackage-info.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fmod%2Fpackage-info.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fmod%2Fpackage-info.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,23 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+@XmlSchema(namespace = SyncopeConstants.NAMESPACE)\n+package org.apache.syncope.common.lib.mod;\n+\n+import javax.xml.bind.annotation.XmlSchema;\n+import org.apache.syncope.common.lib.SyncopeConstants;"},{"sha":"295316ba4429a65d150f518c0a1e110033b69398","filename":"syncope620/common/lib/src/main/java/org/apache/syncope/common/lib/report/RoleReportletConf.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Freport%2FRoleReportletConf.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Freport%2FRoleReportletConf.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Freport%2FRoleReportletConf.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -39,7 +39,7 @@ public class RoleReportletConf extends AbstractReportletConf {\n     @XmlType(name = \"roleReportletConfFeature\")\n     public enum Feature {\n \n-        id,\n+        key,\n         name,\n         roleOwner,\n         userOwner,"},{"sha":"afd806a85db4f538fb7cf55c636df4ae53e47497","filename":"syncope620/common/lib/src/main/java/org/apache/syncope/common/lib/report/UserReportletConf.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Freport%2FUserReportletConf.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Freport%2FUserReportletConf.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Freport%2FUserReportletConf.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -38,7 +38,7 @@ public class UserReportletConf extends AbstractReportletConf {\n     @XmlType(name = \"userReportletConfFeature\")\n     public enum Feature {\n \n-        id,\n+        key,\n         username,\n         workflowId,\n         status,"},{"sha":"41d152c79cbbbae8d75408cbb5d9ba6f1929e785","filename":"syncope620/common/lib/src/main/java/org/apache/syncope/common/lib/search/OrderByClauseBuilder.java","status":"added","additions":45,"deletions":0,"changes":45,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fsearch%2FOrderByClauseBuilder.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fsearch%2FOrderByClauseBuilder.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fsearch%2FOrderByClauseBuilder.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,45 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.common.lib.search;\n+\n+import org.apache.commons.lang3.StringUtils;\n+\n+/**\n+ * Simple builder for generating <tt>orderby</tt> values.\n+ */\n+public class OrderByClauseBuilder {\n+\n+    private final StringBuilder builder = new StringBuilder();\n+\n+    public OrderByClauseBuilder asc(final String key) {\n+        builder.append(key).append(\" ASC,\");\n+        return this;\n+    }\n+\n+    public OrderByClauseBuilder desc(final String key) {\n+        builder.append(key).append(\" DESC,\");\n+        return this;\n+    }\n+\n+    public String build() {\n+        return builder.length() == 0\n+                ? StringUtils.EMPTY\n+                : builder.deleteCharAt(builder.length() - 1).toString();\n+    }\n+}"},{"sha":"b6cbb6d52513796d8be63605fe72dec027cb1359","filename":"syncope620/common/lib/src/main/java/org/apache/syncope/common/lib/search/RoleFiqlSearchConditionBuilder.java","status":"added","additions":90,"deletions":0,"changes":90,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fsearch%2FRoleFiqlSearchConditionBuilder.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fsearch%2FRoleFiqlSearchConditionBuilder.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fsearch%2FRoleFiqlSearchConditionBuilder.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,90 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.common.lib.search;\n+\n+import java.util.Map;\n+import org.apache.cxf.jaxrs.ext.search.client.CompleteCondition;\n+import org.apache.cxf.jaxrs.ext.search.fiql.FiqlParser;\n+\n+/**\n+ * Extends <tt>SyncopeFiqlSearchConditionBuilder</tt> by providing some additional facilities for searching\n+ * roles in Syncope.\n+ */\n+public class RoleFiqlSearchConditionBuilder extends SyncopeFiqlSearchConditionBuilder {\n+\n+    public RoleFiqlSearchConditionBuilder() {\n+        super();\n+    }\n+\n+    public RoleFiqlSearchConditionBuilder(final Map<String, String> properties) {\n+        super(properties);\n+    }\n+\n+    @Override\n+    protected Builder newBuilderInstance() {\n+        return new Builder(properties);\n+    }\n+\n+    @Override\n+    public RoleProperty is(final String property) {\n+        return newBuilderInstance().is(property);\n+    }\n+\n+    public CompleteCondition hasEntitlements(final String entitlement, final String... moreEntitlements) {\n+        return newBuilderInstance().is(SpecialAttr.ENTITLEMENTS.toString()).\n+                hasEntitlements(entitlement, moreEntitlements);\n+    }\n+\n+    public CompleteCondition hasNotEntitlements(final String entitlement, final String... moreEntitlements) {\n+        return newBuilderInstance().is(SpecialAttr.ENTITLEMENTS.toString()).\n+                hasNotEntitlements(entitlement, moreEntitlements);\n+    }\n+\n+    protected static class Builder extends SyncopeFiqlSearchConditionBuilder.Builder\n+            implements RoleProperty, CompleteCondition {\n+\n+        public Builder(final Map<String, String> properties) {\n+            super(properties);\n+        }\n+\n+        public Builder(final Builder parent) {\n+            super(parent);\n+        }\n+\n+        @Override\n+        public RoleProperty is(final String property) {\n+            Builder b = new Builder(this);\n+            b.result = property;\n+            return b;\n+        }\n+\n+        @Override\n+        public CompleteCondition hasEntitlements(final String entitlement, final String... moreEntitlements) {\n+            this.result = SpecialAttr.ENTITLEMENTS.toString();\n+            return condition(FiqlParser.EQ, entitlement, (Object[]) moreEntitlements);\n+        }\n+\n+        @Override\n+        public CompleteCondition hasNotEntitlements(final String entitlement, final String... moreEntitlements) {\n+            this.result = SpecialAttr.ENTITLEMENTS.toString();\n+            return condition(FiqlParser.NEQ, entitlement, (Object[]) moreEntitlements);\n+        }\n+\n+    }\n+}"},{"sha":"433ed11877bdddeede26499009a0c74a336c942f","filename":"syncope620/common/lib/src/main/java/org/apache/syncope/common/lib/search/RoleProperty.java","status":"added","additions":29,"deletions":0,"changes":29,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fsearch%2FRoleProperty.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fsearch%2FRoleProperty.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fsearch%2FRoleProperty.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,29 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.common.lib.search;\n+\n+import org.apache.cxf.jaxrs.ext.search.client.CompleteCondition;\n+\n+public interface RoleProperty extends SyncopeProperty {\n+\n+    CompleteCondition hasEntitlements(String entitlement, String... moreEntitlements);\n+\n+    CompleteCondition hasNotEntitlements(String entitlement, String... moreEntitlements);\n+\n+}"},{"sha":"5a006f5375edf3c58c33b6faf535dfb4a82603a9","filename":"syncope620/common/lib/src/main/java/org/apache/syncope/common/lib/search/SearchableFields.java","status":"added","additions":67,"deletions":0,"changes":67,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fsearch%2FSearchableFields.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fsearch%2FSearchableFields.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fsearch%2FSearchableFields.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,67 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.common.lib.search;\n+\n+import java.lang.reflect.Field;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.syncope.common.lib.to.AbstractAttributableTO;\n+import org.apache.syncope.common.lib.to.RoleTO;\n+import org.apache.syncope.common.lib.to.UserTO;\n+import org.apache.syncope.common.lib.types.SubjectType;\n+\n+public class SearchableFields {\n+\n+    protected static final String[] ATTRIBUTES_NOTINCLUDED = {\n+        \"plainAttrs\", \"derAttrs\", \"virAttrs\",\n+        \"serialVersionUID\", \"memberships\", \"entitlements\", \"resources\", \"password\",\n+        \"propagationTOs\", \"propagationStatusMap\"\n+    };\n+\n+    public static final List<String> get(final SubjectType subjectType) {\n+        return get(subjectType == SubjectType.USER\n+                ? UserTO.class\n+                : RoleTO.class);\n+    }\n+\n+    public static final List<String> get(final Class<? extends AbstractAttributableTO> attributableRef) {\n+        final List<String> fieldNames = new ArrayList<>();\n+\n+        // loop on class and all superclasses searching for field\n+        Class<?> clazz = attributableRef;\n+        while (clazz != null && clazz != Object.class) {\n+            for (Field field : clazz.getDeclaredFields()) {\n+                if (!ArrayUtils.contains(ATTRIBUTES_NOTINCLUDED, field.getName())) {\n+                    fieldNames.add(field.getName());\n+                }\n+            }\n+            clazz = clazz.getSuperclass();\n+        }\n+\n+        Collections.reverse(fieldNames);\n+        return fieldNames;\n+\n+    }\n+\n+    private SearchableFields() {\n+        // empty constructor for static utility class\n+    }\n+}"},{"sha":"b4c2f21fc0d9cb3b6a35119e5448cfa757014448","filename":"syncope620/common/lib/src/main/java/org/apache/syncope/common/lib/search/SpecialAttr.java","status":"added","additions":50,"deletions":0,"changes":50,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fsearch%2FSpecialAttr.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fsearch%2FSpecialAttr.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fsearch%2FSpecialAttr.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,50 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.common.lib.search;\n+\n+public enum SpecialAttr {\n+\n+    NULL(\"$null\"),\n+    RESOURCES(\"$resources\"),\n+    ROLES(\"$roles\"),\n+    ENTITLEMENTS(\"$entitlements\");\n+\n+    private final String literal;\n+\n+    SpecialAttr(final String literal) {\n+        this.literal = literal;\n+    }\n+\n+    public static SpecialAttr fromString(final String value) {\n+        SpecialAttr result = null;\n+        for (SpecialAttr specialAttr : values()) {\n+            if (specialAttr.literal.equals(value)) {\n+                result = specialAttr;\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return literal;\n+    }\n+\n+}"},{"sha":"6c710a2d32411f0db5e1bff73ed27e92664741f7","filename":"syncope620/common/lib/src/main/java/org/apache/syncope/common/lib/search/SyncopeFiqlSearchConditionBuilder.java","status":"added","additions":110,"deletions":0,"changes":110,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fsearch%2FSyncopeFiqlSearchConditionBuilder.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fsearch%2FSyncopeFiqlSearchConditionBuilder.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fsearch%2FSyncopeFiqlSearchConditionBuilder.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,110 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.common.lib.search;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.apache.cxf.jaxrs.ext.search.SearchUtils;\n+import org.apache.cxf.jaxrs.ext.search.client.CompleteCondition;\n+import org.apache.cxf.jaxrs.ext.search.client.FiqlSearchConditionBuilder;\n+import org.apache.cxf.jaxrs.ext.search.fiql.FiqlParser;\n+\n+public abstract class SyncopeFiqlSearchConditionBuilder extends FiqlSearchConditionBuilder {\n+\n+    public static final Map<String, String> CONTEXTUAL_PROPERTIES;\n+\n+    static {\n+        CONTEXTUAL_PROPERTIES = new HashMap<String, String>();\n+        CONTEXTUAL_PROPERTIES.put(SearchUtils.LAX_PROPERTY_MATCH, \"true\");\n+    }\n+\n+    protected SyncopeFiqlSearchConditionBuilder() {\n+        super();\n+    }\n+\n+    protected SyncopeFiqlSearchConditionBuilder(final Map<String, String> properties) {\n+        super(properties);\n+    }\n+\n+    @Override\n+    protected Builder newBuilderInstance() {\n+        return new Builder(properties);\n+    }\n+\n+    public SyncopeProperty is(final String property) {\n+        return newBuilderInstance().is(property);\n+    }\n+\n+    public CompleteCondition isNull(final String property) {\n+        return newBuilderInstance().is(property).nullValue();\n+    }\n+\n+    public CompleteCondition isNotNull(final String property) {\n+        return newBuilderInstance().is(property).notNullValue();\n+    }\n+\n+    public CompleteCondition hasResources(final String resource, final String... moreResources) {\n+        return newBuilderInstance().is(SpecialAttr.RESOURCES.toString()).hasResources(resource, moreResources);\n+    }\n+\n+    public CompleteCondition hasNotResources(final String resource, final String... moreResources) {\n+        return newBuilderInstance().is(SpecialAttr.RESOURCES.toString()).hasNotResources(resource, moreResources);\n+    }\n+\n+    protected static class Builder extends FiqlSearchConditionBuilder.Builder\n+            implements SyncopeProperty, CompleteCondition {\n+\n+        protected Builder(final Map<String, String> properties) {\n+            super(properties);\n+        }\n+\n+        protected Builder(final Builder parent) {\n+            super(parent);\n+        }\n+\n+        @Override\n+        public SyncopeProperty is(final String property) {\n+            Builder b = new Builder(this);\n+            b.result = property;\n+            return b;\n+        }\n+\n+        @Override\n+        public CompleteCondition nullValue() {\n+            return condition(FiqlParser.EQ, SpecialAttr.NULL);\n+        }\n+\n+        @Override\n+        public CompleteCondition notNullValue() {\n+            return condition(FiqlParser.NEQ, SpecialAttr.NULL);\n+        }\n+\n+        @Override\n+        public CompleteCondition hasResources(final String resource, final String... moreResources) {\n+            this.result = SpecialAttr.RESOURCES.toString();\n+            return condition(FiqlParser.EQ, resource, (Object[]) moreResources);\n+        }\n+\n+        @Override\n+        public CompleteCondition hasNotResources(final String resource, final String... moreResources) {\n+            this.result = SpecialAttr.RESOURCES.toString();\n+            return condition(FiqlParser.NEQ, resource, (Object[]) moreResources);\n+        }\n+    }\n+}"},{"sha":"0f833f83a4ce2fdc03af7afbc31e359c6def790d","filename":"syncope620/common/lib/src/main/java/org/apache/syncope/common/lib/search/SyncopeProperty.java","status":"added","additions":37,"deletions":0,"changes":37,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fsearch%2FSyncopeProperty.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fsearch%2FSyncopeProperty.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fsearch%2FSyncopeProperty.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,37 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.common.lib.search;\n+\n+import org.apache.cxf.jaxrs.ext.search.client.CompleteCondition;\n+import org.apache.cxf.jaxrs.ext.search.client.Property;\n+\n+/**\n+ * Extension of fluent interface, for {@link SyncopeFiqlSearchConditionBuilder}.\n+ */\n+public abstract interface SyncopeProperty extends Property {\n+\n+    CompleteCondition nullValue();\n+\n+    CompleteCondition notNullValue();\n+    \n+    CompleteCondition hasResources(String resource, String... moreResources);\n+\n+    CompleteCondition hasNotResources(String resource, String... moreResources);\n+\n+}"},{"sha":"ef16e3d5a35ffe2d7c380d13636b7e2456fdb2c4","filename":"syncope620/common/lib/src/main/java/org/apache/syncope/common/lib/search/UserFiqlSearchConditionBuilder.java","status":"added","additions":95,"deletions":0,"changes":95,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fsearch%2FUserFiqlSearchConditionBuilder.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fsearch%2FUserFiqlSearchConditionBuilder.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fsearch%2FUserFiqlSearchConditionBuilder.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,95 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.common.lib.search;\n+\n+import java.util.Map;\n+import org.apache.cxf.jaxrs.ext.search.client.CompleteCondition;\n+import org.apache.cxf.jaxrs.ext.search.fiql.FiqlParser;\n+\n+/**\n+ * Extends <tt>SyncopeFiqlSearchConditionBuilder</tt> by providing some additional facilities for searching\n+ * users in Syncope.\n+ */\n+public class UserFiqlSearchConditionBuilder extends SyncopeFiqlSearchConditionBuilder {\n+\n+    public UserFiqlSearchConditionBuilder() {\n+        super();\n+    }\n+\n+    public UserFiqlSearchConditionBuilder(final Map<String, String> properties) {\n+        super(properties);\n+    }\n+\n+    @Override\n+    protected Builder newBuilderInstance() {\n+        return new Builder(properties);\n+    }\n+\n+    @Override\n+    public UserProperty is(final String property) {\n+        return newBuilderInstance().is(property);\n+    }\n+\n+    public CompleteCondition hasRoles(final Long role, final Long... moreRoles) {\n+        return newBuilderInstance().is(SpecialAttr.ROLES.toString()).hasRoles(role, moreRoles);\n+    }\n+\n+    public CompleteCondition hasNotRoles(final Long role, final Long... moreRoles) {\n+        return newBuilderInstance().is(SpecialAttr.ROLES.toString()).hasNotRoles(role, moreRoles);\n+    }\n+\n+    public CompleteCondition hasResources(final String resource, final String... moreResources) {\n+        return newBuilderInstance().is(SpecialAttr.RESOURCES.toString()).hasResources(resource, moreResources);\n+    }\n+\n+    public CompleteCondition hasNotResources(final String resource, final String... moreResources) {\n+        return newBuilderInstance().is(SpecialAttr.RESOURCES.toString()).hasNotResources(resource, moreResources);\n+    }\n+\n+    protected static class Builder extends SyncopeFiqlSearchConditionBuilder.Builder\n+            implements UserProperty, CompleteCondition {\n+\n+        public Builder(final Map<String, String> properties) {\n+            super(properties);\n+        }\n+\n+        public Builder(final Builder parent) {\n+            super(parent);\n+        }\n+\n+        @Override\n+        public UserProperty is(final String property) {\n+            Builder b = new Builder(this);\n+            b.result = property;\n+            return b;\n+        }\n+\n+        @Override\n+        public CompleteCondition hasRoles(final Long role, final Long... moreRoles) {\n+            this.result = SpecialAttr.ROLES.toString();\n+            return condition(FiqlParser.EQ, role, (Object[]) moreRoles);\n+        }\n+\n+        @Override\n+        public CompleteCondition hasNotRoles(final Long role, final Long... moreRoles) {\n+            this.result = SpecialAttr.ROLES.toString();\n+            return condition(FiqlParser.NEQ, role, (Object[]) moreRoles);\n+        }\n+    }\n+}"},{"sha":"886f27ff06a07553be08383021be3172c04348d3","filename":"syncope620/common/lib/src/main/java/org/apache/syncope/common/lib/search/UserProperty.java","status":"added","additions":29,"deletions":0,"changes":29,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fsearch%2FUserProperty.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fsearch%2FUserProperty.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fsearch%2FUserProperty.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,29 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.common.lib.search;\n+\n+import org.apache.cxf.jaxrs.ext.search.client.CompleteCondition;\n+\n+public interface UserProperty extends SyncopeProperty {\n+\n+    CompleteCondition hasRoles(Long role, Long... moreRoles);\n+\n+    CompleteCondition hasNotRoles(Long role, Long... moreRoles);\n+\n+}"},{"sha":"0794b091f384fb40a2fb178517fb76e63bc4a4d8","filename":"syncope620/common/lib/src/main/java/org/apache/syncope/common/lib/to/AbstractAttributableTO.java","status":"modified","additions":5,"deletions":5,"changes":10,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FAbstractAttributableTO.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FAbstractAttributableTO.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FAbstractAttributableTO.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -34,18 +34,18 @@ public abstract class AbstractAttributableTO extends ConnObjectTO {\n \n     private static final long serialVersionUID = 4083884098736820255L;\n \n-    private long id;\n+    private long key;\n \n     private final List<AttrTO> derAttrs = new ArrayList<>();\n \n     private final List<AttrTO> virAttrs = new ArrayList<>();\n \n-    public long getId() {\n-        return id;\n+    public long getKey() {\n+        return key;\n     }\n \n-    public void setId(final long id) {\n-        this.id = id;\n+    public void setKey(final long id) {\n+        this.key = id;\n     }\n \n     @JsonIgnore"},{"sha":"71b735fb44b72214f2193dc52c26868f27c92e5e","filename":"syncope620/common/lib/src/main/java/org/apache/syncope/common/lib/to/AbstractExecTO.java","status":"added","additions":87,"deletions":0,"changes":87,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FAbstractExecTO.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FAbstractExecTO.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FAbstractExecTO.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,87 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.common.lib.to;\n+\n+import java.util.Date;\n+import javax.xml.bind.annotation.XmlType;\n+import org.apache.syncope.common.lib.AbstractBaseBean;\n+\n+@XmlType\n+public class AbstractExecTO extends AbstractBaseBean {\n+\n+    private static final long serialVersionUID = -4621191979198357081L;\n+\n+    protected long key;\n+\n+    protected String status;\n+\n+    protected String message;\n+\n+    protected Date startDate;\n+\n+    protected Date endDate;\n+\n+    public long getKey() {\n+        return key;\n+    }\n+\n+    public void setKey(long key) {\n+        this.key = key;\n+    }\n+\n+    public String getMessage() {\n+        return message;\n+    }\n+\n+    public void setMessage(final String message) {\n+        this.message = message;\n+    }\n+\n+    public String getStatus() {\n+        return status;\n+    }\n+\n+    public void setStatus(final String status) {\n+        this.status = status;\n+    }\n+\n+    public Date getStartDate() {\n+        return startDate == null\n+                ? null\n+                : new Date(startDate.getTime());\n+    }\n+\n+    public void setStartDate(final Date startDate) {\n+        if (startDate != null) {\n+            this.startDate = new Date(startDate.getTime());\n+        }\n+    }\n+\n+    public Date getEndDate() {\n+        return endDate == null\n+                ? null\n+                : new Date(endDate.getTime());\n+    }\n+\n+    public void setEndDate(final Date endDate) {\n+        if (endDate != null) {\n+            this.endDate = new Date(endDate.getTime());\n+        }\n+    }\n+}"},{"sha":"4423e41f1ed0b9d954591b126445531ba0e3bba2","filename":"syncope620/common/lib/src/main/java/org/apache/syncope/common/lib/to/AbstractPolicyTO.java","status":"added","additions":89,"deletions":0,"changes":89,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FAbstractPolicyTO.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FAbstractPolicyTO.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FAbstractPolicyTO.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,89 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.common.lib.to;\n+\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlElementWrapper;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.bind.annotation.XmlSeeAlso;\n+import javax.xml.bind.annotation.XmlType;\n+import org.apache.syncope.common.lib.AbstractBaseBean;\n+import org.apache.syncope.common.lib.types.PolicyType;\n+\n+@XmlRootElement(name = \"abstractPolicy\")\n+@XmlType\n+@XmlSeeAlso({ AccountPolicyTO.class, PasswordPolicyTO.class, SyncPolicyTO.class })\n+@JsonTypeInfo(use = JsonTypeInfo.Id.CLASS, include = JsonTypeInfo.As.PROPERTY, property = \"@class\")\n+public abstract class AbstractPolicyTO extends AbstractBaseBean {\n+\n+    private static final long serialVersionUID = -2903888572649721035L;\n+\n+    private long id;\n+\n+    private String description;\n+\n+    private PolicyType type;\n+\n+    private final List<String> usedByResources = new ArrayList<>();\n+\n+    private final List<Long> usedByRoles = new ArrayList<>();\n+\n+    public long getId() {\n+        return id;\n+    }\n+\n+    public void setId(long id) {\n+        this.id = id;\n+    }\n+\n+    public String getDescription() {\n+        return description;\n+    }\n+\n+    public void setDescription(final String description) {\n+        this.description = description;\n+    }\n+\n+    public PolicyType getType() {\n+        return type;\n+    }\n+\n+    public void setType(final PolicyType type) {\n+        this.type = type;\n+    }\n+\n+    @XmlElementWrapper(name = \"usedByResources\")\n+    @XmlElement(name = \"resource\")\n+    @JsonProperty(\"usedByResources\")\n+    public List<String> getUsedByResources() {\n+        return usedByResources;\n+    }\n+\n+    @XmlElementWrapper(name = \"usedByRoles\")\n+    @XmlElement(name = \"role\")\n+    @JsonProperty(\"usedByRoles\")\n+    public List<Long> getUsedByRoles() {\n+        return usedByRoles;\n+    }\n+\n+}"},{"sha":"fe92877b8ad583a6459928bf5c0f425d474791c6","filename":"syncope620/common/lib/src/main/java/org/apache/syncope/common/lib/to/AbstractProvisioningTaskTO.java","status":"added","additions":117,"deletions":0,"changes":117,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FAbstractProvisioningTaskTO.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FAbstractProvisioningTaskTO.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FAbstractProvisioningTaskTO.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,117 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.common.lib.to;\n+\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlElementWrapper;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.bind.annotation.XmlSeeAlso;\n+import javax.xml.bind.annotation.XmlType;\n+import org.apache.syncope.common.lib.types.MatchingRule;\n+import org.apache.syncope.common.lib.types.UnmatchingRule;\n+\n+@XmlRootElement(name = \"abstractProvisioningTask\")\n+@XmlType\n+@XmlSeeAlso({ PushTaskTO.class, SyncTaskTO.class })\n+public class AbstractProvisioningTaskTO extends SchedTaskTO {\n+\n+    private static final long serialVersionUID = -2143537546915809016L;\n+\n+    private String resource;\n+\n+    private boolean performCreate;\n+\n+    private boolean performUpdate;\n+\n+    private boolean performDelete;\n+\n+    private boolean syncStatus;\n+\n+    private UnmatchingRule unmatchingRule;\n+\n+    private MatchingRule matchingRule;\n+\n+    private List<String> actionsClassNames = new ArrayList<>();\n+\n+    public String getResource() {\n+        return resource;\n+    }\n+\n+    public void setResource(String resource) {\n+        this.resource = resource;\n+    }\n+\n+    public boolean isPerformCreate() {\n+        return performCreate;\n+    }\n+\n+    public void setPerformCreate(boolean performCreate) {\n+        this.performCreate = performCreate;\n+    }\n+\n+    public boolean isPerformUpdate() {\n+        return performUpdate;\n+    }\n+\n+    public void setPerformUpdate(boolean performUpdate) {\n+        this.performUpdate = performUpdate;\n+    }\n+\n+    public boolean isPerformDelete() {\n+        return performDelete;\n+    }\n+\n+    public void setPerformDelete(boolean performDelete) {\n+        this.performDelete = performDelete;\n+    }\n+\n+    public boolean isSyncStatus() {\n+        return syncStatus;\n+    }\n+\n+    public void setSyncStatus(boolean syncStatus) {\n+        this.syncStatus = syncStatus;\n+    }\n+\n+    @XmlElementWrapper(name = \"actionsClassNames\")\n+    @XmlElement(name = \"actionsClassName\")\n+    @JsonProperty(\"actionsClassNames\")\n+    public List<String> getActionsClassNames() {\n+        return actionsClassNames;\n+    }\n+\n+    public UnmatchingRule getUnmatchingRule() {\n+        return unmatchingRule;\n+    }\n+\n+    public void setUnmatchingRule(final UnmatchingRule unmatchigRule) {\n+        this.unmatchingRule = unmatchigRule;\n+    }\n+\n+    public MatchingRule getMatchingRule() {\n+        return matchingRule;\n+    }\n+\n+    public void setMatchingRule(final MatchingRule matchigRule) {\n+        this.matchingRule = matchigRule;\n+    }\n+}"},{"sha":"b3a37a8798dfbdf6a1fbfe22a958b4cd31d42992","filename":"syncope620/common/lib/src/main/java/org/apache/syncope/common/lib/to/AbstractSchemaTO.java","status":"added","additions":44,"deletions":0,"changes":44,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FAbstractSchemaTO.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FAbstractSchemaTO.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FAbstractSchemaTO.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,44 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.common.lib.to;\n+\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.bind.annotation.XmlSeeAlso;\n+import javax.xml.bind.annotation.XmlType;\n+import org.apache.syncope.common.lib.AbstractBaseBean;\n+\n+@XmlRootElement(name = \"abstractSchema\")\n+@XmlType\n+@XmlSeeAlso({ PlainSchemaTO.class, DerSchemaTO.class, VirSchemaTO.class })\n+@JsonTypeInfo(use = JsonTypeInfo.Id.CLASS, include = JsonTypeInfo.As.PROPERTY, property = \"@class\")\n+public abstract class AbstractSchemaTO extends AbstractBaseBean {\n+\n+    private static final long serialVersionUID = 4088388951694301759L;\n+\n+    private String key;\n+\n+    public String getKey() {\n+        return key;\n+    }\n+\n+    public void setKey(final String key) {\n+        this.key = key;\n+    }\n+}"},{"sha":"6ed17505da0ffd9c8e2d1002923b518d14ac727a","filename":"syncope620/common/lib/src/main/java/org/apache/syncope/common/lib/to/AbstractTaskTO.java","status":"added","additions":98,"deletions":0,"changes":98,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FAbstractTaskTO.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FAbstractTaskTO.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FAbstractTaskTO.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,98 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.common.lib.to;\n+\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.List;\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlElementWrapper;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.bind.annotation.XmlSeeAlso;\n+import javax.xml.bind.annotation.XmlType;\n+import org.apache.syncope.common.lib.AbstractBaseBean;\n+\n+@XmlRootElement(name = \"abstractTask\")\n+@XmlType\n+@XmlSeeAlso({ PropagationTaskTO.class, SchedTaskTO.class, NotificationTaskTO.class })\n+@JsonTypeInfo(use = JsonTypeInfo.Id.CLASS, include = JsonTypeInfo.As.PROPERTY, property = \"@class\")\n+public abstract class AbstractTaskTO extends AbstractBaseBean {\n+\n+    private static final long serialVersionUID = 386450127003321197L;\n+\n+    private long id;\n+\n+    private String latestExecStatus;\n+\n+    private List<TaskExecTO> executions = new ArrayList<>();\n+\n+    private Date startDate;\n+\n+    private Date endDate;\n+\n+    public long getId() {\n+        return id;\n+    }\n+\n+    public void setId(final long id) {\n+        this.id = id;\n+    }\n+\n+    public String getLatestExecStatus() {\n+        return latestExecStatus;\n+    }\n+\n+    public void setLatestExecStatus(final String latestExecStatus) {\n+        this.latestExecStatus = latestExecStatus;\n+    }\n+\n+    @XmlElementWrapper(name = \"executions\")\n+    @XmlElement(name = \"execution\")\n+    @JsonProperty(\"executions\")\n+    public List<TaskExecTO> getExecutions() {\n+        return executions;\n+    }\n+\n+    public Date getStartDate() {\n+        return startDate == null\n+                ? null\n+                : new Date(startDate.getTime());\n+    }\n+\n+    public void setStartDate(final Date startDate) {\n+        if (startDate != null) {\n+            this.startDate = new Date(startDate.getTime());\n+        }\n+    }\n+\n+    public Date getEndDate() {\n+        return endDate == null\n+                ? null\n+                : new Date(endDate.getTime());\n+    }\n+\n+    public void setEndDate(final Date endDate) {\n+        if (endDate != null) {\n+            this.endDate = new Date(endDate.getTime());\n+        }\n+    }\n+}"},{"sha":"a58b24f9c94690a4b0f576db0206efdaef3441fa","filename":"syncope620/common/lib/src/main/java/org/apache/syncope/common/lib/to/AccountPolicyTO.java","status":"added","additions":68,"deletions":0,"changes":68,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FAccountPolicyTO.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FAccountPolicyTO.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FAccountPolicyTO.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,68 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.common.lib.to;\n+\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlElementWrapper;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.bind.annotation.XmlType;\n+import org.apache.syncope.common.lib.types.AccountPolicySpec;\n+import org.apache.syncope.common.lib.types.PolicyType;\n+\n+@XmlRootElement(name = \"accountPolicy\")\n+@XmlType\n+public class AccountPolicyTO extends AbstractPolicyTO {\n+\n+    private static final long serialVersionUID = -1557150042828800134L;\n+\n+    private AccountPolicySpec specification;\n+\n+    private final List<String> resources = new ArrayList<String>();\n+\n+    public AccountPolicyTO() {\n+        this(false);\n+    }\n+\n+    public AccountPolicyTO(final boolean global) {\n+        super();\n+\n+        PolicyType type = global\n+                ? PolicyType.GLOBAL_ACCOUNT\n+                : PolicyType.ACCOUNT;\n+        setType(type);\n+    }\n+\n+    public void setSpecification(final AccountPolicySpec specification) {\n+        this.specification = specification;\n+    }\n+\n+    public AccountPolicySpec getSpecification() {\n+        return specification;\n+    }\n+\n+    @XmlElementWrapper(name = \"resources\")\n+    @XmlElement(name = \"resource\")\n+    @JsonProperty(\"resources\")\n+    public List<String> getResources() {\n+        return resources;\n+    }\n+}"},{"sha":"a514dcb80577b29a54b77878f9e90d7b283f885e","filename":"syncope620/common/lib/src/main/java/org/apache/syncope/common/lib/to/BulkAction.java","status":"added","additions":70,"deletions":0,"changes":70,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FBulkAction.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FBulkAction.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FBulkAction.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,70 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.common.lib.to;\n+\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlElementWrapper;\n+import javax.xml.bind.annotation.XmlEnum;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.bind.annotation.XmlType;\n+import org.apache.syncope.common.lib.AbstractBaseBean;\n+\n+@XmlRootElement(name = \"bulkAction\")\n+@XmlType\n+public class BulkAction extends AbstractBaseBean {\n+\n+    private static final long serialVersionUID = 1395353278878758961L;\n+\n+    @XmlEnum\n+    @XmlType(name = \"bulkActionType\")\n+    public enum Type {\n+\n+        DELETE,\n+        REACTIVATE,\n+        SUSPEND,\n+        DRYRUN,\n+        EXECUTE\n+\n+    }\n+\n+    private Type operation;\n+\n+    /**\n+     * Serialized identifiers.\n+     */\n+    private final List<String> targets = new ArrayList<>();\n+\n+    public Type getOperation() {\n+        return operation;\n+    }\n+\n+    public void setOperation(final Type operation) {\n+        this.operation = operation;\n+    }\n+\n+    @XmlElementWrapper(name = \"targets\")\n+    @XmlElement(name = \"target\")\n+    @JsonProperty(\"targets\")\n+    public List<String> getTargets() {\n+        return targets;\n+    }\n+}"},{"sha":"dfe52dedecfc273de3afa40b1df9f17f51a563bf","filename":"syncope620/common/lib/src/main/java/org/apache/syncope/common/lib/to/BulkActionResult.java","status":"added","additions":134,"deletions":0,"changes":134,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FBulkActionResult.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FBulkActionResult.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FBulkActionResult.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,134 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.common.lib.to;\n+\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlElementWrapper;\n+import javax.xml.bind.annotation.XmlEnum;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.bind.annotation.XmlType;\n+import org.apache.syncope.common.lib.AbstractBaseBean;\n+\n+@XmlRootElement(name = \"bulkActionResult\")\n+@XmlType\n+public class BulkActionResult extends AbstractBaseBean {\n+\n+    private static final long serialVersionUID = 2868894178821778133L;\n+\n+    @XmlEnum\n+    @XmlType(name = \"bulkActionStatus\")\n+    public enum Status {\n+\n+        // general bulk action result statuses\n+        SUCCESS,\n+        FAILURE,\n+        // specific propagation task execution statuses\n+        CREATED,\n+        SUBMITTED,\n+        UNSUBMITTED;\n+\n+    }\n+\n+    private final List<Result> results = new ArrayList<Result>();\n+\n+    @XmlElementWrapper(name = \"result\")\n+    @XmlElement(name = \"item\")\n+    @JsonProperty(\"result\")\n+    public List<Result> getResult() {\n+        return results;\n+    }\n+\n+    @JsonIgnore\n+    public void add(final Object id, final Status status) {\n+        if (id != null) {\n+            results.add(new Result(id.toString(), status));\n+        }\n+    }\n+\n+    @JsonIgnore\n+    public void add(final Object id, final String status) {\n+        if (id != null) {\n+            results.add(new Result(id.toString(), Status.valueOf(status.toUpperCase())));\n+        }\n+    }\n+\n+    @JsonIgnore\n+    public Map<String, Status> getResultMap() {\n+        final Map<String, Status> res = new HashMap<String, Status>();\n+\n+        for (Result result : results) {\n+            res.put(result.getKey(), result.getValue());\n+        }\n+\n+        return res;\n+    }\n+\n+    @JsonIgnore\n+    public List<String> getResultByStatus(final Status status) {\n+        final List<String> res = new ArrayList<String>();\n+\n+        for (Result result : results) {\n+            if (result.getValue() == status) {\n+                res.add(result.getKey());\n+            }\n+        }\n+\n+        return res;\n+    }\n+\n+    public static class Result extends AbstractBaseBean {\n+\n+        private static final long serialVersionUID = -1149681964161193232L;\n+\n+        private String key;\n+\n+        private Status value;\n+\n+        public Result() {\n+            super();\n+        }\n+\n+        public Result(final String key, final Status value) {\n+            this.key = key;\n+            this.value = value;\n+        }\n+\n+        public String getKey() {\n+            return key;\n+        }\n+\n+        public Status getValue() {\n+            return value;\n+        }\n+\n+        public void setKey(final String key) {\n+            this.key = key;\n+        }\n+\n+        public void setValue(final Status value) {\n+            this.value = value;\n+        }\n+    }\n+}"},{"sha":"4856a48db8089f7ade68c7f176670e30300d5ce1","filename":"syncope620/common/lib/src/main/java/org/apache/syncope/common/lib/to/ConfTO.java","status":"added","additions":30,"deletions":0,"changes":30,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FConfTO.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FConfTO.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FConfTO.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,30 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.common.lib.to;\n+\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.bind.annotation.XmlType;\n+\n+@XmlRootElement(name = \"conf\")\n+@XmlType\n+public class ConfTO extends AbstractAttributableTO {\n+\n+    private static final long serialVersionUID = -3825039700228595590L;\n+\n+}"},{"sha":"87583a4ecdb3ff205bf320d2b9262e0d476f6b7e","filename":"syncope620/common/lib/src/main/java/org/apache/syncope/common/lib/to/ConnBundleTO.java","status":"added","additions":95,"deletions":0,"changes":95,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FConnBundleTO.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FConnBundleTO.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FConnBundleTO.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,95 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.common.lib.to;\n+\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlElementWrapper;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.bind.annotation.XmlType;\n+import org.apache.syncope.common.lib.AbstractBaseBean;\n+import org.apache.syncope.common.lib.types.ConnConfPropSchema;\n+\n+@XmlRootElement(name = \"connectorBundle\")\n+@XmlType\n+public class ConnBundleTO extends AbstractBaseBean {\n+\n+    private static final long serialVersionUID = 7215115961910138005L;\n+\n+    private String displayName;\n+\n+    private String location;\n+\n+    private String bundleName;\n+\n+    private String connectorName;\n+\n+    private String version;\n+\n+    private List<ConnConfPropSchema> properties = new ArrayList<>();\n+\n+    public String getDisplayName() {\n+        return displayName;\n+    }\n+\n+    public void setDisplayName(final String displayName) {\n+        this.displayName = displayName;\n+    }\n+\n+    public String getLocation() {\n+        return location;\n+    }\n+\n+    public void setLocation(final String location) {\n+        this.location = location;\n+    }\n+\n+    public String getBundleName() {\n+        return bundleName;\n+    }\n+\n+    public void setBundleName(final String bundleName) {\n+        this.bundleName = bundleName;\n+    }\n+\n+    public String getConnectorName() {\n+        return connectorName;\n+    }\n+\n+    public void setConnectorName(final String connectorName) {\n+        this.connectorName = connectorName;\n+    }\n+\n+    @XmlElementWrapper(name = \"properties\")\n+    @XmlElement(name = \"connConfPropSchema\")\n+    @JsonProperty(\"properties\")\n+    public List<ConnConfPropSchema> getProperties() {\n+        return properties;\n+    }\n+\n+    public String getVersion() {\n+        return version;\n+    }\n+\n+    public void setVersion(final String version) {\n+        this.version = version;\n+    }\n+}"},{"sha":"5c25783553607e3072bb438d7e4f700dad6ac964","filename":"syncope620/common/lib/src/main/java/org/apache/syncope/common/lib/to/ConnInstanceTO.java","status":"added","additions":177,"deletions":0,"changes":177,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FConnInstanceTO.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FConnInstanceTO.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FConnInstanceTO.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,177 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.common.lib.to;\n+\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import java.util.Collections;\n+import java.util.EnumSet;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlElementWrapper;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.bind.annotation.XmlType;\n+import org.apache.syncope.common.lib.AbstractBaseBean;\n+import org.apache.syncope.common.lib.types.ConnConfProperty;\n+import org.apache.syncope.common.lib.types.ConnectorCapability;\n+\n+@XmlRootElement(name = \"connInstance\")\n+@XmlType\n+public class ConnInstanceTO extends AbstractBaseBean {\n+\n+    private static final long serialVersionUID = 2707778645445168671L;\n+\n+    private long key;\n+\n+    private String location;\n+\n+    private String connectorName;\n+\n+    private String bundleName;\n+\n+    private String version;\n+\n+    private final Set<ConnConfProperty> configuration;\n+\n+    private final Set<ConnectorCapability> capabilities;\n+\n+    private String displayName;\n+\n+    private Integer connRequestTimeout;\n+\n+    private ConnPoolConfTO poolConf;\n+\n+    public ConnInstanceTO() {\n+        super();\n+\n+        configuration = new HashSet<>();\n+        capabilities = EnumSet.noneOf(ConnectorCapability.class);\n+    }\n+\n+    public long getKey() {\n+        return key;\n+    }\n+\n+    public void setKey(final long key) {\n+        this.key = key;\n+    }\n+\n+    public String getLocation() {\n+        return location;\n+    }\n+\n+    public void setLocation(final String location) {\n+        this.location = location;\n+    }\n+\n+    public String getConnectorName() {\n+        return connectorName;\n+    }\n+\n+    public void setConnectorName(final String connectorname) {\n+        this.connectorName = connectorname;\n+    }\n+\n+    public String getBundleName() {\n+        return bundleName;\n+    }\n+\n+    public void setBundleName(final String bundlename) {\n+        this.bundleName = bundlename;\n+    }\n+\n+    public String getVersion() {\n+        return version;\n+    }\n+\n+    public void setVersion(final String version) {\n+        this.version = version;\n+    }\n+\n+    @XmlElementWrapper(name = \"configuration\")\n+    @XmlElement(name = \"property\")\n+    @JsonProperty(\"configuration\")\n+    public Set<ConnConfProperty> getConfiguration() {\n+        return this.configuration;\n+    }\n+\n+    @JsonIgnore\n+    public Map<String, ConnConfProperty> getConfigurationMap() {\n+        Map<String, ConnConfProperty> result;\n+\n+        if (getConfiguration() == null) {\n+            result = Collections.<String, ConnConfProperty>emptyMap();\n+        } else {\n+            result = new HashMap<>();\n+            for (ConnConfProperty prop : getConfiguration()) {\n+                result.put(prop.getSchema().getName(), prop);\n+            }\n+            result = Collections.unmodifiableMap(result);\n+        }\n+\n+        return result;\n+    }\n+\n+    @XmlElementWrapper(name = \"capabilities\")\n+    @XmlElement(name = \"capability\")\n+    @JsonProperty(\"capabilities\")\n+    public Set<ConnectorCapability> getCapabilities() {\n+        return capabilities;\n+    }\n+\n+    public String getDisplayName() {\n+        return displayName;\n+    }\n+\n+    public void setDisplayName(final String displayName) {\n+        this.displayName = displayName;\n+    }\n+\n+    /**\n+     * Get connector request timeout.\n+     * It is not applied in case of sync, full reconciliation and search.\n+     *\n+     * @return timeout.\n+     */\n+    public Integer getConnRequestTimeout() {\n+        return connRequestTimeout;\n+    }\n+\n+    /**\n+     * Set connector request timeout.\n+     * It is not applied in case of sync, full reconciliation and search.\n+     *\n+     * @param connRequestTimeout timeout\n+     */\n+    public void setConnRequestTimeout(final Integer connRequestTimeout) {\n+        this.connRequestTimeout = connRequestTimeout;\n+    }\n+\n+    public ConnPoolConfTO getPoolConf() {\n+        return poolConf;\n+    }\n+\n+    public void setPoolConf(final ConnPoolConfTO poolConf) {\n+        this.poolConf = poolConf;\n+    }\n+\n+}"},{"sha":"dc84864b5c1ae7f24f98121fb2503a79600047a8","filename":"syncope620/common/lib/src/main/java/org/apache/syncope/common/lib/to/DerSchemaTO.java","status":"added","additions":39,"deletions":0,"changes":39,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FDerSchemaTO.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FDerSchemaTO.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FDerSchemaTO.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,39 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.common.lib.to;\n+\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.bind.annotation.XmlType;\n+\n+@XmlRootElement(name = \"derivedSchema\")\n+@XmlType\n+public class DerSchemaTO extends AbstractSchemaTO {\n+\n+    private static final long serialVersionUID = -6747399803792103108L;\n+\n+    private String expression;\n+\n+    public String getExpression() {\n+        return expression;\n+    }\n+\n+    public void setExpression(final String expression) {\n+        this.expression = expression;\n+    }\n+}"},{"sha":"e0f14adcbb998c1b1a4248b28a5b7e964dff4425","filename":"syncope620/common/lib/src/main/java/org/apache/syncope/common/lib/to/ErrorTO.java","status":"added","additions":66,"deletions":0,"changes":66,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FErrorTO.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FErrorTO.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FErrorTO.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,66 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.common.lib.to;\n+\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlElementWrapper;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.bind.annotation.XmlType;\n+import org.apache.syncope.common.lib.AbstractBaseBean;\n+import org.apache.syncope.common.lib.types.ClientExceptionType;\n+\n+@XmlRootElement(name = \"error\")\n+@XmlType\n+public class ErrorTO extends AbstractBaseBean {\n+\n+    private static final long serialVersionUID = 2435764161719225927L;\n+\n+    private int status;\n+\n+    private ClientExceptionType type;\n+\n+    private final List<Object> elements = new ArrayList<>();\n+\n+    public int getStatus() {\n+        return status;\n+    }\n+\n+    public void setStatus(final int status) {\n+        this.status = status;\n+    }\n+\n+    public ClientExceptionType getType() {\n+        return type;\n+    }\n+\n+    public void setType(final ClientExceptionType type) {\n+        this.type = type;\n+    }\n+\n+    @XmlElementWrapper(name = \"elements\")\n+    @XmlElement(name = \"element\")\n+    @JsonProperty(\"elements\")\n+    public List<Object> getElements() {\n+        return elements;\n+    }\n+\n+}"},{"sha":"8e11686acb726cc97c00098fa75cc92958563824","filename":"syncope620/common/lib/src/main/java/org/apache/syncope/common/lib/to/EventCategoryTO.java","status":"added","additions":89,"deletions":0,"changes":89,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FEventCategoryTO.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FEventCategoryTO.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FEventCategoryTO.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,89 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.common.lib.to;\n+\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlElementWrapper;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.bind.annotation.XmlType;\n+import org.apache.syncope.common.lib.AbstractBaseBean;\n+import org.apache.syncope.common.lib.types.AuditElements;\n+\n+@XmlRootElement(name = \"eventCategory\")\n+@XmlType\n+public class EventCategoryTO extends AbstractBaseBean {\n+\n+    private static final long serialVersionUID = -4340060002701633401L;\n+\n+    private AuditElements.EventCategoryType type;\n+\n+    private String category;\n+\n+    private String subcategory;\n+\n+    private final List<String> events = new ArrayList<String>();\n+\n+    /**\n+     * Constructor for Type.REST event category.\n+     */\n+    public EventCategoryTO() {\n+        this.type = AuditElements.EventCategoryType.REST;\n+    }\n+\n+    /**\n+     * Constructor for the given Type event category.\n+     */\n+    public EventCategoryTO(final AuditElements.EventCategoryType type) {\n+        this.type = type;\n+    }\n+\n+    public AuditElements.EventCategoryType getType() {\n+        return type;\n+    }\n+\n+    public void setType(final AuditElements.EventCategoryType type) {\n+        this.type = type == null ? AuditElements.EventCategoryType.CUSTOM : type;\n+    }\n+\n+    public String getCategory() {\n+        return category;\n+    }\n+\n+    public void setCategory(final String category) {\n+        this.category = category;\n+    }\n+\n+    public String getSubcategory() {\n+        return subcategory;\n+    }\n+\n+    public void setSubcategory(final String subcategory) {\n+        this.subcategory = subcategory;\n+    }\n+\n+    @XmlElementWrapper(name = \"events\")\n+    @XmlElement(name = \"event\")\n+    @JsonProperty(\"events\")\n+    public List<String> getEvents() {\n+        return events;\n+    }\n+}"},{"sha":"263ab97fe5a781211d0a66fab886245a23d9c532","filename":"syncope620/common/lib/src/main/java/org/apache/syncope/common/lib/to/LoggerTO.java","status":"added","additions":51,"deletions":0,"changes":51,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FLoggerTO.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FLoggerTO.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FLoggerTO.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,51 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.common.lib.to;\n+\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.bind.annotation.XmlType;\n+import org.apache.syncope.common.lib.AbstractBaseBean;\n+import org.apache.syncope.common.lib.types.LoggerLevel;\n+\n+@XmlRootElement(name = \"logger\")\n+@XmlType\n+public class LoggerTO extends AbstractBaseBean {\n+\n+    private static final long serialVersionUID = -7794833835668648505L;\n+\n+    private String name;\n+\n+    private LoggerLevel level;\n+\n+    public LoggerLevel getLevel() {\n+        return level;\n+    }\n+\n+    public void setLevel(final LoggerLevel level) {\n+        this.level = level;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public void setName(final String name) {\n+        this.name = name;\n+    }\n+}"},{"sha":"4df561ce6c8ae882a157069353597e6b50f5e6eb","filename":"syncope620/common/lib/src/main/java/org/apache/syncope/common/lib/to/MappingItemTO.java","status":"added","additions":134,"deletions":0,"changes":134,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FMappingItemTO.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FMappingItemTO.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FMappingItemTO.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,134 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.common.lib.to;\n+\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.bind.annotation.XmlType;\n+import org.apache.syncope.common.lib.AbstractBaseBean;\n+import org.apache.syncope.common.lib.types.IntMappingType;\n+import org.apache.syncope.common.lib.types.MappingPurpose;\n+\n+@XmlRootElement(name = \"mappingItem\")\n+@XmlType\n+public class MappingItemTO extends AbstractBaseBean {\n+\n+    private static final long serialVersionUID = 2983498836767176862L;\n+\n+    private Long key;\n+\n+    /**\n+     * Attribute schema to be mapped. Consider that we can associate tha same attribute schema more than once, with\n+     * different aliases, to different resource attributes.\n+     */\n+    private String intAttrName;\n+\n+    /**\n+     * Schema type to be mapped.\n+     */\n+    private IntMappingType intMappingType;\n+\n+    /**\n+     * External resource's field to be mapped.\n+     */\n+    private String extAttrName;\n+\n+    /**\n+     * Specify if the mapped target resource's field is the key.\n+     */\n+    private boolean accountid;\n+\n+    /**\n+     * Specify if the mapped target resource's field is the password.\n+     */\n+    private boolean password;\n+\n+    /**\n+     * Specify if the mapped target resource's field is nullable.\n+     */\n+    private String mandatoryCondition = \"false\";\n+\n+    /**\n+     * Mapping purposes: SYNCHRONIZATION, PROPAGATION, BOTH, NONE.\n+     */\n+    private MappingPurpose purpose;\n+\n+    public boolean isAccountid() {\n+        return accountid;\n+    }\n+\n+    public void setAccountid(final boolean accountid) {\n+        this.accountid = accountid;\n+    }\n+\n+    public String getExtAttrName() {\n+        return extAttrName;\n+    }\n+\n+    public void setExtAttrName(final String extAttrName) {\n+        this.extAttrName = extAttrName;\n+    }\n+\n+    public Long getKey() {\n+        return key;\n+    }\n+\n+    public void setKey(final Long key) {\n+        this.key = key;\n+    }\n+\n+    public String getMandatoryCondition() {\n+        return mandatoryCondition;\n+    }\n+\n+    public void setMandatoryCondition(final String mandatoryCondition) {\n+        this.mandatoryCondition = mandatoryCondition;\n+    }\n+\n+    public boolean isPassword() {\n+        return password;\n+    }\n+\n+    public void setPassword(final boolean password) {\n+        this.password = password;\n+    }\n+\n+    public String getIntAttrName() {\n+        return intAttrName;\n+    }\n+\n+    public void setIntAttrName(final String intAttrName) {\n+        this.intAttrName = intAttrName;\n+    }\n+\n+    public IntMappingType getIntMappingType() {\n+        return intMappingType;\n+    }\n+\n+    public void setIntMappingType(final IntMappingType intMappingType) {\n+        this.intMappingType = intMappingType;\n+    }\n+\n+    public MappingPurpose getPurpose() {\n+        return purpose;\n+    }\n+\n+    public void setPurpose(final MappingPurpose purpose) {\n+        this.purpose = purpose;\n+    }\n+}"},{"sha":"3d29914c0153a66560f11d5be35d8baac6c07364","filename":"syncope620/common/lib/src/main/java/org/apache/syncope/common/lib/to/MappingTO.java","status":"added","additions":120,"deletions":0,"changes":120,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FMappingTO.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FMappingTO.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FMappingTO.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,120 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.common.lib.to;\n+\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlElementWrapper;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.bind.annotation.XmlType;\n+import org.apache.syncope.common.lib.AbstractBaseBean;\n+import org.apache.syncope.common.lib.types.IntMappingType;\n+\n+@XmlRootElement(name = \"mapping\")\n+@XmlType\n+public class MappingTO extends AbstractBaseBean {\n+\n+    private static final long serialVersionUID = 8447688036282611118L;\n+\n+    private String accountLink;\n+\n+    private final List<MappingItemTO> items = new ArrayList<>();\n+\n+    public String getAccountLink() {\n+        return accountLink;\n+    }\n+\n+    public void setAccountLink(final String accountLink) {\n+        this.accountLink = accountLink;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends MappingItemTO> T getAccountIdItem() {\n+        T accountIdItem = null;\n+        for (MappingItemTO item : getItems()) {\n+            if (item.isAccountid()) {\n+                accountIdItem = (T) item;\n+            }\n+        }\n+        return accountIdItem;\n+    }\n+\n+    protected <T extends MappingItemTO> boolean addAccountIdItem(final T accountIdItem) {\n+        if (IntMappingType.UserVirtualSchema == accountIdItem.getIntMappingType()\n+                || IntMappingType.RoleVirtualSchema == accountIdItem.getIntMappingType()\n+                || IntMappingType.MembershipVirtualSchema == accountIdItem.getIntMappingType()\n+                || IntMappingType.Password == accountIdItem.getIntMappingType()) {\n+\n+            throw new IllegalArgumentException(\"Virtual attributes cannot be set as accountId\");\n+        }\n+        if (IntMappingType.Password == accountIdItem.getIntMappingType()) {\n+            throw new IllegalArgumentException(\"Password attributes cannot be set as accountId\");\n+        }\n+\n+        accountIdItem.setExtAttrName(accountIdItem.getExtAttrName());\n+        accountIdItem.setAccountid(true);\n+\n+        return this.addItem(accountIdItem);\n+    }\n+\n+    public boolean setAccountIdItem(final MappingItemTO accountIdItem) {\n+        if (accountIdItem == null) {\n+            return this.removeItem(getAccountIdItem());\n+        } else {\n+            return addAccountIdItem(accountIdItem);\n+        }\n+    }\n+\n+    public MappingItemTO getPasswordItem() {\n+        MappingItemTO passwordItem = null;\n+        for (MappingItemTO item : getItems()) {\n+            if (item.isPassword()) {\n+                passwordItem = item;\n+            }\n+        }\n+        return passwordItem;\n+    }\n+\n+    public boolean setPasswordItem(final MappingItemTO passwordItem) {\n+        if (passwordItem == null) {\n+            return this.removeItem(getPasswordItem());\n+        } else {\n+            passwordItem.setExtAttrName(null);\n+            passwordItem.setPassword(true);\n+            return addItem(passwordItem);\n+        }\n+    }\n+\n+    @XmlElementWrapper(name = \"items\")\n+    @XmlElement(name = \"item\")\n+    @JsonProperty(\"items\")\n+    public List<MappingItemTO> getItems() {\n+        return items;\n+    }\n+\n+    public boolean addItem(final MappingItemTO item) {\n+        return item == null ? false : this.items.contains(item) || this.items.add(item);\n+    }\n+\n+    public boolean removeItem(final MappingItemTO item) {\n+        return this.items.remove(item);\n+    }\n+}"},{"sha":"b921e53333df018d6d3b8efb6d501df2b68e2047","filename":"syncope620/common/lib/src/main/java/org/apache/syncope/common/lib/to/NotificationTO.java","status":"added","additions":175,"deletions":0,"changes":175,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FNotificationTO.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FNotificationTO.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FNotificationTO.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,175 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.common.lib.to;\n+\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlElementWrapper;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.bind.annotation.XmlType;\n+import org.apache.syncope.common.lib.AbstractBaseBean;\n+import org.apache.syncope.common.lib.types.IntMappingType;\n+import org.apache.syncope.common.lib.types.TraceLevel;\n+\n+@XmlRootElement(name = \"notification\")\n+@XmlType\n+public class NotificationTO extends AbstractBaseBean {\n+\n+    private static final long serialVersionUID = -6145117115632592612L;\n+\n+    private Long key;\n+\n+    private List<String> events = new ArrayList<>();\n+\n+    private String userAbout;\n+\n+    private String roleAbout;\n+\n+    private String recipients;\n+\n+    private List<String> staticRecipients = new ArrayList<>();\n+\n+    private IntMappingType recipientAttrType;\n+\n+    private String recipientAttrName;\n+\n+    private boolean selfAsRecipient;\n+\n+    private String sender;\n+\n+    private String subject;\n+\n+    private String template;\n+\n+    private TraceLevel traceLevel;\n+\n+    private boolean active;\n+\n+    public String getUserAbout() {\n+        return userAbout;\n+    }\n+\n+    public void setUserAbout(final String userAbout) {\n+        this.userAbout = userAbout;\n+    }\n+\n+    public String getRoleAbout() {\n+        return roleAbout;\n+    }\n+\n+    public void setRoleAbout(final String roleAbout) {\n+        this.roleAbout = roleAbout;\n+    }\n+\n+    @XmlElementWrapper(name = \"events\")\n+    @XmlElement(name = \"event\")\n+    @JsonProperty(\"events\")\n+    public List<String> getEvents() {\n+        return events;\n+    }\n+\n+    @XmlElementWrapper(name = \"staticRecipients\")\n+    @XmlElement(name = \"staticRecipient\")\n+    @JsonProperty(\"staticRecipients\")\n+    public List<String> getStaticRecipients() {\n+        return staticRecipients;\n+    }\n+\n+    public Long getKey() {\n+        return key;\n+    }\n+\n+    public void setKey(Long key) {\n+        this.key = key;\n+    }\n+\n+    public String getRecipients() {\n+        return recipients;\n+    }\n+\n+    public void setRecipients(final String recipients) {\n+        this.recipients = recipients;\n+    }\n+\n+    public String getRecipientAttrName() {\n+        return recipientAttrName;\n+    }\n+\n+    public void setRecipientAttrName(final String recipientAttrName) {\n+        this.recipientAttrName = recipientAttrName;\n+    }\n+\n+    public IntMappingType getRecipientAttrType() {\n+        return recipientAttrType;\n+    }\n+\n+    public void setRecipientAttrType(final IntMappingType recipientAttrType) {\n+        this.recipientAttrType = recipientAttrType;\n+    }\n+\n+    public boolean isSelfAsRecipient() {\n+        return selfAsRecipient;\n+    }\n+\n+    public void setSelfAsRecipient(final boolean selfAsRecipient) {\n+        this.selfAsRecipient = selfAsRecipient;\n+    }\n+\n+    public String getSender() {\n+        return sender;\n+    }\n+\n+    public void setSender(final String sender) {\n+        this.sender = sender;\n+    }\n+\n+    public String getSubject() {\n+        return subject;\n+    }\n+\n+    public void setSubject(final String subject) {\n+        this.subject = subject;\n+    }\n+\n+    public String getTemplate() {\n+        return template;\n+    }\n+\n+    public void setTemplate(final String template) {\n+        this.template = template;\n+    }\n+\n+    public TraceLevel getTraceLevel() {\n+        return traceLevel;\n+    }\n+\n+    public void setTraceLevel(final TraceLevel traceLevel) {\n+        this.traceLevel = traceLevel;\n+    }\n+\n+    public boolean isActive() {\n+        return active;\n+    }\n+\n+    public void setActive(final boolean active) {\n+        this.active = active;\n+    }\n+}"},{"sha":"48661f9eefc78a1b8546a6365dc20fbca5710b85","filename":"syncope620/common/lib/src/main/java/org/apache/syncope/common/lib/to/NotificationTaskTO.java","status":"added","additions":105,"deletions":0,"changes":105,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FNotificationTaskTO.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FNotificationTaskTO.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FNotificationTaskTO.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,105 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.common.lib.to;\n+\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlElementWrapper;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.bind.annotation.XmlType;\n+import org.apache.syncope.common.lib.types.TraceLevel;\n+\n+@XmlRootElement(name = \"notificationTask\")\n+@XmlType\n+public class NotificationTaskTO extends AbstractTaskTO {\n+\n+    private static final long serialVersionUID = 371671242591093846L;\n+\n+    private final Set<String> recipients = new HashSet<>();\n+\n+    private String sender;\n+\n+    private String subject;\n+\n+    private String textBody;\n+\n+    private String htmlBody;\n+\n+    private boolean executed;\n+\n+    private TraceLevel traceLevel;\n+\n+    @XmlElementWrapper(name = \"recipients\")\n+    @XmlElement(name = \"recipient\")\n+    @JsonProperty(\"recipients\")\n+    public Set<String> getRecipients() {\n+        return recipients;\n+    }\n+\n+    public String getSender() {\n+        return sender;\n+    }\n+\n+    public void setSender(final String sender) {\n+        this.sender = sender;\n+    }\n+\n+    public String getSubject() {\n+        return subject;\n+    }\n+\n+    public void setSubject(final String subject) {\n+        this.subject = subject;\n+    }\n+\n+    public String getTextBody() {\n+        return textBody;\n+    }\n+\n+    public void setTextBody(final String textBody) {\n+        this.textBody = textBody;\n+    }\n+\n+    public String getHtmlBody() {\n+        return htmlBody;\n+    }\n+\n+    public void setHtmlBody(final String htmlBody) {\n+        this.htmlBody = htmlBody;\n+    }\n+\n+    public boolean isExecuted() {\n+        return executed;\n+    }\n+\n+    public void setExecuted(boolean executed) {\n+        this.executed = executed;\n+    }\n+\n+    public TraceLevel getTraceLevel() {\n+        return traceLevel;\n+    }\n+\n+    public void setTraceLevel(final TraceLevel traceLevel) {\n+        this.traceLevel = traceLevel;\n+    }\n+}"},{"sha":"f383ece311a0bf2112b7fc45e07f800143eaa2e9","filename":"syncope620/common/lib/src/main/java/org/apache/syncope/common/lib/to/PagedResult.java","status":"added","additions":98,"deletions":0,"changes":98,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FPagedResult.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FPagedResult.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FPagedResult.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,98 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.common.lib.to;\n+\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlElementWrapper;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.bind.annotation.XmlType;\n+import org.apache.syncope.common.lib.AbstractBaseBean;\n+\n+@XmlRootElement(name = \"pagedResult\")\n+@XmlType\n+public class PagedResult<T extends AbstractBaseBean> extends AbstractBaseBean {\n+\n+    private static final long serialVersionUID = 3472875885259250934L;\n+\n+    private URI prev;\n+\n+    private URI next;\n+\n+    private final List<T> result = new ArrayList<T>();\n+\n+    private int page;\n+\n+    private int size;\n+\n+    private int totalCount;\n+\n+    public URI getPrev() {\n+        return prev;\n+    }\n+\n+    public void setPrev(final URI prev) {\n+        this.prev = prev;\n+    }\n+\n+    public URI getNext() {\n+        return next;\n+    }\n+\n+    public void setNext(final URI next) {\n+        this.next = next;\n+    }\n+\n+    @XmlElementWrapper(name = \"result\")\n+    @XmlElement(name = \"item\")\n+    @JsonProperty(\"result\")\n+    @JsonTypeInfo(use = JsonTypeInfo.Id.CLASS, include = JsonTypeInfo.As.PROPERTY, property = \"@class\")\n+    public List<T> getResult() {\n+        return result;\n+    }\n+\n+    public int getPage() {\n+        return page;\n+    }\n+\n+    public void setPage(final int page) {\n+        this.page = page;\n+    }\n+\n+    public int getSize() {\n+        return size;\n+    }\n+\n+    public void setSize(final int size) {\n+        this.size = size;\n+    }\n+\n+    public int getTotalCount() {\n+        return totalCount;\n+    }\n+\n+    public void setTotalCount(final int totalCount) {\n+        this.totalCount = totalCount;\n+    }\n+\n+}"},{"sha":"05c4e5a55e1a12e81f2f0ee2d67910ff2dac3163","filename":"syncope620/common/lib/src/main/java/org/apache/syncope/common/lib/to/PasswordPolicyTO.java","status":"added","additions":54,"deletions":0,"changes":54,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FPasswordPolicyTO.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FPasswordPolicyTO.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FPasswordPolicyTO.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,54 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.common.lib.to;\n+\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.bind.annotation.XmlType;\n+import org.apache.syncope.common.lib.types.PasswordPolicySpec;\n+import org.apache.syncope.common.lib.types.PolicyType;\n+\n+@XmlRootElement(name = \"passwordPolicy\")\n+@XmlType\n+public class PasswordPolicyTO extends AbstractPolicyTO {\n+\n+    private static final long serialVersionUID = -5606086441294799690L;\n+\n+    private PasswordPolicySpec specification;\n+\n+    public PasswordPolicyTO() {\n+        this(false);\n+    }\n+\n+    public PasswordPolicyTO(boolean global) {\n+        super();\n+\n+        PolicyType type = global\n+                ? PolicyType.GLOBAL_PASSWORD\n+                : PolicyType.PASSWORD;\n+        setType(type);\n+    }\n+\n+    public void setSpecification(final PasswordPolicySpec specification) {\n+        this.specification = specification;\n+    }\n+\n+    public PasswordPolicySpec getSpecification() {\n+        return specification;\n+    }\n+}"},{"sha":"4568e36ccd387cc53a87165a3348ec4664857071","filename":"syncope620/common/lib/src/main/java/org/apache/syncope/common/lib/to/PlainSchemaTO.java","status":"added","additions":156,"deletions":0,"changes":156,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FPlainSchemaTO.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FPlainSchemaTO.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FPlainSchemaTO.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,156 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.common.lib.to;\n+\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.bind.annotation.XmlType;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.syncope.common.lib.types.AttrSchemaType;\n+import org.apache.syncope.common.lib.types.CipherAlgorithm;\n+\n+@XmlRootElement(name = \"schema\")\n+@XmlType\n+public class PlainSchemaTO extends AbstractSchemaTO {\n+\n+    private static final long serialVersionUID = -8133983392476990308L;\n+\n+    private AttrSchemaType type = AttrSchemaType.String;\n+\n+    private String mandatoryCondition;\n+\n+    private boolean multivalue;\n+\n+    private boolean uniqueConstraint;\n+\n+    private boolean readonly;\n+\n+    private String conversionPattern;\n+\n+    private String validatorClass;\n+\n+    private String enumerationValues;\n+\n+    private String enumerationKeys;\n+\n+    private String secretKey;\n+\n+    private CipherAlgorithm cipherAlgorithm;\n+\n+    private String mimeType;\n+\n+    public String getConversionPattern() {\n+        return conversionPattern;\n+    }\n+\n+    public void setConversionPattern(final String conversionPattern) {\n+        this.conversionPattern = conversionPattern;\n+    }\n+\n+    public String getMandatoryCondition() {\n+        return StringUtils.isNotBlank(mandatoryCondition)\n+                ? mandatoryCondition\n+                : \"false\";\n+    }\n+\n+    public void setMandatoryCondition(final String mandatoryCondition) {\n+        this.mandatoryCondition = mandatoryCondition;\n+    }\n+\n+    public boolean isMultivalue() {\n+        return multivalue;\n+    }\n+\n+    public void setMultivalue(final boolean multivalue) {\n+        this.multivalue = multivalue;\n+    }\n+\n+    public boolean isUniqueConstraint() {\n+        return uniqueConstraint;\n+    }\n+\n+    public void setUniqueConstraint(final boolean uniqueConstraint) {\n+        this.uniqueConstraint = uniqueConstraint;\n+    }\n+\n+    public boolean isReadonly() {\n+        return readonly;\n+    }\n+\n+    public void setReadonly(final boolean readonly) {\n+        this.readonly = readonly;\n+    }\n+\n+    public AttrSchemaType getType() {\n+        return type;\n+    }\n+\n+    public void setType(final AttrSchemaType type) {\n+        this.type = type;\n+    }\n+\n+    public String getValidatorClass() {\n+        return validatorClass;\n+    }\n+\n+    public void setValidatorClass(final String validatorClass) {\n+        this.validatorClass = validatorClass;\n+    }\n+\n+    public String getEnumerationValues() {\n+        return enumerationValues;\n+    }\n+\n+    public void setEnumerationValues(final String enumerationValues) {\n+        this.enumerationValues = enumerationValues;\n+    }\n+\n+    public String getEnumerationKeys() {\n+        return enumerationKeys;\n+    }\n+\n+    public void setEnumerationKeys(final String enumerationKeys) {\n+        this.enumerationKeys = enumerationKeys;\n+    }\n+\n+    public String getSecretKey() {\n+        return secretKey;\n+    }\n+\n+    public void setSecretKey(final String secretKey) {\n+        this.secretKey = secretKey;\n+    }\n+\n+    public CipherAlgorithm getCipherAlgorithm() {\n+        return cipherAlgorithm;\n+    }\n+\n+    public void setCipherAlgorithm(final CipherAlgorithm cipherAlgorithm) {\n+        this.cipherAlgorithm = cipherAlgorithm;\n+    }\n+\n+    public String getMimeType() {\n+        return mimeType;\n+    }\n+\n+    public void setMimeType(final String mimeType) {\n+        this.mimeType = mimeType;\n+    }\n+\n+}"},{"sha":"7c6ec080805e3067747315253a1b0a99fd3951ba","filename":"syncope620/common/lib/src/main/java/org/apache/syncope/common/lib/to/PropagationTaskTO.java","status":"added","additions":123,"deletions":0,"changes":123,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FPropagationTaskTO.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FPropagationTaskTO.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FPropagationTaskTO.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,123 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.common.lib.to;\n+\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.bind.annotation.XmlType;\n+import org.apache.syncope.common.lib.types.PropagationMode;\n+import org.apache.syncope.common.lib.types.ResourceOperation;\n+import org.apache.syncope.common.lib.types.SubjectType;\n+\n+@XmlRootElement(name = \"propagationTask\")\n+@XmlType\n+public class PropagationTaskTO extends AbstractTaskTO {\n+\n+    private static final long serialVersionUID = 386450127003321197L;\n+\n+    private PropagationMode propagationMode;\n+\n+    private ResourceOperation propagationOperation;\n+\n+    private String accountId;\n+\n+    private String oldAccountId;\n+\n+    private String xmlAttributes;\n+\n+    private String resource;\n+\n+    private String objectClassName;\n+\n+    private SubjectType subjectType;\n+\n+    private Long subjectId;\n+\n+    public String getAccountId() {\n+        return accountId;\n+    }\n+\n+    public void setAccountId(final String accountId) {\n+        this.accountId = accountId;\n+    }\n+\n+    public String getOldAccountId() {\n+        return oldAccountId;\n+    }\n+\n+    public void setOldAccountId(final String oldAccountId) {\n+        this.oldAccountId = oldAccountId;\n+    }\n+\n+    public PropagationMode getPropagationMode() {\n+        return propagationMode;\n+    }\n+\n+    public void setPropagationMode(final PropagationMode propagationMode) {\n+        this.propagationMode = propagationMode;\n+    }\n+\n+    public String getResource() {\n+        return resource;\n+    }\n+\n+    public void setResource(final String resource) {\n+        this.resource = resource;\n+    }\n+\n+    public ResourceOperation getPropagationOperation() {\n+        return propagationOperation;\n+    }\n+\n+    public void setPropagationOperation(final ResourceOperation propagationOperation) {\n+\n+        this.propagationOperation = propagationOperation;\n+    }\n+\n+    public String getXmlAttributes() {\n+        return xmlAttributes;\n+    }\n+\n+    public void setXmlAttributes(final String xmlAttributes) {\n+        this.xmlAttributes = xmlAttributes;\n+    }\n+\n+    public String getObjectClassName() {\n+        return objectClassName;\n+    }\n+\n+    public void setObjectClassName(final String objectClassName) {\n+        this.objectClassName = objectClassName;\n+    }\n+\n+    public SubjectType getSubjectType() {\n+        return subjectType;\n+    }\n+\n+    public void setSubjectType(final SubjectType subjectType) {\n+        this.subjectType = subjectType;\n+    }\n+\n+    public Long getSubjectId() {\n+        return subjectId;\n+    }\n+\n+    public void setSubjectId(final Long subjectId) {\n+        this.subjectId = subjectId;\n+    }\n+}"},{"sha":"13d2ff4bd1b1559e4b75e5ae2dcde818ec92807a","filename":"syncope620/common/lib/src/main/java/org/apache/syncope/common/lib/to/PushTaskTO.java","status":"added","additions":49,"deletions":0,"changes":49,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FPushTaskTO.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FPushTaskTO.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FPushTaskTO.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,49 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.common.lib.to;\n+\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.bind.annotation.XmlType;\n+\n+@XmlRootElement(name = \"pushTask\")\n+@XmlType\n+public class PushTaskTO extends AbstractProvisioningTaskTO {\n+\n+    private static final long serialVersionUID = -2143537546915809018L;\n+\n+    private String userFilter;\n+\n+    private String roleFilter;\n+\n+    public String getUserFilter() {\n+        return userFilter;\n+    }\n+\n+    public void setUserFilter(final String filter) {\n+        this.userFilter = filter;\n+    }\n+\n+    public String getRoleFilter() {\n+        return roleFilter;\n+    }\n+\n+    public void setRoleFilter(final String roleFilter) {\n+        this.roleFilter = roleFilter;\n+    }\n+}"},{"sha":"ef92b3bcec9964d480b41f5cead8f4102b8b3246","filename":"syncope620/common/lib/src/main/java/org/apache/syncope/common/lib/to/ReportExecTO.java","status":"added","additions":40,"deletions":0,"changes":40,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FReportExecTO.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FReportExecTO.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FReportExecTO.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,40 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.common.lib.to;\n+\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.bind.annotation.XmlType;\n+\n+@XmlRootElement(name = \"reportExec\")\n+@XmlType\n+public class ReportExecTO extends AbstractExecTO {\n+\n+    private static final long serialVersionUID = -1025555939724089215L;\n+\n+    private long report;\n+\n+    public long getReport() {\n+        return report;\n+    }\n+\n+    public void setReport(long report) {\n+        this.report = report;\n+    }\n+\n+}"},{"sha":"a8ae1ac7d9ef4a8472793535a6e9827618891ded","filename":"syncope620/common/lib/src/main/java/org/apache/syncope/common/lib/to/ReportTO.java","status":"added","additions":151,"deletions":0,"changes":151,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FReportTO.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FReportTO.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FReportTO.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,151 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.common.lib.to;\n+\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.List;\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlElementWrapper;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.bind.annotation.XmlType;\n+import org.apache.syncope.common.lib.AbstractBaseBean;\n+import org.apache.syncope.common.lib.report.AbstractReportletConf;\n+\n+@XmlRootElement(name = \"report\")\n+@XmlType\n+public class ReportTO extends AbstractBaseBean {\n+\n+    private static final long serialVersionUID = 5274568072084814410L;\n+\n+    private long id;\n+\n+    private String name;\n+\n+    private List<AbstractReportletConf> reportletConfs = new ArrayList<>();\n+\n+    private String cronExpression;\n+\n+    private List<ReportExecTO> executions = new ArrayList<>();\n+\n+    private String latestExecStatus;\n+\n+    private Date lastExec;\n+\n+    private Date nextExec;\n+\n+    private Date startDate;\n+\n+    private Date endDate;\n+\n+    public long getId() {\n+        return id;\n+    }\n+\n+    public void setId(long id) {\n+        this.id = id;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public void setName(final String name) {\n+        this.name = name;\n+    }\n+\n+    @XmlElementWrapper(name = \"reportletConfs\")\n+    @XmlElement(name = \"reportletConf\")\n+    @JsonProperty(\"reportletConfs\")\n+    public List<AbstractReportletConf> getReportletConfs() {\n+        return reportletConfs;\n+    }\n+\n+    public String getCronExpression() {\n+        return cronExpression;\n+    }\n+\n+    public void setCronExpression(final String cronExpression) {\n+        this.cronExpression = cronExpression;\n+    }\n+\n+    @XmlElementWrapper(name = \"executions\")\n+    @XmlElement(name = \"execution\")\n+    @JsonProperty(\"executions\")\n+    public List<ReportExecTO> getExecutions() {\n+        return executions;\n+    }\n+\n+    public String getLatestExecStatus() {\n+        return latestExecStatus;\n+    }\n+\n+    public void setLatestExecStatus(final String latestExecStatus) {\n+        this.latestExecStatus = latestExecStatus;\n+    }\n+\n+    public Date getLastExec() {\n+        return lastExec == null\n+                ? null\n+                : new Date(lastExec.getTime());\n+    }\n+\n+    public void setLastExec(final Date lastExec) {\n+        if (lastExec != null) {\n+            this.lastExec = new Date(lastExec.getTime());\n+        }\n+    }\n+\n+    public Date getNextExec() {\n+        return nextExec == null\n+                ? null\n+                : new Date(nextExec.getTime());\n+    }\n+\n+    public void setNextExec(final Date nextExec) {\n+        if (nextExec != null) {\n+            this.nextExec = new Date(nextExec.getTime());\n+        }\n+    }\n+\n+    public Date getStartDate() {\n+        return startDate == null\n+                ? null\n+                : new Date(startDate.getTime());\n+    }\n+\n+    public void setStartDate(final Date startDate) {\n+        if (startDate != null) {\n+            this.startDate = new Date(startDate.getTime());\n+        }\n+    }\n+\n+    public Date getEndDate() {\n+        return endDate == null\n+                ? null\n+                : new Date(endDate.getTime());\n+    }\n+\n+    public void setEndDate(final Date endDate) {\n+        if (endDate != null) {\n+            this.endDate = new Date(endDate.getTime());\n+        }\n+    }\n+}"},{"sha":"98f33d227f98f2d5044d5a43361a6e8277ec47a9","filename":"syncope620/common/lib/src/main/java/org/apache/syncope/common/lib/to/ResourceTO.java","status":"added","additions":270,"deletions":0,"changes":270,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FResourceTO.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FResourceTO.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FResourceTO.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,270 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.common.lib.to;\n+\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlElementWrapper;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.bind.annotation.XmlType;\n+import org.apache.syncope.common.lib.types.ConnConfProperty;\n+import org.apache.syncope.common.lib.types.PropagationMode;\n+import org.apache.syncope.common.lib.types.TraceLevel;\n+\n+@XmlRootElement(name = \"resource\")\n+@XmlType\n+public class ResourceTO extends AbstractAnnotatedBean {\n+\n+    private static final long serialVersionUID = -9193551354041698963L;\n+\n+    /**\n+     * The resource identifier is the name.\n+     */\n+    private String name;\n+\n+    /**\n+     * The resource type is identified by the associated connector.\n+     */\n+    private Long connectorId;\n+\n+    /**\n+     * Convenience information: display name for the connector id.\n+     */\n+    private String connectorDisplayName;\n+\n+    private MappingTO umapping;\n+\n+    private MappingTO rmapping;\n+\n+    private boolean propagationPrimary;\n+\n+    private int propagationPriority;\n+\n+    private boolean randomPwdIfNotProvided;\n+\n+    private PropagationMode propagationMode;\n+\n+    private boolean enforceMandatoryCondition;\n+\n+    private TraceLevel createTraceLevel;\n+\n+    private TraceLevel updateTraceLevel;\n+\n+    private TraceLevel deleteTraceLevel;\n+\n+    private TraceLevel syncTraceLevel;\n+\n+    private Long passwordPolicy;\n+\n+    private Long accountPolicy;\n+\n+    private Long syncPolicy;\n+\n+    private Set<ConnConfProperty> connConfProperties;\n+\n+    private String usyncToken;\n+\n+    private String rsyncToken;\n+\n+    private List<String> propagationActionsClassNames = new ArrayList<>();\n+\n+    public ResourceTO() {\n+        super();\n+\n+        connConfProperties = new HashSet<>();\n+        propagationMode = PropagationMode.TWO_PHASES;\n+        propagationPriority = 0;\n+\n+        createTraceLevel = TraceLevel.ALL;\n+        updateTraceLevel = TraceLevel.ALL;\n+        deleteTraceLevel = TraceLevel.ALL;\n+        syncTraceLevel = TraceLevel.ALL;\n+    }\n+\n+    public String getKey() {\n+        return name;\n+    }\n+\n+    public void setKey(final String key) {\n+        this.name = key;\n+    }\n+\n+    public boolean isEnforceMandatoryCondition() {\n+        return enforceMandatoryCondition;\n+    }\n+\n+    public void setEnforceMandatoryCondition(final boolean enforceMandatoryCondition) {\n+        this.enforceMandatoryCondition = enforceMandatoryCondition;\n+    }\n+\n+    public Long getConnectorId() {\n+        return connectorId;\n+    }\n+\n+    public void setConnectorId(final Long connectorId) {\n+        this.connectorId = connectorId;\n+    }\n+\n+    public String getConnectorDisplayName() {\n+        return connectorDisplayName;\n+    }\n+\n+    public void setConnectorDisplayName(final String connectorDisplayName) {\n+        this.connectorDisplayName = connectorDisplayName;\n+    }\n+\n+    public MappingTO getUmapping() {\n+        return umapping;\n+    }\n+\n+    public void setUmapping(final MappingTO umapping) {\n+        this.umapping = umapping;\n+    }\n+\n+    public MappingTO getRmapping() {\n+        return rmapping;\n+    }\n+\n+    public void setRmapping(final MappingTO rmapping) {\n+        this.rmapping = rmapping;\n+    }\n+\n+    public boolean isPropagationPrimary() {\n+        return propagationPrimary;\n+    }\n+\n+    public void setPropagationPrimary(final boolean propagationPrimary) {\n+        this.propagationPrimary = propagationPrimary;\n+    }\n+\n+    public int getPropagationPriority() {\n+        return propagationPriority;\n+    }\n+\n+    public void setPropagationPriority(final int propagationPriority) {\n+        this.propagationPriority = propagationPriority;\n+    }\n+\n+    public boolean isRandomPwdIfNotProvided() {\n+        return randomPwdIfNotProvided;\n+    }\n+\n+    public void setRandomPwdIfNotProvided(final boolean randomPwdIfNotProvided) {\n+        this.randomPwdIfNotProvided = randomPwdIfNotProvided;\n+    }\n+\n+    public PropagationMode getPropagationMode() {\n+        return propagationMode;\n+    }\n+\n+    public void setPropagationMode(final PropagationMode propagationMode) {\n+        this.propagationMode = propagationMode;\n+    }\n+\n+    public TraceLevel getCreateTraceLevel() {\n+        return createTraceLevel;\n+    }\n+\n+    public void setCreateTraceLevel(final TraceLevel createTraceLevel) {\n+        this.createTraceLevel = createTraceLevel;\n+    }\n+\n+    public TraceLevel getDeleteTraceLevel() {\n+        return deleteTraceLevel;\n+    }\n+\n+    public void setDeleteTraceLevel(final TraceLevel deleteTraceLevel) {\n+        this.deleteTraceLevel = deleteTraceLevel;\n+    }\n+\n+    public TraceLevel getUpdateTraceLevel() {\n+        return updateTraceLevel;\n+    }\n+\n+    public void setUpdateTraceLevel(final TraceLevel updateTraceLevel) {\n+        this.updateTraceLevel = updateTraceLevel;\n+    }\n+\n+    public Long getPasswordPolicy() {\n+        return passwordPolicy;\n+    }\n+\n+    public void setPasswordPolicy(final Long passwordPolicy) {\n+        this.passwordPolicy = passwordPolicy;\n+    }\n+\n+    public Long getAccountPolicy() {\n+        return accountPolicy;\n+    }\n+\n+    public void setAccountPolicy(final Long accountPolicy) {\n+        this.accountPolicy = accountPolicy;\n+    }\n+\n+    public Long getSyncPolicy() {\n+        return syncPolicy;\n+    }\n+\n+    public void setSyncPolicy(final Long syncPolicy) {\n+        this.syncPolicy = syncPolicy;\n+    }\n+\n+    @XmlElementWrapper(name = \"connConfProperties\")\n+    @XmlElement(name = \"property\")\n+    @JsonProperty(\"connConfProperties\")\n+    public Set<ConnConfProperty> getConnConfProperties() {\n+        return connConfProperties;\n+    }\n+\n+    public TraceLevel getSyncTraceLevel() {\n+        return syncTraceLevel;\n+    }\n+\n+    public void setSyncTraceLevel(final TraceLevel syncTraceLevel) {\n+        this.syncTraceLevel = syncTraceLevel;\n+    }\n+\n+    public String getUsyncToken() {\n+        return usyncToken;\n+    }\n+\n+    public void setUsyncToken(final String syncToken) {\n+        this.usyncToken = syncToken;\n+    }\n+\n+    public String getRsyncToken() {\n+        return rsyncToken;\n+    }\n+\n+    public void setRsyncToken(final String syncToken) {\n+        this.rsyncToken = syncToken;\n+    }\n+\n+    @XmlElementWrapper(name = \"propagationActionsClassNames\")\n+    @XmlElement(name = \"propagationActionsClassName\")\n+    @JsonProperty(\"propagationActionsClassNames\")\n+    public List<String> getPropagationActionsClassNames() {\n+        return propagationActionsClassNames;\n+    }\n+\n+}"},{"sha":"6e249291d3e60cd1ac39020cd15d2e2d0a8d587b","filename":"syncope620/common/lib/src/main/java/org/apache/syncope/common/lib/to/RoleTO.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FRoleTO.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FRoleTO.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FRoleTO.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -239,7 +239,7 @@ public void setInheritAccountPolicy(final boolean inheritAccountPolicy) {\n     }\n \n     public String getDisplayName() {\n-        return getId() + \" \" + getName();\n+        return getKey() + \" \" + getName();\n     }\n \n     public static long fromDisplayName(final String displayName) {"},{"sha":"330a12d1b83ec0d8d30f3d6b1572f2b318cbe931","filename":"syncope620/common/lib/src/main/java/org/apache/syncope/common/lib/to/SchedTaskTO.java","status":"added","additions":101,"deletions":0,"changes":101,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FSchedTaskTO.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FSchedTaskTO.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FSchedTaskTO.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,101 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.common.lib.to;\n+\n+import java.util.Date;\n+\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.bind.annotation.XmlSeeAlso;\n+import javax.xml.bind.annotation.XmlType;\n+\n+@XmlRootElement(name = \"schedTask\")\n+@XmlType\n+@XmlSeeAlso(AbstractProvisioningTaskTO.class)\n+public class SchedTaskTO extends AbstractTaskTO {\n+\n+    private static final long serialVersionUID = -5722284116974636425L;\n+\n+    private String cronExpression;\n+\n+    private String jobClassName;\n+\n+    private String name;\n+\n+    private String description;\n+\n+    private Date lastExec;\n+\n+    private Date nextExec;\n+\n+    public String getCronExpression() {\n+        return cronExpression;\n+    }\n+\n+    public void setCronExpression(final String cronExpression) {\n+        this.cronExpression = cronExpression;\n+    }\n+\n+    public String getJobClassName() {\n+        return jobClassName;\n+    }\n+\n+    public void setJobClassName(final String jobClassName) {\n+        this.jobClassName = jobClassName;\n+    }\n+\n+    public Date getLastExec() {\n+        return lastExec == null\n+                ? null\n+                : new Date(lastExec.getTime());\n+    }\n+\n+    public void setLastExec(final Date lastExec) {\n+        if (lastExec != null) {\n+            this.lastExec = new Date(lastExec.getTime());\n+        }\n+    }\n+\n+    public Date getNextExec() {\n+        return nextExec == null\n+                ? null\n+                : new Date(nextExec.getTime());\n+    }\n+\n+    public void setNextExec(final Date nextExec) {\n+        if (nextExec != null) {\n+            this.nextExec = new Date(nextExec.getTime());\n+        }\n+    }\n+\n+    public String getDescription() {\n+        return description;\n+    }\n+\n+    public void setDescription(final String description) {\n+        this.description = description;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public void setName(final String name) {\n+        this.name = name;\n+    }\n+}"},{"sha":"dd73f2c180c4284a55cc8987352e135c83902648","filename":"syncope620/common/lib/src/main/java/org/apache/syncope/common/lib/to/SecurityQuestionTO.java","status":"added","additions":51,"deletions":0,"changes":51,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FSecurityQuestionTO.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FSecurityQuestionTO.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FSecurityQuestionTO.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,51 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.common.lib.to;\n+\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.bind.annotation.XmlType;\n+import org.apache.syncope.common.lib.AbstractBaseBean;\n+\n+@XmlRootElement(name = \"securityQuestion\")\n+@XmlType\n+public class SecurityQuestionTO extends AbstractBaseBean {\n+\n+    private static final long serialVersionUID = 5969810939993556530L;\n+\n+    private long key;\n+\n+    private String content;\n+\n+    public long getKey() {\n+        return key;\n+    }\n+\n+    public void setKey(final long key) {\n+        this.key = key;\n+    }\n+\n+    public String getContent() {\n+        return content;\n+    }\n+\n+    public void setContent(final String content) {\n+        this.content = content;\n+    }\n+\n+}"},{"sha":"4edcc435be0e1782477508d6c9e82e638ba54fd8","filename":"syncope620/common/lib/src/main/java/org/apache/syncope/common/lib/to/SyncPolicyTO.java","status":"added","additions":54,"deletions":0,"changes":54,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FSyncPolicyTO.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FSyncPolicyTO.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FSyncPolicyTO.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,54 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.common.lib.to;\n+\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.bind.annotation.XmlType;\n+import org.apache.syncope.common.lib.types.PolicyType;\n+import org.apache.syncope.common.lib.types.SyncPolicySpec;\n+\n+@XmlRootElement(name = \"syncPolicy\")\n+@XmlType\n+public class SyncPolicyTO extends AbstractPolicyTO {\n+\n+    private static final long serialVersionUID = 993024634238024242L;\n+\n+    private SyncPolicySpec specification;\n+\n+    public SyncPolicyTO() {\n+        this(false);\n+    }\n+\n+    public SyncPolicyTO(final boolean global) {\n+        super();\n+\n+        PolicyType type = global\n+                ? PolicyType.GLOBAL_SYNC\n+                : PolicyType.SYNC;\n+        setType(type);\n+    }\n+\n+    public void setSpecification(final SyncPolicySpec specification) {\n+        this.specification = specification;\n+    }\n+\n+    public SyncPolicySpec getSpecification() {\n+        return specification;\n+    }\n+}"},{"sha":"9e33e96a6335332b807427990f49ebc6032bc723","filename":"syncope620/common/lib/src/main/java/org/apache/syncope/common/lib/to/SyncTaskTO.java","status":"added","additions":59,"deletions":0,"changes":59,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FSyncTaskTO.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FSyncTaskTO.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FSyncTaskTO.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,59 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.common.lib.to;\n+\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.bind.annotation.XmlType;\n+\n+@XmlRootElement(name = \"syncTask\")\n+@XmlType\n+public class SyncTaskTO extends AbstractProvisioningTaskTO {\n+\n+    private static final long serialVersionUID = -2143537546915809017L;\n+\n+    private UserTO userTemplate;\n+\n+    private RoleTO roleTemplate;\n+\n+    private boolean fullReconciliation;\n+\n+    public UserTO getUserTemplate() {\n+        return userTemplate;\n+    }\n+\n+    public void setUserTemplate(final UserTO userTemplate) {\n+        this.userTemplate = userTemplate;\n+    }\n+\n+    public RoleTO getRoleTemplate() {\n+        return roleTemplate;\n+    }\n+\n+    public void setRoleTemplate(final RoleTO roleTemplate) {\n+        this.roleTemplate = roleTemplate;\n+    }\n+\n+    public boolean isFullReconciliation() {\n+        return fullReconciliation;\n+    }\n+\n+    public void setFullReconciliation(boolean fullReconciliation) {\n+        this.fullReconciliation = fullReconciliation;\n+    }\n+}"},{"sha":"467c35ef0d131136bdba69326d528a0f3f1a9218","filename":"syncope620/common/lib/src/main/java/org/apache/syncope/common/lib/to/TaskExecTO.java","status":"added","additions":39,"deletions":0,"changes":39,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FTaskExecTO.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FTaskExecTO.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FTaskExecTO.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,39 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.common.lib.to;\n+\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.bind.annotation.XmlType;\n+\n+@XmlRootElement(name = \"taskExec\")\n+@XmlType\n+public class TaskExecTO extends AbstractExecTO {\n+\n+    private static final long serialVersionUID = -5401795154606268973L;\n+\n+    private long task;\n+\n+    public long getTask() {\n+        return task;\n+    }\n+\n+    public void setTask(final long task) {\n+        this.task = task;\n+    }\n+}"},{"sha":"1a9d3bd91f281bc68ddb3c671ecfda7f09be4b87","filename":"syncope620/common/lib/src/main/java/org/apache/syncope/common/lib/to/VirSchemaTO.java","status":"added","additions":38,"deletions":0,"changes":38,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FVirSchemaTO.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FVirSchemaTO.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FVirSchemaTO.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,38 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.common.lib.to;\n+\n+import javax.xml.bind.annotation.XmlRootElement;\n+\n+@XmlRootElement(name = \"virtualSchema\")\n+public class VirSchemaTO extends AbstractSchemaTO {\n+\n+    private static final long serialVersionUID = -8198557479659701343L;\n+\n+    private boolean readonly;\n+\n+    public boolean isReadonly() {\n+        return readonly;\n+    }\n+\n+    public void setReadonly(final boolean readonly) {\n+        this.readonly = readonly;\n+    }\n+\n+}"},{"sha":"c89bfcd69cd0dfe65f2dafe41a5da0bf4d766edc","filename":"syncope620/common/lib/src/main/java/org/apache/syncope/common/lib/to/WorkflowFormPropertyTO.java","status":"added","additions":119,"deletions":0,"changes":119,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FWorkflowFormPropertyTO.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FWorkflowFormPropertyTO.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FWorkflowFormPropertyTO.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,119 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.common.lib.to;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.bind.annotation.XmlType;\n+import org.apache.syncope.common.lib.AbstractBaseBean;\n+import org.apache.syncope.common.lib.types.WorkflowFormPropertyType;\n+\n+@XmlRootElement(name = \"workflowFormProperty\")\n+@XmlType\n+public class WorkflowFormPropertyTO extends AbstractBaseBean {\n+\n+    private static final long serialVersionUID = 9139969592634304261L;\n+\n+    private String key;\n+\n+    private String name;\n+\n+    private WorkflowFormPropertyType type;\n+\n+    private String value;\n+\n+    private boolean readable;\n+\n+    private boolean writable;\n+\n+    private boolean required;\n+\n+    private String datePattern;\n+\n+    private Map<String, String> enumValues = new HashMap<>();\n+\n+    public String getKey() {\n+        return key;\n+    }\n+\n+    public void setKey(final String key) {\n+        this.key = key;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public void setName(final String name) {\n+        this.name = name;\n+    }\n+\n+    public boolean isReadable() {\n+        return readable;\n+    }\n+\n+    public void setReadable(final boolean readable) {\n+        this.readable = readable;\n+    }\n+\n+    public boolean isRequired() {\n+        return required;\n+    }\n+\n+    public void setRequired(final boolean required) {\n+        this.required = required;\n+    }\n+\n+    public WorkflowFormPropertyType getType() {\n+        return type;\n+    }\n+\n+    public void setType(final WorkflowFormPropertyType type) {\n+        this.type = type;\n+    }\n+\n+    public String getValue() {\n+        return value;\n+    }\n+\n+    public void setValue(final String value) {\n+        this.value = value;\n+    }\n+\n+    public boolean isWritable() {\n+        return writable;\n+    }\n+\n+    public void setWritable(final boolean writable) {\n+        this.writable = writable;\n+    }\n+\n+    public String getDatePattern() {\n+        return datePattern;\n+    }\n+\n+    public void setDatePattern(final String datePattern) {\n+        this.datePattern = datePattern;\n+    }\n+\n+    public Map<String, String> getEnumValues() {\n+        return enumValues;\n+    }\n+}"},{"sha":"f63d9fe493e7bc49fdb8f9f318bf7493dd4c95d3","filename":"syncope620/common/lib/src/main/java/org/apache/syncope/common/lib/to/WorkflowFormTO.java","status":"added","additions":162,"deletions":0,"changes":162,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FWorkflowFormTO.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FWorkflowFormTO.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2FWorkflowFormTO.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,162 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.common.lib.to;\n+\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlElementWrapper;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.bind.annotation.XmlType;\n+import org.apache.syncope.common.lib.AbstractBaseBean;\n+\n+@XmlRootElement(name = \"workflowForm\")\n+@XmlType\n+public class WorkflowFormTO extends AbstractBaseBean {\n+\n+    private static final long serialVersionUID = -7044543391316529128L;\n+\n+    private long userKey;\n+\n+    private String taskId;\n+\n+    private String key;\n+\n+    private String description;\n+\n+    private Date createTime;\n+\n+    private Date dueDate;\n+\n+    private String owner;\n+\n+    private final List<WorkflowFormPropertyTO> properties;\n+\n+    public WorkflowFormTO() {\n+        properties = new ArrayList<>();\n+    }\n+\n+    public long getUserKey() {\n+        return userKey;\n+    }\n+\n+    public void setUserKey(long userKey) {\n+        this.userKey = userKey;\n+    }\n+\n+    public String getTaskId() {\n+        return taskId;\n+    }\n+\n+    public void setTaskId(final String taskId) {\n+        this.taskId = taskId;\n+    }\n+\n+    public String getKey() {\n+        return key;\n+    }\n+\n+    public void setKey(final String key) {\n+        this.key = key;\n+    }\n+\n+    public Date getCreateTime() {\n+        return createTime;\n+    }\n+\n+    public void setCreateTime(final Date createTime) {\n+        this.createTime = createTime;\n+    }\n+\n+    public String getDescription() {\n+        return description;\n+    }\n+\n+    public void setDescription(final String description) {\n+        this.description = description;\n+    }\n+\n+    public Date getDueDate() {\n+        return dueDate;\n+    }\n+\n+    public void setDueDate(final Date dueDate) {\n+        this.dueDate = dueDate;\n+    }\n+\n+    public String getOwner() {\n+        return owner;\n+    }\n+\n+    public void setOwner(final String owner) {\n+        this.owner = owner;\n+    }\n+\n+    @XmlElementWrapper(name = \"workflowFormProperties\")\n+    @XmlElement(name = \"workflowFormProperty\")\n+    @JsonProperty(\"workflowFormProperties\")\n+    public List<WorkflowFormPropertyTO> getProperties() {\n+        return properties;\n+    }\n+\n+    public boolean addProperty(final WorkflowFormPropertyTO property) {\n+        return properties.contains(property)\n+                ? true\n+                : properties.add(property);\n+    }\n+\n+    public boolean removeProperty(final WorkflowFormPropertyTO property) {\n+        return properties.remove(property);\n+    }\n+\n+    @JsonIgnore\n+    public Map<String, WorkflowFormPropertyTO> getPropertyMap() {\n+        Map<String, WorkflowFormPropertyTO> result;\n+\n+        if (getProperties() == null) {\n+            result = Collections.emptyMap();\n+        } else {\n+            result = new HashMap<>();\n+            for (WorkflowFormPropertyTO prop : getProperties()) {\n+                result.put(prop.getKey(), prop);\n+            }\n+            result = Collections.unmodifiableMap(result);\n+        }\n+\n+        return result;\n+    }\n+\n+    @JsonIgnore\n+    public Map<String, String> getPropertiesForSubmit() {\n+        Map<String, String> props = new HashMap<String, String>();\n+        for (WorkflowFormPropertyTO prop : getProperties()) {\n+            if (prop.isWritable()) {\n+                props.put(prop.getKey(), prop.getValue());\n+            }\n+        }\n+\n+        return props;\n+    }\n+}"},{"sha":"b02ed8f49a965d360ec80cde2e7f68a994610631","filename":"syncope620/common/lib/src/main/java/org/apache/syncope/common/lib/to/package-info.java","status":"added","additions":23,"deletions":0,"changes":23,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2Fpackage-info.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2Fpackage-info.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fto%2Fpackage-info.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,23 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+@XmlSchema(namespace = SyncopeConstants.NAMESPACE)\n+package org.apache.syncope.common.lib.to;\n+\n+import javax.xml.bind.annotation.XmlSchema;\n+import org.apache.syncope.common.lib.SyncopeConstants;"},{"sha":"40ff86ae772703414f02fdfb90cc443c827293c4","filename":"syncope620/common/lib/src/main/java/org/apache/syncope/common/lib/types/AuditElements.java","status":"added","additions":61,"deletions":0,"changes":61,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Ftypes%2FAuditElements.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Ftypes%2FAuditElements.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Ftypes%2FAuditElements.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,61 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.common.lib.types;\n+\n+import java.io.Serializable;\n+import javax.xml.bind.annotation.XmlEnum;\n+import org.apache.commons.lang3.StringUtils;\n+\n+public final class AuditElements implements Serializable {\n+\n+    private static final long serialVersionUID = -4385059255522273254L;\n+\n+    private AuditElements() {\n+    }\n+\n+    @XmlEnum\n+    public enum EventCategoryType {\n+\n+        REST(StringUtils.EMPTY),\n+        TASK(StringUtils.EMPTY),\n+        PROPAGATION(\"PropagationTask\"),\n+        SYNCHRONIZATION(\"SyncTask\"),\n+        PUSH(\"PushTask\"),\n+        CUSTOM(StringUtils.EMPTY);\n+\n+        private final String value;\n+\n+        EventCategoryType(final String value) {\n+            this.value = value;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return value;\n+        }\n+    }\n+\n+    @XmlEnum\n+    public enum Result {\n+\n+        SUCCESS,\n+        FAILURE\n+\n+    }\n+}"},{"sha":"2e385fc89bbbb0cfcbf3dbcf025097afea97fa15","filename":"syncope620/common/lib/src/main/java/org/apache/syncope/common/lib/types/AuditLoggerName.java","status":"added","additions":222,"deletions":0,"changes":222,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Ftypes%2FAuditLoggerName.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Ftypes%2FAuditLoggerName.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Ftypes%2FAuditLoggerName.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,222 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.common.lib.types;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import java.text.ParseException;\n+import java.util.AbstractMap;\n+import java.util.Map;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.syncope.common.lib.AbstractBaseBean;\n+import org.apache.syncope.common.lib.to.EventCategoryTO;\n+import org.apache.syncope.common.lib.types.AuditElements.EventCategoryType;\n+import org.apache.syncope.common.lib.types.AuditElements.Result;\n+\n+public class AuditLoggerName extends AbstractBaseBean {\n+\n+    private static final long serialVersionUID = -647989486671786839L;\n+\n+    private final AuditElements.EventCategoryType type;\n+\n+    private final String category;\n+\n+    private final String subcategory;\n+\n+    private final String event;\n+\n+    private final Result result;\n+\n+    @JsonCreator\n+    public AuditLoggerName(\n+            @JsonProperty(\"type\") final AuditElements.EventCategoryType type,\n+            @JsonProperty(\"category\") final String category,\n+            @JsonProperty(\"subcategory\") final String subcategory,\n+            @JsonProperty(\"event\") final String event,\n+            @JsonProperty(\"result\") final Result result)\n+            throws IllegalArgumentException {\n+\n+        this.type = type == null ? AuditElements.EventCategoryType.CUSTOM : type;\n+        this.category = category;\n+        this.subcategory = subcategory;\n+        this.event = event;\n+        this.result = result == null ? Result.SUCCESS : result;\n+    }\n+\n+    public AuditElements.EventCategoryType getType() {\n+        return type;\n+    }\n+\n+    public String getEvent() {\n+        return event;\n+    }\n+\n+    public String getCategory() {\n+        return category;\n+    }\n+\n+    public Result getResult() {\n+        return result;\n+    }\n+\n+    public String getSubcategory() {\n+        return subcategory;\n+    }\n+\n+    public String toLoggerName() {\n+        return new StringBuilder().append(LoggerType.AUDIT.getPrefix()).append('.').\n+                append(buildEvent(type, category, subcategory, event, result)).toString();\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public static AuditLoggerName fromLoggerName(final String loggerName)\n+            throws IllegalArgumentException, ParseException {\n+\n+        if (StringUtils.isBlank(loggerName)) {\n+            throw new IllegalArgumentException(\"Null value not permitted\");\n+        }\n+\n+        if (!loggerName.startsWith(LoggerType.AUDIT.getPrefix())) {\n+            throw new ParseException(\"Audit logger name must start with \" + LoggerType.AUDIT.getPrefix(), 0);\n+        }\n+\n+        final Map.Entry<EventCategoryTO, Result> eventCategory = parseEventCategory(\n+                loggerName.replaceAll(LoggerType.AUDIT.getPrefix() + \".\", \"\"));\n+\n+        return new AuditLoggerName(\n+                eventCategory.getKey().getType(),\n+                eventCategory.getKey().getCategory(),\n+                eventCategory.getKey().getSubcategory(),\n+                eventCategory.getKey().getEvents().isEmpty()\n+                        ? StringUtils.EMPTY : eventCategory.getKey().getEvents().iterator().next(),\n+                eventCategory.getValue());\n+    }\n+\n+    private static Map.Entry<EventCategoryTO, Result> parseEventCategory(final String event) {\n+        final EventCategoryTO eventCategoryTO = new EventCategoryTO();\n+\n+        Result condition = null;\n+\n+        if (StringUtils.isNotEmpty(event)) {\n+            final String[] elements = event.substring(1, event.length() - 1).split(\"\\\\]:\\\\[\");\n+\n+            if (elements.length == 1) {\n+                eventCategoryTO.setType(EventCategoryType.CUSTOM);\n+                condition = Result.SUCCESS;\n+                eventCategoryTO.getEvents().add(event);\n+            } else {\n+                EventCategoryType type;\n+\n+                if (EventCategoryType.PROPAGATION.toString().equals(elements[0])) {\n+                    type = EventCategoryType.PROPAGATION;\n+                } else if (EventCategoryType.SYNCHRONIZATION.toString().equals(elements[0])) {\n+                    type = EventCategoryType.SYNCHRONIZATION;\n+                } else if (EventCategoryType.PUSH.toString().equals(elements[0])) {\n+                    type = EventCategoryType.PUSH;\n+                } else {\n+                    try {\n+                        type = EventCategoryType.valueOf(elements[0]);\n+                    } catch (Exception e) {\n+                        type = EventCategoryType.CUSTOM;\n+                    }\n+                }\n+\n+                eventCategoryTO.setType(type);\n+\n+                eventCategoryTO.setCategory(StringUtils.isNotEmpty(elements[1]) ? elements[1] : null);\n+\n+                eventCategoryTO.setSubcategory(StringUtils.isNotEmpty(elements[2]) ? elements[2] : null);\n+\n+                if (elements.length > 3 && StringUtils.isNotEmpty(elements[3])) {\n+                    eventCategoryTO.getEvents().add(elements[3]);\n+                }\n+\n+                if (elements.length > 4) {\n+                    condition = Result.valueOf(elements[4].toUpperCase());\n+                }\n+            }\n+        }\n+\n+        return new AbstractMap.SimpleEntry< EventCategoryTO, Result>(eventCategoryTO, condition);\n+    }\n+\n+    /**\n+     * Build event string with the following syntax [type]:[category]:[subcategory]:[event]:[maybe result value cond].\n+     *\n+     * @param type event type.\n+     * @param category event category.\n+     * @param subcategory event subcategory.\n+     * @param event event.\n+     * @param resultValueCondition result value condition.\n+     * @return event string.\n+     */\n+    public static String buildEvent(\n+            final AuditElements.EventCategoryType type,\n+            final String category,\n+            final String subcategory,\n+            final String event,\n+            final AuditElements.Result resultValueCondition) {\n+\n+        final StringBuilder eventBuilder = new StringBuilder();\n+\n+        eventBuilder.append('[');\n+        if (type != null) {\n+            if (StringUtils.isNotBlank(type.toString())) {\n+                eventBuilder.append(type.toString());\n+            } else {\n+                eventBuilder.append(type.name());\n+            }\n+        }\n+        eventBuilder.append(']');\n+\n+        eventBuilder.append(\":\");\n+\n+        eventBuilder.append('[');\n+        if (StringUtils.isNotBlank(category)) {\n+            eventBuilder.append(category);\n+        }\n+        eventBuilder.append(']');\n+\n+        eventBuilder.append(\":\");\n+\n+        eventBuilder.append('[');\n+        if (StringUtils.isNotBlank(subcategory)) {\n+            eventBuilder.append(subcategory);\n+        }\n+        eventBuilder.append(']');\n+\n+        eventBuilder.append(\":\");\n+\n+        eventBuilder.append('[');\n+        if (StringUtils.isNotBlank(event)) {\n+            eventBuilder.append(event);\n+        }\n+        eventBuilder.append(']');\n+\n+        if (resultValueCondition != null) {\n+            eventBuilder.append(\":\");\n+\n+            eventBuilder.append('[');\n+            eventBuilder.append(resultValueCondition);\n+            eventBuilder.append(']');\n+        }\n+\n+        return eventBuilder.toString();\n+    }\n+}"},{"sha":"0c272a95ef7af1b6cff6313f6572801c7a2e1f9b","filename":"syncope620/common/lib/src/main/java/org/apache/syncope/common/lib/types/ClientExceptionType.java","status":"added","additions":107,"deletions":0,"changes":107,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Ftypes%2FClientExceptionType.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Ftypes%2FClientExceptionType.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Ftypes%2FClientExceptionType.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,107 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.common.lib.types;\n+\n+import javax.ws.rs.core.Response;\n+\n+public enum ClientExceptionType {\n+\n+    AssociatedResources(Response.Status.BAD_REQUEST),\n+    Composite(Response.Status.BAD_REQUEST),\n+    ConcurrentModification(Response.Status.PRECONDITION_FAILED),\n+    DataIntegrityViolation(Response.Status.BAD_REQUEST),\n+    EntityExists(Response.Status.CONFLICT),\n+    GenericPersistence(Response.Status.BAD_REQUEST),\n+    InvalidSecurityAnswer(Response.Status.BAD_REQUEST),\n+    InvalidLogger(Response.Status.BAD_REQUEST),\n+    InvalidConnInstance(Response.Status.BAD_REQUEST),\n+    InvalidConnIdConf(Response.Status.BAD_REQUEST),\n+    InvalidPolicy(Response.Status.BAD_REQUEST),\n+    InvalidSyncopeConf(Response.Status.BAD_REQUEST),\n+    InvalidSyncopeRole(Response.Status.BAD_REQUEST),\n+    InvalidReportExec(Response.Status.BAD_REQUEST),\n+    InvalidRoles(Response.Status.BAD_REQUEST),\n+    InvalidSchemaDefinition(Response.Status.BAD_REQUEST),\n+    InvalidSearchExpression(Response.Status.BAD_REQUEST),\n+    InvalidPageOrSize(Response.Status.BAD_REQUEST),\n+    InvalidPropagationTaskExecReport(Response.Status.BAD_REQUEST),\n+    InvalidUSchema(Response.Status.BAD_REQUEST),\n+    InvalidUDerSchema(Response.Status.BAD_REQUEST),\n+    InvalidUVirSchema(Response.Status.BAD_REQUEST),\n+    InvalidRSchema(Response.Status.BAD_REQUEST),\n+    InvalidRDerSchema(Response.Status.BAD_REQUEST),\n+    InvalidRVirSchema(Response.Status.BAD_REQUEST),\n+    InvalidMSchema(Response.Status.BAD_REQUEST),\n+    InvalidMDerSchema(Response.Status.BAD_REQUEST),\n+    InvalidMVirSchema(Response.Status.BAD_REQUEST),\n+    InvalidCSchema(Response.Status.BAD_REQUEST),\n+    InvalidSchemaMapping(Response.Status.BAD_REQUEST),\n+    InvalidSyncopeUser(Response.Status.BAD_REQUEST),\n+    InvalidExternalResource(Response.Status.BAD_REQUEST),\n+    InvalidNotification(Response.Status.BAD_REQUEST),\n+    InvalidPropagationTask(Response.Status.BAD_REQUEST),\n+    InvalidSchedTask(Response.Status.BAD_REQUEST),\n+    InvalidSyncTask(Response.Status.BAD_REQUEST),\n+    InvalidPushTask(Response.Status.BAD_REQUEST),\n+    InvalidValues(Response.Status.BAD_REQUEST),\n+    NotFound(Response.Status.NOT_FOUND),\n+    RejectedUserCreate(Response.Status.BAD_REQUEST),\n+    RequiredValuesMissing(Response.Status.BAD_REQUEST),\n+    RESTValidation(Response.Status.BAD_REQUEST),\n+    RoleOwnership(Response.Status.BAD_REQUEST),\n+    Scheduling(Response.Status.BAD_REQUEST),\n+    UnauthorizedRole(Response.Status.UNAUTHORIZED),\n+    Unauthorized(Response.Status.UNAUTHORIZED),\n+    Unknown(Response.Status.BAD_REQUEST),\n+    Workflow(Response.Status.BAD_REQUEST);\n+\n+    private final Response.Status responseStatus;\n+\n+    private ClientExceptionType(final Response.Status responseStatus) {\n+        this.responseStatus = responseStatus;\n+    }\n+\n+    public static ClientExceptionType fromHeaderValue(final String exceptionTypeHeaderValue) {\n+        ClientExceptionType result = null;\n+        for (ClientExceptionType type : values()) {\n+            if (exceptionTypeHeaderValue.equals(type.getHeaderValue())) {\n+                result = type;\n+            }\n+        }\n+\n+        if (result == null) {\n+            throw new IllegalArgumentException(\"Unexpected header value: \" + exceptionTypeHeaderValue);\n+        }\n+\n+        return result;\n+    }\n+\n+    public String getHeaderValue() {\n+        return name();\n+    }\n+\n+    public String getInfoHeaderValue(final String value) {\n+        return getHeaderValue() + \":\" + value;\n+    }\n+\n+    public Response.Status getResponseStatus() {\n+        return responseStatus;\n+    }\n+\n+}"},{"sha":"0b498d6d80c4db9e0e8a894db4c56cb6d985676c","filename":"syncope620/common/lib/src/main/java/org/apache/syncope/common/lib/types/PolicyType.java","status":"modified","additions":4,"deletions":0,"changes":4,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Ftypes%2FPolicyType.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Ftypes%2FPolicyType.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Ftypes%2FPolicyType.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -55,6 +55,10 @@ public String getDescription() {\n         return description;\n     }\n \n+    public boolean isGlobal() {\n+        return name().startsWith(\"GLOBAL\");\n+    }\n+\n     public static PolicyType fromString(final String value) {\n         return PolicyType.valueOf(value.toUpperCase());\n     }"},{"sha":"fdac43d5f125f7d5fd21eb2e179c6c79e2a63494","filename":"syncope620/common/lib/src/main/java/org/apache/syncope/common/lib/types/ReportExecExportFormat.java","status":"added","additions":32,"deletions":0,"changes":32,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Ftypes%2FReportExecExportFormat.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Ftypes%2FReportExecExportFormat.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Ftypes%2FReportExecExportFormat.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,32 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.common.lib.types;\n+\n+import javax.xml.bind.annotation.XmlEnum;\n+\n+@XmlEnum\n+public enum ReportExecExportFormat {\n+\n+    XML,\n+    HTML,\n+    PDF,\n+    RTF,\n+    CSV\n+\n+}"},{"sha":"673666d71656a96e3df6d1d6c02cbafa2bd5da4a","filename":"syncope620/common/lib/src/main/java/org/apache/syncope/common/lib/types/SchemaType.java","status":"added","additions":68,"deletions":0,"changes":68,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Ftypes%2FSchemaType.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Ftypes%2FSchemaType.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Ftypes%2FSchemaType.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,68 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.common.lib.types;\n+\n+import javax.xml.bind.annotation.XmlEnum;\n+import org.apache.syncope.common.lib.to.AbstractSchemaTO;\n+import org.apache.syncope.common.lib.to.DerSchemaTO;\n+import org.apache.syncope.common.lib.to.PlainSchemaTO;\n+import org.apache.syncope.common.lib.to.VirSchemaTO;\n+\n+@XmlEnum\n+public enum SchemaType {\n+\n+    /**\n+     * Standard schema for normal attributes to be stored within syncope.\n+     */\n+    PLAIN(PlainSchemaTO.class),\n+    /**\n+     * Derived schema calculated based on other attributes.\n+     */\n+    DERIVED(DerSchemaTO.class),\n+    /**\n+     * Virtual schema for attributes fetched from remote resources only.\n+     */\n+    VIRTUAL(VirSchemaTO.class);\n+\n+    private final Class<? extends AbstractSchemaTO> toClass;\n+\n+    SchemaType(final Class<? extends AbstractSchemaTO> toClass) {\n+        this.toClass = toClass;\n+    }\n+\n+    public Class<? extends AbstractSchemaTO> getToClass() {\n+        return toClass;\n+    }\n+\n+    public static SchemaType fromToClass(final Class<? extends AbstractSchemaTO> toClass) {\n+        SchemaType schemaType = null;\n+\n+        if (PlainSchemaTO.class.equals(toClass)) {\n+            schemaType = SchemaType.PLAIN;\n+        } else if (DerSchemaTO.class.equals(toClass)) {\n+            schemaType = SchemaType.DERIVED;\n+        } else if (VirSchemaTO.class.equals(toClass)) {\n+            schemaType = SchemaType.VIRTUAL;\n+        } else {\n+            throw new IllegalArgumentException(\"Unexpected class: \" + toClass.getName());\n+        }\n+\n+        return schemaType;\n+    }\n+}"},{"sha":"ec2db4afc0c23b0554df8137aeeebca5e7ff3964","filename":"syncope620/common/lib/src/main/java/org/apache/syncope/common/lib/types/WorkflowFormPropertyType.java","status":"added","additions":32,"deletions":0,"changes":32,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Ftypes%2FWorkflowFormPropertyType.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Ftypes%2FWorkflowFormPropertyType.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Ftypes%2FWorkflowFormPropertyType.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,32 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.common.lib.types;\n+\n+import javax.xml.bind.annotation.XmlEnum;\n+\n+@XmlEnum\n+public enum WorkflowFormPropertyType {\n+\n+    String,\n+    Long,\n+    Enum,\n+    Date,\n+    Boolean\n+\n+}"},{"sha":"8c487f861a135b2af99d3e8ccf25d7b4ef402bab","filename":"syncope620/common/lib/src/main/java/org/apache/syncope/common/lib/types/WorkflowTasks.java","status":"added","additions":47,"deletions":0,"changes":47,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Ftypes%2FWorkflowTasks.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Ftypes%2FWorkflowTasks.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Ftypes%2FWorkflowTasks.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,47 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.common.lib.types;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import javax.xml.bind.annotation.XmlRootElement;\n+\n+@XmlRootElement\n+public class WorkflowTasks {\n+\n+    private List<String> tasks;\n+\n+    public WorkflowTasks() {\n+        this.tasks = new ArrayList<String>();\n+    }\n+\n+    public WorkflowTasks(final Collection<String> tasks) {\n+        this();\n+        this.tasks.addAll(tasks);\n+    }\n+\n+    public List<String> getTasks() {\n+        return tasks;\n+    }\n+\n+    public void setTasks(final List<String> tasks) {\n+        this.tasks = tasks;\n+    }\n+}"},{"sha":"7ba0afad64fbe6d6570a8ebcd792117b653fca1b","filename":"syncope620/common/lib/src/main/java/org/apache/syncope/common/lib/wrap/AbstractWrappable.java","status":"added","additions":46,"deletions":0,"changes":46,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fwrap%2FAbstractWrappable.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fwrap%2FAbstractWrappable.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fwrap%2FAbstractWrappable.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,46 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.common.lib.wrap;\n+\n+import org.apache.syncope.common.lib.AbstractBaseBean;\n+\n+public abstract class AbstractWrappable<E> extends AbstractBaseBean {\n+\n+    private static final long serialVersionUID = 1712808704911635170L;\n+\n+    private E element;\n+\n+    public static <E, T extends AbstractWrappable<E>> T getInstance(final Class<T> reference, final E element) {\n+        try {\n+            T instance = reference.newInstance();\n+            instance.setElement(element);\n+            return instance;\n+        } catch (Exception e) {\n+            throw new IllegalArgumentException(\"Could not instantiate \" + reference.getName(), e);\n+        }\n+    }\n+\n+    public E getElement() {\n+        return element;\n+    }\n+\n+    public void setElement(final E element) {\n+        this.element = element;\n+    }\n+}"},{"sha":"6a8997c7cccc5f3d7c0e921ee1a665ff0ac95034","filename":"syncope620/common/lib/src/main/java/org/apache/syncope/common/lib/wrap/CorrelationRuleClass.java","status":"added","additions":30,"deletions":0,"changes":30,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fwrap%2FCorrelationRuleClass.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fwrap%2FCorrelationRuleClass.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fwrap%2FCorrelationRuleClass.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,30 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.common.lib.wrap;\n+\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.bind.annotation.XmlType;\n+\n+@XmlRootElement(name = \"correlationRuleClass\")\n+@XmlType\n+public class CorrelationRuleClass extends AbstractWrappable<String> {\n+\n+    private static final long serialVersionUID = -6715106427060816725L;\n+\n+}"},{"sha":"62530eb7a84e70c3cab6556144f1a14287f51e3f","filename":"syncope620/common/lib/src/main/java/org/apache/syncope/common/lib/wrap/EntitlementTO.java","status":"added","additions":30,"deletions":0,"changes":30,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fwrap%2FEntitlementTO.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fwrap%2FEntitlementTO.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fwrap%2FEntitlementTO.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,30 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.common.lib.wrap;\n+\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.bind.annotation.XmlType;\n+\n+@XmlRootElement(name = \"entitlement\")\n+@XmlType\n+public class EntitlementTO extends AbstractWrappable<String> {\n+\n+    private static final long serialVersionUID = 7133614577172038452L;\n+\n+}"},{"sha":"b85a6f5cd27ea211e899c98cb4f1e240c29007e4","filename":"syncope620/common/lib/src/main/java/org/apache/syncope/common/lib/wrap/JobClass.java","status":"added","additions":30,"deletions":0,"changes":30,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fwrap%2FJobClass.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fwrap%2FJobClass.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fwrap%2FJobClass.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,30 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.common.lib.wrap;\n+\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.bind.annotation.XmlType;\n+\n+@XmlRootElement(name = \"jobClass\")\n+@XmlType\n+public class JobClass extends AbstractWrappable<String> {\n+\n+    private static final long serialVersionUID = -1953799905627918822L;\n+\n+}"},{"sha":"11e254da64300dca656cf9c7122e227262f9101c","filename":"syncope620/common/lib/src/main/java/org/apache/syncope/common/lib/wrap/MailTemplate.java","status":"added","additions":30,"deletions":0,"changes":30,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fwrap%2FMailTemplate.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fwrap%2FMailTemplate.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fwrap%2FMailTemplate.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,30 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.common.lib.wrap;\n+\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.bind.annotation.XmlType;\n+\n+@XmlRootElement(name = \"mailTemplate\")\n+@XmlType\n+public class MailTemplate extends AbstractWrappable<String> {\n+\n+    private static final long serialVersionUID = 7232619557172031478L;\n+\n+}"},{"sha":"f8e54b6830cb32bd2033db823d0181987216c331","filename":"syncope620/common/lib/src/main/java/org/apache/syncope/common/lib/wrap/PropagationActionClass.java","status":"added","additions":30,"deletions":0,"changes":30,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fwrap%2FPropagationActionClass.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fwrap%2FPropagationActionClass.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fwrap%2FPropagationActionClass.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,30 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.common.lib.wrap;\n+\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.bind.annotation.XmlType;\n+\n+@XmlRootElement(name = \"propagationActionClass\")\n+@XmlType\n+public class PropagationActionClass extends AbstractWrappable<String> {\n+\n+    private static final long serialVersionUID = 2187654394121198308L;\n+\n+}"},{"sha":"e12fd8e5f6f89a70820e2e8394634d073e3fd34f","filename":"syncope620/common/lib/src/main/java/org/apache/syncope/common/lib/wrap/PushActionClass.java","status":"added","additions":30,"deletions":0,"changes":30,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fwrap%2FPushActionClass.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fwrap%2FPushActionClass.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fwrap%2FPushActionClass.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,30 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.common.lib.wrap;\n+\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.bind.annotation.XmlType;\n+\n+@XmlRootElement(name = \"pushActionClass\")\n+@XmlType\n+public class PushActionClass extends AbstractWrappable<String> {\n+\n+    private static final long serialVersionUID = 1669581609310071906L;\n+\n+}"},{"sha":"24ba18873e21c878a7f1ce599282ed1fd1ce6e8d","filename":"syncope620/common/lib/src/main/java/org/apache/syncope/common/lib/wrap/ReportletConfClass.java","status":"added","additions":30,"deletions":0,"changes":30,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fwrap%2FReportletConfClass.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fwrap%2FReportletConfClass.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fwrap%2FReportletConfClass.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,30 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.common.lib.wrap;\n+\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.bind.annotation.XmlType;\n+\n+@XmlRootElement(name = \"reportletConfClass\")\n+@XmlType\n+public class ReportletConfClass extends AbstractWrappable<String> {\n+\n+    private static final long serialVersionUID = 1343357929074360450L;\n+\n+}"},{"sha":"42b77cadc7ad31dce8fb49a938e4660d8d0de06f","filename":"syncope620/common/lib/src/main/java/org/apache/syncope/common/lib/wrap/ResourceName.java","status":"added","additions":30,"deletions":0,"changes":30,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fwrap%2FResourceName.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fwrap%2FResourceName.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fwrap%2FResourceName.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,30 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.common.lib.wrap;\n+\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.bind.annotation.XmlType;\n+\n+@XmlRootElement(name = \"resourceName\")\n+@XmlType\n+public class ResourceName extends AbstractWrappable<String> {\n+\n+    private static final long serialVersionUID = -175720097924079573L;\n+\n+}"},{"sha":"d61f1d9cf912e018a27ef57b04476ef5e5a52ab8","filename":"syncope620/common/lib/src/main/java/org/apache/syncope/common/lib/wrap/SubjectId.java","status":"added","additions":25,"deletions":0,"changes":25,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fwrap%2FSubjectId.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fwrap%2FSubjectId.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fwrap%2FSubjectId.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,25 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.common.lib.wrap;\n+\n+public class SubjectId extends AbstractWrappable<Long> {\n+\n+    private static final long serialVersionUID = -8664228651057889297L;\n+\n+}"},{"sha":"d6c7a77e03a946f486805dd8c1d127654e210d9e","filename":"syncope620/common/lib/src/main/java/org/apache/syncope/common/lib/wrap/SyncActionClass.java","status":"added","additions":30,"deletions":0,"changes":30,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fwrap%2FSyncActionClass.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fwrap%2FSyncActionClass.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fwrap%2FSyncActionClass.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,30 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.common.lib.wrap;\n+\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.bind.annotation.XmlType;\n+\n+@XmlRootElement(name = \"syncActionClass\")\n+@XmlType\n+public class SyncActionClass extends AbstractWrappable<String> {\n+\n+    private static final long serialVersionUID = 1669581609310071905L;\n+\n+}"},{"sha":"71cad0038ed6a23416568163c45351cd44b7c3d1","filename":"syncope620/common/lib/src/main/java/org/apache/syncope/common/lib/wrap/Validator.java","status":"added","additions":30,"deletions":0,"changes":30,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fwrap%2FValidator.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fwrap%2FValidator.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fwrap%2FValidator.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,30 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.common.lib.wrap;\n+\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.bind.annotation.XmlType;\n+\n+@XmlRootElement(name = \"validator\")\n+@XmlType\n+public class Validator extends AbstractWrappable<String> {\n+\n+    private static final long serialVersionUID = 7233619557177034453L;\n+\n+}"},{"sha":"397cb66e9020b3f4615430489ea88da1c0c58499","filename":"syncope620/common/lib/src/main/java/org/apache/syncope/common/lib/wrap/package-info.java","status":"added","additions":23,"deletions":0,"changes":23,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fwrap%2Fpackage-info.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fwrap%2Fpackage-info.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fcommon%2Flib%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcommon%2Flib%2Fwrap%2Fpackage-info.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,23 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+@XmlSchema(namespace = SyncopeConstants.NAMESPACE)\n+package org.apache.syncope.common.lib.wrap;\n+\n+import javax.xml.bind.annotation.XmlSchema;\n+import org.apache.syncope.common.lib.SyncopeConstants;"},{"sha":"ad69b63137d9bfc04137d5144f85ab3c02f4958b","filename":"syncope620/pom.xml","status":"modified","additions":145,"deletions":1,"changes":146,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fpom.xml","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fpom.xml","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fpom.xml?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -320,6 +320,8 @@ under the License.\n     <connid.ldap.version>1.4.0</connid.ldap.version>\n     <connid.ad.version>1.2.1</connid.ad.version>\n \n+    <cxf.version>3.0.3</cxf.version>\n+\n     <jackson.version>2.5.0</jackson.version>\n \n     <spring.version>4.1.4.RELEASE</spring.version>\n@@ -333,7 +335,9 @@ under the License.\n \n     <quartz.version>2.2.1</quartz.version>\n \n-    <slf4j.version>1.7.9</slf4j.version>\n+    <cocoon.version>3.0.0-alpha-3</cocoon.version>\n+\n+    <slf4j.version>1.7.10</slf4j.version>\n     <log4j.version>2.1</log4j.version>\n \n     <commons-io.version>2.4</commons-io.version>\n@@ -379,6 +383,49 @@ under the License.\n         <version>3.0.0</version>\n         <scope>provided</scope>\n       </dependency>\n+      <dependency>\n+        <groupId>javax.ws.rs</groupId>\n+        <artifactId>javax.ws.rs-api</artifactId>\n+        <version>2.0.1</version>\n+      </dependency>\n+      <dependency>\n+        <groupId>org.apache.geronimo.javamail</groupId>\n+        <artifactId>geronimo-javamail_1.4_mail</artifactId>\n+        <version>1.8.4</version>\n+      </dependency>\n+\n+      <!-- CXF -->\n+      <dependency>\n+        <groupId>org.apache.cxf</groupId>\n+        <artifactId>cxf-rt-frontend-jaxrs</artifactId>\n+        <version>${cxf.version}</version>\n+      </dependency>\n+      <dependency>\n+        <groupId>org.apache.cxf</groupId>\n+        <artifactId>cxf-rt-rs-extension-providers</artifactId>\n+        <version>${cxf.version}</version>\n+      </dependency>\n+      <dependency>\n+        <groupId>org.apache.cxf</groupId>\n+        <artifactId>cxf-rt-rs-extension-search</artifactId>\n+        <version>${cxf.version}</version>\n+      </dependency>\n+      <dependency>\n+        <groupId>org.apache.cxf</groupId>\n+        <artifactId>cxf-rt-frontend-jaxws</artifactId>\n+        <version>${cxf.version}</version>\n+      </dependency>\n+      <dependency>\n+        <groupId>org.apache.cxf</groupId>\n+        <artifactId>cxf-rt-rs-service-description</artifactId>\n+        <version>${cxf.version}</version>\n+      </dependency>\n+      <dependency>\n+        <groupId>org.apache.cxf</groupId>\n+        <artifactId>cxf-rt-rs-client</artifactId>\n+        <version>${cxf.version}</version>\n+      </dependency>      \n+      <!-- /CXF -->\n       \n       <dependency>\n         <groupId>org.apache.openjpa</groupId>\n@@ -434,6 +481,11 @@ under the License.\n         <artifactId>spring-context</artifactId>\n         <version>${spring.version}</version>\n       </dependency>\n+      <dependency>\n+        <groupId>org.springframework</groupId>\n+        <artifactId>spring-context-support</artifactId>\n+        <version>${spring.version}</version>\n+      </dependency>\n       <dependency>\n         <groupId>org.springframework</groupId>\n         <artifactId>spring-tx</artifactId>\n@@ -454,6 +506,12 @@ under the License.\n         <artifactId>spring-security-core</artifactId>\n         <version>${spring-security.version}</version>\n       </dependency>\n+\n+     <dependency>\n+        <groupId>org.aspectj</groupId>\n+        <artifactId>aspectjweaver</artifactId>\n+        <version>1.8.4</version>\n+      </dependency>\n       \n       <dependency>\n         <groupId>commons-io</groupId>\n@@ -516,6 +574,87 @@ under the License.\n         </exclusions>\n       </dependency>\n       \n+      <dependency>\n+        <groupId>org.apache.velocity</groupId>\n+        <artifactId>velocity</artifactId>\n+        <version>1.7</version>\n+      </dependency>\n+      <dependency>\n+        <groupId>org.apache.velocity</groupId>\n+        <artifactId>velocity-tools</artifactId>\n+        <version>2.0</version>\n+        <exclusions>\n+          <exclusion>\n+            <artifactId>struts-core</artifactId>\n+            <groupId>org.apache.struts</groupId>\n+          </exclusion>\n+          <exclusion>\n+            <artifactId>struts-taglib</artifactId>\n+            <groupId>org.apache.struts</groupId>\n+          </exclusion>\n+          <exclusion>\n+            <artifactId>struts-tiles</artifactId>\n+            <groupId>org.apache.struts</groupId>\n+          </exclusion>\n+          <exclusion>\n+            <artifactId>sslext</artifactId>\n+            <groupId>sslext</groupId>\n+          </exclusion>\n+        </exclusions>\n+      </dependency>\n+      \n+      <dependency>\n+        <groupId>org.apache.cocoon.sax</groupId>\n+        <artifactId>cocoon-sax</artifactId>\n+        <version>${cocoon.version}</version>\n+      </dependency>\n+      <dependency>\n+        <groupId>org.apache.cocoon.optional</groupId>\n+        <artifactId>cocoon-optional</artifactId>\n+        <version>${cocoon.version}</version>\n+      </dependency>\n+\n+      <dependency>\n+        <groupId>org.apache.xmlgraphics</groupId>\n+        <artifactId>fop</artifactId>\n+        <version>1.1</version>\n+        <exclusions>\n+          <exclusion>\n+            <groupId>org.apache.avalon.framework</groupId>\n+            <artifactId>avalon-framework-api</artifactId>\n+          </exclusion>\n+          <exclusion>\n+            <groupId>org.apache.avalon.framework</groupId>\n+            <artifactId>avalon-framework-impl</artifactId>\n+          </exclusion>\n+          <exclusion>\n+            <groupId>xalan</groupId>\n+            <artifactId>xalan</artifactId>\n+          </exclusion>\n+        </exclusions>\n+      </dependency>\n+      <dependency>\n+        <groupId>org.apache.avalon.framework</groupId>\n+        <artifactId>avalon-framework-api</artifactId>\n+        <version>4.3.1</version>\n+      </dependency>\n+      <dependency>\n+        <groupId>org.apache.avalon.framework</groupId>\n+        <artifactId>avalon-framework-impl</artifactId>\n+        <version>4.3.1</version>\n+      </dependency>\n+\n+      <dependency>\n+        <groupId>xalan</groupId>\n+        <artifactId>xalan</artifactId>\n+        <version>2.7.1</version>\n+      </dependency>\n+      <dependency>\n+        <groupId>xerces</groupId>\n+        <artifactId>xercesImpl</artifactId>\n+        <version>2.11.0</version>\n+      </dependency>\n+\n       <dependency>\n         <groupId>org.slf4j</groupId>\n         <artifactId>slf4j-api</artifactId>\n@@ -526,6 +665,11 @@ under the License.\n         <artifactId>log4j-api</artifactId>\n         <version>${log4j.version}</version>\n       </dependency>\n+      <dependency>\n+        <groupId>org.apache.logging.log4j</groupId>\n+        <artifactId>log4j-core</artifactId>\n+        <version>${log4j.version}</version>\n+      </dependency>\n       \n       <dependency>\n         <groupId>org.springframework</groupId>"},{"sha":"fd8fc427680d2cee5fd54af986a4ecb6715df536","filename":"syncope620/server/logic/pom.xml","status":"added","additions":127,"deletions":0,"changes":127,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fpom.xml","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fpom.xml","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Flogic%2Fpom.xml?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,127 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<!--\n+Licensed to the Apache Software Foundation (ASF) under one\n+or more contributor license agreements.  See the NOTICE file\n+distributed with this work for additional information\n+regarding copyright ownership.  The ASF licenses this file\n+to you under the Apache License, Version 2.0 (the\n+\"License\"); you may not use this file except in compliance\n+with the License.  You may obtain a copy of the License at\n+\n+  http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing,\n+software distributed under the License is distributed on an\n+\"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+KIND, either express or implied.  See the License for the\n+specific language governing permissions and limitations\n+under the License.\n+-->\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+\n+  <modelVersion>4.0.0</modelVersion>\n+\n+  <parent>\n+    <groupId>org.apache.syncope</groupId>\n+    <artifactId>syncope-server</artifactId>\n+    <version>2.0.0-SNAPSHOT</version>\n+  </parent>\n+\n+  <name>Apache Syncope Server Logic</name>\n+  <description>Apache Syncope Server Logic</description>\n+  <groupId>org.apache.syncope.server</groupId>\n+  <artifactId>syncope-server-logic</artifactId>\n+  <packaging>jar</packaging>\n+\n+  <dependencies>\n+    <dependency>\n+      <groupId>org.apache.geronimo.javamail</groupId>\n+      <artifactId>geronimo-javamail_1.4_mail</artifactId>\n+    </dependency>\n+\n+    <dependency>\n+      <groupId>org.apache.commons</groupId>\n+      <artifactId>commons-dbcp2</artifactId>\n+    </dependency>\n+\n+    <dependency>\n+      <groupId>org.springframework</groupId>\n+      <artifactId>spring-context</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.springframework</groupId>\n+      <artifactId>spring-context-support</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.springframework</groupId>\n+      <artifactId>spring-jdbc</artifactId>\n+    </dependency>\n+    \n+    <dependency>\n+      <groupId>org.aspectj</groupId>\n+      <artifactId>aspectjweaver</artifactId>\n+    </dependency>\n+\n+    <dependency>\n+      <groupId>org.apache.velocity</groupId>\n+      <artifactId>velocity</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.apache.velocity</groupId>\n+      <artifactId>velocity-tools</artifactId>\n+    </dependency>\n+      \n+    <dependency>\n+      <groupId>org.apache.cocoon.sax</groupId>\n+      <artifactId>cocoon-sax</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.apache.cocoon.optional</groupId>\n+      <artifactId>cocoon-optional</artifactId>\n+    </dependency>\n+\n+    <dependency>\n+      <groupId>org.apache.xmlgraphics</groupId>\n+      <artifactId>fop</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.apache.avalon.framework</groupId>\n+      <artifactId>avalon-framework-api</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.apache.avalon.framework</groupId>\n+      <artifactId>avalon-framework-impl</artifactId>\n+    </dependency>\n+\n+    <dependency>\n+      <groupId>xalan</groupId>\n+      <artifactId>xalan</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>xerces</groupId>\n+      <artifactId>xercesImpl</artifactId>\n+    </dependency>\n+\n+    <dependency>\n+      <groupId>org.apache.logging.log4j</groupId>\n+      <artifactId>log4j-core</artifactId>\n+    </dependency>\n+      \n+    <dependency>\n+      <groupId>org.apache.syncope.server</groupId>\n+      <artifactId>syncope-persistence-api</artifactId>\n+      <version>${project.version}</version>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.apache.syncope.server</groupId>\n+      <artifactId>syncope-workflow-api</artifactId>\n+      <version>${project.version}</version>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.apache.syncope.server</groupId>\n+      <artifactId>syncope-server-utils</artifactId>\n+      <version>${project.version}</version>\n+    </dependency>\n+  </dependencies>\n+\n+</project>"},{"sha":"11686a20c84b043018a9a7f0972771eade679dfa","filename":"syncope620/server/logic/src/main/java/org/apache/syncope/server/logic/AbstractLogic.java","status":"added","additions":58,"deletions":0,"changes":58,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2FAbstractLogic.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2FAbstractLogic.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2FAbstractLogic.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,58 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.server.logic;\n+\n+import java.lang.reflect.Method;\n+import org.apache.syncope.common.lib.AbstractBaseBean;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+/**\n+ * Superclass for all controllers.\n+ *\n+ * @param <T> transfer object used for input / output\n+ */\n+abstract class AbstractLogic<T extends AbstractBaseBean> {\n+\n+    /**\n+     * Logger.\n+     */\n+    protected static final Logger LOG = LoggerFactory.getLogger(AbstractLogic.class);\n+\n+    /**\n+     * Resolves stored bean (if existing) referred by the given CUD method.\n+     * <br />\n+     * Read-only methods will be unresolved for performance reasons.\n+     *\n+     * @param method method.\n+     * @param args method arguments.\n+     * @return referred stored bean.\n+     * @throws UnresolvedReferenceException in case of failures, read-only methods and unresolved bean.\n+     */\n+    public T resolveBeanReference(final Method method, final Object... args) throws UnresolvedReferenceException {\n+        final Transactional transactional = method.getAnnotation(Transactional.class);\n+        if (transactional != null && transactional.readOnly()) {\n+            throw new UnresolvedReferenceException();\n+        }\n+        return resolveReference(method, args);\n+    }\n+\n+    protected abstract T resolveReference(Method method, Object... args) throws UnresolvedReferenceException;\n+}"},{"sha":"2a20d1f042e986479835fc6a1da76b7e1b7dcafb","filename":"syncope620/server/logic/src/main/java/org/apache/syncope/server/logic/AbstractResourceAssociator.java","status":"added","additions":37,"deletions":0,"changes":37,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2FAbstractResourceAssociator.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2FAbstractResourceAssociator.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2FAbstractResourceAssociator.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,37 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.server.logic;\n+\n+import java.util.Collection;\n+import org.apache.syncope.common.lib.to.AbstractAttributableTO;\n+\n+public abstract class AbstractResourceAssociator<T extends AbstractAttributableTO> extends AbstractLogic<T> {\n+\n+    public abstract T unlink(Long id, Collection<String> resources);\n+\n+    public abstract T link(Long id, Collection<String> resources);\n+\n+    public abstract T unassign(Long id, Collection<String> resources);\n+\n+    public abstract T assign(Long id, Collection<String> resources, boolean changepwd, String password);\n+\n+    public abstract T deprovision(Long userId, Collection<String> resources);\n+\n+    public abstract T provision(Long userId, Collection<String> resources, boolean changepwd, String password);\n+}"},{"sha":"a9117b8de13a90675eb6ecb92043b9df0aa9344c","filename":"syncope620/server/logic/src/main/java/org/apache/syncope/server/logic/AbstractSubjectLogic.java","status":"added","additions":43,"deletions":0,"changes":43,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2FAbstractSubjectLogic.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2FAbstractSubjectLogic.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2FAbstractSubjectLogic.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,43 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.server.logic;\n+\n+import java.util.List;\n+import org.apache.syncope.common.lib.mod.AbstractSubjectMod;\n+import org.apache.syncope.common.lib.to.AbstractSubjectTO;\n+import org.apache.syncope.persistence.api.dao.search.OrderByClause;\n+import org.apache.syncope.persistence.api.dao.search.SearchCond;\n+\n+public abstract class AbstractSubjectLogic<T extends AbstractSubjectTO, V extends AbstractSubjectMod>\n+        extends AbstractResourceAssociator<T> {\n+\n+    public abstract T read(Long key);\n+\n+    public abstract int count();\n+\n+    public abstract T update(V attributableMod);\n+\n+    public abstract T delete(Long key);\n+\n+    public abstract List<T> list(int page, int size, List<OrderByClause> orderBy);\n+\n+    public abstract List<T> search(SearchCond searchCondition, int page, int size, List<OrderByClause> orderBy);\n+\n+    public abstract int searchCount(SearchCond searchCondition);\n+}"},{"sha":"00526b853992af59b13663c80665ee219ac46754","filename":"syncope620/server/logic/src/main/java/org/apache/syncope/server/logic/AbstractTransactionalLogic.java","status":"added","additions":31,"deletions":0,"changes":31,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2FAbstractTransactionalLogic.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2FAbstractTransactionalLogic.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2FAbstractTransactionalLogic.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,31 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.server.logic;\n+\n+import org.apache.syncope.common.lib.AbstractBaseBean;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+/**\n+ * Adds Spring's transactional support to {@link AbstractLogic}.\n+ *\n+ * @param <T> transfer object used for input / output\n+ */\n+@Transactional(rollbackFor = { Throwable.class })\n+abstract class AbstractTransactionalLogic<T extends AbstractBaseBean> extends AbstractLogic<T> {\n+}"},{"sha":"581f6401ebd99949921f3b3f3cbd06bd68cda27f","filename":"syncope620/server/logic/src/main/java/org/apache/syncope/server/logic/ConfigurationLogic.java","status":"added","additions":157,"deletions":0,"changes":157,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2FConfigurationLogic.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2FConfigurationLogic.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2FConfigurationLogic.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,157 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.server.logic;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.lang.reflect.Method;\n+import java.util.HashSet;\n+import java.util.Set;\n+import org.apache.syncope.common.lib.to.AttrTO;\n+import org.apache.syncope.common.lib.to.ConfTO;\n+import org.apache.syncope.common.lib.wrap.Validator;\n+import org.apache.syncope.persistence.api.content.ContentExporter;\n+import org.apache.syncope.persistence.api.dao.ConfDAO;\n+import org.apache.syncope.persistence.api.dao.NotFoundException;\n+import org.apache.syncope.persistence.api.dao.PlainSchemaDAO;\n+import org.apache.syncope.persistence.api.entity.conf.CPlainAttr;\n+import org.apache.syncope.persistence.api.entity.conf.CPlainSchema;\n+import org.apache.syncope.server.logic.data.ConfigurationDataBinder;\n+import org.apache.syncope.server.logic.init.ImplementationClassNamesLoader;\n+import org.apache.syncope.server.logic.init.WorkflowAdapterLoader;\n+import org.apache.syncope.server.logic.notification.NotificationManager;\n+import org.apache.syncope.server.spring.ResourceWithFallbackLoader;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.core.io.Resource;\n+import org.springframework.security.access.prepost.PreAuthorize;\n+import org.springframework.stereotype.Component;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+@Component\n+public class ConfigurationLogic extends AbstractTransactionalLogic<ConfTO> {\n+\n+    @Autowired\n+    private ConfDAO confDAO;\n+\n+    @Autowired\n+    private PlainSchemaDAO plainSchemaDAO;\n+\n+    @Autowired\n+    private ConfigurationDataBinder binder;\n+\n+    @Autowired\n+    private ContentExporter exporter;\n+\n+    @Autowired\n+    private ImplementationClassNamesLoader classNamesLoader;\n+\n+    @javax.annotation.Resource(name = \"velocityResourceLoader\")\n+    private ResourceWithFallbackLoader resourceLoader;\n+\n+    @Autowired\n+    private WorkflowAdapterLoader wfAdapterLoader;\n+\n+    @PreAuthorize(\"hasRole('CONFIGURATION_DELETE')\")\n+    public void delete(final String key) {\n+        confDAO.delete(key);\n+    }\n+\n+    @PreAuthorize(\"hasRole('CONFIGURATION_LIST')\")\n+    public ConfTO list() {\n+        return binder.getConfTO(confDAO.get());\n+    }\n+\n+    @PreAuthorize(\"isAuthenticated()\")\n+    public AttrTO read(final String key) {\n+        AttrTO result;\n+\n+        CPlainAttr conf = confDAO.find(key);\n+        if (conf == null) {\n+            CPlainSchema schema = plainSchemaDAO.find(key, CPlainSchema.class);\n+            if (schema == null) {\n+                throw new NotFoundException(\"Configuration key \" + key);\n+            }\n+\n+            result = new AttrTO();\n+            result.setSchema(key);\n+        } else {\n+            result = binder.getAttrTO(conf);\n+        }\n+\n+        return result;\n+    }\n+\n+    @PreAuthorize(\"hasRole('CONFIGURATION_SET')\")\n+    public void set(final AttrTO value) {\n+        confDAO.save(binder.getAttribute(value));\n+    }\n+\n+    @PreAuthorize(\"hasRole('CONFIGURATION_LIST')\")\n+    public Set<String> getValidators() {\n+        return classNamesLoader.getClassNames(ImplementationClassNamesLoader.Type.VALIDATOR);\n+    }\n+\n+    @PreAuthorize(\"hasRole('CONFIGURATION_LIST')\")\n+    public Set<String> getMailTemplates() {\n+        Set<String> htmlTemplates = new HashSet<String>();\n+        Set<String> textTemplates = new HashSet<String>();\n+\n+        try {\n+            for (Resource resource : resourceLoader.getResources(NotificationManager.MAIL_TEMPLATES + \"*.vm\")) {\n+                String template = resource.getURL().toExternalForm();\n+                if (template.endsWith(NotificationManager.MAIL_TEMPLATE_HTML_SUFFIX)) {\n+                    htmlTemplates.add(\n+                            template.substring(template.indexOf(NotificationManager.MAIL_TEMPLATES) + 14,\n+                                    template.indexOf(NotificationManager.MAIL_TEMPLATE_HTML_SUFFIX)));\n+                } else if (template.endsWith(NotificationManager.MAIL_TEMPLATE_TEXT_SUFFIX)) {\n+                    textTemplates.add(\n+                            template.substring(template.indexOf(NotificationManager.MAIL_TEMPLATES) + 14,\n+                                    template.indexOf(NotificationManager.MAIL_TEMPLATE_TEXT_SUFFIX)));\n+                } else {\n+                    LOG.warn(\"Unexpected template found: {}, ignoring...\", template);\n+                }\n+            }\n+        } catch (IOException e) {\n+            LOG.error(\"While searching for class implementing {}\", Validator.class.getName(), e);\n+        }\n+\n+        // Only templates available both as HTML and TEXT are considered\n+        htmlTemplates.retainAll(textTemplates);\n+\n+        return htmlTemplates;\n+    }\n+\n+    @PreAuthorize(\"hasRole('CONFIGURATION_EXPORT')\")\n+    @Transactional(readOnly = true)\n+    public void export(final OutputStream os) {\n+        try {\n+            exporter.export(os, wfAdapterLoader.getTablePrefix());\n+            LOG.debug(\"Database content successfully exported\");\n+        } catch (Exception e) {\n+            LOG.error(\"While exporting database content\", e);\n+        }\n+    }\n+\n+    @Override\n+    protected ConfTO resolveReference(final Method method, final Object... args)\n+            throws UnresolvedReferenceException {\n+\n+        throw new UnresolvedReferenceException();\n+    }\n+}"},{"sha":"ee550cd3631290afb68b9d760b56d34eed3dfe8e","filename":"syncope620/server/logic/src/main/java/org/apache/syncope/server/logic/ConnectorLogic.java","status":"added","additions":341,"deletions":0,"changes":341,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2FConnectorLogic.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2FConnectorLogic.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2FConnectorLogic.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,341 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.server.logic;\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.syncope.common.lib.SyncopeClientException;\n+import org.apache.syncope.common.lib.to.BulkAction;\n+import org.apache.syncope.common.lib.to.BulkActionResult;\n+import org.apache.syncope.common.lib.to.ConnBundleTO;\n+import org.apache.syncope.common.lib.to.ConnInstanceTO;\n+import org.apache.syncope.common.lib.types.ClientExceptionType;\n+import org.apache.syncope.common.lib.types.ConnConfProperty;\n+import org.apache.syncope.persistence.api.dao.ConnInstanceDAO;\n+import org.apache.syncope.persistence.api.dao.ExternalResourceDAO;\n+import org.apache.syncope.persistence.api.dao.NotFoundException;\n+import org.apache.syncope.persistence.api.entity.ConnInstance;\n+import org.apache.syncope.persistence.api.entity.ExternalResource;\n+import org.apache.syncope.provisioning.api.ConnIdBundleManager;\n+import org.apache.syncope.provisioning.api.Connector;\n+import org.apache.syncope.provisioning.api.ConnectorFactory;\n+import org.apache.syncope.server.logic.data.ConnInstanceDataBinder;\n+import org.identityconnectors.common.l10n.CurrentLocale;\n+import org.identityconnectors.framework.api.ConfigurationProperties;\n+import org.identityconnectors.framework.api.ConnectorInfo;\n+import org.identityconnectors.framework.api.ConnectorKey;\n+import org.identityconnectors.framework.common.objects.ObjectClass;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.access.prepost.PreAuthorize;\n+import org.springframework.stereotype.Component;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+@Component\n+public class ConnectorLogic extends AbstractTransactionalLogic<ConnInstanceTO> {\n+\n+    @Autowired\n+    private ConnIdBundleManager connIdBundleManager;\n+\n+    @Autowired\n+    private ExternalResourceDAO resourceDAO;\n+\n+    @Autowired\n+    private ConnInstanceDAO connInstanceDAO;\n+\n+    @Autowired\n+    private ConnInstanceDataBinder binder;\n+\n+    @Autowired\n+    private ConnectorFactory connFactory;\n+\n+    @PreAuthorize(\"hasRole('CONNECTOR_CREATE')\")\n+    public ConnInstanceTO create(final ConnInstanceTO connInstanceTO) {\n+        ConnInstance connInstance = binder.getConnInstance(connInstanceTO);\n+        try {\n+            connInstance = connInstanceDAO.save(connInstance);\n+        } catch (SyncopeClientException e) {\n+            throw e;\n+        } catch (Exception e) {\n+            SyncopeClientException ex = SyncopeClientException.build(ClientExceptionType.InvalidConnInstance);\n+            ex.getElements().add(e.getMessage());\n+            throw ex;\n+        }\n+\n+        return binder.getConnInstanceTO(connInstance);\n+    }\n+\n+    @PreAuthorize(\"hasRole('CONNECTOR_UPDATE')\")\n+    public ConnInstanceTO update(final ConnInstanceTO connInstanceTO) {\n+        ConnInstance connInstance = binder.updateConnInstance(connInstanceTO.getKey(), connInstanceTO);\n+        try {\n+            connInstance = connInstanceDAO.save(connInstance);\n+        } catch (SyncopeClientException e) {\n+            throw e;\n+        } catch (Exception e) {\n+            SyncopeClientException ex = SyncopeClientException.build(ClientExceptionType.InvalidConnInstance);\n+            ex.getElements().add(e.getMessage());\n+            throw ex;\n+        }\n+\n+        return binder.getConnInstanceTO(connInstance);\n+    }\n+\n+    @PreAuthorize(\"hasRole('CONNECTOR_DELETE')\")\n+    public ConnInstanceTO delete(final Long connInstanceId) {\n+        ConnInstance connInstance = connInstanceDAO.find(connInstanceId);\n+        if (connInstance == null) {\n+            throw new NotFoundException(\"Connector '\" + connInstanceId + \"'\");\n+        }\n+\n+        if (!connInstance.getResources().isEmpty()) {\n+            SyncopeClientException associatedResources = SyncopeClientException.build(\n+                    ClientExceptionType.AssociatedResources);\n+            for (ExternalResource resource : connInstance.getResources()) {\n+                associatedResources.getElements().add(resource.getKey());\n+            }\n+            throw associatedResources;\n+        }\n+\n+        ConnInstanceTO connToDelete = binder.getConnInstanceTO(connInstance);\n+\n+        connInstanceDAO.delete(connInstanceId);\n+\n+        return connToDelete;\n+    }\n+\n+    @PreAuthorize(\"hasRole('CONNECTOR_LIST')\")\n+    @Transactional(readOnly = true)\n+    public List<ConnInstanceTO> list(final String lang) {\n+        if (StringUtils.isBlank(lang)) {\n+            CurrentLocale.set(Locale.ENGLISH);\n+        } else {\n+            CurrentLocale.set(new Locale(lang));\n+        }\n+\n+        List<ConnInstance> connInstances = connInstanceDAO.findAll();\n+\n+        final List<ConnInstanceTO> connInstanceTOs = new ArrayList<>();\n+\n+        for (ConnInstance connector : connInstances) {\n+            try {\n+                connInstanceTOs.add(binder.getConnInstanceTO(connector));\n+            } catch (NotFoundException e) {\n+                LOG.error(\"Connector '{}#{}' not found\", connector.getBundleName(), connector.getVersion());\n+            }\n+        }\n+\n+        return connInstanceTOs;\n+    }\n+\n+    @PreAuthorize(\"hasRole('CONNECTOR_READ')\")\n+    @Transactional(readOnly = true)\n+    public ConnInstanceTO read(final Long connInstanceId) {\n+        ConnInstance connInstance = connInstanceDAO.find(connInstanceId);\n+        if (connInstance == null) {\n+            throw new NotFoundException(\"Connector '\" + connInstanceId + \"'\");\n+        }\n+\n+        return binder.getConnInstanceTO(connInstance);\n+    }\n+\n+    @PreAuthorize(\"hasRole('CONNECTOR_READ')\")\n+    @Transactional(readOnly = true)\n+    public List<ConnBundleTO> getBundles(final String lang) {\n+        if (StringUtils.isBlank(lang)) {\n+            CurrentLocale.set(Locale.ENGLISH);\n+        } else {\n+            CurrentLocale.set(new Locale(lang));\n+        }\n+\n+        List<ConnBundleTO> connectorBundleTOs = new ArrayList<>();\n+        for (Map.Entry<String, List<ConnectorInfo>> entry : connIdBundleManager.getConnectorInfos().entrySet()) {\n+            for (ConnectorInfo bundle : entry.getValue()) {\n+                ConnBundleTO connBundleTO = new ConnBundleTO();\n+                connBundleTO.setDisplayName(bundle.getConnectorDisplayName());\n+\n+                connBundleTO.setLocation(entry.getKey());\n+\n+                ConnectorKey key = bundle.getConnectorKey();\n+                connBundleTO.setBundleName(key.getBundleName());\n+                connBundleTO.setConnectorName(key.getConnectorName());\n+                connBundleTO.setVersion(key.getBundleVersion());\n+\n+                ConfigurationProperties properties = connIdBundleManager.getConfigurationProperties(bundle);\n+\n+                for (String propName : properties.getPropertyNames()) {\n+                    connBundleTO.getProperties().add(binder.buildConnConfPropSchema(properties.getProperty(propName)));\n+                }\n+\n+                LOG.debug(\"Connector bundle: {}\", connBundleTO);\n+\n+                connectorBundleTOs.add(connBundleTO);\n+            }\n+        }\n+\n+        return connectorBundleTOs;\n+    }\n+\n+    @PreAuthorize(\"hasRole('CONNECTOR_READ')\")\n+    @Transactional(readOnly = true)\n+    public List<String> getSchemaNames(final ConnInstanceTO connInstanceTO, final boolean includeSpecial) {\n+        final ConnInstance connInstance = connInstanceDAO.find(connInstanceTO.getKey());\n+        if (connInstance == null) {\n+            throw new NotFoundException(\"Connector '\" + connInstanceTO.getKey() + \"'\");\n+        }\n+\n+        // consider the possibility to receive overridden properties only\n+        final Set<ConnConfProperty> conf = binder.mergeConnConfProperties(connInstanceTO.getConfiguration(),\n+                connInstance.getConfiguration());\n+\n+        // We cannot use Spring bean because this method could be used during resource definition or modification:\n+        // bean couldn't exist or couldn't be updated.\n+        // This is the reason why we should take a \"not mature\" connector facade proxy to ask for schema names.\n+        final List<String> result = new ArrayList<>(connFactory.createConnector(connInstance, conf).\n+                getSchemaNames(includeSpecial));\n+\n+        return result;\n+    }\n+\n+    @PreAuthorize(\"hasRole('CONNECTOR_READ')\")\n+    @Transactional(readOnly = true)\n+    public List<String> getSupportedObjectClasses(final ConnInstanceTO connInstanceTO) {\n+        final ConnInstance connInstance = connInstanceDAO.find(connInstanceTO.getKey());\n+        if (connInstance == null) {\n+            throw new NotFoundException(\"Connector '\" + connInstanceTO.getKey() + \"'\");\n+        }\n+\n+        // consider the possibility to receive overridden properties only\n+        final Set<ConnConfProperty> conf = binder.mergeConnConfProperties(connInstanceTO.getConfiguration(),\n+                connInstance.getConfiguration());\n+\n+        // We cannot use Spring bean because this method could be used during resource definition or modification:\n+        // bean couldn't exist or couldn't be updated.\n+        // This is the reason why we should take a \"not mature\" connector facade proxy to ask for object classes.\n+        Set<ObjectClass> objectClasses = connFactory.createConnector(connInstance, conf).getSupportedObjectClasses();\n+\n+        List<String> result = new ArrayList<>(objectClasses.size());\n+        for (ObjectClass objectClass : objectClasses) {\n+            result.add(objectClass.getObjectClassValue());\n+        }\n+\n+        return result;\n+    }\n+\n+    @PreAuthorize(\"hasRole('CONNECTOR_READ')\")\n+    @Transactional(readOnly = true)\n+    public List<ConnConfProperty> getConfigurationProperties(final Long connInstanceId) {\n+\n+        final ConnInstance connInstance = connInstanceDAO.find(connInstanceId);\n+        if (connInstance == null) {\n+            throw new NotFoundException(\"Connector '\" + connInstanceId + \"'\");\n+        }\n+\n+        return new ArrayList<ConnConfProperty>(connInstance.getConfiguration());\n+    }\n+\n+    @PreAuthorize(\"hasRole('CONNECTOR_READ')\")\n+    @Transactional(readOnly = true)\n+    public boolean check(final ConnInstanceTO connInstanceTO) {\n+        final Connector connector = connFactory.createConnector(\n+                binder.getConnInstance(connInstanceTO), connInstanceTO.getConfiguration());\n+\n+        boolean result;\n+        try {\n+            connector.test();\n+            result = true;\n+        } catch (Exception ex) {\n+            LOG.error(\"Test connection failure {}\", ex);\n+            result = false;\n+        }\n+\n+        return result;\n+    }\n+\n+    @PreAuthorize(\"hasRole('CONNECTOR_READ')\")\n+    @Transactional(readOnly = true)\n+    public ConnInstanceTO readByResource(final String resourceName) {\n+        ExternalResource resource = resourceDAO.find(resourceName);\n+        if (resource == null) {\n+            throw new NotFoundException(\"Resource '\" + resourceName + \"'\");\n+        }\n+        return binder.getConnInstanceTO(connFactory.getConnector(resource).getActiveConnInstance());\n+    }\n+\n+    @PreAuthorize(\"hasRole('CONNECTOR_RELOAD')\")\n+    @Transactional(readOnly = true)\n+    public void reload() {\n+        connFactory.unload();\n+        connFactory.load();\n+    }\n+\n+    @PreAuthorize(\"hasRole('CONNECTOR_DELETE') and #bulkAction.operation == #bulkAction.operation.DELETE\")\n+    public BulkActionResult bulk(final BulkAction bulkAction) {\n+        BulkActionResult res = new BulkActionResult();\n+\n+        if (bulkAction.getOperation() == BulkAction.Type.DELETE) {\n+            for (String id : bulkAction.getTargets()) {\n+                try {\n+                    res.add(delete(Long.valueOf(id)).getKey(), BulkActionResult.Status.SUCCESS);\n+                } catch (Exception e) {\n+                    LOG.error(\"Error performing delete for connector {}\", id, e);\n+                    res.add(id, BulkActionResult.Status.FAILURE);\n+                }\n+            }\n+        }\n+\n+        return res;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    protected ConnInstanceTO resolveReference(final Method method, final Object... args)\n+            throws UnresolvedReferenceException {\n+\n+        Long id = null;\n+\n+        if (ArrayUtils.isNotEmpty(args)) {\n+            for (int i = 0; id == null && i < args.length; i++) {\n+                if (args[i] instanceof Long) {\n+                    id = (Long) args[i];\n+                } else if (args[i] instanceof ConnInstanceTO) {\n+                    id = ((ConnInstanceTO) args[i]).getKey();\n+                }\n+            }\n+        }\n+\n+        if ((id != null) && !id.equals(0l)) {\n+            try {\n+                return binder.getConnInstanceTO(connInstanceDAO.find(id));\n+            } catch (Throwable ignore) {\n+                LOG.debug(\"Unresolved reference\", ignore);\n+                throw new UnresolvedReferenceException(ignore);\n+            }\n+        }\n+\n+        throw new UnresolvedReferenceException();\n+    }\n+}"},{"sha":"e71fcb9706898e8f5cc8f8c83767990c017408b8","filename":"syncope620/server/logic/src/main/java/org/apache/syncope/server/logic/EntitlementLogic.java","status":"added","additions":58,"deletions":0,"changes":58,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2FEntitlementLogic.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2FEntitlementLogic.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2FEntitlementLogic.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,58 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.server.logic;\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+import org.apache.syncope.common.lib.wrap.EntitlementTO;\n+import org.apache.syncope.persistence.api.dao.EntitlementDAO;\n+import org.apache.syncope.persistence.api.entity.Entitlement;\n+import org.apache.syncope.server.security.AuthContextUtil;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Component;\n+\n+@Component\n+public class EntitlementLogic extends AbstractTransactionalLogic<EntitlementTO> {\n+\n+    @Autowired\n+    private EntitlementDAO entitlementDAO;\n+\n+    public List<String> getAll() {\n+        List<Entitlement> entitlements = entitlementDAO.findAll();\n+        List<String> result = new ArrayList<String>(entitlements.size());\n+        for (Entitlement entitlement : entitlements) {\n+            result.add(entitlement.getKey());\n+        }\n+\n+        return result;\n+    }\n+\n+    public Set<String> getOwn() {\n+        return AuthContextUtil.getOwnedEntitlementNames();\n+    }\n+\n+    @Override\n+    protected EntitlementTO resolveReference(final Method method, final Object... args)\n+            throws UnresolvedReferenceException {\n+\n+        throw new UnresolvedReferenceException();\n+    }\n+}"},{"sha":"5356b86977f7e683da2d9beb60fb8211ab7e0d26","filename":"syncope620/server/logic/src/main/java/org/apache/syncope/server/logic/LoggerLogic.java","status":"added","additions":307,"deletions":0,"changes":307,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2FLoggerLogic.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2FLoggerLogic.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2FLoggerLogic.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,307 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.server.logic;\n+\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import org.apache.logging.log4j.Level;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.core.LoggerContext;\n+import org.apache.logging.log4j.core.config.LoggerConfig;\n+import org.apache.syncope.common.lib.SyncopeClientException;\n+import org.apache.syncope.common.lib.SyncopeConstants;\n+import org.apache.syncope.common.lib.to.EventCategoryTO;\n+import org.apache.syncope.common.lib.to.LoggerTO;\n+import org.apache.syncope.common.lib.types.AttributableType;\n+import org.apache.syncope.common.lib.types.AuditElements.EventCategoryType;\n+import org.apache.syncope.common.lib.types.AuditLoggerName;\n+import org.apache.syncope.common.lib.types.ClientExceptionType;\n+import org.apache.syncope.common.lib.types.LoggerLevel;\n+import org.apache.syncope.common.lib.types.LoggerType;\n+import org.apache.syncope.common.lib.types.ResourceOperation;\n+import org.apache.syncope.common.lib.types.TaskType;\n+import org.apache.syncope.persistence.api.dao.ExternalResourceDAO;\n+import org.apache.syncope.persistence.api.dao.LoggerDAO;\n+import org.apache.syncope.persistence.api.dao.NotFoundException;\n+import org.apache.syncope.persistence.api.dao.TaskDAO;\n+import org.apache.syncope.persistence.api.entity.EntityFactory;\n+import org.apache.syncope.persistence.api.entity.ExternalResource;\n+import org.apache.syncope.persistence.api.entity.Logger;\n+import org.apache.syncope.persistence.api.entity.task.SchedTask;\n+import org.apache.syncope.persistence.api.entity.task.SyncTask;\n+import org.apache.syncope.server.spring.BeanUtils;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.core.io.Resource;\n+import org.springframework.core.io.support.PathMatchingResourcePatternResolver;\n+import org.springframework.core.io.support.ResourcePatternResolver;\n+import org.springframework.core.type.classreading.CachingMetadataReaderFactory;\n+import org.springframework.core.type.classreading.MetadataReader;\n+import org.springframework.core.type.classreading.MetadataReaderFactory;\n+import org.springframework.security.access.prepost.PreAuthorize;\n+import org.springframework.stereotype.Component;\n+import org.springframework.transaction.annotation.Transactional;\n+import org.springframework.util.ClassUtils;\n+import org.springframework.util.SystemPropertyUtils;\n+\n+@Component\n+public class LoggerLogic extends AbstractTransactionalLogic<LoggerTO> {\n+\n+    @Autowired\n+    private LoggerDAO loggerDAO;\n+\n+    @Autowired\n+    private ExternalResourceDAO resourceDAO;\n+\n+    @Autowired\n+    private TaskDAO taskDAO;\n+\n+    @Autowired\n+    private EntityFactory entityFactory;\n+\n+    private List<LoggerTO> list(final LoggerType type) {\n+        List<LoggerTO> result = new ArrayList<>();\n+        for (Logger syncopeLogger : loggerDAO.findAll(type)) {\n+            LoggerTO loggerTO = new LoggerTO();\n+            BeanUtils.copyProperties(syncopeLogger, loggerTO);\n+            result.add(loggerTO);\n+        }\n+\n+        return result;\n+    }\n+\n+    @PreAuthorize(\"hasRole('LOG_LIST')\")\n+    @Transactional(readOnly = true)\n+    public List<LoggerTO> listLogs() {\n+        return list(LoggerType.LOG);\n+    }\n+\n+    @PreAuthorize(\"hasRole('AUDIT_LIST')\")\n+    @Transactional(readOnly = true)\n+    public List<AuditLoggerName> listAudits() {\n+        List<AuditLoggerName> result = new ArrayList<>();\n+\n+        for (LoggerTO logger : list(LoggerType.AUDIT)) {\n+            try {\n+                result.add(AuditLoggerName.fromLoggerName(logger.getName()));\n+            } catch (Exception e) {\n+                LOG.warn(\"Unexpected audit logger name: {}\", logger.getName(), e);\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    private void throwInvalidLogger(final LoggerType type) {\n+        SyncopeClientException sce = SyncopeClientException.build(ClientExceptionType.InvalidLogger);\n+        sce.getElements().add(\"Expected \" + type.name());\n+\n+        throw sce;\n+    }\n+\n+    private LoggerTO setLevel(final String name, final Level level, final LoggerType expectedType) {\n+        Logger syncopeLogger = loggerDAO.find(name);\n+        if (syncopeLogger == null) {\n+            LOG.debug(\"Logger {} not found: creating new...\", name);\n+\n+            syncopeLogger = entityFactory.newEntity(Logger.class);\n+            syncopeLogger.setKey(name);\n+            syncopeLogger.setType(name.startsWith(LoggerType.AUDIT.getPrefix())\n+                    ? LoggerType.AUDIT\n+                    : LoggerType.LOG);\n+        }\n+\n+        if (expectedType != syncopeLogger.getType()) {\n+            throwInvalidLogger(expectedType);\n+        }\n+\n+        syncopeLogger.setLevel(LoggerLevel.fromLevel(level));\n+        syncopeLogger = loggerDAO.save(syncopeLogger);\n+\n+        LoggerContext ctx = (LoggerContext) LogManager.getContext(false);\n+        LoggerConfig logConf = SyncopeConstants.ROOT_LOGGER.equals(name)\n+                ? ctx.getConfiguration().getLoggerConfig(LogManager.ROOT_LOGGER_NAME)\n+                : ctx.getConfiguration().getLoggerConfig(name);\n+        logConf.setLevel(level);\n+        ctx.updateLoggers();\n+\n+        LoggerTO result = new LoggerTO();\n+        BeanUtils.copyProperties(syncopeLogger, result);\n+\n+        return result;\n+    }\n+\n+    @PreAuthorize(\"hasRole('LOG_SET_LEVEL')\")\n+    public LoggerTO setLogLevel(final String name, final Level level) {\n+        return setLevel(name, level, LoggerType.LOG);\n+    }\n+\n+    @PreAuthorize(\"hasRole('AUDIT_ENABLE')\")\n+    public void enableAudit(final AuditLoggerName auditLoggerName) {\n+        try {\n+            setLevel(auditLoggerName.toLoggerName(), Level.DEBUG, LoggerType.AUDIT);\n+        } catch (IllegalArgumentException e) {\n+            SyncopeClientException sce = SyncopeClientException.build(ClientExceptionType.InvalidLogger);\n+            sce.getElements().add(e.getMessage());\n+            throw sce;\n+        }\n+    }\n+\n+    private LoggerTO delete(final String name, final LoggerType expectedType) throws NotFoundException {\n+        Logger syncopeLogger = loggerDAO.find(name);\n+        if (syncopeLogger == null) {\n+            throw new NotFoundException(\"Logger \" + name);\n+        } else if (expectedType != syncopeLogger.getType()) {\n+            throwInvalidLogger(expectedType);\n+        }\n+\n+        LoggerTO loggerToDelete = new LoggerTO();\n+        BeanUtils.copyProperties(syncopeLogger, loggerToDelete);\n+\n+        // remove SyncopeLogger from local storage, so that LoggerLoader won't load this next time\n+        loggerDAO.delete(syncopeLogger);\n+\n+        // set log level to OFF in order to disable configured logger until next reboot\n+        LoggerContext ctx = (LoggerContext) LogManager.getContext(false);\n+        org.apache.logging.log4j.core.Logger logger = SyncopeConstants.ROOT_LOGGER.equals(name)\n+                ? ctx.getLogger(LogManager.ROOT_LOGGER_NAME) : ctx.getLogger(name);\n+        logger.setLevel(Level.OFF);\n+        ctx.updateLoggers();\n+\n+        return loggerToDelete;\n+    }\n+\n+    @PreAuthorize(\"hasRole('LOG_DELETE')\")\n+    public LoggerTO deleteLog(final String name) throws NotFoundException {\n+        return delete(name, LoggerType.LOG);\n+    }\n+\n+    @PreAuthorize(\"hasRole('AUDIT_DISABLE')\")\n+    public void disableAudit(final AuditLoggerName auditLoggerName) {\n+        try {\n+            delete(auditLoggerName.toLoggerName(), LoggerType.AUDIT);\n+        } catch (NotFoundException e) {\n+            LOG.debug(\"Ignoring disable of non existing logger {}\", auditLoggerName.toLoggerName());\n+        } catch (IllegalArgumentException e) {\n+            SyncopeClientException sce = SyncopeClientException.build(ClientExceptionType.InvalidLogger);\n+            sce.getElements().add(e.getMessage());\n+            throw sce;\n+        }\n+    }\n+\n+    @PreAuthorize(\"hasRole('AUDIT_LIST') or hasRole('NOTIFICATION_LIST')\")\n+    public List<EventCategoryTO> listAuditEvents() {\n+        // use set to avoi duplications or null elements\n+        final Set<EventCategoryTO> events = new HashSet<EventCategoryTO>();\n+\n+        try {\n+            final ResourcePatternResolver resourcePatternResolver = new PathMatchingResourcePatternResolver();\n+            final MetadataReaderFactory metadataReaderFactory =\n+                    new CachingMetadataReaderFactory(resourcePatternResolver);\n+\n+            final String packageSearchPath =\n+                    ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX\n+                    + ClassUtils.convertClassNameToResourcePath(\n+                            SystemPropertyUtils.resolvePlaceholders(this.getClass().getPackage().getName()))\n+                    + \"/\" + \"**/*.class\";\n+\n+            final Resource[] resources = resourcePatternResolver.getResources(packageSearchPath);\n+            for (Resource resource : resources) {\n+                if (resource.isReadable()) {\n+                    final MetadataReader metadataReader = metadataReaderFactory.getMetadataReader(resource);\n+                    final Class<?> clazz = Class.forName(metadataReader.getClassMetadata().getClassName());\n+\n+                    if (clazz.isAnnotationPresent(Component.class)\n+                            && AbstractLogic.class.isAssignableFrom(clazz)) {\n+                        final EventCategoryTO eventCategoryTO = new EventCategoryTO();\n+                        eventCategoryTO.setCategory(clazz.getSimpleName());\n+                        for (Method method : clazz.getDeclaredMethods()) {\n+                            if (Modifier.isPublic(method.getModifiers())) {\n+                                eventCategoryTO.getEvents().add(method.getName());\n+                            }\n+                        }\n+                        events.add(eventCategoryTO);\n+                    }\n+                }\n+            }\n+\n+            //SYNCOPE-608\n+            final EventCategoryTO authenticationControllerEvents = new EventCategoryTO();\n+            authenticationControllerEvents.setCategory(\"AuthenticationController\");\n+            authenticationControllerEvents.getEvents().add(\"login\");\n+            events.add(authenticationControllerEvents);\n+\n+            events.add(new EventCategoryTO(EventCategoryType.PROPAGATION));\n+            events.add(new EventCategoryTO(EventCategoryType.SYNCHRONIZATION));\n+            events.add(new EventCategoryTO(EventCategoryType.PUSH));\n+\n+            for (AttributableType attributableType : AttributableType.values()) {\n+                for (ExternalResource resource : resourceDAO.findAll()) {\n+                    final EventCategoryTO propEventCategoryTO = new EventCategoryTO(EventCategoryType.PROPAGATION);\n+                    final EventCategoryTO syncEventCategoryTO = new EventCategoryTO(EventCategoryType.SYNCHRONIZATION);\n+                    final EventCategoryTO pushEventCategoryTO = new EventCategoryTO(EventCategoryType.PUSH);\n+\n+                    propEventCategoryTO.setCategory(attributableType.name().toLowerCase());\n+                    propEventCategoryTO.setSubcategory(resource.getKey());\n+\n+                    syncEventCategoryTO.setCategory(attributableType.name().toLowerCase());\n+                    pushEventCategoryTO.setCategory(attributableType.name().toLowerCase());\n+                    syncEventCategoryTO.setSubcategory(resource.getKey());\n+                    pushEventCategoryTO.setSubcategory(resource.getKey());\n+\n+                    for (ResourceOperation resourceOperation : ResourceOperation.values()) {\n+                        propEventCategoryTO.getEvents().add(resourceOperation.name().toLowerCase());\n+                        syncEventCategoryTO.getEvents().add(resourceOperation.name().toLowerCase());\n+                        pushEventCategoryTO.getEvents().add(resourceOperation.name().toLowerCase());\n+                    }\n+\n+                    events.add(propEventCategoryTO);\n+                    events.add(syncEventCategoryTO);\n+                    events.add(pushEventCategoryTO);\n+                }\n+            }\n+\n+            for (SchedTask task : taskDAO.<SchedTask>findAll(TaskType.SCHEDULED)) {\n+                final EventCategoryTO eventCategoryTO = new EventCategoryTO(EventCategoryType.TASK);\n+                eventCategoryTO.setCategory(Class.forName(task.getJobClassName()).getSimpleName());\n+                events.add(eventCategoryTO);\n+            }\n+\n+            for (SyncTask task : taskDAO.<SyncTask>findAll(TaskType.SYNCHRONIZATION)) {\n+                final EventCategoryTO eventCategoryTO = new EventCategoryTO(EventCategoryType.TASK);\n+                eventCategoryTO.setCategory(Class.forName(task.getJobClassName()).getSimpleName());\n+                events.add(eventCategoryTO);\n+            }\n+        } catch (Exception e) {\n+            LOG.error(\"Failure retrieving audit/notification events\", e);\n+        }\n+\n+        return new ArrayList<EventCategoryTO>(events);\n+    }\n+\n+    @Override\n+    protected LoggerTO resolveReference(final Method method, final Object... args)\n+            throws UnresolvedReferenceException {\n+\n+        throw new UnresolvedReferenceException();\n+    }\n+}"},{"sha":"81ca56f8f64255a75da9afc40a83fc578e9c62e5","filename":"syncope620/server/logic/src/main/java/org/apache/syncope/server/logic/LogicInvocationHandler.java","status":"added","additions":108,"deletions":0,"changes":108,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2FLogicInvocationHandler.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2FLogicInvocationHandler.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2FLogicInvocationHandler.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,108 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.server.logic;\n+\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+import org.apache.syncope.common.lib.types.AuditElements;\n+import org.apache.syncope.server.logic.audit.AuditManager;\n+import org.apache.syncope.server.logic.notification.NotificationManager;\n+import org.aspectj.lang.ProceedingJoinPoint;\n+import org.aspectj.lang.annotation.Around;\n+import org.aspectj.lang.annotation.Aspect;\n+import org.aspectj.lang.reflect.MethodSignature;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+@Aspect\n+public class LogicInvocationHandler {\n+\n+    /**\n+     * Logger.\n+     */\n+    private static final Logger LOG = LoggerFactory.getLogger(LogicInvocationHandler.class);\n+\n+    @Autowired\n+    private NotificationManager notificationManager;\n+\n+    @Autowired\n+    private AuditManager auditManager;\n+\n+    @Around(\"execution(* org.apache.syncope.server.logic.AbstractLogic+.*(..))\")\n+    public Object around(final ProceedingJoinPoint joinPoint) throws Throwable {\n+        final Class<?> clazz = joinPoint.getTarget().getClass();\n+\n+        final Object[] input = joinPoint.getArgs();\n+\n+        final String category = clazz.getSimpleName();\n+\n+        final MethodSignature ms = (MethodSignature) joinPoint.getSignature();\n+        Method method = ms.getMethod();\n+\n+        final String event = joinPoint.getSignature().getName();\n+\n+        AuditElements.Result result = null;\n+        Object output = null;\n+        Object before = null;\n+\n+        try {\n+            LOG.debug(\"Before {}.{}({})\", clazz.getSimpleName(), event,\n+                    input == null || input.length == 0 ? \"\" : Arrays.asList(input));\n+\n+            try {\n+                before = ((AbstractLogic) joinPoint.getTarget()).resolveBeanReference(method, input);\n+            } catch (UnresolvedReferenceException ignore) {\n+                LOG.debug(\"Unresolved bean reference ...\");\n+            }\n+\n+            output = joinPoint.proceed();\n+            result = AuditElements.Result.SUCCESS;\n+\n+            LOG.debug(\"After returning {}.{}: {}\", clazz.getSimpleName(), event, output);\n+            return output;\n+        } catch (Throwable t) {\n+            output = t;\n+            result = AuditElements.Result.FAILURE;\n+\n+            LOG.debug(\"After throwing {}.{}\", clazz.getSimpleName(), event);\n+            throw t;\n+        } finally {\n+            notificationManager.createTasks(\n+                    AuditElements.EventCategoryType.REST,\n+                    category,\n+                    null,\n+                    event,\n+                    result,\n+                    before,\n+                    output,\n+                    input);\n+\n+            auditManager.audit(\n+                    AuditElements.EventCategoryType.REST,\n+                    category,\n+                    null,\n+                    event,\n+                    result,\n+                    before,\n+                    output,\n+                    input);\n+        }\n+    }\n+}"},{"sha":"053cf3f465321c65f893978b9bafe8e74c54ebfd","filename":"syncope620/server/logic/src/main/java/org/apache/syncope/server/logic/NotificationController.java","status":"added","additions":127,"deletions":0,"changes":127,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2FNotificationController.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2FNotificationController.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2FNotificationController.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,127 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.server.logic;\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.syncope.common.lib.to.NotificationTO;\n+import org.apache.syncope.persistence.api.dao.NotFoundException;\n+import org.apache.syncope.persistence.api.dao.NotificationDAO;\n+import org.apache.syncope.persistence.api.entity.Notification;\n+import org.apache.syncope.server.logic.data.NotificationDataBinder;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.access.prepost.PreAuthorize;\n+import org.springframework.stereotype.Component;\n+\n+@Component\n+public class NotificationController extends AbstractTransactionalLogic<NotificationTO> {\n+\n+    @Autowired\n+    private NotificationDAO notificationDAO;\n+\n+    @Autowired\n+    private NotificationDataBinder binder;\n+\n+    @PreAuthorize(\"hasRole('NOTIFICATION_READ')\")\n+    public NotificationTO read(final Long notificationId) {\n+        Notification notification = notificationDAO.find(notificationId);\n+        if (notification == null) {\n+            LOG.error(\"Could not find notification '\" + notificationId + \"'\");\n+\n+            throw new NotFoundException(String.valueOf(notificationId));\n+        }\n+\n+        return binder.getNotificationTO(notification);\n+    }\n+\n+    @PreAuthorize(\"hasRole('NOTIFICATION_LIST')\")\n+    public List<NotificationTO> list() {\n+        List<Notification> notifications = notificationDAO.findAll();\n+\n+        List<NotificationTO> notificationTOs = new ArrayList<NotificationTO>();\n+        for (Notification notification : notifications) {\n+            notificationTOs.add(binder.getNotificationTO(notification));\n+        }\n+\n+        return notificationTOs;\n+    }\n+\n+    @PreAuthorize(\"hasRole('NOTIFICATION_CREATE')\")\n+    public NotificationTO create(final NotificationTO notificationTO) {\n+        return binder.getNotificationTO(notificationDAO.save(binder.create(notificationTO)));\n+    }\n+\n+    @PreAuthorize(\"hasRole('NOTIFICATION_UPDATE')\")\n+    public NotificationTO update(final NotificationTO notificationTO) {\n+        Notification notification = notificationDAO.find(notificationTO.getKey());\n+        if (notification == null) {\n+            LOG.error(\"Could not find notification '\" + notificationTO.getKey() + \"'\");\n+            throw new NotFoundException(String.valueOf(notificationTO.getKey()));\n+        }\n+\n+        binder.update(notification, notificationTO);\n+        notification = notificationDAO.save(notification);\n+\n+        return binder.getNotificationTO(notification);\n+    }\n+\n+    @PreAuthorize(\"hasRole('CONNECTOR_DELETE')\")\n+    public NotificationTO delete(final Long notificationId) {\n+        Notification notification = notificationDAO.find(notificationId);\n+        if (notification == null) {\n+            LOG.error(\"Could not find notification '\" + notificationId + \"'\");\n+\n+            throw new NotFoundException(String.valueOf(notificationId));\n+        }\n+\n+        NotificationTO deleted = binder.getNotificationTO(notification);\n+        notificationDAO.delete(notificationId);\n+        return deleted;\n+    }\n+\n+    @Override\n+    protected NotificationTO resolveReference(final Method method, final Object... args)\n+            throws UnresolvedReferenceException {\n+\n+        Long id = null;\n+\n+        if (ArrayUtils.isNotEmpty(args)) {\n+            for (int i = 0; id == null && i < args.length; i++) {\n+                if (args[i] instanceof Long) {\n+                    id = (Long) args[i];\n+                } else if (args[i] instanceof NotificationTO) {\n+                    id = ((NotificationTO) args[i]).getKey();\n+                }\n+            }\n+        }\n+\n+        if ((id != null) && !id.equals(0l)) {\n+            try {\n+                return binder.getNotificationTO(notificationDAO.find(id));\n+            } catch (Throwable ignore) {\n+                LOG.debug(\"Unresolved reference\", ignore);\n+                throw new UnresolvedReferenceException(ignore);\n+            }\n+        }\n+\n+        throw new UnresolvedReferenceException();\n+    }\n+}"},{"sha":"fbfb127db18150ce9b10643a119de29e3dbb82fa","filename":"syncope620/server/logic/src/main/java/org/apache/syncope/server/logic/PolicyController.java","status":"added","additions":197,"deletions":0,"changes":197,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2FPolicyController.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2FPolicyController.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2FPolicyController.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,197 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.server.logic;\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.syncope.common.lib.to.AbstractPolicyTO;\n+import org.apache.syncope.common.lib.to.AccountPolicyTO;\n+import org.apache.syncope.common.lib.to.PasswordPolicyTO;\n+import org.apache.syncope.common.lib.to.SyncPolicyTO;\n+import org.apache.syncope.common.lib.types.PolicyType;\n+import org.apache.syncope.persistence.api.dao.NotFoundException;\n+import org.apache.syncope.persistence.api.dao.PolicyDAO;\n+import org.apache.syncope.persistence.api.entity.AccountPolicy;\n+import org.apache.syncope.persistence.api.entity.PasswordPolicy;\n+import org.apache.syncope.persistence.api.entity.Policy;\n+import org.apache.syncope.persistence.api.entity.SyncPolicy;\n+import org.apache.syncope.server.logic.data.PolicyDataBinder;\n+import org.apache.syncope.server.logic.init.ImplementationClassNamesLoader;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.access.prepost.PreAuthorize;\n+import org.springframework.stereotype.Component;\n+\n+@Component\n+public class PolicyController extends AbstractTransactionalLogic<AbstractPolicyTO> {\n+\n+    @Autowired\n+    private ImplementationClassNamesLoader classNamesLoader;\n+\n+    @Autowired\n+    private PolicyDAO policyDAO;\n+\n+    @Autowired\n+    private PolicyDataBinder binder;\n+\n+    @PreAuthorize(\"hasRole('POLICY_CREATE')\")\n+    public <T extends AbstractPolicyTO> T create(final T policyTO) {\n+        return binder.getPolicyTO(policyDAO.save(binder.getPolicy(null, policyTO)));\n+    }\n+\n+    private <T extends AbstractPolicyTO, K extends Policy> T update(final T policyTO, final K policy) {\n+        binder.getPolicy(policy, policyTO);\n+        K savedPolicy = policyDAO.save(policy);\n+        return binder.getPolicyTO(savedPolicy);\n+    }\n+\n+    @PreAuthorize(\"hasRole('POLICY_UPDATE')\")\n+    public PasswordPolicyTO update(final PasswordPolicyTO policyTO) {\n+        Policy policy = policyDAO.find(policyTO.getId());\n+        if (!(policy instanceof PasswordPolicy)) {\n+            throw new NotFoundException(\"PasswordPolicy with id \" + policyTO.getId());\n+        }\n+\n+        return update(policyTO, policy);\n+    }\n+\n+    @PreAuthorize(\"hasRole('POLICY_UPDATE')\")\n+    public AccountPolicyTO update(final AccountPolicyTO policyTO) {\n+        Policy policy = policyDAO.find(policyTO.getId());\n+        if (!(policy instanceof AccountPolicy)) {\n+            throw new NotFoundException(\"AccountPolicy with id \" + policyTO.getId());\n+        }\n+\n+        return update(policyTO, policy);\n+    }\n+\n+    @PreAuthorize(\"hasRole('POLICY_UPDATE')\")\n+    public SyncPolicyTO update(final SyncPolicyTO policyTO) {\n+        Policy policy = policyDAO.find(policyTO.getId());\n+        if (!(policy instanceof SyncPolicy)) {\n+            throw new NotFoundException(\"SyncPolicy with id \" + policyTO.getId());\n+        }\n+\n+        return update(policyTO, policy);\n+    }\n+\n+    @PreAuthorize(\"hasRole('POLICY_LIST')\")\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends AbstractPolicyTO> List<T> list(final PolicyType type) {\n+\n+        List<? extends Policy> policies = policyDAO.find(type);\n+\n+        final List<T> policyTOs = new ArrayList<T>();\n+        for (Policy policy : policies) {\n+            policyTOs.add((T) binder.getPolicyTO(policy));\n+        }\n+\n+        return policyTOs;\n+    }\n+\n+    @PreAuthorize(\"hasRole('POLICY_READ')\")\n+    public PasswordPolicyTO getGlobalPasswordPolicy() {\n+        PasswordPolicy policy = policyDAO.getGlobalPasswordPolicy();\n+        if (policy == null) {\n+            throw new NotFoundException(\"No password policy found\");\n+        }\n+\n+        return (PasswordPolicyTO) binder.getPolicyTO(policy);\n+    }\n+\n+    @PreAuthorize(\"hasRole('POLICY_READ')\")\n+    public AccountPolicyTO getGlobalAccountPolicy() {\n+        AccountPolicy policy = policyDAO.getGlobalAccountPolicy();\n+        if (policy == null) {\n+            throw new NotFoundException(\"No account policy found\");\n+        }\n+\n+        return (AccountPolicyTO) binder.getPolicyTO(policy);\n+    }\n+\n+    @PreAuthorize(\"hasRole('POLICY_READ')\")\n+    public SyncPolicyTO getGlobalSyncPolicy() {\n+        SyncPolicy policy = policyDAO.getGlobalSyncPolicy();\n+        if (policy == null) {\n+            throw new NotFoundException(\"No sync policy found\");\n+        }\n+\n+        return (SyncPolicyTO) binder.getPolicyTO(policy);\n+    }\n+\n+    @PreAuthorize(\"hasRole('POLICY_READ')\")\n+    public <T extends AbstractPolicyTO> T read(final Long id) {\n+        Policy policy = policyDAO.find(id);\n+        if (policy == null) {\n+            throw new NotFoundException(\"Policy \" + id + \" not found\");\n+        }\n+\n+        return binder.getPolicyTO(policy);\n+    }\n+\n+    @PreAuthorize(\"hasRole('POLICY_DELETE')\")\n+    public <T extends AbstractPolicyTO> T delete(final Long id) {\n+        Policy policy = policyDAO.find(id);\n+        if (policy == null) {\n+            throw new NotFoundException(\"Policy \" + id + \" not found\");\n+        }\n+\n+        T policyToDelete = binder.getPolicyTO(policy);\n+        policyDAO.delete(policy);\n+\n+        return policyToDelete;\n+    }\n+\n+    @PreAuthorize(\"hasRole('POLICY_LIST')\")\n+    public Set<String> getSyncCorrelationRuleClasses() {\n+        return classNamesLoader.getClassNames(ImplementationClassNamesLoader.Type.SYNC_CORRELATION_RULES);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    protected AbstractPolicyTO resolveReference(final Method method, final Object... args)\n+            throws UnresolvedReferenceException {\n+        Long id = null;\n+\n+        if (ArrayUtils.isNotEmpty(args)) {\n+            for (int i = 0; id == null && i < args.length; i++) {\n+                if (args[i] instanceof Long) {\n+                    id = (Long) args[i];\n+                } else if (args[i] instanceof AbstractPolicyTO) {\n+                    id = ((AbstractPolicyTO) args[i]).getId();\n+                }\n+            }\n+        }\n+\n+        if ((id != null) && !id.equals(0l)) {\n+            try {\n+                return binder.getPolicyTO(policyDAO.find(id));\n+            } catch (Throwable ignore) {\n+                LOG.debug(\"Unresolved reference\", ignore);\n+                throw new UnresolvedReferenceException(ignore);\n+            }\n+        }\n+\n+        throw new UnresolvedReferenceException();\n+    }\n+}"},{"sha":"0d8af577b42b145864468f7eb5e56d688fca648b","filename":"syncope620/server/logic/src/main/java/org/apache/syncope/server/logic/ReportLogic.java","status":"added","additions":348,"deletions":0,"changes":348,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2FReportLogic.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2FReportLogic.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2FReportLogic.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,348 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.server.logic;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.OutputStream;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.zip.ZipInputStream;\n+import org.apache.cocoon.optional.pipeline.components.sax.fop.FopSerializer;\n+import org.apache.cocoon.pipeline.NonCachingPipeline;\n+import org.apache.cocoon.pipeline.Pipeline;\n+import org.apache.cocoon.sax.SAXPipelineComponent;\n+import org.apache.cocoon.sax.component.XMLGenerator;\n+import org.apache.cocoon.sax.component.XMLSerializer;\n+import org.apache.cocoon.sax.component.XSLTTransformer;\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.syncope.common.lib.SyncopeClientException;\n+import org.apache.syncope.common.lib.report.ReportletConf;\n+import org.apache.syncope.common.lib.to.ReportExecTO;\n+import org.apache.syncope.common.lib.to.ReportTO;\n+import org.apache.syncope.common.lib.types.ClientExceptionType;\n+import org.apache.syncope.common.lib.types.ReportExecExportFormat;\n+import org.apache.syncope.common.lib.types.ReportExecStatus;\n+import org.apache.syncope.persistence.api.dao.NotFoundException;\n+import org.apache.syncope.persistence.api.dao.ReportDAO;\n+import org.apache.syncope.persistence.api.dao.ReportExecDAO;\n+import org.apache.syncope.persistence.api.dao.search.OrderByClause;\n+import org.apache.syncope.persistence.api.entity.EntityFactory;\n+import org.apache.syncope.persistence.api.entity.Report;\n+import org.apache.syncope.persistence.api.entity.ReportExec;\n+import org.apache.syncope.server.logic.data.ReportDataBinder;\n+import org.apache.syncope.server.logic.init.JobInstanceLoader;\n+import org.apache.syncope.server.logic.report.Reportlet;\n+import org.apache.syncope.server.logic.report.TextSerializer;\n+import org.apache.xmlgraphics.util.MimeConstants;\n+import org.quartz.JobKey;\n+import org.quartz.Scheduler;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.scheduling.quartz.SchedulerFactoryBean;\n+import org.springframework.security.access.prepost.PreAuthorize;\n+import org.springframework.stereotype.Component;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+@Component\n+public class ReportLogic extends AbstractTransactionalLogic<ReportTO> {\n+\n+    @Autowired\n+    private ReportDAO reportDAO;\n+\n+    @Autowired\n+    private ReportExecDAO reportExecDAO;\n+\n+    @Autowired\n+    private JobInstanceLoader jobInstanceLoader;\n+\n+    @Autowired\n+    private SchedulerFactoryBean scheduler;\n+\n+    @Autowired\n+    private ReportDataBinder binder;\n+\n+    @Autowired\n+    private EntityFactory entityFactory;\n+\n+    @PreAuthorize(\"hasRole('REPORT_CREATE')\")\n+    public ReportTO create(final ReportTO reportTO) {\n+        Report report = entityFactory.newEntity(Report.class);\n+        binder.getReport(report, reportTO);\n+        report = reportDAO.save(report);\n+\n+        try {\n+            jobInstanceLoader.registerJob(report);\n+        } catch (Exception e) {\n+            LOG.error(\"While registering quartz job for report \" + report.getKey(), e);\n+\n+            SyncopeClientException sce = SyncopeClientException.build(ClientExceptionType.Scheduling);\n+            sce.getElements().add(e.getMessage());\n+            throw sce;\n+        }\n+\n+        return binder.getReportTO(report);\n+    }\n+\n+    @PreAuthorize(\"hasRole('REPORT_UPDATE')\")\n+    public ReportTO update(final ReportTO reportTO) {\n+        Report report = reportDAO.find(reportTO.getId());\n+        if (report == null) {\n+            throw new NotFoundException(\"Report \" + reportTO.getId());\n+        }\n+\n+        binder.getReport(report, reportTO);\n+        report = reportDAO.save(report);\n+\n+        try {\n+            jobInstanceLoader.registerJob(report);\n+        } catch (Exception e) {\n+            LOG.error(\"While registering quartz job for report \" + report.getKey(), e);\n+\n+            SyncopeClientException sce = SyncopeClientException.build(ClientExceptionType.Scheduling);\n+            sce.getElements().add(e.getMessage());\n+            throw sce;\n+        }\n+\n+        return binder.getReportTO(report);\n+    }\n+\n+    @PreAuthorize(\"hasRole('REPORT_LIST')\")\n+    public int count() {\n+        return reportDAO.count();\n+    }\n+\n+    @PreAuthorize(\"hasRole('REPORT_LIST')\")\n+    public List<ReportTO> list(final int page, final int size, final List<OrderByClause> orderByClauses) {\n+        List<Report> reports = reportDAO.findAll(page, size, orderByClauses);\n+        List<ReportTO> result = new ArrayList<ReportTO>(reports.size());\n+        for (Report report : reports) {\n+            result.add(binder.getReportTO(report));\n+        }\n+        return result;\n+    }\n+\n+    @PreAuthorize(\"hasRole('REPORT_LIST')\")\n+    @SuppressWarnings(\"rawtypes\")\n+    public Set<String> getReportletConfClasses() {\n+        Set<String> reportletConfClasses = new HashSet<String>();\n+\n+        for (Class<Reportlet> reportletClass : binder.getAllReportletClasses()) {\n+            Class<? extends ReportletConf> reportletConfClass = binder.getReportletConfClass(reportletClass);\n+            if (reportletConfClass != null) {\n+                reportletConfClasses.add(reportletConfClass.getName());\n+            }\n+        }\n+\n+        return reportletConfClasses;\n+    }\n+\n+    @PreAuthorize(\"hasRole('REPORT_READ')\")\n+    public ReportTO read(final Long reportId) {\n+        Report report = reportDAO.find(reportId);\n+        if (report == null) {\n+            throw new NotFoundException(\"Report \" + reportId);\n+        }\n+        return binder.getReportTO(report);\n+    }\n+\n+    @PreAuthorize(\"hasRole('REPORT_READ')\")\n+    @Transactional(readOnly = true)\n+    public ReportExecTO readExecution(final Long executionId) {\n+        ReportExec reportExec = reportExecDAO.find(executionId);\n+        if (reportExec == null) {\n+            throw new NotFoundException(\"Report execution \" + executionId);\n+        }\n+        return binder.getReportExecTO(reportExec);\n+    }\n+\n+    @PreAuthorize(\"hasRole('REPORT_READ')\")\n+    public void exportExecutionResult(final OutputStream os, final ReportExec reportExec,\n+            final ReportExecExportFormat format) {\n+\n+        // streaming SAX handler from a compressed byte array stream\n+        ByteArrayInputStream bais = new ByteArrayInputStream(reportExec.getExecResult());\n+        ZipInputStream zis = new ZipInputStream(bais);\n+        try {\n+            // a single ZipEntry in the ZipInputStream (see ReportJob)\n+            zis.getNextEntry();\n+\n+            Pipeline<SAXPipelineComponent> pipeline = new NonCachingPipeline<SAXPipelineComponent>();\n+            pipeline.addComponent(new XMLGenerator(zis));\n+\n+            Map<String, Object> parameters = new HashMap<String, Object>();\n+            parameters.put(\"status\", reportExec.getStatus());\n+            parameters.put(\"message\", reportExec.getMessage());\n+            parameters.put(\"startDate\", reportExec.getStartDate());\n+            parameters.put(\"endDate\", reportExec.getEndDate());\n+\n+            switch (format) {\n+                case HTML:\n+                    XSLTTransformer xsl2html = new XSLTTransformer(getClass().getResource(\"/report/report2html.xsl\"));\n+                    xsl2html.setParameters(parameters);\n+                    pipeline.addComponent(xsl2html);\n+                    pipeline.addComponent(XMLSerializer.createXHTMLSerializer());\n+                    break;\n+\n+                case PDF:\n+                    XSLTTransformer xsl2pdf = new XSLTTransformer(getClass().getResource(\"/report/report2fo.xsl\"));\n+                    xsl2pdf.setParameters(parameters);\n+                    pipeline.addComponent(xsl2pdf);\n+                    pipeline.addComponent(new FopSerializer(MimeConstants.MIME_PDF));\n+                    break;\n+\n+                case RTF:\n+                    XSLTTransformer xsl2rtf = new XSLTTransformer(getClass().getResource(\"/report/report2fo.xsl\"));\n+                    xsl2rtf.setParameters(parameters);\n+                    pipeline.addComponent(xsl2rtf);\n+                    pipeline.addComponent(new FopSerializer(MimeConstants.MIME_RTF));\n+                    break;\n+\n+                case CSV:\n+                    XSLTTransformer xsl2csv = new XSLTTransformer(getClass().getResource(\"/report/report2csv.xsl\"));\n+                    xsl2csv.setParameters(parameters);\n+                    pipeline.addComponent(xsl2csv);\n+                    pipeline.addComponent(new TextSerializer());\n+                    break;\n+\n+                case XML:\n+                default:\n+                    pipeline.addComponent(XMLSerializer.createXMLSerializer());\n+            }\n+\n+            pipeline.setup(os);\n+            pipeline.execute();\n+\n+            LOG.debug(\"Result of {} successfully exported as {}\", reportExec, format);\n+        } catch (Exception e) {\n+            LOG.error(\"While exporting content\", e);\n+        } finally {\n+            IOUtils.closeQuietly(zis);\n+            IOUtils.closeQuietly(bais);\n+        }\n+    }\n+\n+    @PreAuthorize(\"hasRole('REPORT_READ')\")\n+    public ReportExec getAndCheckReportExec(final Long executionId) {\n+        ReportExec reportExec = reportExecDAO.find(executionId);\n+        if (reportExec == null) {\n+            throw new NotFoundException(\"Report execution \" + executionId);\n+        }\n+        if (!ReportExecStatus.SUCCESS.name().equals(reportExec.getStatus()) || reportExec.getExecResult() == null) {\n+            SyncopeClientException sce = SyncopeClientException.build(ClientExceptionType.InvalidReportExec);\n+            sce.getElements().add(reportExec.getExecResult() == null\n+                    ? \"No report data produced\"\n+                    : \"Report did not run successfully\");\n+            throw sce;\n+        }\n+        return reportExec;\n+    }\n+\n+    @PreAuthorize(\"hasRole('REPORT_EXECUTE')\")\n+    public ReportExecTO execute(final Long reportId) {\n+        Report report = reportDAO.find(reportId);\n+        if (report == null) {\n+            throw new NotFoundException(\"Report \" + reportId);\n+        }\n+\n+        try {\n+            jobInstanceLoader.registerJob(report);\n+\n+            scheduler.getScheduler().triggerJob(\n+                    new JobKey(JobInstanceLoader.getJobName(report), Scheduler.DEFAULT_GROUP));\n+        } catch (Exception e) {\n+            LOG.error(\"While executing report {}\", report, e);\n+\n+            SyncopeClientException sce = SyncopeClientException.build(ClientExceptionType.Scheduling);\n+            sce.getElements().add(e.getMessage());\n+            throw sce;\n+        }\n+\n+        ReportExecTO result = new ReportExecTO();\n+        result.setReport(reportId);\n+        result.setStartDate(new Date());\n+        result.setStatus(ReportExecStatus.STARTED.name());\n+        result.setMessage(\"Job fired; waiting for results...\");\n+\n+        return result;\n+    }\n+\n+    @PreAuthorize(\"hasRole('REPORT_DELETE')\")\n+    public ReportTO delete(final Long reportId) {\n+        Report report = reportDAO.find(reportId);\n+        if (report == null) {\n+            throw new NotFoundException(\"Report \" + reportId);\n+        }\n+\n+        ReportTO deletedReport = binder.getReportTO(report);\n+        jobInstanceLoader.unregisterJob(report);\n+        reportDAO.delete(report);\n+        return deletedReport;\n+    }\n+\n+    @PreAuthorize(\"hasRole('REPORT_DELETE')\")\n+    public ReportExecTO deleteExecution(final Long executionId) {\n+        ReportExec reportExec = reportExecDAO.find(executionId);\n+        if (reportExec == null) {\n+            throw new NotFoundException(\"Report execution \" + executionId);\n+        }\n+\n+        ReportExecTO reportExecToDelete = binder.getReportExecTO(reportExec);\n+        reportExecDAO.delete(reportExec);\n+        return reportExecToDelete;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    protected ReportTO resolveReference(final Method method, final Object... args)\n+            throws UnresolvedReferenceException {\n+\n+        Long id = null;\n+\n+        if (ArrayUtils.isNotEmpty(args) && (\"create\".equals(method.getName())\n+                || \"update\".equals(method.getName())\n+                || \"delete\".equals(method.getName()))) {\n+            for (int i = 0; id == null && i < args.length; i++) {\n+                if (args[i] instanceof Long) {\n+                    id = (Long) args[i];\n+                } else if (args[i] instanceof ReportTO) {\n+                    id = ((ReportTO) args[i]).getId();\n+                }\n+            }\n+        }\n+\n+        if ((id != null) && !id.equals(0l)) {\n+            try {\n+                return binder.getReportTO(reportDAO.find(id));\n+            } catch (Throwable ignore) {\n+                LOG.debug(\"Unresolved reference\", ignore);\n+                throw new UnresolvedReferenceException(ignore);\n+            }\n+        }\n+\n+        throw new UnresolvedReferenceException();\n+    }\n+}"},{"sha":"d1b28510c44c97c39a3a8338ac45d96ff2ce5c48","filename":"syncope620/server/logic/src/main/java/org/apache/syncope/server/logic/ResourceLogic.java","status":"added","additions":301,"deletions":0,"changes":301,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2FResourceLogic.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2FResourceLogic.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2FResourceLogic.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,301 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.server.logic;\n+\n+import java.lang.reflect.Method;\n+import java.util.List;\n+import java.util.Set;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.syncope.common.lib.SyncopeClientException;\n+import org.apache.syncope.common.lib.to.BulkAction;\n+import org.apache.syncope.common.lib.to.BulkActionResult;\n+import org.apache.syncope.common.lib.to.ConnObjectTO;\n+import org.apache.syncope.common.lib.to.ResourceTO;\n+import org.apache.syncope.common.lib.types.ClientExceptionType;\n+import org.apache.syncope.common.lib.types.MappingPurpose;\n+import org.apache.syncope.common.lib.types.SubjectType;\n+import org.apache.syncope.persistence.api.dao.ConnInstanceDAO;\n+import org.apache.syncope.persistence.api.dao.DuplicateException;\n+import org.apache.syncope.persistence.api.dao.ExternalResourceDAO;\n+import org.apache.syncope.persistence.api.dao.NotFoundException;\n+import org.apache.syncope.persistence.api.dao.RoleDAO;\n+import org.apache.syncope.persistence.api.dao.UserDAO;\n+import org.apache.syncope.persistence.api.entity.AttributableUtil;\n+import org.apache.syncope.persistence.api.entity.AttributableUtilFactory;\n+import org.apache.syncope.persistence.api.entity.ConnInstance;\n+import org.apache.syncope.persistence.api.entity.ExternalResource;\n+import org.apache.syncope.persistence.api.entity.MappingItem;\n+import org.apache.syncope.persistence.api.entity.Subject;\n+import org.apache.syncope.provisioning.api.Connector;\n+import org.apache.syncope.provisioning.api.ConnectorFactory;\n+import org.apache.syncope.server.logic.data.ResourceDataBinder;\n+import org.apache.syncope.server.logic.init.ImplementationClassNamesLoader;\n+import org.apache.syncope.server.utils.ConnObjectUtil;\n+import org.apache.syncope.server.utils.MappingUtil;\n+import org.identityconnectors.framework.common.objects.Attribute;\n+import org.identityconnectors.framework.common.objects.AttributeUtil;\n+import org.identityconnectors.framework.common.objects.ConnectorObject;\n+import org.identityconnectors.framework.common.objects.Name;\n+import org.identityconnectors.framework.common.objects.ObjectClass;\n+import org.identityconnectors.framework.common.objects.Uid;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.access.prepost.PreAuthorize;\n+import org.springframework.stereotype.Component;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+@Component\n+public class ResourceLogic extends AbstractTransactionalLogic<ResourceTO> {\n+\n+    @Autowired\n+    private ExternalResourceDAO resourceDAO;\n+\n+    @Autowired\n+    private ConnInstanceDAO connInstanceDAO;\n+\n+    @Autowired\n+    private UserDAO userDAO;\n+\n+    @Autowired\n+    private RoleDAO roleDAO;\n+\n+    @Autowired\n+    private ResourceDataBinder binder;\n+\n+    @Autowired\n+    private ImplementationClassNamesLoader classNamesLoader;\n+\n+    @Autowired\n+    private ConnObjectUtil connObjectUtil;\n+\n+    @Autowired\n+    private ConnectorFactory connFactory;\n+\n+    @Autowired\n+    private AttributableUtilFactory attrUtilFactory;\n+\n+    @PreAuthorize(\"hasRole('RESOURCE_CREATE')\")\n+    public ResourceTO create(final ResourceTO resourceTO) {\n+        if (StringUtils.isBlank(resourceTO.getKey())) {\n+            SyncopeClientException sce = SyncopeClientException.build(ClientExceptionType.RequiredValuesMissing);\n+            sce.getElements().add(\"Resource name\");\n+            throw sce;\n+        }\n+\n+        if (resourceDAO.find(resourceTO.getKey()) != null) {\n+            throw new DuplicateException(\"Resource '\" + resourceTO.getKey() + \"'\");\n+        }\n+\n+        ExternalResource resource = null;\n+        try {\n+            resource = resourceDAO.save(binder.create(resourceTO));\n+        } catch (SyncopeClientException e) {\n+            throw e;\n+        } catch (Exception e) {\n+            SyncopeClientException ex = SyncopeClientException.build(ClientExceptionType.InvalidExternalResource);\n+            ex.getElements().add(e.getMessage());\n+            throw ex;\n+        }\n+\n+        return binder.getResourceTO(resource);\n+    }\n+\n+    @PreAuthorize(\"hasRole('RESOURCE_UPDATE')\")\n+    public ResourceTO update(final ResourceTO resourceTO) {\n+        ExternalResource resource = resourceDAO.find(resourceTO.getKey());\n+        if (resource == null) {\n+            throw new NotFoundException(\"Resource '\" + resourceTO.getKey() + \"'\");\n+        }\n+\n+        resource = binder.update(resource, resourceTO);\n+        try {\n+            resource = resourceDAO.save(resource);\n+        } catch (SyncopeClientException e) {\n+            throw e;\n+        } catch (Exception e) {\n+            SyncopeClientException ex = SyncopeClientException.build(ClientExceptionType.InvalidExternalResource);\n+            ex.getElements().add(e.getMessage());\n+            throw ex;\n+        }\n+\n+        return binder.getResourceTO(resource);\n+    }\n+\n+    @PreAuthorize(\"hasRole('RESOURCE_DELETE')\")\n+    public ResourceTO delete(final String resourceName) {\n+        ExternalResource resource = resourceDAO.find(resourceName);\n+        if (resource == null) {\n+            throw new NotFoundException(\"Resource '\" + resourceName + \"'\");\n+        }\n+\n+        ResourceTO resourceToDelete = binder.getResourceTO(resource);\n+\n+        resourceDAO.delete(resourceName);\n+\n+        return resourceToDelete;\n+    }\n+\n+    @PreAuthorize(\"hasRole('RESOURCE_READ')\")\n+    @Transactional(readOnly = true)\n+    public ResourceTO read(final String resourceName) {\n+        ExternalResource resource = resourceDAO.find(resourceName);\n+        if (resource == null) {\n+            throw new NotFoundException(\"Resource '\" + resourceName + \"'\");\n+        }\n+\n+        return binder.getResourceTO(resource);\n+    }\n+\n+    @PreAuthorize(\"hasRole('RESOURCE_READ')\")\n+    public Set<String> getPropagationActionsClasses() {\n+        Set<String> actionsClasses = classNamesLoader.getClassNames(\n+                ImplementationClassNamesLoader.Type.PROPAGATION_ACTIONS);\n+\n+        return actionsClasses;\n+    }\n+\n+    @PreAuthorize(\"isAuthenticated()\")\n+    @Transactional(readOnly = true)\n+    public List<ResourceTO> list(final Long connInstanceId) {\n+        List<? extends ExternalResource> resources;\n+\n+        if (connInstanceId == null) {\n+            resources = resourceDAO.findAll();\n+        } else {\n+            ConnInstance connInstance = connInstanceDAO.find(connInstanceId);\n+            resources = connInstance.getResources();\n+        }\n+\n+        return binder.getResourceTOs(resources);\n+    }\n+\n+    @PreAuthorize(\"hasRole('RESOURCE_GETCONNECTOROBJECT')\")\n+    @Transactional(readOnly = true)\n+    public ConnObjectTO getConnectorObject(final String resourceName, final SubjectType type, final Long id) {\n+        ExternalResource resource = resourceDAO.find(resourceName);\n+        if (resource == null) {\n+            throw new NotFoundException(\"Resource '\" + resourceName + \"'\");\n+        }\n+\n+        Subject<?, ?, ?> subject = type == SubjectType.USER\n+                ? userDAO.find(id)\n+                : roleDAO.find(id);\n+        if (subject == null) {\n+            throw new NotFoundException(type + \" \" + id);\n+        }\n+\n+        final AttributableUtil attrUtil = attrUtilFactory.getInstance(type.asAttributableType());\n+\n+        MappingItem accountIdItem = attrUtil.getAccountIdItem(resource);\n+        if (accountIdItem == null) {\n+            throw new NotFoundException(\"AccountId mapping for \" + type + \" \" + id + \" on resource '\" + resourceName\n+                    + \"'\");\n+        }\n+        final String accountIdValue = MappingUtil.getAccountIdValue(\n+                subject, resource, attrUtil.getAccountIdItem(resource));\n+\n+        final ObjectClass objectClass = SubjectType.USER == type ? ObjectClass.ACCOUNT : ObjectClass.GROUP;\n+\n+        final Connector connector = connFactory.getConnector(resource);\n+        final ConnectorObject connectorObject = connector.getObject(objectClass, new Uid(accountIdValue),\n+                connector.getOperationOptions(attrUtil.getMappingItems(resource, MappingPurpose.BOTH)));\n+        if (connectorObject == null) {\n+            throw new NotFoundException(\"Object \" + accountIdValue + \" with class \" + objectClass\n+                    + \"not found on resource \" + resourceName);\n+        }\n+\n+        final Set<Attribute> attributes = connectorObject.getAttributes();\n+        if (AttributeUtil.find(Uid.NAME, attributes) == null) {\n+            attributes.add(connectorObject.getUid());\n+        }\n+        if (AttributeUtil.find(Name.NAME, attributes) == null) {\n+            attributes.add(connectorObject.getName());\n+        }\n+\n+        return connObjectUtil.getConnObjectTO(connectorObject);\n+    }\n+\n+    @PreAuthorize(\"hasRole('CONNECTOR_READ')\")\n+    @Transactional(readOnly = true)\n+    public boolean check(final ResourceTO resourceTO) {\n+        final ConnInstance connInstance = binder.getConnInstance(resourceTO);\n+\n+        final Connector connector = connFactory.createConnector(connInstance, connInstance.getConfiguration());\n+\n+        boolean result;\n+        try {\n+            connector.test();\n+            result = true;\n+        } catch (Exception e) {\n+            LOG.error(\"Test connection failure {}\", e);\n+            result = false;\n+        }\n+\n+        return result;\n+    }\n+\n+    @PreAuthorize(\"hasRole('RESOURCE_DELETE') and #bulkAction.operation == #bulkAction.operation.DELETE\")\n+    public BulkActionResult bulk(final BulkAction bulkAction) {\n+        BulkActionResult res = new BulkActionResult();\n+\n+        if (bulkAction.getOperation() == BulkAction.Type.DELETE) {\n+            for (String name : bulkAction.getTargets()) {\n+                try {\n+                    res.add(delete(name).getKey(), BulkActionResult.Status.SUCCESS);\n+                } catch (Exception e) {\n+                    LOG.error(\"Error performing delete for resource {}\", name, e);\n+                    res.add(name, BulkActionResult.Status.FAILURE);\n+                }\n+            }\n+        }\n+\n+        return res;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    protected ResourceTO resolveReference(final Method method, final Object... args)\n+            throws UnresolvedReferenceException {\n+\n+        String name = null;\n+\n+        if (ArrayUtils.isNotEmpty(args)) {\n+            for (int i = 0; name == null && i < args.length; i++) {\n+                if (args[i] instanceof String) {\n+                    name = (String) args[i];\n+                } else if (args[i] instanceof ResourceTO) {\n+                    name = ((ResourceTO) args[i]).getKey();\n+                }\n+            }\n+        }\n+\n+        if (name != null) {\n+            try {\n+                return binder.getResourceTO(resourceDAO.find(name));\n+            } catch (Throwable ignore) {\n+                LOG.debug(\"Unresolved reference\", ignore);\n+                throw new UnresolvedReferenceException(ignore);\n+            }\n+        }\n+\n+        throw new UnresolvedReferenceException();\n+    }\n+}"},{"sha":"aee0d27fc5932a2903d5a1bad434693a62ca95f6","filename":"syncope620/server/logic/src/main/java/org/apache/syncope/server/logic/RoleLogic.java","status":"added","additions":405,"deletions":0,"changes":405,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2FRoleLogic.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2FRoleLogic.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2FRoleLogic.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,405 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.server.logic;\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import javax.annotation.Resource;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.syncope.common.lib.SyncopeClientException;\n+import org.apache.syncope.common.lib.mod.RoleMod;\n+import org.apache.syncope.common.lib.to.BulkAction;\n+import org.apache.syncope.common.lib.to.BulkActionResult;\n+import org.apache.syncope.common.lib.to.PropagationStatus;\n+import org.apache.syncope.common.lib.to.RoleTO;\n+import org.apache.syncope.common.lib.types.ClientExceptionType;\n+import org.apache.syncope.common.lib.types.SubjectType;\n+import org.apache.syncope.persistence.api.RoleEntitlementUtil;\n+import org.apache.syncope.persistence.api.dao.NotFoundException;\n+import org.apache.syncope.persistence.api.dao.RoleDAO;\n+import org.apache.syncope.persistence.api.dao.SubjectSearchDAO;\n+import org.apache.syncope.persistence.api.dao.UserDAO;\n+import org.apache.syncope.persistence.api.dao.search.OrderByClause;\n+import org.apache.syncope.persistence.api.dao.search.SearchCond;\n+import org.apache.syncope.persistence.api.entity.role.Role;\n+import org.apache.syncope.persistence.api.entity.user.User;\n+import org.apache.syncope.provisioning.api.AttributableTransformer;\n+import org.apache.syncope.provisioning.api.RoleProvisioningManager;\n+import org.apache.syncope.provisioning.api.propagation.PropagationManager;\n+import org.apache.syncope.provisioning.api.propagation.PropagationTaskExecutor;\n+import org.apache.syncope.server.logic.data.RoleDataBinder;\n+import org.apache.syncope.server.security.AuthContextUtil;\n+import org.apache.syncope.server.security.UnauthorizedRoleException;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.access.prepost.PreAuthorize;\n+import org.springframework.stereotype.Component;\n+import org.springframework.transaction.annotation.Transactional;\n+import org.springframework.transaction.interceptor.TransactionInterceptor;\n+\n+/**\n+ * Note that this controller does not extend {@link AbstractTransactionalLogic}, hence does not provide any\n+ * Spring's Transactional logic at class level.\n+ */\n+@Component\n+public class RoleLogic extends AbstractSubjectLogic<RoleTO, RoleMod> {\n+\n+    @Autowired\n+    protected RoleDAO roleDAO;\n+\n+    @Autowired\n+    protected UserDAO userDAO;\n+\n+    @Autowired\n+    protected SubjectSearchDAO searchDAO;\n+\n+    @Autowired\n+    protected RoleDataBinder binder;\n+\n+    @Autowired\n+    protected PropagationManager propagationManager;\n+\n+    @Autowired\n+    protected PropagationTaskExecutor taskExecutor;\n+\n+    @Autowired\n+    protected AttributableTransformer attrTransformer;\n+\n+    @Resource(name = \"anonymousUser\")\n+    protected String anonymousUser;\n+\n+    @Autowired\n+    protected RoleProvisioningManager provisioningManager;\n+\n+    @PreAuthorize(\"hasAnyRole('ROLE_READ', T(org.apache.syncope.common.lib.SyncopeConstants).ANONYMOUS_ENTITLEMENT)\")\n+    @Transactional(readOnly = true)\n+    @Override\n+    public RoleTO read(final Long roleKey) {\n+        Role role;\n+        // bypass role entitlements check\n+        if (anonymousUser.equals(AuthContextUtil.getAuthenticatedUsername())) {\n+            role = roleDAO.find(roleKey);\n+        } else {\n+            role = roleDAO.authFetchRole(roleKey);\n+        }\n+\n+        if (role == null) {\n+            throw new NotFoundException(\"Role \" + roleKey);\n+        }\n+\n+        return binder.getRoleTO(role);\n+    }\n+\n+    @PreAuthorize(\"isAuthenticated() \"\n+            + \"and not(hasRole(T(org.apache.syncope.common.lib.SyncopeConstants).ANONYMOUS_ENTITLEMENT))\")\n+    @Transactional(readOnly = true)\n+    public RoleTO readSelf(final Long roleKey) {\n+        // Explicit search instead of using binder.getRoleFromId() in order to bypass auth checks - will do here\n+        Role role = roleDAO.find(roleKey);\n+        if (role == null) {\n+            throw new NotFoundException(\"Role \" + roleKey);\n+        }\n+\n+        Set<Long> ownedRoleIds;\n+        User authUser = userDAO.find(AuthContextUtil.getAuthenticatedUsername());\n+        if (authUser == null) {\n+            ownedRoleIds = Collections.<Long>emptySet();\n+        } else {\n+            ownedRoleIds = authUser.getRoleIds();\n+        }\n+\n+        Set<Long> allowedRoleIds = RoleEntitlementUtil.getRoleKeys(AuthContextUtil.getOwnedEntitlementNames());\n+        allowedRoleIds.addAll(ownedRoleIds);\n+        if (!allowedRoleIds.contains(role.getKey())) {\n+            throw new UnauthorizedRoleException(role.getKey());\n+        }\n+\n+        return binder.getRoleTO(role);\n+    }\n+\n+    @PreAuthorize(\"hasRole('ROLE_READ')\")\n+    @Transactional(readOnly = true)\n+    public RoleTO parent(final Long roleKey) {\n+        Role role = roleDAO.authFetchRole(roleKey);\n+\n+        Set<Long> allowedRoleIds = RoleEntitlementUtil.getRoleKeys(AuthContextUtil.getOwnedEntitlementNames());\n+        if (role.getParent() != null && !allowedRoleIds.contains(role.getParent().getKey())) {\n+            throw new UnauthorizedRoleException(role.getParent().getKey());\n+        }\n+\n+        RoleTO result = role.getParent() == null\n+                ? null\n+                : binder.getRoleTO(role.getParent());\n+\n+        return result;\n+    }\n+\n+    @PreAuthorize(\"hasRole('ROLE_READ')\")\n+    @Transactional(readOnly = true)\n+    public List<RoleTO> children(final Long roleKey) {\n+        Role role = roleDAO.authFetchRole(roleKey);\n+\n+        Set<Long> allowedRoleIds = RoleEntitlementUtil.getRoleKeys(AuthContextUtil.getOwnedEntitlementNames());\n+\n+        List<Role> children = roleDAO.findChildren(role);\n+        List<RoleTO> childrenTOs = new ArrayList<RoleTO>(children.size());\n+        for (Role child : children) {\n+            if (allowedRoleIds.contains(child.getKey())) {\n+                childrenTOs.add(binder.getRoleTO(child));\n+            }\n+        }\n+\n+        return childrenTOs;\n+    }\n+\n+    @PreAuthorize(\"isAuthenticated()\")\n+    @Transactional(readOnly = true, rollbackFor = { Throwable.class })\n+    @Override\n+    public int count() {\n+        return roleDAO.count();\n+    }\n+\n+    @PreAuthorize(\"isAuthenticated()\")\n+    @Transactional(readOnly = true)\n+    @Override\n+    public List<RoleTO> list(final int page, final int size, final List<OrderByClause> orderBy) {\n+        List<Role> roles = roleDAO.findAll(page, size, orderBy);\n+\n+        List<RoleTO> roleTOs = new ArrayList<>(roles.size());\n+        for (Role role : roles) {\n+            roleTOs.add(binder.getRoleTO(role));\n+        }\n+\n+        return roleTOs;\n+    }\n+\n+    @PreAuthorize(\"isAuthenticated()\")\n+    @Transactional(readOnly = true, rollbackFor = { Throwable.class })\n+    @Override\n+    public int searchCount(final SearchCond searchCondition) {\n+        final Set<Long> adminRoleIds = RoleEntitlementUtil.getRoleKeys(AuthContextUtil.getOwnedEntitlementNames());\n+        return searchDAO.count(adminRoleIds, searchCondition, SubjectType.ROLE);\n+    }\n+\n+    @PreAuthorize(\"isAuthenticated()\")\n+    @Transactional(readOnly = true, rollbackFor = { Throwable.class })\n+    @Override\n+    public List<RoleTO> search(final SearchCond searchCondition, final int page, final int size,\n+            final List<OrderByClause> orderBy) {\n+\n+        final List<Role> matchingRoles = searchDAO.search(\n+                RoleEntitlementUtil.getRoleKeys(AuthContextUtil.getOwnedEntitlementNames()),\n+                searchCondition, page, size, orderBy, SubjectType.ROLE);\n+\n+        final List<RoleTO> result = new ArrayList<>(matchingRoles.size());\n+        for (Role role : matchingRoles) {\n+            result.add(binder.getRoleTO(role));\n+        }\n+\n+        return result;\n+    }\n+\n+    @PreAuthorize(\"hasRole('ROLE_CREATE')\")\n+    public RoleTO create(final RoleTO roleTO) {\n+        // Check that this operation is allowed to be performed by caller\n+        Set<Long> allowedRoleIds = RoleEntitlementUtil.getRoleKeys(AuthContextUtil.getOwnedEntitlementNames());\n+        if (roleTO.getParent() != 0 && !allowedRoleIds.contains(roleTO.getParent())) {\n+            throw new UnauthorizedRoleException(roleTO.getParent());\n+        }\n+\n+        // Attributable transformation (if configured)\n+        RoleTO actual = attrTransformer.transform(roleTO);\n+        LOG.debug(\"Transformed: {}\", actual);\n+\n+        /*\n+         * Actual operations: workflow, propagation\n+         */\n+        Map.Entry<Long, List<PropagationStatus>> created = provisioningManager.create(roleTO);\n+        final RoleTO savedTO = binder.getRoleTO(created.getKey());\n+        savedTO.getPropagationStatusTOs().addAll(created.getValue());\n+        return savedTO;\n+    }\n+\n+    @PreAuthorize(\"hasRole('ROLE_UPDATE')\")\n+    @Override\n+    public RoleTO update(final RoleMod roleMod) {\n+        // Check that this operation is allowed to be performed by caller\n+        roleDAO.authFetchRole(roleMod.getKey());\n+\n+        // Attribute value transformation (if configured)\n+        RoleMod actual = attrTransformer.transform(roleMod);\n+        LOG.debug(\"Transformed: {}\", actual);\n+\n+        Map.Entry<Long, List<PropagationStatus>> updated = provisioningManager.update(roleMod);\n+\n+        final RoleTO updatedTO = binder.getRoleTO(updated.getKey());\n+        updatedTO.getPropagationStatusTOs().addAll(updated.getValue());\n+        return updatedTO;\n+    }\n+\n+    @PreAuthorize(\"hasRole('ROLE_DELETE')\")\n+    @Override\n+    public RoleTO delete(final Long roleKey) {\n+        List<Role> ownedRoles = roleDAO.findOwnedByRole(roleKey);\n+        if (!ownedRoles.isEmpty()) {\n+            List<String> owned = new ArrayList<String>(ownedRoles.size());\n+            for (Role role : ownedRoles) {\n+                owned.add(role.getKey() + \" \" + role.getName());\n+            }\n+\n+            SyncopeClientException sce = SyncopeClientException.build(ClientExceptionType.RoleOwnership);\n+            sce.getElements().addAll(owned);\n+            throw sce;\n+        }\n+\n+        List<PropagationStatus> statuses = provisioningManager.delete(roleKey);\n+\n+        RoleTO roleTO = new RoleTO();\n+        roleTO.setKey(roleKey);\n+\n+        roleTO.getPropagationStatusTOs().addAll(statuses);\n+\n+        return roleTO;\n+    }\n+\n+    @PreAuthorize(\"(hasRole('ROLE_DELETE') and #bulkAction.operation == #bulkAction.operation.DELETE)\")\n+    public BulkActionResult bulk(final BulkAction bulkAction) {\n+        BulkActionResult res = new BulkActionResult();\n+\n+        if (bulkAction.getOperation() == BulkAction.Type.DELETE) {\n+            for (String roleKey : bulkAction.getTargets()) {\n+                try {\n+                    res.add(delete(Long.valueOf(roleKey)).getKey(), BulkActionResult.Status.SUCCESS);\n+                } catch (Exception e) {\n+                    LOG.error(\"Error performing delete for role {}\", roleKey, e);\n+                    res.add(roleKey, BulkActionResult.Status.FAILURE);\n+                }\n+            }\n+        } else {\n+            LOG.warn(\"Unsupported bulk action: {}\", bulkAction.getOperation());\n+        }\n+\n+        return res;\n+    }\n+\n+    @PreAuthorize(\"hasRole('ROLE_UPDATE')\")\n+    @Transactional(rollbackFor = { Throwable.class })\n+    @Override\n+    public RoleTO unlink(final Long roleKey, final Collection<String> resources) {\n+        final RoleMod roleMod = new RoleMod();\n+        roleMod.setKey(roleKey);\n+        roleMod.getResourcesToRemove().addAll(resources);\n+        final Long updatedResult = provisioningManager.unlink(roleMod);\n+\n+        return binder.getRoleTO(updatedResult);\n+    }\n+\n+    @PreAuthorize(\"hasRole('ROLE_UPDATE')\")\n+    @Transactional(rollbackFor = { Throwable.class })\n+    @Override\n+    public RoleTO link(final Long roleKey, final Collection<String> resources) {\n+        final RoleMod roleMod = new RoleMod();\n+        roleMod.setKey(roleKey);\n+        roleMod.getResourcesToAdd().addAll(resources);\n+        return binder.getRoleTO(provisioningManager.link(roleMod));\n+    }\n+\n+    @PreAuthorize(\"hasRole('ROLE_UPDATE')\")\n+    @Transactional(rollbackFor = { Throwable.class })\n+    @Override\n+    public RoleTO unassign(final Long roleKey, final Collection<String> resources) {\n+        final RoleMod roleMod = new RoleMod();\n+        roleMod.setKey(roleKey);\n+        roleMod.getResourcesToRemove().addAll(resources);\n+        return update(roleMod);\n+    }\n+\n+    @PreAuthorize(\"hasRole('ROLE_UPDATE')\")\n+    @Transactional(rollbackFor = { Throwable.class })\n+    @Override\n+    public RoleTO assign(\n+            final Long roleKey, final Collection<String> resources, final boolean changePwd, final String password) {\n+\n+        final RoleMod userMod = new RoleMod();\n+        userMod.setKey(roleKey);\n+        userMod.getResourcesToAdd().addAll(resources);\n+        return update(userMod);\n+    }\n+\n+    @PreAuthorize(\"hasRole('ROLE_UPDATE')\")\n+    @Transactional(rollbackFor = { Throwable.class })\n+    @Override\n+    public RoleTO deprovision(final Long roleKey, final Collection<String> resources) {\n+        final Role role = roleDAO.authFetchRole(roleKey);\n+\n+        List<PropagationStatus> statuses = provisioningManager.deprovision(roleKey, resources);\n+\n+        final RoleTO updatedTO = binder.getRoleTO(role);\n+        updatedTO.getPropagationStatusTOs().addAll(statuses);\n+        return updatedTO;\n+    }\n+\n+    @PreAuthorize(\"hasRole('ROLE_UPDATE')\")\n+    @Transactional(rollbackFor = { Throwable.class })\n+    @Override\n+    public RoleTO provision(\n+            final Long roleKey, final Collection<String> resources, final boolean changePwd, final String password) {\n+        final RoleTO original = binder.getRoleTO(roleKey);\n+\n+        //trick: assign and retrieve propagation statuses ...\n+        original.getPropagationStatusTOs().addAll(\n+                assign(roleKey, resources, changePwd, password).getPropagationStatusTOs());\n+\n+        // .... rollback.\n+        TransactionInterceptor.currentTransactionStatus().setRollbackOnly();\n+        return original;\n+    }\n+\n+    @Override\n+    protected RoleTO resolveReference(final Method method, final Object... args) throws UnresolvedReferenceException {\n+        Long id = null;\n+\n+        if (ArrayUtils.isNotEmpty(args)) {\n+            for (int i = 0; id == null && i < args.length; i++) {\n+                if (args[i] instanceof Long) {\n+                    id = (Long) args[i];\n+                } else if (args[i] instanceof RoleTO) {\n+                    id = ((RoleTO) args[i]).getKey();\n+                } else if (args[i] instanceof RoleMod) {\n+                    id = ((RoleMod) args[i]).getKey();\n+                }\n+            }\n+        }\n+\n+        if ((id != null) && !id.equals(0l)) {\n+            try {\n+                return binder.getRoleTO(id);\n+            } catch (Throwable ignore) {\n+                LOG.debug(\"Unresolved reference\", ignore);\n+                throw new UnresolvedReferenceException(ignore);\n+            }\n+        }\n+\n+        throw new UnresolvedReferenceException();\n+    }\n+}"},{"sha":"675bd42cc7b4e9c2e905666c78ad16bebddc6573","filename":"syncope620/server/logic/src/main/java/org/apache/syncope/server/logic/SchemaLogic.java","status":"added","additions":328,"deletions":0,"changes":328,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2FSchemaLogic.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2FSchemaLogic.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2FSchemaLogic.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,328 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.server.logic;\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.syncope.common.lib.SyncopeClientException;\n+import org.apache.syncope.common.lib.to.AbstractSchemaTO;\n+import org.apache.syncope.common.lib.to.DerSchemaTO;\n+import org.apache.syncope.common.lib.to.PlainSchemaTO;\n+import org.apache.syncope.common.lib.to.VirSchemaTO;\n+import org.apache.syncope.common.lib.types.AttributableType;\n+import org.apache.syncope.common.lib.types.ClientExceptionType;\n+import org.apache.syncope.common.lib.types.SchemaType;\n+import org.apache.syncope.persistence.api.dao.DerSchemaDAO;\n+import org.apache.syncope.persistence.api.dao.DuplicateException;\n+import org.apache.syncope.persistence.api.dao.NotFoundException;\n+import org.apache.syncope.persistence.api.dao.PlainSchemaDAO;\n+import org.apache.syncope.persistence.api.dao.VirSchemaDAO;\n+import org.apache.syncope.persistence.api.entity.AttributableUtil;\n+import org.apache.syncope.persistence.api.entity.AttributableUtilFactory;\n+import org.apache.syncope.persistence.api.entity.DerSchema;\n+import org.apache.syncope.persistence.api.entity.PlainSchema;\n+import org.apache.syncope.persistence.api.entity.VirSchema;\n+import org.apache.syncope.server.logic.data.SchemaDataBinder;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.access.prepost.PreAuthorize;\n+import org.springframework.stereotype.Component;\n+\n+@Component\n+public class SchemaLogic extends AbstractTransactionalLogic<AbstractSchemaTO> {\n+\n+    @Autowired\n+    private PlainSchemaDAO plainSchemaDAO;\n+\n+    @Autowired\n+    private DerSchemaDAO derSchemaDAO;\n+\n+    @Autowired\n+    private VirSchemaDAO virSchemaDAO;\n+\n+    @Autowired\n+    private SchemaDataBinder binder;\n+\n+    @Autowired\n+    private AttributableUtilFactory attrUtilFactory;\n+\n+    private boolean doesSchemaExist(final SchemaType schemaType, final String name, final AttributableUtil attrUtil) {\n+        boolean found;\n+\n+        switch (schemaType) {\n+            case VIRTUAL:\n+                found = virSchemaDAO.find(name, attrUtil.virSchemaClass()) != null;\n+                break;\n+\n+            case DERIVED:\n+                found = derSchemaDAO.find(name, attrUtil.derSchemaClass()) != null;\n+                break;\n+\n+            case PLAIN:\n+                found = plainSchemaDAO.find(name, attrUtil.plainSchemaClass()) != null;\n+                break;\n+\n+            default:\n+                found = false;\n+        }\n+\n+        return found;\n+    }\n+\n+    @PreAuthorize(\"hasRole('SCHEMA_CREATE')\")\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends AbstractSchemaTO> T create(\n+            final AttributableType attrType, final SchemaType schemaType, final T schemaTO) {\n+\n+        if (StringUtils.isBlank(schemaTO.getKey())) {\n+            SyncopeClientException sce = SyncopeClientException.build(ClientExceptionType.RequiredValuesMissing);\n+            sce.getElements().add(\"Schema name\");\n+            throw sce;\n+        }\n+\n+        final AttributableUtil attrUtil = attrUtilFactory.getInstance(attrType);\n+\n+        if (doesSchemaExist(schemaType, schemaTO.getKey(), attrUtil)) {\n+            throw new DuplicateException(schemaType + \"/\" + attrType + \"/\" + schemaTO.getKey());\n+        }\n+\n+        T created;\n+        switch (schemaType) {\n+            case VIRTUAL:\n+                VirSchema virSchema = attrUtil.newVirSchema();\n+                binder.create((VirSchemaTO) schemaTO, virSchema);\n+                virSchema = virSchemaDAO.save(virSchema);\n+                created = (T) binder.getVirSchemaTO(virSchema);\n+                break;\n+            case DERIVED:\n+                DerSchema derSchema = attrUtil.newDerSchema();\n+                binder.create((DerSchemaTO) schemaTO, derSchema);\n+                derSchema = derSchemaDAO.save(derSchema);\n+\n+                created = (T) binder.getDerSchemaTO(derSchema);\n+                break;\n+\n+            case PLAIN:\n+            default:\n+                PlainSchema normalSchema = attrUtil.newPlainSchema();\n+                binder.create((PlainSchemaTO) schemaTO, normalSchema);\n+                normalSchema = plainSchemaDAO.save(normalSchema);\n+\n+                created = (T) binder.getSchemaTO(normalSchema, attrUtil);\n+        }\n+        return created;\n+    }\n+\n+    @PreAuthorize(\"hasRole('SCHEMA_DELETE')\")\n+    public void delete(final AttributableType attrType, final SchemaType schemaType, final String schemaName) {\n+        final AttributableUtil attrUtil = attrUtilFactory.getInstance(attrType);\n+\n+        if (!doesSchemaExist(schemaType, schemaName, attrUtil)) {\n+            throw new NotFoundException(schemaType + \"/\" + attrType + \"/\" + schemaName);\n+        }\n+\n+        switch (schemaType) {\n+            case VIRTUAL:\n+                virSchemaDAO.delete(schemaName, attrUtil);\n+                break;\n+\n+            case DERIVED:\n+                derSchemaDAO.delete(schemaName, attrUtil);\n+                break;\n+\n+            case PLAIN:\n+            default:\n+                plainSchemaDAO.delete(schemaName, attrUtil);\n+        }\n+    }\n+\n+    @PreAuthorize(\"isAuthenticated()\")\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends AbstractSchemaTO> List<T> list(final AttributableType attrType, final SchemaType schemaType) {\n+        final AttributableUtil attrUtil = attrUtilFactory.getInstance(attrType);\n+\n+        List<T> result;\n+        switch (schemaType) {\n+            case VIRTUAL:\n+                List<VirSchema> virSchemas = virSchemaDAO.findAll(attrUtil.virSchemaClass());\n+                result = new ArrayList<>(virSchemas.size());\n+                for (VirSchema derSchema : virSchemas) {\n+                    result.add((T) binder.getVirSchemaTO(derSchema));\n+                }\n+                break;\n+\n+            case DERIVED:\n+                List<DerSchema> derSchemas = derSchemaDAO.findAll(attrUtil.derSchemaClass());\n+                result = new ArrayList<>(derSchemas.size());\n+                for (DerSchema derSchema : derSchemas) {\n+                    result.add((T) binder.getDerSchemaTO(derSchema));\n+                }\n+                break;\n+\n+            case PLAIN:\n+            default:\n+                List<PlainSchema> schemas = plainSchemaDAO.findAll(attrUtil.plainSchemaClass());\n+                result = new ArrayList<>(schemas.size());\n+                for (PlainSchema schema : schemas) {\n+                    result.add((T) binder.getSchemaTO(schema, attrUtil));\n+                }\n+        }\n+\n+        return result;\n+    }\n+\n+    @PreAuthorize(\"hasRole('SCHEMA_READ')\")\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends AbstractSchemaTO> T read(\n+            final AttributableType attrType, final SchemaType schemaType, final String schemaName) {\n+\n+        final AttributableUtil attrUtil = attrUtilFactory.getInstance(attrType);\n+\n+        T read;\n+        switch (schemaType) {\n+            case VIRTUAL:\n+                VirSchema virSchema = virSchemaDAO.find(schemaName, attrUtil.virSchemaClass());\n+                if (virSchema == null) {\n+                    throw new NotFoundException(\"Virtual Schema '\" + schemaName + \"'\");\n+                }\n+\n+                read = (T) binder.getVirSchemaTO(virSchema);\n+                break;\n+\n+            case DERIVED:\n+                DerSchema derSchema = derSchemaDAO.find(schemaName, attrUtil.derSchemaClass());\n+                if (derSchema == null) {\n+                    throw new NotFoundException(\"Derived schema '\" + schemaName + \"'\");\n+                }\n+\n+                read = (T) binder.getDerSchemaTO(derSchema);\n+                break;\n+\n+            case PLAIN:\n+            default:\n+                PlainSchema schema = plainSchemaDAO.find(schemaName, attrUtil.plainSchemaClass());\n+                if (schema == null) {\n+                    throw new NotFoundException(\"Schema '\" + schemaName + \"'\");\n+                }\n+\n+                read = (T) binder.getSchemaTO(schema, attrUtil);\n+        }\n+\n+        return read;\n+    }\n+\n+    @PreAuthorize(\"hasRole('SCHEMA_UPDATE')\")\n+    public <T extends AbstractSchemaTO> void update(\n+            final AttributableType attrType, final SchemaType schemaType, final T schemaTO) {\n+\n+        final AttributableUtil attrUtil = attrUtilFactory.getInstance(attrType);\n+\n+        if (!doesSchemaExist(schemaType, schemaTO.getKey(), attrUtil)) {\n+            throw new NotFoundException(schemaType + \"/\" + attrType + \"/\" + schemaTO.getKey());\n+        }\n+\n+        switch (schemaType) {\n+            case VIRTUAL:\n+                VirSchema virSchema = virSchemaDAO.find(schemaTO.getKey(), attrUtil.virSchemaClass());\n+                if (virSchema == null) {\n+                    throw new NotFoundException(\"Virtual Schema '\" + schemaTO.getKey() + \"'\");\n+                }\n+\n+                binder.update((VirSchemaTO) schemaTO, virSchema);\n+                virSchemaDAO.save(virSchema);\n+                break;\n+\n+            case DERIVED:\n+                DerSchema derSchema = derSchemaDAO.find(schemaTO.getKey(), attrUtil.derSchemaClass());\n+                if (derSchema == null) {\n+                    throw new NotFoundException(\"Derived schema '\" + schemaTO.getKey() + \"'\");\n+                }\n+\n+                binder.update((DerSchemaTO) schemaTO, derSchema);\n+                derSchemaDAO.save(derSchema);\n+                break;\n+\n+            case PLAIN:\n+            default:\n+                PlainSchema schema = plainSchemaDAO.find(schemaTO.getKey(), attrUtil.plainSchemaClass());\n+                if (schema == null) {\n+                    throw new NotFoundException(\"Schema '\" + schemaTO.getKey() + \"'\");\n+                }\n+\n+                binder.update((PlainSchemaTO) schemaTO, schema, attrUtil);\n+                plainSchemaDAO.save(schema);\n+        }\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    protected AbstractSchemaTO resolveReference(final Method method, final Object... args)\n+            throws UnresolvedReferenceException {\n+\n+        String kind = null;\n+        String name = null;\n+        if (ArrayUtils.isNotEmpty(args)) {\n+            for (int i = 0; (name == null || kind == null) && i < args.length; i++) {\n+                if (args[i] instanceof String) {\n+                    if (kind == null) {\n+                        kind = (String) args[i];\n+                    } else {\n+                        name = (String) args[i];\n+                    }\n+                } else if (args[i] instanceof AbstractSchemaTO) {\n+                    name = ((AbstractSchemaTO) args[i]).getKey();\n+                }\n+            }\n+        }\n+\n+        if (name != null) {\n+            try {\n+                final AttributableUtil attrUtil = attrUtilFactory.getInstance(kind);\n+\n+                AbstractSchemaTO result = null;\n+\n+                PlainSchema plainSchema = plainSchemaDAO.find(name, attrUtil.plainSchemaClass());\n+                if (plainSchema == null) {\n+                    DerSchema derSchema = derSchemaDAO.find(name, attrUtil.derSchemaClass());\n+                    if (derSchema == null) {\n+                        VirSchema virSchema = virSchemaDAO.find(name, attrUtil.virSchemaClass());\n+                        if (virSchema != null) {\n+                            result = binder.getVirSchemaTO(virSchema);\n+                        }\n+                    } else {\n+                        result = binder.getDerSchemaTO(derSchema);\n+                    }\n+                } else {\n+                    result = binder.getSchemaTO(plainSchema, attrUtil);\n+                }\n+\n+                return result;\n+            } catch (Throwable ignore) {\n+                LOG.debug(\"Unresolved reference\", ignore);\n+                throw new UnresolvedReferenceException(ignore);\n+            }\n+        }\n+\n+        throw new UnresolvedReferenceException();\n+    }\n+}"},{"sha":"01b2a573525c0ce67794b143e571ce1020d29411","filename":"syncope620/server/logic/src/main/java/org/apache/syncope/server/logic/SecurityQuestionLogic.java","status":"added","additions":150,"deletions":0,"changes":150,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2FSecurityQuestionLogic.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2FSecurityQuestionLogic.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2FSecurityQuestionLogic.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,150 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.server.logic;\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.syncope.common.lib.to.SecurityQuestionTO;\n+import org.apache.syncope.persistence.api.dao.NotFoundException;\n+import org.apache.syncope.persistence.api.dao.SecurityQuestionDAO;\n+import org.apache.syncope.persistence.api.dao.UserDAO;\n+import org.apache.syncope.persistence.api.entity.user.SecurityQuestion;\n+import org.apache.syncope.persistence.api.entity.user.User;\n+import org.apache.syncope.server.logic.data.SecurityQuestionDataBinder;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.access.prepost.PreAuthorize;\n+import org.springframework.stereotype.Component;\n+\n+@Component\n+public class SecurityQuestionLogic extends AbstractTransactionalLogic<SecurityQuestionTO> {\n+\n+    @Autowired\n+    private SecurityQuestionDAO securityQuestionDAO;\n+\n+    @Autowired\n+    private UserDAO userDAO;\n+\n+    @Autowired\n+    private SecurityQuestionDataBinder binder;\n+\n+    @PreAuthorize(\"isAuthenticated()\")\n+    public List<SecurityQuestionTO> list() {\n+        List<SecurityQuestionTO> result = new ArrayList<SecurityQuestionTO>();\n+        for (SecurityQuestion securityQuestion : securityQuestionDAO.findAll()) {\n+            result.add(binder.getSecurityQuestionTO(securityQuestion));\n+        }\n+\n+        return result;\n+    }\n+\n+    @PreAuthorize(\"isAuthenticated()\")\n+    public SecurityQuestionTO read(final Long securityQuestionId) {\n+        SecurityQuestion securityQuestion = securityQuestionDAO.find(securityQuestionId);\n+        if (securityQuestion == null) {\n+            LOG.error(\"Could not find security question '\" + securityQuestionId + \"'\");\n+\n+            throw new NotFoundException(String.valueOf(securityQuestionId));\n+        }\n+\n+        return binder.getSecurityQuestionTO(securityQuestion);\n+    }\n+\n+    @PreAuthorize(\"hasRole('SECURITY_QUESTION_CREATE')\")\n+    public SecurityQuestionTO create(final SecurityQuestionTO securityQuestionTO) {\n+        return binder.getSecurityQuestionTO(securityQuestionDAO.save(binder.create(securityQuestionTO)));\n+    }\n+\n+    @PreAuthorize(\"hasRole('SECURITY_QUESTION_UPDATE')\")\n+    public SecurityQuestionTO update(final SecurityQuestionTO securityQuestionTO) {\n+        SecurityQuestion securityQuestion = securityQuestionDAO.find(securityQuestionTO.getKey());\n+        if (securityQuestion == null) {\n+            LOG.error(\"Could not find security question '\" + securityQuestionTO.getKey() + \"'\");\n+\n+            throw new NotFoundException(String.valueOf(securityQuestionTO.getKey()));\n+        }\n+\n+        binder.update(securityQuestion, securityQuestionTO);\n+        securityQuestion = securityQuestionDAO.save(securityQuestion);\n+\n+        return binder.getSecurityQuestionTO(securityQuestion);\n+    }\n+\n+    @PreAuthorize(\"hasRole('SECURITY_QUESTION_DELETE')\")\n+    public SecurityQuestionTO delete(final Long securityQuestionId) {\n+        SecurityQuestion securityQuestion = securityQuestionDAO.find(securityQuestionId);\n+        if (securityQuestion == null) {\n+            LOG.error(\"Could not find security question '\" + securityQuestionId + \"'\");\n+\n+            throw new NotFoundException(String.valueOf(securityQuestionId));\n+        }\n+\n+        SecurityQuestionTO deleted = binder.getSecurityQuestionTO(securityQuestion);\n+        securityQuestionDAO.delete(securityQuestionId);\n+        return deleted;\n+    }\n+\n+    @PreAuthorize(\"isAnonymous() or hasRole(T(org.apache.syncope.common.lib.SyncopeConstants).ANONYMOUS_ENTITLEMENT)\")\n+    public SecurityQuestionTO read(final String username) {\n+        if (username == null) {\n+            throw new NotFoundException(\"Null username\");\n+        }\n+        User user = userDAO.find(username);\n+        if (user == null) {\n+            throw new NotFoundException(\"User \" + username);\n+        }\n+\n+        if (user.getSecurityQuestion() == null) {\n+            LOG.error(\"Could not find security question for user '\" + username + \"'\");\n+\n+            throw new NotFoundException(\"Security question for user \" + username);\n+        }\n+\n+        return binder.getSecurityQuestionTO(user.getSecurityQuestion());\n+    }\n+\n+    @Override\n+    protected SecurityQuestionTO resolveReference(final Method method, final Object... args)\n+            throws UnresolvedReferenceException {\n+\n+        Long id = null;\n+\n+        if (ArrayUtils.isNotEmpty(args)) {\n+            for (int i = 0; id == null && i < args.length; i++) {\n+                if (args[i] instanceof Long) {\n+                    id = (Long) args[i];\n+                } else if (args[i] instanceof SecurityQuestionTO) {\n+                    id = ((SecurityQuestionTO) args[i]).getKey();\n+                }\n+            }\n+        }\n+\n+        if ((id != null) && !id.equals(0l)) {\n+            try {\n+                return binder.getSecurityQuestionTO(securityQuestionDAO.find(id));\n+            } catch (Throwable ignore) {\n+                LOG.debug(\"Unresolved reference\", ignore);\n+                throw new UnresolvedReferenceException(ignore);\n+            }\n+        }\n+\n+        throw new UnresolvedReferenceException();\n+    }\n+}"},{"sha":"11c9b4b818223af3e0fddb2077ba7f99400a4162","filename":"syncope620/server/logic/src/main/java/org/apache/syncope/server/logic/TaskLogic.java","status":"added","additions":408,"deletions":0,"changes":408,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2FTaskLogic.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2FTaskLogic.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2FTaskLogic.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,408 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.server.logic;\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Set;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.syncope.common.lib.SyncopeClientException;\n+import org.apache.syncope.common.lib.to.AbstractTaskTO;\n+import org.apache.syncope.common.lib.to.BulkAction;\n+import org.apache.syncope.common.lib.to.BulkActionResult;\n+import org.apache.syncope.common.lib.to.SchedTaskTO;\n+import org.apache.syncope.common.lib.to.SyncTaskTO;\n+import org.apache.syncope.common.lib.to.TaskExecTO;\n+import org.apache.syncope.common.lib.types.ClientExceptionType;\n+import org.apache.syncope.common.lib.types.PropagationMode;\n+import org.apache.syncope.common.lib.types.PropagationTaskExecStatus;\n+import org.apache.syncope.common.lib.types.TaskType;\n+import org.apache.syncope.persistence.api.dao.NotFoundException;\n+import org.apache.syncope.persistence.api.dao.TaskDAO;\n+import org.apache.syncope.persistence.api.dao.TaskExecDAO;\n+import org.apache.syncope.persistence.api.dao.search.OrderByClause;\n+import org.apache.syncope.persistence.api.entity.task.NotificationTask;\n+import org.apache.syncope.persistence.api.entity.task.PropagationTask;\n+import org.apache.syncope.persistence.api.entity.task.SchedTask;\n+import org.apache.syncope.persistence.api.entity.task.Task;\n+import org.apache.syncope.persistence.api.entity.task.TaskExec;\n+import org.apache.syncope.persistence.api.entity.task.TaskUtil;\n+import org.apache.syncope.persistence.api.entity.task.TaskUtilFactory;\n+import org.apache.syncope.provisioning.api.job.TaskJob;\n+import org.apache.syncope.provisioning.api.propagation.PropagationTaskExecutor;\n+import org.apache.syncope.server.logic.data.TaskDataBinder;\n+import org.apache.syncope.server.logic.init.ImplementationClassNamesLoader;\n+import org.apache.syncope.server.logic.init.JobInstanceLoader;\n+import org.apache.syncope.server.logic.notification.NotificationJob;\n+import org.quartz.JobDataMap;\n+import org.quartz.JobKey;\n+import org.quartz.Scheduler;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.scheduling.quartz.SchedulerFactoryBean;\n+import org.springframework.security.access.prepost.PreAuthorize;\n+import org.springframework.stereotype.Component;\n+\n+@Component\n+public class TaskLogic extends AbstractTransactionalLogic<AbstractTaskTO> {\n+\n+    @Autowired\n+    private TaskDAO taskDAO;\n+\n+    @Autowired\n+    private TaskExecDAO taskExecDAO;\n+\n+    @Autowired\n+    private TaskDataBinder binder;\n+\n+    @Autowired\n+    private PropagationTaskExecutor taskExecutor;\n+\n+    @Autowired\n+    private NotificationJob notificationJob;\n+\n+    @Autowired\n+    private JobInstanceLoader jobInstanceLoader;\n+\n+    @Autowired\n+    private SchedulerFactoryBean scheduler;\n+\n+    @Autowired\n+    private ImplementationClassNamesLoader classNamesLoader;\n+\n+    @Autowired\n+    private TaskUtilFactory taskUtilFactory;\n+\n+    @PreAuthorize(\"hasRole('TASK_CREATE')\")\n+    public <T extends SchedTaskTO> T createSchedTask(final T taskTO) {\n+        TaskUtil taskUtil = taskUtilFactory.getInstance(taskTO);\n+\n+        SchedTask task = binder.createSchedTask(taskTO, taskUtil);\n+        task = taskDAO.save(task);\n+\n+        try {\n+            jobInstanceLoader.registerJob(task, task.getJobClassName(), task.getCronExpression());\n+        } catch (Exception e) {\n+            LOG.error(\"While registering quartz job for task \" + task.getKey(), e);\n+\n+            SyncopeClientException sce = SyncopeClientException.build(ClientExceptionType.Scheduling);\n+            sce.getElements().add(e.getMessage());\n+            throw sce;\n+        }\n+\n+        return binder.getTaskTO(task, taskUtil);\n+    }\n+\n+    @PreAuthorize(\"hasRole('TASK_UPDATE')\")\n+    public SyncTaskTO updateSync(final SyncTaskTO taskTO) {\n+        return updateSched(taskTO);\n+    }\n+\n+    @PreAuthorize(\"hasRole('TASK_UPDATE')\")\n+    public <T extends SchedTaskTO> T updateSched(final SchedTaskTO taskTO) {\n+        SchedTask task = taskDAO.find(taskTO.getId());\n+        if (task == null) {\n+            throw new NotFoundException(\"Task \" + taskTO.getId());\n+        }\n+\n+        TaskUtil taskUtil = taskUtilFactory.getInstance(task);\n+\n+        binder.updateSchedTask(task, taskTO, taskUtil);\n+        task = taskDAO.save(task);\n+\n+        try {\n+            jobInstanceLoader.registerJob(task, task.getJobClassName(), task.getCronExpression());\n+        } catch (Exception e) {\n+            LOG.error(\"While registering quartz job for task \" + task.getKey(), e);\n+\n+            SyncopeClientException sce = SyncopeClientException.build(ClientExceptionType.Scheduling);\n+            sce.getElements().add(e.getMessage());\n+            throw sce;\n+        }\n+\n+        return binder.getTaskTO(task, taskUtil);\n+    }\n+\n+    @PreAuthorize(\"hasRole('TASK_LIST')\")\n+    public int count(final TaskType taskType) {\n+        return taskDAO.count(taskType);\n+    }\n+\n+    @PreAuthorize(\"hasRole('TASK_LIST')\")\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends AbstractTaskTO> List<T> list(final TaskType taskType,\n+            final int page, final int size, final List<OrderByClause> orderByClauses) {\n+\n+        TaskUtil taskUtil = taskUtilFactory.getInstance(taskType);\n+\n+        List<Task> tasks = taskDAO.findAll(page, size, orderByClauses, taskType);\n+        List<T> taskTOs = new ArrayList<>(tasks.size());\n+        for (Task task : tasks) {\n+            taskTOs.add((T) binder.getTaskTO(task, taskUtil));\n+        }\n+\n+        return taskTOs;\n+    }\n+\n+    @PreAuthorize(\"hasRole('TASK_LIST')\")\n+    public Set<String> getJobClasses() {\n+        return classNamesLoader.getClassNames(ImplementationClassNamesLoader.Type.TASKJOB);\n+    }\n+\n+    @PreAuthorize(\"hasRole('TASK_LIST')\")\n+    public Set<String> getSyncActionsClasses() {\n+        return classNamesLoader.getClassNames(ImplementationClassNamesLoader.Type.SYNC_ACTIONS);\n+    }\n+\n+    @PreAuthorize(\"hasRole('TASK_LIST')\")\n+    public Set<String> getPushActionsClasses() {\n+        return classNamesLoader.getClassNames(ImplementationClassNamesLoader.Type.PUSH_ACTIONS);\n+    }\n+\n+    @PreAuthorize(\"hasRole('TASK_READ')\")\n+    public <T extends AbstractTaskTO> T read(final Long taskId) {\n+        Task task = taskDAO.find(taskId);\n+        if (task == null) {\n+            throw new NotFoundException(\"Task \" + taskId);\n+        }\n+        return binder.getTaskTO(task, taskUtilFactory.getInstance(task));\n+    }\n+\n+    @PreAuthorize(\"hasRole('TASK_READ')\")\n+    public TaskExecTO readExecution(final Long executionId) {\n+        TaskExec taskExec = taskExecDAO.find(executionId);\n+        if (taskExec == null) {\n+            throw new NotFoundException(\"Task execution \" + executionId);\n+        }\n+        return binder.getTaskExecTO(taskExec);\n+    }\n+\n+    @PreAuthorize(\"hasRole('TASK_EXECUTE')\")\n+    public TaskExecTO execute(final Long taskId, final boolean dryRun) {\n+        Task task = taskDAO.find(taskId);\n+        if (task == null) {\n+            throw new NotFoundException(\"Task \" + taskId);\n+        }\n+        TaskUtil taskUtil = taskUtilFactory.getInstance(task);\n+\n+        TaskExecTO result = null;\n+        switch (taskUtil.getType()) {\n+            case PROPAGATION:\n+                final TaskExec propExec = taskExecutor.execute((PropagationTask) task);\n+                result = binder.getTaskExecTO(propExec);\n+                break;\n+\n+            case NOTIFICATION:\n+                final TaskExec notExec = notificationJob.executeSingle((NotificationTask) task);\n+                result = binder.getTaskExecTO(notExec);\n+                break;\n+\n+            case SCHEDULED:\n+            case SYNCHRONIZATION:\n+            case PUSH:\n+                try {\n+                    jobInstanceLoader.registerJob(task,\n+                            ((SchedTask) task).getJobClassName(),\n+                            ((SchedTask) task).getCronExpression());\n+\n+                    JobDataMap map = new JobDataMap();\n+                    map.put(TaskJob.DRY_RUN_JOBDETAIL_KEY, dryRun);\n+\n+                    scheduler.getScheduler().triggerJob(\n+                            new JobKey(JobInstanceLoader.getJobName(task), Scheduler.DEFAULT_GROUP), map);\n+                } catch (Exception e) {\n+                    LOG.error(\"While executing task {}\", task, e);\n+\n+                    SyncopeClientException sce = SyncopeClientException.build(ClientExceptionType.Scheduling);\n+                    sce.getElements().add(e.getMessage());\n+                    throw sce;\n+                }\n+\n+                result = new TaskExecTO();\n+                result.setTask(taskId);\n+                result.setStartDate(new Date());\n+                result.setStatus(\"JOB_FIRED\");\n+                result.setMessage(\"Job fired; waiting for results...\");\n+                break;\n+\n+            default:\n+        }\n+\n+        return result;\n+    }\n+\n+    @PreAuthorize(\"hasRole('TASK_READ')\")\n+    public TaskExecTO report(final Long executionId, final PropagationTaskExecStatus status, final String message) {\n+        TaskExec exec = taskExecDAO.find(executionId);\n+        if (exec == null) {\n+            throw new NotFoundException(\"Task execution \" + executionId);\n+        }\n+\n+        SyncopeClientException sce = SyncopeClientException.build(\n+                ClientExceptionType.InvalidPropagationTaskExecReport);\n+\n+        TaskUtil taskUtil = taskUtilFactory.getInstance(exec.getTask());\n+        if (TaskType.PROPAGATION == taskUtil.getType()) {\n+            PropagationTask task = (PropagationTask) exec.getTask();\n+            if (task.getPropagationMode() != PropagationMode.TWO_PHASES) {\n+                sce.getElements().add(\"Propagation mode: \" + task.getPropagationMode());\n+            }\n+        } else {\n+            sce.getElements().add(\"Task type: \" + taskUtil);\n+        }\n+\n+        switch (status) {\n+            case SUCCESS:\n+            case FAILURE:\n+                break;\n+\n+            case CREATED:\n+            case SUBMITTED:\n+            case UNSUBMITTED:\n+                sce.getElements().add(\"Execution status to be set: \" + status);\n+                break;\n+\n+            default:\n+        }\n+\n+        if (!sce.isEmpty()) {\n+            throw sce;\n+        }\n+\n+        exec.setStatus(status.toString());\n+        exec.setMessage(message);\n+        return binder.getTaskExecTO(taskExecDAO.save(exec));\n+    }\n+\n+    @PreAuthorize(\"hasRole('TASK_DELETE')\")\n+    public <T extends AbstractTaskTO> T delete(final Long taskId) {\n+        Task task = taskDAO.find(taskId);\n+        if (task == null) {\n+            throw new NotFoundException(\"Task \" + taskId);\n+        }\n+        TaskUtil taskUtil = taskUtilFactory.getInstance(task);\n+\n+        T taskToDelete = binder.getTaskTO(task, taskUtil);\n+\n+        if (TaskType.SCHEDULED == taskUtil.getType()\n+                || TaskType.SYNCHRONIZATION == taskUtil.getType()\n+                || TaskType.PUSH == taskUtil.getType()) {\n+            jobInstanceLoader.unregisterJob(task);\n+        }\n+\n+        taskDAO.delete(task);\n+        return taskToDelete;\n+    }\n+\n+    @PreAuthorize(\"hasRole('TASK_DELETE')\")\n+    public TaskExecTO deleteExecution(final Long executionId) {\n+        TaskExec taskExec = taskExecDAO.find(executionId);\n+        if (taskExec == null) {\n+            throw new NotFoundException(\"Task execution \" + executionId);\n+        }\n+\n+        TaskExecTO taskExecutionToDelete = binder.getTaskExecTO(taskExec);\n+        taskExecDAO.delete(taskExec);\n+        return taskExecutionToDelete;\n+    }\n+\n+    @PreAuthorize(\"(hasRole('TASK_DELETE') and #bulkAction.operation == #bulkAction.operation.DELETE) or \"\n+            + \"(hasRole('TASK_EXECUTE') and \"\n+            + \"(#bulkAction.operation == #bulkAction.operation.EXECUTE or \"\n+            + \"#bulkAction.operation == #bulkAction.operation.DRYRUN))\")\n+    public BulkActionResult bulk(final BulkAction bulkAction) {\n+        BulkActionResult res = new BulkActionResult();\n+\n+        switch (bulkAction.getOperation()) {\n+            case DELETE:\n+                for (String taskId : bulkAction.getTargets()) {\n+                    try {\n+                        res.add(delete(Long.valueOf(taskId)).getId(), BulkActionResult.Status.SUCCESS);\n+                    } catch (Exception e) {\n+                        LOG.error(\"Error performing delete for task {}\", taskId, e);\n+                        res.add(taskId, BulkActionResult.Status.FAILURE);\n+                    }\n+                }\n+                break;\n+\n+            case DRYRUN:\n+                for (String taskId : bulkAction.getTargets()) {\n+                    try {\n+                        execute(Long.valueOf(taskId), true);\n+                        res.add(taskId, BulkActionResult.Status.SUCCESS);\n+                    } catch (Exception e) {\n+                        LOG.error(\"Error performing dryrun for task {}\", taskId, e);\n+                        res.add(taskId, BulkActionResult.Status.FAILURE);\n+                    }\n+                }\n+                break;\n+\n+            case EXECUTE:\n+                for (String taskId : bulkAction.getTargets()) {\n+                    try {\n+                        execute(Long.valueOf(taskId), false);\n+                        res.add(taskId, BulkActionResult.Status.SUCCESS);\n+                    } catch (Exception e) {\n+                        LOG.error(\"Error performing execute for task {}\", taskId, e);\n+                        res.add(taskId, BulkActionResult.Status.FAILURE);\n+                    }\n+                }\n+                break;\n+\n+            default:\n+        }\n+\n+        return res;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    protected AbstractTaskTO resolveReference(final Method method, final Object... args)\n+            throws UnresolvedReferenceException {\n+\n+        Long id = null;\n+\n+        if (ArrayUtils.isNotEmpty(args)\n+                && !\"deleteExecution\".equals(method.getName()) && !\"readExecution\".equals(method.getName())) {\n+\n+            for (int i = 0; id == null && i < args.length; i++) {\n+                if (args[i] instanceof Long) {\n+                    id = (Long) args[i];\n+                } else if (args[i] instanceof AbstractTaskTO) {\n+                    id = ((AbstractTaskTO) args[i]).getId();\n+                }\n+            }\n+        }\n+\n+        if ((id != null) && !id.equals(0l)) {\n+            try {\n+                final Task task = taskDAO.find(id);\n+                return binder.getTaskTO(task, taskUtilFactory.getInstance(task));\n+            } catch (Throwable ignore) {\n+                LOG.debug(\"Unresolved reference\", ignore);\n+                throw new UnresolvedReferenceException(ignore);\n+            }\n+        }\n+\n+        throw new UnresolvedReferenceException();\n+    }\n+}"},{"sha":"aff28d9d9276f413f6e0998b768abc6d726e44e8","filename":"syncope620/server/logic/src/main/java/org/apache/syncope/server/logic/UnresolvedReferenceException.java","status":"added","additions":35,"deletions":0,"changes":35,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2FUnresolvedReferenceException.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2FUnresolvedReferenceException.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2FUnresolvedReferenceException.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,35 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.server.logic;\n+\n+/**\n+ * Indicates unresolved bean reference.\n+ */\n+public class UnresolvedReferenceException extends Exception {\n+\n+    private static final long serialVersionUID = -675489116009955632L;\n+\n+    public UnresolvedReferenceException() {\n+        super();\n+    }\n+\n+    public UnresolvedReferenceException(final Throwable cause) {\n+        super(cause);\n+    }\n+}"},{"sha":"870a0758a6818560704dd3472d57d1d4bfdc19e7","filename":"syncope620/server/logic/src/main/java/org/apache/syncope/server/logic/UserLogic.java","status":"added","additions":534,"deletions":0,"changes":534,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2FUserLogic.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2FUserLogic.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2FUserLogic.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,534 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.server.logic;\n+\n+import org.apache.syncope.server.security.UnauthorizedRoleException;\n+import java.lang.reflect.Method;\n+import java.security.AccessControlException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.syncope.common.lib.SyncopeClientException;\n+import org.apache.syncope.common.lib.mod.AttrMod;\n+import org.apache.syncope.common.lib.mod.StatusMod;\n+import org.apache.syncope.common.lib.mod.UserMod;\n+import org.apache.syncope.common.lib.to.BulkAction;\n+import org.apache.syncope.common.lib.to.BulkActionResult;\n+import org.apache.syncope.common.lib.to.BulkActionResult.Status;\n+import org.apache.syncope.common.lib.to.MembershipTO;\n+import org.apache.syncope.common.lib.to.PropagationStatus;\n+import org.apache.syncope.common.lib.to.UserTO;\n+import org.apache.syncope.common.lib.types.ClientExceptionType;\n+import org.apache.syncope.common.lib.types.SubjectType;\n+import org.apache.syncope.persistence.api.RoleEntitlementUtil;\n+import org.apache.syncope.persistence.api.dao.ConfDAO;\n+import org.apache.syncope.persistence.api.dao.NotFoundException;\n+import org.apache.syncope.persistence.api.dao.RoleDAO;\n+import org.apache.syncope.persistence.api.dao.SubjectSearchDAO;\n+import org.apache.syncope.persistence.api.dao.UserDAO;\n+import org.apache.syncope.persistence.api.dao.search.OrderByClause;\n+import org.apache.syncope.persistence.api.dao.search.SearchCond;\n+import org.apache.syncope.persistence.api.entity.role.Role;\n+import org.apache.syncope.persistence.api.entity.user.User;\n+import org.apache.syncope.provisioning.api.AttributableTransformer;\n+import org.apache.syncope.provisioning.api.UserProvisioningManager;\n+import org.apache.syncope.provisioning.api.propagation.PropagationManager;\n+import org.apache.syncope.provisioning.api.propagation.PropagationTaskExecutor;\n+import org.apache.syncope.server.logic.data.UserDataBinder;\n+import org.apache.syncope.server.security.AuthContextUtil;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.access.prepost.PreAuthorize;\n+import org.springframework.stereotype.Component;\n+import org.springframework.transaction.annotation.Transactional;\n+import org.springframework.transaction.interceptor.TransactionInterceptor;\n+\n+/**\n+ * Note that this controller does not extend {@link AbstractTransactionalLogic}, hence does not provide any\n+ * Spring's Transactional logic at class level.\n+ */\n+@Component\n+public class UserLogic extends AbstractSubjectLogic<UserTO, UserMod> {\n+\n+    @Autowired\n+    protected UserDAO userDAO;\n+\n+    @Autowired\n+    protected RoleDAO roleDAO;\n+\n+    @Autowired\n+    protected SubjectSearchDAO searchDAO;\n+\n+    @Autowired\n+    protected ConfDAO confDAO;\n+\n+    @Autowired\n+    protected UserDataBinder binder;\n+\n+    @Autowired\n+    protected PropagationManager propagationManager;\n+\n+    @Autowired\n+    protected PropagationTaskExecutor taskExecutor;\n+\n+    @Autowired\n+    protected AttributableTransformer attrTransformer;\n+\n+    @Autowired\n+    protected UserProvisioningManager provisioningManager;\n+\n+    @Transactional(readOnly = true)\n+    public boolean isSelfRegAllowed() {\n+        return confDAO.find(\"selfRegistration.allowed\", \"false\").getValues().get(0).getBooleanValue();\n+    }\n+\n+    @Transactional(readOnly = true)\n+    public boolean isPwdResetAllowed() {\n+        return confDAO.find(\"passwordReset.allowed\", \"false\").getValues().get(0).getBooleanValue();\n+    }\n+\n+    @Transactional(readOnly = true)\n+    public boolean isPwdResetRequiringSecurityQuestions() {\n+        return confDAO.find(\"passwordReset.securityQuestion\", \"true\").getValues().get(0).getBooleanValue();\n+    }\n+\n+    @PreAuthorize(\"hasRole('USER_READ')\")\n+    public String getUsername(final Long key) {\n+        return binder.getUserTO(key).getUsername();\n+    }\n+\n+    @PreAuthorize(\"hasRole('USER_READ')\")\n+    public Long getKey(final String username) {\n+        return binder.getUserTO(username).getKey();\n+    }\n+\n+    @PreAuthorize(\"hasRole('USER_LIST')\")\n+    @Transactional(readOnly = true, rollbackFor = { Throwable.class })\n+    @Override\n+    public int count() {\n+        return userDAO.count(RoleEntitlementUtil.getRoleKeys(AuthContextUtil.getOwnedEntitlementNames()));\n+    }\n+\n+    @PreAuthorize(\"hasRole('USER_LIST')\")\n+    @Transactional(readOnly = true, rollbackFor = { Throwable.class })\n+    @Override\n+    public int searchCount(final SearchCond searchCondition) {\n+        return searchDAO.count(RoleEntitlementUtil.getRoleKeys(AuthContextUtil.getOwnedEntitlementNames()),\n+                searchCondition, SubjectType.USER);\n+    }\n+\n+    @PreAuthorize(\"hasRole('USER_LIST')\")\n+    @Transactional(readOnly = true, rollbackFor = { Throwable.class })\n+    @Override\n+    public List<UserTO> list(final int page, final int size, final List<OrderByClause> orderBy) {\n+        Set<Long> adminRoleIds = RoleEntitlementUtil.getRoleKeys(AuthContextUtil.getOwnedEntitlementNames());\n+\n+        List<User> users = userDAO.findAll(adminRoleIds, page, size, orderBy);\n+        List<UserTO> userTOs = new ArrayList<UserTO>(users.size());\n+        for (User user : users) {\n+            userTOs.add(binder.getUserTO(user));\n+        }\n+\n+        return userTOs;\n+    }\n+\n+    @PreAuthorize(\"isAuthenticated() \"\n+            + \"and not(hasRole(T(org.apache.syncope.common.lib.SyncopeConstants).ANONYMOUS_ENTITLEMENT))\")\n+    @Transactional(readOnly = true)\n+    public UserTO readSelf() {\n+        return binder.getAuthenticatedUserTO();\n+    }\n+\n+    @PreAuthorize(\"hasRole('USER_READ')\")\n+    @Transactional(readOnly = true)\n+    @Override\n+    public UserTO read(final Long key) {\n+        return binder.getUserTO(key);\n+    }\n+\n+    @PreAuthorize(\"hasRole('USER_LIST')\")\n+    @Transactional(readOnly = true)\n+    @Override\n+    public List<UserTO> search(final SearchCond searchCondition, final int page, final int size,\n+            final List<OrderByClause> orderBy) {\n+\n+        final List<User> matchingUsers = searchDAO.search(\n+                RoleEntitlementUtil.getRoleKeys(AuthContextUtil.getOwnedEntitlementNames()),\n+                searchCondition, page, size, orderBy, SubjectType.USER);\n+\n+        final List<UserTO> result = new ArrayList<>(matchingUsers.size());\n+        for (User user : matchingUsers) {\n+            result.add(binder.getUserTO(user));\n+        }\n+\n+        return result;\n+    }\n+\n+    @PreAuthorize(\"isAnonymous() or hasRole(T(org.apache.syncope.common.lib.SyncopeConstants).ANONYMOUS_ENTITLEMENT)\")\n+    public UserTO createSelf(final UserTO userTO, final boolean storePassword) {\n+        return doCreate(userTO, storePassword);\n+    }\n+\n+    @PreAuthorize(\"hasRole('USER_CREATE')\")\n+    public UserTO create(final UserTO userTO, final boolean storePassword) {\n+        Set<Long> requestRoleIds = new HashSet<Long>(userTO.getMemberships().size());\n+        for (MembershipTO membership : userTO.getMemberships()) {\n+            requestRoleIds.add(membership.getRoleId());\n+        }\n+        Set<Long> adminRoleIds = RoleEntitlementUtil.getRoleKeys(AuthContextUtil.getOwnedEntitlementNames());\n+        requestRoleIds.removeAll(adminRoleIds);\n+        if (!requestRoleIds.isEmpty()) {\n+            throw new UnauthorizedRoleException(requestRoleIds);\n+        }\n+\n+        return doCreate(userTO, storePassword);\n+    }\n+\n+    protected UserTO doCreate(final UserTO userTO, final boolean storePassword) {\n+        // Attributable transformation (if configured)\n+        UserTO actual = attrTransformer.transform(userTO);\n+        LOG.debug(\"Transformed: {}\", actual);\n+\n+        Map.Entry<Long, List<PropagationStatus>> created = provisioningManager.create(actual, storePassword);\n+\n+        final UserTO savedTO = binder.getUserTO(created.getKey());\n+        savedTO.getPropagationStatusTOs().addAll(created.getValue());\n+        return savedTO;\n+    }\n+\n+    @PreAuthorize(\"isAuthenticated() \"\n+            + \"and not(hasRole(T(org.apache.syncope.common.lib.SyncopeConstants).ANONYMOUS_ENTITLEMENT))\")\n+    public UserTO updateSelf(final UserMod userMod) {\n+        UserTO userTO = binder.getAuthenticatedUserTO();\n+\n+        if (userTO.getKey() != userMod.getKey()) {\n+            throw new AccessControlException(\"Not allowed for user with key \" + userMod.getKey());\n+        }\n+\n+        return update(userMod);\n+    }\n+\n+    @PreAuthorize(\"hasRole('USER_UPDATE')\")\n+    @Override\n+    public UserTO update(final UserMod userMod) {\n+        // AttributableMod transformation (if configured)\n+        UserMod actual = attrTransformer.transform(userMod);\n+        LOG.debug(\"Transformed: {}\", actual);\n+\n+        // SYNCOPE-501: check if there are memberships to be removed with virtual attributes assigned\n+        boolean removeMemberships = false;\n+        for (Long membershipId : actual.getMembershipsToRemove()) {\n+            if (!binder.fillMembershipVirtual(\n+                    null,\n+                    null,\n+                    membershipId,\n+                    Collections.<String>emptySet(),\n+                    Collections.<AttrMod>emptySet(),\n+                    true).isEmpty()) {\n+\n+                removeMemberships = true;\n+            }\n+        }\n+\n+        Map.Entry<Long, List<PropagationStatus>> updated = provisioningManager.update(actual, removeMemberships);\n+\n+        final UserTO updatedTO = binder.getUserTO(updated.getKey());\n+        updatedTO.getPropagationStatusTOs().addAll(updated.getValue());\n+        return updatedTO;\n+    }\n+\n+    protected Map.Entry<Long, List<PropagationStatus>> setStatusOnWfAdapter(final User user,\n+            final StatusMod statusMod) {\n+        Map.Entry<Long, List<PropagationStatus>> updated;\n+\n+        switch (statusMod.getType()) {\n+            case SUSPEND:\n+                updated = provisioningManager.suspend(user, statusMod);\n+                break;\n+\n+            case REACTIVATE:\n+                updated = provisioningManager.reactivate(user, statusMod);\n+                break;\n+\n+            case ACTIVATE:\n+            default:\n+                updated = provisioningManager.activate(user, statusMod);\n+                break;\n+\n+        }\n+\n+        return updated;\n+    }\n+\n+    @PreAuthorize(\"hasRole('USER_UPDATE')\")\n+    @Transactional(rollbackFor = { Throwable.class })\n+    public UserTO status(final StatusMod statusMod) {\n+        User user = userDAO.authFecthUser(statusMod.getId());\n+\n+        Map.Entry<Long, List<PropagationStatus>> updated = setStatusOnWfAdapter(user, statusMod);\n+        final UserTO savedTO = binder.getUserTO(updated.getKey());\n+        savedTO.getPropagationStatusTOs().addAll(updated.getValue());\n+        return savedTO;\n+    }\n+\n+    @PreAuthorize(\"isAnonymous() or hasRole(T(org.apache.syncope.common.lib.SyncopeConstants).ANONYMOUS_ENTITLEMENT)\")\n+    @Transactional\n+    public void requestPasswordReset(final String username, final String securityAnswer) {\n+        if (username == null) {\n+            throw new NotFoundException(\"Null username\");\n+        }\n+\n+        User user = userDAO.find(username);\n+        if (user == null) {\n+            throw new NotFoundException(\"User \" + username);\n+        }\n+\n+        if (isPwdResetRequiringSecurityQuestions()\n+                && (securityAnswer == null || !securityAnswer.equals(user.getSecurityAnswer()))) {\n+\n+            throw SyncopeClientException.build(ClientExceptionType.InvalidSecurityAnswer);\n+        }\n+\n+        provisioningManager.requestPasswordReset(user.getKey());\n+    }\n+\n+    @PreAuthorize(\"isAnonymous() or hasRole(T(org.apache.syncope.common.lib.SyncopeConstants).ANONYMOUS_ENTITLEMENT)\")\n+    @Transactional\n+    public void confirmPasswordReset(final String token, final String password) {\n+        User user = userDAO.findByToken(token);\n+        if (user == null) {\n+            throw new NotFoundException(\"User with token \" + token);\n+        }\n+        provisioningManager.confirmPasswordReset(user, token, password);\n+    }\n+\n+    @PreAuthorize(\"isAuthenticated() \"\n+            + \"and not(hasRole(T(org.apache.syncope.common.lib.SyncopeConstants).ANONYMOUS_ENTITLEMENT))\")\n+    public UserTO deleteSelf() {\n+        UserTO userTO = binder.getAuthenticatedUserTO();\n+\n+        return delete(userTO.getKey());\n+    }\n+\n+    @PreAuthorize(\"hasRole('USER_DELETE')\")\n+    @Override\n+    public UserTO delete(final Long key) {\n+        List<Role> ownedRoles = roleDAO.findOwnedByUser(key);\n+        if (!ownedRoles.isEmpty()) {\n+            List<String> owned = new ArrayList<String>(ownedRoles.size());\n+            for (Role role : ownedRoles) {\n+                owned.add(role.getKey() + \" \" + role.getName());\n+            }\n+\n+            SyncopeClientException sce = SyncopeClientException.build(ClientExceptionType.RoleOwnership);\n+            sce.getElements().addAll(owned);\n+            throw sce;\n+        }\n+\n+        List<PropagationStatus> statuses = provisioningManager.delete(key);\n+\n+        final UserTO deletedTO;\n+        User deleted = userDAO.find(key);\n+        if (deleted == null) {\n+            deletedTO = new UserTO();\n+            deletedTO.setKey(key);\n+        } else {\n+            deletedTO = binder.getUserTO(key);\n+        }\n+        deletedTO.getPropagationStatusTOs().addAll(statuses);\n+\n+        return deletedTO;\n+    }\n+\n+    @PreAuthorize(\"(hasRole('USER_DELETE') and #bulkAction.operation == #bulkAction.operation.DELETE) or \"\n+            + \"(hasRole('USER_UPDATE') and \"\n+            + \"(#bulkAction.operation == #bulkAction.operation.REACTIVATE or \"\n+            + \"#bulkAction.operation == #bulkAction.operation.SUSPEND))\")\n+    public BulkActionResult bulk(final BulkAction bulkAction) {\n+        BulkActionResult res = new BulkActionResult();\n+\n+        switch (bulkAction.getOperation()) {\n+            case DELETE:\n+                for (String key : bulkAction.getTargets()) {\n+                    try {\n+                        res.add(delete(Long.valueOf(key)).getKey(), Status.SUCCESS);\n+                    } catch (Exception e) {\n+                        LOG.error(\"Error performing delete for user {}\", key, e);\n+                        res.add(key, Status.FAILURE);\n+                    }\n+                }\n+                break;\n+\n+            case SUSPEND:\n+                for (String key : bulkAction.getTargets()) {\n+                    StatusMod statusMod = new StatusMod();\n+                    statusMod.setId(Long.valueOf(key));\n+                    statusMod.setType(StatusMod.ModType.SUSPEND);\n+                    try {\n+                        res.add(status(statusMod).getKey(), Status.SUCCESS);\n+                    } catch (Exception e) {\n+                        LOG.error(\"Error performing suspend for user {}\", key, e);\n+                        res.add(key, Status.FAILURE);\n+                    }\n+                }\n+                break;\n+\n+            case REACTIVATE:\n+                for (String key : bulkAction.getTargets()) {\n+                    StatusMod statusMod = new StatusMod();\n+                    statusMod.setId(Long.valueOf(key));\n+                    statusMod.setType(StatusMod.ModType.REACTIVATE);\n+                    try {\n+                        res.add(status(statusMod).getKey(), Status.SUCCESS);\n+                    } catch (Exception e) {\n+                        LOG.error(\"Error performing reactivate for user {}\", key, e);\n+                        res.add(key, Status.FAILURE);\n+                    }\n+                }\n+                break;\n+\n+            default:\n+        }\n+\n+        return res;\n+    }\n+\n+    @PreAuthorize(\"hasRole('USER_UPDATE')\")\n+    @Transactional(rollbackFor = { Throwable.class })\n+    @Override\n+    public UserTO unlink(final Long key, final Collection<String> resources) {\n+        final UserMod userMod = new UserMod();\n+        userMod.setKey(key);\n+        userMod.getResourcesToRemove().addAll(resources);\n+        Long updatedId = provisioningManager.unlink(userMod);\n+\n+        return binder.getUserTO(updatedId);\n+    }\n+\n+    @PreAuthorize(\"hasRole('USER_UPDATE')\")\n+    @Transactional(rollbackFor = { Throwable.class })\n+    @Override\n+    public UserTO link(final Long key, final Collection<String> resources) {\n+        final UserMod userMod = new UserMod();\n+        userMod.setKey(key);\n+        userMod.getResourcesToAdd().addAll(resources);\n+        return binder.getUserTO(provisioningManager.link(userMod));\n+    }\n+\n+    @PreAuthorize(\"hasRole('USER_UPDATE')\")\n+    @Transactional(rollbackFor = { Throwable.class })\n+    @Override\n+    public UserTO unassign(final Long key, final Collection<String> resources) {\n+        final UserMod userMod = new UserMod();\n+        userMod.setKey(key);\n+        userMod.getResourcesToRemove().addAll(resources);\n+        return update(userMod);\n+    }\n+\n+    @PreAuthorize(\"hasRole('USER_UPDATE')\")\n+    @Transactional(rollbackFor = { Throwable.class })\n+    @Override\n+    public UserTO assign(\n+            final Long key,\n+            final Collection<String> resources,\n+            final boolean changepwd,\n+            final String password) {\n+\n+        final UserMod userMod = new UserMod();\n+        userMod.setKey(key);\n+        userMod.getResourcesToAdd().addAll(resources);\n+\n+        if (changepwd) {\n+            StatusMod statusMod = new StatusMod();\n+            statusMod.setOnSyncope(false);\n+            statusMod.getResourceNames().addAll(resources);\n+            userMod.setPwdPropRequest(statusMod);\n+            userMod.setPassword(password);\n+        }\n+\n+        return update(userMod);\n+    }\n+\n+    @PreAuthorize(\"hasRole('USER_UPDATE')\")\n+    @Transactional(rollbackFor = { Throwable.class })\n+    @Override\n+    public UserTO deprovision(final Long key, final Collection<String> resources) {\n+        final User user = userDAO.authFecthUser(key);\n+\n+        List<PropagationStatus> statuses = provisioningManager.deprovision(key, resources);\n+\n+        final UserTO updatedUserTO = binder.getUserTO(user);\n+        updatedUserTO.getPropagationStatusTOs().addAll(statuses);\n+        return updatedUserTO;\n+    }\n+\n+    @PreAuthorize(\"hasRole('USER_UPDATE')\")\n+    @Transactional(readOnly = true)\n+    @Override\n+    public UserTO provision(\n+            final Long key,\n+            final Collection<String> resources,\n+            final boolean changePwd,\n+            final String password) {\n+\n+        final UserTO original = binder.getUserTO(key);\n+\n+        //trick: assign and retrieve propagation statuses ...\n+        original.getPropagationStatusTOs().addAll(\n+                assign(key, resources, changePwd, password).getPropagationStatusTOs());\n+\n+        // .... rollback.\n+        TransactionInterceptor.currentTransactionStatus().setRollbackOnly();\n+        return original;\n+    }\n+\n+    @Override\n+    protected UserTO resolveReference(final Method method, final Object... args) throws UnresolvedReferenceException {\n+        Object id = null;\n+\n+        if (!\"confirmPasswordReset\".equals(method.getName()) && ArrayUtils.isNotEmpty(args)) {\n+            for (int i = 0; id == null && i < args.length; i++) {\n+                if (args[i] instanceof Long) {\n+                    id = (Long) args[i];\n+                } else if (args[i] instanceof String) {\n+                    id = (String) args[i];\n+                } else if (args[i] instanceof UserTO) {\n+                    id = ((UserTO) args[i]).getKey();\n+                } else if (args[i] instanceof UserMod) {\n+                    id = ((UserMod) args[i]).getKey();\n+                }\n+            }\n+        }\n+\n+        if ((id != null) && !id.equals(0l)) {\n+            try {\n+                return id instanceof Long ? binder.getUserTO((Long) id) : binder.getUserTO((String) id);\n+            } catch (Throwable ignore) {\n+                LOG.debug(\"Unresolved reference\", ignore);\n+                throw new UnresolvedReferenceException(ignore);\n+            }\n+        }\n+\n+        throw new UnresolvedReferenceException();\n+    }\n+}"},{"sha":"08b5e71e9a100403bb8ebc0a5048592ea75d96ee","filename":"syncope620/server/logic/src/main/java/org/apache/syncope/server/logic/UserWorkflowLogic.java","status":"added","additions":131,"deletions":0,"changes":131,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2FUserWorkflowLogic.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2FUserWorkflowLogic.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2FUserWorkflowLogic.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,131 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.server.logic;\n+\n+import java.lang.reflect.Method;\n+import java.util.AbstractMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.syncope.common.lib.mod.AbstractAttributableMod;\n+import org.apache.syncope.common.lib.mod.UserMod;\n+import org.apache.syncope.common.lib.to.UserTO;\n+import org.apache.syncope.common.lib.to.WorkflowFormTO;\n+import org.apache.syncope.persistence.api.dao.UserDAO;\n+import org.apache.syncope.persistence.api.entity.task.PropagationTask;\n+import org.apache.syncope.persistence.api.entity.user.User;\n+import org.apache.syncope.provisioning.api.propagation.PropagationManager;\n+import org.apache.syncope.provisioning.api.propagation.PropagationTaskExecutor;\n+import org.apache.syncope.server.logic.data.UserDataBinder;\n+import org.apache.syncope.server.workflow.api.UserWorkflowAdapter;\n+import org.apache.syncope.provisioning.api.WorkflowResult;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.access.prepost.PreAuthorize;\n+import org.springframework.stereotype.Component;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+@Component\n+public class UserWorkflowLogic extends AbstractTransactionalLogic<WorkflowFormTO> {\n+\n+    @Autowired\n+    private UserWorkflowAdapter uwfAdapter;\n+\n+    @Autowired\n+    private PropagationManager propagationManager;\n+\n+    @Autowired\n+    private PropagationTaskExecutor taskExecutor;\n+\n+    @Autowired\n+    private UserDataBinder binder;\n+\n+    @Autowired\n+    private UserDAO userDAO;\n+\n+    @PreAuthorize(\"hasRole('WORKFLOW_FORM_CLAIM')\")\n+    @Transactional(rollbackFor = { Throwable.class })\n+    public WorkflowFormTO claimForm(final String taskId) {\n+        return uwfAdapter.claimForm(taskId);\n+    }\n+\n+    @PreAuthorize(\"hasRole('USER_UPDATE')\")\n+    public UserTO executeWorkflowTask(final UserTO userTO, final String taskId) {\n+        WorkflowResult<Long> updated = uwfAdapter.execute(userTO, taskId);\n+\n+        UserMod userMod = new UserMod();\n+        userMod.setKey(userTO.getKey());\n+\n+        List<PropagationTask> tasks = propagationManager.getUserUpdateTaskIds(\n+                new WorkflowResult<Map.Entry<UserMod, Boolean>>(\n+                        new AbstractMap.SimpleEntry<UserMod, Boolean>(userMod, null),\n+                        updated.getPropByRes(), updated.getPerformedTasks()));\n+\n+        taskExecutor.execute(tasks);\n+\n+        return binder.getUserTO(updated.getResult());\n+    }\n+\n+    @PreAuthorize(\"hasRole('WORKFLOW_FORM_READ') and hasRole('USER_READ')\")\n+    @Transactional(rollbackFor = { Throwable.class })\n+    public WorkflowFormTO getFormForUser(final Long key) {\n+        User user = userDAO.authFecthUser(key);\n+        return uwfAdapter.getForm(user.getWorkflowId());\n+    }\n+\n+    @PreAuthorize(\"hasRole('WORKFLOW_FORM_LIST')\")\n+    @Transactional(rollbackFor = { Throwable.class })\n+    public List<WorkflowFormTO> getForms() {\n+        return uwfAdapter.getForms();\n+    }\n+\n+    @PreAuthorize(\"hasRole('WORKFLOW_FORM_READ') and hasRole('USER_READ')\")\n+    @Transactional(rollbackFor = { Throwable.class })\n+    public List<WorkflowFormTO> getForms(final Long key, final String formName) {\n+        User user = userDAO.authFecthUser(key);\n+        return uwfAdapter.getForms(user.getWorkflowId(), formName);\n+    }\n+\n+    @PreAuthorize(\"hasRole('WORKFLOW_FORM_SUBMIT')\")\n+    @Transactional(rollbackFor = { Throwable.class })\n+    public UserTO submitForm(final WorkflowFormTO form) {\n+        WorkflowResult<? extends AbstractAttributableMod> updated = uwfAdapter.submitForm(form);\n+\n+        // propByRes can be made empty by the workflow definition if no propagation should occur \n+        // (for example, with rejected users)\n+        if (updated.getResult() instanceof UserMod\n+                && updated.getPropByRes() != null && !updated.getPropByRes().isEmpty()) {\n+\n+            List<PropagationTask> tasks = propagationManager.getUserUpdateTaskIds(\n+                    new WorkflowResult<Map.Entry<UserMod, Boolean>>(\n+                            new AbstractMap.SimpleEntry<UserMod, Boolean>((UserMod) updated.getResult(), Boolean.TRUE),\n+                            updated.getPropByRes(),\n+                            updated.getPerformedTasks()));\n+\n+            taskExecutor.execute(tasks);\n+        }\n+\n+        return binder.getUserTO(updated.getResult().getKey());\n+    }\n+\n+    @Override\n+    protected WorkflowFormTO resolveReference(final Method method, final Object... args)\n+            throws UnresolvedReferenceException {\n+\n+        throw new UnresolvedReferenceException();\n+    }\n+}"},{"sha":"2e5ae74762dc97af7055ba7c4f851f25f2e1b975","filename":"syncope620/server/logic/src/main/java/org/apache/syncope/server/logic/WorkflowLogic.java","status":"added","additions":115,"deletions":0,"changes":115,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2FWorkflowLogic.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2FWorkflowLogic.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2FWorkflowLogic.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,115 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.server.logic;\n+\n+import java.io.OutputStream;\n+import java.lang.reflect.Method;\n+import javax.ws.rs.core.MediaType;\n+import org.apache.syncope.common.lib.AbstractBaseBean;\n+import org.apache.syncope.server.workflow.api.RoleWorkflowAdapter;\n+import org.apache.syncope.server.workflow.api.UserWorkflowAdapter;\n+import org.apache.syncope.server.workflow.api.WorkflowAdapter;\n+import org.apache.syncope.server.workflow.api.WorkflowDefinitionFormat;\n+import org.apache.syncope.server.workflow.api.WorkflowException;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.access.prepost.PreAuthorize;\n+import org.springframework.stereotype.Component;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+@Component\n+public class WorkflowLogic extends AbstractTransactionalLogic<AbstractBaseBean> {\n+\n+    @Autowired\n+    private UserWorkflowAdapter uwfAdapter;\n+\n+    @Autowired\n+    private RoleWorkflowAdapter rwfAdapter;\n+\n+    private void exportDefinition(\n+            final WorkflowAdapter adapter, final WorkflowDefinitionFormat format, final OutputStream os)\n+            throws WorkflowException {\n+\n+        adapter.exportDefinition(format, os);\n+    }\n+\n+    private WorkflowDefinitionFormat getFormat(final MediaType format) {\n+        return format.equals(MediaType.APPLICATION_JSON_TYPE)\n+                ? WorkflowDefinitionFormat.JSON\n+                : WorkflowDefinitionFormat.XML;\n+    }\n+\n+    @PreAuthorize(\"hasRole('WORKFLOW_DEF_READ')\")\n+    @Transactional(readOnly = true)\n+    public void exportUserDefinition(final MediaType format, final OutputStream os)\n+            throws WorkflowException {\n+\n+        exportDefinition(uwfAdapter, getFormat(format), os);\n+    }\n+\n+    @PreAuthorize(\"hasRole('WORKFLOW_DEF_READ')\")\n+    @Transactional(readOnly = true)\n+    public void exportRoleDefinition(final MediaType format, final OutputStream os)\n+            throws WorkflowException {\n+\n+        exportDefinition(rwfAdapter, getFormat(format), os);\n+    }\n+\n+    private void exportDiagram(final WorkflowAdapter adapter, final OutputStream os)\n+            throws WorkflowException {\n+        adapter.exportDiagram(os);\n+    }\n+\n+    @PreAuthorize(\"hasRole('WORKFLOW_DEF_READ')\")\n+    @Transactional(readOnly = true)\n+    public void exportUserDiagram(final OutputStream os)\n+            throws WorkflowException {\n+\n+        exportDiagram(uwfAdapter, os);\n+    }\n+\n+    @PreAuthorize(\"hasRole('WORKFLOW_DEF_READ')\")\n+    @Transactional(readOnly = true)\n+    public void exportRoleDiagram(final OutputStream os)\n+            throws WorkflowException {\n+\n+        exportDiagram(rwfAdapter, os);\n+    }\n+\n+    private void importDefinition(\n+            final WorkflowAdapter adapter, final WorkflowDefinitionFormat format, final String definition) {\n+        adapter.importDefinition(format, definition);\n+    }\n+\n+    @PreAuthorize(\"hasRole('WORKFLOW_DEF_UPDATE')\")\n+    public void importUserDefinition(final MediaType format, final String definition) {\n+        importDefinition(uwfAdapter, getFormat(format), definition);\n+    }\n+\n+    @PreAuthorize(\"hasRole('WORKFLOW_DEF_UPDATE')\")\n+    public void importRoleDefinition(final MediaType format, final String definition) {\n+        importDefinition(rwfAdapter, getFormat(format), definition);\n+    }\n+\n+    @Override\n+    protected AbstractBaseBean resolveReference(final Method method, final Object... args)\n+            throws UnresolvedReferenceException {\n+\n+        throw new UnresolvedReferenceException();\n+    }\n+}"},{"sha":"dae9fbfcd9513ca1fb042345d8fcbbc7ad2d800f","filename":"syncope620/server/logic/src/main/java/org/apache/syncope/server/logic/audit/AuditConnectionFactory.java","status":"added","additions":159,"deletions":0,"changes":159,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Faudit%2FAuditConnectionFactory.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Faudit%2FAuditConnectionFactory.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Faudit%2FAuditConnectionFactory.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,159 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.server.logic.audit;\n+\n+import java.io.InputStream;\n+import java.sql.Connection;\n+import java.util.Properties;\n+import javax.naming.Context;\n+import javax.naming.InitialContext;\n+import javax.rmi.PortableRemoteObject;\n+import javax.sql.DataSource;\n+import javax.xml.xpath.XPath;\n+import javax.xml.xpath.XPathConstants;\n+import javax.xml.xpath.XPathExpression;\n+import javax.xml.xpath.XPathFactory;\n+import org.apache.commons.dbcp2.BasicDataSource;\n+import org.apache.commons.io.IOUtils;\n+import org.springframework.core.io.ClassPathResource;\n+import org.springframework.core.io.FileSystemResource;\n+import org.springframework.core.io.Resource;\n+import org.springframework.core.io.support.PropertiesLoaderUtils;\n+import org.springframework.jdbc.datasource.DataSourceUtils;\n+import org.springframework.jdbc.datasource.init.ResourceDatabasePopulator;\n+import org.springframework.jdbc.datasource.init.ScriptUtils;\n+import org.w3c.dom.Document;\n+import org.w3c.dom.bootstrap.DOMImplementationRegistry;\n+import org.w3c.dom.ls.DOMImplementationLS;\n+import org.w3c.dom.ls.LSInput;\n+import org.w3c.dom.ls.LSParser;\n+\n+/**\n+ * LOG4J SQL connection factory that first attempts to obtain a {@link javax.sql.DataSource} from the JNDI name\n+ * configured in Spring or, when not found, builds a new {@link javax.sql.DataSource DataSource} via Commons DBCP; if\n+ * any datasource if found, the SQL init script is used to populate the database.\n+ */\n+public final class AuditConnectionFactory {\n+\n+    private static DataSource datasource;\n+\n+    private static final String PERSISTENCE_CONTEXT = \"/persistenceContext.xml\";\n+\n+    static {\n+        // 1. Attempts to lookup for configured JNDI datasource (if present and available)\n+        InputStream springConf = AuditConnectionFactory.class.getResourceAsStream(PERSISTENCE_CONTEXT);\n+        String primary = null;\n+        String fallback = null;\n+        try {\n+            DOMImplementationRegistry reg = DOMImplementationRegistry.newInstance();\n+            DOMImplementationLS impl = (DOMImplementationLS) reg.getDOMImplementation(\"LS\");\n+            LSParser parser = impl.createLSParser(DOMImplementationLS.MODE_SYNCHRONOUS, null);\n+            LSInput lsinput = impl.createLSInput();\n+            lsinput.setByteStream(springConf);\n+            Document source = parser.parse(lsinput);\n+\n+            XPathFactory xPathfactory = XPathFactory.newInstance();\n+            XPath xpath = xPathfactory.newXPath();\n+\n+            XPathExpression expr = xpath.compile(\"//*[local-name()='bean' and @id='persistenceProperties']/\"\n+                    + \"child::*[local-name()='property' and @name='primary']/@value\");\n+            primary = (String) expr.evaluate(source, XPathConstants.STRING);\n+            expr = xpath.compile(\"//*[local-name()='bean' and @id='persistenceProperties']/\"\n+                    + \"child::*[local-name()='property' and @name='fallback']/@value\");\n+            fallback = (String) expr.evaluate(source, XPathConstants.STRING);\n+\n+            expr = xpath.compile(\"//*[local-name()='property' and @name='jndiName']/@value\");\n+            String jndiName = (String) expr.evaluate(source, XPathConstants.STRING);\n+\n+            Context ctx = new InitialContext();\n+            Object obj = ctx.lookup(jndiName);\n+\n+            datasource = (DataSource) PortableRemoteObject.narrow(obj, DataSource.class);\n+        } catch (Exception e) {\n+            // ignore\n+        } finally {\n+            IOUtils.closeQuietly(springConf);\n+        }\n+\n+        // 2. Creates Commons DBCP datasource\n+        String initSQLScript = null;\n+        try {\n+            Resource persistenceProperties = null;\n+            if (primary != null) {\n+                if (primary.startsWith(\"file:\")) {\n+                    persistenceProperties = new FileSystemResource(primary.substring(5));\n+                }\n+                if (primary.startsWith(\"classpath:\")) {\n+                    persistenceProperties = new ClassPathResource(primary.substring(10));\n+                }\n+            }\n+            if ((persistenceProperties == null || !persistenceProperties.exists()) && fallback != null) {\n+                if (fallback.startsWith(\"file:\")) {\n+                    persistenceProperties = new FileSystemResource(fallback.substring(5));\n+                }\n+                if (fallback.startsWith(\"classpath:\")) {\n+                    persistenceProperties = new ClassPathResource(fallback.substring(10));\n+                }\n+            }\n+            Properties persistence = PropertiesLoaderUtils.loadProperties(persistenceProperties);\n+\n+            initSQLScript = persistence.getProperty(\"audit.sql\");\n+\n+            if (datasource == null) {\n+                BasicDataSource bds = new BasicDataSource();\n+                bds.setDriverClassName(persistence.getProperty(\"jpa.driverClassName\"));\n+                bds.setUrl(persistence.getProperty(\"jpa.url\"));\n+                bds.setUsername(persistence.getProperty(\"jpa.username\"));\n+                bds.setPassword(persistence.getProperty(\"jpa.password\"));\n+\n+                bds.setLogAbandoned(true);\n+                bds.setRemoveAbandonedOnBorrow(true);\n+                bds.setRemoveAbandonedOnMaintenance(true);\n+\n+                datasource = bds;\n+            }\n+        } catch (Exception e) {\n+            throw new IllegalStateException(\"Audit datasource configuration failed\", e);\n+        }\n+\n+        // 3. Initializes the chosen datasource\n+        ResourceDatabasePopulator populator = new ResourceDatabasePopulator();\n+        populator.setScripts(new Resource[] { new ClassPathResource(\"/audit/\" + initSQLScript) });\n+        // forces no statement separation\n+        populator.setSeparator(ScriptUtils.EOF_STATEMENT_SEPARATOR);\n+        Connection conn = DataSourceUtils.getConnection(datasource);\n+        try {\n+            populator.populate(conn);\n+        } finally {\n+            DataSourceUtils.releaseConnection(conn, datasource);\n+        }\n+    }\n+\n+    public static Connection getConnection() {\n+        if (datasource != null) {\n+            return DataSourceUtils.getConnection(datasource);\n+        }\n+\n+        throw new IllegalStateException(\"Audit dataSource init failed: check logs\");\n+    }\n+\n+    private AuditConnectionFactory() {\n+        // empty constructor for static utility class\n+    }\n+}"},{"sha":"ed674fd928de2df6930972d86636540d7c2ce375","filename":"syncope620/server/logic/src/main/java/org/apache/syncope/server/logic/audit/AuditManager.java","status":"added","additions":107,"deletions":0,"changes":107,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Faudit%2FAuditManager.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Faudit%2FAuditManager.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Faudit%2FAuditManager.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,107 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.server.logic.audit;\n+\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.syncope.common.lib.types.AuditElements;\n+import org.apache.syncope.common.lib.types.AuditElements.Result;\n+import org.apache.syncope.common.lib.types.AuditLoggerName;\n+import org.apache.syncope.common.lib.types.LoggerLevel;\n+import org.apache.syncope.persistence.api.dao.LoggerDAO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.core.context.SecurityContext;\n+import org.springframework.security.core.context.SecurityContextHolder;\n+\n+public class AuditManager {\n+\n+    /**\n+     * Logger.\n+     */\n+    private static final Logger LOG = LoggerFactory.getLogger(AuditManager.class);\n+\n+    @Autowired\n+    private LoggerDAO loggerDAO;\n+\n+    public void audit(\n+            final AuditElements.EventCategoryType type,\n+            final String category,\n+            final String subcategory,\n+            final String event,\n+            final Result result,\n+            final Object before,\n+            final Object output,\n+            final Object... input) {\n+\n+        final Throwable throwable;\n+        final StringBuilder message = new StringBuilder();\n+\n+        message.append(\"BEFORE:\\n\");\n+        message.append(\"\\t\").append(before == null ? \"unknown\" : before).append(\"\\n\");\n+\n+        message.append(\"INPUT:\\n\");\n+\n+        if (ArrayUtils.isNotEmpty(input)) {\n+            for (Object obj : input) {\n+                message.append(\"\\t\").append(obj == null ? null : obj.toString()).append(\"\\n\");\n+            }\n+        } else {\n+            message.append(\"\\t\").append(\"none\").append(\"\\n\");\n+        }\n+\n+        message.append(\"OUTPUT:\\n\");\n+\n+        if (output instanceof Throwable) {\n+            throwable = (Throwable) output;\n+            message.append(\"\\t\").append(throwable.getMessage());\n+        } else {\n+            throwable = null;\n+            message.append(\"\\t\").append(output == null ? \"none\" : output.toString());\n+        }\n+\n+        AuditLoggerName auditLoggerName = null;\n+        try {\n+            auditLoggerName = new AuditLoggerName(type, category, subcategory, event, result);\n+        } catch (IllegalArgumentException e) {\n+            LOG.error(\"Invalid audit parameters, aborting...\", e);\n+        }\n+\n+        if (auditLoggerName != null) {\n+            org.apache.syncope.persistence.api.entity.Logger syncopeLogger =\n+                     loggerDAO.find(auditLoggerName.toLoggerName());\n+            if (syncopeLogger != null && syncopeLogger.getLevel() == LoggerLevel.DEBUG) {\n+                StringBuilder auditMessage = new StringBuilder();\n+\n+                final SecurityContext ctx = SecurityContextHolder.getContext();\n+                if (ctx != null && ctx.getAuthentication() != null) {\n+                    auditMessage.append('[').append(ctx.getAuthentication().getName()).append(']').append(' ');\n+                }\n+                auditMessage.append(message);\n+\n+                final Logger logger = LoggerFactory.getLogger(auditLoggerName.toLoggerName());\n+                if (throwable == null) {\n+                    logger.debug(auditMessage.toString());\n+                } else {\n+                    logger.debug(auditMessage.toString(), throwable);\n+                }\n+            }\n+        }\n+    }\n+}"},{"sha":"d84c62f21934d894f654692fc7e91a9e25dfa4a5","filename":"syncope620/server/logic/src/main/java/org/apache/syncope/server/logic/data/AbstractAttributableDataBinder.java","status":"added","additions":918,"deletions":0,"changes":918,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Fdata%2FAbstractAttributableDataBinder.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Fdata%2FAbstractAttributableDataBinder.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Fdata%2FAbstractAttributableDataBinder.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,918 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.server.logic.data;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.syncope.common.lib.SyncopeClientCompositeException;\n+import org.apache.syncope.common.lib.SyncopeClientException;\n+import org.apache.syncope.common.lib.mod.AbstractAttributableMod;\n+import org.apache.syncope.common.lib.mod.AbstractSubjectMod;\n+import org.apache.syncope.common.lib.mod.AttrMod;\n+import org.apache.syncope.common.lib.to.AbstractAttributableTO;\n+import org.apache.syncope.common.lib.to.AbstractSubjectTO;\n+import org.apache.syncope.common.lib.to.AttrTO;\n+import org.apache.syncope.common.lib.types.AttributableType;\n+import org.apache.syncope.common.lib.types.ClientExceptionType;\n+import org.apache.syncope.common.lib.types.IntMappingType;\n+import org.apache.syncope.common.lib.types.MappingPurpose;\n+import org.apache.syncope.common.lib.types.ResourceOperation;\n+import org.apache.syncope.persistence.api.attrvalue.validation.InvalidPlainAttrValueException;\n+import org.apache.syncope.persistence.api.dao.DerAttrDAO;\n+import org.apache.syncope.persistence.api.dao.DerSchemaDAO;\n+import org.apache.syncope.persistence.api.dao.ExternalResourceDAO;\n+import org.apache.syncope.persistence.api.dao.MembershipDAO;\n+import org.apache.syncope.persistence.api.dao.PlainAttrDAO;\n+import org.apache.syncope.persistence.api.dao.PlainAttrValueDAO;\n+import org.apache.syncope.persistence.api.dao.PlainSchemaDAO;\n+import org.apache.syncope.persistence.api.dao.PolicyDAO;\n+import org.apache.syncope.persistence.api.dao.RoleDAO;\n+import org.apache.syncope.persistence.api.dao.UserDAO;\n+import org.apache.syncope.persistence.api.dao.VirAttrDAO;\n+import org.apache.syncope.persistence.api.dao.VirSchemaDAO;\n+import org.apache.syncope.persistence.api.entity.Attributable;\n+import org.apache.syncope.persistence.api.entity.AttributableUtil;\n+import org.apache.syncope.persistence.api.entity.AttributableUtilFactory;\n+import org.apache.syncope.persistence.api.entity.DerAttr;\n+import org.apache.syncope.persistence.api.entity.DerSchema;\n+import org.apache.syncope.persistence.api.entity.EntityFactory;\n+import org.apache.syncope.persistence.api.entity.ExternalResource;\n+import org.apache.syncope.persistence.api.entity.MappingItem;\n+import org.apache.syncope.persistence.api.entity.PlainAttr;\n+import org.apache.syncope.persistence.api.entity.PlainAttrValue;\n+import org.apache.syncope.persistence.api.entity.PlainSchema;\n+import org.apache.syncope.persistence.api.entity.Schema;\n+import org.apache.syncope.persistence.api.entity.Subject;\n+import org.apache.syncope.persistence.api.entity.VirAttr;\n+import org.apache.syncope.persistence.api.entity.VirSchema;\n+import org.apache.syncope.persistence.api.entity.membership.MDerAttr;\n+import org.apache.syncope.persistence.api.entity.membership.MDerAttrTemplate;\n+import org.apache.syncope.persistence.api.entity.membership.MPlainAttr;\n+import org.apache.syncope.persistence.api.entity.membership.MPlainAttrTemplate;\n+import org.apache.syncope.persistence.api.entity.membership.MVirAttr;\n+import org.apache.syncope.persistence.api.entity.membership.MVirAttrTemplate;\n+import org.apache.syncope.persistence.api.entity.membership.Membership;\n+import org.apache.syncope.persistence.api.entity.role.RDerAttr;\n+import org.apache.syncope.persistence.api.entity.role.RDerAttrTemplate;\n+import org.apache.syncope.persistence.api.entity.role.RPlainAttr;\n+import org.apache.syncope.persistence.api.entity.role.RPlainAttrTemplate;\n+import org.apache.syncope.persistence.api.entity.role.RVirAttr;\n+import org.apache.syncope.persistence.api.entity.role.RVirAttrTemplate;\n+import org.apache.syncope.persistence.api.entity.role.Role;\n+import org.apache.syncope.persistence.api.entity.user.UDerAttr;\n+import org.apache.syncope.persistence.api.entity.user.UDerSchema;\n+import org.apache.syncope.persistence.api.entity.user.UPlainAttr;\n+import org.apache.syncope.persistence.api.entity.user.UPlainSchema;\n+import org.apache.syncope.persistence.api.entity.user.UVirAttr;\n+import org.apache.syncope.persistence.api.entity.user.UVirSchema;\n+import org.apache.syncope.provisioning.api.propagation.PropagationByResource;\n+import org.apache.syncope.server.utils.MappingUtil;\n+import org.apache.syncope.server.utils.jexl.JexlUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+public abstract class AbstractAttributableDataBinder {\n+\n+    /**\n+     * Logger.\n+     */\n+    protected static final Logger LOG = LoggerFactory.getLogger(AbstractAttributableDataBinder.class);\n+\n+    @Autowired\n+    protected RoleDAO roleDAO;\n+\n+    @Autowired\n+    protected PlainSchemaDAO plainSchemaDAO;\n+\n+    @Autowired\n+    protected DerSchemaDAO derSchemaDAO;\n+\n+    @Autowired\n+    protected VirSchemaDAO virSchemaDAO;\n+\n+    @Autowired\n+    protected PlainAttrDAO plainAttrDAO;\n+\n+    @Autowired\n+    protected DerAttrDAO derAttrDAO;\n+\n+    @Autowired\n+    protected VirAttrDAO virAttrDAO;\n+\n+    @Autowired\n+    protected PlainAttrValueDAO plainAttrValueDAO;\n+\n+    @Autowired\n+    protected UserDAO userDAO;\n+\n+    @Autowired\n+    protected ExternalResourceDAO resourceDAO;\n+\n+    @Autowired\n+    protected MembershipDAO membershipDAO;\n+\n+    @Autowired\n+    protected PolicyDAO policyDAO;\n+\n+    @Autowired\n+    protected EntityFactory entityFactory;\n+\n+    @Autowired\n+    protected AttributableUtilFactory attrUtilFactory;\n+\n+    @SuppressWarnings(\"unchecked\")\n+    protected <T extends Schema> T getSchema(final String schemaName, final Class<T> reference) {\n+        T result = null;\n+\n+        if (PlainSchema.class.isAssignableFrom(reference)) {\n+            result = (T) getPlainSchema(schemaName, (Class<? extends PlainSchema>) reference);\n+        } else if (DerSchema.class.isAssignableFrom(reference)) {\n+            result = (T) getDerSchema(schemaName, (Class<? extends DerSchema>) reference);\n+        } else if (VirSchema.class.isAssignableFrom(reference)) {\n+            result = (T) getVirSchema(schemaName, (Class<? extends VirSchema>) reference);\n+        }\n+\n+        return result;\n+    }\n+\n+    protected <T extends PlainSchema> T getPlainSchema(final String schemaName, final Class<T> reference) {\n+        T schema = null;\n+        if (StringUtils.isNotBlank(schemaName)) {\n+            schema = plainSchemaDAO.find(schemaName, reference);\n+\n+            // safely ignore invalid schemas from AttrTO\n+            // see http://code.google.com/p/syncope/issues/detail?id=17\n+            if (schema == null) {\n+                LOG.debug(\"Ignoring invalid schema {}\", schemaName);\n+            } else if (schema.isReadonly()) {\n+                schema = null;\n+\n+                LOG.debug(\"Ignoring readonly schema {}\", schemaName);\n+            }\n+        }\n+\n+        return schema;\n+    }\n+\n+    private <T extends DerSchema> T getDerSchema(final String derSchemaName, final Class<T> reference) {\n+        T derivedSchema = null;\n+        if (StringUtils.isNotBlank(derSchemaName)) {\n+            derivedSchema = derSchemaDAO.find(derSchemaName, reference);\n+            if (derivedSchema == null) {\n+                LOG.debug(\"Ignoring invalid derived schema {}\", derSchemaName);\n+            }\n+        }\n+\n+        return derivedSchema;\n+    }\n+\n+    private <T extends VirSchema> T getVirSchema(final String virSchemaName, final Class<T> reference) {\n+        T virtualSchema = null;\n+        if (StringUtils.isNotBlank(virSchemaName)) {\n+            virtualSchema = virSchemaDAO.find(virSchemaName, reference);\n+\n+            if (virtualSchema == null) {\n+                LOG.debug(\"Ignoring invalid virtual schema {}\", virSchemaName);\n+            }\n+        }\n+\n+        return virtualSchema;\n+    }\n+\n+    protected void fillAttribute(final List<String> values, final AttributableUtil attributableUtil,\n+            final PlainSchema schema, final PlainAttr attr, final SyncopeClientException invalidValues) {\n+\n+        // if schema is multivalue, all values are considered for addition;\n+        // otherwise only the fist one - if provided - is considered\n+        List<String> valuesProvided = schema.isMultivalue()\n+                ? values\n+                : (values.isEmpty()\n+                        ? Collections.<String>emptyList()\n+                        : Collections.singletonList(values.iterator().next()));\n+\n+        for (String value : valuesProvided) {\n+            if (value == null || value.isEmpty()) {\n+                LOG.debug(\"Null value for {}, ignoring\", schema.getKey());\n+            } else {\n+                try {\n+                    attr.addValue(value, attributableUtil);\n+                } catch (InvalidPlainAttrValueException e) {\n+                    LOG.warn(\"Invalid value for attribute \" + schema.getKey() + \": \" + value, e);\n+\n+                    invalidValues.getElements().add(schema.getKey() + \": \" + value + \" - \" + e.getMessage());\n+                }\n+            }\n+        }\n+    }\n+\n+    private boolean evaluateMandatoryCondition(final AttributableUtil attrUtil, final ExternalResource resource,\n+            final Attributable attributable, final String intAttrName, final IntMappingType intMappingType) {\n+\n+        boolean result = false;\n+\n+        final List<MappingItem> mappings = MappingUtil.getMatchingMappingItems(\n+                attrUtil.getMappingItems(resource, MappingPurpose.PROPAGATION), intAttrName, intMappingType);\n+        for (Iterator<MappingItem> itor = mappings.iterator(); itor.hasNext() && !result;) {\n+            final MappingItem mapping = itor.next();\n+            result |= JexlUtil.evaluateMandatoryCondition(mapping.getMandatoryCondition(), attributable);\n+        }\n+\n+        return result;\n+    }\n+\n+    private boolean evaluateMandatoryCondition(final AttributableUtil attrUtil,\n+            final Attributable<?, ?, ?> attributable, final String intAttrName, final IntMappingType intMappingType) {\n+\n+        boolean result = false;\n+\n+        if (attributable instanceof Subject) {\n+            for (Iterator<? extends ExternalResource> itor = ((Subject<?, ?, ?>) attributable).getResources().iterator();\n+                    itor.hasNext() && !result;) {\n+\n+                final ExternalResource resource = itor.next();\n+                if (resource.isEnforceMandatoryCondition()) {\n+                    result |= evaluateMandatoryCondition(attrUtil, resource, attributable, intAttrName, intMappingType);\n+                }\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    private SyncopeClientException checkMandatory(final AttributableUtil attrUtil,\n+            final Attributable<?, ?, ?> attributable) {\n+\n+        SyncopeClientException reqValMissing = SyncopeClientException.build(ClientExceptionType.RequiredValuesMissing);\n+\n+        // Check if there is some mandatory schema defined for which no value has been provided\n+        List<? extends PlainSchema> plainSchemas;\n+        switch (attrUtil.getType()) {\n+            case ROLE:\n+                plainSchemas = ((Role) attributable).getAttrTemplateSchemas(RPlainAttrTemplate.class);\n+                break;\n+\n+            case MEMBERSHIP:\n+                plainSchemas = ((Membership) attributable).getRole().getAttrTemplateSchemas(MPlainAttrTemplate.class);\n+                break;\n+\n+            case USER:\n+            default:\n+                plainSchemas = plainSchemaDAO.findAll(attrUtil.plainSchemaClass());\n+        }\n+        for (PlainSchema schema : plainSchemas) {\n+            if (attributable.getPlainAttr(schema.getKey()) == null\n+                    && !schema.isReadonly()\n+                    && (JexlUtil.evaluateMandatoryCondition(schema.getMandatoryCondition(), attributable)\n+                    || evaluateMandatoryCondition(attrUtil, attributable, schema.getKey(),\n+                            attrUtil.intMappingType()))) {\n+\n+                LOG.error(\"Mandatory schema \" + schema.getKey() + \" not provided with values\");\n+\n+                reqValMissing.getElements().add(schema.getKey());\n+            }\n+        }\n+\n+        List<? extends DerSchema> derSchemas;\n+        switch (attrUtil.getType()) {\n+            case ROLE:\n+                derSchemas = ((Role) attributable).getAttrTemplateSchemas(RDerAttrTemplate.class);\n+                break;\n+\n+            case MEMBERSHIP:\n+                derSchemas = ((Membership) attributable).getRole().getAttrTemplateSchemas(MDerAttrTemplate.class);\n+                break;\n+\n+            case USER:\n+            default:\n+                derSchemas = derSchemaDAO.findAll(attrUtil.derSchemaClass());\n+        }\n+        for (DerSchema derSchema : derSchemas) {\n+            if (attributable.getDerAttr(derSchema.getKey()) == null\n+                    && evaluateMandatoryCondition(attrUtil, attributable, derSchema.getKey(),\n+                            attrUtil.derIntMappingType())) {\n+\n+                LOG.error(\"Mandatory derived schema \" + derSchema.getKey() + \" does not evaluate to any value\");\n+\n+                reqValMissing.getElements().add(derSchema.getKey());\n+            }\n+        }\n+\n+        List<? extends VirSchema> virSchemas;\n+        switch (attrUtil.getType()) {\n+            case ROLE:\n+                virSchemas = ((Role) attributable).getAttrTemplateSchemas(RVirAttrTemplate.class);\n+                break;\n+\n+            case MEMBERSHIP:\n+                virSchemas = ((Membership) attributable).getRole().getAttrTemplateSchemas(MVirAttrTemplate.class);\n+                break;\n+\n+            case USER:\n+            default:\n+                virSchemas = virSchemaDAO.findAll(attrUtil.virSchemaClass());\n+        }\n+        for (VirSchema virSchema : virSchemas) {\n+            if (attributable.getVirAttr(virSchema.getKey()) == null\n+                    && !virSchema.isReadonly()\n+                    && evaluateMandatoryCondition(attrUtil, attributable, virSchema.getKey(),\n+                            attrUtil.virIntMappingType())) {\n+\n+                LOG.error(\"Mandatory virtual schema \" + virSchema.getKey() + \" not provided with values\");\n+\n+                reqValMissing.getElements().add(virSchema.getKey());\n+            }\n+        }\n+\n+        return reqValMissing;\n+    }\n+\n+    private void setPlainAttrSchema(final Attributable<?, ?, ?> attributable,\n+            final PlainAttr attr, final PlainSchema schema) {\n+\n+        if (attr instanceof UPlainAttr) {\n+            ((UPlainAttr) attr).setSchema((UPlainSchema) schema);\n+        } else if (attr instanceof RPlainAttr) {\n+            RPlainAttrTemplate template =\n+                    ((Role) attributable).getAttrTemplate(RPlainAttrTemplate.class, schema.getKey());\n+            if (template != null) {\n+                ((RPlainAttr) attr).setTemplate(template);\n+            }\n+        } else if (attr instanceof MPlainAttr) {\n+            MPlainAttrTemplate template = ((Membership) attributable).getRole().\n+                    getAttrTemplate(MPlainAttrTemplate.class, schema.getKey());\n+            if (template != null) {\n+                ((MPlainAttr) attr).setTemplate(template);\n+            }\n+        }\n+    }\n+\n+    private void setDerAttrSchema(final Attributable<?, ?, ?> attributable,\n+            final DerAttr derAttr, final DerSchema derSchema) {\n+\n+        if (derAttr instanceof UDerAttr) {\n+            ((UDerAttr) derAttr).setSchema((UDerSchema) derSchema);\n+        } else if (derAttr instanceof RDerAttr) {\n+            RDerAttrTemplate template = ((Role) attributable).\n+                    getAttrTemplate(RDerAttrTemplate.class, derSchema.getKey());\n+            if (template != null) {\n+                ((RDerAttr) derAttr).setTemplate(template);\n+            }\n+        } else if (derAttr instanceof MDerAttr) {\n+            MDerAttrTemplate template = ((Membership) attributable).getRole().\n+                    getAttrTemplate(MDerAttrTemplate.class, derSchema.getKey());\n+            if (template != null) {\n+                ((MDerAttr) derAttr).setTemplate(template);\n+            }\n+        }\n+    }\n+\n+    private void setVirAttrSchema(final Attributable<?, ?, ?> attributable,\n+            final VirAttr virAttr, final VirSchema virSchema) {\n+\n+        if (virAttr instanceof UVirAttr) {\n+            ((UVirAttr) virAttr).setSchema((UVirSchema) virSchema);\n+        } else if (virAttr instanceof RVirAttr) {\n+            RVirAttrTemplate template = ((Role) attributable).\n+                    getAttrTemplate(RVirAttrTemplate.class, virSchema.getKey());\n+            if (template != null) {\n+                ((RVirAttr) virAttr).setTemplate(template);\n+            }\n+        } else if (virAttr instanceof MVirAttr) {\n+            MVirAttrTemplate template =\n+                    ((Membership) attributable).getRole().\n+                    getAttrTemplate(MVirAttrTemplate.class, virSchema.getKey());\n+            if (template != null) {\n+                ((MVirAttr) virAttr).setTemplate(template);\n+            }\n+        }\n+    }\n+\n+    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+    public PropagationByResource fillVirtual(final Attributable attributable,\n+            final Set<String> vAttrsToBeRemoved, final Set<AttrMod> vAttrsToBeUpdated,\n+            final AttributableUtil attrUtil) {\n+\n+        PropagationByResource propByRes = new PropagationByResource();\n+\n+        final Set<ExternalResource> externalResources = new HashSet<>();\n+        if (attributable instanceof Subject) {\n+            externalResources.addAll(((Subject<?, ?, ?>) attributable).getResources());\n+        }\n+\n+        if (attributable instanceof Membership) {\n+            externalResources.clear();\n+            externalResources.addAll(((Membership) attributable).getUser().getResources());\n+        }\n+\n+        // 1. virtual attributes to be removed\n+        for (String vAttrToBeRemoved : vAttrsToBeRemoved) {\n+            VirSchema virSchema = getVirSchema(vAttrToBeRemoved, attrUtil.virSchemaClass());\n+            if (virSchema != null) {\n+                VirAttr virAttr = attributable.getVirAttr(virSchema.getKey());\n+                if (virAttr == null) {\n+                    LOG.debug(\"No virtual attribute found for schema {}\", virSchema.getKey());\n+                } else {\n+                    attributable.removeVirAttr(virAttr);\n+                    virAttrDAO.delete(virAttr);\n+                }\n+\n+                for (ExternalResource resource : resourceDAO.findAll()) {\n+                    for (MappingItem mapItem : attrUtil.getMappingItems(resource, MappingPurpose.PROPAGATION)) {\n+                        if (virSchema.getKey().equals(mapItem.getIntAttrName())\n+                                && mapItem.getIntMappingType() == attrUtil.virIntMappingType()\n+                                && externalResources.contains(resource)) {\n+\n+                            propByRes.add(ResourceOperation.UPDATE, resource.getKey());\n+\n+                            // Using virtual attribute as AccountId must be avoided\n+                            if (mapItem.isAccountid() && virAttr != null && !virAttr.getValues().isEmpty()) {\n+                                propByRes.addOldAccountId(resource.getKey(), virAttr.getValues().get(0));\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        LOG.debug(\"Virtual attributes to be removed:\\n{}\", propByRes);\n+\n+        // 2. virtual attributes to be updated\n+        for (AttrMod vAttrToBeUpdated : vAttrsToBeUpdated) {\n+            VirSchema virSchema = getVirSchema(vAttrToBeUpdated.getSchema(), attrUtil.virSchemaClass());\n+            VirAttr virAttr = null;\n+            if (virSchema != null) {\n+                virAttr = attributable.getVirAttr(virSchema.getKey());\n+                if (virAttr == null) {\n+                    virAttr = attrUtil.newVirAttr();\n+                    setVirAttrSchema(attributable, virAttr, virSchema);\n+                    if (virAttr.getSchema() == null) {\n+                        LOG.debug(\"Ignoring {} because no valid schema or template was found\", vAttrToBeUpdated);\n+                    } else {\n+                        attributable.addVirAttr(virAttr);\n+                    }\n+                }\n+            }\n+\n+            if (virSchema != null && virAttr != null && virAttr.getSchema() != null) {\n+                for (ExternalResource resource : resourceDAO.findAll()) {\n+                    for (MappingItem mapItem : attrUtil.getMappingItems(resource, MappingPurpose.PROPAGATION)) {\n+                        if (virSchema.getKey().equals(mapItem.getIntAttrName())\n+                                && mapItem.getIntMappingType() == attrUtil.virIntMappingType()\n+                                && externalResources.contains(resource)) {\n+\n+                            propByRes.add(ResourceOperation.UPDATE, resource.getKey());\n+                        }\n+                    }\n+                }\n+\n+                final List<String> values = new ArrayList<>(virAttr.getValues());\n+                values.removeAll(vAttrToBeUpdated.getValuesToBeRemoved());\n+                values.addAll(vAttrToBeUpdated.getValuesToBeAdded());\n+\n+                virAttr.getValues().clear();\n+                virAttr.getValues().addAll(values);\n+\n+                // Owner cannot be specified before otherwise a virtual attribute remove will be invalidated.\n+                virAttr.setOwner(attributable);\n+            }\n+        }\n+\n+        LOG.debug(\"Virtual attributes to be added:\\n{}\", propByRes);\n+\n+        return propByRes;\n+    }\n+\n+    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+    protected PropagationByResource fill(final Attributable attributable,\n+            final AbstractAttributableMod attributableMod, final AttributableUtil attrUtil,\n+            final SyncopeClientCompositeException scce) {\n+\n+        PropagationByResource propByRes = new PropagationByResource();\n+\n+        SyncopeClientException invalidValues = SyncopeClientException.build(ClientExceptionType.InvalidValues);\n+\n+        if (attributable instanceof Subject && attributableMod instanceof AbstractSubjectMod) {\n+            // 1. resources to be removed\n+            for (String resourceToBeRemoved : ((AbstractSubjectMod) attributableMod).getResourcesToRemove()) {\n+                ExternalResource resource = resourceDAO.find(resourceToBeRemoved);\n+                if (resource != null) {\n+                    propByRes.add(ResourceOperation.DELETE, resource.getKey());\n+                    ((Subject<?, ?, ?>) attributable).removeResource(resource);\n+                }\n+            }\n+\n+            LOG.debug(\"Resources to be removed:\\n{}\", propByRes);\n+\n+            // 2. resources to be added\n+            for (String resourceToBeAdded : ((AbstractSubjectMod) attributableMod).getResourcesToAdd()) {\n+                ExternalResource resource = resourceDAO.find(resourceToBeAdded);\n+                if (resource != null) {\n+                    propByRes.add(ResourceOperation.CREATE, resource.getKey());\n+                    ((Subject<?, ?, ?>) attributable).addResource(resource);\n+                }\n+            }\n+\n+            LOG.debug(\"Resources to be added:\\n{}\", propByRes);\n+        }\n+\n+        // 3. attributes to be removed\n+        for (String attributeToBeRemoved : attributableMod.getAttrsToRemove()) {\n+            PlainSchema schema = getPlainSchema(attributeToBeRemoved, attrUtil.plainSchemaClass());\n+            if (schema != null) {\n+                PlainAttr attr = attributable.getPlainAttr(schema.getKey());\n+                if (attr == null) {\n+                    LOG.debug(\"No attribute found for schema {}\", schema);\n+                } else {\n+                    String newValue = null;\n+                    for (AttrMod mod : attributableMod.getAttrsToUpdate()) {\n+                        if (schema.getKey().equals(mod.getSchema())) {\n+                            newValue = mod.getValuesToBeAdded().get(0);\n+                        }\n+                    }\n+\n+                    if (!schema.isUniqueConstraint()\n+                            || (!attr.getUniqueValue().getStringValue().equals(newValue))) {\n+\n+                        attributable.removePlainAttr(attr);\n+                        plainAttrDAO.delete(attr.getKey(), attrUtil.plainAttrClass());\n+                    }\n+                }\n+\n+                if (attributable instanceof Subject) {\n+                    for (ExternalResource resource : resourceDAO.findAll()) {\n+                        for (MappingItem mapItem : attrUtil.getMappingItems(resource, MappingPurpose.PROPAGATION)) {\n+                            if (schema.getKey().equals(mapItem.getIntAttrName())\n+                                    && mapItem.getIntMappingType() == attrUtil.intMappingType()\n+                                    && ((Subject<?, ?, ?>) attributable).getResources().contains(resource)) {\n+\n+                                propByRes.add(ResourceOperation.UPDATE, resource.getKey());\n+\n+                                if (mapItem.isAccountid() && attr != null\n+                                        && !attr.getValuesAsStrings().isEmpty()) {\n+\n+                                    propByRes.addOldAccountId(resource.getKey(),\n+                                            attr.getValuesAsStrings().iterator().next());\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        LOG.debug(\"Attributes to be removed:\\n{}\", propByRes);\n+\n+        // 4. attributes to be updated\n+        for (AttrMod attributeMod : attributableMod.getAttrsToUpdate()) {\n+            PlainSchema schema = getPlainSchema(attributeMod.getSchema(), attrUtil.plainSchemaClass());\n+            PlainAttr attr = null;\n+            if (schema != null) {\n+                attr = attributable.getPlainAttr(schema.getKey());\n+                if (attr == null) {\n+                    attr = attrUtil.newPlainAttr();\n+                    setPlainAttrSchema(attributable, attr, schema);\n+                    if (attr.getSchema() == null) {\n+                        LOG.debug(\"Ignoring {} because no valid schema or template was found\", attributeMod);\n+                    } else {\n+                        attr.setOwner(attributable);\n+                        attributable.addPlainAttr(attr);\n+                    }\n+                }\n+            }\n+\n+            if (schema != null && attr != null && attr.getSchema() != null) {\n+                if (attributable instanceof Subject) {\n+                    for (ExternalResource resource : resourceDAO.findAll()) {\n+                        for (MappingItem mapItem : attrUtil.getMappingItems(resource, MappingPurpose.PROPAGATION)) {\n+                            if (schema.getKey().equals(mapItem.getIntAttrName())\n+                                    && mapItem.getIntMappingType() == attrUtil.intMappingType()\n+                                    && ((Subject<?, ?, ?>) attributable).getResources().contains(resource)) {\n+\n+                                propByRes.add(ResourceOperation.UPDATE, resource.getKey());\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                // 1.1 remove values\n+                Set<Long> valuesToBeRemoved = new HashSet<>();\n+                for (String valueToBeRemoved : attributeMod.getValuesToBeRemoved()) {\n+                    if (attr.getSchema().isUniqueConstraint()) {\n+                        if (attr.getUniqueValue() != null\n+                                && valueToBeRemoved.equals(attr.getUniqueValue().getValueAsString())) {\n+\n+                            valuesToBeRemoved.add(attr.getUniqueValue().getKey());\n+                        }\n+                    } else {\n+                        for (PlainAttrValue mav : attr.getValues()) {\n+                            if (valueToBeRemoved.equals(mav.getValueAsString())) {\n+                                valuesToBeRemoved.add(mav.getKey());\n+                            }\n+                        }\n+                    }\n+                }\n+                for (Long attributeValueId : valuesToBeRemoved) {\n+                    plainAttrValueDAO.delete(attributeValueId, attrUtil.plainAttrValueClass());\n+                }\n+\n+                // 1.2 add values\n+                List<String> valuesToBeAdded = attributeMod.getValuesToBeAdded();\n+                if (valuesToBeAdded != null && !valuesToBeAdded.isEmpty()\n+                        && (!schema.isUniqueConstraint() || attr.getUniqueValue() == null\n+                        || !valuesToBeAdded.iterator().next().equals(attr.getUniqueValue().getValueAsString()))) {\n+\n+                    fillAttribute(attributeMod.getValuesToBeAdded(), attrUtil, schema, attr, invalidValues);\n+                }\n+\n+                // if no values are in, the attribute can be safely removed\n+                if (attr.getValuesAsStrings().isEmpty()) {\n+                    plainAttrDAO.delete(attr);\n+                }\n+            }\n+        }\n+\n+        if (!invalidValues.isEmpty()) {\n+            scce.addException(invalidValues);\n+        }\n+\n+        LOG.debug(\"Attributes to be updated:\\n{}\", propByRes);\n+\n+        // 5. derived attributes to be removed\n+        for (String derAttrToBeRemoved : attributableMod.getDerAttrsToRemove()) {\n+            DerSchema derSchema = getDerSchema(derAttrToBeRemoved, attrUtil.derSchemaClass());\n+            if (derSchema != null) {\n+                DerAttr derAttr = attributable.getDerAttr(derSchema.getKey());\n+                if (derAttr == null) {\n+                    LOG.debug(\"No derived attribute found for schema {}\", derSchema.getKey());\n+                } else {\n+                    derAttrDAO.delete(derAttr);\n+                }\n+\n+                if (attributable instanceof Subject) {\n+                    for (ExternalResource resource : resourceDAO.findAll()) {\n+                        for (MappingItem mapItem : attrUtil.getMappingItems(resource, MappingPurpose.PROPAGATION)) {\n+                            if (derSchema.getKey().equals(mapItem.getIntAttrName())\n+                                    && mapItem.getIntMappingType() == attrUtil.derIntMappingType()\n+                                    && ((Subject<?, ?, ?>) attributable).getResources().contains(resource)) {\n+\n+                                propByRes.add(ResourceOperation.UPDATE, resource.getKey());\n+\n+                                if (mapItem.isAccountid() && derAttr != null\n+                                        && !derAttr.getValue(attributable.getPlainAttrs()).isEmpty()) {\n+\n+                                    propByRes.addOldAccountId(resource.getKey(),\n+                                            derAttr.getValue(attributable.getPlainAttrs()));\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        LOG.debug(\"Derived attributes to be removed:\\n{}\", propByRes);\n+\n+        // 6. derived attributes to be added\n+        for (String derAttrToBeAdded : attributableMod.getDerAttrsToAdd()) {\n+            DerSchema derSchema = getDerSchema(derAttrToBeAdded, attrUtil.derSchemaClass());\n+            if (derSchema != null) {\n+                if (attributable instanceof Subject) {\n+                    for (ExternalResource resource : resourceDAO.findAll()) {\n+                        for (MappingItem mapItem : attrUtil.getMappingItems(resource, MappingPurpose.PROPAGATION)) {\n+                            if (derSchema.getKey().equals(mapItem.getIntAttrName())\n+                                    && mapItem.getIntMappingType() == attrUtil.derIntMappingType()\n+                                    && ((Subject<?, ?, ?>) attributable).getResources().contains(resource)) {\n+\n+                                propByRes.add(ResourceOperation.UPDATE, resource.getKey());\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                DerAttr derAttr = attrUtil.newDerAttr();\n+                setDerAttrSchema(attributable, derAttr, derSchema);\n+                if (derAttr.getSchema() == null) {\n+                    LOG.debug(\"Ignoring {} because no valid schema or template was found\", derAttrToBeAdded);\n+                } else {\n+                    derAttr.setOwner(attributable);\n+                    attributable.addDerAttr(derAttr);\n+                }\n+            }\n+        }\n+\n+        LOG.debug(\"Derived attributes to be added:\\n{}\", propByRes);\n+\n+        // 7. virtual attributes: for users and roles this is delegated to PropagationManager\n+        if (AttributableType.USER != attrUtil.getType() && AttributableType.ROLE != attrUtil.getType()) {\n+            fillVirtual(attributable, attributableMod.getVirAttrsToRemove(),\n+                    attributableMod.getVirAttrsToUpdate(), attrUtil);\n+        }\n+\n+        // Finally, check if mandatory values are missing\n+        SyncopeClientException requiredValuesMissing = checkMandatory(attrUtil, attributable);\n+        if (!requiredValuesMissing.isEmpty()) {\n+            scce.addException(requiredValuesMissing);\n+        }\n+\n+        // Throw composite exception if there is at least one element set in the composing exceptions\n+        if (scce.hasExceptions()) {\n+            throw scce;\n+        }\n+\n+        return propByRes;\n+    }\n+\n+    /**\n+     * Add virtual attributes and specify values to be propagated.\n+     *\n+     * @param attributable attributable.\n+     * @param vAttrs virtual attributes to be added.\n+     * @param attrUtil attributable util.\n+     */\n+    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+    public void fillVirtual(final Attributable attributable, final Collection<AttrTO> vAttrs,\n+            final AttributableUtil attrUtil) {\n+\n+        for (AttrTO attributeTO : vAttrs) {\n+            VirAttr virAttr = attributable.getVirAttr(attributeTO.getSchema());\n+            if (virAttr == null) {\n+                VirSchema virSchema = getVirSchema(attributeTO.getSchema(), attrUtil.virSchemaClass());\n+                if (virSchema != null) {\n+                    virAttr = attrUtil.newVirAttr();\n+                    setVirAttrSchema(attributable, virAttr, virSchema);\n+                    if (virAttr.getSchema() == null) {\n+                        LOG.debug(\"Ignoring {} because no valid schema or template was found\", attributeTO);\n+                    } else {\n+                        virAttr.setOwner(attributable);\n+                        attributable.addVirAttr(virAttr);\n+                        virAttr.getValues().clear();\n+                        virAttr.getValues().addAll(attributeTO.getValues());\n+                    }\n+                }\n+            } else {\n+                virAttr.getValues().clear();\n+                virAttr.getValues().addAll(attributeTO.getValues());\n+            }\n+        }\n+    }\n+\n+    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+    protected void fill(final Attributable attributable, final AbstractAttributableTO attributableTO,\n+            final AttributableUtil attributableUtil, final SyncopeClientCompositeException scce) {\n+\n+        // 1. attributes\n+        SyncopeClientException invalidValues = SyncopeClientException.build(ClientExceptionType.InvalidValues);\n+\n+        // Only consider attributeTO with values\n+        for (AttrTO attributeTO : attributableTO.getPlainAttrs()) {\n+            if (attributeTO.getValues() != null && !attributeTO.getValues().isEmpty()) {\n+                PlainSchema schema = getPlainSchema(attributeTO.getSchema(), attributableUtil.plainSchemaClass());\n+\n+                if (schema != null) {\n+                    PlainAttr attr = attributable.getPlainAttr(schema.getKey());\n+                    if (attr == null) {\n+                        attr = attributableUtil.newPlainAttr();\n+                        setPlainAttrSchema(attributable, attr, schema);\n+                    }\n+                    if (attr.getSchema() == null) {\n+                        LOG.debug(\"Ignoring {} because no valid schema or template was found\", attributeTO);\n+                    } else {\n+                        fillAttribute(attributeTO.getValues(), attributableUtil, schema, attr, invalidValues);\n+\n+                        if (!attr.getValuesAsStrings().isEmpty()) {\n+                            attributable.addPlainAttr(attr);\n+                            attr.setOwner(attributable);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        if (!invalidValues.isEmpty()) {\n+            scce.addException(invalidValues);\n+        }\n+\n+        // 2. derived attributes\n+        for (AttrTO attributeTO : attributableTO.getDerAttrs()) {\n+            DerSchema derSchema = getDerSchema(attributeTO.getSchema(), attributableUtil.derSchemaClass());\n+\n+            if (derSchema != null) {\n+                DerAttr derAttr = attributableUtil.newDerAttr();\n+                setDerAttrSchema(attributable, derAttr, derSchema);\n+                if (derAttr.getSchema() == null) {\n+                    LOG.debug(\"Ignoring {} because no valid schema or template was found\", attributeTO);\n+                } else {\n+                    derAttr.setOwner(attributable);\n+                    attributable.addDerAttr(derAttr);\n+                }\n+            }\n+        }\n+\n+        // 3. user and role virtual attributes will be evaluated by the propagation manager only (if needed).\n+        if (AttributableType.USER == attributableUtil.getType()\n+                || AttributableType.ROLE == attributableUtil.getType()) {\n+\n+            for (AttrTO vattrTO : attributableTO.getVirAttrs()) {\n+                VirSchema virSchema = getVirSchema(vattrTO.getSchema(), attributableUtil.virSchemaClass());\n+\n+                if (virSchema != null) {\n+                    VirAttr virAttr = attributableUtil.newVirAttr();\n+                    setVirAttrSchema(attributable, virAttr, virSchema);\n+                    if (virAttr.getSchema() == null) {\n+                        LOG.debug(\"Ignoring {} because no valid schema or template was found\", vattrTO);\n+                    } else {\n+                        virAttr.setOwner(attributable);\n+                        attributable.addVirAttr(virAttr);\n+                    }\n+                }\n+            }\n+        }\n+\n+        fillVirtual(attributable, attributableTO.getVirAttrs(), attributableUtil);\n+\n+        // 4. resources\n+        if (attributable instanceof Subject && attributableTO instanceof AbstractSubjectTO) {\n+            for (String resourceName : ((AbstractSubjectTO) attributableTO).getResources()) {\n+                ExternalResource resource = resourceDAO.find(resourceName);\n+\n+                if (resource != null) {\n+                    ((Subject<?, ?, ?>) attributable).addResource(resource);\n+                }\n+            }\n+        }\n+\n+        SyncopeClientException requiredValuesMissing = checkMandatory(attributableUtil, attributable);\n+        if (!requiredValuesMissing.isEmpty()) {\n+            scce.addException(requiredValuesMissing);\n+        }\n+\n+        // Throw composite exception if there is at least one element set in the composing exceptions\n+        if (scce.hasExceptions()) {\n+            throw scce;\n+        }\n+    }\n+\n+    protected void fillTO(final AbstractAttributableTO attributableTO,\n+            final Collection<? extends PlainAttr> attrs,\n+            final Collection<? extends DerAttr> derAttrs,\n+            final Collection<? extends VirAttr> virAttrs,\n+            final Collection<? extends ExternalResource> resources) {\n+\n+        AttrTO attributeTO;\n+        for (PlainAttr attr : attrs) {\n+            attributeTO = new AttrTO();\n+            attributeTO.setSchema(attr.getSchema().getKey());\n+            attributeTO.getValues().addAll(attr.getValuesAsStrings());\n+            attributeTO.setReadonly(attr.getSchema().isReadonly());\n+\n+            attributableTO.getPlainAttrs().add(attributeTO);\n+        }\n+\n+        for (DerAttr derAttr : derAttrs) {\n+            attributeTO = new AttrTO();\n+            attributeTO.setSchema(derAttr.getSchema().getKey());\n+            attributeTO.getValues().add(derAttr.getValue(attrs));\n+            attributeTO.setReadonly(true);\n+\n+            attributableTO.getDerAttrs().add(attributeTO);\n+        }\n+\n+        for (VirAttr virAttr : virAttrs) {\n+            attributeTO = new AttrTO();\n+            attributeTO.setSchema(virAttr.getSchema().getKey());\n+            attributeTO.getValues().addAll(virAttr.getValues());\n+            attributeTO.setReadonly(virAttr.getSchema().isReadonly());\n+\n+            attributableTO.getVirAttrs().add(attributeTO);\n+        }\n+\n+        if (attributableTO instanceof AbstractSubjectTO) {\n+            for (ExternalResource resource : resources) {\n+                ((AbstractSubjectTO) attributableTO).getResources().add(resource.getKey());\n+            }\n+        }\n+    }\n+}"},{"sha":"64c4a4e45f4c26df75c19c1a64008f066cf36467","filename":"syncope620/server/logic/src/main/java/org/apache/syncope/server/logic/data/ConfigurationDataBinder.java","status":"added","additions":75,"deletions":0,"changes":75,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Fdata%2FConfigurationDataBinder.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Fdata%2FConfigurationDataBinder.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Fdata%2FConfigurationDataBinder.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,75 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.server.logic.data;\n+\n+import java.util.Collections;\n+import org.apache.syncope.common.lib.SyncopeClientException;\n+import org.apache.syncope.common.lib.to.AttrTO;\n+import org.apache.syncope.common.lib.to.ConfTO;\n+import org.apache.syncope.common.lib.types.AttributableType;\n+import org.apache.syncope.common.lib.types.ClientExceptionType;\n+import org.apache.syncope.persistence.api.dao.NotFoundException;\n+import org.apache.syncope.persistence.api.entity.ExternalResource;\n+import org.apache.syncope.persistence.api.entity.conf.CPlainAttr;\n+import org.apache.syncope.persistence.api.entity.conf.CPlainSchema;\n+import org.apache.syncope.persistence.api.entity.conf.Conf;\n+import org.springframework.stereotype.Component;\n+\n+@Component\n+public class ConfigurationDataBinder extends AbstractAttributableDataBinder {\n+\n+    public ConfTO getConfTO(final Conf conf) {\n+        final ConfTO confTO = new ConfTO();\n+        confTO.setKey(conf.getKey());\n+\n+        fillTO(confTO, conf.getPlainAttrs(),\n+                conf.getDerAttrs(), conf.getVirAttrs(), Collections.<ExternalResource>emptySet());\n+\n+        return confTO;\n+    }\n+\n+    public AttrTO getAttrTO(final CPlainAttr attr) {\n+        final AttrTO attributeTO = new AttrTO();\n+        attributeTO.setSchema(attr.getSchema().getKey());\n+        attributeTO.getValues().addAll(attr.getValuesAsStrings());\n+        attributeTO.setReadonly(attr.getSchema().isReadonly());\n+\n+        return attributeTO;\n+    }\n+\n+    public CPlainAttr getAttribute(final AttrTO attributeTO) {\n+        CPlainSchema schema = getPlainSchema(attributeTO.getSchema(), CPlainSchema.class);\n+        if (schema == null) {\n+            throw new NotFoundException(\"Conf schema \" + attributeTO.getSchema());\n+        } else {\n+            SyncopeClientException invalidValues = SyncopeClientException.build(ClientExceptionType.InvalidValues);\n+\n+            CPlainAttr attr = entityFactory.newEntity(CPlainAttr.class);\n+            attr.setSchema(schema);\n+            fillAttribute(attributeTO.getValues(), attrUtilFactory.getInstance(AttributableType.CONFIGURATION),\n+                    schema, attr, invalidValues);\n+\n+            if (!invalidValues.isEmpty()) {\n+                throw invalidValues;\n+            }\n+            return attr;\n+        }\n+    }\n+\n+}"},{"sha":"1091be17384ae3431de2a3386e005335b20f8bb2","filename":"syncope620/server/logic/src/main/java/org/apache/syncope/server/logic/data/ConnInstanceDataBinder.java","status":"added","additions":246,"deletions":0,"changes":246,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Fdata%2FConnInstanceDataBinder.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Fdata%2FConnInstanceDataBinder.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Fdata%2FConnInstanceDataBinder.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,246 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.server.logic.data;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import org.apache.syncope.common.lib.SyncopeClientException;\n+import org.apache.syncope.common.lib.to.ConnInstanceTO;\n+import org.apache.syncope.common.lib.to.ConnPoolConfTO;\n+import org.apache.syncope.common.lib.types.ClientExceptionType;\n+import org.apache.syncope.common.lib.types.ConnConfPropSchema;\n+import org.apache.syncope.common.lib.types.ConnConfProperty;\n+import org.apache.syncope.persistence.api.dao.ConnInstanceDAO;\n+import org.apache.syncope.persistence.api.entity.ConnInstance;\n+import org.apache.syncope.persistence.api.entity.EntityFactory;\n+import org.apache.syncope.provisioning.api.ConnIdBundleManager;\n+import org.apache.syncope.provisioning.api.ConnPoolConfUtil;\n+import org.identityconnectors.framework.api.ConfigurationProperties;\n+import org.identityconnectors.framework.api.ConfigurationProperty;\n+import org.identityconnectors.framework.impl.api.ConfigurationPropertyImpl;\n+import org.apache.syncope.server.spring.BeanUtils;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Component;\n+\n+@Component\n+public class ConnInstanceDataBinder {\n+\n+    private static final String[] IGNORE_PROPERTIES = { \"key\", \"poolConf\" };\n+\n+    @Autowired\n+    private ConnIdBundleManager connIdBundleManager;\n+\n+    @Autowired\n+    private ConnInstanceDAO connInstanceDAO;\n+\n+    @Autowired\n+    private EntityFactory entityFactory;\n+\n+    /**\n+     * Merge connector configuration properties avoiding repetition but giving priority to primary set.\n+     *\n+     * @param primary primary set.\n+     * @param secondary secondary set.\n+     * @return merged set.\n+     */\n+    public Set<ConnConfProperty> mergeConnConfProperties(final Set<ConnConfProperty> primary,\n+            final Set<ConnConfProperty> secondary) {\n+\n+        final Set<ConnConfProperty> conf = new HashSet<>();\n+\n+        // to be used to control managed prop (needed by overridden mechanism)\n+        final Set<String> propertyNames = new HashSet<>();\n+\n+        // get overridden connector configuration properties\n+        for (ConnConfProperty prop : primary) {\n+            if (!propertyNames.contains(prop.getSchema().getName())) {\n+                conf.add(prop);\n+                propertyNames.add(prop.getSchema().getName());\n+            }\n+        }\n+\n+        // get connector configuration properties\n+        for (ConnConfProperty prop : secondary) {\n+            if (!propertyNames.contains(prop.getSchema().getName())) {\n+                conf.add(prop);\n+                propertyNames.add(prop.getSchema().getName());\n+            }\n+        }\n+\n+        return conf;\n+    }\n+\n+    public ConnInstance getConnInstance(final ConnInstanceTO connInstanceTO) {\n+        SyncopeClientException sce = SyncopeClientException.build(ClientExceptionType.RequiredValuesMissing);\n+\n+        if (connInstanceTO.getLocation() == null) {\n+            sce.getElements().add(\"location\");\n+        }\n+\n+        if (connInstanceTO.getBundleName() == null) {\n+            sce.getElements().add(\"bundlename\");\n+        }\n+\n+        if (connInstanceTO.getVersion() == null) {\n+            sce.getElements().add(\"bundleversion\");\n+        }\n+\n+        if (connInstanceTO.getConnectorName() == null) {\n+            sce.getElements().add(\"connectorname\");\n+        }\n+\n+        if (connInstanceTO.getConfiguration() == null || connInstanceTO.getConfiguration().isEmpty()) {\n+            sce.getElements().add(\"configuration\");\n+        }\n+\n+        ConnInstance connInstance = entityFactory.newEntity(ConnInstance.class);\n+\n+        BeanUtils.copyProperties(connInstanceTO, connInstance, IGNORE_PROPERTIES);\n+        if (connInstanceTO.getLocation() != null) {\n+            connInstance.setLocation(connInstanceTO.getLocation());\n+        }\n+        if (connInstanceTO.getPoolConf() != null) {\n+            connInstance.setPoolConf(\n+                    ConnPoolConfUtil.getConnPoolConf(connInstanceTO.getPoolConf(), entityFactory.newConnPoolConf()));\n+        }\n+\n+        // Throw exception if there is at least one element set\n+        if (!sce.isEmpty()) {\n+            throw sce;\n+        }\n+\n+        return connInstance;\n+    }\n+\n+    public ConnInstance updateConnInstance(final long connInstanceId, final ConnInstanceTO connInstanceTO) {\n+        SyncopeClientException sce = SyncopeClientException.build(ClientExceptionType.RequiredValuesMissing);\n+\n+        if (connInstanceId == 0) {\n+            sce.getElements().add(\"connector id\");\n+        }\n+\n+        ConnInstance connInstance = connInstanceDAO.find(connInstanceId);\n+        connInstance.getCapabilities().clear();\n+        connInstance.getCapabilities().addAll(connInstanceTO.getCapabilities());\n+\n+        if (connInstanceTO.getLocation() != null) {\n+            connInstance.setLocation(connInstanceTO.getLocation());\n+        }\n+\n+        if (connInstanceTO.getBundleName() != null) {\n+            connInstance.setBundleName(connInstanceTO.getBundleName());\n+        }\n+\n+        if (connInstanceTO.getVersion() != null) {\n+            connInstance.setVersion(connInstanceTO.getVersion());\n+        }\n+\n+        if (connInstanceTO.getConnectorName() != null) {\n+            connInstance.setConnectorName(connInstanceTO.getConnectorName());\n+        }\n+\n+        if (connInstanceTO.getConfiguration() != null && !connInstanceTO.getConfiguration().isEmpty()) {\n+            connInstance.setConfiguration(connInstanceTO.getConfiguration());\n+        }\n+\n+        if (connInstanceTO.getDisplayName() != null) {\n+            connInstance.setDisplayName(connInstanceTO.getDisplayName());\n+        }\n+\n+        if (connInstanceTO.getConnRequestTimeout() != null) {\n+            connInstance.setConnRequestTimeout(connInstanceTO.getConnRequestTimeout());\n+        }\n+\n+        if (connInstanceTO.getPoolConf() == null) {\n+            connInstance.setPoolConf(null);\n+        } else {\n+            connInstance.setPoolConf(\n+                    ConnPoolConfUtil.getConnPoolConf(connInstanceTO.getPoolConf(), entityFactory.newConnPoolConf()));\n+        }\n+\n+        if (!sce.isEmpty()) {\n+            throw sce;\n+        }\n+\n+        return connInstance;\n+    }\n+\n+    public ConnConfPropSchema buildConnConfPropSchema(final ConfigurationProperty property) {\n+        ConnConfPropSchema connConfPropSchema = new ConnConfPropSchema();\n+\n+        connConfPropSchema.setName(property.getName());\n+        connConfPropSchema.setDisplayName(property.getDisplayName(property.getName()));\n+        connConfPropSchema.setHelpMessage(property.getHelpMessage(property.getName()));\n+        connConfPropSchema.setRequired(property.isRequired());\n+        connConfPropSchema.setType(property.getType().getName());\n+        connConfPropSchema.setOrder(((ConfigurationPropertyImpl) property).getOrder());\n+        connConfPropSchema.setConfidential(property.isConfidential());\n+\n+        if (property.getValue() != null) {\n+            if (property.getValue().getClass().isArray()) {\n+                connConfPropSchema.getDefaultValues().addAll(Arrays.asList((Object[]) property.getValue()));\n+            } else if (property.getValue() instanceof Collection<?>) {\n+                connConfPropSchema.getDefaultValues().addAll((Collection<?>) property.getValue());\n+            } else {\n+                connConfPropSchema.getDefaultValues().add(property.getValue());\n+            }\n+        }\n+\n+        return connConfPropSchema;\n+    }\n+\n+    public ConnInstanceTO getConnInstanceTO(final ConnInstance connInstance) {\n+        ConnInstanceTO connInstanceTO = new ConnInstanceTO();\n+        connInstanceTO.setKey(connInstance.getKey() == null ? 0L : connInstance.getKey());\n+\n+        // retrieve the ConfigurationProperties\n+        ConfigurationProperties properties = connIdBundleManager.getConfigurationProperties(\n+                connIdBundleManager.getConnectorInfo(connInstance.getLocation(),\n+                        connInstance.getBundleName(), connInstance.getVersion(), connInstance.getConnectorName()));\n+\n+        BeanUtils.copyProperties(connInstance, connInstanceTO, IGNORE_PROPERTIES);\n+\n+        final Map<String, ConnConfProperty> connInstanceToConfMap = connInstanceTO.getConfigurationMap();\n+\n+        for (String propName : properties.getPropertyNames()) {\n+            ConnConfPropSchema schema = buildConnConfPropSchema(properties.getProperty(propName));\n+\n+            ConnConfProperty property;\n+            if (connInstanceToConfMap.containsKey(propName)) {\n+                property = connInstanceToConfMap.get(propName);\n+            } else {\n+                property = new ConnConfProperty();\n+                connInstanceTO.getConfiguration().add(property);\n+            }\n+\n+            property.setSchema(schema);\n+        }\n+\n+        if (connInstance.getPoolConf() != null) {\n+            ConnPoolConfTO poolConf = new ConnPoolConfTO();\n+            BeanUtils.copyProperties(connInstance.getPoolConf(), poolConf);\n+            connInstanceTO.setPoolConf(poolConf);\n+        }\n+\n+        return connInstanceTO;\n+    }\n+}"},{"sha":"0ddb74ebefd683f7ccef337d0b481286f37fcebd","filename":"syncope620/server/logic/src/main/java/org/apache/syncope/server/logic/data/NotificationDataBinder.java","status":"added","additions":62,"deletions":0,"changes":62,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Fdata%2FNotificationDataBinder.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Fdata%2FNotificationDataBinder.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Fdata%2FNotificationDataBinder.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,62 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.server.logic.data;\n+\n+import org.apache.syncope.common.lib.to.NotificationTO;\n+import org.apache.syncope.persistence.api.entity.EntityFactory;\n+import org.apache.syncope.persistence.api.entity.Notification;\n+import org.apache.syncope.server.spring.BeanUtils;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Component;\n+\n+@Component\n+public class NotificationDataBinder {\n+\n+    private static final String[] IGNORE_PROPERTIES = { \"key\", \"about\", \"recipients\" };\n+\n+    @Autowired\n+    private EntityFactory entityFactory;\n+\n+    public NotificationTO getNotificationTO(final Notification notification) {\n+        NotificationTO result = new NotificationTO();\n+\n+        BeanUtils.copyProperties(notification, result, IGNORE_PROPERTIES);\n+\n+        result.setKey(notification.getKey());\n+        result.setUserAbout(notification.getUserAbout());\n+        result.setRoleAbout(notification.getRoleAbout());\n+        result.setRecipients(notification.getRecipients());\n+\n+        return result;\n+    }\n+\n+    public Notification create(final NotificationTO notificationTO) {\n+        Notification result = entityFactory.newEntity(Notification.class);\n+        update(result, notificationTO);\n+        return result;\n+    }\n+\n+    public void update(final Notification notification, final NotificationTO notificationTO) {\n+        BeanUtils.copyProperties(notificationTO, notification, IGNORE_PROPERTIES);\n+\n+        notification.setUserAbout(notificationTO.getUserAbout());\n+        notification.setRoleAbout(notificationTO.getRoleAbout());\n+        notification.setRecipients(notificationTO.getRecipients());\n+    }\n+}"},{"sha":"57877d2178ab09f10808853b9d5b1d9fcb3dfd00","filename":"syncope620/server/logic/src/main/java/org/apache/syncope/server/logic/data/PolicyDataBinder.java","status":"added","additions":186,"deletions":0,"changes":186,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Fdata%2FPolicyDataBinder.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Fdata%2FPolicyDataBinder.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Fdata%2FPolicyDataBinder.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,186 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.server.logic.data;\n+\n+import org.apache.syncope.common.lib.SyncopeClientException;\n+import org.apache.syncope.common.lib.to.AbstractPolicyTO;\n+import org.apache.syncope.common.lib.to.AccountPolicyTO;\n+import org.apache.syncope.common.lib.to.PasswordPolicyTO;\n+import org.apache.syncope.common.lib.to.SyncPolicyTO;\n+import org.apache.syncope.common.lib.types.AccountPolicySpec;\n+import org.apache.syncope.common.lib.types.ClientExceptionType;\n+import org.apache.syncope.common.lib.types.PasswordPolicySpec;\n+import org.apache.syncope.common.lib.types.SyncPolicySpec;\n+import org.apache.syncope.persistence.api.dao.ExternalResourceDAO;\n+import org.apache.syncope.persistence.api.dao.RoleDAO;\n+import org.apache.syncope.persistence.api.entity.AccountPolicy;\n+import org.apache.syncope.persistence.api.entity.EntityFactory;\n+import org.apache.syncope.persistence.api.entity.ExternalResource;\n+import org.apache.syncope.persistence.api.entity.PasswordPolicy;\n+import org.apache.syncope.persistence.api.entity.Policy;\n+import org.apache.syncope.persistence.api.entity.SyncPolicy;\n+import org.apache.syncope.persistence.api.entity.role.Role;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Component;\n+\n+@Component\n+public class PolicyDataBinder {\n+\n+    /**\n+     * Logger.\n+     */\n+    protected static final Logger LOG = LoggerFactory.getLogger(PolicyDataBinder.class);\n+\n+    @Autowired\n+    private ExternalResourceDAO resourceDAO;\n+\n+    @Autowired\n+    private RoleDAO roleDAO;\n+\n+    @Autowired\n+    private EntityFactory entityFactory;\n+\n+    /**\n+     * Get policy TO from policy bean.\n+     *\n+     * @param policy bean.\n+     * @return policy TO.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends AbstractPolicyTO> T getPolicyTO(final Policy policy) {\n+        final T policyTO;\n+\n+        switch (policy.getType()) {\n+            case GLOBAL_PASSWORD:\n+            case PASSWORD:\n+                policyTO = (T) new PasswordPolicyTO(policy.getType().isGlobal());\n+                ((PasswordPolicyTO) policyTO).setSpecification(policy.getSpecification(PasswordPolicySpec.class));\n+                break;\n+\n+            case GLOBAL_ACCOUNT:\n+            case ACCOUNT:\n+                policyTO = (T) new AccountPolicyTO(policy.getType().isGlobal());\n+                ((AccountPolicyTO) policyTO).setSpecification(policy.getSpecification(AccountPolicySpec.class));\n+                ((AccountPolicyTO) policyTO).getResources().addAll(((AccountPolicy) policy).getResourceNames());\n+                break;\n+\n+            case GLOBAL_SYNC:\n+            case SYNC:\n+            default:\n+                policyTO = (T) new SyncPolicyTO(policy.getType().isGlobal());\n+                ((SyncPolicyTO) policyTO).setSpecification(policy.getSpecification(SyncPolicySpec.class));\n+        }\n+\n+        policyTO.setId(policy.getKey());\n+        policyTO.setDescription(policy.getDescription());\n+\n+        for (ExternalResource resource : resourceDAO.findByPolicy(policy)) {\n+            policyTO.getUsedByResources().add(resource.getKey());\n+        }\n+        if (policy.getType().isGlobal()) {\n+            for (ExternalResource resource : resourceDAO.findWithoutPolicy(policy.getType())) {\n+                policyTO.getUsedByResources().add(resource.getKey());\n+            }\n+        }\n+        for (Role role : roleDAO.findByPolicy(policy)) {\n+            policyTO.getUsedByRoles().add(role.getKey());\n+        }\n+        if (policy.getType().isGlobal()) {\n+            for (Role role : roleDAO.findWithoutPolicy(policy.getType())) {\n+                policyTO.getUsedByRoles().add(role.getKey());\n+            }\n+        }\n+\n+        return policyTO;\n+    }\n+\n+    private ExternalResource getResource(final String resourceName) {\n+        ExternalResource resource = resourceDAO.find(resourceName);\n+        if (resource == null) {\n+            LOG.debug(\"Ignoring invalid resource {} \", resourceName);\n+        }\n+\n+        return resource;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends Policy> T getPolicy(T policy, final AbstractPolicyTO policyTO) {\n+        if (policy != null && policy.getType() != policyTO.getType()) {\n+            SyncopeClientException sce = SyncopeClientException.build(ClientExceptionType.InvalidPolicy);\n+            sce.getElements().add(String.format(\"Cannot update %s from %s\", policy.getType(), policyTO.getType()));\n+            throw sce;\n+        }\n+\n+        switch (policyTO.getType()) {\n+            case GLOBAL_PASSWORD:\n+            case PASSWORD:\n+                if (!(policyTO instanceof PasswordPolicyTO)) {\n+                    throw new ClassCastException(\"Expected \" + PasswordPolicyTO.class.getName()\n+                            + \", found \" + policyTO.getClass().getName());\n+                }\n+                if (policy == null) {\n+                    policy = (T) entityFactory.newPolicy(PasswordPolicy.class, policyTO.getType().isGlobal());\n+                }\n+                policy.setSpecification(((PasswordPolicyTO) policyTO).getSpecification());\n+                break;\n+\n+            case GLOBAL_ACCOUNT:\n+            case ACCOUNT:\n+                if (!(policyTO instanceof AccountPolicyTO)) {\n+                    throw new ClassCastException(\"Expected \" + AccountPolicyTO.class.getName()\n+                            + \", found \" + policyTO.getClass().getName());\n+                }\n+                if (policy == null) {\n+                    policy = (T) entityFactory.newPolicy(AccountPolicy.class, policyTO.getType().isGlobal());\n+                }\n+                policy.setSpecification(((AccountPolicyTO) policyTO).getSpecification());\n+\n+                if (((AccountPolicy) policy).getResources() != null\n+                        && !((AccountPolicy) policy).getResources().isEmpty()) {\n+                    ((AccountPolicy) policy).getResources().clear();\n+                }\n+                for (String resourceName : ((AccountPolicyTO) policyTO).getResources()) {\n+                    ExternalResource resource = getResource(resourceName);\n+\n+                    if (resource != null) {\n+                        ((AccountPolicy) policy).addResource(resource);\n+                    }\n+                }\n+                break;\n+\n+            case GLOBAL_SYNC:\n+            case SYNC:\n+            default:\n+                if (!(policyTO instanceof SyncPolicyTO)) {\n+                    throw new ClassCastException(\"Expected \" + SyncPolicyTO.class.getName()\n+                            + \", found \" + policyTO.getClass().getName());\n+                }\n+                if (policy == null) {\n+                    policy = (T) entityFactory.newPolicy(SyncPolicy.class, policyTO.getType().isGlobal());\n+                }\n+                policy.setSpecification(((SyncPolicyTO) policyTO).getSpecification());\n+        }\n+\n+        policy.setDescription(policyTO.getDescription());\n+\n+        return policy;\n+    }\n+}"},{"sha":"952de94341cd1b0dc018654c7408e3b78f02cf76","filename":"syncope620/server/logic/src/main/java/org/apache/syncope/server/logic/data/ReportDataBinder.java","status":"added","additions":175,"deletions":0,"changes":175,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Fdata%2FReportDataBinder.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Fdata%2FReportDataBinder.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Fdata%2FReportDataBinder.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,175 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.server.logic.data;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+import org.apache.syncope.common.lib.report.AbstractReportletConf;\n+import org.apache.syncope.common.lib.report.ReportletConf;\n+import org.apache.syncope.common.lib.to.ReportExecTO;\n+import org.apache.syncope.common.lib.to.ReportTO;\n+import org.apache.syncope.persistence.api.dao.ReportExecDAO;\n+import org.apache.syncope.persistence.api.entity.Report;\n+import org.apache.syncope.persistence.api.entity.ReportExec;\n+import org.apache.syncope.server.logic.init.ImplementationClassNamesLoader;\n+import org.apache.syncope.server.logic.report.Reportlet;\n+import org.apache.syncope.server.logic.init.JobInstanceLoader;\n+import org.apache.syncope.server.logic.report.ReportletConfClass;\n+import org.apache.syncope.server.spring.BeanUtils;\n+import org.quartz.Scheduler;\n+import org.quartz.SchedulerException;\n+import org.quartz.Trigger;\n+import org.quartz.TriggerKey;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.scheduling.quartz.SchedulerFactoryBean;\n+import org.springframework.stereotype.Component;\n+import org.springframework.util.ClassUtils;\n+\n+@Component\n+public class ReportDataBinder {\n+\n+    /**\n+     * Logger.\n+     */\n+    private static final Logger LOG = LoggerFactory.getLogger(ReportDataBinder.class);\n+\n+    private static final String[] IGNORE_REPORT_PROPERTIES = { \"key\", \"reportlets\", \"executions\" };\n+\n+    private static final String[] IGNORE_REPORT_EXECUTION_PROPERTIES = { \"key\", \"report\", \"execResult\" };\n+\n+    @Autowired\n+    private ReportExecDAO reportExecDAO;\n+\n+    @Autowired\n+    private SchedulerFactoryBean scheduler;\n+\n+    @Autowired\n+    private ImplementationClassNamesLoader classNamesLoader;\n+\n+    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+    public Set<Class<Reportlet>> getAllReportletClasses() {\n+        Set<Class<Reportlet>> reportletClasses = new HashSet<Class<Reportlet>>();\n+\n+        for (String className : classNamesLoader.getClassNames(ImplementationClassNamesLoader.Type.REPORTLET)) {\n+            try {\n+                Class reportletClass = ClassUtils.forName(className, ClassUtils.getDefaultClassLoader());\n+                reportletClasses.add(reportletClass);\n+            } catch (ClassNotFoundException e) {\n+                LOG.warn(\"Could not load class {}\", className);\n+            } catch (LinkageError e) {\n+                LOG.warn(\"Could not link class {}\", className);\n+            }\n+        }\n+        return reportletClasses;\n+    }\n+\n+    public Class<? extends ReportletConf> getReportletConfClass(final Class<Reportlet> reportletClass) {\n+        Class<? extends ReportletConf> result = null;\n+\n+        ReportletConfClass annotation = reportletClass.getAnnotation(ReportletConfClass.class);\n+        if (annotation != null) {\n+            result = annotation.value();\n+        }\n+\n+        return result;\n+    }\n+\n+    public Class<Reportlet> findReportletClassHavingConfClass(final Class<? extends ReportletConf> reportletConfClass) {\n+        Class<Reportlet> result = null;\n+        for (Class<Reportlet> reportletClass : getAllReportletClasses()) {\n+            Class<? extends ReportletConf> found = getReportletConfClass(reportletClass);\n+            if (found != null && found.equals(reportletConfClass)) {\n+                result = reportletClass;\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    public void getReport(final Report report, final ReportTO reportTO) {\n+        BeanUtils.copyProperties(reportTO, report, IGNORE_REPORT_PROPERTIES);\n+        report.getReportletConfs().clear();\n+        for (ReportletConf conf : reportTO.getReportletConfs()) {\n+            report.addReportletConf(conf);\n+        }\n+    }\n+\n+    public ReportTO getReportTO(final Report report) {\n+        ReportTO reportTO = new ReportTO();\n+        reportTO.setId(report.getKey());\n+        BeanUtils.copyProperties(report, reportTO, IGNORE_REPORT_PROPERTIES);\n+\n+        copyReportletConfs(report, reportTO);\n+\n+        ReportExec latestExec = reportExecDAO.findLatestStarted(report);\n+        reportTO.setLatestExecStatus(latestExec == null\n+                ? \"\"\n+                : latestExec.getStatus());\n+\n+        reportTO.setStartDate(latestExec == null\n+                ? null\n+                : latestExec.getStartDate());\n+\n+        reportTO.setEndDate(latestExec == null\n+                ? null\n+                : latestExec.getEndDate());\n+\n+        for (ReportExec reportExec : report.getExecs()) {\n+            reportTO.getExecutions().add(getReportExecTO(reportExec));\n+        }\n+\n+        String triggerName = JobInstanceLoader.getTriggerName(JobInstanceLoader.getJobName(report));\n+\n+        Trigger trigger;\n+        try {\n+            trigger = scheduler.getScheduler().getTrigger(new TriggerKey(triggerName, Scheduler.DEFAULT_GROUP));\n+        } catch (SchedulerException e) {\n+            LOG.warn(\"While trying to get to \" + triggerName, e);\n+            trigger = null;\n+        }\n+\n+        if (trigger != null) {\n+            reportTO.setLastExec(trigger.getPreviousFireTime());\n+            reportTO.setNextExec(trigger.getNextFireTime());\n+        }\n+\n+        return reportTO;\n+    }\n+\n+    private void copyReportletConfs(final Report report, final ReportTO reportTO) {\n+        reportTO.getReportletConfs().clear();\n+        for (ReportletConf reportletConf : report.getReportletConfs()) {\n+            reportTO.getReportletConfs().add((AbstractReportletConf) reportletConf);\n+        }\n+    }\n+\n+    public ReportExecTO getReportExecTO(final ReportExec execution) {\n+        ReportExecTO executionTO = new ReportExecTO();\n+        executionTO.setKey(execution.getKey());\n+        BeanUtils.copyProperties(execution, executionTO, IGNORE_REPORT_EXECUTION_PROPERTIES);\n+        if (execution.getKey() != null) {\n+            executionTO.setKey(execution.getKey());\n+        }\n+        executionTO.setReport(execution.getReport().getKey());\n+\n+        return executionTO;\n+    }\n+}"},{"sha":"b307eee3400763a04ced80e586d1a2b3c3ee8df0","filename":"syncope620/server/logic/src/main/java/org/apache/syncope/server/logic/data/ResourceDataBinder.java","status":"added","additions":389,"deletions":0,"changes":389,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Fdata%2FResourceDataBinder.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Fdata%2FResourceDataBinder.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Fdata%2FResourceDataBinder.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,389 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.server.logic.data;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.apache.commons.lang3.SerializationUtils;\n+import org.apache.syncope.common.lib.SyncopeClientCompositeException;\n+import org.apache.syncope.common.lib.SyncopeClientException;\n+import org.apache.syncope.common.lib.to.MappingItemTO;\n+import org.apache.syncope.common.lib.to.MappingTO;\n+import org.apache.syncope.common.lib.to.ResourceTO;\n+import org.apache.syncope.common.lib.types.ClientExceptionType;\n+import org.apache.syncope.common.lib.types.ConnConfProperty;\n+import org.apache.syncope.common.lib.types.IntMappingType;\n+import org.apache.syncope.persistence.api.dao.ConnInstanceDAO;\n+import org.apache.syncope.persistence.api.dao.NotFoundException;\n+import org.apache.syncope.persistence.api.dao.PolicyDAO;\n+import org.apache.syncope.persistence.api.entity.AccountPolicy;\n+import org.apache.syncope.persistence.api.entity.ConnInstance;\n+import org.apache.syncope.persistence.api.entity.EntityFactory;\n+import org.apache.syncope.persistence.api.entity.ExternalResource;\n+import org.apache.syncope.persistence.api.entity.Mapping;\n+import org.apache.syncope.persistence.api.entity.MappingItem;\n+import org.apache.syncope.persistence.api.entity.PasswordPolicy;\n+import org.apache.syncope.persistence.api.entity.SyncPolicy;\n+import org.apache.syncope.persistence.api.entity.role.RMapping;\n+import org.apache.syncope.persistence.api.entity.role.RMappingItem;\n+import org.apache.syncope.persistence.api.entity.user.UMapping;\n+import org.apache.syncope.persistence.api.entity.user.UMappingItem;\n+import org.apache.syncope.server.utils.jexl.JexlUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.apache.syncope.server.spring.BeanUtils;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Component;\n+\n+@Component\n+public class ResourceDataBinder {\n+\n+    /**\n+     * Logger.\n+     */\n+    private static final Logger LOG = LoggerFactory.getLogger(ResourceDataBinder.class);\n+\n+    private static final String[] MAPPINGITEM_IGNORE_PROPERTIES = { \"key\", \"mapping\" };\n+\n+    @Autowired\n+    private ConnInstanceDAO connInstanceDAO;\n+\n+    @Autowired\n+    private PolicyDAO policyDAO;\n+\n+    @Autowired\n+    private EntityFactory entityFactory;\n+\n+    public ExternalResource create(final ResourceTO resourceTO) {\n+        return update(entityFactory.newEntity(ExternalResource.class), resourceTO);\n+    }\n+\n+    public ExternalResource update(final ExternalResource resource, final ResourceTO resourceTO) {\n+        if (resourceTO == null) {\n+            return null;\n+        }\n+\n+        resource.setKey(resourceTO.getKey());\n+\n+        if (resourceTO.getConnectorId() != null) {\n+            ConnInstance connector = connInstanceDAO.find(resourceTO.getConnectorId());\n+            resource.setConnector(connector);\n+\n+            if (!connector.getResources().contains(resource)) {\n+                connector.addResource(resource);\n+            }\n+        }\n+\n+        resource.setEnforceMandatoryCondition(resourceTO.isEnforceMandatoryCondition());\n+\n+        resource.setPropagationPrimary(resourceTO.isPropagationPrimary());\n+\n+        resource.setPropagationPriority(resourceTO.getPropagationPriority());\n+\n+        resource.setRandomPwdIfNotProvided(resourceTO.isRandomPwdIfNotProvided());\n+\n+        resource.setPropagationMode(resourceTO.getPropagationMode());\n+\n+        if (resourceTO.getUmapping() == null || resourceTO.getUmapping().getItems().isEmpty()) {\n+            resource.setUmapping(null);\n+        } else {\n+            UMapping mapping = entityFactory.newEntity(UMapping.class);\n+            mapping.setResource(resource);\n+            resource.setUmapping(mapping);\n+            populateMapping(resourceTO.getUmapping(), mapping, entityFactory.newEntity(UMappingItem.class));\n+        }\n+        if (resourceTO.getRmapping() == null || resourceTO.getRmapping().getItems().isEmpty()) {\n+            resource.setRmapping(null);\n+        } else {\n+            RMapping mapping = entityFactory.newEntity(RMapping.class);\n+            mapping.setResource(resource);\n+            resource.setRmapping(mapping);\n+            populateMapping(resourceTO.getRmapping(), mapping, entityFactory.newEntity(RMappingItem.class));\n+        }\n+\n+        resource.setCreateTraceLevel(resourceTO.getCreateTraceLevel());\n+        resource.setUpdateTraceLevel(resourceTO.getUpdateTraceLevel());\n+        resource.setDeleteTraceLevel(resourceTO.getDeleteTraceLevel());\n+        resource.setSyncTraceLevel(resourceTO.getSyncTraceLevel());\n+\n+        resource.setPasswordPolicy(resourceTO.getPasswordPolicy() == null\n+                ? null : (PasswordPolicy) policyDAO.find(resourceTO.getPasswordPolicy()));\n+\n+        resource.setAccountPolicy(resourceTO.getAccountPolicy() == null\n+                ? null : (AccountPolicy) policyDAO.find(resourceTO.getAccountPolicy()));\n+\n+        resource.setSyncPolicy(resourceTO.getSyncPolicy() == null\n+                ? null : (SyncPolicy) policyDAO.find(resourceTO.getSyncPolicy()));\n+\n+        resource.setConnInstanceConfiguration(new HashSet<>(resourceTO.getConnConfProperties()));\n+\n+        if (resourceTO.getUsyncToken() == null) {\n+            resource.setUsyncToken(null);\n+        }\n+        if (resourceTO.getRsyncToken() == null) {\n+            resource.setRsyncToken(null);\n+        }\n+\n+        resource.getPropagationActionsClassNames().clear();\n+        resource.getPropagationActionsClassNames().addAll(resourceTO.getPropagationActionsClassNames());\n+\n+        return resource;\n+    }\n+\n+    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+    private void populateMapping(final MappingTO mappingTO, final Mapping mapping, final MappingItem prototype) {\n+        mapping.setAccountLink(mappingTO.getAccountLink());\n+\n+        for (MappingItem item : getMappingItems(mappingTO.getItems(), prototype)) {\n+            item.setMapping(mapping);\n+            if (item.isAccountid()) {\n+                mapping.setAccountIdItem(item);\n+            } else if (item.isPassword()) {\n+                ((UMapping) mapping).setPasswordItem((UMappingItem) item);\n+            } else {\n+                mapping.addItem(item);\n+            }\n+        }\n+    }\n+\n+    private Set<MappingItem> getMappingItems(final Collection<MappingItemTO> itemTOs, final MappingItem prototype) {\n+        Set<MappingItem> items = new HashSet<>(itemTOs.size());\n+        for (MappingItemTO itemTO : itemTOs) {\n+            items.add(getMappingItem(itemTO, prototype));\n+        }\n+\n+        return items;\n+    }\n+\n+    private MappingItem getMappingItem(final MappingItemTO itemTO, final MappingItem prototype) {\n+        if (itemTO == null || itemTO.getIntMappingType() == null) {\n+            LOG.error(\"Null mappingTO provided\");\n+            return null;\n+        }\n+\n+        SyncopeClientCompositeException scce = SyncopeClientException.buildComposite();\n+\n+        SyncopeClientException requiredValuesMissing = SyncopeClientException.build(\n+                ClientExceptionType.RequiredValuesMissing);\n+\n+        if (itemTO.getIntAttrName() == null) {\n+            if (IntMappingType.getEmbedded().contains(itemTO.getIntMappingType())) {\n+                itemTO.setIntAttrName(itemTO.getIntMappingType().toString());\n+            } else {\n+                requiredValuesMissing.getElements().add(\"intAttrName\");\n+            }\n+        }\n+\n+        // Throw composite exception if there is at least one element set\n+        // in the composing exceptions\n+        if (!requiredValuesMissing.isEmpty()) {\n+            scce.addException(requiredValuesMissing);\n+        }\n+\n+        // no mandatory condition implies mandatory condition false\n+        if (!JexlUtil.isExpressionValid(itemTO.getMandatoryCondition() == null\n+                ? \"false\" : itemTO.getMandatoryCondition())) {\n+\n+            SyncopeClientException invalidMandatoryCondition = SyncopeClientException.build(\n+                    ClientExceptionType.InvalidValues);\n+\n+            invalidMandatoryCondition.getElements().add(itemTO.getMandatoryCondition());\n+\n+            scce.addException(invalidMandatoryCondition);\n+        }\n+\n+        if (scce.hasExceptions()) {\n+            throw scce;\n+        }\n+\n+        MappingItem item = SerializationUtils.clone(prototype);\n+        BeanUtils.copyProperties(itemTO, item, MAPPINGITEM_IGNORE_PROPERTIES);\n+        return item;\n+    }\n+\n+    public ConnInstance getConnInstance(final ExternalResource resource) {\n+        final ConnInstance connInstanceClone = SerializationUtils.clone(resource.getConnector());\n+        return getConnInstance(connInstanceClone, resource.getConnInstanceConfiguration());\n+    }\n+\n+    public ConnInstance getConnInstance(final ResourceTO resourceTO) {\n+        ConnInstance connInstance = connInstanceDAO.find(resourceTO.getConnectorId());\n+        if (connInstance == null) {\n+            throw new NotFoundException(\"Connector '\" + resourceTO.getConnectorId() + \"'\");\n+        }\n+\n+        final ConnInstance connInstanceClone = SerializationUtils.clone(connInstance);\n+        return getConnInstance(connInstanceClone, resourceTO.getConnConfProperties());\n+    }\n+\n+    private ConnInstance getConnInstance(final ConnInstance connInstance, final Set<ConnConfProperty> overridden) {\n+        final Set<ConnConfProperty> configuration = new HashSet<>();\n+        final Map<String, ConnConfProperty> overridable = new HashMap<>();\n+\n+        // add not overridable properties\n+        for (ConnConfProperty prop : connInstance.getConfiguration()) {\n+            if (prop.isOverridable()) {\n+                overridable.put(prop.getSchema().getName(), prop);\n+            } else {\n+                configuration.add(prop);\n+            }\n+        }\n+\n+        // add overridden properties\n+        for (ConnConfProperty prop : overridden) {\n+            if (overridable.containsKey(prop.getSchema().getName()) && !prop.getValues().isEmpty()) {\n+                configuration.add(prop);\n+                overridable.remove(prop.getSchema().getName());\n+            }\n+        }\n+\n+        // add overridable properties not overridden\n+        configuration.addAll(overridable.values());\n+\n+        connInstance.setConfiguration(configuration);\n+\n+        return connInstance;\n+    }\n+\n+    public List<ResourceTO> getResourceTOs(final Collection<? extends ExternalResource> resources) {\n+        List<ResourceTO> resourceTOs = new ArrayList<>();\n+        for (ExternalResource resource : resources) {\n+            resourceTOs.add(getResourceTO(resource));\n+        }\n+\n+        return resourceTOs;\n+    }\n+\n+    public ResourceTO getResourceTO(final ExternalResource resource) {\n+        if (resource == null) {\n+            return null;\n+        }\n+\n+        ResourceTO resourceTO = new ResourceTO();\n+\n+        // set sys info\n+        resourceTO.setCreator(resource.getCreator());\n+        resourceTO.setCreationDate(resource.getCreationDate());\n+        resourceTO.setLastModifier(resource.getLastModifier());\n+        resourceTO.setLastChangeDate(resource.getLastChangeDate());\n+\n+        // set the resource name\n+        resourceTO.setKey(resource.getKey());\n+\n+        // set the connector instance\n+        ConnInstance connector = resource.getConnector();\n+\n+        resourceTO.setConnectorId(connector == null ? null : connector.getKey());\n+        resourceTO.setConnectorDisplayName(connector == null ? null : connector.getDisplayName());\n+\n+        // set the mappings\n+        if (resource.getUmapping() != null) {\n+            MappingTO mappingTO = new MappingTO();\n+            resourceTO.setUmapping(mappingTO);\n+            populateMappingTO(resource.getUmapping(), mappingTO);\n+        }\n+        if (resource.getRmapping() != null) {\n+            MappingTO mappingTO = new MappingTO();\n+            resourceTO.setRmapping(mappingTO);\n+            populateMappingTO(resource.getRmapping(), mappingTO);\n+        }\n+\n+        resourceTO.setEnforceMandatoryCondition(resource.isEnforceMandatoryCondition());\n+\n+        resourceTO.setPropagationPrimary(resource.isPropagationPrimary());\n+\n+        resourceTO.setPropagationPriority(resource.getPropagationPriority());\n+\n+        resourceTO.setRandomPwdIfNotProvided(resource.isRandomPwdIfNotProvided());\n+\n+        resourceTO.setPropagationMode(resource.getPropagationMode());\n+\n+        resourceTO.setCreateTraceLevel(resource.getCreateTraceLevel());\n+        resourceTO.setUpdateTraceLevel(resource.getUpdateTraceLevel());\n+        resourceTO.setDeleteTraceLevel(resource.getDeleteTraceLevel());\n+        resourceTO.setSyncTraceLevel(resource.getSyncTraceLevel());\n+\n+        resourceTO.setPasswordPolicy(resource.getPasswordPolicy() == null\n+                ? null : resource.getPasswordPolicy().getKey());\n+\n+        resourceTO.setAccountPolicy(resource.getAccountPolicy() == null\n+                ? null : resource.getAccountPolicy().getKey());\n+\n+        resourceTO.setSyncPolicy(resource.getSyncPolicy() == null\n+                ? null : resource.getSyncPolicy().getKey());\n+\n+        resourceTO.getConnConfProperties().addAll(resource.getConnInstanceConfiguration());\n+\n+        resourceTO.setUsyncToken(resource.getSerializedUSyncToken());\n+        resourceTO.setRsyncToken(resource.getSerializedRSyncToken());\n+\n+        resourceTO.getPropagationActionsClassNames().addAll(resource.getPropagationActionsClassNames());\n+\n+        return resourceTO;\n+    }\n+\n+    private void populateMappingTO(final Mapping<?> mapping, final MappingTO mappingTO) {\n+        mappingTO.setAccountLink(mapping.getAccountLink());\n+\n+        for (MappingItemTO itemTO : getMappingItemTOs(mapping.getItems())) {\n+            if (itemTO.isAccountid()) {\n+                mappingTO.setAccountIdItem(itemTO);\n+            } else if (itemTO.isPassword()) {\n+                mappingTO.setPasswordItem(itemTO);\n+            } else {\n+                mappingTO.addItem(itemTO);\n+            }\n+        }\n+    }\n+\n+    private Set<MappingItemTO> getMappingItemTOs(final Collection<? extends MappingItem> items) {\n+        Set<MappingItemTO> mappingTOs = new HashSet<>();\n+        for (MappingItem item : items) {\n+            LOG.debug(\"Asking for TO for {}\", item);\n+            mappingTOs.add(getMappingItemTO(item));\n+        }\n+\n+        LOG.debug(\"Collected TOs: {}\", mappingTOs);\n+\n+        return mappingTOs;\n+    }\n+\n+    private MappingItemTO getMappingItemTO(final MappingItem item) {\n+        if (item == null) {\n+            LOG.error(\"Provided null mapping\");\n+\n+            return null;\n+        }\n+\n+        MappingItemTO itemTO = new MappingItemTO();\n+\n+        BeanUtils.copyProperties(item, itemTO, MAPPINGITEM_IGNORE_PROPERTIES);\n+\n+        itemTO.setKey(item.getKey());\n+\n+        LOG.debug(\"Obtained SchemaMappingTO {}\", itemTO);\n+\n+        return itemTO;\n+    }\n+}"},{"sha":"d8dc0df3fd0511f65bcb47c3cca8ccf28b3c452c","filename":"syncope620/server/logic/src/main/java/org/apache/syncope/server/logic/data/RoleDataBinder.java","status":"added","additions":429,"deletions":0,"changes":429,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Fdata%2FRoleDataBinder.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Fdata%2FRoleDataBinder.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Fdata%2FRoleDataBinder.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,429 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.server.logic.data;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import org.apache.syncope.common.lib.SyncopeClientCompositeException;\n+import org.apache.syncope.common.lib.SyncopeClientException;\n+import org.apache.syncope.common.lib.mod.RoleMod;\n+import org.apache.syncope.common.lib.to.RoleTO;\n+import org.apache.syncope.common.lib.types.AttributableType;\n+import org.apache.syncope.common.lib.types.ClientExceptionType;\n+import org.apache.syncope.common.lib.types.ResourceOperation;\n+import org.apache.syncope.persistence.api.dao.EntitlementDAO;\n+import org.apache.syncope.persistence.api.dao.RoleDAO;\n+import org.apache.syncope.persistence.api.entity.AccountPolicy;\n+import org.apache.syncope.persistence.api.entity.AttrTemplate;\n+import org.apache.syncope.persistence.api.entity.Entitlement;\n+import org.apache.syncope.persistence.api.entity.ExternalResource;\n+import org.apache.syncope.persistence.api.entity.PasswordPolicy;\n+import org.apache.syncope.persistence.api.entity.Schema;\n+import org.apache.syncope.persistence.api.entity.membership.MDerAttrTemplate;\n+import org.apache.syncope.persistence.api.entity.membership.MDerSchema;\n+import org.apache.syncope.persistence.api.entity.membership.MPlainAttrTemplate;\n+import org.apache.syncope.persistence.api.entity.membership.MPlainSchema;\n+import org.apache.syncope.persistence.api.entity.membership.MVirAttrTemplate;\n+import org.apache.syncope.persistence.api.entity.membership.MVirSchema;\n+import org.apache.syncope.persistence.api.entity.membership.Membership;\n+import org.apache.syncope.persistence.api.entity.role.RDerAttr;\n+import org.apache.syncope.persistence.api.entity.role.RDerAttrTemplate;\n+import org.apache.syncope.persistence.api.entity.role.RDerSchema;\n+import org.apache.syncope.persistence.api.entity.role.RPlainAttr;\n+import org.apache.syncope.persistence.api.entity.role.RPlainAttrTemplate;\n+import org.apache.syncope.persistence.api.entity.role.RPlainSchema;\n+import org.apache.syncope.persistence.api.entity.role.RVirAttr;\n+import org.apache.syncope.persistence.api.entity.role.RVirAttrTemplate;\n+import org.apache.syncope.persistence.api.entity.role.RVirSchema;\n+import org.apache.syncope.persistence.api.entity.role.Role;\n+import org.apache.syncope.persistence.api.entity.user.User;\n+import org.apache.syncope.provisioning.api.propagation.PropagationByResource;\n+import org.apache.syncope.server.utils.ConnObjectUtil;\n+import org.apache.syncope.provisioning.api.WorkflowResult;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Component;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+@Component\n+@Transactional(rollbackFor = { Throwable.class })\n+public class RoleDataBinder extends AbstractAttributableDataBinder {\n+\n+    @Autowired\n+    private RoleDAO roleDAO;\n+\n+    @Autowired\n+    private ConnObjectUtil connObjectUtil;\n+\n+    @Autowired\n+    private EntitlementDAO entitlementDAO;\n+\n+    @Transactional(readOnly = true)\n+    public List<WorkflowResult<Long>> getUsersOnResourcesOnlyBecauseOfRole(final Long roleId) {\n+        Role role = roleDAO.authFetchRole(roleId);\n+\n+        List<WorkflowResult<Long>> result = new ArrayList<WorkflowResult<Long>>();\n+\n+        for (Membership membership : roleDAO.findMemberships(role)) {\n+            User user = membership.getUser();\n+\n+            PropagationByResource propByRes = new PropagationByResource();\n+            for (ExternalResource resource : role.getResources()) {\n+                if (!user.getOwnResources().contains(resource)) {\n+                    propByRes.add(ResourceOperation.DELETE, resource.getKey());\n+                }\n+\n+                if (!propByRes.isEmpty()) {\n+                    result.add(new WorkflowResult<Long>(user.getKey(), propByRes, Collections.<String>emptySet()));\n+                }\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    private <T extends AttrTemplate<S>, S extends Schema> void setAttrTemplates(\n+            final Role role, final List<String> schemaNames,\n+            final Class<T> templateClass, final Class<S> schemaClass) {\n+\n+        List<T> toRemove = new ArrayList<T>();\n+        for (T template : role.getAttrTemplates(templateClass)) {\n+            if (!schemaNames.contains(template.getSchema().getKey())) {\n+                toRemove.add(template);\n+            }\n+        }\n+        role.getAttrTemplates(templateClass).removeAll(toRemove);\n+\n+        for (String schemaName : schemaNames) {\n+            if (role.getAttrTemplate(templateClass, schemaName) == null) {\n+                S schema = getSchema(schemaName, schemaClass);\n+                if (schema != null) {\n+                    try {\n+                        T template = templateClass.newInstance();\n+                        template.setSchema(schema);\n+                        template.setOwner(role);\n+                        role.getAttrTemplates(templateClass).add(template);\n+                    } catch (Exception e) {\n+                        LOG.error(\"Could not create template for {}\", templateClass, e);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    public Role create(final Role role, final RoleTO roleTO) {\n+        role.setInheritOwner(roleTO.isInheritOwner());\n+\n+        role.setInheritPlainAttrs(roleTO.isInheritAttrs());\n+        role.setInheritDerAttrs(roleTO.isInheritDerAttrs());\n+        role.setInheritVirAttrs(roleTO.isInheritVirAttrs());\n+\n+        role.setInheritTemplates(roleTO.isInheritTemplates());\n+\n+        role.setInheritPasswordPolicy(roleTO.isInheritPasswordPolicy());\n+        role.setInheritAccountPolicy(roleTO.isInheritAccountPolicy());\n+\n+        SyncopeClientCompositeException scce = SyncopeClientException.buildComposite();\n+\n+        // name and parent\n+        SyncopeClientException invalidRoles = SyncopeClientException.build(ClientExceptionType.InvalidRoles);\n+        if (roleTO.getName() == null) {\n+            LOG.error(\"No name specified for this role\");\n+\n+            invalidRoles.getElements().add(\"No name specified for this role\");\n+        } else {\n+            role.setName(roleTO.getName());\n+        }\n+        Long parentRoleKey = null;\n+        if (roleTO.getParent() != 0) {\n+            Role parentRole = roleDAO.find(roleTO.getParent());\n+            if (parentRole == null) {\n+                LOG.error(\"Could not find role with id \" + roleTO.getParent());\n+\n+                invalidRoles.getElements().add(String.valueOf(roleTO.getParent()));\n+                scce.addException(invalidRoles);\n+            } else {\n+                role.setParent(parentRole);\n+                parentRoleKey = role.getParent().getKey();\n+            }\n+        }\n+\n+        Role otherRole = roleDAO.find(roleTO.getName(), parentRoleKey);\n+        if (otherRole != null) {\n+            LOG.error(\"Another role exists with the same name \" + \"and the same parent role: \" + otherRole);\n+\n+            invalidRoles.getElements().add(roleTO.getName());\n+        }\n+\n+        // attribute templates\n+        setAttrTemplates(role, roleTO.getRAttrTemplates(), RPlainAttrTemplate.class, RPlainSchema.class);\n+        setAttrTemplates(role, roleTO.getRDerAttrTemplates(), RDerAttrTemplate.class, RDerSchema.class);\n+        setAttrTemplates(role, roleTO.getRVirAttrTemplates(), RVirAttrTemplate.class, RVirSchema.class);\n+        setAttrTemplates(role, roleTO.getMAttrTemplates(), MPlainAttrTemplate.class, MPlainSchema.class);\n+        setAttrTemplates(role, roleTO.getMDerAttrTemplates(), MDerAttrTemplate.class, MDerSchema.class);\n+        setAttrTemplates(role, roleTO.getMVirAttrTemplates(), MVirAttrTemplate.class, MVirSchema.class);\n+\n+        // attributes, derived attributes, virtual attributes and resources\n+        fill(role, roleTO, attrUtilFactory.getInstance(AttributableType.ROLE), scce);\n+\n+        // entitlements\n+        for (String entitlementName : roleTO.getEntitlements()) {\n+            Entitlement entitlement = entitlementDAO.find(entitlementName);\n+            if (entitlement == null) {\n+                LOG.warn(\"Ignoring invalid entitlement {}\", entitlementName);\n+            } else {\n+                role.addEntitlement(entitlement);\n+            }\n+        }\n+\n+        // owner\n+        if (roleTO.getUserOwner() != null) {\n+            User owner = userDAO.find(roleTO.getUserOwner());\n+            if (owner == null) {\n+                LOG.warn(\"Ignoring invalid user specified as owner: {}\", roleTO.getUserOwner());\n+            } else {\n+                role.setUserOwner(owner);\n+            }\n+        }\n+        if (roleTO.getRoleOwner() != null) {\n+            Role owner = roleDAO.find(roleTO.getRoleOwner());\n+            if (owner == null) {\n+                LOG.warn(\"Ignoring invalid role specified as owner: {}\", roleTO.getRoleOwner());\n+            } else {\n+                role.setRoleOwner(owner);\n+            }\n+        }\n+\n+        // policies\n+        if (roleTO.getPasswordPolicy() != null) {\n+            role.setPasswordPolicy((PasswordPolicy) policyDAO.find(roleTO.getPasswordPolicy()));\n+        }\n+        if (roleTO.getAccountPolicy() != null) {\n+            role.setAccountPolicy((AccountPolicy) policyDAO.find(roleTO.getAccountPolicy()));\n+        }\n+\n+        return role;\n+    }\n+\n+    public PropagationByResource update(final Role role, final RoleMod roleMod) {\n+        PropagationByResource propByRes = new PropagationByResource();\n+\n+        SyncopeClientCompositeException scce = SyncopeClientException.buildComposite();\n+\n+        Set<String> currentResources = role.getResourceNames();\n+\n+        // name\n+        SyncopeClientException invalidRoles = SyncopeClientException.build(ClientExceptionType.InvalidRoles);\n+        if (roleMod.getName() != null) {\n+            Role otherRole = roleDAO.find(roleMod.getName(),\n+                    role.getParent() == null ? null : role.getParent().getKey());\n+            if (otherRole == null || role.equals(otherRole)) {\n+                if (!roleMod.getName().equals(role.getName())) {\n+                    propByRes.addAll(ResourceOperation.UPDATE, currentResources);\n+                    for (String resource : currentResources) {\n+                        propByRes.addOldAccountId(resource, role.getName());\n+                    }\n+\n+                    role.setName(roleMod.getName());\n+                }\n+            } else {\n+                LOG.error(\"Another role exists with the same name and the same parent role: \" + otherRole);\n+\n+                invalidRoles.getElements().add(roleMod.getName());\n+                scce.addException(invalidRoles);\n+            }\n+        }\n+\n+        if (roleMod.getInheritOwner() != null) {\n+            role.setInheritOwner(roleMod.getInheritOwner());\n+        }\n+\n+        if (roleMod.getInheritTemplates() != null) {\n+            role.setInheritTemplates(roleMod.getInheritTemplates());\n+        }\n+\n+        if (roleMod.getInheritPlainAttrs() != null) {\n+            role.setInheritPlainAttrs(roleMod.getInheritPlainAttrs());\n+        }\n+        if (roleMod.getInheritDerAttrs() != null) {\n+            role.setInheritDerAttrs(roleMod.getInheritDerAttrs());\n+        }\n+        if (roleMod.getInheritVirAttrs() != null) {\n+            role.setInheritVirAttrs(roleMod.getInheritVirAttrs());\n+        }\n+\n+        if (roleMod.getInheritPasswordPolicy() != null) {\n+            role.setInheritPasswordPolicy(roleMod.getInheritPasswordPolicy());\n+        }\n+        if (roleMod.getInheritAccountPolicy() != null) {\n+            role.setInheritAccountPolicy(roleMod.getInheritAccountPolicy());\n+        }\n+\n+        // entitlements\n+        if (roleMod.isModEntitlements()) {\n+            role.getEntitlements().clear();\n+            for (String entitlementName : roleMod.getEntitlements()) {\n+                Entitlement entitlement = entitlementDAO.find(entitlementName);\n+                if (entitlement == null) {\n+                    LOG.warn(\"Ignoring invalid entitlement {}\", entitlementName);\n+                } else {\n+                    role.addEntitlement(entitlement);\n+                }\n+            }\n+        }\n+\n+        // attribute templates\n+        if (roleMod.isModRAttrTemplates()) {\n+            setAttrTemplates(role, roleMod.getRPlainAttrTemplates(), RPlainAttrTemplate.class, RPlainSchema.class);\n+        }\n+        if (roleMod.isModRDerAttrTemplates()) {\n+            setAttrTemplates(role, roleMod.getRDerAttrTemplates(), RDerAttrTemplate.class, RDerSchema.class);\n+        }\n+        if (roleMod.isModRVirAttrTemplates()) {\n+            setAttrTemplates(role, roleMod.getRVirAttrTemplates(), RVirAttrTemplate.class, RVirSchema.class);\n+        }\n+        if (roleMod.isModMAttrTemplates()) {\n+            setAttrTemplates(role, roleMod.getMPlainAttrTemplates(), MPlainAttrTemplate.class, MPlainSchema.class);\n+        }\n+        if (roleMod.isModMDerAttrTemplates()) {\n+            setAttrTemplates(role, roleMod.getMDerAttrTemplates(), MDerAttrTemplate.class, MDerSchema.class);\n+        }\n+        if (roleMod.isModMVirAttrTemplates()) {\n+            setAttrTemplates(role, roleMod.getMVirAttrTemplates(), MVirAttrTemplate.class, MVirSchema.class);\n+        }\n+\n+        // policies\n+        if (roleMod.getPasswordPolicy() != null) {\n+            role.setPasswordPolicy(roleMod.getPasswordPolicy().getKey() == null\n+                    ? null\n+                    : (PasswordPolicy) policyDAO.find(roleMod.getPasswordPolicy().getKey()));\n+        }\n+        if (roleMod.getAccountPolicy() != null) {\n+            role.setAccountPolicy(roleMod.getAccountPolicy().getKey() == null\n+                    ? null\n+                    : (AccountPolicy) policyDAO.find(roleMod.getAccountPolicy().getKey()));\n+        }\n+\n+        // owner\n+        if (roleMod.getUserOwner() != null) {\n+            role.setUserOwner(roleMod.getUserOwner().getKey() == null\n+                    ? null\n+                    : userDAO.find(roleMod.getUserOwner().getKey()));\n+        }\n+        if (roleMod.getRoleOwner() != null) {\n+            role.setRoleOwner(roleMod.getRoleOwner().getKey() == null\n+                    ? null\n+                    : roleDAO.find(roleMod.getRoleOwner().getKey()));\n+        }\n+\n+        // attributes, derived attributes, virtual attributes and resources\n+        propByRes.merge(fill(role, roleMod, attrUtilFactory.getInstance(AttributableType.ROLE), scce));\n+\n+        return propByRes;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Transactional(readOnly = true)\n+    public RoleTO getRoleTO(final Role role) {\n+        connObjectUtil.retrieveVirAttrValues(role, attrUtilFactory.getInstance(AttributableType.ROLE));\n+\n+        RoleTO roleTO = new RoleTO();\n+\n+        // set sys info\n+        roleTO.setCreator(role.getCreator());\n+        roleTO.setCreationDate(role.getCreationDate());\n+        roleTO.setLastModifier(role.getLastModifier());\n+        roleTO.setLastChangeDate(role.getLastChangeDate());\n+\n+        roleTO.setKey(role.getKey());\n+        roleTO.setName(role.getName());\n+\n+        roleTO.setInheritOwner(role.isInheritOwner());\n+\n+        roleTO.setInheritTemplates(role.isInheritTemplates());\n+\n+        roleTO.setInheritAttrs(role.isInheritPlainAttrs());\n+        roleTO.setInheritDerAttrs(role.isInheritDerAttrs());\n+        roleTO.setInheritVirAttrs(role.isInheritVirAttrs());\n+\n+        roleTO.setInheritPasswordPolicy(role.isInheritPasswordPolicy());\n+        roleTO.setInheritAccountPolicy(role.isInheritAccountPolicy());\n+\n+        if (role.getParent() != null) {\n+            roleTO.setParent(role.getParent().getKey());\n+        }\n+\n+        if (role.getUserOwner() != null) {\n+            roleTO.setUserOwner(role.getUserOwner().getKey());\n+        }\n+        if (role.getRoleOwner() != null) {\n+            roleTO.setRoleOwner(role.getRoleOwner().getKey());\n+        }\n+\n+        // -------------------------\n+        // Retrieve all [derived/virtual] attributes (inherited and not)\n+        // -------------------------        \n+        final List<? extends RPlainAttr> allAttributes = role.findLastInheritedAncestorPlainAttrs();\n+\n+        final List<? extends RDerAttr> allDerAttributes = role.findLastInheritedAncestorDerAttrs();\n+\n+        final List<? extends RVirAttr> allVirAttributes = role.findLastInheritedAncestorVirAttrs();\n+        // -------------------------\n+\n+        fillTO(roleTO, allAttributes, allDerAttributes, allVirAttributes, role.getResources());\n+\n+        for (Entitlement entitlement : role.getEntitlements()) {\n+            roleTO.getEntitlements().add(entitlement.getKey());\n+        }\n+\n+        for (RPlainAttrTemplate template : role.findInheritedTemplates(RPlainAttrTemplate.class)) {\n+            roleTO.getRAttrTemplates().add(template.getSchema().getKey());\n+        }\n+        for (RDerAttrTemplate template : role.findInheritedTemplates(RDerAttrTemplate.class)) {\n+            roleTO.getRDerAttrTemplates().add(template.getSchema().getKey());\n+        }\n+        for (RVirAttrTemplate template : role.findInheritedTemplates(RVirAttrTemplate.class)) {\n+            roleTO.getRVirAttrTemplates().add(template.getSchema().getKey());\n+        }\n+        for (MPlainAttrTemplate template : role.findInheritedTemplates(MPlainAttrTemplate.class)) {\n+            roleTO.getMAttrTemplates().add(template.getSchema().getKey());\n+        }\n+        for (MDerAttrTemplate template : role.findInheritedTemplates(MDerAttrTemplate.class)) {\n+            roleTO.getMDerAttrTemplates().add(template.getSchema().getKey());\n+        }\n+        for (MVirAttrTemplate template : role.findInheritedTemplates(MVirAttrTemplate.class)) {\n+            roleTO.getMVirAttrTemplates().add(template.getSchema().getKey());\n+        }\n+\n+        roleTO.setPasswordPolicy(role.getPasswordPolicy() == null\n+                ? null\n+                : role.getPasswordPolicy().getKey());\n+        roleTO.setAccountPolicy(role.getAccountPolicy() == null\n+                ? null\n+                : role.getAccountPolicy().getKey());\n+\n+        return roleTO;\n+    }\n+\n+    @Transactional(readOnly = true)\n+    public RoleTO getRoleTO(final Long key) {\n+        return getRoleTO(roleDAO.authFetchRole(key));\n+    }\n+}"},{"sha":"79cb4a59757899d71b8abe74aafc1e80eb9503f3","filename":"syncope620/server/logic/src/main/java/org/apache/syncope/server/logic/data/SchemaDataBinder.java","status":"added","additions":163,"deletions":0,"changes":163,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Fdata%2FSchemaDataBinder.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Fdata%2FSchemaDataBinder.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Fdata%2FSchemaDataBinder.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,163 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.server.logic.data;\n+\n+import java.util.List;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.syncope.common.lib.SyncopeClientCompositeException;\n+import org.apache.syncope.common.lib.SyncopeClientException;\n+import org.apache.syncope.common.lib.to.DerSchemaTO;\n+import org.apache.syncope.common.lib.to.PlainSchemaTO;\n+import org.apache.syncope.common.lib.to.VirSchemaTO;\n+import org.apache.syncope.common.lib.types.ClientExceptionType;\n+import org.apache.syncope.persistence.api.dao.PlainSchemaDAO;\n+import org.apache.syncope.persistence.api.entity.AttributableUtil;\n+import org.apache.syncope.persistence.api.entity.DerSchema;\n+import org.apache.syncope.persistence.api.entity.PlainAttr;\n+import org.apache.syncope.persistence.api.entity.PlainSchema;\n+import org.apache.syncope.persistence.api.entity.VirSchema;\n+import org.apache.syncope.server.spring.BeanUtils;\n+import org.apache.syncope.server.utils.jexl.JexlUtil;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Component;\n+\n+@Component\n+public class SchemaDataBinder {\n+\n+    @Autowired\n+    private PlainSchemaDAO schemaDAO;\n+\n+    // --------------- PLAIN -----------------\n+    private <T extends PlainSchema> void fill(final T schema, final PlainSchemaTO schemaTO) {\n+        if (!JexlUtil.isExpressionValid(schemaTO.getMandatoryCondition())) {\n+            SyncopeClientException sce = SyncopeClientException.build(ClientExceptionType.InvalidValues);\n+            sce.getElements().add(schemaTO.getMandatoryCondition());\n+            throw sce;\n+        }\n+\n+        BeanUtils.copyProperties(schemaTO, schema);\n+    }\n+\n+    public <T extends PlainSchema> void create(final PlainSchemaTO schemaTO, final T schema) {\n+        fill(schema, schemaTO);\n+    }\n+\n+    public <T extends PlainSchema> void update(final PlainSchemaTO schemaTO, final T schema,\n+            final AttributableUtil attributableUtil) {\n+\n+        SyncopeClientCompositeException scce = SyncopeClientException.buildComposite();\n+\n+        List<PlainAttr> attrs = schemaDAO.findAttrs(schema, attributableUtil.plainAttrClass());\n+        if (!attrs.isEmpty()) {\n+            if (schema.getType() != schemaTO.getType()) {\n+                SyncopeClientException e = SyncopeClientException.build(\n+                        ClientExceptionType.valueOf(\"Invalid\" + schema.getClass().getSimpleName()));\n+                e.getElements().add(\"Cannot change type since \" + schema.getKey() + \" has attributes\");\n+\n+                scce.addException(e);\n+            }\n+            if (schema.isUniqueConstraint() != schemaTO.isUniqueConstraint()) {\n+                SyncopeClientException e = SyncopeClientException.build(ClientExceptionType.valueOf(\"Invalid\"\n+                        + schema.getClass().getSimpleName()));\n+                e.getElements().add(\"Cannot alter unique contraint since \" + schema.getKey() + \" has attributes\");\n+\n+                scce.addException(e);\n+            }\n+        }\n+\n+        if (scce.hasExceptions()) {\n+            throw scce;\n+        }\n+\n+        fill(schema, schemaTO);\n+    }\n+\n+    public <T extends PlainSchema> PlainSchemaTO getSchemaTO(\n+            final T schema, final AttributableUtil attributableUtil) {\n+\n+        PlainSchemaTO schemaTO = new PlainSchemaTO();\n+        BeanUtils.copyProperties(schema, schemaTO);\n+\n+        return schemaTO;\n+    }\n+\n+    // --------------- DERIVED -----------------\n+    private <T extends DerSchema> T populate(final T derSchema, final DerSchemaTO derSchemaTO) {\n+        SyncopeClientCompositeException scce = SyncopeClientException.buildComposite();\n+\n+        if (StringUtils.isBlank(derSchemaTO.getExpression())) {\n+            SyncopeClientException requiredValuesMissing =\n+                    SyncopeClientException.build(ClientExceptionType.RequiredValuesMissing);\n+            requiredValuesMissing.getElements().add(\"expression\");\n+\n+            scce.addException(requiredValuesMissing);\n+        } else if (!JexlUtil.isExpressionValid(derSchemaTO.getExpression())) {\n+            SyncopeClientException invalidMandatoryCondition = SyncopeClientException.build(\n+                    ClientExceptionType.InvalidValues);\n+            invalidMandatoryCondition.getElements().add(derSchemaTO.getExpression());\n+\n+            scce.addException(invalidMandatoryCondition);\n+        }\n+\n+        if (scce.hasExceptions()) {\n+            throw scce;\n+        }\n+\n+        BeanUtils.copyProperties(derSchemaTO, derSchema);\n+\n+        return derSchema;\n+    }\n+\n+    public <T extends DerSchema> T create(final DerSchemaTO derSchemaTO, final T derSchema) {\n+        return populate(derSchema, derSchemaTO);\n+    }\n+\n+    public <T extends DerSchema> T update(final DerSchemaTO derSchemaTO, final T derSchema) {\n+        return populate(derSchema, derSchemaTO);\n+    }\n+\n+    public <T extends DerSchema> DerSchemaTO getDerSchemaTO(final T derSchema) {\n+        DerSchemaTO derSchemaTO = new DerSchemaTO();\n+        BeanUtils.copyProperties(derSchema, derSchemaTO);\n+\n+        return derSchemaTO;\n+    }\n+\n+    // --------------- VIRTUAL -----------------\n+    private <T extends VirSchema> T fill(final T virSchema, final VirSchemaTO virSchemaTO) {\n+        BeanUtils.copyProperties(virSchemaTO, virSchema);\n+\n+        return virSchema;\n+    }\n+\n+    public <T extends VirSchema> T create(final VirSchemaTO virSchemaTO, final T virSchema) {\n+        return fill(virSchema, virSchemaTO);\n+    }\n+\n+    public <T extends VirSchema> T update(final VirSchemaTO virSchemaTO, final T virSchema) {\n+        return fill(virSchema, virSchemaTO);\n+    }\n+\n+    public <T extends VirSchema> VirSchemaTO getVirSchemaTO(final T virSchema) {\n+        VirSchemaTO virSchemaTO = new VirSchemaTO();\n+        BeanUtils.copyProperties(virSchema, virSchemaTO);\n+\n+        return virSchemaTO;\n+    }\n+}"},{"sha":"b8dce1d806dd2661bb73b9c4997a467689ce6848","filename":"syncope620/server/logic/src/main/java/org/apache/syncope/server/logic/data/SecurityQuestionDataBinder.java","status":"added","additions":51,"deletions":0,"changes":51,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Fdata%2FSecurityQuestionDataBinder.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Fdata%2FSecurityQuestionDataBinder.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Fdata%2FSecurityQuestionDataBinder.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,51 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.server.logic.data;\n+\n+import org.apache.syncope.common.lib.to.SecurityQuestionTO;\n+import org.apache.syncope.persistence.api.entity.EntityFactory;\n+import org.apache.syncope.persistence.api.entity.user.SecurityQuestion;\n+import org.apache.syncope.server.spring.BeanUtils;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Component;\n+\n+@Component\n+public class SecurityQuestionDataBinder {\n+\n+    @Autowired\n+    private EntityFactory entityFactory;\n+\n+    public SecurityQuestionTO getSecurityQuestionTO(final SecurityQuestion securityQuestion) {\n+        SecurityQuestionTO securityQuestionTO = new SecurityQuestionTO();\n+\n+        BeanUtils.copyProperties(securityQuestion, securityQuestionTO);\n+\n+        return securityQuestionTO;\n+    }\n+\n+    public SecurityQuestion create(final SecurityQuestionTO securityQuestionTO) {\n+        SecurityQuestion result = entityFactory.newEntity(SecurityQuestion.class);\n+        update(result, securityQuestionTO);\n+        return result;\n+    }\n+\n+    public void update(final SecurityQuestion securityQuestion, final SecurityQuestionTO securityQuestionTO) {\n+        BeanUtils.copyProperties(securityQuestionTO, securityQuestion, \"key\");\n+    }\n+}"},{"sha":"204207bc55d47e31b886832adaa31acf70de7515","filename":"syncope620/server/logic/src/main/java/org/apache/syncope/server/logic/data/TaskDataBinder.java","status":"added","additions":338,"deletions":0,"changes":338,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Fdata%2FTaskDataBinder.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Fdata%2FTaskDataBinder.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Fdata%2FTaskDataBinder.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,338 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.server.logic.data;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.syncope.common.lib.SyncopeClientException;\n+import org.apache.syncope.common.lib.to.AbstractAttributableTO;\n+import org.apache.syncope.common.lib.to.AbstractProvisioningTaskTO;\n+import org.apache.syncope.common.lib.to.AbstractTaskTO;\n+import org.apache.syncope.common.lib.to.AttrTO;\n+import org.apache.syncope.common.lib.to.MembershipTO;\n+import org.apache.syncope.common.lib.to.PropagationTaskTO;\n+import org.apache.syncope.common.lib.to.PushTaskTO;\n+import org.apache.syncope.common.lib.to.RoleTO;\n+import org.apache.syncope.common.lib.to.SchedTaskTO;\n+import org.apache.syncope.common.lib.to.SyncTaskTO;\n+import org.apache.syncope.common.lib.to.TaskExecTO;\n+import org.apache.syncope.common.lib.to.UserTO;\n+import org.apache.syncope.common.lib.types.ClientExceptionType;\n+import org.apache.syncope.common.lib.types.MatchingRule;\n+import org.apache.syncope.common.lib.types.TaskType;\n+import org.apache.syncope.common.lib.types.UnmatchingRule;\n+import org.apache.syncope.persistence.api.dao.ExternalResourceDAO;\n+import org.apache.syncope.persistence.api.dao.NotFoundException;\n+import org.apache.syncope.persistence.api.dao.TaskExecDAO;\n+import org.apache.syncope.persistence.api.entity.ExternalResource;\n+import org.apache.syncope.persistence.api.entity.task.NotificationTask;\n+import org.apache.syncope.persistence.api.entity.task.PropagationTask;\n+import org.apache.syncope.persistence.api.entity.task.ProvisioningTask;\n+import org.apache.syncope.persistence.api.entity.task.PushTask;\n+import org.apache.syncope.persistence.api.entity.task.SchedTask;\n+import org.apache.syncope.persistence.api.entity.task.SyncTask;\n+import org.apache.syncope.persistence.api.entity.task.Task;\n+import org.apache.syncope.persistence.api.entity.task.TaskExec;\n+import org.apache.syncope.persistence.api.entity.task.TaskUtil;\n+import org.apache.syncope.server.logic.init.JobInstanceLoader;\n+import org.apache.syncope.server.spring.BeanUtils;\n+import org.apache.syncope.server.utils.jexl.JexlUtil;\n+import org.quartz.Scheduler;\n+import org.quartz.SchedulerException;\n+import org.quartz.Trigger;\n+import org.quartz.TriggerKey;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.scheduling.quartz.SchedulerFactoryBean;\n+import org.springframework.stereotype.Component;\n+\n+@Component\n+public class TaskDataBinder {\n+\n+    /**\n+     * Logger.\n+     */\n+    private static final Logger LOG = LoggerFactory.getLogger(TaskDataBinder.class);\n+\n+    private static final String[] IGNORE_TASK_PROPERTIES = {\n+        \"executions\", \"resource\", \"matchingRule\", \"unmatchingRule\" };\n+\n+    private static final String[] IGNORE_TASK_EXECUTION_PROPERTIES = { \"key\", \"task\" };\n+\n+    @Autowired\n+    private ExternalResourceDAO resourceDAO;\n+\n+    @Autowired\n+    private TaskExecDAO taskExecDAO;\n+\n+    @Autowired\n+    private SchedulerFactoryBean scheduler;\n+\n+    private void checkJexl(final AbstractAttributableTO attributableTO, final SyncopeClientException sce) {\n+        for (AttrTO attrTO : attributableTO.getPlainAttrs()) {\n+            if (!attrTO.getValues().isEmpty() && !JexlUtil.isExpressionValid(attrTO.getValues().get(0))) {\n+                sce.getElements().add(\"Invalid JEXL: \" + attrTO.getValues().get(0));\n+            }\n+        }\n+\n+        for (AttrTO attrTO : attributableTO.getVirAttrs()) {\n+            if (!attrTO.getValues().isEmpty() && !JexlUtil.isExpressionValid(attrTO.getValues().get(0))) {\n+                sce.getElements().add(\"Invalid JEXL: \" + attrTO.getValues().get(0));\n+            }\n+        }\n+    }\n+\n+    private void fill(final ProvisioningTask task, final AbstractProvisioningTaskTO taskTO) {\n+        SyncopeClientException sce = SyncopeClientException.build(ClientExceptionType.InvalidSyncTask);\n+\n+        if (task instanceof PushTask && taskTO instanceof PushTaskTO) {\n+            final PushTask pushTask = (PushTask) task;\n+            final PushTaskTO pushTaskTO = (PushTaskTO) taskTO;\n+\n+            pushTask.setUserFilter(pushTaskTO.getUserFilter());\n+            pushTask.setRoleFilter(pushTaskTO.getRoleFilter());\n+\n+            pushTask.setMatchingRule(pushTaskTO.getMatchingRule() == null\n+                    ? MatchingRule.LINK : pushTaskTO.getMatchingRule());\n+\n+            pushTask.setUnmatchingRule(pushTaskTO.getUnmatchingRule() == null\n+                    ? UnmatchingRule.ASSIGN : pushTaskTO.getUnmatchingRule());\n+\n+        } else if (task instanceof SyncTask && taskTO instanceof SyncTaskTO) {\n+            final SyncTask syncTask = (SyncTask) task;\n+            final SyncTaskTO syncTaskTO = (SyncTaskTO) taskTO;\n+\n+            syncTask.setMatchingRule(syncTaskTO.getMatchingRule() == null\n+                    ? MatchingRule.UPDATE : syncTaskTO.getMatchingRule());\n+\n+            syncTask.setUnmatchingRule(syncTaskTO.getUnmatchingRule() == null\n+                    ? UnmatchingRule.PROVISION : syncTaskTO.getUnmatchingRule());\n+\n+            // 1. validate JEXL expressions in user and role templates\n+            if (syncTaskTO.getUserTemplate() != null) {\n+                UserTO template = syncTaskTO.getUserTemplate();\n+\n+                if (StringUtils.isNotBlank(template.getUsername())\n+                        && !JexlUtil.isExpressionValid(template.getUsername())) {\n+\n+                    sce.getElements().add(\"Invalid JEXL: \" + template.getUsername());\n+                }\n+                if (StringUtils.isNotBlank(template.getPassword())\n+                        && !JexlUtil.isExpressionValid(template.getPassword())) {\n+\n+                    sce.getElements().add(\"Invalid JEXL: \" + template.getPassword());\n+                }\n+\n+                checkJexl(template, sce);\n+\n+                for (MembershipTO memb : template.getMemberships()) {\n+                    checkJexl(memb, sce);\n+                }\n+            }\n+            if (syncTaskTO.getRoleTemplate() != null) {\n+                RoleTO template = syncTaskTO.getRoleTemplate();\n+\n+                if (StringUtils.isNotBlank(template.getName()) && !JexlUtil.isExpressionValid(template.getName())) {\n+                    sce.getElements().add(\"Invalid JEXL: \" + template.getName());\n+                }\n+\n+                checkJexl(template, sce);\n+            }\n+            if (!sce.isEmpty()) {\n+                throw sce;\n+            }\n+\n+            // 2. all JEXL expressions are valid: accept user and role templates\n+            syncTask.setUserTemplate(syncTaskTO.getUserTemplate());\n+            syncTask.setRoleTemplate(syncTaskTO.getRoleTemplate());\n+\n+            syncTask.setFullReconciliation(syncTaskTO.isFullReconciliation());\n+        }\n+\n+        // 3. fill the remaining fields\n+        task.setPerformCreate(taskTO.isPerformCreate());\n+        task.setPerformUpdate(taskTO.isPerformUpdate());\n+        task.setPerformDelete(taskTO.isPerformDelete());\n+        task.setSyncStatus(taskTO.isSyncStatus());\n+        task.getActionsClassNames().clear();\n+        task.getActionsClassNames().addAll(taskTO.getActionsClassNames());\n+    }\n+\n+    public SchedTask createSchedTask(final SchedTaskTO taskTO, final TaskUtil taskUtil) {\n+        final Class<? extends AbstractTaskTO> taskTOClass = taskUtil.taskTOClass();\n+\n+        if (taskTOClass == null || !taskTOClass.equals(taskTO.getClass())) {\n+            throw new ClassCastException(\n+                    String.format(\"taskUtil is type %s but task is not: %s\", taskTOClass, taskTO.getClass()));\n+        }\n+\n+        SchedTask task = taskUtil.newTask();\n+        task.setCronExpression(taskTO.getCronExpression());\n+        task.setName(taskTO.getName());\n+        task.setDescription(taskTO.getDescription());\n+\n+        if (taskUtil.getType() == TaskType.SCHEDULED) {\n+            task.setJobClassName(taskTO.getJobClassName());\n+        } else if (taskTO instanceof AbstractProvisioningTaskTO) {\n+            final AbstractProvisioningTaskTO provisioningTaskTO = (AbstractProvisioningTaskTO) taskTO;\n+\n+            ExternalResource resource = resourceDAO.find(provisioningTaskTO.getResource());\n+            if (resource == null) {\n+                throw new NotFoundException(\"Resource \" + provisioningTaskTO.getResource());\n+            }\n+            ((ProvisioningTask) task).setResource(resource);\n+\n+            fill((ProvisioningTask) task, provisioningTaskTO);\n+        }\n+\n+        return task;\n+    }\n+\n+    public void updateSchedTask(final SchedTask task, final SchedTaskTO taskTO, final TaskUtil taskUtil) {\n+        Class<? extends Task> taskClass = taskUtil.taskClass();\n+        Class<? extends AbstractTaskTO> taskTOClass = taskUtil.taskTOClass();\n+\n+        if (taskClass == null || !taskClass.equals(task.getClass())) {\n+            throw new ClassCastException(\n+                    String.format(\"taskUtil is type %s but task is not: %s\", taskClass, task.getClass()));\n+        }\n+\n+        if (taskTOClass == null || !taskTOClass.equals(taskTO.getClass())) {\n+            throw new ClassCastException(\n+                    String.format(\"taskUtil is type %s but task is not: %s\", taskTOClass, taskTO.getClass()));\n+        }\n+\n+        task.setCronExpression(taskTO.getCronExpression());\n+        if (StringUtils.isNotBlank(taskTO.getName())) {\n+            task.setName(taskTO.getName());\n+        }\n+        if (StringUtils.isNotBlank(taskTO.getDescription())) {\n+            task.setDescription(taskTO.getDescription());\n+        }\n+\n+        if (task instanceof ProvisioningTask) {\n+            fill((ProvisioningTask) task, (AbstractProvisioningTaskTO) taskTO);\n+        }\n+    }\n+\n+    public TaskExecTO getTaskExecTO(final TaskExec execution) {\n+        TaskExecTO executionTO = new TaskExecTO();\n+        BeanUtils.copyProperties(execution, executionTO, IGNORE_TASK_EXECUTION_PROPERTIES);\n+\n+        if (execution.getKey() != null) {\n+            executionTO.setKey(execution.getKey());\n+        }\n+\n+        if (execution.getTask() != null && execution.getTask().getKey() != null) {\n+            executionTO.setTask(execution.getTask().getKey());\n+        }\n+\n+        return executionTO;\n+    }\n+\n+    private void setExecTime(final SchedTaskTO taskTO, final Task task) {\n+        String triggerName = JobInstanceLoader.getTriggerName(JobInstanceLoader.getJobName(task));\n+\n+        Trigger trigger = null;\n+        try {\n+            trigger = scheduler.getScheduler().getTrigger(new TriggerKey(triggerName, Scheduler.DEFAULT_GROUP));\n+        } catch (SchedulerException e) {\n+            LOG.warn(\"While trying to get to \" + triggerName, e);\n+        }\n+\n+        if (trigger != null) {\n+            taskTO.setLastExec(trigger.getPreviousFireTime());\n+            taskTO.setNextExec(trigger.getNextFireTime());\n+        }\n+    }\n+\n+    public <T extends AbstractTaskTO> T getTaskTO(final Task task, final TaskUtil taskUtil) {\n+        T taskTO = taskUtil.newTaskTO();\n+        BeanUtils.copyProperties(task, taskTO, IGNORE_TASK_PROPERTIES);\n+\n+        TaskExec latestExec = taskExecDAO.findLatestStarted(task);\n+        taskTO.setLatestExecStatus(latestExec == null ? \"\" : latestExec.getStatus());\n+        taskTO.setStartDate(latestExec == null ? null : latestExec.getStartDate());\n+        taskTO.setEndDate(latestExec == null ? null : latestExec.getEndDate());\n+\n+        for (TaskExec execution : task.getExecs()) {\n+            taskTO.getExecutions().add(getTaskExecTO(execution));\n+        }\n+\n+        switch (taskUtil.getType()) {\n+            case PROPAGATION:\n+                if (!(task instanceof PropagationTask)) {\n+                    throw new ClassCastException(\"taskUtil is type Propagation but task is not PropagationTask: \"\n+                            + task.getClass().getName());\n+                }\n+                ((PropagationTaskTO) taskTO).setResource(((PropagationTask) task).getResource().getKey());\n+                break;\n+\n+            case SCHEDULED:\n+                if (!(task instanceof SchedTask)) {\n+                    throw new ClassCastException(\"taskUtil is type Sched but task is not SchedTask: \"\n+                            + task.getClass().getName());\n+                }\n+                setExecTime((SchedTaskTO) taskTO, task);\n+                ((SchedTaskTO) taskTO).setName(((SchedTask) task).getName());\n+                ((SchedTaskTO) taskTO).setDescription(((SchedTask) task).getDescription());\n+                break;\n+\n+            case SYNCHRONIZATION:\n+                if (!(task instanceof SyncTask)) {\n+                    throw new ClassCastException(\"taskUtil is type Sync but task is not SyncTask: \"\n+                            + task.getClass().getName());\n+                }\n+                setExecTime((SchedTaskTO) taskTO, task);\n+                ((SyncTaskTO) taskTO).setName(((SyncTask) task).getName());\n+                ((SyncTaskTO) taskTO).setDescription(((SyncTask) task).getDescription());\n+                ((SyncTaskTO) taskTO).setResource(((SyncTask) task).getResource().getKey());\n+                ((SyncTaskTO) taskTO).setMatchingRule(((SyncTask) task).getMatchingRule() == null\n+                        ? MatchingRule.UPDATE : ((SyncTask) task).getMatchingRule());\n+                ((SyncTaskTO) taskTO).setUnmatchingRule(((SyncTask) task).getUnmatchingRule() == null\n+                        ? UnmatchingRule.PROVISION : ((SyncTask) task).getUnmatchingRule());\n+                break;\n+\n+            case PUSH:\n+                if (!(task instanceof PushTask)) {\n+                    throw new ClassCastException(\"taskUtil is type Push but task is not PushTask: \"\n+                            + task.getClass().getName());\n+                }\n+                setExecTime((SchedTaskTO) taskTO, task);\n+                ((PushTaskTO) taskTO).setName(((PushTask) task).getName());\n+                ((PushTaskTO) taskTO).setDescription(((PushTask) task).getDescription());\n+                ((PushTaskTO) taskTO).setResource(((PushTask) task).getResource().getKey());\n+                ((PushTaskTO) taskTO).setMatchingRule(((PushTask) task).getMatchingRule() == null\n+                        ? MatchingRule.LINK : ((PushTask) task).getMatchingRule());\n+                ((PushTaskTO) taskTO).setUnmatchingRule(((PushTask) task).getUnmatchingRule() == null\n+                        ? UnmatchingRule.ASSIGN : ((PushTask) task).getUnmatchingRule());\n+                break;\n+\n+            case NOTIFICATION:\n+                if (((NotificationTask) task).isExecuted() && StringUtils.isBlank(taskTO.getLatestExecStatus())) {\n+                    taskTO.setLatestExecStatus(\"[EXECUTED]\");\n+                }\n+                break;\n+\n+            default:\n+        }\n+\n+        return taskTO;\n+    }\n+}"},{"sha":"861452c8c23fbae539b594a342ac40f94d9bcd1c","filename":"syncope620/server/logic/src/main/java/org/apache/syncope/server/logic/data/UserDataBinder.java","status":"added","additions":479,"deletions":0,"changes":479,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Fdata%2FUserDataBinder.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Fdata%2FUserDataBinder.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Fdata%2FUserDataBinder.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,479 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.server.logic.data;\n+\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import javax.annotation.Resource;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.syncope.common.lib.SyncopeClientCompositeException;\n+import org.apache.syncope.common.lib.SyncopeClientException;\n+import org.apache.syncope.common.lib.mod.AttrMod;\n+import org.apache.syncope.common.lib.mod.MembershipMod;\n+import org.apache.syncope.common.lib.mod.UserMod;\n+import org.apache.syncope.common.lib.to.MembershipTO;\n+import org.apache.syncope.common.lib.to.UserTO;\n+import org.apache.syncope.common.lib.types.AttributableType;\n+import org.apache.syncope.common.lib.types.CipherAlgorithm;\n+import org.apache.syncope.common.lib.types.ClientExceptionType;\n+import org.apache.syncope.common.lib.types.IntMappingType;\n+import org.apache.syncope.common.lib.types.ResourceOperation;\n+import org.apache.syncope.persistence.api.dao.ConfDAO;\n+import org.apache.syncope.persistence.api.dao.NotFoundException;\n+import org.apache.syncope.persistence.api.dao.SecurityQuestionDAO;\n+import org.apache.syncope.persistence.api.entity.DerAttr;\n+import org.apache.syncope.persistence.api.entity.ExternalResource;\n+import org.apache.syncope.persistence.api.entity.MappingItem;\n+import org.apache.syncope.persistence.api.entity.PlainAttr;\n+import org.apache.syncope.persistence.api.entity.VirAttr;\n+import org.apache.syncope.persistence.api.entity.membership.MDerAttr;\n+import org.apache.syncope.persistence.api.entity.membership.MPlainAttr;\n+import org.apache.syncope.persistence.api.entity.membership.MVirAttr;\n+import org.apache.syncope.persistence.api.entity.membership.Membership;\n+import org.apache.syncope.persistence.api.entity.role.Role;\n+import org.apache.syncope.persistence.api.entity.user.SecurityQuestion;\n+import org.apache.syncope.persistence.api.entity.user.User;\n+import org.apache.syncope.provisioning.api.propagation.PropagationByResource;\n+import org.apache.syncope.server.security.AuthContextUtil;\n+import org.apache.syncope.server.security.Encryptor;\n+import org.apache.syncope.server.spring.BeanUtils;\n+import org.apache.syncope.server.utils.ConnObjectUtil;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Component;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+@Component\n+@Transactional(rollbackFor = { Throwable.class })\n+public class UserDataBinder extends AbstractAttributableDataBinder {\n+\n+    private static final String[] IGNORE_USER_PROPERTIES = {\n+        \"memberships\", \"plainAttrs\", \"derAttrs\", \"virAttrs\", \"resources\", \"securityQuestion\", \"securityAnswer\"\n+    };\n+\n+    @Autowired\n+    private ConfDAO confDAO;\n+\n+    @Autowired\n+    private ConnObjectUtil connObjectUtil;\n+\n+    @Autowired\n+    private SecurityQuestionDAO securityQuestionDAO;\n+\n+    @Resource(name = \"adminUser\")\n+    private String adminUser;\n+\n+    @Resource(name = \"anonymousUser\")\n+    private String anonymousUser;\n+\n+    private final Encryptor encryptor = Encryptor.getInstance();\n+\n+    @Transactional(readOnly = true)\n+    public Membership getMembershipFromId(final Long membershipId) {\n+        if (membershipId == null) {\n+            throw new NotFoundException(\"Null membership id\");\n+        }\n+\n+        Membership membership = membershipDAO.find(membershipId);\n+        if (membership == null) {\n+            throw new NotFoundException(\"Membership \" + membershipId);\n+        }\n+\n+        return membership;\n+    }\n+\n+    @Transactional(readOnly = true)\n+    public Set<String> getResourceNamesForUser(final Long key) {\n+        return userDAO.authFecthUser(key).getResourceNames();\n+    }\n+\n+    @Transactional(readOnly = true)\n+    public UserTO getAuthenticatedUserTO() {\n+        final UserTO authUserTO;\n+\n+        final String authUsername = AuthContextUtil.getAuthenticatedUsername();\n+        if (anonymousUser.equals(authUsername)) {\n+            authUserTO = new UserTO();\n+            authUserTO.setKey(-2);\n+            authUserTO.setUsername(anonymousUser);\n+        } else if (adminUser.equals(authUsername)) {\n+            authUserTO = new UserTO();\n+            authUserTO.setKey(-1);\n+            authUserTO.setUsername(adminUser);\n+        } else {\n+            User authUser = userDAO.find(authUsername);\n+            authUserTO = getUserTO(authUser);\n+        }\n+\n+        return authUserTO;\n+    }\n+\n+    @Transactional(readOnly = true)\n+    public boolean verifyPassword(final String username, final String password) {\n+        return verifyPassword(userDAO.authFecthUser(username), password);\n+    }\n+\n+    @Transactional(readOnly = true)\n+    public boolean verifyPassword(final User user, final String password) {\n+        return encryptor.verify(password, user.getCipherAlgorithm(), user.getPassword());\n+    }\n+\n+    private void setPassword(final User user, final String password,\n+            final SyncopeClientCompositeException scce) {\n+\n+        try {\n+            final String algorithm = confDAO.find(\n+                    \"password.cipher.algorithm\", CipherAlgorithm.AES.name()).getValues().get(0).getStringValue();\n+            CipherAlgorithm predefined = CipherAlgorithm.valueOf(algorithm);\n+            user.setPassword(password, predefined);\n+        } catch (IllegalArgumentException e) {\n+            final SyncopeClientException invalidCiperAlgorithm =\n+                    SyncopeClientException.build(ClientExceptionType.NotFound);\n+            invalidCiperAlgorithm.getElements().add(e.getMessage());\n+            scce.addException(invalidCiperAlgorithm);\n+\n+            throw scce;\n+        }\n+    }\n+\n+    public void create(final User user, final UserTO userTO, final boolean storePassword) {\n+        SyncopeClientCompositeException scce = SyncopeClientException.buildComposite();\n+\n+        // memberships\n+        Role role;\n+        for (MembershipTO membershipTO : userTO.getMemberships()) {\n+            role = roleDAO.find(membershipTO.getRoleId());\n+\n+            if (role == null) {\n+                if (LOG.isDebugEnabled()) {\n+                    LOG.debug(\"Ignoring invalid role \" + membershipTO.getRoleName());\n+                }\n+            } else {\n+                Membership membership = null;\n+                if (user.getKey() != null) {\n+                    membership = user.getMembership(role.getKey()) == null\n+                            ? membershipDAO.find(user, role)\n+                            : user.getMembership(role.getKey());\n+                }\n+                if (membership == null) {\n+                    membership = entityFactory.newEntity(Membership.class);\n+                    membership.setRole(role);\n+                    membership.setUser(user);\n+\n+                    user.addMembership(membership);\n+                }\n+\n+                fill(membership, membershipTO, attrUtilFactory.getInstance(AttributableType.MEMBERSHIP), scce);\n+            }\n+        }\n+\n+        // attributes, derived attributes, virtual attributes and resources\n+        fill(user, userTO, attrUtilFactory.getInstance(AttributableType.USER), scce);\n+\n+        // set password\n+        if (StringUtils.isBlank(userTO.getPassword()) || !storePassword) {\n+            LOG.debug(\"Password was not provided or not required to be stored\");\n+        } else {\n+            setPassword(user, userTO.getPassword(), scce);\n+        }\n+\n+        // set username\n+        user.setUsername(userTO.getUsername());\n+\n+        // security question / answer\n+        if (userTO.getSecurityQuestion() != null) {\n+            SecurityQuestion securityQuestion = securityQuestionDAO.find(userTO.getSecurityQuestion());\n+            if (securityQuestion != null) {\n+                user.setSecurityQuestion(securityQuestion);\n+            }\n+        }\n+        user.setSecurityAnswer(userTO.getSecurityAnswer());\n+    }\n+\n+    /**\n+     * Update user, given UserMod.\n+     *\n+     * @param toBeUpdated user to be updated\n+     * @param userMod bean containing update request\n+     * @return updated user + propagation by resource\n+     * @see PropagationByResource\n+     */\n+    public PropagationByResource update(final User toBeUpdated, final UserMod userMod) {\n+        // Re-merge any pending change from workflow tasks\n+        User user = userDAO.save(toBeUpdated);\n+\n+        PropagationByResource propByRes = new PropagationByResource();\n+\n+        SyncopeClientCompositeException scce = SyncopeClientException.buildComposite();\n+\n+        Set<String> currentResources = user.getResourceNames();\n+\n+        // password\n+        if (StringUtils.isNotBlank(userMod.getPassword())) {\n+            setPassword(user, userMod.getPassword(), scce);\n+            user.setChangePwdDate(new Date());\n+            propByRes.addAll(ResourceOperation.UPDATE, currentResources);\n+        }\n+\n+        // username\n+        if (userMod.getUsername() != null && !userMod.getUsername().equals(user.getUsername())) {\n+            String oldUsername = user.getUsername();\n+\n+            user.setUsername(userMod.getUsername());\n+            propByRes.addAll(ResourceOperation.UPDATE, currentResources);\n+\n+            for (ExternalResource resource : user.getResources()) {\n+                for (MappingItem mapItem : resource.getUmapping().getItems()) {\n+                    if (mapItem.isAccountid() && mapItem.getIntMappingType() == IntMappingType.Username) {\n+                        propByRes.addOldAccountId(resource.getKey(), oldUsername);\n+                    }\n+                }\n+            }\n+        }\n+\n+        // security question / answer:\n+        // userMod.getSecurityQuestion() is null => remove user security question and answer\n+        // userMod.getSecurityQuestion() == 0 => don't change anything\n+        // userMod.getSecurityQuestion() > 0 => update user security question and answer\n+        if (userMod.getSecurityQuestion() == null) {\n+            user.setSecurityQuestion(null);\n+            user.setSecurityAnswer(null);\n+        } else if (userMod.getSecurityQuestion() > 0) {\n+            SecurityQuestion securityQuestion = securityQuestionDAO.find(userMod.getSecurityQuestion());\n+            if (securityQuestion != null) {\n+                user.setSecurityQuestion(securityQuestion);\n+                user.setSecurityAnswer(userMod.getSecurityAnswer());\n+            }\n+        }\n+\n+        // attributes, derived attributes, virtual attributes and resources\n+        propByRes.merge(fill(user, userMod, attrUtilFactory.getInstance(AttributableType.USER), scce));\n+\n+        // store the role ids of membership required to be added\n+        Set<Long> membershipToBeAddedRoleIds = new HashSet<>();\n+        for (MembershipMod membToBeAdded : userMod.getMembershipsToAdd()) {\n+            membershipToBeAddedRoleIds.add(membToBeAdded.getRole());\n+        }\n+\n+        final Set<String> toBeDeprovisioned = new HashSet<>();\n+        final Set<String> toBeProvisioned = new HashSet<>();\n+\n+        // memberships to be removed\n+        for (Long membershipId : userMod.getMembershipsToRemove()) {\n+            LOG.debug(\"Membership to be removed: {}\", membershipId);\n+\n+            Membership membership = membershipDAO.find(membershipId);\n+            if (membership == null) {\n+                LOG.debug(\"Invalid membership id specified to be removed: {}\", membershipId);\n+            } else {\n+                if (!membershipToBeAddedRoleIds.contains(membership.getRole().getKey())) {\n+                    toBeDeprovisioned.addAll(membership.getRole().getResourceNames());\n+                }\n+\n+                // In order to make the removeMembership() below to work,\n+                // we need to be sure to take exactly the same membership\n+                // of the user object currently in memory (which has potentially\n+                // some modifications compared to the one stored in the DB\n+                membership = user.getMembership(membership.getRole().getKey());\n+                if (membershipToBeAddedRoleIds.contains(membership.getRole().getKey())) {\n+                    Set<Long> attributeIds = new HashSet<>(membership.getPlainAttrs().size());\n+                    for (PlainAttr attribute : membership.getPlainAttrs()) {\n+                        attributeIds.add(attribute.getKey());\n+                    }\n+                    for (Long attributeId : attributeIds) {\n+                        plainAttrDAO.delete(attributeId, MPlainAttr.class);\n+                    }\n+                    attributeIds.clear();\n+\n+                    // remove derived attributes\n+                    for (DerAttr derAttr : membership.getDerAttrs()) {\n+                        attributeIds.add(derAttr.getKey());\n+                    }\n+                    for (Long derAttrId : attributeIds) {\n+                        derAttrDAO.delete(derAttrId, MDerAttr.class);\n+                    }\n+                    attributeIds.clear();\n+\n+                    // remove virtual attributes\n+                    for (VirAttr virAttr : membership.getVirAttrs()) {\n+                        attributeIds.add(virAttr.getKey());\n+                    }\n+                    for (Long virAttrId : attributeIds) {\n+                        virAttrDAO.delete(virAttrId, MVirAttr.class);\n+                    }\n+                    attributeIds.clear();\n+                } else {\n+                    user.removeMembership(membership);\n+\n+                    membershipDAO.delete(membershipId);\n+                }\n+            }\n+        }\n+\n+        // memberships to be added\n+        for (MembershipMod membershipMod : userMod.getMembershipsToAdd()) {\n+            LOG.debug(\"Membership to be added: role({})\", membershipMod.getRole());\n+\n+            Role role = roleDAO.find(membershipMod.getRole());\n+            if (role == null) {\n+                LOG.debug(\"Ignoring invalid role {}\", membershipMod.getRole());\n+            } else {\n+                Membership membership = user.getMembership(role.getKey());\n+                if (membership == null) {\n+                    membership = entityFactory.newEntity(Membership.class);\n+                    membership.setRole(role);\n+                    membership.setUser(user);\n+\n+                    user.addMembership(membership);\n+\n+                    toBeProvisioned.addAll(role.getResourceNames());\n+                }\n+\n+                propByRes.merge(fill(membership, membershipMod,\n+                        attrUtilFactory.getInstance(AttributableType.MEMBERSHIP), scce));\n+            }\n+        }\n+\n+        propByRes.addAll(ResourceOperation.DELETE, toBeDeprovisioned);\n+        propByRes.addAll(ResourceOperation.UPDATE, toBeProvisioned);\n+\n+        /**\n+         * In case of new memberships all the current resources have to be updated in order to propagate new role and\n+         * membership attribute values.\n+         */\n+        if (!toBeDeprovisioned.isEmpty() || !toBeProvisioned.isEmpty()) {\n+            currentResources.removeAll(toBeDeprovisioned);\n+            propByRes.addAll(ResourceOperation.UPDATE, currentResources);\n+        }\n+\n+        return propByRes;\n+    }\n+\n+    @Transactional(readOnly = true)\n+    public UserTO getUserTO(final User user) {\n+        UserTO userTO = new UserTO();\n+\n+        BeanUtils.copyProperties(user, userTO, IGNORE_USER_PROPERTIES);\n+\n+        if (user.getSecurityQuestion() != null) {\n+            userTO.setSecurityQuestion(user.getSecurityQuestion().getKey());\n+        }\n+\n+        connObjectUtil.retrieveVirAttrValues(user, attrUtilFactory.getInstance(AttributableType.USER));\n+        fillTO(userTO, user.getPlainAttrs(), user.getDerAttrs(), user.getVirAttrs(), user.getResources());\n+\n+        MembershipTO membershipTO;\n+        for (Membership membership : user.getMemberships()) {\n+            membershipTO = new MembershipTO();\n+\n+            // set sys info\n+            membershipTO.setCreator(membership.getCreator());\n+            membershipTO.setCreationDate(membership.getCreationDate());\n+            membershipTO.setLastModifier(membership.getLastModifier());\n+            membershipTO.setLastChangeDate(membership.getLastChangeDate());\n+\n+            membershipTO.setKey(membership.getKey());\n+            membershipTO.setRoleId(membership.getRole().getKey());\n+            membershipTO.setRoleName(membership.getRole().getName());\n+\n+            // SYNCOPE-458 retrieve also membership virtual attributes\n+            connObjectUtil.retrieveVirAttrValues(membership, attrUtilFactory.getInstance(AttributableType.MEMBERSHIP));\n+\n+            fillTO(membershipTO,\n+                    membership.getPlainAttrs(), membership.getDerAttrs(), membership.getVirAttrs(),\n+                    Collections.<ExternalResource>emptyList());\n+\n+            userTO.getMemberships().add(membershipTO);\n+        }\n+\n+        return userTO;\n+    }\n+\n+    @Transactional(readOnly = true)\n+    public UserTO getUserTO(final String username) {\n+        return getUserTO(userDAO.authFecthUser(username));\n+    }\n+\n+    @Transactional(readOnly = true)\n+    public UserTO getUserTO(final Long key) {\n+        return getUserTO(userDAO.authFecthUser(key));\n+    }\n+\n+    /**\n+     * SYNCOPE-459: build virtual attribute changes in case no other changes were made.\n+     *\n+     * @param key user id\n+     * @param vAttrsToBeRemoved virtual attributes to be removed.\n+     * @param vAttrsToBeUpdated virtual attributes to be updated.\n+     * @return operations to be performed on external resources for virtual attributes changes\n+     */\n+    public PropagationByResource fillVirtual(\n+            final Long key, final Set<String> vAttrsToBeRemoved, final Set<AttrMod> vAttrsToBeUpdated) {\n+\n+        return fillVirtual(\n+                userDAO.authFecthUser(key),\n+                vAttrsToBeRemoved,\n+                vAttrsToBeUpdated,\n+                attrUtilFactory.getInstance(AttributableType.USER));\n+    }\n+\n+    /**\n+     * SYNCOPE-501: build membership virtual attribute changes in case no other changes were made.\n+     *\n+     * @param key user id\n+     * @param roleId role id\n+     * @param membershipId membership id\n+     * @param vAttrsToBeRemoved virtual attributes to be removed.\n+     * @param vAttrsToBeUpdated virtual attributes to be updated.\n+     * @param isRemoval flag to check if fill is on removed or added membership\n+     * @return operations to be performed on external resources for membership virtual attributes changes\n+     */\n+    public PropagationByResource fillMembershipVirtual(\n+            final Long key, final Long roleId, final Long membershipId, final Set<String> vAttrsToBeRemoved,\n+            final Set<AttrMod> vAttrsToBeUpdated, final boolean isRemoval) {\n+\n+        final Membership membership = membershipId == null\n+                ? userDAO.authFecthUser(key).getMembership(roleId)\n+                : getMembershipFromId(membershipId);\n+\n+        return membership == null ? new PropagationByResource() : isRemoval\n+                ? fillVirtual(\n+                        membership,\n+                        membership.getVirAttrs() == null\n+                                ? Collections.<String>emptySet()\n+                                : getAttributeNames(membership.getVirAttrs()),\n+                        vAttrsToBeUpdated,\n+                        attrUtilFactory.getInstance(AttributableType.MEMBERSHIP))\n+                : fillVirtual(\n+                        membership,\n+                        vAttrsToBeRemoved,\n+                        vAttrsToBeUpdated,\n+                        attrUtilFactory.getInstance(AttributableType.MEMBERSHIP));\n+    }\n+\n+    private Set<String> getAttributeNames(final List<? extends VirAttr> virAttrs) {\n+        final Set<String> virAttrNames = new HashSet<String>();\n+        for (VirAttr attr : virAttrs) {\n+            virAttrNames.add(attr.getSchema().getKey());\n+        }\n+        return virAttrNames;\n+    }\n+}"},{"sha":"4219881dd04b83278603e850249d75a2661d254a","filename":"syncope620/server/logic/src/main/java/org/apache/syncope/server/logic/init/ImplementationClassNamesLoader.java","status":"added","additions":141,"deletions":0,"changes":141,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Finit%2FImplementationClassNamesLoader.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Finit%2FImplementationClassNamesLoader.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Finit%2FImplementationClassNamesLoader.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,141 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.server.logic.init;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.EnumMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import org.apache.syncope.common.lib.wrap.Validator;\n+import org.apache.syncope.provisioning.api.job.PushJob;\n+import org.apache.syncope.provisioning.api.job.SyncJob;\n+import org.apache.syncope.provisioning.api.job.TaskJob;\n+import org.apache.syncope.provisioning.api.propagation.PropagationActions;\n+import org.apache.syncope.provisioning.api.sync.PushActions;\n+import org.apache.syncope.provisioning.api.sync.SyncActions;\n+import org.apache.syncope.provisioning.api.sync.SyncCorrelationRule;\n+import org.apache.syncope.server.logic.report.Reportlet;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.core.io.Resource;\n+import org.springframework.core.io.support.ResourcePatternResolver;\n+import org.springframework.core.type.ClassMetadata;\n+import org.springframework.core.type.classreading.CachingMetadataReaderFactory;\n+import org.springframework.stereotype.Component;\n+import org.springframework.util.ClassUtils;\n+\n+/**\n+ * Cache class names for all implementations of Syncope interfaces found in classpath, for later usage.\n+ */\n+@Component\n+public class ImplementationClassNamesLoader {\n+\n+    public enum Type {\n+\n+        REPORTLET,\n+        TASKJOB,\n+        SYNC_ACTIONS,\n+        PUSH_ACTIONS,\n+        SYNC_CORRELATION_RULES,\n+        PUSH_CORRELATION_RULES,\n+        PROPAGATION_ACTIONS,\n+        VALIDATOR\n+\n+    }\n+\n+    /**\n+     * Logger.\n+     */\n+    private static final Logger LOG = LoggerFactory.getLogger(ImplementationClassNamesLoader.class);\n+\n+    @Autowired\n+    private ResourcePatternResolver resResolver;\n+\n+    private Map<Type, Set<String>> classNames;\n+\n+    public void load() {\n+        CachingMetadataReaderFactory factory = new CachingMetadataReaderFactory();\n+\n+        classNames = new EnumMap<Type, Set<String>>(Type.class);\n+        for (Type type : Type.values()) {\n+            classNames.put(type, new HashSet<String>());\n+        }\n+\n+        try {\n+            for (Resource resource : resResolver.getResources(\"classpath*:**/*.class\")) {\n+                ClassMetadata metadata = factory.getMetadataReader(resource).getClassMetadata();\n+\n+                try {\n+                    Class<?> clazz = ClassUtils.forName(metadata.getClassName(), ClassUtils.getDefaultClassLoader());\n+                    Set<Class<?>> interfaces = ClassUtils.getAllInterfacesForClassAsSet(clazz);\n+\n+                    if (interfaces.contains(Reportlet.class) && !metadata.isAbstract()) {\n+                        classNames.get(Type.REPORTLET).add(clazz.getName());\n+                    }\n+\n+                    if ((interfaces.contains(TaskJob.class))\n+                            && !metadata.isAbstract()\n+                            && !SyncJob.class.getName().equals(metadata.getClassName())\n+                            && !PushJob.class.getName().equals(metadata.getClassName())) {\n+\n+                        classNames.get(Type.TASKJOB).add(metadata.getClassName());\n+                    }\n+\n+                    if (interfaces.contains(SyncActions.class) && !metadata.isAbstract()) {\n+                        classNames.get(Type.SYNC_ACTIONS).add(metadata.getClassName());\n+                    }\n+\n+                    if (interfaces.contains(PushActions.class) && !metadata.isAbstract()) {\n+                        classNames.get(Type.PUSH_ACTIONS).add(metadata.getClassName());\n+                    }\n+\n+                    if (interfaces.contains(SyncCorrelationRule.class) && !metadata.isAbstract()) {\n+                        classNames.get(Type.SYNC_CORRELATION_RULES).add(metadata.getClassName());\n+                    }\n+\n+                    // TODO: add push correlation rules management\n+                    if (interfaces.contains(PropagationActions.class) && !metadata.isAbstract()) {\n+                        classNames.get(Type.PROPAGATION_ACTIONS).add(metadata.getClassName());\n+                    }\n+\n+                    if (interfaces.contains(Validator.class) && !metadata.isAbstract()) {\n+                        classNames.get(Type.VALIDATOR).add(metadata.getClassName());\n+                    }\n+                } catch (ClassNotFoundException e) {\n+                    LOG.warn(\"Could not load class {}\", metadata.getClassName());\n+                } catch (LinkageError e) {\n+                    LOG.warn(\"Could not link class {}\", metadata.getClassName());\n+                }\n+            }\n+        } catch (IOException e) {\n+            LOG.error(\"While searching for implementatiom classes\", e);\n+        }\n+\n+        classNames = Collections.unmodifiableMap(classNames);\n+\n+        LOG.debug(\"Implementation classes found: {}\", classNames);\n+    }\n+\n+    public Set<String> getClassNames(final Type type) {\n+        return classNames.get(type);\n+    }\n+}"},{"sha":"89447775424db340d888fe482160328da56d7288","filename":"syncope620/server/logic/src/main/java/org/apache/syncope/server/logic/init/JobInstanceLoader.java","status":"added","additions":287,"deletions":0,"changes":287,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Finit%2FJobInstanceLoader.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Finit%2FJobInstanceLoader.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Finit%2FJobInstanceLoader.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,287 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.server.logic.init;\n+\n+import java.text.ParseException;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.syncope.common.lib.types.TaskType;\n+import org.apache.syncope.persistence.api.dao.ConfDAO;\n+import org.apache.syncope.persistence.api.dao.NotFoundException;\n+import org.apache.syncope.persistence.api.dao.ReportDAO;\n+import org.apache.syncope.persistence.api.dao.TaskDAO;\n+import org.apache.syncope.persistence.api.entity.Report;\n+import org.apache.syncope.persistence.api.entity.conf.CPlainAttr;\n+import org.apache.syncope.persistence.api.entity.task.PushTask;\n+import org.apache.syncope.persistence.api.entity.task.SchedTask;\n+import org.apache.syncope.persistence.api.entity.task.SyncTask;\n+import org.apache.syncope.persistence.api.entity.task.Task;\n+import org.apache.syncope.provisioning.api.job.SyncJob;\n+import org.apache.syncope.provisioning.api.job.TaskJob;\n+import org.apache.syncope.provisioning.api.sync.SyncActions;\n+import org.apache.syncope.server.logic.notification.NotificationJob;\n+import org.apache.syncope.server.logic.report.ReportJob;\n+import org.apache.syncope.server.spring.ApplicationContextProvider;\n+import org.quartz.Job;\n+import org.quartz.JobExecutionContext;\n+import org.quartz.JobKey;\n+import org.quartz.Scheduler;\n+import org.quartz.SchedulerException;\n+import org.quartz.TriggerKey;\n+import org.quartz.impl.JobDetailImpl;\n+import org.quartz.impl.triggers.CronTriggerImpl;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.support.AbstractBeanDefinition;\n+import org.springframework.scheduling.quartz.SchedulerFactoryBean;\n+import org.springframework.stereotype.Component;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+@Component\n+public class JobInstanceLoader {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(JobInstanceLoader.class);\n+\n+    @Autowired\n+    private SchedulerFactoryBean scheduler;\n+\n+    @Autowired\n+    private TaskDAO taskDAO;\n+\n+    @Autowired\n+    private ReportDAO reportDAO;\n+\n+    @Autowired\n+    private ConfDAO confDAO;\n+\n+    private static Long getIdFromJobName(final String name, final String pattern, final int prefixLength) {\n+        Long result = null;\n+\n+        Matcher jobMatcher = Pattern.compile(pattern).matcher(name);\n+        if (jobMatcher.matches()) {\n+            try {\n+                result = Long.valueOf(name.substring(prefixLength));\n+            } catch (NumberFormatException e) {\n+                LOG.error(\"Unparsable id: {}\", name.substring(prefixLength), e);\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    public static Long getTaskIdFromJobName(final String name) {\n+        return getIdFromJobName(\"taskJob[0-9]+\", name, 7);\n+    }\n+\n+    public static Long getReportIdFromJobName(final String name) {\n+        return getIdFromJobName(\"reportJob[0-9]+\", name, 9);\n+    }\n+\n+    public static String getJobName(final Task task) {\n+        return task == null\n+                ? \"taskNotificationJob\"\n+                : \"taskJob\" + task.getKey();\n+    }\n+\n+    public static String getJobName(final Report report) {\n+        return \"reportJob\" + report.getKey();\n+    }\n+\n+    public static String getTriggerName(final String jobName) {\n+        return \"Trigger_\" + jobName;\n+    }\n+\n+    private void registerJob(final String jobName, final Job jobInstance, final String cronExpression)\n+            throws SchedulerException, ParseException {\n+\n+        synchronized (scheduler.getScheduler()) {\n+            boolean jobAlreadyRunning = false;\n+            for (JobExecutionContext jobCtx : scheduler.getScheduler().getCurrentlyExecutingJobs()) {\n+                if (jobName.equals(jobCtx.getJobDetail().getKey().getName())\n+                        && Scheduler.DEFAULT_GROUP.equals(jobCtx.getJobDetail().getKey().getGroup())) {\n+\n+                    jobAlreadyRunning = true;\n+\n+                    LOG.debug(\"Job {} already running, cancel\", jobCtx.getJobDetail().getKey());\n+                }\n+            }\n+\n+            if (jobAlreadyRunning) {\n+                return;\n+            }\n+        }\n+\n+        // 0. unregister job\n+        unregisterJob(jobName);\n+\n+        // 1. Job bean\n+        ApplicationContextProvider.getBeanFactory().registerSingleton(jobName, jobInstance);\n+\n+        // 2. JobDetail bean\n+        JobDetailImpl jobDetail = new JobDetailImpl();\n+        jobDetail.setName(jobName);\n+        jobDetail.setGroup(Scheduler.DEFAULT_GROUP);\n+        jobDetail.setJobClass(jobInstance.getClass());\n+\n+        // 3. Trigger\n+        if (cronExpression == null) {\n+            // Jobs added with no trigger must be durable\n+            jobDetail.setDurability(true);\n+            scheduler.getScheduler().addJob(jobDetail, true);\n+        } else {\n+            CronTriggerImpl cronTrigger = new CronTriggerImpl();\n+            cronTrigger.setName(getTriggerName(jobName));\n+            cronTrigger.setCronExpression(cronExpression);\n+\n+            scheduler.getScheduler().scheduleJob(jobDetail, cronTrigger);\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void registerJob(final Task task, final String jobClassName, final String cronExpression)\n+            throws ClassNotFoundException, SchedulerException, ParseException {\n+\n+        final Class<?> jobClass = Class.forName(jobClassName);\n+        Job jobInstance = (Job) ApplicationContextProvider.getBeanFactory().\n+                createBean(jobClass, AbstractBeanDefinition.AUTOWIRE_BY_TYPE, false);\n+        if (jobInstance instanceof TaskJob) {\n+            ((TaskJob) jobInstance).setTaskId(task.getKey());\n+        }\n+\n+        // In case of synchronization job/task retrieve and set synchronization actions:\n+        // actions cannot be changed at runtime but connector and synchronization policies (reloaded at execution time).\n+        if (jobInstance instanceof SyncJob && task instanceof SyncTask) {\n+            final List<SyncActions> actions = new ArrayList<>();\n+            for (String className : ((SyncTask) task).getActionsClassNames()) {\n+                try {\n+                    Class<?> actionsClass = Class.forName(className);\n+\n+                    final SyncActions syncActions =\n+                            (SyncActions) ApplicationContextProvider.getBeanFactory().\n+                            createBean(actionsClass, AbstractBeanDefinition.AUTOWIRE_BY_TYPE, true);\n+\n+                    actions.add(syncActions);\n+                } catch (Exception e) {\n+                    LOG.info(\"Class '{}' not found\", className, e);\n+                }\n+            }\n+\n+            ((SyncJob) jobInstance).setActions(actions);\n+        }\n+\n+        registerJob(getJobName(task), jobInstance, cronExpression);\n+    }\n+\n+    @Transactional(readOnly = true)\n+    public void registerTaskJob(final Long taskId)\n+            throws ClassNotFoundException, SchedulerException, ParseException {\n+\n+        SchedTask task = taskDAO.find(taskId);\n+        if (task == null) {\n+            throw new NotFoundException(\"Task \" + taskId);\n+        } else {\n+            registerJob(task, task.getJobClassName(), task.getCronExpression());\n+        }\n+    }\n+\n+    public void registerJob(final Report report) throws SchedulerException, ParseException {\n+        Job jobInstance = (Job) ApplicationContextProvider.getBeanFactory().\n+                createBean(ReportJob.class, AbstractBeanDefinition.AUTOWIRE_BY_TYPE, false);\n+        ((ReportJob) jobInstance).setReportKey(report.getKey());\n+\n+        registerJob(getJobName(report), jobInstance, report.getCronExpression());\n+    }\n+\n+    @Transactional(readOnly = true)\n+    public void registerReportJob(final Long reportId) throws SchedulerException, ParseException {\n+        Report report = reportDAO.find(reportId);\n+        if (report == null) {\n+            throw new NotFoundException(\"Report \" + reportId);\n+        } else {\n+            registerJob(report);\n+        }\n+    }\n+\n+    private void unregisterJob(final String jobName) {\n+        try {\n+            scheduler.getScheduler().unscheduleJob(new TriggerKey(jobName, Scheduler.DEFAULT_GROUP));\n+            scheduler.getScheduler().deleteJob(new JobKey(jobName, Scheduler.DEFAULT_GROUP));\n+        } catch (SchedulerException e) {\n+            LOG.error(\"Could not remove job \" + jobName, e);\n+        }\n+\n+        if (ApplicationContextProvider.getBeanFactory().containsSingleton(jobName)) {\n+            ApplicationContextProvider.getBeanFactory().destroySingleton(jobName);\n+        }\n+    }\n+\n+    public void unregisterJob(final Task task) {\n+        unregisterJob(getJobName(task));\n+    }\n+\n+    public void unregisterJob(final Report report) {\n+        unregisterJob(getJobName(report));\n+    }\n+\n+    @Transactional\n+    public void load() {\n+        // 1. jobs for SchedTasks\n+        Set<SchedTask> tasks = new HashSet<>(taskDAO.<SchedTask>findAll(TaskType.SCHEDULED));\n+        tasks.addAll(taskDAO.<SyncTask>findAll(TaskType.SYNCHRONIZATION));\n+        tasks.addAll(taskDAO.<PushTask>findAll(TaskType.PUSH));\n+        for (SchedTask task : tasks) {\n+            try {\n+                registerJob(task, task.getJobClassName(), task.getCronExpression());\n+            } catch (Exception e) {\n+                LOG.error(\"While loading job instance for task \" + task.getKey(), e);\n+            }\n+        }\n+\n+        // 2. NotificationJob\n+        CPlainAttr notificationJobCronExp =\n+                confDAO.find(\"notificationjob.cronExpression\", NotificationJob.DEFAULT_CRON_EXP);\n+        if (StringUtils.isBlank(notificationJobCronExp.getValuesAsStrings().get(0))) {\n+            LOG.debug(\"Empty value provided for NotificationJob's cron, not registering anything on Quartz\");\n+        } else {\n+            LOG.debug(\"NotificationJob's cron expression: {} - registering Quartz job and trigger\",\n+                    notificationJobCronExp);\n+\n+            try {\n+                registerJob(null, NotificationJob.class.getName(), notificationJobCronExp.getValuesAsStrings().get(0));\n+            } catch (Exception e) {\n+                LOG.error(\"While loading NotificationJob instance\", e);\n+            }\n+        }\n+\n+        // 3. ReportJobs\n+        for (Report report : reportDAO.findAll()) {\n+            try {\n+                registerJob(report);\n+            } catch (Exception e) {\n+                LOG.error(\"While loading job instance for report \" + report.getName(), e);\n+            }\n+        }\n+    }\n+}"},{"sha":"58442775f52ec7f6c6c4b41ee82e23b3e03fcbf8","filename":"syncope620/server/logic/src/main/java/org/apache/syncope/server/logic/init/WorkflowAdapterLoader.java","status":"added","additions":88,"deletions":0,"changes":88,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Finit%2FWorkflowAdapterLoader.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Finit%2FWorkflowAdapterLoader.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Finit%2FWorkflowAdapterLoader.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,88 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.server.logic.init;\n+\n+import org.apache.syncope.server.workflow.api.RoleWorkflowAdapter;\n+import org.apache.syncope.server.workflow.api.UserWorkflowAdapter;\n+import org.apache.syncope.server.workflow.api.WorkflowInstanceLoader;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.BeansException;\n+import org.springframework.beans.factory.BeanFactory;\n+import org.springframework.beans.factory.BeanFactoryAware;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.support.AbstractBeanDefinition;\n+import org.springframework.beans.factory.support.DefaultListableBeanFactory;\n+import org.springframework.stereotype.Component;\n+\n+@Component\n+public class WorkflowAdapterLoader implements BeanFactoryAware {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(WorkflowAdapterLoader.class);\n+\n+    @Autowired\n+    private UserWorkflowAdapter uwfAdapter;\n+\n+    @Autowired\n+    private RoleWorkflowAdapter rwfAdapter;\n+\n+    private DefaultListableBeanFactory beanFactory;\n+\n+    private WorkflowInstanceLoader wfLoader;\n+\n+    @Override\n+    public void setBeanFactory(final BeanFactory beanFactory) throws BeansException {\n+        this.beanFactory = (DefaultListableBeanFactory) beanFactory;\n+    }\n+\n+    private void lazyInit() {\n+        if (wfLoader == null) {\n+            if (uwfAdapter.getLoaderClass() != null) {\n+                wfLoader = (WorkflowInstanceLoader) beanFactory.createBean(\n+                        uwfAdapter.getLoaderClass(), AbstractBeanDefinition.AUTOWIRE_BY_TYPE, false);\n+            }\n+            if (rwfAdapter.getLoaderClass() != null) {\n+                wfLoader = (WorkflowInstanceLoader) beanFactory.createBean(\n+                        rwfAdapter.getLoaderClass(), AbstractBeanDefinition.AUTOWIRE_BY_TYPE, false);\n+            }\n+        }\n+    }\n+\n+    public String getTablePrefix() {\n+        lazyInit();\n+        return wfLoader == null ? null : wfLoader.getTablePrefix();\n+    }\n+\n+    public void init() {\n+        lazyInit();\n+        if (wfLoader != null) {\n+            wfLoader.init();\n+        }\n+    }\n+\n+    public void load() {\n+        lazyInit();\n+        if (wfLoader == null) {\n+            LOG.debug(\"Configured workflow adapter does not need loading\");\n+        } else {\n+            LOG.debug(\"Loading workflow adapter by {}\", wfLoader.getClass().getName());\n+            wfLoader.load();\n+        }\n+    }\n+}"},{"sha":"77189e1922c36971e050d815cdb65d180ca8ac33","filename":"syncope620/server/logic/src/main/java/org/apache/syncope/server/logic/notification/NotificationJob.java","status":"added","additions":280,"deletions":0,"changes":280,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Fnotification%2FNotificationJob.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Fnotification%2FNotificationJob.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Fnotification%2FNotificationJob.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,280 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.server.logic.notification;\n+\n+import java.util.Date;\n+import java.util.Properties;\n+import javax.mail.internet.MimeMessage;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.syncope.common.lib.types.AuditElements;\n+import org.apache.syncope.common.lib.types.AuditElements.Result;\n+import org.apache.syncope.common.lib.types.TaskType;\n+import org.apache.syncope.common.lib.types.TraceLevel;\n+import org.apache.syncope.persistence.api.dao.TaskDAO;\n+import org.apache.syncope.persistence.api.entity.EntityFactory;\n+import org.apache.syncope.persistence.api.entity.task.NotificationTask;\n+import org.apache.syncope.persistence.api.entity.task.TaskExec;\n+import org.apache.syncope.server.logic.audit.AuditManager;\n+import org.apache.syncope.server.utils.ExceptionUtil;\n+import org.quartz.DisallowConcurrentExecution;\n+import org.quartz.Job;\n+import org.quartz.JobExecutionContext;\n+import org.quartz.JobExecutionException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.mail.javamail.JavaMailSender;\n+import org.springframework.mail.javamail.JavaMailSenderImpl;\n+import org.springframework.mail.javamail.MimeMessageHelper;\n+\n+/**\n+ * Periodically checks for notification to send.\n+ *\n+ * @see NotificationTask\n+ */\n+@DisallowConcurrentExecution\n+public class NotificationJob implements Job {\n+\n+    enum Status {\n+\n+        SENT,\n+        NOT_SENT\n+\n+    }\n+\n+    public static final String DEFAULT_CRON_EXP = \"0 0/5 * * * ?\";\n+\n+    /**\n+     * Logger.\n+     */\n+    private static final Logger LOG = LoggerFactory.getLogger(NotificationJob.class);\n+\n+    @Autowired\n+    private AuditManager auditManager;\n+\n+    @Autowired\n+    private NotificationManager notificationManager;\n+\n+    @Autowired\n+    private JavaMailSender mailSender;\n+\n+    @Autowired\n+    private EntityFactory entityFactory;\n+\n+    /**\n+     * Task DAO.\n+     */\n+    @Autowired\n+    private TaskDAO taskDAO;\n+\n+    private long maxRetries;\n+\n+    private void init() {\n+        maxRetries = notificationManager.getMaxRetries();\n+\n+        if (mailSender instanceof JavaMailSenderImpl\n+                && StringUtils.isNotBlank(((JavaMailSenderImpl) mailSender).getUsername())) {\n+\n+            Properties javaMailProperties = ((JavaMailSenderImpl) mailSender).getJavaMailProperties();\n+            javaMailProperties.setProperty(\"mail.smtp.auth\", \"true\");\n+            ((JavaMailSenderImpl) mailSender).setJavaMailProperties(javaMailProperties);\n+        }\n+    }\n+\n+    public TaskExec executeSingle(final NotificationTask task) {\n+        init();\n+\n+        TaskExec execution = entityFactory.newEntity(TaskExec.class);\n+        execution.setTask(task);\n+        execution.setStartDate(new Date());\n+\n+        boolean retryPossible = true;\n+\n+        if (StringUtils.isBlank(task.getSubject()) || task.getRecipients().isEmpty()\n+                || StringUtils.isBlank(task.getHtmlBody()) || StringUtils.isBlank(task.getTextBody())) {\n+\n+            String message = \"Could not fetch all required information for sending e-mails:\\n\"\n+                    + task.getRecipients() + \"\\n\"\n+                    + task.getSender() + \"\\n\"\n+                    + task.getSubject() + \"\\n\"\n+                    + task.getHtmlBody() + \"\\n\"\n+                    + task.getTextBody();\n+            LOG.error(message);\n+\n+            execution.setStatus(Status.NOT_SENT.name());\n+            retryPossible = false;\n+\n+            if (task.getTraceLevel().ordinal() >= TraceLevel.FAILURES.ordinal()) {\n+                execution.setMessage(message);\n+            }\n+        } else {\n+            if (LOG.isDebugEnabled()) {\n+                LOG.debug(\"About to send e-mails:\\n\"\n+                        + task.getRecipients() + \"\\n\"\n+                        + task.getSender() + \"\\n\"\n+                        + task.getSubject() + \"\\n\"\n+                        + task.getHtmlBody() + \"\\n\"\n+                        + task.getTextBody() + \"\\n\");\n+            }\n+\n+            for (String to : task.getRecipients()) {\n+                try {\n+                    MimeMessage message = mailSender.createMimeMessage();\n+                    MimeMessageHelper helper = new MimeMessageHelper(message, true);\n+                    helper.setTo(to);\n+                    helper.setFrom(task.getSender());\n+                    helper.setSubject(task.getSubject());\n+                    helper.setText(task.getTextBody(), task.getHtmlBody());\n+\n+                    mailSender.send(message);\n+\n+                    execution.setStatus(Status.SENT.name());\n+\n+                    StringBuilder report = new StringBuilder();\n+                    switch (task.getTraceLevel()) {\n+                        case ALL:\n+                            report.append(\"FROM: \").append(task.getSender()).append('\\n').\n+                                    append(\"TO: \").append(to).append('\\n').\n+                                    append(\"SUBJECT: \").append(task.getSubject()).append('\\n').append('\\n').\n+                                    append(task.getTextBody()).append('\\n').append('\\n').\n+                                    append(task.getHtmlBody()).append('\\n');\n+                            break;\n+\n+                        case SUMMARY:\n+                            report.append(\"E-mail sent to \").append(to).append('\\n');\n+                            break;\n+\n+                        case FAILURES:\n+                        case NONE:\n+                        default:\n+                    }\n+                    if (report.length() > 0) {\n+                        execution.setMessage(report.toString());\n+                    }\n+\n+                    auditManager.audit(\n+                            AuditElements.EventCategoryType.TASK,\n+                            \"notification\",\n+                            null,\n+                            \"send\",\n+                            Result.SUCCESS,\n+                            null,\n+                            null,\n+                            task,\n+                            \"Successfully sent notification to \" + to);\n+                } catch (Exception e) {\n+                    LOG.error(\"Could not send e-mail\", e);\n+\n+                    execution.setStatus(Status.NOT_SENT.name());\n+                    if (task.getTraceLevel().ordinal() >= TraceLevel.FAILURES.ordinal()) {\n+                        execution.setMessage(ExceptionUtil.getFullStackTrace(e));\n+                    }\n+\n+                    auditManager.audit(\n+                            AuditElements.EventCategoryType.TASK,\n+                            \"notification\",\n+                            null,\n+                            \"send\",\n+                            Result.FAILURE,\n+                            null,\n+                            null,\n+                            task,\n+                            \"Could not send notification to \" + to, e);\n+                }\n+\n+                execution.setEndDate(new Date());\n+            }\n+        }\n+\n+        if (hasToBeRegistered(execution)) {\n+            execution = notificationManager.storeExec(execution);\n+            if (retryPossible && (Status.valueOf(execution.getStatus()) == Status.NOT_SENT)) {\n+                handleRetries(execution);\n+            }\n+        } else {\n+            notificationManager.setTaskExecuted(execution.getTask().getKey(), true);\n+        }\n+\n+        return execution;\n+    }\n+\n+    @Override\n+    public void execute(final JobExecutionContext context)\n+            throws JobExecutionException {\n+\n+        LOG.debug(\"Waking up...\");\n+\n+        for (NotificationTask task : taskDAO.<NotificationTask>findToExec(TaskType.NOTIFICATION)) {\n+            LOG.debug(\"Found notification task {} to be executed: starting...\", task);\n+            executeSingle(task);\n+            LOG.debug(\"Notification task {} executed\", task);\n+        }\n+\n+        LOG.debug(\"Sleeping again...\");\n+    }\n+\n+    private boolean hasToBeRegistered(final TaskExec execution) {\n+        NotificationTask task = (NotificationTask) execution.getTask();\n+\n+        // True if either failed and failures have to be registered, or if ALL\n+        // has to be registered.\n+        return (Status.valueOf(execution.getStatus()) == Status.NOT_SENT\n+                && task.getTraceLevel().ordinal() >= TraceLevel.FAILURES.ordinal())\n+                || task.getTraceLevel() == TraceLevel.ALL;\n+    }\n+\n+    private void handleRetries(final TaskExec execution) {\n+        if (maxRetries <= 0) {\n+            return;\n+        }\n+\n+        long failedExecutionsCount = notificationManager.countExecutionsWithStatus(\n+                execution.getTask().getKey(), Status.NOT_SENT.name());\n+\n+        if (failedExecutionsCount <= maxRetries) {\n+            LOG.debug(\"Execution of notification task {} will be retried [{}/{}]\",\n+                    execution.getTask(), failedExecutionsCount, maxRetries);\n+            notificationManager.setTaskExecuted(execution.getTask().getKey(), false);\n+\n+            auditManager.audit(\n+                    AuditElements.EventCategoryType.TASK,\n+                    \"notification\",\n+                    null,\n+                    \"retry\",\n+                    Result.SUCCESS,\n+                    null,\n+                    null,\n+                    execution,\n+                    \"Notification task \" + execution.getTask().getKey() + \" will be retried\");\n+        } else {\n+            LOG.error(\"Maximum number of retries reached for task {} - giving up\", execution.getTask());\n+\n+            auditManager.audit(\n+                    AuditElements.EventCategoryType.TASK,\n+                    \"notification\",\n+                    null,\n+                    \"retry\",\n+                    Result.FAILURE,\n+                    null,\n+                    null,\n+                    execution,\n+                    \"Giving up retries on notification task \" + execution.getTask().getKey());\n+        }\n+    }\n+}"},{"sha":"68c3a788e607ba27d7c0fbee75852174436b193e","filename":"syncope620/server/logic/src/main/java/org/apache/syncope/server/logic/notification/NotificationManager.java","status":"added","additions":441,"deletions":0,"changes":441,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Fnotification%2FNotificationManager.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Fnotification%2FNotificationManager.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Fnotification%2FNotificationManager.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,441 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.server.logic.notification;\n+\n+import java.io.StringWriter;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.apache.syncope.common.lib.SyncopeConstants;\n+import org.apache.syncope.common.lib.to.RoleTO;\n+import org.apache.syncope.common.lib.to.UserTO;\n+import org.apache.syncope.common.lib.types.AttributableType;\n+import org.apache.syncope.common.lib.types.AuditElements;\n+import org.apache.syncope.common.lib.types.AuditElements.Result;\n+import org.apache.syncope.common.lib.types.AuditLoggerName;\n+import org.apache.syncope.common.lib.types.IntMappingType;\n+import org.apache.syncope.common.lib.types.SubjectType;\n+import org.apache.syncope.persistence.api.RoleEntitlementUtil;\n+import org.apache.syncope.persistence.api.dao.ConfDAO;\n+import org.apache.syncope.persistence.api.dao.EntitlementDAO;\n+import org.apache.syncope.persistence.api.dao.NotificationDAO;\n+import org.apache.syncope.persistence.api.dao.RoleDAO;\n+import org.apache.syncope.persistence.api.dao.SubjectSearchDAO;\n+import org.apache.syncope.persistence.api.dao.TaskDAO;\n+import org.apache.syncope.persistence.api.dao.UserDAO;\n+import org.apache.syncope.persistence.api.dao.search.OrderByClause;\n+import org.apache.syncope.persistence.api.entity.Attributable;\n+import org.apache.syncope.persistence.api.entity.AttributableUtilFactory;\n+import org.apache.syncope.persistence.api.entity.EntityFactory;\n+import org.apache.syncope.persistence.api.entity.Notification;\n+import org.apache.syncope.persistence.api.entity.PlainAttr;\n+import org.apache.syncope.persistence.api.entity.Subject;\n+import org.apache.syncope.persistence.api.entity.role.Role;\n+import org.apache.syncope.persistence.api.entity.task.NotificationTask;\n+import org.apache.syncope.persistence.api.entity.task.TaskExec;\n+import org.apache.syncope.persistence.api.entity.user.UDerAttr;\n+import org.apache.syncope.persistence.api.entity.user.UPlainAttr;\n+import org.apache.syncope.persistence.api.entity.user.UVirAttr;\n+import org.apache.syncope.persistence.api.entity.user.User;\n+import org.apache.syncope.server.logic.data.RoleDataBinder;\n+import org.apache.syncope.server.logic.data.UserDataBinder;\n+import org.apache.syncope.server.logic.search.SearchCondConverter;\n+import org.apache.syncope.server.utils.ConnObjectUtil;\n+import org.apache.velocity.VelocityContext;\n+import org.apache.velocity.app.VelocityEngine;\n+import org.apache.velocity.context.Context;\n+import org.apache.velocity.exception.VelocityException;\n+import org.apache.velocity.tools.ToolManager;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+/**\n+ * Create notification tasks that will be executed by NotificationJob.\n+ *\n+ * @see NotificationTask\n+ */\n+@Transactional(rollbackFor = { Throwable.class })\n+public class NotificationManager {\n+\n+    /**\n+     * Logger.\n+     */\n+    private static final Logger LOG = LoggerFactory.getLogger(NotificationManager.class);\n+\n+    public static final String MAIL_TEMPLATES = \"mailTemplates/\";\n+\n+    public static final String MAIL_TEMPLATE_HTML_SUFFIX = \".html.vm\";\n+\n+    public static final String MAIL_TEMPLATE_TEXT_SUFFIX = \".txt.vm\";\n+\n+    /**\n+     * Notification DAO.\n+     */\n+    @Autowired\n+    private NotificationDAO notificationDAO;\n+\n+    /**\n+     * Configuration DAO.\n+     */\n+    @Autowired\n+    private ConfDAO confDAO;\n+\n+    /**\n+     * User DAO.\n+     */\n+    @Autowired\n+    private UserDAO userDAO;\n+\n+    /**\n+     * Role DAO.\n+     */\n+    @Autowired\n+    private RoleDAO roleDAO;\n+\n+    /**\n+     * User data binder.\n+     */\n+    @Autowired\n+    private UserDataBinder userDataBinder;\n+\n+    /**\n+     * Role data binder.\n+     */\n+    @Autowired\n+    private RoleDataBinder roleDataBinder;\n+\n+    /**\n+     * User Search DAO.\n+     */\n+    @Autowired\n+    private SubjectSearchDAO searchDAO;\n+\n+    /**\n+     * Task DAO.\n+     */\n+    @Autowired\n+    private TaskDAO taskDAO;\n+\n+    /**\n+     * Velocity template engine.\n+     */\n+    @Autowired\n+    private VelocityEngine velocityEngine;\n+\n+    /**\n+     * Velocity tool manager.\n+     */\n+    @Autowired\n+    private ToolManager velocityToolManager;\n+\n+    @Autowired\n+    private EntitlementDAO entitlementDAO;\n+\n+    @Autowired\n+    private ConnObjectUtil connObjectUtil;\n+\n+    @Autowired\n+    private EntityFactory entityFactory;\n+\n+    @Autowired\n+    private AttributableUtilFactory attrUtilFactory;\n+\n+    @Transactional(readOnly = true)\n+    public long getMaxRetries() {\n+        return confDAO.find(\"notification.maxRetries\", \"0\").getValues().get(0).getLongValue();\n+    }\n+\n+    /**\n+     * Create a notification task.\n+     *\n+     * @param notification notification to take as model\n+     * @param attributable the user this task is about\n+     * @param model Velocity model\n+     * @return notification task, fully populated\n+     */\n+    private NotificationTask getNotificationTask(\n+            final Notification notification,\n+            final Attributable<?, ?, ?> attributable,\n+            final Map<String, Object> model) {\n+\n+        if (attributable != null) {\n+            connObjectUtil.retrieveVirAttrValues(attributable,\n+                    attrUtilFactory.getInstance(\n+                            attributable instanceof User ? AttributableType.USER : AttributableType.ROLE));\n+        }\n+\n+        final List<User> recipients = new ArrayList<>();\n+\n+        if (notification.getRecipients() != null) {\n+            recipients.addAll(searchDAO.<User>search(RoleEntitlementUtil.getRoleKeys(entitlementDAO.findAll()),\n+                    SearchCondConverter.convert(notification.getRecipients()),\n+                    Collections.<OrderByClause>emptyList(), SubjectType.USER));\n+        }\n+\n+        if (notification.isSelfAsRecipient() && attributable instanceof User) {\n+            recipients.add((User) attributable);\n+        }\n+\n+        final Set<String> recipientEmails = new HashSet<>();\n+        final List<UserTO> recipientTOs = new ArrayList<>(recipients.size());\n+        for (User recipient : recipients) {\n+            connObjectUtil.retrieveVirAttrValues(recipient, attrUtilFactory.getInstance(AttributableType.USER));\n+\n+            String email = getRecipientEmail(notification.getRecipientAttrType(),\n+                    notification.getRecipientAttrName(), recipient);\n+            if (email == null) {\n+                LOG.warn(\"{} cannot be notified: {} not found\", recipient, notification.getRecipientAttrName());\n+            } else {\n+                recipientEmails.add(email);\n+                recipientTOs.add(userDataBinder.getUserTO(recipient));\n+            }\n+        }\n+\n+        if (notification.getStaticRecipients() != null) {\n+            recipientEmails.addAll(notification.getStaticRecipients());\n+        }\n+\n+        model.put(\"recipients\", recipientTOs);\n+        model.put(\"syncopeConf\", this.findAllSyncopeConfs());\n+        model.put(\"events\", notification.getEvents());\n+\n+        NotificationTask task = entityFactory.newEntity(NotificationTask.class);\n+        task.setTraceLevel(notification.getTraceLevel());\n+        task.getRecipients().addAll(recipientEmails);\n+        task.setSender(notification.getSender());\n+        task.setSubject(notification.getSubject());\n+\n+        String htmlBody = mergeTemplateIntoString(\n+                MAIL_TEMPLATES + notification.getTemplate() + MAIL_TEMPLATE_HTML_SUFFIX, model);\n+        String textBody = mergeTemplateIntoString(\n+                MAIL_TEMPLATES + notification.getTemplate() + MAIL_TEMPLATE_TEXT_SUFFIX, model);\n+\n+        task.setHtmlBody(htmlBody);\n+        task.setTextBody(textBody);\n+\n+        return task;\n+    }\n+\n+    private String mergeTemplateIntoString(final String templateLocation, final Map<String, Object> model) {\n+        StringWriter result = new StringWriter();\n+        try {\n+            Context velocityContext = createVelocityContext(model);\n+            velocityEngine.mergeTemplate(templateLocation, SyncopeConstants.DEFAULT_ENCODING, velocityContext, result);\n+        } catch (VelocityException e) {\n+            LOG.error(\"Could not get mail body\", e);\n+        } catch (RuntimeException e) {\n+            // ensure same behaviour as by using Spring VelocityEngineUtils.mergeTemplateIntoString()\n+            throw e;\n+        } catch (Exception e) {\n+            LOG.error(\"Could not get mail body\", e);\n+        }\n+\n+        return result.toString();\n+    }\n+\n+    /**\n+     * Create a Velocity Context for the given model, to be passed to the template for merging.\n+     *\n+     * @param model Velocity model\n+     * @return Velocity context\n+     */\n+    protected Context createVelocityContext(Map<String, Object> model) {\n+        Context toolContext = velocityToolManager.createContext();\n+        return new VelocityContext(model, toolContext);\n+    }\n+\n+    /**\n+     * Create notification tasks for each notification matching the given user id and (some of) tasks performed.\n+     */\n+    public void createTasks(\n+            final AuditElements.EventCategoryType type,\n+            final String category,\n+            final String subcategory,\n+            final String event,\n+            final Result condition,\n+            final Object before,\n+            final Object output,\n+            final Object... input) {\n+\n+        SubjectType subjectType = null;\n+        Subject<?, ?, ?> subject = null;\n+\n+        if (before instanceof UserTO) {\n+            subjectType = SubjectType.USER;\n+            subject = userDAO.find(((UserTO) before).getKey());\n+        } else if (output instanceof UserTO) {\n+            subjectType = SubjectType.USER;\n+            subject = userDAO.find(((UserTO) output).getKey());\n+        } else if (before instanceof RoleTO) {\n+            subjectType = SubjectType.ROLE;\n+            subject = roleDAO.find(((RoleTO) before).getKey());\n+        } else if (output instanceof RoleTO) {\n+            subjectType = SubjectType.ROLE;\n+            subject = roleDAO.find(((RoleTO) output).getKey());\n+        }\n+\n+        LOG.debug(\"Search notification for [{}]{}\", subjectType, subject);\n+\n+        for (Notification notification : notificationDAO.findAll()) {\n+            LOG.debug(\"Notification available user about {}\", notification.getUserAbout());\n+            LOG.debug(\"Notification available role about {}\", notification.getRoleAbout());\n+            if (notification.isActive()) {\n+\n+                final Set<String> events = new HashSet<>(notification.getEvents());\n+                events.retainAll(Collections.<String>singleton(AuditLoggerName.buildEvent(\n+                        type, category, subcategory, event, condition)));\n+\n+                if (events.isEmpty()) {\n+                    LOG.debug(\"No events found about {}\", subject);\n+                } else if (subjectType == null || subject == null\n+                        || notification.getUserAbout() == null || notification.getRoleAbout() == null\n+                        || searchDAO.matches(subject,\n+                                SearchCondConverter.convert(notification.getUserAbout()), subjectType)\n+                        || searchDAO.matches(subject,\n+                                SearchCondConverter.convert(notification.getRoleAbout()), subjectType)) {\n+\n+                    LOG.debug(\"Creating notification task for events {} about {}\", events, subject);\n+\n+                    final Map<String, Object> model = new HashMap<>();\n+                    model.put(\"type\", type);\n+                    model.put(\"category\", category);\n+                    model.put(\"subcategory\", subcategory);\n+                    model.put(\"event\", event);\n+                    model.put(\"condition\", condition);\n+                    model.put(\"before\", before);\n+                    model.put(\"output\", output);\n+                    model.put(\"input\", input);\n+\n+                    if (subject instanceof User) {\n+                        model.put(\"user\", userDataBinder.getUserTO((User) subject));\n+                    } else if (subject instanceof Role) {\n+                        model.put(\"role\", roleDataBinder.getRoleTO((Role) subject));\n+                    }\n+\n+                    taskDAO.save(getNotificationTask(notification, subject, model));\n+                }\n+            } else {\n+                LOG.debug(\"Notification {}, userAbout {}, roleAbout {} is deactivated, \"\n+                        + \"notification task will not be created\", notification.getKey(),\n+                        notification.getUserAbout(), notification.getRoleAbout());\n+            }\n+        }\n+    }\n+\n+    private String getRecipientEmail(\n+            final IntMappingType recipientAttrType, final String recipientAttrName, final User user) {\n+\n+        String email = null;\n+\n+        switch (recipientAttrType) {\n+            case Username:\n+                email = user.getUsername();\n+                break;\n+\n+            case UserSchema:\n+                UPlainAttr attr = user.getPlainAttr(recipientAttrName);\n+                if (attr != null && !attr.getValuesAsStrings().isEmpty()) {\n+                    email = attr.getValuesAsStrings().get(0);\n+                }\n+                break;\n+\n+            case UserVirtualSchema:\n+                UVirAttr virAttr = user.getVirAttr(recipientAttrName);\n+                if (virAttr != null && !virAttr.getValues().isEmpty()) {\n+                    email = virAttr.getValues().get(0);\n+                }\n+                break;\n+\n+            case UserDerivedSchema:\n+                UDerAttr derAttr = user.getDerAttr(recipientAttrName);\n+                if (derAttr != null) {\n+                    email = derAttr.getValue(user.getPlainAttrs());\n+                }\n+                break;\n+\n+            default:\n+        }\n+\n+        return email;\n+    }\n+\n+    /**\n+     * Store execution of a NotificationTask.\n+     *\n+     * @param execution task execution.\n+     * @return merged task execution.\n+     */\n+    public TaskExec storeExec(final TaskExec execution) {\n+        NotificationTask task = taskDAO.find(execution.getTask().getKey());\n+        task.addExec(execution);\n+        task.setExecuted(true);\n+        taskDAO.save(task);\n+        // this flush call is needed to generate a value for the execution id\n+        taskDAO.flush();\n+        return execution;\n+    }\n+\n+    /**\n+     * Set execution state of NotificationTask with provided id.\n+     *\n+     * @param taskId task to be updated\n+     * @param executed execution state\n+     */\n+    public void setTaskExecuted(final Long taskId, final boolean executed) {\n+        NotificationTask task = taskDAO.find(taskId);\n+        task.setExecuted(executed);\n+        taskDAO.save(task);\n+    }\n+\n+    /**\n+     * Count the number of task executions of a given task with a given status.\n+     *\n+     * @param taskId task id\n+     * @param status status\n+     * @return number of task executions\n+     */\n+    public long countExecutionsWithStatus(final Long taskId, final String status) {\n+        NotificationTask task = taskDAO.find(taskId);\n+        long count = 0;\n+        for (TaskExec taskExec : task.getExecs()) {\n+            if (status == null) {\n+                if (taskExec.getStatus() == null) {\n+                    count++;\n+                }\n+            } else if (status.equals(taskExec.getStatus())) {\n+                count++;\n+            }\n+        }\n+        return count;\n+    }\n+\n+    protected Map<String, String> findAllSyncopeConfs() {\n+        Map<String, String> syncopeConfMap = new HashMap<>();\n+        for (PlainAttr attr : confDAO.get().getPlainAttrs()) {\n+            syncopeConfMap.put(attr.getSchema().getKey(), attr.getValuesAsStrings().get(0));\n+        }\n+        return syncopeConfMap;\n+    }\n+}"},{"sha":"8c8661b43466c2fef0a341987a51bbb77eb4e467","filename":"syncope620/server/logic/src/main/java/org/apache/syncope/server/logic/report/AbstractReportlet.java","status":"added","additions":66,"deletions":0,"changes":66,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Freport%2FAbstractReportlet.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Freport%2FAbstractReportlet.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Freport%2FAbstractReportlet.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,66 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.server.logic.report;\n+\n+import org.apache.syncope.common.lib.report.AbstractReportletConf;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.transaction.annotation.Transactional;\n+import org.xml.sax.ContentHandler;\n+import org.xml.sax.SAXException;\n+import org.xml.sax.helpers.AttributesImpl;\n+\n+public abstract class AbstractReportlet<T extends AbstractReportletConf> implements Reportlet<T> {\n+\n+    /**\n+     * Logger.\n+     */\n+    protected static final Logger LOG = LoggerFactory.getLogger(AbstractReportlet.class);\n+\n+    protected T conf;\n+\n+    public T getConf() {\n+        return conf;\n+    }\n+\n+    @Override\n+    public void setConf(final T conf) {\n+        this.conf = conf;\n+    }\n+\n+    protected abstract void doExtract(ContentHandler handler) throws SAXException, ReportException;\n+\n+    @Override\n+    @Transactional(readOnly = true)\n+    public void extract(final ContentHandler handler) throws SAXException, ReportException {\n+\n+        if (conf == null) {\n+            throw new ReportException(new IllegalArgumentException(\"No configuration provided\"));\n+        }\n+\n+        AttributesImpl atts = new AttributesImpl();\n+        atts.addAttribute(\"\", \"\", ReportXMLConst.ATTR_NAME, ReportXMLConst.XSD_STRING, conf.getName());\n+        atts.addAttribute(\"\", \"\", ReportXMLConst.ATTR_CLASS, ReportXMLConst.XSD_STRING, getClass().getName());\n+        handler.startElement(\"\", \"\", ReportXMLConst.ELEMENT_REPORTLET, atts);\n+\n+        doExtract(handler);\n+\n+        handler.endElement(\"\", \"\", ReportXMLConst.ELEMENT_REPORTLET);\n+    }\n+}"},{"sha":"b8d311b2631acded535504d6828387c0fccf9ad4","filename":"syncope620/server/logic/src/main/java/org/apache/syncope/server/logic/report/ReportException.java","status":"added","additions":32,"deletions":0,"changes":32,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Freport%2FReportException.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Freport%2FReportException.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Freport%2FReportException.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,32 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.server.logic.report;\n+\n+public class ReportException extends RuntimeException {\n+\n+    private static final long serialVersionUID = 6719507778589395283L;\n+\n+    public ReportException(final Throwable cause) {\n+        super(cause);\n+    }\n+\n+    public ReportException(final String message, final Throwable cause) {\n+        super(message, cause);\n+    }\n+}"},{"sha":"ca5970516d41c797c3b8fbc3010516eb15217e51","filename":"syncope620/server/logic/src/main/java/org/apache/syncope/server/logic/report/ReportJob.java","status":"added","additions":206,"deletions":0,"changes":206,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Freport%2FReportJob.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Freport%2FReportJob.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Freport%2FReportJob.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,206 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.server.logic.report;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.util.Date;\n+import java.util.zip.Deflater;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipOutputStream;\n+import javax.xml.transform.OutputKeys;\n+import javax.xml.transform.Transformer;\n+import javax.xml.transform.sax.SAXTransformerFactory;\n+import javax.xml.transform.sax.TransformerHandler;\n+import javax.xml.transform.stream.StreamResult;\n+import org.apache.commons.io.IOUtils;\n+import org.apache.syncope.common.lib.SyncopeConstants;\n+import org.apache.syncope.common.lib.report.ReportletConf;\n+import org.apache.syncope.common.lib.types.ReportExecStatus;\n+import org.apache.syncope.persistence.api.dao.ReportDAO;\n+import org.apache.syncope.persistence.api.dao.ReportExecDAO;\n+import org.apache.syncope.persistence.api.entity.EntityFactory;\n+import org.apache.syncope.persistence.api.entity.Report;\n+import org.apache.syncope.persistence.api.entity.ReportExec;\n+import org.apache.syncope.server.logic.data.ReportDataBinder;\n+import org.apache.syncope.server.spring.ApplicationContextProvider;\n+import org.apache.syncope.server.utils.ExceptionUtil;\n+import org.quartz.DisallowConcurrentExecution;\n+import org.quartz.Job;\n+import org.quartz.JobExecutionContext;\n+import org.quartz.JobExecutionException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.support.AbstractBeanDefinition;\n+import org.xml.sax.helpers.AttributesImpl;\n+\n+/**\n+ * Quartz job for executing a given report.\n+ */\n+@SuppressWarnings(\"unchecked\")\n+@DisallowConcurrentExecution\n+public class ReportJob implements Job {\n+\n+    /**\n+     * Logger.\n+     */\n+    private static final Logger LOG = LoggerFactory.getLogger(ReportJob.class);\n+\n+    /**\n+     * Report DAO.\n+     */\n+    @Autowired\n+    private ReportDAO reportDAO;\n+\n+    /**\n+     * Report execution DAO.\n+     */\n+    @Autowired\n+    private ReportExecDAO reportExecDAO;\n+\n+    /**\n+     * Report data binder.\n+     */\n+    @Autowired\n+    private ReportDataBinder dataBinder;\n+\n+    @Autowired\n+    private EntityFactory entityFactory;\n+\n+    /**\n+     * Key, set by the caller, for identifying the report to be executed.\n+     */\n+    private Long reportKey;\n+\n+    /**\n+     * Report id setter.\n+     *\n+     * @param reportKey to be set\n+     */\n+    public void setReportKey(final Long reportKey) {\n+        this.reportKey = reportKey;\n+    }\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    @Override\n+    public void execute(final JobExecutionContext context) throws JobExecutionException {\n+        Report report = reportDAO.find(reportKey);\n+        if (report == null) {\n+            throw new JobExecutionException(\"Report \" + reportKey + \" not found\");\n+        }\n+\n+        // 1. create execution\n+        ReportExec execution = entityFactory.newEntity(ReportExec.class);\n+        execution.setStatus(ReportExecStatus.STARTED);\n+        execution.setStartDate(new Date());\n+        execution.setReport(report);\n+        execution = reportExecDAO.save(execution);\n+\n+        report.addExec(execution);\n+        report = reportDAO.save(report);\n+\n+        // 2. define a SAX handler for generating result as XML\n+        TransformerHandler handler;\n+\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        ZipOutputStream zos = new ZipOutputStream(baos);\n+        zos.setLevel(Deflater.BEST_COMPRESSION);\n+        try {\n+            SAXTransformerFactory tFactory = (SAXTransformerFactory) SAXTransformerFactory.newInstance();\n+            handler = tFactory.newTransformerHandler();\n+            Transformer serializer = handler.getTransformer();\n+            serializer.setOutputProperty(OutputKeys.ENCODING, SyncopeConstants.DEFAULT_ENCODING);\n+            serializer.setOutputProperty(OutputKeys.INDENT, \"yes\");\n+\n+            // a single ZipEntry in the ZipOutputStream\n+            zos.putNextEntry(new ZipEntry(report.getName()));\n+\n+            // streaming SAX handler in a compressed byte array stream\n+            handler.setResult(new StreamResult(zos));\n+        } catch (Exception e) {\n+            throw new JobExecutionException(\"While configuring for SAX generation\", e, true);\n+        }\n+\n+        execution.setStatus(ReportExecStatus.RUNNING);\n+        execution = reportExecDAO.save(execution);\n+\n+        // 3. actual report execution\n+        StringBuilder reportExecutionMessage = new StringBuilder();\n+        try {\n+            // report header\n+            handler.startDocument();\n+            AttributesImpl atts = new AttributesImpl();\n+            atts.addAttribute(\"\", \"\", ReportXMLConst.ATTR_NAME, ReportXMLConst.XSD_STRING, report.getName());\n+            handler.startElement(\"\", \"\", ReportXMLConst.ELEMENT_REPORT, atts);\n+\n+            // iterate over reportlet instances defined for this report\n+            for (ReportletConf reportletConf : report.getReportletConfs()) {\n+                Class<Reportlet> reportletClass =\n+                        dataBinder.findReportletClassHavingConfClass(reportletConf.getClass());\n+                if (reportletClass != null) {\n+                    Reportlet<ReportletConf> autowired =\n+                            (Reportlet<ReportletConf>) ApplicationContextProvider.getBeanFactory().\n+                            createBean(reportletClass, AbstractBeanDefinition.AUTOWIRE_BY_TYPE, false);\n+                    autowired.setConf(reportletConf);\n+\n+                    // invoke reportlet\n+                    try {\n+                        autowired.extract(handler);\n+                    } catch (Exception e) {\n+                        execution.setStatus(ReportExecStatus.FAILURE);\n+\n+                        Throwable t = e instanceof ReportException\n+                                ? e.getCause()\n+                                : e;\n+                        reportExecutionMessage.\n+                                append(ExceptionUtil.getFullStackTrace(t)).\n+                                append(\"\\n==================\\n\");\n+                    }\n+                }\n+            }\n+\n+            // report footer\n+            handler.endElement(\"\", \"\", ReportXMLConst.ELEMENT_REPORT);\n+            handler.endDocument();\n+\n+            if (!ReportExecStatus.FAILURE.name().equals(execution.getStatus())) {\n+                execution.setStatus(ReportExecStatus.SUCCESS);\n+            }\n+        } catch (Exception e) {\n+            execution.setStatus(ReportExecStatus.FAILURE);\n+            reportExecutionMessage.append(ExceptionUtil.getFullStackTrace(e));\n+\n+            throw new JobExecutionException(e, true);\n+        } finally {\n+            try {\n+                zos.closeEntry();\n+                IOUtils.closeQuietly(zos);\n+                IOUtils.closeQuietly(baos);\n+            } catch (IOException e) {\n+                LOG.error(\"While closing StreamResult's backend\", e);\n+            }\n+\n+            execution.setExecResult(baos.toByteArray());\n+            execution.setMessage(reportExecutionMessage.toString());\n+            execution.setEndDate(new Date());\n+            reportExecDAO.save(execution);\n+        }\n+    }\n+}"},{"sha":"3cd22cdfc3b776e3fd36746aea9afcbcc26f87a3","filename":"syncope620/server/logic/src/main/java/org/apache/syncope/server/logic/report/ReportXMLConst.java","status":"added","additions":44,"deletions":0,"changes":44,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Freport%2FReportXMLConst.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Freport%2FReportXMLConst.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Freport%2FReportXMLConst.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,44 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.server.logic.report;\n+\n+public final class ReportXMLConst {\n+\n+    public static final String XSD_STRING = \"xsd:string\";\n+\n+    public static final String XSD_INT = \"xsd:integer\";\n+\n+    public static final String XSD_LONG = \"xsd:long\";\n+\n+    public static final String XSD_BOOLEAN = \"xsd:boolean\";\n+\n+    public static final String XSD_DATETIME = \"xsd:dateTime\";\n+\n+    public static final String ELEMENT_REPORT = \"report\";\n+\n+    public static final String ATTR_NAME = \"name\";\n+\n+    public static final String ATTR_CLASS = \"class\";\n+\n+    public static final String ELEMENT_REPORTLET = \"reportlet\";\n+\n+    private ReportXMLConst() {\n+        // empty private constructor for static utility class\n+    }\n+}"},{"sha":"49438bce9115ad929a3299fe186bc7cb57915f7b","filename":"syncope620/server/logic/src/main/java/org/apache/syncope/server/logic/report/Reportlet.java","status":"added","additions":47,"deletions":0,"changes":47,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Freport%2FReportlet.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Freport%2FReportlet.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Freport%2FReportlet.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,47 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.server.logic.report;\n+\n+import org.apache.syncope.common.lib.report.ReportletConf;\n+import org.xml.sax.ContentHandler;\n+import org.xml.sax.SAXException;\n+\n+/**\n+ * Interface for all elements that can be embedded in a report.\n+ *\n+ * @see org.apache.syncope.core.persistence.beans.Report\n+ */\n+public interface Reportlet<T extends ReportletConf> {\n+\n+    /**\n+     * Set this reportlet configuration.\n+     *\n+     * @param conf configuration\n+     */\n+    void setConf(T conf);\n+\n+    /**\n+     * Actual data extraction for reporting.\n+     *\n+     * @param handler SAX content handler for streaming result\n+     * @throws SAXException if there is any problem in SAX handling\n+     * @throws ReportException if anything goes wrong\n+     */\n+    void extract(ContentHandler handler) throws SAXException, ReportException;\n+}"},{"sha":"48896cc93d66531d203dbb44915a86b26205ebf0","filename":"syncope620/server/logic/src/main/java/org/apache/syncope/server/logic/report/ReportletConfClass.java","status":"added","additions":32,"deletions":0,"changes":32,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Freport%2FReportletConfClass.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Freport%2FReportletConfClass.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Freport%2FReportletConfClass.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,32 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.server.logic.report;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+import org.apache.syncope.common.lib.report.ReportletConf;\n+\n+@Target({ ElementType.TYPE })\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface ReportletConfClass {\n+\n+    Class<? extends ReportletConf> value();\n+}"},{"sha":"3ffbdfb8f9ebb9331562c17c0be20ad1e7ed38b5","filename":"syncope620/server/logic/src/main/java/org/apache/syncope/server/logic/report/RoleReportlet.java","status":"added","additions":327,"deletions":0,"changes":327,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Freport%2FRoleReportlet.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Freport%2FRoleReportlet.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Freport%2FRoleReportlet.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,327 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.server.logic.report;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.syncope.common.lib.report.RoleReportletConf;\n+import org.apache.syncope.common.lib.report.RoleReportletConf.Feature;\n+import org.apache.syncope.common.lib.to.AbstractAttributableTO;\n+import org.apache.syncope.common.lib.to.AbstractSubjectTO;\n+import org.apache.syncope.common.lib.to.AttrTO;\n+import org.apache.syncope.common.lib.to.RoleTO;\n+import org.apache.syncope.common.lib.types.SubjectType;\n+import org.apache.syncope.persistence.api.RoleEntitlementUtil;\n+import org.apache.syncope.persistence.api.dao.EntitlementDAO;\n+import org.apache.syncope.persistence.api.dao.RoleDAO;\n+import org.apache.syncope.persistence.api.dao.SubjectSearchDAO;\n+import org.apache.syncope.persistence.api.dao.search.OrderByClause;\n+import org.apache.syncope.persistence.api.entity.membership.Membership;\n+import org.apache.syncope.persistence.api.entity.role.Role;\n+import org.apache.syncope.server.logic.data.RoleDataBinder;\n+import org.apache.syncope.server.logic.search.SearchCondConverter;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.xml.sax.ContentHandler;\n+import org.xml.sax.SAXException;\n+import org.xml.sax.helpers.AttributesImpl;\n+\n+@ReportletConfClass(RoleReportletConf.class)\n+public class RoleReportlet extends AbstractReportlet<RoleReportletConf> {\n+\n+    private static final int PAGE_SIZE = 10;\n+\n+    @Autowired\n+    private EntitlementDAO entitlementDAO;\n+\n+    @Autowired\n+    private RoleDAO roleDAO;\n+\n+    @Autowired\n+    private SubjectSearchDAO searchDAO;\n+\n+    @Autowired\n+    private RoleDataBinder roleDataBinder;\n+\n+    private List<Role> getPagedRoles(final int page) {\n+        final Set<Long> adminRoleIds = RoleEntitlementUtil.getRoleKeys(entitlementDAO.findAll());\n+        final List<Role> result;\n+        if (StringUtils.isBlank(conf.getMatchingCond())) {\n+            result = roleDAO.findAll();\n+        } else {\n+            result = searchDAO.search(adminRoleIds, SearchCondConverter.convert(conf.getMatchingCond()),\n+                    page, PAGE_SIZE, Collections.<OrderByClause>emptyList(), SubjectType.ROLE);\n+        }\n+\n+        return result;\n+    }\n+\n+    private int count() {\n+        Set<Long> adminRoleIds = RoleEntitlementUtil.getRoleKeys(entitlementDAO.findAll());\n+\n+        return StringUtils.isBlank(conf.getMatchingCond())\n+                ? roleDAO.findAll().size()\n+                : searchDAO.count(adminRoleIds, SearchCondConverter.convert(conf.getMatchingCond()), SubjectType.ROLE);\n+    }\n+\n+    private void doExtractResources(final ContentHandler handler, final AbstractSubjectTO subjectTO)\n+            throws SAXException {\n+\n+        if (subjectTO.getResources().isEmpty()) {\n+            LOG.debug(\"No resources found for {}[{}]\", subjectTO.getClass().getSimpleName(), subjectTO.getKey());\n+        } else {\n+            AttributesImpl atts = new AttributesImpl();\n+            handler.startElement(\"\", \"\", \"resources\", null);\n+\n+            for (String resourceName : subjectTO.getResources()) {\n+                atts.clear();\n+\n+                atts.addAttribute(\"\", \"\", ReportXMLConst.ATTR_NAME, ReportXMLConst.XSD_STRING, resourceName);\n+                handler.startElement(\"\", \"\", \"resource\", atts);\n+                handler.endElement(\"\", \"\", \"resource\");\n+            }\n+\n+            handler.endElement(\"\", \"\", \"resources\");\n+        }\n+    }\n+\n+    private void doExtractAttributes(final ContentHandler handler, final AbstractAttributableTO attributableTO,\n+            final Collection<String> attrs, final Collection<String> derAttrs, final Collection<String> virAttrs)\n+            throws SAXException {\n+\n+        AttributesImpl atts = new AttributesImpl();\n+        if (!attrs.isEmpty()) {\n+            Map<String, AttrTO> attrMap = attributableTO.getAttrMap();\n+\n+            handler.startElement(\"\", \"\", \"attributes\", null);\n+            for (String attrName : attrs) {\n+                atts.clear();\n+\n+                atts.addAttribute(\"\", \"\", ReportXMLConst.ATTR_NAME, ReportXMLConst.XSD_STRING, attrName);\n+                handler.startElement(\"\", \"\", \"attribute\", atts);\n+\n+                if (attrMap.containsKey(attrName)) {\n+                    for (String value : attrMap.get(attrName).getValues()) {\n+                        handler.startElement(\"\", \"\", \"value\", null);\n+                        handler.characters(value.toCharArray(), 0, value.length());\n+                        handler.endElement(\"\", \"\", \"value\");\n+                    }\n+                } else {\n+                    LOG.debug(\"{} not found for {}[{}]\", attrName,\n+                            attributableTO.getClass().getSimpleName(), attributableTO.getKey());\n+                }\n+\n+                handler.endElement(\"\", \"\", \"attribute\");\n+            }\n+            handler.endElement(\"\", \"\", \"attributes\");\n+        }\n+\n+        if (!derAttrs.isEmpty()) {\n+            Map<String, AttrTO> derAttrMap = attributableTO.getDerAttrMap();\n+\n+            handler.startElement(\"\", \"\", \"derivedAttributes\", null);\n+            for (String attrName : derAttrs) {\n+                atts.clear();\n+\n+                atts.addAttribute(\"\", \"\", ReportXMLConst.ATTR_NAME, ReportXMLConst.XSD_STRING, attrName);\n+                handler.startElement(\"\", \"\", \"derivedAttribute\", atts);\n+\n+                if (derAttrMap.containsKey(attrName)) {\n+                    for (String value : derAttrMap.get(attrName).getValues()) {\n+                        handler.startElement(\"\", \"\", \"value\", null);\n+                        handler.characters(value.toCharArray(), 0, value.length());\n+                        handler.endElement(\"\", \"\", \"value\");\n+                    }\n+                } else {\n+                    LOG.debug(\"{} not found for {}[{}]\", attrName,\n+                            attributableTO.getClass().getSimpleName(), attributableTO.getKey());\n+                }\n+\n+                handler.endElement(\"\", \"\", \"derivedAttribute\");\n+            }\n+            handler.endElement(\"\", \"\", \"derivedAttributes\");\n+        }\n+\n+        if (!virAttrs.isEmpty()) {\n+            Map<String, AttrTO> virAttrMap = attributableTO.getVirAttrMap();\n+\n+            handler.startElement(\"\", \"\", \"virtualAttributes\", null);\n+            for (String attrName : virAttrs) {\n+                atts.clear();\n+\n+                atts.addAttribute(\"\", \"\", ReportXMLConst.ATTR_NAME, ReportXMLConst.XSD_STRING, attrName);\n+                handler.startElement(\"\", \"\", \"virtualAttribute\", atts);\n+\n+                if (virAttrMap.containsKey(attrName)) {\n+                    for (String value : virAttrMap.get(attrName).getValues()) {\n+                        handler.startElement(\"\", \"\", \"value\", null);\n+                        handler.characters(value.toCharArray(), 0, value.length());\n+                        handler.endElement(\"\", \"\", \"value\");\n+                    }\n+                } else {\n+                    LOG.debug(\"{} not found for {}[{}]\", attrName,\n+                            attributableTO.getClass().getSimpleName(), attributableTO.getKey());\n+                }\n+\n+                handler.endElement(\"\", \"\", \"virtualAttribute\");\n+            }\n+            handler.endElement(\"\", \"\", \"virtualAttributes\");\n+        }\n+    }\n+\n+    private void doExtract(final ContentHandler handler, final List<Role> roles)\n+            throws SAXException, ReportException {\n+\n+        AttributesImpl atts = new AttributesImpl();\n+        for (Role role : roles) {\n+            atts.clear();\n+\n+            for (Feature feature : conf.getFeatures()) {\n+                String type = null;\n+                String value = null;\n+                switch (feature) {\n+                    case key:\n+                        type = ReportXMLConst.XSD_LONG;\n+                        value = String.valueOf(role.getKey());\n+                        break;\n+\n+                    case name:\n+                        type = ReportXMLConst.XSD_STRING;\n+                        value = String.valueOf(role.getName());\n+                        break;\n+\n+                    case roleOwner:\n+                        type = ReportXMLConst.XSD_LONG;\n+                        value = String.valueOf(role.getRoleOwner());\n+                        break;\n+\n+                    case userOwner:\n+                        type = ReportXMLConst.XSD_LONG;\n+                        value = String.valueOf(role.getUserOwner());\n+                        break;\n+\n+                    default:\n+                }\n+\n+                if (type != null && value != null) {\n+                    atts.addAttribute(\"\", \"\", feature.name(), type, value);\n+                }\n+            }\n+\n+            handler.startElement(\"\", \"\", \"role\", atts);\n+\n+            // Using RoleTO for attribute values, since the conversion logic of\n+            // values to String is already encapsulated there\n+            RoleTO roleTO = roleDataBinder.getRoleTO(role);\n+\n+            doExtractAttributes(handler, roleTO, conf.getAttrs(), conf.getDerAttrs(), conf.getVirAttrs());\n+\n+            if (conf.getFeatures().contains(Feature.entitlements)) {\n+                handler.startElement(\"\", \"\", \"entitlements\", null);\n+\n+                for (String ent : roleTO.getEntitlements()) {\n+                    atts.clear();\n+\n+                    atts.addAttribute(\"\", \"\", \"id\", ReportXMLConst.XSD_STRING, String.valueOf(ent));\n+\n+                    handler.startElement(\"\", \"\", \"entitlement\", atts);\n+                    handler.endElement(\"\", \"\", \"entitlement\");\n+                }\n+\n+                handler.endElement(\"\", \"\", \"entitlements\");\n+            }\n+            // to get resources associated to a role\n+            if (conf.getFeatures().contains(Feature.resources)) {\n+                doExtractResources(handler, roleTO);\n+            }\n+            //to get users asscoiated to a role is preferred RoleDAO to RoleTO\n+            if (conf.getFeatures().contains(Feature.users)) {\n+                handler.startElement(\"\", \"\", \"users\", null);\n+\n+                for (Membership memb : roleDAO.findMemberships(role)) {\n+                    atts.clear();\n+\n+                    atts.addAttribute(\"\", \"\", \"key\", ReportXMLConst.XSD_LONG,\n+                            String.valueOf(memb.getUser().getKey()));\n+                    atts.addAttribute(\"\", \"\", \"username\", ReportXMLConst.XSD_STRING,\n+                            String.valueOf(memb.getUser().getUsername()));\n+\n+                    handler.startElement(\"\", \"\", \"user\", atts);\n+                    handler.endElement(\"\", \"\", \"user\");\n+                }\n+\n+                handler.endElement(\"\", \"\", \"users\");\n+            }\n+\n+            handler.endElement(\"\", \"\", \"role\");\n+        }\n+    }\n+\n+    private void doExtractConf(final ContentHandler handler) throws SAXException {\n+        if (conf == null) {\n+            LOG.debug(\"Report configuration is not present\");\n+        }\n+\n+        AttributesImpl atts = new AttributesImpl();\n+        handler.startElement(\"\", \"\", \"configurations\", null);\n+        handler.startElement(\"\", \"\", \"roleAttributes\", atts);\n+\n+        for (Feature feature : conf.getFeatures()) {\n+            atts.clear();\n+            handler.startElement(\"\", \"\", \"feature\", atts);\n+            handler.characters(feature.name().toCharArray(), 0, feature.name().length());\n+            handler.endElement(\"\", \"\", \"feature\");\n+        }\n+\n+        for (String attr : conf.getAttrs()) {\n+            atts.clear();\n+            handler.startElement(\"\", \"\", \"attribute\", atts);\n+            handler.characters(attr.toCharArray(), 0, attr.length());\n+            handler.endElement(\"\", \"\", \"attribute\");\n+        }\n+\n+        for (String derAttr : conf.getDerAttrs()) {\n+            atts.clear();\n+            handler.startElement(\"\", \"\", \"derAttribute\", atts);\n+            handler.characters(derAttr.toCharArray(), 0, derAttr.length());\n+            handler.endElement(\"\", \"\", \"derAttribute\");\n+        }\n+\n+        for (String virAttr : conf.getVirAttrs()) {\n+            atts.clear();\n+            handler.startElement(\"\", \"\", \"virAttribute\", atts);\n+            handler.characters(virAttr.toCharArray(), 0, virAttr.length());\n+            handler.endElement(\"\", \"\", \"virAttribute\");\n+        }\n+\n+        handler.endElement(\"\", \"\", \"roleAttributes\");\n+        handler.endElement(\"\", \"\", \"configurations\");\n+    }\n+\n+    @Override\n+    protected void doExtract(final ContentHandler handler) throws SAXException, ReportException {\n+        doExtractConf(handler);\n+        for (int i = 1; i <= (count() / PAGE_SIZE) + 1; i++) {\n+            doExtract(handler, getPagedRoles(i));\n+        }\n+    }\n+}"},{"sha":"bdc76f84b16442d86b4f86dc604fd1310915b146","filename":"syncope620/server/logic/src/main/java/org/apache/syncope/server/logic/report/StaticReportlet.java","status":"added","additions":120,"deletions":0,"changes":120,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Freport%2FStaticReportlet.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Freport%2FStaticReportlet.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Freport%2FStaticReportlet.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,120 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.server.logic.report;\n+\n+import org.apache.syncope.common.lib.report.StaticReportletConf;\n+import org.apache.syncope.server.utils.DataFormat;\n+import org.springframework.util.StringUtils;\n+import org.xml.sax.ContentHandler;\n+import org.xml.sax.SAXException;\n+import org.xml.sax.helpers.AttributesImpl;\n+\n+@ReportletConfClass(StaticReportletConf.class)\n+public class StaticReportlet extends AbstractReportlet<StaticReportletConf> {\n+\n+    private void doExtractConf(final ContentHandler handler) throws SAXException {\n+\n+        AttributesImpl atts = new AttributesImpl();\n+        handler.startElement(\"\", \"\", \"configurations\", null);\n+        handler.startElement(\"\", \"\", \"staticAttributes\", atts);\n+\n+        handler.startElement(\"\", \"\", \"string\", atts);\n+        handler.characters(\"string\".toCharArray(), 0, \"string\".length());\n+        handler.endElement(\"\", \"\", \"string\");\n+\n+        handler.startElement(\"\", \"\", \"long\", atts);\n+        handler.characters(\"long\".toCharArray(), 0, \"long\".length());\n+        handler.endElement(\"\", \"\", \"long\");\n+\n+        handler.startElement(\"\", \"\", \"double\", atts);\n+        handler.characters(\"double\".toCharArray(), 0, \"double\".length());\n+        handler.endElement(\"\", \"\", \"double\");\n+\n+        handler.startElement(\"\", \"\", \"date\", atts);\n+        handler.characters(\"date\".toCharArray(), 0, \"date\".length());\n+        handler.endElement(\"\", \"\", \"date\");\n+\n+        handler.startElement(\"\", \"\", \"double\", atts);\n+        handler.characters(\"double\".toCharArray(), 0, \"double\".length());\n+        handler.endElement(\"\", \"\", \"double\");\n+\n+        handler.startElement(\"\", \"\", \"enum\", atts);\n+        handler.characters(\"enum\".toCharArray(), 0, \"enum\".length());\n+        handler.endElement(\"\", \"\", \"enum\");\n+\n+        handler.startElement(\"\", \"\", \"list\", atts);\n+        handler.characters(\"list\".toCharArray(), 0, \"list\".length());\n+        handler.endElement(\"\", \"\", \"list\");\n+\n+        handler.endElement(\"\", \"\", \"staticAttributes\");\n+        handler.endElement(\"\", \"\", \"configurations\");\n+    }\n+\n+    @Override\n+    public void doExtract(final ContentHandler handler) throws SAXException, ReportException {\n+\n+        doExtractConf(handler);\n+\n+        if (StringUtils.hasText(conf.getStringField())) {\n+            handler.startElement(\"\", \"\", \"string\", null);\n+            handler.characters(conf.getStringField().toCharArray(), 0, conf.getStringField().length());\n+            handler.endElement(\"\", \"\", \"string\");\n+        }\n+\n+        if (conf.getLongField() != null) {\n+            handler.startElement(\"\", \"\", \"long\", null);\n+            String printed = String.valueOf(conf.getLongField());\n+            handler.characters(printed.toCharArray(), 0, printed.length());\n+            handler.endElement(\"\", \"\", \"long\");\n+        }\n+\n+        if (conf.getDoubleField() != null) {\n+            handler.startElement(\"\", \"\", \"double\", null);\n+            String printed = String.valueOf(conf.getDoubleField());\n+            handler.characters(printed.toCharArray(), 0, printed.length());\n+            handler.endElement(\"\", \"\", \"double\");\n+        }\n+\n+        if (conf.getDateField() != null) {\n+            handler.startElement(\"\", \"\", \"date\", null);\n+            String printed = DataFormat.format(conf.getDateField());\n+            handler.characters(printed.toCharArray(), 0, printed.length());\n+            handler.endElement(\"\", \"\", \"date\");\n+        }\n+\n+        if (conf.getTraceLevel() != null) {\n+            handler.startElement(\"\", \"\", \"enum\", null);\n+            String printed = conf.getTraceLevel().name();\n+            handler.characters(printed.toCharArray(), 0, printed.length());\n+            handler.endElement(\"\", \"\", \"enum\");\n+        }\n+\n+        if (conf.getListField() != null && !conf.getListField().isEmpty()) {\n+            handler.startElement(\"\", \"\", \"list\", null);\n+            for (String item : conf.getListField()) {\n+                if (StringUtils.hasText(item)) {\n+                    handler.startElement(\"\", \"\", \"string\", null);\n+                    handler.characters(item.toCharArray(), 0, item.length());\n+                    handler.endElement(\"\", \"\", \"string\");\n+                }\n+            }\n+            handler.endElement(\"\", \"\", \"list\");\n+        }\n+    }\n+}"},{"sha":"8ad63fc8dfddc0620de971132b8fd49cb631933b","filename":"syncope620/server/logic/src/main/java/org/apache/syncope/server/logic/report/TextSerializer.java","status":"added","additions":101,"deletions":0,"changes":101,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Freport%2FTextSerializer.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Freport%2FTextSerializer.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Freport%2FTextSerializer.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,101 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.server.logic.report;\n+\n+import org.apache.cocoon.sax.component.XMLSerializer;\n+import org.xml.sax.Attributes;\n+import org.xml.sax.Locator;\n+import org.xml.sax.SAXException;\n+\n+/**\n+ * Converts XML into plain text. It omits all XML tags and writes only character events to the output. Input document\n+ * must have at least one element - root element - which should wrap all the text inside it.\n+ *\n+ */\n+public class TextSerializer extends XMLSerializer {\n+\n+    private static final String UTF_8 = \"UTF-8\";\n+\n+    private static final String TXT = \"text\";\n+\n+    public TextSerializer() {\n+        super();\n+        super.setOmitXmlDeclaration(true);\n+    }\n+\n+    @Override\n+    public void setDocumentLocator(final Locator locator) {\n+        // nothing\n+    }\n+\n+    @Override\n+    public void processingInstruction(final String target, final String data)\n+            throws SAXException {\n+        // nothing\n+    }\n+\n+    @Override\n+    public void startDTD(final String name, final String publicId, final String systemId)\n+            throws SAXException {\n+        // nothing\n+    }\n+\n+    @Override\n+    public void endDTD() throws SAXException {\n+        // nothing\n+    }\n+\n+    @Override\n+    public void startElement(final String uri, final String loc, final String raw, final Attributes atts)\n+            throws SAXException {\n+        // nothing\n+    }\n+\n+    @Override\n+    public void endElement(final String uri, final String name, final String raw)\n+            throws SAXException {\n+        // nothing\n+    }\n+\n+    @Override\n+    public void endDocument() throws SAXException {\n+        super.endDocument();\n+    }\n+\n+    /**\n+     * @throws SAXException if text is encountered before root element.\n+     */\n+    @Override\n+    public void characters(final char buffer[], final int start, final int len) throws SAXException {\n+        super.characters(buffer, start, len);\n+    }\n+\n+    @Override\n+    public void recycle() {\n+        super.recycle();\n+    }\n+\n+    public static TextSerializer createPlainSerializer() {\n+        final TextSerializer serializer = new TextSerializer();\n+        serializer.setContentType(\"text/plain; charset=\" + UTF_8);\n+        serializer.setEncoding(UTF_8);\n+        serializer.setMethod(TXT);\n+        return serializer;\n+    }\n+}"},{"sha":"ecae60437b018fc3e606c610360fd9b8521668f6","filename":"syncope620/server/logic/src/main/java/org/apache/syncope/server/logic/report/UserReportlet.java","status":"added","additions":359,"deletions":0,"changes":359,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Freport%2FUserReportlet.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Freport%2FUserReportlet.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Freport%2FUserReportlet.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,359 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.server.logic.report;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.syncope.common.lib.report.UserReportletConf;\n+import org.apache.syncope.common.lib.report.UserReportletConf.Feature;\n+import org.apache.syncope.common.lib.to.AbstractAttributableTO;\n+import org.apache.syncope.common.lib.to.AbstractSubjectTO;\n+import org.apache.syncope.common.lib.to.AttrTO;\n+import org.apache.syncope.common.lib.to.MembershipTO;\n+import org.apache.syncope.common.lib.to.UserTO;\n+import org.apache.syncope.common.lib.types.SubjectType;\n+import org.apache.syncope.persistence.api.RoleEntitlementUtil;\n+import org.apache.syncope.persistence.api.dao.EntitlementDAO;\n+import org.apache.syncope.persistence.api.dao.SubjectSearchDAO;\n+import org.apache.syncope.persistence.api.dao.UserDAO;\n+import org.apache.syncope.persistence.api.dao.search.OrderByClause;\n+import org.apache.syncope.persistence.api.entity.membership.Membership;\n+import org.apache.syncope.persistence.api.entity.user.User;\n+import org.apache.syncope.server.logic.data.RoleDataBinder;\n+import org.apache.syncope.server.logic.data.UserDataBinder;\n+import org.apache.syncope.server.logic.search.SearchCondConverter;\n+import org.apache.syncope.server.utils.DataFormat;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.xml.sax.ContentHandler;\n+import org.xml.sax.SAXException;\n+import org.xml.sax.helpers.AttributesImpl;\n+\n+@ReportletConfClass(UserReportletConf.class)\n+public class UserReportlet extends AbstractReportlet<UserReportletConf> {\n+\n+    private static final int PAGE_SIZE = 10;\n+\n+    @Autowired\n+    private EntitlementDAO entitlementDAO;\n+\n+    @Autowired\n+    private UserDAO userDAO;\n+\n+    @Autowired\n+    private SubjectSearchDAO searchDAO;\n+\n+    @Autowired\n+    private UserDataBinder userDataBinder;\n+\n+    @Autowired\n+    private RoleDataBinder roleDataBinder;\n+\n+    private List<User> getPagedUsers(final int page) {\n+        final Set<Long> adminRoleIds = RoleEntitlementUtil.getRoleKeys(entitlementDAO.findAll());\n+\n+        final List<User> result;\n+        if (StringUtils.isBlank(conf.getMatchingCond())) {\n+            result = userDAO.findAll(adminRoleIds, page, PAGE_SIZE);\n+        } else {\n+            result = searchDAO.search(adminRoleIds, SearchCondConverter.convert(conf.getMatchingCond()),\n+                    page, PAGE_SIZE, Collections.<OrderByClause>emptyList(), SubjectType.USER);\n+        }\n+\n+        return result;\n+    }\n+\n+    private int count() {\n+        Set<Long> adminRoleIds = RoleEntitlementUtil.getRoleKeys(entitlementDAO.findAll());\n+\n+        return StringUtils.isBlank(conf.getMatchingCond())\n+                ? userDAO.count(adminRoleIds)\n+                : searchDAO.count(adminRoleIds, SearchCondConverter.convert(conf.getMatchingCond()), SubjectType.USER);\n+    }\n+\n+    private void doExtractResources(final ContentHandler handler, final AbstractSubjectTO subjectTO)\n+            throws SAXException {\n+\n+        if (subjectTO.getResources().isEmpty()) {\n+            LOG.debug(\"No resources found for {}[{}]\", subjectTO.getClass().getSimpleName(), subjectTO.getKey());\n+        } else {\n+            AttributesImpl atts = new AttributesImpl();\n+            handler.startElement(\"\", \"\", \"resources\", null);\n+\n+            for (String resourceName : subjectTO.getResources()) {\n+                atts.clear();\n+\n+                atts.addAttribute(\"\", \"\", ReportXMLConst.ATTR_NAME, ReportXMLConst.XSD_STRING, resourceName);\n+                handler.startElement(\"\", \"\", \"resource\", atts);\n+                handler.endElement(\"\", \"\", \"resource\");\n+            }\n+\n+            handler.endElement(\"\", \"\", \"resources\");\n+        }\n+    }\n+\n+    private void doExtractAttributes(final ContentHandler handler, final AbstractAttributableTO attributableTO,\n+            final Collection<String> attrs, final Collection<String> derAttrs, final Collection<String> virAttrs)\n+            throws SAXException {\n+\n+        AttributesImpl atts = new AttributesImpl();\n+        if (!attrs.isEmpty()) {\n+            Map<String, AttrTO> attrMap = attributableTO.getAttrMap();\n+\n+            handler.startElement(\"\", \"\", \"attributes\", null);\n+            for (String attrName : attrs) {\n+                atts.clear();\n+\n+                atts.addAttribute(\"\", \"\", ReportXMLConst.ATTR_NAME, ReportXMLConst.XSD_STRING, attrName);\n+                handler.startElement(\"\", \"\", \"attribute\", atts);\n+\n+                if (attrMap.containsKey(attrName)) {\n+                    for (String value : attrMap.get(attrName).getValues()) {\n+                        handler.startElement(\"\", \"\", \"value\", null);\n+                        handler.characters(value.toCharArray(), 0, value.length());\n+                        handler.endElement(\"\", \"\", \"value\");\n+                    }\n+                } else {\n+                    LOG.debug(\"{} not found for {}[{}]\", attrName,\n+                            attributableTO.getClass().getSimpleName(), attributableTO.getKey());\n+                }\n+\n+                handler.endElement(\"\", \"\", \"attribute\");\n+            }\n+            handler.endElement(\"\", \"\", \"attributes\");\n+        }\n+\n+        if (!derAttrs.isEmpty()) {\n+            Map<String, AttrTO> derAttrMap = attributableTO.getDerAttrMap();\n+\n+            handler.startElement(\"\", \"\", \"derivedAttributes\", null);\n+            for (String attrName : derAttrs) {\n+                atts.clear();\n+\n+                atts.addAttribute(\"\", \"\", ReportXMLConst.ATTR_NAME, ReportXMLConst.XSD_STRING, attrName);\n+                handler.startElement(\"\", \"\", \"derivedAttribute\", atts);\n+\n+                if (derAttrMap.containsKey(attrName)) {\n+                    for (String value : derAttrMap.get(attrName).getValues()) {\n+                        handler.startElement(\"\", \"\", \"value\", null);\n+                        handler.characters(value.toCharArray(), 0, value.length());\n+                        handler.endElement(\"\", \"\", \"value\");\n+                    }\n+                } else {\n+                    LOG.debug(\"{} not found for {}[{}]\", attrName,\n+                            attributableTO.getClass().getSimpleName(), attributableTO.getKey());\n+                }\n+\n+                handler.endElement(\"\", \"\", \"derivedAttribute\");\n+            }\n+            handler.endElement(\"\", \"\", \"derivedAttributes\");\n+        }\n+\n+        if (!virAttrs.isEmpty()) {\n+            Map<String, AttrTO> virAttrMap = attributableTO.getVirAttrMap();\n+\n+            handler.startElement(\"\", \"\", \"virtualAttributes\", null);\n+            for (String attrName : virAttrs) {\n+                atts.clear();\n+\n+                atts.addAttribute(\"\", \"\", ReportXMLConst.ATTR_NAME, ReportXMLConst.XSD_STRING, attrName);\n+                handler.startElement(\"\", \"\", \"virtualAttribute\", atts);\n+\n+                if (virAttrMap.containsKey(attrName)) {\n+                    for (String value : virAttrMap.get(attrName).getValues()) {\n+                        handler.startElement(\"\", \"\", \"value\", null);\n+                        handler.characters(value.toCharArray(), 0, value.length());\n+                        handler.endElement(\"\", \"\", \"value\");\n+                    }\n+                } else {\n+                    LOG.debug(\"{} not found for {}[{}]\", attrName,\n+                            attributableTO.getClass().getSimpleName(), attributableTO.getKey());\n+                }\n+\n+                handler.endElement(\"\", \"\", \"virtualAttribute\");\n+            }\n+            handler.endElement(\"\", \"\", \"virtualAttributes\");\n+        }\n+    }\n+\n+    private void doExtract(final ContentHandler handler, final List<User> users)\n+            throws SAXException, ReportException {\n+\n+        AttributesImpl atts = new AttributesImpl();\n+        for (User user : users) {\n+            atts.clear();\n+\n+            for (Feature feature : conf.getFeatures()) {\n+                String type = null;\n+                String value = null;\n+                switch (feature) {\n+                    case key:\n+                        type = ReportXMLConst.XSD_LONG;\n+                        value = String.valueOf(user.getKey());\n+                        break;\n+\n+                    case username:\n+                        type = ReportXMLConst.XSD_STRING;\n+                        value = user.getUsername();\n+                        break;\n+\n+                    case workflowId:\n+                        type = ReportXMLConst.XSD_LONG;\n+                        value = String.valueOf(user.getWorkflowId());\n+                        break;\n+\n+                    case status:\n+                        type = ReportXMLConst.XSD_STRING;\n+                        value = user.getStatus();\n+                        break;\n+\n+                    case creationDate:\n+                        type = ReportXMLConst.XSD_DATETIME;\n+                        value = user.getCreationDate() == null\n+                                ? \"\"\n+                                : DataFormat.format(user.getCreationDate());\n+                        break;\n+\n+                    case lastLoginDate:\n+                        type = ReportXMLConst.XSD_DATETIME;\n+                        value = user.getLastLoginDate() == null\n+                                ? \"\"\n+                                : DataFormat.format(user.getLastLoginDate());\n+                        break;\n+\n+                    case changePwdDate:\n+                        type = ReportXMLConst.XSD_DATETIME;\n+                        value = user.getChangePwdDate() == null\n+                                ? \"\"\n+                                : DataFormat.format(user.getChangePwdDate());\n+                        break;\n+\n+                    case passwordHistorySize:\n+                        type = ReportXMLConst.XSD_INT;\n+                        value = String.valueOf(user.getPasswordHistory().size());\n+                        break;\n+\n+                    case failedLoginCount:\n+                        type = ReportXMLConst.XSD_INT;\n+                        value = String.valueOf(user.getFailedLogins());\n+                        break;\n+\n+                    default:\n+                }\n+\n+                if (type != null && value != null) {\n+                    atts.addAttribute(\"\", \"\", feature.name(), type, value);\n+                }\n+            }\n+\n+            handler.startElement(\"\", \"\", \"user\", atts);\n+\n+            // Using UserTO for attribute values, since the conversion logic of\n+            // values to String is already encapsulated there\n+            UserTO userTO = userDataBinder.getUserTO(user);\n+\n+            doExtractAttributes(handler, userTO, conf.getAttrs(), conf.getDerAttrs(), conf.getVirAttrs());\n+\n+            if (conf.getFeatures().contains(Feature.memberships)) {\n+                handler.startElement(\"\", \"\", \"memberships\", null);\n+\n+                for (MembershipTO memb : userTO.getMemberships()) {\n+                    atts.clear();\n+\n+                    atts.addAttribute(\"\", \"\", \"id\", ReportXMLConst.XSD_LONG, String.valueOf(memb.getKey()));\n+                    atts.addAttribute(\"\", \"\", \"roleId\", ReportXMLConst.XSD_LONG, String.valueOf(memb.getRoleId()));\n+                    atts.addAttribute(\"\", \"\", \"roleName\", ReportXMLConst.XSD_STRING, String.valueOf(memb.getRoleName()));\n+                    handler.startElement(\"\", \"\", \"membership\", atts);\n+\n+                    doExtractAttributes(handler, memb, memb.getAttrMap().keySet(), memb.getDerAttrMap()\n+                            .keySet(), memb.getVirAttrMap().keySet());\n+\n+                    if (conf.getFeatures().contains(Feature.resources)) {\n+                        Membership actualMemb = user.getMembership(memb.getRoleId());\n+                        if (actualMemb == null) {\n+                            LOG.warn(\"Unexpected: cannot find membership for role {} for user {}\", memb.getRoleId(),\n+                                    user);\n+                        } else {\n+                            doExtractResources(handler, roleDataBinder.getRoleTO(actualMemb.getRole()));\n+                        }\n+                    }\n+\n+                    handler.endElement(\"\", \"\", \"membership\");\n+                }\n+\n+                handler.endElement(\"\", \"\", \"memberships\");\n+            }\n+\n+            if (conf.getFeatures().contains(Feature.resources)) {\n+                doExtractResources(handler, userTO);\n+            }\n+\n+            handler.endElement(\"\", \"\", \"user\");\n+        }\n+    }\n+\n+    private void doExtractConf(final ContentHandler handler) throws SAXException {\n+\n+        AttributesImpl atts = new AttributesImpl();\n+        handler.startElement(\"\", \"\", \"configurations\", null);\n+        handler.startElement(\"\", \"\", \"userAttributes\", atts);\n+\n+        for (Feature feature : conf.getFeatures()) {\n+            atts.clear();\n+            handler.startElement(\"\", \"\", \"feature\", atts);\n+            handler.characters(feature.name().toCharArray(), 0, feature.name().length());\n+            handler.endElement(\"\", \"\", \"feature\");\n+        }\n+\n+        for (String attr : conf.getAttrs()) {\n+            atts.clear();\n+            handler.startElement(\"\", \"\", \"attribute\", atts);\n+            handler.characters(attr.toCharArray(), 0, attr.length());\n+            handler.endElement(\"\", \"\", \"attribute\");\n+        }\n+\n+        for (String derAttr : conf.getDerAttrs()) {\n+            atts.clear();\n+            handler.startElement(\"\", \"\", \"derAttribute\", atts);\n+            handler.characters(derAttr.toCharArray(), 0, derAttr.length());\n+            handler.endElement(\"\", \"\", \"derAttribute\");\n+        }\n+\n+        for (String virAttr : conf.getVirAttrs()) {\n+            atts.clear();\n+            handler.startElement(\"\", \"\", \"virAttribute\", atts);\n+            handler.characters(virAttr.toCharArray(), 0, virAttr.length());\n+            handler.endElement(\"\", \"\", \"virAttribute\");\n+        }\n+\n+        handler.endElement(\"\", \"\", \"userAttributes\");\n+        handler.endElement(\"\", \"\", \"configurations\");\n+    }\n+\n+    @Override\n+    protected void doExtract(final ContentHandler handler) throws SAXException, ReportException {\n+        doExtractConf(handler);\n+        for (int i = 1; i <= (count() / PAGE_SIZE) + 1; i++) {\n+            doExtract(handler, getPagedUsers(i));\n+        }\n+    }\n+}"},{"sha":"662cd46134c8803070772eca992a3b1772f4e5e0","filename":"syncope620/server/logic/src/main/java/org/apache/syncope/server/logic/search/SearchCondConverter.java","status":"added","additions":50,"deletions":0,"changes":50,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Fsearch%2FSearchCondConverter.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Fsearch%2FSearchCondConverter.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Fsearch%2FSearchCondConverter.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,50 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.server.logic.search;\n+\n+import org.apache.cxf.jaxrs.ext.search.SearchBean;\n+import org.apache.cxf.jaxrs.ext.search.fiql.FiqlParser;\n+import org.apache.syncope.common.lib.search.SyncopeFiqlSearchConditionBuilder;\n+import org.apache.syncope.persistence.api.dao.search.SearchCond;\n+\n+/**\n+ * Converts FIQL expressions to Syncope's <tt>SearchCond</tt>.\n+ */\n+public final class SearchCondConverter {\n+\n+    /**\n+     * Parses a FIQL expression into Syncope's <tt>SearchCond</tt>, using CXF's <tt>FiqlParser</tt>.\n+     *\n+     * @param fiqlExpression FIQL string\n+     * @return <tt>SearchCond</tt> instance for given FIQL expression\n+     * @see FiqlParser\n+     */\n+    public static SearchCond convert(final String fiqlExpression) {\n+        FiqlParser<SearchBean> fiqlParser = new FiqlParser<SearchBean>(\n+                SearchBean.class, SyncopeFiqlSearchConditionBuilder.CONTEXTUAL_PROPERTIES);\n+        SearchCondVisitor searchCondVisitor = new SearchCondVisitor();\n+\n+        searchCondVisitor.visit(fiqlParser.parse(fiqlExpression));\n+        return searchCondVisitor.getQuery();\n+    }\n+\n+    private SearchCondConverter() {\n+        // empty constructor for static utility class        \n+    }\n+}"},{"sha":"5c9acdb8f78321f45a330f3216b06eddffdda8b4","filename":"syncope620/server/logic/src/main/java/org/apache/syncope/server/logic/search/SearchCondVisitor.java","status":"added","additions":203,"deletions":0,"changes":203,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Fsearch%2FSearchCondVisitor.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Fsearch%2FSearchCondVisitor.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Flogic%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Flogic%2Fsearch%2FSearchCondVisitor.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,203 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.server.logic.search;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.cxf.jaxrs.ext.search.ConditionType;\n+import org.apache.cxf.jaxrs.ext.search.SearchBean;\n+import org.apache.cxf.jaxrs.ext.search.SearchCondition;\n+import org.apache.cxf.jaxrs.ext.search.SearchUtils;\n+import org.apache.cxf.jaxrs.ext.search.visitor.AbstractSearchConditionVisitor;\n+import org.apache.syncope.common.lib.search.SearchableFields;\n+import org.apache.syncope.common.lib.search.SpecialAttr;\n+import org.apache.syncope.common.lib.to.RoleTO;\n+import org.apache.syncope.common.lib.to.UserTO;\n+import org.apache.syncope.persistence.api.dao.search.AttributeCond;\n+import org.apache.syncope.persistence.api.dao.search.EntitlementCond;\n+import org.apache.syncope.persistence.api.dao.search.MembershipCond;\n+import org.apache.syncope.persistence.api.dao.search.ResourceCond;\n+import org.apache.syncope.persistence.api.dao.search.SearchCond;\n+import org.apache.syncope.persistence.api.dao.search.SubjectCond;\n+\n+/**\n+ * Converts CXF's <tt>SearchCondition</tt> into internal <tt>SearchCond</tt>.\n+ */\n+public class SearchCondVisitor extends AbstractSearchConditionVisitor<SearchBean, SearchCond> {\n+\n+    private static final List<String> ATTRIBUTABLE_FIELDS;\n+\n+    static {\n+        ATTRIBUTABLE_FIELDS = new ArrayList<String>();\n+        ATTRIBUTABLE_FIELDS.addAll(SearchableFields.get(UserTO.class));\n+        ATTRIBUTABLE_FIELDS.addAll(SearchableFields.get(RoleTO.class));\n+    }\n+\n+    private SearchCond searchCond;\n+\n+    public SearchCondVisitor() {\n+        super(null);\n+    }\n+\n+    public SearchCondVisitor(final Map<String, String> fieldMap) {\n+        super(fieldMap);\n+    }\n+\n+    private AttributeCond createAttributeCond(final String schema) {\n+        AttributeCond attributeCond = ATTRIBUTABLE_FIELDS.contains(schema)\n+                ? new SubjectCond()\n+                : new AttributeCond();\n+        attributeCond.setSchema(schema);\n+        return attributeCond;\n+    }\n+\n+    private SearchCond visitPrimitive(final SearchCondition<SearchBean> sc) {\n+        String name = getRealPropertyName(sc.getStatement().getProperty());\n+        SpecialAttr specialAttrName = SpecialAttr.fromString(name);\n+\n+        String value = SearchUtils.toSqlWildcardString(sc.getStatement().getValue().toString(), false).\n+                replaceAll(\"\\\\\\\\_\", \"_\");\n+        SpecialAttr specialAttrValue = SpecialAttr.fromString(value);\n+\n+        AttributeCond attributeCond = createAttributeCond(name);\n+        attributeCond.setExpression(value);\n+\n+        SearchCond leaf;\n+        switch (sc.getConditionType()) {\n+            case EQUALS:\n+            case NOT_EQUALS:\n+                if (specialAttrName == null) {\n+                    if (specialAttrValue != null && specialAttrValue == SpecialAttr.NULL) {\n+                        attributeCond.setType(AttributeCond.Type.ISNULL);\n+                        attributeCond.setExpression(null);\n+                    } else if (value.indexOf('%') == -1) {\n+                        attributeCond.setType(AttributeCond.Type.EQ);\n+                    } else {\n+                        attributeCond.setType(AttributeCond.Type.LIKE);\n+                    }\n+\n+                    leaf = SearchCond.getLeafCond(attributeCond);\n+                } else {\n+                    switch (specialAttrName) {\n+                        case ROLES:\n+                            MembershipCond membershipCond = new MembershipCond();\n+                            membershipCond.setRoleId(Long.valueOf(value));\n+                            leaf = SearchCond.getLeafCond(membershipCond);\n+                            break;\n+\n+                        case RESOURCES:\n+                            ResourceCond resourceCond = new ResourceCond();\n+                            resourceCond.setResourceName(value);\n+                            leaf = SearchCond.getLeafCond(resourceCond);\n+                            break;\n+\n+                        case ENTITLEMENTS:\n+                            EntitlementCond entitlementCond = new EntitlementCond();\n+                            entitlementCond.setExpression(value);\n+                            leaf = SearchCond.getLeafCond(entitlementCond);\n+                            break;\n+\n+                        default:\n+                            throw new IllegalArgumentException(\n+                                    String.format(\"Special attr name %s is not supported\", specialAttrName));\n+                    }\n+                }\n+                if (sc.getConditionType() == ConditionType.NOT_EQUALS) {\n+                    if (leaf.getAttributeCond() != null\n+                            && leaf.getAttributeCond().getType() == AttributeCond.Type.ISNULL) {\n+\n+                        leaf.getAttributeCond().setType(AttributeCond.Type.ISNOTNULL);\n+                    } else if (leaf.getSubjectCond() != null\n+                            && leaf.getSubjectCond().getType() == SubjectCond.Type.ISNULL) {\n+\n+                        leaf.getSubjectCond().setType(AttributeCond.Type.ISNOTNULL);\n+                    } else {\n+                        leaf = SearchCond.getNotLeafCond(leaf);\n+                    }\n+                }\n+                break;\n+\n+            case GREATER_OR_EQUALS:\n+                attributeCond.setType(AttributeCond.Type.GE);\n+                leaf = SearchCond.getLeafCond(attributeCond);\n+                break;\n+\n+            case GREATER_THAN:\n+                attributeCond.setType(AttributeCond.Type.GT);\n+                leaf = SearchCond.getLeafCond(attributeCond);\n+                break;\n+\n+            case LESS_OR_EQUALS:\n+                attributeCond.setType(AttributeCond.Type.LE);\n+                leaf = SearchCond.getLeafCond(attributeCond);\n+                break;\n+\n+            case LESS_THAN:\n+                attributeCond.setType(AttributeCond.Type.LT);\n+                leaf = SearchCond.getLeafCond(attributeCond);\n+                break;\n+\n+            default:\n+                throw new IllegalArgumentException(\n+                        String.format(\"Condition type %s is not supported\", sc.getConditionType().name()));\n+        }\n+\n+        return leaf;\n+    }\n+\n+    private SearchCond visitCompount(final SearchCondition<SearchBean> sc) {\n+        List<SearchCond> searchConds = new ArrayList<SearchCond>();\n+        for (SearchCondition<SearchBean> searchCondition : sc.getSearchConditions()) {\n+            searchConds.add(searchCondition.getStatement() == null\n+                    ? visitCompount(searchCondition)\n+                    : visitPrimitive(searchCondition));\n+        }\n+\n+        SearchCond compound;\n+        switch (sc.getConditionType()) {\n+            case AND:\n+                compound = SearchCond.getAndCond(searchConds);\n+                break;\n+\n+            case OR:\n+                compound = SearchCond.getOrCond(searchConds);\n+                break;\n+\n+            default:\n+                throw new IllegalArgumentException(\n+                        String.format(\"Condition type %s is not supported\", sc.getConditionType().name()));\n+        }\n+\n+        return compound;\n+    }\n+\n+    @Override\n+    public void visit(final SearchCondition<SearchBean> sc) {\n+        searchCond = sc.getStatement() == null\n+                ? visitCompount(sc)\n+                : visitPrimitive(sc);\n+    }\n+\n+    @Override\n+    public SearchCond getQuery() {\n+        return searchCond;\n+    }\n+\n+}"},{"sha":"517d64dd9d30a1809f568fbffcb54f7ad17e4ed5","filename":"syncope620/server/persistence-api/src/main/java/org/apache/syncope/persistence/api/dao/DuplicateException.java","status":"added","additions":35,"deletions":0,"changes":35,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fapi%2Fdao%2FDuplicateException.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fapi%2Fdao%2FDuplicateException.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Fpersistence-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fapi%2Fdao%2FDuplicateException.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,35 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.persistence.api.dao;\n+\n+/**\n+ * Thrown when something is not found.\n+ */\n+public class DuplicateException extends RuntimeException {\n+\n+    private static final long serialVersionUID = -8200698688516957508L;\n+\n+    public DuplicateException(final String msg) {\n+        super(msg);\n+    }\n+\n+    public DuplicateException(final String msg, final Exception cause) {\n+        super(msg, cause);\n+    }\n+}"},{"sha":"d26615dc952d0072e848ed795767449410db6f74","filename":"syncope620/server/persistence-api/src/main/java/org/apache/syncope/persistence/api/dao/RoleDAO.java","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fapi%2Fdao%2FRoleDAO.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fapi%2Fdao%2FRoleDAO.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Fpersistence-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fapi%2Fdao%2FRoleDAO.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -77,4 +77,6 @@ public interface RoleDAO extends SubjectDAO<RPlainAttr, RDerAttr, RVirAttr> {\n     void delete(Role role);\n \n     void delete(Long key);\n+    \n+    Role authFetchRole(Long key);\n }"},{"sha":"0f359c382f830a142b40c80c3a2e6bc7a96ca075","filename":"syncope620/server/persistence-api/src/main/java/org/apache/syncope/persistence/api/dao/UserDAO.java","status":"modified","additions":3,"deletions":0,"changes":3,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fapi%2Fdao%2FUserDAO.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fapi%2Fdao%2FUserDAO.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Fpersistence-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fapi%2Fdao%2FUserDAO.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -62,4 +62,7 @@ public interface UserDAO extends SubjectDAO<UPlainAttr, UDerAttr, UVirAttr> {\n \n     void delete(User user);\n \n+    User authFecthUser(Long key);\n+\n+    User authFecthUser(String username);\n }"},{"sha":"3d12ec97cd61bb3bfea297abbf85e2a83918dfa5","filename":"syncope620/server/persistence-api/src/main/java/org/apache/syncope/persistence/api/entity/AttributableUtil.java","status":"modified","additions":5,"deletions":0,"changes":5,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fapi%2Fentity%2FAttributableUtil.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fapi%2Fentity%2FAttributableUtil.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Fpersistence-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fapi%2Fentity%2FAttributableUtil.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -19,6 +19,8 @@\n package org.apache.syncope.persistence.api.entity;\n \n import java.util.List;\n+import org.apache.syncope.common.lib.to.AbstractAttributableTO;\n+import org.apache.syncope.common.lib.to.AbstractSubjectTO;\n import org.apache.syncope.common.lib.types.AttributableType;\n import org.apache.syncope.common.lib.types.IntMappingType;\n import org.apache.syncope.common.lib.types.MappingPurpose;\n@@ -83,4 +85,7 @@ public interface AttributableUtil {\n \n     <T extends MappingItem> Class<T> mappingItemClass();\n \n+    <T extends AbstractAttributableTO> T newAttributableTO();\n+\n+    <T extends AbstractSubjectTO> T newSubjectTO();\n }"},{"sha":"1f42c1791b265f92baf6cd93ef95a38c8daf63f7","filename":"syncope620/server/persistence-api/src/main/java/org/apache/syncope/persistence/api/entity/AttributableUtilFactory.java","status":"added","additions":33,"deletions":0,"changes":33,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fapi%2Fentity%2FAttributableUtilFactory.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fapi%2Fentity%2FAttributableUtilFactory.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Fpersistence-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fapi%2Fentity%2FAttributableUtilFactory.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,33 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.persistence.api.entity;\n+\n+import org.apache.syncope.common.lib.types.AttributableType;\n+import org.identityconnectors.framework.common.objects.ObjectClass;\n+\n+public interface AttributableUtilFactory {\n+\n+    AttributableUtil getInstance(AttributableType type);\n+\n+    AttributableUtil getInstance(String attributableType);\n+\n+    AttributableUtil getInstance(ObjectClass objectClass);\n+\n+    AttributableUtil getInstance(Attributable<?, ?, ?> attributable);\n+}"},{"sha":"6c8afbdb250737df0221a6d696f9581d59abc8d5","filename":"syncope620/server/persistence-api/src/main/java/org/apache/syncope/persistence/api/entity/Entity.java","status":"modified","additions":3,"deletions":1,"changes":4,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fapi%2Fentity%2FEntity.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fapi%2Fentity%2FEntity.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Fpersistence-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fapi%2Fentity%2FEntity.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -18,7 +18,9 @@\n  */\n package org.apache.syncope.persistence.api.entity;\n \n-public interface Entity<KEY> {\n+import java.io.Serializable;\n+\n+public interface Entity<KEY> extends Serializable {\n \n     KEY getKey();\n }"},{"sha":"c36030b339d1886bb1b5cb17bf124ec4ccaa5cba","filename":"syncope620/server/persistence-api/src/main/java/org/apache/syncope/persistence/api/entity/EntityFactory.java","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fapi%2Fentity%2FEntityFactory.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fapi%2Fentity%2FEntityFactory.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Fpersistence-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fapi%2Fentity%2FEntityFactory.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -23,4 +23,6 @@ public interface EntityFactory {\n     <KEY, T extends Entity<KEY>> T newEntity(Class<T> reference);\n \n     <T extends Policy> T newPolicy(Class<T> reference, boolean global);\n+\n+    ConnPoolConf newConnPoolConf();\n }"},{"sha":"8e55c26123e6aeff0175fa54af18ff12daf0b1ec","filename":"syncope620/server/persistence-api/src/main/java/org/apache/syncope/persistence/api/entity/ExternalResource.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fapi%2Fentity%2FExternalResource.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fapi%2Fentity%2FExternalResource.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Fpersistence-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fapi%2Fentity%2FExternalResource.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -27,7 +27,7 @@\n import org.apache.syncope.common.lib.types.TraceLevel;\n import org.identityconnectors.framework.common.objects.SyncToken;\n \n-public interface ExternalResource extends Entity<String> {\n+public interface ExternalResource extends AnnotatedEntity<String> {\n \n     AccountPolicy getAccountPolicy();\n "},{"sha":"b61afdc4abc00eb474b4c4432cb635cb7f1a69fb","filename":"syncope620/server/persistence-api/src/main/java/org/apache/syncope/persistence/api/entity/role/Role.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fapi%2Fentity%2Frole%2FRole.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fapi%2Fentity%2Frole%2FRole.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Fpersistence-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fapi%2Fentity%2Frole%2FRole.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -92,7 +92,7 @@ <T extends AttrTemplate<K>, K extends Schema> T getAttrTemplate(\n \n     boolean isInheritAccountPolicy();\n \n-    boolean isInheritAttrs();\n+    boolean isInheritPlainAttrs();\n \n     boolean isInheritDerAttrs();\n \n@@ -108,7 +108,7 @@ <T extends AttrTemplate<K>, K extends Schema> T getAttrTemplate(\n \n     void setInheritAccountPolicy(boolean condition);\n \n-    void setInheritAttrs(boolean inheritAttrs);\n+    void setInheritPlainAttrs(boolean inheritAttrs);\n \n     void setInheritDerAttrs(boolean inheritDerAttrs);\n "},{"sha":"661c645e8e9ebe8353f36a8c0977636a3ef17334","filename":"syncope620/server/persistence-api/src/main/java/org/apache/syncope/persistence/api/entity/task/TaskUtil.java","status":"added","additions":36,"deletions":0,"changes":36,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fapi%2Fentity%2Ftask%2FTaskUtil.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fapi%2Fentity%2Ftask%2FTaskUtil.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Fpersistence-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fapi%2Fentity%2Ftask%2FTaskUtil.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,36 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.persistence.api.entity.task;\n+\n+import org.apache.syncope.common.lib.to.AbstractTaskTO;\n+import org.apache.syncope.common.lib.types.TaskType;\n+\n+public interface TaskUtil {\n+\n+    TaskType getType();\n+\n+    <T extends Task> T newTask();\n+\n+    <T extends AbstractTaskTO> T newTaskTO();\n+\n+    <T extends Task> Class<T> taskClass();\n+\n+    <T extends AbstractTaskTO> Class<T> taskTOClass();\n+\n+}"},{"sha":"b2b24e61489e4a4a8cd36d70c30d119a072b59e6","filename":"syncope620/server/persistence-api/src/main/java/org/apache/syncope/persistence/api/entity/task/TaskUtilFactory.java","status":"added","additions":33,"deletions":0,"changes":33,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fapi%2Fentity%2Ftask%2FTaskUtilFactory.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fapi%2Fentity%2Ftask%2FTaskUtilFactory.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Fpersistence-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fapi%2Fentity%2Ftask%2FTaskUtilFactory.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,33 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.persistence.api.entity.task;\n+\n+import org.apache.syncope.common.lib.to.AbstractTaskTO;\n+import org.apache.syncope.common.lib.types.TaskType;\n+\n+public interface TaskUtilFactory {\n+\n+    TaskUtil getInstance(TaskType type);\n+\n+    TaskUtil getInstance(Task task);\n+\n+    TaskUtil getInstance(Class<? extends AbstractTaskTO> taskClass);\n+\n+    TaskUtil getInstance(AbstractTaskTO taskTO);\n+}"},{"sha":"b5f0bbeb0844b58a008a6bcdfaa86d37c1178cb6","filename":"syncope620/server/persistence-jpa/pom.xml","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-jpa%2Fpom.xml","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-jpa%2Fpom.xml","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Fpersistence-jpa%2Fpom.xml?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -91,7 +91,7 @@ under the License.\n       \n     <dependency>\n       <groupId>org.apache.syncope.server</groupId>\n-      <artifactId>syncope-provisioning-api</artifactId>\n+      <artifactId>syncope-provisioning-common</artifactId>\n       <version>${project.version}</version>\n     </dependency>\n     <dependency>"},{"sha":"64712c8419c63cfcbe85b9e75f8ee58bc1a06597","filename":"syncope620/server/persistence-jpa/src/main/java/org/apache/syncope/persistence/jpa/dao/AbstractSubjectDAO.java","status":"modified","additions":5,"deletions":5,"changes":10,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fdao%2FAbstractSubjectDAO.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fdao%2FAbstractSubjectDAO.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fdao%2FAbstractSubjectDAO.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -89,10 +89,10 @@ private Set<String> getWhereClause(final String expression, final String value,\n         final Parser parser = new Parser(new StringReader(expression));\n \n         // Schema names\n-        final List<String> identifiers = new ArrayList<String>();\n+        final List<String> identifiers = new ArrayList<>();\n \n         // Literals\n-        final List<String> literals = new ArrayList<String>();\n+        final List<String> literals = new ArrayList<>();\n \n         // Get schema names and literals\n         Token token;\n@@ -131,18 +131,18 @@ public int compare(final String t, final String t1) {\n         final List<String> attrValues = split(value, literals);\n \n         if (attrValues.size() != identifiers.size()) {\n-            LOG.error(\"Ambiguous jexl expression resolution.\");\n+            LOG.error(\"Ambiguous JEXL expression resolution.\");\n             throw new IllegalArgumentException(\"literals and values have different size\");\n         }\n \n         // clauses to be used with INTERSECTed queries\n-        final Set<String> clauses = new HashSet<String>();\n+        final Set<String> clauses = new HashSet<>();\n \n         // builder to build the clauses\n         final StringBuilder bld = new StringBuilder();\n \n         // Contains used identifiers in order to avoid replications\n-        final Set<String> used = new HashSet<String>();\n+        final Set<String> used = new HashSet<>();\n \n         // Create several clauses: one for eanch identifiers\n         for (int i = 0; i < identifiers.size(); i++) {"},{"sha":"5e7bc8325594bc9f161a9d07708be247fc0dd0a6","filename":"syncope620/server/persistence-jpa/src/main/java/org/apache/syncope/persistence/jpa/dao/JPAConfDAO.java","status":"modified","additions":5,"deletions":2,"changes":7,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fdao%2FJPAConfDAO.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fdao%2FJPAConfDAO.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fdao%2FJPAConfDAO.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -22,10 +22,10 @@\n import org.apache.syncope.persistence.api.dao.ConfDAO;\n import org.apache.syncope.persistence.api.dao.PlainAttrDAO;\n import org.apache.syncope.persistence.api.dao.PlainSchemaDAO;\n+import org.apache.syncope.persistence.api.entity.AttributableUtilFactory;\n import org.apache.syncope.persistence.api.entity.conf.CPlainAttr;\n import org.apache.syncope.persistence.api.entity.conf.CPlainSchema;\n import org.apache.syncope.persistence.api.entity.conf.Conf;\n-import org.apache.syncope.persistence.jpa.entity.JPAAttributableUtil;\n import org.apache.syncope.persistence.jpa.entity.conf.JPACPlainAttr;\n import org.apache.syncope.persistence.jpa.entity.conf.JPAConf;\n import org.springframework.beans.factory.annotation.Autowired;\n@@ -41,6 +41,9 @@ public class JPAConfDAO extends AbstractDAO<Conf, Long> implements ConfDAO {\n     @Autowired\n     private PlainAttrDAO attrDAO;\n \n+    @Autowired\n+    private AttributableUtilFactory attrUtilFactory;\n+\n     @Override\n     public Conf get() {\n         Conf instance = entityManager.find(JPAConf.class, 1L);\n@@ -68,7 +71,7 @@ public CPlainAttr find(final String key, final String defaultValue) {\n             result = new JPACPlainAttr();\n             result.setSchema(schemaDAO.find(key, CPlainSchema.class));\n \n-            result.addValue(defaultValue, JPAAttributableUtil.getInstance(AttributableType.CONFIGURATION));\n+            result.addValue(defaultValue, attrUtilFactory.getInstance(AttributableType.CONFIGURATION));\n         }\n \n         return result;"},{"sha":"8ac1423344a19b6caf071b8ece40755ae292571d","filename":"syncope620/server/persistence-jpa/src/main/java/org/apache/syncope/persistence/jpa/dao/JPARoleDAO.java","status":"modified","additions":31,"deletions":5,"changes":36,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fdao%2FJPARoleDAO.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fdao%2FJPARoleDAO.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fdao%2FJPARoleDAO.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -23,6 +23,7 @@\n import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n+import java.util.Set;\n import javax.persistence.NoResultException;\n import javax.persistence.Query;\n import javax.persistence.TypedQuery;\n@@ -31,12 +32,14 @@\n import org.apache.syncope.persistence.api.RoleEntitlementUtil;\n import org.apache.syncope.persistence.api.dao.DerAttrDAO;\n import org.apache.syncope.persistence.api.dao.EntitlementDAO;\n+import org.apache.syncope.persistence.api.dao.NotFoundException;\n import org.apache.syncope.persistence.api.dao.PlainAttrDAO;\n import org.apache.syncope.persistence.api.dao.RoleDAO;\n import org.apache.syncope.persistence.api.dao.UserDAO;\n import org.apache.syncope.persistence.api.dao.VirAttrDAO;\n import org.apache.syncope.persistence.api.dao.search.OrderByClause;\n import org.apache.syncope.persistence.api.entity.AttrTemplate;\n+import org.apache.syncope.persistence.api.entity.AttributableUtilFactory;\n import org.apache.syncope.persistence.api.entity.DerAttr;\n import org.apache.syncope.persistence.api.entity.Entitlement;\n import org.apache.syncope.persistence.api.entity.ExternalResource;\n@@ -60,9 +63,10 @@\n import org.apache.syncope.persistence.api.entity.role.RVirAttrTemplate;\n import org.apache.syncope.persistence.api.entity.role.Role;\n import org.apache.syncope.persistence.api.entity.user.User;\n-import org.apache.syncope.persistence.jpa.entity.JPAAttributableUtil;\n import org.apache.syncope.persistence.jpa.entity.membership.JPAMembership;\n import org.apache.syncope.persistence.jpa.entity.role.JPARole;\n+import org.apache.syncope.server.security.AuthContextUtil;\n+import org.apache.syncope.server.security.UnauthorizedRoleException;\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.stereotype.Repository;\n import org.springframework.transaction.annotation.Transactional;\n@@ -85,6 +89,9 @@ public class JPARoleDAO extends AbstractSubjectDAO<RPlainAttr, RDerAttr, RVirAtt\n     @Autowired\n     private EntitlementDAO entitlementDAO;\n \n+    @Autowired\n+    private AttributableUtilFactory attrUtilFactory;\n+\n     @Override\n     protected Subject<RPlainAttr, RDerAttr, RVirAttr> findInternal(final Long key) {\n         return find(key);\n@@ -321,27 +328,27 @@ public List<Role> findDescendants(final Role role) {\n     @Override\n     public List<Role> findByAttrValue(final String schemaName, final RPlainAttrValue attrValue) {\n         return (List<Role>) findByAttrValue(\n-                schemaName, attrValue, JPAAttributableUtil.getInstance(AttributableType.ROLE));\n+                schemaName, attrValue, attrUtilFactory.getInstance(AttributableType.ROLE));\n     }\n \n     @SuppressWarnings(\"unchecked\")\n     @Override\n     public Role findByAttrUniqueValue(final String schemaName, final RPlainAttrValue attrUniqueValue) {\n         return (Role) findByAttrUniqueValue(schemaName, attrUniqueValue,\n-                JPAAttributableUtil.getInstance(AttributableType.ROLE));\n+                attrUtilFactory.getInstance(AttributableType.ROLE));\n     }\n \n     @SuppressWarnings(\"unchecked\")\n     @Override\n     public List<Role> findByDerAttrValue(final String schemaName, final String value) {\n         return (List<Role>) findByDerAttrValue(\n-                schemaName, value, JPAAttributableUtil.getInstance(AttributableType.ROLE));\n+                schemaName, value, attrUtilFactory.getInstance(AttributableType.ROLE));\n     }\n \n     @SuppressWarnings(\"unchecked\")\n     @Override\n     public List<Role> findByResource(final ExternalResource resource) {\n-        return (List<Role>) findByResource(resource, JPAAttributableUtil.getInstance(AttributableType.ROLE));\n+        return (List<Role>) findByResource(resource, attrUtilFactory.getInstance(AttributableType.ROLE));\n     }\n \n     @Override\n@@ -528,4 +535,23 @@ public void delete(final Long key) {\n \n         delete(role);\n     }\n+\n+    @Override\n+    public Role authFetchRole(Long key) {\n+        if (key == null) {\n+            throw new NotFoundException(\"Null role id\");\n+        }\n+\n+        Role role = find(key);\n+        if (role == null) {\n+            throw new NotFoundException(\"Role \" + key);\n+        }\n+\n+        Set<Long> allowedRoleIds = RoleEntitlementUtil.getRoleKeys(AuthContextUtil.getOwnedEntitlementNames());\n+        if (!allowedRoleIds.contains(role.getKey())) {\n+            throw new UnauthorizedRoleException(role.getKey());\n+        }\n+        return role;\n+    }\n+\n }"},{"sha":"e71488d23e4b9381e400a5f7f502ea3ce5f3d4f7","filename":"syncope620/server/persistence-jpa/src/main/java/org/apache/syncope/persistence/jpa/dao/JPASubjectSearchDAO.java","status":"modified","additions":8,"deletions":5,"changes":13,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fdao%2FJPASubjectSearchDAO.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fdao%2FJPASubjectSearchDAO.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fdao%2FJPASubjectSearchDAO.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -46,10 +46,10 @@\n import org.apache.syncope.persistence.api.dao.search.SearchCond;\n import org.apache.syncope.persistence.api.dao.search.SubjectCond;\n import org.apache.syncope.persistence.api.entity.AttributableUtil;\n+import org.apache.syncope.persistence.api.entity.AttributableUtilFactory;\n import org.apache.syncope.persistence.api.entity.PlainAttrValue;\n import org.apache.syncope.persistence.api.entity.PlainSchema;\n import org.apache.syncope.persistence.api.entity.Subject;\n-import org.apache.syncope.persistence.jpa.entity.JPAAttributableUtil;\n import org.springframework.beans.BeanUtils;\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.stereotype.Repository;\n@@ -69,6 +69,9 @@ public class JPASubjectSearchDAO extends AbstractDAO<Subject<?, ?, ?>, Long> imp\n     @Autowired\n     private PlainSchemaDAO schemaDAO;\n \n+    @Autowired\n+    private AttributableUtilFactory attrUtilFactory;\n+\n     private String getAdminRolesFilter(final Set<Long> adminRoles, final SubjectType type) {\n         final StringBuilder adminRolesFilter = new StringBuilder();\n \n@@ -272,7 +275,7 @@ private StringBuilder buildOrderBy(final OrderBySupport orderBySupport) {\n     private OrderBySupport parseOrderBy(final SubjectType type, final SearchSupport svs,\n             final List<OrderByClause> orderByClauses) {\n \n-        final AttributableUtil attrUtil = JPAAttributableUtil.getInstance(type.asAttributableType());\n+        final AttributableUtil attrUtil = attrUtilFactory.getInstance(type.asAttributableType());\n \n         OrderBySupport orderBySupport = new OrderBySupport();\n \n@@ -598,7 +601,7 @@ private void fillAttributeQuery(final StringBuilder query, final PlainAttrValue\n     private String getQuery(final AttributeCond cond, final boolean not, final List<Object> parameters,\n             final SubjectType type, final SearchSupport svs) {\n \n-        final AttributableUtil attrUtil = JPAAttributableUtil.getInstance(type.asAttributableType());\n+        final AttributableUtil attrUtil = attrUtilFactory.getInstance(type.asAttributableType());\n \n         PlainSchema schema = schemaDAO.find(cond.getSchema(), attrUtil.plainSchemaClass());\n         if (schema == null) {\n@@ -647,7 +650,7 @@ private String getQuery(final AttributeCond cond, final boolean not, final List<\n     private String getQuery(final SubjectCond cond, final boolean not, final List<Object> parameters,\n             final SubjectType type, final SearchSupport svs) {\n \n-        final AttributableUtil attrUtil = JPAAttributableUtil.getInstance(type.asAttributableType());\n+        final AttributableUtil attrUtil = attrUtilFactory.getInstance(type.asAttributableType());\n \n         Field subjectField = ReflectionUtils.findField(attrUtil.attributableClass(), cond.getSchema());\n         if (subjectField == null) {\n@@ -664,7 +667,7 @@ private String getQuery(final SubjectCond cond, final boolean not, final List<Ob\n         }\n \n         // Deal with subject Integer fields logically mapping to boolean values\n-        // (SyncopeRole.inheritAttrs, for example)\n+        // (SyncopeRole.inheritPlainAttrs, for example)\n         boolean foundBooleanMin = false;\n         boolean foundBooleanMax = false;\n         if (Integer.class.equals(subjectField.getType())) {"},{"sha":"fd28fcdd797e984ac37b1a8490911beb9b079d4b","filename":"syncope620/server/persistence-jpa/src/main/java/org/apache/syncope/persistence/jpa/dao/JPAUserDAO.java","status":"modified","additions":64,"deletions":5,"changes":69,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fdao%2FJPAUserDAO.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fdao%2FJPAUserDAO.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fdao%2FJPAUserDAO.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -21,17 +21,21 @@\n import java.util.Collections;\n import java.util.List;\n import java.util.Set;\n+import javax.annotation.Resource;\n import javax.persistence.NoResultException;\n import javax.persistence.TypedQuery;\n import org.apache.syncope.common.lib.types.AttributableType;\n import org.apache.syncope.common.lib.types.SubjectType;\n+import org.apache.syncope.persistence.api.RoleEntitlementUtil;\n+import org.apache.syncope.persistence.api.dao.NotFoundException;\n import org.apache.syncope.persistence.api.dao.RoleDAO;\n import org.apache.syncope.persistence.api.dao.SubjectSearchDAO;\n import org.apache.syncope.persistence.api.dao.UserDAO;\n import org.apache.syncope.persistence.api.dao.search.AttributeCond;\n import org.apache.syncope.persistence.api.dao.search.OrderByClause;\n import org.apache.syncope.persistence.api.dao.search.SearchCond;\n import org.apache.syncope.persistence.api.dao.search.SubjectCond;\n+import org.apache.syncope.persistence.api.entity.AttributableUtilFactory;\n import org.apache.syncope.persistence.api.entity.ExternalResource;\n import org.apache.syncope.persistence.api.entity.Subject;\n import org.apache.syncope.persistence.api.entity.VirAttr;\n@@ -42,8 +46,9 @@\n import org.apache.syncope.persistence.api.entity.user.UPlainAttrValue;\n import org.apache.syncope.persistence.api.entity.user.UVirAttr;\n import org.apache.syncope.persistence.api.entity.user.User;\n-import org.apache.syncope.persistence.jpa.entity.JPAAttributableUtil;\n import org.apache.syncope.persistence.jpa.entity.user.JPAUser;\n+import org.apache.syncope.server.security.AuthContextUtil;\n+import org.apache.syncope.server.security.UnauthorizedRoleException;\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.stereotype.Repository;\n \n@@ -56,6 +61,12 @@ public class JPAUserDAO extends AbstractSubjectDAO<UPlainAttr, UDerAttr, UVirAtt\n     @Autowired\n     private RoleDAO roleDAO;\n \n+    @Resource(name = \"anonymousUser\")\n+    private String anonymousUser;\n+\n+    @Autowired\n+    private AttributableUtilFactory attrUtilFactory;\n+\n     @Override\n     protected Subject<UPlainAttr, UDerAttr, UVirAttr> findInternal(Long key) {\n         return find(key);\n@@ -138,27 +149,27 @@ public List<User> findBySecurityQuestion(final SecurityQuestion securityQuestion\n     @Override\n     public List<User> findByAttrValue(final String schemaName, final UPlainAttrValue attrValue) {\n         return (List<User>) findByAttrValue(\n-                schemaName, attrValue, JPAAttributableUtil.getInstance(AttributableType.USER));\n+                schemaName, attrValue, attrUtilFactory.getInstance(AttributableType.USER));\n     }\n \n     @SuppressWarnings(\"unchecked\")\n     @Override\n     public User findByAttrUniqueValue(final String schemaName, final UPlainAttrValue attrUniqueValue) {\n         return (User) findByAttrUniqueValue(schemaName, attrUniqueValue,\n-                JPAAttributableUtil.getInstance(AttributableType.USER));\n+                attrUtilFactory.getInstance(AttributableType.USER));\n     }\n \n     @SuppressWarnings(\"unchecked\")\n     @Override\n     public List<User> findByDerAttrValue(final String schemaName, final String value) {\n         return (List<User>) findByDerAttrValue(\n-                schemaName, value, JPAAttributableUtil.getInstance(AttributableType.USER));\n+                schemaName, value, attrUtilFactory.getInstance(AttributableType.USER));\n     }\n \n     @SuppressWarnings(\"unchecked\")\n     @Override\n     public List<User> findByResource(final ExternalResource resource) {\n-        return (List<User>) findByResource(resource, JPAAttributableUtil.getInstance(AttributableType.USER));\n+        return (List<User>) findByResource(resource, attrUtilFactory.getInstance(AttributableType.USER));\n     }\n \n     @Override\n@@ -222,4 +233,52 @@ public void delete(final User user) {\n \n         entityManager.remove(user);\n     }\n+\n+    private void securityChecks(final User user) {\n+        // Allows anonymous (during self-registration) and self (during self-update) to read own SyncopeUser,\n+        // otherwise goes thorugh security checks to see if needed role entitlements are owned\n+        if (!AuthContextUtil.getAuthenticatedUsername().equals(anonymousUser)\n+                && !AuthContextUtil.getAuthenticatedUsername().equals(user.getUsername())) {\n+\n+            Set<Long> roleIds = user.getRoleIds();\n+            Set<Long> adminRoleIds = RoleEntitlementUtil.getRoleKeys(AuthContextUtil.getOwnedEntitlementNames());\n+            roleIds.removeAll(adminRoleIds);\n+            if (!roleIds.isEmpty()) {\n+                throw new UnauthorizedRoleException(roleIds);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public User authFecthUser(final Long key) {\n+        if (key == null) {\n+            throw new NotFoundException(\"Null user id\");\n+        }\n+\n+        User user = find(key);\n+        if (user == null) {\n+            throw new NotFoundException(\"User \" + key);\n+        }\n+\n+        securityChecks(user);\n+\n+        return user;\n+    }\n+\n+    @Override\n+    public User authFecthUser(final String username) {\n+        if (username == null) {\n+            throw new NotFoundException(\"Null username\");\n+        }\n+\n+        User user = find(username);\n+        if (user == null) {\n+            throw new NotFoundException(\"User \" + username);\n+        }\n+\n+        securityChecks(user);\n+\n+        return user;\n+    }\n+\n }"},{"sha":"8bde455d9e6b2fa03fbc1bbf1ea5676dfe62e2dd","filename":"syncope620/server/persistence-jpa/src/main/java/org/apache/syncope/persistence/jpa/entity/AbstractEntity.java","status":"modified","additions":2,"deletions":3,"changes":5,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fentity%2FAbstractEntity.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fentity%2FAbstractEntity.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fentity%2FAbstractEntity.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -19,7 +19,6 @@\n package org.apache.syncope.persistence.jpa.entity;\n \n import java.beans.PropertyDescriptor;\n-import java.io.Serializable;\n import java.lang.reflect.Method;\n import java.util.Collections;\n import java.util.HashSet;\n@@ -31,7 +30,7 @@\n import org.slf4j.LoggerFactory;\n import org.springframework.beans.BeanUtils;\n \n-public abstract class AbstractEntity<KEY> implements Entity<KEY>, Serializable {\n+public abstract class AbstractEntity<KEY> implements Entity<KEY> {\n \n     private static final long serialVersionUID = -9017214159540857901L;\n \n@@ -41,7 +40,7 @@\n     protected static final Logger LOG = LoggerFactory.getLogger(AbstractEntity.class);\n \n     protected void checkType(final Object object, final Class<?> clazz) {\n-        if (object !=null && !clazz.isInstance(object)) {\n+        if (object != null && !clazz.isInstance(object)) {\n             throw new ClassCastException(\"Expected \" + clazz.getName() + \", got \" + object.getClass().getName());\n         }\n     }"},{"sha":"8b42b17b52b749f5718bc7fec7b9d953788945c5","filename":"syncope620/server/persistence-jpa/src/main/java/org/apache/syncope/persistence/jpa/entity/JPAAttributableUtil.java","status":"modified","additions":50,"deletions":53,"changes":103,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fentity%2FJPAAttributableUtil.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fentity%2FJPAAttributableUtil.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fentity%2FJPAAttributableUtil.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -21,6 +21,12 @@\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.List;\n+import org.apache.syncope.common.lib.to.AbstractAttributableTO;\n+import org.apache.syncope.common.lib.to.AbstractSubjectTO;\n+import org.apache.syncope.common.lib.to.ConfTO;\n+import org.apache.syncope.common.lib.to.MembershipTO;\n+import org.apache.syncope.common.lib.to.RoleTO;\n+import org.apache.syncope.common.lib.to.UserTO;\n import org.apache.syncope.common.lib.types.AttributableType;\n import org.apache.syncope.common.lib.types.IntMappingType;\n import org.apache.syncope.common.lib.types.MappingPurpose;\n@@ -36,10 +42,6 @@\n import org.apache.syncope.persistence.api.entity.PlainSchema;\n import org.apache.syncope.persistence.api.entity.VirAttr;\n import org.apache.syncope.persistence.api.entity.VirSchema;\n-import org.apache.syncope.persistence.api.entity.conf.Conf;\n-import org.apache.syncope.persistence.api.entity.membership.Membership;\n-import org.apache.syncope.persistence.api.entity.role.Role;\n-import org.apache.syncope.persistence.api.entity.user.User;\n import org.apache.syncope.persistence.jpa.entity.conf.JPACPlainAttr;\n import org.apache.syncope.persistence.jpa.entity.conf.JPACPlainAttrUniqueValue;\n import org.apache.syncope.persistence.jpa.entity.conf.JPACPlainAttrValue;\n@@ -81,7 +83,6 @@\n import org.apache.syncope.persistence.jpa.entity.user.JPAUVirSchema;\n import org.apache.syncope.persistence.jpa.entity.user.JPAUser;\n import org.apache.syncope.server.spring.BeanUtils;\n-import org.identityconnectors.framework.common.objects.ObjectClass;\n import org.identityconnectors.framework.common.objects.Uid;\n import org.slf4j.LoggerFactory;\n \n@@ -93,55 +94,9 @@ public class JPAAttributableUtil implements AttributableUtil {\n      */\n     private static final org.slf4j.Logger LOG = LoggerFactory.getLogger(AttributableUtil.class);\n \n-    public static AttributableUtil getInstance(final AttributableType type) {\n-        return new JPAAttributableUtil(type);\n-    }\n-\n-    public static AttributableUtil valueOf(final String name) {\n-        return new JPAAttributableUtil(AttributableType.valueOf(name));\n-    }\n-\n-    public static AttributableUtil getInstance(final ObjectClass objectClass) {\n-        AttributableType type = null;\n-        if (ObjectClass.ACCOUNT.equals(objectClass)) {\n-            type = AttributableType.USER;\n-        }\n-        if (ObjectClass.GROUP.equals(objectClass)) {\n-            type = AttributableType.ROLE;\n-        }\n-\n-        if (type == null) {\n-            throw new IllegalArgumentException(\"ObjectClass not supported: \" + objectClass);\n-        }\n-\n-        return new JPAAttributableUtil(type);\n-    }\n-\n-    public static AttributableUtil getInstance(final Attributable attributable) {\n-        AttributableType type = null;\n-        if (attributable instanceof User) {\n-            type = AttributableType.USER;\n-        }\n-        if (attributable instanceof Role) {\n-            type = AttributableType.ROLE;\n-        }\n-        if (attributable instanceof Membership) {\n-            type = AttributableType.MEMBERSHIP;\n-        }\n-        if (attributable instanceof Conf) {\n-            type = AttributableType.CONFIGURATION;\n-        }\n-\n-        if (type == null) {\n-            throw new IllegalArgumentException(\"Attributable type not supported: \" + attributable.getClass().getName());\n-        }\n-\n-        return new JPAAttributableUtil(type);\n-    }\n-\n     private final AttributableType type;\n \n-    private JPAAttributableUtil(final AttributableType type) {\n+    protected JPAAttributableUtil(final AttributableType type) {\n         this.type = type;\n     }\n \n@@ -723,7 +678,7 @@ public <T extends MappingItem> List<T> getMappingItems(\n             }\n         }\n \n-        final List<T> result = new ArrayList<T>();\n+        final List<T> result = new ArrayList<>();\n \n         switch (purpose) {\n             case SYNCHRONIZATION:\n@@ -879,4 +834,46 @@ public <T extends MappingItem> Class<T> mappingItemClass() {\n         return result;\n     }\n \n+    @Override\n+    public <T extends AbstractAttributableTO> T newAttributableTO() {\n+        T result = null;\n+\n+        switch (type) {\n+            case USER:\n+                result = (T) new UserTO();\n+                break;\n+            case ROLE:\n+                result = (T) new RoleTO();\n+                break;\n+            case MEMBERSHIP:\n+                result = (T) new MembershipTO();\n+                break;\n+            case CONFIGURATION:\n+                result = (T) new ConfTO();\n+                break;\n+            default:\n+        }\n+\n+        return result;\n+    }\n+\n+    @Override\n+    public <T extends AbstractSubjectTO> T newSubjectTO() {\n+        T result = null;\n+\n+        switch (type) {\n+            case USER:\n+                result = (T) new UserTO();\n+                break;\n+            case ROLE:\n+                result = (T) new RoleTO();\n+                break;\n+            case MEMBERSHIP:\n+            case CONFIGURATION:\n+            default:\n+                break;\n+        }\n+\n+        return result;\n+    }\n }"},{"sha":"8e772b86a1d88ab457f6c80e817a74a9bc8b0268","filename":"syncope620/server/persistence-jpa/src/main/java/org/apache/syncope/persistence/jpa/entity/JPAEntityFactory.java","status":"modified","additions":8,"deletions":1,"changes":9,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fentity%2FJPAEntityFactory.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fentity%2FJPAEntityFactory.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fentity%2FJPAEntityFactory.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -20,6 +20,7 @@\n \n import org.apache.syncope.persistence.api.entity.AccountPolicy;\n import org.apache.syncope.persistence.api.entity.ConnInstance;\n+import org.apache.syncope.persistence.api.entity.ConnPoolConf;\n import org.apache.syncope.persistence.api.entity.Entitlement;\n import org.apache.syncope.persistence.api.entity.Entity;\n import org.apache.syncope.persistence.api.entity.EntityFactory;\n@@ -134,8 +135,8 @@\n @Component\n public class JPAEntityFactory implements EntityFactory {\n \n-    @Override\n     @SuppressWarnings(\"unchecked\")\n+    @Override\n     public <KEY, T extends Entity<KEY>> T newEntity(final Class<T> reference) {\n         T result;\n \n@@ -258,6 +259,7 @@ public <KEY, T extends Entity<KEY>> T newEntity(final Class<T> reference) {\n         return result;\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     @Override\n     public <T extends Policy> T newPolicy(final Class<T> reference, final boolean global) {\n         T result;\n@@ -277,4 +279,9 @@ public <T extends Policy> T newPolicy(final Class<T> reference, final boolean gl\n         return result;\n     }\n \n+    @Override\n+    public ConnPoolConf newConnPoolConf() {\n+        return new JPAConnPoolConf();\n+    }\n+\n }"},{"sha":"b2213302eb3ce0394c63b764a40f1a9b5edd2fee","filename":"syncope620/server/persistence-jpa/src/main/java/org/apache/syncope/persistence/jpa/entity/JPAPushPolicy.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fentity%2FJPAPushPolicy.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fentity%2FJPAPushPolicy.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fentity%2FJPAPushPolicy.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -25,7 +25,7 @@\n @Entity\n public class JPAPushPolicy extends JPAPolicy implements PushPolicy {\n \n-    private static final long serialVersionUID = -6090413855809521279L;\n+    private static final long serialVersionUID = -5875589156893921113L;\n \n     public JPAPushPolicy() {\n         this(false);"},{"sha":"4ce7d5e28f8f8a59e13005196b2531818071f8c3","filename":"syncope620/server/persistence-jpa/src/main/java/org/apache/syncope/persistence/jpa/entity/JPASecurityQuestion.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fentity%2FJPASecurityQuestion.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fentity%2FJPASecurityQuestion.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fentity%2FJPASecurityQuestion.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -28,7 +28,7 @@\n @Table(name = JPASecurityQuestion.TABLE)\n public class JPASecurityQuestion extends AbstractEntity<Long> implements SecurityQuestion {\n \n-    private static final long serialVersionUID = -7646140284033489392L;\n+    private static final long serialVersionUID = 7675321820453579744L;\n \n     public static final String TABLE = \"SecurityQuestion\";\n "},{"sha":"6962b41567112a34ffa213dfdcc87de76b7eeb4f","filename":"syncope620/server/persistence-jpa/src/main/java/org/apache/syncope/persistence/jpa/entity/JPAttributableUtilFactory.java","status":"added","additions":85,"deletions":0,"changes":85,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fentity%2FJPAttributableUtilFactory.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fentity%2FJPAttributableUtilFactory.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fentity%2FJPAttributableUtilFactory.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,85 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.persistence.jpa.entity;\n+\n+import org.apache.syncope.common.lib.types.AttributableType;\n+import org.apache.syncope.persistence.api.entity.Attributable;\n+import org.apache.syncope.persistence.api.entity.AttributableUtil;\n+import org.apache.syncope.persistence.api.entity.AttributableUtilFactory;\n+import org.apache.syncope.persistence.api.entity.conf.Conf;\n+import org.apache.syncope.persistence.api.entity.membership.Membership;\n+import org.apache.syncope.persistence.api.entity.role.Role;\n+import org.apache.syncope.persistence.api.entity.user.User;\n+import org.identityconnectors.framework.common.objects.ObjectClass;\n+import org.springframework.stereotype.Component;\n+\n+@Component\n+public class JPAttributableUtilFactory implements AttributableUtilFactory {\n+\n+    @Override\n+    public AttributableUtil getInstance(final AttributableType type) {\n+        return new JPAAttributableUtil(type);\n+    }\n+\n+    @Override\n+    public AttributableUtil getInstance(final String attributableType) {\n+        return new JPAAttributableUtil(AttributableType.valueOf(attributableType));\n+    }\n+\n+    @Override\n+    public AttributableUtil getInstance(final ObjectClass objectClass) {\n+        AttributableType type = null;\n+        if (ObjectClass.ACCOUNT.equals(objectClass)) {\n+            type = AttributableType.USER;\n+        }\n+        if (ObjectClass.GROUP.equals(objectClass)) {\n+            type = AttributableType.ROLE;\n+        }\n+\n+        if (type == null) {\n+            throw new IllegalArgumentException(\"ObjectClass not supported: \" + objectClass);\n+        }\n+\n+        return new JPAAttributableUtil(type);\n+    }\n+\n+    @Override\n+    public AttributableUtil getInstance(final Attributable<?, ?, ?> attributable) {\n+        AttributableType type = null;\n+        if (attributable instanceof User) {\n+            type = AttributableType.USER;\n+        }\n+        if (attributable instanceof Role) {\n+            type = AttributableType.ROLE;\n+        }\n+        if (attributable instanceof Membership) {\n+            type = AttributableType.MEMBERSHIP;\n+        }\n+        if (attributable instanceof Conf) {\n+            type = AttributableType.CONFIGURATION;\n+        }\n+\n+        if (type == null) {\n+            throw new IllegalArgumentException(\"Attributable type not supported: \" + attributable.getClass().getName());\n+        }\n+\n+        return new JPAAttributableUtil(type);\n+    }\n+\n+}"},{"sha":"3e0d404b5af97fd8291a8e8f3b837a8734c4110b","filename":"syncope620/server/persistence-jpa/src/main/java/org/apache/syncope/persistence/jpa/entity/conf/JPACPlainAttr.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fentity%2Fconf%2FJPACPlainAttr.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fentity%2Fconf%2FJPACPlainAttr.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fentity%2Fconf%2FJPACPlainAttr.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -48,7 +48,7 @@\n @Table(name = JPACPlainAttr.TABLE)\n public class JPACPlainAttr extends AbstractPlainAttr implements CPlainAttr {\n \n-    private static final long serialVersionUID = 6333601983691157406L;\n+    private static final long serialVersionUID = 8022331942314540648L;\n \n     public static final String TABLE = \"CPlainAttr\";\n "},{"sha":"8cc830cad2564c483688d36bd469e1c82c7de012","filename":"syncope620/server/persistence-jpa/src/main/java/org/apache/syncope/persistence/jpa/entity/conf/JPACPlainAttrUniqueValue.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fentity%2Fconf%2FJPACPlainAttrUniqueValue.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fentity%2Fconf%2FJPACPlainAttrUniqueValue.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fentity%2Fconf%2FJPACPlainAttrUniqueValue.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -35,7 +35,7 @@\n @Table(name = JPACPlainAttrUniqueValue.TABLE)\n public class JPACPlainAttrUniqueValue extends AbstractPlainAttrValue implements CPlainAttrUniqueValue {\n \n-    private static final long serialVersionUID = -64080804563305387L;\n+    private static final long serialVersionUID = -2072445894710677162L;\n \n     public static final String TABLE = \"CPlainAttrUniqueValue\";\n "},{"sha":"ff0a8ae9069a7e54aa891687e375a8b60403d4a6","filename":"syncope620/server/persistence-jpa/src/main/java/org/apache/syncope/persistence/jpa/entity/conf/JPACPlainAttrValue.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fentity%2Fconf%2FJPACPlainAttrValue.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fentity%2Fconf%2FJPACPlainAttrValue.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fentity%2Fconf%2FJPACPlainAttrValue.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -35,7 +35,7 @@\n @Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)\n public class JPACPlainAttrValue extends AbstractPlainAttrValue implements CPlainAttrValue {\n \n-    private static final long serialVersionUID = -6259576015647897446L;\n+    private static final long serialVersionUID = -4029895248193486171L;\n \n     public static final String TABLE = \"CPlainAttrValue\";\n "},{"sha":"0438543401be8916754ff8d773749e424246aca4","filename":"syncope620/server/persistence-jpa/src/main/java/org/apache/syncope/persistence/jpa/entity/conf/JPAConf.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fentity%2Fconf%2FJPAConf.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fentity%2Fconf%2FJPAConf.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fentity%2Fconf%2FJPAConf.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -39,7 +39,7 @@\n @Cacheable\n public class JPAConf extends AbstractAttributable<CPlainAttr, DerAttr, VirAttr> implements Conf {\n \n-    private static final long serialVersionUID = -5281258853142421875L;\n+    private static final long serialVersionUID = 7671699609879382195L;\n \n     public static final String TABLE = \"SyncopeConf\";\n "},{"sha":"1b35470c5e7a904177f5b92ecf90dab51f8c4f8b","filename":"syncope620/server/persistence-jpa/src/main/java/org/apache/syncope/persistence/jpa/entity/membership/JPAMDerAttrTemplate.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fentity%2Fmembership%2FJPAMDerAttrTemplate.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fentity%2Fmembership%2FJPAMDerAttrTemplate.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fentity%2Fmembership%2FJPAMDerAttrTemplate.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -32,7 +32,7 @@\n @Table(name = JPAMDerAttrTemplate.TABLE)\n public class JPAMDerAttrTemplate extends AbstractAttrTemplate<MDerSchema> implements MDerAttrTemplate {\n \n-    private static final long serialVersionUID = -3424574558427502145L;\n+    private static final long serialVersionUID = -4465930976210263434L;\n \n     public static final String TABLE = \"MDerAttrTemplate\";\n "},{"sha":"ad6d2c2fd667afe1cdeeec0eba31f8c44a66b0be","filename":"syncope620/server/persistence-jpa/src/main/java/org/apache/syncope/persistence/jpa/entity/membership/JPAMPlainAttrTemplate.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fentity%2Fmembership%2FJPAMPlainAttrTemplate.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fentity%2Fmembership%2FJPAMPlainAttrTemplate.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fentity%2Fmembership%2FJPAMPlainAttrTemplate.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -32,7 +32,7 @@\n @Table(name = JPAMPlainAttrTemplate.TABLE)\n public class JPAMPlainAttrTemplate extends AbstractAttrTemplate<MPlainSchema> implements MPlainAttrTemplate {\n \n-    private static final long serialVersionUID = -3424574558427502145L;\n+    private static final long serialVersionUID = -8768086609963244514L;\n \n     public static final String TABLE = \"MPlainAttrTemplate\";\n "},{"sha":"684068608c7e8f1a25633b1f65a7bc54ee7800e8","filename":"syncope620/server/persistence-jpa/src/main/java/org/apache/syncope/persistence/jpa/entity/membership/JPAMVirAttrTemplate.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fentity%2Fmembership%2FJPAMVirAttrTemplate.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fentity%2Fmembership%2FJPAMVirAttrTemplate.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fentity%2Fmembership%2FJPAMVirAttrTemplate.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -32,7 +32,7 @@\n @Table(name = JPAMVirAttrTemplate.TABLE)\n public class JPAMVirAttrTemplate extends AbstractAttrTemplate<MVirSchema> implements MVirAttrTemplate {\n \n-    private static final long serialVersionUID = -3424574558427502145L;\n+    private static final long serialVersionUID = 6618560912535667392L;\n \n     public static final String TABLE = \"MVirAttrTemplate\";\n "},{"sha":"3b382bb420ec82e0b0166c9d7262c54c5c458bdc","filename":"syncope620/server/persistence-jpa/src/main/java/org/apache/syncope/persistence/jpa/entity/role/JPARDerAttrTemplate.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fentity%2Frole%2FJPARDerAttrTemplate.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fentity%2Frole%2FJPARDerAttrTemplate.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fentity%2Frole%2FJPARDerAttrTemplate.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -31,7 +31,7 @@\n @Table(name = JPARDerAttrTemplate.TABLE)\n public class JPARDerAttrTemplate extends AbstractAttrTemplate<RDerSchema> implements RDerAttrTemplate {\n \n-    private static final long serialVersionUID = -3424574558427502145L;\n+    private static final long serialVersionUID = 624868884107016649L;\n \n     public static final String TABLE = \"RDerAttrTemplate\";\n "},{"sha":"7d88bf7b49b645e46d713fb062a3e4a89de35f98","filename":"syncope620/server/persistence-jpa/src/main/java/org/apache/syncope/persistence/jpa/entity/role/JPARPlainAttrTemplate.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fentity%2Frole%2FJPARPlainAttrTemplate.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fentity%2Frole%2FJPARPlainAttrTemplate.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fentity%2Frole%2FJPARPlainAttrTemplate.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -31,7 +31,7 @@\n @Table(name = JPARPlainAttrTemplate.TABLE)\n public class JPARPlainAttrTemplate extends AbstractAttrTemplate<RPlainSchema> implements RPlainAttrTemplate {\n \n-    private static final long serialVersionUID = -3424574558427502145L;\n+    private static final long serialVersionUID = 6943917051517266268L;\n \n     public static final String TABLE = \"RPlainAttrTemplate\";\n "},{"sha":"2228663b40010b6eb84bff80095bc38662b440df","filename":"syncope620/server/persistence-jpa/src/main/java/org/apache/syncope/persistence/jpa/entity/role/JPARVirAttrTemplate.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fentity%2Frole%2FJPARVirAttrTemplate.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fentity%2Frole%2FJPARVirAttrTemplate.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fentity%2Frole%2FJPARVirAttrTemplate.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -31,7 +31,7 @@\n @Table(name = JPARVirAttrTemplate.TABLE)\n public class JPARVirAttrTemplate extends AbstractAttrTemplate<RVirSchema> implements RVirAttrTemplate {\n \n-    private static final long serialVersionUID = -3424574558427502145L;\n+    private static final long serialVersionUID = 4896495904794493479L;\n \n     public static final String TABLE = \"RVirAttrTemplate\";\n "},{"sha":"50bcf42acc78332e9aafe505816bfb6e8ecb30f0","filename":"syncope620/server/persistence-jpa/src/main/java/org/apache/syncope/persistence/jpa/entity/role/JPARole.java","status":"modified","additions":8,"deletions":8,"changes":16,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fentity%2Frole%2FJPARole.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fentity%2Frole%2FJPARole.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fentity%2Frole%2FJPARole.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -156,7 +156,7 @@ public class JPARole extends AbstractSubject<RPlainAttr, RDerAttr, RVirAttr> imp\n     @Basic(optional = true)\n     @Min(0)\n     @Max(1)\n-    private Integer inheritAttrs;\n+    private Integer inheritPlainAttrs;\n \n     @Basic(optional = true)\n     @Min(0)\n@@ -213,7 +213,7 @@ public JPARole() {\n \n         inheritOwner = getBooleanAsInteger(false);\n         inheritTemplates = getBooleanAsInteger(false);\n-        inheritAttrs = getBooleanAsInteger(false);\n+        inheritPlainAttrs = getBooleanAsInteger(false);\n         inheritDerAttrs = getBooleanAsInteger(false);\n         inheritVirAttrs = getBooleanAsInteger(false);\n         inheritPasswordPolicy = getBooleanAsInteger(false);\n@@ -423,13 +423,13 @@ public List<? extends RVirAttr> getVirAttrs() {\n     }\n \n     @Override\n-    public boolean isInheritAttrs() {\n-        return isBooleanAsInteger(inheritAttrs);\n+    public boolean isInheritPlainAttrs() {\n+        return isBooleanAsInteger(inheritPlainAttrs);\n     }\n \n     @Override\n-    public void setInheritAttrs(final boolean inheritAttrs) {\n-        this.inheritAttrs = getBooleanAsInteger(inheritAttrs);\n+    public void setInheritPlainAttrs(final boolean inheritPlainAttrs) {\n+        this.inheritPlainAttrs = getBooleanAsInteger(inheritPlainAttrs);\n     }\n \n     /**\n@@ -441,10 +441,10 @@ public void setInheritAttrs(final boolean inheritAttrs) {\n     public List<? extends RPlainAttr> findLastInheritedAncestorPlainAttrs() {\n         final Map<JPARPlainSchema, RPlainAttr> result = new HashMap<>();\n \n-        if (!isInheritAttrs()) {\n+        if (!isInheritPlainAttrs()) {\n             return plainAttrs;\n         }\n-        if (isInheritAttrs() && getParent() != null) {\n+        if (isInheritPlainAttrs() && getParent() != null) {\n             final Map<PlainSchema, RPlainAttr> attrMap = getPlainAttrMap();\n \n             // Add inherit attributes"},{"sha":"ef03fd71127a48f2c2741ab4526c3354ff3d107b","filename":"syncope620/server/persistence-jpa/src/main/java/org/apache/syncope/persistence/jpa/entity/task/JPASchedTask.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fentity%2Ftask%2FJPASchedTask.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fentity%2Ftask%2FJPASchedTask.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fentity%2Ftask%2FJPASchedTask.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -30,7 +30,7 @@\n @SchedTaskCheck\n public class JPASchedTask extends JPATask implements SchedTask {\n \n-    private static final long serialVersionUID = -4141057723006682562L;\n+    private static final long serialVersionUID = 7596236684832602180L;\n \n     protected String cronExpression;\n "},{"sha":"3fae881cef38a323a84836c59b1213e0531d380f","filename":"syncope620/server/persistence-jpa/src/main/java/org/apache/syncope/persistence/jpa/entity/task/JPATaskUtil.java","status":"added","additions":132,"deletions":0,"changes":132,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fentity%2Ftask%2FJPATaskUtil.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fentity%2Ftask%2FJPATaskUtil.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fentity%2Ftask%2FJPATaskUtil.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,132 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.persistence.jpa.entity.task;\n+\n+import org.apache.syncope.common.lib.to.AbstractTaskTO;\n+import org.apache.syncope.common.lib.to.NotificationTaskTO;\n+import org.apache.syncope.common.lib.to.PropagationTaskTO;\n+import org.apache.syncope.common.lib.to.PushTaskTO;\n+import org.apache.syncope.common.lib.to.SchedTaskTO;\n+import org.apache.syncope.common.lib.to.SyncTaskTO;\n+import org.apache.syncope.common.lib.types.TaskType;\n+import org.apache.syncope.persistence.api.entity.task.NotificationTask;\n+import org.apache.syncope.persistence.api.entity.task.PropagationTask;\n+import org.apache.syncope.persistence.api.entity.task.PushTask;\n+import org.apache.syncope.persistence.api.entity.task.SchedTask;\n+import org.apache.syncope.persistence.api.entity.task.SyncTask;\n+import org.apache.syncope.persistence.api.entity.task.Task;\n+import org.apache.syncope.persistence.api.entity.task.TaskUtil;\n+\n+@SuppressWarnings(\"unchecked\")\n+public final class JPATaskUtil implements TaskUtil {\n+\n+    private final TaskType type;\n+\n+    protected JPATaskUtil(final TaskType type) {\n+        this.type = type;\n+    }\n+\n+    @Override\n+    public TaskType getType() {\n+        return type;\n+    }\n+\n+    @Override\n+    public <T extends Task> Class<T> taskClass() {\n+        Class<T> result = null;\n+\n+        switch (type) {\n+            case PROPAGATION:\n+                result = (Class<T>) PropagationTask.class;\n+                break;\n+\n+            case SCHEDULED:\n+                result = (Class<T>) SchedTask.class;\n+                break;\n+\n+            case SYNCHRONIZATION:\n+                result = (Class<T>) SyncTask.class;\n+                break;\n+\n+            case PUSH:\n+                result = (Class<T>) PushTask.class;\n+                break;\n+\n+            case NOTIFICATION:\n+                result = (Class<T>) NotificationTask.class;\n+                break;\n+\n+            default:\n+        }\n+\n+        return result;\n+    }\n+\n+    @Override\n+    public <T extends Task> T newTask() {\n+        final Class<T> taskClass = taskClass();\n+        try {\n+            return taskClass == null ? null : taskClass.newInstance();\n+        } catch (Exception e) {\n+            return null;\n+        }\n+    }\n+\n+    @Override\n+    public <T extends AbstractTaskTO> Class<T> taskTOClass() {\n+        Class<T> result = null;\n+\n+        switch (type) {\n+            case PROPAGATION:\n+                result = (Class<T>) PropagationTaskTO.class;\n+                break;\n+\n+            case SCHEDULED:\n+                result = (Class<T>) SchedTaskTO.class;\n+                break;\n+\n+            case SYNCHRONIZATION:\n+                result = (Class<T>) SyncTaskTO.class;\n+                break;\n+\n+            case PUSH:\n+                result = (Class<T>) PushTaskTO.class;\n+                break;\n+\n+            case NOTIFICATION:\n+                result = (Class<T>) NotificationTaskTO.class;\n+                break;\n+\n+            default:\n+        }\n+\n+        return result;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public <T extends AbstractTaskTO> T newTaskTO() {\n+        final Class<T> taskClass = taskTOClass();\n+        try {\n+            return taskClass == null ? null : taskClass.newInstance();\n+        } catch (Exception e) {\n+            return null;\n+        }\n+    }\n+}"},{"sha":"62f5dab07ac08d805904edddd473ea9abcd5799c","filename":"syncope620/server/persistence-jpa/src/main/java/org/apache/syncope/persistence/jpa/entity/task/JPATaskUtilFactory.java","status":"added","additions":91,"deletions":0,"changes":91,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fentity%2Ftask%2FJPATaskUtilFactory.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fentity%2Ftask%2FJPATaskUtilFactory.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fentity%2Ftask%2FJPATaskUtilFactory.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,91 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.persistence.jpa.entity.task;\n+\n+import org.apache.syncope.common.lib.to.AbstractTaskTO;\n+import org.apache.syncope.common.lib.to.NotificationTaskTO;\n+import org.apache.syncope.common.lib.to.PropagationTaskTO;\n+import org.apache.syncope.common.lib.to.PushTaskTO;\n+import org.apache.syncope.common.lib.to.SchedTaskTO;\n+import org.apache.syncope.common.lib.to.SyncTaskTO;\n+import org.apache.syncope.common.lib.types.TaskType;\n+import org.apache.syncope.persistence.api.entity.task.NotificationTask;\n+import org.apache.syncope.persistence.api.entity.task.PropagationTask;\n+import org.apache.syncope.persistence.api.entity.task.PushTask;\n+import org.apache.syncope.persistence.api.entity.task.SchedTask;\n+import org.apache.syncope.persistence.api.entity.task.SyncTask;\n+import org.apache.syncope.persistence.api.entity.task.Task;\n+import org.apache.syncope.persistence.api.entity.task.TaskUtil;\n+import org.apache.syncope.persistence.api.entity.task.TaskUtilFactory;\n+import org.springframework.stereotype.Component;\n+\n+@Component\n+public class JPATaskUtilFactory implements TaskUtilFactory {\n+\n+    @Override\n+    public TaskUtil getInstance(final TaskType type) {\n+        return new JPATaskUtil(type);\n+    }\n+\n+    @Override\n+    public TaskUtil getInstance(final Task task) {\n+        TaskType type;\n+        if (task instanceof SyncTask) {\n+            type = TaskType.SYNCHRONIZATION;\n+        } else if (task instanceof PushTask) {\n+            type = TaskType.PUSH;\n+        } else if (task instanceof SchedTask) {\n+            type = TaskType.SCHEDULED;\n+        } else if (task instanceof PropagationTask) {\n+            type = TaskType.PROPAGATION;\n+        } else if (task instanceof NotificationTask) {\n+            type = TaskType.NOTIFICATION;\n+        } else {\n+            throw new IllegalArgumentException(\"Invalid task: \" + task);\n+        }\n+\n+        return getInstance(type);\n+    }\n+\n+    @Override\n+    public TaskUtil getInstance(final Class<? extends AbstractTaskTO> taskClass) {\n+        TaskType type;\n+        if (taskClass == PropagationTaskTO.class) {\n+            type = TaskType.PROPAGATION;\n+        } else if (taskClass == NotificationTaskTO.class) {\n+            type = TaskType.NOTIFICATION;\n+        } else if (taskClass == SchedTaskTO.class) {\n+            type = TaskType.SCHEDULED;\n+        } else if (taskClass == SyncTaskTO.class) {\n+            type = TaskType.SYNCHRONIZATION;\n+        } else if (taskClass == PushTaskTO.class) {\n+            type = TaskType.PUSH;\n+        } else {\n+            throw new IllegalArgumentException(\"Invalid TaskTO class: \" + taskClass.getName());\n+        }\n+\n+        return getInstance(type);\n+    }\n+\n+    @Override\n+    public TaskUtil getInstance(final AbstractTaskTO taskTO) {\n+        return getInstance(taskTO.getClass());\n+    }\n+\n+}"},{"sha":"efc66ecf6639f71e421b2e8eea96c5060a97647f","filename":"syncope620/server/persistence-jpa/src/main/java/org/apache/syncope/persistence/jpa/entity/user/JPAUser.java","status":"modified","additions":5,"deletions":3,"changes":8,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fentity%2Fuser%2FJPAUser.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fentity%2Fuser%2FJPAUser.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fentity%2Fuser%2FJPAUser.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -62,9 +62,10 @@\n import org.apache.syncope.persistence.jpa.validation.entity.UserCheck;\n import org.apache.syncope.persistence.jpa.entity.AbstractSubject;\n import org.apache.syncope.persistence.jpa.entity.JPAExternalResource;\n+import org.apache.syncope.persistence.jpa.entity.JPASecurityQuestion;\n import org.apache.syncope.persistence.jpa.entity.membership.JPAMembership;\n import org.apache.syncope.server.security.Encryptor;\n-import org.apache.syncope.server.security.SecureRandomUtil;\n+import org.apache.syncope.server.utils.SecureRandomUtil;\n \n /**\n  * Syncope user bean.\n@@ -170,7 +171,7 @@ public class JPAUser extends AbstractSubject<UPlainAttr, UDerAttr, UVirAttr> imp\n     private Set<JPAExternalResource> resources;\n \n     @ManyToOne(fetch = FetchType.EAGER, optional = true)\n-    private SecurityQuestion securityQuestion;\n+    private JPASecurityQuestion securityQuestion;\n \n     @Column(nullable = true)\n     private String securityAnswer;\n@@ -520,7 +521,8 @@ public SecurityQuestion getSecurityQuestion() {\n \n     @Override\n     public void setSecurityQuestion(final SecurityQuestion securityQuestion) {\n-        this.securityQuestion = securityQuestion;\n+        checkType(securityQuestion, JPASecurityQuestion.class);\n+        this.securityQuestion = (JPASecurityQuestion) securityQuestion;\n     }\n \n     @Override"},{"sha":"c2bdb3ab586fd6bd4b9bf13870fd78b25f839dbc","filename":"syncope620/server/persistence-jpa/src/main/java/org/apache/syncope/persistence/jpa/validation/entity/ConnInstanceValidator.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fvalidation%2Fentity%2FConnInstanceValidator.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fvalidation%2Fentity%2FConnInstanceValidator.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fvalidation%2Fentity%2FConnInstanceValidator.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -22,7 +22,7 @@\n import org.apache.syncope.common.lib.types.EntityViolationType;\n import org.apache.syncope.persistence.api.entity.ConnInstance;\n import org.apache.syncope.persistence.jpa.entity.JPAConnPoolConf;\n-import org.apache.syncope.server.utils.URIUtil;\n+import org.apache.syncope.provisioning.api.URIUtil;\n import org.apache.syncope.provisioning.api.ConnPoolConfUtil;\n \n public class ConnInstanceValidator extends AbstractValidator<ConnInstanceCheck, ConnInstance> {"},{"sha":"afb405a4d8db0a5c41d068947c1b3a04de4386be","filename":"syncope620/server/persistence-jpa/src/test/java/org/apache/syncope/persistence/jpa/AbstractTest.java","status":"modified","additions":4,"deletions":0,"changes":4,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2FAbstractTest.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2FAbstractTest.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2FAbstractTest.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -18,6 +18,7 @@\n  */\n package org.apache.syncope.persistence.jpa;\n \n+import org.apache.syncope.persistence.api.entity.AttributableUtilFactory;\n import org.apache.syncope.persistence.api.entity.EntityFactory;\n import org.junit.runner.RunWith;\n import org.springframework.beans.factory.annotation.Autowired;\n@@ -31,4 +32,7 @@ public abstract class AbstractTest {\n     @Autowired\n     protected EntityFactory entityFactory;\n \n+    @Autowired\n+    protected AttributableUtilFactory attrUtilFactory;\n+\n }"},{"sha":"0b5ccf1430914b58944522fede926d9bfe23f66a","filename":"syncope620/server/persistence-jpa/src/test/java/org/apache/syncope/persistence/jpa/entity/AttrTest.java","status":"modified","additions":7,"deletions":7,"changes":14,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fentity%2FAttrTest.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fentity%2FAttrTest.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fentity%2FAttrTest.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -87,15 +87,15 @@ public void save() throws ClassNotFoundException {\n \n         Exception thrown = null;\n         try {\n-            attribute.addValue(\"john.doe@gmail.com\", JPAAttributableUtil.getInstance(AttributableType.USER));\n-            attribute.addValue(\"mario.rossi@gmail.com\", JPAAttributableUtil.getInstance(AttributableType.USER));\n+            attribute.addValue(\"john.doe@gmail.com\", attrUtilFactory.getInstance(AttributableType.USER));\n+            attribute.addValue(\"mario.rossi@gmail.com\", attrUtilFactory.getInstance(AttributableType.USER));\n         } catch (ValidationException e) {\n             thrown = e;\n         }\n         assertNull(\"no validation exception expected here \", thrown);\n \n         try {\n-            attribute.addValue(\"http://www.apache.org\", JPAAttributableUtil.getInstance(AttributableType.USER));\n+            attribute.addValue(\"http://www.apache.org\", attrUtilFactory.getInstance(AttributableType.USER));\n         } catch (ValidationException e) {\n             thrown = e;\n         }\n@@ -119,13 +119,13 @@ public void saveWithEnum() throws ClassNotFoundException {\n         Exception thrown = null;\n \n         try {\n-            attribute.addValue(\"A\", JPAAttributableUtil.getInstance(AttributableType.USER));\n+            attribute.addValue(\"A\", attrUtilFactory.getInstance(AttributableType.USER));\n         } catch (ValidationException e) {\n             thrown = e;\n         }\n         assertNotNull(\"validation exception expected here \", thrown);\n \n-        attribute.addValue(\"M\", JPAAttributableUtil.getInstance(AttributableType.USER));\n+        attribute.addValue(\"M\", attrUtilFactory.getInstance(AttributableType.USER));\n \n         InvalidEntityException iee = null;\n         try {\n@@ -183,7 +183,7 @@ public void saveWithEncrypted() throws Exception {\n \n         UPlainAttr attribute = entityFactory.newEntity(UPlainAttr.class);\n         attribute.setSchema(obscureSchema);\n-        attribute.addValue(\"testvalue\", JPAAttributableUtil.getInstance(AttributableType.USER));\n+        attribute.addValue(\"testvalue\", attrUtilFactory.getInstance(AttributableType.USER));\n         attribute.setOwner(user);\n         user.addPlainAttr(attribute);\n \n@@ -210,7 +210,7 @@ public void saveWithBinary() throws UnsupportedEncodingException {\n \n         UPlainAttr attribute = entityFactory.newEntity(UPlainAttr.class);\n         attribute.setSchema(photoSchema);\n-        attribute.addValue(photoB64Value, JPAAttributableUtil.getInstance(AttributableType.USER));\n+        attribute.addValue(photoB64Value, attrUtilFactory.getInstance(AttributableType.USER));\n         attribute.setOwner(user);\n         user.addPlainAttr(attribute);\n "},{"sha":"143a4fedb689bc6f0d9706d4c04b3e9f8ca3c0e3","filename":"syncope620/server/persistence-jpa/src/test/java/org/apache/syncope/persistence/jpa/entity/ConfTest.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fentity%2FConfTest.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fentity%2FConfTest.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fentity%2FConfTest.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -72,15 +72,15 @@ public void setAndDelete() {\n         // 2. create conf\n         CPlainAttr newConf = entityFactory.newEntity(CPlainAttr.class);\n         newConf.setSchema(useless);\n-        newConf.addValue(\"2014-06-20\", JPAAttributableUtil.getInstance(AttributableType.CONFIGURATION));\n+        newConf.addValue(\"2014-06-20\", attrUtilFactory.getInstance(AttributableType.CONFIGURATION));\n         confDAO.save(newConf);\n \n         CPlainAttr actual = confDAO.find(\"useless\");\n         assertEquals(actual.getValuesAsStrings(), newConf.getValuesAsStrings());\n \n         // 3. update conf\n         newConf.getValues().clear();\n-        newConf.addValue(\"2014-06-20\", JPAAttributableUtil.getInstance(AttributableType.CONFIGURATION));\n+        newConf.addValue(\"2014-06-20\", attrUtilFactory.getInstance(AttributableType.CONFIGURATION));\n         confDAO.save(newConf);\n \n         actual = confDAO.find(\"useless\");"},{"sha":"94c61aa29b382d09501bf8fc805677878cd2b2d2","filename":"syncope620/server/persistence-jpa/src/test/java/org/apache/syncope/persistence/jpa/entity/DerSchemaTest.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fentity%2FDerSchemaTest.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fentity%2FDerSchemaTest.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fentity%2FDerSchemaTest.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -73,7 +73,7 @@ public void delete() {\n         UDerSchema cn = derSchemaDAO.find(\"cn\", UDerSchema.class);\n         assertNotNull(cn);\n \n-        derSchemaDAO.delete(cn.getKey(), JPAAttributableUtil.getInstance(AttributableType.USER));\n+        derSchemaDAO.delete(cn.getKey(), attrUtilFactory.getInstance(AttributableType.USER));\n \n         DerSchema actual = derSchemaDAO.find(\"cn\", UDerSchema.class);\n         assertNull(\"delete did not work\", actual);\n@@ -82,7 +82,7 @@ public void delete() {\n         RDerSchema rderiveddata = derSchemaDAO.find(\"rderiveddata\", RDerSchema.class);\n         assertNotNull(rderiveddata);\n \n-        derSchemaDAO.delete(rderiveddata.getKey(), JPAAttributableUtil.getInstance(AttributableType.ROLE));\n+        derSchemaDAO.delete(rderiveddata.getKey(), attrUtilFactory.getInstance(AttributableType.ROLE));\n \n         actual = derSchemaDAO.find(\"rderiveddata\", RDerSchema.class);\n         assertNull(\"delete did not work\", actual);"},{"sha":"652d32e8626c6d29c24e323c0251eae133c0e2c1","filename":"syncope620/server/persistence-jpa/src/test/java/org/apache/syncope/persistence/jpa/entity/PlainSchemaTest.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fentity%2FPlainSchemaTest.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fentity%2FPlainSchemaTest.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fentity%2FPlainSchemaTest.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -139,7 +139,7 @@ public void saveInvalidSchema() {\n     public void delete() {\n         UPlainSchema fullnam = plainSchemaDAO.find(\"fullname\", UPlainSchema.class);\n \n-        plainSchemaDAO.delete(fullnam.getKey(), JPAAttributableUtil.getInstance(AttributableType.USER));\n+        plainSchemaDAO.delete(fullnam.getKey(), attrUtilFactory.getInstance(AttributableType.USER));\n \n         UPlainSchema actual = plainSchemaDAO.find(\"fullname\", UPlainSchema.class);\n         assertNull(\"delete did not work\", actual);"},{"sha":"df60909e7452a52f7aabe77f4ba10a4e87956b37","filename":"syncope620/server/persistence-jpa/src/test/java/org/apache/syncope/persistence/jpa/entity/VirSchemaTest.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fentity%2FVirSchemaTest.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fentity%2FVirSchemaTest.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Fentity%2FVirSchemaTest.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -72,7 +72,7 @@ public void save() {\n     public void delete() {\n         UVirSchema virtualdata = virSchemaDAO.find(\"virtualdata\", UVirSchema.class);\n \n-        virSchemaDAO.delete(virtualdata.getKey(), JPAAttributableUtil.getInstance(AttributableType.USER));\n+        virSchemaDAO.delete(virtualdata.getKey(), attrUtilFactory.getInstance(AttributableType.USER));\n \n         VirSchema actual = virSchemaDAO.find(\"virtualdata\", UVirSchema.class);\n         assertNull(\"delete did not work\", actual);\n@@ -81,7 +81,7 @@ public void delete() {\n         RVirSchema rvirtualdata = virSchemaDAO.find(\"rvirtualdata\", RVirSchema.class);\n         assertNotNull(rvirtualdata);\n \n-        virSchemaDAO.delete(rvirtualdata.getKey(), JPAAttributableUtil.getInstance(AttributableType.ROLE));\n+        virSchemaDAO.delete(rvirtualdata.getKey(), attrUtilFactory.getInstance(AttributableType.ROLE));\n \n         actual = virSchemaDAO.find(\"rvirtualdata\", RVirSchema.class);\n         assertNull(\"delete did not work\", actual);"},{"sha":"a74e3a1b8fb33568b6d675f388c9945fd0c925e2","filename":"syncope620/server/persistence-jpa/src/test/java/org/apache/syncope/persistence/jpa/relationship/AttrTest.java","status":"modified","additions":1,"deletions":2,"changes":3,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Frelationship%2FAttrTest.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Frelationship%2FAttrTest.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Frelationship%2FAttrTest.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -47,7 +47,6 @@\n import org.apache.syncope.persistence.api.entity.user.UPlainAttrValue;\n import org.apache.syncope.persistence.api.entity.user.User;\n import org.apache.syncope.persistence.jpa.AbstractTest;\n-import org.apache.syncope.persistence.jpa.entity.JPAAttributableUtil;\n import org.junit.Test;\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.transaction.annotation.Transactional;\n@@ -125,7 +124,7 @@ public void checkForEnumType() {\n         MPlainAttr attr = entityFactory.newEntity(MPlainAttr.class);\n         attr.setTemplate(template);\n         attr.setOwner(membership);\n-        attr.addValue(\"yellow\", JPAAttributableUtil.getInstance(AttributableType.MEMBERSHIP));\n+        attr.addValue(\"yellow\", attrUtilFactory.getInstance(AttributableType.MEMBERSHIP));\n         membership.addPlainAttr(attr);\n \n         MPlainAttr actualAttribute = userDAO.save(user).getMembership(1L).getPlainAttr(\"color\");"},{"sha":"2982423859df33af05acab677ef74b9d33de7e56","filename":"syncope620/server/persistence-jpa/src/test/java/org/apache/syncope/persistence/jpa/relationship/DerSchemaTest.java","status":"modified","additions":1,"deletions":2,"changes":3,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Frelationship%2FDerSchemaTest.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Frelationship%2FDerSchemaTest.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Frelationship%2FDerSchemaTest.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -27,7 +27,6 @@\n import org.apache.syncope.persistence.api.entity.user.UDerAttr;\n import org.apache.syncope.persistence.api.entity.user.UDerSchema;\n import org.apache.syncope.persistence.jpa.AbstractTest;\n-import org.apache.syncope.persistence.jpa.entity.JPAAttributableUtil;\n import org.junit.Test;\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.transaction.annotation.Transactional;\n@@ -48,7 +47,7 @@ public class DerSchemaTest extends AbstractTest {\n     public void test() {\n         UDerSchema schema = derSchemaDAO.find(\"cn\", UDerSchema.class);\n \n-        derSchemaDAO.delete(schema.getKey(), JPAAttributableUtil.getInstance(AttributableType.USER));\n+        derSchemaDAO.delete(schema.getKey(), attrUtilFactory.getInstance(AttributableType.USER));\n \n         derSchemaDAO.flush();\n "},{"sha":"710444c03388d56e68e683bb5b2fd2af5d96da32","filename":"syncope620/server/persistence-jpa/src/test/java/org/apache/syncope/persistence/jpa/relationship/PlainSchemaTest.java","status":"modified","additions":3,"deletions":4,"changes":7,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Frelationship%2FPlainSchemaTest.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Frelationship%2FPlainSchemaTest.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Frelationship%2FPlainSchemaTest.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -36,7 +36,6 @@\n import org.apache.syncope.persistence.api.entity.user.UPlainAttr;\n import org.apache.syncope.persistence.api.entity.user.UPlainSchema;\n import org.apache.syncope.persistence.jpa.AbstractTest;\n-import org.apache.syncope.persistence.jpa.entity.JPAAttributableUtil;\n import org.junit.Test;\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.transaction.annotation.Transactional;\n@@ -86,7 +85,7 @@ public void deleteFullname() {\n         assertFalse(mapItems.isEmpty());\n \n         // delete user schema fullname\n-        plainSchemaDAO.delete(\"fullname\", JPAAttributableUtil.getInstance(AttributableType.USER));\n+        plainSchemaDAO.delete(\"fullname\", attrUtilFactory.getInstance(AttributableType.USER));\n \n         plainSchemaDAO.flush();\n \n@@ -135,7 +134,7 @@ public void deleteSurname() {\n         assertFalse(mappings.isEmpty());\n \n         // delete user schema fullname\n-        plainSchemaDAO.delete(\"surname\", JPAAttributableUtil.getInstance(AttributableType.USER));\n+        plainSchemaDAO.delete(\"surname\", attrUtilFactory.getInstance(AttributableType.USER));\n \n         plainSchemaDAO.flush();\n \n@@ -148,7 +147,7 @@ public void deleteSurname() {\n     public void deleteALong() {\n         assertEquals(6, resourceDAO.find(\"resource-db-sync\").getUmapping().getItems().size());\n \n-        plainSchemaDAO.delete(\"aLong\", JPAAttributableUtil.getInstance(AttributableType.USER));\n+        plainSchemaDAO.delete(\"aLong\", attrUtilFactory.getInstance(AttributableType.USER));\n         assertNull(plainSchemaDAO.find(\"aLong\", UPlainSchema.class));\n \n         plainSchemaDAO.flush();"},{"sha":"e4231b78f808ea250f527036cc5a80c1b76b6214","filename":"syncope620/server/persistence-jpa/src/test/java/org/apache/syncope/persistence/jpa/relationship/SecurityQuestionTest.java","status":"modified","additions":3,"deletions":0,"changes":3,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Frelationship%2FSecurityQuestionTest.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Frelationship%2FSecurityQuestionTest.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fpersistence%2Fjpa%2Frelationship%2FSecurityQuestionTest.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -40,6 +40,8 @@ public class SecurityQuestionTest extends AbstractTest {\n     @Test\n     public void test() {\n         User user = userDAO.find(4L);\n+        assertNull(user.getSecurityQuestion());\n+        assertNull(user.getSecurityAnswer());\n \n         user.setSecurityQuestion(securityQuestionDAO.find(1L));\n         user.setSecurityAnswer(\"Rossi\");\n@@ -54,5 +56,6 @@ public void test() {\n         user = userDAO.find(4L);\n \n         assertNull(user.getSecurityQuestion());\n+        assertNull(user.getSecurityAnswer());\n     }\n }"},{"sha":"04ee4625c4628bdc0498c16e9477ebdfe3b323c3","filename":"syncope620/server/persistence-jpa/src/test/resources/content.xml","status":"modified","additions":13,"deletions":13,"changes":26,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Ftest%2Fresources%2Fcontent.xml","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Ftest%2Fresources%2Fcontent.xml","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Ftest%2Fresources%2Fcontent.xml?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -143,15 +143,15 @@ under the License.\n                creationDate=\"2010-10-20 11:00:00\" lastChangeDate=\"2010-10-20 11:00:00\"/>\n   <SyncopeRole id=\"6\"\n                name=\"director\" parent_id=\"4\" userOwner_id=\"5\"\n-               inheritAttrs=\"1\" inheritDerAttrs=\"1\" inheritVirAttrs=\"1\"\n+               inheritPlainAttrs=\"1\" inheritDerAttrs=\"1\" inheritVirAttrs=\"1\"\n                inheritPasswordPolicy=\"0\" inheritAccountPolicy=\"0\"\n                passwordPolicy_id=\"4\"\n                accountPolicy_id=\"6\"\n                creator=\"admin\" lastModifier=\"admin\" \n                creationDate=\"2010-10-20 11:00:00\" lastChangeDate=\"2010-10-20 11:00:00\"/>\n   <SyncopeRole id=\"7\"\n                name=\"managingDirector\" parent_id=\"6\"\n-               inheritAttrs=\"1\" inheritDerAttrs=\"1\" inheritVirAttrs=\"1\"\n+               inheritPlainAttrs=\"1\" inheritDerAttrs=\"1\" inheritVirAttrs=\"1\"\n                inheritPasswordPolicy=\"1\" inheritAccountPolicy=\"1\" inheritOwner=\"1\"\n                creator=\"admin\" lastModifier=\"admin\" \n                creationDate=\"2010-10-20 11:00:00\" lastChangeDate=\"2010-10-20 11:00:00\"/>\n@@ -166,7 +166,7 @@ under the License.\n                creationDate=\"2010-10-20 11:00:00\" lastChangeDate=\"2010-10-20 11:00:00\"/>\n   <SyncopeRole id=\"10\"\n                name=\"managingConsultant\" parent_id=\"6\"\n-               inheritAttrs=\"1\" inheritDerAttrs=\"1\" inheritVirAttrs=\"1\"\n+               inheritPlainAttrs=\"1\" inheritDerAttrs=\"1\" inheritVirAttrs=\"1\"\n                inheritPasswordPolicy=\"1\" inheritAccountPolicy=\"1\" inheritOwner=\"0\"\n                creator=\"admin\" lastModifier=\"admin\" \n                creationDate=\"2010-10-20 11:00:00\" lastChangeDate=\"2010-10-20 11:00:00\"/>\n@@ -181,7 +181,7 @@ under the License.\n                creationDate=\"2010-10-20 11:00:00\" lastChangeDate=\"2010-10-20 11:00:00\"/>\n   <SyncopeRole id=\"14\"\n                name=\"artDirector\" parent_id=\"4\"\n-               inheritAttrs=\"1\" inheritDerAttrs=\"1\" inheritVirAttrs=\"1\"\n+               inheritPlainAttrs=\"1\" inheritDerAttrs=\"1\" inheritVirAttrs=\"1\"\n                inheritPasswordPolicy=\"0\" inheritAccountPolicy=\"0\"\n                passwordPolicy_id=\"8\"\n                accountPolicy_id=\"6\"\n@@ -904,8 +904,8 @@ under the License.\n   <Task DTYPE=\"SyncTask\" type=\"SYNCHRONIZATION\" id=\"4\" name=\"CSV (update matching; assign unmatching)\" resource_name=\"resource-csv\"\n         performCreate=\"1\" performUpdate=\"1\" performDelete=\"1\" syncStatus=\"1\" fullReconciliation=\"0\"\n         jobClassName=\"org.apache.syncope.provisioning.api.job.SyncJob\" unmatchingRule=\"ASSIGN\" matchingRule=\"UPDATE\"\n-        userTemplate='{\"creator\":null,\"creationDate\":null,\"lastModifier\":null,\"lastChangeDate\":null,\"id\":0,\"password\":null,\"status\":null,\"token\":null,\"tokenExpireTime\":null,\"username\":null,\"lastLoginDate\":null,\"changePwdDate\":null,\"failedLogins\":null,\"attributes\":[{\"schema\":\"type\",\"readonly\":false,\"values\":[\"email == &apos;test8@syncope.apache.org&apos;? &apos;TYPE_8&apos;: &apos;TYPE_OTHER&apos;\"]}],\"derivedAttributes\":[{\"schema\":\"cn\",\"readonly\":false,\"values\":[null]}],\"virtualAttributes\":[],\"resources\":[\"resource-testdb\"],\"propagationStatuses\":[],\"memberships\":[{\"creator\":null,\"creationDate\":null,\"lastModifier\":null,\"lastChangeDate\":null,\"id\":0,\"roleId\":8,\"roleName\":null,\"attributes\":[{\"schema\":\"subscriptionDate\",\"readonly\":false,\"values\":[\"&apos;2009-08-18T16:33:12.203+0200&apos;\"]}],\"derivedAttributes\":[],\"virtualAttributes\":[]}]}'\n-        roleTemplate='{\"creator\":null,\"creationDate\":null,\"lastModifier\":null,\"lastChangeDate\":null,\"id\":0,\"name\":null,\"parent\":0,\"userOwner\":null,\"roleOwner\":null,\"inheritOwner\":false,\"inheritTemplates\":false,\"inheritAttrs\":false,\"inheritDerAttrs\":false,\"inheritVirAttrs\":false,\"inheritPasswordPolicy\":false,\"inheritAccountPolicy\":false,\"passwordPolicy\":null,\"accountPolicy\":null,\"attributes\":[],\"derivedAttributes\":[],\"virtualAttributes\":[],\"resources\":[],\"propagationStatuses\":[],\"entitlements\":[],\"rAttrTemplates\":[],\"rDerAttrTemplates\":[],\"rVirAttrTemplates\":[],\"mAttrTemplates\":[],\"mDerAttrTemplates\":[],\"mVirAttrTemplates\":[]}'/>\n+        userTemplate='{\"creator\":null,\"creationDate\":null,\"lastModifier\":null,\"lastChangeDate\":null,\"key\":0,\"password\":null,\"status\":null,\"token\":null,\"tokenExpireTime\":null,\"username\":null,\"lastLoginDate\":null,\"changePwdDate\":null,\"failedLogins\":null,\"attributes\":[{\"schema\":\"type\",\"readonly\":false,\"values\":[\"email == &apos;test8@syncope.apache.org&apos;? &apos;TYPE_8&apos;: &apos;TYPE_OTHER&apos;\"]}],\"derivedAttributes\":[{\"schema\":\"cn\",\"readonly\":false,\"values\":[null]}],\"virtualAttributes\":[],\"resources\":[\"resource-testdb\"],\"propagationStatuses\":[],\"memberships\":[{\"creator\":null,\"creationDate\":null,\"lastModifier\":null,\"lastChangeDate\":null,\"id\":0,\"roleId\":8,\"roleName\":null,\"attributes\":[{\"schema\":\"subscriptionDate\",\"readonly\":false,\"values\":[\"&apos;2009-08-18T16:33:12.203+0200&apos;\"]}],\"derivedAttributes\":[],\"virtualAttributes\":[]}]}'\n+        roleTemplate='{\"creator\":null,\"creationDate\":null,\"lastModifier\":null,\"lastChangeDate\":null,\"key\":0,\"name\":null,\"parent\":0,\"userOwner\":null,\"roleOwner\":null,\"inheritOwner\":false,\"inheritTemplates\":false,\"inheritPlainAttrs\":false,\"inheritDerAttrs\":false,\"inheritVirAttrs\":false,\"inheritPasswordPolicy\":false,\"inheritAccountPolicy\":false,\"passwordPolicy\":null,\"accountPolicy\":null,\"attributes\":[],\"derivedAttributes\":[],\"virtualAttributes\":[],\"resources\":[],\"propagationStatuses\":[],\"entitlements\":[],\"rAttrTemplates\":[],\"rDerAttrTemplates\":[],\"rVirAttrTemplates\":[],\"mAttrTemplates\":[],\"mDerAttrTemplates\":[],\"mVirAttrTemplates\":[]}'/>\n   <Task DTYPE=\"SchedTask\" type=\"SCHEDULED\" id=\"5\" name=\"SampleJob Task\" jobClassName=\"org.apache.syncope.core.quartz.SampleJob\" cronExpression=\"0 0 0 1 * ?\"/>\n   <Task DTYPE=\"PropagationTask\" type=\"PROPAGATION\" id=\"6\" propagationMode=\"TWO_PHASES\" propagationOperation=\"UPDATE\"\n         objectClassName=\"__ACCOUNT__\" resource_name=\"ws-target-resource-nopropagation\" subjectType=\"USER\" subjectId=\"1\"\n@@ -914,8 +914,8 @@ under the License.\n   <Task DTYPE=\"SyncTask\" type=\"SYNCHRONIZATION\" id=\"7\" name=\"TestDB Task\" resource_name=\"resource-testdb\"\n         performCreate=\"1\" performUpdate=\"1\" performDelete=\"0\" syncStatus=\"1\" fullReconciliation=\"1\"\n         jobClassName=\"org.apache.syncope.provisioning.api.job.SyncJob\" unmatchingRule=\"PROVISION\" matchingRule=\"UPDATE\"\n-        userTemplate='{\"creator\":null,\"creationDate\":null,\"lastModifier\":null,\"lastChangeDate\":null,\"id\":0,\"password\":null,\"status\":null,\"token\":null,\"tokenExpireTime\":null,\"username\":null,\"lastLoginDate\":null,\"changePwdDate\":null,\"failedLogins\":null,\"attributes\":[{\"schema\":\"type\",\"readonly\":false,\"values\":[\"&apos;type a&apos;\"]},{\"schema\":\"userId\",\"readonly\":false,\"values\":[\"&apos;reconciled@syncope.apache.org&apos;\"]},{\"schema\":\"fullname\",\"readonly\":false,\"values\":[\"&apos;reconciled fullname&apos;\"]},{\"schema\":\"surname\",\"readonly\":false,\"values\":[\"&apos;surname&apos;\"]}],\"derivedAttributes\":[],\"virtualAttributes\":[],\"resources\":[],\"propagationStatuses\":[],\"memberships\":[]}'\n-        roleTemplate='{\"creator\":null,\"creationDate\":null,\"lastModifier\":null,\"lastChangeDate\":null,\"id\":0,\"name\":null,\"parent\":0,\"userOwner\":null,\"roleOwner\":null,\"inheritOwner\":false,\"inheritTemplates\":false,\"inheritAttrs\":false,\"inheritDerAttrs\":false,\"inheritVirAttrs\":false,\"inheritPasswordPolicy\":false,\"inheritAccountPolicy\":false,\"passwordPolicy\":null,\"accountPolicy\":null,\"attributes\":[],\"derivedAttributes\":[],\"virtualAttributes\":[],\"resources\":[],\"propagationStatuses\":[],\"entitlements\":[],\"rAttrTemplates\":[],\"rDerAttrTemplates\":[],\"rVirAttrTemplates\":[],\"mAttrTemplates\":[],\"mDerAttrTemplates\":[],\"mVirAttrTemplates\":[]}'/>\n+        userTemplate='{\"creator\":null,\"creationDate\":null,\"lastModifier\":null,\"lastChangeDate\":null,\"key\":0,\"password\":null,\"status\":null,\"token\":null,\"tokenExpireTime\":null,\"username\":null,\"lastLoginDate\":null,\"changePwdDate\":null,\"failedLogins\":null,\"attributes\":[{\"schema\":\"type\",\"readonly\":false,\"values\":[\"&apos;type a&apos;\"]},{\"schema\":\"userId\",\"readonly\":false,\"values\":[\"&apos;reconciled@syncope.apache.org&apos;\"]},{\"schema\":\"fullname\",\"readonly\":false,\"values\":[\"&apos;reconciled fullname&apos;\"]},{\"schema\":\"surname\",\"readonly\":false,\"values\":[\"&apos;surname&apos;\"]}],\"derivedAttributes\":[],\"virtualAttributes\":[],\"resources\":[],\"propagationStatuses\":[],\"memberships\":[]}'\n+        roleTemplate='{\"creator\":null,\"creationDate\":null,\"lastModifier\":null,\"lastChangeDate\":null,\"key\":0,\"name\":null,\"parent\":0,\"userOwner\":null,\"roleOwner\":null,\"inheritOwner\":false,\"inheritTemplates\":false,\"inheritPlainAttrs\":false,\"inheritDerAttrs\":false,\"inheritVirAttrs\":false,\"inheritPasswordPolicy\":false,\"inheritAccountPolicy\":false,\"passwordPolicy\":null,\"accountPolicy\":null,\"attributes\":[],\"derivedAttributes\":[],\"virtualAttributes\":[],\"resources\":[],\"propagationStatuses\":[],\"entitlements\":[],\"rAttrTemplates\":[],\"rDerAttrTemplates\":[],\"rVirAttrTemplates\":[],\"mAttrTemplates\":[],\"mDerAttrTemplates\":[],\"mVirAttrTemplates\":[]}'/>\n   <Task DTYPE=\"NotificationTask\" type=\"NOTIFICATION\" id=\"8\" sender=\"admin@prova.org\" subject=\"Notification for SYNCOPE-81\" \n         textBody=\"NOTIFICATION-81\" htmlBody=\"NOTIFICATION-81\" traceLevel=\"ALL\"/>\n   <Task DTYPE=\"SyncTask\" type=\"SYNCHRONIZATION\" id=\"9\" name=\"TestDB2 Task\" resource_name=\"resource-testdb2\"\n@@ -927,8 +927,8 @@ under the License.\n   <Task DTYPE=\"SyncTask\" type=\"SYNCHRONIZATION\" id=\"11\" name=\"LDAP Sync Task\" resource_name=\"resource-ldap\"\n         fullReconciliation=\"1\" performCreate=\"1\" performDelete=\"1\" performUpdate=\"1\" syncStatus=\"0\"\n         jobClassName=\"org.apache.syncope.provisioning.api.job.SyncJob\" unmatchingRule=\"PROVISION\" matchingRule=\"UPDATE\"\n-        userTemplate='{\"creator\":null,\"creationDate\":null,\"lastModifier\":null,\"lastChangeDate\":null,\"id\":0,\"password\":null,\"status\":null,\"token\":null,\"tokenExpireTime\":null,\"username\":null,\"lastLoginDate\":null,\"changePwdDate\":null,\"failedLogins\":null,\"attributes\":[],\"derivedAttributes\":[],\"virtualAttributes\":[{\"schema\":\"virtualReadOnly\",\"readonly\":false,\"values\":[\"\"]}],\"resources\":[\"resource-ldap\"],\"propagationStatuses\":[],\"memberships\":[]}'\n-        roleTemplate='{\"creator\":null,\"creationDate\":null,\"lastModifier\":null,\"lastChangeDate\":null,\"id\":0,\"name\":null,\"parent\":8,\"userOwner\":null,\"roleOwner\":null,\"inheritOwner\":false,\"inheritTemplates\":false,\"inheritAttrs\":false,\"inheritDerAttrs\":false,\"inheritVirAttrs\":false,\"inheritPasswordPolicy\":false,\"inheritAccountPolicy\":false,\"passwordPolicy\":null,\"accountPolicy\":null,\"attributes\":[{\"schema\":\"show\",\"readonly\":false,\"values\":[\"&apos;true&apos;\"]}],\"derivedAttributes\":[],\"virtualAttributes\":[],\"resources\":[],\"propagationStatuses\":[],\"entitlements\":[],\"rAttrTemplates\":[\"show\"],\"rDerAttrTemplates\":[],\"rVirAttrTemplates\":[],\"mAttrTemplates\":[],\"mDerAttrTemplates\":[],\"mVirAttrTemplates\":[]}'/>\n+        userTemplate='{\"creator\":null,\"creationDate\":null,\"lastModifier\":null,\"lastChangeDate\":null,\"key\":0,\"password\":null,\"status\":null,\"token\":null,\"tokenExpireTime\":null,\"username\":null,\"lastLoginDate\":null,\"changePwdDate\":null,\"failedLogins\":null,\"attributes\":[],\"derivedAttributes\":[],\"virtualAttributes\":[{\"schema\":\"virtualReadOnly\",\"readonly\":false,\"values\":[\"\"]}],\"resources\":[\"resource-ldap\"],\"propagationStatuses\":[],\"memberships\":[]}'\n+        roleTemplate='{\"creator\":null,\"creationDate\":null,\"lastModifier\":null,\"lastChangeDate\":null,\"key\":0,\"name\":null,\"parent\":8,\"userOwner\":null,\"roleOwner\":null,\"inheritOwner\":false,\"inheritTemplates\":false,\"inheritPlainAttrs\":false,\"inheritDerAttrs\":false,\"inheritVirAttrs\":false,\"inheritPasswordPolicy\":false,\"inheritAccountPolicy\":false,\"passwordPolicy\":null,\"accountPolicy\":null,\"attributes\":[{\"schema\":\"show\",\"readonly\":false,\"values\":[\"&apos;true&apos;\"]}],\"derivedAttributes\":[],\"virtualAttributes\":[],\"resources\":[],\"propagationStatuses\":[],\"entitlements\":[],\"rAttrTemplates\":[\"show\"],\"rDerAttrTemplates\":[],\"rVirAttrTemplates\":[],\"mAttrTemplates\":[],\"mDerAttrTemplates\":[],\"mVirAttrTemplates\":[]}'/>\n   <SyncTask_actionsClassNames SyncTask_id=\"11\" actionClassName=\"org.apache.syncope.core.sync.impl.LDAPMembershipSyncActions\"/>\n   <Task DTYPE=\"SyncTask\" type=\"SYNCHRONIZATION\" id=\"12\" name=\"VirAttrCache test\" resource_name=\"resource-csv\"\n         performCreate=\"0\" performUpdate=\"1\" performDelete=\"0\" syncStatus=\"0\" fullReconciliation=\"1\"\n@@ -980,8 +980,8 @@ under the License.\n   <Task DTYPE=\"SyncTask\" type=\"SYNCHRONIZATION\" id=\"24\" name=\"CSV Task (update matching; provision unmatching)\" resource_name=\"resource-csv\"\n         performCreate=\"1\" performUpdate=\"1\" performDelete=\"1\" syncStatus=\"1\" fullReconciliation=\"0\"\n         jobClassName=\"org.apache.syncope.provisioning.api.job.SyncJob\" unmatchingRule=\"PROVISION\" matchingRule=\"UPDATE\"\n-        userTemplate='{\"creator\":null,\"creationDate\":null,\"lastModifier\":null,\"lastChangeDate\":null,\"id\":0,\"password\":null,\"status\":null,\"token\":null,\"tokenExpireTime\":null,\"username\":null,\"lastLoginDate\":null,\"changePwdDate\":null,\"failedLogins\":null,\"attributes\":[{\"schema\":\"firstname\",\"readonly\":false,\"values\":[\"\"]},{\"schema\":\"userId\",\"readonly\":false,\"values\":[\"&apos;test&apos;\"]},{\"schema\":\"fullname\",\"readonly\":false,\"values\":[\"&apos;test&apos;\"]},{\"schema\":\"surname\",\"readonly\":false,\"values\":[\"&apos;test&apos;\"]}],\"derivedAttributes\":[],\"virtualAttributes\":[],\"resources\":[\"resource-testdb\"],\"propagationStatuses\":[],\"memberships\":[]}'\n-        roleTemplate='{\"creator\":null,\"creationDate\":null,\"lastModifier\":null,\"lastChangeDate\":null,\"id\":0,\"name\":null,\"parent\":0,\"userOwner\":null,\"roleOwner\":null,\"inheritOwner\":false,\"inheritTemplates\":false,\"inheritAttrs\":false,\"inheritDerAttrs\":false,\"inheritVirAttrs\":false,\"inheritPasswordPolicy\":false,\"inheritAccountPolicy\":false,\"passwordPolicy\":null,\"accountPolicy\":null,\"attributes\":[],\"derivedAttributes\":[],\"virtualAttributes\":[],\"resources\":[],\"propagationStatuses\":[],\"entitlements\":[],\"rAttrTemplates\":[],\"rDerAttrTemplates\":[],\"rVirAttrTemplates\":[],\"mAttrTemplates\":[],\"mDerAttrTemplates\":[],\"mVirAttrTemplates\":[]}'/>\n+        userTemplate='{\"creator\":null,\"creationDate\":null,\"lastModifier\":null,\"lastChangeDate\":null,\"key\":0,\"password\":null,\"status\":null,\"token\":null,\"tokenExpireTime\":null,\"username\":null,\"lastLoginDate\":null,\"changePwdDate\":null,\"failedLogins\":null,\"attributes\":[{\"schema\":\"firstname\",\"readonly\":false,\"values\":[\"\"]},{\"schema\":\"userId\",\"readonly\":false,\"values\":[\"&apos;test&apos;\"]},{\"schema\":\"fullname\",\"readonly\":false,\"values\":[\"&apos;test&apos;\"]},{\"schema\":\"surname\",\"readonly\":false,\"values\":[\"&apos;test&apos;\"]}],\"derivedAttributes\":[],\"virtualAttributes\":[],\"resources\":[\"resource-testdb\"],\"propagationStatuses\":[],\"memberships\":[]}'\n+        roleTemplate='{\"creator\":null,\"creationDate\":null,\"lastModifier\":null,\"lastChangeDate\":null,\"key\":0,\"name\":null,\"parent\":0,\"userOwner\":null,\"roleOwner\":null,\"inheritOwner\":false,\"inheritTemplates\":false,\"inheritPlainAttrs\":false,\"inheritDerAttrs\":false,\"inheritVirAttrs\":false,\"inheritPasswordPolicy\":false,\"inheritAccountPolicy\":false,\"passwordPolicy\":null,\"accountPolicy\":null,\"attributes\":[],\"derivedAttributes\":[],\"virtualAttributes\":[],\"resources\":[],\"propagationStatuses\":[],\"entitlements\":[],\"rAttrTemplates\":[],\"rDerAttrTemplates\":[],\"rVirAttrTemplates\":[],\"mAttrTemplates\":[],\"mDerAttrTemplates\":[],\"mVirAttrTemplates\":[]}'/>\n   <Task DTYPE=\"SyncTask\" type=\"SYNCHRONIZATION\" id=\"25\" name=\"CSV (unlink matching; ignore unmatching)\" resource_name=\"resource-csv\"\n         performCreate=\"1\" performUpdate=\"1\" performDelete=\"1\" syncStatus=\"1\" fullReconciliation=\"0\"\n         jobClassName=\"org.apache.syncope.provisioning.api.job.SyncJob\" unmatchingRule=\"IGNORE\" matchingRule=\"UNLINK\"/>\n@@ -1011,7 +1011,7 @@ under the License.\n   \n   <Report id=\"1\" name=\"test\"/>\n   <ReportletConfInstance id=\"1\" Report_id=\"1\" \n-                         serializedInstance='{\"@class\":\"org.apache.syncope.common.lib.report.UserReportletConf\",\"name\":\"testUserReportlet\",\"matchingCond\":null,\"attributes\":[\"fullname\",\"gender\"],\"derivedAttributes\":[\"cn\"],\"virtualAttributes\":[\"virtualdata\"],\"features\":[\"id\",\"username\",\"workflowId\",\"status\",\"creationDate\",\"lastLoginDate\",\"changePwdDate\",\"passwordHistorySize\",\"failedLoginCount\",\"memberships\",\"resources\"]}'/>\n+                         serializedInstance='{\"@class\":\"org.apache.syncope.common.lib.report.UserReportletConf\",\"name\":\"testUserReportlet\",\"matchingCond\":null,\"attributes\":[\"fullname\",\"gender\"],\"derivedAttributes\":[\"cn\"],\"virtualAttributes\":[\"virtualdata\"],\"features\":[\"key\",\"username\",\"workflowId\",\"status\",\"creationDate\",\"lastLoginDate\",\"changePwdDate\",\"passwordHistorySize\",\"failedLoginCount\",\"memberships\",\"resources\"]}'/>\n   <ReportExec Report_id=\"1\" id=\"1\" status=\"SUCCESS\" startDate=\"2012-02-26 15:40:04\" endDate=\"2012-02-26 15:41:04\"/>\n   \n   <SyncopeLogger logName=\"syncope.audit.[REST]:[EntitlementController]:[]:[getOwn]:[SUCCESS]\" logLevel=\"DEBUG\" logType=\"AUDIT\"/>"},{"sha":"01705697324fa31277f2826dfdaa00c336dffcc8","filename":"syncope620/server/persistence-jpa/src/test/resources/persistenceTestEnv.xml","status":"modified","additions":5,"deletions":0,"changes":5,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Ftest%2Fresources%2FpersistenceTestEnv.xml","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Ftest%2Fresources%2FpersistenceTestEnv.xml","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Fpersistence-jpa%2Fsrc%2Ftest%2Fresources%2FpersistenceTestEnv.xml?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -45,5 +45,10 @@ under the License.\n   \n   <context:component-scan base-package=\"org.apache.syncope.server.utils\"/>\n \n+  <bean id=\"virAttrCache\" class=\"org.apache.syncope.provisioning.common.cache.MemoryVirAttrCache\" scope=\"singleton\">\n+    <constructor-arg value=\"60\"/>\n+    <constructor-arg value=\"5000\"/>\n+  </bean>\n+\n   <import resource=\"persistenceContext.xml\"/>\n </beans>"},{"sha":"19a959bd0a3b5f5b910b290ff0d93c5d598c63bd","filename":"syncope620/server/pom.xml","status":"modified","additions":4,"deletions":1,"changes":5,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpom.xml","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fpom.xml","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Fpom.xml?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -34,12 +34,15 @@ under the License.\n   <packaging>pom</packaging>\n \n   <modules>\n-    <module>provisioning-api</module>\n     <module>persistence-api</module>\n     <module>persistence-jpa</module>\n     <module>spring</module>\n     <module>security</module>\n     <module>utils</module>\n+    <module>provisioning-api</module>\n+    <module>provisioning-common</module>\n+    <module>workflow-api</module>\n+    <module>logic</module>\n   </modules>\n \n </project>"},{"sha":"b1f39f905dd8f2c87e605e0469acf5d10ab80e14","filename":"syncope620/server/provisioning-api/src/main/java/org/apache/syncope/provisioning/api/AttributableTransformer.java","status":"added","additions":33,"deletions":0,"changes":33,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fprovisioning-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fprovisioning%2Fapi%2FAttributableTransformer.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fprovisioning-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fprovisioning%2Fapi%2FAttributableTransformer.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Fprovisioning-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fprovisioning%2Fapi%2FAttributableTransformer.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,33 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.provisioning.api;\n+\n+import org.apache.syncope.common.lib.mod.AbstractAttributableMod;\n+import org.apache.syncope.common.lib.to.AbstractAttributableTO;\n+\n+/**\n+ * Provides logic for transforming user or role, received as input by RESTful methods, before any internal\n+ * processing logic takes place.\n+ */\n+public interface AttributableTransformer {\n+\n+    <T extends AbstractAttributableTO> T transform(T input);\n+\n+    <T extends AbstractAttributableMod> T transform(T input);\n+}"},{"sha":"bf07215796952b8f08e201db501f4e41ab9fca1e","filename":"syncope620/server/provisioning-api/src/main/java/org/apache/syncope/provisioning/api/ConnIdBundleManager.java","status":"added","additions":284,"deletions":0,"changes":284,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fprovisioning-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fprovisioning%2Fapi%2FConnIdBundleManager.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fprovisioning-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fprovisioning%2Fapi%2FConnIdBundleManager.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Fprovisioning-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fprovisioning%2Fapi%2FConnIdBundleManager.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,284 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.provisioning.api;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URL;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import javax.net.ssl.TrustManager;\n+import javax.net.ssl.X509TrustManager;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.syncope.persistence.api.dao.NotFoundException;\n+import org.identityconnectors.common.IOUtil;\n+import org.identityconnectors.common.security.GuardedString;\n+import org.identityconnectors.framework.api.APIConfiguration;\n+import org.identityconnectors.framework.api.ConfigurationProperties;\n+import org.identityconnectors.framework.api.ConnectorInfo;\n+import org.identityconnectors.framework.api.ConnectorInfoManager;\n+import org.identityconnectors.framework.api.ConnectorInfoManagerFactory;\n+import org.identityconnectors.framework.api.ConnectorKey;\n+import org.identityconnectors.framework.api.RemoteFrameworkConnectionInfo;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Manage information about ConnId connector bundles.\n+ */\n+public class ConnIdBundleManager {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(ConnIdBundleManager.class);\n+\n+    private String stringLocations;\n+\n+    /**\n+     * ConnId Locations.\n+     */\n+    private List<URI> locations;\n+\n+    /**\n+     * ConnectorInfoManager instances.\n+     */\n+    private final Map<URI, ConnectorInfoManager> connInfoManagers =\n+            Collections.synchronizedMap(new LinkedHashMap<URI, ConnectorInfoManager>());\n+\n+    public void setStringLocations(final String stringLocations) {\n+        this.stringLocations = stringLocations;\n+    }\n+\n+    private void init() {\n+        if (locations == null) {\n+            locations = new ArrayList<>();\n+            for (String location : StringUtils.isBlank(stringLocations) ? new String[0] : stringLocations.split(\",\")) {\n+                try {\n+                    locations.add(URIUtil.buildForConnId(location));\n+                    LOG.info(\"Valid ConnId location: {}\", location.trim());\n+                } catch (Exception e) {\n+                    LOG.error(\"Invalid ConnId location: {}\", location.trim(), e);\n+                }\n+            }\n+            locations = Collections.unmodifiableList(locations);\n+        }\n+    }\n+\n+    private void initLocal(final URI location) {\n+        // 1. Find bundles inside local directory\n+        File bundleDirectory = new File(location);\n+        String[] bundleFiles = bundleDirectory.list();\n+        if (bundleFiles == null) {\n+            throw new NotFoundException(\"Local bundles directory \" + location);\n+        }\n+\n+        List<URL> bundleFileURLs = new ArrayList<>();\n+        for (String file : bundleFiles) {\n+            try {\n+                bundleFileURLs.add(IOUtil.makeURL(bundleDirectory, file));\n+            } catch (IOException ignore) {\n+                // ignore exception and don't add bundle\n+                LOG.debug(\"{}/{} is not a valid connector bundle\", bundleDirectory.toString(), file, ignore);\n+            }\n+        }\n+\n+        if (bundleFileURLs.isEmpty()) {\n+            LOG.warn(\"No connector bundles found in {}\", location);\n+        }\n+        LOG.debug(\"Configuring local connector server:\"\n+                + \"\\n\\tFiles: {}\", bundleFileURLs);\n+\n+        // 2. Get connector info manager\n+        ConnectorInfoManager manager = ConnectorInfoManagerFactory.getInstance().getLocalManager(\n+                bundleFileURLs.toArray(new URL[bundleFileURLs.size()]));\n+        if (manager == null) {\n+            throw new NotFoundException(\"Local ConnectorInfoManager\");\n+        }\n+\n+        connInfoManagers.put(location, manager);\n+    }\n+\n+    private void initRemote(final URI location) {\n+        // 1. Extract conf params for remote connection from given URI\n+        final String host = location.getHost();\n+        final int port = location.getPort();\n+        final GuardedString key = new GuardedString(location.getUserInfo().toCharArray());\n+        final boolean useSSL = location.getScheme().equals(\"connids\");\n+\n+        final List<TrustManager> trustManagers = new ArrayList<>();\n+        final String[] params = StringUtils.isBlank(location.getQuery()) ? null : location.getQuery().split(\"&\");\n+        if (params != null && params.length > 0) {\n+            final String[] trustAllCerts = params[0].split(\"=\");\n+            if (trustAllCerts != null && trustAllCerts.length > 1\n+                    && \"trustAllCerts\".equalsIgnoreCase(trustAllCerts[0])\n+                    && \"true\".equalsIgnoreCase(trustAllCerts[1])) {\n+\n+                trustManagers.add(new X509TrustManager() {\n+\n+                    @Override\n+                    public void checkClientTrusted(final X509Certificate[] chain, final String authType)\n+                            throws CertificateException {\n+                        // no checks, trust all\n+                    }\n+\n+                    @Override\n+                    public void checkServerTrusted(final X509Certificate[] chain, final String authType)\n+                            throws CertificateException {\n+                        // no checks, trust all\n+                    }\n+\n+                    @Override\n+                    public X509Certificate[] getAcceptedIssuers() {\n+                        return null;\n+                    }\n+                });\n+            }\n+        }\n+\n+        LOG.debug(\"Configuring remote connector server:\"\n+                + \"\\n\\tHost: {}\"\n+                + \"\\n\\tPort: {}\"\n+                + \"\\n\\tKey: {}\"\n+                + \"\\n\\tUseSSL: {}\"\n+                + \"\\n\\tTrustAllCerts: {}\",\n+                host, port, key, useSSL, !trustManagers.isEmpty());\n+\n+        RemoteFrameworkConnectionInfo info =\n+                new RemoteFrameworkConnectionInfo(host, port, key, useSSL, trustManagers, 60 * 1000);\n+        LOG.debug(\"Remote connection info: {}\", info);\n+\n+        // 2. Get connector info manager\n+        ConnectorInfoManager manager = ConnectorInfoManagerFactory.getInstance().getRemoteManager(info);\n+        if (manager == null) {\n+            throw new NotFoundException(\"Remote ConnectorInfoManager\");\n+        }\n+\n+        connInfoManagers.put(location, manager);\n+    }\n+\n+    public void resetConnManagers() {\n+        connInfoManagers.clear();\n+    }\n+\n+    public Map<URI, ConnectorInfoManager> getConnManagers() {\n+        init();\n+\n+        if (connInfoManagers.isEmpty()) {\n+            for (URI location : locations) {\n+                try {\n+                    if (\"file\".equals(location.getScheme())) {\n+                        LOG.debug(\"Local initialization: {}\", location);\n+                        initLocal(location);\n+                    } else if (location.getScheme().startsWith(\"connid\")) {\n+                        LOG.debug(\"Remote initialization: {}\", location);\n+                        initRemote(location);\n+                    } else {\n+                        LOG.warn(\"Unsupported scheme: {}\", location);\n+                    }\n+                } catch (Exception e) {\n+                    LOG.error(\"Could not process {}\", location, e);\n+                }\n+            }\n+        }\n+\n+        if (LOG.isDebugEnabled()) {\n+            for (Map.Entry<URI, ConnectorInfoManager> entry : connInfoManagers.entrySet()) {\n+                LOG.debug(\"Connector bundles found at {}\", entry.getKey());\n+                for (ConnectorInfo connInfo : entry.getValue().getConnectorInfos()) {\n+                    LOG.debug(\"\\t{}\", connInfo.getConnectorDisplayName());\n+                }\n+            }\n+        }\n+\n+        return connInfoManagers;\n+    }\n+\n+    public ConnectorInfo getConnectorInfo(\n+            final String location, final String bundleName, final String bundleVersion, final String connectorName) {\n+\n+        // check ConnIdLocation\n+        URI uriLocation = null;\n+        try {\n+            uriLocation = URIUtil.buildForConnId(location);\n+        } catch (Exception e) {\n+            throw new IllegalArgumentException(\"Invalid ConnId location \" + location, e);\n+        }\n+\n+        // create key for search all properties\n+        final ConnectorKey key = new ConnectorKey(bundleName, bundleVersion, connectorName);\n+\n+        if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"\\nBundle name: \" + key.getBundleName()\n+                    + \"\\nBundle version: \" + key.getBundleVersion()\n+                    + \"\\nBundle class: \" + key.getConnectorName());\n+        }\n+\n+        // get the specified connector\n+        ConnectorInfo info = null;\n+        if (getConnManagers().containsKey(uriLocation)) {\n+            info = getConnManagers().get(uriLocation).findConnectorInfo(key);\n+        }\n+        if (info == null) {\n+            throw new NotFoundException(\"Connector Info for location \" + location + \" and key \" + key);\n+        }\n+\n+        return info;\n+    }\n+\n+    public Map<String, List<ConnectorInfo>> getConnectorInfos() {\n+        final Map<String, List<ConnectorInfo>> infos = new LinkedHashMap<>();\n+        for (Map.Entry<URI, ConnectorInfoManager> entry : connInfoManagers.entrySet()) {\n+            infos.put(entry.getKey().toString(), entry.getValue().getConnectorInfos());\n+        }\n+        return infos;\n+    }\n+\n+    public ConfigurationProperties getConfigurationProperties(final ConnectorInfo info) {\n+        if (info == null) {\n+            throw new NotFoundException(\"Invalid: connector info is null\");\n+        }\n+\n+        // create default configuration\n+        final APIConfiguration apiConfig = info.createDefaultAPIConfiguration();\n+        if (apiConfig == null) {\n+            throw new NotFoundException(\"Default API configuration\");\n+        }\n+\n+        // retrieve the ConfigurationProperties.\n+        final ConfigurationProperties properties = apiConfig.getConfigurationProperties();\n+        if (properties == null) {\n+            throw new NotFoundException(\"Configuration properties\");\n+        }\n+\n+        if (LOG.isDebugEnabled()) {\n+            for (String propName : properties.getPropertyNames()) {\n+                LOG.debug(\"Property Name: {}\"\n+                        + \"\\nProperty Type: {}\",\n+                        properties.getProperty(propName).getName(),\n+                        properties.getProperty(propName).getType());\n+            }\n+        }\n+\n+        return properties;\n+    }\n+}"},{"sha":"66f5e73371d3512254ec6cc3fd56fc0ed4ec8342","filename":"syncope620/server/provisioning-api/src/main/java/org/apache/syncope/provisioning/api/ProvisioningManager.java","status":"added","additions":42,"deletions":0,"changes":42,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fprovisioning-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fprovisioning%2Fapi%2FProvisioningManager.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fprovisioning-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fprovisioning%2Fapi%2FProvisioningManager.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Fprovisioning-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fprovisioning%2Fapi%2FProvisioningManager.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,42 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.provisioning.api;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.syncope.common.lib.mod.AbstractAttributableMod;\n+import org.apache.syncope.common.lib.to.AbstractAttributableTO;\n+import org.apache.syncope.common.lib.to.PropagationStatus;\n+\n+public interface ProvisioningManager<T extends AbstractAttributableTO, M extends AbstractAttributableMod> {\n+\n+    Map.Entry<Long, List<PropagationStatus>> create(T subject);\n+\n+    Map.Entry<Long, List<PropagationStatus>> update(M subjectMod);\n+\n+    List<PropagationStatus> delete(Long subjectId);\n+\n+    Long unlink(M subjectMod);\n+\n+    Long link(M subjectMod);\n+\n+    List<PropagationStatus> deprovision(Long user, Collection<String> resources);\n+\n+}"},{"sha":"822981b4eb2071d8b2eaafbeff3a758af840882c","filename":"syncope620/server/provisioning-api/src/main/java/org/apache/syncope/provisioning/api/RoleProvisioningManager.java","status":"added","additions":37,"deletions":0,"changes":37,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fprovisioning-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fprovisioning%2Fapi%2FRoleProvisioningManager.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fprovisioning-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fprovisioning%2Fapi%2FRoleProvisioningManager.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Fprovisioning-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fprovisioning%2Fapi%2FRoleProvisioningManager.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,37 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.provisioning.api;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.apache.syncope.common.lib.mod.RoleMod;\n+import org.apache.syncope.common.lib.to.PropagationStatus;\n+import org.apache.syncope.common.lib.to.RoleTO;\n+\n+public interface RoleProvisioningManager extends ProvisioningManager<RoleTO, RoleMod> {\n+\n+    Map.Entry<Long, List<PropagationStatus>> create(RoleTO roleTO, Set<String> excludedResources);\n+\n+    Map.Entry<Long, List<PropagationStatus>> create(\n+            RoleTO roleTO, Map<Long, String> roleOwnerMap, Set<String> excludedResources);\n+\n+    Map.Entry<Long, List<PropagationStatus>> update(RoleMod subjectMod, Set<String> excludedResources);\n+\n+}"},{"sha":"f8fd111df8efb98742e7d2da2869c48a792e08e4","filename":"syncope620/server/provisioning-api/src/main/java/org/apache/syncope/provisioning/api/URIUtil.java","status":"renamed","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fprovisioning-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fprovisioning%2Fapi%2FURIUtil.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fprovisioning-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fprovisioning%2Fapi%2FURIUtil.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Fprovisioning-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fprovisioning%2Fapi%2FURIUtil.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -16,7 +16,7 @@\n  * specific language governing permissions and limitations\n  * under the License.\n  */\n-package org.apache.syncope.server.utils;\n+package org.apache.syncope.provisioning.api;\n \n import java.io.File;\n import java.net.MalformedURLException;","previous_filename":"syncope620/server/utils/src/main/java/org/apache/syncope/server/utils/URIUtil.java"},{"sha":"b68612710299774ce84a9563ec3e05e97422a298","filename":"syncope620/server/provisioning-api/src/main/java/org/apache/syncope/provisioning/api/UserProvisioningManager.java","status":"added","additions":57,"deletions":0,"changes":57,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fprovisioning-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fprovisioning%2Fapi%2FUserProvisioningManager.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fprovisioning-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fprovisioning%2Fapi%2FUserProvisioningManager.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Fprovisioning-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fprovisioning%2Fapi%2FUserProvisioningManager.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,57 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.provisioning.api;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.apache.syncope.common.lib.mod.StatusMod;\n+import org.apache.syncope.common.lib.mod.UserMod;\n+import org.apache.syncope.common.lib.to.PropagationStatus;\n+import org.apache.syncope.common.lib.to.UserTO;\n+import org.apache.syncope.persistence.api.entity.user.User;\n+import org.apache.syncope.provisioning.api.sync.SyncResult;\n+\n+public interface UserProvisioningManager extends ProvisioningManager<UserTO, UserMod> {\n+\n+    Map.Entry<Long, List<PropagationStatus>> activate(User user, StatusMod statusMod);\n+\n+    Map.Entry<Long, List<PropagationStatus>> reactivate(User user, StatusMod statusMod);\n+\n+    Map.Entry<Long, List<PropagationStatus>> suspend(User user, StatusMod statusMod);\n+\n+    void innerSuspend(User user, boolean propagate);\n+\n+    Map.Entry<Long, List<PropagationStatus>> create(UserTO userTO, boolean storePassword);\n+\n+    Map.Entry<Long, List<PropagationStatus>> create(UserTO userTO, boolean storePassword,\n+            boolean disablePwdPolicyCheck, Boolean enabled, Set<String> excludedResources);\n+\n+    Map.Entry<Long, List<PropagationStatus>> update(UserMod userMod, boolean removeMemberships);\n+\n+    Map.Entry<Long, List<PropagationStatus>> update(UserMod userMod, Long key,\n+            SyncResult result, Boolean enabled, Set<String> excludedResources);\n+\n+    List<PropagationStatus> delete(Long subjectKey, Set<String> excludedResources);\n+\n+    void requestPasswordReset(Long key);\n+\n+    void confirmPasswordReset(User user, String token, String password);\n+\n+}"},{"sha":"bb80219fcc3f948e129d06ac0c050301f64df5d6","filename":"syncope620/server/provisioning-api/src/main/java/org/apache/syncope/provisioning/api/WorkflowResult.java","status":"added","additions":87,"deletions":0,"changes":87,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fprovisioning-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fprovisioning%2Fapi%2FWorkflowResult.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fprovisioning-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fprovisioning%2Fapi%2FWorkflowResult.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Fprovisioning-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fprovisioning%2Fapi%2FWorkflowResult.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","patch":"@@ -0,0 +1,87 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.provisioning.api;\n+\n+import java.util.Collections;\n+import java.util.Set;\n+import org.apache.commons.lang3.builder.EqualsBuilder;\n+import org.apache.commons.lang3.builder.HashCodeBuilder;\n+import org.apache.commons.lang3.builder.ReflectionToStringBuilder;\n+import org.apache.commons.lang3.builder.ToStringStyle;\n+import org.apache.syncope.provisioning.api.propagation.PropagationByResource;\n+\n+public class WorkflowResult<T> {\n+\n+    private T result;\n+\n+    private PropagationByResource propByRes;\n+\n+    private Set<String> performedTasks;\n+\n+    public WorkflowResult(final T result, final PropagationByResource propByRes, final String performedTask) {\n+        this.result = result;\n+        this.propByRes = propByRes;\n+        this.performedTasks = Collections.singleton(performedTask);\n+    }\n+\n+    public WorkflowResult(final T result, final PropagationByResource propByRes, final Set<String> performedTasks) {\n+        this.result = result;\n+        this.propByRes = propByRes;\n+        this.performedTasks = performedTasks;\n+    }\n+\n+    public T getResult() {\n+        return result;\n+    }\n+\n+    public void setResult(final T result) {\n+        this.result = result;\n+    }\n+\n+    public Set<String> getPerformedTasks() {\n+        return performedTasks;\n+    }\n+\n+    public void setPerformedTasks(final Set<String> performedTasks) {\n+        this.performedTasks = performedTasks;\n+    }\n+\n+    public PropagationByResource getPropByRes() {\n+        return propByRes;\n+    }\n+\n+    public void setPropByRes(final PropagationByResource propByRes) {\n+        this.propByRes = propByRes;\n+    }\n+\n+    @Override\n+    public boolean equals(final Object obj) {\n+        return EqualsBuilder.reflectionEquals(this, obj);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return HashCodeBuilder.reflectionHashCode(this);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return ReflectionToStringBuilder.toString(this, ToStringStyle.MULTI_LINE_STYLE);\n+    }\n+}"},{"sha":"c4936a58d528259d169b6baf4c3b4bb93ace54bf","filename":"syncope620/server/provisioning-api/src/main/java/org/apache/syncope/provisioning/api/cache/VirAttrCache.java","status":"added","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fprovisioning-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fprovisioning%2Fapi%2Fcache%2FVirAttrCache.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fprovisioning-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fprovisioning%2Fapi%2Fcache%2FVirAttrCache.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Fprovisioning-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fprovisioning%2Fapi%2Fcache%2FVirAttrCache.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5"},{"sha":"bdc60dbb53bb1b44f62b4339a461187bd12347d4","filename":"syncope620/server/provisioning-api/src/main/java/org/apache/syncope/provisioning/api/cache/VirAttrCacheKey.java","status":"added","additions":79,"deletions":0,"changes":79,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fprovisioning-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fprovisioning%2Fapi%2Fcache%2FVirAttrCacheKey.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fprovisioning-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fprovisioning%2Fapi%2Fcache%2FVirAttrCacheKey.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Fprovisioning-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fprovisioning%2Fapi%2Fcache%2FVirAttrCacheKey.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5"},{"sha":"1ca9965921a3fd7ba5c399fc2c70e57bf96e21f6","filename":"syncope620/server/provisioning-api/src/main/java/org/apache/syncope/provisioning/api/cache/VirAttrCacheValue.java","status":"added","additions":86,"deletions":0,"changes":86,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fprovisioning-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fprovisioning%2Fapi%2Fcache%2FVirAttrCacheValue.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fprovisioning-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fprovisioning%2Fapi%2Fcache%2FVirAttrCacheValue.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Fprovisioning-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fprovisioning%2Fapi%2Fcache%2FVirAttrCacheValue.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5"},{"sha":"e43443ee320d1f744ce0dea977a51dbf256ef2fa","filename":"syncope620/server/provisioning-api/src/main/java/org/apache/syncope/provisioning/api/propagation/PropagationByResource.java","status":"added","additions":365,"deletions":0,"changes":365,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fprovisioning-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fprovisioning%2Fapi%2Fpropagation%2FPropagationByResource.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fprovisioning-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fprovisioning%2Fapi%2Fpropagation%2FPropagationByResource.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Fprovisioning-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fprovisioning%2Fapi%2Fpropagation%2FPropagationByResource.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5"},{"sha":"ff256340131d49364fc2f5f6a03e098c165752c1","filename":"syncope620/server/provisioning-api/src/main/java/org/apache/syncope/provisioning/api/propagation/PropagationException.java","status":"added","additions":51,"deletions":0,"changes":51,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fprovisioning-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fprovisioning%2Fapi%2Fpropagation%2FPropagationException.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fprovisioning-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fprovisioning%2Fapi%2Fpropagation%2FPropagationException.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Fprovisioning-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fprovisioning%2Fapi%2Fpropagation%2FPropagationException.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5"},{"sha":"d2060c957805d8ad12f5e247952e666ffa4cef51","filename":"syncope620/server/provisioning-api/src/main/java/org/apache/syncope/provisioning/api/propagation/PropagationManager.java","status":"added","additions":248,"deletions":0,"changes":248,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fprovisioning-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fprovisioning%2Fapi%2Fpropagation%2FPropagationManager.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fprovisioning-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fprovisioning%2Fapi%2Fpropagation%2FPropagationManager.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Fprovisioning-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fprovisioning%2Fapi%2Fpropagation%2FPropagationManager.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5"},{"sha":"b4b714bf29fbf3399f038507156fd331a356f68d","filename":"syncope620/server/provisioning-api/src/main/java/org/apache/syncope/provisioning/api/propagation/PropagationReporter.java","status":"added","additions":58,"deletions":0,"changes":58,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fprovisioning-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fprovisioning%2Fapi%2Fpropagation%2FPropagationReporter.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fprovisioning-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fprovisioning%2Fapi%2Fpropagation%2FPropagationReporter.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Fprovisioning-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fprovisioning%2Fapi%2Fpropagation%2FPropagationReporter.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5"},{"sha":"1b37718b4316af4296a0fa7b382b4bdcf6fa1b3e","filename":"syncope620/server/provisioning-api/src/main/java/org/apache/syncope/provisioning/api/propagation/PropagationTaskExecutor.java","status":"added","additions":77,"deletions":0,"changes":77,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fprovisioning-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fprovisioning%2Fapi%2Fpropagation%2FPropagationTaskExecutor.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fprovisioning-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fprovisioning%2Fapi%2Fpropagation%2FPropagationTaskExecutor.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Fprovisioning-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fprovisioning%2Fapi%2Fpropagation%2FPropagationTaskExecutor.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5"},{"sha":"4056e74d2bc77aa17f0c76a4da319cb0c72d0871","filename":"syncope620/server/provisioning-api/src/main/java/org/apache/syncope/provisioning/api/sync/SyncCorrelationRule.java","status":"added","additions":36,"deletions":0,"changes":36,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fprovisioning-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fprovisioning%2Fapi%2Fsync%2FSyncCorrelationRule.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fprovisioning-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fprovisioning%2Fapi%2Fsync%2FSyncCorrelationRule.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Fprovisioning-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fprovisioning%2Fapi%2Fsync%2FSyncCorrelationRule.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5"},{"sha":"d920258d641f9381737e8be9711d06c44d6b5a13","filename":"syncope620/server/provisioning-common/pom.xml","status":"added","additions":44,"deletions":0,"changes":44,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fprovisioning-common%2Fpom.xml","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fprovisioning-common%2Fpom.xml","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Fprovisioning-common%2Fpom.xml?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5"},{"sha":"3491075d8e3836c7eaf69886a43b3c340c2bae77","filename":"syncope620/server/provisioning-common/src/main/java/org/apache/syncope/provisioning/common/cache/DisabledVirAttrCache.java","status":"added","additions":52,"deletions":0,"changes":52,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fprovisioning-common%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fprovisioning%2Fcommon%2Fcache%2FDisabledVirAttrCache.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fprovisioning-common%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fprovisioning%2Fcommon%2Fcache%2FDisabledVirAttrCache.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Fprovisioning-common%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fprovisioning%2Fcommon%2Fcache%2FDisabledVirAttrCache.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5"},{"sha":"01994998bcb080459eef5cd69296af88509c2b69","filename":"syncope620/server/provisioning-common/src/main/java/org/apache/syncope/provisioning/common/cache/MemoryVirAttrCache.java","status":"added","additions":151,"deletions":0,"changes":151,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fprovisioning-common%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fprovisioning%2Fcommon%2Fcache%2FMemoryVirAttrCache.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fprovisioning-common%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fprovisioning%2Fcommon%2Fcache%2FMemoryVirAttrCache.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Fprovisioning-common%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fprovisioning%2Fcommon%2Fcache%2FMemoryVirAttrCache.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5"},{"sha":"6586ccc789fcdf4b54bd1e19d83988a31a98d155","filename":"syncope620/server/security/src/main/java/org/apache/syncope/server/security/UnauthorizedRoleException.java","status":"added","additions":42,"deletions":0,"changes":42,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fsecurity%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Fsecurity%2FUnauthorizedRoleException.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fsecurity%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Fsecurity%2FUnauthorizedRoleException.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Fsecurity%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Fsecurity%2FUnauthorizedRoleException.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5"},{"sha":"4e9fb6f35da91e0b8151e9f5f187dfd69369505f","filename":"syncope620/server/utils/pom.xml","status":"modified","additions":16,"deletions":1,"changes":17,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Futils%2Fpom.xml","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Futils%2Fpom.xml","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Futils%2Fpom.xml?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5"},{"sha":"d2afd3560f8ec5188cfba8c1188690944df7fb6f","filename":"syncope620/server/utils/src/main/java/org/apache/syncope/server/utils/ConnObjectUtil.java","status":"added","additions":764,"deletions":0,"changes":764,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Futils%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Futils%2FConnObjectUtil.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Futils%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Futils%2FConnObjectUtil.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Futils%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Futils%2FConnObjectUtil.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5"},{"sha":"5a39faf39690876424fb840f62464e25155a6fa4","filename":"syncope620/server/utils/src/main/java/org/apache/syncope/server/utils/ExceptionUtil.java","status":"added","additions":47,"deletions":0,"changes":47,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Futils%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Futils%2FExceptionUtil.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Futils%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Futils%2FExceptionUtil.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Futils%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Futils%2FExceptionUtil.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5"},{"sha":"8c97a1c4a2caa6ec1b61a7fdde64f884c252b107","filename":"syncope620/server/utils/src/main/java/org/apache/syncope/server/utils/InvalidPasswordPolicySpecException.java","status":"added","additions":37,"deletions":0,"changes":37,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Futils%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Futils%2FInvalidPasswordPolicySpecException.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Futils%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Futils%2FInvalidPasswordPolicySpecException.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Futils%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Futils%2FInvalidPasswordPolicySpecException.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5"},{"sha":"cb2e140b3a485cff058e18fd3c2e3004e2d46580","filename":"syncope620/server/utils/src/main/java/org/apache/syncope/server/utils/MappingUtil.java","status":"added","additions":736,"deletions":0,"changes":736,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Futils%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Futils%2FMappingUtil.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Futils%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Futils%2FMappingUtil.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Futils%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Futils%2FMappingUtil.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5"},{"sha":"9ad4ad0f6c5012920a0c3daa242301ef64e697de","filename":"syncope620/server/utils/src/main/java/org/apache/syncope/server/utils/PasswordGenerator.java","status":"added","additions":320,"deletions":0,"changes":320,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Futils%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Futils%2FPasswordGenerator.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Futils%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Futils%2FPasswordGenerator.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Futils%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Futils%2FPasswordGenerator.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5"},{"sha":"50d32591e12af6600de4044720a798c9bf275479","filename":"syncope620/server/utils/src/main/java/org/apache/syncope/server/utils/SecureRandomUtil.java","status":"renamed","additions":10,"deletions":6,"changes":16,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Futils%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Futils%2FSecureRandomUtil.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Futils%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Futils%2FSecureRandomUtil.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Futils%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Futils%2FSecureRandomUtil.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5","previous_filename":"syncope620/server/security/src/main/java/org/apache/syncope/server/security/SecureRandomUtil.java"},{"sha":"29bce71470c575e5af95b2bbfafd40e6096b7158","filename":"syncope620/server/utils/src/main/java/org/apache/syncope/server/utils/serialization/UnwrappedObjectMapper.java","status":"added","additions":95,"deletions":0,"changes":95,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Futils%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Futils%2Fserialization%2FUnwrappedObjectMapper.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Futils%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Futils%2Fserialization%2FUnwrappedObjectMapper.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Futils%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Futils%2Fserialization%2FUnwrappedObjectMapper.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5"},{"sha":"af7bed8372bbeddb4a227e179b59cdb404931c35","filename":"syncope620/server/workflow-api/pom.xml","status":"added","additions":44,"deletions":0,"changes":44,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fworkflow-api%2Fpom.xml","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fworkflow-api%2Fpom.xml","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Fworkflow-api%2Fpom.xml?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5"},{"sha":"76e07988f0daddad06aacfc31e4cc5939cf102ac","filename":"syncope620/server/workflow-api/src/main/java/org/apache/syncope/server/workflow/api/RoleWorkflowAdapter.java","status":"added","additions":71,"deletions":0,"changes":71,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fworkflow-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Fworkflow%2Fapi%2FRoleWorkflowAdapter.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fworkflow-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Fworkflow%2Fapi%2FRoleWorkflowAdapter.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Fworkflow-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Fworkflow%2Fapi%2FRoleWorkflowAdapter.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5"},{"sha":"1c521f11dc51719ff4d4a43d8d4565d7db8a304c","filename":"syncope620/server/workflow-api/src/main/java/org/apache/syncope/server/workflow/api/UserWorkflowAdapter.java","status":"added","additions":151,"deletions":0,"changes":151,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fworkflow-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Fworkflow%2Fapi%2FUserWorkflowAdapter.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fworkflow-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Fworkflow%2Fapi%2FUserWorkflowAdapter.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Fworkflow-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Fworkflow%2Fapi%2FUserWorkflowAdapter.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5"},{"sha":"0b500314b8b10b7374704558335d8151972918aa","filename":"syncope620/server/workflow-api/src/main/java/org/apache/syncope/server/workflow/api/WorkflowAdapter.java","status":"added","additions":111,"deletions":0,"changes":111,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fworkflow-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Fworkflow%2Fapi%2FWorkflowAdapter.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fworkflow-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Fworkflow%2Fapi%2FWorkflowAdapter.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Fworkflow-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Fworkflow%2Fapi%2FWorkflowAdapter.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5"},{"sha":"41ffe1dc3e88d977543ecf45ecea22e546ccf6fa","filename":"syncope620/server/workflow-api/src/main/java/org/apache/syncope/server/workflow/api/WorkflowDefinitionFormat.java","status":"added","additions":29,"deletions":0,"changes":29,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fworkflow-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Fworkflow%2Fapi%2FWorkflowDefinitionFormat.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fworkflow-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Fworkflow%2Fapi%2FWorkflowDefinitionFormat.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Fworkflow-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Fworkflow%2Fapi%2FWorkflowDefinitionFormat.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5"},{"sha":"246889313ebbd645f2211b6c4a2a3f14642a1751","filename":"syncope620/server/workflow-api/src/main/java/org/apache/syncope/server/workflow/api/WorkflowException.java","status":"added","additions":51,"deletions":0,"changes":51,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fworkflow-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Fworkflow%2Fapi%2FWorkflowException.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fworkflow-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Fworkflow%2Fapi%2FWorkflowException.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Fworkflow-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Fworkflow%2Fapi%2FWorkflowException.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5"},{"sha":"6271ec60ae2263b6c4ddc69726dbdbc10b3f5866","filename":"syncope620/server/workflow-api/src/main/java/org/apache/syncope/server/workflow/api/WorkflowInstanceLoader.java","status":"added","additions":28,"deletions":0,"changes":28,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fworkflow-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Fworkflow%2Fapi%2FWorkflowInstanceLoader.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fworkflow-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Fworkflow%2Fapi%2FWorkflowInstanceLoader.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Fworkflow-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Fworkflow%2Fapi%2FWorkflowInstanceLoader.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5"},{"sha":"bb796244e98761e01a8619b488f74b2e8388c47b","filename":"syncope620/server/workflow-api/src/main/java/org/apache/syncope/server/workflow/api/package-info.java","status":"added","additions":19,"deletions":0,"changes":19,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fworkflow-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Fworkflow%2Fapi%2Fpackage-info.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/99369c3115b9feec77bebff5fbbb2813d72aedf5/syncope620%2Fserver%2Fworkflow-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Fworkflow%2Fapi%2Fpackage-info.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/syncope620%2Fserver%2Fworkflow-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fserver%2Fworkflow%2Fapi%2Fpackage-info.java?ref=99369c3115b9feec77bebff5fbbb2813d72aedf5"}]}