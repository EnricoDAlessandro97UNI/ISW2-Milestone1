{"sha":"56c18fe7854e83c6d64c7c938a49793c1419cd59","node_id":"MDY6Q29tbWl0NjM2ODc5MDYyOjU2YzE4ZmU3ODU0ZTgzYzZkNjRjN2M5MzhhNDk3OTNjMTQxOWNkNTk=","commit":{"author":{"name":"Fabio Martelli","email":"fmartelli@apache.org","date":"2014-06-25T12:05:42Z"},"committer":{"name":"Fabio Martelli","email":"fmartelli@apache.org","date":"2014-06-25T12:05:42Z"},"message":"[SYNCOPE-504, SYNCOPE-515] merge from the branch 1_1_X\n\ngit-svn-id: https://svn.apache.org/repos/asf/syncope/trunk@1605361 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"5705e79a43cdb853b45beb806f4673e5ce718a76","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/git/trees/5705e79a43cdb853b45beb806f4673e5ce718a76"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/git/commits/56c18fe7854e83c6d64c7c938a49793c1419cd59","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/56c18fe7854e83c6d64c7c938a49793c1419cd59","html_url":"https://github.com/EnricoDAlessandro97UNI/syncope/commit/56c18fe7854e83c6d64c7c938a49793c1419cd59","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/56c18fe7854e83c6d64c7c938a49793c1419cd59/comments","author":{"login":"fmartelli","id":1791932,"node_id":"MDQ6VXNlcjE3OTE5MzI=","avatar_url":"https://avatars.githubusercontent.com/u/1791932?v=4","gravatar_id":"","url":"https://api.github.com/users/fmartelli","html_url":"https://github.com/fmartelli","followers_url":"https://api.github.com/users/fmartelli/followers","following_url":"https://api.github.com/users/fmartelli/following{/other_user}","gists_url":"https://api.github.com/users/fmartelli/gists{/gist_id}","starred_url":"https://api.github.com/users/fmartelli/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fmartelli/subscriptions","organizations_url":"https://api.github.com/users/fmartelli/orgs","repos_url":"https://api.github.com/users/fmartelli/repos","events_url":"https://api.github.com/users/fmartelli/events{/privacy}","received_events_url":"https://api.github.com/users/fmartelli/received_events","type":"User","site_admin":false},"committer":{"login":"fmartelli","id":1791932,"node_id":"MDQ6VXNlcjE3OTE5MzI=","avatar_url":"https://avatars.githubusercontent.com/u/1791932?v=4","gravatar_id":"","url":"https://api.github.com/users/fmartelli","html_url":"https://github.com/fmartelli","followers_url":"https://api.github.com/users/fmartelli/followers","following_url":"https://api.github.com/users/fmartelli/following{/other_user}","gists_url":"https://api.github.com/users/fmartelli/gists{/gist_id}","starred_url":"https://api.github.com/users/fmartelli/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/fmartelli/subscriptions","organizations_url":"https://api.github.com/users/fmartelli/orgs","repos_url":"https://api.github.com/users/fmartelli/repos","events_url":"https://api.github.com/users/fmartelli/events{/privacy}","received_events_url":"https://api.github.com/users/fmartelli/received_events","type":"User","site_admin":false},"parents":[{"sha":"65f506efd5e86908663228760b30a97fca51e522","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/65f506efd5e86908663228760b30a97fca51e522","html_url":"https://github.com/EnricoDAlessandro97UNI/syncope/commit/65f506efd5e86908663228760b30a97fca51e522"},{"sha":"cbe082a2ebf17cb5ebf0f4be93cca1eda5b80446","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/cbe082a2ebf17cb5ebf0f4be93cca1eda5b80446","html_url":"https://github.com/EnricoDAlessandro97UNI/syncope/commit/cbe082a2ebf17cb5ebf0f4be93cca1eda5b80446"}],"stats":{"total":3160,"additions":1769,"deletions":1391},"files":[{"sha":"51f8fd7f941e15dca9b61a2135a423a143b95de8","filename":"core/src/main/java/org/apache/syncope/core/sync/AbstractSyncActions.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/56c18fe7854e83c6d64c7c938a49793c1419cd59/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fsync%2FAbstractSyncActions.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/56c18fe7854e83c6d64c7c938a49793c1419cd59/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fsync%2FAbstractSyncActions.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fsync%2FAbstractSyncActions.java?ref=56c18fe7854e83c6d64c7c938a49793c1419cd59","patch":"@@ -30,7 +30,7 @@\n      * @param handler synchronization handler being executed.\n      * @throws JobExecutionException in case of generic failure.\n      */\n-    void beforeAll(final T handler) throws JobExecutionException;\n+    void beforeAll(final SyncProfile<?, ?> profile) throws JobExecutionException;\n \n     /**\n      * Action to be executed after the synchronization task completion.\n@@ -39,5 +39,5 @@\n      * @param results synchronization result\n      * @throws JobExecutionException in case of generic failure\n      */\n-    void afterAll(final T handler, final List<SyncResult> results) throws JobExecutionException;\n+    void afterAll(final SyncProfile<?, ?> profile, final List<SyncResult> results) throws JobExecutionException;\n }"},{"sha":"03011422b49feeb2918c797e05f5e0c4365eb7ae","filename":"core/src/main/java/org/apache/syncope/core/sync/DefaultPushActions.java","status":"modified","additions":11,"deletions":12,"changes":23,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/56c18fe7854e83c6d64c7c938a49793c1419cd59/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fsync%2FDefaultPushActions.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/56c18fe7854e83c6d64c7c938a49793c1419cd59/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fsync%2FDefaultPushActions.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fsync%2FDefaultPushActions.java?ref=56c18fe7854e83c6d64c7c938a49793c1419cd59","patch":"@@ -23,7 +23,6 @@\n import java.util.Set;\n \n import org.apache.syncope.core.persistence.beans.AbstractAttributable;\n-import org.apache.syncope.core.sync.impl.AbstractSyncopeResultHandler;\n import org.identityconnectors.framework.common.objects.Attribute;\n import org.quartz.JobExecutionException;\n \n@@ -33,20 +32,20 @@\n public abstract class DefaultPushActions implements PushActions {\n \n     @Override\n-    public void beforeAll(final AbstractSyncopeResultHandler<?, ?> handler) throws JobExecutionException {\n+    public void beforeAll(final SyncProfile<?, ?> profile) throws JobExecutionException {\n     }\n \n     @Override\n     public <T extends AbstractAttributable> Map.Entry<String, Set<Attribute>> beforeAssign(\n-            final AbstractSyncopeResultHandler<?, ?> handler,\n+            final SyncProfile<?, ?> profile,\n             final Map.Entry<String, Set<Attribute>> delta,\n             final T subject) throws JobExecutionException {\n         return delta;\n     }\n \n     @Override\n     public <T extends AbstractAttributable> Map.Entry<String, Set<Attribute>> beforeUpdate(\n-            final AbstractSyncopeResultHandler<?, ?> handler,\n+            final SyncProfile<?, ?> profile,\n             final Map.Entry<String, Set<Attribute>> delta,\n             final T subject) throws JobExecutionException {\n \n@@ -55,63 +54,63 @@ public <T extends AbstractAttributable> Map.Entry<String, Set<Attribute>> before\n \n     @Override\n     public <T extends AbstractAttributable> void after(\n-            final AbstractSyncopeResultHandler<?, ?> handler,\n+            final SyncProfile<?, ?> profile,\n             final Map.Entry<String, Set<Attribute>> delta,\n             final T subject,\n             SyncResult result) throws JobExecutionException {\n     }\n \n     @Override\n     public <T extends AbstractAttributable> Map.Entry<String, Set<Attribute>> beforeProvision(\n-            final AbstractSyncopeResultHandler<?, ?> handler,\n+            final SyncProfile<?, ?> profile,\n             final Map.Entry<String, Set<Attribute>> delta,\n             final T subject) throws JobExecutionException {\n         return delta;\n     }\n \n     @Override\n     public <T extends AbstractAttributable> Map.Entry<String, Set<Attribute>> beforeLink(\n-            final AbstractSyncopeResultHandler<?, ?> handler,\n+            final SyncProfile<?, ?> profile,\n             final Map.Entry<String, Set<Attribute>> delta,\n             final T subject) throws JobExecutionException {\n         return delta;\n     }\n \n     @Override\n     public <T extends AbstractAttributable> Map.Entry<String, Set<Attribute>> beforeUnlink(\n-            final AbstractSyncopeResultHandler<?, ?> handler,\n+            final SyncProfile<?, ?> profile,\n             final Map.Entry<String, Set<Attribute>> delta,\n             final T subject) throws JobExecutionException {\n         return delta;\n     }\n \n     @Override\n     public <T extends AbstractAttributable> Map.Entry<String, Set<Attribute>> beforeUnassign(\n-            final AbstractSyncopeResultHandler<?, ?> handler,\n+            final SyncProfile<?, ?> profile,\n             final Map.Entry<String, Set<Attribute>> delta,\n             final T subject) throws JobExecutionException {\n         return delta;\n     }\n \n     @Override\n     public <T extends AbstractAttributable> Map.Entry<String, Set<Attribute>> beforeDeprovision(\n-            final AbstractSyncopeResultHandler<?, ?> handler,\n+            final SyncProfile<?, ?> profile,\n             final Map.Entry<String, Set<Attribute>> delta,\n             final T subject) throws JobExecutionException {\n         return delta;\n     }\n \n     @Override\n     public <T extends AbstractAttributable> Map.Entry<String, Set<Attribute>> beforeDelete(\n-            final AbstractSyncopeResultHandler<?, ?> handler,\n+            final SyncProfile<?, ?> profile,\n             final Map.Entry<String, Set<Attribute>> delta,\n             final T subject) throws JobExecutionException {\n         return delta;\n     }\n \n     @Override\n     public void afterAll(\n-            final AbstractSyncopeResultHandler<?, ?> handler,\n+            final SyncProfile<?, ?> profile,\n             final List<SyncResult> results)\n             throws JobExecutionException {\n     }"},{"sha":"e51761e38dd19166cd3216874b57621d95da9c2c","filename":"core/src/main/java/org/apache/syncope/core/sync/DefaultSyncActions.java","status":"modified","additions":11,"deletions":12,"changes":23,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/56c18fe7854e83c6d64c7c938a49793c1419cd59/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fsync%2FDefaultSyncActions.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/56c18fe7854e83c6d64c7c938a49793c1419cd59/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fsync%2FDefaultSyncActions.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fsync%2FDefaultSyncActions.java?ref=56c18fe7854e83c6d64c7c938a49793c1419cd59","patch":"@@ -22,7 +22,6 @@\n \n import org.apache.syncope.common.mod.AbstractAttributableMod;\n import org.apache.syncope.common.to.AbstractAttributableTO;\n-import org.apache.syncope.core.sync.impl.AbstractSyncopeResultHandler;\n import org.identityconnectors.framework.common.objects.SyncDelta;\n import org.quartz.JobExecutionException;\n \n@@ -32,12 +31,12 @@\n public abstract class DefaultSyncActions implements SyncActions {\n \n     @Override\n-    public void beforeAll(final AbstractSyncopeResultHandler<?, ?> handler) throws JobExecutionException {\n+    public void beforeAll(final SyncProfile<?, ?> profile) throws JobExecutionException {\n     }\n \n     @Override\n     public <T extends AbstractAttributableTO> SyncDelta beforeCreate(\n-            final AbstractSyncopeResultHandler<?, ?> handler,\n+            final SyncProfile<?, ?> profile,\n             final SyncDelta delta,\n             final T subject) throws JobExecutionException {\n \n@@ -46,7 +45,7 @@ public <T extends AbstractAttributableTO> SyncDelta beforeCreate(\n \n     @Override\n     public <T extends AbstractAttributableTO, K extends AbstractAttributableMod> SyncDelta beforeUpdate(\n-            final AbstractSyncopeResultHandler<?, ?> handler,\n+            final SyncProfile<?, ?> profile,\n             final SyncDelta delta,\n             final T subject,\n             final K subjectMod)\n@@ -57,7 +56,7 @@ public <T extends AbstractAttributableTO, K extends AbstractAttributableMod> Syn\n \n     @Override\n     public <T extends AbstractAttributableTO> SyncDelta beforeDelete(\n-            final AbstractSyncopeResultHandler<?, ?> handler,\n+            final SyncProfile<?, ?> profile,\n             final SyncDelta delta,\n             final T subject) throws JobExecutionException {\n \n@@ -66,15 +65,15 @@ public <T extends AbstractAttributableTO> SyncDelta beforeDelete(\n \n     @Override\n     public <T extends AbstractAttributableTO> void after(\n-            final AbstractSyncopeResultHandler<?, ?> handler,\n+            final SyncProfile<?, ?> profile,\n             final SyncDelta delta,\n             final T subject,\n             final SyncResult result) throws JobExecutionException {\n     }\n \n     @Override\n     public <T extends AbstractAttributableTO> SyncDelta beforeAssign(\n-            final AbstractSyncopeResultHandler<?, ?> handler,\n+            final SyncProfile<?, ?> profile,\n             final SyncDelta delta,\n             final T subject) throws JobExecutionException {\n \n@@ -83,7 +82,7 @@ public <T extends AbstractAttributableTO> SyncDelta beforeAssign(\n \n     @Override\n     public <T extends AbstractAttributableTO> SyncDelta beforeUnassign(\n-            final AbstractSyncopeResultHandler<?, ?> handler,\n+            final SyncProfile<?, ?> profile,\n             final SyncDelta delta,\n             final T subject) throws JobExecutionException {\n \n@@ -92,7 +91,7 @@ public <T extends AbstractAttributableTO> SyncDelta beforeUnassign(\n \n     @Override\n     public <T extends AbstractAttributableTO> SyncDelta beforeDeprovision(\n-            final AbstractSyncopeResultHandler<?, ?> handler,\n+            final SyncProfile<?, ?> profile,\n             final SyncDelta delta,\n             final T subject) throws JobExecutionException {\n \n@@ -101,7 +100,7 @@ public <T extends AbstractAttributableTO> SyncDelta beforeDeprovision(\n \n     @Override\n     public <T extends AbstractAttributableTO> SyncDelta beforeUnlink(\n-            final AbstractSyncopeResultHandler<?, ?> handler,\n+            final SyncProfile<?, ?> profile,\n             final SyncDelta delta,\n             final T subject) throws JobExecutionException {\n \n@@ -110,7 +109,7 @@ public <T extends AbstractAttributableTO> SyncDelta beforeUnlink(\n \n     @Override\n     public <T extends AbstractAttributableTO> SyncDelta beforeLink(\n-            final AbstractSyncopeResultHandler<?, ?> handler,\n+            final SyncProfile<?, ?> profile,\n             final SyncDelta delta,\n             final T subject) throws JobExecutionException {\n \n@@ -119,7 +118,7 @@ public <T extends AbstractAttributableTO> SyncDelta beforeLink(\n \n     @Override\n     public void afterAll(\n-            final AbstractSyncopeResultHandler<?, ?> handler,\n+            final SyncProfile<?, ?> profile,\n             final List<SyncResult> results)\n             throws JobExecutionException {\n     }"},{"sha":"6b954ba41355250e691f5378955dc6c16f3d0723","filename":"core/src/main/java/org/apache/syncope/core/sync/PushActions.java","status":"modified","additions":18,"deletions":18,"changes":36,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/56c18fe7854e83c6d64c7c938a49793c1419cd59/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fsync%2FPushActions.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/56c18fe7854e83c6d64c7c938a49793c1419cd59/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fsync%2FPushActions.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fsync%2FPushActions.java?ref=56c18fe7854e83c6d64c7c938a49793c1419cd59","patch":"@@ -33,126 +33,126 @@ public interface PushActions extends AbstractSyncActions<AbstractSyncopeResultHa\n     /**\n      * Action to be executed before to assign (link & provision) a synchronized user / role to the resource.\n      *\n-     * @param handler synchronization handler being executed.\n+     * @param profile profile of the synchronization being executed.\n      * @param delta info to be pushed out (accountId, attributes).\n      * @param subject user / role to be created.\n      * @return info to be pushed out (accountId, attributes).\n      * @throws JobExecutionException in case of generic failure\n      */\n     <T extends AbstractAttributable> Map.Entry<String, Set<Attribute>> beforeAssign(\n-            final AbstractSyncopeResultHandler<?, ?> handler,\n+            final SyncProfile<?, ?> profile,\n             final Map.Entry<String, Set<Attribute>> delta,\n             final T subject) throws JobExecutionException;\n \n     /**\n      * Action to be executed before to provision a synchronized user / role to the resource.\n      *\n-     * @param handler synchronization handler being executed.\n+     * @param profile profile of the synchronization being executed.\n      * @param delta info to be pushed out (accountId, attributes).\n      * @param subject user / role to be created.\n      * @return info to be pushed out (accountId, attributes).\n      * @throws JobExecutionException in case of generic failure\n      */\n     <T extends AbstractAttributable> Map.Entry<String, Set<Attribute>> beforeProvision(\n-            final AbstractSyncopeResultHandler<?, ?> handler,\n+            final SyncProfile<?, ?> profile,\n             final Map.Entry<String, Set<Attribute>> delta,\n             final T subject) throws JobExecutionException;\n \n     /**\n      * Action to be executed before to update a synchronized user / role on the resource.\n      *\n-     * @param handler synchronization handler being executed.\n+     * @param profile profile of the synchronization being executed.\n      * @param delta info to be pushed out (accountId, attributes).\n      * @param subject user / role to be updated.\n      * @return info to be pushed out (accountId, attributes).\n      * @throws JobExecutionException in case of generic failure\n      */\n     <T extends AbstractAttributable> Map.Entry<String, Set<Attribute>> beforeUpdate(\n-            final AbstractSyncopeResultHandler<?, ?> handler,\n+            final SyncProfile<?, ?> profile,\n             final Map.Entry<String, Set<Attribute>> delta,\n             final T subject) throws JobExecutionException;\n \n     /**\n      * Action to be executed before to link a synchronized user / role to the resource.\n      *\n-     * @param handler synchronization handler being executed.\n+     * @param profile profile of the synchronization being executed.\n      * @param delta info to be pushed out (accountId, attributes).\n      * @param subject user / role to be created.\n      * @return info to be pushed out (accountId, attributes).\n      * @throws JobExecutionException in case of generic failure\n      */\n     <T extends AbstractAttributable> Map.Entry<String, Set<Attribute>> beforeLink(\n-            final AbstractSyncopeResultHandler<?, ?> handler,\n+            final SyncProfile<?, ?> profile,\n             final Map.Entry<String, Set<Attribute>> delta,\n             final T subject) throws JobExecutionException;\n \n     /**\n      * Action to be executed before to unlink a synchronized user / role from the resource.\n      *\n-     * @param handler synchronization handler being executed.\n+     * @param profile profile of the synchronization being executed.\n      * @param delta info to be pushed out (accountId, attributes).\n      * @param subject user / role to be created.\n      * @return info to be pushed out (accountId, attributes).\n      * @throws JobExecutionException in case of generic failure\n      */\n     <T extends AbstractAttributable> Map.Entry<String, Set<Attribute>> beforeUnlink(\n-            final AbstractSyncopeResultHandler<?, ?> handler,\n+            final SyncProfile<?, ?> profile,\n             final Map.Entry<String, Set<Attribute>> delta,\n             final T subject) throws JobExecutionException;\n \n     /**\n      * Action to be executed before to unassign a synchronized user / role from the resource.\n      *\n-     * @param handler synchronization handler being executed.\n+     * @param profile profile of the synchronization being executed.\n      * @param delta info to be pushed out (accountId, attributes).\n      * @param subject user / role to be created.\n      * @return info to be pushed out (accountId, attributes).\n      * @throws JobExecutionException in case of generic failure\n      */\n     <T extends AbstractAttributable> Map.Entry<String, Set<Attribute>> beforeUnassign(\n-            final AbstractSyncopeResultHandler<?, ?> handler,\n+            final SyncProfile<?, ?> profile,\n             final Map.Entry<String, Set<Attribute>> delta,\n             final T subject) throws JobExecutionException;\n \n     /**\n      * Action to be executed before to unassign a synchronized user / role from the resource.\n      *\n-     * @param handler synchronization handler being executed.\n+     * @param profile profile of the synchronization being executed.\n      * @param delta info to be pushed out (accountId, attributes).\n      * @param subject user / role to be created.\n      * @return info to be pushed out (accountId, attributes).\n      * @throws JobExecutionException in case of generic failure\n      */\n     <T extends AbstractAttributable> Map.Entry<String, Set<Attribute>> beforeDeprovision(\n-            final AbstractSyncopeResultHandler<?, ?> handler,\n+            final SyncProfile<?, ?> profile,\n             final Map.Entry<String, Set<Attribute>> delta,\n             final T subject) throws JobExecutionException;\n \n     /**\n      * Action to be executed before delete a synchronized user / role locally and from the resource.\n      *\n-     * @param handler synchronization handler being executed.\n+     * @param profile profile of the synchronization being executed.\n      * @param delta info to be pushed out (accountId, attributes).\n      * @param subject user / role to be created.\n      * @return info to be pushed out (accountId, attributes).\n      * @throws JobExecutionException in case of generic failure\n      */\n     <T extends AbstractAttributable> Map.Entry<String, Set<Attribute>> beforeDelete(\n-            final AbstractSyncopeResultHandler<?, ?> handler,\n+            final SyncProfile<?, ?> profile,\n             final Map.Entry<String, Set<Attribute>> delta,\n             final T subject) throws JobExecutionException;\n \n     /**\n      * Action to be executed after each local user / role synchronization.\n      *\n-     * @param handler synchronization handler being executed.\n+     * @param profile profile of the synchronization being executed.\n      * @param delta info pushed out (accountId, attributes)\n      * @param subject synchronized user / role.\n      * @param result operation result.\n      * @throws JobExecutionException in case of generic failure\n      */\n     <T extends AbstractAttributable> void after(\n-            final AbstractSyncopeResultHandler<?, ?> handler,\n+            final SyncProfile<?, ?> profile,\n             final Map.Entry<String, Set<Attribute>> delta,\n             final T subject,\n             final SyncResult result) throws JobExecutionException;"},{"sha":"1212ab1b86fd34c08cae9be6152276137db2bdbd","filename":"core/src/main/java/org/apache/syncope/core/sync/SyncActions.java","status":"modified","additions":32,"deletions":18,"changes":50,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/56c18fe7854e83c6d64c7c938a49793c1419cd59/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fsync%2FSyncActions.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/56c18fe7854e83c6d64c7c938a49793c1419cd59/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fsync%2FSyncActions.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fsync%2FSyncActions.java?ref=56c18fe7854e83c6d64c7c938a49793c1419cd59","patch":"@@ -31,100 +31,114 @@ public interface SyncActions extends AbstractSyncActions<AbstractSyncopeResultHa\n \n     /**\n      * Action to be executed before to create a synchronized user / role locally.\n+     * User/role is created locally upon synchronization in case of the un-matching rule\n+     * {@link org.apache.syncope.common.types.UnmatchingRule#PROVISION} (default un-matching rule) is applied.\n      *\n-     * @param handler synchronization handler being executed.\n+     * @param profile profile of the synchronization being executed.\n      * @param delta retrieved synchronization information\n      * @param subject user / role to be created\n      * @return synchronization information used for user status evaluation and to be passed to the 'after' method.\n      * @throws JobExecutionException in case of generic failure\n      */\n     <T extends AbstractAttributableTO> SyncDelta beforeCreate(\n-            final AbstractSyncopeResultHandler<?, ?> handler,\n+            final SyncProfile<?, ?> profile,\n             final SyncDelta delta,\n             final T subject) throws JobExecutionException;\n \n     /**\n      * Action to be executed before creating (and linking to the resource) a synchronized user / role locally.\n+     * User/role is created locally and linked to the synchronized resource upon synchronization in case of the\n+     * un-matching rule {@link org.apache.syncope.common.types.UnmatchingRule#ASSIGN} is applied.\n      *\n-     * @param handler synchronization handler being executed.\n+     * @param profile profile of the synchronization being executed.\n      * @param delta retrieved synchronization information\n      * @param subject user / role to be created\n      * @return synchronization information used for user status evaluation and to be passed to the 'after' method.\n      * @throws JobExecutionException in case of generic failure\n      */\n     <T extends AbstractAttributableTO> SyncDelta beforeAssign(\n-            final AbstractSyncopeResultHandler<?, ?> handler,\n+            final SyncProfile<?, ?> profile,\n             final SyncDelta delta,\n             final T subject) throws JobExecutionException;\n \n     /**\n      * Action to be executed before unlinking resource from the synchronized user / role and de-provisioning.\n+     * User/role is unlinked and de-provisioned from the synchronized resource upon synchronization in case of the\n+     * matching rule {@link org.apache.syncope.common.types.MatchingRule#UNASSIGN} is applied.\n      *\n-     * @param handler synchronization handler being executed.\n+     * @param profile profile of the synchronization being executed.\n      * @param delta retrieved synchronization information\n      * @param subject user / role to be created\n      * @return synchronization information used for user status evaluation and to be passed to the 'after' method.\n      * @throws JobExecutionException in case of generic failure\n      */\n     <T extends AbstractAttributableTO> SyncDelta beforeUnassign(\n-            final AbstractSyncopeResultHandler<?, ?> handler,\n+            final SyncProfile<?, ?> profile,\n             final SyncDelta delta,\n             final T subject) throws JobExecutionException;\n \n     /**\n      * Action to be executed before de-provisioning action only.\n+     * User/role is de-provisioned (without unlinking) from the synchronized resource upon synchronization in case of\n+     * the matching rule {@link org.apache.syncope.common.types.MatchingRule#DEPROVISION} is applied.\n      *\n-     * @param handler synchronization handler being executed.\n+     * @param profile profile of the synchronization being executed.\n      * @param delta retrieved synchronization information\n      * @param subject user / role to be created\n      * @return synchronization information used for user status evaluation and to be passed to the 'after' method.\n      * @throws JobExecutionException in case of generic failure\n      */\n     <T extends AbstractAttributableTO> SyncDelta beforeDeprovision(\n-            final AbstractSyncopeResultHandler<?, ?> handler,\n+            final SyncProfile<?, ?> profile,\n             final SyncDelta delta,\n             final T subject) throws JobExecutionException;\n \n     /**\n      * Action to be executed before unlinking resource from the synchronized user / role.\n+     * User/role is unlinked (without de-provisioning) from the synchronized resource upon synchronization in case of\n+     * the matching rule {@link org.apache.syncope.common.types.MatchingRule#UNLINK} is applied.\n      *\n-     * @param handler synchronization handler being executed.\n+     * @param profile profile of the synchronization being executed.\n      * @param delta retrieved synchronization information\n      * @param subject user / role to be created\n      * @return synchronization information used for user status evaluation and to be passed to the 'after' method.\n      * @throws JobExecutionException in case of generic failure\n      */\n     <T extends AbstractAttributableTO> SyncDelta beforeUnlink(\n-            final AbstractSyncopeResultHandler<?, ?> handler,\n+            final SyncProfile<?, ?> profile,\n             final SyncDelta delta,\n             final T subject) throws JobExecutionException;\n \n     /**\n      * Action to be executed before linking resource to the synchronized user / role.\n+     * User/role is linked (without updating) to the synchronized resource upon synchronization in case of\n+     * the matching rule {@link org.apache.syncope.common.types.MatchingRule#LINK} is applied.\n      *\n-     * @param handler synchronization handler being executed.\n+     * @param profile profile of the synchronization being executed.\n      * @param delta retrieved synchronization information\n      * @param subject user / role to be created\n      * @return synchronization information used for user status evaluation and to be passed to the 'after' method.\n      * @throws JobExecutionException in case of generic failure\n      */\n     <T extends AbstractAttributableTO> SyncDelta beforeLink(\n-            final AbstractSyncopeResultHandler<?, ?> handler,\n+            final SyncProfile<?, ?> profile,\n             final SyncDelta delta,\n             final T subject) throws JobExecutionException;\n \n     /**\n      * Action to be executed before to update a synchronized user / role locally.\n+     * User/role is updated upon synchronization in case of the matching rule\n+     * {@link org.apache.syncope.common.types.MatchingRule#UPDATE} (default matching rule) is applied.\n      *\n-     * @param handler synchronization handler being executed.\n+     * @param profile profile of the synchronization being executed.\n      * @param delta retrieved synchronization information\n      * @param subject local user / role information\n      * @param subjectMod modification\n      * @return synchronization information used for logging and to be passed to the 'after' method.\n      * @throws JobExecutionException in case of generic failure.\n      */\n     <T extends AbstractAttributableTO, K extends AbstractAttributableMod> SyncDelta beforeUpdate(\n-            final AbstractSyncopeResultHandler<?, ?> handler,\n+            final SyncProfile<?, ?> profile,\n             final SyncDelta delta,\n             final T subject,\n             final K subjectMod)\n@@ -133,28 +147,28 @@ <T extends AbstractAttributableTO, K extends AbstractAttributableMod> SyncDelta\n     /**\n      * Action to be executed before to delete a synchronized user / role locally.\n      *\n-     * @param handler synchronization handler being executed.\n+     * @param profile profile of the synchronization being executed.\n      * @param delta retrieved synchronization information\n      * @param subject local user / role to be deleted\n      * @return synchronization information used for logging and to be passed to the 'after' method.\n      * @throws JobExecutionException in case of generic failure\n      */\n     <T extends AbstractAttributableTO> SyncDelta beforeDelete(\n-            final AbstractSyncopeResultHandler<?, ?> handler,\n+            final SyncProfile<?, ?> profile,\n             final SyncDelta delta,\n             final T subject) throws JobExecutionException;\n \n     /**\n      * Action to be executed after each local user / role synchronization.\n      *\n-     * @param handler synchronization handler being executed.\n+     * @param profile profile of the synchronization being executed.\n      * @param delta retrieved synchronization information (may be modified by 'beforeCreate/beforeUpdate/beforeDelete')\n      * @param subject synchronized local user / role\n      * @param result global synchronization results at the current synchronization step\n      * @throws JobExecutionException in case of generic failure\n      */\n     <T extends AbstractAttributableTO> void after(\n-            final AbstractSyncopeResultHandler<?, ?> handler,\n+            final SyncProfile<?, ?> profile,\n             final SyncDelta delta,\n             final T subject,\n             final SyncResult result) throws JobExecutionException;"},{"sha":"9074d447ee901528cda93dcca48a3b074d1d4783","filename":"core/src/main/java/org/apache/syncope/core/sync/SyncProfile.java","status":"added","additions":91,"deletions":0,"changes":91,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/56c18fe7854e83c6d64c7c938a49793c1419cd59/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fsync%2FSyncProfile.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/56c18fe7854e83c6d64c7c938a49793c1419cd59/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fsync%2FSyncProfile.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fsync%2FSyncProfile.java?ref=56c18fe7854e83c6d64c7c938a49793c1419cd59","patch":"@@ -0,0 +1,91 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.core.sync;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import org.apache.syncope.common.types.ConflictResolutionAction;\n+import org.apache.syncope.core.persistence.beans.AbstractSyncTask;\n+import org.apache.syncope.core.propagation.Connector;\n+import org.apache.syncope.core.sync.AbstractSyncActions;\n+import org.apache.syncope.core.sync.SyncResult;\n+\n+public class SyncProfile<T extends AbstractSyncTask, A extends AbstractSyncActions<?>> {\n+\n+    /**\n+     * Syncing connector.\n+     */\n+    private Connector connector;\n+\n+    private Collection<SyncResult> results;\n+\n+    private boolean dryRun;\n+\n+    private ConflictResolutionAction resAct;\n+\n+    private List<A> actions;\n+\n+    private T syncTask;\n+\n+    public SyncProfile(final Connector connector, final T syncTask) {\n+        this.connector = connector;\n+        this.syncTask = syncTask;\n+    }\n+\n+    public Connector getConnector() {\n+        return connector;\n+    }\n+\n+    public Collection<SyncResult> getResults() {\n+        return results;\n+    }\n+\n+    public void setResults(final Collection<SyncResult> results) {\n+        this.results = results;\n+    }\n+\n+    public boolean isDryRun() {\n+        return dryRun;\n+    }\n+\n+    public void setDryRun(boolean dryRun) {\n+        this.dryRun = dryRun;\n+    }\n+\n+    public ConflictResolutionAction getResAct() {\n+        return resAct;\n+    }\n+\n+    public void setResAct(final ConflictResolutionAction resAct) {\n+        this.resAct = resAct;\n+    }\n+\n+    public List<A> getActions() {\n+        return actions;\n+    }\n+\n+    public void setActions(\n+            List<A> actions) {\n+        this.actions = actions;\n+    }\n+\n+    public T getSyncTask() {\n+        return syncTask;\n+    }\n+}"},{"sha":"d7430d4704c520ffa9c33c6a3d9bfa633bd07868","filename":"core/src/main/java/org/apache/syncope/core/sync/SyncUtilities.java","status":"added","additions":346,"deletions":0,"changes":346,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/56c18fe7854e83c6d64c7c938a49793c1419cd59/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fsync%2FSyncUtilities.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/56c18fe7854e83c6d64c7c938a49793c1419cd59/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fsync%2FSyncUtilities.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fsync%2FSyncUtilities.java?ref=56c18fe7854e83c6d64c7c938a49793c1419cd59","patch":"@@ -0,0 +1,346 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.core.sync;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.syncope.common.types.MappingPurpose;\n+import org.apache.syncope.common.types.SubjectType;\n+import org.apache.syncope.common.types.SyncPolicySpec;\n+import org.apache.syncope.core.persistence.beans.AbstractAttrValue;\n+import org.apache.syncope.core.persistence.beans.AbstractMappingItem;\n+import org.apache.syncope.core.persistence.beans.AbstractNormalSchema;\n+import org.apache.syncope.core.persistence.beans.AbstractSubject;\n+import org.apache.syncope.core.persistence.beans.AbstractSyncTask;\n+import org.apache.syncope.core.persistence.beans.ExternalResource;\n+import org.apache.syncope.core.persistence.beans.SyncPolicy;\n+import org.apache.syncope.core.persistence.beans.role.SyncopeRole;\n+import org.apache.syncope.core.persistence.beans.user.SyncopeUser;\n+import org.apache.syncope.core.persistence.dao.EntitlementDAO;\n+import org.apache.syncope.core.persistence.dao.PolicyDAO;\n+import org.apache.syncope.core.persistence.dao.RoleDAO;\n+import org.apache.syncope.core.persistence.dao.SchemaDAO;\n+import org.apache.syncope.core.persistence.dao.SubjectSearchDAO;\n+import org.apache.syncope.core.persistence.dao.UserDAO;\n+import org.apache.syncope.core.persistence.dao.search.AttributeCond;\n+import org.apache.syncope.core.persistence.dao.search.OrderByClause;\n+import org.apache.syncope.core.persistence.dao.search.SearchCond;\n+import org.apache.syncope.core.persistence.dao.search.SubjectCond;\n+import org.apache.syncope.core.persistence.validation.attrvalue.ParsingValidationException;\n+import org.apache.syncope.core.propagation.Connector;\n+import org.apache.syncope.core.sync.SyncCorrelationRule;\n+import org.apache.syncope.core.util.AttributableUtil;\n+import org.apache.syncope.core.util.EntitlementUtil;\n+import org.identityconnectors.framework.common.objects.Attribute;\n+import org.identityconnectors.framework.common.objects.AttributeUtil;\n+import org.identityconnectors.framework.common.objects.ConnectorObject;\n+import org.identityconnectors.framework.common.objects.Name;\n+import org.identityconnectors.framework.common.objects.ObjectClass;\n+import org.identityconnectors.framework.common.objects.OperationalAttributes;\n+import org.identityconnectors.framework.common.objects.filter.EqualsFilter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Component;\n+\n+@Component\n+public class SyncUtilities {\n+\n+    /**\n+     * Logger.\n+     */\n+    protected static final Logger LOG = LoggerFactory.getLogger(SyncUtilities.class);\n+\n+    /**\n+     * Policy DAO.\n+     */\n+    @Autowired\n+    protected PolicyDAO policyDAO;\n+\n+    /**\n+     * Entitlement DAO.\n+     */\n+    @Autowired\n+    protected EntitlementDAO entitlementDAO;\n+\n+    /**\n+     * Schema DAO.\n+     */\n+    @Autowired\n+    protected SchemaDAO schemaDAO;\n+\n+    /**\n+     * User DAO.\n+     */\n+    @Autowired\n+    protected UserDAO userDAO;\n+\n+    /**\n+     * Role DAO.\n+     */\n+    @Autowired\n+    protected RoleDAO roleDAO;\n+\n+    /**\n+     * Search DAO.\n+     */\n+    @Autowired\n+    protected SubjectSearchDAO searchDAO;\n+\n+    public Long findMatchingAttributableId(\n+            final ObjectClass oclass,\n+            final String name,\n+            final ExternalResource resource,\n+            final Connector connector) {\n+        Long result = null;\n+\n+        final AttributableUtil attrUtil = AttributableUtil.getInstance(oclass);\n+\n+        final List<ConnectorObject> found = connector.search(oclass,\n+                new EqualsFilter(new Name(name)), connector.getOperationOptions(\n+                attrUtil.getMappingItems(resource, MappingPurpose.SYNCHRONIZATION)));\n+\n+        if (found.isEmpty()) {\n+            LOG.debug(\"No {} found on {} with __NAME__ {}\", oclass, resource, name);\n+        } else {\n+            if (found.size() > 1) {\n+                LOG.warn(\"More than one {} found on {} with __NAME__ {} - taking first only\", oclass, resource, name);\n+            }\n+\n+            ConnectorObject connObj = found.iterator().next();\n+            final List<Long> subjectIds = findExisting(connObj.getUid().getUidValue(), connObj, resource, attrUtil);\n+            if (subjectIds.isEmpty()) {\n+                LOG.debug(\"No matching {} found for {}, aborting\", attrUtil.getType(), connObj);\n+            } else {\n+                if (subjectIds.size() > 1) {\n+                    LOG.warn(\"More than one {} found {} - taking first only\", attrUtil.getType(), subjectIds);\n+                }\n+\n+                result = subjectIds.iterator().next();\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    public List<Long> findByAccountIdItem(\n+            final String uid, final ExternalResource resource, final AttributableUtil attrUtil) {\n+        final List<Long> result = new ArrayList<Long>();\n+\n+        final AbstractMappingItem accountIdItem = attrUtil.getAccountIdItem(resource);\n+        switch (accountIdItem.getIntMappingType()) {\n+            case UserSchema:\n+            case RoleSchema:\n+                final AbstractAttrValue value = attrUtil.newAttrValue();\n+\n+                AbstractNormalSchema schema = schemaDAO.find(accountIdItem.getIntAttrName(), attrUtil.schemaClass());\n+                if (schema == null) {\n+                    value.setStringValue(uid);\n+                } else {\n+                    try {\n+                        value.parseValue(schema, uid);\n+                    } catch (ParsingValidationException e) {\n+                        LOG.error(\"While parsing provided __UID__ {}\", uid, e);\n+                        value.setStringValue(uid);\n+                    }\n+                }\n+\n+                List<AbstractSubject> subjects =\n+                        userDAO.findByAttrValue(accountIdItem.getIntAttrName(), value, attrUtil);\n+                for (AbstractSubject subject : subjects) {\n+                    result.add(subject.getId());\n+                }\n+                break;\n+\n+            case UserDerivedSchema:\n+            case RoleDerivedSchema:\n+                subjects = userDAO.findByDerAttrValue(accountIdItem.getIntAttrName(), uid, attrUtil);\n+                for (AbstractSubject subject : subjects) {\n+                    result.add(subject.getId());\n+                }\n+                break;\n+\n+            case Username:\n+                SyncopeUser user = userDAO.find(uid);\n+                if (user != null) {\n+                    result.add(user.getId());\n+                }\n+                break;\n+\n+            case UserId:\n+                user = userDAO.find(Long.parseLong(uid));\n+                if (user != null) {\n+                    result.add(user.getId());\n+                }\n+                break;\n+\n+            case RoleName:\n+                List<SyncopeRole> roles = roleDAO.find(uid);\n+                for (SyncopeRole role : roles) {\n+                    result.add(role.getId());\n+                }\n+                break;\n+\n+            case RoleId:\n+                SyncopeRole role = roleDAO.find(Long.parseLong(uid));\n+                if (role != null) {\n+                    result.add(role.getId());\n+                }\n+                break;\n+\n+            default:\n+                LOG.error(\"Invalid accountId type '{}'\", accountIdItem.getIntMappingType());\n+        }\n+\n+        return result;\n+    }\n+\n+    public List<Long> search(final SearchCond searchCond, final SubjectType type) {\n+        final List<Long> result = new ArrayList<Long>();\n+\n+        final List<AbstractSubject> subjects = searchDAO.search(\n+                EntitlementUtil.getRoleIds(entitlementDAO.findAll()),\n+                searchCond, Collections.<OrderByClause>emptyList(), type);\n+        for (AbstractSubject subject : subjects) {\n+            result.add(subject.getId());\n+        }\n+\n+        return result;\n+    }\n+\n+    public List<Long> findByCorrelationRule(\n+            final ConnectorObject connObj, final SyncCorrelationRule rule, final SubjectType type) {\n+\n+        return search(rule.getSearchCond(connObj), type);\n+    }\n+\n+    public List<Long> findByAttributableSearch(\n+            final ConnectorObject connObj,\n+            final List<String> altSearchSchemas,\n+            final ExternalResource resource,\n+            final AttributableUtil attrUtil) {\n+\n+        // search for external attribute's name/value of each specified name\n+        final Map<String, Attribute> extValues = new HashMap<String, Attribute>();\n+\n+        for (AbstractMappingItem item : attrUtil.getMappingItems(resource, MappingPurpose.SYNCHRONIZATION)) {\n+            extValues.put(item.getIntAttrName(), connObj.getAttributeByName(item.getExtAttrName()));\n+        }\n+\n+        // search for user/role by attribute(s) specified in the policy\n+        SearchCond searchCond = null;\n+\n+        for (String schema : altSearchSchemas) {\n+            Attribute value = extValues.get(schema);\n+\n+            AttributeCond.Type type;\n+            String expression = null;\n+\n+            if (value == null || value.getValue() == null || value.getValue().isEmpty()\n+                    || (value.getValue().size() == 1 && value.getValue().get(0) == null)) {\n+                type = AttributeCond.Type.ISNULL;\n+            } else {\n+                type = AttributeCond.Type.EQ;\n+                expression = value.getValue().size() > 1\n+                        ? value.getValue().toString()\n+                        : value.getValue().get(0).toString();\n+            }\n+\n+            SearchCond nodeCond;\n+            // users: just id or username can be selected to be used\n+            // roles: just id or name can be selected to be used\n+            if (\"id\".equalsIgnoreCase(schema) || \"username\".equalsIgnoreCase(schema)\n+                    || \"name\".equalsIgnoreCase(schema)) {\n+\n+                SubjectCond cond = new SubjectCond();\n+                cond.setSchema(schema);\n+                cond.setType(type);\n+                cond.setExpression(expression);\n+\n+                nodeCond = SearchCond.getLeafCond(cond);\n+            } else {\n+                AttributeCond cond = new AttributeCond();\n+                cond.setSchema(schema);\n+                cond.setType(type);\n+                cond.setExpression(expression);\n+\n+                nodeCond = SearchCond.getLeafCond(cond);\n+            }\n+\n+            searchCond = searchCond == null\n+                    ? nodeCond\n+                    : SearchCond.getAndCond(searchCond, nodeCond);\n+        }\n+\n+        return search(searchCond, SubjectType.valueOf(attrUtil.getType().name()));\n+    }\n+\n+    /**\n+     * Find users / roles based on mapped uid value (or previous uid value, if updated).\n+     *\n+     * @param uid for finding by account id\n+     * @param connObj for finding by attribute value\n+     * @param attrUtil attributable util\n+     * @return list of matching users / roles\n+     */\n+    public List<Long> findExisting(\n+            final String uid,\n+            final ConnectorObject connObj,\n+            final ExternalResource resource,\n+            final AttributableUtil attrUtil) {\n+\n+        SyncPolicySpec syncPolicySpec = null;\n+        if (resource.getSyncPolicy() == null) {\n+            SyncPolicy globalSP = policyDAO.getGlobalSyncPolicy();\n+            if (globalSP != null) {\n+                syncPolicySpec = globalSP.<SyncPolicySpec>getSpecification();\n+            }\n+        } else {\n+            syncPolicySpec = resource.getSyncPolicy().<SyncPolicySpec>getSpecification();\n+        }\n+\n+        SyncCorrelationRule syncRule = null;\n+        List<String> altSearchSchemas = null;\n+\n+        if (syncPolicySpec != null) {\n+            syncRule = attrUtil.getCorrelationRule(syncPolicySpec);\n+            altSearchSchemas = attrUtil.getAltSearchSchemas(syncPolicySpec);\n+        }\n+\n+        return syncRule == null ? altSearchSchemas == null || altSearchSchemas.isEmpty()\n+                ? findByAccountIdItem(uid, resource, attrUtil)\n+                : findByAttributableSearch(connObj, altSearchSchemas, resource, attrUtil)\n+                : findByCorrelationRule(connObj, syncRule, SubjectType.valueOf(attrUtil.getType().name()));\n+    }\n+\n+    public Boolean readEnabled(final ConnectorObject connectorObject, final AbstractSyncTask task) {\n+        Boolean enabled = null;\n+        if (task.isSyncStatus()) {\n+            Attribute status = AttributeUtil.find(OperationalAttributes.ENABLE_NAME, connectorObject.getAttributes());\n+            if (status != null && status.getValue() != null && !status.getValue().isEmpty()) {\n+                enabled = (Boolean) status.getValue().get(0);\n+            }\n+        }\n+\n+        return enabled;\n+    }\n+}"},{"sha":"ff31051cf8ccc84e5be788f770d7addb453a2670","filename":"core/src/main/java/org/apache/syncope/core/sync/impl/AbstractSubjectPushResultHandler.java","status":"renamed","additions":56,"deletions":54,"changes":110,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/56c18fe7854e83c6d64c7c938a49793c1419cd59/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fsync%2Fimpl%2FAbstractSubjectPushResultHandler.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/56c18fe7854e83c6d64c7c938a49793c1419cd59/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fsync%2Fimpl%2FAbstractSubjectPushResultHandler.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fsync%2Fimpl%2FAbstractSubjectPushResultHandler.java?ref=56c18fe7854e83c6d64c7c938a49793c1419cd59","patch":"@@ -20,7 +20,6 @@\n \n import java.util.ArrayList;\n import java.util.Collections;\n-import java.util.HashMap;\n import java.util.HashSet;\n import java.util.Map;\n import java.util.Set;\n@@ -47,13 +46,7 @@\n import org.quartz.JobExecutionException;\n import org.springframework.transaction.annotation.Transactional;\n \n-public class SyncopePushResultHandler extends AbstractSyncopeResultHandler<PushTask, PushActions> {\n-\n-    protected Map<Long, String> roleOwnerMap = new HashMap<Long, String>();\n-\n-    public Map<Long, String> getRoleOwnerMap() {\n-        return roleOwnerMap;\n-    }\n+public abstract class AbstractSubjectPushResultHandler extends AbstractSyncopeResultHandler<PushTask, PushActions> {\n \n     @Transactional\n     public boolean handle(final AbstractSubject subject) {\n@@ -69,26 +62,27 @@ public boolean handle(final AbstractSubject subject) {\n     protected final void doHandle(final AbstractSubject subject)\n             throws JobExecutionException {\n \n-        if (results == null) {\n-            results = new ArrayList<SyncResult>();\n+        if (profile.getResults() == null) {\n+            profile.setResults(new ArrayList<SyncResult>());\n         }\n \n         final AttributableUtil attrUtil = AttributableUtil.getInstance(subject);\n \n         final SyncResult result = new SyncResult();\n-        results.add(result);\n+        profile.getResults().add(result);\n \n         result.setId(subject.getId());\n         result.setSubjectType(attrUtil.getType());\n \n         final AbstractSubjectController<?, ?> controller;\n         final AbstractSubject toBeHandled;\n+\n         final Boolean enabled;\n \n         if (attrUtil.getType() == AttributableType.USER) {\n             toBeHandled = userDataBinder.getUserFromId(subject.getId());\n             result.setName(((SyncopeUser) toBeHandled).getUsername());\n-            enabled = getSyncTask().isSyncStatus()\n+            enabled = profile.getSyncTask().isSyncStatus()\n                     ? ((SyncopeUser) toBeHandled).isSuspended() ? Boolean.FALSE : Boolean.TRUE\n                     : null;\n             controller = userController;\n@@ -100,7 +94,7 @@ protected final void doHandle(final AbstractSubject subject)\n         }\n \n         LOG.debug(\"Propagating {} with ID {} towards {}\",\n-                attrUtil.getType(), toBeHandled.getId(), getSyncTask().getResource());\n+                attrUtil.getType(), toBeHandled.getId(), profile.getSyncTask().getResource());\n \n         Object output = null;\n         Result resultStatus = null;\n@@ -120,100 +114,106 @@ protected final void doHandle(final AbstractSubject subject)\n                     null, // no membership vir attrs to be removed\n                     null, // propagate current membership vir attr values\n                     enabled, // propagate status (suspended or not) if required\n-                    getSyncTask().getResource()); // target external resource\n+                    profile.getSyncTask().getResource()); // target external resource\n \n             final ObjectClass oclass =\n                     attrUtil.getType() == AttributableType.USER ? ObjectClass.ACCOUNT : ObjectClass.GROUP;\n \n             // Try to read remote object (user / group) BEFORE any actual operation\n-            beforeObj = getRemoteObject(oclass, values.getKey(), getSyncTask().getResource().getName());\n+            beforeObj = getRemoteObject(oclass, values.getKey(), profile.getSyncTask().getResource().getName());\n \n             if (beforeObj == null) {\n-                operation = getSyncTask().getUnmatchigRule().name().toLowerCase();\n-                switch (getSyncTask().getUnmatchigRule()) {\n+                operation = profile.getSyncTask().getUnmatchigRule().name().toLowerCase();\n+                switch (profile.getSyncTask().getUnmatchigRule()) {\n                     case ASSIGN:\n                         result.setOperation(ResourceOperation.CREATE);\n-                        for (PushActions action : actions) {\n-                            action.beforeAssign(this, values, toBeHandled);\n+                        for (PushActions action : profile.getActions()) {\n+                            action.beforeAssign(this.getProfile(), values, toBeHandled);\n                         }\n                         controller.assign(\n                                 toBeHandled.getId(),\n-                                Collections.singleton(getSyncTask().getResource().getName()), true, null);\n+                                Collections.singleton(profile.getSyncTask().getResource().getName()), true, null);\n                         break;\n                     case PROVISION:\n                         result.setOperation(ResourceOperation.CREATE);\n-                        for (PushActions action : actions) {\n-                            action.beforeProvision(this, values, toBeHandled);\n+                        for (PushActions action : profile.getActions()) {\n+                            action.beforeProvision(this.getProfile(), values, toBeHandled);\n                         }\n                         controller.provision(\n                                 toBeHandled.getId(),\n-                                Collections.singleton(getSyncTask().getResource().getName()), true, null);\n+                                Collections.singleton(profile.getSyncTask().getResource().getName()), true, null);\n                         break;\n                     case UNLINK:\n                         result.setOperation(ResourceOperation.NONE);\n-                        for (PushActions action : actions) {\n-                            action.beforeUnlink(this, values, toBeHandled);\n+                        for (PushActions action : profile.getActions()) {\n+                            action.beforeUnlink(this.getProfile(), values, toBeHandled);\n                         }\n                         controller.unlink(\n-                                toBeHandled.getId(), Collections.singleton(getSyncTask().getResource().getName()));\n+                                toBeHandled.getId(), Collections.\n+                                singleton(profile.getSyncTask().getResource().getName()));\n                         break;\n                     default:\n                     // do nothing\n                 }\n \n             } else {\n-                operation = getSyncTask().getMatchigRule().name().toLowerCase();\n-                switch (getSyncTask().getMatchigRule()) {\n+                operation = profile.getSyncTask().getMatchigRule().name().toLowerCase();\n+                switch (profile.getSyncTask().getMatchigRule()) {\n                     case UPDATE:\n                         result.setOperation(ResourceOperation.UPDATE);\n-                        for (PushActions action : actions) {\n-                            action.beforeUpdate(this, values, toBeHandled);\n+                        for (PushActions action : profile.getActions()) {\n+                            action.beforeUpdate(this.getProfile(), values, toBeHandled);\n                         }\n \n                         AbstractPropagationTaskExecutor.createOrUpdate(\n                                 oclass,\n                                 values.getKey(),\n                                 values.getValue(),\n-                                getSyncTask().getResource().getName(),\n-                                getSyncTask().getResource().getPropagationMode(),\n+                                profile.getSyncTask().getResource().getName(),\n+                                profile.getSyncTask().getResource().getPropagationMode(),\n                                 beforeObj,\n-                                connector,\n+                                profile.getConnector(),\n                                 new HashSet<String>(),\n                                 connObjectUtil);\n                         break;\n                     case DEPROVISION:\n                         result.setOperation(ResourceOperation.DELETE);\n-                        for (PushActions action : actions) {\n-                            action.beforeDeprovision(this, values, toBeHandled);\n+                        for (PushActions action : profile.getActions()) {\n+                            action.beforeDeprovision(this.getProfile(), values, toBeHandled);\n                         }\n                         controller.deprovision(\n-                                toBeHandled.getId(), Collections.singleton(getSyncTask().getResource().getName()));\n+                                toBeHandled.getId(), Collections.\n+                                singleton(profile.getSyncTask().getResource().getName()));\n                         break;\n                     case UNASSIGN:\n                         result.setOperation(ResourceOperation.DELETE);\n-                        for (PushActions action : actions) {\n-                            action.beforeUnassign(this, values, toBeHandled);\n+                        for (PushActions action : profile.getActions()) {\n+                            action.beforeUnassign(this.getProfile(), values, toBeHandled);\n                         }\n                         controller.unlink(\n-                                toBeHandled.getId(), Collections.singleton(getSyncTask().getResource().getName()));\n+                                toBeHandled.getId(), Collections.\n+                                singleton(profile.getSyncTask().getResource().getName()));\n                         controller.deprovision(\n-                                toBeHandled.getId(), Collections.singleton(getSyncTask().getResource().getName()));\n+                                toBeHandled.getId(), Collections.\n+                                singleton(profile.getSyncTask().getResource().getName()));\n                         break;\n                     case LINK:\n                         result.setOperation(ResourceOperation.NONE);\n-                        for (PushActions action : actions) {\n-                            action.beforeLink(this, values, toBeHandled);\n+                        for (PushActions action : profile.getActions()) {\n+                            action.beforeLink(this.getProfile(), values, toBeHandled);\n                         }\n                         controller.link(\n-                                toBeHandled.getId(), Collections.singleton(getSyncTask().getResource().getName()));\n+                                toBeHandled.getId(), Collections.\n+                                singleton(profile.getSyncTask().getResource().getName()));\n                         break;\n                     case UNLINK:\n                         result.setOperation(ResourceOperation.NONE);\n-                        for (PushActions action : actions) {\n-                            action.beforeUnlink(this, values, toBeHandled);\n+                        for (PushActions action : profile.getActions()) {\n+                            action.beforeUnlink(this.getProfile(), values, toBeHandled);\n                         }\n                         controller.unlink(\n-                                toBeHandled.getId(), Collections.singleton(getSyncTask().getResource().getName()));\n+                                toBeHandled.getId(), Collections.\n+                                singleton(profile.getSyncTask().getResource().getName()));\n                         break;\n                     default:\n                     // do nothing\n@@ -222,23 +222,23 @@ protected final void doHandle(final AbstractSubject subject)\n \n             result.setStatus(SyncResult.Status.SUCCESS);\n             resultStatus = AuditElements.Result.SUCCESS;\n-            output = getRemoteObject(oclass, values.getKey(), getSyncTask().getResource().getName());\n+            output = getRemoteObject(oclass, values.getKey(), profile.getSyncTask().getResource().getName());\n         } catch (Exception e) {\n             result.setStatus(SyncResult.Status.FAILURE);\n             result.setMessage(e.getMessage());\n             resultStatus = AuditElements.Result.FAILURE;\n             output = e;\n \n-            LOG.warn(\"Error pushing {} towards {}\", toBeHandled, getSyncTask().getResource(), e);\n+            LOG.warn(\"Error pushing {} towards {}\", toBeHandled, profile.getSyncTask().getResource(), e);\n             throw new JobExecutionException(e);\n         } finally {\n-            for (PushActions action : actions) {\n-                action.after(this, values, toBeHandled, result);\n+            for (PushActions action : profile.getActions()) {\n+                action.after(this.getProfile(), values, toBeHandled, result);\n             }\n             notificationManager.createTasks(\n                     AuditElements.EventCategoryType.PUSH,\n                     AttributableType.USER.name().toLowerCase(),\n-                    syncTask.getResource().getName(),\n+                    profile.getSyncTask().getResource().getName(),\n                     operation,\n                     resultStatus,\n                     beforeObj,\n@@ -247,7 +247,7 @@ protected final void doHandle(final AbstractSubject subject)\n             auditManager.audit(\n                     AuditElements.EventCategoryType.PUSH,\n                     AttributableType.USER.name().toLowerCase(),\n-                    syncTask.getResource().getName(),\n+                    profile.getSyncTask().getResource().getName(),\n                     operation,\n                     resultStatus,\n                     beforeObj,\n@@ -264,8 +264,10 @@ private ConnectorObject getRemoteObject(\n \n             final Uid uid = new Uid(accountId);\n \n-            connector.getObject(\n-                    oclass, uid, connector.getOperationOptions(Collections.<AbstractMappingItem>emptySet()));\n+            profile.getConnector().getObject(\n+                    oclass,\n+                    uid,\n+                    profile.getConnector().getOperationOptions(Collections.<AbstractMappingItem>emptySet()));\n \n         } catch (TimeoutException toe) {\n             LOG.debug(\"Request timeout\", toe);","previous_filename":"core/src/main/java/org/apache/syncope/core/sync/impl/SyncopePushResultHandler.java"},{"sha":"898df6015003bff38c645c9f0fdf503a979f4ebd","filename":"core/src/main/java/org/apache/syncope/core/sync/impl/AbstractSubjectSyncResultHandler.java","status":"added","additions":708,"deletions":0,"changes":708,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/56c18fe7854e83c6d64c7c938a49793c1419cd59/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fsync%2Fimpl%2FAbstractSubjectSyncResultHandler.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/56c18fe7854e83c6d64c7c938a49793c1419cd59/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fsync%2Fimpl%2FAbstractSubjectSyncResultHandler.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fsync%2Fimpl%2FAbstractSubjectSyncResultHandler.java?ref=56c18fe7854e83c6d64c7c938a49793c1419cd59","patch":"@@ -0,0 +1,708 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.core.sync.impl;\n+\n+import org.apache.syncope.core.sync.SyncUtilities;\n+import static org.apache.syncope.core.sync.impl.AbstractSyncopeResultHandler.LOG;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import org.apache.syncope.common.mod.AbstractSubjectMod;\n+import org.apache.syncope.common.to.AbstractSubjectTO;\n+import org.apache.syncope.common.to.RoleTO;\n+import org.apache.syncope.common.to.UserTO;\n+import org.apache.syncope.common.types.AttributableType;\n+import org.apache.syncope.common.types.AuditElements;\n+import org.apache.syncope.common.types.AuditElements.Result;\n+import org.apache.syncope.common.types.ResourceOperation;\n+import org.apache.syncope.core.persistence.beans.SyncTask;\n+import org.apache.syncope.core.persistence.dao.NotFoundException;\n+import org.apache.syncope.core.persistence.dao.UserDAO;\n+import org.apache.syncope.core.propagation.PropagationException;\n+import org.apache.syncope.core.propagation.PropagationTaskExecutor;\n+import org.apache.syncope.core.propagation.impl.PropagationManager;\n+import org.apache.syncope.core.rest.controller.AbstractSubjectController;\n+import org.apache.syncope.core.rest.controller.UnauthorizedRoleException;\n+import org.apache.syncope.core.rest.data.AttributableTransformer;\n+import org.apache.syncope.core.sync.SyncActions;\n+import org.apache.syncope.core.sync.SyncResult;\n+import org.apache.syncope.core.util.AttributableUtil;\n+import org.identityconnectors.framework.common.objects.SyncDelta;\n+import org.identityconnectors.framework.common.objects.SyncDeltaType;\n+import org.identityconnectors.framework.common.objects.SyncResultsHandler;\n+import org.quartz.JobExecutionException;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+public abstract class AbstractSubjectSyncResultHandler extends AbstractSyncopeResultHandler<SyncTask, SyncActions>\n+        implements SyncResultsHandler {\n+\n+    @Autowired\n+    protected SyncUtilities syncUtilities;\n+\n+    @Autowired\n+    protected PropagationManager propagationManager;\n+\n+    @Autowired\n+    protected PropagationTaskExecutor taskExecutor;\n+\n+    @Autowired\n+    protected AttributableTransformer attrTransformer;\n+\n+    @Autowired\n+    protected UserDAO userDAO;\n+\n+    protected abstract AttributableUtil getAttributableUtil();\n+\n+    protected abstract String getName(\n+            final AbstractSubjectTO subjectTO);\n+\n+    protected abstract AbstractSubjectTO getSubjectTO(\n+            final long id);\n+\n+    protected abstract AbstractSubjectMod getSubjectMod(\n+            final AbstractSubjectTO subjectTO, final SyncDelta delta);\n+\n+    protected abstract AbstractSubjectTO create(\n+            final AbstractSubjectTO subjectTO,\n+            final SyncDelta _delta,\n+            final SyncResult result);\n+\n+    protected abstract AbstractSubjectTO update(\n+            final AbstractSubjectTO before,\n+            final AbstractSubjectMod subjectMod,\n+            final SyncDelta delta,\n+            final SyncResult result)\n+            throws Exception;\n+\n+    protected abstract void delete(final Long id);\n+\n+    @Override\n+    public boolean handle(final SyncDelta delta) {\n+        try {\n+            if (profile.getResults() == null) {\n+                profile.setResults(new ArrayList<SyncResult>());\n+            }\n+\n+            doHandle(delta, profile.getResults());\n+            return true;\n+        } catch (JobExecutionException e) {\n+            LOG.error(\"Synchronization failed\", e);\n+            return false;\n+        }\n+    }\n+\n+    protected List<SyncResult> assign(\n+            final SyncDelta delta, final AttributableUtil attrUtil, final boolean dryRun)\n+            throws JobExecutionException {\n+\n+        final AbstractSubjectTO subjectTO =\n+                connObjectUtil.getSubjectTO(delta.getObject(), profile.getSyncTask(), attrUtil);\n+\n+        subjectTO.getResources().add(profile.getSyncTask().getResource().getName());\n+\n+        SyncDelta _delta = delta;\n+        for (SyncActions action : profile.getActions()) {\n+            _delta = action.beforeAssign(this.getProfile(), _delta, subjectTO);\n+        }\n+\n+        return create(subjectTO, _delta, attrUtil, \"assign\", dryRun);\n+    }\n+\n+    protected List<SyncResult> create(\n+            final SyncDelta delta, final AttributableUtil attrUtil, final boolean dryRun)\n+            throws JobExecutionException {\n+\n+        final AbstractSubjectTO subjectTO =\n+                connObjectUtil.getSubjectTO(delta.getObject(), profile.getSyncTask(), attrUtil);\n+\n+        return create(subjectTO, delta, attrUtil, \"provision\", dryRun);\n+    }\n+\n+    private List<SyncResult> create(\n+            final AbstractSubjectTO subjectTO,\n+            final SyncDelta delta,\n+            final AttributableUtil attrUtil,\n+            final String operation,\n+            final boolean dryRun)\n+            throws JobExecutionException {\n+\n+        if (!profile.getSyncTask().isPerformCreate()) {\n+            LOG.debug(\"SyncTask not configured for create\");\n+            return Collections.<SyncResult>emptyList();\n+        }\n+\n+        final SyncResult result = new SyncResult();\n+        result.setOperation(ResourceOperation.CREATE);\n+        result.setSubjectType(attrUtil.getType());\n+        result.setStatus(SyncResult.Status.SUCCESS);\n+\n+        // Attributable transformation (if configured)\n+        AbstractSubjectTO actual = attrTransformer.transform(subjectTO);\n+        LOG.debug(\"Transformed: {}\", actual);\n+\n+        result.setName(getName(actual));\n+\n+        if (dryRun) {\n+            result.setId(0L);\n+        } else {\n+            SyncDelta _delta = delta;\n+            for (SyncActions action : profile.getActions()) {\n+                _delta = action.beforeCreate(this.getProfile(), _delta, subjectTO);\n+            }\n+\n+            Object output;\n+            Result resultStatus;\n+\n+            try {\n+                actual = create(actual, _delta, result);\n+                output = actual;\n+                resultStatus = Result.SUCCESS;\n+            } catch (PropagationException e) {\n+                // A propagation failure doesn't imply a synchronization failure.\n+                // The propagation exception status will be reported into the propagation task execution.\n+                LOG.error(\"Could not propagate {} {}\", attrUtil.getType(), _delta.getUid().getUidValue(), e);\n+                output = e;\n+                resultStatus = Result.FAILURE;\n+            } catch (Exception e) {\n+                result.setStatus(SyncResult.Status.FAILURE);\n+                result.setMessage(e.getMessage());\n+                LOG.error(\"Could not create {} {} \", attrUtil.getType(), _delta.getUid().getUidValue(), e);\n+                output = e;\n+                resultStatus = Result.FAILURE;\n+            }\n+\n+            for (SyncActions action : profile.getActions()) {\n+                action.after(this.getProfile(), _delta, actual, result);\n+            }\n+\n+            notificationManager.createTasks(\n+                    AuditElements.EventCategoryType.SYNCHRONIZATION,\n+                    AttributableType.USER.name().toLowerCase(),\n+                    profile.getSyncTask().getResource().getName(),\n+                    operation,\n+                    resultStatus,\n+                    null,\n+                    output,\n+                    _delta);\n+\n+            auditManager.audit(\n+                    AuditElements.EventCategoryType.SYNCHRONIZATION,\n+                    AttributableType.USER.name().toLowerCase(),\n+                    profile.getSyncTask().getResource().getName(),\n+                    operation,\n+                    resultStatus,\n+                    null,\n+                    output,\n+                    _delta);\n+        }\n+\n+        return Collections.singletonList(result);\n+    }\n+\n+    protected List<SyncResult> update(SyncDelta delta, final List<Long> subjects, final AttributableUtil attrUtil,\n+            final boolean dryRun)\n+            throws JobExecutionException {\n+\n+        if (!profile.getSyncTask().isPerformUpdate()) {\n+            LOG.debug(\"SyncTask not configured for update\");\n+            return Collections.<SyncResult>emptyList();\n+        }\n+\n+        LOG.debug(\"About to update {}\", subjects);\n+\n+        List<SyncResult> updResults = new ArrayList<SyncResult>();\n+\n+        for (Long id : subjects) {\n+            LOG.debug(\"About to update {}\", id);\n+\n+            Object output;\n+            AbstractSubjectTO before = null;\n+            Result resultStatus;\n+\n+            final SyncResult result = new SyncResult();\n+            result.setOperation(ResourceOperation.UPDATE);\n+            result.setSubjectType(attrUtil.getType());\n+            result.setStatus(SyncResult.Status.SUCCESS);\n+            result.setId(id);\n+\n+            try {\n+                before = userDataBinder.getUserTO(id);\n+\n+                if (dryRun) {\n+                    output = before;\n+                } else {\n+\n+                    final AbstractSubjectMod attributableMod = getSubjectMod(before, delta);\n+\n+                    // Attribute value transformation (if configured)\n+                    final AbstractSubjectMod actual = attrTransformer.transform(attributableMod);\n+                    LOG.debug(\"Transformed: {}\", actual);\n+\n+                    for (SyncActions action : profile.getActions()) {\n+                        delta = action.beforeUpdate(this.getProfile(), delta, before, attributableMod);\n+                    }\n+\n+                    final AbstractSubjectTO updated = update(before, attributableMod, delta, result);\n+\n+                    for (SyncActions action : profile.getActions()) {\n+                        action.after(this.getProfile(), delta, updated, result);\n+                    }\n+\n+                    output = updated;\n+                }\n+\n+                resultStatus = Result.SUCCESS;\n+            } catch (PropagationException e) {\n+                // A propagation failure doesn't imply a synchronization failure.\n+                // The propagation exception status will be reported into the propagation task execution.\n+                LOG.error(\"Could not propagate {} {}\", attrUtil.getType(), delta.getUid().getUidValue(), e);\n+                output = e;\n+                resultStatus = Result.FAILURE;\n+            } catch (Exception e) {\n+                result.setStatus(SyncResult.Status.FAILURE);\n+                result.setMessage(e.getMessage());\n+                LOG.error(\"Could not update {} {}\", attrUtil.getType(), delta.getUid().getUidValue(), e);\n+                output = e;\n+                resultStatus = Result.FAILURE;\n+            }\n+            updResults.add(result);\n+\n+            if (!dryRun) {\n+                notificationManager.createTasks(\n+                        AuditElements.EventCategoryType.SYNCHRONIZATION,\n+                        attrUtil.getType().name().toLowerCase(),\n+                        profile.getSyncTask().getResource().getName(),\n+                        \"update\",\n+                        resultStatus,\n+                        before,\n+                        output,\n+                        delta);\n+\n+                auditManager.audit(\n+                        AuditElements.EventCategoryType.SYNCHRONIZATION,\n+                        attrUtil.getType().name().toLowerCase(),\n+                        profile.getSyncTask().getResource().getName(),\n+                        \"update\",\n+                        resultStatus,\n+                        before,\n+                        output,\n+                        delta);\n+            }\n+\n+            LOG.debug(\"{} {} successfully updated\", attrUtil.getType(), id);\n+        }\n+\n+        return updResults;\n+    }\n+\n+    protected List<SyncResult> deprovision(\n+            SyncDelta delta,\n+            final List<Long> subjects,\n+            final AttributableUtil attrUtil,\n+            final boolean unlink,\n+            final boolean dryRun)\n+            throws JobExecutionException {\n+\n+        if (!profile.getSyncTask().isPerformUpdate()) {\n+            LOG.debug(\"SyncTask not configured for update\");\n+            return Collections.<SyncResult>emptyList();\n+        }\n+\n+        LOG.debug(\"About to update {}\", subjects);\n+\n+        final List<SyncResult> updResults = new ArrayList<SyncResult>();\n+\n+        final AbstractSubjectController<?, ?> controller;\n+        if (AttributableType.USER == attrUtil.getType()) {\n+            controller = userController;\n+        } else {\n+            controller = roleController;\n+        }\n+\n+        for (Long id : subjects) {\n+            LOG.debug(\"About to unassign resource {}\", id);\n+\n+            Object output;\n+            Result resultStatus;\n+\n+            final SyncResult result = new SyncResult();\n+            result.setOperation(ResourceOperation.DELETE);\n+            result.setSubjectType(attrUtil.getType());\n+            result.setStatus(SyncResult.Status.SUCCESS);\n+            result.setId(id);\n+\n+            final AbstractSubjectTO before = controller.read(id);\n+            result.setName(before instanceof UserTO ? UserTO.class.cast(before).getUsername()\n+                    : before instanceof RoleTO ? RoleTO.class.cast(before).getName() : null);\n+\n+            try {\n+                if (!dryRun) {\n+                    if (unlink) {\n+                        for (SyncActions action : profile.getActions()) {\n+                            action.beforeUnassign(this.getProfile(), delta, before);\n+                        }\n+                        controller.unlink(\n+                                id, Collections.<String>singleton(profile.getSyncTask().getResource().getName()));\n+                    } else {\n+                        for (SyncActions action : profile.getActions()) {\n+                            action.beforeDeprovision(this.getProfile(), delta, before);\n+                        }\n+                    }\n+\n+                    controller.deprovision(\n+                            id, Collections.<String>singleton(profile.getSyncTask().getResource().getName()));\n+\n+                    output = controller.read(id);\n+                    for (SyncActions action : profile.getActions()) {\n+                        action.after(this.getProfile(), delta, AbstractSubjectTO.class.cast(output), result);\n+                    }\n+                } else {\n+                    output = before;\n+                }\n+\n+                resultStatus = Result.SUCCESS;\n+            } catch (PropagationException e) {\n+                // A propagation failure doesn't imply a synchronization failure.\n+                // The propagation exception status will be reported into the propagation task execution.\n+                LOG.error(\"Could not propagate {} {}\", attrUtil.getType(), delta.getUid().getUidValue(), e);\n+                output = e;\n+                resultStatus = Result.FAILURE;\n+            } catch (Exception e) {\n+                result.setStatus(SyncResult.Status.FAILURE);\n+                result.setMessage(e.getMessage());\n+                LOG.error(\"Could not update {} {}\", attrUtil.getType(), delta.getUid().getUidValue(), e);\n+                output = e;\n+                resultStatus = Result.FAILURE;\n+            }\n+            updResults.add(result);\n+\n+            if (!dryRun) {\n+                notificationManager.createTasks(\n+                        AuditElements.EventCategoryType.SYNCHRONIZATION,\n+                        attrUtil.getType().name().toLowerCase(),\n+                        profile.getSyncTask().getResource().getName(),\n+                        unlink ? \"unassign\" : \"deprovision\",\n+                        resultStatus,\n+                        before,\n+                        output,\n+                        delta);\n+\n+                auditManager.audit(\n+                        AuditElements.EventCategoryType.SYNCHRONIZATION,\n+                        attrUtil.getType().name().toLowerCase(),\n+                        profile.getSyncTask().getResource().getName(),\n+                        unlink ? \"unassign\" : \"deprovision\",\n+                        resultStatus,\n+                        before,\n+                        output,\n+                        delta);\n+            }\n+\n+            LOG.debug(\"{} {} successfully updated\", attrUtil.getType(), id);\n+        }\n+\n+        return updResults;\n+    }\n+\n+    protected List<SyncResult> link(\n+            SyncDelta delta,\n+            final List<Long> subjects,\n+            final AttributableUtil attrUtil,\n+            final boolean unlink,\n+            final boolean dryRun)\n+            throws JobExecutionException {\n+\n+        if (!profile.getSyncTask().isPerformUpdate()) {\n+            LOG.debug(\"SyncTask not configured for update\");\n+            return Collections.<SyncResult>emptyList();\n+        }\n+\n+        LOG.debug(\"About to update {}\", subjects);\n+\n+        final List<SyncResult> updResults = new ArrayList<SyncResult>();\n+\n+        final AbstractSubjectController<?, ?> controller;\n+        if (AttributableType.USER == attrUtil.getType()) {\n+            controller = userController;\n+        } else {\n+            controller = roleController;\n+        }\n+\n+        for (Long id : subjects) {\n+            LOG.debug(\"About to unassign resource {}\", id);\n+\n+            Object output;\n+            Result resultStatus;\n+\n+            final SyncResult result = new SyncResult();\n+            result.setOperation(ResourceOperation.NONE);\n+            result.setSubjectType(attrUtil.getType());\n+            result.setStatus(SyncResult.Status.SUCCESS);\n+            result.setId(id);\n+\n+            final AbstractSubjectTO before = controller.read(id);\n+            result.setName(before instanceof UserTO ? UserTO.class.cast(before).getUsername()\n+                    : before instanceof RoleTO ? RoleTO.class.cast(before).getName() : null);\n+\n+            try {\n+                if (!dryRun) {\n+                    if (unlink) {\n+                        for (SyncActions action : profile.getActions()) {\n+                            action.beforeUnlink(this.getProfile(), delta, before);\n+                        }\n+                        controller.unlink(\n+                                id, Collections.<String>singleton(profile.getSyncTask().getResource().getName()));\n+                    } else {\n+                        for (SyncActions action : profile.getActions()) {\n+                            action.beforeLink(this.getProfile(), delta, before);\n+                        }\n+                        controller.link(\n+                                id, Collections.<String>singleton(profile.getSyncTask().getResource().getName()));\n+                    }\n+\n+                    output = controller.read(id);\n+                    for (SyncActions action : profile.getActions()) {\n+                        action.after(this.getProfile(), delta, AbstractSubjectTO.class.cast(output), result);\n+                    }\n+                } else {\n+                    output = before;\n+                }\n+\n+                resultStatus = Result.SUCCESS;\n+            } catch (PropagationException e) {\n+                // A propagation failure doesn't imply a synchronization failure.\n+                // The propagation exception status will be reported into the propagation task execution.\n+                LOG.error(\"Could not propagate {} {}\", attrUtil.getType(), delta.getUid().getUidValue(), e);\n+                output = e;\n+                resultStatus = Result.FAILURE;\n+            } catch (Exception e) {\n+                result.setStatus(SyncResult.Status.FAILURE);\n+                result.setMessage(e.getMessage());\n+                LOG.error(\"Could not update {} {}\", attrUtil.getType(), delta.getUid().getUidValue(), e);\n+                output = e;\n+                resultStatus = Result.FAILURE;\n+            }\n+            updResults.add(result);\n+\n+            if (!dryRun) {\n+                notificationManager.createTasks(\n+                        AuditElements.EventCategoryType.SYNCHRONIZATION,\n+                        attrUtil.getType().name().toLowerCase(),\n+                        profile.getSyncTask().getResource().getName(),\n+                        unlink ? \"unlink\" : \"link\",\n+                        resultStatus,\n+                        before,\n+                        output,\n+                        delta);\n+\n+                auditManager.audit(\n+                        AuditElements.EventCategoryType.SYNCHRONIZATION,\n+                        attrUtil.getType().name().toLowerCase(),\n+                        profile.getSyncTask().getResource().getName(),\n+                        unlink ? \"unlink\" : \"link\",\n+                        resultStatus,\n+                        before,\n+                        output,\n+                        delta);\n+            }\n+\n+            LOG.debug(\"{} {} successfully updated\", attrUtil.getType(), id);\n+        }\n+\n+        return updResults;\n+    }\n+\n+    protected List<SyncResult> delete(SyncDelta delta, final List<Long> subjects, final AttributableUtil attrUtil,\n+            final boolean dryRun)\n+            throws JobExecutionException {\n+\n+        if (!profile.getSyncTask().isPerformDelete()) {\n+            LOG.debug(\"SyncTask not configured for delete\");\n+            return Collections.<SyncResult>emptyList();\n+        }\n+\n+        LOG.debug(\"About to delete {}\", subjects);\n+\n+        List<SyncResult> delResults = new ArrayList<SyncResult>();\n+\n+        for (Long id : subjects) {\n+            Object output;\n+            Result resultStatus = Result.FAILURE;\n+\n+            AbstractSubjectTO before = null;\n+            final SyncResult result = new SyncResult();\n+\n+            try {\n+                before = getSubjectTO(id);\n+\n+                result.setId(id);\n+                if (before instanceof UserTO) {\n+                    result.setName(((UserTO) before).getUsername());\n+                }\n+                if (before instanceof RoleTO) {\n+                    result.setName(((RoleTO) before).getName());\n+                }\n+                result.setOperation(ResourceOperation.DELETE);\n+                result.setSubjectType(attrUtil.getType());\n+                result.setStatus(SyncResult.Status.SUCCESS);\n+\n+                if (!dryRun) {\n+                    for (SyncActions action : profile.getActions()) {\n+                        delta = action.beforeDelete(this.getProfile(), delta, before);\n+                    }\n+\n+                    try {\n+                        delete(id);\n+                        output = null;\n+                        resultStatus = Result.SUCCESS;\n+                    } catch (Exception e) {\n+                        result.setStatus(SyncResult.Status.FAILURE);\n+                        result.setMessage(e.getMessage());\n+                        LOG.error(\"Could not delete {} {}\", attrUtil.getType(), id, e);\n+                        output = e;\n+                    }\n+\n+                    for (SyncActions action : profile.getActions()) {\n+                        action.after(this.getProfile(), delta, before, result);\n+                    }\n+\n+                    notificationManager.createTasks(\n+                            AuditElements.EventCategoryType.SYNCHRONIZATION,\n+                            attrUtil.getType().name().toLowerCase(),\n+                            profile.getSyncTask().getResource().getName(),\n+                            \"delete\",\n+                            resultStatus,\n+                            before,\n+                            output,\n+                            delta);\n+\n+                    auditManager.audit(\n+                            AuditElements.EventCategoryType.SYNCHRONIZATION,\n+                            attrUtil.getType().name().toLowerCase(),\n+                            profile.getSyncTask().getResource().getName(),\n+                            \"delete\",\n+                            resultStatus,\n+                            before,\n+                            output,\n+                            delta);\n+                }\n+\n+                delResults.add(result);\n+\n+            } catch (NotFoundException e) {\n+                LOG.error(\"Could not find {} {}\", attrUtil.getType(), id, e);\n+            } catch (UnauthorizedRoleException e) {\n+                LOG.error(\"Not allowed to read {} {}\", attrUtil.getType(), id, e);\n+            } catch (Exception e) {\n+                LOG.error(\"Could not delete {} {}\", attrUtil.getType(), id, e);\n+            }\n+        }\n+\n+        return delResults;\n+    }\n+\n+    /**\n+     * Look into SyncDelta and take necessary profile.getActions() (create / update / delete) on user(s)/role(s).\n+     *\n+     * @param delta returned by the underlying profile.getConnector()\n+     * @throws JobExecutionException in case of synchronization failure.\n+     */\n+    protected final void doHandle(final SyncDelta delta, final Collection<SyncResult> syncResults)\n+            throws JobExecutionException {\n+\n+        final AttributableUtil attrUtil = getAttributableUtil();\n+\n+        LOG.debug(\"Process {} for {} as {}\",\n+                delta.getDeltaType(), delta.getUid().getUidValue(), delta.getObject().getObjectClass());\n+\n+        final String uid = delta.getPreviousUid() == null\n+                ? delta.getUid().getUidValue()\n+                : delta.getPreviousUid().getUidValue();\n+\n+        try {\n+            List<Long> subjectIds = syncUtilities.findExisting(\n+                    uid, delta.getObject(), profile.getSyncTask().getResource(), attrUtil);\n+\n+            if (subjectIds.size() > 1) {\n+                switch (profile.getResAct()) {\n+                    case IGNORE:\n+                        throw new IllegalStateException(\"More than one match \" + subjectIds);\n+\n+                    case FIRSTMATCH:\n+                        subjectIds = subjectIds.subList(0, 1);\n+                        break;\n+\n+                    case LASTMATCH:\n+                        subjectIds = subjectIds.subList(subjectIds.size() - 1, subjectIds.size());\n+                        break;\n+\n+                    default:\n+                    // keep subjectIds as is\n+                }\n+            }\n+\n+            if (SyncDeltaType.CREATE_OR_UPDATE == delta.getDeltaType()) {\n+                if (subjectIds.isEmpty()) {\n+                    switch (profile.getSyncTask().getUnmatchigRule()) {\n+                        case ASSIGN:\n+                            profile.getResults().addAll(assign(delta, attrUtil, profile.isDryRun()));\n+                            break;\n+                        case PROVISION:\n+                            profile.getResults().addAll(create(delta, attrUtil, profile.isDryRun()));\n+                            break;\n+                        default:\n+                        // do nothing\n+                    }\n+                } else {\n+                    switch (profile.getSyncTask().getMatchigRule()) {\n+                        case UPDATE:\n+                            profile.getResults().addAll(update(delta, subjectIds, attrUtil, profile.isDryRun()));\n+                            break;\n+                        case DEPROVISION:\n+                            profile.getResults().addAll(\n+                                    deprovision(delta, subjectIds, attrUtil, false, profile.isDryRun()));\n+                            break;\n+                        case UNASSIGN:\n+                            profile.getResults().addAll(\n+                                    deprovision(delta, subjectIds, attrUtil, true, profile.isDryRun()));\n+                            break;\n+                        case LINK:\n+                            profile.getResults().addAll(link(delta, subjectIds, attrUtil, false, profile.isDryRun()));\n+                            break;\n+                        case UNLINK:\n+                            profile.getResults().addAll(link(delta, subjectIds, attrUtil, true, profile.isDryRun()));\n+                            break;\n+                        default:\n+                        // do nothing\n+                    }\n+                }\n+            } else if (SyncDeltaType.DELETE == delta.getDeltaType()) {\n+                if (subjectIds.isEmpty()) {\n+                    LOG.debug(\"No match found for deletion\");\n+                } else {\n+                    profile.getResults().addAll(delete(delta, subjectIds, attrUtil, profile.isDryRun()));\n+                }\n+            }\n+        } catch (IllegalStateException e) {\n+            LOG.warn(e.getMessage());\n+        }\n+    }\n+}"},{"sha":"ab900f969e71b344dbac7745b990cfe1df7bac16","filename":"core/src/main/java/org/apache/syncope/core/sync/impl/AbstractSyncopeResultHandler.java","status":"modified","additions":9,"deletions":63,"changes":72,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/56c18fe7854e83c6d64c7c938a49793c1419cd59/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fsync%2Fimpl%2FAbstractSyncopeResultHandler.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/56c18fe7854e83c6d64c7c938a49793c1419cd59/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fsync%2Fimpl%2FAbstractSyncopeResultHandler.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fsync%2Fimpl%2FAbstractSyncopeResultHandler.java?ref=56c18fe7854e83c6d64c7c938a49793c1419cd59","patch":"@@ -18,20 +18,16 @@\n  */\n package org.apache.syncope.core.sync.impl;\n \n-import java.util.Collection;\n-import java.util.List;\n-import org.apache.syncope.common.types.ConflictResolutionAction;\n+import org.apache.syncope.core.sync.SyncProfile;\n import org.apache.syncope.core.audit.AuditManager;\n import org.apache.syncope.core.connid.ConnObjectUtil;\n import org.apache.syncope.core.notification.NotificationManager;\n import org.apache.syncope.core.persistence.beans.AbstractSyncTask;\n-import org.apache.syncope.core.propagation.Connector;\n import org.apache.syncope.core.rest.controller.RoleController;\n import org.apache.syncope.core.rest.controller.UserController;\n import org.apache.syncope.core.rest.data.RoleDataBinder;\n import org.apache.syncope.core.rest.data.UserDataBinder;\n import org.apache.syncope.core.sync.AbstractSyncActions;\n-import org.apache.syncope.core.sync.SyncResult;\n import org.apache.syncope.core.workflow.role.RoleWorkflowAdapter;\n import org.apache.syncope.core.workflow.user.UserWorkflowAdapter;\n import org.slf4j.Logger;\n@@ -45,13 +41,12 @@\n      */\n     protected static final Logger LOG = LoggerFactory.getLogger(AbstractSyncopeResultHandler.class);\n \n-    \n     @Autowired\n     protected UserController userController;\n \n     @Autowired\n     protected RoleController roleController;\n-    \n+\n     /**\n      * User data binder.\n      */\n@@ -95,65 +90,16 @@\n     protected RoleWorkflowAdapter rwfAdapter;\n \n     /**\n-     * Syncing connector.\n+     * Sync profile.\n      */\n-    protected Connector connector;\n-\n-    protected Collection<SyncResult> results;\n-\n-    protected boolean dryRun;\n-\n-    protected ConflictResolutionAction resAct;\n-\n-    protected List<A> actions;\n-\n-    protected T syncTask;\n-\n-    public List<A> getActions() {\n-        return actions;\n-    }\n-\n-    public void setActions(final List<A> actions) {\n-        this.actions = actions;\n-    }\n-\n-    public T getSyncTask() {\n-        return syncTask;\n-    }\n-\n-    public void setSyncTask(T syncTask) {\n-        this.syncTask = syncTask;\n-    }\n-\n-    public Connector getConnector() {\n-        return connector;\n-    }\n-\n-    public void setConnector(final Connector connector) {\n-        this.connector = connector;\n-    }\n-\n-    public Collection<SyncResult> getResults() {\n-        return results;\n-    }\n-\n-    public void setResults(final Collection<SyncResult> results) {\n-        this.results = results;\n-    }\n-\n-    public boolean isDryRun() {\n-        return dryRun;\n-    }\n-\n-    public void setDryRun(final boolean dryRun) {\n-        this.dryRun = dryRun;\n-    }\n+    protected SyncProfile<T, A> profile;\n \n-    public ConflictResolutionAction getResAct() {\n-        return resAct;\n+    public void setProfile(\n+            SyncProfile<T, A> profile) {\n+        this.profile = profile;\n     }\n \n-    public void setResAct(final ConflictResolutionAction resAct) {\n-        this.resAct = resAct;\n+    public SyncProfile<T, A> getProfile() {\n+        return profile;\n     }\n }"},{"sha":"ab1d9e0b9f36e0952bb7d774987957cdbaaf377b","filename":"core/src/main/java/org/apache/syncope/core/sync/impl/DBPasswordSyncActions.java","status":"modified","additions":6,"deletions":6,"changes":12,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/56c18fe7854e83c6d64c7c938a49793c1419cd59/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fsync%2Fimpl%2FDBPasswordSyncActions.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/56c18fe7854e83c6d64c7c938a49793c1419cd59/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fsync%2Fimpl%2FDBPasswordSyncActions.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fsync%2Fimpl%2FDBPasswordSyncActions.java?ref=56c18fe7854e83c6d64c7c938a49793c1419cd59","patch":"@@ -18,6 +18,7 @@\n  */\n package org.apache.syncope.core.sync.impl;\n \n+import org.apache.syncope.core.sync.SyncProfile;\n import java.util.Iterator;\n \n import org.apache.syncope.common.to.AbstractAttributableTO;\n@@ -58,16 +59,16 @@ public class DBPasswordSyncActions extends DefaultSyncActions {\n     @Transactional(readOnly = true)\n     @Override\n     public <T extends AbstractAttributableTO> SyncDelta beforeCreate(\n-            final AbstractSyncopeResultHandler<?, ?> handler,\n+            final SyncProfile<?, ?> profile,\n             final SyncDelta delta,\n             final T subject) throws JobExecutionException {\n \n         if (subject instanceof UserTO) {\n             String password = ((UserTO) subject).getPassword();\n             if (password != null) {\n-                Connector connector = handler.getConnector();\n+                Connector connector = profile.getConnector();\n                 ConnInstance connInstance = connector.getActiveConnInstance();\n-                \n+\n                 String cipherAlgorithm = getCipherAlgorithm(connInstance);\n                 if (!CLEARTEXT.equals(cipherAlgorithm)) {\n                     try {\n@@ -83,7 +84,7 @@ public <T extends AbstractAttributableTO> SyncDelta beforeCreate(\n \n         return delta;\n     }\n-    \n+\n     private String getCipherAlgorithm(ConnInstance connInstance) {\n         String cipherAlgorithm = CLEARTEXT;\n         for (Iterator<ConnConfProperty> propertyIterator = connInstance.getConfiguration().iterator();\n@@ -102,7 +103,7 @@ private String getCipherAlgorithm(ConnInstance connInstance) {\n     @Transactional(readOnly = true)\n     @Override\n     public <T extends AbstractAttributableTO> void after(\n-            final AbstractSyncopeResultHandler<?, ?> handler,\n+            final SyncProfile<?, ?> profile,\n             final SyncDelta delta,\n             final T subject,\n             final SyncResult result) throws JobExecutionException {\n@@ -116,5 +117,4 @@ public <T extends AbstractAttributableTO> void after(\n             cipher = null;\n         }\n     }\n-\n }"},{"sha":"2f67346d38fad51711fca8f78d19ebe5d443d4f8","filename":"core/src/main/java/org/apache/syncope/core/sync/impl/LDAPMembershipSyncActions.java","status":"modified","additions":22,"deletions":14,"changes":36,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/56c18fe7854e83c6d64c7c938a49793c1419cd59/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fsync%2Fimpl%2FLDAPMembershipSyncActions.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/56c18fe7854e83c6d64c7c938a49793c1419cd59/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fsync%2Fimpl%2FLDAPMembershipSyncActions.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fsync%2Fimpl%2FLDAPMembershipSyncActions.java?ref=56c18fe7854e83c6d64c7c938a49793c1419cd59","patch":"@@ -18,6 +18,8 @@\n  */\n package org.apache.syncope.core.sync.impl;\n \n+import org.apache.syncope.core.sync.SyncProfile;\n+import org.apache.syncope.core.sync.SyncUtilities;\n import java.util.Collections;\n import java.util.HashMap;\n import java.util.Iterator;\n@@ -34,6 +36,7 @@\n import org.apache.syncope.common.types.ConnConfProperty;\n import org.apache.syncope.core.audit.AuditManager;\n import org.apache.syncope.core.notification.NotificationManager;\n+import org.apache.syncope.core.persistence.beans.AbstractSyncTask;\n import org.apache.syncope.core.persistence.beans.ConnInstance;\n import org.apache.syncope.core.persistence.beans.ExternalResource;\n import org.apache.syncope.core.persistence.beans.PropagationTask;\n@@ -87,6 +90,9 @@ public class LDAPMembershipSyncActions extends DefaultSyncActions {\n     @Autowired\n     private AuditManager auditManager;\n \n+    @Autowired\n+    private SyncUtilities syncUtilities;\n+\n     protected Map<Long, Long> membersBeforeRoleUpdate = Collections.<Long, Long>emptyMap();\n \n     /**\n@@ -121,7 +127,7 @@ protected String getGroupMembershipAttrName(final Connector connector) {\n     @Transactional(readOnly = true)\n     @Override\n     public <T extends AbstractAttributableTO, K extends AbstractAttributableMod> SyncDelta beforeUpdate(\n-            final AbstractSyncopeResultHandler<?, ?> handler,\n+            final SyncProfile<?, ?> profile,\n             final SyncDelta delta,\n             final T subject,\n             final K subjectMod) throws JobExecutionException {\n@@ -139,7 +145,7 @@ public <T extends AbstractAttributableTO, K extends AbstractAttributableMod> Syn\n             }\n         }\n \n-        return super.beforeUpdate(handler, delta, subject, subjectMod);\n+        return super.beforeUpdate(profile, delta, subject, subjectMod);\n     }\n \n     /**\n@@ -255,15 +261,18 @@ protected void userUpdate(final UserMod userMod, final String resourceName) {\n      * @param roleTO role after modification performed by the handler\n      * @throws JobExecutionException if anything goes wrong\n      */\n-    protected void synchronizeMemberships(final SyncopeSyncResultHandler handler, final SyncDelta delta,\n-            final RoleTO roleTO) throws JobExecutionException {\n-\n-        final SyncTask task = handler.getSyncTask();\n+    protected void synchronizeMemberships(\n+            final SyncProfile<?, ?> profile, final SyncDelta delta, final RoleTO roleTO) throws JobExecutionException {\n+        final AbstractSyncTask task = profile.getSyncTask();\n         final ExternalResource resource = task.getResource();\n-        final Connector connector = handler.getConnector();\n+        final Connector connector = profile.getConnector();\n \n         for (Object membValue : getMembAttrValues(delta, connector)) {\n-            Long userId = handler.findMatchingAttributableId(ObjectClass.ACCOUNT, membValue.toString());\n+            Long userId = syncUtilities.findMatchingAttributableId(\n+                    ObjectClass.ACCOUNT,\n+                    membValue.toString(),\n+                    profile.getSyncTask().getResource(),\n+                    profile.getConnector());\n             if (userId != null) {\n                 UserMod userMod = getUserMod(userId, roleTO);\n                 userUpdate(userMod, resource.getName());\n@@ -285,20 +294,19 @@ protected void synchronizeMemberships(final SyncopeSyncResultHandler handler, fi\n      */\n     @Override\n     public <T extends AbstractAttributableTO> void after(\n-            final AbstractSyncopeResultHandler<?, ?> handler,\n+            final SyncProfile<?, ?> profile,\n             final SyncDelta delta,\n             final T subject,\n             final SyncResult result) throws JobExecutionException {\n \n-        if (!(handler instanceof SyncopeSyncResultHandler)) {\n+        if (!(profile.getSyncTask() instanceof SyncTask)) {\n             return;\n         }\n \n-        SyncopeSyncResultHandler intHandler = (SyncopeSyncResultHandler) handler;\n-        if (!(subject instanceof RoleTO) || intHandler.getSyncTask().getResource().getUmapping() == null) {\n-            super.after(handler, delta, subject, result);\n+        if (!(subject instanceof RoleTO) || profile.getSyncTask().getResource().getUmapping() == null) {\n+            super.after(profile, delta, subject, result);\n         } else {\n-            synchronizeMemberships(intHandler, delta, (RoleTO) subject);\n+            synchronizeMemberships(profile, delta, (RoleTO) subject);\n         }\n     }\n }"},{"sha":"f9c45554150a5d2a2bec8e7bbb590ced50a80a7d","filename":"core/src/main/java/org/apache/syncope/core/sync/impl/LDAPPasswordSyncActions.java","status":"modified","additions":3,"deletions":3,"changes":6,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/56c18fe7854e83c6d64c7c938a49793c1419cd59/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fsync%2Fimpl%2FLDAPPasswordSyncActions.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/56c18fe7854e83c6d64c7c938a49793c1419cd59/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fsync%2Fimpl%2FLDAPPasswordSyncActions.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fsync%2Fimpl%2FLDAPPasswordSyncActions.java?ref=56c18fe7854e83c6d64c7c938a49793c1419cd59","patch":"@@ -18,6 +18,7 @@\n  */\n package org.apache.syncope.core.sync.impl;\n \n+import org.apache.syncope.core.sync.SyncProfile;\n import org.apache.syncope.common.to.AbstractAttributableTO;\n import org.apache.syncope.common.to.UserTO;\n import org.apache.syncope.common.types.CipherAlgorithm;\n@@ -52,7 +53,7 @@ public class LDAPPasswordSyncActions extends DefaultSyncActions {\n     @Transactional(readOnly = true)\n     @Override\n     public <T extends AbstractAttributableTO> SyncDelta beforeCreate(\n-            final AbstractSyncopeResultHandler<?, ?> handler,\n+            final SyncProfile<?, ?> profile,\n             final SyncDelta delta,\n             final T subject) throws JobExecutionException {\n \n@@ -80,7 +81,7 @@ public <T extends AbstractAttributableTO> SyncDelta beforeCreate(\n     @Transactional(readOnly = true)\n     @Override\n     public <T extends AbstractAttributableTO> void after(\n-            final AbstractSyncopeResultHandler<?, ?> handler,\n+            final SyncProfile<?, ?> profile,\n             final SyncDelta delta,\n             final T subject,\n             final SyncResult result) throws JobExecutionException {\n@@ -98,5 +99,4 @@ public <T extends AbstractAttributableTO> void after(\n             cipher = null;\n         }\n     }\n-\n }"},{"sha":"9f82ea598ced10ac06d3d06269a227b6c942d53b","filename":"core/src/main/java/org/apache/syncope/core/sync/impl/PushJob.java","status":"modified","additions":29,"deletions":15,"changes":44,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/56c18fe7854e83c6d64c7c938a49793c1419cd59/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fsync%2Fimpl%2FPushJob.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/56c18fe7854e83c6d64c7c938a49793c1419cd59/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fsync%2Fimpl%2FPushJob.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fsync%2Fimpl%2FPushJob.java?ref=56c18fe7854e83c6d64c7c938a49793c1419cd59","patch":"@@ -18,6 +18,7 @@\n  */\n package org.apache.syncope.core.sync.impl;\n \n+import org.apache.syncope.core.sync.SyncProfile;\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.List;\n@@ -87,18 +88,29 @@ protected String executeWithSecurityContext(\n \n         final Set<Long> authorizations = EntitlementUtil.getRoleIds(entitlementDAO.findAll());\n \n-        final SyncopePushResultHandler handler =\n-                (SyncopePushResultHandler) ((DefaultListableBeanFactory) ApplicationContextProvider.\n+        final SyncProfile<PushTask, PushActions> profile =\n+                new SyncProfile<PushTask, PushActions>(connector, pushTask);\n+        profile.setActions(actions);\n+        profile.setDryRun(dryRun);\n+        profile.setResAct(syncPolicySpec.getConflictResolutionAction());\n+        profile.setResults(results);\n+\n+        final UserPushResultHandler uhandler =\n+                (UserPushResultHandler) ((DefaultListableBeanFactory) ApplicationContextProvider.\n+                getApplicationContext().getBeanFactory()).createBean(\n+                UserPushResultHandler.class, AbstractBeanDefinition.AUTOWIRE_BY_NAME, false);\n+        uhandler.setProfile(profile);\n+\n+        final RolePushResultHandler rhandler =\n+                (RolePushResultHandler) ((DefaultListableBeanFactory) ApplicationContextProvider.\n                 getApplicationContext().getBeanFactory()).createBean(\n-                        SyncopePushResultHandler.class, AbstractBeanDefinition.AUTOWIRE_BY_NAME, false);\n-        handler.setConnector(connector);\n-        handler.setDryRun(dryRun);\n-        handler.setResults(results);\n-        handler.setSyncTask(pushTask);\n-        handler.setActions(actions);\n-\n-        for (PushActions action : actions) {\n-            action.beforeAll(handler);\n+                RolePushResultHandler.class, AbstractBeanDefinition.AUTOWIRE_BY_NAME, false);\n+        rhandler.setProfile(profile);\n+\n+        if (!profile.isDryRun()) {\n+            for (PushActions action : actions) {\n+                action.beforeAll(profile);\n+            }\n         }\n \n         if (uMapping != null) {\n@@ -109,7 +121,7 @@ protected String executeWithSecurityContext(\n                 for (SyncopeUser localUser : localUsers) {\n                     try {\n                         // user propagation\n-                        handler.handle(localUser);\n+                        uhandler.handle(localUser);\n                     } catch (Exception e) {\n                         LOG.warn(\"Failure pushing user '{}' on '{}'\", localUser, pushTask.getResource());\n                         if (!continueOnError()) {\n@@ -126,7 +138,7 @@ protected String executeWithSecurityContext(\n             for (SyncopeRole localRole : localRoles) {\n                 try {\n                     // role propagation\n-                    handler.handle(localRole);\n+                    rhandler.handle(localRole);\n                 } catch (Exception e) {\n                     LOG.warn(\"Failure pushing role '{}' on '{}'\", localRole, pushTask.getResource());\n                     if (!continueOnError()) {\n@@ -136,8 +148,10 @@ protected String executeWithSecurityContext(\n             }\n         }\n \n-        for (PushActions action : actions) {\n-            action.afterAll(handler, results);\n+        if (!profile.isDryRun()) {\n+            for (PushActions action : actions) {\n+                action.afterAll(profile, results);\n+            }\n         }\n \n         final String result = createReport(results, pushTask.getResource().getSyncTraceLevel(), dryRun);"},{"sha":"c7975f27c54b12724d2adbd27889819f61af0671","filename":"core/src/main/java/org/apache/syncope/core/sync/impl/RolePushResultHandler.java","status":"added","additions":22,"deletions":0,"changes":22,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/56c18fe7854e83c6d64c7c938a49793c1419cd59/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fsync%2Fimpl%2FRolePushResultHandler.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/56c18fe7854e83c6d64c7c938a49793c1419cd59/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fsync%2Fimpl%2FRolePushResultHandler.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fsync%2Fimpl%2FRolePushResultHandler.java?ref=56c18fe7854e83c6d64c7c938a49793c1419cd59","patch":"@@ -0,0 +1,22 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.core.sync.impl;\n+\n+public class RolePushResultHandler extends AbstractSubjectPushResultHandler {\n+}"},{"sha":"93b952f1d75d8bfd6c98a388dec9978734e11d69","filename":"core/src/main/java/org/apache/syncope/core/sync/impl/RoleSyncResultHandler.java","status":"added","additions":150,"deletions":0,"changes":150,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/56c18fe7854e83c6d64c7c938a49793c1419cd59/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fsync%2Fimpl%2FRoleSyncResultHandler.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/56c18fe7854e83c6d64c7c938a49793c1419cd59/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fsync%2Fimpl%2FRoleSyncResultHandler.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fsync%2Fimpl%2FRoleSyncResultHandler.java?ref=56c18fe7854e83c6d64c7c938a49793c1419cd59","patch":"@@ -0,0 +1,150 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.core.sync.impl;\n+\n+import static org.apache.syncope.core.sync.impl.AbstractSyncopeResultHandler.LOG;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.syncope.common.mod.AbstractSubjectMod;\n+import org.apache.syncope.common.mod.AttributeMod;\n+import org.apache.syncope.common.mod.RoleMod;\n+import org.apache.syncope.common.to.AbstractSubjectTO;\n+import org.apache.syncope.common.to.AttributeTO;\n+import org.apache.syncope.common.to.RoleTO;\n+import org.apache.syncope.common.types.AttributableType;\n+import org.apache.syncope.core.persistence.beans.PropagationTask;\n+import org.apache.syncope.core.sync.SyncResult;\n+import org.apache.syncope.core.util.AttributableUtil;\n+import org.apache.syncope.core.util.EntitlementUtil;\n+import org.apache.syncope.core.workflow.WorkflowResult;\n+import org.identityconnectors.framework.common.objects.SyncDelta;\n+\n+public class RoleSyncResultHandler extends AbstractSubjectSyncResultHandler {\n+\n+    protected Map<Long, String> roleOwnerMap = new HashMap<Long, String>();\n+\n+    public Map<Long, String> getRoleOwnerMap() {\n+        return this.roleOwnerMap;\n+    }\n+\n+    @Override\n+    protected AttributableUtil getAttributableUtil() {\n+        return AttributableUtil.getInstance(AttributableType.ROLE);\n+    }\n+\n+    @Override\n+    protected String getName(final AbstractSubjectTO subjectTO) {\n+        return RoleTO.class.cast(subjectTO).getName();\n+    }\n+\n+    @Override\n+    protected AbstractSubjectTO getSubjectTO(final long id) {\n+        return roleDataBinder.getRoleTO(id);\n+    }\n+\n+    @Override\n+    protected AbstractSubjectMod getSubjectMod(\n+            final AbstractSubjectTO subjectTO, final SyncDelta delta) {\n+\n+        return connObjectUtil.getAttributableMod(\n+                subjectTO.getId(),\n+                delta.getObject(),\n+                subjectTO,\n+                profile.getSyncTask(),\n+                AttributableUtil.getInstance(AttributableType.ROLE));\n+    }\n+\n+    @Override\n+    protected AbstractSubjectTO create(\n+            final AbstractSubjectTO subjectTO, final SyncDelta _delta, final SyncResult result) {\n+\n+        RoleTO roleTO = RoleTO.class.cast(subjectTO);\n+\n+        WorkflowResult<Long> created = rwfAdapter.create(roleTO);\n+        AttributeTO roleOwner = roleTO.getAttrMap().get(StringUtils.EMPTY);\n+        if (roleOwner != null) {\n+            roleOwnerMap.put(created.getResult(), roleOwner.getValues().iterator().next());\n+        }\n+\n+        EntitlementUtil.extendAuthContext(created.getResult());\n+\n+        List<PropagationTask> tasks = propagationManager.getRoleCreateTaskIds(created,\n+                roleTO.getVirAttrs(), Collections.singleton(profile.getSyncTask().getResource().getName()));\n+\n+        taskExecutor.execute(tasks);\n+\n+        roleTO = roleDataBinder.getRoleTO(created.getResult());\n+\n+        result.setId(created.getResult());\n+        result.setName(getName(subjectTO));\n+\n+        return roleTO;\n+    }\n+\n+    @Override\n+    protected AbstractSubjectTO update(\n+            final AbstractSubjectTO before,\n+            final AbstractSubjectMod subjectMod,\n+            final SyncDelta delta,\n+            final SyncResult result)\n+            throws Exception {\n+\n+        RoleMod roleMod = RoleMod.class.cast(subjectMod);\n+\n+        final WorkflowResult<Long> updated = rwfAdapter.update(roleMod);\n+        String roleOwner = null;\n+        for (AttributeMod attrMod : roleMod.getAttrsToUpdate()) {\n+            if (attrMod.getSchema().isEmpty()) {\n+                roleOwner = attrMod.getValuesToBeAdded().iterator().next();\n+            }\n+        }\n+        if (roleOwner != null) {\n+            roleOwnerMap.put(updated.getResult(), roleOwner);\n+        }\n+\n+        List<PropagationTask> tasks = propagationManager.getRoleUpdateTaskIds(updated,\n+                roleMod.getVirAttrsToRemove(),\n+                roleMod.getVirAttrsToUpdate(),\n+                Collections.singleton(profile.getSyncTask().getResource().getName()));\n+\n+        taskExecutor.execute(tasks);\n+\n+        final RoleTO after = roleDataBinder.getRoleTO(updated.getResult());\n+        result.setName(getName(after));\n+\n+        return after;\n+    }\n+\n+    @Override\n+    protected void delete(Long id) {\n+        try {\n+            taskExecutor.execute(\n+                    propagationManager.getRoleDeleteTaskIds(id, profile.getSyncTask().getResource().getName()));\n+        } catch (Exception e) {\n+            // A propagation failure doesn't imply a synchronization failure.\n+            // The propagation exception status will be reported into the propagation task execution.\n+            LOG.error(\"Could not propagate user \" + id, e);\n+        }\n+\n+        rwfAdapter.delete(id);\n+    }\n+}"},{"sha":"f3cd08bac04030ae0ed8ba205a52c1cd66d5f631","filename":"core/src/main/java/org/apache/syncope/core/sync/impl/SyncJob.java","status":"modified","additions":53,"deletions":24,"changes":77,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/56c18fe7854e83c6d64c7c938a49793c1419cd59/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fsync%2Fimpl%2FSyncJob.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/56c18fe7854e83c6d64c7c938a49793c1419cd59/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fsync%2Fimpl%2FSyncJob.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fsync%2Fimpl%2FSyncJob.java?ref=56c18fe7854e83c6d64c7c938a49793c1419cd59","patch":"@@ -18,6 +18,8 @@\n  */\n package org.apache.syncope.core.sync.impl;\n \n+import org.apache.syncope.core.sync.SyncProfile;\n+import org.apache.syncope.core.sync.SyncUtilities;\n import java.util.ArrayList;\n import java.util.List;\n import java.util.Map;\n@@ -57,20 +59,33 @@ public class SyncJob extends AbstractSyncJob<SyncTask, SyncActions> {\n     @Autowired\n     private RoleWorkflowAdapter rwfAdapter;\n \n-    protected void setRoleOwners(final SyncopeSyncResultHandler handler)\n+    @Autowired\n+    protected SyncUtilities syncUtilities;\n+\n+    protected void setRoleOwners(final RoleSyncResultHandler rhandler)\n             throws UnauthorizedRoleException, NotFoundException {\n \n-        for (Map.Entry<Long, String> entry : handler.getRoleOwnerMap().entrySet()) {\n+        for (Map.Entry<Long, String> entry : rhandler.getRoleOwnerMap().entrySet()) {\n             RoleMod roleMod = new RoleMod();\n             roleMod.setId(entry.getKey());\n \n             if (StringUtils.isBlank(entry.getValue())) {\n                 roleMod.setRoleOwner(null);\n                 roleMod.setUserOwner(null);\n             } else {\n-                Long userId = handler.findMatchingAttributableId(ObjectClass.ACCOUNT, entry.getValue());\n+                Long userId = syncUtilities.findMatchingAttributableId(\n+                        ObjectClass.ACCOUNT,\n+                        entry.getValue(),\n+                        rhandler.getProfile().getSyncTask().getResource(),\n+                        rhandler.getProfile().getConnector());\n+\n                 if (userId == null) {\n-                    Long roleId = handler.findMatchingAttributableId(ObjectClass.GROUP, entry.getValue());\n+                    Long roleId = syncUtilities.findMatchingAttributableId(\n+                            ObjectClass.GROUP,\n+                            entry.getValue(),\n+                            rhandler.getProfile().getSyncTask().getResource(),\n+                            rhandler.getProfile().getConnector());\n+\n                     if (roleId != null) {\n                         roleMod.setRoleOwner(new ReferenceMod(roleId));\n                     }\n@@ -95,21 +110,33 @@ protected String executeWithSecurityContext(\n \n         final List<SyncResult> results = new ArrayList<SyncResult>();\n \n-        // Prepare handler for SyncDelta objects\n-        final SyncopeSyncResultHandler handler =\n-                (SyncopeSyncResultHandler) ((DefaultListableBeanFactory) ApplicationContextProvider.\n+        final SyncProfile<SyncTask, SyncActions> profile =\n+                new SyncProfile<SyncTask, SyncActions>(connector, syncTask);\n+        profile.setActions(actions);\n+        profile.setDryRun(dryRun);\n+        profile.setResAct(syncPolicySpec.getConflictResolutionAction());\n+        profile.setResults(results);\n+\n+        // Prepare handler for SyncDelta objects (users)\n+        final UserSyncResultHandler uhandler =\n+                (UserSyncResultHandler) ((DefaultListableBeanFactory) ApplicationContextProvider.\n                 getApplicationContext().getBeanFactory()).createBean(\n-                        SyncopeSyncResultHandler.class, AbstractBeanDefinition.AUTOWIRE_BY_NAME, false);\n-        handler.setConnector(connector);\n-        handler.setActions(actions);\n-        handler.setDryRun(dryRun);\n-        handler.setResAct(syncPolicySpec.getConflictResolutionAction());\n-        handler.setResults(results);\n-        handler.setSyncTask(syncTask);\n-\n-        for (SyncActions action : actions) {\n-            action.beforeAll(handler);\n+                UserSyncResultHandler.class, AbstractBeanDefinition.AUTOWIRE_BY_NAME, false);\n+        uhandler.setProfile(profile);\n+\n+        // Prepare handler for SyncDelta objects (roles/groups)\n+        final RoleSyncResultHandler rhandler =\n+                (RoleSyncResultHandler) ((DefaultListableBeanFactory) ApplicationContextProvider.\n+                getApplicationContext().getBeanFactory()).createBean(\n+                RoleSyncResultHandler.class, AbstractBeanDefinition.AUTOWIRE_BY_NAME, false);\n+        rhandler.setProfile(profile);\n+\n+        if (!profile.isDryRun()) {\n+            for (SyncActions action : actions) {\n+                action.beforeAll(profile);\n+            }\n         }\n+\n         try {\n             SyncToken latestUSyncToken = null;\n             if (uMapping != null && !syncTask.isFullReconciliation()) {\n@@ -122,20 +149,20 @@ protected String executeWithSecurityContext(\n \n             if (syncTask.isFullReconciliation()) {\n                 if (uMapping != null) {\n-                    connector.getAllObjects(ObjectClass.ACCOUNT, handler,\n+                    connector.getAllObjects(ObjectClass.ACCOUNT, uhandler,\n                             connector.getOperationOptions(uMapping.getItems()));\n                 }\n                 if (rMapping != null) {\n-                    connector.getAllObjects(ObjectClass.GROUP, handler,\n+                    connector.getAllObjects(ObjectClass.GROUP, rhandler,\n                             connector.getOperationOptions(rMapping.getItems()));\n                 }\n             } else {\n                 if (uMapping != null) {\n-                    connector.sync(ObjectClass.ACCOUNT, syncTask.getResource().getUsyncToken(), handler,\n+                    connector.sync(ObjectClass.ACCOUNT, syncTask.getResource().getUsyncToken(), uhandler,\n                             connector.getOperationOptions(uMapping.getItems()));\n                 }\n                 if (rMapping != null) {\n-                    connector.sync(ObjectClass.GROUP, syncTask.getResource().getRsyncToken(), handler,\n+                    connector.sync(ObjectClass.GROUP, syncTask.getResource().getRsyncToken(), rhandler,\n                             connector.getOperationOptions(rMapping.getItems()));\n                 }\n             }\n@@ -159,13 +186,15 @@ protected String executeWithSecurityContext(\n         }\n \n         try {\n-            setRoleOwners(handler);\n+            setRoleOwners(rhandler);\n         } catch (Exception e) {\n             LOG.error(\"While setting role owners\", e);\n         }\n \n-        for (SyncActions action : actions) {\n-            action.afterAll(handler, results);\n+        if (!profile.isDryRun()) {\n+            for (SyncActions action : actions) {\n+                action.afterAll(profile, results);\n+            }\n         }\n \n         final String result = createReport(results, syncTask.getResource().getSyncTraceLevel(), dryRun);"},{"sha":"bdcae0e1a188cdb694f450c6fdf97e69ba718a89","filename":"core/src/main/java/org/apache/syncope/core/sync/impl/SyncopeSyncResultHandler.java","status":"removed","additions":0,"deletions":1147,"changes":1147,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/65f506efd5e86908663228760b30a97fca51e522/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fsync%2Fimpl%2FSyncopeSyncResultHandler.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/65f506efd5e86908663228760b30a97fca51e522/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fsync%2Fimpl%2FSyncopeSyncResultHandler.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fsync%2Fimpl%2FSyncopeSyncResultHandler.java?ref=65f506efd5e86908663228760b30a97fca51e522","patch":"@@ -1,1147 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-package org.apache.syncope.core.sync.impl;\n-\n-import static org.apache.syncope.core.sync.impl.AbstractSyncopeResultHandler.LOG;\n-\n-import java.util.AbstractMap;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Map;\n-import org.apache.commons.lang3.StringUtils;\n-import org.apache.syncope.common.mod.AttributeMod;\n-import org.apache.syncope.common.mod.RoleMod;\n-import org.apache.syncope.common.mod.UserMod;\n-import org.apache.syncope.common.to.AbstractSubjectTO;\n-import org.apache.syncope.common.to.AttributeTO;\n-import org.apache.syncope.common.to.RoleTO;\n-import org.apache.syncope.common.to.UserTO;\n-import org.apache.syncope.common.types.AttributableType;\n-import org.apache.syncope.common.types.AuditElements;\n-import org.apache.syncope.common.types.AuditElements.Result;\n-import org.apache.syncope.common.types.MappingPurpose;\n-import org.apache.syncope.common.types.ResourceOperation;\n-import org.apache.syncope.common.types.SubjectType;\n-import org.apache.syncope.common.types.SyncPolicySpec;\n-import org.apache.syncope.core.persistence.beans.AbstractAttrValue;\n-import org.apache.syncope.core.persistence.beans.AbstractMappingItem;\n-import org.apache.syncope.core.persistence.beans.AbstractNormalSchema;\n-import org.apache.syncope.core.persistence.beans.AbstractSubject;\n-import org.apache.syncope.core.persistence.beans.PropagationTask;\n-import org.apache.syncope.core.persistence.beans.SyncPolicy;\n-import org.apache.syncope.core.persistence.beans.SyncTask;\n-import org.apache.syncope.core.persistence.beans.role.SyncopeRole;\n-import org.apache.syncope.core.persistence.beans.user.SyncopeUser;\n-import org.apache.syncope.core.persistence.dao.EntitlementDAO;\n-import org.apache.syncope.core.persistence.dao.NotFoundException;\n-import org.apache.syncope.core.persistence.dao.PolicyDAO;\n-import org.apache.syncope.core.persistence.dao.RoleDAO;\n-import org.apache.syncope.core.persistence.dao.SchemaDAO;\n-import org.apache.syncope.core.persistence.dao.SubjectSearchDAO;\n-import org.apache.syncope.core.persistence.dao.UserDAO;\n-import org.apache.syncope.core.persistence.dao.search.AttributeCond;\n-import org.apache.syncope.core.persistence.dao.search.OrderByClause;\n-import org.apache.syncope.core.persistence.dao.search.SearchCond;\n-import org.apache.syncope.core.persistence.dao.search.SubjectCond;\n-import org.apache.syncope.core.persistence.validation.attrvalue.ParsingValidationException;\n-import org.apache.syncope.core.propagation.PropagationByResource;\n-import org.apache.syncope.core.propagation.PropagationException;\n-import org.apache.syncope.core.propagation.PropagationTaskExecutor;\n-import org.apache.syncope.core.propagation.impl.PropagationManager;\n-import org.apache.syncope.core.rest.controller.AbstractSubjectController;\n-import org.apache.syncope.core.rest.controller.UnauthorizedRoleException;\n-import org.apache.syncope.core.rest.data.AttributableTransformer;\n-import org.apache.syncope.core.sync.SyncActions;\n-import org.apache.syncope.core.sync.SyncCorrelationRule;\n-import org.apache.syncope.core.sync.SyncResult;\n-import org.apache.syncope.core.util.AttributableUtil;\n-import org.apache.syncope.core.util.EntitlementUtil;\n-import org.apache.syncope.core.workflow.WorkflowResult;\n-import org.identityconnectors.framework.common.objects.Attribute;\n-import org.identityconnectors.framework.common.objects.AttributeUtil;\n-import org.identityconnectors.framework.common.objects.ConnectorObject;\n-import org.identityconnectors.framework.common.objects.Name;\n-import org.identityconnectors.framework.common.objects.ObjectClass;\n-import org.identityconnectors.framework.common.objects.OperationalAttributes;\n-import org.identityconnectors.framework.common.objects.SyncDelta;\n-import org.identityconnectors.framework.common.objects.SyncDeltaType;\n-import org.identityconnectors.framework.common.objects.SyncResultsHandler;\n-import org.identityconnectors.framework.common.objects.filter.EqualsFilter;\n-import org.quartz.JobExecutionException;\n-import org.springframework.beans.factory.annotation.Autowired;\n-\n-public class SyncopeSyncResultHandler extends AbstractSyncopeResultHandler<SyncTask, SyncActions>\n-        implements SyncResultsHandler {\n-\n-    /**\n-     * Policy DAO.\n-     */\n-    @Autowired\n-    protected PolicyDAO policyDAO;\n-\n-    /**\n-     * Entitlement DAO.\n-     */\n-    @Autowired\n-    protected EntitlementDAO entitlementDAO;\n-\n-    /**\n-     * Schema DAO.\n-     */\n-    @Autowired\n-    protected SchemaDAO schemaDAO;\n-\n-    /**\n-     * User DAO.\n-     */\n-    @Autowired\n-    protected UserDAO userDAO;\n-\n-    /**\n-     * Role DAO.\n-     */\n-    @Autowired\n-    protected RoleDAO roleDAO;\n-\n-    /**\n-     * Search DAO.\n-     */\n-    @Autowired\n-    protected SubjectSearchDAO searchDAO;\n-\n-    /**\n-     * Propagation Manager.\n-     */\n-    @Autowired\n-    protected PropagationManager propagationManager;\n-\n-    /**\n-     * PropagationTask executor.\n-     */\n-    @Autowired\n-    protected PropagationTaskExecutor taskExecutor;\n-\n-    @Autowired\n-    protected AttributableTransformer attrTransformer;\n-\n-    protected Map<Long, String> roleOwnerMap = new HashMap<Long, String>();\n-\n-    public Map<Long, String> getRoleOwnerMap() {\n-        return roleOwnerMap;\n-    }\n-\n-    @Override\n-    public boolean handle(final SyncDelta delta) {\n-        try {\n-            doHandle(delta);\n-            return true;\n-        } catch (JobExecutionException e) {\n-            LOG.error(\"Synchronization failed\", e);\n-            return false;\n-        }\n-    }\n-\n-    protected List<Long> findByAccountIdItem(final String uid, final AttributableUtil attrUtil) {\n-        final List<Long> result = new ArrayList<Long>();\n-\n-        final AbstractMappingItem accountIdItem = attrUtil.getAccountIdItem(syncTask.getResource());\n-        switch (accountIdItem.getIntMappingType()) {\n-            case UserSchema:\n-            case RoleSchema:\n-                final AbstractAttrValue value = attrUtil.newAttrValue();\n-\n-                AbstractNormalSchema schema = schemaDAO.find(accountIdItem.getIntAttrName(), attrUtil.schemaClass());\n-                if (schema == null) {\n-                    value.setStringValue(uid);\n-                } else {\n-                    try {\n-                        value.parseValue(schema, uid);\n-                    } catch (ParsingValidationException e) {\n-                        LOG.error(\"While parsing provided __UID__ {}\", uid, e);\n-                        value.setStringValue(uid);\n-                    }\n-                }\n-\n-                List<AbstractSubject> subjects =\n-                        userDAO.findByAttrValue(accountIdItem.getIntAttrName(), value, attrUtil);\n-                for (AbstractSubject subject : subjects) {\n-                    result.add(subject.getId());\n-                }\n-                break;\n-\n-            case UserDerivedSchema:\n-            case RoleDerivedSchema:\n-                subjects = userDAO.findByDerAttrValue(accountIdItem.getIntAttrName(), uid, attrUtil);\n-                for (AbstractSubject subject : subjects) {\n-                    result.add(subject.getId());\n-                }\n-                break;\n-\n-            case Username:\n-                SyncopeUser user = userDAO.find(uid);\n-                if (user != null) {\n-                    result.add(user.getId());\n-                }\n-                break;\n-\n-            case UserId:\n-                user = userDAO.find(Long.parseLong(uid));\n-                if (user != null) {\n-                    result.add(user.getId());\n-                }\n-                break;\n-\n-            case RoleName:\n-                List<SyncopeRole> roles = roleDAO.find(uid);\n-                for (SyncopeRole role : roles) {\n-                    result.add(role.getId());\n-                }\n-                break;\n-\n-            case RoleId:\n-                SyncopeRole role = roleDAO.find(Long.parseLong(uid));\n-                if (role != null) {\n-                    result.add(role.getId());\n-                }\n-                break;\n-\n-            default:\n-                LOG.error(\"Invalid accountId type '{}'\", accountIdItem.getIntMappingType());\n-        }\n-\n-        return result;\n-    }\n-\n-    protected List<Long> search(final SearchCond searchCond, final SubjectType type) {\n-        final List<Long> result = new ArrayList<Long>();\n-\n-        final List<AbstractSubject> subjects = searchDAO.search(\n-                EntitlementUtil.getRoleIds(entitlementDAO.findAll()),\n-                searchCond, Collections.<OrderByClause>emptyList(), type);\n-        for (AbstractSubject subject : subjects) {\n-            result.add(subject.getId());\n-        }\n-\n-        return result;\n-    }\n-\n-    protected List<Long> findByCorrelationRule(\n-            final ConnectorObject connObj, final SyncCorrelationRule rule, final SubjectType type) {\n-\n-        return search(rule.getSearchCond(connObj), type);\n-    }\n-\n-    protected List<Long> findByAttributableSearch(\n-            final ConnectorObject connObj, final List<String> altSearchSchemas, final AttributableUtil attrUtil) {\n-\n-        // search for external attribute's name/value of each specified name\n-        final Map<String, Attribute> extValues = new HashMap<String, Attribute>();\n-\n-        for (AbstractMappingItem item\n-                : attrUtil.getMappingItems(syncTask.getResource(), MappingPurpose.SYNCHRONIZATION)) {\n-\n-            extValues.put(item.getIntAttrName(), connObj.getAttributeByName(item.getExtAttrName()));\n-        }\n-\n-        // search for user/role by attribute(s) specified in the policy\n-        SearchCond searchCond = null;\n-\n-        for (String schema : altSearchSchemas) {\n-            Attribute value = extValues.get(schema);\n-\n-            AttributeCond.Type type;\n-            String expression = null;\n-\n-            if (value == null || value.getValue() == null || value.getValue().isEmpty()\n-                    || (value.getValue().size() == 1 && value.getValue().get(0) == null)) {\n-                type = AttributeCond.Type.ISNULL;\n-            } else {\n-                type = AttributeCond.Type.EQ;\n-                expression = value.getValue().size() > 1\n-                        ? value.getValue().toString()\n-                        : value.getValue().get(0).toString();\n-            }\n-\n-            SearchCond nodeCond;\n-            // users: just id or username can be selected to be used\n-            // roles: just id or name can be selected to be used\n-            if (\"id\".equalsIgnoreCase(schema) || \"username\".equalsIgnoreCase(schema)\n-                    || \"name\".equalsIgnoreCase(schema)) {\n-\n-                SubjectCond cond = new SubjectCond();\n-                cond.setSchema(schema);\n-                cond.setType(type);\n-                cond.setExpression(expression);\n-\n-                nodeCond = SearchCond.getLeafCond(cond);\n-            } else {\n-                AttributeCond cond = new AttributeCond();\n-                cond.setSchema(schema);\n-                cond.setType(type);\n-                cond.setExpression(expression);\n-\n-                nodeCond = SearchCond.getLeafCond(cond);\n-            }\n-\n-            searchCond = searchCond == null\n-                    ? nodeCond\n-                    : SearchCond.getAndCond(searchCond, nodeCond);\n-        }\n-\n-        return search(searchCond, SubjectType.valueOf(attrUtil.getType().name()));\n-    }\n-\n-    /**\n-     * Find users / roles based on mapped uid value (or previous uid value, if updated).\n-     *\n-     * @param uid for finding by account id\n-     * @param connObj for finding by attribute value\n-     * @param attrUtil attributable util\n-     * @return list of matching users / roles\n-     */\n-    protected List<Long> findExisting(final String uid, final ConnectorObject connObj,\n-            final AttributableUtil attrUtil) {\n-\n-        SyncPolicySpec syncPolicySpec = null;\n-        if (syncTask.getResource().getSyncPolicy() == null) {\n-            SyncPolicy globalSP = policyDAO.getGlobalSyncPolicy();\n-            if (globalSP != null) {\n-                syncPolicySpec = globalSP.<SyncPolicySpec>getSpecification();\n-            }\n-        } else {\n-            syncPolicySpec = syncTask.getResource().getSyncPolicy().<SyncPolicySpec>getSpecification();\n-        }\n-\n-        SyncCorrelationRule syncRule = null;\n-        List<String> altSearchSchemas = null;\n-\n-        if (syncPolicySpec != null) {\n-            syncRule = attrUtil.getCorrelationRule(syncPolicySpec);\n-            altSearchSchemas = attrUtil.getAltSearchSchemas(syncPolicySpec);\n-        }\n-\n-        return syncRule == null ? altSearchSchemas == null || altSearchSchemas.isEmpty()\n-                ? findByAccountIdItem(uid, attrUtil)\n-                : findByAttributableSearch(connObj, altSearchSchemas, attrUtil)\n-                : findByCorrelationRule(connObj, syncRule, SubjectType.valueOf(attrUtil.getType().name()));\n-    }\n-\n-    public Long findMatchingAttributableId(final ObjectClass objectClass, final String name) {\n-        Long result = null;\n-\n-        final AttributableUtil attrUtil = AttributableUtil.getInstance(objectClass);\n-\n-        final List<ConnectorObject> found = connector.search(objectClass,\n-                new EqualsFilter(new Name(name)), connector.getOperationOptions(\n-                        attrUtil.getMappingItems(syncTask.getResource(), MappingPurpose.SYNCHRONIZATION)));\n-\n-        if (found.isEmpty()) {\n-            LOG.debug(\"No {} found on {} with __NAME__ {}\", objectClass, syncTask.getResource(), name);\n-        } else {\n-            if (found.size() > 1) {\n-                LOG.warn(\"More than one {} found on {} with __NAME__ {} - taking first only\",\n-                        objectClass, syncTask.getResource(), name);\n-            }\n-\n-            ConnectorObject connObj = found.iterator().next();\n-            final List<Long> subjectIds = findExisting(connObj.getUid().getUidValue(), connObj, attrUtil);\n-            if (subjectIds.isEmpty()) {\n-                LOG.debug(\"No matching {} found for {}, aborting\", attrUtil.getType(), connObj);\n-            } else {\n-                if (subjectIds.size() > 1) {\n-                    LOG.warn(\"More than one {} found {} - taking first only\", attrUtil.getType(), subjectIds);\n-                }\n-\n-                result = subjectIds.iterator().next();\n-            }\n-        }\n-\n-        return result;\n-    }\n-\n-    protected Boolean readEnabled(final ConnectorObject connectorObject) {\n-        Boolean enabled = null;\n-        if (syncTask.isSyncStatus()) {\n-            Attribute status = AttributeUtil.find(OperationalAttributes.ENABLE_NAME, connectorObject.getAttributes());\n-            if (status != null && status.getValue() != null && !status.getValue().isEmpty()) {\n-                enabled = (Boolean) status.getValue().get(0);\n-            }\n-        }\n-\n-        return enabled;\n-    }\n-\n-    protected List<SyncResult> assign(\n-            final SyncDelta delta, final AttributableUtil attrUtil, final boolean dryRun)\n-            throws JobExecutionException {\n-\n-        final AbstractSubjectTO subjectTO = connObjectUtil.getSubjectTO(delta.getObject(), syncTask, attrUtil);\n-\n-        subjectTO.getResources().add(getSyncTask().getResource().getName());\n-\n-        SyncDelta _delta = delta;\n-        for (SyncActions action : actions) {\n-            _delta = action.beforeAssign(this, _delta, subjectTO);\n-        }\n-\n-        return create(subjectTO, _delta, attrUtil, \"assign\", dryRun);\n-    }\n-\n-    protected List<SyncResult> create(\n-            final SyncDelta delta, final AttributableUtil attrUtil, final boolean dryRun)\n-            throws JobExecutionException {\n-\n-        final AbstractSubjectTO subjectTO =\n-                connObjectUtil.getSubjectTO(delta.getObject(), syncTask, attrUtil);\n-\n-        SyncDelta _delta = delta;\n-        for (SyncActions action : actions) {\n-            _delta = action.beforeCreate(this, _delta, subjectTO);\n-        }\n-\n-        return create(subjectTO, _delta, attrUtil, \"provision\", dryRun);\n-    }\n-\n-    private List<SyncResult> create(\n-            final AbstractSubjectTO subjectTO,\n-            final SyncDelta delta,\n-            final AttributableUtil attrUtil,\n-            final String operation,\n-            final boolean dryRun)\n-            throws JobExecutionException {\n-\n-        if (!syncTask.isPerformCreate()) {\n-            LOG.debug(\"SyncTask not configured for create\");\n-            return Collections.<SyncResult>emptyList();\n-        }\n-\n-        final SyncResult result = new SyncResult();\n-        result.setOperation(ResourceOperation.CREATE);\n-        result.setSubjectType(attrUtil.getType());\n-        result.setStatus(SyncResult.Status.SUCCESS);\n-\n-        // Attributable transformation (if configured)\n-        AbstractSubjectTO actual = attrTransformer.transform(subjectTO);\n-        LOG.debug(\"Transformed: {}\", actual);\n-\n-        if (dryRun) {\n-            result.setId(0L);\n-            if (actual instanceof UserTO) {\n-                result.setName(((UserTO) actual).getUsername());\n-            }\n-            if (actual instanceof RoleTO) {\n-                result.setName(((RoleTO) actual).getName());\n-            }\n-        } else {\n-            Object output;\n-            Result resultStatus;\n-\n-            try {\n-                if (AttributableType.USER == attrUtil.getType()) {\n-                    Boolean enabled = readEnabled(delta.getObject());\n-                    WorkflowResult<Map.Entry<Long, Boolean>> created =\n-                            uwfAdapter.create((UserTO) actual, true, enabled);\n-\n-                    List<PropagationTask> tasks = propagationManager.getUserCreateTaskIds(created,\n-                            ((UserTO) actual).getPassword(), actual.getVirAttrs(),\n-                            Collections.singleton(syncTask.getResource().getName()), ((UserTO) actual).getMemberships());\n-\n-                    taskExecutor.execute(tasks);\n-\n-                    actual = userDataBinder.getUserTO(created.getResult().getKey());\n-\n-                    result.setId(created.getResult().getKey());\n-                    result.setName(((UserTO) actual).getUsername());\n-                } else if (AttributableType.ROLE == attrUtil.getType()) {\n-                    WorkflowResult<Long> created = rwfAdapter.create((RoleTO) actual);\n-                    AttributeTO roleOwner = actual.getAttrMap().get(StringUtils.EMPTY);\n-                    if (roleOwner != null) {\n-                        roleOwnerMap.put(created.getResult(), roleOwner.getValues().iterator().next());\n-                    }\n-\n-                    EntitlementUtil.extendAuthContext(created.getResult());\n-\n-                    List<PropagationTask> tasks = propagationManager.getRoleCreateTaskIds(created,\n-                            actual.getVirAttrs(), Collections.singleton(syncTask.getResource().getName()));\n-\n-                    taskExecutor.execute(tasks);\n-\n-                    actual = roleDataBinder.getRoleTO(created.getResult());\n-\n-                    result.setId(created.getResult());\n-                    result.setName(((RoleTO) actual).getName());\n-                }\n-                output = actual;\n-                resultStatus = Result.SUCCESS;\n-\n-            } catch (PropagationException e) {\n-                // A propagation failure doesn't imply a synchronization failure.\n-                // The propagation exception status will be reported into the propagation task execution.\n-                LOG.error(\"Could not propagate {} {}\", attrUtil.getType(), delta.getUid().getUidValue(), e);\n-                output = e;\n-                resultStatus = Result.FAILURE;\n-            } catch (Exception e) {\n-                result.setStatus(SyncResult.Status.FAILURE);\n-                result.setMessage(e.getMessage());\n-                LOG.error(\"Could not create {} {} \", attrUtil.getType(), delta.getUid().getUidValue(), e);\n-                output = e;\n-                resultStatus = Result.FAILURE;\n-            }\n-\n-            notificationManager.createTasks(\n-                    AuditElements.EventCategoryType.SYNCHRONIZATION,\n-                    AttributableType.USER.name().toLowerCase(),\n-                    syncTask.getResource().getName(),\n-                    operation,\n-                    resultStatus,\n-                    null,\n-                    output,\n-                    delta);\n-\n-            auditManager.audit(\n-                    AuditElements.EventCategoryType.SYNCHRONIZATION,\n-                    AttributableType.USER.name().toLowerCase(),\n-                    syncTask.getResource().getName(),\n-                    operation,\n-                    resultStatus,\n-                    null,\n-                    output,\n-                    delta);\n-        }\n-\n-        for (SyncActions action : actions) {\n-            action.after(this, delta, actual, result);\n-        }\n-        return Collections.singletonList(result);\n-    }\n-\n-    protected Map.Entry<UserTO, UserTO> updateUser(final Long id, SyncDelta delta, final boolean dryRun,\n-            final SyncResult result)\n-            throws Exception {\n-\n-        final UserTO before = userDataBinder.getUserTO(id);\n-        UserMod userMod = connObjectUtil.getAttributableMod(\n-                id, delta.getObject(), before, syncTask, AttributableUtil.getInstance(AttributableType.USER));\n-\n-        for (SyncActions action : actions) {\n-            delta = action.beforeUpdate(this, delta, before, userMod);\n-        }\n-\n-        if (dryRun) {\n-            return new AbstractMap.SimpleEntry<UserTO, UserTO>(before, before);\n-        }\n-\n-        // Attribute value transformation (if configured)\n-        UserMod actual = attrTransformer.transform(userMod);\n-        LOG.debug(\"Transformed: {}\", actual);\n-\n-        WorkflowResult<Map.Entry<UserMod, Boolean>> updated;\n-        try {\n-            updated = uwfAdapter.update(actual);\n-        } catch (Exception e) {\n-            LOG.error(\"Update of user {} failed, trying to sync its status anyway (if configured)\", id, e);\n-\n-            result.setStatus(SyncResult.Status.FAILURE);\n-            result.setMessage(\"Update failed, trying to sync status anyway (if configured)\\n\" + e.getMessage());\n-\n-            updated = new WorkflowResult<Map.Entry<UserMod, Boolean>>(\n-                    new AbstractMap.SimpleEntry<UserMod, Boolean>(userMod, false), new PropagationByResource(),\n-                    new HashSet<String>());\n-        }\n-\n-        Boolean enabled = readEnabled(delta.getObject());\n-        if (enabled != null) {\n-            SyncopeUser user = userDAO.find(id);\n-\n-            WorkflowResult<Long> enableUpdate = null;\n-            if (user.isSuspended() == null) {\n-                enableUpdate = uwfAdapter.activate(id, null);\n-            } else if (enabled && user.isSuspended()) {\n-                enableUpdate = uwfAdapter.reactivate(id);\n-            } else if (!enabled && !user.isSuspended()) {\n-                enableUpdate = uwfAdapter.suspend(id);\n-            }\n-\n-            if (enableUpdate != null) {\n-                if (enableUpdate.getPropByRes() != null) {\n-                    updated.getPropByRes().merge(enableUpdate.getPropByRes());\n-                    updated.getPropByRes().purge();\n-                }\n-                updated.getPerformedTasks().addAll(enableUpdate.getPerformedTasks());\n-            }\n-        }\n-\n-        List<PropagationTask> tasks = propagationManager.getUserUpdateTaskIds(\n-                updated, updated.getResult().getKey().getPassword() != null,\n-                Collections.singleton(syncTask.getResource().getName()));\n-\n-        taskExecutor.execute(tasks);\n-\n-        final UserTO after = userDataBinder.getUserTO(updated.getResult().getKey().getId());\n-        for (SyncActions action : actions) {\n-            action.after(this, delta, after, result);\n-        }\n-\n-        return new AbstractMap.SimpleEntry<UserTO, UserTO>(before, after);\n-    }\n-\n-    protected Map.Entry<RoleTO, RoleTO> updateRole(\n-            final Long id, SyncDelta delta, final boolean dryRun, final SyncResult result)\n-            throws Exception {\n-\n-        final RoleTO before = roleDataBinder.getRoleTO(id);\n-        RoleMod roleMod = connObjectUtil.getAttributableMod(\n-                id, delta.getObject(), before, syncTask, AttributableUtil.getInstance(AttributableType.ROLE));\n-\n-        for (SyncActions action : actions) {\n-            delta = action.beforeUpdate(this, delta, before, roleMod);\n-        }\n-\n-        if (dryRun) {\n-            return new AbstractMap.SimpleEntry<RoleTO, RoleTO>(before, before);\n-        }\n-\n-        // Attribute value transformation (if configured)\n-        RoleMod actual = attrTransformer.transform(roleMod);\n-        LOG.debug(\"Transformed: {}\", actual);\n-\n-        WorkflowResult<Long> updated = rwfAdapter.update(actual);\n-        String roleOwner = null;\n-        for (AttributeMod attrMod : actual.getAttrsToUpdate()) {\n-            if (attrMod.getSchema().isEmpty()) {\n-                roleOwner = attrMod.getValuesToBeAdded().iterator().next();\n-            }\n-        }\n-        if (roleOwner != null) {\n-            roleOwnerMap.put(updated.getResult(), roleOwner);\n-        }\n-\n-        List<PropagationTask> tasks = propagationManager.getRoleUpdateTaskIds(updated,\n-                actual.getVirAttrsToRemove(),\n-                actual.getVirAttrsToUpdate(),\n-                Collections.singleton(syncTask.getResource().getName()));\n-\n-        taskExecutor.execute(tasks);\n-\n-        final RoleTO after = roleDataBinder.getRoleTO(updated.getResult());\n-\n-        for (SyncActions action : actions) {\n-            action.after(this, delta, after, result);\n-        }\n-\n-        return new AbstractMap.SimpleEntry<RoleTO, RoleTO>(before, after);\n-    }\n-\n-    protected List<SyncResult> update(SyncDelta delta, final List<Long> subjects, final AttributableUtil attrUtil,\n-            final boolean dryRun)\n-            throws JobExecutionException {\n-\n-        if (!syncTask.isPerformUpdate()) {\n-            LOG.debug(\"SyncTask not configured for update\");\n-            return Collections.<SyncResult>emptyList();\n-        }\n-\n-        LOG.debug(\"About to update {}\", subjects);\n-\n-        List<SyncResult> updResults = new ArrayList<SyncResult>();\n-\n-        for (Long id : subjects) {\n-            LOG.debug(\"About to update {}\", id);\n-\n-            Object output;\n-            AbstractSubjectTO before = null;\n-            Result resultStatus;\n-\n-            final SyncResult result = new SyncResult();\n-            result.setOperation(ResourceOperation.UPDATE);\n-            result.setSubjectType(attrUtil.getType());\n-            result.setStatus(SyncResult.Status.SUCCESS);\n-            result.setId(id);\n-\n-            try {\n-                final AbstractSubjectTO updated;\n-                if (AttributableType.USER == attrUtil.getType()) {\n-                    final Map.Entry<UserTO, UserTO> res = updateUser(id, delta, dryRun, result);\n-                    before = res.getKey();\n-                    updated = res.getValue();\n-                    result.setName(((UserTO) updated).getUsername());\n-                } else if (AttributableType.ROLE == attrUtil.getType()) {\n-                    final Map.Entry<RoleTO, RoleTO> res = updateRole(id, delta, dryRun, result);\n-                    before = res.getKey();\n-                    updated = res.getValue();\n-                    result.setName(((RoleTO) updated).getName());\n-                } else {\n-                    updated = null;\n-                }\n-                output = updated;\n-                resultStatus = Result.SUCCESS;\n-            } catch (PropagationException e) {\n-                // A propagation failure doesn't imply a synchronization failure.\n-                // The propagation exception status will be reported into the propagation task execution.\n-                LOG.error(\"Could not propagate {} {}\", attrUtil.getType(), delta.getUid().getUidValue(), e);\n-                output = e;\n-                resultStatus = Result.FAILURE;\n-            } catch (Exception e) {\n-                result.setStatus(SyncResult.Status.FAILURE);\n-                result.setMessage(e.getMessage());\n-                LOG.error(\"Could not update {} {}\", attrUtil.getType(), delta.getUid().getUidValue(), e);\n-                output = e;\n-                resultStatus = Result.FAILURE;\n-            }\n-            updResults.add(result);\n-\n-            if (!dryRun) {\n-                notificationManager.createTasks(\n-                        AuditElements.EventCategoryType.SYNCHRONIZATION,\n-                        attrUtil.getType().name().toLowerCase(),\n-                        syncTask.getResource().getName(),\n-                        \"update\",\n-                        resultStatus,\n-                        before,\n-                        output,\n-                        delta);\n-\n-                auditManager.audit(\n-                        AuditElements.EventCategoryType.SYNCHRONIZATION,\n-                        attrUtil.getType().name().toLowerCase(),\n-                        syncTask.getResource().getName(),\n-                        \"update\",\n-                        resultStatus,\n-                        before,\n-                        output,\n-                        delta);\n-            }\n-\n-            LOG.debug(\"{} {} successfully updated\", attrUtil.getType(), id);\n-        }\n-\n-        return updResults;\n-    }\n-\n-    protected List<SyncResult> deprovision(\n-            SyncDelta delta,\n-            final List<Long> subjects,\n-            final AttributableUtil attrUtil,\n-            final boolean unlink,\n-            final boolean dryRun)\n-            throws JobExecutionException {\n-\n-        if (!syncTask.isPerformUpdate()) {\n-            LOG.debug(\"SyncTask not configured for update\");\n-            return Collections.<SyncResult>emptyList();\n-        }\n-\n-        LOG.debug(\"About to update {}\", subjects);\n-\n-        final List<SyncResult> updResults = new ArrayList<SyncResult>();\n-\n-        final AbstractSubjectController<?, ?> controller;\n-        if (AttributableType.USER == attrUtil.getType()) {\n-            controller = userController;\n-        } else {\n-            controller = roleController;\n-        }\n-\n-        for (Long id : subjects) {\n-            LOG.debug(\"About to unassign resource {}\", id);\n-\n-            Object output;\n-            Result resultStatus;\n-\n-            final SyncResult result = new SyncResult();\n-            result.setOperation(ResourceOperation.DELETE);\n-            result.setSubjectType(attrUtil.getType());\n-            result.setStatus(SyncResult.Status.SUCCESS);\n-            result.setId(id);\n-\n-            final AbstractSubjectTO before = controller.read(id);\n-            result.setName(before instanceof UserTO ? UserTO.class.cast(before).getUsername()\n-                    : before instanceof RoleTO ? RoleTO.class.cast(before).getName() : null);\n-\n-            try {\n-                if (!dryRun) {\n-                    if (unlink) {\n-                        for (SyncActions action : actions) {\n-                            action.beforeUnassign(this, delta, before);\n-                        }\n-                        controller.unlink(id, Collections.<String>singleton(getSyncTask().getResource().getName()));\n-                    } else {\n-                        for (SyncActions action : actions) {\n-                            action.beforeDeprovision(this, delta, before);\n-                        }\n-                    }\n-\n-                    controller.deprovision(id, Collections.<String>singleton(getSyncTask().getResource().getName()));\n-\n-                    output = controller.read(id);\n-                    for (SyncActions action : actions) {\n-                        action.after(this, delta, AbstractSubjectTO.class.cast(output), result);\n-                    }\n-                } else {\n-                    output = before;\n-                }\n-\n-                resultStatus = Result.SUCCESS;\n-            } catch (PropagationException e) {\n-                // A propagation failure doesn't imply a synchronization failure.\n-                // The propagation exception status will be reported into the propagation task execution.\n-                LOG.error(\"Could not propagate {} {}\", attrUtil.getType(), delta.getUid().getUidValue(), e);\n-                output = e;\n-                resultStatus = Result.FAILURE;\n-            } catch (Exception e) {\n-                result.setStatus(SyncResult.Status.FAILURE);\n-                result.setMessage(e.getMessage());\n-                LOG.error(\"Could not update {} {}\", attrUtil.getType(), delta.getUid().getUidValue(), e);\n-                output = e;\n-                resultStatus = Result.FAILURE;\n-            }\n-            updResults.add(result);\n-\n-            if (!dryRun) {\n-                notificationManager.createTasks(\n-                        AuditElements.EventCategoryType.SYNCHRONIZATION,\n-                        attrUtil.getType().name().toLowerCase(),\n-                        syncTask.getResource().getName(),\n-                        unlink ? \"unassign\" : \"deprovision\",\n-                        resultStatus,\n-                        before,\n-                        output,\n-                        delta);\n-\n-                auditManager.audit(\n-                        AuditElements.EventCategoryType.SYNCHRONIZATION,\n-                        attrUtil.getType().name().toLowerCase(),\n-                        syncTask.getResource().getName(),\n-                        unlink ? \"unassign\" : \"deprovision\",\n-                        resultStatus,\n-                        before,\n-                        output,\n-                        delta);\n-            }\n-\n-            LOG.debug(\"{} {} successfully updated\", attrUtil.getType(), id);\n-        }\n-\n-        return updResults;\n-    }\n-\n-    protected List<SyncResult> link(\n-            SyncDelta delta,\n-            final List<Long> subjects,\n-            final AttributableUtil attrUtil,\n-            final boolean unlink,\n-            final boolean dryRun)\n-            throws JobExecutionException {\n-\n-        if (!syncTask.isPerformUpdate()) {\n-            LOG.debug(\"SyncTask not configured for update\");\n-            return Collections.<SyncResult>emptyList();\n-        }\n-\n-        LOG.debug(\"About to update {}\", subjects);\n-\n-        final List<SyncResult> updResults = new ArrayList<SyncResult>();\n-\n-        final AbstractSubjectController<?, ?> controller;\n-        if (AttributableType.USER == attrUtil.getType()) {\n-            controller = userController;\n-        } else {\n-            controller = roleController;\n-        }\n-\n-        for (Long id : subjects) {\n-            LOG.debug(\"About to unassign resource {}\", id);\n-\n-            Object output;\n-            Result resultStatus;\n-\n-            final SyncResult result = new SyncResult();\n-            result.setOperation(ResourceOperation.NONE);\n-            result.setSubjectType(attrUtil.getType());\n-            result.setStatus(SyncResult.Status.SUCCESS);\n-            result.setId(id);\n-\n-            final AbstractSubjectTO before = controller.read(id);\n-            result.setName(before instanceof UserTO ? UserTO.class.cast(before).getUsername()\n-                    : before instanceof RoleTO ? RoleTO.class.cast(before).getName() : null);\n-\n-            try {\n-                if (!dryRun) {\n-                    if (unlink) {\n-                        for (SyncActions action : actions) {\n-                            action.beforeUnlink(this, delta, before);\n-                        }\n-                        controller.unlink(id, Collections.<String>singleton(getSyncTask().getResource().getName()));\n-                    } else {\n-                        for (SyncActions action : actions) {\n-                            action.beforeLink(this, delta, before);\n-                        }\n-                        controller.link(id, Collections.<String>singleton(getSyncTask().getResource().getName()));\n-                    }\n-\n-                    output = controller.read(id);\n-                    for (SyncActions action : actions) {\n-                        action.after(this, delta, AbstractSubjectTO.class.cast(output), result);\n-                    }\n-                } else {\n-                    output = before;\n-                }\n-\n-                resultStatus = Result.SUCCESS;\n-            } catch (PropagationException e) {\n-                // A propagation failure doesn't imply a synchronization failure.\n-                // The propagation exception status will be reported into the propagation task execution.\n-                LOG.error(\"Could not propagate {} {}\", attrUtil.getType(), delta.getUid().getUidValue(), e);\n-                output = e;\n-                resultStatus = Result.FAILURE;\n-            } catch (Exception e) {\n-                result.setStatus(SyncResult.Status.FAILURE);\n-                result.setMessage(e.getMessage());\n-                LOG.error(\"Could not update {} {}\", attrUtil.getType(), delta.getUid().getUidValue(), e);\n-                output = e;\n-                resultStatus = Result.FAILURE;\n-            }\n-            updResults.add(result);\n-\n-            if (!dryRun) {\n-                notificationManager.createTasks(\n-                        AuditElements.EventCategoryType.SYNCHRONIZATION,\n-                        attrUtil.getType().name().toLowerCase(),\n-                        syncTask.getResource().getName(),\n-                        unlink ? \"unlink\" : \"link\",\n-                        resultStatus,\n-                        before,\n-                        output,\n-                        delta);\n-\n-                auditManager.audit(\n-                        AuditElements.EventCategoryType.SYNCHRONIZATION,\n-                        attrUtil.getType().name().toLowerCase(),\n-                        syncTask.getResource().getName(),\n-                        unlink ? \"unlink\" : \"link\",\n-                        resultStatus,\n-                        before,\n-                        output,\n-                        delta);\n-            }\n-\n-            LOG.debug(\"{} {} successfully updated\", attrUtil.getType(), id);\n-        }\n-\n-        return updResults;\n-    }\n-\n-    protected List<SyncResult> delete(SyncDelta delta, final List<Long> subjects, final AttributableUtil attrUtil,\n-            final boolean dryRun)\n-            throws JobExecutionException {\n-\n-        if (!syncTask.isPerformDelete()) {\n-            LOG.debug(\"SyncTask not configured for delete\");\n-            return Collections.<SyncResult>emptyList();\n-        }\n-\n-        LOG.debug(\"About to delete {}\", subjects);\n-\n-        List<SyncResult> delResults = new ArrayList<SyncResult>();\n-\n-        for (Long id : subjects) {\n-            Object output = null;\n-            Result resultStatus = Result.FAILURE;\n-\n-            AbstractSubjectTO before = null;\n-\n-            try {\n-                before = AttributableType.USER == attrUtil.getType()\n-                        ? userDataBinder.getUserTO(id)\n-                        : roleDataBinder.getRoleTO(id);\n-\n-                for (SyncActions action : actions) {\n-                    delta = action.beforeDelete(this, delta, before);\n-                }\n-\n-                final SyncResult result = new SyncResult();\n-                result.setId(id);\n-                if (before instanceof UserTO) {\n-                    result.setName(((UserTO) before).getUsername());\n-                }\n-                if (before instanceof RoleTO) {\n-                    result.setName(((RoleTO) before).getName());\n-                }\n-                result.setOperation(ResourceOperation.DELETE);\n-                result.setSubjectType(attrUtil.getType());\n-                result.setStatus(SyncResult.Status.SUCCESS);\n-\n-                if (!dryRun) {\n-                    try {\n-                        List<PropagationTask> tasks = Collections.<PropagationTask>emptyList();\n-                        if (AttributableType.USER == attrUtil.getType()) {\n-                            tasks = propagationManager.getUserDeleteTaskIds(id, syncTask.getResource().getName());\n-                        } else if (AttributableType.ROLE == attrUtil.getType()) {\n-                            tasks = propagationManager.getRoleDeleteTaskIds(id, syncTask.getResource().getName());\n-                        }\n-                        taskExecutor.execute(tasks);\n-                    } catch (Exception e) {\n-                        // A propagation failure doesn't imply a synchronization failure.\n-                        // The propagation exception status will be reported into the propagation task execution.\n-                        LOG.error(\"Could not propagate user \" + id, e);\n-                    }\n-\n-                    try {\n-                        if (AttributableType.USER == attrUtil.getType()) {\n-                            uwfAdapter.delete(id);\n-                        } else if (AttributableType.ROLE == attrUtil.getType()) {\n-                            rwfAdapter.delete(id);\n-                        }\n-                        output = null;\n-                        resultStatus = Result.SUCCESS;\n-                    } catch (Exception e) {\n-                        result.setStatus(SyncResult.Status.FAILURE);\n-                        result.setMessage(e.getMessage());\n-                        LOG.error(\"Could not delete {} {}\", attrUtil.getType(), id, e);\n-                        output = e;\n-                    }\n-                }\n-\n-                for (SyncActions action : actions) {\n-                    action.after(this, delta, before, result);\n-                }\n-                delResults.add(result);\n-\n-            } catch (NotFoundException e) {\n-                LOG.error(\"Could not find {} {}\", attrUtil.getType(), id, e);\n-            } catch (UnauthorizedRoleException e) {\n-                LOG.error(\"Not allowed to read {} {}\", attrUtil.getType(), id, e);\n-            }\n-\n-            if (!dryRun) {\n-                notificationManager.createTasks(\n-                        AuditElements.EventCategoryType.SYNCHRONIZATION,\n-                        attrUtil.getType().name().toLowerCase(),\n-                        syncTask.getResource().getName(),\n-                        \"delete\",\n-                        resultStatus,\n-                        before,\n-                        output,\n-                        delta);\n-\n-                auditManager.audit(\n-                        AuditElements.EventCategoryType.SYNCHRONIZATION,\n-                        attrUtil.getType().name().toLowerCase(),\n-                        syncTask.getResource().getName(),\n-                        \"delete\",\n-                        resultStatus,\n-                        before,\n-                        output,\n-                        delta);\n-            }\n-        }\n-\n-        return delResults;\n-    }\n-\n-    /**\n-     * Look into SyncDelta and take necessary actions (create / update / delete) on user(s) / role(s).\n-     *\n-     * @param delta returned by the underlying connector\n-     * @throws JobExecutionException in case of synchronization failure.\n-     */\n-    protected final void doHandle(final SyncDelta delta)\n-            throws JobExecutionException {\n-\n-        if (results == null) {\n-            results = new ArrayList<SyncResult>();\n-        }\n-\n-        LOG.debug(\"Process {} for {} as {}\",\n-                delta.getDeltaType(), delta.getUid().getUidValue(), delta.getObject().getObjectClass());\n-\n-        AttributableUtil attrUtil = AttributableUtil.getInstance(delta.getObject().getObjectClass());\n-\n-        final String uid = delta.getPreviousUid() == null\n-                ? delta.getUid().getUidValue()\n-                : delta.getPreviousUid().getUidValue();\n-\n-        try {\n-            List<Long> subjectIds = findExisting(uid, delta.getObject(), attrUtil);\n-            if (subjectIds.size() > 1) {\n-                switch (resAct) {\n-                    case IGNORE:\n-                        throw new IllegalStateException(\"More than one match \" + subjectIds);\n-\n-                    case FIRSTMATCH:\n-                        subjectIds = subjectIds.subList(0, 1);\n-                        break;\n-\n-                    case LASTMATCH:\n-                        subjectIds = subjectIds.subList(subjectIds.size() - 1, subjectIds.size());\n-                        break;\n-\n-                    default:\n-                    // keep subjectIds as is\n-                }\n-            }\n-\n-            if (SyncDeltaType.CREATE_OR_UPDATE == delta.getDeltaType()) {\n-                if (subjectIds.isEmpty()) {\n-                    switch (getSyncTask().getUnmatchigRule()) {\n-                        case ASSIGN:\n-                            results.addAll(assign(delta, attrUtil, dryRun));\n-                            break;\n-                        case PROVISION:\n-                            results.addAll(create(delta, attrUtil, dryRun));\n-                            break;\n-                        default:\n-                        // do nothing\n-                    }\n-                } else {\n-                    switch (getSyncTask().getMatchigRule()) {\n-                        case UPDATE:\n-                            results.addAll(update(delta, subjectIds, attrUtil, dryRun));\n-                            break;\n-                        case DEPROVISION:\n-                            results.addAll(deprovision(delta, subjectIds, attrUtil, false, dryRun));\n-                            break;\n-                        case UNASSIGN:\n-                            results.addAll(deprovision(delta, subjectIds, attrUtil, true, dryRun));\n-                            break;\n-                        case LINK:\n-                            results.addAll(link(delta, subjectIds, attrUtil, false, dryRun));\n-                            break;\n-                        case UNLINK:\n-                            results.addAll(link(delta, subjectIds, attrUtil, true, dryRun));\n-                            break;\n-                        default:\n-                        // do nothing\n-                    }\n-                }\n-            } else if (SyncDeltaType.DELETE == delta.getDeltaType()) {\n-                if (subjectIds.isEmpty()) {\n-                    LOG.debug(\"No match found for deletion\");\n-                } else {\n-                    results.addAll(delete(delta, subjectIds, attrUtil, dryRun));\n-                }\n-            }\n-        } catch (IllegalStateException e) {\n-            LOG.warn(e.getMessage());\n-        }\n-    }\n-}"},{"sha":"bcb95e7f3cc83af91bec4318101a6ae935cd0b89","filename":"core/src/main/java/org/apache/syncope/core/sync/impl/UserPushResultHandler.java","status":"added","additions":22,"deletions":0,"changes":22,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/56c18fe7854e83c6d64c7c938a49793c1419cd59/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fsync%2Fimpl%2FUserPushResultHandler.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/56c18fe7854e83c6d64c7c938a49793c1419cd59/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fsync%2Fimpl%2FUserPushResultHandler.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fsync%2Fimpl%2FUserPushResultHandler.java?ref=56c18fe7854e83c6d64c7c938a49793c1419cd59","patch":"@@ -0,0 +1,22 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.core.sync.impl;\n+\n+public class UserPushResultHandler extends AbstractSubjectPushResultHandler {\n+}"},{"sha":"23b926967cc3627de20908c291d3b6a50158fcbf","filename":"core/src/main/java/org/apache/syncope/core/sync/impl/UserSyncResultHandler.java","status":"added","additions":164,"deletions":0,"changes":164,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/56c18fe7854e83c6d64c7c938a49793c1419cd59/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fsync%2Fimpl%2FUserSyncResultHandler.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/56c18fe7854e83c6d64c7c938a49793c1419cd59/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fsync%2Fimpl%2FUserSyncResultHandler.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fsync%2Fimpl%2FUserSyncResultHandler.java?ref=56c18fe7854e83c6d64c7c938a49793c1419cd59","patch":"@@ -0,0 +1,164 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.syncope.core.sync.impl;\n+\n+import static org.apache.syncope.core.sync.impl.AbstractSyncopeResultHandler.LOG;\n+import java.util.AbstractMap;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.syncope.common.mod.AbstractSubjectMod;\n+import org.apache.syncope.common.mod.UserMod;\n+import org.apache.syncope.common.to.AbstractSubjectTO;\n+import org.apache.syncope.common.to.UserTO;\n+import org.apache.syncope.common.types.AttributableType;\n+import org.apache.syncope.core.persistence.beans.PropagationTask;\n+import org.apache.syncope.core.persistence.beans.user.SyncopeUser;\n+import org.apache.syncope.core.propagation.PropagationByResource;\n+import org.apache.syncope.core.sync.SyncResult;\n+import org.apache.syncope.core.util.AttributableUtil;\n+import org.apache.syncope.core.workflow.WorkflowResult;\n+import org.identityconnectors.framework.common.objects.SyncDelta;\n+\n+public class UserSyncResultHandler extends AbstractSubjectSyncResultHandler {\n+\n+    @Override\n+    protected AttributableUtil getAttributableUtil() {\n+        return AttributableUtil.getInstance(AttributableType.USER);\n+    }\n+\n+    @Override\n+    protected String getName(final AbstractSubjectTO subjectTO) {\n+        return UserTO.class.cast(subjectTO).getUsername();\n+    }\n+\n+    @Override\n+    protected AbstractSubjectTO getSubjectTO(final long id) {\n+        return userDataBinder.getUserTO(id);\n+    }\n+\n+    @Override\n+    protected AbstractSubjectMod getSubjectMod(\n+            final AbstractSubjectTO subjectTO, final SyncDelta delta) {\n+\n+        return connObjectUtil.getAttributableMod(\n+                subjectTO.getId(),\n+                delta.getObject(),\n+                subjectTO,\n+                profile.getSyncTask(),\n+                AttributableUtil.getInstance(AttributableType.USER));\n+    }\n+\n+    @Override\n+    protected AbstractSubjectTO create(\n+            final AbstractSubjectTO subjectTO, final SyncDelta delta, final SyncResult result) {\n+\n+        UserTO userTO = UserTO.class.cast(subjectTO);\n+\n+        Boolean enabled = syncUtilities.readEnabled(delta.getObject(), profile.getSyncTask());\n+        WorkflowResult<Map.Entry<Long, Boolean>> created =\n+                uwfAdapter.create(userTO, true, enabled);\n+\n+        List<PropagationTask> tasks = propagationManager.getUserCreateTaskIds(created,\n+                userTO.getPassword(), userTO.getVirAttrs(),\n+                Collections.singleton(profile.getSyncTask().getResource().getName()),\n+                userTO.getMemberships());\n+\n+        taskExecutor.execute(tasks);\n+\n+        userTO = userDataBinder.getUserTO(created.getResult().getKey());\n+\n+        result.setId(created.getResult().getKey());\n+        result.setName(getName(subjectTO));\n+\n+        return userTO;\n+    }\n+\n+    @Override\n+    protected AbstractSubjectTO update(\n+            final AbstractSubjectTO before,\n+            final AbstractSubjectMod subjectMod,\n+            final SyncDelta delta, final SyncResult result)\n+            throws Exception {\n+\n+        final UserMod userMod = UserMod.class.cast(subjectMod);\n+\n+        WorkflowResult<Map.Entry<UserMod, Boolean>> updated;\n+        try {\n+            updated = uwfAdapter.update(userMod);\n+        } catch (Exception e) {\n+            LOG.error(\"Update of user {} failed, trying to sync its status anyway (if configured)\", before.getId(), e);\n+\n+            result.setStatus(SyncResult.Status.FAILURE);\n+            result.setMessage(\"Update failed, trying to sync status anyway (if configured)\\n\" + e.getMessage());\n+\n+            updated = new WorkflowResult<Map.Entry<UserMod, Boolean>>(\n+                    new AbstractMap.SimpleEntry<UserMod, Boolean>(userMod, false), new PropagationByResource(),\n+                    new HashSet<String>());\n+        }\n+\n+        final Boolean enabled = syncUtilities.readEnabled(delta.getObject(), profile.getSyncTask());\n+        if (enabled != null) {\n+            SyncopeUser user = userDAO.find(before.getId());\n+\n+            WorkflowResult<Long> enableUpdate = null;\n+            if (user.isSuspended() == null) {\n+                enableUpdate = uwfAdapter.activate(before.getId(), null);\n+            } else if (enabled && user.isSuspended()) {\n+                enableUpdate = uwfAdapter.reactivate(before.getId());\n+            } else if (!enabled && !user.isSuspended()) {\n+                enableUpdate = uwfAdapter.suspend(before.getId());\n+            }\n+\n+            if (enableUpdate != null) {\n+                if (enableUpdate.getPropByRes() != null) {\n+                    updated.getPropByRes().merge(enableUpdate.getPropByRes());\n+                    updated.getPropByRes().purge();\n+                }\n+                updated.getPerformedTasks().addAll(enableUpdate.getPerformedTasks());\n+            }\n+        }\n+\n+        final List<PropagationTask> tasks = propagationManager.getUserUpdateTaskIds(\n+                updated, updated.getResult().getKey().getPassword() != null,\n+                Collections.singleton(profile.getSyncTask().getResource().getName()));\n+\n+        taskExecutor.execute(tasks);\n+\n+        final UserTO after = userDataBinder.getUserTO(updated.getResult().getKey().getId());\n+\n+        result.setName(getName(after));\n+        return after;\n+    }\n+\n+    @Override\n+    protected void delete(final Long id) {\n+        try {\n+            taskExecutor.execute(\n+                    propagationManager.getUserDeleteTaskIds(id, profile.getSyncTask().getResource().getName()));\n+        } catch (Exception e) {\n+            // A propagation failure doesn't imply a synchronization failure.\n+            // The propagation exception status will be reported into the propagation task execution.\n+            LOG.error(\"Could not propagate user \" + id, e);\n+        }\n+\n+        uwfAdapter.delete(id);\n+    }\n+}"},{"sha":"6adc75c0944f5b9efad48c46f4b8fccd67517681","filename":"core/src/main/resources/syncopeContext.xml","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/56c18fe7854e83c6d64c7c938a49793c1419cd59/core%2Fsrc%2Fmain%2Fresources%2FsyncopeContext.xml","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/56c18fe7854e83c6d64c7c938a49793c1419cd59/core%2Fsrc%2Fmain%2Fresources%2FsyncopeContext.xml","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fresources%2FsyncopeContext.xml?ref=56c18fe7854e83c6d64c7c938a49793c1419cd59","patch":"@@ -89,6 +89,8 @@ under the License.\n   <bean id=\"connectorFacadeProxy\" class=\"org.apache.syncope.core.propagation.impl.ConnectorFacadeProxy\" scope=\"prototype\"/>\n   <bean id=\"asyncConnFacade\" class=\"org.apache.syncope.core.propagation.impl.AsyncConnectorFacade\" scope=\"singleton\"/>\n \n+  <bean id=\"syncUtilities\" class=\"org.apache.syncope.core.sync.SyncUtilities\"/>\n+  \n   <bean id=\"mailSender\" class=\"org.springframework.mail.javamail.JavaMailSenderImpl\">\n     <property name=\"defaultEncoding\" value=\"${smtpEncoding}\"/>\n     <property name=\"host\" value=\"${smtpHost}\"/>"},{"sha":"f08ae7e8d47955b473a92a549d891d2999c6e2d4","filename":"core/src/test/java/org/apache/syncope/core/rest/RoleTestITCase.java","status":"modified","additions":10,"deletions":0,"changes":10,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/56c18fe7854e83c6d64c7c938a49793c1419cd59/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Frest%2FRoleTestITCase.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/56c18fe7854e83c6d64c7c938a49793c1419cd59/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Frest%2FRoleTestITCase.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Frest%2FRoleTestITCase.java?ref=56c18fe7854e83c6d64c7c938a49793c1419cd59","patch":"@@ -36,6 +36,7 @@\n import org.apache.syncope.client.SyncopeClient;\n import org.apache.syncope.common.SyncopeClientException;\n import org.apache.syncope.common.mod.AttributeMod;\n+import org.apache.syncope.common.mod.ReferenceMod;\n import org.apache.syncope.common.mod.RoleMod;\n import org.apache.syncope.common.reqres.BulkActionResult;\n import org.apache.syncope.common.reqres.PagedResult;\n@@ -60,6 +61,7 @@\n import org.apache.syncope.common.wrap.ResourceName;\n import org.identityconnectors.framework.common.objects.Name;\n import org.junit.FixMethodOrder;\n+import org.junit.Ignore;\n import org.junit.Test;\n import org.junit.runners.MethodSorters;\n \n@@ -106,6 +108,7 @@ public void createWithException() {\n     }\n \n     @Test\n+    @Ignore\n     public void create() {\n         RoleTO roleTO = buildRoleTO(\"lastRole\");\n         roleTO.getRVirAttrTemplates().add(\"rvirtualdata\");\n@@ -132,6 +135,13 @@ public void create() {\n                 resourceService.getConnectorObject(RESOURCE_NAME_LDAP, SubjectType.ROLE, roleTO.getId());\n         assertNotNull(connObjectTO);\n         assertNotNull(connObjectTO.getAttrMap().get(\"owner\"));\n+\n+        // SYNCOPE-515: remove ownership\n+        final RoleMod roleMod = new RoleMod();\n+        roleMod.setId(roleTO.getId());\n+        roleMod.setRoleOwner(new ReferenceMod());\n+\n+        assertNull(updateRole(roleMod).getRoleOwner());\n     }\n \n     @Test"},{"sha":"875fd8397fc57f71fbbac10ed8b9cf214842b879","filename":"core/src/test/java/org/apache/syncope/core/sync/TestSyncActions.java","status":"modified","additions":2,"deletions":3,"changes":5,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/56c18fe7854e83c6d64c7c938a49793c1419cd59/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fsync%2FTestSyncActions.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/56c18fe7854e83c6d64c7c938a49793c1419cd59/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fsync%2FTestSyncActions.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fsyncope%2Fcore%2Fsync%2FTestSyncActions.java?ref=56c18fe7854e83c6d64c7c938a49793c1419cd59","patch":"@@ -22,7 +22,6 @@\n import org.apache.syncope.common.mod.AttributeMod;\n import org.apache.syncope.common.to.AbstractAttributableTO;\n import org.apache.syncope.common.to.AttributeTO;\n-import org.apache.syncope.core.sync.impl.AbstractSyncopeResultHandler;\n import org.identityconnectors.framework.common.objects.SyncDelta;\n import org.quartz.JobExecutionException;\n \n@@ -32,7 +31,7 @@ public class TestSyncActions extends DefaultSyncActions {\n \n     @Override\n     public <T extends AbstractAttributableTO> SyncDelta beforeCreate(\n-            final AbstractSyncopeResultHandler<?, ?> handler,\n+            final SyncProfile<?, ?> profile,\n             final SyncDelta delta,\n             final T subject) throws JobExecutionException {\n \n@@ -55,7 +54,7 @@ public <T extends AbstractAttributableTO> SyncDelta beforeCreate(\n \n     @Override\n     public <T extends AbstractAttributableTO, K extends AbstractAttributableMod> SyncDelta beforeUpdate(\n-            final AbstractSyncopeResultHandler<?, ?> handler,\n+            final SyncProfile<?, ?> profile,\n             final SyncDelta delta,\n             final T subject,\n             final K subjectMod) throws JobExecutionException {"}]}