{"sha":"18a3262e1059623a08ef97099edb3ba50583b7b8","node_id":"MDY6Q29tbWl0NjM2ODc5MDYyOjE4YTMyNjJlMTA1OTYyM2EwOGVmOTcwOTllZGIzYmE1MDU4M2I3Yjg=","commit":{"author":{"name":"Unknown","email":"unknown@apache.org","date":"2011-08-24T07:47:11Z"},"committer":{"name":"Unknown","email":"unknown@apache.org","date":"2011-08-24T07:47:11Z"},"message":"Upgrading to latest Spring 3.0.6\n\ngit-svn-id: https://svn.apache.org/repos/asf/incubator/syncope/trunk@1247089 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"e16a62c86afa535d7c4032d10bb6edd5efb2ced2","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/git/trees/e16a62c86afa535d7c4032d10bb6edd5efb2ced2"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/git/commits/18a3262e1059623a08ef97099edb3ba50583b7b8","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/18a3262e1059623a08ef97099edb3ba50583b7b8","html_url":"https://github.com/EnricoDAlessandro97UNI/syncope/commit/18a3262e1059623a08ef97099edb3ba50583b7b8","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/18a3262e1059623a08ef97099edb3ba50583b7b8/comments","author":null,"committer":null,"parents":[{"sha":"6b4e85b262e0abe537901139be4e192f1b16188c","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/commits/6b4e85b262e0abe537901139be4e192f1b16188c","html_url":"https://github.com/EnricoDAlessandro97UNI/syncope/commit/6b4e85b262e0abe537901139be4e192f1b16188c"}],"stats":{"total":1128,"additions":22,"deletions":1106},"files":[{"sha":"bf94be32a4ed3377e420a0d34660b261e999c1b0","filename":"archetype/src/main/resources/archetype-resources/pom.xml","status":"modified","additions":7,"deletions":7,"changes":14,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/18a3262e1059623a08ef97099edb3ba50583b7b8/archetype%2Fsrc%2Fmain%2Fresources%2Farchetype-resources%2Fpom.xml","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/18a3262e1059623a08ef97099edb3ba50583b7b8/archetype%2Fsrc%2Fmain%2Fresources%2Farchetype-resources%2Fpom.xml","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/archetype%2Fsrc%2Fmain%2Fresources%2Farchetype-resources%2Fpom.xml?ref=18a3262e1059623a08ef97099edb3ba50583b7b8","patch":"@@ -15,21 +15,21 @@\n     <properties>\r\n         <syncope.version>0.7-SNAPSHOT</syncope.version>\r\n         <hsqldb.version>2.2.4</hsqldb.version>\r\n-        <connid.soap.version>1.0</connid.soap.version>\r\n-        <connid.db.table.version>1.1</connid.db.table.version>\r\n+        <connid.soap.version>1.1</connid.soap.version>\r\n+        <connid.db.table.version>1.2.1</connid.db.table.version>\r\n \r\n         <servlet-api.version>2.5</servlet-api.version>\r\n         <jsp-api.version>2.1</jsp-api.version>\r\n         <jstl.version>1.2</jstl.version>\r\n         \r\n-        <spring>3.0.5.RELEASE</spring>\r\n+        <spring>3.0.6.RELEASE</spring>\r\n         <aspectj.version>1.6.9</aspectj.version>\r\n \r\n         <osworkflow.version>2.8.0</osworkflow.version>\r\n         <propertyset.version>1.3</propertyset.version>\r\n         <oscore.version>2.2.6</oscore.version>\r\n \r\n-        <wicket.version>1.4.17</wicket.version>\r\n+        <wicket.version>1.4.18</wicket.version>\r\n \r\n         <commons-lang.version>2.6</commons-lang.version>\r\n         <commons-httpclient.version>3.1</commons-httpclient.version>\r\n@@ -41,7 +41,7 @@\n \r\n         <junit.version>4.8.2</junit.version>\r\n \r\n-        <cargo.version>1.1.1</cargo.version>\r\n+        <cargo.version>1.1.2</cargo.version>\r\n         <tomcat.version>7.0.20</tomcat.version>\r\n \r\n         <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\r\n@@ -304,7 +304,7 @@\n                 <plugin>\r\n                     <groupId>org.apache.maven.plugins</groupId>\r\n                     <artifactId>maven-failsafe-plugin</artifactId>\r\n-                    <version>2.8</version>\r\n+                    <version>2.9</version>\r\n                     <executions>\r\n                         <execution>\r\n                             <goals>\r\n@@ -317,7 +317,7 @@\n                 <plugin>\r\n                     <groupId>org.apache.maven.plugins</groupId>\r\n                     <artifactId>maven-war-plugin</artifactId>\r\n-                    <version>2.1</version>\r\n+                    <version>2.1.1</version>\r\n                 </plugin>\r\n                 <plugin>\r\n                     <groupId>org.codehaus.cargo</groupId>\r"},{"sha":"4d8bdbbb968ed27421622230f1200720cca95adc","filename":"core/pom.xml","status":"modified","additions":0,"deletions":16,"changes":16,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/18a3262e1059623a08ef97099edb3ba50583b7b8/core%2Fpom.xml","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/18a3262e1059623a08ef97099edb3ba50583b7b8/core%2Fpom.xml","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fpom.xml?ref=18a3262e1059623a08ef97099edb3ba50583b7b8","patch":"@@ -82,11 +82,6 @@\n             <artifactId>commons-jexl</artifactId>\n         </dependency>\n \n-        <dependency>\n-            <groupId>commons-lang</groupId>\n-            <artifactId>commons-lang</artifactId>\n-        </dependency>\n-\n         <dependency>\n             <groupId>commons-httpclient</groupId>\n             <artifactId>commons-httpclient</artifactId>\n@@ -256,17 +251,6 @@\n             <scope>runtime</scope>\n         </dependency>\n \n-        <dependency>\n-            <groupId>postgresql</groupId>\n-            <artifactId>postgresql</artifactId>\n-            <version>9.0-801.jdbc4</version>\n-        </dependency>\n-        <dependency>\n-            <groupId>com.oracle</groupId>\n-            <artifactId>ojdbc6</artifactId>\n-            <version>11.1.0</version>\n-        </dependency>\n-\n         <!-- TEST -->\n         <dependency>\n             <groupId>org.connid.bundles.soap</groupId>"},{"sha":"0a08d13af753ee364c5f4bb4fc680022f1fba077","filename":"core/src/main/java/org/springframework/beans/factory/support/DefaultListableBeanFactory.java","status":"removed","additions":0,"deletions":1059,"changes":1059,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/6b4e85b262e0abe537901139be4e192f1b16188c/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fbeans%2Ffactory%2Fsupport%2FDefaultListableBeanFactory.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/6b4e85b262e0abe537901139be4e192f1b16188c/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fbeans%2Ffactory%2Fsupport%2FDefaultListableBeanFactory.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fbeans%2Ffactory%2Fsupport%2FDefaultListableBeanFactory.java?ref=6b4e85b262e0abe537901139be4e192f1b16188c","patch":"@@ -1,1059 +0,0 @@\n-/*\n- * Copyright 2002-2010 the original author or authors.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.springframework.beans.factory.support;\n-\n-import java.io.NotSerializableException;\n-import java.io.ObjectStreamException;\n-import java.io.Serializable;\n-import java.lang.annotation.Annotation;\n-import java.lang.ref.Reference;\n-import java.lang.ref.WeakReference;\n-import java.lang.reflect.ParameterizedType;\n-import java.lang.reflect.Type;\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collection;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.LinkedHashMap;\n-import java.util.LinkedHashSet;\n-import java.util.List;\n-import java.util.ListIterator;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.CopyOnWriteArrayList;\n-import javax.inject.Provider;\n-\n-import org.springframework.beans.BeansException;\n-import org.springframework.beans.FatalBeanException;\n-import org.springframework.beans.TypeConverter;\n-import org.springframework.beans.factory.BeanCreationException;\n-import org.springframework.beans.factory.BeanCurrentlyInCreationException;\n-import org.springframework.beans.factory.BeanDefinitionStoreException;\n-import org.springframework.beans.factory.BeanFactory;\n-import org.springframework.beans.factory.BeanFactoryAware;\n-import org.springframework.beans.factory.BeanFactoryUtils;\n-import org.springframework.beans.factory.CannotLoadBeanClassException;\n-import org.springframework.beans.factory.FactoryBean;\n-import org.springframework.beans.factory.NoSuchBeanDefinitionException;\n-import org.springframework.beans.factory.ObjectFactory;\n-import org.springframework.beans.factory.SmartFactoryBean;\n-import org.springframework.beans.factory.config.BeanDefinition;\n-import org.springframework.beans.factory.config.BeanDefinitionHolder;\n-import org.springframework.beans.factory.config.ConfigurableBeanFactory;\n-import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;\n-import org.springframework.beans.factory.config.DependencyDescriptor;\n-import org.springframework.core.annotation.AnnotationUtils;\n-import org.springframework.util.Assert;\n-import org.springframework.util.ObjectUtils;\n-import org.springframework.util.StringUtils;\n-\n-/*\n- * Variant of standard DefaultListableBeanFactory (Spring 3.0.5-RELEASE) where\n- * \n- * private final List<String> beanDefinitionNames = new ArrayList<String>();\n- * \n- * is replaced by\n- * \n- * private final List<String> beanDefinitionNames = new CopyOnWriteArrayList<String>();\n- * \n- * @see https://jira.springsource.org/browse/SPR-7757\n- */\n-/**\n- * Default implementation of the\n- * {@link org.springframework.beans.factory.ListableBeanFactory} and\n- * {@link BeanDefinitionRegistry} interfaces: a full-fledged bean factory\n- * based on bean definition objects.\n- *\n- * <p>Typical usage is registering all bean definitions first (possibly read\n- * from a bean definition file), before accessing beans. Bean definition lookup\n- * is therefore an inexpensive operation in a local bean definition table,\n- * operating on pre-built bean definition metadata objects.\n- *\n- * <p>Can be used as a standalone bean factory, or as a superclass for custom\n- * bean factories. Note that readers for specific bean definition formats are\n- * typically implemented separately rather than as bean factory subclasses:\n- * see for example {@link PropertiesBeanDefinitionReader} and\n- * {@link org.springframework.beans.factory.xml.XmlBeanDefinitionReader}.\n- *\n- * <p>For an alternative implementation of the\n- * {@link org.springframework.beans.factory.ListableBeanFactory} interface,\n- * have a look at {@link StaticListableBeanFactory}, which manages existing\n- * bean instances rather than creating new ones based on bean definitions.\n- *\n- * @author Rod Johnson\n- * @author Juergen Hoeller\n- * @author Sam Brannen\n- * @author Costin Leau\n- * @since 16 April 2001\n- * @see StaticListableBeanFactory\n- * @see PropertiesBeanDefinitionReader\n- * @see org.springframework.beans.factory.xml.XmlBeanDefinitionReader\n- */\n-public class DefaultListableBeanFactory extends AbstractAutowireCapableBeanFactory\n-\t\timplements ConfigurableListableBeanFactory, BeanDefinitionRegistry, Serializable {\n-\n-\tprivate static Class javaxInjectProviderClass = null;\n-\n-\tstatic {\n-\t\tClassLoader cl = DefaultListableBeanFactory.class.getClassLoader();\n-\t\ttry {\n-\t\t\tjavaxInjectProviderClass = cl.loadClass(\"javax.inject.Provider\");\n-\t\t}\n-\t\tcatch (ClassNotFoundException ex) {\n-\t\t\t// JSR-330 API not available - Provider interface simply not supported then.\n-\t\t}\n-\t}\n-\n-\n-\t/** Map from serialized id to factory instance */\n-\tprivate static final Map<String, Reference<DefaultListableBeanFactory>> serializableFactories =\n-\t\t\tnew ConcurrentHashMap<String, Reference<DefaultListableBeanFactory>>();\n-\n-\t/** Optional id for this factory, for serialization purposes */\n-\tprivate String serializationId;\n-\n-\t/** Whether to allow re-registration of a different definition with the same name */\n-\tprivate boolean allowBeanDefinitionOverriding = true;\n-\n-\t/** Whether to allow eager class loading even for lazy-init beans */\n-\tprivate boolean allowEagerClassLoading = true;\n-\n-\t/** Resolver to use for checking if a bean definition is an autowire candidate */\n-\tprivate AutowireCandidateResolver autowireCandidateResolver = new SimpleAutowireCandidateResolver();\n-\n-\t/** Map from dependency type to corresponding autowired value */\n-\tprivate final Map<Class, Object> resolvableDependencies = new HashMap<Class, Object>();\n-\n-\t/** Map of bean definition objects, keyed by bean name */\n-\tprivate final Map<String, BeanDefinition> beanDefinitionMap = new ConcurrentHashMap<String, BeanDefinition>();\n-\n-\t/** List of bean definition names, in registration order */\n-\tprivate final List<String> beanDefinitionNames = new CopyOnWriteArrayList<String>();\n-\n-\t/** Whether bean definition metadata may be cached for all beans */\n-\tprivate boolean configurationFrozen = false;\n-\n-\t/** Cached array of bean definition names in case of frozen configuration */\n-\tprivate String[] frozenBeanDefinitionNames;\n-\n-\n-\t/**\n-\t * Create a new DefaultListableBeanFactory.\n-\t */\n-\tpublic DefaultListableBeanFactory() {\n-\t\tsuper();\n-\t}\n-\n-\t/**\n-\t * Create a new DefaultListableBeanFactory with the given parent.\n-\t * @param parentBeanFactory the parent BeanFactory\n-\t */\n-\tpublic DefaultListableBeanFactory(BeanFactory parentBeanFactory) {\n-\t\tsuper(parentBeanFactory);\n-\t}\n-\n-\n-\t/**\n-\t * Specify an id for serialization purposes, allowing this BeanFactory to be\n-\t * deserialized from this id back into the BeanFactory object, if needed.\n-\t */\n-\tpublic void setSerializationId(String serializationId) {\n-\t\tif (serializationId != null) {\n-\t\t\tserializableFactories.put(serializationId, new WeakReference<DefaultListableBeanFactory>(this));\n-\t\t}\n-\t\telse if (this.serializationId != null) {\n-\t\t\tserializableFactories.remove(this.serializationId);\n-\t\t}\n-\t\tthis.serializationId = serializationId;\n-\t}\n-\n-\t/**\n-\t * Set whether it should be allowed to override bean definitions by registering\n-\t * a different definition with the same name, automatically replacing the former.\n-\t * If not, an exception will be thrown. This also applies to overriding aliases.\n-\t * <p>Default is \"true\".\n-\t * @see #registerBeanDefinition\n-\t */\n-\tpublic void setAllowBeanDefinitionOverriding(boolean allowBeanDefinitionOverriding) {\n-\t\tthis.allowBeanDefinitionOverriding = allowBeanDefinitionOverriding;\n-\t}\n-\n-\t/**\n-\t * Set whether the factory is allowed to eagerly load bean classes\n-\t * even for bean definitions that are marked as \"lazy-init\".\n-\t * <p>Default is \"true\". Turn this flag off to suppress class loading\n-\t * for lazy-init beans unless such a bean is explicitly requested.\n-\t * In particular, by-type lookups will then simply ignore bean definitions\n-\t * without resolved class name, instead of loading the bean classes on\n-\t * demand just to perform a type check.\n-\t * @see AbstractBeanDefinition#setLazyInit\n-\t */\n-\tpublic void setAllowEagerClassLoading(boolean allowEagerClassLoading) {\n-\t\tthis.allowEagerClassLoading = allowEagerClassLoading;\n-\t}\n-\n-\t/**\n-\t * Set a custom autowire candidate resolver for this BeanFactory to use\n-\t * when deciding whether a bean definition should be considered as a\n-\t * candidate for autowiring.\n-\t */\n-\tpublic void setAutowireCandidateResolver(final AutowireCandidateResolver autowireCandidateResolver) {\n-\t\tAssert.notNull(autowireCandidateResolver, \"AutowireCandidateResolver must not be null\");\n-\t\tif (autowireCandidateResolver instanceof BeanFactoryAware) {\n-\t\t\tif (System.getSecurityManager() != null) {\n-\t\t\t\tfinal BeanFactory target = this;\n-\t\t\t\tAccessController.doPrivileged(new PrivilegedAction<Object>() {\n-\t\t\t\t\tpublic Object run() {\n-\t\t\t\t\t\t((BeanFactoryAware) autowireCandidateResolver).setBeanFactory(target);\n-\t\t\t\t\t\treturn null;\n-\t\t\t\t\t}\n-\t\t\t\t}, getAccessControlContext());\n-\t\t\t}\n-\t\t\telse {\n-\t\t\t\t((BeanFactoryAware) autowireCandidateResolver).setBeanFactory(this);\n-\t\t\t}\n-\t\t}\n-\t\tthis.autowireCandidateResolver = autowireCandidateResolver;\n-\t}\n-\n-\t/**\n-\t * Return the autowire candidate resolver for this BeanFactory (never <code>null</code>).\n-\t */\n-\tpublic AutowireCandidateResolver getAutowireCandidateResolver() {\n-\t\treturn this.autowireCandidateResolver;\n-\t}\n-\n-\n-\t@Override\n-\tpublic void copyConfigurationFrom(ConfigurableBeanFactory otherFactory) {\n-\t\tsuper.copyConfigurationFrom(otherFactory);\n-\t\tif (otherFactory instanceof DefaultListableBeanFactory) {\n-\t\t\tDefaultListableBeanFactory otherListableFactory = (DefaultListableBeanFactory) otherFactory;\n-\t\t\tthis.allowBeanDefinitionOverriding = otherListableFactory.allowBeanDefinitionOverriding;\n-\t\t\tthis.allowEagerClassLoading = otherListableFactory.allowEagerClassLoading;\n-\t\t\tthis.autowireCandidateResolver = otherListableFactory.autowireCandidateResolver;\n-\t\t\tthis.resolvableDependencies.putAll(otherListableFactory.resolvableDependencies);\n-\t\t}\n-\t}\n-\n-\n-\t//---------------------------------------------------------------------\n-\t// Implementation of ListableBeanFactory interface\n-\t//---------------------------------------------------------------------\n-\n-\tpublic <T> T getBean(Class<T> requiredType) throws BeansException {\n-\t\tAssert.notNull(requiredType, \"Required type must not be null\");\n-\t\tString[] beanNames = getBeanNamesForType(requiredType);\n-\t\tif (beanNames.length > 1) {\n-\t\t\tArrayList<String> autowireCandidates = new ArrayList<String>();\n-\t\t\tfor (String beanName : beanNames) {\n-\t\t\t\tif (getBeanDefinition(beanName).isAutowireCandidate()) {\n-\t\t\t\t\tautowireCandidates.add(beanName);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tif (autowireCandidates.size() > 0) {\n-\t\t\t\tbeanNames = autowireCandidates.toArray(new String[autowireCandidates.size()]);\n-\t\t\t}\n-\t\t}\n-\t\tif (beanNames.length == 1) {\n-\t\t\treturn getBean(beanNames[0], requiredType);\n-\t\t}\n-\t\telse if (beanNames.length == 0 && getParentBeanFactory() != null) {\n-\t\t\treturn getParentBeanFactory().getBean(requiredType);\n-\t\t}\n-\t\telse {\n-\t\t\tthrow new NoSuchBeanDefinitionException(requiredType, \"expected single bean but found \" +\n-\t\t\t\t\tbeanNames.length + \": \" + StringUtils.arrayToCommaDelimitedString(beanNames));\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic boolean containsBeanDefinition(String beanName) {\n-\t\tAssert.notNull(beanName, \"Bean name must not be null\");\n-\t\treturn this.beanDefinitionMap.containsKey(beanName);\n-\t}\n-\n-\tpublic int getBeanDefinitionCount() {\n-\t\treturn this.beanDefinitionMap.size();\n-\t}\n-\n-\tpublic String[] getBeanDefinitionNames() {\n-\t\tsynchronized (this.beanDefinitionMap) {\n-\t\t\tif (this.frozenBeanDefinitionNames != null) {\n-\t\t\t\treturn this.frozenBeanDefinitionNames;\n-\t\t\t}\n-\t\t\telse {\n-\t\t\t\treturn StringUtils.toStringArray(this.beanDefinitionNames);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tpublic String[] getBeanNamesForType(Class type) {\n-\t\treturn getBeanNamesForType(type, true, true);\n-\t}\n-\n-\tpublic String[] getBeanNamesForType(Class type, boolean includeNonSingletons, boolean allowEagerInit) {\n-\t\tList<String> result = new ArrayList<String>();\n-\n-\t\t// Check all bean definitions.\n-\t\tString[] beanDefinitionNames = getBeanDefinitionNames();\n-\t\tfor (String beanName : beanDefinitionNames) {\n-\t\t\t// Only consider bean as eligible if the bean name\n-\t\t\t// is not defined as alias for some other bean.\n-\t\t\tif (!isAlias(beanName)) {\n-\t\t\t\ttry {\n-\t\t\t\t\tRootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);\n-\t\t\t\t\t// Only check bean definition if it is complete.\n-\t\t\t\t\tif (!mbd.isAbstract() && (allowEagerInit ||\n-\t\t\t\t\t\t\t((mbd.hasBeanClass() || !mbd.isLazyInit() || this.allowEagerClassLoading)) &&\n-\t\t\t\t\t\t\t\t\t!requiresEagerInitForType(mbd.getFactoryBeanName()))) {\n-\t\t\t\t\t\t// In case of FactoryBean, match object created by FactoryBean.\n-\t\t\t\t\t\tboolean isFactoryBean = isFactoryBean(beanName, mbd);\n-\t\t\t\t\t\tboolean matchFound = (allowEagerInit || !isFactoryBean || containsSingleton(beanName)) &&\n-\t\t\t\t\t\t\t\t(includeNonSingletons || isSingleton(beanName)) && isTypeMatch(beanName, type);\n-\t\t\t\t\t\tif (!matchFound && isFactoryBean) {\n-\t\t\t\t\t\t\t// In case of FactoryBean, try to match FactoryBean instance itself next.\n-\t\t\t\t\t\t\tbeanName = FACTORY_BEAN_PREFIX + beanName;\n-\t\t\t\t\t\t\tmatchFound = (includeNonSingletons || mbd.isSingleton()) && isTypeMatch(beanName, type);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tif (matchFound) {\n-\t\t\t\t\t\t\tresult.add(beanName);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tcatch (CannotLoadBeanClassException ex) {\n-\t\t\t\t\tif (allowEagerInit) {\n-\t\t\t\t\t\tthrow ex;\n-\t\t\t\t\t}\n-\t\t\t\t\t// Probably contains a placeholder: let's ignore it for type matching purposes.\n-\t\t\t\t\tif (this.logger.isDebugEnabled()) {\n-\t\t\t\t\t\tthis.logger.debug(\"Ignoring bean class loading failure for bean '\" + beanName + \"'\", ex);\n-\t\t\t\t\t}\n-\t\t\t\t\tonSuppressedException(ex);\n-\t\t\t\t}\n-\t\t\t\tcatch (BeanDefinitionStoreException ex) {\n-\t\t\t\t\tif (allowEagerInit) {\n-\t\t\t\t\t\tthrow ex;\n-\t\t\t\t\t}\n-\t\t\t\t\t// Probably contains a placeholder: let's ignore it for type matching purposes.\n-\t\t\t\t\tif (this.logger.isDebugEnabled()) {\n-\t\t\t\t\t\tthis.logger.debug(\"Ignoring unresolvable metadata in bean definition '\" + beanName + \"'\", ex);\n-\t\t\t\t\t}\n-\t\t\t\t\tonSuppressedException(ex);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\t// Check singletons too, to catch manually registered singletons.\n-\t\tString[] singletonNames = getSingletonNames();\n-\t\tfor (String beanName : singletonNames) {\n-\t\t\t// Only check if manually registered.\n-\t\t\tif (!containsBeanDefinition(beanName)) {\n-\t\t\t\t// In case of FactoryBean, match object created by FactoryBean.\n-\t\t\t\tif (isFactoryBean(beanName)) {\n-\t\t\t\t\tif ((includeNonSingletons || isSingleton(beanName)) && isTypeMatch(beanName, type)) {\n-\t\t\t\t\t\tresult.add(beanName);\n-\t\t\t\t\t\t// Match found for this bean: do not match FactoryBean itself anymore.\n-\t\t\t\t\t\tcontinue;\n-\t\t\t\t\t}\n-\t\t\t\t\t// In case of FactoryBean, try to match FactoryBean itself next.\n-\t\t\t\t\tbeanName = FACTORY_BEAN_PREFIX + beanName;\n-\t\t\t\t}\n-\t\t\t\t// Match raw bean instance (might be raw FactoryBean).\n-\t\t\t\tif (isTypeMatch(beanName, type)) {\n-\t\t\t\t\tresult.add(beanName);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn StringUtils.toStringArray(result);\n-\t}\n-\n-\t/**\n-\t * Check whether the specified bean would need to be eagerly initialized\n-\t * in order to determine its type.\n-\t * @param factoryBeanName a factory-bean reference that the bean definition\n-\t * defines a factory method for\n-\t * @return whether eager initialization is necessary\n-\t */\n-\tprivate boolean requiresEagerInitForType(String factoryBeanName) {\n-\t\treturn (factoryBeanName != null && isFactoryBean(factoryBeanName) && !containsSingleton(factoryBeanName));\n-\t}\n-\n-\tpublic <T> Map<String, T> getBeansOfType(Class<T> type) throws BeansException {\n-\t\treturn getBeansOfType(type, true, true);\n-\t}\n-\n-\tpublic <T> Map<String, T> getBeansOfType(Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)\n-\t\t\tthrows BeansException {\n-\n-\t\tString[] beanNames = getBeanNamesForType(type, includeNonSingletons, allowEagerInit);\n-\t\tMap<String, T> result = new LinkedHashMap<String, T>(beanNames.length);\n-\t\tfor (String beanName : beanNames) {\n-\t\t\ttry {\n-\t\t\t\tresult.put(beanName, getBean(beanName, type));\n-\t\t\t}\n-\t\t\tcatch (BeanCreationException ex) {\n-\t\t\t\tThrowable rootCause = ex.getMostSpecificCause();\n-\t\t\t\tif (rootCause instanceof BeanCurrentlyInCreationException) {\n-\t\t\t\t\tBeanCreationException bce = (BeanCreationException) rootCause;\n-\t\t\t\t\tif (isCurrentlyInCreation(bce.getBeanName())) {\n-\t\t\t\t\t\tif (this.logger.isDebugEnabled()) {\n-\t\t\t\t\t\t\tthis.logger.debug(\"Ignoring match to currently created bean '\" + beanName + \"': \" +\n-\t\t\t\t\t\t\t\t\tex.getMessage());\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tonSuppressedException(ex);\n-\t\t\t\t\t\t// Ignore: indicates a circular reference when autowiring constructors.\n-\t\t\t\t\t\t// We want to find matches other than the currently created bean itself.\n-\t\t\t\t\t\tcontinue;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tthrow ex;\n-\t\t\t}\n-\t\t}\n-\t\treturn result;\n-\t}\n-\n-\tpublic Map<String, Object> getBeansWithAnnotation(Class<? extends Annotation> annotationType) {\n-\t\tSet<String> beanNames = new LinkedHashSet<String>(getBeanDefinitionCount());\n-\t\tbeanNames.addAll(Arrays.asList(getBeanDefinitionNames()));\n-\t\tbeanNames.addAll(Arrays.asList(getSingletonNames()));\n-\t\tMap<String, Object> results = new LinkedHashMap<String, Object>();\n-\t\tfor (String beanName : beanNames) {\n-\t\t\tif (findAnnotationOnBean(beanName, annotationType) != null) {\n-\t\t\t\tresults.put(beanName, getBean(beanName));\n-\t\t\t}\n-\t\t}\n-\t\treturn results;\n-\t}\n-\n-\t/**\n-\t * Find a {@link Annotation} of <code>annotationType</code> on the specified\n-\t * bean, traversing its interfaces and super classes if no annotation can be\n-\t * found on the given class itself, as well as checking its raw bean class\n-\t * if not found on the exposed bean reference (e.g. in case of a proxy).\n-\t */\n-\tpublic <A extends Annotation> A findAnnotationOnBean(String beanName, Class<A> annotationType) {\n-\t\tA ann = null;\n-\t\tClass beanType = getType(beanName);\n-\t\tif (beanType != null) {\n-\t\t\tann = AnnotationUtils.findAnnotation(beanType, annotationType);\n-\t\t}\n-\t\tif (ann == null && containsBeanDefinition(beanName)) {\n-\t\t\tBeanDefinition bd = getMergedBeanDefinition(beanName);\n-\t\t\tif (bd instanceof AbstractBeanDefinition) {\n-\t\t\t\tAbstractBeanDefinition abd = (AbstractBeanDefinition) bd;\n-\t\t\t\tif (abd.hasBeanClass()) {\n-\t\t\t\t\tann = AnnotationUtils.findAnnotation(abd.getBeanClass(), annotationType);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn ann;\n-\t}\n-\n-\n-\t//---------------------------------------------------------------------\n-\t// Implementation of ConfigurableListableBeanFactory interface\n-\t//---------------------------------------------------------------------\n-\n-\tpublic void registerResolvableDependency(Class dependencyType, Object autowiredValue) {\n-\t\tAssert.notNull(dependencyType, \"Type must not be null\");\n-\t\tif (autowiredValue != null) {\n-\t\t\tAssert.isTrue((autowiredValue instanceof ObjectFactory || dependencyType.isInstance(autowiredValue)),\n-\t\t\t\t\t\"Value [\" + autowiredValue + \"] does not implement specified type [\" + dependencyType.getName() + \"]\");\n-\t\t\tthis.resolvableDependencies.put(dependencyType, autowiredValue);\n-\t\t}\n-\t}\n-\n-\tpublic boolean isAutowireCandidate(String beanName, DependencyDescriptor descriptor)\n-\t\t\tthrows NoSuchBeanDefinitionException {\n-\n-\t\t// Consider FactoryBeans as autowiring candidates.\n-\t\tboolean isFactoryBean = (descriptor != null && descriptor.getDependencyType() != null &&\n-\t\t\t\tFactoryBean.class.isAssignableFrom(descriptor.getDependencyType()));\n-\t\tif (isFactoryBean) {\n-\t\t\tbeanName = BeanFactoryUtils.transformedBeanName(beanName);\n-\t\t}\n-\n-\t\tif (containsBeanDefinition(beanName)) {\n-\t\t\treturn isAutowireCandidate(beanName, getMergedLocalBeanDefinition(beanName), descriptor);\n-\t\t}\n-\t\telse if (containsSingleton(beanName)) {\n-\t\t\treturn isAutowireCandidate(beanName, new RootBeanDefinition(getType(beanName)), descriptor);\n-\t\t}\n-\t\telse if (getParentBeanFactory() instanceof ConfigurableListableBeanFactory) {\n-\t\t\t// No bean definition found in this factory -> delegate to parent.\n-\t\t\treturn ((ConfigurableListableBeanFactory) getParentBeanFactory()).isAutowireCandidate(beanName, descriptor);\n-\t\t}\n-\t\telse {\n-\t\t\treturn true;\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Determine whether the specified bean definition qualifies as an autowire candidate,\n-\t * to be injected into other beans which declare a dependency of matching type.\n-\t * @param beanName the name of the bean definition to check\n-\t * @param mbd the merged bean definition to check\n-\t * @param descriptor the descriptor of the dependency to resolve\n-\t * @return whether the bean should be considered as autowire candidate\n-\t */\n-\tprotected boolean isAutowireCandidate(String beanName, RootBeanDefinition mbd, DependencyDescriptor descriptor) {\n-\t\tresolveBeanClass(mbd, beanName);\n-\t\tif (mbd.isFactoryMethodUnique) {\n-\t\t\tboolean resolve;\n-\t\t\tsynchronized (mbd.constructorArgumentLock) {\n-\t\t\t\tresolve = (mbd.resolvedConstructorOrFactoryMethod == null);\n-\t\t\t}\n-\t\t\tif (resolve) {\n-\t\t\t\tnew ConstructorResolver(this).resolveFactoryMethodIfPossible(mbd);\n-\t\t\t}\n-\t\t}\n-\t\treturn getAutowireCandidateResolver().isAutowireCandidate(\n-\t\t\t\tnew BeanDefinitionHolder(mbd, beanName, getAliases(beanName)), descriptor);\n-\t}\n-\n-\t@Override\n-\tpublic BeanDefinition getBeanDefinition(String beanName) throws NoSuchBeanDefinitionException {\n-\t\tBeanDefinition bd = this.beanDefinitionMap.get(beanName);\n-\t\tif (bd == null) {\n-\t\t\tif (this.logger.isTraceEnabled()) {\n-\t\t\t\tthis.logger.trace(\"No bean named '\" + beanName + \"' found in \" + this);\n-\t\t\t}\n-\t\t\tthrow new NoSuchBeanDefinitionException(beanName);\n-\t\t}\n-\t\treturn bd;\n-\t}\n-\n-\tpublic void freezeConfiguration() {\n-\t\tthis.configurationFrozen = true;\n-\t\tsynchronized (this.beanDefinitionMap) {\n-\t\t\tthis.frozenBeanDefinitionNames = StringUtils.toStringArray(this.beanDefinitionNames);\n-\t\t}\n-\t}\n-\n-\tpublic boolean isConfigurationFrozen() {\n-\t\treturn this.configurationFrozen;\n-\t}\n-\n-\t/**\n-\t * Considers all beans as eligible for metdata caching\n-\t * if the factory's configuration has been marked as frozen.\n-\t * @see #freezeConfiguration()\n-\t */\n-\t@Override\n-\tprotected boolean isBeanEligibleForMetadataCaching(String beanName) {\n-\t\treturn (this.configurationFrozen || super.isBeanEligibleForMetadataCaching(beanName));\n-\t}\n-\n-\tpublic void preInstantiateSingletons() throws BeansException {\n-\t\tif (this.logger.isInfoEnabled()) {\n-\t\t\tthis.logger.info(\"Pre-instantiating singletons in \" + this);\n-\t\t}\n-\n-\t\tsynchronized (this.beanDefinitionMap) {\n-\t\t\tfor (String beanName : this.beanDefinitionNames) {\n-\t\t\t\tRootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);\n-\t\t\t\tif (!bd.isAbstract() && bd.isSingleton() && !bd.isLazyInit()) {\n-\t\t\t\t\tif (isFactoryBean(beanName)) {\n-\t\t\t\t\t\tfinal FactoryBean factory = (FactoryBean) getBean(FACTORY_BEAN_PREFIX + beanName);\n-\t\t\t\t\t\tboolean isEagerInit;\n-\t\t\t\t\t\tif (System.getSecurityManager() != null && factory instanceof SmartFactoryBean) {\n-\t\t\t\t\t\t\tisEagerInit = AccessController.doPrivileged(new PrivilegedAction<Boolean>() {\n-\t\t\t\t\t\t\t\tpublic Boolean run() {\n-\t\t\t\t\t\t\t\t\treturn ((SmartFactoryBean) factory).isEagerInit();\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}, getAccessControlContext());\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\telse {\n-\t\t\t\t\t\t\tisEagerInit = factory instanceof SmartFactoryBean && ((SmartFactoryBean) factory).isEagerInit(); \n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tif (isEagerInit) {\n-\t\t\t\t\t\t\tgetBean(beanName);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\telse {\n-\t\t\t\t\t\tgetBean(beanName);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\n-\t//---------------------------------------------------------------------\n-\t// Implementation of BeanDefinitionRegistry interface\n-\t//---------------------------------------------------------------------\n-\n-\tpublic void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)\n-\t\t\tthrows BeanDefinitionStoreException {\n-\n-\t\tAssert.hasText(beanName, \"Bean name must not be empty\");\n-\t\tAssert.notNull(beanDefinition, \"BeanDefinition must not be null\");\n-\n-\t\tif (beanDefinition instanceof AbstractBeanDefinition) {\n-\t\t\ttry {\n-\t\t\t\t((AbstractBeanDefinition) beanDefinition).validate();\n-\t\t\t}\n-\t\t\tcatch (BeanDefinitionValidationException ex) {\n-\t\t\t\tthrow new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,\n-\t\t\t\t\t\t\"Validation of bean definition failed\", ex);\n-\t\t\t}\n-\t\t}\n-\n-\t\tsynchronized (this.beanDefinitionMap) {\n-\t\t\tObject oldBeanDefinition = this.beanDefinitionMap.get(beanName);\n-\t\t\tif (oldBeanDefinition != null) {\n-\t\t\t\tif (!this.allowBeanDefinitionOverriding) {\n-\t\t\t\t\tthrow new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,\n-\t\t\t\t\t\t\t\"Cannot register bean definition [\" + beanDefinition + \"] for bean '\" + beanName +\n-\t\t\t\t\t\t\t\"': There is already [\" + oldBeanDefinition + \"] bound.\");\n-\t\t\t\t}\n-\t\t\t\telse {\n-\t\t\t\t\tif (this.logger.isInfoEnabled()) {\n-\t\t\t\t\t\tthis.logger.info(\"Overriding bean definition for bean '\" + beanName +\n-\t\t\t\t\t\t\t\t\"': replacing [\" + oldBeanDefinition + \"] with [\" + beanDefinition + \"]\");\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\telse {\n-\t\t\t\tthis.beanDefinitionNames.add(beanName);\n-\t\t\t\tthis.frozenBeanDefinitionNames = null;\n-\t\t\t}\n-\t\t\tthis.beanDefinitionMap.put(beanName, beanDefinition);\n-\n-\t\t\tresetBeanDefinition(beanName);\n-\t\t}\n-\t}\n-\n-\tpublic void removeBeanDefinition(String beanName) throws NoSuchBeanDefinitionException {\n-\t\tAssert.hasText(beanName, \"'beanName' must not be empty\");\n-\n-\t\tsynchronized (this.beanDefinitionMap) {\n-\t\t\tBeanDefinition bd = this.beanDefinitionMap.remove(beanName);\n-\t\t\tif (bd == null) {\n-\t\t\t\tif (this.logger.isTraceEnabled()) {\n-\t\t\t\t\tthis.logger.trace(\"No bean named '\" + beanName + \"' found in \" + this);\n-\t\t\t\t}\n-\t\t\t\tthrow new NoSuchBeanDefinitionException(beanName);\n-\t\t\t}\n-\t\t\tthis.beanDefinitionNames.remove(beanName);\n-\t\t\tthis.frozenBeanDefinitionNames = null;\n-\n-\t\t\tresetBeanDefinition(beanName);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Reset all bean definition caches for the given bean,\n-\t * including the caches of beans that are derived from it.\n-\t * @param beanName the name of the bean to reset\n-\t */\n-\tprotected void resetBeanDefinition(String beanName) {\n-\t\t// Remove the merged bean definition for the given bean, if already created.\n-\t\tclearMergedBeanDefinition(beanName);\n-\n-\t\t// Remove corresponding bean from singleton cache, if any. Shouldn't usually\n-\t\t// be necessary, rather just meant for overriding a context's default beans\n-\t\t// (e.g. the default StaticMessageSource in a StaticApplicationContext).\n-\t\tsynchronized (getSingletonMutex()) {\n-\t\t\tdestroySingleton(beanName);\n-\t\t}\n-\n-\t\t// Reset all bean definitions that have the given bean as parent\n-\t\t// (recursively).\n-\t\tfor (String bdName : this.beanDefinitionNames) {\n-\t\t\tif (!beanName.equals(bdName)) {\n-\t\t\t\tBeanDefinition bd = this.beanDefinitionMap.get(bdName);\n-\t\t\t\tif (beanName.equals(bd.getParentName())) {\n-\t\t\t\t\tresetBeanDefinition(bdName);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Only allows alias overriding if bean definition overriding is allowed.\n-\t */\n-\t@Override\n-\tprotected boolean allowAliasOverriding() {\n-\t\treturn this.allowBeanDefinitionOverriding;\n-\t}\n-\n-\n-\t//---------------------------------------------------------------------\n-\t// Dependency resolution functionality\n-\t//---------------------------------------------------------------------\n-\n-\tpublic Object resolveDependency(DependencyDescriptor descriptor, String beanName,\n-\t\t\tSet<String> autowiredBeanNames, TypeConverter typeConverter) throws BeansException  {\n-\n-\t\tdescriptor.initParameterNameDiscovery(getParameterNameDiscoverer());\n-\t\tif (descriptor.getDependencyType().equals(ObjectFactory.class)) {\n-\t\t\treturn new DependencyObjectFactory(descriptor, beanName);\n-\t\t}\n-\t\telse if (descriptor.getDependencyType().equals(javaxInjectProviderClass)) {\n-\t\t\treturn new DependencyProviderFactory().createDependencyProvider(descriptor, beanName);\n-\t\t}\n-\t\telse {\n-\t\t\treturn doResolveDependency(descriptor, descriptor.getDependencyType(), beanName, autowiredBeanNames, typeConverter);\n-\t\t}\n-\t}\n-\n-\tprotected Object doResolveDependency(DependencyDescriptor descriptor, Class<?> type, String beanName,\n-\t\t\tSet<String> autowiredBeanNames, TypeConverter typeConverter) throws BeansException  {\n-\n-\t\tObject value = getAutowireCandidateResolver().getSuggestedValue(descriptor);\n-\t\tif (value != null) {\n-\t\t\tif (value instanceof String) {\n-\t\t\t\tString strVal = resolveEmbeddedValue((String) value);\n-\t\t\t\tBeanDefinition bd = (containsBean(beanName) ? getMergedBeanDefinition(beanName) : null);\n-\t\t\t\tvalue = evaluateBeanDefinitionString(strVal, bd);\n-\t\t\t}\n-\t\t\tTypeConverter converter = (typeConverter != null ? typeConverter : getTypeConverter());\n-\t\t\treturn converter.convertIfNecessary(value, type);\n-\t\t}\n-\n-\t\tif (type.isArray()) {\n-\t\t\tClass componentType = type.getComponentType();\n-\t\t\tMap<String, Object> matchingBeans = findAutowireCandidates(beanName, componentType, descriptor);\n-\t\t\tif (matchingBeans.isEmpty()) {\n-\t\t\t\tif (descriptor.isRequired()) {\n-\t\t\t\t\traiseNoSuchBeanDefinitionException(componentType, \"array of \" + componentType.getName(), descriptor);\n-\t\t\t\t}\n-\t\t\t\treturn null;\n-\t\t\t}\n-\t\t\tif (autowiredBeanNames != null) {\n-\t\t\t\tautowiredBeanNames.addAll(matchingBeans.keySet());\n-\t\t\t}\n-\t\t\tTypeConverter converter = (typeConverter != null ? typeConverter : getTypeConverter());\n-\t\t\treturn converter.convertIfNecessary(matchingBeans.values(), type);\n-\t\t}\n-\t\telse if (Collection.class.isAssignableFrom(type) && type.isInterface()) {\n-\t\t\tClass elementType = descriptor.getCollectionType();\n-\t\t\tif (elementType == null) {\n-\t\t\t\tif (descriptor.isRequired()) {\n-\t\t\t\t\tthrow new FatalBeanException(\"No element type declared for collection [\" + type.getName() + \"]\");\n-\t\t\t\t}\n-\t\t\t\treturn null;\n-\t\t\t}\n-\t\t\tMap<String, Object> matchingBeans = findAutowireCandidates(beanName, elementType, descriptor);\n-\t\t\tif (matchingBeans.isEmpty()) {\n-\t\t\t\tif (descriptor.isRequired()) {\n-\t\t\t\t\traiseNoSuchBeanDefinitionException(elementType, \"collection of \" + elementType.getName(), descriptor);\n-\t\t\t\t}\n-\t\t\t\treturn null;\n-\t\t\t}\n-\t\t\tif (autowiredBeanNames != null) {\n-\t\t\t\tautowiredBeanNames.addAll(matchingBeans.keySet());\n-\t\t\t}\n-\t\t\tTypeConverter converter = (typeConverter != null ? typeConverter : getTypeConverter());\n-\t\t\treturn converter.convertIfNecessary(matchingBeans.values(), type);\n-\t\t}\n-\t\telse if (Map.class.isAssignableFrom(type) && type.isInterface()) {\n-\t\t\tClass keyType = descriptor.getMapKeyType();\n-\t\t\tif (keyType == null || !String.class.isAssignableFrom(keyType)) {\n-\t\t\t\tif (descriptor.isRequired()) {\n-\t\t\t\t\tthrow new FatalBeanException(\"Key type [\" + keyType + \"] of map [\" + type.getName() +\n-\t\t\t\t\t\t\t\"] must be assignable to [java.lang.String]\");\n-\t\t\t\t}\n-\t\t\t\treturn null;\n-\t\t\t}\n-\t\t\tClass valueType = descriptor.getMapValueType();\n-\t\t\tif (valueType == null) {\n-\t\t\t\tif (descriptor.isRequired()) {\n-\t\t\t\t\tthrow new FatalBeanException(\"No value type declared for map [\" + type.getName() + \"]\");\n-\t\t\t\t}\n-\t\t\t\treturn null;\n-\t\t\t}\n-\t\t\tMap<String, Object> matchingBeans = findAutowireCandidates(beanName, valueType, descriptor);\n-\t\t\tif (matchingBeans.isEmpty()) {\n-\t\t\t\tif (descriptor.isRequired()) {\n-\t\t\t\t\traiseNoSuchBeanDefinitionException(valueType, \"map with value type \" + valueType.getName(), descriptor);\n-\t\t\t\t}\n-\t\t\t\treturn null;\n-\t\t\t}\n-\t\t\tif (autowiredBeanNames != null) {\n-\t\t\t\tautowiredBeanNames.addAll(matchingBeans.keySet());\n-\t\t\t}\n-\t\t\treturn matchingBeans;\n-\t\t}\n-\t\telse {\n-\t\t\tMap<String, Object> matchingBeans = findAutowireCandidates(beanName, type, descriptor);\n-\t\t\tif (matchingBeans.isEmpty()) {\n-\t\t\t\tif (descriptor.isRequired()) {\n-\t\t\t\t\traiseNoSuchBeanDefinitionException(type, \"\", descriptor);\n-\t\t\t\t}\n-\t\t\t\treturn null;\n-\t\t\t}\n-\t\t\tif (matchingBeans.size() > 1) {\n-\t\t\t\tString primaryBeanName = determinePrimaryCandidate(matchingBeans, descriptor);\n-\t\t\t\tif (primaryBeanName == null) {\n-\t\t\t\t\tthrow new NoSuchBeanDefinitionException(type, \"expected single matching bean but found \" +\n-\t\t\t\t\t\t\tmatchingBeans.size() + \": \" + matchingBeans.keySet());\n-\t\t\t\t}\n-\t\t\t\tif (autowiredBeanNames != null) {\n-\t\t\t\t\tautowiredBeanNames.add(primaryBeanName);\n-\t\t\t\t}\n-\t\t\t\treturn matchingBeans.get(primaryBeanName);\n-\t\t\t}\n-\t\t\t// We have exactly one match.\n-\t\t\tMap.Entry<String, Object> entry = matchingBeans.entrySet().iterator().next();\n-\t\t\tif (autowiredBeanNames != null) {\n-\t\t\t\tautowiredBeanNames.add(entry.getKey());\n-\t\t\t}\n-\t\t\treturn entry.getValue();\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Find bean instances that match the required type.\n-\t * Called during autowiring for the specified bean.\n-\t * @param beanName the name of the bean that is about to be wired\n-\t * @param requiredType the actual type of bean to look for\n-\t * (may be an array component type or collection element type)\n-\t * @param descriptor the descriptor of the dependency to resolve\n-\t * @return a Map of candidate names and candidate instances that match\n-\t * the required type (never <code>null</code>)\n-\t * @throws BeansException in case of errors\n-\t * @see #autowireByType\n-\t * @see #autowireConstructor\n-\t */\n-\tprotected Map<String, Object> findAutowireCandidates(\n-\t\t\tString beanName, Class requiredType, DependencyDescriptor descriptor) {\n-\n-\t\tString[] candidateNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(\n-\t\t\t\tthis, requiredType, true, descriptor.isEager());\n-\t\tMap<String, Object> result = new LinkedHashMap<String, Object>(candidateNames.length);\n-\t\tfor (Class autowiringType : this.resolvableDependencies.keySet()) {\n-\t\t\tif (autowiringType.isAssignableFrom(requiredType)) {\n-\t\t\t\tObject autowiringValue = this.resolvableDependencies.get(autowiringType);\n-\t\t\t\tautowiringValue = AutowireUtils.resolveAutowiringValue(autowiringValue, requiredType);\n-\t\t\t\tif (requiredType.isInstance(autowiringValue)) {\n-\t\t\t\t\tresult.put(ObjectUtils.identityToString(autowiringValue), autowiringValue);\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\tfor (String candidateName : candidateNames) {\n-\t\t\tif (!candidateName.equals(beanName) && isAutowireCandidate(candidateName, descriptor)) {\n-\t\t\t\tresult.put(candidateName, getBean(candidateName));\n-\t\t\t}\n-\t\t}\n-\t\treturn result;\n-\t}\n-\n-\t/**\n-\t * Determine the primary autowire candidate in the given set of beans.\n-\t * @param candidateBeans a Map of candidate names and candidate instances\n-\t * that match the required type, as returned by {@link #findAutowireCandidates}\n-\t * @param descriptor the target dependency to match against\n-\t * @return the name of the primary candidate, or <code>null</code> if none found\n-\t */\n-\tprotected String determinePrimaryCandidate(Map<String, Object> candidateBeans, DependencyDescriptor descriptor) {\n-\t\tString primaryBeanName = null;\n-\t\tString fallbackBeanName = null;\n-\t\tfor (Map.Entry<String, Object> entry : candidateBeans.entrySet()) {\n-\t\t\tString candidateBeanName = entry.getKey();\n-\t\t\tObject beanInstance = entry.getValue();\n-\t\t\tif (isPrimary(candidateBeanName, beanInstance)) {\n-\t\t\t\tif (primaryBeanName != null) {\n-\t\t\t\t\tboolean candidateLocal = containsBeanDefinition(candidateBeanName);\n-\t\t\t\t\tboolean primaryLocal = containsBeanDefinition(primaryBeanName);\n-\t\t\t\t\tif (candidateLocal == primaryLocal) {\n-\t\t\t\t\t\tthrow new NoSuchBeanDefinitionException(descriptor.getDependencyType(),\n-\t\t\t\t\t\t\t\t\"more than one 'primary' bean found among candidates: \" + candidateBeans.keySet());\n-\t\t\t\t\t}\n-\t\t\t\t\telse if (candidateLocal && !primaryLocal) {\n-\t\t\t\t\t\tprimaryBeanName = candidateBeanName;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\telse {\n-\t\t\t\t\tprimaryBeanName = candidateBeanName;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tif (primaryBeanName == null &&\n-\t\t\t\t\t(this.resolvableDependencies.values().contains(beanInstance) ||\n-\t\t\t\t\t\t\tmatchesBeanName(candidateBeanName, descriptor.getDependencyName()))) {\n-\t\t\t\tfallbackBeanName = candidateBeanName;\n-\t\t\t}\n-\t\t}\n-\t\treturn (primaryBeanName != null ? primaryBeanName : fallbackBeanName);\n-\t}\n-\n-\t/**\n-\t * Return whether the bean definition for the given bean name has been\n-\t * marked as a primary bean.\n-\t * @param beanName the name of the bean\n-\t * @param beanInstance the corresponding bean instance\n-\t * @return whether the given bean qualifies as primary\n-\t */\n-\tprotected boolean isPrimary(String beanName, Object beanInstance) {\n-\t\tif (containsBeanDefinition(beanName)) {\n-\t\t\treturn getMergedLocalBeanDefinition(beanName).isPrimary();\n-\t\t}\n-\t\tBeanFactory parentFactory = getParentBeanFactory();\n-\t\treturn (parentFactory instanceof DefaultListableBeanFactory &&\n-\t\t\t\t((DefaultListableBeanFactory) parentFactory).isPrimary(beanName, beanInstance));\n-\t}\n-\n-\t/**\n-\t * Determine whether the given candidate name matches the bean name or the aliases\n-\t * stored in this bean definition.\n-\t */\n-\tprotected boolean matchesBeanName(String beanName, String candidateName) {\n-\t\treturn (candidateName != null &&\n-\t\t\t\t(candidateName.equals(beanName) || ObjectUtils.containsElement(getAliases(beanName), candidateName)));\n-\t}\n-\n-\t/**\n-\t * Raise a NoSuchBeanDefinitionException for an unresolvable dependency.\n-\t */\n-\tprivate void raiseNoSuchBeanDefinitionException(\n-\t\t\tClass type, String dependencyDescription, DependencyDescriptor descriptor)\n-\t\t\tthrows NoSuchBeanDefinitionException {\n-\n-\t\tthrow new NoSuchBeanDefinitionException(type, dependencyDescription,\n-\t\t\t\t\"expected at least 1 bean which qualifies as autowire candidate for this dependency. \" +\n-\t\t\t\t\"Dependency annotations: \" + ObjectUtils.nullSafeToString(descriptor.getAnnotations()));\n-\t}\n-\n-\n-\t@Override\n-\tpublic String toString() {\n-\t\tStringBuilder sb = new StringBuilder(ObjectUtils.identityToString(this));\n-\t\tsb.append(\": defining beans [\");\n-\t\tsb.append(StringUtils.arrayToCommaDelimitedString(getBeanDefinitionNames()));\n-\t\tsb.append(\"]; \");\n-\t\tBeanFactory parent = getParentBeanFactory();\n-\t\tif (parent == null) {\n-\t\t\tsb.append(\"root of factory hierarchy\");\n-\t\t}\n-\t\telse {\n-\t\t\tsb.append(\"parent: \").append(ObjectUtils.identityToString(parent));\n-\t\t}\n-\t\treturn sb.toString();\n-\t}\n-\n-\n-\t//---------------------------------------------------------------------\n-\t// Serialization support\n-\t//---------------------------------------------------------------------\n-\n-\tprotected Object writeReplace() throws ObjectStreamException {\n-\t\tif (this.serializationId != null) {\n-\t\t\treturn new SerializedBeanFactoryReference(this.serializationId);\n-\t\t}\n-\t\telse {\n-\t\t\tthrow new NotSerializableException(\"DefaultListableBeanFactory has no serialization id\");\n-\t\t}\n-\t}\n-\n-\n-\t/**\n-\t * Minimal id reference to the factory.\n-\t * Resolved to the actual factory instance on deserialization.\n-\t */\n-\tprivate static class SerializedBeanFactoryReference implements Serializable {\n-\n-\t\tprivate final String id;\n-\n-\t\tpublic SerializedBeanFactoryReference(String id) {\n-\t\t\tthis.id = id;\n-\t\t}\n-\n-\t\tprivate Object readResolve() {\n-\t\t\tReference ref = serializableFactories.get(this.id);\n-\t\t\tif (ref == null) {\n-\t\t\t\tthrow new IllegalStateException(\n-\t\t\t\t\t\t\"Cannot deserialize BeanFactory with id \" + this.id + \": no factory registered for this id\");\n-\t\t\t}\n-\t\t\tObject result = ref.get();\n-\t\t\tif (result == null) {\n-\t\t\t\tthrow new IllegalStateException(\n-\t\t\t\t\t\t\"Cannot deserialize BeanFactory with id \" + this.id + \": factory has been garbage-collected\");\n-\t\t\t}\n-\t\t\treturn result;\n-\t\t}\n-\t}\n-\n-\n-\t/**\n-\t * Serializable ObjectFactory for lazy resolution of a dependency.\n-\t */\n-\tprivate class DependencyObjectFactory implements ObjectFactory, Serializable {\n-\n-\t\tprivate final DependencyDescriptor descriptor;\n-\n-\t\tprivate final String beanName;\n-\n-\t\tprivate final Class type;\n-\n-\t\tpublic DependencyObjectFactory(DependencyDescriptor descriptor, String beanName) {\n-\t\t\tthis.descriptor = descriptor;\n-\t\t\tthis.beanName = beanName;\n-\t\t\tthis.type = determineObjectFactoryType();\n-\t\t}\n-\n-\t\tprivate Class determineObjectFactoryType() {\n-\t\t\tType type = this.descriptor.getGenericDependencyType();\n-\t\t\tif (type instanceof ParameterizedType) {\n-\t\t\t\tType arg = ((ParameterizedType) type).getActualTypeArguments()[0];\n-\t\t\t\tif (arg instanceof Class) {\n-\t\t\t\t\treturn (Class) arg;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\treturn Object.class;\n-\t\t}\n-\n-\t\tpublic Object getObject() throws BeansException {\n-\t\t\treturn doResolveDependency(this.descriptor, this.type, this.beanName, null, null);\n-\t\t}\n-\t}\n-\n-\n-\t/**\n-\t * Serializable ObjectFactory for lazy resolution of a dependency.\n-\t */\n-\tprivate class DependencyProvider extends DependencyObjectFactory implements Provider {\n-\n-\t\tpublic DependencyProvider(DependencyDescriptor descriptor, String beanName) {\n-\t\t\tsuper(descriptor, beanName);\n-\t\t}\n-\n-\t\tpublic Object get() throws BeansException {\n-\t\t\treturn getObject();\n-\t\t}\n-\t}\n-\n-\n-\t/**\n-\t * Separate inner class for avoiding a hard dependency on the <code>javax.inject</code> API.\n-\t */\n-\tprivate class DependencyProviderFactory {\n-\n-\t\tpublic Object createDependencyProvider(DependencyDescriptor descriptor, String beanName) {\n-\t\t\treturn new DependencyProvider(descriptor, beanName);\n-\t\t}\n-\t}\n-\n-}\n-"},{"sha":"94f1bfe4c3d2dec403ad36c0f401c5bcf37c611f","filename":"core/src/test/java/org/syncope/core/rest/TaskTestITCase.java","status":"modified","additions":0,"deletions":1,"changes":1,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/18a3262e1059623a08ef97099edb3ba50583b7b8/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fsyncope%2Fcore%2Frest%2FTaskTestITCase.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/18a3262e1059623a08ef97099edb3ba50583b7b8/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fsyncope%2Fcore%2Frest%2FTaskTestITCase.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fsyncope%2Fcore%2Frest%2FTaskTestITCase.java?ref=18a3262e1059623a08ef97099edb3ba50583b7b8","patch":"@@ -112,7 +112,6 @@ public final void paginatedList() {\n \n         assertNotNull(tasks);\n         assertFalse(tasks.isEmpty());\n-        assertEquals(2, tasks.size());\n \n         for (TaskTO task : tasks) {\n             assertNotNull(task);"},{"sha":"e924d35bd48ba31d82e9ea13941eae930c0ab177","filename":"pom.xml","status":"modified","additions":15,"deletions":23,"changes":38,"blob_url":"https://github.com/EnricoDAlessandro97UNI/syncope/blob/18a3262e1059623a08ef97099edb3ba50583b7b8/pom.xml","raw_url":"https://github.com/EnricoDAlessandro97UNI/syncope/raw/18a3262e1059623a08ef97099edb3ba50583b7b8/pom.xml","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/syncope/contents/pom.xml?ref=18a3262e1059623a08ef97099edb3ba50583b7b8","patch":"@@ -77,7 +77,6 @@\n         <connid.db.table.version>1.2.1</connid.db.table.version>\n \n         <commons-jexl.version>2.0.1</commons-jexl.version>\n-        <commons-lang.version>2.6</commons-lang.version>\n         <commons-httpclient.version>3.1</commons-httpclient.version>\n \n         <javamail-specs.version>1.6</javamail-specs.version>\n@@ -88,19 +87,19 @@\n         <oscore.version>2.2.6</oscore.version>\n         <bsh.version>2.0b4</bsh.version>\n \n-        <spring.version>3.0.5.RELEASE</spring.version>\n-        <cglib.version>2.2</cglib.version>\n-        <jackson.version>1.5.3</jackson.version>\n-        <xstream.version>1.3.1</xstream.version>\n-        <aspectj.version>1.6.9</aspectj.version>\n+        <spring.version>3.0.6.RELEASE</spring.version>\n+        <cglib.version>2.2.2</cglib.version>\n+        <jackson.version>1.8.5</jackson.version>\n+        <xstream.version>1.4.1</xstream.version>\n+        <aspectj.version>1.6.11</aspectj.version>\n         <velocity.version>1.7</velocity.version>\n         <quartz.version>1.8.5</quartz.version>\n \n         <hibernate.version>3.6.7.Final</hibernate.version>\n         <hibernate-validator.version>4.2.0.Final</hibernate-validator.version>\n         <ehcache.version>2.4.4</ehcache.version>\n \n-        <wicket.version>1.4.17</wicket.version>\n+        <wicket.version>1.4.18</wicket.version>\n \n         <org.apache.cxf.version>2.4.2</org.apache.cxf.version>\n \n@@ -115,7 +114,6 @@\n \n         <dbunit.version>2.4.8</dbunit.version>\n \n-        <cargo.version>1.1.1</cargo.version>\n         <tomcat.version>7.0.20</tomcat.version>\n \n         <bundles.directory>/var/tmp/bundles</bundles.directory>\n@@ -163,12 +161,6 @@\n                 <version>${commons-jexl.version}</version>\n             </dependency>\n \n-            <dependency>\n-                <groupId>commons-lang</groupId>\n-                <artifactId>commons-lang</artifactId>\n-                <version>${commons-lang.version}</version>\n-            </dependency>\n-\n             <dependency>\n                 <groupId>commons-httpclient</groupId>\n                 <artifactId>commons-httpclient</artifactId>\n@@ -494,25 +486,25 @@\n                 <plugin>\n                     <groupId>org.apache.maven.plugins</groupId>\n                     <artifactId>maven-surefire-plugin</artifactId>\n-                    <version>2.8</version>\n+                    <version>2.9</version>\n                     <configuration>\n                         <redirectTestOutputToFile>true</redirectTestOutputToFile>\n                     </configuration>\n                 </plugin>\n                 <plugin>\n                     <groupId>org.apache.maven.plugins</groupId>\n                     <artifactId>maven-checkstyle-plugin</artifactId>\n-                    <version>2.6</version>\n+                    <version>2.7</version>\n                 </plugin>\n                 <plugin>\n                     <groupId>org.apache.maven.plugins</groupId>\n                     <artifactId>maven-jxr-plugin</artifactId>\n-                    <version>2.2</version>\n+                    <version>2.3</version>\n                 </plugin>\n                 <plugin>\n                     <groupId>org.apache.maven.plugins</groupId>\n                     <artifactId>maven-javadoc-plugin</artifactId>\n-                    <version>2.7</version>\n+                    <version>2.8</version>\n                 </plugin>\n                 <plugin>\n                     <groupId>org.apache.maven.plugins</groupId>\n@@ -522,15 +514,15 @@\n                 <plugin>\n                     <groupId>org.apache.maven.plugins</groupId>\n                     <artifactId>maven-site-plugin</artifactId>\n-                    <version>2.2</version>\n+                    <version>3.0</version>\n                     <configuration>\n                         <locales>en,it</locales>\n                     </configuration>\n                 </plugin>\n                 <plugin>\n                     <groupId>org.apache.maven.plugins</groupId>\n                     <artifactId>maven-war-plugin</artifactId>\n-                    <version>2.1</version>\n+                    <version>2.1.1</version>\n                 </plugin>\n                 <plugin>\n                     <groupId>org.codehaus.mojo</groupId>\n@@ -545,7 +537,7 @@\n                 <plugin>\n                     <groupId>org.apache.maven.plugins</groupId>\n                     <artifactId>maven-failsafe-plugin</artifactId>\n-                    <version>2.6</version>\n+                    <version>2.9</version>\n                     <executions>\n                         <execution>\n                             <goals>\n@@ -563,12 +555,12 @@\n                 <plugin>\n                     <groupId>org.apache.maven.plugins</groupId>\n                     <artifactId>maven-dependency-plugin</artifactId>\n-                    <version>2.2</version>\n+                    <version>2.3</version>\n                 </plugin>\n                 <plugin>\n                     <groupId>org.codehaus.cargo</groupId>\n                     <artifactId>cargo-maven2-plugin</artifactId>\n-                    <version>${cargo.version}</version>\n+                    <version>1.1.2</version>\n                 </plugin>\n             </plugins>\n         </pluginManagement>"}]}