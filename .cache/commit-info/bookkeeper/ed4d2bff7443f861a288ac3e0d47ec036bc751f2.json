{"sha":"ed4d2bff7443f861a288ac3e0d47ec036bc751f2","node_id":"MDY6Q29tbWl0NDc4NTkyNTI2OmVkNGQyYmZmNzQ0M2Y4NjFhMjg4YWMzZTBkNDdlYzAzNmJjNzUxZjI=","commit":{"author":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2016-12-21T08:09:57Z"},"committer":{"name":"Sijie Guo","email":"sijieg@twitter.com","date":"2016-12-21T08:09:57Z"},"message":"DL-97: Remove unused methods in BKLogHandler\n\nmerge code change on remove unused methods in BKLogHandler.\n\nAuthor: Sijie Guo <sijie@apache.org>\nAuthor: Sijie Guo <sijieg@twitter.com>\nAuthor: Leigh Stewart <lstewart@twitter.com>\nAuthor: Jordan Bull <jbull@twitter.com>\nAuthor: Dave Rusek <dave.rusek@gmail.com>\nAuthor: Dave Rusek <drusek@twitter.com>\n\nReviewers: Leigh Stewart <lstewart@apache.org>\n\nCloses #69 from sijie/merge/DL-97","tree":{"sha":"acf1793a946991db1dd306041a3b72e92705c587","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/trees/acf1793a946991db1dd306041a3b72e92705c587"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/commits/ed4d2bff7443f861a288ac3e0d47ec036bc751f2","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/ed4d2bff7443f861a288ac3e0d47ec036bc751f2","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/ed4d2bff7443f861a288ac3e0d47ec036bc751f2","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/ed4d2bff7443f861a288ac3e0d47ec036bc751f2/comments","author":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"committer":null,"parents":[{"sha":"77de65efa4e06aa4434ba87f4760e6851ae8c6ba","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/77de65efa4e06aa4434ba87f4760e6851ae8c6ba","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/77de65efa4e06aa4434ba87f4760e6851ae8c6ba"}],"stats":{"total":381,"additions":147,"deletions":234},"files":[{"sha":"b1a927355d065306baf8e6c691e11e43ff274059","filename":"src/main/java/com/twitter/distributedlog/BKAsyncLogReaderDLSN.java","status":"modified","additions":1,"deletions":14,"changes":15,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/ed4d2bff7443f861a288ac3e0d47ec036bc751f2/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FBKAsyncLogReaderDLSN.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/ed4d2bff7443f861a288ac3e0d47ec036bc751f2/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FBKAsyncLogReaderDLSN.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FBKAsyncLogReaderDLSN.java?ref=ed4d2bff7443f861a288ac3e0d47ec036bc751f2","patch":"@@ -49,7 +49,6 @@\n import org.apache.bookkeeper.stats.Counter;\n import org.apache.bookkeeper.stats.OpStatsLogger;\n import org.apache.bookkeeper.stats.StatsLogger;\n-import org.apache.zookeeper.Watcher;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import scala.Function1;\n@@ -73,7 +72,7 @@\n  * <li> `async_reader`/idle_reader_error: counter. the number idle reader errors.\n  * </ul>\n  */\n-class BKAsyncLogReaderDLSN implements ZooKeeperClient.ZooKeeperSessionExpireNotifier, AsyncLogReader, Runnable, AsyncNotification {\n+class BKAsyncLogReaderDLSN implements AsyncLogReader, Runnable, AsyncNotification {\n     static final Logger LOG = LoggerFactory.getLogger(BKAsyncLogReaderDLSN.class);\n \n     private static final Function1<List<LogRecordWithDLSN>, LogRecordWithDLSN> READ_NEXT_MAP_FUNCTION =\n@@ -86,7 +85,6 @@ public LogRecordWithDLSN apply(List<LogRecordWithDLSN> records) {\n \n     protected final BKDistributedLogManager bkDistributedLogManager;\n     protected final BKLogReadHandler bkLedgerManager;\n-    private Watcher sessionExpireWatcher = null;\n     private final AtomicReference<Throwable> lastException = new AtomicReference<Throwable>();\n     private final ScheduledExecutorService executorService;\n     private final ConcurrentLinkedQueue<PendingReadRequest> pendingRequests = new ConcurrentLinkedQueue<PendingReadRequest>();\n@@ -218,7 +216,6 @@ void complete() {\n         this.executorService = executorService;\n         this.bkLedgerManager = bkDistributedLogManager.createReadHandler(subscriberId,\n                 lockStateExecutor, this, deserializeRecordSet, true);\n-        sessionExpireWatcher = this.bkLedgerManager.registerExpirationHandler(this);\n         LOG.debug(\"Starting async reader at {}\", startDLSN);\n         this.startDLSN = startDLSN;\n         this.scheduleDelayStopwatch = Stopwatch.createUnstarted();\n@@ -255,14 +252,6 @@ void complete() {\n         this.idleReaderTimeoutTask = scheduleIdleReaderTaskIfNecessary();\n     }\n \n-    @Override\n-    public void notifySessionExpired() {\n-        // ZK Session notification is an indication to check if this has resulted in a fatal error\n-        // of the underlying reader, in itself this reader doesnt error out unless the underlying\n-        // reader has hit an error\n-        scheduleBackgroundRead();\n-    }\n-\n     private ScheduledFuture<?> scheduleIdleReaderTaskIfNecessary() {\n         if (idleErrorThresholdMillis < Integer.MAX_VALUE) {\n             // Dont run the task more than once every seconds (for sanity)\n@@ -494,8 +483,6 @@ public Future<Void> asyncClose() {\n \n         cancelAllPendingReads(exception);\n \n-        bkLedgerManager.unregister(sessionExpireWatcher);\n-\n         FutureUtils.ignore(bkLedgerManager.asyncClose()).proxyTo(closePromise);\n         return closePromise;\n     }"},{"sha":"2df104684381b08c1610efcba1336a10fa9e6b56","filename":"src/main/java/com/twitter/distributedlog/BKDistributedLogNamespace.java","status":"modified","additions":15,"deletions":5,"changes":20,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/ed4d2bff7443f861a288ac3e0d47ec036bc751f2/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FBKDistributedLogNamespace.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/ed4d2bff7443f861a288ac3e0d47ec036bc751f2/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FBKDistributedLogNamespace.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FBKDistributedLogNamespace.java?ref=ed4d2bff7443f861a288ac3e0d47ec036bc751f2","patch":"@@ -75,6 +75,7 @@\n import org.slf4j.LoggerFactory;\n \n import java.io.IOException;\n+import java.net.InetAddress;\n import java.net.URI;\n import java.util.Collection;\n import java.util.HashMap;\n@@ -252,6 +253,14 @@ private static <T> T withZooKeeperClient(ZooKeeperClientHandler<T> handler,\n         }\n     }\n \n+    private static String getHostIpLockClientId() {\n+        try {\n+            return InetAddress.getLocalHost().toString();\n+        } catch(Exception ex) {\n+            return DistributedLogConstants.UNKNOWN_CLIENT_ID;\n+        }\n+    }\n+\n     private final String clientId;\n     private final int regionId;\n     private final DistributedLogConfiguration conf;\n@@ -326,9 +335,13 @@ private BKDistributedLogNamespace(\n         this.featureProvider = featureProvider;\n         this.statsLogger = statsLogger;\n         this.perLogStatsLogger = perLogStatsLogger;\n-        this.clientId = clientId;\n         this.regionId = regionId;\n         this.bkdlConfig = bkdlConfig;\n+        if (clientId.equals(DistributedLogConstants.UNKNOWN_CLIENT_ID)) {\n+            this.clientId = getHostIpLockClientId();\n+        } else {\n+            this.clientId = clientId;\n+        }\n \n         // Build resources\n         StatsLogger schedulerStatsLogger = statsLogger.scope(\"factory\").scope(\"thread_pool\");\n@@ -622,13 +635,10 @@ private static ZooKeeperClientBuilder createBKZKClientBuilder(String zkcName,\n                                                                   DistributedLogConfiguration conf,\n                                                                   String zkServers,\n                                                                   StatsLogger statsLogger) {\n-        RetryPolicy retryPolicy = null;\n-        if (conf.getZKNumRetries() > 0) {\n-            retryPolicy = new BoundExponentialBackoffRetryPolicy(\n+        RetryPolicy retryPolicy = new BoundExponentialBackoffRetryPolicy(\n                     conf.getBKClientZKRetryBackoffStartMillis(),\n                     conf.getBKClientZKRetryBackoffMaxMillis(),\n                     conf.getBKClientZKNumRetries());\n-        }\n         ZooKeeperClientBuilder builder = ZooKeeperClientBuilder.newBuilder()\n                 .name(zkcName)\n                 .sessionTimeoutMs(conf.getBKClientZKSessionTimeoutMilliSeconds())"},{"sha":"460de11f8ac75efe8409bde8865bc9d244284369","filename":"src/main/java/com/twitter/distributedlog/BKLogHandler.java","status":"modified","additions":1,"deletions":139,"changes":140,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/ed4d2bff7443f861a288ac3e0d47ec036bc751f2/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FBKLogHandler.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/ed4d2bff7443f861a288ac3e0d47ec036bc751f2/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FBKLogHandler.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FBKLogHandler.java?ref=ed4d2bff7443f861a288ac3e0d47ec036bc751f2","patch":"@@ -32,9 +32,7 @@\n import com.twitter.distributedlog.logsegment.LogSegmentCache;\n import com.twitter.distributedlog.logsegment.LogSegmentFilter;\n import com.twitter.distributedlog.logsegment.LogSegmentMetadataStore;\n-import com.twitter.distributedlog.util.FutureUtils;\n import com.twitter.distributedlog.util.OrderedScheduler;\n-import com.twitter.distributedlog.util.Utils;\n import com.twitter.util.Function;\n import com.twitter.util.Future;\n import com.twitter.util.FutureEventListener;\n@@ -56,7 +54,6 @@\n import scala.runtime.BoxedUnit;\n \n import java.io.IOException;\n-import java.net.InetAddress;\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.Comparator;\n@@ -104,8 +101,6 @@\n public abstract class BKLogHandler implements Watcher, AsyncCloseable, AsyncAbortable {\n     static final Logger LOG = LoggerFactory.getLogger(BKLogHandler.class);\n \n-    private static final int LAYOUT_VERSION = -1;\n-\n     protected final ZKLogMetadata logMetadata;\n     protected final DistributedLogConfiguration conf;\n     protected final ZooKeeperClient zooKeeperClient;\n@@ -274,12 +269,7 @@ public void run() {\n         LOG.debug(\"Using ZK Path {}\", logMetadata.getLogRootPath());\n         this.bookKeeperClient = bkcBuilder.build();\n         this.metadataStore = metadataStore;\n-\n-        if (lockClientId.equals(DistributedLogConstants.UNKNOWN_CLIENT_ID)) {\n-            this.lockClientId = getHostIpLockClientId();\n-        } else {\n-            this.lockClientId = lockClientId;\n-        }\n+        this.lockClientId = lockClientId;\n \n         this.getChildrenWatcher = this.zooKeeperClient.getWatcherManager()\n                 .registerChildWatcher(logMetadata.getLogSegmentsPath(), this);\n@@ -316,14 +306,6 @@ public String getLockClientId() {\n         return lockClientId;\n     }\n \n-    private String getHostIpLockClientId() {\n-        try {\n-            return InetAddress.getLocalHost().toString();\n-        } catch(Exception ex) {\n-            return DistributedLogConstants.UNKNOWN_CLIENT_ID;\n-        }\n-    }\n-\n     protected void registerListener(LogSegmentListener listener) {\n         listeners.add(listener);\n     }\n@@ -472,57 +454,6 @@ public void onFailure(Throwable cause) {\n         }\n     }\n \n-    public LogRecordWithDLSN getLastLogRecord(boolean recover, boolean includeEndOfStream) throws IOException {\n-        checkLogStreamExists();\n-        List<LogSegmentMetadata> ledgerList = getFullLedgerListDesc(true, true);\n-\n-        for (LogSegmentMetadata metadata: ledgerList) {\n-            LogRecordWithDLSN record = recoverLastRecordInLedger(metadata, recover, false, includeEndOfStream);\n-\n-            if (null != record) {\n-                assert(!record.isControl());\n-                LOG.debug(\"{} getLastLogRecord Returned {}\", getFullyQualifiedName(), record);\n-                return record;\n-            }\n-        }\n-\n-        throw new LogEmptyException(\"Log \" + getFullyQualifiedName() + \" has no records\");\n-    }\n-\n-    public long getLastTxId(boolean recover,\n-                            boolean includeEndOfStream) throws IOException {\n-        checkLogStreamExists();\n-        return getLastLogRecord(recover, includeEndOfStream).getTransactionId();\n-    }\n-\n-    public DLSN getLastDLSN(boolean recover,\n-                            boolean includeEndOfStream) throws IOException {\n-        checkLogStreamExists();\n-        return getLastLogRecord(recover, includeEndOfStream).getDlsn();\n-    }\n-\n-    public long getLogRecordCount() throws IOException {\n-        try {\n-            checkLogStreamExists();\n-        } catch (LogNotFoundException exc) {\n-            return 0;\n-        }\n-\n-        List<LogSegmentMetadata> ledgerList = getFullLedgerList(true, false);\n-        long count = 0;\n-        for (LogSegmentMetadata l : ledgerList) {\n-            if (l.isInProgress()) {\n-                LogRecord record = recoverLastRecordInLedger(l, false, false, false);\n-                if (null != record) {\n-                    count += record.getLastPositionWithinLogSegment();\n-                }\n-            } else {\n-                count += l.getRecordCount();\n-            }\n-        }\n-        return count;\n-    }\n-\n     private Future<LogRecordWithDLSN> asyncReadFirstUserRecord(LogSegmentMetadata ledger, DLSN beginDLSN) {\n         final LedgerHandleCache handleCache =\n                 LedgerHandleCache.newBuilder().bkc(bookKeeperClient).conf(conf).build();\n@@ -634,15 +565,6 @@ private Long sum(List<Long> values) {\n         return sum;\n     }\n \n-    public long getFirstTxId() throws IOException {\n-        checkLogStreamExists();\n-        List<LogSegmentMetadata> ledgerList = getFullLedgerList(true, true);\n-\n-        // The ledger list should at least have one element\n-        // First TxId is populated even for in progress ledgers\n-        return ledgerList.get(0).getFirstTxId();\n-    }\n-\n     Future<Void> checkLogStreamExistsAsync() {\n         final Promise<Void> promise = new Promise<Void>();\n         try {\n@@ -685,54 +607,11 @@ public void processResult(int rc, String path, Object ctx, Stat stat) {\n         return promise;\n     }\n \n-    private void checkLogStreamExists() throws IOException {\n-        try {\n-            if (null == Utils.sync(zooKeeperClient, logMetadata.getLogSegmentsPath())\n-                    .exists(logMetadata.getLogSegmentsPath(), false)) {\n-                throw new LogNotFoundException(\"Log \" + getFullyQualifiedName() + \" doesn't exist\");\n-            }\n-        } catch (InterruptedException ie) {\n-            LOG.error(\"Interrupted while reading {}\", logMetadata.getLogSegmentsPath(), ie);\n-            throw new DLInterruptedException(\"Interrupted while checking \"\n-                    + logMetadata.getLogSegmentsPath(), ie);\n-        } catch (KeeperException ke) {\n-            LOG.error(\"Error checking existence for {} : \", logMetadata.getLogSegmentsPath(), ke);\n-            throw new ZKException(\"Error checking existence for \" + getFullyQualifiedName() + \" : \", ke);\n-        }\n-    }\n-\n     @Override\n     public Future<Void> asyncAbort() {\n         return asyncClose();\n     }\n \n-    /**\n-     * Find the id of the last edit log transaction written to a edit log\n-     * ledger.\n-     */\n-    protected Pair<Long, DLSN> readLastTxIdInLedger(LogSegmentMetadata l) throws IOException {\n-        LogRecordWithDLSN record = recoverLastRecordInLedger(l, false, false, true);\n-\n-        if (null == record) {\n-            return Pair.of(DistributedLogConstants.EMPTY_LOGSEGMENT_TX_ID, DLSN.InvalidDLSN);\n-        }\n-        else {\n-            return Pair.of(record.getTransactionId(), record.getDlsn());\n-        }\n-    }\n-\n-    /**\n-     * Find the id of the last edit log transaction written to a edit log\n-     * ledger.\n-     */\n-    protected LogRecordWithDLSN recoverLastRecordInLedger(LogSegmentMetadata l,\n-                                                          boolean fence,\n-                                                          boolean includeControl,\n-                                                          boolean includeEndOfStream)\n-        throws IOException {\n-        return FutureUtils.result(asyncReadLastRecord(l, fence, includeControl, includeEndOfStream));\n-    }\n-\n     public Future<LogRecordWithDLSN> asyncReadLastUserRecord(final LogSegmentMetadata l) {\n         return asyncReadLastRecord(l, false, false, false);\n     }\n@@ -1293,21 +1172,4 @@ void notifyOnOperationComplete() {\n         }\n     }\n \n-    // ZooKeeper Watchers\n-\n-    Watcher registerExpirationHandler(final ZooKeeperClient.ZooKeeperSessionExpireNotifier onExpired) {\n-        if (conf.getZKNumRetries() > 0) {\n-            return new Watcher() {\n-                @Override\n-                public void process(WatchedEvent event) {\n-                    // nop\n-                }\n-            };\n-        }\n-        return zooKeeperClient.registerExpirationHandler(onExpired);\n-    }\n-\n-    boolean unregister(Watcher watcher) {\n-        return zooKeeperClient.unregister(watcher);\n-    }\n }"},{"sha":"8276125323b98ee4c0c0362e8780ff66811f2ec1","filename":"src/main/java/com/twitter/distributedlog/BKLogSegmentWriter.java","status":"modified","additions":9,"deletions":3,"changes":12,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/ed4d2bff7443f861a288ac3e0d47ec036bc751f2/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FBKLogSegmentWriter.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/ed4d2bff7443f861a288ac3e0d47ec036bc751f2/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FBKLogSegmentWriter.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FBKLogSegmentWriter.java?ref=ed4d2bff7443f861a288ac3e0d47ec036bc751f2","patch":"@@ -156,8 +156,10 @@ class BKLogSegmentWriter implements LogSegmentWriter, AddCallback, Runnable, Siz\n \n     // stats\n     private final StatsLogger envelopeStatsLogger;\n+    private final StatsLogger transmitOutstandingLogger;\n     private final Counter transmitDataSuccesses;\n     private final Counter transmitDataMisses;\n+    private final Gauge<Number> transmitOutstandingGauge;\n     private final OpStatsLogger transmitDataPacketSize;\n     private final Counter transmitControlSuccesses;\n     private final Counter pFlushSuccesses;\n@@ -255,8 +257,8 @@ protected BKLogSegmentWriter(String streamName,\n         pendingWrites = segWriterStatsLogger.getCounter(\"pending\");\n \n         // outstanding transmit requests\n-        StatsLogger transmitOutstandingLogger = perLogStatsLogger.scope(\"transmit\").scope(\"outstanding\");\n-        transmitOutstandingLogger.registerGauge(\"requests\", new Gauge<Number>() {\n+        transmitOutstandingLogger = perLogStatsLogger.scope(\"transmit\").scope(\"outstanding\");\n+        transmitOutstandingGauge = new Gauge<Number>() {\n             @Override\n             public Number getDefaultValue() {\n                 return 0;\n@@ -265,7 +267,8 @@ public Number getDefaultValue() {\n             public Number getSample() {\n                 return outstandingTransmits.get();\n             }\n-        });\n+        };\n+        transmitOutstandingLogger.registerGauge(\"requests\", transmitOutstandingGauge);\n \n         outstandingTransmits = new AtomicInteger(0);\n         this.fullyQualifiedLogSegment = streamName + \":\" + logSegmentName;\n@@ -531,6 +534,9 @@ private Future<Void> closeInternal(boolean abort) {\n     private void closeInternal(final boolean abort,\n                                final AtomicReference<Throwable> throwExc,\n                                final Promise<Void> closePromise) {\n+        // remove stats\n+        this.transmitOutstandingLogger.unregisterGauge(\"requests\", transmitOutstandingGauge);\n+\n         // Cancel the periodic keep alive schedule first\n         if (null != periodicKeepAliveSchedule) {\n             if (!periodicKeepAliveSchedule.cancel(false)) {"},{"sha":"c39ae4c4e041e11a82d3b2c45cce760946e3b782","filename":"src/main/java/com/twitter/distributedlog/BookKeeperClient.java","status":"modified","additions":9,"deletions":39,"changes":48,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/ed4d2bff7443f861a288ac3e0d47ec036bc751f2/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FBookKeeperClient.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/ed4d2bff7443f861a288ac3e0d47ec036bc751f2/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FBookKeeperClient.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FBookKeeperClient.java?ref=ed4d2bff7443f861a288ac3e0d47ec036bc751f2","patch":"@@ -17,6 +17,7 @@\n  */\n package com.twitter.distributedlog;\n \n+import com.google.common.base.Optional;\n import com.twitter.distributedlog.ZooKeeperClient.Credentials;\n import com.twitter.distributedlog.ZooKeeperClient.DigestCredentials;\n import com.twitter.distributedlog.exceptions.AlreadyClosedException;\n@@ -41,16 +42,12 @@\n import org.apache.bookkeeper.zookeeper.RetryPolicy;\n import org.apache.commons.configuration.ConfigurationException;\n import org.apache.zookeeper.KeeperException;\n-import org.apache.zookeeper.Watcher;\n import org.jboss.netty.channel.socket.ClientSocketChannelFactory;\n import org.jboss.netty.util.HashedWheelTimer;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n import java.io.IOException;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-\n-import com.google.common.base.Optional;\n \n import static com.google.common.base.Charsets.UTF_8;\n \n@@ -62,7 +59,7 @@\n  * <li> bookkeeper operation stats are exposed under current scope by {@link BookKeeper}\n  * </ul>\n  */\n-public class BookKeeperClient implements ZooKeeperClient.ZooKeeperSessionExpireNotifier {\n+public class BookKeeperClient {\n     static final Logger LOG = LoggerFactory.getLogger(BookKeeperClient.class);\n \n     // Parameters to build bookkeeper client\n@@ -83,14 +80,10 @@ public class BookKeeperClient implements ZooKeeperClient.ZooKeeperSessionExpireN\n     // feature provider\n     private final Optional<FeatureProvider> featureProvider;\n \n-    private Watcher sessionExpireWatcher = null;\n-    private AtomicBoolean zkSessionExpired = new AtomicBoolean(false);\n-\n     @SuppressWarnings(\"deprecation\")\n     private synchronized void commonInitialization(\n             DistributedLogConfiguration conf, String ledgersPath,\n-            ClientSocketChannelFactory channelFactory, StatsLogger statsLogger, HashedWheelTimer requestTimer,\n-            boolean registerExpirationHandler)\n+            ClientSocketChannelFactory channelFactory, StatsLogger statsLogger, HashedWheelTimer requestTimer)\n         throws IOException, InterruptedException, KeeperException {\n         ClientConfiguration bkConfig = new ClientConfiguration();\n         bkConfig.setAddEntryTimeout(conf.getBKClientWriteTimeout());\n@@ -124,10 +117,6 @@ private synchronized void commonInitialization(\n             .requestTimer(requestTimer)\n             .featureProvider(featureProvider.orNull())\n             .build();\n-\n-        if (registerExpirationHandler) {\n-            sessionExpireWatcher = this.zkc.registerExpirationHandler(this);\n-        }\n     }\n \n     BookKeeperClient(DistributedLogConfiguration conf,\n@@ -159,16 +148,11 @@ private synchronized void initialize() throws IOException {\n         if (null != this.bkc) {\n             return;\n         }\n-        boolean registerExpirationHandler;\n         if (null == this.zkc) {\n             int zkSessionTimeout = conf.getBKClientZKSessionTimeoutMilliSeconds();\n-            RetryPolicy retryPolicy = null;\n-            if (conf.getBKClientZKNumRetries() > 0) {\n-                retryPolicy = new BoundExponentialBackoffRetryPolicy(\n+            RetryPolicy retryPolicy = new BoundExponentialBackoffRetryPolicy(\n                         conf.getBKClientZKRetryBackoffStartMillis(),\n                         conf.getBKClientZKRetryBackoffMaxMillis(), conf.getBKClientZKNumRetries());\n-            }\n-\n             Credentials credentials = Credentials.NONE;\n             if (conf.getZkAclId() != null) {\n                 credentials = new DigestCredentials(conf.getZkAclId(), conf.getZkAclId());\n@@ -178,10 +162,9 @@ private synchronized void initialize() throws IOException {\n                                            retryPolicy, statsLogger.scope(\"bkc_zkc\"), conf.getZKClientNumberRetryThreads(),\n                                            conf.getBKClientZKRequestRateLimit(), credentials);\n         }\n-        registerExpirationHandler = conf.getBKClientZKNumRetries() <= 0;\n \n         try {\n-            commonInitialization(conf, ledgersPath, channelFactory, statsLogger, requestTimer, registerExpirationHandler);\n+            commonInitialization(conf, ledgersPath, channelFactory, statsLogger, requestTimer);\n         } catch (InterruptedException e) {\n             throw new DLInterruptedException(\"Interrupted on creating bookkeeper client \" + name + \" : \", e);\n         } catch (KeeperException e) {\n@@ -190,18 +173,18 @@ private synchronized void initialize() throws IOException {\n \n         if (ownZK) {\n             LOG.info(\"BookKeeper Client created {} with its own ZK Client : ledgersPath = {}, numRetries = {}, \" +\n-                    \"sessionTimeout = {}, backoff = {}, maxBackoff = {}, dnsResolver = {}, registerExpirationHandler = {}\",\n+                    \"sessionTimeout = {}, backoff = {}, maxBackoff = {}, dnsResolver = {}\",\n                     new Object[] { name, ledgersPath,\n                     conf.getBKClientZKNumRetries(), conf.getBKClientZKSessionTimeoutMilliSeconds(),\n                     conf.getBKClientZKRetryBackoffStartMillis(), conf.getBKClientZKRetryBackoffMaxMillis(),\n-                    conf.getBkDNSResolverOverrides(), registerExpirationHandler });\n+                    conf.getBkDNSResolverOverrides() });\n         } else {\n             LOG.info(\"BookKeeper Client created {} with shared zookeeper client : ledgersPath = {}, numRetries = {}, \" +\n-                    \"sessionTimeout = {}, backoff = {}, maxBackoff = {}, dnsResolver = {}, registerExpirationHandler = {}\",\n+                    \"sessionTimeout = {}, backoff = {}, maxBackoff = {}, dnsResolver = {}\",\n                     new Object[] { name, ledgersPath,\n                     conf.getZKNumRetries(), conf.getZKSessionTimeoutMilliseconds(),\n                     conf.getZKRetryBackoffStartMillis(), conf.getZKRetryBackoffMaxMillis(),\n-                    conf.getBkDNSResolverOverrides(), registerExpirationHandler });\n+                    conf.getBkDNSResolverOverrides() });\n         }\n     }\n \n@@ -284,30 +267,17 @@ public synchronized void close() {\n             }\n         }\n         if (null != zkc) {\n-            if (null != sessionExpireWatcher) {\n-                zkc.unregister(sessionExpireWatcher);\n-            }\n             if (ownZK) {\n                 zkc.close();\n             }\n         }\n         closed = true;\n     }\n \n-    @Override\n-    public void notifySessionExpired() {\n-        zkSessionExpired.set(true);\n-    }\n-\n     public synchronized void checkClosedOrInError() throws AlreadyClosedException {\n         if (closed) {\n             LOG.error(\"BookKeeper Client {} is already closed\", name);\n             throw new AlreadyClosedException(\"BookKeeper Client \" + name + \" is already closed\");\n         }\n-\n-        if (zkSessionExpired.get()) {\n-            LOG.error(\"BookKeeper Client {}'s Zookeeper session has expired\", name);\n-            throw new AlreadyClosedException(\"BookKeeper Client \" + name + \"'s Zookeeper session has expired\");\n-        }\n     }\n }"},{"sha":"5d0e59a7e28fa7de50cb1f429c5399f08545f3c2","filename":"src/main/java/com/twitter/distributedlog/DistributedLogConfiguration.java","status":"modified","additions":6,"deletions":2,"changes":8,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/ed4d2bff7443f861a288ac3e0d47ec036bc751f2/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FDistributedLogConfiguration.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/ed4d2bff7443f861a288ac3e0d47ec036bc751f2/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FDistributedLogConfiguration.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FDistributedLogConfiguration.java?ref=ed4d2bff7443f861a288ac3e0d47ec036bc751f2","patch":"@@ -809,12 +809,16 @@ public DistributedLogConfiguration setBKClientZKRequestRateLimit(double rateLimi\n      * Get num of retries for zookeeper client that used by bookkeeper client.\n      * <p>Retries only happen on retryable failures like session expired,\n      * session moved. for permanent failures, the request will fail immediately.\n-     * The default value is 3.\n+     * The default value is 3. Setting it to zero or negative will retry infinitely.\n      *\n      * @return num of retries of zookeeper client used by bookkeeper client.\n      */\n     public int getBKClientZKNumRetries() {\n-        return this.getInt(BKDL_BKCLIENT_ZK_NUM_RETRIES, BKDL_BKCLIENT_ZK_NUM_RETRIES_DEFAULT);\n+        int zkNumRetries = this.getInt(BKDL_BKCLIENT_ZK_NUM_RETRIES, BKDL_BKCLIENT_ZK_NUM_RETRIES_DEFAULT);\n+        if (zkNumRetries <= 0) {\n+            return Integer.MAX_VALUE;\n+        }\n+        return zkNumRetries;\n     }\n \n     /**"},{"sha":"cb53b2333d3d519cf4c72d4eaf1467e9f857a803","filename":"src/main/java/com/twitter/distributedlog/impl/ZKLogSegmentMetadataStore.java","status":"modified","additions":78,"deletions":16,"changes":94,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/ed4d2bff7443f861a288ac3e0d47ec036bc751f2/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fimpl%2FZKLogSegmentMetadataStore.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/ed4d2bff7443f861a288ac3e0d47ec036bc751f2/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fimpl%2FZKLogSegmentMetadataStore.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fimpl%2FZKLogSegmentMetadataStore.java?ref=ed4d2bff7443f861a288ac3e0d47ec036bc751f2","patch":"@@ -17,6 +17,7 @@\n  */\n package com.twitter.distributedlog.impl;\n \n+import com.google.common.collect.ImmutableList;\n import com.twitter.distributedlog.DistributedLogConfiguration;\n import com.twitter.distributedlog.LogSegmentMetadata;\n import com.twitter.distributedlog.ZooKeeperClient;\n@@ -45,10 +46,14 @@\n import org.apache.zookeeper.data.Stat;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n+import scala.runtime.AbstractFunction1;\n \n import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n import java.util.HashSet;\n import java.util.List;\n+import java.util.Map;\n import java.util.Set;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.ConcurrentMap;\n@@ -64,7 +69,9 @@ public class ZKLogSegmentMetadataStore implements LogSegmentMetadataStore, Watch\n \n     private static final Logger logger = LoggerFactory.getLogger(ZKLogSegmentMetadataStore.class);\n \n-    private static class ReadLogSegmentsTask implements Runnable, FutureEventListener<List<String>> {\n+    private static final List<String> EMPTY_LIST = ImmutableList.of();\n+\n+    private static class ReadLogSegmentsTask implements Runnable, FutureEventListener<Versioned<List<String>>> {\n \n         private final String logSegmentsPath;\n         private final ZKLogSegmentMetadataStore store;\n@@ -78,15 +85,16 @@ private static class ReadLogSegmentsTask implements Runnable, FutureEventListene\n         }\n \n         @Override\n-        public void onSuccess(final List<String> segments) {\n+        public void onSuccess(final Versioned<List<String>> segments) {\n             // reset the back off after a successful operation\n             currentZKBackOffMs = store.minZKBackoffMs;\n-            final Set<LogSegmentNamesListener> listenerSet = store.listeners.get(logSegmentsPath);\n+            final Map<LogSegmentNamesListener, VersionedLogSegmentNamesListener> listenerSet =\n+                    store.listeners.get(logSegmentsPath);\n             if (null != listenerSet) {\n                 store.submitTask(logSegmentsPath, new Runnable() {\n                     @Override\n                     public void run() {\n-                        for (LogSegmentNamesListener listener : listenerSet) {\n+                        for (VersionedLogSegmentNamesListener listener : listenerSet.values()) {\n                             listener.onSegmentsUpdated(segments);\n                         }\n                     }\n@@ -120,6 +128,48 @@ public void run() {\n         }\n     }\n \n+    /**\n+     * A log segment names listener that keeps tracking the version of list of log segments that it has been notified.\n+     * It only notify the newer log segments.\n+     */\n+    static class VersionedLogSegmentNamesListener {\n+\n+        private final LogSegmentNamesListener listener;\n+        private Versioned<List<String>> lastNotifiedLogSegments;\n+\n+        VersionedLogSegmentNamesListener(LogSegmentNamesListener listener) {\n+            this.listener = listener;\n+            this.lastNotifiedLogSegments = new Versioned<List<String>>(EMPTY_LIST, Version.NEW);\n+        }\n+\n+        synchronized void onSegmentsUpdated(Versioned<List<String>> logSegments) {\n+            if (lastNotifiedLogSegments.getVersion() == Version.NEW ||\n+                    lastNotifiedLogSegments.getVersion().compare(logSegments.getVersion()) == Version.Occurred.BEFORE) {\n+                lastNotifiedLogSegments = logSegments;\n+                listener.onSegmentsUpdated(logSegments.getValue());\n+            }\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return listener.hashCode();\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (!(obj instanceof VersionedLogSegmentNamesListener)) {\n+                return false;\n+            }\n+            VersionedLogSegmentNamesListener other = (VersionedLogSegmentNamesListener) obj;\n+            return listener.equals(other.listener);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return listener.toString();\n+        }\n+    }\n+\n     final DistributedLogConfiguration conf;\n     // settings\n     final int minZKBackoffMs;\n@@ -128,7 +178,7 @@ public void run() {\n \n     final ZooKeeperClient zkc;\n     // log segment listeners\n-    final ConcurrentMap<String, Set<LogSegmentNamesListener>> listeners;\n+    final ConcurrentMap<String, Map<LogSegmentNamesListener, VersionedLogSegmentNamesListener>> listeners;\n     // scheduler\n     final OrderedScheduler scheduler;\n     final ReentrantReadWriteLock closeLock;\n@@ -139,7 +189,8 @@ public ZKLogSegmentMetadataStore(DistributedLogConfiguration conf,\n                                      OrderedScheduler scheduler) {\n         this.conf = conf;\n         this.zkc = zkc;\n-        this.listeners = new ConcurrentHashMap<String, Set<LogSegmentNamesListener>>();\n+        this.listeners =\n+                new ConcurrentHashMap<String, Map<LogSegmentNamesListener, VersionedLogSegmentNamesListener>>();\n         this.scheduler = scheduler;\n         this.closeLock = new ReentrantReadWriteLock();\n         // settings\n@@ -275,11 +326,16 @@ public Future<LogSegmentMetadata> getLogSegment(String logSegmentPath) {\n \n     @Override\n     public Future<List<String>> getLogSegmentNames(String logSegmentsPath) {\n-        return getLogSegmentNames(logSegmentsPath, null);\n+        return getLogSegmentNames(logSegmentsPath, null).map(new AbstractFunction1<Versioned<List<String>>, List<String>>() {\n+            @Override\n+            public List<String> apply(Versioned<List<String>> list) {\n+                return list.getValue();\n+            }\n+        });\n     }\n \n-    Future<List<String>> getLogSegmentNames(String logSegmentsPath, Watcher watcher) {\n-        Promise<List<String>> result = new Promise<List<String>>();\n+    Future<Versioned<List<String>>> getLogSegmentNames(String logSegmentsPath, Watcher watcher) {\n+        Promise<Versioned<List<String>>> result = new Promise<Versioned<List<String>>>();\n         try {\n             zkc.get().getChildren(logSegmentsPath, watcher, this, result);\n         } catch (ZooKeeperClient.ZooKeeperConnectionException e) {\n@@ -293,9 +349,11 @@ Future<List<String>> getLogSegmentNames(String logSegmentsPath, Watcher watcher)\n     @Override\n     @SuppressWarnings(\"unchecked\")\n     public void processResult(int rc, String path, Object ctx, List<String> children, Stat stat) {\n-        Promise<List<String>> result = ((Promise<List<String>>) ctx);\n+        Promise<Versioned<List<String>>> result = ((Promise<Versioned<List<String>>>) ctx);\n         if (KeeperException.Code.OK.intValue() == rc) {\n-            result.setValue(children);\n+            /** cversion: the number of changes to the children of this znode **/\n+            ZkVersion zkVersion = new ZkVersion(stat.getCversion());\n+            result.setValue(new Versioned(children, zkVersion));\n         } else {\n             result.setException(KeeperException.create(KeeperException.Code.get(rc)));\n         }\n@@ -312,18 +370,21 @@ public void registerLogSegmentListener(String logSegmentsPath,\n             if (closed) {\n                 return;\n             }\n-            Set<LogSegmentNamesListener> listenerSet = listeners.get(logSegmentsPath);\n+            Map<LogSegmentNamesListener, VersionedLogSegmentNamesListener> listenerSet =\n+                    listeners.get(logSegmentsPath);\n             if (null == listenerSet) {\n-                Set<LogSegmentNamesListener> newListenerSet = new HashSet<LogSegmentNamesListener>();\n-                Set<LogSegmentNamesListener> oldListenerSet = listeners.putIfAbsent(logSegmentsPath, newListenerSet);\n+                Map<LogSegmentNamesListener, VersionedLogSegmentNamesListener> newListenerSet =\n+                        new HashMap<LogSegmentNamesListener, VersionedLogSegmentNamesListener>();\n+                Map<LogSegmentNamesListener, VersionedLogSegmentNamesListener> oldListenerSet =\n+                        listeners.putIfAbsent(logSegmentsPath, newListenerSet);\n                 if (null != oldListenerSet) {\n                     listenerSet = oldListenerSet;\n                 } else {\n                     listenerSet = newListenerSet;\n                 }\n             }\n             synchronized (listenerSet) {\n-                listenerSet.add(listener);\n+                listenerSet.put(listener, new VersionedLogSegmentNamesListener(listener));\n                 if (!listeners.containsKey(logSegmentsPath)) {\n                     // listener set has been removed, add it back\n                     listeners.put(logSegmentsPath, listenerSet);\n@@ -343,7 +404,8 @@ public void unregisterLogSegmentListener(String logSegmentsPath,\n             if (closed) {\n                 return;\n             }\n-            Set<LogSegmentNamesListener> listenerSet = listeners.get(logSegmentsPath);\n+            Map<LogSegmentNamesListener, VersionedLogSegmentNamesListener> listenerSet =\n+                    listeners.get(logSegmentsPath);\n             if (null == listenerSet) {\n                 return;\n             }"},{"sha":"10a70115fea6e2937beb34da3f17fef61d8cfd56","filename":"src/main/java/com/twitter/distributedlog/stats/BroadCastStatsLogger.java","status":"modified","additions":22,"deletions":0,"changes":22,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/ed4d2bff7443f861a288ac3e0d47ec036bc751f2/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fstats%2FBroadCastStatsLogger.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/ed4d2bff7443f861a288ac3e0d47ec036bc751f2/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fstats%2FBroadCastStatsLogger.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fstats%2FBroadCastStatsLogger.java?ref=ed4d2bff7443f861a288ac3e0d47ec036bc751f2","patch":"@@ -132,10 +132,27 @@ public <T extends Number> void registerGauge(String statName, Gauge<T> gauge) {\n             throw new RuntimeException(\"Cannot register a gauge on BroadCastStatsLogger.Two\");\n         }\n \n+        @Override\n+        public <T extends Number> void unregisterGauge(String statName, Gauge<T> gauge) {\n+            // no-op\n+        }\n+\n         @Override\n         public StatsLogger scope(final String scope) {\n             return new Two(first.scope(scope), second.scope(scope));\n         }\n+\n+        @Override\n+        public void removeScope(String scope, StatsLogger statsLogger) {\n+            if (!(statsLogger instanceof Two)) {\n+                return;\n+            }\n+\n+            Two another = (Two) statsLogger;\n+\n+            first.removeScope(scope, another.first);\n+            second.removeScope(scope, another.second);\n+        }\n     }\n \n     /**\n@@ -164,6 +181,11 @@ public <T extends Number> void registerGauge(String statName, Gauge<T> gauge) {\n             first.registerGauge(statName, gauge);\n         }\n \n+        @Override\n+        public <T extends Number> void unregisterGauge(String statName, Gauge<T> gauge) {\n+            first.unregisterGauge(statName, gauge);\n+        }\n+\n         @Override\n         public StatsLogger scope(String scope) {\n             return new MasterSlave(first.scope(scope), second.scope(scope));"},{"sha":"f8fd3eb66c6deee67585dad83405988f07eadbc4","filename":"src/test/java/com/twitter/distributedlog/impl/TestZKLogSegmentMetadataStore.java","status":"modified","additions":6,"deletions":16,"changes":22,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/ed4d2bff7443f861a288ac3e0d47ec036bc751f2/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fimpl%2FTestZKLogSegmentMetadataStore.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/ed4d2bff7443f861a288ac3e0d47ec036bc751f2/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fimpl%2FTestZKLogSegmentMetadataStore.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fimpl%2FTestZKLogSegmentMetadataStore.java?ref=ed4d2bff7443f861a288ac3e0d47ec036bc751f2","patch":"@@ -367,7 +367,7 @@ public void onSegmentsUpdated(List<String> segments) {\n         lsmStore.registerLogSegmentListener(rootPath, listener);\n         assertEquals(1, lsmStore.listeners.size());\n         assertTrue(\"Should contain listener\", lsmStore.listeners.containsKey(rootPath));\n-        assertTrue(\"Should contain listener\", lsmStore.listeners.get(rootPath).contains(listener));\n+        assertTrue(\"Should contain listener\", lsmStore.listeners.get(rootPath).containsKey(listener));\n         while (numNotifications.get() < 1) {\n             TimeUnit.MILLISECONDS.sleep(10);\n         }\n@@ -429,7 +429,7 @@ public void onSegmentsUpdated(List<String> segments) {\n         lsmStore.registerLogSegmentListener(rootPath, listener);\n         assertEquals(1, lsmStore.listeners.size());\n         assertTrue(\"Should contain listener\", lsmStore.listeners.containsKey(rootPath));\n-        assertTrue(\"Should contain listener\", lsmStore.listeners.get(rootPath).contains(listener));\n+        assertTrue(\"Should contain listener\", lsmStore.listeners.get(rootPath).containsKey(listener));\n         while (numNotifications.get() < 1) {\n             TimeUnit.MILLISECONDS.sleep(10);\n         }\n@@ -496,7 +496,7 @@ public void onSegmentsUpdated(List<String> segments) {\n         lsmStore.registerLogSegmentListener(rootPath, listener);\n         assertEquals(1, lsmStore.listeners.size());\n         assertTrue(\"Should contain listener\", lsmStore.listeners.containsKey(rootPath));\n-        assertTrue(\"Should contain listener\", lsmStore.listeners.get(rootPath).contains(listener));\n+        assertTrue(\"Should contain listener\", lsmStore.listeners.get(rootPath).containsKey(listener));\n         while (numNotifications.get() < 1) {\n             TimeUnit.MILLISECONDS.sleep(10);\n         }\n@@ -510,16 +510,6 @@ public void onSegmentsUpdated(List<String> segments) {\n         ZooKeeperClientUtils.expireSession(zkc,\n                 DLUtils.getZKServersFromDLUri(uri), conf.getZKSessionTimeoutMilliseconds());\n \n-        while (numNotifications.get() < 2) {\n-            TimeUnit.MILLISECONDS.sleep(10);\n-        }\n-        assertEquals(\"Should receive second segment list update\",\n-                2, numNotifications.get());\n-        List<String> secondSegmentList = segmentLists.get(1);\n-        Collections.sort(secondSegmentList);\n-        assertEquals(\"List of segments should be same\",\n-                children, secondSegmentList);\n-\n         logger.info(\"Create another {} segments.\", numSegments);\n \n         // create another log segment, it should trigger segment list updated\n@@ -532,12 +522,12 @@ public void onSegmentsUpdated(List<String> segments) {\n         List<String> newChildren = zkc.get().getChildren(rootPath, false);\n         Collections.sort(newChildren);\n         logger.info(\"All log segments become {}\", newChildren);\n-        while (numNotifications.get() < 3) {\n+        while (numNotifications.get() < 2) {\n             TimeUnit.MILLISECONDS.sleep(10);\n         }\n         assertEquals(\"Should receive third segment list update\",\n-                3, numNotifications.get());\n-        List<String> thirdSegmentList = segmentLists.get(2);\n+                2, numNotifications.get());\n+        List<String> thirdSegmentList = segmentLists.get(1);\n         Collections.sort(thirdSegmentList);\n         assertEquals(\"List of segments should be updated\",\n                 2 * numSegments, thirdSegmentList.size());"}]}