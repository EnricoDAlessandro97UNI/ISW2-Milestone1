{"sha":"90e4e46bccdd1a788e10056f4a3818aa2aead452","node_id":"MDY6Q29tbWl0NDc4NTkyNTI2OjkwZTRlNDZiY2NkZDFhNzg4ZTEwMDU2ZjRhMzgxOGFhMmFlYWQ0NTI=","commit":{"author":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2017-06-21T17:58:00Z"},"committer":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2017-06-21T17:58:00Z"},"message":"BOOKKEEPER-1093: Piggyback LAC on ReadResponse\n\nThis change is based #178 - (you can review git sha 40ca8c2)\n\nbookkeeper: LAC piggyback at read response\n\n        - bookie server changes\n          * cache maximum lac in file info\n          * provide getLastAddConfirmed & setLastAddConfirmed in ledger storage\n          * addEntry will set its lac thru setLastAddConfirmed\n          * readEntry will read latest lac and piggyback\n        - client change\n          * check whether the response has lac piggybacked, if there is lac update lac in its corresponding ledger handle.\n\nAuthor: Sijie Guo <sijie@apache.org>\nAuthor: Sijie Guo <sijieg@twitter.com>\n\nReviewers: Jia Zhai <None>, Matteo Merli <mmerli@apache.org>\n\nThis closes #180 from sijie/piggyback_lac","tree":{"sha":"4000c3d3e8f66d2ef43d64ad845facefa77aab0b","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/trees/4000c3d3e8f66d2ef43d64ad845facefa77aab0b"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/commits/90e4e46bccdd1a788e10056f4a3818aa2aead452","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/90e4e46bccdd1a788e10056f4a3818aa2aead452","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/90e4e46bccdd1a788e10056f4a3818aa2aead452","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/90e4e46bccdd1a788e10056f4a3818aa2aead452/comments","author":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"committer":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"parents":[{"sha":"90a8f283999ddbfee818629e1be17102e63be22c","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/90a8f283999ddbfee818629e1be17102e63be22c","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/90a8f283999ddbfee818629e1be17102e63be22c"}],"stats":{"total":136,"additions":123,"deletions":13},"files":[{"sha":"97d1885b019ba5b078210804ad7e9c67f1628347","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerRecoveryOp.java","status":"modified","additions":6,"deletions":6,"changes":12,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/90e4e46bccdd1a788e10056f4a3818aa2aead452/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FLedgerRecoveryOp.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/90e4e46bccdd1a788e10056f4a3818aa2aead452/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FLedgerRecoveryOp.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FLedgerRecoveryOp.java?ref=90e4e46bccdd1a788e10056f4a3818aa2aead452","patch":"@@ -44,7 +44,7 @@ class LedgerRecoveryOp implements ReadEntryListener, AddCallback {\n \n     final LedgerHandle lh;\n     final AtomicLong readCount, writeCount;\n-    final AtomicBoolean readDone;\n+    volatile boolean readDone;\n     final AtomicBoolean callbackDone;\n     volatile long startEntryToRead;\n     volatile long endEntryToRead;\n@@ -76,7 +76,7 @@ protected LedgerMetadata getLedgerMetadata() {\n     public LedgerRecoveryOp(LedgerHandle lh, GenericCallback<Void> cb) {\n         readCount = new AtomicLong(0);\n         writeCount = new AtomicLong(0);\n-        readDone = new AtomicBoolean(false);\n+        readDone = false;\n         callbackDone = new AtomicBoolean(false);\n         this.cb = cb;\n         this.lh = lh;\n@@ -185,7 +185,7 @@ public void onEntryComplete(int rc, LedgerHandle lh, LedgerEntry entry, Object c\n         }\n \n         // we only trigger recovery add an entry when readDone == false && callbackDone == false\n-        if (!callbackDone.get() && !readDone.get() && rc == BKException.Code.OK) {\n+        if (!callbackDone.get() && !readDone && rc == BKException.Code.OK) {\n             readCount.incrementAndGet();\n             byte[] data = entry.getEntry();\n \n@@ -215,7 +215,7 @@ public void onEntryComplete(int rc, LedgerHandle lh, LedgerEntry entry, Object c\n \n         // no entry found. stop recovery procedure but wait until recovery add finished.\n         if (rc == BKException.Code.NoSuchEntryException || rc == BKException.Code.NoSuchLedgerExistsException) {\n-            readDone.set(true);\n+            readDone = true;\n             if (readCount.get() == writeCount.get()) {\n                 closeAndCallback();\n             }\n@@ -231,7 +231,7 @@ public void onEntryComplete(int rc, LedgerHandle lh, LedgerEntry entry, Object c\n             // we are here is because we successfully read an entry but readDone was already set to true.\n             // this would happen on recovery a ledger than has gaps in the tail.\n             LOG.warn(\"Successfully read entry {} for ledger {}, but readDone is already {}\",\n-                     new Object[] { entry.getEntryId(), lh.getId(), readDone.get() });\n+                     new Object[] { entry.getEntryId(), lh.getId(), readDone });\n         }\n         return;\n     }\n@@ -248,7 +248,7 @@ public void addComplete(int rc, LedgerHandle lh, long entryId, Object ctx) {\n             return;\n         }\n         long numAdd = writeCount.incrementAndGet();\n-        if (readDone.get() && readCount.get() == numAdd) {\n+        if (readDone && readCount.get() == numAdd) {\n             closeAndCallback();\n         }\n     }"},{"sha":"306c5dd077faba25bcd496bc0fccc61febd5598e","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingReadOp.java","status":"modified","additions":16,"deletions":2,"changes":18,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/90e4e46bccdd1a788e10056f4a3818aa2aead452/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FPendingReadOp.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/90e4e46bccdd1a788e10056f4a3818aa2aead452/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FPendingReadOp.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FPendingReadOp.java?ref=90e4e46bccdd1a788e10056f4a3818aa2aead452","patch":"@@ -41,6 +41,7 @@\n import org.apache.bookkeeper.client.BKException.BKDigestMatchException;\n import org.apache.bookkeeper.net.BookieSocketAddress;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ReadEntryCallback;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ReadEntryCallbackCtx;\n import org.apache.bookkeeper.stats.OpStatsLogger;\n import org.apache.bookkeeper.util.MathUtils;\n import org.slf4j.Logger;\n@@ -489,14 +490,25 @@ public void run() {\n         }\n     }\n \n-    private static class ReadContext {\n+    private static class ReadContext implements ReadEntryCallbackCtx {\n         final BookieSocketAddress to;\n         final LedgerEntryRequest entry;\n+        long lac = LedgerHandle.INVALID_ENTRY_ID;\n \n         ReadContext(BookieSocketAddress to, LedgerEntryRequest entry) {\n             this.to = to;\n             this.entry = entry;\n         }\n+\n+        @Override\n+        public void setLastAddConfirmed(long lac) {\n+            this.lac = lac;\n+        }\n+\n+        @Override\n+        public long getLastAddConfirmed() {\n+            return lac;\n+        }\n     }\n \n     void sendReadTo(BookieSocketAddress to, LedgerEntryRequest entry) throws InterruptedException {\n@@ -521,11 +533,13 @@ public void readEntryComplete(int rc, long ledgerId, final long entryId, final B\n         heardFromHosts.add(rctx.to);\n \n         if (entry.complete(rctx.to, buffer)) {\n+            lh.updateLastConfirmed(rctx.getLastAddConfirmed(), 0L);\n             submitCallback(BKException.Code.OK);\n         }\n \n         if(numPendingEntries < 0)\n-            LOG.error(\"Read too many values\");\n+            LOG.error(\"Read too many values for ledger {} : [{}, {}].\", new Object[] { ledgerId,\n+                    startEntryId, endEntryId });\n     }\n \n     protected void submitCallback(int code) {"},{"sha":"8b02a80fe3d2918773acf8da727b9840bdb3b0c5","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ClientConfiguration.java","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/90e4e46bccdd1a788e10056f4a3818aa2aead452/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fconf%2FClientConfiguration.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/90e4e46bccdd1a788e10056f4a3818aa2aead452/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fconf%2FClientConfiguration.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fconf%2FClientConfiguration.java?ref=90e4e46bccdd1a788e10056f4a3818aa2aead452","patch":"@@ -1140,4 +1140,5 @@ public ClientConfiguration setClientRole(String role) {\n     public String getClientRole() {\n         return getString(CLIENT_ROLE, CLIENT_ROLE_STANDARD);\n     }\n+\n }"},{"sha":"6c5d68f2717ff503a0b48acb304a6fa3b629ee90","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java","status":"modified","additions":19,"deletions":4,"changes":23,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/90e4e46bccdd1a788e10056f4a3818aa2aead452/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FPerChannelBookieClient.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/90e4e46bccdd1a788e10056f4a3818aa2aead452/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FPerChannelBookieClient.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FPerChannelBookieClient.java?ref=90e4e46bccdd1a788e10056f4a3818aa2aead452","patch":"@@ -17,6 +17,8 @@\n  */\n package org.apache.bookkeeper.proto;\n \n+import static org.apache.bookkeeper.client.LedgerHandle.INVALID_ENTRY_ID;\n+\n import io.netty.bootstrap.Bootstrap;\n import io.netty.buffer.ByteBuf;\n import io.netty.buffer.PooledByteBufAllocator;\n@@ -68,6 +70,7 @@\n import org.apache.bookkeeper.net.BookieSocketAddress;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ReadEntryCallback;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ReadEntryCallbackCtx;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GetBookieInfoCallback;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteCallback;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteLacCallback;\n@@ -1163,7 +1166,7 @@ public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws E\n      * Called by netty when a message is received on a channel\n      */\n     @Override\n-\tpublic void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n+    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n \n         if (msg instanceof BookieProtocol.Response) {\n             BookieProtocol.Response response = (BookieProtocol.Response) msg;\n@@ -1208,7 +1211,7 @@ public void safeRun() {\n                             if (readResponse.hasData()) {\n                               data = readResponse.getData();\n                             }\n-                            handleReadResponse(ledgerId, entryId, status, data, completionValue);\n+                            handleReadResponse(ledgerId, entryId, status, data, INVALID_ENTRY_ID, completionValue);\n                             break;\n                         }\n                         default:\n@@ -1296,7 +1299,11 @@ public void safeRun() {\n                             if (readResponse.hasBody()) {\n                                 buffer = Unpooled.wrappedBuffer(readResponse.getBody().asReadOnlyByteBuffer());\n                             }\n-                            handleReadResponse(readResponse.getLedgerId(), readResponse.getEntryId(), status, buffer, completionValue);\n+                            long maxLAC = INVALID_ENTRY_ID;\n+                            if (readResponse.hasMaxLAC()) {\n+                                maxLAC = readResponse.getMaxLAC();\n+                            }\n+                            handleReadResponse(readResponse.getLedgerId(), readResponse.getEntryId(), status, buffer, maxLAC, completionValue);\n                             break;\n                         }\n                         case WRITE_LAC: {\n@@ -1405,7 +1412,12 @@ void handleReadLacResponse(long ledgerId, StatusCode status, ByteBuf lacBuffer,\n         glac.cb.readLacComplete(rcToRet, ledgerId, lacBuffer.slice(), lastEntryBuffer.slice(), glac.ctx);\n     }\n \n-    void handleReadResponse(long ledgerId, long entryId, StatusCode status, ByteBuf buffer, CompletionValue completionValue) {\n+    void handleReadResponse(long ledgerId,\n+                            long entryId,\n+                            StatusCode status,\n+                            ByteBuf buffer,\n+                            long maxLAC, // max known lac piggy-back from bookies\n+                            CompletionValue completionValue) {\n         // The completion value should always be an instance of a ReadCompletion object when we reach here.\n         ReadCompletion rc = (ReadCompletion)completionValue;\n \n@@ -1426,6 +1438,9 @@ void handleReadResponse(long ledgerId, long entryId, StatusCode status, ByteBuf\n         if(buffer != null) {\n             buffer = buffer.slice();\n         }\n+        if (maxLAC > INVALID_ENTRY_ID && (rc.ctx instanceof ReadEntryCallbackCtx)) {\n+            ((ReadEntryCallbackCtx) rc.ctx).setLastAddConfirmed(maxLAC);\n+        }\n         rc.cb.readEntryComplete(rcToRet, ledgerId, entryId, buffer, rc.ctx);\n     }\n "},{"sha":"9da6f05d84cafdde9d0778eade510691b218da29","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestPiggybackLAC.java","status":"added","additions":80,"deletions":0,"changes":80,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/90e4e46bccdd1a788e10056f4a3818aa2aead452/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FTestPiggybackLAC.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/90e4e46bccdd1a788e10056f4a3818aa2aead452/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FTestPiggybackLAC.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FTestPiggybackLAC.java?ref=90e4e46bccdd1a788e10056f4a3818aa2aead452","patch":"@@ -0,0 +1,80 @@\n+/**\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.client;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+import org.apache.bookkeeper.client.BookKeeper.DigestType;\n+import org.apache.bookkeeper.test.BookKeeperClusterTestCase;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Enumeration;\n+\n+public class TestPiggybackLAC extends BookKeeperClusterTestCase {\n+\n+    static Logger LOG = LoggerFactory.getLogger(TestPiggybackLAC.class);\n+\n+    final DigestType digestType;\n+\n+    public TestPiggybackLAC() {\n+        super(3);\n+        this.digestType = DigestType.CRC32;\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testPiggybackLAC() throws Exception {\n+        int numEntries = 10;\n+        LedgerHandle lh = bkc.createLedger(3, 3, 3, digestType, \"\".getBytes());\n+        // tried to add entries\n+        for (int i=0; i<numEntries; i++) {\n+            lh.addEntry((\"data\" + i).getBytes());\n+            LOG.info(\"Added entry {}.\", i);\n+        }\n+        LedgerHandle readLh = bkc.openLedgerNoRecovery(lh.getId(), digestType, \"\".getBytes());\n+        long lastLAC = readLh.getLastAddConfirmed();\n+        assertEquals(numEntries - 2, lastLAC);\n+        // write add entries\n+        for (int i=0; i<numEntries; i++) {\n+            lh.addEntry((\"data\" + (i + numEntries)).getBytes());\n+            LOG.info(\"Added entry {}.\", (i + numEntries));\n+        }\n+        int numReads = 0;\n+        int i = 0;\n+        while (true) {\n+            if (i > readLh.getLastAddConfirmed()) {\n+                break;\n+            }\n+            Enumeration<LedgerEntry> data = readLh.readEntries(i, i);\n+            while (data.hasMoreElements()) {\n+                LedgerEntry entry = data.nextElement();\n+                assertEquals(\"data\" + i, new String(entry.getEntry()));\n+                ++numReads;\n+            }\n+            i++;\n+        }\n+        assertEquals(2 * numEntries - 1, numReads);\n+        assertEquals(2 * numEntries - 2, readLh.getLastAddConfirmed());\n+        readLh.close();\n+        lh.close();\n+    }\n+}"},{"sha":"fe371e5810df873b48168c2178ce950e62717fc9","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieClientTest.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/90e4e46bccdd1a788e10056f4a3818aa2aead452/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Ftest%2FBookieClientTest.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/90e4e46bccdd1a788e10056f4a3818aa2aead452/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Ftest%2FBookieClientTest.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Ftest%2FBookieClientTest.java?ref=90e4e46bccdd1a788e10056f4a3818aa2aead452","patch":"@@ -231,7 +231,7 @@ public void testWriteGaps() throws Exception {\n     }\n \n     private ByteBuf createByteBuffer(int i, long lid, long eid) {\n-        ByteBuf bb = Unpooled.buffer(4 + 16);\n+        ByteBuf bb = Unpooled.buffer(4 + 24);\n         bb.writeLong(lid);\n         bb.writeLong(eid);\n         bb.writeLong(eid - 1);"}]}