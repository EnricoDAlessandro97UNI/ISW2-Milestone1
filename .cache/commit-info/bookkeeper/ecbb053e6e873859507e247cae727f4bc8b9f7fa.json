{"sha":"ecbb053e6e873859507e247cae727f4bc8b9f7fa","node_id":"MDY6Q29tbWl0NDc4NTkyNTI2OmVjYmIwNTNlNmU4NzM4NTk1MDdlMjQ3Y2FlNzI3ZjRiYzhiOWY3ZmE=","commit":{"author":{"name":"Matteo Merli","email":"mmerli@yahoo-inc.com","date":"2016-11-29T23:17:46Z"},"committer":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2016-11-29T23:17:46Z"},"message":"BOOKKEEPER-964: Add concurrent maps and sets for primitive types\n\nIn BookKeeper there are many instances of maps and sets that use ledger id\nand entry ids as keys or values. JDK concurrent collections have the overhead\nof boxing all the primitive values into objects (eg: long --> Long) that would\nneed to be allocated from the heap. In addition to that, JDK map implementations\nare closed hash tables and they will require at least one more allocation to hold\nthe linked-list/tree node.\n\nThere are already available libraries that offer primitive collections with\nzero-allocation, but none of these support concurrent maps/sets.\n\nWe have added a handful of specializations, all based on the same implementation\nidea. We have a hash table which is broken down into multiple sections. Each\nsections, on its own, is an open hash table with linear probing, protected by\na stamped lock.\n\nAll insertions, lookups and iterations on these collections are allocation free.\n\n```\nConcurrentLongHashMap: Map<long, Object>\nConcurrentLongHashSet: Set<long>\nConcurrentLongLongHashMap: Map<long, long>\nConcurrentLongLongPairHashMap: Map< Pair<long, long>, Pair<long, long> >\nConcurrentOpenHashMap: Map<Object, Object>\nConcurrentOpenHashSet: Set<Object>\n```\n\nAuthor: Matteo Merli <mmerli@yahoo-inc.com>\n\nReviewers: Sijie Guo <sijie@apache.org>, Enrico Olivelli <Enrico.olivelli@diennea.com>\n\nCloses #72 from merlimat/bk-collections","tree":{"sha":"fce07974a9aae01db840af48f0f2c654a5da1d6e","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/trees/fce07974a9aae01db840af48f0f2c654a5da1d6e"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/commits/ecbb053e6e873859507e247cae727f4bc8b9f7fa","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/ecbb053e6e873859507e247cae727f4bc8b9f7fa","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/ecbb053e6e873859507e247cae727f4bc8b9f7fa","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/ecbb053e6e873859507e247cae727f4bc8b9f7fa/comments","author":{"login":"merlimat","id":62500,"node_id":"MDQ6VXNlcjYyNTAw","avatar_url":"https://avatars.githubusercontent.com/u/62500?v=4","gravatar_id":"","url":"https://api.github.com/users/merlimat","html_url":"https://github.com/merlimat","followers_url":"https://api.github.com/users/merlimat/followers","following_url":"https://api.github.com/users/merlimat/following{/other_user}","gists_url":"https://api.github.com/users/merlimat/gists{/gist_id}","starred_url":"https://api.github.com/users/merlimat/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/merlimat/subscriptions","organizations_url":"https://api.github.com/users/merlimat/orgs","repos_url":"https://api.github.com/users/merlimat/repos","events_url":"https://api.github.com/users/merlimat/events{/privacy}","received_events_url":"https://api.github.com/users/merlimat/received_events","type":"User","site_admin":false},"committer":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"parents":[{"sha":"4cf097871d28b70a53f8c6bffaf1c2022e9953b2","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/4cf097871d28b70a53f8c6bffaf1c2022e9953b2","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/4cf097871d28b70a53f8c6bffaf1c2022e9953b2"}],"stats":{"total":5429,"additions":5429,"deletions":0},"files":[{"sha":"63603cbc39b4a6239890a904eed261751b563448","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/util/collections/ConcurrentLongHashMap.java","status":"added","additions":494,"deletions":0,"changes":494,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/ecbb053e6e873859507e247cae727f4bc8b9f7fa/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2Fcollections%2FConcurrentLongHashMap.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/ecbb053e6e873859507e247cae727f4bc8b9f7fa/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2Fcollections%2FConcurrentLongHashMap.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2Fcollections%2FConcurrentLongHashMap.java?ref=ecbb053e6e873859507e247cae727f4bc8b9f7fa","patch":"@@ -0,0 +1,494 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.util.collections;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.locks.StampedLock;\n+import java.util.function.LongFunction;\n+\n+import com.google.common.collect.Lists;\n+\n+/**\n+ * Map from long to an Object.\n+ * \n+ * Provides similar methods as a ConcurrentMap<long,Object> with 2 differences:\n+ * <ol>\n+ * <li>No boxing/unboxing from long -> Long\n+ * <li>Open hash map with linear probing, no node allocations to store the values\n+ * </ol>\n+ *\n+ * @param <V>\n+ */\n+@SuppressWarnings(\"unchecked\")\n+public class ConcurrentLongHashMap<V> {\n+\n+    private static final Object EmptyValue = null;\n+    private static final Object DeletedValue = new Object();\n+\n+    private static final float MapFillFactor = 0.66f;\n+\n+    private static final int DefaultExpectedItems = 256;\n+    private static final int DefaultConcurrencyLevel = 16;\n+\n+    private final Section<V>[] sections;\n+\n+    public ConcurrentLongHashMap() {\n+        this(DefaultExpectedItems);\n+    }\n+\n+    public ConcurrentLongHashMap(int expectedItems) {\n+        this(expectedItems, DefaultConcurrencyLevel);\n+    }\n+\n+    public ConcurrentLongHashMap(int expectedItems, int concurrencyLevel) {\n+        checkArgument(expectedItems > 0);\n+        checkArgument(concurrencyLevel > 0);\n+        checkArgument(expectedItems >= concurrencyLevel);\n+\n+        int numSections = concurrencyLevel;\n+        int perSectionExpectedItems = expectedItems / numSections;\n+        int perSectionCapacity = (int) (perSectionExpectedItems / MapFillFactor);\n+        this.sections = (Section<V>[]) new Section[numSections];\n+\n+        for (int i = 0; i < numSections; i++) {\n+            sections[i] = new Section<>(perSectionCapacity);\n+        }\n+    }\n+\n+    public long size() {\n+        long size = 0;\n+        for (Section<V> s : sections) {\n+            size += s.size;\n+        }\n+        return size;\n+    }\n+\n+    long getUsedBucketCount() {\n+        long usedBucketCount = 0;\n+        for (Section<V> s : sections) {\n+            usedBucketCount += s.usedBuckets;\n+        }\n+        return usedBucketCount;\n+    }\n+\n+    public long capacity() {\n+        long capacity = 0;\n+        for (Section<V> s : sections) {\n+            capacity += s.capacity;\n+        }\n+        return capacity;\n+    }\n+\n+    public boolean isEmpty() {\n+        for (Section<V> s : sections) {\n+            if (s.size != 0) {\n+                return false;\n+            }\n+        }\n+\n+        return true;\n+    }\n+\n+    public V get(long key) {\n+        long h = hash(key);\n+        return getSection(h).get(key, (int) h);\n+    }\n+\n+    public boolean containsKey(long key) {\n+        return get(key) != null;\n+    }\n+\n+    public V put(long key, V value) {\n+        checkNotNull(value);\n+        long h = hash(key);\n+        return getSection(h).put(key, value, (int) h, false, null);\n+    }\n+\n+    public V putIfAbsent(long key, V value) {\n+        checkNotNull(value);\n+        long h = hash(key);\n+        return getSection(h).put(key, value, (int) h, true, null);\n+    }\n+\n+    public V computeIfAbsent(long key, LongFunction<V> provider) {\n+        checkNotNull(provider);\n+        long h = hash(key);\n+        return getSection(h).put(key, null, (int) h, true, provider);\n+    }\n+\n+    public V remove(long key) {\n+        long h = hash(key);\n+        return getSection(h).remove(key, null, (int) h);\n+    }\n+\n+    public boolean remove(long key, Object value) {\n+        checkNotNull(value);\n+        long h = hash(key);\n+        return getSection(h).remove(key, value, (int) h) != null;\n+    }\n+\n+    private Section<V> getSection(long hash) {\n+        // Use 32 msb out of long to get the section\n+        final int sectionIdx = (int) (hash >>> 32) & (sections.length - 1);\n+        return sections[sectionIdx];\n+    }\n+\n+    public void clear() {\n+        for (Section<V> s : sections) {\n+            s.clear();\n+        }\n+    }\n+\n+    public void forEach(EntryProcessor<V> processor) {\n+        for (Section<V> s : sections) {\n+            s.forEach(processor);\n+        }\n+    }\n+\n+    /**\n+     * @return a new list of all keys (makes a copy)\n+     */\n+    public List<Long> keys() {\n+        List<Long> keys = Lists.newArrayListWithExpectedSize((int) size());\n+        forEach((key, value) -> keys.add(key));\n+        return keys;\n+    }\n+\n+    List<V> values() {\n+        List<V> values = Lists.newArrayListWithExpectedSize((int) size());\n+        forEach((key, value) -> values.add(value));\n+        return values;\n+    }\n+\n+    public static interface EntryProcessor<V> {\n+        void accept(long key, V value);\n+    }\n+\n+    // A section is a portion of the hash map that is covered by a single\n+    @SuppressWarnings(\"serial\")\n+    private static final class Section<V> extends StampedLock {\n+        private long[] keys;\n+        private V[] values;\n+\n+        private int capacity;\n+        private volatile int size;\n+        private int usedBuckets;\n+        private int resizeThreshold;\n+\n+        Section(int capacity) {\n+            this.capacity = alignToPowerOfTwo(capacity);\n+            this.keys = new long[this.capacity];\n+            this.values = (V[]) new Object[this.capacity];\n+            this.size = 0;\n+            this.usedBuckets = 0;\n+            this.resizeThreshold = (int) (this.capacity * MapFillFactor);\n+        }\n+\n+        V get(long key, int keyHash) {\n+            int bucket = keyHash;\n+\n+            long stamp = tryOptimisticRead();\n+            boolean acquiredLock = false;\n+\n+            try {\n+                while (true) {\n+                    int capacity = this.capacity;\n+                    bucket = signSafeMod(bucket, capacity);\n+\n+                    // First try optimistic locking\n+                    long storedKey = keys[bucket];\n+                    V storedValue = values[bucket];\n+\n+                    if (!acquiredLock && validate(stamp)) {\n+                        // The values we have read are consistent\n+                        if (storedKey == key) {\n+                            return storedValue != DeletedValue ? storedValue : null;\n+                        } else if (storedValue == EmptyValue) {\n+                            // Not found\n+                            return null;\n+                        }\n+                    } else {\n+                        // Fallback to acquiring read lock\n+                        if (!acquiredLock) {\n+                            stamp = readLock();\n+                            acquiredLock = true;\n+                            storedKey = keys[bucket];\n+                            storedValue = values[bucket];\n+                        }\n+\n+                        if (capacity != this.capacity) {\n+                            // There has been a rehashing. We need to restart the search\n+                            bucket = keyHash;\n+                            continue;\n+                        }\n+\n+                        if (storedKey == key) {\n+                            return storedValue != DeletedValue ? storedValue : null;\n+                        } else if (storedValue == EmptyValue) {\n+                            // Not found\n+                            return null;\n+                        }\n+                    }\n+\n+                    ++bucket;\n+                }\n+            } finally {\n+                if (acquiredLock) {\n+                    unlockRead(stamp);\n+                }\n+            }\n+        }\n+\n+        V put(long key, V value, int keyHash, boolean onlyIfAbsent, LongFunction<V> valueProvider) {\n+            int bucket = keyHash;\n+\n+            long stamp = writeLock();\n+            int capacity = this.capacity;\n+\n+            // Remember where we find the first available spot\n+            int firstDeletedKey = -1;\n+\n+            try {\n+                while (true) {\n+                    bucket = signSafeMod(bucket, capacity);\n+\n+                    long storedKey = keys[bucket];\n+                    V storedValue = values[bucket];\n+\n+                    if (storedKey == key) {\n+                        if (storedValue == EmptyValue) {\n+                            values[bucket] = value != null ? value : valueProvider.apply(key);\n+                            ++size;\n+                            ++usedBuckets;\n+                            return valueProvider != null ? values[bucket] : null;\n+                        } else if (storedValue == DeletedValue) {\n+                            values[bucket] = value != null ? value : valueProvider.apply(key);\n+                            ++size;\n+                            return valueProvider != null ? values[bucket] : null;\n+                        } else if (!onlyIfAbsent) {\n+                            // Over written an old value for same key\n+                            values[bucket] = value;\n+                            return storedValue;\n+                        } else {\n+                            return storedValue;\n+                        }\n+                    } else if (storedValue == EmptyValue) {\n+                        // Found an empty bucket. This means the key is not in the map. If we've already seen a deleted\n+                        // key, we should write at that position\n+                        if (firstDeletedKey != -1) {\n+                            bucket = firstDeletedKey;\n+                        } else {\n+                            ++usedBuckets;\n+                        }\n+\n+                        keys[bucket] = key;\n+                        values[bucket] = value != null ? value : valueProvider.apply(key);\n+                        ++size;\n+                        return valueProvider != null ? values[bucket] : null;\n+                    } else if (storedValue == DeletedValue) {\n+                        // The bucket contained a different deleted key\n+                        if (firstDeletedKey == -1) {\n+                            firstDeletedKey = bucket;\n+                        }\n+                    }\n+\n+                    ++bucket;\n+                }\n+            } finally {\n+                if (usedBuckets > resizeThreshold) {\n+                    try {\n+                        rehash();\n+                    } finally {\n+                        unlockWrite(stamp);\n+                    }\n+                } else {\n+                    unlockWrite(stamp);\n+                }\n+            }\n+        }\n+\n+        private V remove(long key, Object value, int keyHash) {\n+            int bucket = keyHash;\n+            long stamp = writeLock();\n+\n+            try {\n+                while (true) {\n+                    int capacity = this.capacity;\n+                    bucket = signSafeMod(bucket, capacity);\n+\n+                    long storedKey = keys[bucket];\n+                    V storedValue = values[bucket];\n+                    if (storedKey == key) {\n+                        if (value == null || value.equals(storedValue)) {\n+                            if (storedValue == EmptyValue || storedValue == DeletedValue) {\n+                                return null;\n+                            }\n+\n+                            --size;\n+                            V nextValueInArray = values[signSafeMod(bucket + 1, capacity)];\n+                            if (nextValueInArray == EmptyValue) {\n+                                values[bucket] = (V) EmptyValue;\n+                                --usedBuckets;\n+                            } else {\n+                                values[bucket] = (V) DeletedValue;\n+                            }\n+\n+                            return storedValue;\n+                        } else {\n+                            return null;\n+                        }\n+                    } else if (storedValue == EmptyValue) {\n+                        // Key wasn't found\n+                        return null;\n+                    }\n+\n+                    ++bucket;\n+                }\n+\n+            } finally {\n+                unlockWrite(stamp);\n+            }\n+        }\n+\n+        void clear() {\n+            long stamp = writeLock();\n+\n+            try {\n+                Arrays.fill(keys, 0);\n+                Arrays.fill(values, EmptyValue);\n+                this.size = 0;\n+                this.usedBuckets = 0;\n+            } finally {\n+                unlockWrite(stamp);\n+            }\n+        }\n+\n+        public void forEach(EntryProcessor<V> processor) {\n+            long stamp = tryOptimisticRead();\n+\n+            int capacity = this.capacity;\n+            long[] keys = this.keys;\n+            V[] values = this.values;\n+\n+            boolean acquiredReadLock = false;\n+\n+            try {\n+\n+                // Validate no rehashing\n+                if (!validate(stamp)) {\n+                    // Fallback to read lock\n+                    stamp = readLock();\n+                    acquiredReadLock = true;\n+\n+                    capacity = this.capacity;\n+                    keys = this.keys;\n+                    values = this.values;\n+                }\n+\n+                // Go through all the buckets for this section\n+                for (int bucket = 0; bucket < capacity; bucket++) {\n+                    long storedKey = keys[bucket];\n+                    V storedValue = values[bucket];\n+\n+                    if (!acquiredReadLock && !validate(stamp)) {\n+                        // Fallback to acquiring read lock\n+                        stamp = readLock();\n+                        acquiredReadLock = true;\n+\n+                        storedKey = keys[bucket];\n+                        storedValue = values[bucket];\n+                    }\n+\n+                    if (storedValue != DeletedValue && storedValue != EmptyValue) {\n+                        processor.accept(storedKey, storedValue);\n+                    }\n+                }\n+            } finally {\n+                if (acquiredReadLock) {\n+                    unlockRead(stamp);\n+                }\n+            }\n+        }\n+\n+        private void rehash() {\n+            // Expand the hashmap\n+            int newCapacity = capacity * 2;\n+            long[] newKeys = new long[newCapacity];\n+            V[] newValues = (V[]) new Object[newCapacity];\n+\n+            // Re-hash table\n+            for (int i = 0; i < keys.length; i++) {\n+                long storedKey = keys[i];\n+                V storedValue = values[i];\n+                if (storedValue != EmptyValue && storedValue != DeletedValue) {\n+                    insertKeyValueNoLock(newKeys, newValues, storedKey, storedValue);\n+                }\n+            }\n+\n+            capacity = newCapacity;\n+            keys = newKeys;\n+            values = newValues;\n+            usedBuckets = size;\n+            resizeThreshold = (int) (capacity * MapFillFactor);\n+        }\n+\n+        private static <V> void insertKeyValueNoLock(long[] keys, V[] values, long key, V value) {\n+            int bucket = (int) hash(key);\n+\n+            while (true) {\n+                bucket = signSafeMod(bucket, keys.length);\n+\n+                V storedValue = values[bucket];\n+\n+                if (storedValue == EmptyValue) {\n+                    // The bucket is empty, so we can use it\n+                    keys[bucket] = key;\n+                    values[bucket] = value;\n+                    return;\n+                }\n+\n+                ++bucket;\n+            }\n+        }\n+    }\n+\n+    private static final long HashMixer = 0xc6a4a7935bd1e995l;\n+    private static final int R = 47;\n+\n+    static final long hash(long key) {\n+        long hash = key * HashMixer;\n+        hash ^= hash >>> R;\n+        hash *= HashMixer;\n+        return hash;\n+    }\n+\n+    static final int signSafeMod(long n, int Max) {\n+        return (int) n & (Max - 1);\n+    }\n+\n+    private static final int alignToPowerOfTwo(int n) {\n+        return (int) Math.pow(2, 32 - Integer.numberOfLeadingZeros(n - 1));\n+    }\n+}"},{"sha":"d02b0bca48ada90acccba318f5836a667b2b5cbd","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/util/collections/ConcurrentLongHashSet.java","status":"added","additions":421,"deletions":0,"changes":421,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/ecbb053e6e873859507e247cae727f4bc8b9f7fa/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2Fcollections%2FConcurrentLongHashSet.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/ecbb053e6e873859507e247cae727f4bc8b9f7fa/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2Fcollections%2FConcurrentLongHashSet.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2Fcollections%2FConcurrentLongHashSet.java?ref=ecbb053e6e873859507e247cae727f4bc8b9f7fa","patch":"@@ -0,0 +1,421 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.util.collections;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.locks.StampedLock;\n+\n+/**\n+ * Concurrent hash set for primitive longs\n+ *\n+ * Provides similar methods as a ConcurrentSet&lt;Long&gt; but since it's an open hash map with linear probing, no node\n+ * allocations are required to store the values.\n+ * <p>\n+ * Items <strong>MUST</strong> be >= 0.\n+ */\n+public class ConcurrentLongHashSet {\n+\n+    private static final long EmptyItem = -1L;\n+    private static final long DeletedItem = -2L;\n+\n+    private static final float SetFillFactor = 0.66f;\n+\n+    private static final int DefaultExpectedItems = 256;\n+    private static final int DefaultConcurrencyLevel = 16;\n+\n+    private final Section[] sections;\n+\n+    public static interface ConsumerLong {\n+        void accept(long item);\n+    }\n+\n+    public ConcurrentLongHashSet() {\n+        this(DefaultExpectedItems);\n+    }\n+\n+    public ConcurrentLongHashSet(int expectedItems) {\n+        this(expectedItems, DefaultConcurrencyLevel);\n+    }\n+\n+    public ConcurrentLongHashSet(int expectedItems, int concurrencyLevel) {\n+        checkArgument(expectedItems > 0);\n+        checkArgument(concurrencyLevel > 0);\n+        checkArgument(expectedItems >= concurrencyLevel);\n+\n+        int numSections = concurrencyLevel;\n+        int perSectionExpectedItems = expectedItems / numSections;\n+        int perSectionCapacity = (int) (perSectionExpectedItems / SetFillFactor);\n+        this.sections = new Section[numSections];\n+\n+        for (int i = 0; i < numSections; i++) {\n+            sections[i] = new Section(perSectionCapacity);\n+        }\n+    }\n+\n+    public long size() {\n+        long size = 0;\n+        for (Section s : sections) {\n+            size += s.size;\n+        }\n+        return size;\n+    }\n+\n+    public long capacity() {\n+        long capacity = 0;\n+        for (Section s : sections) {\n+            capacity += s.capacity;\n+        }\n+        return capacity;\n+    }\n+\n+    public boolean isEmpty() {\n+        for (Section s : sections) {\n+            if (s.size != 0) {\n+                return false;\n+            }\n+        }\n+\n+        return true;\n+    }\n+\n+    long getUsedBucketCount() {\n+        long usedBucketCount = 0;\n+        for (Section s : sections) {\n+            usedBucketCount += s.usedBuckets;\n+        }\n+        return usedBucketCount;\n+    }\n+\n+    public boolean contains(long item) {\n+        checkBiggerEqualZero(item);\n+        long h = hash(item);\n+        return getSection(h).contains(item, (int) h);\n+    }\n+\n+    public boolean add(long item) {\n+        checkBiggerEqualZero(item);\n+        long h = hash(item);\n+        return getSection(h).add(item, (int) h);\n+    }\n+\n+    /**\n+     * Remove an existing entry if found\n+     *\n+     * @param item\n+     * @return true if removed or false if item was not present\n+     */\n+    public boolean remove(long item) {\n+        checkBiggerEqualZero(item);\n+        long h = hash(item);\n+        return getSection(h).remove(item, (int) h);\n+    }\n+\n+    private final Section getSection(long hash) {\n+        // Use 32 msb out of long to get the section\n+        final int sectionIdx = (int) (hash >>> 32) & (sections.length - 1);\n+        return sections[sectionIdx];\n+    }\n+\n+    public void clear() {\n+        for (Section s : sections) {\n+            s.clear();\n+        }\n+    }\n+\n+    public void forEach(ConsumerLong processor) {\n+        for (Section s : sections) {\n+            s.forEach(processor);\n+        }\n+    }\n+\n+    /**\n+     * @return a new list of all keys (makes a copy)\n+     */\n+    public Set<Long> items() {\n+        Set<Long> items = new HashSet<>();\n+        forEach(items::add);\n+        return items;\n+    }\n+\n+    // A section is a portion of the hash map that is covered by a single\n+    @SuppressWarnings(\"serial\")\n+    private static final class Section extends StampedLock {\n+        // Keys and values are stored interleaved in the table array\n+        private long[] table;\n+\n+        private int capacity;\n+        private volatile int size;\n+        private int usedBuckets;\n+        private int resizeThreshold;\n+\n+        Section(int capacity) {\n+            this.capacity = alignToPowerOfTwo(capacity);\n+            this.table = new long[this.capacity];\n+            this.size = 0;\n+            this.usedBuckets = 0;\n+            this.resizeThreshold = (int) (this.capacity * SetFillFactor);\n+            Arrays.fill(table, EmptyItem);\n+        }\n+\n+        boolean contains(long item, int hash) {\n+            long stamp = tryOptimisticRead();\n+            boolean acquiredLock = false;\n+            int bucket = signSafeMod(hash, capacity);\n+\n+            try {\n+                while (true) {\n+                    // First try optimistic locking\n+                    long storedItem = table[bucket];\n+\n+                    if (!acquiredLock && validate(stamp)) {\n+                        // The values we have read are consistent\n+                        if (item == storedItem) {\n+                            return true;\n+                        } else if (storedItem == EmptyItem) {\n+                            // Not found\n+                            return false;\n+                        }\n+                    } else {\n+                        // Fallback to acquiring read lock\n+                        if (!acquiredLock) {\n+                            stamp = readLock();\n+                            acquiredLock = true;\n+\n+                            bucket = signSafeMod(hash, capacity);\n+                            storedItem = table[bucket];\n+                        }\n+\n+                        if (item == storedItem) {\n+                            return true;\n+                        } else if (storedItem == EmptyItem) {\n+                            // Not found\n+                            return false;\n+                        }\n+                    }\n+\n+                    bucket = (bucket + 1) & (table.length - 1);\n+                }\n+            } finally {\n+                if (acquiredLock) {\n+                    unlockRead(stamp);\n+                }\n+            }\n+        }\n+\n+        boolean add(long item, long hash) {\n+            long stamp = writeLock();\n+            int bucket = signSafeMod(hash, capacity);\n+\n+            // Remember where we find the first available spot\n+            int firstDeletedItem = -1;\n+\n+            try {\n+                while (true) {\n+                    long storedItem = table[bucket];\n+\n+                    if (item == storedItem) {\n+                        // Item was already in set\n+                        return false;\n+                    } else if (storedItem == EmptyItem) {\n+                        // Found an empty bucket. This means the key is not in the map. If we've already seen a deleted\n+                        // key, we should write at that position\n+                        if (firstDeletedItem != -1) {\n+                            bucket = firstDeletedItem;\n+                        } else {\n+                            ++usedBuckets;\n+                        }\n+\n+                        table[bucket] = item;\n+                        ++size;\n+                        return true;\n+                    } else if (storedItem == DeletedItem) {\n+                        // The bucket contained a different deleted key\n+                        if (firstDeletedItem == -1) {\n+                            firstDeletedItem = bucket;\n+                        }\n+                    }\n+\n+                    bucket = (bucket + 1) & (table.length - 1);\n+                }\n+            } finally {\n+                if (usedBuckets > resizeThreshold) {\n+                    try {\n+                        rehash();\n+                    } finally {\n+                        unlockWrite(stamp);\n+                    }\n+                } else {\n+                    unlockWrite(stamp);\n+                }\n+            }\n+        }\n+\n+        private boolean remove(long item, int hash) {\n+            long stamp = writeLock();\n+            int bucket = signSafeMod(hash, capacity);\n+\n+            try {\n+                while (true) {\n+                    long storedItem = table[bucket];\n+                    if (item == storedItem) {\n+                        --size;\n+\n+                        cleanBucket(bucket);\n+                        return true;\n+\n+                    } else if (storedItem == EmptyItem) {\n+                        // Key wasn't found\n+                        return false;\n+                    }\n+\n+                    bucket = (bucket + 1) & (table.length - 1);\n+                }\n+            } finally {\n+                unlockWrite(stamp);\n+            }\n+        }\n+\n+        private void cleanBucket(int bucket) {\n+            int nextInArray = (bucket + 1) & (table.length - 1);\n+            if (table[nextInArray] == EmptyItem) {\n+                table[bucket] = EmptyItem;\n+                --usedBuckets;\n+            } else {\n+                table[bucket] = DeletedItem;\n+            }\n+        }\n+\n+        void clear() {\n+            long stamp = writeLock();\n+\n+            try {\n+                Arrays.fill(table, EmptyItem);\n+                this.size = 0;\n+                this.usedBuckets = 0;\n+            } finally {\n+                unlockWrite(stamp);\n+            }\n+        }\n+\n+        public void forEach(ConsumerLong processor) {\n+            long stamp = tryOptimisticRead();\n+\n+            long[] table = this.table;\n+            boolean acquiredReadLock = false;\n+\n+            try {\n+\n+                // Validate no rehashing\n+                if (!validate(stamp)) {\n+                    // Fallback to read lock\n+                    stamp = readLock();\n+                    acquiredReadLock = true;\n+                    table = this.table;\n+                }\n+\n+                // Go through all the buckets for this section\n+                for (int bucket = 0; bucket < table.length; bucket++) {\n+                    long storedItem = table[bucket];\n+\n+                    if (!acquiredReadLock && !validate(stamp)) {\n+                        // Fallback to acquiring read lock\n+                        stamp = readLock();\n+                        acquiredReadLock = true;\n+\n+                        storedItem = table[bucket];\n+                    }\n+\n+                    if (storedItem != DeletedItem && storedItem != EmptyItem) {\n+                        processor.accept(storedItem);\n+                    }\n+                }\n+            } finally {\n+                if (acquiredReadLock) {\n+                    unlockRead(stamp);\n+                }\n+            }\n+        }\n+\n+        private void rehash() {\n+            // Expand the hashmap\n+            int newCapacity = capacity * 2;\n+            long[] newTable = new long[newCapacity];\n+            Arrays.fill(newTable, EmptyItem);\n+\n+            // Re-hash table\n+            for (int i = 0; i < table.length; i++) {\n+                long storedItem = table[i];\n+                if (storedItem != EmptyItem && storedItem != DeletedItem) {\n+                    insertKeyValueNoLock(newTable, newCapacity, storedItem);\n+                }\n+            }\n+\n+            capacity = newCapacity;\n+            table = newTable;\n+            usedBuckets = size;\n+            resizeThreshold = (int) (capacity * SetFillFactor);\n+        }\n+\n+        private static void insertKeyValueNoLock(long[] table, int capacity, long item) {\n+            int bucket = signSafeMod(hash(item), capacity);\n+\n+            while (true) {\n+                long storedKey = table[bucket];\n+\n+                if (storedKey == EmptyItem) {\n+                    // The bucket is empty, so we can use it\n+                    table[bucket] = item;\n+                    return;\n+                }\n+\n+                bucket = (bucket + 1) & (table.length - 1);\n+            }\n+        }\n+    }\n+\n+    private static final long HashMixer = 0xc6a4a7935bd1e995l;\n+    private static final int R = 47;\n+\n+    final static long hash(long key) {\n+        long hash = key * HashMixer;\n+        hash ^= hash >>> R;\n+        hash *= HashMixer;\n+        return hash;\n+    }\n+\n+    static final int signSafeMod(long n, int Max) {\n+        return (int) (n & (Max - 1));\n+    }\n+\n+    private static final int alignToPowerOfTwo(int n) {\n+        return (int) Math.pow(2, 32 - Integer.numberOfLeadingZeros(n - 1));\n+    }\n+\n+    private static final void checkBiggerEqualZero(long n) {\n+        if (n < 0L) {\n+            throw new IllegalArgumentException(\"Keys and values must be >= 0\");\n+        }\n+    }\n+}"},{"sha":"7b5b5c278100e3766338243bc4aa1ba34d8cdfbc","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/util/collections/ConcurrentLongLongHashMap.java","status":"added","additions":723,"deletions":0,"changes":723,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/ecbb053e6e873859507e247cae727f4bc8b9f7fa/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2Fcollections%2FConcurrentLongLongHashMap.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/ecbb053e6e873859507e247cae727f4bc8b9f7fa/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2Fcollections%2FConcurrentLongLongHashMap.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2Fcollections%2FConcurrentLongLongHashMap.java?ref=ecbb053e6e873859507e247cae727f4bc8b9f7fa","patch":"@@ -0,0 +1,723 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.util.collections;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.locks.StampedLock;\n+import java.util.function.LongPredicate;\n+\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+\n+/**\n+ * Concurrent hash map from primitive long to long\n+ *\n+ * Provides similar methods as a ConcurrentMap<K,V> but since it's an open hash map with linear probing, no node\n+ * allocations are required to store the values.\n+ * <p>\n+ * Keys <strong>MUST</strong> be >= 0.\n+ */\n+public class ConcurrentLongLongHashMap {\n+\n+    private static final long EmptyKey = -1L;\n+    private static final long DeletedKey = -2L;\n+\n+    private static final long ValueNotFound = -1L;\n+\n+    private static final float MapFillFactor = 0.66f;\n+\n+    private static final int DefaultExpectedItems = 256;\n+    private static final int DefaultConcurrencyLevel = 16;\n+\n+    private final Section[] sections;\n+\n+    public static interface BiConsumerLong {\n+        void accept(long key, long value);\n+    }\n+\n+    public static interface LongLongFunction {\n+        long apply(long key);\n+    }\n+\n+    public static interface LongLongPredicate {\n+        boolean test(long key, long value);\n+    }\n+\n+    public ConcurrentLongLongHashMap() {\n+        this(DefaultExpectedItems);\n+    }\n+\n+    public ConcurrentLongLongHashMap(int expectedItems) {\n+        this(expectedItems, DefaultConcurrencyLevel);\n+    }\n+\n+    public ConcurrentLongLongHashMap(int expectedItems, int concurrencyLevel) {\n+        checkArgument(expectedItems > 0);\n+        checkArgument(concurrencyLevel > 0);\n+        checkArgument(expectedItems >= concurrencyLevel);\n+\n+        int numSections = concurrencyLevel;\n+        int perSectionExpectedItems = expectedItems / numSections;\n+        int perSectionCapacity = (int) (perSectionExpectedItems / MapFillFactor);\n+        this.sections = new Section[numSections];\n+\n+        for (int i = 0; i < numSections; i++) {\n+            sections[i] = new Section(perSectionCapacity);\n+        }\n+    }\n+\n+    public long size() {\n+        long size = 0;\n+        for (Section s : sections) {\n+            size += s.size;\n+        }\n+        return size;\n+    }\n+\n+    public long capacity() {\n+        long capacity = 0;\n+        for (Section s : sections) {\n+            capacity += s.capacity;\n+        }\n+        return capacity;\n+    }\n+\n+    public boolean isEmpty() {\n+        for (Section s : sections) {\n+            if (s.size != 0) {\n+                return false;\n+            }\n+        }\n+\n+        return true;\n+    }\n+\n+    long getUsedBucketCount() {\n+        long usedBucketCount = 0;\n+        for (Section s : sections) {\n+            usedBucketCount += s.usedBuckets;\n+        }\n+        return usedBucketCount;\n+    }\n+\n+    /**\n+     *\n+     * @param key\n+     * @return the value or -1 if the key was not present\n+     */\n+    public long get(long key) {\n+        checkBiggerEqualZero(key);\n+        long h = hash(key);\n+        return getSection(h).get(key, (int) h);\n+    }\n+\n+    public boolean containsKey(long key) {\n+        return get(key) != ValueNotFound;\n+    }\n+\n+    public long put(long key, long value) {\n+        checkBiggerEqualZero(key);\n+        checkBiggerEqualZero(value);\n+        long h = hash(key);\n+        return getSection(h).put(key, value, (int) h, false, null);\n+    }\n+\n+    public long putIfAbsent(long key, long value) {\n+        checkBiggerEqualZero(key);\n+        checkBiggerEqualZero(value);\n+        long h = hash(key);\n+        return getSection(h).put(key, value, (int) h, true, null);\n+    }\n+\n+    public long computeIfAbsent(long key, LongLongFunction provider) {\n+        checkBiggerEqualZero(key);\n+        checkNotNull(provider);\n+        long h = hash(key);\n+        return getSection(h).put(key, ValueNotFound, (int) h, true, provider);\n+    }\n+\n+    /**\n+     * Atomically add the specified delta to a current value identified by the key. If the entry was not in the map, a\n+     * new entry with default value 0 is added and then the delta is added.\n+     *\n+     * @param key\n+     *            the entry key\n+     * @param delta\n+     *            the delta to add\n+     * @return the new value of the entry\n+     * @throws IllegalArgumentException\n+     *             if the delta was invalid, such as it would have caused the value to be < 0\n+     */\n+    public long addAndGet(long key, long delta) {\n+        checkBiggerEqualZero(key);\n+        long h = hash(key);\n+        return getSection(h).addAndGet(key, delta, (int) h);\n+    }\n+\n+    /**\n+     * Change the value for a specific key only if it matches the current value.\n+     *\n+     * @param key\n+     * @param currentValue\n+     * @param newValue\n+     * @return\n+     */\n+    public boolean compareAndSet(long key, long currentValue, long newValue) {\n+        checkBiggerEqualZero(key);\n+        checkBiggerEqualZero(newValue);\n+        long h = hash(key);\n+        return getSection(h).compareAndSet(key, currentValue, newValue, (int) h);\n+    }\n+\n+    /**\n+     * Remove an existing entry if found\n+     *\n+     * @param key\n+     * @return the value associated with the key or -1 if key was not present\n+     */\n+    public long remove(long key) {\n+        checkBiggerEqualZero(key);\n+        long h = hash(key);\n+        return getSection(h).remove(key, ValueNotFound, (int) h);\n+    }\n+\n+    public boolean remove(long key, long value) {\n+        checkBiggerEqualZero(key);\n+        checkBiggerEqualZero(value);\n+        long h = hash(key);\n+        return getSection(h).remove(key, value, (int) h) != ValueNotFound;\n+    }\n+\n+    public int removeIf(LongPredicate filter) {\n+        checkNotNull(filter);\n+\n+        int removedCount = 0;\n+        for (Section s : sections) {\n+            removedCount += s.removeIf(filter);\n+        }\n+\n+        return removedCount;\n+    }\n+\n+    public int removeIf(LongLongPredicate filter) {\n+        checkNotNull(filter);\n+\n+        int removedCount = 0;\n+        for (Section s : sections) {\n+            removedCount += s.removeIf(filter);\n+        }\n+\n+        return removedCount;\n+    }\n+\n+    private final Section getSection(long hash) {\n+        // Use 32 msb out of long to get the section\n+        final int sectionIdx = (int) (hash >>> 32) & (sections.length - 1);\n+        return sections[sectionIdx];\n+    }\n+\n+    public void clear() {\n+        for (Section s : sections) {\n+            s.clear();\n+        }\n+    }\n+\n+    public void forEach(BiConsumerLong processor) {\n+        for (Section s : sections) {\n+            s.forEach(processor);\n+        }\n+    }\n+\n+    /**\n+     * @return a new list of all keys (makes a copy)\n+     */\n+    public List<Long> keys() {\n+        List<Long> keys = Lists.newArrayList();\n+        forEach((key, value) -> keys.add(key));\n+        return keys;\n+    }\n+\n+    public List<Long> values() {\n+        List<Long> values = Lists.newArrayList();\n+        forEach((key, value) -> values.add(value));\n+        return values;\n+    }\n+\n+    public Map<Long, Long> asMap() {\n+        Map<Long, Long> map = Maps.newHashMap();\n+        forEach((key, value) -> map.put(key, value));\n+        return map;\n+    }\n+\n+    // A section is a portion of the hash map that is covered by a single\n+    @SuppressWarnings(\"serial\")\n+    private static final class Section extends StampedLock {\n+        // Keys and values are stored interleaved in the table array\n+        private long[] table;\n+\n+        private int capacity;\n+        private volatile int size;\n+        private int usedBuckets;\n+        private int resizeThreshold;\n+\n+        Section(int capacity) {\n+            this.capacity = alignToPowerOfTwo(capacity);\n+            this.table = new long[2 * this.capacity];\n+            this.size = 0;\n+            this.usedBuckets = 0;\n+            this.resizeThreshold = (int) (this.capacity * MapFillFactor);\n+            Arrays.fill(table, EmptyKey);\n+        }\n+\n+        long get(long key, int keyHash) {\n+            long stamp = tryOptimisticRead();\n+            boolean acquiredLock = false;\n+            int bucket = signSafeMod(keyHash, capacity);\n+\n+            try {\n+                while (true) {\n+                    // First try optimistic locking\n+                    long storedKey = table[bucket];\n+                    long storedValue = table[bucket + 1];\n+\n+                    if (!acquiredLock && validate(stamp)) {\n+                        // The values we have read are consistent\n+                        if (key == storedKey) {\n+                            return storedValue;\n+                        } else if (storedKey == EmptyKey) {\n+                            // Not found\n+                            return ValueNotFound;\n+                        }\n+                    } else {\n+                        // Fallback to acquiring read lock\n+                        if (!acquiredLock) {\n+                            stamp = readLock();\n+                            acquiredLock = true;\n+\n+                            bucket = signSafeMod(keyHash, capacity);\n+                            storedKey = table[bucket];\n+                            storedValue = table[bucket + 1];\n+                        }\n+\n+                        if (key == storedKey) {\n+                            return storedValue;\n+                        } else if (storedKey == EmptyKey) {\n+                            // Not found\n+                            return ValueNotFound;\n+                        }\n+                    }\n+\n+                    bucket = (bucket + 2) & (table.length - 1);\n+                }\n+            } finally {\n+                if (acquiredLock) {\n+                    unlockRead(stamp);\n+                }\n+            }\n+        }\n+\n+        long put(long key, long value, int keyHash, boolean onlyIfAbsent, LongLongFunction valueProvider) {\n+            long stamp = writeLock();\n+            int bucket = signSafeMod(keyHash, capacity);\n+\n+            // Remember where we find the first available spot\n+            int firstDeletedKey = -1;\n+\n+            try {\n+                while (true) {\n+                    long storedKey = table[bucket];\n+                    long storedValue = table[bucket + 1];\n+\n+                    if (key == storedKey) {\n+                        if (!onlyIfAbsent) {\n+                            // Over written an old value for same key\n+                            table[bucket + 1] = value;\n+                            return storedValue;\n+                        } else {\n+                            return storedValue;\n+                        }\n+                    } else if (storedKey == EmptyKey) {\n+                        // Found an empty bucket. This means the key is not in the map. If we've already seen a deleted\n+                        // key, we should write at that position\n+                        if (firstDeletedKey != -1) {\n+                            bucket = firstDeletedKey;\n+                        } else {\n+                            ++usedBuckets;\n+                        }\n+\n+                        if (value == ValueNotFound) {\n+                            value = valueProvider.apply(key);\n+                        }\n+\n+                        table[bucket] = key;\n+                        table[bucket + 1] = value;\n+                        ++size;\n+                        return valueProvider != null ? value : ValueNotFound;\n+                    } else if (storedKey == DeletedKey) {\n+                        // The bucket contained a different deleted key\n+                        if (firstDeletedKey == -1) {\n+                            firstDeletedKey = bucket;\n+                        }\n+                    }\n+\n+                    bucket = (bucket + 2) & (table.length - 1);\n+                }\n+            } finally {\n+                if (usedBuckets > resizeThreshold) {\n+                    try {\n+                        rehash();\n+                    } finally {\n+                        unlockWrite(stamp);\n+                    }\n+                } else {\n+                    unlockWrite(stamp);\n+                }\n+            }\n+        }\n+\n+        long addAndGet(long key, long delta, int keyHash) {\n+            long stamp = writeLock();\n+            int bucket = signSafeMod(keyHash, capacity);\n+\n+            // Remember where we find the first available spot\n+            int firstDeletedKey = -1;\n+\n+            try {\n+                while (true) {\n+                    long storedKey = table[bucket];\n+                    long storedValue = table[bucket + 1];\n+\n+                    if (key == storedKey) {\n+                        // Over written an old value for same key\n+                        long newValue = storedValue + delta;\n+                        checkBiggerEqualZero(newValue);\n+\n+                        table[bucket + 1] = newValue;\n+                        return newValue;\n+                    } else if (storedKey == EmptyKey) {\n+                        // Found an empty bucket. This means the key is not in the map. If we've already seen a deleted\n+                        // key, we should write at that position\n+                        checkBiggerEqualZero(delta);\n+\n+                        if (firstDeletedKey != -1) {\n+                            bucket = firstDeletedKey;\n+                        } else {\n+                            ++usedBuckets;\n+                        }\n+\n+                        table[bucket] = key;\n+                        table[bucket + 1] = delta;\n+                        ++size;\n+                        return delta;\n+                    } else if (storedKey == DeletedKey) {\n+                        // The bucket contained a different deleted key\n+                        if (firstDeletedKey == -1) {\n+                            firstDeletedKey = bucket;\n+                        }\n+                    }\n+\n+                    bucket = (bucket + 2) & (table.length - 1);\n+                }\n+            } finally {\n+                if (usedBuckets > resizeThreshold) {\n+                    try {\n+                        rehash();\n+                    } finally {\n+                        unlockWrite(stamp);\n+                    }\n+                } else {\n+                    unlockWrite(stamp);\n+                }\n+            }\n+        }\n+\n+        boolean compareAndSet(long key, long currentValue, long newValue, int keyHash) {\n+            long stamp = writeLock();\n+            int bucket = signSafeMod(keyHash, capacity);\n+\n+            // Remember where we find the first available spot\n+            int firstDeletedKey = -1;\n+\n+            try {\n+                while (true) {\n+                    long storedKey = table[bucket];\n+                    long storedValue = table[bucket + 1];\n+\n+                    if (key == storedKey) {\n+                        if (storedValue != currentValue) {\n+                            return false;\n+                        }\n+\n+                        // Over write an old value for same key\n+                        table[bucket + 1] = newValue;\n+                        return true;\n+                    } else if (storedKey == EmptyKey) {\n+                        // Found an empty bucket. This means the key is not in the map.\n+                        if (currentValue == -1) {\n+                            if (firstDeletedKey != -1) {\n+                                bucket = firstDeletedKey;\n+                            } else {\n+                                ++usedBuckets;\n+                            }\n+\n+                            table[bucket] = key;\n+                            table[bucket + 1] = newValue;\n+                            ++size;\n+                            return true;\n+                        } else {\n+                            return false;\n+                        }\n+                    } else if (storedKey == DeletedKey) {\n+                        // The bucket contained a different deleted key\n+                        if (firstDeletedKey == -1) {\n+                            firstDeletedKey = bucket;\n+                        }\n+                    }\n+\n+                    bucket = (bucket + 2) & (table.length - 1);\n+                }\n+            } finally {\n+                if (usedBuckets > resizeThreshold) {\n+                    try {\n+                        rehash();\n+                    } finally {\n+                        unlockWrite(stamp);\n+                    }\n+                } else {\n+                    unlockWrite(stamp);\n+                }\n+            }\n+        }\n+\n+        private long remove(long key, long value, int keyHash) {\n+            long stamp = writeLock();\n+            int bucket = signSafeMod(keyHash, capacity);\n+\n+            try {\n+                while (true) {\n+                    long storedKey = table[bucket];\n+                    long storedValue = table[bucket + 1];\n+                    if (key == storedKey) {\n+                        if (value == ValueNotFound || value == storedValue) {\n+                            --size;\n+\n+                            cleanBucket(bucket);\n+                            return storedValue;\n+                        } else {\n+                            return ValueNotFound;\n+                        }\n+                    } else if (storedKey == EmptyKey) {\n+                        // Key wasn't found\n+                        return ValueNotFound;\n+                    }\n+\n+                    bucket = (bucket + 2) & (table.length - 1);\n+                }\n+\n+            } finally {\n+                unlockWrite(stamp);\n+            }\n+        }\n+\n+        int removeIf(LongPredicate filter) {\n+            long stamp = writeLock();\n+\n+            int removedCount = 0;\n+            try {\n+                // Go through all the buckets for this section\n+                for (int bucket = 0; bucket < table.length; bucket += 2) {\n+                    long storedKey = table[bucket];\n+\n+                    if (storedKey != DeletedKey && storedKey != EmptyKey) {\n+                        if (filter.test(storedKey)) {\n+                            // Removing item\n+                            --size;\n+                            ++removedCount;\n+                            cleanBucket(bucket);\n+                        }\n+                    }\n+                }\n+\n+                return removedCount;\n+            } finally {\n+                unlockWrite(stamp);\n+            }\n+        }\n+\n+        int removeIf(LongLongPredicate filter) {\n+            long stamp = writeLock();\n+\n+            int removedCount = 0;\n+            try {\n+                // Go through all the buckets for this section\n+                for (int bucket = 0; bucket < table.length; bucket += 2) {\n+                    long storedKey = table[bucket];\n+                    long storedValue = table[bucket + 1];\n+\n+                    if (storedKey != DeletedKey && storedKey != EmptyKey) {\n+                        if (filter.test(storedKey, storedValue)) {\n+                            // Removing item\n+                            --size;\n+                            ++removedCount;\n+                            cleanBucket(bucket);\n+                        }\n+                    }\n+                }\n+\n+                return removedCount;\n+            } finally {\n+                unlockWrite(stamp);\n+            }\n+        }\n+\n+        private void cleanBucket(int bucket) {\n+            int nextInArray = (bucket + 2) & (table.length - 1);\n+            if (table[nextInArray] == EmptyKey) {\n+                table[bucket] = EmptyKey;\n+                table[bucket + 1] = ValueNotFound;\n+                --usedBuckets;\n+            } else {\n+                table[bucket] = DeletedKey;\n+                table[bucket + 1] = ValueNotFound;\n+            }\n+        }\n+\n+        void clear() {\n+            long stamp = writeLock();\n+\n+            try {\n+                Arrays.fill(table, EmptyKey);\n+                this.size = 0;\n+                this.usedBuckets = 0;\n+            } finally {\n+                unlockWrite(stamp);\n+            }\n+        }\n+\n+        public void forEach(BiConsumerLong processor) {\n+            long stamp = tryOptimisticRead();\n+\n+            long[] table = this.table;\n+            boolean acquiredReadLock = false;\n+\n+            try {\n+\n+                // Validate no rehashing\n+                if (!validate(stamp)) {\n+                    // Fallback to read lock\n+                    stamp = readLock();\n+                    acquiredReadLock = true;\n+                    table = this.table;\n+                }\n+\n+                // Go through all the buckets for this section\n+                for (int bucket = 0; bucket < table.length; bucket += 2) {\n+                    long storedKey = table[bucket];\n+                    long storedValue = table[bucket + 1];\n+\n+                    if (!acquiredReadLock && !validate(stamp)) {\n+                        // Fallback to acquiring read lock\n+                        stamp = readLock();\n+                        acquiredReadLock = true;\n+\n+                        storedKey = table[bucket];\n+                        storedValue = table[bucket + 1];\n+                    }\n+\n+                    if (storedKey != DeletedKey && storedKey != EmptyKey) {\n+                        processor.accept(storedKey, storedValue);\n+                    }\n+                }\n+            } finally {\n+                if (acquiredReadLock) {\n+                    unlockRead(stamp);\n+                }\n+            }\n+        }\n+\n+        private void rehash() {\n+            // Expand the hashmap\n+            int newCapacity = capacity * 2;\n+            long[] newTable = new long[2 * newCapacity];\n+            Arrays.fill(newTable, EmptyKey);\n+\n+            // Re-hash table\n+            for (int i = 0; i < table.length; i += 2) {\n+                long storedKey = table[i];\n+                long storedValue = table[i + 1];\n+                if (storedKey != EmptyKey && storedKey != DeletedKey) {\n+                    insertKeyValueNoLock(newTable, newCapacity, storedKey, storedValue);\n+                }\n+            }\n+\n+            capacity = newCapacity;\n+            table = newTable;\n+            usedBuckets = size;\n+            resizeThreshold = (int) (capacity * MapFillFactor);\n+        }\n+\n+        private static void insertKeyValueNoLock(long[] table, int capacity, long key, long value) {\n+            int bucket = signSafeMod(hash(key), capacity);\n+\n+            while (true) {\n+                long storedKey = table[bucket];\n+\n+                if (storedKey == EmptyKey) {\n+                    // The bucket is empty, so we can use it\n+                    table[bucket] = key;\n+                    table[bucket + 1] = value;\n+                    return;\n+                }\n+\n+                bucket = (bucket + 2) & (table.length - 1);\n+            }\n+        }\n+    }\n+\n+    private static final long HashMixer = 0xc6a4a7935bd1e995l;\n+    private static final int R = 47;\n+\n+    final static long hash(long key) {\n+        long hash = key * HashMixer;\n+        hash ^= hash >>> R;\n+        hash *= HashMixer;\n+        return hash;\n+    }\n+\n+    static final int signSafeMod(long n, int Max) {\n+        return (int) (n & (Max - 1)) << 1;\n+    }\n+\n+    private static final int alignToPowerOfTwo(int n) {\n+        return (int) Math.pow(2, 32 - Integer.numberOfLeadingZeros(n - 1));\n+    }\n+\n+    private static final void checkBiggerEqualZero(long n) {\n+        if (n < 0L) {\n+            throw new IllegalArgumentException(\"Keys and values must be >= 0\");\n+        }\n+    }\n+}"},{"sha":"767773516688c3f2e0a62720651281b80a80427c","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/util/collections/ConcurrentLongLongPairHashMap.java","status":"added","additions":550,"deletions":0,"changes":550,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/ecbb053e6e873859507e247cae727f4bc8b9f7fa/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2Fcollections%2FConcurrentLongLongPairHashMap.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/ecbb053e6e873859507e247cae727f4bc8b9f7fa/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2Fcollections%2FConcurrentLongLongPairHashMap.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2Fcollections%2FConcurrentLongLongPairHashMap.java?ref=ecbb053e6e873859507e247cae727f4bc8b9f7fa","patch":"@@ -0,0 +1,550 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.util.collections;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.locks.StampedLock;\n+\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+\n+/**\n+ * Concurrent hash map where both keys and values are composed of pairs of longs.\n+ * <p>\n+ * (long,long) --&gt; (long,long)\n+ * <p>\n+ * Provides similar methods as a ConcurrentMap<K,V> but since it's an open hash map with linear probing, no node\n+ * allocations are required to store the keys and values, and no boxing is required.\n+ * <p>\n+ * Keys <strong>MUST</strong> be >= 0.\n+ */\n+public class ConcurrentLongLongPairHashMap {\n+\n+    private static final long EmptyKey = -1L;\n+    private static final long DeletedKey = -2L;\n+\n+    private static final long ValueNotFound = -1L;\n+\n+    private static final float MapFillFactor = 0.66f;\n+\n+    private static final int DefaultExpectedItems = 256;\n+    private static final int DefaultConcurrencyLevel = 16;\n+\n+    private final Section[] sections;\n+\n+    public static interface BiConsumerLongPair {\n+        void accept(long key1, long key2, long value1, long value2);\n+    }\n+\n+    public static interface LongLongPairFunction {\n+        long apply(long key1, long key2);\n+    }\n+\n+    public static interface LongLongPairPredicate {\n+        boolean test(long key1, long key2, long value1, long value2);\n+    }\n+\n+    public ConcurrentLongLongPairHashMap() {\n+        this(DefaultExpectedItems);\n+    }\n+\n+    public ConcurrentLongLongPairHashMap(int expectedItems) {\n+        this(expectedItems, DefaultConcurrencyLevel);\n+    }\n+\n+    public ConcurrentLongLongPairHashMap(int expectedItems, int concurrencyLevel) {\n+        checkArgument(expectedItems > 0);\n+        checkArgument(concurrencyLevel > 0);\n+        checkArgument(expectedItems >= concurrencyLevel);\n+\n+        int numSections = concurrencyLevel;\n+        int perSectionExpectedItems = expectedItems / numSections;\n+        int perSectionCapacity = (int) (perSectionExpectedItems / MapFillFactor);\n+        this.sections = new Section[numSections];\n+\n+        for (int i = 0; i < numSections; i++) {\n+            sections[i] = new Section(perSectionCapacity);\n+        }\n+    }\n+\n+    public long size() {\n+        long size = 0;\n+        for (Section s : sections) {\n+            size += s.size;\n+        }\n+        return size;\n+    }\n+\n+    public long capacity() {\n+        long capacity = 0;\n+        for (Section s : sections) {\n+            capacity += s.capacity;\n+        }\n+        return capacity;\n+    }\n+\n+    public boolean isEmpty() {\n+        for (Section s : sections) {\n+            if (s.size != 0) {\n+                return false;\n+            }\n+        }\n+\n+        return true;\n+    }\n+\n+    long getUsedBucketCount() {\n+        long usedBucketCount = 0;\n+        for (Section s : sections) {\n+            usedBucketCount += s.usedBuckets;\n+        }\n+        return usedBucketCount;\n+    }\n+\n+    /**\n+     *\n+     * @param key\n+     * @return the value or -1 if the key was not present\n+     */\n+    public LongPair get(long key1, long key2) {\n+        checkBiggerEqualZero(key1);\n+        long h = hash(key1, key2);\n+        return getSection(h).get(key1, key2, (int) h);\n+    }\n+\n+    public boolean containsKey(long key1, long key2) {\n+        return get(key1, key2) != null;\n+    }\n+\n+    public boolean put(long key1, long key2, long value1, long value2) {\n+        checkBiggerEqualZero(key1);\n+        checkBiggerEqualZero(value1);\n+        long h = hash(key1, key2);\n+        return getSection(h).put(key1, key2, value1, value2, (int) h, false);\n+    }\n+\n+    public boolean putIfAbsent(long key1, long key2, long value1, long value2) {\n+        checkBiggerEqualZero(key1);\n+        checkBiggerEqualZero(value1);\n+        long h = hash(key1, key2);\n+        return getSection(h).put(key1, key2, value1, value2, (int) h, true);\n+    }\n+\n+    /**\n+     * Remove an existing entry if found\n+     *\n+     * @param key\n+     * @return the value associated with the key or -1 if key was not present\n+     */\n+    public boolean remove(long key1, long key2) {\n+        checkBiggerEqualZero(key1);\n+        long h = hash(key1, key2);\n+        return getSection(h).remove(key1, key2, ValueNotFound, ValueNotFound, (int) h);\n+    }\n+\n+    public boolean remove(long key1, long key2, long value1, long value2) {\n+        checkBiggerEqualZero(key1);\n+        checkBiggerEqualZero(value1);\n+        long h = hash(key1, key2);\n+        return getSection(h).remove(key1, key2, value1, value2, (int) h);\n+    }\n+\n+    private final Section getSection(long hash) {\n+        // Use 32 msb out of long to get the section\n+        final int sectionIdx = (int) (hash >>> 32) & (sections.length - 1);\n+        return sections[sectionIdx];\n+    }\n+\n+    public void clear() {\n+        for (Section s : sections) {\n+            s.clear();\n+        }\n+    }\n+\n+    public void forEach(BiConsumerLongPair processor) {\n+        for (Section s : sections) {\n+            s.forEach(processor);\n+        }\n+    }\n+\n+    /**\n+     * @return a new list of all keys (makes a copy)\n+     */\n+    public List<LongPair> keys() {\n+        List<LongPair> keys = Lists.newArrayList();\n+        forEach((key1, key2, value1, value2) -> keys.add(new LongPair(key1, key2)));\n+        return keys;\n+    }\n+\n+    public List<LongPair> values() {\n+        List<LongPair> values = Lists.newArrayList();\n+        forEach((key1, key2, value1, value2) -> values.add(new LongPair(value1, value2)));\n+        return values;\n+    }\n+\n+    public Map<LongPair, LongPair> asMap() {\n+        Map<LongPair, LongPair> map = Maps.newHashMap();\n+        forEach((key1, key2, value1, value2) -> map.put(new LongPair(key1, key2), new LongPair(value1, value2)));\n+        return map;\n+    }\n+\n+    // A section is a portion of the hash map that is covered by a single\n+    @SuppressWarnings(\"serial\")\n+    private static final class Section extends StampedLock {\n+        // Keys and values are stored interleaved in the table array\n+        private long[] table;\n+\n+        private int capacity;\n+        private volatile int size;\n+        private int usedBuckets;\n+        private int resizeThreshold;\n+\n+        Section(int capacity) {\n+            this.capacity = alignToPowerOfTwo(capacity);\n+            this.table = new long[4 * this.capacity];\n+            this.size = 0;\n+            this.usedBuckets = 0;\n+            this.resizeThreshold = (int) (this.capacity * MapFillFactor);\n+            Arrays.fill(table, EmptyKey);\n+        }\n+\n+        LongPair get(long key1, long key2, int keyHash) {\n+            long stamp = tryOptimisticRead();\n+            boolean acquiredLock = false;\n+            int bucket = signSafeMod(keyHash, capacity);\n+\n+            try {\n+                while (true) {\n+                    // First try optimistic locking\n+                    long storedKey1 = table[bucket];\n+                    long storedKey2 = table[bucket + 1];\n+                    long storedValue1 = table[bucket + 2];\n+                    long storedValue2 = table[bucket + 3];\n+\n+                    if (!acquiredLock && validate(stamp)) {\n+                        // The values we have read are consistent\n+                        if (key1 == storedKey1 && key2 == storedKey2) {\n+                            return new LongPair(storedValue1, storedValue2);\n+                        } else if (storedKey1 == EmptyKey) {\n+                            // Not found\n+                            return null;\n+                        }\n+                    } else {\n+                        // Fallback to acquiring read lock\n+                        if (!acquiredLock) {\n+                            stamp = readLock();\n+                            acquiredLock = true;\n+\n+                            bucket = signSafeMod(keyHash, capacity);\n+                            storedKey1 = table[bucket];\n+                            storedKey2 = table[bucket + 1];\n+                            storedValue1 = table[bucket + 2];\n+                            storedValue2 = table[bucket + 3];\n+                        }\n+\n+                        if (key1 == storedKey1 && key2 == storedKey2) {\n+                            return new LongPair(storedValue1, storedValue2);\n+                        } else if (storedKey1 == EmptyKey) {\n+                            // Not found\n+                            return null;\n+                        }\n+                    }\n+\n+                    bucket = (bucket + 4) & (table.length - 1);\n+                }\n+            } finally {\n+                if (acquiredLock) {\n+                    unlockRead(stamp);\n+                }\n+            }\n+        }\n+\n+        boolean put(long key1, long key2, long value1, long value2, int keyHash, boolean onlyIfAbsent) {\n+            long stamp = writeLock();\n+            int bucket = signSafeMod(keyHash, capacity);\n+\n+            // Remember where we find the first available spot\n+            int firstDeletedKey = -1;\n+\n+            try {\n+                while (true) {\n+                    long storedKey1 = table[bucket];\n+                    long storedKey2 = table[bucket + 1];\n+\n+                    if (key1 == storedKey1 && key2 == storedKey2) {\n+                        if (!onlyIfAbsent) {\n+                            // Over written an old value for same key\n+                            table[bucket + 2] = value1;\n+                            table[bucket + 3] = value2;\n+                            return true;\n+                        } else {\n+                            return false;\n+                        }\n+                    } else if (storedKey1 == EmptyKey) {\n+                        // Found an empty bucket. This means the key is not in the map. If we've already seen a deleted\n+                        // key, we should write at that position\n+                        if (firstDeletedKey != -1) {\n+                            bucket = firstDeletedKey;\n+                        } else {\n+                            ++usedBuckets;\n+                        }\n+\n+                        table[bucket] = key1;\n+                        table[bucket + 1] = key2;\n+                        table[bucket + 2] = value1;\n+                        table[bucket + 3] = value2;\n+                        ++size;\n+                        return true;\n+                    } else if (storedKey1 == DeletedKey) {\n+                        // The bucket contained a different deleted key\n+                        if (firstDeletedKey == -1) {\n+                            firstDeletedKey = bucket;\n+                        }\n+                    }\n+\n+                    bucket = (bucket + 4) & (table.length - 1);\n+                }\n+            } finally {\n+                if (usedBuckets > resizeThreshold) {\n+                    try {\n+                        rehash();\n+                    } finally {\n+                        unlockWrite(stamp);\n+                    }\n+                } else {\n+                    unlockWrite(stamp);\n+                }\n+            }\n+        }\n+\n+        private boolean remove(long key1, long key2, long value1, long value2, int keyHash) {\n+            long stamp = writeLock();\n+            int bucket = signSafeMod(keyHash, capacity);\n+\n+            try {\n+                while (true) {\n+                    long storedKey1 = table[bucket];\n+                    long storedKey2 = table[bucket + 1];\n+                    long storedValue1 = table[bucket + 2];\n+                    long storedValue2 = table[bucket + 3];\n+                    if (key1 == storedKey1 && key2 == storedKey2) {\n+                        if (value1 == ValueNotFound || (value1 == storedValue1 && value2 == storedValue2)) {\n+                            --size;\n+\n+                            cleanBucket(bucket);\n+                            return true;\n+                        } else {\n+                            return false;\n+                        }\n+                    } else if (storedKey1 == EmptyKey) {\n+                        // Key wasn't found\n+                        return false;\n+                    }\n+\n+                    bucket = (bucket + 4) & (table.length - 1);\n+                }\n+\n+            } finally {\n+                unlockWrite(stamp);\n+            }\n+        }\n+\n+        private void cleanBucket(int bucket) {\n+            int nextInArray = (bucket + 4) & (table.length - 1);\n+            if (table[nextInArray] == EmptyKey) {\n+                table[bucket] = EmptyKey;\n+                table[bucket + 1] = EmptyKey;\n+                table[bucket + 2] = ValueNotFound;\n+                table[bucket + 3] = ValueNotFound;\n+                --usedBuckets;\n+            } else {\n+                table[bucket] = DeletedKey;\n+                table[bucket + 1] = DeletedKey;\n+                table[bucket + 2] = ValueNotFound;\n+                table[bucket + 3] = ValueNotFound;\n+            }\n+        }\n+\n+        void clear() {\n+            long stamp = writeLock();\n+\n+            try {\n+                Arrays.fill(table, EmptyKey);\n+                this.size = 0;\n+                this.usedBuckets = 0;\n+            } finally {\n+                unlockWrite(stamp);\n+            }\n+        }\n+\n+        public void forEach(BiConsumerLongPair processor) {\n+            long stamp = tryOptimisticRead();\n+\n+            long[] table = this.table;\n+            boolean acquiredReadLock = false;\n+\n+            try {\n+\n+                // Validate no rehashing\n+                if (!validate(stamp)) {\n+                    // Fallback to read lock\n+                    stamp = readLock();\n+                    acquiredReadLock = true;\n+                    table = this.table;\n+                }\n+\n+                // Go through all the buckets for this section\n+                for (int bucket = 0; bucket < table.length; bucket += 4) {\n+                    long storedKey1 = table[bucket];\n+                    long storedKey2 = table[bucket + 1];\n+                    long storedValue1 = table[bucket + 2];\n+                    long storedValue2 = table[bucket + 3];\n+\n+                    if (!acquiredReadLock && !validate(stamp)) {\n+                        // Fallback to acquiring read lock\n+                        stamp = readLock();\n+                        acquiredReadLock = true;\n+\n+                        storedKey1 = table[bucket];\n+                        storedKey2 = table[bucket + 1];\n+                        storedValue1 = table[bucket + 2];\n+                        storedValue2 = table[bucket + 3];\n+                    }\n+\n+                    if (storedKey1 != DeletedKey && storedKey1 != EmptyKey) {\n+                        processor.accept(storedKey1, storedKey2, storedValue1, storedValue2);\n+                    }\n+                }\n+            } finally {\n+                if (acquiredReadLock) {\n+                    unlockRead(stamp);\n+                }\n+            }\n+        }\n+\n+        private void rehash() {\n+            // Expand the hashmap\n+            int newCapacity = capacity * 2;\n+            long[] newTable = new long[4 * newCapacity];\n+            Arrays.fill(newTable, EmptyKey);\n+\n+            // Re-hash table\n+            for (int i = 0; i < table.length; i += 4) {\n+                long storedKey1 = table[i];\n+                long storedKey2 = table[i + 1];\n+                long storedValue1 = table[i + 2];\n+                long storedValue2 = table[i + 3];\n+                if (storedKey1 != EmptyKey && storedKey1 != DeletedKey) {\n+                    insertKeyValueNoLock(newTable, newCapacity, storedKey1, storedKey2, storedValue1, storedValue2);\n+                }\n+            }\n+\n+            capacity = newCapacity;\n+            table = newTable;\n+            usedBuckets = size;\n+            resizeThreshold = (int) (capacity * MapFillFactor);\n+        }\n+\n+        private static void insertKeyValueNoLock(long[] table, int capacity, long key1, long key2, long value1,\n+                long value2) {\n+            int bucket = signSafeMod(hash(key1, key2), capacity);\n+\n+            while (true) {\n+                long storedKey1 = table[bucket];\n+\n+                if (storedKey1 == EmptyKey) {\n+                    // The bucket is empty, so we can use it\n+                    table[bucket] = key1;\n+                    table[bucket + 1] = key2;\n+                    table[bucket + 2] = value1;\n+                    table[bucket + 3] = value2;\n+                    return;\n+                }\n+\n+                bucket = (bucket + 4) & (table.length - 1);\n+            }\n+        }\n+    }\n+\n+    private static final long HashMixer = 0xc6a4a7935bd1e995l;\n+    private static final int R = 47;\n+\n+    final static long hash(long key1, long key2) {\n+        long hash = key1 * HashMixer;\n+        hash ^= hash >>> R;\n+        hash *= HashMixer;\n+        hash += 31 + (key2 * HashMixer);\n+        hash ^= hash >>> R;\n+        hash *= HashMixer;\n+        return hash;\n+    }\n+\n+    static final int signSafeMod(long n, int Max) {\n+        return (int) (n & (Max - 1)) << 2;\n+    }\n+\n+    private static final int alignToPowerOfTwo(int n) {\n+        return (int) Math.pow(2, 32 - Integer.numberOfLeadingZeros(n - 1));\n+    }\n+\n+    private static final void checkBiggerEqualZero(long n) {\n+        if (n < 0L) {\n+            throw new IllegalArgumentException(\"Keys and values must be >= 0\");\n+        }\n+    }\n+\n+    public static class LongPair implements Comparable<LongPair> {\n+        public final long first;\n+        public final long second;\n+\n+        public LongPair(long first, long second) {\n+            this.first = first;\n+            this.second = second;\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (obj instanceof LongPair) {\n+                LongPair other = (LongPair) obj;\n+                return first == other.first && second == other.second;\n+            }\n+            return false;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return (int) hash(first, second);\n+        }\n+\n+        @Override\n+        public int compareTo(LongPair o) {\n+            if (first != o.first) {\n+                return Long.compare(first, o.first);\n+            } else {\n+                return Long.compare(second, o.second);\n+            }\n+        }\n+    }\n+}"},{"sha":"90fc5489e35bf9fbf061d05c9260ea8d9afb131b","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/util/collections/ConcurrentOpenHashMap.java","status":"added","additions":493,"deletions":0,"changes":493,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/ecbb053e6e873859507e247cae727f4bc8b9f7fa/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2Fcollections%2FConcurrentOpenHashMap.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/ecbb053e6e873859507e247cae727f4bc8b9f7fa/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2Fcollections%2FConcurrentOpenHashMap.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2Fcollections%2FConcurrentOpenHashMap.java?ref=ecbb053e6e873859507e247cae727f4bc8b9f7fa","patch":"@@ -0,0 +1,493 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.util.collections;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.locks.StampedLock;\n+import java.util.function.BiConsumer;\n+import java.util.function.BiPredicate;\n+import java.util.function.Function;\n+\n+import com.google.common.collect.Lists;\n+\n+/**\n+ * Concurrent hash map\n+ *\n+ * Provides similar methods as a ConcurrentMap<K,V> but since it's an open hash map with linear probing, no node\n+ * allocations are required to store the values\n+ *\n+ * @param <V>\n+ */\n+@SuppressWarnings(\"unchecked\")\n+public class ConcurrentOpenHashMap<K, V> {\n+\n+    private static final Object EmptyKey = null;\n+    private static final Object DeletedKey = new Object();\n+\n+    private static final float MapFillFactor = 0.66f;\n+\n+    private static final int DefaultExpectedItems = 256;\n+    private static final int DefaultConcurrencyLevel = 16;\n+\n+    private final Section<K, V>[] sections;\n+\n+    public ConcurrentOpenHashMap() {\n+        this(DefaultExpectedItems);\n+    }\n+\n+    public ConcurrentOpenHashMap(int expectedItems) {\n+        this(expectedItems, DefaultConcurrencyLevel);\n+    }\n+\n+    public ConcurrentOpenHashMap(int expectedItems, int concurrencyLevel) {\n+        checkArgument(expectedItems > 0);\n+        checkArgument(concurrencyLevel > 0);\n+        checkArgument(expectedItems >= concurrencyLevel);\n+\n+        int numSections = concurrencyLevel;\n+        int perSectionExpectedItems = expectedItems / numSections;\n+        int perSectionCapacity = (int) (perSectionExpectedItems / MapFillFactor);\n+        this.sections = (Section<K, V>[]) new Section[numSections];\n+\n+        for (int i = 0; i < numSections; i++) {\n+            sections[i] = new Section<>(perSectionCapacity);\n+        }\n+    }\n+\n+    public long size() {\n+        long size = 0;\n+        for (Section<K, V> s : sections) {\n+            size += s.size;\n+        }\n+        return size;\n+    }\n+\n+    public long capacity() {\n+        long capacity = 0;\n+        for (Section<K, V> s : sections) {\n+            capacity += s.capacity;\n+        }\n+        return capacity;\n+    }\n+\n+    public boolean isEmpty() {\n+        for (Section<K, V> s : sections) {\n+            if (s.size != 0) {\n+                return false;\n+            }\n+        }\n+\n+        return true;\n+    }\n+\n+    public V get(K key) {\n+        checkNotNull(key);\n+        long h = hash(key);\n+        return getSection(h).get(key, (int) h);\n+    }\n+\n+    public boolean containsKey(K key) {\n+        return get(key) != null;\n+    }\n+\n+    public V put(K key, V value) {\n+        checkNotNull(key);\n+        checkNotNull(value);\n+        long h = hash(key);\n+        return getSection(h).put(key, value, (int) h, false, null);\n+    }\n+\n+    public V putIfAbsent(K key, V value) {\n+        checkNotNull(key);\n+        checkNotNull(value);\n+        long h = hash(key);\n+        return getSection(h).put(key, value, (int) h, true, null);\n+    }\n+\n+    public V computeIfAbsent(K key, Function<K, V> provider) {\n+        checkNotNull(key);\n+        checkNotNull(provider);\n+        long h = hash(key);\n+        return getSection(h).put(key, null, (int) h, true, provider);\n+    }\n+\n+    public V remove(K key) {\n+        checkNotNull(key);\n+        long h = hash(key);\n+        return getSection(h).remove(key, null, (int) h);\n+    }\n+\n+    public boolean remove(K key, Object value) {\n+        checkNotNull(key);\n+        checkNotNull(value);\n+        long h = hash(key);\n+        return getSection(h).remove(key, value, (int) h) != null;\n+    }\n+\n+    private Section<K, V> getSection(long hash) {\n+        // Use 32 msb out of long to get the section\n+        final int sectionIdx = (int) (hash >>> 32) & (sections.length - 1);\n+        return sections[sectionIdx];\n+    }\n+\n+    public void clear() {\n+        for (Section<K, V> s : sections) {\n+            s.clear();\n+        }\n+    }\n+\n+    public void forEach(BiConsumer<? super K, ? super V> processor) {\n+        for (Section<K, V> s : sections) {\n+            s.forEach(processor);\n+        }\n+    }\n+\n+    public int removeIf(BiPredicate<K, V> filter) {\n+        checkNotNull(filter);\n+\n+        int removedCount = 0;\n+        for (Section<K,V> s : sections) {\n+            removedCount += s.removeIf(filter);\n+        }\n+\n+        return removedCount;\n+    }\n+\n+    /**\n+     * @return a new list of all keys (makes a copy)\n+     */\n+    public List<K> keys() {\n+        List<K> keys = Lists.newArrayList();\n+        forEach((key, value) -> keys.add(key));\n+        return keys;\n+    }\n+\n+    public List<V> values() {\n+        List<V> values = Lists.newArrayList();\n+        forEach((key, value) -> values.add(value));\n+        return values;\n+    }\n+\n+    // A section is a portion of the hash map that is covered by a single\n+    @SuppressWarnings(\"serial\")\n+    private static final class Section<K, V> extends StampedLock {\n+        // Keys and values are stored interleaved in the table array\n+        private Object[] table;\n+\n+        private int capacity;\n+        private volatile int size;\n+        private int usedBuckets;\n+        private int resizeThreshold;\n+\n+        Section(int capacity) {\n+            this.capacity = alignToPowerOfTwo(capacity);\n+            this.table = new Object[2 * this.capacity];\n+            this.size = 0;\n+            this.usedBuckets = 0;\n+            this.resizeThreshold = (int) (this.capacity * MapFillFactor);\n+        }\n+\n+        V get(K key, int keyHash) {\n+            long stamp = tryOptimisticRead();\n+            boolean acquiredLock = false;\n+            int bucket = signSafeMod(keyHash, capacity);\n+\n+            try {\n+                while (true) {\n+                    // First try optimistic locking\n+                    K storedKey = (K) table[bucket];\n+                    V storedValue = (V) table[bucket + 1];\n+\n+                    if (!acquiredLock && validate(stamp)) {\n+                        // The values we have read are consistent\n+                        if (key.equals(storedKey)) {\n+                            return storedValue;\n+                        } else if (storedKey == EmptyKey) {\n+                            // Not found\n+                            return null;\n+                        }\n+                    } else {\n+                        // Fallback to acquiring read lock\n+                        if (!acquiredLock) {\n+                            stamp = readLock();\n+                            acquiredLock = true;\n+\n+                            bucket = signSafeMod(keyHash, capacity);\n+                            storedKey = (K) table[bucket];\n+                            storedValue = (V) table[bucket + 1];\n+                        }\n+\n+                        if (key.equals(storedKey)) {\n+                            return storedValue;\n+                        } else if (storedKey == EmptyKey) {\n+                            // Not found\n+                            return null;\n+                        }\n+                    }\n+\n+                    bucket = (bucket + 2) & (table.length - 1);\n+                }\n+            } finally {\n+                if (acquiredLock) {\n+                    unlockRead(stamp);\n+                }\n+            }\n+        }\n+\n+        V put(K key, V value, int keyHash, boolean onlyIfAbsent, Function<K, V> valueProvider) {\n+            long stamp = writeLock();\n+            int bucket = signSafeMod(keyHash, capacity);\n+\n+            // Remember where we find the first available spot\n+            int firstDeletedKey = -1;\n+\n+            try {\n+                while (true) {\n+                    K storedKey = (K) table[bucket];\n+                    V storedValue = (V) table[bucket + 1];\n+\n+                    if (key.equals(storedKey)) {\n+                        if (!onlyIfAbsent) {\n+                            // Over written an old value for same key\n+                            table[bucket + 1] = value;\n+                            return storedValue;\n+                        } else {\n+                            return storedValue;\n+                        }\n+                    } else if (storedKey == EmptyKey) {\n+                        // Found an empty bucket. This means the key is not in the map. If we've already seen a deleted\n+                        // key, we should write at that position\n+                        if (firstDeletedKey != -1) {\n+                            bucket = firstDeletedKey;\n+                        } else {\n+                            ++usedBuckets;\n+                        }\n+\n+                        if (value == null) {\n+                            value = valueProvider.apply(key);\n+                        }\n+\n+                        table[bucket] = key;\n+                        table[bucket + 1] = value;\n+                        ++size;\n+                        return valueProvider != null ? value : null;\n+                    } else if (storedKey == DeletedKey) {\n+                        // The bucket contained a different deleted key\n+                        if (firstDeletedKey == -1) {\n+                            firstDeletedKey = bucket;\n+                        }\n+                    }\n+\n+                    bucket = (bucket + 2) & (table.length - 1);\n+                }\n+            } finally {\n+                if (usedBuckets > resizeThreshold) {\n+                    try {\n+                        rehash();\n+                    } finally {\n+                        unlockWrite(stamp);\n+                    }\n+                } else {\n+                    unlockWrite(stamp);\n+                }\n+            }\n+        }\n+\n+        private V remove(K key, Object value, int keyHash) {\n+            long stamp = writeLock();\n+            int bucket = signSafeMod(keyHash, capacity);\n+\n+            try {\n+                while (true) {\n+                    K storedKey = (K) table[bucket];\n+                    V storedValue = (V) table[bucket + 1];\n+                    if (key.equals(storedKey)) {\n+                        if (value == null || value.equals(storedValue)) {\n+                            --size;\n+                            cleanBucket(bucket);\n+                            return storedValue;\n+                        } else {\n+                            return null;\n+                        }\n+                    } else if (storedKey == EmptyKey) {\n+                        // Key wasn't found\n+                        return null;\n+                    }\n+\n+                    bucket = (bucket + 2) & (table.length - 1);\n+                }\n+\n+            } finally {\n+                unlockWrite(stamp);\n+            }\n+        }\n+\n+        void clear() {\n+            long stamp = writeLock();\n+\n+            try {\n+                Arrays.fill(table, EmptyKey);\n+                this.size = 0;\n+                this.usedBuckets = 0;\n+            } finally {\n+                unlockWrite(stamp);\n+            }\n+        }\n+\n+        public void forEach(BiConsumer<? super K, ? super V> processor) {\n+            long stamp = tryOptimisticRead();\n+\n+            Object[] table = this.table;\n+            boolean acquiredReadLock = false;\n+\n+            try {\n+\n+                // Validate no rehashing\n+                if (!validate(stamp)) {\n+                    // Fallback to read lock\n+                    stamp = readLock();\n+                    acquiredReadLock = true;\n+                    table = this.table;\n+                }\n+\n+                // Go through all the buckets for this section\n+                for (int bucket = 0; bucket < table.length; bucket += 2) {\n+                    K storedKey = (K) table[bucket];\n+                    V storedValue = (V) table[bucket + 1];\n+\n+                    if (!acquiredReadLock && !validate(stamp)) {\n+                        // Fallback to acquiring read lock\n+                        stamp = readLock();\n+                        acquiredReadLock = true;\n+\n+                        storedKey = (K) table[bucket];\n+                        storedValue = (V) table[bucket + 1];\n+                    }\n+\n+                    if (storedKey != DeletedKey && storedKey != EmptyKey) {\n+                        processor.accept(storedKey, storedValue);\n+                    }\n+                }\n+            } finally {\n+                if (acquiredReadLock) {\n+                    unlockRead(stamp);\n+                }\n+            }\n+        }\n+\n+        int removeIf(BiPredicate<K, V> filter) {\n+            long stamp = writeLock();\n+\n+            int removedCount = 0;\n+            try {\n+                // Go through all the buckets for this section\n+                for (int bucket = 0; bucket < table.length; bucket += 2) {\n+                    K storedKey = (K) table[bucket];\n+                    V storedValue = (V) table[bucket + 1];\n+\n+                    if (storedKey != DeletedKey && storedKey != EmptyKey) {\n+                        if (filter.test(storedKey, storedValue)) {\n+                            // Removing item\n+                            --size;\n+                            ++removedCount;\n+                            cleanBucket(bucket);\n+                        }\n+                    }\n+                }\n+\n+                return removedCount;\n+            } finally {\n+                unlockWrite(stamp);\n+            }\n+        }\n+\n+        private final void cleanBucket(int bucket) {\n+            int nextInArray = (bucket + 2) & (table.length - 1);\n+            if (table[nextInArray] == EmptyKey) {\n+                table[bucket] = EmptyKey;\n+                table[bucket + 1] = null;\n+                --usedBuckets;\n+            } else {\n+                table[bucket] = DeletedKey;\n+                table[bucket + 1] = null;\n+            }\n+        }\n+\n+        private void rehash() {\n+            // Expand the hashmap\n+            int newCapacity = capacity * 2;\n+            Object[] newTable = new Object[2 * newCapacity];\n+\n+            // Re-hash table\n+            for (int i = 0; i < table.length; i += 2) {\n+                K storedKey = (K) table[i];\n+                V storedValue = (V) table[i + 1];\n+                if (storedKey != EmptyKey && storedKey != DeletedKey) {\n+                    insertKeyValueNoLock(newTable, newCapacity, storedKey, storedValue);\n+                }\n+            }\n+\n+            capacity = newCapacity;\n+            table = newTable;\n+            usedBuckets = size;\n+            resizeThreshold = (int) (capacity * MapFillFactor);\n+        }\n+\n+        private static <K, V> void insertKeyValueNoLock(Object[] table, int capacity, K key, V value) {\n+            int bucket = signSafeMod(hash(key), capacity);\n+\n+            while (true) {\n+                K storedKey = (K) table[bucket];\n+\n+                if (storedKey == EmptyKey) {\n+                    // The bucket is empty, so we can use it\n+                    table[bucket] = key;\n+                    table[bucket + 1] = value;\n+                    return;\n+                }\n+\n+                bucket = (bucket + 2) & (table.length - 1);\n+            }\n+        }\n+    }\n+\n+    private static final long HashMixer = 0xc6a4a7935bd1e995l;\n+    private static final int R = 47;\n+\n+    final static <K> long hash(K key) {\n+        long hash = key.hashCode() * HashMixer;\n+        hash ^= hash >>> R;\n+        hash *= HashMixer;\n+        return hash;\n+    }\n+\n+    static final int signSafeMod(long n, int Max) {\n+        return (int) (n & (Max - 1)) << 1;\n+    }\n+\n+    private static final int alignToPowerOfTwo(int n) {\n+        return (int) Math.pow(2, 32 - Integer.numberOfLeadingZeros(n - 1));\n+    }\n+}"},{"sha":"99a552d8d5194cab20151da64c279483d27c6a18","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/util/collections/ConcurrentOpenHashSet.java","status":"added","additions":416,"deletions":0,"changes":416,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/ecbb053e6e873859507e247cae727f4bc8b9f7fa/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2Fcollections%2FConcurrentOpenHashSet.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/ecbb053e6e873859507e247cae727f4bc8b9f7fa/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2Fcollections%2FConcurrentOpenHashSet.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2Fcollections%2FConcurrentOpenHashSet.java?ref=ecbb053e6e873859507e247cae727f4bc8b9f7fa","patch":"@@ -0,0 +1,416 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.util.collections;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.locks.StampedLock;\n+import java.util.function.Consumer;\n+\n+import com.google.common.collect.Lists;\n+\n+/**\n+ * Concurrent hash set\n+ * \n+ * Provides similar methods as a ConcurrentMap<K,V> but since it's an open hash map with linear probing, no node\n+ * allocations are required to store the values\n+ *\n+ * @param <V>\n+ */\n+@SuppressWarnings(\"unchecked\")\n+public class ConcurrentOpenHashSet<V> {\n+\n+    private static final Object EmptyValue = null;\n+    private static final Object DeletedValue = new Object();\n+\n+    private static final float MapFillFactor = 0.66f;\n+\n+    private static final int DefaultExpectedItems = 256;\n+    private static final int DefaultConcurrencyLevel = 16;\n+\n+    private final Section<V>[] sections;\n+\n+    public ConcurrentOpenHashSet() {\n+        this(DefaultExpectedItems);\n+    }\n+\n+    public ConcurrentOpenHashSet(int expectedItems) {\n+        this(expectedItems, DefaultConcurrencyLevel);\n+    }\n+\n+    public ConcurrentOpenHashSet(int expectedItems, int concurrencyLevel) {\n+        checkArgument(expectedItems > 0);\n+        checkArgument(concurrencyLevel > 0);\n+        checkArgument(expectedItems >= concurrencyLevel);\n+\n+        int numSections = concurrencyLevel;\n+        int perSectionExpectedItems = expectedItems / numSections;\n+        int perSectionCapacity = (int) (perSectionExpectedItems / MapFillFactor);\n+        this.sections = (Section<V>[]) new Section[numSections];\n+\n+        for (int i = 0; i < numSections; i++) {\n+            sections[i] = new Section<>(perSectionCapacity);\n+        }\n+    }\n+\n+    public long size() {\n+        long size = 0;\n+        for (Section<V> s : sections) {\n+            size += s.size;\n+        }\n+        return size;\n+    }\n+\n+    public long capacity() {\n+        long capacity = 0;\n+        for (Section<V> s : sections) {\n+            capacity += s.capacity;\n+        }\n+        return capacity;\n+    }\n+\n+    public boolean isEmpty() {\n+        for (Section<V> s : sections) {\n+            if (s.size != 0) {\n+                return false;\n+            }\n+        }\n+\n+        return true;\n+    }\n+\n+    public boolean contains(V value) {\n+        checkNotNull(value);\n+        long h = hash(value);\n+        return getSection(h).contains(value, (int) h);\n+    }\n+\n+    public boolean add(V value) {\n+        checkNotNull(value);\n+        long h = hash(value);\n+        return getSection(h).add(value, (int) h);\n+    }\n+\n+    public boolean remove(V value) {\n+        checkNotNull(value);\n+        long h = hash(value);\n+        return getSection(h).remove(value, (int) h);\n+    }\n+\n+    private Section<V> getSection(long hash) {\n+        // Use 32 msb out of long to get the section\n+        final int sectionIdx = (int) (hash >>> 32) & (sections.length - 1);\n+        return sections[sectionIdx];\n+    }\n+\n+    public void clear() {\n+        for (Section<V> s : sections) {\n+            s.clear();\n+        }\n+    }\n+\n+    public void forEach(Consumer<? super V> processor) {\n+        for (Section<V> s : sections) {\n+            s.forEach(processor);\n+        }\n+    }\n+\n+    /**\n+     * @return a new list of all values (makes a copy)\n+     */\n+    List<V> values() {\n+        List<V> values = Lists.newArrayList();\n+        forEach(value -> values.add(value));\n+        return values;\n+    }\n+\n+    // A section is a portion of the hash map that is covered by a single\n+    @SuppressWarnings(\"serial\")\n+    private static final class Section<V> extends StampedLock {\n+        private V[] values;\n+\n+        private int capacity;\n+        private volatile int size;\n+        private int usedBuckets;\n+        private int resizeThreshold;\n+\n+        Section(int capacity) {\n+            this.capacity = alignToPowerOfTwo(capacity);\n+            this.values = (V[]) new Object[this.capacity];\n+            this.size = 0;\n+            this.usedBuckets = 0;\n+            this.resizeThreshold = (int) (this.capacity * MapFillFactor);\n+        }\n+\n+        boolean contains(V value, int keyHash) {\n+            int bucket = keyHash;\n+\n+            long stamp = tryOptimisticRead();\n+            boolean acquiredLock = false;\n+\n+            try {\n+                while (true) {\n+                    int capacity = this.capacity;\n+                    bucket = signSafeMod(bucket, capacity);\n+\n+                    // First try optimistic locking\n+                    V storedValue = values[bucket];\n+\n+                    if (!acquiredLock && validate(stamp)) {\n+                        // The values we have read are consistent\n+                        if (value.equals(storedValue)) {\n+                            return true;\n+                        } else if (storedValue == EmptyValue) {\n+                            // Not found\n+                            return false;\n+                        }\n+                    } else {\n+                        // Fallback to acquiring read lock\n+                        if (!acquiredLock) {\n+                            stamp = readLock();\n+                            acquiredLock = true;\n+\n+                            storedValue = values[bucket];\n+                        }\n+\n+                        if (capacity != this.capacity) {\n+                            // There has been a rehashing. We need to restart the search\n+                            bucket = keyHash;\n+                            continue;\n+                        }\n+\n+                        if (value.equals(storedValue)) {\n+                            return true;\n+                        } else if (storedValue == EmptyValue) {\n+                            // Not found\n+                            return false;\n+                        }\n+                    }\n+\n+                    ++bucket;\n+                }\n+            } finally {\n+                if (acquiredLock) {\n+                    unlockRead(stamp);\n+                }\n+            }\n+        }\n+\n+        boolean add(V value, int keyHash) {\n+            int bucket = keyHash;\n+\n+            long stamp = writeLock();\n+            int capacity = this.capacity;\n+\n+            // Remember where we find the first available spot\n+            int firstDeletedValue = -1;\n+\n+            try {\n+                while (true) {\n+                    bucket = signSafeMod(bucket, capacity);\n+\n+                    V storedValue = values[bucket];\n+\n+                    if (value.equals(storedValue)) {\n+                        return false;\n+                    } else if (storedValue == EmptyValue) {\n+                        // Found an empty bucket. This means the value is not in the set. If we've already seen a\n+                        // deleted value, we should write at that position\n+                        if (firstDeletedValue != -1) {\n+                            bucket = firstDeletedValue;\n+                        } else {\n+                            ++usedBuckets;\n+                        }\n+\n+                        values[bucket] = value;\n+                        ++size;\n+                        return true;\n+                    } else if (storedValue == DeletedValue) {\n+                        // The bucket contained a different deleted key\n+                        if (firstDeletedValue == -1) {\n+                            firstDeletedValue = bucket;\n+                        }\n+                    }\n+\n+                    ++bucket;\n+                }\n+            } finally {\n+                if (usedBuckets > resizeThreshold) {\n+                    try {\n+                        rehash();\n+                    } finally {\n+                        unlockWrite(stamp);\n+                    }\n+                } else {\n+                    unlockWrite(stamp);\n+                }\n+            }\n+        }\n+\n+        private boolean remove(V value, int keyHash) {\n+            int bucket = keyHash;\n+            long stamp = writeLock();\n+\n+            try {\n+                while (true) {\n+                    int capacity = this.capacity;\n+                    bucket = signSafeMod(bucket, capacity);\n+\n+                    V storedValue = values[bucket];\n+                    if (value.equals(storedValue)) {\n+                        --size;\n+\n+                        int nextInArray = signSafeMod(bucket + 1, capacity);\n+                        if (values[nextInArray] == EmptyValue) {\n+                            values[bucket] = (V) EmptyValue;\n+                            --usedBuckets;\n+                        } else {\n+                            values[bucket] = (V) DeletedValue;\n+                        }\n+\n+                        return true;\n+                    } else if (storedValue == EmptyValue) {\n+                        // Value wasn't found\n+                        return false;\n+                    }\n+\n+                    ++bucket;\n+                }\n+\n+            } finally {\n+                unlockWrite(stamp);\n+            }\n+        }\n+\n+        void clear() {\n+            long stamp = writeLock();\n+\n+            try {\n+                Arrays.fill(values, EmptyValue);\n+                this.size = 0;\n+                this.usedBuckets = 0;\n+            } finally {\n+                unlockWrite(stamp);\n+            }\n+        }\n+\n+        public void forEach(Consumer<? super V> processor) {\n+            long stamp = tryOptimisticRead();\n+\n+            int capacity = this.capacity;\n+            V[] values = this.values;\n+\n+            boolean acquiredReadLock = false;\n+\n+            try {\n+\n+                // Validate no rehashing\n+                if (!validate(stamp)) {\n+                    // Fallback to read lock\n+                    stamp = readLock();\n+                    acquiredReadLock = true;\n+\n+                    capacity = this.capacity;\n+                    values = this.values;\n+                }\n+\n+                // Go through all the buckets for this section\n+                for (int bucket = 0; bucket < capacity; bucket++) {\n+                    V storedValue = values[bucket];\n+\n+                    if (!acquiredReadLock && !validate(stamp)) {\n+                        // Fallback to acquiring read lock\n+                        stamp = readLock();\n+                        acquiredReadLock = true;\n+\n+                        storedValue = values[bucket];\n+                    }\n+\n+                    if (storedValue != DeletedValue && storedValue != EmptyValue) {\n+                        processor.accept(storedValue);\n+                    }\n+                }\n+            } finally {\n+                if (acquiredReadLock) {\n+                    unlockRead(stamp);\n+                }\n+            }\n+        }\n+\n+        private void rehash() {\n+            // Expand the hashmap\n+            int newCapacity = capacity * 2;\n+            V[] newValues = (V[]) new Object[newCapacity];\n+\n+            // Re-hash table\n+            for (int i = 0; i < values.length; i++) {\n+                V storedValue = values[i];\n+                if (storedValue != EmptyValue && storedValue != DeletedValue) {\n+                    insertValueNoLock(newValues, storedValue);\n+                }\n+            }\n+\n+            capacity = newCapacity;\n+            values = newValues;\n+            usedBuckets = size;\n+            resizeThreshold = (int) (capacity * MapFillFactor);\n+        }\n+\n+        private static <V> void insertValueNoLock(V[] values, V value) {\n+            int bucket = (int) hash(value);\n+\n+            while (true) {\n+                bucket = signSafeMod(bucket, values.length);\n+\n+                V storedValue = values[bucket];\n+\n+                if (storedValue == EmptyValue) {\n+                    // The bucket is empty, so we can use it\n+                    values[bucket] = value;\n+                    return;\n+                }\n+\n+                ++bucket;\n+            }\n+        }\n+    }\n+\n+    private static final long HashMixer = 0xc6a4a7935bd1e995l;\n+    private static final int R = 47;\n+\n+    final static <K> long hash(K key) {\n+        long hash = key.hashCode() * HashMixer;\n+        hash ^= hash >>> R;\n+        hash *= HashMixer;\n+        return hash;\n+    }\n+\n+    static final int signSafeMod(long n, int Max) {\n+        return (int) n & (Max - 1);\n+    }\n+\n+    private static final int alignToPowerOfTwo(int n) {\n+        return (int) Math.pow(2, 32 - Integer.numberOfLeadingZeros(n - 1));\n+    }\n+}"},{"sha":"44f42b830928804057bf2a70876cceb9332088ee","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/util/collections/ConcurrentLongHashMapTest.java","status":"added","additions":435,"deletions":0,"changes":435,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/ecbb053e6e873859507e247cae727f4bc8b9f7fa/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2Fcollections%2FConcurrentLongHashMapTest.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/ecbb053e6e873859507e247cae727f4bc8b9f7fa/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2Fcollections%2FConcurrentLongHashMapTest.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2Fcollections%2FConcurrentLongHashMapTest.java?ref=ecbb053e6e873859507e247cae727f4bc8b9f7fa","patch":"@@ -0,0 +1,435 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.util.collections;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.LongFunction;\n+\n+import org.junit.Test;\n+\n+import com.google.common.collect.Lists;\n+\n+public class ConcurrentLongHashMapTest {\n+\n+    @Test\n+    public void testConstructor() {\n+        try {\n+            new ConcurrentLongHashMap<String>(0);\n+            fail(\"should have thrown exception\");\n+        } catch (IllegalArgumentException e) {\n+            // ok\n+        }\n+\n+        try {\n+            new ConcurrentLongHashMap<String>(16, 0);\n+            fail(\"should have thrown exception\");\n+        } catch (IllegalArgumentException e) {\n+            // ok\n+        }\n+\n+        try {\n+            new ConcurrentLongHashMap<String>(4, 8);\n+            fail(\"should have thrown exception\");\n+        } catch (IllegalArgumentException e) {\n+            // ok\n+        }\n+    }\n+\n+    @Test\n+    public void simpleInsertions() {\n+        ConcurrentLongHashMap<String> map = new ConcurrentLongHashMap<>(16);\n+\n+        assertTrue(map.isEmpty());\n+        assertNull(map.put(1, \"one\"));\n+        assertFalse(map.isEmpty());\n+\n+        assertNull(map.put(2, \"two\"));\n+        assertNull(map.put(3, \"three\"));\n+\n+        assertEquals(map.size(), 3);\n+\n+        assertEquals(map.get(1), \"one\");\n+        assertEquals(map.size(), 3);\n+\n+        assertEquals(map.remove(1), \"one\");\n+        assertEquals(map.size(), 2);\n+        assertEquals(map.get(1), null);\n+        assertEquals(map.get(5), null);\n+        assertEquals(map.size(), 2);\n+\n+        assertNull(map.put(1, \"one\"));\n+        assertEquals(map.size(), 3);\n+        assertEquals(map.put(1, \"uno\"), \"one\");\n+        assertEquals(map.size(), 3);\n+    }\n+\n+    @Test\n+    public void testRemove() {\n+        ConcurrentLongHashMap<String> map = new ConcurrentLongHashMap<>();\n+\n+        assertTrue(map.isEmpty());\n+        assertNull(map.put(1, \"one\"));\n+        assertFalse(map.isEmpty());\n+\n+        assertFalse(map.remove(0, \"zero\"));\n+        assertFalse(map.remove(1, \"uno\"));\n+\n+        assertFalse(map.isEmpty());\n+        assertTrue(map.remove(1, \"one\"));\n+        assertTrue(map.isEmpty());\n+    }\n+\n+    @Test\n+    public void testNegativeUsedBucketCount() {\n+        ConcurrentLongHashMap<String> map = new ConcurrentLongHashMap<>(16, 1);\n+\n+        map.put(0, \"zero\");\n+        assertEquals(1, map.getUsedBucketCount());\n+        map.put(0, \"zero1\");\n+        assertEquals(1, map.getUsedBucketCount());\n+        map.remove(0);\n+        assertEquals(0, map.getUsedBucketCount());\n+        map.remove(0);\n+        assertEquals(0, map.getUsedBucketCount());\n+    }\n+\n+    @Test\n+    public void testRehashing() {\n+        int n = 16;\n+        ConcurrentLongHashMap<Integer> map = new ConcurrentLongHashMap<>(n / 2, 1);\n+        assertEquals(map.capacity(), n);\n+        assertEquals(map.size(), 0);\n+\n+        for (int i = 0; i < n; i++) {\n+            map.put(i, i);\n+        }\n+\n+        assertEquals(map.capacity(), 2 * n);\n+        assertEquals(map.size(), n);\n+    }\n+\n+    @Test\n+    public void testRehashingWithDeletes() {\n+        int n = 16;\n+        ConcurrentLongHashMap<Integer> map = new ConcurrentLongHashMap<>(n / 2, 1);\n+        assertEquals(map.capacity(), n);\n+        assertEquals(map.size(), 0);\n+\n+        for (int i = 0; i < n / 2; i++) {\n+            map.put(i, i);\n+        }\n+\n+        for (int i = 0; i < n / 2; i++) {\n+            map.remove(i);\n+        }\n+\n+        for (int i = n; i < (2 * n); i++) {\n+            map.put(i, i);\n+        }\n+\n+        assertEquals(map.capacity(), 2 * n);\n+        assertEquals(map.size(), n);\n+    }\n+\n+    @Test\n+    public void concurrentInsertions() throws Throwable {\n+        ConcurrentLongHashMap<String> map = new ConcurrentLongHashMap<>();\n+        ExecutorService executor = Executors.newCachedThreadPool();\n+\n+        final int nThreads = 16;\n+        final int N = 100_000;\n+        String value = \"value\";\n+\n+        List<Future<?>> futures = new ArrayList<>();\n+        for (int i = 0; i < nThreads; i++) {\n+            final int threadIdx = i;\n+\n+            futures.add(executor.submit(() -> {\n+                Random random = new Random();\n+\n+                for (int j = 0; j < N; j++) {\n+                    long key = random.nextLong();\n+                    // Ensure keys are uniques\n+                    key -= key % (threadIdx + 1);\n+\n+                    map.put(key, value);\n+                }\n+            }));\n+        }\n+\n+        for (Future<?> future : futures) {\n+            future.get();\n+        }\n+\n+        assertEquals(map.size(), N * nThreads);\n+\n+        executor.shutdown();\n+    }\n+\n+    @Test\n+    public void concurrentInsertionsAndReads() throws Throwable {\n+        ConcurrentLongHashMap<String> map = new ConcurrentLongHashMap<>();\n+        ExecutorService executor = Executors.newCachedThreadPool();\n+\n+        final int nThreads = 16;\n+        final int N = 100_000;\n+        String value = \"value\";\n+\n+        List<Future<?>> futures = new ArrayList<>();\n+        for (int i = 0; i < nThreads; i++) {\n+            final int threadIdx = i;\n+\n+            futures.add(executor.submit(() -> {\n+                Random random = new Random();\n+\n+                for (int j = 0; j < N; j++) {\n+                    long key = random.nextLong();\n+                    // Ensure keys are uniques\n+                    key -= key % (threadIdx + 1);\n+\n+                    map.put(key, value);\n+                }\n+            }));\n+        }\n+\n+        for (Future<?> future : futures) {\n+            future.get();\n+        }\n+\n+        assertEquals(map.size(), N * nThreads);\n+\n+        executor.shutdown();\n+    }\n+\n+    @Test\n+    public void testIteration() {\n+        ConcurrentLongHashMap<String> map = new ConcurrentLongHashMap<>();\n+\n+        assertEquals(map.keys(), Collections.emptyList());\n+        assertEquals(map.values(), Collections.emptyList());\n+\n+        map.put(0, \"zero\");\n+\n+        assertEquals(map.keys(), Lists.newArrayList(0l));\n+        assertEquals(map.values(), Lists.newArrayList(\"zero\"));\n+\n+        map.remove(0);\n+\n+        assertEquals(map.keys(), Collections.emptyList());\n+        assertEquals(map.values(), Collections.emptyList());\n+\n+        map.put(0, \"zero\");\n+        map.put(1, \"one\");\n+        map.put(2, \"two\");\n+\n+        List<Long> keys = map.keys();\n+        Collections.sort(keys);\n+        assertEquals(keys, Lists.newArrayList(0l, 1l, 2l));\n+\n+        List<String> values = map.values();\n+        Collections.sort(values);\n+        assertEquals(values, Lists.newArrayList(\"one\", \"two\", \"zero\"));\n+\n+        map.put(1, \"uno\");\n+\n+        keys = map.keys();\n+        Collections.sort(keys);\n+        assertEquals(keys, Lists.newArrayList(0l, 1l, 2l));\n+\n+        values = map.values();\n+        Collections.sort(values);\n+        assertEquals(values, Lists.newArrayList(\"two\", \"uno\", \"zero\"));\n+\n+        map.clear();\n+        assertTrue(map.isEmpty());\n+    }\n+\n+    @Test\n+    public void testHashConflictWithDeletion() {\n+        final int Buckets = 16;\n+        ConcurrentLongHashMap<String> map = new ConcurrentLongHashMap<>(Buckets, 1);\n+\n+        // Pick 2 keys that fall into the same bucket\n+        long key1 = 1;\n+        long key2 = 27;\n+\n+        int bucket1 = ConcurrentLongHashMap.signSafeMod(ConcurrentLongHashMap.hash(key1), Buckets);\n+        int bucket2 = ConcurrentLongHashMap.signSafeMod(ConcurrentLongHashMap.hash(key2), Buckets);\n+        assertEquals(bucket1, bucket2);\n+\n+        assertEquals(map.put(key1, \"value-1\"), null);\n+        assertEquals(map.put(key2, \"value-2\"), null);\n+        assertEquals(map.size(), 2);\n+\n+        assertEquals(map.remove(key1), \"value-1\");\n+        assertEquals(map.size(), 1);\n+\n+        assertEquals(map.put(key1, \"value-1-overwrite\"), null);\n+        assertEquals(map.size(), 2);\n+\n+        assertEquals(map.remove(key1), \"value-1-overwrite\");\n+        assertEquals(map.size(), 1);\n+\n+        assertEquals(map.put(key2, \"value-2-overwrite\"), \"value-2\");\n+        assertEquals(map.get(key2), \"value-2-overwrite\");\n+\n+        assertEquals(map.size(), 1);\n+        assertEquals(map.remove(key2), \"value-2-overwrite\");\n+        assertTrue(map.isEmpty());\n+    }\n+\n+    @Test\n+    public void testPutIfAbsent() {\n+        ConcurrentLongHashMap<String> map = new ConcurrentLongHashMap<>();\n+        assertEquals(map.putIfAbsent(1, \"one\"), null);\n+        assertEquals(map.get(1), \"one\");\n+\n+        assertEquals(map.putIfAbsent(1, \"uno\"), \"one\");\n+        assertEquals(map.get(1), \"one\");\n+    }\n+\n+    @Test\n+    public void testComputeIfAbsent() {\n+        ConcurrentLongHashMap<Integer> map = new ConcurrentLongHashMap<>(16, 1);\n+        AtomicInteger counter = new AtomicInteger();\n+        LongFunction<Integer> provider = new LongFunction<Integer>() {\n+            public Integer apply(long key) {\n+                return counter.getAndIncrement();\n+            }\n+        };\n+\n+        assertEquals(map.computeIfAbsent(0, provider).intValue(), 0);\n+        assertEquals(map.get(0).intValue(), 0);\n+\n+        assertEquals(map.computeIfAbsent(1, provider).intValue(), 1);\n+        assertEquals(map.get(1).intValue(), 1);\n+\n+        assertEquals(map.computeIfAbsent(1, provider).intValue(), 1);\n+        assertEquals(map.get(1).intValue(), 1);\n+\n+        assertEquals(map.computeIfAbsent(2, provider).intValue(), 2);\n+        assertEquals(map.get(2).intValue(), 2);\n+    }\n+\n+    final static int Iterations = 1;\n+    final static int ReadIterations = 100;\n+    final static int N = 1_000_000;\n+\n+    public void benchConcurrentLongHashMap() throws Exception {\n+        // public static void main(String args[]) {\n+        ConcurrentLongHashMap<String> map = new ConcurrentLongHashMap<>(N, 1);\n+\n+        for (long i = 0; i < Iterations; i++) {\n+            for (int j = 0; j < N; j++) {\n+                map.put(i, \"value\");\n+            }\n+\n+            for (long h = 0; h < ReadIterations; h++) {\n+                for (int j = 0; j < N; j++) {\n+                    map.get(i);\n+                }\n+            }\n+\n+            for (int j = 0; j < N; j++) {\n+                map.remove(i);\n+            }\n+        }\n+    }\n+\n+    public void benchConcurrentHashMap() throws Exception {\n+        ConcurrentHashMap<Long, String> map = new ConcurrentHashMap<Long, String>(N, 0.66f, 1);\n+\n+        for (long i = 0; i < Iterations; i++) {\n+            for (int j = 0; j < N; j++) {\n+                map.put(i, \"value\");\n+            }\n+\n+            for (long h = 0; h < ReadIterations; h++) {\n+                for (int j = 0; j < N; j++) {\n+                    map.get(i);\n+                }\n+            }\n+\n+            for (int j = 0; j < N; j++) {\n+                map.remove(i);\n+            }\n+        }\n+    }\n+\n+    void benchHashMap() throws Exception {\n+        HashMap<Long, String> map = new HashMap<Long, String>(N, 0.66f);\n+\n+        for (long i = 0; i < Iterations; i++) {\n+            for (int j = 0; j < N; j++) {\n+                map.put(i, \"value\");\n+            }\n+\n+            for (long h = 0; h < ReadIterations; h++) {\n+                for (int j = 0; j < N; j++) {\n+                    map.get(i);\n+                }\n+            }\n+\n+            for (int j = 0; j < N; j++) {\n+                map.remove(i);\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        ConcurrentLongHashMapTest t = new ConcurrentLongHashMapTest();\n+\n+        long start = System.nanoTime();\n+        // t.benchHashMap();\n+        long end = System.nanoTime();\n+\n+        System.out.println(\"HM:   \" + TimeUnit.NANOSECONDS.toMillis(end - start) + \" ms\");\n+\n+        start = System.nanoTime();\n+        t.benchConcurrentHashMap();\n+        end = System.nanoTime();\n+\n+        System.out.println(\"CHM:  \" + TimeUnit.NANOSECONDS.toMillis(end - start) + \" ms\");\n+\n+        start = System.nanoTime();\n+        // t.benchConcurrentLongHashMap();\n+        end = System.nanoTime();\n+\n+        System.out.println(\"CLHM: \" + TimeUnit.NANOSECONDS.toMillis(end - start) + \" ms\");\n+\n+    }\n+}"},{"sha":"5a8d9043d9a28c499f25b60b517cadefc54f200b","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/util/collections/ConcurrentLongHashSetTest.java","status":"added","additions":275,"deletions":0,"changes":275,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/ecbb053e6e873859507e247cae727f4bc8b9f7fa/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2Fcollections%2FConcurrentLongHashSetTest.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/ecbb053e6e873859507e247cae727f4bc8b9f7fa/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2Fcollections%2FConcurrentLongHashSetTest.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2Fcollections%2FConcurrentLongHashSetTest.java?ref=ecbb053e6e873859507e247cae727f4bc8b9f7fa","patch":"@@ -0,0 +1,275 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.util.collections;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+\n+import org.junit.Test;\n+\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Sets;\n+\n+public class ConcurrentLongHashSetTest {\n+\n+    @Test\n+    public void testConstructor() {\n+        try {\n+            new ConcurrentLongHashSet(0);\n+            fail(\"should have thrown exception\");\n+        } catch (IllegalArgumentException e) {\n+            // ok\n+        }\n+\n+        try {\n+            new ConcurrentLongHashSet(16, 0);\n+            fail(\"should have thrown exception\");\n+        } catch (IllegalArgumentException e) {\n+            // ok\n+        }\n+\n+        try {\n+            new ConcurrentLongHashSet(4, 8);\n+            fail(\"should have thrown exception\");\n+        } catch (IllegalArgumentException e) {\n+            // ok\n+        }\n+    }\n+\n+    @Test\n+    public void simpleInsertions() {\n+        ConcurrentLongHashSet set = new ConcurrentLongHashSet(16);\n+\n+        assertTrue(set.isEmpty());\n+        assertTrue(set.add(1));\n+        assertFalse(set.isEmpty());\n+\n+        assertTrue(set.add(2));\n+        assertTrue(set.add(3));\n+\n+        assertEquals(set.size(), 3);\n+\n+        assertTrue(set.contains(1));\n+        assertEquals(set.size(), 3);\n+\n+        assertTrue(set.remove(1));\n+        assertEquals(set.size(), 2);\n+        assertFalse(set.contains(1));\n+        assertFalse(set.contains(5));\n+        assertEquals(set.size(), 2);\n+\n+        assertTrue(set.add(1));\n+        assertEquals(set.size(), 3);\n+        assertFalse(set.add(1));\n+        assertEquals(set.size(), 3);\n+    }\n+\n+    @Test\n+    public void testRemove() {\n+        ConcurrentLongHashSet set = new ConcurrentLongHashSet();\n+\n+        assertTrue(set.isEmpty());\n+        assertTrue(set.add(1));\n+        assertFalse(set.isEmpty());\n+\n+        assertFalse(set.remove(0));\n+        assertFalse(set.isEmpty());\n+        assertTrue(set.remove(1));\n+        assertTrue(set.isEmpty());\n+    }\n+\n+    @Test\n+    public void testRehashing() {\n+        int n = 16;\n+        ConcurrentLongHashSet set = new ConcurrentLongHashSet(n / 2, 1);\n+        assertEquals(set.capacity(), n);\n+        assertEquals(set.size(), 0);\n+\n+        for (int i = 0; i < n; i++) {\n+            set.add(i);\n+        }\n+\n+        assertEquals(set.capacity(), 2 * n);\n+        assertEquals(set.size(), n);\n+    }\n+\n+    @Test\n+    public void testRehashingWithDeletes() {\n+        int n = 16;\n+        ConcurrentLongHashSet set = new ConcurrentLongHashSet(n / 2, 1);\n+        assertEquals(set.capacity(), n);\n+        assertEquals(set.size(), 0);\n+\n+        for (int i = 0; i < n / 2; i++) {\n+            set.add(i);\n+        }\n+\n+        for (int i = 0; i < n / 2; i++) {\n+            set.remove(i);\n+        }\n+\n+        for (int i = n; i < (2 * n); i++) {\n+            set.add(i);\n+        }\n+\n+        assertEquals(set.capacity(), 2 * n);\n+        assertEquals(set.size(), n);\n+    }\n+\n+    @Test\n+    public void concurrentInsertions() throws Throwable {\n+        ConcurrentLongHashSet set = new ConcurrentLongHashSet();\n+        ExecutorService executor = Executors.newCachedThreadPool();\n+\n+        final int nThreads = 16;\n+        final int N = 100_000;\n+\n+        List<Future<?>> futures = new ArrayList<>();\n+        for (int i = 0; i < nThreads; i++) {\n+            final int threadIdx = i;\n+\n+            futures.add(executor.submit(() -> {\n+                Random random = new Random();\n+\n+                for (int j = 0; j < N; j++) {\n+                    long key = Math.abs(random.nextLong());\n+                    // Ensure keys are unique\n+                    key -= key % (threadIdx + 1);\n+\n+                    set.add(key);\n+                }\n+            }));\n+        }\n+\n+        for (Future<?> future : futures) {\n+            future.get();\n+        }\n+\n+        assertEquals(set.size(), N * nThreads);\n+\n+        executor.shutdown();\n+    }\n+\n+    @Test\n+    public void concurrentInsertionsAndReads() throws Throwable {\n+        ConcurrentLongHashSet map = new ConcurrentLongHashSet();\n+        ExecutorService executor = Executors.newCachedThreadPool();\n+\n+        final int nThreads = 16;\n+        final int N = 100_000;\n+\n+        List<Future<?>> futures = new ArrayList<>();\n+        for (int i = 0; i < nThreads; i++) {\n+            final int threadIdx = i;\n+\n+            futures.add(executor.submit(() -> {\n+                Random random = new Random();\n+\n+                for (int j = 0; j < N; j++) {\n+                    long key = Math.abs(random.nextLong());\n+                    // Ensure keys are unique\n+                    key -= key % (threadIdx + 1);\n+\n+                    map.add(key);\n+                }\n+            }));\n+        }\n+\n+        for (Future<?> future : futures) {\n+            future.get();\n+        }\n+\n+        assertEquals(map.size(), N * nThreads);\n+\n+        executor.shutdown();\n+    }\n+\n+    @Test\n+    public void testIteration() {\n+        ConcurrentLongHashSet set = new ConcurrentLongHashSet();\n+\n+        assertEquals(set.items(), Collections.emptySet());\n+\n+        set.add(0l);\n+\n+        assertEquals(set.items(), Sets.newHashSet(0l));\n+\n+        set.remove(0l);\n+\n+        assertEquals(set.items(), Collections.emptySet());\n+\n+        set.add(0l);\n+        set.add(1l);\n+        set.add(2l);\n+\n+        List<Long> values = Lists.newArrayList(set.items());\n+        Collections.sort(values);\n+        assertEquals(values, Lists.newArrayList(0l, 1l, 2l));\n+\n+        set.clear();\n+        assertTrue(set.isEmpty());\n+    }\n+\n+    @Test\n+    public void testHashConflictWithDeletion() {\n+        final int Buckets = 16;\n+        ConcurrentLongHashSet set = new ConcurrentLongHashSet(Buckets, 1);\n+\n+        // Pick 2 keys that fall into the same bucket\n+        long key1 = 1;\n+        long key2 = 27;\n+\n+        int bucket1 = ConcurrentOpenHashSet.signSafeMod(ConcurrentOpenHashSet.hash(key1), Buckets);\n+        int bucket2 = ConcurrentOpenHashSet.signSafeMod(ConcurrentOpenHashSet.hash(key2), Buckets);\n+        assertEquals(bucket1, bucket2);\n+\n+        assertTrue(set.add(key1));\n+        assertTrue(set.add(key2));\n+        assertEquals(set.size(), 2);\n+\n+        assertTrue(set.remove(key1));\n+        assertEquals(set.size(), 1);\n+\n+        assertTrue(set.add(key1));\n+        assertEquals(set.size(), 2);\n+\n+        assertTrue(set.remove(key1));\n+        assertEquals(set.size(), 1);\n+\n+        assertFalse(set.add(key2));\n+        assertTrue(set.contains(key2));\n+\n+        assertEquals(set.size(), 1);\n+        assertTrue(set.remove(key2));\n+        assertTrue(set.isEmpty());\n+    }\n+\n+}"},{"sha":"a7492a1e79d4965de2f74eae9fcc22f722c516f6","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/util/collections/ConcurrentLongLongHashMapTest.java","status":"added","additions":473,"deletions":0,"changes":473,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/ecbb053e6e873859507e247cae727f4bc8b9f7fa/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2Fcollections%2FConcurrentLongLongHashMapTest.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/ecbb053e6e873859507e247cae727f4bc8b9f7fa/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2Fcollections%2FConcurrentLongLongHashMapTest.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2Fcollections%2FConcurrentLongLongHashMapTest.java?ref=ecbb053e6e873859507e247cae727f4bc8b9f7fa","patch":"@@ -0,0 +1,473 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.util.collections;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import org.apache.bookkeeper.util.collections.ConcurrentLongLongHashMap.LongLongFunction;\n+import org.junit.Test;\n+\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+\n+public class ConcurrentLongLongHashMapTest {\n+\n+    @Test\n+    public void testConstructor() {\n+        try {\n+            new ConcurrentLongLongHashMap(0);\n+            fail(\"should have thrown exception\");\n+        } catch (IllegalArgumentException e) {\n+            // ok\n+        }\n+\n+        try {\n+            new ConcurrentLongLongHashMap(16, 0);\n+            fail(\"should have thrown exception\");\n+        } catch (IllegalArgumentException e) {\n+            // ok\n+        }\n+\n+        try {\n+            new ConcurrentLongLongHashMap(4, 8);\n+            fail(\"should have thrown exception\");\n+        } catch (IllegalArgumentException e) {\n+            // ok\n+        }\n+    }\n+\n+    @Test\n+    public void simpleInsertions() {\n+        ConcurrentLongLongHashMap map = new ConcurrentLongLongHashMap(16);\n+\n+        assertTrue(map.isEmpty());\n+        assertEquals(map.put(1, 11), -1);\n+        assertFalse(map.isEmpty());\n+\n+        assertEquals(map.put(2, 22), -1);\n+        assertEquals(map.put(3, 33), -1);\n+\n+        assertEquals(map.size(), 3);\n+\n+        assertEquals(map.get(1), 11);\n+        assertEquals(map.size(), 3);\n+\n+        assertEquals(map.remove(1), 11);\n+        assertEquals(map.size(), 2);\n+        assertEquals(map.get(1), -1);\n+        assertEquals(map.get(5), -1);\n+        assertEquals(map.size(), 2);\n+\n+        assertEquals(map.put(1, 11), -1);\n+        assertEquals(map.size(), 3);\n+        assertEquals(map.put(1, 111), 11);\n+        assertEquals(map.size(), 3);\n+    }\n+\n+    @Test\n+    public void testRemove() {\n+        ConcurrentLongLongHashMap map = new ConcurrentLongLongHashMap();\n+\n+        assertTrue(map.isEmpty());\n+        assertEquals(map.put(1, 11), -1);\n+        assertFalse(map.isEmpty());\n+\n+        assertFalse(map.remove(0, 0));\n+        assertFalse(map.remove(1, 111));\n+\n+        assertFalse(map.isEmpty());\n+        assertTrue(map.remove(1, 11));\n+        assertTrue(map.isEmpty());\n+    }\n+\n+    @Test\n+    public void testNegativeUsedBucketCount() {\n+        ConcurrentLongLongHashMap map = new ConcurrentLongLongHashMap(16, 1);\n+\n+        map.put(0, 0);\n+        assertEquals(1, map.getUsedBucketCount());\n+        map.put(0, 1);\n+        assertEquals(1, map.getUsedBucketCount());\n+        map.remove(0);\n+        assertEquals(0, map.getUsedBucketCount());\n+        map.remove(0);\n+        assertEquals(0, map.getUsedBucketCount());\n+    }\n+\n+    @Test\n+    public void testRehashing() {\n+        int n = 16;\n+        ConcurrentLongLongHashMap map = new ConcurrentLongLongHashMap(n / 2, 1);\n+        assertEquals(map.capacity(), n);\n+        assertEquals(map.size(), 0);\n+\n+        for (int i = 0; i < n; i++) {\n+            map.put(i, i);\n+        }\n+\n+        assertEquals(map.capacity(), 2 * n);\n+        assertEquals(map.size(), n);\n+    }\n+\n+    @Test\n+    public void testRehashingWithDeletes() {\n+        int n = 16;\n+        ConcurrentLongLongHashMap map = new ConcurrentLongLongHashMap(n / 2, 1);\n+        assertEquals(map.capacity(), n);\n+        assertEquals(map.size(), 0);\n+\n+        for (int i = 0; i < n / 2; i++) {\n+            map.put(i, i);\n+        }\n+\n+        for (int i = 0; i < n / 2; i++) {\n+            map.remove(i);\n+        }\n+\n+        for (int i = n; i < (2 * n); i++) {\n+            map.put(i, i);\n+        }\n+\n+        assertEquals(map.capacity(), 2 * n);\n+        assertEquals(map.size(), n);\n+    }\n+\n+    @Test\n+    public void concurrentInsertions() throws Throwable {\n+        ConcurrentLongLongHashMap map = new ConcurrentLongLongHashMap();\n+        ExecutorService executor = Executors.newCachedThreadPool();\n+\n+        final int nThreads = 16;\n+        final int N = 100_000;\n+        long value = 55;\n+\n+        List<Future<?>> futures = new ArrayList<>();\n+        for (int i = 0; i < nThreads; i++) {\n+            final int threadIdx = i;\n+\n+            futures.add(executor.submit(() -> {\n+                Random random = new Random();\n+\n+                for (int j = 0; j < N; j++) {\n+                    long key = Math.abs(random.nextLong());\n+                    // Ensure keys are uniques\n+                    key -= key % (threadIdx + 1);\n+\n+                    map.put(key, value);\n+                }\n+            }));\n+        }\n+\n+        for (Future<?> future : futures) {\n+            future.get();\n+        }\n+\n+        assertEquals(map.size(), N * nThreads);\n+\n+        executor.shutdown();\n+    }\n+\n+    @Test\n+    public void concurrentInsertionsAndReads() throws Throwable {\n+        ConcurrentLongLongHashMap map = new ConcurrentLongLongHashMap();\n+        ExecutorService executor = Executors.newCachedThreadPool();\n+\n+        final int nThreads = 16;\n+        final int N = 100_000;\n+        final long value = 55;\n+\n+        List<Future<?>> futures = new ArrayList<>();\n+        for (int i = 0; i < nThreads; i++) {\n+            final int threadIdx = i;\n+\n+            futures.add(executor.submit(() -> {\n+                Random random = new Random();\n+\n+                for (int j = 0; j < N; j++) {\n+                    long key = Math.abs(random.nextLong());\n+                    // Ensure keys are uniques\n+                    key -= key % (threadIdx + 1);\n+\n+                    map.put(key, value);\n+                }\n+            }));\n+        }\n+\n+        for (Future<?> future : futures) {\n+            future.get();\n+        }\n+\n+        assertEquals(map.size(), N * nThreads);\n+\n+        executor.shutdown();\n+    }\n+\n+    @Test\n+    public void testIteration() {\n+        ConcurrentLongLongHashMap map = new ConcurrentLongLongHashMap();\n+\n+        assertEquals(map.keys(), Collections.emptyList());\n+        assertEquals(map.values(), Collections.emptyList());\n+\n+        map.put(0, 0);\n+\n+        assertEquals(map.keys(), Lists.newArrayList(0l));\n+        assertEquals(map.values(), Lists.newArrayList(0l));\n+\n+        map.remove(0);\n+\n+        assertEquals(map.keys(), Collections.emptyList());\n+        assertEquals(map.values(), Collections.emptyList());\n+\n+        map.put(0, 0);\n+        map.put(1, 11);\n+        map.put(2, 22);\n+\n+        List<Long> keys = map.keys();\n+        Collections.sort(keys);\n+        assertEquals(keys, Lists.newArrayList(0l, 1l, 2l));\n+\n+        List<Long> values = map.values();\n+        Collections.sort(values);\n+        assertEquals(values, Lists.newArrayList(0l, 11l, 22l));\n+\n+        map.put(1, 111);\n+\n+        keys = map.keys();\n+        Collections.sort(keys);\n+        assertEquals(keys, Lists.newArrayList(0l, 1l, 2l));\n+\n+        values = map.values();\n+        Collections.sort(values);\n+        assertEquals(values, Lists.newArrayList(0l, 22l, 111l));\n+\n+        map.clear();\n+        assertTrue(map.isEmpty());\n+    }\n+\n+    @Test\n+    public void testHashConflictWithDeletion() {\n+        final int Buckets = 16;\n+        ConcurrentLongLongHashMap map = new ConcurrentLongLongHashMap(Buckets, 1);\n+\n+        // Pick 2 keys that fall into the same bucket\n+        long key1 = 1;\n+        long key2 = 27;\n+\n+        int bucket1 = ConcurrentLongLongHashMap.signSafeMod(ConcurrentLongLongHashMap.hash(key1), Buckets);\n+        int bucket2 = ConcurrentLongLongHashMap.signSafeMod(ConcurrentLongLongHashMap.hash(key2), Buckets);\n+        assertEquals(bucket1, bucket2);\n+\n+        final long value1 = 1;\n+        final long value2 = 2;\n+        final long value1Overwrite = 3;\n+        final long value2Overwrite = 3;\n+\n+        assertEquals(map.put(key1, value1), -1);\n+        assertEquals(map.put(key2, value2), -1);\n+        assertEquals(map.size(), 2);\n+\n+        assertEquals(map.remove(key1), value1);\n+        assertEquals(map.size(), 1);\n+\n+        assertEquals(map.put(key1, value1Overwrite), -1);\n+        assertEquals(map.size(), 2);\n+\n+        assertEquals(map.remove(key1), value1Overwrite);\n+        assertEquals(map.size(), 1);\n+\n+        assertEquals(map.put(key2, value2Overwrite), value2);\n+        assertEquals(map.get(key2), value2Overwrite);\n+\n+        assertEquals(map.size(), 1);\n+        assertEquals(map.remove(key2), value2Overwrite);\n+        assertTrue(map.isEmpty());\n+    }\n+\n+    @Test\n+    public void testPutIfAbsent() {\n+        ConcurrentLongLongHashMap map = new ConcurrentLongLongHashMap();\n+        assertEquals(map.putIfAbsent(1, 11), -1);\n+        assertEquals(map.get(1), 11);\n+\n+        assertEquals(map.putIfAbsent(1, 111), 11);\n+        assertEquals(map.get(1), 11);\n+    }\n+\n+    @Test\n+    public void testComputeIfAbsent() {\n+        ConcurrentLongLongHashMap map = new ConcurrentLongLongHashMap(16, 1);\n+        AtomicLong counter = new AtomicLong();\n+        LongLongFunction provider = new LongLongFunction() {\n+            public long apply(long key) {\n+                return counter.getAndIncrement();\n+            }\n+        };\n+\n+        assertEquals(map.computeIfAbsent(0, provider), 0);\n+        assertEquals(map.get(0), 0);\n+\n+        assertEquals(map.computeIfAbsent(1, provider), 1);\n+        assertEquals(map.get(1), 1);\n+\n+        assertEquals(map.computeIfAbsent(1, provider), 1);\n+        assertEquals(map.get(1), 1);\n+\n+        assertEquals(map.computeIfAbsent(2, provider), 2);\n+        assertEquals(map.get(2), 2);\n+    }\n+\n+    @Test\n+    public void testAddAndGet() {\n+        ConcurrentLongLongHashMap map = new ConcurrentLongLongHashMap(16, 1);\n+\n+        assertEquals(map.addAndGet(0, 0), 0);\n+        assertEquals(map.containsKey(0), true);\n+        assertEquals(map.get(0), 0);\n+\n+        assertEquals(map.containsKey(5), false);\n+\n+        assertEquals(map.addAndGet(0, 5), 5);\n+        assertEquals(map.get(0), 5);\n+\n+        assertEquals(map.addAndGet(0, 1), 6);\n+        assertEquals(map.get(0), 6);\n+\n+        assertEquals(map.addAndGet(0, -2), 4);\n+        assertEquals(map.get(0), 4);\n+\n+        // Cannot bring to value to negative\n+        try {\n+            map.addAndGet(0, -5);\n+            fail(\"should have failed\");\n+        } catch (IllegalArgumentException e) {\n+            // ok\n+        }\n+        assertEquals(map.get(0), 4);\n+    }\n+\n+    @Test\n+    public void testRemoveIf() {\n+        ConcurrentLongLongHashMap map = new ConcurrentLongLongHashMap(16, 1);\n+\n+        map.put(1L, 1L);\n+        map.put(2L, 2L);\n+        map.put(3L, 3L);\n+        map.put(4L, 4L);\n+\n+        map.removeIf(key -> key < 3);\n+        assertFalse(map.containsKey(1L));\n+        assertFalse(map.containsKey(2L));\n+        assertTrue(map.containsKey(3L));\n+        assertTrue(map.containsKey(4L));\n+        assertEquals(2, map.size());\n+    }\n+\n+    @Test\n+    public void testRemoveIfValue() {\n+        ConcurrentLongLongHashMap map = new ConcurrentLongLongHashMap(16, 1);\n+\n+        map.put(1L, 1L);\n+        map.put(2L, 2L);\n+        map.put(3L, 1L);\n+        map.put(4L, 2L);\n+\n+        map.removeIf((key, value) -> value < 2);\n+        assertFalse(map.containsKey(1L));\n+        assertTrue(map.containsKey(2L));\n+        assertFalse(map.containsKey(3L));\n+        assertTrue(map.containsKey(4L));\n+        assertEquals(2, map.size());\n+    }\n+\n+    @Test\n+    public void testIvalidKeys() {\n+        ConcurrentLongLongHashMap map = new ConcurrentLongLongHashMap(16, 1);\n+\n+        try {\n+            map.put(-5, 4);\n+            fail(\"should have failed\");\n+        } catch (IllegalArgumentException e) {\n+            // ok\n+        }\n+\n+        try {\n+            map.get(-1);\n+            fail(\"should have failed\");\n+        } catch (IllegalArgumentException e) {\n+            // ok\n+        }\n+\n+        try {\n+            map.containsKey(-1);\n+            fail(\"should have failed\");\n+        } catch (IllegalArgumentException e) {\n+            // ok\n+        }\n+\n+        try {\n+            map.putIfAbsent(-1, 1);\n+            fail(\"should have failed\");\n+        } catch (IllegalArgumentException e) {\n+            // ok\n+        }\n+\n+        try {\n+            map.computeIfAbsent(-1, new LongLongFunction() {\n+                @Override\n+                public long apply(long key) {\n+                    return 1;\n+                }\n+            });\n+            fail(\"should have failed\");\n+        } catch (IllegalArgumentException e) {\n+            // ok\n+        }\n+    }\n+\n+    @Test\n+    public void testAsMap() {\n+        ConcurrentLongLongHashMap lmap = new ConcurrentLongLongHashMap(16, 1);\n+        lmap.put(1, 11);\n+        lmap.put(2, 22);\n+        lmap.put(3, 33);\n+\n+        Map<Long, Long> map = Maps.newTreeMap();\n+        map.put(1l, 11l);\n+        map.put(2l, 22l);\n+        map.put(3l, 33l);\n+\n+        assertEquals(map, lmap.asMap());\n+    }\n+}"},{"sha":"23aa327c35bb352e64f2b55716b43ced47389ccc","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/util/collections/ConcurrentLongLongPairHashMapTest.java","status":"added","additions":343,"deletions":0,"changes":343,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/ecbb053e6e873859507e247cae727f4bc8b9f7fa/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2Fcollections%2FConcurrentLongLongPairHashMapTest.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/ecbb053e6e873859507e247cae727f4bc8b9f7fa/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2Fcollections%2FConcurrentLongLongPairHashMapTest.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2Fcollections%2FConcurrentLongLongPairHashMapTest.java?ref=ecbb053e6e873859507e247cae727f4bc8b9f7fa","patch":"@@ -0,0 +1,343 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.util.collections;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+\n+import org.apache.bookkeeper.util.collections.ConcurrentLongLongPairHashMap.LongPair;\n+import org.junit.Test;\n+\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+\n+public class ConcurrentLongLongPairHashMapTest {\n+\n+    @Test\n+    public void testConstructor() {\n+        try {\n+            new ConcurrentLongLongPairHashMap(0);\n+            fail(\"should have thrown exception\");\n+        } catch (IllegalArgumentException e) {\n+            // ok\n+        }\n+\n+        try {\n+            new ConcurrentLongLongPairHashMap(16, 0);\n+            fail(\"should have thrown exception\");\n+        } catch (IllegalArgumentException e) {\n+            // ok\n+        }\n+\n+        try {\n+            new ConcurrentLongLongPairHashMap(4, 8);\n+            fail(\"should have thrown exception\");\n+        } catch (IllegalArgumentException e) {\n+            // ok\n+        }\n+    }\n+\n+    @Test\n+    public void simpleInsertions() {\n+        ConcurrentLongLongPairHashMap map = new ConcurrentLongLongPairHashMap(16);\n+\n+        assertTrue(map.isEmpty());\n+        assertTrue(map.put(1, 1, 11, 11));\n+        assertFalse(map.isEmpty());\n+\n+        assertTrue(map.put(2, 2, 22, 22));\n+        assertTrue(map.put(3, 3, 33, 33));\n+\n+        assertEquals(map.size(), 3);\n+\n+        assertEquals(map.get(1, 1), new LongPair(11, 11));\n+        assertEquals(map.size(), 3);\n+\n+        assertTrue(map.remove(1, 1));\n+        assertEquals(map.size(), 2);\n+        assertEquals(map.get(1, 1), null);\n+        assertEquals(map.get(5, 5), null);\n+        assertEquals(map.size(), 2);\n+\n+        assertTrue(map.put(1, 1, 11, 11));\n+        assertEquals(map.size(), 3);\n+        assertTrue(map.put(1, 1, 111, 111));\n+        assertEquals(map.size(), 3);\n+    }\n+\n+    @Test\n+    public void testRemove() {\n+        ConcurrentLongLongPairHashMap map = new ConcurrentLongLongPairHashMap();\n+\n+        assertTrue(map.isEmpty());\n+        assertTrue(map.put(1, 1, 11, 11));\n+        assertFalse(map.isEmpty());\n+\n+        assertFalse(map.remove(0, 0));\n+        assertFalse(map.remove(1, 1, 111, 111));\n+\n+        assertFalse(map.isEmpty());\n+        assertTrue(map.remove(1, 1, 11, 11));\n+        assertTrue(map.isEmpty());\n+    }\n+\n+    @Test\n+    public void testNegativeUsedBucketCount() {\n+        ConcurrentLongLongPairHashMap map = new ConcurrentLongLongPairHashMap(16, 1);\n+\n+        map.put(0, 0, 0, 0);\n+        assertEquals(1, map.getUsedBucketCount());\n+        map.put(0, 0, 1, 1);\n+        assertEquals(1, map.getUsedBucketCount());\n+        map.remove(0, 0);\n+        assertEquals(0, map.getUsedBucketCount());\n+        map.remove(0, 0);\n+        assertEquals(0, map.getUsedBucketCount());\n+    }\n+\n+    @Test\n+    public void testRehashing() {\n+        int n = 16;\n+        ConcurrentLongLongPairHashMap map = new ConcurrentLongLongPairHashMap(n / 2, 1);\n+        assertEquals(map.capacity(), n);\n+        assertEquals(map.size(), 0);\n+\n+        for (int i = 0; i < n; i++) {\n+            map.put(i, i, i, i);\n+        }\n+\n+        assertEquals(map.capacity(), 2 * n);\n+        assertEquals(map.size(), n);\n+    }\n+\n+    @Test\n+    public void testRehashingWithDeletes() {\n+        int n = 16;\n+        ConcurrentLongLongPairHashMap map = new ConcurrentLongLongPairHashMap(n / 2, 1);\n+        assertEquals(map.capacity(), n);\n+        assertEquals(map.size(), 0);\n+\n+        for (int i = 0; i < n / 2; i++) {\n+            map.put(i, i, i, i);\n+        }\n+\n+        for (int i = 0; i < n / 2; i++) {\n+            map.remove(i, i);\n+        }\n+\n+        for (int i = n; i < (2 * n); i++) {\n+            map.put(i, i, i, i);\n+        }\n+\n+        assertEquals(map.capacity(), 2 * n);\n+        assertEquals(map.size(), n);\n+    }\n+\n+    @Test\n+    public void concurrentInsertions() throws Throwable {\n+        ConcurrentLongLongPairHashMap map = new ConcurrentLongLongPairHashMap();\n+        ExecutorService executor = Executors.newCachedThreadPool();\n+\n+        final int nThreads = 16;\n+        final int N = 100_000;\n+        long value = 55;\n+\n+        List<Future<?>> futures = new ArrayList<>();\n+        for (int i = 0; i < nThreads; i++) {\n+            final int threadIdx = i;\n+\n+            futures.add(executor.submit(() -> {\n+                Random random = new Random();\n+\n+                for (int j = 0; j < N; j++) {\n+                    long key1 = Math.abs(random.nextLong());\n+                    // Ensure keys are uniques\n+                    key1 -= key1 % (threadIdx + 1);\n+\n+                    long key2 = Math.abs(random.nextLong());\n+                    // Ensure keys are uniques\n+                    key2 -= key2 % (threadIdx + 1);\n+\n+                    map.put(key1, key2, value, value);\n+                }\n+            }));\n+        }\n+\n+        for (Future<?> future : futures) {\n+            future.get();\n+        }\n+\n+        assertEquals(map.size(), N * nThreads);\n+\n+        executor.shutdown();\n+    }\n+\n+    @Test\n+    public void concurrentInsertionsAndReads() throws Throwable {\n+        ConcurrentLongLongPairHashMap map = new ConcurrentLongLongPairHashMap();\n+        ExecutorService executor = Executors.newCachedThreadPool();\n+\n+        final int nThreads = 16;\n+        final int N = 100_000;\n+        final long value = 55;\n+\n+        List<Future<?>> futures = new ArrayList<>();\n+        for (int i = 0; i < nThreads; i++) {\n+            final int threadIdx = i;\n+\n+            futures.add(executor.submit(() -> {\n+                Random random = new Random();\n+\n+                for (int j = 0; j < N; j++) {\n+                    long key1 = Math.abs(random.nextLong());\n+                    // Ensure keys are uniques\n+                    key1 -= key1 % (threadIdx + 1);\n+\n+                    long key2 = Math.abs(random.nextLong());\n+                    // Ensure keys are uniques\n+                    key2 -= key2 % (threadIdx + 1);\n+\n+                    map.put(key1, key2, value, value);\n+                }\n+            }));\n+        }\n+\n+        for (Future<?> future : futures) {\n+            future.get();\n+        }\n+\n+        assertEquals(map.size(), N * nThreads);\n+\n+        executor.shutdown();\n+    }\n+\n+    @Test\n+    public void testIteration() {\n+        ConcurrentLongLongPairHashMap map = new ConcurrentLongLongPairHashMap();\n+\n+        assertEquals(map.keys(), Collections.emptyList());\n+        assertEquals(map.values(), Collections.emptyList());\n+\n+        map.put(0, 0, 0, 0);\n+\n+        assertEquals(map.keys(), Lists.newArrayList(new LongPair(0, 0)));\n+        assertEquals(map.values(), Lists.newArrayList(new LongPair(0, 0)));\n+\n+        map.remove(0, 0);\n+\n+        assertEquals(map.keys(), Collections.emptyList());\n+        assertEquals(map.values(), Collections.emptyList());\n+\n+        map.put(0, 0, 0, 0);\n+        map.put(1, 1, 11, 11);\n+        map.put(2, 2, 22, 22);\n+\n+        List<LongPair> keys = map.keys();\n+        Collections.sort(keys);\n+        assertEquals(keys, Lists.newArrayList(new LongPair(0, 0), new LongPair(1, 1), new LongPair(2, 2)));\n+\n+        List<LongPair> values = map.values();\n+        Collections.sort(values);\n+        assertEquals(values, Lists.newArrayList(new LongPair(0, 0), new LongPair(11, 11), new LongPair(22, 22)));\n+\n+        map.put(1, 1, 111, 111);\n+\n+        keys = map.keys();\n+        Collections.sort(keys);\n+        assertEquals(keys, Lists.newArrayList(new LongPair(0, 0), new LongPair(1, 1), new LongPair(2, 2)));\n+\n+        values = map.values();\n+        Collections.sort(values);\n+        assertEquals(values, Lists.newArrayList(new LongPair(0, 0), new LongPair(22, 22), new LongPair(111, 111)));\n+\n+        map.clear();\n+        assertTrue(map.isEmpty());\n+    }\n+\n+    @Test\n+    public void testPutIfAbsent() {\n+        ConcurrentLongLongPairHashMap map = new ConcurrentLongLongPairHashMap();\n+        assertTrue(map.putIfAbsent(1, 1, 11, 11));\n+        assertEquals(map.get(1, 1), new LongPair(11, 11));\n+\n+        assertFalse(map.putIfAbsent(1, 1, 111, 111));\n+        assertEquals(map.get(1, 1), new LongPair(11, 11));\n+    }\n+\n+    @Test\n+    public void testIvalidKeys() {\n+        ConcurrentLongLongPairHashMap map = new ConcurrentLongLongPairHashMap(16, 1);\n+\n+        try {\n+            map.put(-5, 3, 4, 4);\n+            fail(\"should have failed\");\n+        } catch (IllegalArgumentException e) {\n+            // ok\n+        }\n+\n+        try {\n+            map.get(-1, 0);\n+            fail(\"should have failed\");\n+        } catch (IllegalArgumentException e) {\n+            // ok\n+        }\n+\n+        try {\n+            map.containsKey(-1, 0);\n+            fail(\"should have failed\");\n+        } catch (IllegalArgumentException e) {\n+            // ok\n+        }\n+\n+        try {\n+            map.putIfAbsent(-1, 1, 1, 1);\n+            fail(\"should have failed\");\n+        } catch (IllegalArgumentException e) {\n+            // ok\n+        }\n+    }\n+\n+    @Test\n+    public void testAsMap() {\n+        ConcurrentLongLongPairHashMap lmap = new ConcurrentLongLongPairHashMap(16, 1);\n+        lmap.put(1, 1, 11, 11);\n+        lmap.put(2, 2, 22, 22);\n+        lmap.put(3, 3, 33, 33);\n+\n+        Map<LongPair, LongPair> map = Maps.newTreeMap();\n+        map.put(new LongPair(1, 1), new LongPair(11, 11));\n+        map.put(new LongPair(2, 2), new LongPair(22, 22));\n+        map.put(new LongPair(3, 3), new LongPair(33, 33));\n+\n+        assertEquals(map, lmap.asMap());\n+    }\n+}"},{"sha":"d1dd0be5a41a3aea6dec9034e04307b5caef7098","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/util/collections/ConcurrentOpenHashMapTest.java","status":"added","additions":488,"deletions":0,"changes":488,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/ecbb053e6e873859507e247cae727f4bc8b9f7fa/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2Fcollections%2FConcurrentOpenHashMapTest.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/ecbb053e6e873859507e247cae727f4bc8b9f7fa/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2Fcollections%2FConcurrentOpenHashMapTest.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2Fcollections%2FConcurrentOpenHashMapTest.java?ref=ecbb053e6e873859507e247cae727f4bc8b9f7fa","patch":"@@ -0,0 +1,488 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.util.collections;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.BiPredicate;\n+import java.util.function.Function;\n+\n+import org.junit.Test;\n+\n+import com.google.common.collect.Lists;\n+\n+public class ConcurrentOpenHashMapTest {\n+\n+    @Test\n+    public void testConstructor() {\n+        try {\n+            new ConcurrentOpenHashMap<String, String>(0);\n+            fail(\"should have thrown exception\");\n+        } catch (IllegalArgumentException e) {\n+            // ok\n+        }\n+\n+        try {\n+            new ConcurrentOpenHashMap<String, String>(16, 0);\n+            fail(\"should have thrown exception\");\n+        } catch (IllegalArgumentException e) {\n+            // ok\n+        }\n+\n+        try {\n+            new ConcurrentOpenHashMap<String, String>(4, 8);\n+            fail(\"should have thrown exception\");\n+        } catch (IllegalArgumentException e) {\n+            // ok\n+        }\n+    }\n+\n+    @Test\n+    public void simpleInsertions() {\n+        ConcurrentOpenHashMap<String, String> map = new ConcurrentOpenHashMap<>(16);\n+\n+        assertTrue(map.isEmpty());\n+        assertNull(map.put(\"1\", \"one\"));\n+        assertFalse(map.isEmpty());\n+\n+        assertNull(map.put(\"2\", \"two\"));\n+        assertNull(map.put(\"3\", \"three\"));\n+\n+        assertEquals(map.size(), 3);\n+\n+        assertEquals(map.get(\"1\"), \"one\");\n+        assertEquals(map.size(), 3);\n+\n+        assertEquals(map.remove(\"1\"), \"one\");\n+        assertEquals(map.size(), 2);\n+        assertEquals(map.get(\"1\"), null);\n+        assertEquals(map.get(\"5\"), null);\n+        assertEquals(map.size(), 2);\n+\n+        assertNull(map.put(\"1\", \"one\"));\n+        assertEquals(map.size(), 3);\n+        assertEquals(map.put(\"1\", \"uno\"), \"one\");\n+        assertEquals(map.size(), 3);\n+    }\n+\n+    @Test\n+    public void testRemove() {\n+        ConcurrentOpenHashMap<String, String> map = new ConcurrentOpenHashMap<>();\n+\n+        assertTrue(map.isEmpty());\n+        assertNull(map.put(\"1\", \"one\"));\n+        assertFalse(map.isEmpty());\n+\n+        assertFalse(map.remove(\"0\", \"zero\"));\n+        assertFalse(map.remove(\"1\", \"uno\"));\n+\n+        assertFalse(map.isEmpty());\n+        assertTrue(map.remove(\"1\", \"one\"));\n+        assertTrue(map.isEmpty());\n+    }\n+\n+    @Test\n+    public void testRehashing() {\n+        int n = 16;\n+        ConcurrentOpenHashMap<String, Integer> map = new ConcurrentOpenHashMap<>(n / 2, 1);\n+        assertEquals(map.capacity(), n);\n+        assertEquals(map.size(), 0);\n+\n+        for (int i = 0; i < n; i++) {\n+            map.put(Integer.toString(i), i);\n+        }\n+\n+        assertEquals(map.capacity(), 2 * n);\n+        assertEquals(map.size(), n);\n+    }\n+\n+    @Test\n+    public void testRehashingWithDeletes() {\n+        int n = 16;\n+        ConcurrentOpenHashMap<Integer, Integer> map = new ConcurrentOpenHashMap<>(n / 2, 1);\n+        assertEquals(map.capacity(), n);\n+        assertEquals(map.size(), 0);\n+\n+        for (int i = 0; i < n / 2; i++) {\n+            map.put(i, i);\n+        }\n+\n+        for (int i = 0; i < n / 2; i++) {\n+            map.remove(i);\n+        }\n+\n+        for (int i = n; i < (2 * n); i++) {\n+            map.put(i, i);\n+        }\n+\n+        assertEquals(map.capacity(), 2 * n);\n+        assertEquals(map.size(), n);\n+    }\n+\n+    @Test\n+    public void concurrentInsertions() throws Throwable {\n+        ConcurrentOpenHashMap<Long, String> map = new ConcurrentOpenHashMap<>();\n+        ExecutorService executor = Executors.newCachedThreadPool();\n+\n+        final int nThreads = 16;\n+        final int N = 100_000;\n+        String value = \"value\";\n+\n+        List<Future<?>> futures = new ArrayList<>();\n+        for (int i = 0; i < nThreads; i++) {\n+            final int threadIdx = i;\n+\n+            futures.add(executor.submit(() -> {\n+                Random random = new Random();\n+\n+                for (int j = 0; j < N; j++) {\n+                    long key = random.nextLong();\n+                    // Ensure keys are uniques\n+                    key -= key % (threadIdx + 1);\n+\n+                    map.put(key, value);\n+                }\n+            }));\n+        }\n+\n+        for (Future<?> future : futures) {\n+            future.get();\n+        }\n+\n+        assertEquals(map.size(), N * nThreads);\n+\n+        executor.shutdown();\n+    }\n+\n+    @Test\n+    public void concurrentInsertionsAndReads() throws Throwable {\n+        ConcurrentOpenHashMap<Long, String> map = new ConcurrentOpenHashMap<>();\n+        ExecutorService executor = Executors.newCachedThreadPool();\n+\n+        final int nThreads = 16;\n+        final int N = 100_000;\n+        String value = \"value\";\n+\n+        List<Future<?>> futures = new ArrayList<>();\n+        for (int i = 0; i < nThreads; i++) {\n+            final int threadIdx = i;\n+\n+            futures.add(executor.submit(() -> {\n+                Random random = new Random();\n+\n+                for (int j = 0; j < N; j++) {\n+                    long key = random.nextLong();\n+                    // Ensure keys are uniques\n+                    key -= key % (threadIdx + 1);\n+\n+                    map.put(key, value);\n+                }\n+            }));\n+        }\n+\n+        for (Future<?> future : futures) {\n+            future.get();\n+        }\n+\n+        assertEquals(map.size(), N * nThreads);\n+\n+        executor.shutdown();\n+    }\n+\n+    @Test\n+    public void testIteration() {\n+        ConcurrentOpenHashMap<Long, String> map = new ConcurrentOpenHashMap<>();\n+\n+        assertEquals(map.keys(), Collections.emptyList());\n+        assertEquals(map.values(), Collections.emptyList());\n+\n+        map.put(0l, \"zero\");\n+\n+        assertEquals(map.keys(), Lists.newArrayList(0l));\n+        assertEquals(map.values(), Lists.newArrayList(\"zero\"));\n+\n+        map.remove(0l);\n+\n+        assertEquals(map.keys(), Collections.emptyList());\n+        assertEquals(map.values(), Collections.emptyList());\n+\n+        map.put(0l, \"zero\");\n+        map.put(1l, \"one\");\n+        map.put(2l, \"two\");\n+\n+        List<Long> keys = map.keys();\n+        Collections.sort(keys);\n+        assertEquals(keys, Lists.newArrayList(0l, 1l, 2l));\n+\n+        List<String> values = map.values();\n+        Collections.sort(values);\n+        assertEquals(values, Lists.newArrayList(\"one\", \"two\", \"zero\"));\n+\n+        map.put(1l, \"uno\");\n+\n+        keys = map.keys();\n+        Collections.sort(keys);\n+        assertEquals(keys, Lists.newArrayList(0l, 1l, 2l));\n+\n+        values = map.values();\n+        Collections.sort(values);\n+        assertEquals(values, Lists.newArrayList(\"two\", \"uno\", \"zero\"));\n+\n+        map.clear();\n+        assertTrue(map.isEmpty());\n+    }\n+\n+    @Test\n+    public void testHashConflictWithDeletion() {\n+        final int Buckets = 16;\n+        ConcurrentOpenHashMap<Long, String> map = new ConcurrentOpenHashMap<>(Buckets, 1);\n+\n+        // Pick 2 keys that fall into the same bucket\n+        long key1 = 1;\n+        long key2 = 27;\n+\n+        int bucket1 = ConcurrentOpenHashMap.signSafeMod(ConcurrentOpenHashMap.hash(key1), Buckets);\n+        int bucket2 = ConcurrentOpenHashMap.signSafeMod(ConcurrentOpenHashMap.hash(key2), Buckets);\n+        assertEquals(bucket1, bucket2);\n+\n+        assertEquals(map.put(key1, \"value-1\"), null);\n+        assertEquals(map.put(key2, \"value-2\"), null);\n+        assertEquals(map.size(), 2);\n+\n+        assertEquals(map.remove(key1), \"value-1\");\n+        assertEquals(map.size(), 1);\n+\n+        assertEquals(map.put(key1, \"value-1-overwrite\"), null);\n+        assertEquals(map.size(), 2);\n+\n+        assertEquals(map.remove(key1), \"value-1-overwrite\");\n+        assertEquals(map.size(), 1);\n+\n+        assertEquals(map.put(key2, \"value-2-overwrite\"), \"value-2\");\n+        assertEquals(map.get(key2), \"value-2-overwrite\");\n+\n+        assertEquals(map.size(), 1);\n+        assertEquals(map.remove(key2), \"value-2-overwrite\");\n+        assertTrue(map.isEmpty());\n+    }\n+\n+    @Test\n+    public void testPutIfAbsent() {\n+        ConcurrentOpenHashMap<Long, String> map = new ConcurrentOpenHashMap<>();\n+        assertEquals(map.putIfAbsent(1l, \"one\"), null);\n+        assertEquals(map.get(1l), \"one\");\n+\n+        assertEquals(map.putIfAbsent(1l, \"uno\"), \"one\");\n+        assertEquals(map.get(1l), \"one\");\n+    }\n+\n+    @Test\n+    public void testComputeIfAbsent() {\n+        ConcurrentOpenHashMap<Integer, Integer> map = new ConcurrentOpenHashMap<>(16, 1);\n+        AtomicInteger counter = new AtomicInteger();\n+        Function<Integer, Integer> provider = key -> counter.getAndIncrement();\n+\n+        assertEquals(map.computeIfAbsent(0, provider).intValue(), 0);\n+        assertEquals(map.get(0).intValue(), 0);\n+\n+        assertEquals(map.computeIfAbsent(1, provider).intValue(), 1);\n+        assertEquals(map.get(1).intValue(), 1);\n+\n+        assertEquals(map.computeIfAbsent(1, provider).intValue(), 1);\n+        assertEquals(map.get(1).intValue(), 1);\n+\n+        assertEquals(map.computeIfAbsent(2, provider).intValue(), 2);\n+        assertEquals(map.get(2).intValue(), 2);\n+    }\n+\n+    @Test\n+    public void testRemoval() {\n+        ConcurrentOpenHashMap<Integer, String> map = new ConcurrentOpenHashMap<>();\n+        map.put(0, \"0\");\n+        map.put(1, \"1\");\n+        map.put(3, \"3\");\n+        map.put(6, \"6\");\n+        map.put(7, \"7\");\n+\n+        List<Integer> keys = map.keys();\n+        Collections.sort(keys);\n+        assertEquals(keys, Lists.newArrayList(0, 1, 3, 6, 7));\n+\n+        int numOfItemsDeleted = map.removeIf(new BiPredicate<Integer, String>() {\n+            @Override\n+            public boolean test(Integer k, String v) {\n+                return k < 5;\n+            }\n+        });\n+        assertEquals(numOfItemsDeleted, 3);\n+        assertEquals(map.size(), keys.size() - numOfItemsDeleted);\n+        keys = map.keys();\n+        Collections.sort(keys);\n+        assertEquals(keys, Lists.newArrayList(6, 7));\n+    }\n+\n+    @Test\n+    public void testEqualsKeys() {\n+        class T {\n+            int value;\n+\n+            T(int value) {\n+                this.value = value;\n+            }\n+\n+            @Override\n+            public int hashCode() {\n+                return Integer.hashCode(value);\n+            }\n+\n+            @Override\n+            public boolean equals(Object obj) {\n+                if (obj instanceof T) {\n+                    return value == ((T) obj).value;\n+                }\n+\n+                return false;\n+            }\n+        }\n+\n+        ConcurrentOpenHashMap<T, String> map = new ConcurrentOpenHashMap<>();\n+\n+        T t1 = new T(1);\n+        T t1_b = new T(1);\n+        T t2 = new T(2);\n+\n+        assertEquals(t1, t1_b);\n+        assertFalse(t1.equals(t2));\n+        assertFalse(t1_b.equals(t2));\n+\n+        assertNull(map.put(t1, \"t1\"));\n+        assertEquals(map.get(t1), \"t1\");\n+        assertEquals(map.get(t1_b), \"t1\");\n+        assertNull(map.get(t2));\n+\n+        assertEquals(map.remove(t1_b), \"t1\");\n+        assertNull(map.get(t1));\n+        assertNull(map.get(t1_b));\n+    }\n+\n+    final static int Iterations = 1;\n+    final static int ReadIterations = 100;\n+    final static int N = 1_000_000;\n+\n+    public void benchConcurrentOpenHashMap() throws Exception {\n+        // public static void main(String args[]) {\n+        ConcurrentOpenHashMap<Long, String> map = new ConcurrentOpenHashMap<>(N, 1);\n+\n+        for (long i = 0; i < Iterations; i++) {\n+            for (int j = 0; j < N; j++) {\n+                map.put(i, \"value\");\n+            }\n+\n+            for (long h = 0; h < ReadIterations; h++) {\n+                for (int j = 0; j < N; j++) {\n+                    map.get(i);\n+                }\n+            }\n+\n+            for (long j = 0; j < N; j++) {\n+                map.remove(i);\n+            }\n+        }\n+    }\n+\n+    public void benchConcurrentHashMap() throws Exception {\n+        ConcurrentHashMap<Long, String> map = new ConcurrentHashMap<Long, String>(N, 0.66f, 1);\n+\n+        for (long i = 0; i < Iterations; i++) {\n+            for (int j = 0; j < N; j++) {\n+                map.put(i, \"value\");\n+            }\n+\n+            for (long h = 0; h < ReadIterations; h++) {\n+                for (int j = 0; j < N; j++) {\n+                    map.get(i);\n+                }\n+            }\n+\n+            for (int j = 0; j < N; j++) {\n+                map.remove(i);\n+            }\n+        }\n+    }\n+\n+    void benchHashMap() throws Exception {\n+        HashMap<Long, String> map = new HashMap<Long, String>(N, 0.66f);\n+\n+        for (long i = 0; i < Iterations; i++) {\n+            for (int j = 0; j < N; j++) {\n+                map.put(i, \"value\");\n+            }\n+\n+            for (long h = 0; h < ReadIterations; h++) {\n+                for (int j = 0; j < N; j++) {\n+                    map.get(i);\n+                }\n+            }\n+\n+            for (int j = 0; j < N; j++) {\n+                map.remove(i);\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        ConcurrentOpenHashMapTest t = new ConcurrentOpenHashMapTest();\n+\n+        long start = System.nanoTime();\n+        // t.benchHashMap();\n+        long end = System.nanoTime();\n+\n+        System.out.println(\"HM:   \" + TimeUnit.NANOSECONDS.toMillis(end - start) + \" ms\");\n+\n+        start = System.nanoTime();\n+        t.benchConcurrentHashMap();\n+        end = System.nanoTime();\n+\n+        System.out.println(\"CHM:  \" + TimeUnit.NANOSECONDS.toMillis(end - start) + \" ms\");\n+\n+        start = System.nanoTime();\n+        // t.benchConcurrentOpenHashMap();\n+        end = System.nanoTime();\n+\n+        System.out.println(\"CLHM: \" + TimeUnit.NANOSECONDS.toMillis(end - start) + \" ms\");\n+\n+    }\n+}"},{"sha":"ec207182c49d5e6fd8276e374b5c489bb9612d86","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/util/collections/ConcurrentOpenHashSetTest.java","status":"added","additions":318,"deletions":0,"changes":318,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/ecbb053e6e873859507e247cae727f4bc8b9f7fa/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2Fcollections%2FConcurrentOpenHashSetTest.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/ecbb053e6e873859507e247cae727f4bc8b9f7fa/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2Fcollections%2FConcurrentOpenHashSetTest.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2Fcollections%2FConcurrentOpenHashSetTest.java?ref=ecbb053e6e873859507e247cae727f4bc8b9f7fa","patch":"@@ -0,0 +1,318 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.util.collections;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+\n+import org.junit.Test;\n+\n+import com.google.common.collect.Lists;\n+\n+public class ConcurrentOpenHashSetTest {\n+\n+    @Test\n+    public void testConstructor() {\n+        try {\n+            new ConcurrentOpenHashSet<String>(0);\n+            fail(\"should have thrown exception\");\n+        } catch (IllegalArgumentException e) {\n+            // ok\n+        }\n+\n+        try {\n+            new ConcurrentOpenHashSet<String>(16, 0);\n+            fail(\"should have thrown exception\");\n+        } catch (IllegalArgumentException e) {\n+            // ok\n+        }\n+\n+        try {\n+            new ConcurrentOpenHashSet<String>(4, 8);\n+            fail(\"should have thrown exception\");\n+        } catch (IllegalArgumentException e) {\n+            // ok\n+        }\n+    }\n+\n+    @Test\n+    public void simpleInsertions() {\n+        ConcurrentOpenHashSet<String> set = new ConcurrentOpenHashSet<>(16);\n+\n+        assertTrue(set.isEmpty());\n+        assertTrue(set.add(\"1\"));\n+        assertFalse(set.isEmpty());\n+\n+        assertTrue(set.add(\"2\"));\n+        assertTrue(set.add(\"3\"));\n+\n+        assertEquals(set.size(), 3);\n+\n+        assertTrue(set.contains(\"1\"));\n+        assertEquals(set.size(), 3);\n+\n+        assertTrue(set.remove(\"1\"));\n+        assertEquals(set.size(), 2);\n+        assertFalse(set.contains(\"1\"));\n+        assertFalse(set.contains(\"5\"));\n+        assertEquals(set.size(), 2);\n+\n+        assertTrue(set.add(\"1\"));\n+        assertEquals(set.size(), 3);\n+        assertFalse(set.add(\"1\"));\n+        assertEquals(set.size(), 3);\n+    }\n+\n+    @Test\n+    public void testRemove() {\n+        ConcurrentOpenHashSet<String> set = new ConcurrentOpenHashSet<>();\n+\n+        assertTrue(set.isEmpty());\n+        assertTrue(set.add(\"1\"));\n+        assertFalse(set.isEmpty());\n+\n+        assertFalse(set.remove(\"0\"));\n+        assertFalse(set.isEmpty());\n+        assertTrue(set.remove(\"1\"));\n+        assertTrue(set.isEmpty());\n+    }\n+\n+    @Test\n+    public void testRehashing() {\n+        int n = 16;\n+        ConcurrentOpenHashSet<Integer> set = new ConcurrentOpenHashSet<>(n / 2, 1);\n+        assertEquals(set.capacity(), n);\n+        assertEquals(set.size(), 0);\n+\n+        for (int i = 0; i < n; i++) {\n+            set.add(i);\n+        }\n+\n+        assertEquals(set.capacity(), 2 * n);\n+        assertEquals(set.size(), n);\n+    }\n+\n+    @Test\n+    public void testRehashingWithDeletes() {\n+        int n = 16;\n+        ConcurrentOpenHashSet<Integer> set = new ConcurrentOpenHashSet<>(n / 2, 1);\n+        assertEquals(set.capacity(), n);\n+        assertEquals(set.size(), 0);\n+\n+        for (int i = 0; i < n / 2; i++) {\n+            set.add(i);\n+        }\n+\n+        for (int i = 0; i < n / 2; i++) {\n+            set.remove(i);\n+        }\n+\n+        for (int i = n; i < (2 * n); i++) {\n+            set.add(i);\n+        }\n+\n+        assertEquals(set.capacity(), 2 * n);\n+        assertEquals(set.size(), n);\n+    }\n+\n+    @Test\n+    public void concurrentInsertions() throws Throwable {\n+        ConcurrentOpenHashSet<Long> set = new ConcurrentOpenHashSet<>();\n+        ExecutorService executor = Executors.newCachedThreadPool();\n+\n+        final int nThreads = 16;\n+        final int N = 100_000;\n+\n+        List<Future<?>> futures = new ArrayList<>();\n+        for (int i = 0; i < nThreads; i++) {\n+            final int threadIdx = i;\n+\n+            futures.add(executor.submit(() -> {\n+                Random random = new Random();\n+\n+                for (int j = 0; j < N; j++) {\n+                    long key = random.nextLong();\n+                    // Ensure keys are unique\n+                    key -= key % (threadIdx + 1);\n+\n+                    set.add(key);\n+                }\n+            }));\n+        }\n+\n+        for (Future<?> future : futures) {\n+            future.get();\n+        }\n+\n+        assertEquals(set.size(), N * nThreads);\n+\n+        executor.shutdown();\n+    }\n+\n+    @Test\n+    public void concurrentInsertionsAndReads() throws Throwable {\n+        ConcurrentOpenHashSet<Long> map = new ConcurrentOpenHashSet<>();\n+        ExecutorService executor = Executors.newCachedThreadPool();\n+\n+        final int nThreads = 16;\n+        final int N = 100_000;\n+\n+        List<Future<?>> futures = new ArrayList<>();\n+        for (int i = 0; i < nThreads; i++) {\n+            final int threadIdx = i;\n+\n+            futures.add(executor.submit(() -> {\n+                Random random = new Random();\n+\n+                for (int j = 0; j < N; j++) {\n+                    long key = random.nextLong();\n+                    // Ensure keys are unique\n+                    key -= key % (threadIdx + 1);\n+\n+                    map.add(key);\n+                }\n+            }));\n+        }\n+\n+        for (Future<?> future : futures) {\n+            future.get();\n+        }\n+\n+        assertEquals(map.size(), N * nThreads);\n+\n+        executor.shutdown();\n+    }\n+\n+    @Test\n+    public void testIteration() {\n+        ConcurrentOpenHashSet<Long> set = new ConcurrentOpenHashSet<>();\n+\n+        assertEquals(set.values(), Collections.emptyList());\n+\n+        set.add(0l);\n+\n+        assertEquals(set.values(), Lists.newArrayList(0l));\n+\n+        set.remove(0l);\n+\n+        assertEquals(set.values(), Collections.emptyList());\n+\n+        set.add(0l);\n+        set.add(1l);\n+        set.add(2l);\n+\n+        List<Long> values = set.values();\n+        Collections.sort(values);\n+        assertEquals(values, Lists.newArrayList(0l, 1l, 2l));\n+\n+        set.clear();\n+        assertTrue(set.isEmpty());\n+    }\n+\n+    @Test\n+    public void testHashConflictWithDeletion() {\n+        final int Buckets = 16;\n+        ConcurrentOpenHashSet<Long> set = new ConcurrentOpenHashSet<>(Buckets, 1);\n+\n+        // Pick 2 keys that fall into the same bucket\n+        long key1 = 1;\n+        long key2 = 27;\n+\n+        int bucket1 = ConcurrentOpenHashSet.signSafeMod(ConcurrentOpenHashSet.hash(key1), Buckets);\n+        int bucket2 = ConcurrentOpenHashSet.signSafeMod(ConcurrentOpenHashSet.hash(key2), Buckets);\n+        assertEquals(bucket1, bucket2);\n+\n+        assertTrue(set.add(key1));\n+        assertTrue(set.add(key2));\n+        assertEquals(set.size(), 2);\n+\n+        assertTrue(set.remove(key1));\n+        assertEquals(set.size(), 1);\n+\n+        assertTrue(set.add(key1));\n+        assertEquals(set.size(), 2);\n+\n+        assertTrue(set.remove(key1));\n+        assertEquals(set.size(), 1);\n+\n+        assertFalse(set.add(key2));\n+        assertTrue(set.contains(key2));\n+\n+        assertEquals(set.size(), 1);\n+        assertTrue(set.remove(key2));\n+        assertTrue(set.isEmpty());\n+    }\n+\n+    @Test\n+    public void testEqualsObjects() {\n+        class T {\n+            int value;\n+\n+            T(int value) {\n+                this.value = value;\n+            }\n+\n+            @Override\n+            public int hashCode() {\n+                return Integer.hashCode(value);\n+            }\n+\n+            @Override\n+            public boolean equals(Object obj) {\n+                if (obj instanceof T) {\n+                    return value == ((T) obj).value;\n+                }\n+\n+                return false;\n+            }\n+        }\n+\n+        ConcurrentOpenHashSet<T> set = new ConcurrentOpenHashSet<>();\n+\n+        T t1 = new T(1);\n+        T t1_b = new T(1);\n+        T t2 = new T(2);\n+\n+        assertEquals(t1, t1_b);\n+        assertFalse(t1.equals(t2));\n+        assertFalse(t1_b.equals(t2));\n+\n+        set.add(t1);\n+        assertTrue(set.contains(t1));\n+        assertTrue(set.contains(t1_b));\n+        assertFalse(set.contains(t2));\n+\n+        assertTrue(set.remove(t1_b));\n+        assertFalse(set.contains(t1));\n+        assertFalse(set.contains(t1_b));\n+    }\n+\n+}"}]}