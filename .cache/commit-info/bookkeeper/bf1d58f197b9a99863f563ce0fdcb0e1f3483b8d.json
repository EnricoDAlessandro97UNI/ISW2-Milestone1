{"sha":"bf1d58f197b9a99863f563ce0fdcb0e1f3483b8d","node_id":"MDY6Q29tbWl0NDc4NTkyNTI2OmJmMWQ1OGYxOTdiOWE5OTg2M2Y1NjNjZTBmZGNiMGUxZjM0ODNiOGQ=","commit":{"author":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2017-08-05T08:33:00Z"},"committer":{"name":"jiazhai","email":"zhaijia@live.com","date":"2017-08-05T08:33:00Z"},"message":"ISSUE #390: [CI] Test errors in TestRackawareEnsemblePlacementPolicyUsingScript\n\nDescriptions of the changes in this PR:\n\n`Shell` class was ported from hadoop, but it contains a lot of unused code. Especially there is not `HADOOP_HOME` will set, so an exception will be thrown. (although the issue seems to be hidden in mac)\n\nThis change is to clean up the `Shell` class. The `Shell` class is only used for executing shell script configured in rackaware placement policy.\n\nAuthor: Sijie Guo <sijie@apache.org>\n\nReviewers: Jia Zhai <None>, Enrico Olivelli <None>\n\nThis closes #396 from sijie/sijie/cleanup_shell, closes #390","tree":{"sha":"d7fb91a7ba1243c5646ceab015816a26941148e4","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/trees/d7fb91a7ba1243c5646ceab015816a26941148e4"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/commits/bf1d58f197b9a99863f563ce0fdcb0e1f3483b8d","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/bf1d58f197b9a99863f563ce0fdcb0e1f3483b8d","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/bf1d58f197b9a99863f563ce0fdcb0e1f3483b8d","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/bf1d58f197b9a99863f563ce0fdcb0e1f3483b8d/comments","author":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"committer":null,"parents":[{"sha":"8986f32db757799ea678fa8c31823566572f3082","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/8986f32db757799ea678fa8c31823566572f3082","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/8986f32db757799ea678fa8c31823566572f3082"}],"stats":{"total":266,"additions":2,"deletions":264},"files":[{"sha":"f9c99e727005db1ac7a9568476559711adcb4748","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/util/Shell.java","status":"modified","additions":2,"deletions":264,"changes":266,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/bf1d58f197b9a99863f563ce0fdcb0e1f3483b8d/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2FShell.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/bf1d58f197b9a99863f563ce0fdcb0e1f3483b8d/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2FShell.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2FShell.java?ref=bf1d58f197b9a99863f563ce0fdcb0e1f3483b8d","patch":"@@ -17,21 +17,18 @@\n  */\n package org.apache.bookkeeper.util;\n \n+import com.google.common.base.Charsets;\n import java.io.BufferedReader;\n import java.io.File;\n import java.io.IOException;\n import java.io.InputStreamReader;\n-import java.util.Arrays;\n import java.util.Map;\n import java.util.Timer;\n import java.util.TimerTask;\n import java.util.concurrent.atomic.AtomicBoolean;\n-\n import org.apache.commons.logging.Log;\n import org.apache.commons.logging.LogFactory;\n \n-import com.google.common.base.Charsets;\n-\n /**\n  * A base class for running a Unix command.\n  *\n@@ -43,266 +40,14 @@ abstract public class Shell {\n \n     public static final Log LOG = LogFactory.getLog(Shell.class);\n \n-    private static boolean IS_JAVA7_OR_ABOVE =\n-        System.getProperty(\"java.version\").substring(0, 3).compareTo(\"1.7\") >= 0;\n-\n-    public static boolean isJava7OrAbove() {\n-        return IS_JAVA7_OR_ABOVE;\n-    }\n-\n-    /** a Unix command to get the current user's name */\n-    public final static String USER_NAME_COMMAND = \"whoami\";\n-\n-    /** Windows CreateProcess synchronization object */\n-    public static final Object WindowsProcessLaunchLock = new Object();\n-\n-    /** a Unix command to get the current user's groups list */\n-    public static String[] getGroupsCommand() {\n-        return (WINDOWS) ? new String[] { \"cmd\", \"/c\", \"groups\" } : new String[] { \"bash\", \"-c\", \"groups\" };\n-    }\n-\n-    /** a Unix command to get a given user's groups list */\n-    public static String[] getGroupsForUserCommand(final String user) {\n-        //'groups username' command return is non-consistent across different unixes\n-        return (WINDOWS) ? new String[] { WINUTILS, \"groups\", \"-F\", \"\\\"\" + user + \"\\\"\" } : new String[] { \"bash\", \"-c\",\n-                \"id -Gn \" + user };\n-    }\n-\n-    /** a Unix command to get a given netgroup's user list */\n-    public static String[] getUsersForNetgroupCommand(final String netgroup) {\n-        //'groups username' command return is non-consistent across different unixes\n-        return (WINDOWS) ? new String[] { \"cmd\", \"/c\", \"getent netgroup \" + netgroup } : new String[] { \"bash\", \"-c\",\n-                \"getent netgroup \" + netgroup };\n-    }\n-\n-    /** Return a command to get permission information. */\n-    public static String[] getGetPermissionCommand() {\n-        return (WINDOWS) ? new String[] { WINUTILS, \"ls\", \"-F\" } : new String[] { \"/bin/ls\", \"-ld\" };\n-    }\n-\n-    /** Return a command to set permission */\n-    public static String[] getSetPermissionCommand(String perm, boolean recursive) {\n-        if (recursive) {\n-            return (WINDOWS) ? new String[] { WINUTILS, \"chmod\", \"-R\", perm } : new String[] { \"chmod\", \"-R\", perm };\n-        } else {\n-            return (WINDOWS) ? new String[] { WINUTILS, \"chmod\", perm } : new String[] { \"chmod\", perm };\n-        }\n-    }\n-\n-    /**\n-     * Return a command to set permission for specific file.\n-     *\n-     * @param perm String permission to set\n-     * @param recursive boolean true to apply to all sub-directories recursively\n-     * @param file String file to set\n-     * @return String[] containing command and arguments\n-     */\n-    public static String[] getSetPermissionCommand(String perm, boolean recursive, String file) {\n-        String[] baseCmd = getSetPermissionCommand(perm, recursive);\n-        String[] cmdWithFile = Arrays.copyOf(baseCmd, baseCmd.length + 1);\n-        cmdWithFile[cmdWithFile.length - 1] = file;\n-        return cmdWithFile;\n-    }\n-\n-    /** Return a command to set owner */\n-    public static String[] getSetOwnerCommand(String owner) {\n-        return (WINDOWS) ? new String[] { WINUTILS, \"chown\", \"\\\"\" + owner + \"\\\"\" } : new String[] { \"chown\", owner };\n-    }\n-\n-    /** Return a command to create symbolic links */\n-    public static String[] getSymlinkCommand(String target, String link) {\n-        return WINDOWS ? new String[] { WINUTILS, \"symlink\", link, target } : new String[] { \"ln\", \"-s\", target, link };\n-    }\n-\n-    /** Return a command for determining if process with specified pid is alive. */\n-    public static String[] getCheckProcessIsAliveCommand(String pid) {\n-        return Shell.WINDOWS ? new String[] { Shell.WINUTILS, \"task\", \"isAlive\", pid } : new String[] { \"kill\", \"-0\",\n-                isSetsidAvailable ? \"-\" + pid : pid };\n-    }\n-\n-    /** Return a command to send a signal to a given pid */\n-    public static String[] getSignalKillCommand(int code, String pid) {\n-        return Shell.WINDOWS ? new String[] { Shell.WINUTILS, \"task\", \"kill\", pid } : new String[] { \"kill\",\n-                \"-\" + code, isSetsidAvailable ? \"-\" + pid : pid };\n-    }\n-\n-    /**\n-     * Returns a File referencing a script with the given basename, inside the\n-     * given parent directory.  The file extension is inferred by platform: \".cmd\"\n-     * on Windows, or \".sh\" otherwise.\n-     *\n-     * @param parent File parent directory\n-     * @param basename String script file basename\n-     * @return File referencing the script in the directory\n-     */\n-    public static File appendScriptExtension(File parent, String basename) {\n-        return new File(parent, appendScriptExtension(basename));\n-    }\n-\n-    /**\n-     * Returns a script file name with the given basename.  The file extension is\n-     * inferred by platform: \".cmd\" on Windows, or \".sh\" otherwise.\n-     *\n-     * @param basename String script file basename\n-     * @return String script file name\n-     */\n-    public static String appendScriptExtension(String basename) {\n-        return basename + (WINDOWS ? \".cmd\" : \".sh\");\n-    }\n-\n-    /**\n-     * Returns a command to run the given script.  The script interpreter is\n-     * inferred by platform: cmd on Windows or bash otherwise.\n-     *\n-     * @param script File script to run\n-     * @return String[] command to run the script\n-     */\n-    public static String[] getRunScriptCommand(File script) {\n-        String absolutePath = script.getAbsolutePath();\n-        return WINDOWS ? new String[] { \"cmd\", \"/c\", absolutePath } : new String[] { \"/bin/bash\", absolutePath };\n-    }\n-\n-    /** a Unix command to set permission */\n-    public static final String SET_PERMISSION_COMMAND = \"chmod\";\n-    /** a Unix command to set owner */\n-    public static final String SET_OWNER_COMMAND = \"chown\";\n-\n-    /** a Unix command to set the change user's groups list */\n-    public static final String SET_GROUP_COMMAND = \"chgrp\";\n-    /** a Unix command to create a link */\n-    public static final String LINK_COMMAND = \"ln\";\n-    /** a Unix command to get a link target */\n-    public static final String READ_LINK_COMMAND = \"readlink\";\n-\n-    /**Time after which the executing script would be timedout*/\n     protected long timeOutInterval = 0L;\n     /** If or not script timed out*/\n     private AtomicBoolean timedOut;\n \n-    /** Centralized logic to discover and validate the sanity of the Hadoop\n-     *  home directory. Returns either NULL or a directory that exists and\n-     *  was specified via either -Dhadoop.home.dir or the HADOOP_HOME ENV\n-     *  variable.  This does a lot of work so it should only be called\n-     *  privately for initialization once per process.\n-     **/\n-    private static String checkHadoopHome() {\n-\n-        // first check the Dflag hadoop.home.dir with JVM scope\n-        String home = System.getProperty(\"hadoop.home.dir\");\n-\n-        // fall back to the system/user-global env variable\n-        if (home == null) {\n-            home = System.getenv(\"HADOOP_HOME\");\n-        }\n-\n-        try {\n-            // couldn't find either setting for hadoop's home directory\n-            if (home == null) {\n-                throw new IOException(\"HADOOP_HOME or hadoop.home.dir are not set.\");\n-            }\n-\n-            if (home.startsWith(\"\\\"\") && home.endsWith(\"\\\"\")) {\n-                home = home.substring(1, home.length() - 1);\n-            }\n-\n-            // check that the home setting is actually a directory that exists\n-            File homedir = new File(home);\n-            if (!homedir.isAbsolute() || !homedir.exists() || !homedir.isDirectory()) {\n-                throw new IOException(\"Hadoop home directory \" + homedir\n-                        + \" does not exist, is not a directory, or is not an absolute path.\");\n-            }\n-\n-            home = homedir.getCanonicalPath();\n-\n-        } catch (IOException ioe) {\n-            LOG.error(\"Failed to detect a valid hadoop home directory\", ioe);\n-            home = null;\n-        }\n-\n-        return home;\n-    }\n-\n-    private static String HADOOP_HOME_DIR = checkHadoopHome();\n-\n-    // Public getter, throws an exception if HADOOP_HOME failed validation\n-    // checks and is being referenced downstream.\n-    public static final String getHadoopHome() throws IOException {\n-        if (HADOOP_HOME_DIR == null) {\n-            throw new IOException(\"Misconfigured HADOOP_HOME cannot be referenced.\");\n-        }\n-\n-        return HADOOP_HOME_DIR;\n-    }\n-\n-    /** fully qualify the path to a binary that should be in a known hadoop\n-     *  bin location. This is primarily useful for disambiguating call-outs\n-     *  to executable sub-components of Hadoop to avoid clashes with other\n-     *  executables that may be in the path.  Caveat:  this call doesn't\n-     *  just format the path to the bin directory.  It also checks for file\n-     *  existence of the composed path. The output of this call should be\n-     *  cached by callers.\n-     * */\n-    public static final String getQualifiedBinPath(String executable) throws IOException {\n-        // construct hadoop bin path to the specified executable\n-        String fullExeName = HADOOP_HOME_DIR + File.separator + \"bin\" + File.separator + executable;\n-\n-        File exeFile = new File(fullExeName);\n-        if (!exeFile.exists()) {\n-            throw new IOException(\"Could not locate executable \" + fullExeName + \" in the Hadoop binaries.\");\n-        }\n-\n-        return exeFile.getCanonicalPath();\n-    }\n-\n     /** Set to true on Windows platforms */\n     public static final boolean WINDOWS /* borrowed from Path.WINDOWS */\n     = System.getProperty(\"os.name\").startsWith(\"Windows\");\n \n-    public static final boolean LINUX = System.getProperty(\"os.name\").startsWith(\"Linux\");\n-\n-    /** a Windows utility to emulate Unix commands */\n-    public static final String WINUTILS = getWinUtilsPath();\n-\n-    public static final String getWinUtilsPath() {\n-        String winUtilsPath = null;\n-\n-        try {\n-            if (WINDOWS) {\n-                winUtilsPath = getQualifiedBinPath(\"winutils.exe\");\n-            }\n-        } catch (IOException ioe) {\n-            LOG.error(\"Failed to locate the winutils binary in the hadoop binary path\", ioe);\n-        }\n-\n-        return winUtilsPath;\n-    }\n-\n-    public static final boolean isSetsidAvailable = isSetsidSupported();\n-\n-    private static boolean isSetsidSupported() {\n-        if (Shell.WINDOWS) {\n-            return false;\n-        }\n-        ShellCommandExecutor shexec = null;\n-        boolean setsidSupported = true;\n-        try {\n-            String[] args = { \"setsid\", \"bash\", \"-c\", \"echo $$\" };\n-            shexec = new ShellCommandExecutor(args);\n-            shexec.execute();\n-        } catch (IOException ioe) {\n-            LOG.warn(\"setsid is not available on this machine. So not using it.\");\n-            setsidSupported = false;\n-        } finally { // handle the exit code\n-            if (null != shexec) {\n-                LOG.info(\"setsid exited with exit code \" + shexec.getExitCode());\n-            }\n-        }\n-        return setsidSupported;\n-    }\n-\n-    /** Token separator regex used to parse Shell tool outputs */\n-    public static final String TOKEN_SEPARATOR_REGEX = WINDOWS ? \"[|\\n\\r]\" : \"[ \\t\\n\\r\\f]\";\n-\n     private long interval; // refresh interval in msec\n     private long lastTime; // last time the command was performed\n     private Map<String, String> environment; // env for the command execution\n@@ -364,14 +109,7 @@ private void runCommand() throws IOException {\n         }\n \n         if (Shell.WINDOWS) {\n-            synchronized (WindowsProcessLaunchLock) {\n-                // To workaround the race condition issue with child processes\n-                // inheriting unintended handles during process launch that can\n-                // lead to hangs on reading output and error streams, we\n-                // serialize process creation. More info available at:\n-                // http://support.microsoft.com/kb/315939\n-                process = builder.start();\n-            }\n+            throw new IOException(\"Windows is not supported.\");\n         } else {\n             process = builder.start();\n         }"}]}