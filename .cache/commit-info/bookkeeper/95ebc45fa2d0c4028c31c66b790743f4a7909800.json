{"sha":"95ebc45fa2d0c4028c31c66b790743f4a7909800","node_id":"MDY6Q29tbWl0NDc4NTkyNTI2Ojk1ZWJjNDVmYTJkMGM0MDI4YzMxYzY2Yjc5MDc0M2Y0YTc5MDk4MDA=","commit":{"author":{"name":"Sijie Guo","email":"sijieg@twitter.com","date":"2017-06-29T22:08:17Z"},"committer":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2017-06-29T22:08:17Z"},"message":"ISSUE #209: Introduce Speculative Read/Read LAC policy\n\nDescriptions of the changes in this PR:\n\n    - Separate out the logic that determines when speculative reads are scheduled from the individual requests into a separate SpeculativeRequestExecutionPolicy\n    - Implement the default speculative read execution policy based on the current mechanism of using first and max timeout\n    - Initialize the policy once in the BookKeeper object and use it for individual requests by keeping information about the requests in the call chain.\n\n---\nBe sure to do all of the following to help us incorporate your contribution\nquickly and easily:\n\n- [x] Make sure the PR title is formatted like:\n    `<Issue #>: Description of pull request`\n    `e.g. Issue 123: Description ...`\n- [x] Make sure tests pass via `mvn clean apache-rat:check install findbugs:check`.\n- [x] Replace `<Issue #>` in the title with the actual Issue number, if there is one.\n\n---\n\nAuthor: Sijie Guo <sijieg@twitter.com>\nAuthor: Robin Dhamankar <rdhamankar@twitter.com>\nAuthor: Sijie Guo <sijie@apache.org>\n\nReviewers: Enrico Olivelli <eolivelli@gmail.com>, Jia Zhai <None>\n\nThis closes #200 from sijie/client_changes/speculative_policy, closes #209","tree":{"sha":"b719e6e936a869e640b0dcead563115845dab49f","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/trees/b719e6e936a869e640b0dcead563115845dab49f"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/commits/95ebc45fa2d0c4028c31c66b790743f4a7909800","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/95ebc45fa2d0c4028c31c66b790743f4a7909800","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/95ebc45fa2d0c4028c31c66b790743f4a7909800","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/95ebc45fa2d0c4028c31c66b790743f4a7909800/comments","author":null,"committer":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"parents":[{"sha":"75aca2397e43ec321a049aaec514c99cc9fad235","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/75aca2397e43ec321a049aaec514c99cc9fad235","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/75aca2397e43ec321a049aaec514c99cc9fad235"}],"stats":{"total":333,"additions":286,"deletions":47},"files":[{"sha":"2d509d4c580025c49a3b9a1913c104e2bc72937a","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeper.java","status":"modified","additions":20,"deletions":7,"changes":27,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/95ebc45fa2d0c4028c31c66b790743f4a7909800/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookKeeper.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/95ebc45fa2d0c4028c31c66b790743f4a7909800/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookKeeper.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookKeeper.java?ref=95ebc45fa2d0c4028c31c66b790743f4a7909800","patch":"@@ -21,6 +21,9 @@\n package org.apache.bookkeeper.client;\n \n import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Optional;\n+import com.google.common.base.Preconditions;\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n import io.netty.channel.EventLoopGroup;\n import io.netty.channel.epoll.EpollEventLoopGroup;\n import io.netty.channel.nio.NioEventLoopGroup;\n@@ -29,16 +32,14 @@\n import java.io.IOException;\n import java.util.List;\n import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.Executors;\n import java.util.concurrent.ScheduledExecutorService;\n import java.util.concurrent.ThreadFactory;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.locks.ReentrantReadWriteLock;\n \n-import com.google.common.base.Optional;\n-import com.google.common.base.Preconditions;\n-\n import org.apache.bookkeeper.client.AsyncCallback.CreateCallback;\n import org.apache.bookkeeper.client.AsyncCallback.DeleteCallback;\n import org.apache.bookkeeper.client.AsyncCallback.OpenCallback;\n@@ -70,9 +71,6 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import com.google.common.util.concurrent.ThreadFactoryBuilder;\n-\n-import java.util.concurrent.CompletableFuture;\n \n /**\n  * BookKeeper client. We assume there is one single writer to a ledger at any\n@@ -86,7 +84,6 @@\n  *\n  *\n  */\n-\n public class BookKeeper implements AutoCloseable {\n \n     static final Logger LOG = LoggerFactory.getLogger(BookKeeper.class);\n@@ -136,6 +133,8 @@ public class BookKeeper implements AutoCloseable {\n     final ClientConfiguration conf;\n     final int explicitLacInterval;\n \n+    final Optional<SpeculativeRequestExecutionPolicy> readSpeculativeRequestPolicy;\n+\n     // Close State\n     boolean closed = false;\n     final ReentrantReadWriteLock closeLock = new ReentrantReadWriteLock();\n@@ -356,6 +355,16 @@ private BookKeeper(ClientConfiguration conf,\n         this.placementPolicy = initializeEnsemblePlacementPolicy(conf,\n                 dnsResolver, this.requestTimer, this.featureProvider, this.statsLogger);\n \n+        if (conf.getFirstSpeculativeReadTimeout() > 0) {\n+            this.readSpeculativeRequestPolicy =\n+                    Optional.of(new DefaultSpeculativeRequestExecutionPolicy(\n+                        conf.getFirstSpeculativeReadTimeout(),\n+                        conf.getMaxSpeculativeReadTimeout(),\n+                        conf.getSpeculativeReadTimeoutBackoffMultiplier()));\n+        } else {\n+            this.readSpeculativeRequestPolicy = Optional.<SpeculativeRequestExecutionPolicy>absent();\n+        }\n+\n         // initialize main worker pool\n         this.mainWorkerPool = OrderedSafeExecutor.newBuilder()\n                 .name(\"BookKeeperClientWorker\")\n@@ -481,6 +490,10 @@ StatsLogger getStatsLogger() {\n         return statsLogger;\n     }\n \n+    public Optional<SpeculativeRequestExecutionPolicy> getReadSpeculativeRequestPolicy() {\n+        return readSpeculativeRequestPolicy;\n+    }\n+\n     /**\n      * Get the BookieClient, currently used for doing bookie recovery.\n      *"},{"sha":"d0a36727eb5b2e70ec9738131e853384a42767e7","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/DefaultSpeculativeRequestExecutionPolicy.java","status":"added","additions":102,"deletions":0,"changes":102,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/95ebc45fa2d0c4028c31c66b790743f4a7909800/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FDefaultSpeculativeRequestExecutionPolicy.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/95ebc45fa2d0c4028c31c66b790743f4a7909800/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FDefaultSpeculativeRequestExecutionPolicy.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FDefaultSpeculativeRequestExecutionPolicy.java?ref=95ebc45fa2d0c4028c31c66b790743f4a7909800","patch":"@@ -0,0 +1,102 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.client;\n+\n+import java.util.concurrent.RejectedExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import com.google.common.util.concurrent.FutureCallback;\n+import com.google.common.util.concurrent.Futures;\n+import com.google.common.util.concurrent.ListenableFuture;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class DefaultSpeculativeRequestExecutionPolicy implements SpeculativeRequestExecutionPolicy {\n+    private static final Logger LOG = LoggerFactory.getLogger(PendingReadOp.class);\n+    final int firstSpeculativeRequestTimeout;\n+    final int maxSpeculativeRequestTimeout;\n+    final float backoffMultiplier;\n+\n+    public DefaultSpeculativeRequestExecutionPolicy(int firstSpeculativeRequestTimeout, int maxSpeculativeRequestTimeout, float backoffMultiplier) {\n+        this.firstSpeculativeRequestTimeout = firstSpeculativeRequestTimeout;\n+        this.maxSpeculativeRequestTimeout = maxSpeculativeRequestTimeout;\n+        this.backoffMultiplier = backoffMultiplier;\n+\n+        if (backoffMultiplier <= 0) {\n+            throw new IllegalArgumentException(\"Invalid value provided for backoffMultiplier\");\n+        }\n+\n+        // Prevent potential over flow\n+        if (Math.round((double)maxSpeculativeRequestTimeout * (double)backoffMultiplier) > Integer.MAX_VALUE) {\n+            throw new IllegalArgumentException(\"Invalid values for maxSpeculativeRequestTimeout and backoffMultiplier\");\n+        }\n+    }\n+\n+    /**\n+     * Initialize the speculative request execution policy\n+     *\n+     * @param scheduler The scheduler service to issue the speculative request\n+     * @param requestExecutor The executor is used to issue the actual speculative requests\n+     */\n+    @Override\n+    public void initiateSpeculativeRequest(final ScheduledExecutorService scheduler, final SpeculativeRequestExectuor requestExecutor) {\n+        scheduleSpeculativeRead(scheduler, requestExecutor, firstSpeculativeRequestTimeout);\n+    }\n+\n+    private void scheduleSpeculativeRead(final ScheduledExecutorService scheduler,\n+                                         final SpeculativeRequestExectuor requestExecutor,\n+                                         final int speculativeRequestTimeout) {\n+        try {\n+            scheduler.schedule(new Runnable() {\n+                @Override\n+                public void run() {\n+                    ListenableFuture<Boolean> issueNextRequest = requestExecutor.issueSpeculativeRequest();\n+                    Futures.addCallback(issueNextRequest, new FutureCallback<Boolean>() {\n+                        // we want this handler to run immediately after we push the big red button!\n+                        public void onSuccess(Boolean issueNextRequest) {\n+                            if (issueNextRequest) {\n+                                scheduleSpeculativeRead(scheduler, requestExecutor, Math.min(maxSpeculativeRequestTimeout,\n+                                    Math.round((float)speculativeRequestTimeout * backoffMultiplier)));\n+                            } else {\n+                                if(LOG.isTraceEnabled()) {\n+                                    LOG.trace(\"Stopped issuing speculative requests for {}, \" +\n+                                        \"speculativeReadTimeout = {}\", requestExecutor, speculativeRequestTimeout);\n+                                }\n+                            }\n+                        }\n+\n+                        public void onFailure(Throwable thrown) {\n+                            LOG.warn(\"Failed to issue speculative request for {}, speculativeReadTimeout = {} : \",\n+                                new Object[] { requestExecutor, speculativeRequestTimeout, thrown });\n+                        }\n+                    });\n+                }\n+            }, speculativeRequestTimeout, TimeUnit.MILLISECONDS);\n+        } catch (RejectedExecutionException re) {\n+            if (!scheduler.isShutdown()) {\n+                LOG.warn(\"Failed to schedule speculative request for {}, speculativeReadTimeout = {} : \",\n+                        new Object[]{requestExecutor, speculativeRequestTimeout, re});\n+            }\n+        }\n+    }\n+}"},{"sha":"f2477c11e33c9c8684a3ec3dfec1ca29c4df295e","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingReadOp.java","status":"modified","additions":29,"deletions":40,"changes":69,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/95ebc45fa2d0c4028c31c66b790743f4a7909800/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FPendingReadOp.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/95ebc45fa2d0c4028c31c66b790743f4a7909800/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FPendingReadOp.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FPendingReadOp.java?ref=95ebc45fa2d0c4028c31c66b790743f4a7909800","patch":"@@ -31,12 +31,14 @@\n import java.util.Queue;\n import java.util.Set;\n import java.util.concurrent.ArrayBlockingQueue;\n-import java.util.concurrent.RejectedExecutionException;\n+import java.util.concurrent.Callable;\n import java.util.concurrent.ScheduledExecutorService;\n import java.util.concurrent.ScheduledFuture;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicBoolean;\n \n+import com.google.common.util.concurrent.ListenableFuture;\n+\n import org.apache.bookkeeper.client.AsyncCallback.ReadCallback;\n import org.apache.bookkeeper.client.BKException.BKDigestMatchException;\n import org.apache.bookkeeper.net.BookieSocketAddress;\n@@ -57,7 +59,6 @@\n class PendingReadOp implements Enumeration<LedgerEntry>, ReadEntryCallback {\n     private static final Logger LOG = LoggerFactory.getLogger(PendingReadOp.class);\n \n-    final int speculativeReadTimeout;\n     final private ScheduledExecutorService scheduler;\n     private ScheduledFuture<?> speculativeTask = null;\n     Queue<LedgerEntryRequest> seq;\n@@ -76,7 +77,7 @@ class PendingReadOp implements Enumeration<LedgerEntry>, ReadEntryCallback {\n     boolean parallelRead = false;\n     final AtomicBoolean complete = new AtomicBoolean(false);\n \n-    abstract class LedgerEntryRequest extends LedgerEntry {\n+    abstract class LedgerEntryRequest extends LedgerEntry implements SpeculativeRequestExectuor {\n \n         final AtomicBoolean complete = new AtomicBoolean(false);\n \n@@ -226,6 +227,28 @@ public String toString() {\n             return String.format(\"L%d-E%d\", ledgerId, entryId);\n         }\n \n+        /**\n+         * Issues a speculative request and indicates if more speculative\n+         * requests should be issued\n+         *\n+         * @return whether more speculative requests should be issued\n+         */\n+        @Override\n+        public ListenableFuture<Boolean> issueSpeculativeRequest() {\n+            return lh.bk.mainWorkerPool.submitOrdered(lh.getId(), new Callable<Boolean>() {\n+                @Override\n+                public Boolean call() throws Exception {\n+                    if (!isComplete() && null != maybeSendSpeculativeRead(heardFromHostsBitSet)) {\n+                        if (LOG.isDebugEnabled()) {\n+                            LOG.debug(\"Send speculative read for {}. Hosts heard are {}, ensemble is {}.\",\n+                                new Object[] { this, heardFromHostsBitSet, ensemble });\n+                        }\n+                        return true;\n+                    }\n+                    return false;\n+                }\n+            });\n+        }\n     }\n \n     class ParallelReadRequest extends LedgerEntryRequest {\n@@ -402,7 +425,6 @@ synchronized void logErrorAndReattemptRead(int bookieIndex, BookieSocketAddress\n         numPendingEntries = endEntryId - startEntryId + 1;\n         maxMissedReadsAllowed = getLedgerMetadata().getWriteQuorumSize()\n                 - getLedgerMetadata().getAckQuorumSize();\n-        speculativeReadTimeout = lh.bk.getConf().getSpeculativeReadTimeout();\n         heardFromHosts = new HashSet<>();\n         heardFromHostsBitSet = new BitSet(getLedgerMetadata().getEnsembleSize());\n \n@@ -430,42 +452,6 @@ public void initiate() {\n         this.requestTimeNanos = MathUtils.nowInNano();\n         ArrayList<BookieSocketAddress> ensemble = null;\n \n-        if (speculativeReadTimeout > 0 && !parallelRead) {\n-            Runnable readTask = new Runnable() {\n-                public void run() {\n-                    int x = 0;\n-                    for (LedgerEntryRequest r : seq) {\n-                        if (!r.isComplete()) {\n-                            if (null == r.maybeSendSpeculativeRead(heardFromHostsBitSet)) {\n-                                // Subsequent speculative read will not materialize anyway\n-                                cancelSpeculativeTask(false);\n-                            } else {\n-                                if (LOG.isDebugEnabled()) {\n-                                    LOG.debug(\"Send speculative read for {}. Hosts heard are {}.\", r, heardFromHostsBitSet);\n-                                }\n-                                ++x;\n-                            }\n-                        }\n-                    }\n-                    if (x > 0) {\n-                        if (LOG.isDebugEnabled()) {\n-                            LOG.debug(\"Send {} speculative reads for ledger {} ({}, {}). Hosts heard are {}.\",\n-                                    new Object[] { x, lh.getId(), startEntryId, endEntryId, heardFromHostsBitSet });\n-                        }\n-                    }\n-                }\n-            };\n-            try {\n-                speculativeTask = scheduler.scheduleWithFixedDelay(readTask,\n-                        speculativeReadTimeout, speculativeReadTimeout, TimeUnit.MILLISECONDS);\n-            } catch (RejectedExecutionException re) {\n-                if (LOG.isDebugEnabled()) {\n-                    LOG.debug(\"Failed to schedule speculative reads for ledger {} ({}, {}) : \", lh.getId(),\n-                            startEntryId, endEntryId, re);\n-                }\n-            }\n-        }\n-\n         do {\n             if (i == nextEnsembleChange) {\n                 ensemble = getLedgerMetadata().getEnsemble(i);\n@@ -483,6 +469,9 @@ public void run() {\n         // read the entries.\n         for (LedgerEntryRequest entry : seq) {\n             entry.read();\n+            if (!parallelRead && lh.bk.getReadSpeculativeRequestPolicy().isPresent()) {\n+                lh.bk.getReadSpeculativeRequestPolicy().get().initiateSpeculativeRequest(scheduler, entry);\n+            }\n         }\n     }\n "},{"sha":"45e1aebc648db171f29cbf9d90c7ac2ae4d18bcb","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/SpeculativeRequestExectuor.java","status":"added","additions":34,"deletions":0,"changes":34,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/95ebc45fa2d0c4028c31c66b790743f4a7909800/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FSpeculativeRequestExectuor.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/95ebc45fa2d0c4028c31c66b790743f4a7909800/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FSpeculativeRequestExectuor.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FSpeculativeRequestExectuor.java?ref=95ebc45fa2d0c4028c31c66b790743f4a7909800","patch":"@@ -0,0 +1,34 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.client;\n+\n+import com.google.common.util.concurrent.ListenableFuture;\n+\n+public interface SpeculativeRequestExectuor {\n+\n+    /**\n+     * Issues a speculative request and indicates if more speculative\n+     * requests should be issued\n+     *\n+     * @return whether more speculative requests should be issued\n+     */\n+    ListenableFuture<Boolean> issueSpeculativeRequest();\n+}"},{"sha":"4489d4146f59869c7b3775b499dc48a565180f25","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/SpeculativeRequestExecutionPolicy.java","status":"added","additions":34,"deletions":0,"changes":34,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/95ebc45fa2d0c4028c31c66b790743f4a7909800/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FSpeculativeRequestExecutionPolicy.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/95ebc45fa2d0c4028c31c66b790743f4a7909800/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FSpeculativeRequestExecutionPolicy.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FSpeculativeRequestExecutionPolicy.java?ref=95ebc45fa2d0c4028c31c66b790743f4a7909800","patch":"@@ -0,0 +1,34 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.client;\n+\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+public interface SpeculativeRequestExecutionPolicy {\n+\n+    /**\n+     * Initialize the speculative request execution policy and initiate requests\n+     *\n+     * @param scheduler The scheduler service to issue the speculative request\n+     * @param requestExectuor The executor is used to issue the actual speculative requests\n+     */\n+    void initiateSpeculativeRequest(ScheduledExecutorService scheduler, SpeculativeRequestExectuor requestExectuor);\n+}"},{"sha":"32b21aacaa8565ca07abec05513d974d9c9ce4b0","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ClientConfiguration.java","status":"modified","additions":66,"deletions":0,"changes":66,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/95ebc45fa2d0c4028c31c66b790743f4a7909800/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fconf%2FClientConfiguration.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/95ebc45fa2d0c4028c31c66b790743f4a7909800/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fconf%2FClientConfiguration.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fconf%2FClientConfiguration.java?ref=95ebc45fa2d0c4028c31c66b790743f4a7909800","patch":"@@ -62,6 +62,9 @@ public class ClientConfiguration extends AbstractConfiguration {\n     // Read Parameters\n     protected final static String READ_TIMEOUT = \"readTimeout\";\n     protected final static String SPECULATIVE_READ_TIMEOUT = \"speculativeReadTimeout\";\n+    protected final static String FIRST_SPECULATIVE_READ_TIMEOUT = \"firstSpeculativeReadTimeout\";\n+    protected final static String MAX_SPECULATIVE_READ_TIMEOUT = \"maxSpeculativeReadTimeout\";\n+    protected final static String SPECULATIVE_READ_TIMEOUT_BACKOFF_MULTIPLIER = \"speculativeReadTimeoutBackoffMultiplier\";\n     protected final static String ENABLE_PARALLEL_RECOVERY_READ = \"enableParallelRecoveryRead\";\n     protected final static String RECOVERY_READ_BATCH_SIZE = \"recoveryReadBatchSize\";\n     // Timeout Setting\n@@ -794,6 +797,69 @@ public ClientConfiguration setSpeculativeReadTimeout(int timeout) {\n         return this;\n     }\n \n+    /**\n+     * Get the first speculative read timeout.\n+     *\n+     * @return first speculative read timeout.\n+     */\n+    public int getFirstSpeculativeReadTimeout() {\n+        return getInt(FIRST_SPECULATIVE_READ_TIMEOUT, getSpeculativeReadTimeout());\n+    }\n+\n+    /**\n+     * Set the first speculative read timeout.\n+     *\n+     * @param timeout\n+     *          first speculative read timeout.\n+     * @return client configuration.\n+     */\n+    public ClientConfiguration setFirstSpeculativeReadTimeout(int timeout) {\n+        setProperty(FIRST_SPECULATIVE_READ_TIMEOUT, timeout);\n+        return this;\n+    }\n+\n+    /**\n+     * Multipler to use when determining time between successive speculative read requests\n+     *\n+     * @return speculative read timeout backoff multiplier.\n+     */\n+    public float getSpeculativeReadTimeoutBackoffMultiplier() {\n+        return getFloat(SPECULATIVE_READ_TIMEOUT_BACKOFF_MULTIPLIER, 2.0f);\n+    }\n+\n+    /**\n+     * Set the multipler to use when determining time between successive speculative read requests\n+     *\n+     * @param speculativeReadTimeoutBackoffMultiplier\n+     *          multipler to use when determining time between successive speculative read requests.\n+     * @return client configuration.\n+     */\n+    public ClientConfiguration setSpeculativeReadTimeoutBackoffMultiplier(float speculativeReadTimeoutBackoffMultiplier) {\n+        setProperty(SPECULATIVE_READ_TIMEOUT_BACKOFF_MULTIPLIER, speculativeReadTimeoutBackoffMultiplier);\n+        return this;\n+    }\n+\n+    /**\n+     * Get the max speculative read timeout.\n+     *\n+     * @return max speculative read timeout.\n+     */\n+    public int getMaxSpeculativeReadTimeout() {\n+        return getInt(MAX_SPECULATIVE_READ_TIMEOUT, getSpeculativeReadTimeout());\n+    }\n+\n+    /**\n+     * Set the max speculative read timeout.\n+     *\n+     * @param timeout\n+     *          max speculative read timeout.\n+     * @return client configuration.\n+     */\n+    public ClientConfiguration setMaxSpeculativeReadTimeout(int timeout) {\n+        setProperty(MAX_SPECULATIVE_READ_TIMEOUT, timeout);\n+        return this;\n+    }\n+\n     /**\n      * Whether to enable parallel reading in recovery read.\n      *"},{"sha":"76f0830ecb8b8e248aa61c1f29eba3cb3f6ccd81","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/util/OrderedSafeExecutor.java","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/95ebc45fa2d0c4028c31c66b790743f4a7909800/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2FOrderedSafeExecutor.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/95ebc45fa2d0c4028c31c66b790743f4a7909800/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2FOrderedSafeExecutor.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2FOrderedSafeExecutor.java?ref=95ebc45fa2d0c4028c31c66b790743f4a7909800","patch":"@@ -246,6 +246,7 @@ public ListeningScheduledExecutorService chooseThread() {\n     }\n \n     public ListeningScheduledExecutorService chooseThread(Object orderingKey) {\n+        // skip hashcode generation in this special case\n         if (threads.length == 1) {\n             return threads[0];\n         }"}]}