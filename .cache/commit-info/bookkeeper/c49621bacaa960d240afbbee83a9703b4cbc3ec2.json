{"sha":"c49621bacaa960d240afbbee83a9703b4cbc3ec2","node_id":"MDY6Q29tbWl0NDc4NTkyNTI2OmM0OTYyMWJhY2FhOTYwZDI0MGFmYmJlZTgzYTk3MDNiNGNiYzNlYzI=","commit":{"author":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2017-07-17T20:47:37Z"},"committer":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2017-07-17T20:47:37Z"},"message":"ISSUE #208: Improve ledger fence logic\n\nDescriptions of the changes in this PR:\n\nProblem:\n    When bookie receive a fence request and couldn't find any writable dirs for the new index file, it will throw exception. This behavior can be improved, because as long as ledger fence request be persisted in Journal, we can say the fence request succeed. It should not depends on the success of flushing new index file.\n\nSolution:\n\n- Add option to fall back to pick from all directories regardless of writable or not when we getFileInfo for a new ledger\n- Return success only when ledger fence request has been persisted in Journal\n\n---\nBe sure to do all of the following to help us incorporate your contribution\nquickly and easily:\n\n- [x] Make sure the PR title is formatted like:\n    `<Issue #>: Description of pull request`\n    `e.g. Issue 123: Description ...`\n- [x] Make sure tests pass via `mvn clean apache-rat:check install findbugs:check`.\n- [x] Replace `<Issue #>` in the title with the actual Issue number, if there is one.\n\n---\n\nAuthor: Sijie Guo <sijie@apache.org>\nAuthor: Yiming Zang <yzang@twitter.com>\n\nReviewers: Enrico Olivelli <eolivelli@gmail.com>, Jia Zhai <None>\n\nThis closes #205 from sijie/improve_fencing_behavior, closes #208","tree":{"sha":"2ac3831f9ce7f2e880152ee5cbbf4fac01337f9e","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/trees/2ac3831f9ce7f2e880152ee5cbbf4fac01337f9e"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/commits/c49621bacaa960d240afbbee83a9703b4cbc3ec2","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/c49621bacaa960d240afbbee83a9703b4cbc3ec2","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/c49621bacaa960d240afbbee83a9703b4cbc3ec2","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/c49621bacaa960d240afbbee83a9703b4cbc3ec2/comments","author":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"committer":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"parents":[{"sha":"ccf83ed5bd49155697e909e13edb572082e838ec","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/ccf83ed5bd49155697e909e13edb572082e838ec","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/ccf83ed5bd49155697e909e13edb572082e838ec"}],"stats":{"total":148,"additions":118,"deletions":30},"files":[{"sha":"3375204d99a1b48463947f850b25d45c5440a66f","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java","status":"modified","additions":1,"deletions":23,"changes":24,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/c49621bacaa960d240afbbee83a9703b4cbc3ec2/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FBookie.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/c49621bacaa960d240afbbee83a9703b4cbc3ec2/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FBookie.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FBookie.java?ref=c49621bacaa960d240afbbee83a9703b4cbc3ec2","patch":"@@ -1492,29 +1492,7 @@ public SettableFuture<Boolean> getResult() {\n      */\n     public SettableFuture<Boolean> fenceLedger(long ledgerId, byte[] masterKey) throws IOException, BookieException {\n         LedgerDescriptor handle = handles.getHandle(ledgerId, masterKey);\n-        boolean success;\n-        synchronized (handle) {\n-            success = handle.setFenced();\n-        }\n-        if (success) {\n-            // fenced first time, we should add the key to journal ensure we can rebuild\n-            ByteBuffer bb = ByteBuffer.allocate(8 + 8);\n-            bb.putLong(ledgerId);\n-            bb.putLong(METAENTRY_ID_FENCE_KEY);\n-            bb.flip();\n-\n-            FutureWriteCallback fwc = new FutureWriteCallback();\n-            if (LOG.isDebugEnabled()) {\n-                LOG.debug(\"record fenced state for ledger {} in journal.\", ledgerId);\n-            }\n-            getJournal(ledgerId).logAddEntry(bb, fwc, null);\n-            return fwc.getResult();\n-        } else {\n-            // already fenced\n-            SettableFuture<Boolean> successFuture = SettableFuture.create();\n-            successFuture.set(true);\n-            return successFuture;\n-        }\n+        return handle.fenceAndLogInJournal(getJournal(ledgerId));\n     }\n \n     public ByteBuf readEntry(long ledgerId, long entryId)"},{"sha":"9a34101e091905c8c747a3764af70a24dc72ea94","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/IndexPersistenceMgr.java","status":"modified","additions":33,"deletions":2,"changes":35,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/c49621bacaa960d240afbbee83a9703b4cbc3ec2/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FIndexPersistenceMgr.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/c49621bacaa960d240afbbee83a9703b4cbc3ec2/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FIndexPersistenceMgr.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FIndexPersistenceMgr.java?ref=c49621bacaa960d240afbbee83a9703b4cbc3ec2","patch":"@@ -125,7 +125,7 @@ FileInfo getFileInfo(Long ledger, byte masterKey[]) throws IOException {\n                         throw new Bookie.NoLedgerException(ledger);\n                     }\n                     // We don't have a ledger index file on disk, so create it.\n-                    lf = getNewLedgerIndexFile(ledger, null);\n+                    lf = getNewLedgerIndexFile(ledger, null, true);\n                     createdNewFile = true;\n                 }\n             }\n@@ -176,7 +176,38 @@ private FileInfo putFileInfo(Long ledger, byte masterKey[], File lf, boolean cre\n      */\n     private File getNewLedgerIndexFile(Long ledger, File excludedDir)\n                     throws NoWritableLedgerDirException {\n-        File dir = ledgerDirsManager.pickRandomWritableDirForNewIndexFile(excludedDir);\n+        return getNewLedgerIndexFile(ledger, excludedDir, false);\n+    }\n+\n+    /**\n+     * Get a new index file for a ledger in a lazy way.\n+     *\n+     + <p>If fallback is false, this function will throw exception when there are no writable dirs.\n+     + If fallback is true and there's no writable dirs, it will ignore the error and pick any dir.\n+     + Set fallback to true is useful when we want to delay disk check and just get the File pointer, e.g. fence ledger\n+     *\n+     * @param ledger\n+     *          Ledger id.\n+     * @param excludedDir\n+     *          The ledger directory to exclude.\n+     * @param fallback\n+     *          If fallback is false, the function will throw exception when there are no writable dirs;\n+     *          If it is true and there's no writable dirs, it will ignore the error and pick any dir.\n+     * @return new index file object.\n+     * @throws NoWritableLedgerDirException if there is no writable dir available.\n+     */\n+    private File getNewLedgerIndexFile(Long ledger, File excludedDir, boolean fallback)\n+                    throws NoWritableLedgerDirException {\n+        File dir = null;\n+        try {\n+            dir = ledgerDirsManager.pickRandomWritableDirForNewIndexFile(excludedDir);\n+        } catch (NoWritableLedgerDirException e) {\n+            if (fallback) {\n+                dir = ledgerDirsManager.pickRandomDir(excludedDir);\n+            } else {\n+                throw e;\n+            }\n+        }\n         String ledgerName = getLedgerName(ledger);\n         return new File(dir, ledgerName);\n     }"},{"sha":"e562dcba534cc9f37f220dcbcc7b0f75ef75854b","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDescriptor.java","status":"modified","additions":19,"deletions":1,"changes":20,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/c49621bacaa960d240afbbee83a9703b4cbc3ec2/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLedgerDescriptor.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/c49621bacaa960d240afbbee83a9703b4cbc3ec2/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLedgerDescriptor.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLedgerDescriptor.java?ref=c49621bacaa960d240afbbee83a9703b4cbc3ec2","patch":"@@ -21,17 +21,21 @@\n \n package org.apache.bookkeeper.bookie;\n \n+import com.google.common.util.concurrent.SettableFuture;\n import io.netty.buffer.ByteBuf;\n-\n+import io.netty.buffer.Unpooled;\n import java.io.IOException;\n import java.util.Observable;\n import java.util.Observer;\n \n+import static org.apache.bookkeeper.bookie.Bookie.METAENTRY_ID_FENCE_KEY;\n+\n /**\n  * Implements a ledger inside a bookie. In particular, it implements operations\n  * to write entries to a ledger and read entries from a ledger.\n  */\n public abstract class LedgerDescriptor {\n+\n     static LedgerDescriptor create(byte[] masterKey,\n                                    long ledgerId,\n                                    LedgerStorage ledgerStorage) throws IOException {\n@@ -49,12 +53,26 @@ static LedgerDescriptor createReadOnly(long ledgerId,\n         return new LedgerDescriptorReadOnlyImpl(ledgerId, ledgerStorage);\n     }\n \n+    static ByteBuf createLedgerFenceEntry(Long ledgerId) {\n+        ByteBuf bb = Unpooled.buffer(8 + 8);\n+        bb.writeLong(ledgerId);\n+        bb.writeLong(METAENTRY_ID_FENCE_KEY);\n+        return bb;\n+    }\n+\n     abstract void checkAccess(byte masterKey[]) throws BookieException, IOException;\n \n     abstract long getLedgerId();\n \n     abstract boolean setFenced() throws IOException;\n     abstract boolean isFenced() throws IOException;\n+    /**\n+     * When we fence a ledger, we need to first set ledger to fenced state in memory and\n+     * then log the fence entry in Journal so that we can rebuild the state.\n+     *\n+     * We should satisfy the future only after we complete logging fence entry in Journal\n+     */\n+    abstract SettableFuture<Boolean> fenceAndLogInJournal(Journal journal) throws IOException;\n \n     abstract long addEntry(ByteBuf entry) throws IOException;\n     abstract ByteBuf readEntry(long entryId) throws IOException;"},{"sha":"c48cd7576a28c8a2e5566bcdcadb4eb6daeda047","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDescriptorImpl.java","status":"modified","additions":56,"deletions":2,"changes":58,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/c49621bacaa960d240afbbee83a9703b4cbc3ec2/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLedgerDescriptorImpl.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/c49621bacaa960d240afbbee83a9703b4cbc3ec2/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLedgerDescriptorImpl.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLedgerDescriptorImpl.java?ref=c49621bacaa960d240afbbee83a9703b4cbc3ec2","patch":"@@ -21,11 +21,13 @@\n \n package org.apache.bookkeeper.bookie;\n \n+import com.google.common.util.concurrent.SettableFuture;\n import io.netty.buffer.ByteBuf;\n import java.io.IOException;\n import java.util.Arrays;\n import java.util.Observable;\n import java.util.Observer;\n+import java.util.concurrent.atomic.AtomicBoolean;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -38,10 +40,14 @@ public class LedgerDescriptorImpl extends LedgerDescriptor {\n     private final static Logger LOG = LoggerFactory.getLogger(LedgerDescriptor.class);\n     final LedgerStorage ledgerStorage;\n     private long ledgerId;\n-\n     final byte[] masterKey;\n \n-    LedgerDescriptorImpl(byte[] masterKey, long ledgerId, LedgerStorage ledgerStorage) {\n+    private AtomicBoolean fenceEntryPersisted = new AtomicBoolean();\n+    private SettableFuture<Boolean> logFenceResult = null;\n+\n+    LedgerDescriptorImpl(byte[] masterKey,\n+                         long ledgerId,\n+                         LedgerStorage ledgerStorage) {\n         this.masterKey = masterKey;\n         this.ledgerId = ledgerId;\n         this.ledgerStorage = ledgerStorage;\n@@ -81,6 +87,54 @@ ByteBuf getExplicitLac() {\n         return ledgerStorage.getExplicitLac(ledgerId);\n     }\n \n+    synchronized SettableFuture<Boolean> fenceAndLogInJournal(Journal journal) throws IOException {\n+        boolean success = this.setFenced();\n+        if(success) {\n+            // fenced for first time, we should add the key to journal ensure we can rebuild.\n+            return logFenceEntryInJournal(journal);\n+        } else {\n+            // If we reach here, it means the fence state in FileInfo has been set (may not be persisted yet).\n+            // However, writing the fence log entry to the journal might still be in progress. This can happen\n+            // when a bookie receives two fence requests almost at the same time. The subsequent logic is used\n+            // to check the fencing progress.\n+            if(logFenceResult == null || fenceEntryPersisted.get()){\n+                // Either ledger's fenced state is recovered from Journal\n+                // Or Log fence entry in Journal succeed\n+                SettableFuture<Boolean> result = SettableFuture.create();\n+                result.set(true);\n+                return result;\n+            } else if (logFenceResult.isDone()) {\n+                // We failed to log fence entry in Journal, try again.\n+                return logFenceEntryInJournal(journal);\n+            }\n+            // Fencing is in progress\n+            return logFenceResult;\n+        }\n+    }\n+\n+    /**\n+     * Log the fence ledger entry in Journal so that we can rebuild the state.\n+     * @param journal log the fence entry in the Journal\n+     * @return A future which will be satisfied when add entry to journal complete\n+     */\n+    private SettableFuture<Boolean> logFenceEntryInJournal(Journal journal) {\n+        SettableFuture<Boolean> result;\n+        synchronized (this) {\n+            result = logFenceResult = SettableFuture.create();\n+        }\n+        ByteBuf entry = createLedgerFenceEntry(ledgerId);\n+        journal.logAddEntry(entry, (rc, ledgerId, entryId, addr, ctx) -> {\n+            LOG.debug(\"Record fenced state for ledger {} in journal with rc {}\", ledgerId, rc);\n+            if (rc == 0) {\n+                fenceEntryPersisted.compareAndSet(false, true);\n+                result.set(true);\n+            } else {\n+                result.set(false);\n+            }\n+        }, null);\n+        return result;\n+    }\n+\n     @Override\n     long addEntry(ByteBuf entry) throws IOException {\n         long ledgerId = entry.getLong(entry.readerIndex());"},{"sha":"ad0777e44a89ce315ed884f288b9c16e38e3c2cf","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDirsManager.java","status":"modified","additions":9,"deletions":2,"changes":11,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/c49621bacaa960d240afbbee83a9703b4cbc3ec2/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLedgerDirsManager.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/c49621bacaa960d240afbbee83a9703b4cbc3ec2/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLedgerDirsManager.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLedgerDirsManager.java?ref=c49621bacaa960d240afbbee83a9703b4cbc3ec2","patch":"@@ -325,8 +325,15 @@ File pickRandomWritableDirForNewIndexFile(File excludedDir) throws NoWritableLed\n         }\n         return pickRandomDir(writableDirsForNewIndexFile, excludedDir);\n     }\n-    \n-    File pickRandomDir(List<File> dirs, File excludedDir) throws NoWritableLedgerDirException{\n+\n+    /**\n+     * Return one dir from all dirs, regardless writable or not.\n+     */\n+    File pickRandomDir(File excludedDir) throws NoWritableLedgerDirException {\n+        return pickRandomDir(getAllLedgerDirs(), excludedDir);\n+    }\n+\n+    File pickRandomDir(List<File> dirs, File excludedDir) throws NoWritableLedgerDirException {\n         final int start = rand.nextInt(dirs.size());\n         int idx = start;\n         File candidate = dirs.get(idx);"}]}