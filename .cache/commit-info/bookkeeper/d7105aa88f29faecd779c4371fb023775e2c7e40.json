{"sha":"d7105aa88f29faecd779c4371fb023775e2c7e40","node_id":"MDY6Q29tbWl0NDc4NTkyNTI2OmQ3MTA1YWE4OGYyOWZhZWNkNzc5YzQzNzFmYjAyMzc3NWUyYzdlNDA=","commit":{"author":{"name":"Sijie Guo","email":"sijieg@twitter.com","date":"2016-12-28T23:09:38Z"},"committer":{"name":"Sijie Guo","email":"sijieg@twitter.com","date":"2016-12-29T10:11:40Z"},"message":"DL-159: ReadAhead Improvement (part 2) - New ReadAhead Reader using the LogSegmentEntryReader interface\n\nProvide a new ReadAhead reader using the log segment entry reader interface. It does reading entries in a batch in parallel for batches, rather than reading entries in batch by batch. This would help mitigate the slow bookie problem.\n\nThe core change is the new ReadAheadEntryReader.","tree":{"sha":"7a4090a302f0394ecf4ce199af0887a6bbdfc0bd","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/trees/7a4090a302f0394ecf4ce199af0887a6bbdfc0bd"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/commits/d7105aa88f29faecd779c4371fb023775e2c7e40","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/d7105aa88f29faecd779c4371fb023775e2c7e40","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/d7105aa88f29faecd779c4371fb023775e2c7e40","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/d7105aa88f29faecd779c4371fb023775e2c7e40/comments","author":null,"committer":null,"parents":[{"sha":"e2c6bc0d7faa7b7912a51a7a4ed6e1b9ac5653bf","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/e2c6bc0d7faa7b7912a51a7a4ed6e1b9ac5653bf","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/e2c6bc0d7faa7b7912a51a7a4ed6e1b9ac5653bf"}],"stats":{"total":2537,"additions":2079,"deletions":458},"files":[{"sha":"e3470125a5dfc50c5a5928afa3217cd98309970f","filename":"src/main/java/com/twitter/distributedlog/BKAsyncLogReaderDLSN.java","status":"modified","additions":110,"deletions":88,"changes":198,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d7105aa88f29faecd779c4371fb023775e2c7e40/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FBKAsyncLogReaderDLSN.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d7105aa88f29faecd779c4371fb023775e2c7e40/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FBKAsyncLogReaderDLSN.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FBKAsyncLogReaderDLSN.java?ref=d7105aa88f29faecd779c4371fb023775e2c7e40","patch":"@@ -20,16 +20,15 @@\n import com.google.common.annotations.VisibleForTesting;\n import com.google.common.base.Optional;\n import com.google.common.base.Stopwatch;\n+import com.google.common.base.Ticker;\n import com.twitter.distributedlog.exceptions.DLIllegalStateException;\n import com.twitter.distributedlog.exceptions.DLInterruptedException;\n import com.twitter.distributedlog.exceptions.EndOfStreamException;\n import com.twitter.distributedlog.exceptions.IdleReaderException;\n import com.twitter.distributedlog.exceptions.LogNotFoundException;\n import com.twitter.distributedlog.exceptions.ReadCancelledException;\n import com.twitter.distributedlog.exceptions.UnexpectedException;\n-import com.twitter.distributedlog.injector.AsyncFailureInjector;\n-import com.twitter.distributedlog.injector.AsyncRandomFailureInjector;\n-import com.twitter.distributedlog.util.FutureUtils;\n+import com.twitter.distributedlog.util.Utils;\n import com.twitter.util.Future;\n import com.twitter.util.FutureEventListener;\n import com.twitter.util.Promise;\n@@ -48,10 +47,12 @@\n import org.apache.bookkeeper.stats.Counter;\n import org.apache.bookkeeper.stats.OpStatsLogger;\n import org.apache.bookkeeper.stats.StatsLogger;\n+import org.apache.bookkeeper.versioning.Versioned;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import scala.Function1;\n import scala.runtime.AbstractFunction1;\n+import scala.runtime.BoxedUnit;\n \n /**\n  * BookKeeper based {@link AsyncLogReader} implementation.\n@@ -83,7 +84,7 @@ public LogRecordWithDLSN apply(List<LogRecordWithDLSN> records) {\n             };\n \n     protected final BKDistributedLogManager bkDistributedLogManager;\n-    protected final BKLogReadHandler bkLedgerManager;\n+    protected final BKLogReadHandler readHandler;\n     private final AtomicReference<Throwable> lastException = new AtomicReference<Throwable>();\n     private final ScheduledExecutorService executorService;\n     private final ConcurrentLinkedQueue<PendingReadRequest> pendingRequests = new ConcurrentLinkedQueue<PendingReadRequest>();\n@@ -92,19 +93,19 @@ public LogRecordWithDLSN apply(List<LogRecordWithDLSN> records) {\n     final private Stopwatch scheduleDelayStopwatch;\n     final private Stopwatch readNextDelayStopwatch;\n     private DLSN startDLSN;\n-    private boolean readAheadStarted = false;\n+    private ReadAheadEntryReader readAheadReader = null;\n     private int lastPosition = 0;\n     private final boolean positionGapDetectionEnabled;\n     private final int idleErrorThresholdMillis;\n     final ScheduledFuture<?> idleReaderTimeoutTask;\n     private ScheduledFuture<?> backgroundScheduleTask = null;\n+    // last process time\n+    private final Stopwatch lastProcessTime;\n \n     protected Promise<Void> closeFuture = null;\n \n     private boolean lockStream = false;\n \n-    private boolean disableReadAheadLogSegmentsNotification = false;\n-\n     private final boolean returnEndOfStreamRecord;\n \n     private final Runnable BACKGROUND_READ_SCHEDULER = new Runnable() {\n@@ -122,7 +123,6 @@ public void run() {\n     private LogRecordWithDLSN nextRecord = null;\n \n     // Failure Injector\n-    private final AsyncFailureInjector failureInjector;\n     private boolean disableProcessingReadRequests = false;\n \n     // Stats\n@@ -198,7 +198,7 @@ void addRecord(LogRecordWithDLSN record) {\n \n         void complete() {\n             if (LOG.isTraceEnabled()) {\n-                LOG.trace(\"{} : Satisfied promise with {} records\", bkLedgerManager.getFullyQualifiedName(), records.size());\n+                LOG.trace(\"{} : Satisfied promise with {} records\", readHandler.getFullyQualifiedName(), records.size());\n             }\n             delayUntilPromiseSatisfied.registerSuccessfulEvent(enqueueTime.stop().elapsed(TimeUnit.MICROSECONDS));\n             Stopwatch stopwatch = Stopwatch.createStarted();\n@@ -212,12 +212,11 @@ void complete() {\n                          DLSN startDLSN,\n                          Optional<String> subscriberId,\n                          boolean returnEndOfStreamRecord,\n-                         boolean deserializeRecordSet,\n                          StatsLogger statsLogger) {\n         this.bkDistributedLogManager = bkdlm;\n         this.executorService = executorService;\n-        this.bkLedgerManager = bkDistributedLogManager.createReadHandler(subscriberId,\n-                this, deserializeRecordSet, true);\n+        this.readHandler = bkDistributedLogManager.createReadHandler(subscriberId,\n+                this, true);\n         LOG.debug(\"Starting async reader at {}\", startDLSN);\n         this.startDLSN = startDLSN;\n         this.scheduleDelayStopwatch = Stopwatch.createUnstarted();\n@@ -226,16 +225,6 @@ void complete() {\n         this.idleErrorThresholdMillis = bkdlm.getConf().getReaderIdleErrorThresholdMillis();\n         this.returnEndOfStreamRecord = returnEndOfStreamRecord;\n \n-        // Failure Injection\n-        this.failureInjector = AsyncRandomFailureInjector.newBuilder()\n-                .injectDelays(bkdlm.getConf().getEIInjectReadAheadDelay(),\n-                              bkdlm.getConf().getEIInjectReadAheadDelayPercent(),\n-                              bkdlm.getConf().getEIInjectMaxReadAheadDelayMs())\n-                .injectErrors(false, 10)\n-                .injectStops(bkdlm.getConf().getEIInjectReadAheadStall(), 10)\n-                .injectCorruption(bkdlm.getConf().getEIInjectReadAheadBrokenEntries())\n-                .build();\n-\n         // Stats\n         StatsLogger asyncReaderStatsLogger = statsLogger.scope(\"async_reader\");\n         futureSetLatency = asyncReaderStatsLogger.getOpStatsLogger(\"future_set\");\n@@ -252,6 +241,7 @@ void complete() {\n         // Lock the stream if requested. The lock will be released when the reader is closed.\n         this.lockStream = false;\n         this.idleReaderTimeoutTask = scheduleIdleReaderTaskIfNecessary();\n+        this.lastProcessTime = Stopwatch.createStarted();\n     }\n \n     private ScheduledFuture<?> scheduleIdleReaderTaskIfNecessary() {\n@@ -276,53 +266,60 @@ public void run() {\n                         return;\n                     }\n \n-                    ReadAheadCache cache = bkLedgerManager.getReadAheadCache();\n+                    ReadAheadEntryReader readAheadReader = getReadAheadReader();\n \n                     // read request has been idle\n                     //   - cache has records but read request are idle,\n                     //     that means notification was missed between readahead and reader.\n                     //   - cache is empty and readahead is idle (no records added for a long time)\n                     idleReaderCheckIdleReadAheadCount.inc();\n                     try {\n-                        if (!hasMoreRecords(cache)\n-                                && !cache.isReadAheadIdle(idleErrorThresholdMillis, TimeUnit.MILLISECONDS)) {\n+                        if (null == readAheadReader || (!hasMoreRecords() &&\n+                                readAheadReader.isReaderIdle(idleErrorThresholdMillis, TimeUnit.MILLISECONDS))) {\n+                            markReaderAsIdle();\n                             return;\n+                        } else if (lastProcessTime.elapsed(TimeUnit.MILLISECONDS) > idleErrorThresholdMillis) {\n+                            markReaderAsIdle();;\n                         }\n                     } catch (IOException e) {\n-                        // we encountered exceptions on checking more records\n                         setLastException(e);\n                         return;\n                     }\n-\n-                    idleReaderError.inc();\n-                    IdleReaderException ire = new IdleReaderException(\"Reader on stream \"\n-                            + bkLedgerManager.getFullyQualifiedName()\n-                            + \" is idle for \" + idleErrorThresholdMillis +\" ms\");\n-                    setLastException(ire);\n-                    // cancel all pending reads directly rather than notifying on error\n-                    // because idle reader could happen on idle read requests that usually means something wrong\n-                    // in scheduling reads\n-                    cancelAllPendingReads(ire);\n                 }\n             }, period, period, TimeUnit.MILLISECONDS);\n         }\n-\n         return null;\n     }\n \n+    synchronized ReadAheadEntryReader getReadAheadReader() {\n+        return readAheadReader;\n+    }\n+\n     void cancelIdleReaderTask() {\n         // Do this after we have checked that the reader was not previously closed\n         try {\n             if (null != idleReaderTimeoutTask) {\n                 idleReaderTimeoutTask.cancel(true);\n             }\n         } catch (Exception exc) {\n-            LOG.info(\"{}: Failed to cancel the background idle reader timeout task\", bkLedgerManager.getFullyQualifiedName());\n+            LOG.info(\"{}: Failed to cancel the background idle reader timeout task\", readHandler.getFullyQualifiedName());\n         }\n     }\n \n+    private void markReaderAsIdle() {\n+        idleReaderError.inc();\n+        IdleReaderException ire = new IdleReaderException(\"Reader on stream \"\n+                + readHandler.getFullyQualifiedName()\n+                + \" is idle for \" + idleErrorThresholdMillis +\" ms\");\n+        setLastException(ire);\n+        // cancel all pending reads directly rather than notifying on error\n+        // because idle reader could happen on idle read requests that usually means something wrong\n+        // in scheduling reads\n+        cancelAllPendingReads(ire);\n+    }\n+\n     protected synchronized void setStartDLSN(DLSN fromDLSN) throws UnexpectedException {\n-        if (readAheadStarted) {\n+        if (null != readAheadReader) {\n             throw new UnexpectedException(\"Could't reset from dlsn after reader already starts reading.\");\n         }\n         startDLSN = fromDLSN;\n@@ -335,14 +332,14 @@ public synchronized DLSN getStartDLSN() {\n \n     public Future<Void> lockStream() {\n         this.lockStream = true;\n-        return bkLedgerManager.lockStream();\n+        return readHandler.lockStream();\n     }\n \n     private boolean checkClosedOrInError(String operation) {\n         if (null == lastException.get()) {\n             try {\n-                if (null != bkLedgerManager && null != bkLedgerManager.readAheadWorker) {\n-                    bkLedgerManager.readAheadWorker.checkClosedOrInError();\n+                if (null != readHandler && null != getReadAheadReader()) {\n+                    getReadAheadReader().checkLastException();\n                 }\n \n                 bkDistributedLogManager.checkClosedOrInError(operation);\n@@ -353,7 +350,7 @@ private boolean checkClosedOrInError(String operation) {\n \n         if (lockStream) {\n             try {\n-                bkLedgerManager.checkReadLock();\n+                readHandler.checkReadLock();\n             } catch (IOException ex) {\n                 setLastException(ex);\n             }\n@@ -411,28 +408,44 @@ private synchronized Future<List<LogRecordWithDLSN>> readInternal(int numEntries\n         readNextDelayStopwatch.reset().start();\n         final PendingReadRequest readRequest = new PendingReadRequest(numEntries, deadlineTime, deadlineTimeUnit);\n \n-        if (!readAheadStarted) {\n-            bkLedgerManager.checkLogStreamExists().addEventListener(new FutureEventListener<Void>() {\n-                @Override\n-                public void onSuccess(Void value) {\n-                    try {\n-                        bkLedgerManager.startReadAhead(\n-                                new LedgerReadPosition(getStartDLSN()),\n-                                failureInjector);\n-                        if (disableReadAheadLogSegmentsNotification) {\n-                            bkLedgerManager.disableReadAheadLogSegmentsNotification();\n+        if (null == readAheadReader) {\n+            try {\n+                final ReadAheadEntryReader readAheadEntryReader = this.readAheadReader = new ReadAheadEntryReader(\n+                        getStreamName(),\n+                        getStartDLSN(),\n+                        bkDistributedLogManager.getConf(),\n+                        readHandler,\n+                        bkDistributedLogManager.getReaderEntryStore(),\n+                        bkDistributedLogManager.getScheduler(),\n+                        Ticker.systemTicker(),\n+                        bkDistributedLogManager.alertStatsLogger);\n+                readHandler.checkLogStreamExists().addEventListener(new FutureEventListener<Void>() {\n+                    @Override\n+                    public void onSuccess(Void value) {\n+                        try {\n+                            readHandler.registerListener(readAheadEntryReader);\n+                            readHandler.asyncStartFetchLogSegments()\n+                                    .map(new AbstractFunction1<Versioned<List<LogSegmentMetadata>>, BoxedUnit>() {\n+                                        @Override\n+                                        public BoxedUnit apply(Versioned<List<LogSegmentMetadata>> logSegments) {\n+                                            readAheadEntryReader.addStateChangeNotification(BKAsyncLogReaderDLSN.this);\n+                                            readAheadEntryReader.start(logSegments.getValue());\n+                                            return BoxedUnit.UNIT;\n+                                        }\n+                                    });\n+                        } catch (Exception exc) {\n+                            notifyOnError(exc);\n                         }\n-                    } catch (Exception exc) {\n-                        notifyOnError(exc);\n                     }\n-                }\n \n-                @Override\n-                public void onFailure(Throwable cause) {\n-                    notifyOnError(cause);\n-                }\n-            });\n-            readAheadStarted = true;\n+                    @Override\n+                    public void onFailure(Throwable cause) {\n+                        notifyOnError(cause);\n+                    }\n+                });\n+            } catch (IOException ioe) {\n+                notifyOnError(ioe);\n+            }\n         }\n \n         if (checkClosedOrInError(\"readNext\")) {\n@@ -475,7 +488,7 @@ public Future<Void> asyncClose() {\n                 return closeFuture;\n             }\n             closePromise = closeFuture = new Promise<Void>();\n-            exception = new ReadCancelledException(bkLedgerManager.getFullyQualifiedName(), \"Reader was closed\");\n+            exception = new ReadCancelledException(readHandler.getFullyQualifiedName(), \"Reader was closed\");\n             setLastException(exception);\n         }\n \n@@ -490,7 +503,15 @@ public Future<Void> asyncClose() {\n \n         cancelAllPendingReads(exception);\n \n-        FutureUtils.ignore(bkLedgerManager.asyncClose()).proxyTo(closePromise);\n+        ReadAheadEntryReader readAheadReader = getReadAheadReader();\n+        if (null != readAheadReader) {\n+            readHandler.unregisterListener(readAheadReader);\n+            readAheadReader.removeStateChangeNotification(this);\n+        }\n+        Utils.closeSequence(bkDistributedLogManager.getScheduler(), true,\n+                readAheadReader,\n+                readHandler\n+        ).proxyTo(closePromise);\n         return closePromise;\n     }\n \n@@ -501,25 +522,26 @@ private void cancelAllPendingReads(Throwable throwExc) {\n         pendingRequests.clear();\n     }\n \n-    boolean hasMoreRecords() throws IOException {\n-        return hasMoreRecords(bkLedgerManager.readAheadCache);\n-    }\n-\n-    private synchronized boolean hasMoreRecords(ReadAheadCache cache) throws IOException {\n-        if (cache.getNumCachedEntries() > 0 || null != nextRecord) {\n+    synchronized boolean hasMoreRecords() throws IOException {\n+        if (null == readAheadReader) {\n+            return false;\n+        }\n+        if (readAheadReader.getNumCachedEntries() > 0 || null != nextRecord) {\n             return true;\n         } else if (null != currentEntry) {\n             nextRecord = currentEntry.nextRecord();\n             return null != nextRecord;\n-        } else {\n-            return false;\n         }\n+        return false;\n     }\n \n     private synchronized LogRecordWithDLSN readNextRecord() throws IOException {\n+        if (null == readAheadReader) {\n+            return null;\n+        }\n         if (null == currentEntry) {\n-            currentEntry = bkLedgerManager.getNextReadAheadEntry();\n-            // no current entry after reading from read head then return null\n+            currentEntry = readAheadReader.getNextReadAheadEntry(0L, TimeUnit.MILLISECONDS);\n+            // no entry after reading from read ahead then return null\n             if (null == currentEntry) {\n                 return null;\n             }\n@@ -551,10 +573,10 @@ public void run() {\n             Stopwatch runTime = Stopwatch.createStarted();\n             int iterations = 0;\n             long scheduleCountLocal = scheduleCount.get();\n-            LOG.debug(\"{}: Scheduled Background Reader\", bkLedgerManager.getFullyQualifiedName());\n+            LOG.debug(\"{}: Scheduled Background Reader\", readHandler.getFullyQualifiedName());\n             while(true) {\n                 if (LOG.isTraceEnabled()) {\n-                    LOG.trace(\"{}: Executing Iteration: {}\", bkLedgerManager.getFullyQualifiedName(), iterations++);\n+                    LOG.trace(\"{}: Executing Iteration: {}\", readHandler.getFullyQualifiedName(), iterations++);\n                 }\n \n                 PendingReadRequest nextRequest = null;\n@@ -563,39 +585,40 @@ public void run() {\n \n                     // Queue is empty, nothing to read, return\n                     if (null == nextRequest) {\n-                        LOG.trace(\"{}: Queue Empty waiting for Input\", bkLedgerManager.getFullyQualifiedName());\n+                        LOG.trace(\"{}: Queue Empty waiting for Input\", readHandler.getFullyQualifiedName());\n                         scheduleCount.set(0);\n                         backgroundReaderRunTime.registerSuccessfulEvent(runTime.stop().elapsed(TimeUnit.MICROSECONDS));\n                         return;\n                     }\n \n                     if (disableProcessingReadRequests) {\n-                        LOG.info(\"Reader of {} is forced to stop processing read requests\", bkLedgerManager.getFullyQualifiedName());\n+                        LOG.info(\"Reader of {} is forced to stop processing read requests\", readHandler.getFullyQualifiedName());\n                         return;\n                     }\n                 }\n+                lastProcessTime.reset().start();\n \n                 // If the oldest pending promise is interrupted then we must mark\n                 // the reader in error and abort all pending reads since we dont\n                 // know the last consumed read\n                 if (null == lastException.get()) {\n                     if (nextRequest.getPromise().isInterrupted().isDefined()) {\n-                        setLastException(new DLInterruptedException(\"Interrupted on reading \" + bkLedgerManager.getFullyQualifiedName() + \" : \",\n+                        setLastException(new DLInterruptedException(\"Interrupted on reading \" + readHandler.getFullyQualifiedName() + \" : \",\n                                 nextRequest.getPromise().isInterrupted().get()));\n                     }\n                 }\n \n                 if (checkClosedOrInError(\"readNext\")) {\n                     if (!(lastException.get().getCause() instanceof LogNotFoundException)) {\n-                        LOG.warn(\"{}: Exception\", bkLedgerManager.getFullyQualifiedName(), lastException.get());\n+                        LOG.warn(\"{}: Exception\", readHandler.getFullyQualifiedName(), lastException.get());\n                     }\n                     backgroundReaderRunTime.registerFailedEvent(runTime.stop().elapsed(TimeUnit.MICROSECONDS));\n                     return;\n                 }\n \n                 try {\n                     // Fail 10% of the requests when asked to simulate errors\n-                    if (failureInjector.shouldInjectErrors()) {\n+                    if (bkDistributedLogManager.getFailureInjector().shouldInjectErrors()) {\n                         throw new IOException(\"Reader Simulated Exception\");\n                     }\n                     LogRecordWithDLSN record;\n@@ -609,15 +632,15 @@ public void run() {\n                         } else {\n                             if (record.isEndOfStream() && !returnEndOfStreamRecord) {\n                                 setLastException(new EndOfStreamException(\"End of Stream Reached for \"\n-                                        + bkLedgerManager.getFullyQualifiedName()));\n+                                        + readHandler.getFullyQualifiedName()));\n                                 break;\n                             }\n \n                             // gap detection\n                             if (recordPositionsContainsGap(record, lastPosition)) {\n-                                bkDistributedLogManager.raiseAlert(\"Gap detected between records at dlsn = {}\", record.getDlsn());\n+                                bkDistributedLogManager.raiseAlert(\"Gap detected between records at record = {}\", record);\n                                 if (positionGapDetectionEnabled) {\n-                                    throw new DLIllegalStateException(\"Gap detected between records at dlsn = \" + record.getDlsn());\n+                                    throw new DLIllegalStateException(\"Gap detected between records at record = \" + record);\n                                 }\n                             }\n                             lastPosition = record.getLastPositionWithinLogSegment();\n@@ -628,7 +651,7 @@ public void run() {\n                 } catch (IOException exc) {\n                     setLastException(exc);\n                     if (!(exc instanceof LogNotFoundException)) {\n-                        LOG.warn(\"{} : read with skip Exception\", bkLedgerManager.getFullyQualifiedName(), lastException.get());\n+                        LOG.warn(\"{} : read with skip Exception\", readHandler.getFullyQualifiedName(), lastException.get());\n                     }\n                     continue;\n                 }\n@@ -709,13 +732,12 @@ public void notifyOnOperationComplete() {\n \n     @VisibleForTesting\n     void simulateErrors() {\n-        failureInjector.injectErrors(true);\n+        bkDistributedLogManager.getFailureInjector().injectErrors(true);\n     }\n \n     @VisibleForTesting\n     synchronized void disableReadAheadLogSegmentsNotification() {\n-        disableReadAheadLogSegmentsNotification = true;\n-        bkLedgerManager.disableReadAheadLogSegmentsNotification();\n+        readHandler.disableReadAheadLogSegmentsNotification();\n     }\n \n     @VisibleForTesting"},{"sha":"49637873d43aebd046a26c1716060348812823c6","filename":"src/main/java/com/twitter/distributedlog/BKDistributedLogManager.java","status":"modified","additions":41,"deletions":13,"changes":54,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d7105aa88f29faecd779c4371fb023775e2c7e40/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FBKDistributedLogManager.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d7105aa88f29faecd779c4371fb023775e2c7e40/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FBKDistributedLogManager.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FBKDistributedLogManager.java?ref=d7105aa88f29faecd779c4371fb023775e2c7e40","patch":"@@ -34,6 +34,10 @@\n import com.twitter.distributedlog.exceptions.UnexpectedException;\n import com.twitter.distributedlog.function.CloseAsyncCloseableFunction;\n import com.twitter.distributedlog.function.GetVersionedValueFunction;\n+import com.twitter.distributedlog.impl.logsegment.BKLogSegmentEntryStore;\n+import com.twitter.distributedlog.injector.AsyncFailureInjector;\n+import com.twitter.distributedlog.injector.AsyncRandomFailureInjector;\n+import com.twitter.distributedlog.logsegment.LogSegmentEntryStore;\n import com.twitter.distributedlog.metadata.LogMetadataForReader;\n import com.twitter.distributedlog.metadata.LogMetadataForWriter;\n import com.twitter.distributedlog.impl.metadata.ZKLogStreamMetadataStore;\n@@ -141,7 +145,7 @@ public DLSN apply(LogRecordWithDLSN record) {\n     private final FeatureProvider featureProvider;\n     private final StatsLogger statsLogger;\n     private final StatsLogger perLogStatsLogger;\n-    private final AlertStatsLogger alertStatsLogger;\n+    final AlertStatsLogger alertStatsLogger;\n \n     // log stream metadata stores\n     private final LogStreamMetadataStore writerMetadataStore;\n@@ -159,6 +163,7 @@ public DLSN apply(LogRecordWithDLSN record) {\n     private final boolean ownWriterBKC;\n     private final BookKeeperClientBuilder readerBKCBuilder;\n     private final BookKeeperClient readerBKC;\n+    private LogSegmentEntryStore readerEntryStore = null;\n     private final boolean ownReaderBKC;\n \n     //\n@@ -176,6 +181,9 @@ public DLSN apply(LogRecordWithDLSN record) {\n     private final PendingReaders pendingReaders;\n     private final ReadAheadExceptionsLogger readAheadExceptionsLogger;\n \n+    // Failure Injector\n+    private final AsyncFailureInjector failureInjector;\n+\n     /**\n      * Create a DLM for testing.\n      *\n@@ -303,6 +311,16 @@ public DLSN apply(LogRecordWithDLSN record) {\n         this.ledgerAllocator = ledgerAllocator;\n         this.writeLimiter = writeLimiter;\n \n+        // Failure Injection\n+        this.failureInjector = AsyncRandomFailureInjector.newBuilder()\n+                .injectDelays(conf.getEIInjectReadAheadDelay(),\n+                              conf.getEIInjectReadAheadDelayPercent(),\n+                              conf.getEIInjectMaxReadAheadDelayMs())\n+                .injectErrors(false, 10)\n+                .injectStops(conf.getEIInjectReadAheadStall(), 10)\n+                .injectCorruption(conf.getEIInjectReadAheadBrokenEntries())\n+                .build();\n+\n         if (null == writerMetadataStore) {\n             this.writerMetadataStore = new ZKLogStreamMetadataStore(\n                     clientId,\n@@ -413,6 +431,18 @@ BookKeeperClient getReaderBKC() {\n         return this.readerBKC;\n     }\n \n+    synchronized LogSegmentEntryStore getReaderEntryStore() throws IOException {\n+        if (null == readerEntryStore) {\n+            readerEntryStore = new BKLogSegmentEntryStore(\n+                conf,\n+                readerBKC.get(),\n+                scheduler,\n+                statsLogger,\n+                failureInjector);\n+        }\n+        return this.readerEntryStore;\n+    }\n+\n     @VisibleForTesting\n     FuturePool getReaderFuturePool() {\n         return this.readerFuturePool;\n@@ -423,6 +453,10 @@ FeatureProvider getFeatureProvider() {\n         return this.featureProvider;\n     }\n \n+    AsyncFailureInjector getFailureInjector() {\n+        return this.failureInjector;\n+    }\n+\n     private synchronized BKLogReadHandler getReadHandlerAndRegisterListener(\n             boolean create, LogSegmentListener listener) {\n         if (null == readHandlerForListener && create) {\n@@ -432,7 +466,9 @@ private synchronized BKLogReadHandler getReadHandlerAndRegisterListener(\n             readHandlerForListener.asyncStartFetchLogSegments();\n             return readHandlerForListener;\n         }\n-        readHandlerForListener.registerListener(listener);\n+        if (null != readHandlerForListener && null != listener) {\n+            readHandlerForListener.registerListener(listener);\n+        }\n         return readHandlerForListener;\n     }\n \n@@ -493,13 +529,11 @@ synchronized BKLogReadHandler createReadHandler(Optional<String> subscriberId,\n         return createReadHandler(\n                 subscriberId,\n                 null,\n-                true, /* deserialize record set */\n                 isHandleForReading);\n     }\n \n     synchronized BKLogReadHandler createReadHandler(Optional<String> subscriberId,\n                                                     AsyncNotification notification,\n-                                                    boolean deserializeRecordSet,\n                                                     boolean isHandleForReading) {\n         LogMetadataForReader logMetadata = LogMetadataForReader.of(uri, name, streamIdentifier);\n         return new BKLogReadHandler(\n@@ -511,15 +545,12 @@ synchronized BKLogReadHandler createReadHandler(Optional<String> subscriberId,\n                 readerMetadataStore,\n                 logSegmentMetadataCache,\n                 scheduler,\n-                readAheadScheduler,\n                 alertStatsLogger,\n-                readAheadExceptionsLogger,\n                 statsLogger,\n                 perLogStatsLogger,\n                 clientId,\n                 notification,\n-                isHandleForReading,\n-                deserializeRecordSet);\n+                isHandleForReading);\n     }\n \n     // Create Ledger Allocator\n@@ -930,7 +961,6 @@ public Future<AsyncLogReader> openAsyncLogReader(DLSN fromDLSN) {\n                 fromDLSN,\n                 subscriberId,\n                 false,\n-                dynConf.getDeserializeRecordSetOnReads(),\n                 statsLogger);\n         pendingReaders.add(reader);\n         return Future.value(reader);\n@@ -969,7 +999,6 @@ protected Future<AsyncLogReader> getAsyncLogReaderWithLock(final Optional<DLSN>\n                 fromDLSN.isPresent() ? fromDLSN.get() : DLSN.InitialDLSN,\n                 subscriberId,\n                 false,\n-                dynConf.getDeserializeRecordSetOnReads(),\n                 statsLogger);\n         pendingReaders.add(reader);\n         final Future<Void> lockFuture = reader.lockStream();\n@@ -1046,15 +1075,14 @@ LogReader getInputStreamInternal(long fromTxnId)\n \n     LogReader getInputStreamInternal(DLSN fromDLSN, Optional<Long> fromTxnId)\n             throws IOException {\n-        LOG.info(\"Create async reader starting from {}\", fromDLSN);\n+        LOG.info(\"Create sync reader starting from {}\", fromDLSN);\n         checkClosedOrInError(\"getInputStream\");\n-        LogReader reader = new BKSyncLogReaderDLSN(\n+        return new BKSyncLogReaderDLSN(\n                 conf,\n                 this,\n                 fromDLSN,\n                 fromTxnId,\n                 statsLogger);\n-        return reader;\n     }\n \n     /**"},{"sha":"67c584cf7dd0ed948f19b95c69d9e147992988ad","filename":"src/main/java/com/twitter/distributedlog/BKLogReadHandler.java","status":"modified","additions":2,"deletions":88,"changes":90,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d7105aa88f29faecd779c4371fb023775e2c7e40/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FBKLogReadHandler.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d7105aa88f29faecd779c4371fb023775e2c7e40/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FBKLogReadHandler.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FBKLogReadHandler.java?ref=d7105aa88f29faecd779c4371fb023775e2c7e40","patch":"@@ -26,7 +26,6 @@\n \n import com.google.common.annotations.VisibleForTesting;\n import com.google.common.base.Optional;\n-import com.google.common.base.Ticker;\n import com.twitter.distributedlog.callback.LogSegmentListener;\n import com.twitter.distributedlog.callback.LogSegmentNamesListener;\n import com.twitter.distributedlog.config.DynamicDistributedLogConfiguration;\n@@ -36,14 +35,10 @@\n import com.twitter.distributedlog.exceptions.LogSegmentNotFoundException;\n import com.twitter.distributedlog.exceptions.UnexpectedException;\n import com.twitter.distributedlog.metadata.LogMetadataForReader;\n-import com.twitter.distributedlog.injector.AsyncFailureInjector;\n import com.twitter.distributedlog.lock.DistributedLock;\n import com.twitter.distributedlog.logsegment.LogSegmentFilter;\n import com.twitter.distributedlog.logsegment.LogSegmentMetadataCache;\n import com.twitter.distributedlog.metadata.LogStreamMetadataStore;\n-import com.twitter.distributedlog.readahead.ReadAheadWorker;\n-import com.twitter.distributedlog.stats.BroadCastStatsLogger;\n-import com.twitter.distributedlog.stats.ReadAheadExceptionsLogger;\n import com.twitter.distributedlog.util.FutureUtils;\n import com.twitter.distributedlog.util.OrderedScheduler;\n import com.twitter.distributedlog.util.Utils;\n@@ -111,13 +106,9 @@ class BKLogReadHandler extends BKLogHandler implements LogSegmentNamesListener {\n     static final Logger LOG = LoggerFactory.getLogger(BKLogReadHandler.class);\n \n     protected final LogMetadataForReader logMetadataForReader;\n-    protected final ReadAheadCache readAheadCache;\n     protected final LedgerHandleCache handleCache;\n \n-    protected final OrderedScheduler readAheadExecutor;\n     protected final DynamicDistributedLogConfiguration dynConf;\n-    protected ReadAheadWorker readAheadWorker = null;\n-    private final boolean isHandleForReading;\n \n     private final Optional<String> subscriberId;\n     private DistributedLock readLock;\n@@ -134,10 +125,7 @@ class BKLogReadHandler extends BKLogHandler implements LogSegmentNamesListener {\n             new Versioned<List<LogSegmentMetadata>>(null, Version.NEW);\n \n     // stats\n-    private final AlertStatsLogger alertStatsLogger;\n-    private final StatsLogger handlerStatsLogger;\n     private final StatsLogger perLogStatsLogger;\n-    private final ReadAheadExceptionsLogger readAheadExceptionsLogger;\n \n     /**\n      * Construct a Bookkeeper journal manager.\n@@ -150,15 +138,12 @@ class BKLogReadHandler extends BKLogHandler implements LogSegmentNamesListener {\n                      LogStreamMetadataStore streamMetadataStore,\n                      LogSegmentMetadataCache metadataCache,\n                      OrderedScheduler scheduler,\n-                     OrderedScheduler readAheadExecutor,\n                      AlertStatsLogger alertStatsLogger,\n-                     ReadAheadExceptionsLogger readAheadExceptionsLogger,\n                      StatsLogger statsLogger,\n                      StatsLogger perLogStatsLogger,\n                      String clientId,\n                      AsyncNotification readerStateNotification,\n-                     boolean isHandleForReading,\n-                     boolean deserializeRecordSet) {\n+                     boolean isHandleForReading) {\n         super(logMetadata,\n                 conf,\n                 bkcBuilder,\n@@ -170,30 +155,16 @@ class BKLogReadHandler extends BKLogHandler implements LogSegmentNamesListener {\n                 clientId);\n         this.logMetadataForReader = logMetadata;\n         this.dynConf = dynConf;\n-        this.readAheadExecutor = readAheadExecutor;\n-        this.alertStatsLogger = alertStatsLogger;\n         this.perLogStatsLogger =\n                 isHandleForReading ? perLogStatsLogger : NullStatsLogger.INSTANCE;\n-        this.handlerStatsLogger =\n-                BroadCastStatsLogger.masterslave(this.perLogStatsLogger, statsLogger);\n-        this.readAheadExceptionsLogger = readAheadExceptionsLogger;\n         this.readerStateNotification = readerStateNotification;\n \n         handleCache = LedgerHandleCache.newBuilder()\n                 .bkc(this.bookKeeperClient)\n                 .conf(conf)\n                 .statsLogger(statsLogger)\n                 .build();\n-        readAheadCache = new ReadAheadCache(\n-                getFullyQualifiedName(),\n-                alertStatsLogger,\n-                readerStateNotification,\n-                dynConf.getReadAheadMaxRecords(),\n-                deserializeRecordSet,\n-                Ticker.systemTicker());\n-\n         this.subscriberId = subscriberId;\n-        this.isHandleForReading = isHandleForReading;\n     }\n \n     @VisibleForTesting\n@@ -290,16 +261,10 @@ public Future<Void> asyncClose() {\n             }\n             lockToClose = readLock;\n         }\n-        return Utils.closeSequence(scheduler, readAheadWorker, lockToClose)\n+        return Utils.closeSequence(scheduler, lockToClose)\n                 .flatMap(new AbstractFunction1<Void, Future<Void>>() {\n             @Override\n             public Future<Void> apply(Void result) {\n-                if (null != readAheadCache) {\n-                    readAheadCache.clear();\n-                }\n-                if (null != readAheadWorker) {\n-                    unregisterListener(readAheadWorker);\n-                }\n                 if (null != handleCache) {\n                     handleCache.clear();\n                 }\n@@ -361,57 +326,6 @@ public void onSuccess(Versioned<List<LogSegmentMetadata>> segments) {\n         });\n     }\n \n-    public void startReadAhead(LedgerReadPosition startPosition,\n-                               AsyncFailureInjector failureInjector) {\n-        if (null == readAheadWorker) {\n-            readAheadWorker = new ReadAheadWorker(\n-                    conf,\n-                    dynConf,\n-                    logMetadataForReader,\n-                    this,\n-                    readAheadExecutor,\n-                    handleCache,\n-                    startPosition,\n-                    readAheadCache,\n-                    isHandleForReading,\n-                    readAheadExceptionsLogger,\n-                    handlerStatsLogger,\n-                    perLogStatsLogger,\n-                    alertStatsLogger,\n-                    failureInjector,\n-                    readerStateNotification);\n-            registerListener(readAheadWorker);\n-            // start the readahead worker after the log segments are fetched\n-            asyncStartFetchLogSegments().map(new AbstractFunction1<Versioned<List<LogSegmentMetadata>>, BoxedUnit>() {\n-                @Override\n-                public BoxedUnit apply(Versioned<List<LogSegmentMetadata>> logSegments) {\n-                    readAheadWorker.start(logSegments.getValue());\n-                    return BoxedUnit.UNIT;\n-                }\n-            });\n-        }\n-    }\n-\n-    public boolean isReadAheadCaughtUp() {\n-        return null != readAheadWorker && readAheadWorker.isCaughtUp();\n-    }\n-\n-    public LedgerHandleCache getHandleCache() {\n-        return handleCache;\n-    }\n-\n-    public Entry.Reader getNextReadAheadEntry() throws IOException {\n-        return readAheadCache.getNextReadAheadEntry();\n-    }\n-\n-    public Entry.Reader getNextReadAheadEntry(long waitTime, TimeUnit waitTimeUnit) throws IOException {\n-        return readAheadCache.getNextReadAheadEntry(waitTime, waitTimeUnit);\n-    }\n-\n-    public ReadAheadCache getReadAheadCache() {\n-        return readAheadCache;\n-    }\n-\n     @VisibleForTesting\n     void disableReadAheadLogSegmentsNotification() {\n         logSegmentsNotificationDisabled = true;"},{"sha":"adf49a1c3d0d4bfde36b7b3811b58590b34caa1b","filename":"src/main/java/com/twitter/distributedlog/BKSyncLogReaderDLSN.java","status":"modified","additions":55,"deletions":25,"changes":80,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d7105aa88f29faecd779c4371fb023775e2c7e40/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FBKSyncLogReaderDLSN.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d7105aa88f29faecd779c4371fb023775e2c7e40/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FBKSyncLogReaderDLSN.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FBKSyncLogReaderDLSN.java?ref=d7105aa88f29faecd779c4371fb023775e2c7e40","patch":"@@ -19,14 +19,18 @@\n \n import com.google.common.annotations.VisibleForTesting;\n import com.google.common.base.Optional;\n+import com.google.common.base.Ticker;\n import com.twitter.distributedlog.exceptions.EndOfStreamException;\n import com.twitter.distributedlog.exceptions.IdleReaderException;\n-import com.twitter.distributedlog.injector.AsyncFailureInjector;\n import com.twitter.distributedlog.util.FutureUtils;\n+import com.twitter.distributedlog.util.Utils;\n import com.twitter.util.Future;\n import com.twitter.util.Promise;\n import org.apache.bookkeeper.stats.Counter;\n import org.apache.bookkeeper.stats.StatsLogger;\n+import org.apache.bookkeeper.versioning.Versioned;\n+import scala.runtime.AbstractFunction1;\n+import scala.runtime.BoxedUnit;\n \n import java.io.IOException;\n import java.util.LinkedList;\n@@ -39,6 +43,7 @@\n  */\n class BKSyncLogReaderDLSN implements LogReader, AsyncNotification {\n \n+    private final BKDistributedLogManager bkdlm;\n     private final BKLogReadHandler readHandler;\n     private final AtomicReference<IOException> readerException =\n             new AtomicReference<IOException>(null);\n@@ -48,6 +53,9 @@ class BKSyncLogReaderDLSN implements LogReader, AsyncNotification {\n     private boolean positioned = false;\n     private Entry.Reader currentEntry = null;\n \n+    // readahead reader\n+    ReadAheadEntryReader readAheadReader = null;\n+\n     // idle reader settings\n     private final boolean shouldCheckIdleReader;\n     private final int idleErrorThresholdMillis;\n@@ -59,19 +67,19 @@ class BKSyncLogReaderDLSN implements LogReader, AsyncNotification {\n                         BKDistributedLogManager bkdlm,\n                         DLSN startDLSN,\n                         Optional<Long> startTransactionId,\n-                        StatsLogger statsLogger) {\n+                        StatsLogger statsLogger) throws IOException {\n+        this.bkdlm = bkdlm;\n         this.readHandler = bkdlm.createReadHandler(\n                 Optional.<String>absent(),\n                 this,\n-                conf.getDeserializeRecordSetOnReads(),\n                 true);\n         this.maxReadAheadWaitTime = conf.getReadAheadWaitTime();\n         this.idleErrorThresholdMillis = conf.getReaderIdleErrorThresholdMillis();\n         this.shouldCheckIdleReader = idleErrorThresholdMillis > 0 && idleErrorThresholdMillis < Integer.MAX_VALUE;\n         this.startTransactionId = startTransactionId;\n-        readHandler.startReadAhead(\n-                new LedgerReadPosition(startDLSN),\n-                AsyncFailureInjector.NULL);\n+\n+        // start readahead\n+        startReadAhead(startDLSN);\n         if (!startTransactionId.isPresent()) {\n             positioned = true;\n         }\n@@ -81,32 +89,55 @@ class BKSyncLogReaderDLSN implements LogReader, AsyncNotification {\n         idleReaderError = syncReaderStatsLogger.getCounter(\"idle_reader_error\");\n     }\n \n+    private void startReadAhead(DLSN startDLSN) throws IOException {\n+        readAheadReader = new ReadAheadEntryReader(\n+                    bkdlm.getStreamName(),\n+                    startDLSN,\n+                    bkdlm.getConf(),\n+                    readHandler,\n+                    bkdlm.getReaderEntryStore(),\n+                    bkdlm.getScheduler(),\n+                    Ticker.systemTicker(),\n+                    bkdlm.alertStatsLogger);\n+        readHandler.registerListener(readAheadReader);\n+        readHandler.asyncStartFetchLogSegments()\n+                .map(new AbstractFunction1<Versioned<List<LogSegmentMetadata>>, BoxedUnit>() {\n+                    @Override\n+                    public BoxedUnit apply(Versioned<List<LogSegmentMetadata>> logSegments) {\n+                        readAheadReader.addStateChangeNotification(BKSyncLogReaderDLSN.this);\n+                        readAheadReader.start(logSegments.getValue());\n+                        return BoxedUnit.UNIT;\n+                    }\n+                });\n+    }\n+\n+    @VisibleForTesting\n+    ReadAheadEntryReader getReadAheadReader() {\n+        return readAheadReader;\n+    }\n+\n     @VisibleForTesting\n     BKLogReadHandler getReadHandler() {\n         return readHandler;\n     }\n \n-    // reader is still catching up, waiting for next record\n-\n     private Entry.Reader readNextEntry(boolean nonBlocking) throws IOException {\n         Entry.Reader entry = null;\n         if (nonBlocking) {\n-            return readHandler.getNextReadAheadEntry();\n+            return readAheadReader.getNextReadAheadEntry(0L, TimeUnit.MILLISECONDS);\n         } else {\n-            while (!readHandler.isReadAheadCaughtUp()\n+            while (!readAheadReader.isReadAheadCaughtUp()\n                     && null == readerException.get()\n                     && null == entry) {\n-                entry = readHandler.getNextReadAheadEntry(maxReadAheadWaitTime,\n-                        TimeUnit.MILLISECONDS);\n+                entry = readAheadReader.getNextReadAheadEntry(maxReadAheadWaitTime, TimeUnit.MILLISECONDS);\n             }\n             if (null != entry) {\n                 return entry;\n             }\n             // reader is caught up\n-            if (readHandler.isReadAheadCaughtUp()\n+            if (readAheadReader.isReadAheadCaughtUp()\n                     && null == readerException.get()) {\n-                entry = readHandler.getNextReadAheadEntry(maxReadAheadWaitTime,\n-                        TimeUnit.MILLISECONDS);\n+                entry = readAheadReader.getNextReadAheadEntry(maxReadAheadWaitTime, TimeUnit.MILLISECONDS);\n             }\n             return entry;\n         }\n@@ -121,30 +152,24 @@ private void markReaderAsIdle() throws IdleReaderException {\n         throw ire;\n     }\n \n-\n     @Override\n     public synchronized LogRecordWithDLSN readNext(boolean nonBlocking)\n             throws IOException {\n         if (null != readerException.get()) {\n             throw readerException.get();\n         }\n-\n         LogRecordWithDLSN record = doReadNext(nonBlocking);\n-\n         // no record is returned, check if the reader becomes idle\n         if (null == record && shouldCheckIdleReader) {\n-            ReadAheadCache cache = readHandler.getReadAheadCache();\n-            if (cache.getNumCachedEntries() <= 0 &&\n-                    cache.isReadAheadIdle(idleErrorThresholdMillis, TimeUnit.MILLISECONDS)) {\n+            if (readAheadReader.getNumCachedEntries() <= 0 &&\n+                    readAheadReader.isReaderIdle(idleErrorThresholdMillis, TimeUnit.MILLISECONDS)) {\n                 markReaderAsIdle();\n             }\n         }\n-\n         return record;\n     }\n \n-    private synchronized LogRecordWithDLSN doReadNext(boolean nonBlocking)\n-            throws IOException {\n+    private LogRecordWithDLSN doReadNext(boolean nonBlocking) throws IOException {\n         LogRecordWithDLSN record = null;\n \n         do {\n@@ -217,7 +242,12 @@ public Future<Void> asyncClose() {\n             }\n             closeFuture = closePromise = new Promise<Void>();\n         }\n-        readHandler.asyncClose().proxyTo(closePromise);\n+        readHandler.unregisterListener(readAheadReader);\n+        readAheadReader.removeStateChangeNotification(this);\n+        Utils.closeSequence(bkdlm.getScheduler(), true,\n+                readAheadReader,\n+                readHandler\n+        ).proxyTo(closePromise);\n         return closePromise;\n     }\n "},{"sha":"bf315fc2149a9f54c8ebbcc5ddcb837c49e6ab99","filename":"src/main/java/com/twitter/distributedlog/Entry.java","status":"modified","additions":14,"deletions":0,"changes":14,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d7105aa88f29faecd779c4371fb023775e2c7e40/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FEntry.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d7105aa88f29faecd779c4371fb023775e2c7e40/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FEntry.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FEntry.java?ref=d7105aa88f29faecd779c4371fb023775e2c7e40","patch":"@@ -357,6 +357,20 @@ void writeRecord(LogRecord record, Promise<DLSN> transmitPromise)\n      */\n     public interface Reader {\n \n+        /**\n+         * Get the log segment sequence number.\n+         *\n+         * @return the log segment sequence number.\n+         */\n+        long getLSSN();\n+\n+        /**\n+         * Return the entry id.\n+         *\n+         * @return the entry id.\n+         */\n+        long getEntryId();\n+\n         /**\n          * Read next log record from this record set.\n          *"},{"sha":"0a15d29e95f17db9182303b5d57ec35db02e1301","filename":"src/main/java/com/twitter/distributedlog/EntryPosition.java","status":"added","additions":63,"deletions":0,"changes":63,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d7105aa88f29faecd779c4371fb023775e2c7e40/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FEntryPosition.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d7105aa88f29faecd779c4371fb023775e2c7e40/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FEntryPosition.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FEntryPosition.java?ref=d7105aa88f29faecd779c4371fb023775e2c7e40","patch":"@@ -0,0 +1,63 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.twitter.distributedlog;\n+\n+/**\n+ * The position of an entry, identified by log segment sequence number and entry id.\n+ */\n+class EntryPosition {\n+\n+    private long lssn;\n+    private long entryId;\n+\n+    EntryPosition(long lssn, long entryId) {\n+        this.lssn = lssn;\n+        this.entryId = entryId;\n+    }\n+\n+    public synchronized long getLogSegmentSequenceNumber() {\n+        return lssn;\n+    }\n+\n+    public synchronized long getEntryId() {\n+        return entryId;\n+    }\n+\n+    public synchronized boolean advance(long lssn, long entryId) {\n+        if (lssn == this.lssn) {\n+            if (entryId <= this.entryId) {\n+                return false;\n+            }\n+            this.entryId = entryId;\n+            return true;\n+        } else if (lssn > this.lssn) {\n+            this.lssn = lssn;\n+            this.entryId = entryId;\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(\"(\").append(lssn).append(\", \").append(entryId).append(\")\");\n+        return sb.toString();\n+    }\n+}"},{"sha":"038bb180e5271da8f6142ed382985bbd7de30f51","filename":"src/main/java/com/twitter/distributedlog/EnvelopedEntryReader.java","status":"modified","additions":10,"deletions":0,"changes":10,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d7105aa88f29faecd779c4371fb023775e2c7e40/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FEnvelopedEntryReader.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d7105aa88f29faecd779c4371fb023775e2c7e40/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FEnvelopedEntryReader.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FEnvelopedEntryReader.java?ref=d7105aa88f29faecd779c4371fb023775e2c7e40","patch":"@@ -56,6 +56,16 @@ class EnvelopedEntryReader implements Entry.Reader, RecordStream {\n                 deserializeRecordSet);\n     }\n \n+    @Override\n+    public long getLSSN() {\n+        return logSegmentSeqNo;\n+    }\n+\n+    @Override\n+    public long getEntryId() {\n+        return entryId;\n+    }\n+\n     @Override\n     public LogRecordWithDLSN nextRecord() throws IOException {\n         return reader.readOp();"},{"sha":"c3948df0863ac9b2d06d86cb3d21ad9a6797ec3e","filename":"src/main/java/com/twitter/distributedlog/MaxTxId.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d7105aa88f29faecd779c4371fb023775e2c7e40/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FMaxTxId.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d7105aa88f29faecd779c4371fb023775e2c7e40/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FMaxTxId.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FMaxTxId.java?ref=d7105aa88f29faecd779c4371fb023775e2c7e40","patch":"@@ -66,7 +66,7 @@ synchronized long get() {\n     }\n \n     public Versioned<Long> getVersionedData(long txId) {\n-        return new Versioned<Long>(Math.max(txId, currentMax), version);\n+        return new Versioned<Long>(Math.max(txId, get()), version);\n     }\n \n }"},{"sha":"94e618a1f656c685134d0fc07ad8dbc2f31a7042","filename":"src/main/java/com/twitter/distributedlog/ReadAheadEntryReader.java","status":"added","additions":966,"deletions":0,"changes":966,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d7105aa88f29faecd779c4371fb023775e2c7e40/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FReadAheadEntryReader.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d7105aa88f29faecd779c4371fb023775e2c7e40/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FReadAheadEntryReader.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FReadAheadEntryReader.java?ref=d7105aa88f29faecd779c4371fb023775e2c7e40","patch":"@@ -0,0 +1,966 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.twitter.distributedlog;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+import com.google.common.base.Ticker;\n+import com.google.common.collect.Lists;\n+import com.twitter.distributedlog.callback.LogSegmentListener;\n+import com.twitter.distributedlog.exceptions.AlreadyTruncatedTransactionException;\n+import com.twitter.distributedlog.exceptions.DLIllegalStateException;\n+import com.twitter.distributedlog.exceptions.DLInterruptedException;\n+import com.twitter.distributedlog.exceptions.EndOfLogSegmentException;\n+import com.twitter.distributedlog.exceptions.LogNotFoundException;\n+import com.twitter.distributedlog.exceptions.UnexpectedException;\n+import com.twitter.distributedlog.io.AsyncCloseable;\n+import com.twitter.distributedlog.logsegment.LogSegmentEntryReader;\n+import com.twitter.distributedlog.logsegment.LogSegmentEntryStore;\n+import com.twitter.distributedlog.logsegment.LogSegmentFilter;\n+import com.twitter.distributedlog.util.OrderedScheduler;\n+import com.twitter.util.Function0;\n+import com.twitter.util.Future;\n+import com.twitter.util.FutureEventListener;\n+import com.twitter.util.Futures;\n+import com.twitter.util.Promise;\n+import org.apache.bookkeeper.stats.AlertStatsLogger;\n+import org.apache.bookkeeper.versioning.Versioned;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import scala.Function1;\n+import scala.runtime.AbstractFunction1;\n+import scala.runtime.BoxedUnit;\n+\n+import java.io.IOException;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.RejectedExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * New ReadAhead Reader that uses {@link com.twitter.distributedlog.logsegment.LogSegmentEntryReader}.\n+ *\n+ * NOTE: all the state changes happen in the same thread. All *unsafe* methods should be submitted to the order\n+ * scheduler using stream name as the key.\n+ */\n+public class ReadAheadEntryReader implements\n+        AsyncCloseable,\n+        LogSegmentListener,\n+        FutureEventListener<List<Entry.Reader>> {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(ReadAheadEntryReader.class);\n+\n+    //\n+    // Static Functions\n+    //\n+\n+    private static AbstractFunction1<LogSegmentEntryReader, BoxedUnit> START_READER_FUNC = new AbstractFunction1<LogSegmentEntryReader, BoxedUnit>() {\n+        @Override\n+        public BoxedUnit apply(LogSegmentEntryReader reader) {\n+            reader.start();\n+            return BoxedUnit.UNIT;\n+        }\n+    };\n+\n+    //\n+    // Internal Classes\n+    //\n+\n+    class SegmentReader implements FutureEventListener<LogSegmentEntryReader> {\n+\n+        private LogSegmentMetadata metadata;\n+        private final long startEntryId;\n+        private Future<LogSegmentEntryReader> openFuture = null;\n+        private LogSegmentEntryReader reader = null;\n+        private boolean isStarted = false;\n+        private boolean isClosed = false;\n+\n+        SegmentReader(LogSegmentMetadata metadata,\n+                      long startEntryId) {\n+            this.metadata = metadata;\n+            this.startEntryId = startEntryId;\n+        }\n+\n+        synchronized LogSegmentEntryReader getEntryReader() {\n+            return reader;\n+        }\n+\n+        synchronized boolean isBeyondLastAddConfirmed() {\n+            return null != reader && reader.isBeyondLastAddConfirmed();\n+        }\n+\n+        synchronized LogSegmentMetadata getSegment() {\n+            return metadata;\n+        }\n+\n+        synchronized boolean isReaderOpen() {\n+            return null != openFuture;\n+        }\n+\n+        synchronized void openReader() {\n+            if (null != openFuture) {\n+                return;\n+            }\n+            openFuture = entryStore.openReader(metadata, startEntryId).addEventListener(this);\n+        }\n+\n+        synchronized boolean isReaderStarted() {\n+            return isStarted;\n+        }\n+\n+        synchronized void startRead() {\n+            if (isStarted) {\n+                return;\n+            }\n+            isStarted = true;\n+            if (null != reader) {\n+                reader.start();\n+            } else {\n+                openFuture.onSuccess(START_READER_FUNC);\n+            }\n+        }\n+\n+        synchronized Future<List<Entry.Reader>> readNext() {\n+            if (null != reader) {\n+                checkCatchingUpStatus(reader);\n+                return reader.readNext(numReadAheadEntries);\n+            } else {\n+                return openFuture.flatMap(readFunc);\n+            }\n+        }\n+\n+        synchronized void updateLogSegmentMetadata(final LogSegmentMetadata segment) {\n+            if (null != reader) {\n+                reader.onLogSegmentMetadataUpdated(segment);\n+                this.metadata = segment;\n+            } else {\n+                openFuture.onSuccess(new AbstractFunction1<LogSegmentEntryReader, BoxedUnit>() {\n+                    @Override\n+                    public BoxedUnit apply(LogSegmentEntryReader reader) {\n+                        reader.onLogSegmentMetadataUpdated(segment);\n+                        synchronized (SegmentReader.this) {\n+                            SegmentReader.this.metadata = segment;\n+                        }\n+                        return BoxedUnit.UNIT;\n+                    }\n+                });\n+            }\n+        }\n+\n+        @Override\n+        synchronized public void onSuccess(LogSegmentEntryReader reader) {\n+            this.reader = reader;\n+        }\n+\n+        @Override\n+        public void onFailure(Throwable cause) {\n+            // no-op, the failure will be propagated on first read.\n+        }\n+\n+        synchronized boolean isClosed() {\n+            return isClosed;\n+        }\n+\n+        synchronized Future<Void> close() {\n+            if (null == openFuture) {\n+                return Future.Void();\n+            }\n+            return openFuture.flatMap(new AbstractFunction1<LogSegmentEntryReader, Future<Void>>() {\n+                @Override\n+                public Future<Void> apply(LogSegmentEntryReader reader) {\n+                    return reader.asyncClose();\n+                }\n+            }).ensure(new Function0<BoxedUnit>() {\n+                @Override\n+                public BoxedUnit apply() {\n+                    synchronized (SegmentReader.this) {\n+                        isClosed = true;\n+                    }\n+                    return null;\n+                }\n+            });\n+        }\n+    }\n+\n+    private class ReadEntriesFunc extends AbstractFunction1<LogSegmentEntryReader, Future<List<Entry.Reader>>> {\n+\n+        private final int numEntries;\n+\n+        ReadEntriesFunc(int numEntries) {\n+            this.numEntries = numEntries;\n+        }\n+\n+        @Override\n+        public Future<List<Entry.Reader>> apply(LogSegmentEntryReader reader) {\n+            checkCatchingUpStatus(reader);\n+            return reader.readNext(numEntries);\n+        }\n+    }\n+\n+    private abstract class CloseableRunnable implements Runnable {\n+\n+        @Override\n+        public void run() {\n+            synchronized (ReadAheadEntryReader.this) {\n+                if (null != closePromise) {\n+                    return;\n+                }\n+                safeRun();\n+            }\n+\n+        }\n+\n+        abstract void safeRun();\n+\n+    }\n+\n+    //\n+    // Functions\n+    //\n+    private final Function1<LogSegmentEntryReader, Future<List<Entry.Reader>>> readFunc;\n+    private final Function0<BoxedUnit> removeClosedSegmentReadersFunc = new Function0<BoxedUnit>() {\n+        @Override\n+        public BoxedUnit apply() {\n+            removeClosedSegmentReaders();\n+            return BoxedUnit.UNIT;\n+        }\n+    };\n+\n+    //\n+    // Resources\n+    //\n+    private final DistributedLogConfiguration conf;\n+    private final BKLogReadHandler readHandler;\n+    private final LogSegmentEntryStore entryStore;\n+    private final OrderedScheduler scheduler;\n+\n+    //\n+    // Parameters\n+    //\n+    private final String streamName;\n+    private final DLSN fromDLSN;\n+    private final int maxCachedEntries;\n+    private final int numReadAheadEntries;\n+    private final int idleWarnThresholdMillis;\n+\n+    //\n+    // Cache\n+    //\n+    private final LinkedBlockingQueue<Entry.Reader> entryQueue;\n+\n+    //\n+    // State of the reader\n+    //\n+\n+    private boolean isInitialized;\n+    private boolean readAheadPaused = false;\n+    private Promise<Void> closePromise = null;\n+    // segment readers\n+    private long currentSegmentSequenceNumber;\n+    private SegmentReader currentSegmentReader;\n+    private SegmentReader nextSegmentReader;\n+    private DLSN lastDLSN;\n+    private final EntryPosition nextEntryPosition;\n+    private volatile boolean isCatchingUp = true;\n+    private final LinkedList<SegmentReader> segmentReaders;\n+    private final LinkedList<SegmentReader> segmentReadersToClose;\n+    // last exception that this reader encounters\n+    private final AtomicReference<IOException> lastException = new AtomicReference<IOException>(null);\n+    // last entry added time\n+    private final Stopwatch lastEntryAddedTime;\n+    // state change notification\n+    private final CopyOnWriteArraySet<AsyncNotification> stateChangeNotifications =\n+            new CopyOnWriteArraySet<AsyncNotification>();\n+    // idle reader check task\n+    private final ScheduledFuture<?> idleReaderCheckTask;\n+\n+    //\n+    // Stats\n+    //\n+    private final AlertStatsLogger alertStatsLogger;\n+\n+    public ReadAheadEntryReader(String streamName,\n+                                DLSN fromDLSN,\n+                                DistributedLogConfiguration conf,\n+                                BKLogReadHandler readHandler,\n+                                LogSegmentEntryStore entryStore,\n+                                OrderedScheduler scheduler,\n+                                Ticker ticker,\n+                                AlertStatsLogger alertStatsLogger) {\n+        this.streamName = streamName;\n+        this.fromDLSN = lastDLSN = fromDLSN;\n+        this.nextEntryPosition = new EntryPosition(\n+                fromDLSN.getLogSegmentSequenceNo(),\n+                fromDLSN.getEntryId());\n+        this.conf = conf;\n+        this.maxCachedEntries = conf.getReadAheadMaxRecords();\n+        this.numReadAheadEntries = conf.getReadAheadBatchSize();\n+        this.idleWarnThresholdMillis = conf.getReaderIdleWarnThresholdMillis();\n+        this.readHandler = readHandler;\n+        this.entryStore = entryStore;\n+        this.scheduler = scheduler;\n+        this.readFunc = new ReadEntriesFunc(numReadAheadEntries);\n+        this.alertStatsLogger = alertStatsLogger;\n+\n+        // create the segment reader list\n+        this.segmentReaders = new LinkedList<SegmentReader>();\n+        this.segmentReadersToClose = new LinkedList<SegmentReader>();\n+        // create the readahead entry queue\n+        this.entryQueue = new LinkedBlockingQueue<Entry.Reader>();\n+\n+        // start the idle reader detection\n+        lastEntryAddedTime = Stopwatch.createStarted(ticker);\n+        // start the idle reader check task\n+        idleReaderCheckTask = scheduleIdleReaderTaskIfNecessary();\n+    }\n+\n+    private ScheduledFuture<?> scheduleIdleReaderTaskIfNecessary() {\n+        if (idleWarnThresholdMillis < Integer.MAX_VALUE && idleWarnThresholdMillis > 0) {\n+            return scheduler.scheduleAtFixedRate(streamName, new Runnable() {\n+                @Override\n+                public void run() {\n+                    if (!isReaderIdle(idleWarnThresholdMillis, TimeUnit.MILLISECONDS)) {\n+                        return;\n+                    }\n+                    // the readahead has been idle\n+                    unsafeCheckIfReadAheadIsIdle();\n+                }\n+            }, idleWarnThresholdMillis, idleWarnThresholdMillis, TimeUnit.MILLISECONDS);\n+        }\n+        return null;\n+    }\n+\n+    private void unsafeCheckIfReadAheadIsIdle() {\n+        boolean forceReadLogSegments =\n+                (null == currentSegmentReader) || currentSegmentReader.isBeyondLastAddConfirmed();\n+        if (forceReadLogSegments) {\n+            readHandler.readLogSegmentsFromStore(\n+                    LogSegmentMetadata.COMPARATOR,\n+                    LogSegmentFilter.DEFAULT_FILTER,\n+                    null\n+            ).addEventListener(new FutureEventListener<Versioned<List<LogSegmentMetadata>>>() {\n+                @Override\n+                public void onFailure(Throwable cause) {\n+                    // do nothing here since it would be retried on next idle reader check task\n+                }\n+\n+                @Override\n+                public void onSuccess(Versioned<List<LogSegmentMetadata>> segments) {\n+                    onSegmentsUpdated(segments.getValue());\n+                }\n+            });\n+        }\n+    }\n+\n+    private void cancelIdleReaderTask() {\n+        if (null != idleReaderCheckTask) {\n+            idleReaderCheckTask.cancel(true);\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    EntryPosition getNextEntryPosition() {\n+        return nextEntryPosition;\n+    }\n+\n+    @VisibleForTesting\n+    SegmentReader getCurrentSegmentReader() {\n+        return currentSegmentReader;\n+    }\n+\n+    @VisibleForTesting\n+    long getCurrentSegmentSequenceNumber() {\n+        return currentSegmentSequenceNumber;\n+    }\n+\n+    @VisibleForTesting\n+    SegmentReader getNextSegmentReader() {\n+        return nextSegmentReader;\n+    }\n+\n+    @VisibleForTesting\n+    LinkedList<SegmentReader> getSegmentReaders() {\n+        return segmentReaders;\n+    }\n+\n+    @VisibleForTesting\n+    boolean isInitialized() {\n+        return isInitialized;\n+    }\n+\n+    private void orderedSubmit(Runnable runnable) {\n+        synchronized (this) {\n+            if (null != closePromise) {\n+                return;\n+            }\n+        }\n+        try {\n+            scheduler.submit(streamName, runnable);\n+        } catch (RejectedExecutionException ree) {\n+            logger.debug(\"Failed to submit and execute an operation for readhead entry reader of {}\",\n+                    streamName, ree);\n+        }\n+    }\n+\n+    public void start(final List<LogSegmentMetadata> segmentList) {\n+        logger.info(\"Starting the readahead entry reader for {} : segments = {}\",\n+                readHandler.getFullyQualifiedName(), segmentList);\n+        processLogSegments(segmentList);\n+    }\n+\n+    private void removeClosedSegmentReaders() {\n+        orderedSubmit(new CloseableRunnable() {\n+            @Override\n+            void safeRun() {\n+                unsafeRemoveClosedSegmentReaders();\n+            }\n+        });\n+    }\n+\n+    private void unsafeRemoveClosedSegmentReaders() {\n+        SegmentReader reader = segmentReadersToClose.peekFirst();\n+        while (null != reader) {\n+            if (reader.isClosed()) {\n+                segmentReadersToClose.pollFirst();\n+                reader = segmentReadersToClose.peekFirst();\n+            } else {\n+                break;\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public Future<Void> asyncClose() {\n+        final Promise<Void> closeFuture;\n+        synchronized (this) {\n+            if (null != closePromise) {\n+                return closePromise;\n+            }\n+            closePromise = closeFuture = new Promise<Void>();\n+        }\n+\n+        // cancel the idle reader task\n+        cancelIdleReaderTask();\n+\n+        // use runnable here instead of CloseableRunnable,\n+        // because we need this to be executed\n+        try {\n+            scheduler.submit(streamName, new Runnable() {\n+                @Override\n+                public void run() {\n+                    unsafeAsyncClose(closeFuture);\n+                }\n+            });\n+        } catch (RejectedExecutionException ree) {\n+            logger.warn(\"Scheduler has been shutdown before closing the readahead entry reader for stream {}\",\n+                    streamName, ree);\n+            unsafeAsyncClose(closeFuture);\n+        }\n+\n+        return closeFuture;\n+    }\n+\n+    private void unsafeAsyncClose(Promise<Void> closePromise) {\n+        List<Future<Void>> closeFutures = Lists.newArrayListWithExpectedSize(\n+                segmentReaders.size() + segmentReadersToClose.size() + 1);\n+        if (null != currentSegmentReader) {\n+            segmentReadersToClose.add(currentSegmentReader);\n+        }\n+        if (null != nextSegmentReader) {\n+            segmentReadersToClose.add(nextSegmentReader);\n+        }\n+        for (SegmentReader reader : segmentReaders) {\n+            segmentReadersToClose.add(reader);\n+        }\n+        segmentReaders.clear();\n+        for (SegmentReader reader : segmentReadersToClose) {\n+            closeFutures.add(reader.close());\n+        }\n+        Futures.collect(closeFutures).proxyTo(closePromise);\n+    }\n+\n+    //\n+    // Reader State Changes\n+    //\n+\n+    ReadAheadEntryReader addStateChangeNotification(AsyncNotification notification) {\n+        this.stateChangeNotifications.add(notification);\n+        return this;\n+    }\n+\n+    ReadAheadEntryReader removeStateChangeNotification(AsyncNotification notification) {\n+        this.stateChangeNotifications.remove(notification);\n+        return this;\n+    }\n+\n+    private void notifyStateChangeOnSuccess() {\n+        for (AsyncNotification notification : stateChangeNotifications) {\n+            notification.notifyOnOperationComplete();\n+        }\n+    }\n+\n+    private void notifyStateChangeOnFailure(Throwable cause) {\n+        for (AsyncNotification notification : stateChangeNotifications) {\n+            notification.notifyOnError(cause);\n+        }\n+    }\n+\n+    void setLastException(IOException cause) {\n+        if (!lastException.compareAndSet(null, cause)) {\n+            return;\n+        }\n+        // the exception is set and notify the state change\n+        notifyStateChangeOnFailure(cause);\n+    }\n+\n+    void checkLastException() throws IOException {\n+        if (null != lastException.get()) {\n+            throw lastException.get();\n+        }\n+    }\n+\n+    void checkCatchingUpStatus(LogSegmentEntryReader reader) {\n+        if (reader.getSegment().isInProgress()\n+                && isCatchingUp\n+                && reader.hasCaughtUpOnInprogress()) {\n+            logger.info(\"ReadAhead for {} is caught up at entry {} @ log segment {}.\",\n+                    new Object[] { readHandler.getFullyQualifiedName(),\n+                            reader.getLastAddConfirmed(), reader.getSegment() });\n+            isCatchingUp = false;\n+        }\n+    }\n+\n+    public boolean isReadAheadCaughtUp() {\n+        return !isCatchingUp;\n+    }\n+\n+    //\n+    // ReadAhead State Machine\n+    //\n+\n+    @Override\n+    public void onSuccess(List<Entry.Reader> entries) {\n+        lastEntryAddedTime.reset().start();\n+        for (Entry.Reader entry : entries) {\n+            entryQueue.add(entry);\n+        }\n+        if (!entries.isEmpty()) {\n+            Entry.Reader lastEntry = entries.get(entries.size() - 1);\n+            nextEntryPosition.advance(lastEntry.getLSSN(), lastEntry.getEntryId() + 1);\n+        }\n+        // notify on data available\n+        notifyStateChangeOnSuccess();\n+        if (entryQueue.size() >= maxCachedEntries) {\n+            pauseReadAheadOnCacheFull();\n+        } else {\n+            scheduleReadNext();\n+        }\n+    }\n+\n+    @Override\n+    public void onFailure(Throwable cause) {\n+        if (cause instanceof EndOfLogSegmentException) {\n+            // we reach end of the log segment\n+            moveToNextLogSegment();\n+            return;\n+        }\n+        if (cause instanceof IOException) {\n+            setLastException((IOException) cause);\n+        } else {\n+            setLastException(new UnexpectedException(\"Unexpected non I/O exception\", cause));\n+        }\n+    }\n+\n+    private synchronized void invokeReadAhead() {\n+        if (readAheadPaused) {\n+            scheduleReadNext();\n+            readAheadPaused = false;\n+        }\n+    }\n+\n+    private synchronized void pauseReadAheadOnCacheFull() {\n+        this.readAheadPaused = true;\n+        if (!isCacheFull()) {\n+            invokeReadAhead();\n+        }\n+    }\n+\n+    private synchronized void pauseReadAheadOnNoMoreLogSegments() {\n+        this.readAheadPaused = true;\n+    }\n+\n+    //\n+    // Cache Related Methods\n+    //\n+\n+    public Entry.Reader getNextReadAheadEntry(long waitTime, TimeUnit waitTimeUnit) throws IOException {\n+        if (null != lastException.get()) {\n+            throw lastException.get();\n+        }\n+        Entry.Reader entry;\n+        try {\n+            entry = entryQueue.poll(waitTime, waitTimeUnit);\n+        } catch (InterruptedException e) {\n+            throw new DLInterruptedException(\"Interrupted on waiting next readahead entry : \", e);\n+        }\n+        try {\n+            return entry;\n+        } finally {\n+            // resume readahead if the cache becomes empty\n+            if (null != entry && !isCacheFull()) {\n+                invokeReadAhead();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Return number cached entries.\n+     *\n+     * @return number cached entries.\n+     */\n+    public int getNumCachedEntries() {\n+        return entryQueue.size();\n+    }\n+\n+    /**\n+     * Return if the cache is full.\n+     *\n+     * @return true if the cache is full, otherwise false.\n+     */\n+    public boolean isCacheFull() {\n+        return getNumCachedEntries() >= maxCachedEntries;\n+    }\n+\n+    @VisibleForTesting\n+    public boolean isCacheEmpty() {\n+        return entryQueue.isEmpty();\n+    }\n+\n+    /**\n+     * Check whether the readahead becomes stall.\n+     *\n+     * @param idleReaderErrorThreshold idle reader error threshold\n+     * @param timeUnit time unit of the idle reader error threshold\n+     * @return true if the readahead becomes stall, otherwise false.\n+     */\n+    public boolean isReaderIdle(int idleReaderErrorThreshold, TimeUnit timeUnit) {\n+        return (lastEntryAddedTime.elapsed(timeUnit) > idleReaderErrorThreshold);\n+    }\n+\n+    //\n+    // LogSegment Management\n+    //\n+\n+    void processLogSegments(final List<LogSegmentMetadata> segments) {\n+        orderedSubmit(new CloseableRunnable() {\n+            @Override\n+            void safeRun() {\n+                unsafeProcessLogSegments(segments);\n+            }\n+        });\n+    }\n+\n+    private void unsafeProcessLogSegments(List<LogSegmentMetadata> segments) {\n+        if (isInitialized) {\n+            unsafeReinitializeLogSegments(segments);\n+        } else {\n+            unsafeInitializeLogSegments(segments);\n+        }\n+    }\n+\n+    /**\n+     * Update the log segment metadata.\n+     *\n+     * @param reader the reader to update the metadata\n+     * @param newMetadata the new metadata received\n+     * @return true if successfully, false on encountering errors\n+     */\n+    private boolean updateLogSegmentMetadata(SegmentReader reader,\n+                                             LogSegmentMetadata newMetadata) {\n+        if (reader.getSegment().getLogSegmentSequenceNumber() != newMetadata.getLogSegmentSequenceNumber()) {\n+            setLastException(new DLIllegalStateException(\"Inconsistent state found in entry reader for \"\n+                    + streamName + \" : current segment = \" + reader.getSegment() + \", new segment = \" + newMetadata));\n+            return false;\n+        }\n+        if (!reader.getSegment().isInProgress() && newMetadata.isInProgress()) {\n+            setLastException(new DLIllegalStateException(\"An inprogress log segment \" + newMetadata\n+                    + \" received after a closed log segment \" + reader.getSegment() + \" on reading segment \"\n+                    + newMetadata.getLogSegmentSequenceNumber() + \" @ stream \" + streamName));\n+            return false;\n+        }\n+        if (reader.getSegment().isInProgress() && !newMetadata.isInProgress()) {\n+            reader.updateLogSegmentMetadata(newMetadata);\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Reinitialize the log segments\n+     */\n+    private void unsafeReinitializeLogSegments(List<LogSegmentMetadata> segments) {\n+        logger.info(\"Reinitialize log segments with {}\", segments);\n+        int segmentIdx = 0;\n+        for (; segmentIdx < segments.size(); segmentIdx++) {\n+            LogSegmentMetadata segment = segments.get(segmentIdx);\n+            if (segment.getLogSegmentSequenceNumber() < currentSegmentSequenceNumber) {\n+                continue;\n+            }\n+            break;\n+        }\n+        if (segmentIdx >= segments.size()) {\n+            return;\n+        }\n+        LogSegmentMetadata segment = segments.get(segmentIdx);\n+        if (null != currentSegmentReader) {\n+            if (!updateLogSegmentMetadata(currentSegmentReader, segment)) {\n+                return;\n+            }\n+        } else {\n+            if (currentSegmentSequenceNumber != segment.getLogSegmentSequenceNumber()) {\n+                setLastException(new DLIllegalStateException(\"Inconsistent state found in entry reader for \"\n+                        + streamName + \" : current segment sn = \" + currentSegmentSequenceNumber\n+                        + \", new segment sn = \" + segment.getLogSegmentSequenceNumber()));\n+                return;\n+            }\n+        }\n+        segmentIdx++;\n+        if (segmentIdx >= segments.size()) {\n+            return;\n+        }\n+        // check next segment\n+        segment = segments.get(segmentIdx);\n+        if (null != nextSegmentReader) {\n+            if (!updateLogSegmentMetadata(nextSegmentReader, segment)) {\n+                return;\n+            }\n+            segmentIdx++;\n+        }\n+        // check the segment readers in the queue\n+        for (int readerIdx = 0;\n+             readerIdx < segmentReaders.size() && segmentIdx < segments.size();\n+             readerIdx++, segmentIdx++) {\n+            SegmentReader reader = segmentReaders.get(readerIdx);\n+            segment = segments.get(segmentIdx);\n+            if (!updateLogSegmentMetadata(reader, segment)) {\n+                return;\n+            }\n+        }\n+        // add the remaining segments to the reader queue\n+        for (; segmentIdx < segments.size(); segmentIdx++) {\n+            segment = segments.get(segmentIdx);\n+            SegmentReader reader = new SegmentReader(segment, 0L);\n+            reader.openReader();\n+            segmentReaders.add(reader);\n+        }\n+        if (null == currentSegmentReader) {\n+            unsafeMoveToNextLogSegment();\n+        }\n+        // resume readahead if necessary\n+        invokeReadAhead();\n+    }\n+\n+    /**\n+     * Initialize the reader with the log <i>segments</i>.\n+     *\n+     * @param segments list of log segments\n+     */\n+    private void unsafeInitializeLogSegments(List<LogSegmentMetadata> segments) {\n+        if (segments.isEmpty()) {\n+            // not initialize the background reader, until the first log segment is notified\n+            return;\n+        }\n+        boolean skipTruncatedLogSegments = true;\n+        DLSN dlsnToStart = fromDLSN;\n+        // positioning the reader\n+        for (int i = 0; i < segments.size(); i++) {\n+            LogSegmentMetadata segment = segments.get(i);\n+            // skip any log segments that have smaller log segment sequence numbers\n+            if (segment.getLogSegmentSequenceNumber() < fromDLSN.getLogSegmentSequenceNo()) {\n+                continue;\n+            }\n+            // if the log segment is truncated, skip it.\n+            if (skipTruncatedLogSegments &&\n+                    !conf.getIgnoreTruncationStatus() &&\n+                    segment.isTruncated()) {\n+                continue;\n+            }\n+            // if the log segment is partially truncated, move the start dlsn to the min active dlsn\n+            if (skipTruncatedLogSegments &&\n+                    !conf.getIgnoreTruncationStatus() &&\n+                    segment.isPartiallyTruncated()) {\n+                if (segment.getMinActiveDLSN().compareTo(fromDLSN) > 0) {\n+                    dlsnToStart = segment.getMinActiveDLSN();\n+                }\n+            }\n+            skipTruncatedLogSegments = false;\n+            if (!isAllowedToPosition(segment, dlsnToStart)) {\n+                return;\n+            }\n+\n+            SegmentReader reader = new SegmentReader(segment,\n+                    segment.getLogSegmentSequenceNumber() == dlsnToStart.getLogSegmentSequenceNo()\n+                            ? dlsnToStart.getEntryId() : 0L);\n+            segmentReaders.add(reader);\n+        }\n+        if (segmentReaders.isEmpty()) {\n+            // not initialize the background reader, until the first log segment is available to read\n+            return;\n+        }\n+        currentSegmentReader = segmentReaders.pollFirst();\n+        currentSegmentReader.openReader();\n+        currentSegmentReader.startRead();\n+        currentSegmentSequenceNumber = currentSegmentReader.getSegment().getLogSegmentSequenceNumber();\n+        unsafeReadNext(currentSegmentReader);\n+        if (!segmentReaders.isEmpty()) {\n+            for (SegmentReader reader : segmentReaders) {\n+                reader.openReader();\n+            }\n+            unsafePrefetchNextSegment(true);\n+        }\n+        // mark the reader initialized\n+        isInitialized = true;\n+    }\n+\n+    private void unsafePrefetchNextSegment(boolean onlyInprogressLogSegment) {\n+        SegmentReader nextReader = segmentReaders.peekFirst();\n+        // open the next log segment if it is inprogress\n+        if (null != nextReader) {\n+            if (onlyInprogressLogSegment && !nextReader.getSegment().isInProgress()) {\n+                return;\n+            }\n+            nextReader.startRead();\n+            nextSegmentReader = nextReader;\n+            segmentReaders.pollFirst();\n+        }\n+    }\n+\n+    /**\n+     * Check if we are allowed to position the reader at <i>fromDLSN</i>.\n+     *\n+     * @return true if it is allowed, otherwise false.\n+     */\n+    private boolean isAllowedToPosition(LogSegmentMetadata segment, DLSN fromDLSN) {\n+        if (segment.isTruncated()\n+                && segment.getLastDLSN().compareTo(fromDLSN) >= 0\n+                && !conf.getIgnoreTruncationStatus()) {\n+            setLastException(new AlreadyTruncatedTransactionException(streamName\n+                    + \" : trying to position read ahead at \" + fromDLSN\n+                    + \" on a segment \" + segment + \" that is already marked as truncated\"));\n+            return false;\n+        }\n+        if (segment.isPartiallyTruncated() &&\n+                segment.getMinActiveDLSN().compareTo(fromDLSN) > 0) {\n+            if (conf.getAlertWhenPositioningOnTruncated()) {\n+                alertStatsLogger.raise(\"Trying to position reader on {} when {} is marked partially truncated\",\n+                    fromDLSN, segment);\n+            }\n+            if (!conf.getIgnoreTruncationStatus()) {\n+                logger.error(\"{}: Trying to position reader on {} when {} is marked partially truncated\",\n+                        new Object[]{ streamName, fromDLSN, segment });\n+\n+                setLastException(new AlreadyTruncatedTransactionException(streamName\n+                        + \" : trying to position read ahead at \" + fromDLSN\n+                        + \" on a segment \" + segment + \" that is already marked as truncated\"));\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    void moveToNextLogSegment() {\n+        orderedSubmit(new CloseableRunnable() {\n+            @Override\n+            void safeRun() {\n+                unsafeMoveToNextLogSegment();\n+            }\n+        });\n+    }\n+\n+    private void unsafeMoveToNextLogSegment() {\n+        if (null != currentSegmentReader) {\n+            segmentReadersToClose.add(currentSegmentReader);\n+            currentSegmentReader.close().ensure(removeClosedSegmentReadersFunc);\n+            logger.debug(\"close current segment reader {}\", currentSegmentReader.getSegment());\n+            currentSegmentReader = null;\n+        }\n+        boolean hasSegmentToRead = false;\n+        if (null != nextSegmentReader) {\n+            currentSegmentReader = nextSegmentReader;\n+            logger.debug(\"move to read segment {}\", currentSegmentReader.getSegment());\n+            currentSegmentSequenceNumber = currentSegmentReader.getSegment().getLogSegmentSequenceNumber();\n+            nextSegmentReader = null;\n+            // start reading\n+            unsafeReadNext(currentSegmentReader);\n+            unsafePrefetchNextSegment(true);\n+            hasSegmentToRead = true;\n+        } else {\n+            unsafePrefetchNextSegment(false);\n+            if (null != nextSegmentReader) {\n+                currentSegmentReader = nextSegmentReader;\n+                logger.debug(\"move to read segment {}\", currentSegmentReader.getSegment());\n+                currentSegmentSequenceNumber = currentSegmentReader.getSegment().getLogSegmentSequenceNumber();\n+                nextSegmentReader = null;\n+                unsafeReadNext(currentSegmentReader);\n+                unsafePrefetchNextSegment(true);\n+                hasSegmentToRead = true;\n+            }\n+        }\n+        if (!hasSegmentToRead) { // no more segment to read, wait until new log segment arrive\n+            if (isCatchingUp) {\n+                logger.info(\"ReadAhead for {} is caught up and no log segments to read now\",\n+                        readHandler.getFullyQualifiedName());\n+                isCatchingUp = false;\n+            }\n+            pauseReadAheadOnNoMoreLogSegments();\n+        }\n+    }\n+\n+    void scheduleReadNext() {\n+        orderedSubmit(new CloseableRunnable() {\n+            @Override\n+            void safeRun() {\n+                if (null == currentSegmentReader) {\n+                    pauseReadAheadOnNoMoreLogSegments();\n+                    return;\n+                }\n+                unsafeReadNext(currentSegmentReader);\n+            }\n+        });\n+    }\n+\n+    private void unsafeReadNext(SegmentReader reader) {\n+        reader.readNext().addEventListener(this);\n+    }\n+\n+    @Override\n+    public void onSegmentsUpdated(List<LogSegmentMetadata> segments) {\n+        logger.info(\"segments is updated with {}\", segments);\n+        processLogSegments(segments);\n+    }\n+\n+    @Override\n+    public void onLogStreamDeleted() {\n+        setLastException(new LogNotFoundException(\"Log stream \"\n+                + streamName + \" is deleted\"));\n+    }\n+\n+}"},{"sha":"be8e1b5333f6f9a8732a97e4b48573ed52975fb8","filename":"src/main/java/com/twitter/distributedlog/impl/logsegment/BKLogSegmentEntryReader.java","status":"modified","additions":96,"deletions":22,"changes":118,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d7105aa88f29faecd779c4371fb023775e2c7e40/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fimpl%2Flogsegment%2FBKLogSegmentEntryReader.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d7105aa88f29faecd779c4371fb023775e2c7e40/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fimpl%2Flogsegment%2FBKLogSegmentEntryReader.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fimpl%2Flogsegment%2FBKLogSegmentEntryReader.java?ref=d7105aa88f29faecd779c4371fb023775e2c7e40","patch":"@@ -27,6 +27,7 @@\n import com.twitter.distributedlog.exceptions.DLInterruptedException;\n import com.twitter.distributedlog.exceptions.EndOfLogSegmentException;\n import com.twitter.distributedlog.exceptions.ReadCancelledException;\n+import com.twitter.distributedlog.injector.AsyncFailureInjector;\n import com.twitter.distributedlog.logsegment.LogSegmentEntryReader;\n import com.twitter.distributedlog.util.FutureUtils;\n import com.twitter.distributedlog.util.OrderedScheduler;\n@@ -37,14 +38,16 @@\n import org.apache.bookkeeper.client.BookKeeper;\n import org.apache.bookkeeper.client.LedgerEntry;\n import org.apache.bookkeeper.client.LedgerHandle;\n+import org.apache.bookkeeper.stats.Counter;\n+import org.apache.bookkeeper.stats.StatsLogger;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n import java.io.IOException;\n import java.util.ArrayList;\n import java.util.Enumeration;\n+import java.util.LinkedList;\n import java.util.List;\n-import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.LinkedBlockingQueue;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicInteger;\n@@ -128,6 +131,16 @@ public void readComplete(int rc,\n                                  LedgerHandle lh,\n                                  Enumeration<LedgerEntry> entries,\n                                  Object ctx) {\n+            if (failureInjector.shouldInjectCorruption(entryId, entryId)) {\n+                rc = BKException.Code.DigestMatchException;\n+            }\n+            processReadEntries(rc, lh, entries, ctx);\n+        }\n+\n+        void processReadEntries(int rc,\n+                                LedgerHandle lh,\n+                                Enumeration<LedgerEntry> entries,\n+                                Object ctx) {\n             if (isDone()) {\n                 return;\n             }\n@@ -155,6 +168,16 @@ public void readLastConfirmedAndEntryComplete(int rc,\n                                                       long entryId,\n                                                       LedgerEntry entry,\n                                                       Object ctx) {\n+            if (failureInjector.shouldInjectCorruption(this.entryId, this.entryId)) {\n+                rc = BKException.Code.DigestMatchException;\n+            }\n+            processReadEntry(rc, entryId, entry, ctx);\n+        }\n+\n+        void processReadEntry(int rc,\n+                              long entryId,\n+                              LedgerEntry entry,\n+                              Object ctx) {\n             if (isDone()) {\n                 return;\n             }\n@@ -245,10 +268,10 @@ boolean hasReadEnoughEntries() {\n     private final BookKeeper bk;\n     private final DistributedLogConfiguration conf;\n     private final OrderedScheduler scheduler;\n-    private final long startEntryId;\n     private final long lssn;\n     private final long startSequenceId;\n     private final boolean envelopeEntries;\n+    private final boolean deserializeRecordSet;\n     private final int numPrefetchEntries;\n     private final int maxPrefetchEntries;\n     // state\n@@ -260,29 +283,39 @@ boolean hasReadEnoughEntries() {\n     private long nextEntryId;\n     private final AtomicReference<Throwable> lastException = new AtomicReference<Throwable>(null);\n     private final AtomicLong scheduleCount = new AtomicLong(0);\n+    private volatile boolean hasCaughtupOnInprogress = false;\n     // read retries\n     private int readAheadWaitTime;\n     private final int maxReadBackoffTime;\n     private final AtomicInteger numReadErrors = new AtomicInteger(0);\n+    private final boolean skipBrokenEntries;\n     // readahead cache\n     int cachedEntries = 0;\n     int numOutstandingEntries = 0;\n     final LinkedBlockingQueue<CacheEntry> readAheadEntries;\n     // request queue\n-    final ConcurrentLinkedQueue<PendingReadRequest> readQueue;\n+    final LinkedList<PendingReadRequest> readQueue;\n+\n+    // failure injector\n+    private final AsyncFailureInjector failureInjector;\n+    // Stats\n+    private final Counter skippedBrokenEntriesCounter;\n \n     BKLogSegmentEntryReader(LogSegmentMetadata metadata,\n                             LedgerHandle lh,\n                             long startEntryId,\n                             BookKeeper bk,\n                             OrderedScheduler scheduler,\n-                            DistributedLogConfiguration conf) {\n+                            DistributedLogConfiguration conf,\n+                            StatsLogger statsLogger,\n+                            AsyncFailureInjector failureInjector) {\n         this.metadata = metadata;\n         this.lssn = metadata.getLogSegmentSequenceNumber();\n         this.startSequenceId = metadata.getStartSequenceId();\n         this.envelopeEntries = metadata.getEnvelopeEntries();\n+        this.deserializeRecordSet = conf.getDeserializeRecordSetOnReads();\n         this.lh = lh;\n-        this.startEntryId = this.nextEntryId = Math.max(startEntryId, 0);\n+        this.nextEntryId = Math.max(startEntryId, 0);\n         this.bk = bk;\n         this.conf = conf;\n         this.numPrefetchEntries = conf.getNumPrefetchEntriesPerLogSegment();\n@@ -294,17 +327,35 @@ boolean hasReadEnoughEntries() {\n         // create the readahead queue\n         this.readAheadEntries = new LinkedBlockingQueue<CacheEntry>();\n         // create the read request queue\n-        this.readQueue = new ConcurrentLinkedQueue<PendingReadRequest>();\n+        this.readQueue = new LinkedList<PendingReadRequest>();\n         // read backoff settings\n         this.readAheadWaitTime = conf.getReadAheadWaitTime();\n         this.maxReadBackoffTime = 4 * conf.getReadAheadWaitTime();\n+        // other read settings\n+        this.skipBrokenEntries = conf.getReadAheadSkipBrokenEntries();\n+\n+        // Failure Injection\n+        this.failureInjector = failureInjector;\n+        // Stats\n+        this.skippedBrokenEntriesCounter = statsLogger.getCounter(\"skipped_broken_entries\");\n+    }\n+\n+    @VisibleForTesting\n+    public synchronized CacheEntry getOutstandingLongPoll() {\n+        return outstandingLongPoll;\n+    }\n+\n+    @VisibleForTesting\n+    LinkedBlockingQueue<CacheEntry> getReadAheadEntries() {\n+        return this.readAheadEntries;\n     }\n \n     synchronized LedgerHandle getLh() {\n         return lh;\n     }\n \n-    synchronized LogSegmentMetadata getSegment() {\n+    @Override\n+    public synchronized LogSegmentMetadata getSegment() {\n         return metadata;\n     }\n \n@@ -318,6 +369,11 @@ public void start() {\n         prefetchIfNecessary();\n     }\n \n+    @Override\n+    public boolean hasCaughtUpOnInprogress() {\n+        return hasCaughtupOnInprogress;\n+    }\n+\n     //\n     // Process on Log Segment Metadata Updates\n     //\n@@ -425,10 +481,15 @@ private void notifyReaders() {\n     }\n \n     private void cancelAllPendingReads(Throwable throwExc) {\n-        for (PendingReadRequest request : readQueue) {\n+        List<PendingReadRequest> requestsToCancel;\n+        synchronized (readQueue) {\n+            requestsToCancel = Lists.newArrayListWithExpectedSize(readQueue.size());\n+            requestsToCancel.addAll(readQueue);\n+            readQueue.clear();\n+        }\n+        for (PendingReadRequest request : requestsToCancel) {\n             request.setException(throwExc);\n         }\n-        readQueue.clear();\n     }\n \n     //\n@@ -475,14 +536,15 @@ private void prefetchIfNecessary() {\n                         (!isLedgerClosed() && nextEntryId > getLastAddConfirmed() + 1)) {\n                     break;\n                 }\n-                entriesToFetch.add(new CacheEntry(nextEntryId));\n+                CacheEntry entry = new CacheEntry(nextEntryId);\n+                entriesToFetch.add(entry);\n+                readAheadEntries.add(entry);\n                 ++numOutstandingEntries;\n                 ++cachedEntries;\n                 ++nextEntryId;\n             }\n         }\n         for (CacheEntry entry : entriesToFetch) {\n-            readAheadEntries.add(entry);\n             issueRead(entry);\n         }\n     }\n@@ -518,6 +580,10 @@ private void issueLongPollRead(CacheEntry cacheEntry) {\n         synchronized (this) {\n             this.outstandingLongPoll = cacheEntry;\n         }\n+\n+        if (!hasCaughtupOnInprogress) {\n+            hasCaughtupOnInprogress = true;\n+        }\n         getLh().asyncReadLastConfirmedAndEntry(\n                 cacheEntry.entryId,\n                 conf.getReadLACLongPollTimeout(),\n@@ -535,7 +601,7 @@ Entry.Reader processReadEntry(LedgerEntry entry) throws IOException {\n                 .setLogSegmentInfo(lssn, startSequenceId)\n                 .setEntryId(entry.getEntryId())\n                 .setEnvelopeEntry(envelopeEntries)\n-                .deserializeRecordSet(false)\n+                .deserializeRecordSet(deserializeRecordSet)\n                 .setInputStream(entry.getEntryInputStream())\n                 .buildReader();\n     }\n@@ -635,12 +701,18 @@ public void run() {\n \n     private void readEntriesFromReadAheadCache(PendingReadRequest nextRequest) {\n         while (!nextRequest.hasReadEnoughEntries()) {\n-            CacheEntry entry = readAheadEntries.peek();\n-            // no entry available in the read ahead cache\n+            CacheEntry entry;\n+            boolean hitEndOfLogSegment;\n+            synchronized (this) {\n+                entry = readAheadEntries.peek();\n+                hitEndOfLogSegment = (null == entry) && isEndOfLogSegment();\n+            }\n+            // reach end of log segment\n+            if (hitEndOfLogSegment) {\n+                setException(new EndOfLogSegmentException(getSegment().getZNodeName()), false);\n+                return;\n+            }\n             if (null == entry) {\n-                if (isEndOfLogSegment()) {\n-                    setException(new EndOfLogSegmentException(getSegment().getZNodeName()), false);\n-                }\n                 return;\n             }\n             // entry is not complete yet.\n@@ -665,6 +737,11 @@ private void readEntriesFromReadAheadCache(PendingReadRequest nextRequest) {\n                     setException(e, false);\n                     return;\n                 }\n+            } else if (skipBrokenEntries && BKException.Code.DigestMatchException == entry.getRc()) {\n+                // skip this entry and move forward\n+                skippedBrokenEntriesCounter.inc();\n+                readAheadEntries.poll();\n+                continue;\n             } else {\n                 setException(new BKTransmitException(\"Encountered issue on reading entry \" + entry.getEntryId()\n                         + \" @ log segment \" + getSegment(), entry.getRc()), false);\n@@ -685,18 +762,15 @@ private boolean isEndOfLogSegment(long entryId) {\n         return isLedgerClosed() && entryId > getLastAddConfirmed();\n     }\n \n-    private synchronized boolean isBeyondLastAddConfirmed() {\n+    @Override\n+    public synchronized boolean isBeyondLastAddConfirmed() {\n         return isBeyondLastAddConfirmed(nextEntryId);\n     }\n \n     private boolean isBeyondLastAddConfirmed(long entryId) {\n         return entryId > getLastAddConfirmed();\n     }\n \n-    private synchronized boolean isNotBeyondLastAddConfirmed() {\n-        return isNotBeyondLastAddConfirmed(nextEntryId);\n-    }\n-\n     private boolean isNotBeyondLastAddConfirmed(long entryId) {\n         return entryId <= getLastAddConfirmed();\n     }"},{"sha":"dc96a800c9a1e858fc5569f859a17bbc46bef4d7","filename":"src/main/java/com/twitter/distributedlog/impl/logsegment/BKLogSegmentEntryStore.java","status":"added","additions":127,"deletions":0,"changes":127,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d7105aa88f29faecd779c4371fb023775e2c7e40/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fimpl%2Flogsegment%2FBKLogSegmentEntryStore.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d7105aa88f29faecd779c4371fb023775e2c7e40/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fimpl%2Flogsegment%2FBKLogSegmentEntryStore.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fimpl%2Flogsegment%2FBKLogSegmentEntryStore.java?ref=d7105aa88f29faecd779c4371fb023775e2c7e40","patch":"@@ -0,0 +1,127 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.twitter.distributedlog.impl.logsegment;\n+\n+import com.twitter.distributedlog.DistributedLogConfiguration;\n+import com.twitter.distributedlog.LogSegmentMetadata;\n+import com.twitter.distributedlog.exceptions.BKTransmitException;\n+import com.twitter.distributedlog.injector.AsyncFailureInjector;\n+import com.twitter.distributedlog.logsegment.LogSegmentEntryReader;\n+import com.twitter.distributedlog.logsegment.LogSegmentEntryStore;\n+import com.twitter.distributedlog.logsegment.LogSegmentEntryWriter;\n+import com.twitter.distributedlog.util.FutureUtils;\n+import com.twitter.distributedlog.util.OrderedScheduler;\n+import com.twitter.util.Future;\n+import com.twitter.util.Promise;\n+import org.apache.bookkeeper.client.AsyncCallback;\n+import org.apache.bookkeeper.client.BKException;\n+import org.apache.bookkeeper.client.BookKeeper;\n+import org.apache.bookkeeper.client.LedgerHandle;\n+import org.apache.bookkeeper.stats.StatsLogger;\n+\n+import static com.google.common.base.Charsets.UTF_8;\n+\n+/**\n+ * BookKeeper Based Entry Store\n+ */\n+public class BKLogSegmentEntryStore implements LogSegmentEntryStore, AsyncCallback.OpenCallback {\n+\n+    private static class OpenReaderRequest {\n+\n+        private final LogSegmentMetadata segment;\n+        private final long startEntryId;\n+        private final Promise<LogSegmentEntryReader> openPromise;\n+\n+        OpenReaderRequest(LogSegmentMetadata segment,\n+                          long startEntryId) {\n+            this.segment = segment;\n+            this.startEntryId = startEntryId;\n+            this.openPromise = new Promise<LogSegmentEntryReader>();\n+        }\n+\n+    }\n+\n+    private final byte[] passwd;\n+    private final BookKeeper bk;\n+    private final OrderedScheduler scheduler;\n+    private final DistributedLogConfiguration conf;\n+    private final StatsLogger statsLogger;\n+    private final AsyncFailureInjector failureInjector;\n+\n+    public BKLogSegmentEntryStore(DistributedLogConfiguration conf,\n+                                  BookKeeper bk,\n+                                  OrderedScheduler scheduler,\n+                                  StatsLogger statsLogger,\n+                                  AsyncFailureInjector failureInjector) {\n+        this.conf = conf;\n+        this.bk = bk;\n+        this.passwd = conf.getBKDigestPW().getBytes(UTF_8);\n+        this.scheduler = scheduler;\n+        this.statsLogger = statsLogger;\n+        this.failureInjector = failureInjector;\n+    }\n+\n+    @Override\n+    public Future<LogSegmentEntryWriter> openWriter(LogSegmentMetadata segment) {\n+        throw new UnsupportedOperationException(\"Not supported yet\");\n+    }\n+\n+    @Override\n+    public Future<LogSegmentEntryReader> openReader(LogSegmentMetadata segment,\n+                                                    long startEntryId) {\n+        OpenReaderRequest request = new OpenReaderRequest(segment, startEntryId);\n+        if (segment.isInProgress()) {\n+            bk.asyncOpenLedgerNoRecovery(\n+                    segment.getLedgerId(),\n+                    BookKeeper.DigestType.CRC32,\n+                    passwd,\n+                    this,\n+                    request);\n+        } else {\n+            bk.asyncOpenLedger(\n+                    segment.getLedgerId(),\n+                    BookKeeper.DigestType.CRC32,\n+                    passwd,\n+                    this,\n+                    request);\n+        }\n+        return request.openPromise;\n+    }\n+\n+    @Override\n+    public void openComplete(int rc, LedgerHandle lh, Object ctx) {\n+        OpenReaderRequest request = (OpenReaderRequest) ctx;\n+        if (BKException.Code.OK != rc) {\n+            FutureUtils.setException(\n+                    request.openPromise,\n+                    new BKTransmitException(\"Failed to open ledger handle for log segment \" + request.segment, rc));\n+            return;\n+        }\n+        // successfully open a ledger\n+        LogSegmentEntryReader reader = new BKLogSegmentEntryReader(\n+                request.segment,\n+                lh,\n+                request.startEntryId,\n+                bk,\n+                scheduler,\n+                conf,\n+                statsLogger,\n+                failureInjector);\n+        FutureUtils.setValue(request.openPromise, reader);\n+    }\n+}"},{"sha":"41450408548a14825d94b5f71609da56fd737c70","filename":"src/main/java/com/twitter/distributedlog/injector/AsyncFailureInjector.java","status":"modified","additions":5,"deletions":2,"changes":7,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d7105aa88f29faecd779c4371fb023775e2c7e40/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Finjector%2FAsyncFailureInjector.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d7105aa88f29faecd779c4371fb023775e2c7e40/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Finjector%2FAsyncFailureInjector.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Finjector%2FAsyncFailureInjector.java?ref=d7105aa88f29faecd779c4371fb023775e2c7e40","patch":"@@ -59,7 +59,7 @@ public boolean shouldInjectStops() {\n         }\n \n         @Override\n-        public boolean shouldInjectCorruption() {\n+        public boolean shouldInjectCorruption(long startEntryId, long endEntryId) {\n             return false;\n         }\n \n@@ -122,7 +122,10 @@ public String toString() {\n     /**\n      * Return the flag indicating if should inject corruption.\n      *\n+     * @param startEntryId the start entry id\n+     * @param endEntryId the end entry id\n      * @return true to inject corruption otherwise false.\n      */\n-    boolean shouldInjectCorruption();\n+    boolean shouldInjectCorruption(long startEntryId, long endEntryId);\n+\n }"},{"sha":"f3bfea9d5c1141f877f8c0681a104369f2a0aa04","filename":"src/main/java/com/twitter/distributedlog/injector/AsyncRandomFailureInjector.java","status":"modified","additions":13,"deletions":2,"changes":15,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d7105aa88f29faecd779c4371fb023775e2c7e40/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Finjector%2FAsyncRandomFailureInjector.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d7105aa88f29faecd779c4371fb023775e2c7e40/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Finjector%2FAsyncRandomFailureInjector.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Finjector%2FAsyncRandomFailureInjector.java?ref=d7105aa88f29faecd779c4371fb023775e2c7e40","patch":"@@ -153,8 +153,19 @@ public boolean shouldInjectStops() {\n     }\n \n     @Override\n-    public boolean shouldInjectCorruption() {\n-        return simulateCorruption;\n+    public boolean shouldInjectCorruption(long startEntryId, long endEntryId) {\n+        if (!simulateCorruption) {\n+            return false;\n+        }\n+        if (startEntryId == endEntryId) {\n+            return startEntryId % 10 == 0;\n+        }\n+        for (long i = startEntryId; i <= endEntryId; i++) {\n+            if (i % 10 == 0) {\n+                return true;\n+            }\n+        }\n+        return false;\n     }\n \n     @Override"},{"sha":"07387cbde708d0dbbb4b2b4c7b62236b94b08184","filename":"src/main/java/com/twitter/distributedlog/logsegment/LogSegmentEntryReader.java","status":"modified","additions":21,"deletions":0,"changes":21,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d7105aa88f29faecd779c4371fb023775e2c7e40/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Flogsegment%2FLogSegmentEntryReader.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d7105aa88f29faecd779c4371fb023775e2c7e40/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Flogsegment%2FLogSegmentEntryReader.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Flogsegment%2FLogSegmentEntryReader.java?ref=d7105aa88f29faecd779c4371fb023775e2c7e40","patch":"@@ -38,6 +38,13 @@ public interface LogSegmentEntryReader extends AsyncCloseable {\n      */\n     void start();\n \n+    /**\n+     * Return the log segment metadata for this reader.\n+     *\n+     * @return the log segment metadata\n+     */\n+    LogSegmentMetadata getSegment();\n+\n     /**\n      * Update the log segment each time when the metadata has changed.\n      *\n@@ -64,4 +71,18 @@ public interface LogSegmentEntryReader extends AsyncCloseable {\n      */\n     long getLastAddConfirmed();\n \n+    /**\n+     * Is the reader reading beyond last add confirmed.\n+     *\n+     * @return true if the reader is reading beyond last add confirmed\n+     */\n+    boolean isBeyondLastAddConfirmed();\n+\n+    /**\n+     * Has the log segment reader caught up with the inprogress log segment.\n+     *\n+     * @return true only if the log segment is inprogress and it is caught up, otherwise return false.\n+     */\n+    boolean hasCaughtUpOnInprogress();\n+\n }"},{"sha":"d8611f92c161515150c9d62035f73a963c59ac70","filename":"src/main/java/com/twitter/distributedlog/logsegment/LogSegmentEntryStore.java","status":"modified","additions":3,"deletions":1,"changes":4,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d7105aa88f29faecd779c4371fb023775e2c7e40/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Flogsegment%2FLogSegmentEntryStore.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d7105aa88f29faecd779c4371fb023775e2c7e40/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Flogsegment%2FLogSegmentEntryStore.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Flogsegment%2FLogSegmentEntryStore.java?ref=d7105aa88f29faecd779c4371fb023775e2c7e40","patch":"@@ -39,8 +39,10 @@ public interface LogSegmentEntryStore {\n      * Open the reader for reading data to the log <i>segment</i>.\n      *\n      * @param segment the log <i>segment</i> to read data from\n+     * @param startEntryId the start entry id\n      * @return future represent the opened reader\n      */\n-    Future<LogSegmentEntryReader> openReader(LogSegmentMetadata segment);\n+    Future<LogSegmentEntryReader> openReader(LogSegmentMetadata segment,\n+                                             long startEntryId);\n \n }"},{"sha":"a77f753f44b921e0ff8e94f352f66406698a5ccb","filename":"src/main/java/com/twitter/distributedlog/rate/MovingAverageRateFactory.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d7105aa88f29faecd779c4371fb023775e2c7e40/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Frate%2FMovingAverageRateFactory.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d7105aa88f29faecd779c4371fb023775e2c7e40/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Frate%2FMovingAverageRateFactory.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Frate%2FMovingAverageRateFactory.java?ref=d7105aa88f29faecd779c4371fb023775e2c7e40","patch":"@@ -62,4 +62,4 @@ private void sampleAll() {\n             avg.sample();\n         }\n     }\n-}\n\\ No newline at end of file\n+}"},{"sha":"5161b91385a0c3bd98cc097fb8eecbc7e475dd0e","filename":"src/main/java/com/twitter/distributedlog/readahead/ReadAheadWorker.java","status":"modified","additions":1,"deletions":11,"changes":12,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d7105aa88f29faecd779c4371fb023775e2c7e40/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Freadahead%2FReadAheadWorker.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d7105aa88f29faecd779c4371fb023775e2c7e40/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Freadahead%2FReadAheadWorker.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Freadahead%2FReadAheadWorker.java?ref=d7105aa88f29faecd779c4371fb023775e2c7e40","patch":"@@ -1245,8 +1245,7 @@ private void read() {\n                         public void onSuccess(Enumeration<LedgerEntry> entries) {\n                             int rc = BKException.Code.OK;\n \n-                            // If the range includes an entry id that is a multiple of 10, simulate corruption.\n-                            if (failureInjector.shouldInjectCorruption() && rangeContainsSimulatedBrokenEntry(startEntryId, endEntryId)) {\n+                            if (failureInjector.shouldInjectCorruption(startEntryId, endEntryId)) {\n                                 rc = BKException.Code.DigestMatchException;\n                             }\n                             readComplete(rc, null, entries, readCtx, startEntryId, endEntryId);\n@@ -1259,15 +1258,6 @@ public void onFailure(Throwable cause) {\n                     });\n         }\n \n-        private boolean rangeContainsSimulatedBrokenEntry(long start, long end) {\n-            for (long i = start; i <= end; i++) {\n-                if (i % 10 == 0) {\n-                    return true;\n-                }\n-            }\n-            return false;\n-        }\n-\n         public void readComplete(final int rc, final LedgerHandle lh,\n                                  final Enumeration<LedgerEntry> seq, final Object ctx,\n                                  final long startEntryId, final long endEntryId) {"},{"sha":"287bd6d1b99dad28d5d41c5d085889881c7c1baa","filename":"src/main/java/com/twitter/distributedlog/util/OrderedScheduler.java","status":"modified","additions":8,"deletions":0,"changes":8,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d7105aa88f29faecd779c4371fb023775e2c7e40/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Futil%2FOrderedScheduler.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d7105aa88f29faecd779c4371fb023775e2c7e40/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Futil%2FOrderedScheduler.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Futil%2FOrderedScheduler.java?ref=d7105aa88f29faecd779c4371fb023775e2c7e40","patch":"@@ -475,6 +475,14 @@ public ScheduledFuture<?> schedule(Object key, Runnable command, long delay, Tim\n         return chooseExecutor(key).schedule(command, delay, unit);\n     }\n \n+    public ScheduledFuture<?> scheduleAtFixedRate(Object key,\n+                                                  Runnable command,\n+                                                  long initialDelay,\n+                                                  long period,\n+                                                  TimeUnit unit) {\n+        return chooseExecutor(key).scheduleAtFixedRate(command, initialDelay, period, unit);\n+    }\n+\n     public Future<?> submit(Object key, Runnable command) {\n         return chooseExecutor(key).submit(command);\n     }"},{"sha":"99276166bd43bba439b456ec639e5f8529642fb6","filename":"src/test/java/com/twitter/distributedlog/TestAsyncReaderLock.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d7105aa88f29faecd779c4371fb023775e2c7e40/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestAsyncReaderLock.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d7105aa88f29faecd779c4371fb023775e2c7e40/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestAsyncReaderLock.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestAsyncReaderLock.java?ref=d7105aa88f29faecd779c4371fb023775e2c7e40","patch":"@@ -81,7 +81,7 @@ public void testReaderLockIfLockPathDoesntExist() throws Exception {\n         assertEquals(0L, record.getSequenceId());\n         DLMTestUtil.verifyLogRecord(record);\n \n-        String readLockPath = reader1.bkLedgerManager.getReadLockPath();\n+        String readLockPath = reader1.readHandler.getReadLockPath();\n         Utils.close(reader1);\n \n         // simulate a old stream created without readlock path"},{"sha":"95d760e4efb6f0d318d1e0b1b342901f0927e965","filename":"src/test/java/com/twitter/distributedlog/TestAsyncReaderWriter.java","status":"modified","additions":29,"deletions":10,"changes":39,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d7105aa88f29faecd779c4371fb023775e2c7e40/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestAsyncReaderWriter.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d7105aa88f29faecd779c4371fb023775e2c7e40/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestAsyncReaderWriter.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestAsyncReaderWriter.java?ref=d7105aa88f29faecd779c4371fb023775e2c7e40","patch":"@@ -140,6 +140,7 @@ public void testWriteControlRecord() throws Exception {\n             }\n             record = reader.readNext(false);\n         }\n+        reader.close();\n         assertEquals(3 * 9, numTrans);\n         assertEquals(3 * 9, readDlm.getLogRecordCount());\n         readDlm.close();\n@@ -339,7 +340,7 @@ public void onSuccess(LogRecordWithDLSN value) {\n                         assertTrue(value.getSequenceId() < 0);\n                         assertTrue(value.getSequenceId() > startSequenceId);\n                     }\n-                    LOG.debug(\"Recevied record {} from {}\", value.getDlsn(), reader.getStreamName());\n+                    LOG.info(\"Received record {} from {}\", value, reader.getStreamName());\n                     assertTrue(!value.isControl());\n                     assertTrue(value.getDlsn().getSlotId() == 0);\n                     assertTrue(value.getDlsn().compareTo(startPosition) >= 0);\n@@ -366,7 +367,7 @@ public void onSuccess(LogRecordWithDLSN value) {\n             }\n             @Override\n             public void onFailure(Throwable cause) {\n-                LOG.debug(\"Encountered Exception on reading {}\", reader.getStreamName(), cause);\n+                LOG.error(\"Encountered Exception on reading {}\", reader.getStreamName(), cause);\n                 errorsFound.set(true);\n                 completionLatch.countDown();\n             }\n@@ -806,6 +807,7 @@ public void testSimpleAsyncReadWriteStartEmpty() throws Exception {\n         readerSyncLatch.await();\n \n         assertTrue(\"Should position reader at least once\", reader.getNumReaderPositions().get() > 1);\n+        reader.stop();\n         dlm.close();\n     }\n \n@@ -906,7 +908,7 @@ public void testSimpleAsyncReadWriteSimulateErrors() throws Exception {\n         confLocal.setOutputBufferSize(1024);\n         DistributedLogManager dlm = createNewDLM(confLocal, name);\n \n-        int numLogSegments = 20;\n+        int numLogSegments = 5;\n         int numRecordsPerLogSegment = 10;\n \n         final CountDownLatch doneLatch = new CountDownLatch(1);\n@@ -924,7 +926,7 @@ public void testSimpleAsyncReadWriteSimulateErrors() throws Exception {\n \n         reader.start();\n \n-        final CountDownLatch writeLatch = new CountDownLatch(200);\n+        final CountDownLatch writeLatch = new CountDownLatch(numLogSegments * numRecordsPerLogSegment);\n         final AtomicBoolean writeErrors = new AtomicBoolean(false);\n \n         int txid = 1;\n@@ -949,6 +951,7 @@ public void testSimpleAsyncReadWriteSimulateErrors() throws Exception {\n         syncLatch.await();\n \n         assertTrue(\"Should position reader at least once\", reader.getNumReaderPositions().get() > 1);\n+        reader.stop();\n         dlm.close();\n     }\n \n@@ -1341,7 +1344,7 @@ private void testAsyncReadIdleErrorInternal(String name,\n         confLocal.setImmediateFlushEnabled(true);\n         confLocal.setReadAheadBatchSize(1);\n         confLocal.setReadAheadMaxRecords(1);\n-        confLocal.setReaderIdleWarnThresholdMillis(50);\n+        confLocal.setReaderIdleWarnThresholdMillis(0);\n         confLocal.setReaderIdleErrorThresholdMillis(idleReaderErrorThreshold);\n         final DistributedLogManager dlm = createNewDLM(confLocal, name);\n         final Thread currentThread = Thread.currentThread();\n@@ -1424,6 +1427,7 @@ public void run() {\n             Assert.assertEquals(segmentSize, recordCount);\n         }\n         assertFalse(currentThread.isInterrupted());\n+        Utils.close(reader);\n         executor.shutdown();\n     }\n \n@@ -1512,7 +1516,6 @@ public void run() {\n                         try {\n                             int txid = 1;\n                             for (long i = 0; i < numSegments; i++) {\n-                                long start = txid;\n                                 BKSyncLogWriter writer = (BKSyncLogWriter) dlm.startLogSegmentNonPartitioned();\n                                 for (long j = 1; j <= segmentSize; j++) {\n                                     writer.write(DLMTestUtil.getLargeLogRecordInstance(txid++));\n@@ -1558,6 +1561,7 @@ public void run() {\n         assertTrue(!exceptionEncountered);\n         Assert.assertEquals(recordCount, segmentSize * numSegments);\n         assertTrue(!currentThread.isInterrupted());\n+        Utils.close(reader);\n         executor.shutdown();\n     }\n \n@@ -1617,19 +1621,20 @@ public void testMaxReadAheadRecords() throws Exception {\n         LOG.info(\"Read record {}\", record);\n         assertEquals(1L, record.getTransactionId());\n \n-        assertNotNull(reader.bkLedgerManager.readAheadWorker);\n-        assertTrue(reader.bkLedgerManager.readAheadCache.getNumCachedEntries() <= maxAllowedCachedRecords);\n+        assertNotNull(reader.getReadAheadReader());\n+        assertTrue(reader.getReadAheadReader().getNumCachedEntries() <= maxAllowedCachedRecords);\n \n         for (int i = 2; i <= numRecords; i++) {\n             record = Await.result(reader.readNext());\n             LOG.info(\"Read record {}\", record);\n             assertEquals((long) i, record.getTransactionId());\n             TimeUnit.MILLISECONDS.sleep(20);\n-            int numCachedEntries = reader.bkLedgerManager.readAheadCache.getNumCachedEntries();\n+            int numCachedEntries = reader.getReadAheadReader().getNumCachedEntries();\n             assertTrue(\"Should cache less than \" + batchSize + \" records but already found \"\n                     + numCachedEntries + \" records when reading \" + i + \"th record\",\n                     numCachedEntries <= maxAllowedCachedRecords);\n         }\n+        Utils.close(reader);\n     }\n \n     @Test(timeout = 60000)\n@@ -1675,6 +1680,7 @@ public void testMarkEndOfStream() throws Exception {\n             fail(\"Should have thrown\");\n         } catch (EndOfStreamException ex) {\n         }\n+        Utils.close(reader);\n     }\n \n     @Test(timeout = 60000)\n@@ -1694,13 +1700,15 @@ public void testMarkEndOfStreamAtBeginningOfSegment() throws Exception {\n             fail(\"Should have thrown\");\n         } catch (EndOfStreamException ex) {\n         }\n+        writer.close();\n \n         BKAsyncLogReaderDLSN reader = (BKAsyncLogReaderDLSN) dlm.getAsyncLogReader(DLSN.InitialDLSN);\n         try {\n             LogRecord record = Await.result(reader.readNext());\n             fail(\"Should have thrown\");\n         } catch (EndOfStreamException ex) {\n         }\n+        Utils.close(reader);\n     }\n \n     @Test(timeout = 60000)\n@@ -1863,7 +1871,7 @@ public void testReadBrokenEntriesWithGapDetection() throws Exception {\n         } catch (DLIllegalStateException e) {\n         }\n \n-        reader.asyncClose();\n+        Utils.close(reader);\n         dlm.close();\n     }\n \n@@ -2096,6 +2104,8 @@ public void onFailure(Throwable cause) {\n             assertEquals(i+1, record.getPositionWithinLogSegment());\n             assertArrayEquals(DLMTestUtil.generatePayload(i+1), record.getPayload());\n         }\n+        Utils.close(reader1);\n+        readDLM1.close();\n \n         DistributedLogConfiguration readConf2 = new DistributedLogConfiguration();\n         readConf2.addConfiguration(confLocal);\n@@ -2124,6 +2134,8 @@ public void onFailure(Throwable cause) {\n                 assertEquals(5, LogRecordSet.numRecords(record));\n             }\n         }\n+        Utils.close(reader2);\n+        readDLM2.close();\n     }\n \n     @Test(timeout = 60000)\n@@ -2152,6 +2164,9 @@ public void testIdleReaderExceptionWhenKeepAliveIsDisabled() throws Exception {\n         } catch (IdleReaderException ire) {\n             // expected\n         }\n+        Utils.close(reader);\n+        writer.close();\n+        dlm.close();\n     }\n \n     @Test(timeout = 60000)\n@@ -2177,5 +2192,9 @@ public void testIdleReaderExceptionWhenKeepAliveIsEnabled() throws Exception {\n         LogRecordWithDLSN record = FutureUtils.result(reader.readNext());\n         assertEquals(1L, record.getTransactionId());\n         DLMTestUtil.verifyLogRecord(record);\n+\n+        Utils.close(reader);\n+        writer.close();\n+        dlm.close();\n     }\n }"},{"sha":"54177c8f50bb6e2c50aa0fc0effe653c8218eef5","filename":"src/test/java/com/twitter/distributedlog/TestBKSyncLogReader.java","status":"modified","additions":2,"deletions":3,"changes":5,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d7105aa88f29faecd779c4371fb023775e2c7e40/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestBKSyncLogReader.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d7105aa88f29faecd779c4371fb023775e2c7e40/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestBKSyncLogReader.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestBKSyncLogReader.java?ref=d7105aa88f29faecd779c4371fb023775e2c7e40","patch":"@@ -162,7 +162,7 @@ public void testReadRecordsAfterReadAheadCaughtUp() throws Exception {\n         BKSyncLogReaderDLSN reader = (BKSyncLogReaderDLSN) dlm.getInputStream(1L);\n \n         // wait until readahead caught up\n-        while (!reader.getReadHandler().isReadAheadCaughtUp()) {\n+        while (!reader.getReadAheadReader().isReadAheadCaughtUp()) {\n             TimeUnit.MILLISECONDS.sleep(20);\n         }\n \n@@ -178,8 +178,7 @@ public void testReadRecordsAfterReadAheadCaughtUp() throws Exception {\n         logger.info(\"Write another 10 records\");\n \n         // wait until readahead move on\n-        while (reader.getReadHandler()\n-                .readAheadWorker.getNextReadAheadPosition().getEntryId() < 21) {\n+        while (reader.getReadAheadReader().getNextEntryPosition().getEntryId() < 21) {\n             TimeUnit.MILLISECONDS.sleep(20);\n         }\n "},{"sha":"384d1e818d801d9c4a977691abbfa1cec815a502","filename":"src/test/java/com/twitter/distributedlog/TestEntryPosition.java","status":"added","additions":59,"deletions":0,"changes":59,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d7105aa88f29faecd779c4371fb023775e2c7e40/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestEntryPosition.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d7105aa88f29faecd779c4371fb023775e2c7e40/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestEntryPosition.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestEntryPosition.java?ref=d7105aa88f29faecd779c4371fb023775e2c7e40","patch":"@@ -0,0 +1,59 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.twitter.distributedlog;\n+\n+import org.junit.Test;\n+\n+import static org.junit.Assert.*;\n+\n+/**\n+ * Test Case for {@link EntryPosition}\n+ */\n+public class TestEntryPosition {\n+\n+    private void checkPosition(EntryPosition position,\n+                               long lssn,\n+                               long entryId) {\n+        assertEquals(position.getLogSegmentSequenceNumber(), lssn);\n+        assertEquals(position.getEntryId(), entryId);\n+    }\n+\n+    @Test\n+    public void testAdvance() {\n+        EntryPosition position = new EntryPosition(9L, 99L);\n+\n+        checkPosition(position, 9L, 99L);\n+\n+        // advance (8L, 100L) takes no effect\n+        assertFalse(position.advance(8L, 100L));\n+        checkPosition(position, 9L, 99L);\n+        // advance (9L, 98L) takes no effect\n+        assertFalse(position.advance(9L, 98L));\n+        checkPosition(position, 9L, 99L);\n+        // advance (9L, 99L) takes no effect\n+        assertFalse(position.advance(9L, 99L));\n+        checkPosition(position, 9L, 99L);\n+        // advance (9L, 100L) takes effects\n+        assertTrue(position.advance(9L, 100L));\n+        checkPosition(position, 9L, 100L);\n+        // advance (10L, 0L) takes effects\n+        assertTrue(position.advance(10L, 0L));\n+        checkPosition(position, 10L, 0L);\n+    }\n+\n+}"},{"sha":"3f473372ecf498146b491f836441cab5de5079fa","filename":"src/test/java/com/twitter/distributedlog/TestNonBlockingReadsMultiReader.java","status":"modified","additions":2,"deletions":3,"changes":5,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d7105aa88f29faecd779c4371fb023775e2c7e40/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestNonBlockingReadsMultiReader.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d7105aa88f29faecd779c4371fb023775e2c7e40/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestNonBlockingReadsMultiReader.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestNonBlockingReadsMultiReader.java?ref=d7105aa88f29faecd779c4371fb023775e2c7e40","patch":"@@ -148,9 +148,8 @@ public void run() {\n             LOG.info(\"Writer stopped after writing {} records, waiting for reader to complete\",\n                     writeCount.get());\n             while (writeCount.get() > (readerThreads[0].getReadCount())) {\n-                LOG.info(\"Write Count = {}, Read Count = {}, ReadAhead = {}\",\n-                        new Object[] { writeCount.get(), readerThreads[0].getReadCount(),\n-                                        reader0.getReadHandler().getReadAheadCache() });\n+                LOG.info(\"Write Count = {}, Read Count = {}\",\n+                        new Object[] { writeCount.get(), readerThreads[0].getReadCount() });\n                 TimeUnit.MILLISECONDS.sleep(100);\n             }\n             assertEquals(writeCount.get(),"},{"sha":"71b6834ab3c7596e1ca3d0f5156a18b74d0104d4","filename":"src/test/java/com/twitter/distributedlog/TestReadAhead.java","status":"removed","additions":0,"deletions":158,"changes":158,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/e2c6bc0d7faa7b7912a51a7a4ed6e1b9ac5653bf/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestReadAhead.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/e2c6bc0d7faa7b7912a51a7a4ed6e1b9ac5653bf/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestReadAhead.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestReadAhead.java?ref=e2c6bc0d7faa7b7912a51a7a4ed6e1b9ac5653bf","patch":"@@ -1,158 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package com.twitter.distributedlog;\n-\n-import com.twitter.distributedlog.LogSegmentMetadata.LogSegmentMetadataVersion;\n-import com.twitter.distributedlog.util.Utils;\n-import com.twitter.distributedlog.readahead.ReadAheadWorker;\n-import com.twitter.util.Await;\n-import com.twitter.util.Duration;\n-import com.twitter.util.Future;\n-import org.junit.Test;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.TimeoutException;\n-\n-import static org.junit.Assert.*;\n-\n-/**\n- * {@link ReadAheadWorker} related test cases.\n- */\n-public class TestReadAhead extends TestDistributedLogBase {\n-\n-    static final Logger logger = LoggerFactory.getLogger(TestReadAhead.class);\n-\n-    @Test(timeout = 60000)\n-    public void testNoSuchLedgerExceptionOnReadLAC() throws Exception {\n-        String name = \"distrlog-nosuchledger-exception-on-readlac\";\n-        DistributedLogConfiguration confLocal = new DistributedLogConfiguration();\n-        confLocal.loadConf(conf);\n-        confLocal.setReadAheadWaitTime(500);\n-        confLocal.setReadAheadNoSuchLedgerExceptionOnReadLACErrorThresholdMillis(2000);\n-        confLocal.setDLLedgerMetadataLayoutVersion(LogSegmentMetadataVersion.VERSION_V4_ENVELOPED_ENTRIES.value);\n-        confLocal.setLogSegmentSequenceNumberValidationEnabled(false);\n-\n-        DistributedLogManager dlm = createNewDLM(confLocal, name);\n-        DLMTestUtil.injectLogSegmentWithGivenLogSegmentSeqNo(dlm, confLocal, 1L, 1L, false, 0, false);\n-        DLMTestUtil.injectLogSegmentWithGivenLogSegmentSeqNo(dlm, confLocal, 2L, 11L, true, 10, true);\n-\n-        BKDistributedLogManager readDLM = (BKDistributedLogManager) createNewDLM(confLocal, name);\n-        final BKAsyncLogReaderDLSN reader = (BKAsyncLogReaderDLSN) readDLM.getAsyncLogReader(DLSN.InitialDLSN);\n-        final Future<LogRecordWithDLSN> readFuture = reader.readNext();\n-        try {\n-            Await.result(readFuture, Duration.fromMilliseconds(2000));\n-            fail(\"Should not read any data beyond an empty inprogress log segment\");\n-        } catch (TimeoutException e) {\n-            // expected\n-        }\n-\n-        LedgerDescriptor ld1;\n-        while (null == (ld1 = reader.bkLedgerManager.readAheadWorker.getCurrentLedgerDescriptor())) {\n-            Thread.sleep(100);\n-        }\n-\n-        TimeUnit.MILLISECONDS.sleep(2 * 2000);\n-\n-        LedgerDescriptor ld2;\n-        while (null == (ld2 = reader.bkLedgerManager.readAheadWorker.getCurrentLedgerDescriptor())) {\n-            Thread.sleep(100);\n-        }\n-\n-        // ledger handle would be re-initialized after reaching error threshold\n-        assertTrue(\"ledger handle should be reinitialized, after reaching error threshold.\", ld1 != ld2);\n-\n-        dlm.close();\n-\n-        dlm = createNewDLM(confLocal, name);\n-        dlm.recover();\n-\n-        long expectedTxId = 11L;\n-        LogRecord record = Await.result(readFuture);\n-        assertNotNull(record);\n-        DLMTestUtil.verifyLogRecord(record);\n-        assertEquals(expectedTxId, record.getTransactionId());\n-        expectedTxId++;\n-\n-        for (int i = 1; i < 10; i++) {\n-            record = Await.result(reader.readNext());\n-            assertNotNull(record);\n-            DLMTestUtil.verifyLogRecord(record);\n-            assertEquals(expectedTxId, record.getTransactionId());\n-            expectedTxId++;\n-        }\n-\n-        Utils.close(reader);\n-        readDLM.close();\n-\n-    }\n-\n-    @Test(timeout = 60000)\n-    public void testReadAheadWaitOnEndOfStream() throws Exception {\n-        String name = \"distrlog-readahead-wait-on-end-of-stream\";\n-        DistributedLogConfiguration confLocal = new DistributedLogConfiguration();\n-        confLocal.loadConf(conf);\n-        confLocal.setZKNumRetries(0);\n-        confLocal.setReadAheadWaitTime(500);\n-        confLocal.setReadAheadWaitTimeOnEndOfStream(Integer.MAX_VALUE);\n-\n-        DistributedLogManager dlm = createNewDLM(confLocal, name);\n-        DLMTestUtil.generateCompletedLogSegments(dlm, confLocal, 3, 10);\n-\n-        BKDistributedLogManager readDLM = (BKDistributedLogManager) createNewDLM(confLocal, name);\n-        final BKAsyncLogReaderDLSN reader = (BKAsyncLogReaderDLSN) readDLM.getAsyncLogReader(DLSN.InitialDLSN);\n-\n-        int numReads = 0;\n-        long expectedID = 1;\n-        for (long i = 0; i < 3; i++) {\n-            for (long j = 1; j <= 10; j++) {\n-                LogRecordWithDLSN record = Await.result(reader.readNext());\n-                assertEquals(expectedID++, record.getTransactionId());\n-                DLMTestUtil.verifyLogRecord(record);\n-                ++numReads;\n-            }\n-        }\n-        assertEquals(30, numReads);\n-        // we are at the end of the stream and there isn't inprogress log segment\n-        Future<LogRecordWithDLSN> readFuture = reader.readNext();\n-\n-        // make sure readahead is backing off on reading log segment on Integer.MAX_VALUE\n-        AsyncNotification notification1;\n-        while (null == (notification1 = reader.bkLedgerManager.readAheadWorker.getMetadataNotification())) {\n-            Thread.sleep(200);\n-        }\n-        Thread.sleep(1000);\n-\n-        // write another record\n-        BKSyncLogWriter writer =\n-                    (BKSyncLogWriter) dlm.startLogSegmentNonPartitioned();\n-        writer.write(DLMTestUtil.getLogRecordInstance(31L));\n-        writer.closeAndComplete();\n-\n-        LogRecordWithDLSN record = Await.result(readFuture);\n-        assertEquals(31L, record.getTransactionId());\n-        DLMTestUtil.verifyLogRecord(record);\n-\n-        Utils.close(reader);\n-        readDLM.close();\n-\n-        dlm.close();\n-    }\n-\n-}"},{"sha":"573ae5c7399b7dac61479e770a077c6275beb7ef","filename":"src/test/java/com/twitter/distributedlog/TestReadAheadEntryReader.java","status":"added","additions":423,"deletions":0,"changes":423,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d7105aa88f29faecd779c4371fb023775e2c7e40/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestReadAheadEntryReader.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d7105aa88f29faecd779c4371fb023775e2c7e40/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestReadAheadEntryReader.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestReadAheadEntryReader.java?ref=d7105aa88f29faecd779c4371fb023775e2c7e40","patch":"@@ -0,0 +1,423 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.twitter.distributedlog;\n+\n+import com.google.common.base.Optional;\n+import com.google.common.base.Ticker;\n+import com.google.common.collect.Lists;\n+import com.twitter.distributedlog.exceptions.AlreadyTruncatedTransactionException;\n+import com.twitter.distributedlog.exceptions.DLIllegalStateException;\n+import com.twitter.distributedlog.impl.logsegment.BKLogSegmentEntryStore;\n+import com.twitter.distributedlog.injector.AsyncFailureInjector;\n+import com.twitter.distributedlog.logsegment.LogSegmentEntryStore;\n+import com.twitter.distributedlog.util.FutureUtils;\n+import com.twitter.distributedlog.util.OrderedScheduler;\n+import com.twitter.distributedlog.util.Utils;\n+import com.twitter.util.Promise;\n+import org.apache.bookkeeper.stats.AlertStatsLogger;\n+import org.apache.bookkeeper.stats.NullStatsLogger;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TestName;\n+\n+import java.util.List;\n+\n+import static org.junit.Assert.*;\n+\n+/**\n+ * Test Case {@link ReadAheadEntryReader}\n+ */\n+public class TestReadAheadEntryReader extends TestDistributedLogBase {\n+\n+    private static final int MAX_CACHED_ENTRIES = 5;\n+    private static final int NUM_PREFETCH_ENTRIES = 10;\n+\n+    @Rule\n+    public TestName runtime = new TestName();\n+    private DistributedLogConfiguration baseConf;\n+    private OrderedScheduler scheduler;\n+    private BookKeeperClient bkc;\n+\n+    @Before\n+    public void setup() throws Exception {\n+        super.setup();\n+        baseConf = new DistributedLogConfiguration();\n+        baseConf.addConfiguration(conf);\n+        baseConf.setOutputBufferSize(0);\n+        baseConf.setPeriodicFlushFrequencyMilliSeconds(0);\n+        baseConf.setImmediateFlushEnabled(false);\n+        baseConf.setReadAheadMaxRecords(MAX_CACHED_ENTRIES);\n+        baseConf.setNumPrefetchEntriesPerLogSegment(NUM_PREFETCH_ENTRIES);\n+        baseConf.setMaxPrefetchEntriesPerLogSegment(NUM_PREFETCH_ENTRIES);\n+        bkc = BookKeeperClientBuilder.newBuilder()\n+                .name(\"test-bk\")\n+                .dlConfig(conf)\n+                .ledgersPath(\"/ledgers\")\n+                .zkServers(bkutil.getZkServers())\n+                .build();\n+        scheduler = OrderedScheduler.newBuilder()\n+                .name(\"test-read-ahead-entry-reader\")\n+                .corePoolSize(1)\n+                .build();\n+    }\n+\n+    @After\n+    public void teardown() throws Exception {\n+        if (null != bkc) {\n+            bkc.close();\n+        }\n+        if (null != scheduler) {\n+            scheduler.shutdown();\n+        }\n+        super.teardown();\n+    }\n+\n+    private ReadAheadEntryReader createEntryReader(String streamName,\n+                                                   DLSN fromDLSN,\n+                                                   BKDistributedLogManager dlm,\n+                                                   DistributedLogConfiguration conf)\n+            throws Exception {\n+        BKLogReadHandler readHandler = dlm.createReadHandler(\n+                Optional.<String>absent(),\n+                true);\n+        LogSegmentEntryStore entryStore = new BKLogSegmentEntryStore(\n+                conf,\n+                bkc.get(),\n+                scheduler,\n+                NullStatsLogger.INSTANCE,\n+                AsyncFailureInjector.NULL);\n+        return new ReadAheadEntryReader(\n+                streamName,\n+                fromDLSN,\n+                conf,\n+                readHandler,\n+                entryStore,\n+                scheduler,\n+                Ticker.systemTicker(),\n+                new AlertStatsLogger(NullStatsLogger.INSTANCE, \"test-alert\"));\n+    }\n+\n+    private void ensureOrderSchedulerEmpty(String streamName) throws Exception {\n+        final Promise<Void> promise = new Promise<Void>();\n+        scheduler.submit(streamName, new Runnable() {\n+            @Override\n+            public void run() {\n+                FutureUtils.setValue(promise, null);\n+            }\n+        });\n+        FutureUtils.result(promise);\n+    }\n+\n+    void generateCompletedLogSegments(DistributedLogManager dlm,\n+                                      long numCompletedSegments,\n+                                      long segmentSize) throws Exception {\n+        generateCompletedLogSegments(dlm, numCompletedSegments, segmentSize, 1L);\n+    }\n+\n+    void generateCompletedLogSegments(DistributedLogManager dlm,\n+                                      long numCompletedSegments,\n+                                      long segmentSize,\n+                                      long startTxId) throws Exception {\n+\n+        long txid = startTxId;\n+        for (long i = 0; i < numCompletedSegments; i++) {\n+            AsyncLogWriter writer = FutureUtils.result(dlm.openAsyncLogWriter());\n+            for (long j = 1; j <= segmentSize; j++) {\n+                FutureUtils.result(writer.write(DLMTestUtil.getLogRecordInstance(txid++)));\n+                LogRecord ctrlRecord = DLMTestUtil.getLogRecordInstance(txid);\n+                ctrlRecord.setControl();\n+                FutureUtils.result(writer.write(ctrlRecord));\n+            }\n+            Utils.close(writer);\n+        }\n+    }\n+\n+    AsyncLogWriter createInprogressLogSegment(DistributedLogManager dlm,\n+                                              DistributedLogConfiguration conf,\n+                                              long segmentSize) throws Exception {\n+        AsyncLogWriter writer = FutureUtils.result(dlm.openAsyncLogWriter());\n+        for (long i = 1L; i <= segmentSize; i++) {\n+            FutureUtils.result(writer.write(DLMTestUtil.getLogRecordInstance(i)));\n+            LogRecord ctrlRecord = DLMTestUtil.getLogRecordInstance(i);\n+            ctrlRecord.setControl();\n+            FutureUtils.result(writer.write(ctrlRecord));\n+        }\n+        return writer;\n+    }\n+\n+    void expectAlreadyTruncatedTransactionException(ReadAheadEntryReader reader,\n+                                                    String errMsg)\n+            throws Exception {\n+        try {\n+            reader.checkLastException();\n+            fail(errMsg);\n+        } catch (AlreadyTruncatedTransactionException atte) {\n+            // expected\n+        }\n+    }\n+\n+    void expectIllegalStateException(ReadAheadEntryReader reader,\n+                                     String errMsg)\n+            throws Exception {\n+        try {\n+            reader.checkLastException();\n+            fail(errMsg);\n+        } catch (DLIllegalStateException le) {\n+            // expected\n+        }\n+    }\n+\n+    void expectNoException(ReadAheadEntryReader reader) throws Exception {\n+        reader.checkLastException();\n+    }\n+\n+    //\n+    // Test Positioning\n+    //\n+\n+    @Test(timeout = 60000)\n+    public void testStartWithEmptySegmentList() throws Exception {\n+        String streamName = runtime.getMethodName();\n+        BKDistributedLogManager dlm = createNewDLM(baseConf, streamName);\n+        ReadAheadEntryReader readAheadEntryReader =\n+                createEntryReader(streamName, DLSN.InitialDLSN, dlm, baseConf);\n+\n+        readAheadEntryReader.start(Lists.<LogSegmentMetadata>newArrayList());\n+\n+        ensureOrderSchedulerEmpty(streamName);\n+        assertFalse(\"ReadAhead should not be initialized with empty segment list\",\n+                readAheadEntryReader.isInitialized());\n+        assertTrue(\"ReadAhead should be empty when it isn't initialized\",\n+                readAheadEntryReader.isCacheEmpty());\n+        assertFalse(\"ReadAhead should not be marked as caught up when it isn't initialized\",\n+                readAheadEntryReader.isReadAheadCaughtUp());\n+\n+        // generate list of log segments\n+        generateCompletedLogSegments(dlm, 1, MAX_CACHED_ENTRIES / 2 + 1);\n+        List<LogSegmentMetadata> segments = dlm.getLogSegments();\n+        assertEquals(segments.size() + \" log segments found, expected to be only one\",\n+                1, segments.size());\n+\n+        // notify the readahead reader with new segment lsit\n+        readAheadEntryReader.onSegmentsUpdated(segments);\n+\n+        // check the reader state after initialization\n+        ensureOrderSchedulerEmpty(streamName);\n+        assertTrue(\"ReadAhead should be initialized with non-empty segment list\",\n+                readAheadEntryReader.isInitialized());\n+        assertNotNull(\"current segment reader should be initialized\",\n+                readAheadEntryReader.getCurrentSegmentReader());\n+        assertEquals(\"current segment sequence number should be \" + segments.get(0).getLogSegmentSequenceNumber(),\n+                segments.get(0).getLogSegmentSequenceNumber(), readAheadEntryReader.getCurrentSegmentSequenceNumber());\n+        assertNull(\"there should be no next segment reader\",\n+                readAheadEntryReader.getNextSegmentReader());\n+        assertTrue(\"there should be no remaining segment readers\",\n+                readAheadEntryReader.getSegmentReaders().isEmpty());\n+\n+        Utils.close(readAheadEntryReader);\n+        dlm.close();\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testInitializeMultipleClosedLogSegments0() throws Exception {\n+        // 5 completed log segments, start from the begin\n+        testInitializeMultipleClosedLogSegments(5, DLSN.InitialDLSN, 0);\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testInitializeMultipleClosedLogSegments1() throws Exception {\n+        // 5 completed log segments, start from the 4th segment and it should skip first 3 log segments\n+        testInitializeMultipleClosedLogSegments(5, new DLSN(4L, 0L, 0L), 3);\n+    }\n+\n+    private void testInitializeMultipleClosedLogSegments(\n+            int numLogSegments,\n+            DLSN fromDLSN,\n+            int expectedCurrentSegmentIdx\n+    ) throws Exception {\n+        String streamName = runtime.getMethodName();\n+        BKDistributedLogManager dlm = createNewDLM(baseConf, streamName);\n+\n+        // generate list of log segments\n+        generateCompletedLogSegments(dlm, 1, MAX_CACHED_ENTRIES / 2 + 1, 1L);\n+        generateCompletedLogSegments(dlm, numLogSegments - 1, 1, MAX_CACHED_ENTRIES + 2);\n+        List<LogSegmentMetadata> segments = dlm.getLogSegments();\n+        assertEquals(segments.size() + \" log segments found, expected to be \" + numLogSegments,\n+                numLogSegments, segments.size());\n+\n+        ReadAheadEntryReader readAheadEntryReader =\n+                createEntryReader(streamName, fromDLSN, dlm, baseConf);\n+        readAheadEntryReader.start(segments);\n+\n+        ensureOrderSchedulerEmpty(streamName);\n+        assertTrue(\"ReadAhead should be initialized with non-empty segment list\",\n+                readAheadEntryReader.isInitialized());\n+        assertNotNull(\"current segment reader should be initialized\",\n+                readAheadEntryReader.getCurrentSegmentReader());\n+        assertTrue(\"current segment reader should be open and started\",\n+                readAheadEntryReader.getCurrentSegmentReader().isReaderOpen()\n+                        && readAheadEntryReader.getCurrentSegmentReader().isReaderStarted());\n+        assertEquals(\"current segment reader should read \" + segments.get(expectedCurrentSegmentIdx),\n+                segments.get(expectedCurrentSegmentIdx),\n+                readAheadEntryReader.getCurrentSegmentReader().getSegment());\n+        assertEquals(\"current segment sequence number should be \"\n+                + segments.get(expectedCurrentSegmentIdx).getLogSegmentSequenceNumber(),\n+                segments.get(expectedCurrentSegmentIdx).getLogSegmentSequenceNumber(),\n+                readAheadEntryReader.getCurrentSegmentSequenceNumber());\n+        assertNull(\"next segment reader should not be initialized since it is a closed log segment\",\n+                readAheadEntryReader.getNextSegmentReader());\n+        assertEquals(\"there should be \" + (numLogSegments - (expectedCurrentSegmentIdx + 1))\n+                + \" remaining segment readers\",\n+                numLogSegments - (expectedCurrentSegmentIdx + 1),\n+                readAheadEntryReader.getSegmentReaders().size());\n+        int segmentIdx = expectedCurrentSegmentIdx + 1;\n+        for (ReadAheadEntryReader.SegmentReader reader : readAheadEntryReader.getSegmentReaders()) {\n+            LogSegmentMetadata expectedSegment = segments.get(segmentIdx);\n+            assertEquals(\"Segment should \" + expectedSegment,\n+                    expectedSegment, reader.getSegment());\n+            assertTrue(\"Segment reader for \" + expectedSegment + \" should be open\",\n+                    reader.isReaderOpen());\n+            assertFalse(\"Segment reader for \" + expectedSegment + \" should not be started\",\n+                    reader.isReaderStarted());\n+            ++segmentIdx;\n+        }\n+\n+        Utils.close(readAheadEntryReader);\n+        dlm.close();\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testPositioningAtInvalidLogSegment() throws Exception {\n+        String streamName = runtime.getMethodName();\n+        BKDistributedLogManager dlm = createNewDLM(baseConf, streamName);\n+\n+        // generate list of log segments\n+        generateCompletedLogSegments(dlm, 3, 2);\n+        AsyncLogWriter writer = FutureUtils.result(dlm.openAsyncLogWriter());\n+        FutureUtils.result(writer.truncate(new DLSN(2L, 1L, 0L)));\n+\n+        List<LogSegmentMetadata> segments = dlm.getLogSegments();\n+\n+        // positioning on a truncated log segment (segment 1)\n+        ReadAheadEntryReader readAheadEntryReader =\n+                createEntryReader(streamName, DLSN.InitialDLSN, dlm, baseConf);\n+        readAheadEntryReader.start(segments);\n+        // ensure initialization to complete\n+        ensureOrderSchedulerEmpty(streamName);\n+        expectAlreadyTruncatedTransactionException(readAheadEntryReader,\n+                \"should fail on positioning to a truncated log segment\");\n+\n+        // positioning on a partially truncated log segment (segment 2) before min active dlsn\n+        readAheadEntryReader = createEntryReader(streamName, new DLSN(2L, 0L, 0L), dlm, baseConf);\n+        readAheadEntryReader.start(segments);\n+        // ensure initialization to complete\n+        ensureOrderSchedulerEmpty(streamName);\n+        expectAlreadyTruncatedTransactionException(readAheadEntryReader,\n+                \"should fail on positioning to a partially truncated log segment\");\n+\n+        // positioning on a partially truncated log segment (segment 2) after min active dlsn\n+        readAheadEntryReader = createEntryReader(streamName, new DLSN(2L, 1L, 0L), dlm, baseConf);\n+        readAheadEntryReader.start(segments);\n+        // ensure initialization to complete\n+        ensureOrderSchedulerEmpty(streamName);\n+        expectNoException(readAheadEntryReader);\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testPositioningIgnoreTruncationStatus() throws Exception {\n+        DistributedLogConfiguration confLocal = new DistributedLogConfiguration();\n+        confLocal.addConfiguration(baseConf);\n+        confLocal.setIgnoreTruncationStatus(true);\n+\n+        String streamName = runtime.getMethodName();\n+        BKDistributedLogManager dlm = createNewDLM(confLocal, streamName);\n+\n+        // generate list of log segments\n+        generateCompletedLogSegments(dlm, 3, 2);\n+        AsyncLogWriter writer = FutureUtils.result(dlm.openAsyncLogWriter());\n+        FutureUtils.result(writer.truncate(new DLSN(2L, 1L, 0L)));\n+\n+        List<LogSegmentMetadata> segments = dlm.getLogSegments();\n+\n+        // positioning on a truncated log segment (segment 1)\n+        ReadAheadEntryReader readAheadEntryReader =\n+                createEntryReader(streamName, DLSN.InitialDLSN, dlm, confLocal);\n+        readAheadEntryReader.start(segments);\n+        // ensure initialization to complete\n+        ensureOrderSchedulerEmpty(streamName);\n+        expectNoException(readAheadEntryReader);\n+\n+        // positioning on a partially truncated log segment (segment 2) before min active dlsn\n+        readAheadEntryReader = createEntryReader(streamName, new DLSN(2L, 0L, 0L), dlm, confLocal);\n+        readAheadEntryReader.start(segments);\n+        // ensure initialization to complete\n+        ensureOrderSchedulerEmpty(streamName);\n+        expectNoException(readAheadEntryReader);\n+\n+        // positioning on a partially truncated log segment (segment 2) after min active dlsn\n+        readAheadEntryReader = createEntryReader(streamName, new DLSN(2L, 1L, 0L), dlm, confLocal);\n+        readAheadEntryReader.start(segments);\n+        // ensure initialization to complete\n+        ensureOrderSchedulerEmpty(streamName);\n+        expectNoException(readAheadEntryReader);\n+    }\n+\n+    //\n+    // Test Reinitialization\n+    //\n+\n+    @Test(timeout = 60000)\n+    public void testLogSegmentSequenceNumberGap() throws Exception {\n+        String streamName = runtime.getMethodName();\n+        BKDistributedLogManager dlm = createNewDLM(baseConf, streamName);\n+\n+        // generate list of log segments\n+        generateCompletedLogSegments(dlm, 3, 2);\n+        List<LogSegmentMetadata> segments = dlm.getLogSegments();\n+\n+        ReadAheadEntryReader readAheadEntryReader =\n+                createEntryReader(streamName, DLSN.InitialDLSN, dlm, baseConf);\n+        readAheadEntryReader.start(segments.subList(0, 1));\n+        int expectedCurrentSegmentIdx = 0;\n+        ensureOrderSchedulerEmpty(streamName);\n+        assertTrue(\"ReadAhead should be initialized with non-empty segment list\",\n+                readAheadEntryReader.isInitialized());\n+        assertNotNull(\"current segment reader should be initialized\",\n+                readAheadEntryReader.getCurrentSegmentReader());\n+        assertTrue(\"current segment reader should be open and started\",\n+                readAheadEntryReader.getCurrentSegmentReader().isReaderOpen()\n+                        && readAheadEntryReader.getCurrentSegmentReader().isReaderStarted());\n+        assertEquals(\"current segment reader should read \" + segments.get(expectedCurrentSegmentIdx),\n+                segments.get(expectedCurrentSegmentIdx),\n+                readAheadEntryReader.getCurrentSegmentReader().getSegment());\n+        assertEquals(\"current segment sequence number should be \"\n+                + segments.get(expectedCurrentSegmentIdx).getLogSegmentSequenceNumber(),\n+                segments.get(expectedCurrentSegmentIdx).getLogSegmentSequenceNumber(),\n+                readAheadEntryReader.getCurrentSegmentSequenceNumber());\n+        assertNull(\"next segment reader should not be initialized since it is a closed log segment\",\n+                readAheadEntryReader.getNextSegmentReader());\n+\n+        readAheadEntryReader.onSegmentsUpdated(segments.subList(2, 3));\n+        ensureOrderSchedulerEmpty(streamName);\n+        expectIllegalStateException(readAheadEntryReader,\n+                \"inconsistent log segment found\");\n+    }\n+\n+}"},{"sha":"1739b479286518cbaefff9c1870d8b4a58f601cc","filename":"src/test/java/com/twitter/distributedlog/TestReader.java","status":"modified","additions":4,"deletions":0,"changes":4,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d7105aa88f29faecd779c4371fb023775e2c7e40/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestReader.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d7105aa88f29faecd779c4371fb023775e2c7e40/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestReader.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestReader.java?ref=d7105aa88f29faecd779c4371fb023775e2c7e40","patch":"@@ -17,6 +17,7 @@\n  */\n package com.twitter.distributedlog;\n \n+import com.twitter.distributedlog.util.Utils;\n import com.twitter.util.Future;\n import com.twitter.util.FutureEventListener;\n import org.slf4j.Logger;\n@@ -121,6 +122,9 @@ public void run() {\n                     }\n                     nextDLSN = dlsn;\n                     LOG.info(\"Positioned reader {} at {}\", readerName, dlsn);\n+                    if (null != TestReader.this.reader) {\n+                        Utils.close(TestReader.this.reader);\n+                    }\n                     TestReader.this.reader = reader;\n                     readNext();\n                     readyLatch.countDown();"},{"sha":"ee53362745cfd25ef5ab12977da8cc465a050148","filename":"src/test/java/com/twitter/distributedlog/TestRollLogSegments.java","status":"modified","additions":9,"deletions":3,"changes":12,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d7105aa88f29faecd779c4371fb023775e2c7e40/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestRollLogSegments.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d7105aa88f29faecd779c4371fb023775e2c7e40/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestRollLogSegments.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestRollLogSegments.java?ref=d7105aa88f29faecd779c4371fb023775e2c7e40","patch":"@@ -23,6 +23,7 @@\n import java.util.concurrent.CountDownLatch;\n \n import com.twitter.distributedlog.feature.CoreFeatureKeys;\n+import com.twitter.distributedlog.impl.logsegment.BKLogSegmentEntryReader;\n import com.twitter.distributedlog.util.FailpointUtils;\n import com.twitter.distributedlog.util.FutureUtils;\n import com.twitter.distributedlog.util.Utils;\n@@ -318,11 +319,11 @@ private void checkAndWaitWriterReaderPosition(BKLogSegmentWriter writer, long ex\n         }\n         assertEquals(expectedWriterPosition, getLedgerHandle(writer).getLastAddConfirmed());\n         assertEquals(expectedLac, inspector.readLastConfirmed());\n-        LedgerReadPosition readPosition = reader.bkLedgerManager.readAheadWorker.getNextReadAheadPosition();\n+        EntryPosition readPosition = reader.getReadAheadReader().getNextEntryPosition();\n         logger.info(\"ReadAhead moved read position {} : \", readPosition);\n         while (readPosition.getEntryId() < expectedReaderPosition) {\n             Thread.sleep(1000);\n-            readPosition = reader.bkLedgerManager.readAheadWorker.getNextReadAheadPosition();\n+            readPosition = reader.getReadAheadReader().getNextEntryPosition();\n             logger.info(\"ReadAhead moved read position {} : \", readPosition);\n         }\n         assertEquals(expectedReaderPosition, readPosition.getEntryId());\n@@ -386,7 +387,12 @@ public void testCaughtUpReaderOnLogSegmentRolling() throws Exception {\n         // Writer moved to lac = 11, while reader knows lac = 10 and moving to wait on 11\n         checkAndWaitWriterReaderPosition(perStreamWriter, 11, reader, 11, readLh, 10);\n \n-        while (null == reader.bkLedgerManager.readAheadWorker.getMetadataNotification()) {\n+        while (true) {\n+            BKLogSegmentEntryReader entryReader =\n+                    (BKLogSegmentEntryReader) reader.getReadAheadReader().getCurrentSegmentReader().getEntryReader();\n+            if (null != entryReader && null != entryReader.getOutstandingLongPoll()) {\n+                break;\n+            }\n             Thread.sleep(1000);\n         }\n         logger.info(\"Waiting for long poll getting interrupted with metadata changed\");"},{"sha":"011fc7017f1d444350bec85a18fc19ef934f3da4","filename":"src/test/java/com/twitter/distributedlog/TestTruncate.java","status":"modified","additions":0,"deletions":1,"changes":1,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d7105aa88f29faecd779c4371fb023775e2c7e40/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestTruncate.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d7105aa88f29faecd779c4371fb023775e2c7e40/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestTruncate.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestTruncate.java?ref=d7105aa88f29faecd779c4371fb023775e2c7e40","patch":"@@ -329,7 +329,6 @@ private void verifyEntries(String name, long readFromTxId, long startTxId, int n\n         LogRecord r = reader.readNext(false);\n         while (null != r) {\n             DLMTestUtil.verifyLogRecord(r);\n-            LOG.trace(\"Read entry {}.\", r.getTransactionId());\n             assertEquals(txid++, r.getTransactionId());\n             ++numRead;\n             r = reader.readNext(false);"},{"sha":"88840a0f3ffe354de3ff6310efeb82d2e327776f","filename":"src/test/java/com/twitter/distributedlog/impl/logsegment/TestBKLogSegmentEntryReader.java","status":"modified","additions":13,"deletions":25,"changes":38,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d7105aa88f29faecd779c4371fb023775e2c7e40/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fimpl%2Flogsegment%2FTestBKLogSegmentEntryReader.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d7105aa88f29faecd779c4371fb023775e2c7e40/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fimpl%2Flogsegment%2FTestBKLogSegmentEntryReader.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fimpl%2Flogsegment%2FTestBKLogSegmentEntryReader.java?ref=d7105aa88f29faecd779c4371fb023775e2c7e40","patch":"@@ -32,24 +32,22 @@\n import com.twitter.distributedlog.TestDistributedLogBase;\n import com.twitter.distributedlog.exceptions.EndOfLogSegmentException;\n import com.twitter.distributedlog.exceptions.ReadCancelledException;\n+import com.twitter.distributedlog.injector.AsyncFailureInjector;\n+import com.twitter.distributedlog.logsegment.LogSegmentEntryStore;\n import com.twitter.distributedlog.util.FutureUtils;\n import com.twitter.distributedlog.util.OrderedScheduler;\n import com.twitter.distributedlog.util.Utils;\n import com.twitter.util.Future;\n-import org.apache.bookkeeper.client.BookKeeper;\n-import org.apache.bookkeeper.client.LedgerHandle;\n+import org.apache.bookkeeper.stats.NullStatsLogger;\n import org.junit.After;\n import org.junit.Before;\n import org.junit.Rule;\n import org.junit.Test;\n import org.junit.rules.TestName;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n \n import java.util.List;\n import java.util.concurrent.TimeUnit;\n \n-import static com.google.common.base.Charsets.UTF_8;\n import static org.junit.Assert.*;\n \n /**\n@@ -92,25 +90,9 @@ BKLogSegmentEntryReader createEntryReader(LogSegmentMetadata segment,\n                                               long startEntryId,\n                                               DistributedLogConfiguration conf)\n             throws Exception {\n-        LedgerHandle lh;\n-        if (segment.isInProgress()) {\n-            lh = bkc.get().openLedgerNoRecovery(\n-                    segment.getLedgerId(),\n-                    BookKeeper.DigestType.CRC32,\n-                    conf.getBKDigestPW().getBytes(UTF_8));\n-        } else {\n-            lh = bkc.get().openLedger(\n-                    segment.getLedgerId(),\n-                    BookKeeper.DigestType.CRC32,\n-                    conf.getBKDigestPW().getBytes(UTF_8));\n-        }\n-        return new BKLogSegmentEntryReader(\n-                segment,\n-                lh,\n-                startEntryId,\n-                bkc.get(),\n-                scheduler,\n-                conf);\n+        LogSegmentEntryStore store = new BKLogSegmentEntryStore(\n+                conf, bkc.get(), scheduler, NullStatsLogger.INSTANCE, AsyncFailureInjector.NULL);\n+        return (BKLogSegmentEntryReader) FutureUtils.result(store.openReader(segment, startEntryId));\n     }\n \n     void generateCompletedLogSegments(DistributedLogManager dlm,\n@@ -186,6 +168,7 @@ public void testReadEntriesFromCompleteLogSegment() throws Exception {\n             ++entryId;\n         }\n         assertEquals(21, txId);\n+        assertFalse(reader.hasCaughtUpOnInprogress());\n         Utils.close(reader);\n     }\n \n@@ -216,6 +199,7 @@ public void testCloseReaderToCancelPendingReads() throws Exception {\n                 // expected\n             }\n         }\n+        assertFalse(reader.hasCaughtUpOnInprogress());\n         assertTrue(\"Reader should be closed yet\", reader.isClosed());\n     }\n \n@@ -245,9 +229,9 @@ public void testMaxPrefetchEntriesSmallBatch() throws Exception {\n         long txId = 1L;\n         long entryId = 0L;\n \n-\n         assertEquals(10, reader.readAheadEntries.size());\n         assertEquals(10, reader.getNextEntryId());\n+        assertFalse(reader.hasCaughtUpOnInprogress());\n         // read first entry\n         Entry.Reader entryReader = FutureUtils.result(reader.readNext(1)).get(0);\n         LogRecordWithDLSN record = entryReader.nextRecord();\n@@ -271,6 +255,7 @@ public void testMaxPrefetchEntriesSmallBatch() throws Exception {\n \n         assertEquals(10, reader.readAheadEntries.size());\n         assertEquals(11, reader.getNextEntryId());\n+        assertFalse(reader.hasCaughtUpOnInprogress());\n \n         Utils.close(reader);\n     }\n@@ -326,6 +311,7 @@ public void testMaxPrefetchEntriesLargeBatch() throws Exception {\n \n         assertEquals(5, reader.readAheadEntries.size());\n         assertEquals(6, reader.getNextEntryId());\n+        assertFalse(reader.hasCaughtUpOnInprogress());\n \n         Utils.close(reader);\n     }\n@@ -376,6 +362,7 @@ public void testMaxPrefetchEntriesSmallSegment() throws Exception {\n         assertEquals(2L, txId);\n         assertEquals(reader.getLastAddConfirmed(), reader.readAheadEntries.size());\n         assertEquals((reader.getLastAddConfirmed() + 1), reader.getNextEntryId());\n+        assertFalse(reader.hasCaughtUpOnInprogress());\n \n         Utils.close(reader);\n     }\n@@ -434,6 +421,7 @@ public void testReadEntriesFromInprogressSegment() throws Exception {\n         // the long poll will be satisfied\n         List<Entry.Reader> nextReadEntries = FutureUtils.result(nextReadFuture);\n         assertEquals(1, nextReadEntries.size());\n+        assertTrue(reader.hasCaughtUpOnInprogress());\n         Entry.Reader entryReader = nextReadEntries.get(0);\n         LogRecordWithDLSN record = entryReader.nextRecord();\n         assertNotNull(record);"}]}