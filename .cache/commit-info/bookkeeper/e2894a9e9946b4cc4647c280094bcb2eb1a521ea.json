{"sha":"e2894a9e9946b4cc4647c280094bcb2eb1a521ea","node_id":"MDY6Q29tbWl0NDc4NTkyNTI2OmUyODk0YTllOTk0NmI0Y2M0NjQ3YzI4MDA5NGJjYjJlYjFhNTIxZWE=","commit":{"author":{"name":"Matteo Merli","email":"mmerli@apache.org","date":"2017-05-12T13:17:36Z"},"committer":{"name":"eolivelli","email":"eolivelli@apache.org","date":"2017-05-12T13:17:36Z"},"message":"BOOKKEEPER-1066: Introduce GrowableArrayBlockingQueue\n\nIn multiple places, (eg: journal, ordered executor, etc..), we are using `LinkedBlockingQueue` instances to pass objects between threads.\n\nThe `LinkedBlockingQueue` differs from the `ArrayBlockingQueue` in that it doesn't require to define a max queue size, though, being implemented with a linked list, it requires to allocates list nodes each time an item is added.\n\nWe can use a `GrowableArrayBlockingQueue` that behaves in the same way as the `LinkedBlockingQueue`, but it's implemented with an array that can be resized when the queue reaches the capacity.\n\nAuthor: Matteo Merli <mmerli@apache.org>\n\nReviewers: Enrico Olivelli <eolivelli@apache.org>\n\nCloses #153 from merlimat/growable-blocking-queue","tree":{"sha":"78eb93e173bad38732377ba9615ce51ebb827f90","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/trees/78eb93e173bad38732377ba9615ce51ebb827f90"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/commits/e2894a9e9946b4cc4647c280094bcb2eb1a521ea","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/e2894a9e9946b4cc4647c280094bcb2eb1a521ea","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/e2894a9e9946b4cc4647c280094bcb2eb1a521ea","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/e2894a9e9946b4cc4647c280094bcb2eb1a521ea/comments","author":{"login":"merlimat","id":62500,"node_id":"MDQ6VXNlcjYyNTAw","avatar_url":"https://avatars.githubusercontent.com/u/62500?v=4","gravatar_id":"","url":"https://api.github.com/users/merlimat","html_url":"https://github.com/merlimat","followers_url":"https://api.github.com/users/merlimat/followers","following_url":"https://api.github.com/users/merlimat/following{/other_user}","gists_url":"https://api.github.com/users/merlimat/gists{/gist_id}","starred_url":"https://api.github.com/users/merlimat/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/merlimat/subscriptions","organizations_url":"https://api.github.com/users/merlimat/orgs","repos_url":"https://api.github.com/users/merlimat/repos","events_url":"https://api.github.com/users/merlimat/events{/privacy}","received_events_url":"https://api.github.com/users/merlimat/received_events","type":"User","site_admin":false},"committer":{"login":"eolivelli","id":9469110,"node_id":"MDQ6VXNlcjk0NjkxMTA=","avatar_url":"https://avatars.githubusercontent.com/u/9469110?v=4","gravatar_id":"","url":"https://api.github.com/users/eolivelli","html_url":"https://github.com/eolivelli","followers_url":"https://api.github.com/users/eolivelli/followers","following_url":"https://api.github.com/users/eolivelli/following{/other_user}","gists_url":"https://api.github.com/users/eolivelli/gists{/gist_id}","starred_url":"https://api.github.com/users/eolivelli/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/eolivelli/subscriptions","organizations_url":"https://api.github.com/users/eolivelli/orgs","repos_url":"https://api.github.com/users/eolivelli/repos","events_url":"https://api.github.com/users/eolivelli/events{/privacy}","received_events_url":"https://api.github.com/users/eolivelli/received_events","type":"User","site_admin":false},"parents":[{"sha":"eeaddeda66fc687d20c2309a8cbc109c5dfeed89","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/eeaddeda66fc687d20c2309a8cbc109c5dfeed89","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/eeaddeda66fc687d20c2309a8cbc109c5dfeed89"}],"stats":{"total":569,"additions":569,"deletions":0},"files":[{"sha":"1b3044d3686b2a61a2b5e2f3537ff67c1a7cf7d4","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/util/MathUtils.java","status":"modified","additions":4,"deletions":0,"changes":4,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/e2894a9e9946b4cc4647c280094bcb2eb1a521ea/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2FMathUtils.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/e2894a9e9946b4cc4647c280094bcb2eb1a521ea/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2FMathUtils.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2FMathUtils.java?ref=e2894a9e9946b4cc4647c280094bcb2eb1a521ea","patch":"@@ -35,6 +35,10 @@ public static int signSafeMod(long dividend, int divisor) {\n \n     }\n \n+    public static int findNextPositivePowerOfTwo(final int value) {\n+        return 1 << (32 - Integer.numberOfLeadingZeros(value - 1));\n+    }\n+\n     /**\n      * Current time from some arbitrary time base in the past, counting in\n      * milliseconds, and not affected by settimeofday or similar system clock"},{"sha":"8f7dae7866309772ebcabfe3a7c858f816437c18","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/util/collections/GrowableArrayBlockingQueue.java","status":"added","additions":359,"deletions":0,"changes":359,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/e2894a9e9946b4cc4647c280094bcb2eb1a521ea/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2Fcollections%2FGrowableArrayBlockingQueue.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/e2894a9e9946b4cc4647c280094bcb2eb1a521ea/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2Fcollections%2FGrowableArrayBlockingQueue.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2Fcollections%2FGrowableArrayBlockingQueue.java?ref=e2894a9e9946b4cc4647c280094bcb2eb1a521ea","patch":"@@ -0,0 +1,359 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.util.collections;\n+\n+import java.util.AbstractQueue;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.locks.Condition;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.apache.bookkeeper.util.MathUtils;\n+\n+\n+/**\n+ * This implements a {@link BlockingQueue} backed by an array with no fixed capacity.\n+ *\n+ * When the capacity is reached, data will be moved to a bigger array.\n+ *\n+ */\n+public class GrowableArrayBlockingQueue<T> extends AbstractQueue<T> implements BlockingQueue<T> {\n+\n+    private final ReentrantLock headLock = new ReentrantLock();\n+    private final PaddedInt headIndex = new PaddedInt();\n+    private final PaddedInt tailIndex = new PaddedInt();\n+    private final ReentrantLock tailLock = new ReentrantLock();\n+    private final Condition isNotEmpty = headLock.newCondition();\n+\n+    private T[] data;\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicIntegerFieldUpdater<GrowableArrayBlockingQueue> SIZE_UPDATER =\n+            AtomicIntegerFieldUpdater.newUpdater(GrowableArrayBlockingQueue.class, \"size\");\n+    @SuppressWarnings(\"unused\")\n+    private volatile int size = 0;\n+\n+    public GrowableArrayBlockingQueue() {\n+        this(64);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public GrowableArrayBlockingQueue(int initialCapacity) {\n+        headIndex.value = 0;\n+        tailIndex.value = 0;\n+\n+        int capacity = MathUtils.findNextPositivePowerOfTwo(initialCapacity);\n+        data = (T[]) new Object[capacity];\n+    }\n+\n+    @Override\n+    public T remove() {\n+        T item = poll();\n+        if (item == null) {\n+            throw new NoSuchElementException();\n+        }\n+\n+        return item;\n+    }\n+\n+    @Override\n+    public T poll() {\n+        headLock.lock();\n+        try {\n+            if (SIZE_UPDATER.get(this) > 0) {\n+                T item = data[headIndex.value];\n+                headIndex.value = (headIndex.value + 1) & (data.length - 1);\n+                SIZE_UPDATER.decrementAndGet(this);\n+                return item;\n+            } else {\n+                return null;\n+            }\n+        } finally {\n+            headLock.unlock();\n+        }\n+    }\n+\n+    @Override\n+    public T element() {\n+        T item = peek();\n+        if (item == null) {\n+            throw new NoSuchElementException();\n+        }\n+\n+        return item;\n+    }\n+\n+    @Override\n+    public T peek() {\n+        headLock.lock();\n+        try {\n+            if (SIZE_UPDATER.get(this) > 0) {\n+                return data[headIndex.value];\n+            } else {\n+                return null;\n+            }\n+        } finally {\n+            headLock.unlock();\n+        }\n+    }\n+\n+    @Override\n+    public boolean offer(T e) {\n+        // Queue is unbounded and it will never reject new items\n+        put(e);\n+        return true;\n+    }\n+\n+    @Override\n+    public void put(T e) {\n+        tailLock.lock();\n+\n+        boolean wasEmpty = false;\n+\n+        try {\n+            if (SIZE_UPDATER.get(this) == data.length) {\n+                expandArray();\n+            }\n+\n+            data[tailIndex.value] = e;\n+            tailIndex.value = (tailIndex.value + 1) & (data.length - 1);\n+            if (SIZE_UPDATER.getAndIncrement(this) == 0) {\n+                wasEmpty = true;\n+            }\n+        } finally {\n+            tailLock.unlock();\n+        }\n+\n+        if (wasEmpty) {\n+            headLock.lock();\n+            try {\n+                isNotEmpty.signal();\n+            } finally {\n+                headLock.unlock();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public boolean add(T e) {\n+        put(e);\n+        return true;\n+    }\n+\n+    @Override\n+    public boolean offer(T e, long timeout, TimeUnit unit) {\n+        // Queue is unbounded and it will never reject new items\n+        put(e);\n+        return true;\n+    }\n+\n+    @Override\n+    public T take() throws InterruptedException {\n+        headLock.lockInterruptibly();\n+\n+        try {\n+            while (SIZE_UPDATER.get(this) == 0) {\n+                isNotEmpty.await();\n+            }\n+\n+            T item = data[headIndex.value];\n+            data[headIndex.value] = null;\n+            headIndex.value = (headIndex.value + 1) & (data.length - 1);\n+            if (SIZE_UPDATER.decrementAndGet(this) > 0) {\n+                // There are still entries to consume\n+                isNotEmpty.signal();\n+            }\n+            return item;\n+        } finally {\n+            headLock.unlock();\n+        }\n+    }\n+\n+    @Override\n+    public T poll(long timeout, TimeUnit unit) throws InterruptedException {\n+        headLock.lockInterruptibly();\n+\n+        try {\n+            long timeoutNanos = unit.toNanos(timeout);\n+            while (SIZE_UPDATER.get(this) == 0) {\n+                if (timeoutNanos <= 0) {\n+                    return null;\n+                }\n+\n+                timeoutNanos = isNotEmpty.awaitNanos(timeoutNanos);\n+            }\n+\n+            T item = data[headIndex.value];\n+            data[headIndex.value] = null;\n+            headIndex.value = (headIndex.value + 1) & (data.length - 1);\n+            if (SIZE_UPDATER.decrementAndGet(this) > 0) {\n+                // There are still entries to consume\n+                isNotEmpty.signal();\n+            }\n+            return item;\n+        } finally {\n+            headLock.unlock();\n+        }\n+    }\n+\n+    @Override\n+    public int remainingCapacity() {\n+        return Integer.MAX_VALUE;\n+    }\n+\n+    @Override\n+    public int drainTo(Collection<? super T> c) {\n+        return drainTo(c, Integer.MAX_VALUE);\n+    }\n+\n+    @Override\n+    public int drainTo(Collection<? super T> c, int maxElements) {\n+        headLock.lock();\n+\n+        try {\n+            int drainedItems = 0;\n+            int size = SIZE_UPDATER.get(this);\n+\n+            while (size > 0 && drainedItems < maxElements) {\n+                T item = data[headIndex.value];\n+                data[headIndex.value] = null;\n+                c.add(item);\n+\n+                headIndex.value = (headIndex.value + 1) & (data.length - 1);\n+                --size;\n+                ++drainedItems;\n+            }\n+\n+            if (SIZE_UPDATER.addAndGet(this, -drainedItems) > 0) {\n+                // There are still entries to consume\n+                isNotEmpty.signal();\n+            }\n+\n+            return drainedItems;\n+        } finally {\n+            headLock.unlock();\n+        }\n+    }\n+\n+    @Override\n+    public void clear() {\n+        headLock.lock();\n+\n+        try {\n+            int size = SIZE_UPDATER.get(this);\n+\n+            for (int i = 0; i < size; i++) {\n+                data[headIndex.value] = null;\n+                headIndex.value = (headIndex.value + 1) & (data.length - 1);\n+            }\n+\n+            if (SIZE_UPDATER.addAndGet(this, -size) > 0) {\n+                // There are still entries to consume\n+                isNotEmpty.signal();\n+            }\n+        } finally {\n+            headLock.unlock();\n+        }\n+    }\n+\n+    @Override\n+    public int size() {\n+        return SIZE_UPDATER.get(this);\n+    }\n+\n+    @Override\n+    public Iterator<T> iterator() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        StringBuilder sb = new StringBuilder();\n+\n+        tailLock.lock();\n+        headLock.lock();\n+\n+        try {\n+            int headIndex = this.headIndex.value;\n+            int size = SIZE_UPDATER.get(this);\n+\n+            sb.append('[');\n+\n+            for (int i = 0; i < size; i++) {\n+                T item = data[headIndex];\n+                if (i > 0) {\n+                    sb.append(\", \");\n+                }\n+\n+                sb.append(item);\n+\n+                headIndex = (headIndex + 1) & (data.length - 1);\n+            }\n+\n+            sb.append(']');\n+        } finally {\n+            headLock.unlock();\n+            tailLock.unlock();\n+        }\n+        return sb.toString();\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private void expandArray() {\n+        // We already hold the tailLock\n+        headLock.lock();\n+\n+        try {\n+            int size = SIZE_UPDATER.get(this);\n+            int newCapacity = data.length * 2;\n+            T[] newData = (T[]) new Object[newCapacity];\n+\n+            int oldHeadIndex = headIndex.value;\n+            int newTailIndex = 0;\n+\n+            for (int i = 0; i < size; i++) {\n+                newData[newTailIndex++] = data[oldHeadIndex];\n+                oldHeadIndex = (oldHeadIndex + 1) & (data.length - 1);\n+            }\n+\n+            data = newData;\n+            headIndex.value = 0;\n+            tailIndex.value = size;\n+        } finally {\n+            headLock.unlock();\n+        }\n+    }\n+\n+    final static class PaddedInt {\n+        private int value;\n+\n+        // Padding to avoid false sharing\n+        public volatile int pi1 = 1;\n+        public volatile long p1 = 1L, p2 = 2L, p3 = 3L, p4 = 4L, p5 = 5L, p6 = 6L;\n+\n+        public long exposeToAvoidOptimization() {\n+            return pi1 + p1 + p2 + p3 + p4 + p5 + p6;\n+        }\n+    }\n+}"},{"sha":"9fd7e844caabd3e44a925f01245b4d24e926f462","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/util/collections/GrowableArrayBlockingQueueTest.java","status":"added","additions":206,"deletions":0,"changes":206,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/e2894a9e9946b4cc4647c280094bcb2eb1a521ea/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2Fcollections%2FGrowableArrayBlockingQueueTest.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/e2894a9e9946b4cc4647c280094bcb2eb1a521ea/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2Fcollections%2FGrowableArrayBlockingQueueTest.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2Fcollections%2FGrowableArrayBlockingQueueTest.java?ref=e2894a9e9946b4cc4647c280094bcb2eb1a521ea","patch":"@@ -0,0 +1,206 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.util.collections;\n+\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+import static org.junit.Assert.assertEquals;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.junit.Test;\n+\n+import com.google.common.collect.Lists;\n+\n+public class GrowableArrayBlockingQueueTest {\n+\n+    @Test\n+    public void simple() throws Exception {\n+        BlockingQueue<Integer> queue = new GrowableArrayBlockingQueue<>(4);\n+\n+        assertEquals(null, queue.poll());\n+\n+        assertEquals(Integer.MAX_VALUE, queue.remainingCapacity());\n+        assertEquals(\"[]\", queue.toString());\n+\n+        try {\n+            queue.element();\n+            fail(\"Should have thrown exception\");\n+        } catch (NoSuchElementException e) {\n+            // Expected\n+        }\n+\n+        try {\n+            queue.iterator();\n+            fail(\"Should have thrown exception\");\n+        } catch (UnsupportedOperationException e) {\n+            // Expected\n+        }\n+\n+        // Test index rollover\n+        for (int i = 0; i < 100; i++) {\n+            queue.add(i);\n+\n+            assertEquals(i, queue.take().intValue());\n+        }\n+\n+        queue.offer(1);\n+        assertEquals(\"[1]\", queue.toString());\n+        queue.offer(2);\n+        assertEquals(\"[1, 2]\", queue.toString());\n+        queue.offer(3);\n+        assertEquals(\"[1, 2, 3]\", queue.toString());\n+        queue.offer(4);\n+        assertEquals(\"[1, 2, 3, 4]\", queue.toString());\n+\n+        assertEquals(4, queue.size());\n+\n+        List<Integer> list = new ArrayList<>();\n+        queue.drainTo(list, 3);\n+\n+        assertEquals(1, queue.size());\n+        assertEquals(Lists.newArrayList(1, 2, 3), list);\n+        assertEquals(\"[4]\", queue.toString());\n+        assertEquals(4, queue.peek().intValue());\n+\n+        assertEquals(4, queue.element().intValue());\n+        assertEquals(4, queue.remove().intValue());\n+        try {\n+            queue.remove();\n+            fail(\"Should have thrown exception\");\n+        } catch (NoSuchElementException e) {\n+            // Expected\n+        }\n+    }\n+\n+    @Test(timeout = 10000)\n+    public void blockingTake() throws Exception {\n+        BlockingQueue<Integer> queue = new GrowableArrayBlockingQueue<>();\n+\n+        CountDownLatch latch = new CountDownLatch(1);\n+\n+        new Thread(() -> {\n+            try {\n+                int expected = 0;\n+\n+                for (int i = 0; i < 100; i++) {\n+                    int n = queue.take();\n+\n+                    assertEquals(expected++, n);\n+                }\n+\n+                latch.countDown();\n+            } catch (Exception e) {\n+                e.printStackTrace();\n+            }\n+        }).start();\n+\n+        int n = 0;\n+        for (int i = 0; i < 10; i++) {\n+            for (int j = 0; j < 10; j++) {\n+                queue.put(n);\n+                ++n;\n+            }\n+\n+            // Wait until all the entries are consumed\n+            while (!queue.isEmpty()) {\n+                Thread.sleep(1);\n+            }\n+        }\n+\n+        latch.await();\n+    }\n+\n+    @Test\n+    public void growArray() throws Exception {\n+        BlockingQueue<Integer> queue = new GrowableArrayBlockingQueue<>(4);\n+\n+        assertEquals(null, queue.poll());\n+\n+        assertTrue(queue.offer(1));\n+        assertTrue(queue.offer(2));\n+        assertTrue(queue.offer(3));\n+        assertTrue(queue.offer(4));\n+        assertTrue(queue.offer(5));\n+\n+        assertEquals(5, queue.size());\n+\n+        queue.clear();\n+        assertEquals(0, queue.size());\n+\n+        assertTrue(queue.offer(1, 1, TimeUnit.SECONDS));\n+        assertTrue(queue.offer(2, 1, TimeUnit.SECONDS));\n+        assertTrue(queue.offer(3, 1, TimeUnit.SECONDS));\n+        assertEquals(3, queue.size());\n+\n+        List<Integer> list = new ArrayList<>();\n+        queue.drainTo(list);\n+        assertEquals(0, queue.size());\n+\n+        assertEquals(Lists.newArrayList(1, 2, 3), list);\n+    }\n+\n+    @Test(timeout = 10000)\n+    public void pollTimeout() throws Exception {\n+        BlockingQueue<Integer> queue = new GrowableArrayBlockingQueue<>(4);\n+\n+        assertEquals(null, queue.poll(1, TimeUnit.MILLISECONDS));\n+\n+        queue.put(1);\n+        assertEquals(1, queue.poll(1, TimeUnit.MILLISECONDS).intValue());\n+\n+        // 0 timeout should not block\n+        assertEquals(null, queue.poll(0, TimeUnit.HOURS));\n+\n+        queue.put(2);\n+        queue.put(3);\n+        assertEquals(2, queue.poll(1, TimeUnit.HOURS).intValue());\n+        assertEquals(3, queue.poll(1, TimeUnit.HOURS).intValue());\n+    }\n+\n+    @Test(timeout = 10000)\n+    public void pollTimeout2() throws Exception {\n+        BlockingQueue<Integer> queue = new GrowableArrayBlockingQueue<>();\n+\n+        CountDownLatch latch = new CountDownLatch(1);\n+\n+        new Thread(() -> {\n+            try {\n+                queue.poll(1, TimeUnit.HOURS);\n+\n+                latch.countDown();\n+            } catch (Exception e) {\n+                e.printStackTrace();\n+            }\n+        }).start();\n+\n+        // Make sure background thread is waiting on poll\n+        Thread.sleep(100);\n+        queue.put(1);\n+\n+        latch.await();\n+    }\n+}"}]}