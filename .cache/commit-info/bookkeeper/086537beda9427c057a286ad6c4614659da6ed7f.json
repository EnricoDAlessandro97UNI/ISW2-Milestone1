{"sha":"086537beda9427c057a286ad6c4614659da6ed7f","node_id":"MDY6Q29tbWl0NDc4NTkyNTI2OjA4NjUzN2JlZGE5NDI3YzA1N2EyODZhZDZjNDYxNDY1OWRhNmVkN2Y=","commit":{"author":{"name":"sigee","email":"sigee15@gmail.com","date":"2017-07-18T03:02:03Z"},"committer":{"name":"jiazhai","email":"zhaijia@live.com","date":"2017-07-18T03:02:03Z"},"message":"ISSUE #230: Add Checkstyle to the build process (Part 2)\n\nFix issues checkstyle reported in\n  - org.apache.bookkeeper.auth\n  - org.apache.bookkeeper.bookie\n\nCheckstyle is not added to the bookkeeper-server yet.\n\n---\nBe sure to do all of the following to help us incorporate your contribution\nquickly and easily:\n\n- [X] Make sure the PR title is formatted like:\n    `<Issue # or BOOKKEEPER-#>: Description of pull request`\n    `e.g. Issue 123: Description ...`\n    `e.g. BOOKKEEPER-1234: Description ...`\n- [ ] Make sure tests pass via `mvn clean apache-rat:check install findbugs:check`.\n- [X] Replace `<Issue # or BOOKKEEPER-#>` in the title with the actual Issue/JIRA number.\n\n---\n\nAuthor: sigee <sigee15@gmail.com>\n\nReviewers: Jia Zhai <None>, Sijie Guo <None>\n\nThis closes #234 from sigee/checkstyle2, closes #230","tree":{"sha":"08686e16e8b0a92957b7a52c4987d88cb92d94cf","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/trees/08686e16e8b0a92957b7a52c4987d88cb92d94cf"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/commits/086537beda9427c057a286ad6c4614659da6ed7f","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/086537beda9427c057a286ad6c4614659da6ed7f","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/086537beda9427c057a286ad6c4614659da6ed7f","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/086537beda9427c057a286ad6c4614659da6ed7f/comments","author":{"login":"sigee","id":6528240,"node_id":"MDQ6VXNlcjY1MjgyNDA=","avatar_url":"https://avatars.githubusercontent.com/u/6528240?v=4","gravatar_id":"","url":"https://api.github.com/users/sigee","html_url":"https://github.com/sigee","followers_url":"https://api.github.com/users/sigee/followers","following_url":"https://api.github.com/users/sigee/following{/other_user}","gists_url":"https://api.github.com/users/sigee/gists{/gist_id}","starred_url":"https://api.github.com/users/sigee/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sigee/subscriptions","organizations_url":"https://api.github.com/users/sigee/orgs","repos_url":"https://api.github.com/users/sigee/repos","events_url":"https://api.github.com/users/sigee/events{/privacy}","received_events_url":"https://api.github.com/users/sigee/received_events","type":"User","site_admin":false},"committer":null,"parents":[{"sha":"1b79adaae7ffd4736530bd1088b45de8ac049f98","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/1b79adaae7ffd4736530bd1088b45de8ac049f98","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/1b79adaae7ffd4736530bd1088b45de8ac049f98"}],"stats":{"total":1555,"additions":794,"deletions":761},"files":[{"sha":"27f9ac55c6ebc18847fb7547ab993a083e1516ec","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/auth/AuthCallbacks.java","status":"modified","additions":4,"deletions":1,"changes":5,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fauth%2FAuthCallbacks.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fauth%2FAuthCallbacks.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fauth%2FAuthCallbacks.java?ref=086537beda9427c057a286ad6c4614659da6ed7f","patch":"@@ -17,10 +17,13 @@\n package org.apache.bookkeeper.auth;\n \n /**\n- * Callbacks for AuthProviders\n+ * Callbacks for AuthProviders.\n  */\n public abstract class AuthCallbacks {\n \n+    /**\n+     * @TODO: Write JavaDoc comment {@link https://github.com/apache/bookkepeer/issues/247}\n+     */\n     public interface GenericCallback<T> {\n \n         void operationComplete(int rc, T result);"},{"sha":"f84dfb3b7983f87b2560c718d75d0aee500bda3d","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/auth/AuthProviderFactoryFactory.java","status":"modified","additions":6,"deletions":7,"changes":13,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fauth%2FAuthProviderFactoryFactory.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fauth%2FAuthProviderFactoryFactory.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fauth%2FAuthProviderFactoryFactory.java?ref=086537beda9427c057a286ad6c4614659da6ed7f","patch":"@@ -26,14 +26,13 @@\n import org.apache.bookkeeper.conf.ClientConfiguration;\n import org.apache.bookkeeper.conf.ServerConfiguration;\n import org.apache.bookkeeper.util.ReflectionUtils;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n import org.apache.bookkeeper.client.ClientConnectionPeer;\n import org.apache.bookkeeper.bookie.BookieConnectionPeer;\n \n-\n+/**\n+ * @TODO: Write JavaDoc comment {@link https://github.com/apache/bookkepeer/issues/247}\n+ */\n public class AuthProviderFactoryFactory {\n-    static Logger LOG = LoggerFactory.getLogger(AuthProviderFactoryFactory.class);\n \n     public static BookieAuthProvider.Factory newBookieAuthProviderFactory(ServerConfiguration conf) throws IOException {\n         String factoryClassName = conf.getBookieAuthProviderFactoryClass();\n@@ -61,12 +60,12 @@ public static ClientAuthProvider.Factory newClientAuthProviderFactory(ClientConf\n         return factory;\n     }\n \n-    public final static String authenticationDisabledPluginName = \"AuthDisabledPlugin\";\n+    public static final String AUTHENTICATION_DISABLED_PLUGIN_NAME = \"AuthDisabledPlugin\";\n \n     private static class AuthenticationDisabledAuthProviderFactory implements BookieAuthProvider.Factory {\n         @Override\n         public String getPluginName() {\n-            return authenticationDisabledPluginName;\n+            return AUTHENTICATION_DISABLED_PLUGIN_NAME;\n         }\n \n         @Override\n@@ -90,7 +89,7 @@ public void process(AuthToken m, AuthCallbacks.GenericCallback<AuthToken> cb) {\n     private static class NullClientAuthProviderFactory implements ClientAuthProvider.Factory {\n         @Override\n         public String getPluginName() {\n-            return authenticationDisabledPluginName;\n+            return AUTHENTICATION_DISABLED_PLUGIN_NAME;\n         }\n \n         @Override"},{"sha":"918d91001a5fe511675b3614d4ae05424475f614","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/auth/AuthToken.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fauth%2FAuthToken.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fauth%2FAuthToken.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fauth%2FAuthToken.java?ref=086537beda9427c057a286ad6c4614659da6ed7f","patch":"@@ -21,7 +21,7 @@\n package org.apache.bookkeeper.auth;\n \n /**\n- * A generic payload for Authentication Messages\n+ * A generic payload for Authentication Messages.\n  */\n public class AuthToken {\n "},{"sha":"41eade56ed33fd4200c240005293be8b7850001a","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/auth/BookKeeperPrincipal.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fauth%2FBookKeeperPrincipal.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fauth%2FBookKeeperPrincipal.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fauth%2FBookKeeperPrincipal.java?ref=086537beda9427c057a286ad6c4614659da6ed7f","patch":"@@ -23,7 +23,7 @@\n import java.util.Objects;\n \n /**\n- * A Principal is the user bound to the connection\n+ * A Principal is the user bound to the connection.\n  */\n public class BookKeeperPrincipal {\n "},{"sha":"cd0a0bb146615b5e8ca3bf94b80e2f9486664685","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/auth/BookieAuthProvider.java","status":"modified","additions":5,"deletions":2,"changes":7,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fauth%2FBookieAuthProvider.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fauth%2FBookieAuthProvider.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fauth%2FBookieAuthProvider.java?ref=086537beda9427c057a286ad6c4614659da6ed7f","patch":"@@ -32,6 +32,9 @@\n  * an authentication mechanism for bookkeeper connections.\n  */\n public interface BookieAuthProvider {\n+    /**\n+     * @TODO: Write JavaDoc comment {@link https://github.com/apache/bookkepeer/issues/247}\n+     */\n     interface Factory {\n         /**\n          * Initialize the factory with the server configuration\n@@ -69,7 +72,7 @@ BookieAuthProvider newProvider(BookieConnectionPeer connection,\n         String getPluginName();\n \n         /**\n-        * Release resources\n+        * Release resources.\n         */\n         default void close() {}\n     }\n@@ -83,7 +86,7 @@ default void close() {}\n     void process(AuthToken m, AuthCallbacks.GenericCallback<AuthToken> cb);\n \n     /**\n-     * Release resources\n+     * Release resources.\n      */\n     default void close() {}\n }"},{"sha":"043cea2bfecedf37c0954e2465347134fd293917","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/auth/ClientAuthProvider.java","status":"modified","additions":5,"deletions":2,"changes":7,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fauth%2FClientAuthProvider.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fauth%2FClientAuthProvider.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fauth%2FClientAuthProvider.java?ref=086537beda9427c057a286ad6c4614659da6ed7f","patch":"@@ -31,6 +31,9 @@\n  * an authentication mechanism for bookkeeper connections.\n  */\n public interface ClientAuthProvider {\n+    /**\n+     * @TODO: Write JavaDoc comment {@link https://github.com/apache/bookkepeer/issues/247}\n+     */\n     interface Factory {\n         /**\n          * Initialize the factory with the client configuration\n@@ -66,7 +69,7 @@ ClientAuthProvider newProvider(ClientConnectionPeer connection,\n         String getPluginName();\n \n         /**\n-        * Release resources\n+        * Release resources.\n         */\n         default void close() {}\n     }\n@@ -88,7 +91,7 @@ default void close() {}\n     void process(AuthToken m, AuthCallbacks.GenericCallback<AuthToken> cb);\n \n     /**\n-     * Release resources\n+     * Release resources.\n      */\n     default void close() {}\n }"},{"sha":"5c86fab253747046311f4fe71a016dc94b937673","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/auth/package-info.java","status":"added","additions":20,"deletions":0,"changes":20,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fauth%2Fpackage-info.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fauth%2Fpackage-info.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fauth%2Fpackage-info.java?ref=086537beda9427c057a286ad6c4614659da6ed7f","patch":"@@ -0,0 +1,20 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership. The ASF\n+ * licenses this file to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+/**\n+ * @TODO: Write JavaDoc comment {@link https://github.com/apache/bookkepeer/issues/247}\n+ */\n+package org.apache.bookkeeper.auth;\n\\ No newline at end of file"},{"sha":"eae8f1a081846347638a324e1d1d938529d60156","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BookKeeperServerStats.java","status":"modified","additions":3,"deletions":0,"changes":3,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FBookKeeperServerStats.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FBookKeeperServerStats.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FBookKeeperServerStats.java?ref=086537beda9427c057a286ad6c4614659da6ed7f","patch":"@@ -20,6 +20,9 @@\n  */\n package org.apache.bookkeeper.bookie;\n \n+/**\n+ * @TODO: Write JavaDoc comment {@link https://github.com/apache/bookkepeer/issues/247}\n+ */\n public interface BookKeeperServerStats {\n \n     String SERVER_SCOPE = \"bookkeeper_server\";"},{"sha":"15bd6340fecb2433d83c592ad03b8674302fa9ea","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java","status":"modified","additions":56,"deletions":57,"changes":113,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FBookie.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FBookie.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FBookie.java?ref=086537beda9427c057a286ad6c4614659da6ed7f","patch":"@@ -116,7 +116,7 @@\n  */\n public class Bookie extends BookieCriticalThread {\n \n-    private final static Logger LOG = LoggerFactory.getLogger(Bookie.class);\n+    private static final Logger LOG = LoggerFactory.getLogger(Bookie.class);\n \n     final List<File> journalDirectories;\n     final ServerConfiguration conf;\n@@ -138,7 +138,7 @@ public class Bookie extends BookieCriticalThread {\n \n     private final LedgerDirsManager ledgerDirsManager;\n     private LedgerDirsManager indexDirsManager;\n-    \n+\n     LedgerDirsMonitor ledgerMonitor;\n     LedgerDirsMonitor idxMonitor;\n \n@@ -154,12 +154,12 @@ public class Bookie extends BookieCriticalThread {\n \n     private final ConcurrentLongHashMap<byte[]> masterKeyCache = new ConcurrentLongHashMap<>();\n \n-    final protected String zkBookieRegPath;\n-    final protected String zkBookieReadOnlyPath;\n-    final protected List<ACL> zkAcls;\n+    protected final String zkBookieRegPath;\n+    protected final String zkBookieReadOnlyPath;\n+    protected final List<ACL> zkAcls;\n \n-    final private AtomicBoolean zkRegistered = new AtomicBoolean(false);\n-    final protected AtomicBoolean readOnly = new AtomicBoolean(false);\n+    private final AtomicBoolean zkRegistered = new AtomicBoolean(false);\n+    protected final AtomicBoolean readOnly = new AtomicBoolean(false);\n     // executor to manage the state changes for a bookie.\n     final ExecutorService stateService = Executors.newSingleThreadExecutor(\n             new ThreadFactoryBuilder().setNameFormat(\"BookieStateService-%d\").build());\n@@ -175,6 +175,9 @@ public class Bookie extends BookieCriticalThread {\n     private final OpStatsLogger addBytesStats;\n     private final OpStatsLogger readBytesStats;\n \n+    /**\n+     * @TODO: Write JavaDoc comment {@link https://github.com/apache/bookkepeer/issues/247}\n+     */\n     public static class NoLedgerException extends IOException {\n         private static final long serialVersionUID = 1L;\n         private final long ledgerId;\n@@ -186,6 +189,10 @@ public long getLedgerId() {\n             return ledgerId;\n         }\n     }\n+\n+    /**\n+     * @TODO: Write JavaDoc comment {@link https://github.com/apache/bookkepeer/issues/247}\n+     */\n     public static class NoEntryException extends IOException {\n         private static final long serialVersionUID = 1L;\n         private final long ledgerId;\n@@ -319,8 +326,8 @@ private void checkEnvironment(ZooKeeper zk) throws BookieException, IOException\n             for (File journalDirectory : journalDirectories) {\n                 checkDirectoryStructure(journalDirectory);\n             }\n-            if(!newEnv){\n-                for(Cookie journalCookie: journalCookies) {\n+            if (!newEnv) {\n+                for (Cookie journalCookie: journalCookies) {\n                     masterCookie.verify(journalCookie);\n                 }\n             }\n@@ -342,7 +349,7 @@ private void checkEnvironment(ZooKeeper zk) throws BookieException, IOException\n                 // Also, if a new ledger dir is being added, we make sure that\n                 // that dir is empty. Else, we reject the request\n                 Set<String> existingLedgerDirs = Sets.newHashSet();\n-                for(Cookie journalCookie : journalCookies) {\n+                for (Cookie journalCookie : journalCookies) {\n                     Collections.addAll(existingLedgerDirs, journalCookie.getLedgerDirPathsFromCookie());\n                 }\n                 List<File> dirsMissingData = new ArrayList<File>();\n@@ -378,7 +385,7 @@ private void checkEnvironment(ZooKeeper zk) throws BookieException, IOException\n                 }\n                 masterCookie.writeToZooKeeper(zk, conf, zkCookie != null ? zkCookie.getVersion() : Version.NEW);\n             }\n-            \n+\n             List<File> ledgerDirs = ledgerDirsManager.getAllLedgerDirs();\n             checkIfDirsOnSameDiskPartition(ledgerDirs);\n             List<File> indexDirs = indexDirsManager.getAllLedgerDirs();\n@@ -404,9 +411,9 @@ private void checkEnvironment(ZooKeeper zk) throws BookieException, IOException\n      * If ALLOW_MULTIPLEDIRS_UNDER_SAME_DISKPARTITION config parameter is not enabled, and\n      * if it is found that there are multiple directories in the same DiskPartition then\n      * it will throw DiskPartitionDuplicationException.\n-     * \n+     *\n      * @param dirs dirs to validate\n-     * \n+     *\n      * @throws IOException\n      */\n     private void checkIfDirsOnSameDiskPartition(List<File> dirs) throws DiskPartitionDuplicationException {\n@@ -444,7 +451,7 @@ private void checkIfDirsOnSameDiskPartition(List<File> dirs) throws DiskPartitio\n             throw new BookieException.DiskPartitionDuplicationException();\n         }\n     }\n-    \n+\n     public static void checkEnvironmentWithStorageExpansion(ServerConfiguration conf,\n             ZooKeeper zk, List<File> journalDirectories, List<File> allLedgerDirs) throws BookieException, IOException {\n         try {\n@@ -488,8 +495,8 @@ public static void checkEnvironmentWithStorageExpansion(ServerConfiguration conf\n             for (File journalDirectory : journalDirectories) {\n                 checkDirectoryStructure(journalDirectory);\n             }\n-            if(!newEnv){\n-                for(Cookie journalCookie: journalCookies) {\n+            if (!newEnv) {\n+                for (Cookie journalCookie: journalCookies) {\n                     masterCookie.verifyIsSuperSet(journalCookie);\n                 }\n             }\n@@ -511,7 +518,7 @@ public static void checkEnvironmentWithStorageExpansion(ServerConfiguration conf\n                 // Also, if a new ledger dir is being added, we make sure that\n                 // that dir is empty. Else, we reject the request\n                 Set<String> existingLedgerDirs = Sets.newHashSet();\n-                for(Cookie journalCookie : journalCookies) {\n+                for (Cookie journalCookie : journalCookies) {\n                     Collections.addAll(existingLedgerDirs, journalCookie.getLedgerDirPathsFromCookie());\n                 }\n                 List<File> dirsMissingData = new ArrayList<File>();\n@@ -678,7 +685,7 @@ public Bookie(ServerConfiguration conf, StatsLogger statsLogger)\n             this.ledgerMonitor.init();\n         } catch (NoWritableLedgerDirException nle) {\n             // start in read-only mode if no writable dirs and read-only allowed\n-            if(!conf.isReadOnlyModeEnabled()) {\n+            if (!conf.isReadOnlyModeEnabled()) {\n                 throw nle;\n             } else {\n                 this.transitionToReadOnlyMode();\n@@ -693,7 +700,7 @@ public Bookie(ServerConfiguration conf, StatsLogger statsLogger)\n                 this.idxMonitor.init();\n             } catch (NoWritableLedgerDirException nle) {\n                 // start in read-only mode if no writable dirs and read-only allowed\n-                if(!conf.isReadOnlyModeEnabled()) {\n+                if (!conf.isReadOnlyModeEnabled()) {\n                     throw nle;\n                 } else {\n                     this.transitionToReadOnlyMode();\n@@ -708,7 +715,7 @@ public Bookie(ServerConfiguration conf, StatsLogger statsLogger)\n \n         // instantiate the journals\n         journals = Lists.newArrayList();\n-        for(int i=0 ;i<journalDirectories.size();i++) {\n+        for (int i = 0; i < journalDirectories.size(); i++) {\n             journals.add(new Journal(journalDirectories.get(i),\n                          conf, ledgerDirsManager, statsLogger.scope(JOURNAL_SCOPE + \"_\" + i)));\n         }\n@@ -719,9 +726,9 @@ public Bookie(ServerConfiguration conf, StatsLogger statsLogger)\n         String ledgerStorageClass = conf.getLedgerStorageClass();\n         LOG.info(\"Using ledger storage: {}\", ledgerStorageClass);\n         ledgerStorage = LedgerStorageFactory.createLedgerStorage(ledgerStorageClass);\n-        ledgerStorage.initialize(conf, ledgerManager, ledgerDirsManager, indexDirsManager, checkpointSource, statsLogger);\n-        syncThread = new SyncThread(conf, getLedgerDirsListener(),\n-                                    ledgerStorage, checkpointSource);\n+        ledgerStorage.initialize(conf, ledgerManager, ledgerDirsManager, indexDirsManager, checkpointSource,\n+                                 statsLogger);\n+        syncThread = new SyncThread(conf, getLedgerDirsListener(), ledgerStorage, checkpointSource);\n         handles = new HandleFactoryImpl(ledgerStorage);\n \n         // Expose Stats\n@@ -814,7 +821,7 @@ public void process(int journalVersion, long offset, ByteBuffer recBuff) throws\n     }\n \n     @Override\n-    synchronized public void start() {\n+    public synchronized void start() {\n         setDaemon(true);\n         if (LOG.isDebugEnabled()) {\n             LOG.debug(\"I'm starting a bookie with journal directories {}\",\n@@ -926,10 +933,9 @@ private ZooKeeper instantiateZookeeperClient(ServerConfiguration conf)\n     }\n \n     /**\n-     * Check existence of <i>regPath</i> and wait it expired if possible\n+     * Check existence of <i>regPath</i> and wait it expired if possible.\n      *\n-     * @param regPath\n-     *          reg node path.\n+     * @param regPath reg node path.\n      * @return true if regPath exists, otherwise return false\n      * @throws IOException if can't create reg path\n      */\n@@ -976,7 +982,7 @@ public void process(WatchedEvent event) {\n     }\n \n     /**\n-     * Register as an available bookie\n+     * Register as an available bookie.\n      */\n     protected Future<Void> registerBookie(final boolean throwException) {\n         return stateService.submit(new Callable<Void>() {\n@@ -992,7 +998,7 @@ public Void call() throws IOException {\n                         triggerBookieShutdown(ExitCode.ZK_REG_FAIL);\n                     }\n                 }\n-                return (Void)null;\n+                return (Void) null;\n             }\n         });\n     }\n@@ -1010,11 +1016,10 @@ private void doRegisterBookie(final String regPath) throws IOException {\n         zkRegistered.set(false);\n \n         // ZK ephemeral node for this Bookie.\n-        try{\n+        try {\n             if (!checkRegNodeAndWaitExpired(regPath)) {\n                 // Create the ZK ephemeral node for this Bookie.\n-                zk.create(regPath, new byte[0], zkAcls,\n-                        CreateMode.EPHEMERAL);\n+                zk.create(regPath, new byte[0], zkAcls, CreateMode.EPHEMERAL);\n                 LOG.info(\"Registered myself in ZooKeeper at {}.\", regPath);\n             }\n             zkRegistered.set(true);\n@@ -1025,8 +1030,7 @@ private void doRegisterBookie(final String regPath) throws IOException {\n             // exit here as this is a fatal error.\n             throw new IOException(ke);\n         } catch (InterruptedException ie) {\n-            LOG.error(\"Interrupted exception registering ephemeral Znode for Bookie!\",\n-                    ie);\n+            LOG.error(\"Interrupted exception registering ephemeral Znode for Bookie!\", ie);\n             // Throw an IOException back up. This will cause the Bookie\n             // constructor to error out. Alternatively, we could do a System\n             // exit here as this is a fatal error.\n@@ -1035,7 +1039,7 @@ private void doRegisterBookie(final String regPath) throws IOException {\n     }\n \n     /**\n-     * Transition the bookie from readOnly mode to writable\n+     * Transition the bookie from readOnly mode to writable.\n      */\n     private Future<Void> transitionToWritableMode() {\n         return stateService.submit(new Callable<Void>() {\n@@ -1083,14 +1087,14 @@ public void doTransitionToWritableMode() {\n     }\n \n     /**\n-     * Transition the bookie to readOnly mode\n+     * Transition the bookie to readOnly mode.\n      */\n     private Future<Void> transitionToReadOnlyMode() {\n         return stateService.submit(new Callable<Void>() {\n             @Override\n             public Void call() {\n                 doTransitionToReadOnlyMode();\n-                return (Void)null;\n+                return (Void) null;\n             }\n         });\n     }\n@@ -1188,8 +1192,7 @@ public void process(WatchedEvent event) {\n                     return;\n                 }\n                 // Check for expired connection.\n-                if (event.getType().equals(EventType.None) &&\n-                    event.getState().equals(KeeperState.Expired)) {\n+                if (event.getType().equals(EventType.None) && event.getState().equals(KeeperState.Expired)) {\n                     zkRegistered.set(false);\n                     // schedule a re-register operation\n                     registerBookie(false);\n@@ -1431,7 +1434,7 @@ public ByteBuf getExplicitLac(long ledgerId) throws IOException, Bookie.NoLedger\n      * @throws BookieException.LedgerFencedException if the ledger is fenced\n      */\n     public void addEntry(ByteBuf entry, WriteCallback cb, Object ctx, byte[] masterKey)\n-            throws IOException, BookieException {\n+            throws IOException, BookieException.LedgerFencedException, BookieException {\n         long requestNanos = MathUtils.nowInNano();\n         boolean success = false;\n         int entrySize = 0;\n@@ -1462,7 +1465,7 @@ public void addEntry(ByteBuf entry, WriteCallback cb, Object ctx, byte[] masterK\n             entry.release();\n         }\n     }\n-    \n+\n     static class FutureWriteCallback implements WriteCallback {\n \n         SettableFuture<Boolean> result = SettableFuture.create();\n@@ -1525,8 +1528,9 @@ public long readLastAddConfirmed(long ledgerId) throws IOException {\n         LedgerDescriptor handle = handles.getReadOnlyHandle(ledgerId);\n         return handle.getLastAddConfirmed();\n     }\n-    \n-    public Observable waitForLastAddConfirmedUpdate(long ledgerId, long previoisLAC, Observer observer) throws IOException {\n+\n+    public Observable waitForLastAddConfirmedUpdate(long ledgerId, long previoisLAC, Observer observer)\n+            throws IOException {\n         LedgerDescriptor handle = handles.getReadOnlyHandle(ledgerId);\n         return handle.waitForLastAddConfirmedUpdate(previoisLAC, observer);\n     }\n@@ -1536,35 +1540,30 @@ static class CounterCallback implements WriteCallback {\n         int count;\n \n         @Override\n-        synchronized public void writeComplete(int rc, long l, long e, BookieSocketAddress addr, Object ctx) {\n+        public synchronized void writeComplete(int rc, long l, long e, BookieSocketAddress addr, Object ctx) {\n             count--;\n             if (count == 0) {\n                 notifyAll();\n             }\n         }\n \n-        synchronized public void incCount() {\n+        public synchronized void incCount() {\n             count++;\n         }\n \n-        synchronized public void waitZero() throws InterruptedException {\n+        public synchronized void waitZero() throws InterruptedException {\n             while (count > 0) {\n                 wait();\n             }\n         }\n     }\n \n     /**\n-     * Format the bookie server data\n+     * Format the bookie server data.\n      *\n-     * @param conf\n-     *            ServerConfiguration\n-     * @param isInteractive\n-     *            Whether format should ask prompt for confirmation if old data\n-     *            exists or not.\n-     * @param force\n-     *            If non interactive and force is true, then old data will be\n-     *            removed without confirm prompt.\n+     * @param conf ServerConfiguration\n+     * @param isInteractive Whether format should ask prompt for confirmation if old data exists or not.\n+     * @param force If non interactive and force is true, then old data will be removed without confirm prompt.\n      * @return Returns true if the format is success else returns false\n      */\n     public static boolean format(ServerConfiguration conf,\n@@ -1665,11 +1664,11 @@ public static void main(String[] args)\n         }\n         cb.waitZero();\n         long end = MathUtils.now();\n-        System.out.println(\"Took \" + (end-start) + \"ms\");\n+        System.out.println(\"Took \" + (end - start) + \"ms\");\n     }\n \n     /**\n-     * Returns exit code - cause of failure\n+     * Returns exit code - cause of failure.\n      *\n      * @return {@link ExitCode}\n      */"},{"sha":"63a5e7d62b944db94b4a063cfdcb2b39519779a3","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BookieConnectionPeer.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FBookieConnectionPeer.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FBookieConnectionPeer.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FBookieConnectionPeer.java?ref=086537beda9427c057a286ad6c4614659da6ed7f","patch":"@@ -23,7 +23,7 @@\n import org.apache.bookkeeper.proto.ConnectionPeer;\n \n /**\n- * Represents the connection to a BookKeeper client, from the Bookie side \n+ * Represents the connection to a BookKeeper client, from the Bookie side.\n  */\n public interface BookieConnectionPeer extends ConnectionPeer {\n "},{"sha":"c62d611e3fea6d586e4f474f159f5384b83b964e","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BookieException.java","status":"modified","additions":21,"deletions":3,"changes":24,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FBookieException.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FBookieException.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FBookieException.java?ref=086537beda9427c057a286ad6c4614659da6ed7f","patch":"@@ -21,9 +21,9 @@\n  *\n  */\n \n-\n-import java.lang.Exception;\n-\n+/**\n+ * @TODO: Write JavaDoc comment {@link https://github.com/apache/bookkepeer/issues/247}\n+ */\n @SuppressWarnings(\"serial\")\n public abstract class BookieException extends Exception {\n \n@@ -57,6 +57,9 @@ public static BookieException create(int code) {\n         }\n     }\n \n+    /**\n+     * @TODO: Write JavaDoc comment {@link https://github.com/apache/bookkepeer/issues/247}\n+     */\n     public interface Code {\n         int OK = 0;\n         int UnauthorizedAccessException = -1;\n@@ -115,24 +118,36 @@ public String getMessage(int code) {\n         }\n     }\n \n+    /**\n+     * @TODO: Write JavaDoc comment {@link https://github.com/apache/bookkepeer/issues/247}\n+     */\n     public static class BookieUnauthorizedAccessException extends BookieException {\n         public BookieUnauthorizedAccessException() {\n             super(Code.UnauthorizedAccessException);\n         }\n     }\n \n+    /**\n+     * @TODO: Write JavaDoc comment {@link https://github.com/apache/bookkepeer/issues/247}\n+     */\n     public static class BookieIllegalOpException extends BookieException {\n         public BookieIllegalOpException() {\n             super(Code.UnauthorizedAccessException);\n         }\n     }\n \n+    /**\n+     * @TODO: Write JavaDoc comment {@link https://github.com/apache/bookkepeer/issues/247}\n+     */\n     public static class LedgerFencedException extends BookieException {\n         public LedgerFencedException() {\n             super(Code.LedgerFencedException);\n         }\n     }\n \n+    /**\n+     * @TODO: Write JavaDoc comment {@link https://github.com/apache/bookkepeer/issues/247}\n+     */\n     public static class InvalidCookieException extends BookieException {\n         public InvalidCookieException() {\n             this(\"\");\n@@ -147,6 +162,9 @@ public InvalidCookieException(Throwable cause) {\n         }\n     }\n \n+    /**\n+     * @TODO: Write JavaDoc comment {@link https://github.com/apache/bookkepeer/issues/247}\n+     */\n     public static class UpgradeException extends BookieException {\n         public UpgradeException() {\n             super(Code.UpgradeException);"},{"sha":"fc4d5e8e4262c2cb84682539314799df8723e866","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BookieShell.java","status":"modified","additions":84,"deletions":99,"changes":183,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FBookieShell.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FBookieShell.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FBookieShell.java?ref=086537beda9427c057a286ad6c4614659da6ed7f","patch":"@@ -131,7 +131,7 @@ public class BookieShell implements Tool {\n     static final String CMD_DELETELEDGER = \"deleteledger\";\n     static final String CMD_BOOKIEINFO = \"bookieinfo\";\n     static final String CMD_DECOMMISSIONBOOKIE = \"decommissionbookie\";\n-    static final String CMD_LOSTBOOKIERECOVERYDELAY = \"lostbookierecoverydelay\"; \n+    static final String CMD_LOSTBOOKIERECOVERYDELAY = \"lostbookierecoverydelay\";\n     static final String CMD_TRIGGERAUDIT = \"triggeraudit\";\n     static final String CMD_HELP = \"help\";\n \n@@ -148,8 +148,8 @@ public class BookieShell implements Tool {\n     int entriesPerPage;\n \n     interface Command {\n-        public int runCmd(String[] args) throws Exception;\n-        public void printUsage();\n+        int runCmd(String[] args) throws Exception;\n+        void printUsage();\n     }\n \n     abstract class MyCommand implements Command {\n@@ -186,7 +186,7 @@ public void printUsage() {\n     }\n \n     /**\n-     * Format the bookkeeper metadata present in zookeeper\n+     * Format the bookkeeper metadata present in zookeeper.\n      */\n     class MetaFormatCmd extends MyCommand {\n         Options opts = new Options();\n@@ -228,7 +228,7 @@ int runCmd(CommandLine cmdLine) throws Exception {\n     }\n \n     /**\n-     * Formats the local data present in current bookie server\n+     * Formats the local data present in current bookie server.\n      */\n     class BookieFormatCmd extends MyCommand {\n         Options opts = new Options();\n@@ -286,7 +286,7 @@ int runCmd(CommandLine cmdLine) throws Exception {\n     }\n \n     /**\n-     * Recover command for ledger data recovery for failed bookie\n+     * Recover command for ledger data recovery for failed bookie.\n      */\n     class RecoverCmd extends MyCommand {\n         Options opts = new Options();\n@@ -365,7 +365,7 @@ private int bkRecovery(ClientConfiguration conf, BookKeeperAdmin bkAdmin,\n     }\n \n     /**\n-     * Ledger Command Handles ledger related operations\n+     * Ledger Command Handles ledger related operations.\n      */\n     class LedgerCmd extends MyCommand {\n         Options lOpts = new Options();\n@@ -422,7 +422,7 @@ Options getOptions() {\n     }\n \n     /**\n-     * Command for reading ledger entries\n+     * Command for reading ledger entries.\n      */\n     class ReadLedgerEntriesCmd extends MyCommand {\n         Options lOpts = new Options();\n@@ -498,7 +498,7 @@ int runCmd(CommandLine cmdLine) throws Exception {\n     }\n \n     /**\n-     * Command for listing underreplicated ledgers\n+     * Command for listing underreplicated ledgers.\n      */\n     class ListUnderreplicatedCmd extends MyCommand {\n         Options opts = new Options();\n@@ -562,9 +562,9 @@ int runCmd(CommandLine cmdLine) throws Exception {\n         }\n     }\n \n-    final static int LIST_BATCH_SIZE = 1000;\n+    static final int LIST_BATCH_SIZE = 1000;\n     /**\n-     * Command to list all ledgers in the cluster\n+     * Command to list all ledgers in the cluster.\n      */\n     class ListLedgersCmd extends MyCommand {\n         Options lOpts = new Options();\n@@ -589,8 +589,7 @@ public int runCmd(CommandLine cmdLine) throws Exception {\n                 m = mFactory.newLedgerManager();\n                 LedgerRangeIterator iter = m.getLedgerRanges();\n                 if (cmdLine.hasOption(\"m\")) {\n-                    List<ReadMetadataCallback> futures\n-                        = new ArrayList<ReadMetadataCallback>(LIST_BATCH_SIZE);\n+                    List<ReadMetadataCallback> futures = new ArrayList<ReadMetadataCallback>(LIST_BATCH_SIZE);\n                     while (iter.hasNext()) {\n                         LedgerRange r = iter.next();\n                         for (Long lid : r.getLedgers()) {\n@@ -678,7 +677,7 @@ public void operationComplete(int rc, LedgerMetadata result) {\n     }\n \n     /**\n-     * Print the metadata for a ledger\n+     * Print the metadata for a ledger.\n      */\n     class LedgerMetadataCmd extends MyCommand {\n         Options lOpts = new Options();\n@@ -743,7 +742,7 @@ Options getOptions() {\n     }\n \n     /**\n-     * Simple test to create a ledger and write to it\n+     * Simple test to create a ledger and write to it.\n      */\n     class SimpleTestCmd extends MyCommand {\n         Options lOpts = new Options();\n@@ -805,7 +804,7 @@ Options getOptions() {\n     }\n \n     /**\n-     * Command to run a bookie sanity test\n+     * Command to run a bookie sanity test.\n      */\n     class BookieSanityTestCmd extends MyCommand {\n         Options lOpts = new Options();\n@@ -834,7 +833,7 @@ String getUsage() {\n         @Override\n         int runCmd(CommandLine cmdLine) throws Exception {\n             int numberOfEntries = getOptionIntValue(cmdLine, \"entries\", 10);\n-            int timeoutSecs= getOptionIntValue(cmdLine, \"timeout\", 1);\n+            int timeoutSecs = getOptionIntValue(cmdLine, \"timeout\", 1);\n \n             ClientConfiguration conf = new ClientConfiguration();\n             conf.addConfiguration(bkConf);\n@@ -966,8 +965,8 @@ String getDescription() {\n \n         @Override\n         String getUsage() {\n-            return \"readlog      [-msg] <entry_log_id | entry_log_file_name> [-ledgerid <ledgerid> [-entryid <entryid>]] \"\n-                    + \"[-startpos <startEntryLogBytePos> [-endpos <endEntryLogBytePos>]]\";\n+            return \"readlog      [-msg] <entry_log_id | entry_log_file_name> [-ledgerid <ledgerid> \"\n+                    + \"[-entryid <entryid>]] [-startpos <startEntryLogBytePos> [-endpos <endEntryLogBytePos>]]\";\n         }\n \n         @Override\n@@ -977,7 +976,7 @@ Options getOptions() {\n     }\n \n     /**\n-     * Command to read journal files\n+     * Command to read journal files.\n      */\n     class ReadJournalCmd extends MyCommand {\n         Options rjOpts = new Options();\n@@ -1065,7 +1064,7 @@ Options getOptions() {\n     }\n \n     /**\n-     * Command to print last log mark\n+     * Command to print last log mark.\n      */\n     class LastMarkCmd extends MyCommand {\n         LastMarkCmd() {\n@@ -1095,7 +1094,7 @@ Options getOptions() {\n     }\n \n     /**\n-     * List available bookies\n+     * List available bookies.\n      */\n     class ListBookiesCmd extends MyCommand {\n         Options opts = new Options();\n@@ -1233,7 +1232,7 @@ Options getOptions() {\n \n \n     /**\n-     * Command to print help message\n+     * Command to print help message.\n      */\n     class HelpCmd extends MyCommand {\n         HelpCmd() {\n@@ -1275,7 +1274,7 @@ Options getOptions() {\n     }\n \n     /**\n-     * Command for administration of autorecovery\n+     * Command for administration of autorecovery.\n      */\n     class AutoRecoveryCmd extends MyCommand {\n         Options opts = new Options();\n@@ -1406,10 +1405,10 @@ int runCmd(CommandLine cmdLine) throws Exception {\n             return 0;\n         }\n     }\n-    \n-    \n+\n+\n     /**\n-     * Print which node has the auditor lock\n+     * Print which node has the auditor lock.\n      */\n     class WhoIsAuditorCmd extends MyCommand {\n         Options opts = new Options();\n@@ -1462,7 +1461,7 @@ int runCmd(CommandLine cmdLine) throws Exception {\n     }\n \n     /**\n-     * Update cookie command\n+     * Update cookie command.\n      */\n     class UpdateCookieCmd extends MyCommand {\n         Options opts = new Options();\n@@ -1605,7 +1604,7 @@ private boolean verifyCookie(Cookie oldCookie, File dir) throws IOException {\n     }\n \n     /**\n-     * Expand the storage directories owned by a bookie\n+     * Expand the storage directories owned by a bookie.\n      */\n     class ExpandStorageCmd extends MyCommand {\n         Options opts = new Options();\n@@ -1662,7 +1661,7 @@ int runCmd(CommandLine cmdLine) {\n     }\n \n     /**\n-     * Update ledger command\n+     * Update ledger command.\n      */\n     class UpdateLedgerCmd extends MyCommand {\n         private final Options opts = new Options();\n@@ -1689,7 +1688,8 @@ String getDescription() {\n \n         @Override\n         String getUsage() {\n-            return \"updateledger -bookieId <hostname|ip> [-updatespersec N] [-limit N] [-verbose true/false] [-printprogress N]\";\n+            return \"updateledger -bookieId <hostname|ip> [-updatespersec N] [-limit N] [-verbose true/false] \"\n+                   + \"[-printprogress N]\";\n         }\n \n         @Override\n@@ -1868,8 +1868,8 @@ String getReadable(long val) {\n             String unit[] = {\"\", \"KB\", \"MB\", \"GB\", \"TB\" };\n             int cnt = 0;\n             double d = val;\n-            while (d >= 1000 && cnt < unit.length-1) {\n-                d = d/1000;\n+            while (d >= 1000 && cnt < unit.length - 1) {\n+                d = d / 1000;\n                 cnt++;\n             }\n             DecimalFormat df = new DecimalFormat(\"#.###\");\n@@ -1891,11 +1891,12 @@ public int runCmd(CommandLine cmdLine) throws Exception {\n             }\n \n             System.out.println(\"Free disk space info:\");\n-            long totalFree = 0, total=0;\n+            long totalFree = 0, total = 0;\n             for (Map.Entry<BookieSocketAddress, BookieInfo> e : map.entrySet()) {\n                 BookieInfo bInfo = e.getValue();\n-                System.out.println(e.getKey() + \":\\tFree: \" + bInfo.getFreeDiskSpace() +  getReadable(bInfo.getFreeDiskSpace()) +\n-                        \"\\tTotal: \" + bInfo.getTotalDiskSpace() +  getReadable(bInfo.getTotalDiskSpace()));\n+                System.out.println(e.getKey() + \":\\tFree: \" + bInfo.getFreeDiskSpace()\n+                        + getReadable(bInfo.getFreeDiskSpace()) + \"\\tTotal: \" + bInfo.getTotalDiskSpace()\n+                        + getReadable(bInfo.getTotalDiskSpace()));\n                 totalFree += bInfo.getFreeDiskSpace();\n                 total += bInfo.getTotalDiskSpace();\n             }\n@@ -1945,14 +1946,14 @@ public int runCmd(CommandLine cmdLine) throws Exception {\n             return 0;\n         }\n     }\n-    \n+\n     /**\n-     * Command to trigger AuditTask by resetting lostBookieRecoveryDelay and then make sure the \n+     * Command to trigger AuditTask by resetting lostBookieRecoveryDelay and then make sure the\n      * ledgers stored in the bookie are properly replicated.\n      */\n     class DecommissionBookieCmd extends MyCommand {\n         Options lOpts = new Options();\n-        \n+\n         DecommissionBookieCmd() {\n             super(CMD_DECOMMISSIONBOOKIE);\n         }\n@@ -1990,7 +1991,7 @@ public int runCmd(CommandLine cmdLine) throws Exception {\n             }\n         }\n     }\n-    \n+\n     /**\n      * A facility for reporting update ledger progress.\n      */\n@@ -2024,7 +2025,7 @@ public interface UpdateLedgerNotifier {\n         commands.put(CMD_BOOKIEINFO, new BookieInfoCmd());\n         commands.put(CMD_DECOMMISSIONBOOKIE, new DecommissionBookieCmd());\n         commands.put(CMD_HELP, new HelpCmd());\n-        commands.put(CMD_LOSTBOOKIERECOVERYDELAY, new LostBookieRecoveryDelayCmd());  \n+        commands.put(CMD_LOSTBOOKIERECOVERYDELAY, new LostBookieRecoveryDelayCmd());\n         commands.put(CMD_TRIGGERAUDIT, new TriggerAuditCmd());\n     }\n \n@@ -2164,8 +2165,7 @@ public static void main(String argv[]) throws Exception {\n     /**\n      * Get the ledger file of a specified ledger.\n      *\n-     * @param ledgerId\n-     *          Ledger Id\n+     * @param ledgerId Ledger Id\n      *\n      * @return file object.\n      */\n@@ -2185,14 +2185,14 @@ private File getLedgerFile(long ledgerId) {\n     /**\n      * Get FileInfo for a specified ledger.\n      *\n-     * @param ledgerId\n-     *          Ledger Id\n+     * @param ledgerId Ledger Id\n      * @return read only file info instance\n      */\n     ReadOnlyFileInfo getFileInfo(long ledgerId) throws IOException {\n         File ledgerFile = getLedgerFile(ledgerId);\n         if (null == ledgerFile) {\n-            throw new FileNotFoundException(\"No index file found for ledger \" + ledgerId + \". It may be not flushed yet.\");\n+            throw new FileNotFoundException(\"No index file found for ledger \" + ledgerId\n+                    + \". It may be not flushed yet.\");\n         }\n         ReadOnlyFileInfo fi = new ReadOnlyFileInfo(ledgerFile, null);\n         fi.readHeader();\n@@ -2207,12 +2207,10 @@ private synchronized void initEntryLogger() throws IOException {\n     }\n \n     /**\n-     * scan over entry log\n+     * Scan over entry log.\n      *\n-     * @param logId\n-     *          Entry Log Id\n-     * @param scanner\n-     *          Entry Log Scanner\n+     * @param logId Entry Log Id\n+     * @param scanner Entry Log Scanner\n      */\n     protected void scanEntryLog(long logId, EntryLogScanner scanner) throws IOException {\n         initEntryLogger();\n@@ -2231,12 +2229,10 @@ private synchronized List<Journal> getJournals() throws IOException {\n     }\n \n     /**\n-     * Scan journal file\n+     * Scan journal file.\n      *\n-     * @param journalId\n-     *          Journal File Id\n-     * @param scanner\n-     *          Journal File Scanner\n+     * @param journalId Journal File Id\n+     * @param scanner Journal File Scanner\n      */\n     protected void scanJournal(Journal journal, long journalId, JournalScanner scanner) throws IOException {\n         journal.scanJournal(journalId, 0L, scanner);\n@@ -2247,10 +2243,9 @@ protected void scanJournal(Journal journal, long journalId, JournalScanner scann\n     ///\n \n     /**\n-     * Read ledger meta\n+     * Read ledger meta.\n      *\n-     * @param ledgerId\n-     *          Ledger Id\n+     * @param ledgerId Ledger Id\n      */\n     protected void readLedgerMeta(long ledgerId) throws Exception {\n         System.out.println(\"===== LEDGER: \" + ledgerId + \" =====\");\n@@ -2272,10 +2267,9 @@ protected void readLedgerMeta(long ledgerId) throws Exception {\n     }\n \n     /**\n-     * Read ledger index entires\n+     * Read ledger index entires.\n      *\n-     * @param ledgerId\n-     *          Ledger Id\n+     * @param ledgerId Ledger Id\n      * @throws IOException\n      */\n     protected void readLedgerIndexEntries(long ledgerId) throws IOException {\n@@ -2293,7 +2287,7 @@ protected void readLedgerIndexEntries(long ledgerId) throws IOException {\n                 lep.readPage(fi);\n \n                 // process a page\n-                for (int i=0; i<entriesPerPage; i++) {\n+                for (int i = 0; i < entriesPerPage; i++) {\n                     long offset = lep.getOffset(i * 8);\n                     if (0 == offset) {\n                         System.out.println(\"entry \" + curEntry + \"\\t:\\tN/A\");\n@@ -2310,10 +2304,11 @@ protected void readLedgerIndexEntries(long ledgerId) throws IOException {\n         } catch (IOException ie) {\n             LOG.error(\"Failed to read index page : \", ie);\n             if (curSize + pageSize < size) {\n-                System.out.println(\"Failed to read index page @ \" + curSize + \", the index file may be corrupted : \" + ie.getMessage());\n+                System.out.println(\"Failed to read index page @ \" + curSize + \", the index file may be corrupted : \"\n+                        + ie.getMessage());\n             } else {\n-                System.out.println(\"Failed to read last index page @ \" + curSize\n-                                 + \", the index file may be corrupted or last index page is not fully flushed yet : \" + ie.getMessage());\n+                System.out.println(\"Failed to read last index page @ \" + curSize + \", the index file may be corrupted \"\n+                        + \"or last index page is not fully flushed yet : \" + ie.getMessage());\n             }\n         }\n     }\n@@ -2341,61 +2336,53 @@ public void process(long ledgerId, long startPos, ByteBuffer entry) {\n     }\n \n     /**\n-     * Scan over an entry log file for a particular entry\n+     * Scan over an entry log file for a particular entry.\n      *\n-     * @param logId\n-     *          Entry Log File id.\n-     * @param ledgerId\n-     *          id of the ledger\n-     * @param entryId\n-     *          entryId of the ledger we are looking for (-1 for all of the entries of the ledger)\n-     * @param printMsg\n-     *          Whether printing the entry data.\n+     * @param logId Entry Log File id.\n+     * @param ledgerId id of the ledger\n+     * @param entryId entryId of the ledger we are looking for (-1 for all of the entries of the ledger)\n+     * @param printMsg Whether printing the entry data.\n      * @throws Exception\n      */\n-    protected void scanEntryLogForSpecificEntry(long logId, final long lId, final long eId, final boolean printMsg)\n-            throws Exception {\n-        System.out.println(\"Scan entry log \" + logId + \" (\" + Long.toHexString(logId) + \".log)\" + \" for LedgerId \" + lId\n-                + ((eId == -1) ? \"\" : \" for EntryId \" + eId));\n+    protected void scanEntryLogForSpecificEntry(long logId, final long ledgerId, final long entryId,\n+                                                final boolean printMsg) throws Exception {\n+        System.out.println(\"Scan entry log \" + logId + \" (\" + Long.toHexString(logId) + \".log)\" + \" for LedgerId \"\n+                + ledgerId + ((entryId == -1) ? \"\" : \" for EntryId \" + entryId));\n         final MutableBoolean entryFound = new MutableBoolean(false);\n         scanEntryLog(logId, new EntryLogScanner() {\n             @Override\n             public boolean accept(long ledgerId) {\n-                return ((lId == ledgerId) && ((!entryFound.booleanValue()) || (eId == -1)));\n+                return (((!entryFound.booleanValue()) || (entryId == -1)));\n             }\n \n             @Override\n             public void process(long ledgerId, long startPos, ByteBuffer entry) {\n                 long entrysLedgerId = entry.getLong();\n                 long entrysEntryId = entry.getLong();\n                 entry.rewind();\n-                if ((ledgerId == entrysLedgerId) && (ledgerId == lId) && ((entrysEntryId == eId)) || (eId == -1)) {\n+                if ((ledgerId == entrysLedgerId) && ((entrysEntryId == entryId)) || (entryId == -1)) {\n                     entryFound.setValue(true);\n                     formatEntry(startPos, entry, printMsg);\n                 }\n             }\n         });\n         if (!entryFound.booleanValue()) {\n-            System.out.println(\"LedgerId \" + lId + ((eId == -1) ? \"\" : \" EntryId \" + eId)\n+            System.out.println(\"LedgerId \" + ledgerId + ((entryId == -1) ? \"\" : \" EntryId \" + entryId)\n                     + \" is not available in the entry log \" + logId + \" (\" + Long.toHexString(logId) + \".log)\");\n         }\n     }\n \n     /**\n-     * Scan over an entry log file for entries in the given position range\n+     * Scan over an entry log file for entries in the given position range.\n      *\n-     * @param logId\n-     *          Entry Log File id.\n-     * @param rangeStartPos\n-     *          Start position of the entry we are looking for\n-     * @param rangeEndPos\n-     *          End position of the entry we are looking for (-1 for till the end of the entrylog)\n-     * @param printMsg\n-     *          Whether printing the entry data.\n+     * @param logId Entry Log File id.\n+     * @param rangeStartPos Start position of the entry we are looking for\n+     * @param rangeEndPos End position of the entry we are looking for (-1 for till the end of the entrylog)\n+     * @param printMsg Whether printing the entry data.\n      * @throws Exception\n      */\n-    protected void scanEntryLogForPositionRange(long logId, final long rangeStartPos, final long rangeEndPos, final boolean printMsg)\n- throws Exception {\n+    protected void scanEntryLogForPositionRange(long logId, final long rangeStartPos, final long rangeEndPos,\n+                                                final boolean printMsg) throws Exception {\n         System.out.println(\"Scan entry log \" + logId + \" (\" + Long.toHexString(logId) + \".log)\" + \" for PositionRange: \"\n                 + rangeStartPos + \" - \" + rangeEndPos);\n         final MutableBoolean entryFound = new MutableBoolean(false);\n@@ -2440,12 +2427,10 @@ public void process(long ledgerId, long entryStartPos, ByteBuffer entry) {\n     }\n \n     /**\n-     * Scan a journal file\n+     * Scan a journal file.\n      *\n-     * @param journalId\n-     *          Journal File Id\n-     * @param printMsg\n-     *          Whether printing the entry data.\n+     * @param journalId Journal File Id\n+     * @param printMsg Whether printing the entry data.\n      */\n     protected void scanJournal(Journal journal, long journalId, final boolean printMsg) throws Exception {\n         System.out.println(\"Scan journal \" + journalId + \" (\" + Long.toHexString(journalId) + \".txn)\");\n@@ -2463,7 +2448,7 @@ public void process(int journalVersion, long offset, ByteBuffer entry) throws IO\n     }\n \n     /**\n-     * Print last log mark\n+     * Print last log mark.\n      */\n     protected void printLastLogMark() throws IOException {\n         for (Journal journal : getJournals()) {"},{"sha":"81cae9e9cd81608d42531b4913e0b98e64e4bc6b","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BookieThread.java","status":"modified","additions":6,"deletions":6,"changes":12,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FBookieThread.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FBookieThread.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FBookieThread.java?ref=086537beda9427c057a286ad6c4614659da6ed7f","patch":"@@ -20,11 +20,11 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-/*\n-* Wrapper that wraps bookie threads\n-* Any common handing that we require for all bookie threads\n-* should be implemented here\n-*/\n+/**\n+ * Wrapper that wraps bookie threads.\n+ * Any common handing that we require for all bookie threads\n+ * should be implemented here\n+ */\n public class BookieThread extends Thread implements\n         Thread.UncaughtExceptionHandler {\n \n@@ -47,7 +47,7 @@ public BookieThread(Runnable thread, String name) {\n     }\n \n     /**\n-     * Handles uncaught exception occurred in thread\n+     * Handles uncaught exception occurred in thread.\n      */\n     protected void handleException(Thread t, Throwable e) {\n         LOG.error(\"Uncaught exception in thread {}\", t.getName(), e);"},{"sha":"3cc963021cada0f9b66a57bfcbddeb4d64b0b25f","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BufferedChannel.java","status":"modified","additions":19,"deletions":19,"changes":38,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FBufferedChannel.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FBufferedChannel.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FBufferedChannel.java?ref=086537beda9427c057a286ad6c4614659da6ed7f","patch":"@@ -64,17 +64,17 @@ public BufferedChannel(FileChannel fc, int writeCapacity, int readCapacity) thro\n      * @param src The source ByteBuffer which contains the data to be written.\n      * @throws IOException if a write operation fails.\n      */\n-    synchronized public void write(ByteBuffer src) throws IOException {\n+    public synchronized void write(ByteBuffer src) throws IOException {\n         int copied = 0;\n-        while(src.remaining() > 0) {\n+        while (src.remaining() > 0) {\n             int truncated = 0;\n             if (writeBuffer.remaining() < src.remaining()) {\n                 truncated = src.remaining() - writeBuffer.remaining();\n-                src.limit(src.limit()-truncated);\n+                src.limit(src.limit() - truncated);\n             }\n             copied += src.remaining();\n             writeBuffer.put(src);\n-            src.limit(src.limit()+truncated);\n+            src.limit(src.limit() + truncated);\n             // if we have run out of buffer space, we should flush to the file\n             if (writeBuffer.remaining() == 0) {\n                 flushInternal();\n@@ -107,7 +107,7 @@ public long getFileChannelPosition() {\n      * @throws IOException if the write or sync operation fails.\n      */\n     public void flush(boolean shouldForceWrite) throws IOException {\n-        synchronized(this) {\n+        synchronized (this) {\n             flushInternal();\n         }\n         if (shouldForceWrite) {\n@@ -116,7 +116,7 @@ public void flush(boolean shouldForceWrite) throws IOException {\n     }\n \n     /**\n-     * Write any data in the buffer to the file and advance the writeBufferPosition\n+     * Write any data in the buffer to the file and advance the writeBufferPosition.\n      * Callers are expected to synchronize appropriately\n      * @throws IOException if the write fails.\n      */\n@@ -140,13 +140,13 @@ public long forceWrite(boolean forceMetadata) throws IOException {\n     }\n \n     @Override\n-    synchronized public int read(ByteBuffer dest, long pos) throws IOException {\n+    public synchronized int read(ByteBuffer dest, long pos) throws IOException {\n         long prevPos = pos;\n-        while(dest.remaining() > 0) {\n+        while (dest.remaining() > 0) {\n             // check if it is in the write buffer\n             if (writeBuffer != null && writeBufferStartPosition.get() <= pos) {\n                 long positionInBuffer = pos - writeBufferStartPosition.get();\n-                long bytesToCopy = writeBuffer.position()-positionInBuffer;\n+                long bytesToCopy = writeBuffer.position() - positionInBuffer;\n                 if (bytesToCopy > dest.remaining()) {\n                     bytesToCopy = dest.remaining();\n                 }\n@@ -155,22 +155,22 @@ synchronized public int read(ByteBuffer dest, long pos) throws IOException {\n                 }\n                 ByteBuffer src = writeBuffer.duplicate();\n                 src.position((int) positionInBuffer);\n-                src.limit((int) (positionInBuffer+bytesToCopy));\n+                src.limit((int) (positionInBuffer + bytesToCopy));\n                 dest.put(src);\n-                pos+= bytesToCopy;\n+                pos += bytesToCopy;\n             } else if (writeBuffer == null && writeBufferStartPosition.get() <= pos) {\n                 // here we reach the end\n                 break;\n                 // first check if there is anything we can grab from the readBuffer\n-            } else if (readBufferStartPosition <= pos && pos < readBufferStartPosition+readBuffer.capacity()) {\n+            } else if (readBufferStartPosition <= pos && pos < readBufferStartPosition + readBuffer.capacity()) {\n                 long positionInBuffer = pos - readBufferStartPosition;\n-                long bytesToCopy = readBuffer.capacity()-positionInBuffer;\n+                long bytesToCopy = readBuffer.capacity() - positionInBuffer;\n                 if (bytesToCopy > dest.remaining()) {\n                     bytesToCopy = dest.remaining();\n                 }\n                 ByteBuffer src = readBuffer.duplicate();\n                 src.position((int) positionInBuffer);\n-                src.limit((int) (positionInBuffer+bytesToCopy));\n+                src.limit((int) (positionInBuffer + bytesToCopy));\n                 dest.put(src);\n                 pos += bytesToCopy;\n                 // let's read it\n@@ -181,23 +181,23 @@ synchronized public int read(ByteBuffer dest, long pos) throws IOException {\n                 if (readBufferStartPosition + readBuffer.capacity() >= writeBufferStartPosition.get()) {\n                     readBufferStartPosition = writeBufferStartPosition.get() - readBuffer.capacity();\n                     if (readBufferStartPosition < 0) {\n-                        ZeroBuffer.put(readBuffer, (int)-readBufferStartPosition);\n+                        ZeroBuffer.put(readBuffer, (int) -readBufferStartPosition);\n                     }\n                 }\n-                while(readBuffer.remaining() > 0) {\n-                    if (fileChannel.read(readBuffer, readBufferStartPosition+readBuffer.position()) <= 0) {\n+                while (readBuffer.remaining() > 0) {\n+                    if (fileChannel.read(readBuffer, readBufferStartPosition + readBuffer.position()) <= 0) {\n                         throw new IOException(\"Short read\");\n                     }\n                 }\n                 ZeroBuffer.put(readBuffer);\n                 readBuffer.clear();\n             }\n         }\n-        return (int)(pos - prevPos);\n+        return (int) (pos - prevPos);\n     }\n \n     @Override\n-    synchronized public void clear() {\n+    public synchronized void clear() {\n         super.clear();\n         writeBuffer.clear();\n     }"},{"sha":"bd8c843e4e8fa8799d0086398c207271df4f76e4","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BufferedChannelBase.java","status":"modified","additions":3,"deletions":0,"changes":3,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FBufferedChannelBase.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FBufferedChannelBase.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FBufferedChannelBase.java?ref=086537beda9427c057a286ad6c4614659da6ed7f","patch":"@@ -20,6 +20,9 @@\n import java.io.IOException;\n import java.nio.channels.FileChannel;\n \n+/**\n+ * @TODO: Write JavaDoc comment {@link https://github.com/apache/bookkepeer/issues/247}\n+ */\n public abstract class BufferedChannelBase {\n     protected final FileChannel fileChannel;\n "},{"sha":"64557d120b65d273d4af95aee8981dc8af64e1cd","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BufferedReadChannel.java","status":"modified","additions":10,"deletions":11,"changes":21,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FBufferedReadChannel.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FBufferedReadChannel.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FBufferedReadChannel.java?ref=086537beda9427c057a286ad6c4614659da6ed7f","patch":"@@ -21,9 +21,6 @@\n \n package org.apache.bookkeeper.bookie;\n \n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n import java.io.IOException;\n import java.nio.ByteBuffer;\n import java.nio.channels.FileChannel;\n@@ -32,7 +29,7 @@\n  * A Buffered channel without a write buffer. Only reads are buffered.\n  */\n public class BufferedReadChannel extends BufferedChannelBase {\n-    private static Logger LOG = LoggerFactory.getLogger(BufferedReadChannel.class);\n+\n     // The capacity of the read buffer.\n     protected final int readCapacity;\n     // The buffer for read operations.\n@@ -56,10 +53,11 @@ public BufferedReadChannel(FileChannel fileChannel, int readCapacity) throws IOE\n      * depending on the implementation..\n      * @param dest\n      * @param pos\n-     * @return The total number of bytes read. -1 if the given position is greater than or equal to the file's current size.\n+     * @return The total number of bytes read.\n+     *         -1 if the given position is greater than or equal to the file's current size.\n      * @throws IOException if I/O error occurs\n      */\n-    synchronized public int read(ByteBuffer dest, long pos) throws IOException {\n+    public synchronized int read(ByteBuffer dest, long pos) throws IOException {\n         invocationCount++;\n         long currentPosition = pos;\n         long eof = validateAndGetFileChannel().size();\n@@ -69,12 +67,13 @@ synchronized public int read(ByteBuffer dest, long pos) throws IOException {\n         }\n         while (dest.remaining() > 0) {\n             // Check if the data is in the buffer, if so, copy it.\n-            if (readBufferStartPosition <= currentPosition && currentPosition < readBufferStartPosition + readBuffer.limit()) {\n+            if (readBufferStartPosition <= currentPosition\n+                    && currentPosition < readBufferStartPosition + readBuffer.limit()) {\n                 long posInBuffer = currentPosition - readBufferStartPosition;\n                 long bytesToCopy = Math.min(dest.remaining(), readBuffer.limit() - posInBuffer);\n                 ByteBuffer rbDup = readBuffer.duplicate();\n-                rbDup.position((int)posInBuffer);\n-                rbDup.limit((int)(posInBuffer + bytesToCopy));\n+                rbDup.position((int) posInBuffer);\n+                rbDup.limit((int) (posInBuffer + bytesToCopy));\n                 dest.put(rbDup);\n                 currentPosition += bytesToCopy;\n                 cacheHitCount++;\n@@ -92,10 +91,10 @@ synchronized public int read(ByteBuffer dest, long pos) throws IOException {\n                 readBuffer.limit(readBytes);\n             }\n         }\n-        return (int)(currentPosition - pos);\n+        return (int) (currentPosition - pos);\n     }\n \n-    synchronized public void clear() {\n+    public synchronized void clear() {\n         readBuffer.clear();\n         readBuffer.limit(0);\n     }"},{"sha":"df9a848a4d6b735c05ddde04d9681dc7aacb0e14","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/CacheCallback.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FCacheCallback.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FCacheCallback.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FCacheCallback.java?ref=086537beda9427c057a286ad6c4614659da6ed7f","patch":"@@ -24,11 +24,11 @@\n import java.io.IOException;\n \n /**\n- * Interface plugged into caching to receive callback notifications\n+ * Interface plugged into caching to receive callback notifications.\n  */\n public interface CacheCallback {\n     /**\n      * Process notification that cache size limit reached.\n      */\n-    public void onSizeLimitReached() throws IOException;\n+    void onSizeLimitReached() throws IOException;\n }"},{"sha":"e7043bd3298defcf723b55ad5f358f0e5c0103c2","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/CheckpointSource.java","status":"modified","additions":5,"deletions":5,"changes":10,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FCheckpointSource.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FCheckpointSource.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FCheckpointSource.java?ref=086537beda9427c057a286ad6c4614659da6ed7f","patch":"@@ -27,9 +27,9 @@ public interface CheckpointSource {\n     /**\n      * A checkpoint presented a time point. All entries added before this checkpoint are already persisted.\n      */\n-    public static interface Checkpoint extends Comparable<Checkpoint> {\n+    public interface Checkpoint extends Comparable<Checkpoint> {\n \n-        public static final Checkpoint MAX = new Checkpoint() {\n+        Checkpoint MAX = new Checkpoint() {\n \n             @Override\n             public int compareTo(Checkpoint o) {\n@@ -46,7 +46,7 @@ public boolean equals(Object o) {\n \n         };\n \n-        public static final Checkpoint MIN = new Checkpoint() {\n+        Checkpoint MIN = new Checkpoint() {\n             @Override\n             public int compareTo(Checkpoint o) {\n                 if (o == MIN) {\n@@ -67,7 +67,7 @@ public boolean equals(Object o) {\n      *\n      * @return checkpoint.\n      */\n-    public Checkpoint newCheckpoint();\n+    Checkpoint newCheckpoint();\n \n     /**\n      * Tell checkpoint source that the checkpoint is completed.\n@@ -79,5 +79,5 @@ public boolean equals(Object o) {\n      * @param compact\n      *          Flag to compact old checkpoints.\n      */\n-    public void checkpointComplete(Checkpoint checkpoint, boolean compact) throws IOException;\n+    void checkpointComplete(Checkpoint checkpoint, boolean compact) throws IOException;\n }"},{"sha":"4c61da2117b3037f30b607e28aa9cfed7905d720","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/CheckpointSourceList.java","status":"modified","additions":3,"deletions":0,"changes":3,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FCheckpointSourceList.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FCheckpointSourceList.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FCheckpointSourceList.java?ref=086537beda9427c057a286ad6c4614659da6ed7f","patch":"@@ -25,6 +25,9 @@\n import com.google.common.base.Objects;\n import com.google.common.collect.Lists;\n \n+/**\n+ * @TODO: Write JavaDoc comment {@link https://github.com/apache/bookkepeer/issues/247}\n+ */\n public class CheckpointSourceList implements CheckpointSource {\n \n     private final List<? extends CheckpointSource> checkpointSourcesList;"},{"sha":"242b9905e7b8eac6cc8009e4a8106a771033fe35","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/CompactableLedgerStorage.java","status":"modified","additions":4,"deletions":5,"changes":9,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FCompactableLedgerStorage.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FCompactableLedgerStorage.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FCompactableLedgerStorage.java?ref=086537beda9427c057a286ad6c4614659da6ed7f","patch":"@@ -24,7 +24,7 @@\n import java.io.IOException;\n \n /**\n- * Interface that identifies LedgerStorage implementations using EntryLogger and running periodic entries compaction\n+ * Interface that identifies LedgerStorage implementations using EntryLogger and running periodic entries compaction.\n  */\n public interface CompactableLedgerStorage extends LedgerStorage {\n \n@@ -44,16 +44,15 @@ Iterable<Long> getActiveLedgersInRange(long firstLedgerId, long lastLedgerId)\n             throws IOException;\n \n     /**\n-     * Update the location of several entries\n+     * Update the location of several entries.\n      *\n-     * @param locations\n-     *            the list of locations to update\n+     * @param locations the list of locations to update\n      * @throws IOException\n      */\n     void updateEntriesLocations(Iterable<EntryLocation> locations) throws IOException;\n \n     /**\n-     * Flush the entries locations index for the compacted entries\n+     * Flush the entries locations index for the compacted entries.\n      *\n      * @throws IOException\n      */"},{"sha":"9224ceb9ac73a2085841c5d3799af2e0ea2e213e","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Cookie.java","status":"modified","additions":38,"deletions":62,"changes":100,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FCookie.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FCookie.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FCookie.java?ref=086537beda9427c057a286ad6c4614659da6ed7f","patch":"@@ -65,14 +65,13 @@\n  * bookie, its configuration stays the same. If any of the bookie directories\n  * becomes unavailable, the bookie becomes unavailable. If the bookie changes\n  * port, it must also reset all of its data.\n- *\n  * This is done to ensure data integrity. Without the cookie a bookie could\n  * start with one of its ledger directories missing, so data would be missing,\n  * but the bookie would be up, so the client would think that everything is ok\n  * with the cluster. It's better to fail early and obviously.\n  */\n class Cookie {\n-    private final static Logger LOG = LoggerFactory.getLogger(Cookie.class);\n+    private static final Logger LOG = LoggerFactory.getLogger(Cookie.class);\n \n     static final int CURRENT_COOKIE_LAYOUT_VERSION = 4;\n     private final int layoutVersion;\n@@ -103,7 +102,7 @@ private static String[] decodeDirPathFromCookie(String s) {\n         // the first part of the string contains a count of how many\n         // directories are present; to skip it, we look for subString\n         // from the first '/'\n-        return s.substring(s.indexOf(SEPARATOR)+SEPARATOR.length()).split(SEPARATOR);\n+        return s.substring(s.indexOf(SEPARATOR) + SEPARATOR.length()).split(SEPARATOR);\n     }\n \n     String[] getLedgerDirPathsFromCookie() {\n@@ -114,13 +113,13 @@ String[] getLedgerDirPathsFromCookie() {\n      * Receives 2 String arrays, that each contain a list of directory paths,\n      * and checks if first is a super set of the second.\n      *\n-     * @param superSet\n-     * @param subSet\n-     * @return true if s1 is a superSet of s2; false otherwise\n+     * @param superS\n+     * @param subS\n+     * @return true if superS is a superSet of subS; false otherwise\n      */\n-    private boolean isSuperSet(String[] s1, String[] s2) {\n-        Set<String> superSet = Sets.newHashSet(s1);\n-        Set<String> subSet = Sets.newHashSet(s2);\n+    private boolean isSuperSet(String[] superS, String[] subS) {\n+        Set<String> superSet = Sets.newHashSet(superS);\n+        Set<String> subSet = Sets.newHashSet(subS);\n         return superSet.containsAll(subSet);\n     }\n \n@@ -236,15 +235,11 @@ void writeToDirectory(File directory) throws IOException {\n     }\n \n     /**\n-     * Writes cookie details to ZooKeeper\n-     *\n-     * @param zk\n-     *            ZooKeeper instance\n-     * @param conf\n-     *            configuration\n-     * @param version\n-     *            version\n+     * Writes cookie details to ZooKeeper.\n      *\n+     * @param zk ZooKeeper instance\n+     * @param conf configuration\n+     * @param version version\n      * @throws KeeperException\n      * @throws InterruptedException\n      * @throws UnknownHostException\n@@ -277,15 +272,11 @@ void writeToZooKeeper(ZooKeeper zk, ServerConfiguration conf, Version version)\n     }\n \n     /**\n-     * Deletes cookie from ZooKeeper and sets znode version to DEFAULT_COOKIE_ZNODE_VERSION\n-     *\n-     * @param zk\n-     *            ZooKeeper instance\n-     * @param conf\n-     *            configuration\n-     * @param version\n-     *            zookeeper version\n+     * Deletes cookie from ZooKeeper and sets znode version to DEFAULT_COOKIE_ZNODE_VERSION.\n      *\n+     * @param zk ZooKeeper instance\n+     * @param conf configuration\n+     * @param version zookeeper version\n      * @throws KeeperException\n      * @throws InterruptedException\n      * @throws UnknownHostException\n@@ -297,7 +288,7 @@ public void deleteFromZooKeeper(ZooKeeper zk, ServerConfiguration conf, Version\n     }\n \n     /**\n-     * Delete cookie from zookeeper\n+     * Delete cookie from zookeeper.\n      *\n      * @param zk zookeeper client\n      * @param conf configuration instance\n@@ -315,18 +306,15 @@ public void deleteFromZooKeeper(ZooKeeper zk, AbstractConfiguration conf,\n         }\n \n         String zkPath = getZkPath(conf, address);\n-        zk.delete(zkPath, ((ZkVersion)version).getZnodeVersion());\n+        zk.delete(zkPath, ((ZkVersion) version).getZnodeVersion());\n         LOG.info(\"Removed cookie from {} for bookie {}.\", conf.getZkLedgersRootPath(), address);\n     }\n \n     /**\n-     * Generate cookie from the given configuration\n-     *\n-     * @param conf\n-     *            configuration\n+     * Generate cookie from the given configuration.\n      *\n+     * @param conf configuration\n      * @return cookie builder object\n-     *\n      * @throws UnknownHostException\n      */\n     static Builder generateCookie(ServerConfiguration conf)\n@@ -342,13 +330,9 @@ static Builder generateCookie(ServerConfiguration conf)\n     /**\n      * Read cookie from ZooKeeper.\n      *\n-     * @param zk\n-     *            ZooKeeper instance\n-     * @param conf\n-     *            configuration\n-     *\n+     * @param zk ZooKeeper instance\n+     * @param conf configuration\n      * @return versioned cookie object\n-     *\n      * @throws KeeperException\n      * @throws InterruptedException\n      * @throws IOException\n@@ -360,7 +344,7 @@ static Versioned<Cookie> readFromZooKeeper(ZooKeeper zk, ServerConfiguration con\n     }\n \n     /**\n-     * Read cookie from zookeeper for a given bookie <i>address</i>\n+     * Read cookie from zookeeper for a given bookie <i>address</i>.\n      *\n      * @param zk zookeeper client\n      * @param conf configuration instance\n@@ -390,18 +374,14 @@ static Versioned<Cookie> readFromZooKeeper(ZooKeeper zk, AbstractConfiguration c\n     }\n \n     /**\n-     * Returns cookie from the given directory\n-     *\n-     * @param directory\n-     *            directory\n+     * Returns cookie from the given directory.\n      *\n+     * @param directory directory\n      * @return cookie object\n-     *\n      * @throws IOException\n      */\n     static Cookie readFromDirectory(File directory) throws IOException {\n-        File versionFile = new File(directory,\n-                BookKeeperConstants.VERSION_FILENAME);\n+        File versionFile = new File(directory, BookKeeperConstants.VERSION_FILENAME);\n         BufferedReader reader = new BufferedReader(\n                 new InputStreamReader(new FileInputStream(versionFile), UTF_8));\n         try {\n@@ -412,13 +392,10 @@ static Cookie readFromDirectory(File directory) throws IOException {\n     }\n \n     /**\n-     * Returns cookie path in zookeeper\n+     * Returns cookie path in zookeeper.\n      *\n-     * @param conf\n-     *            configuration\n-     *          \n+     * @param conf configuration\n      * @return cookie zk path\n-     *\n      * @throws UnknownHostException\n      */\n     static String getZkPath(ServerConfiguration conf)\n@@ -427,15 +404,14 @@ static String getZkPath(ServerConfiguration conf)\n     }\n \n     /**\n-     * Return cookie path for a given bookie <i>address</i>\n+     * Return cookie path for a given bookie <i>address</i>.\n      *\n      * @param conf configuration\n      * @param address bookie address\n      * @return cookie path for bookie\n      */\n     static String getZkPath(AbstractConfiguration conf, BookieSocketAddress address) {\n-        String bookieCookiePath = conf.getZkLedgersRootPath() + \"/\"\n-                + BookKeeperConstants.COOKIE_NODE;\n+        String bookieCookiePath = conf.getZkLedgersRootPath() + \"/\" + BookKeeperConstants.COOKIE_NODE;\n         return bookieCookiePath + \"/\" + address;\n     }\n \n@@ -444,7 +420,7 @@ static String getZkPath(AbstractConfiguration conf, BookieSocketAddress address)\n      * address. Represent as 'hostname/IPaddress' if the InetSocketAddress was\n      * created using hostname. Represent as '/IPaddress' if the\n      * InetSocketAddress was created using an IPaddress\n-     * \n+     *\n      * @return true if the 'bookieHost' was created using an IP address, false\n      *         if the 'bookieHost' was created using a hostname\n      */\n@@ -465,7 +441,7 @@ public boolean isBookieHostCreatedFromIp() throws IOException {\n     }\n \n     /**\n-     * Cookie builder\n+     * Cookie builder.\n      */\n     public static class Builder {\n         private int layoutVersion = 0;\n@@ -477,7 +453,8 @@ public static class Builder {\n         private Builder() {\n         }\n \n-        private Builder(int layoutVersion, String bookieHost, String journalDirs, String ledgerDirs, String instanceId) {\n+        private Builder(int layoutVersion, String bookieHost, String journalDirs, String ledgerDirs,\n+                        String instanceId) {\n             this.layoutVersion = layoutVersion;\n             this.bookieHost = bookieHost;\n             this.journalDirs = journalDirs;\n@@ -516,19 +493,18 @@ public Cookie build() {\n     }\n \n     /**\n-     * Returns Cookie builder\n-     * \n+     * Returns Cookie builder.\n+     *\n      * @return cookie builder\n      */\n     static Builder newBuilder() {\n         return new Builder();\n     }\n \n     /**\n-     * Returns Cookie builder with the copy of given oldCookie\n+     * Returns Cookie builder with the copy of given oldCookie.\n      *\n-     * @param oldCookie\n-     *            build new cookie from this cookie\n+     * @param oldCookie build new cookie from this cookie\n      * @return cookie builder\n      */\n     static Builder newBuilder(Cookie oldCookie) {"},{"sha":"4169ede175fb52bee1cb156170e9db6a5ce95132","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/EntryKey.java","status":"modified","additions":8,"deletions":6,"changes":14,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FEntryKey.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FEntryKey.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FEntryKey.java?ref=086537beda9427c057a286ad6c4614659da6ed7f","patch":"@@ -22,6 +22,9 @@\n import java.io.Serializable;\n import java.util.Comparator;\n \n+/**\n+ * @TODO: Write JavaDoc comment {@link https://github.com/apache/bookkepeer/issues/247}\n+ */\n public class EntryKey {\n     long ledgerId;\n     long entryId;\n@@ -44,7 +47,7 @@ public long getEntryId() {\n     }\n \n     /**\n-    * Comparator for the key portion\n+    * Comparator for the key portion.\n     */\n     public static final KeyComparator COMPARATOR = new KeyComparator();\n \n@@ -54,14 +57,13 @@ public boolean equals(Object other) {\n         if (!(other instanceof EntryKey)) {\n           return false;\n         }\n-        EntryKey key = (EntryKey)other;\n-        return ledgerId == key.ledgerId &&\n-            entryId == key.entryId;\n+        EntryKey key = (EntryKey) other;\n+        return ledgerId == key.ledgerId && entryId == key.entryId;\n     }\n \n     @Override\n     public int hashCode() {\n-        return (int)(ledgerId * 13 ^ entryId * 17);\n+        return (int) (ledgerId * 13 ^ entryId * 17);\n     }\n }\n \n@@ -78,6 +80,6 @@ public int compare(EntryKey left, EntryKey right) {\n         if (ret == 0) {\n             ret = left.entryId - right.entryId;\n         }\n-        return (ret < 0)? -1 : ((ret > 0)? 1 : 0);\n+        return (ret < 0) ? -1 : ((ret > 0) ? 1 : 0);\n     }\n }"},{"sha":"43e35fbbaa4c21d6c3be7a9661e2584912b2d1f3","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/EntryKeyValue.java","status":"modified","additions":2,"deletions":4,"changes":6,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FEntryKeyValue.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FEntryKeyValue.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FEntryKeyValue.java?ref=086537beda9427c057a286ad6c4614659da6ed7f","patch":"@@ -30,7 +30,7 @@\n  * interpret the content as entry blob.\n  */\n public class EntryKeyValue extends EntryKey {\n-    final private byte [] bytes;\n+    private final byte [] bytes;\n     private int offset = 0; // start offset of entry blob\n     private int length = 0; // length of entry blob\n \n@@ -56,7 +56,6 @@ public int getLength() {\n     }\n \n     /**\n-     *\n      * Creates a EntryKeyValue from the start of the specified byte array.\n      * Presumes <code>bytes</code> content contains the value portion of a EntryKeyValue.\n      * @param bytes byte array\n@@ -66,7 +65,6 @@ public EntryKeyValue(long ledgerId, long entryId, final byte [] bytes) {\n     }\n \n     /**\n-     *\n      * Creates a EntryKeyValue from the start of the specified byte array.\n      * Presumes <code>bytes</code> content contains the value portion of a EntryKeyValue.\n      * @param bytes byte array\n@@ -109,7 +107,7 @@ int writeToByteBuffer(ByteBuffer dst) {\n     }\n \n     /**\n-    * String representation\n+    * String representation.\n     */\n     public String toString() {\n         return ledgerId + \":\" + entryId;"},{"sha":"df2195957acc195f4511309632f4faad3bf45845","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/EntryLocation.java","status":"modified","additions":3,"deletions":0,"changes":3,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FEntryLocation.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FEntryLocation.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FEntryLocation.java?ref=086537beda9427c057a286ad6c4614659da6ed7f","patch":"@@ -21,6 +21,9 @@\n \n package org.apache.bookkeeper.bookie;\n \n+/**\n+ * @TODO: Write JavaDoc comment {@link https://github.com/apache/bookkepeer/issues/247}\n+ */\n public class EntryLocation {\n     public final long ledger;\n     public final long entry;"},{"sha":"418b7e0feb621431f5ad4a92db941cb97d66ab38","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/EntryLogger.java","status":"modified","additions":54,"deletions":52,"changes":106,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FEntryLogger.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FEntryLogger.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FEntryLogger.java?ref=086537beda9427c057a286ad6c4614659da6ed7f","patch":"@@ -75,25 +75,25 @@ public class EntryLogger {\n     private static final Logger LOG = LoggerFactory.getLogger(EntryLogger.class);\n \n     private static class BufferedLogChannel extends BufferedChannel {\n-        final private long logId;\n-        private final EntryLogMetadata entryLogMetada;\n+        private final long logId;\n+        private final EntryLogMetadata entryLogMetadata;\n \n         public BufferedLogChannel(FileChannel fc, int writeCapacity,\n                                   int readCapacity, long logId) throws IOException {\n             super(fc, writeCapacity, readCapacity);\n             this.logId = logId;\n-            this.entryLogMetada = new EntryLogMetadata(logId);\n+            this.entryLogMetadata = new EntryLogMetadata(logId);\n         }\n         public long getLogId() {\n             return logId;\n         }\n \n         public void registerWrittenEntry(long ledgerId, long entrySize) {\n-            entryLogMetada.addLedgerSize(ledgerId, entrySize);\n+            entryLogMetadata.addLedgerSize(ledgerId, entrySize);\n         }\n \n         public Map<Long, Long> getLedgersMap() {\n-            return entryLogMetada.getLedgersMap();\n+            return entryLogMetadata.getLedgersMap();\n         }\n     }\n \n@@ -111,8 +111,7 @@ public Map<Long, Long> getLedgersMap() {\n     private volatile BufferedLogChannel logChannel;\n     private final EntryLoggerAllocator entryLoggerAllocator;\n     private final boolean entryLogPreAllocationEnabled;\n-    private final CopyOnWriteArrayList<EntryLogListener> listeners\n-        = new CopyOnWriteArrayList<EntryLogListener>();\n+    private final CopyOnWriteArrayList<EntryLogListener> listeners = new CopyOnWriteArrayList<EntryLogListener>();\n \n     private static final int HEADER_V0 = 0; // Old log file format (no ledgers map index)\n     private static final int HEADER_V1 = 1; // Introduced ledger map index\n@@ -134,17 +133,19 @@ private static class Header {\n      * The 1K block at the head of the entry logger file\n      * that contains the fingerprint and meta-data.\n      *\n+     * <pre>\n      * Header is composed of:\n      * Fingerprint: 4 bytes \"BKLO\"\n      * Log file HeaderVersion enum: 4 bytes\n      * Ledger map offset: 8 bytes\n      * Ledgers Count: 4 bytes\n+     * </pre>\n      */\n-    final static int LOGFILE_HEADER_SIZE = 1024;\n-    final ByteBuffer LOGFILE_HEADER = ByteBuffer.allocate(LOGFILE_HEADER_SIZE);\n+    static final int LOGFILE_HEADER_SIZE = 1024;\n+    final ByteBuffer logfileHeader = ByteBuffer.allocate(LOGFILE_HEADER_SIZE);\n \n-    final static int HEADER_VERSION_POSITION = 4;\n-    final static int LEDGERS_MAP_OFFSET_POSITION = HEADER_VERSION_POSITION + 4;\n+    static final int HEADER_VERSION_POSITION = 4;\n+    static final int LEDGERS_MAP_OFFSET_POSITION = HEADER_VERSION_POSITION + 4;\n \n     /**\n      * Ledgers map is composed of multiple parts that can be split into separated entries. Each of them is composed of:\n@@ -157,19 +158,19 @@ private static class Header {\n      * ledger entries: sequence of (ledgerid, size) (8 + 8 bytes each) [24..]\n      * </pre>\n      */\n-    final static int LEDGERS_MAP_HEADER_SIZE = 4 + 8 + 8 + 4;\n-    final static int LEDGERS_MAP_ENTRY_SIZE = 8 + 8;\n+    static final int LEDGERS_MAP_HEADER_SIZE = 4 + 8 + 8 + 4;\n+    static final int LEDGERS_MAP_ENTRY_SIZE = 8 + 8;\n \n     // Break the ledgers map into multiple batches, each of which can contain up to 10K ledgers\n-    final static int LEDGERS_MAP_MAX_BATCH_SIZE = 10000;\n+    static final int LEDGERS_MAP_MAX_BATCH_SIZE = 10000;\n \n-    final static long INVALID_LID = -1L;\n+    static final long INVALID_LID = -1L;\n \n     // EntryId used to mark an entry (belonging to INVALID_ID) as a component of the serialized ledgers map\n-    final static long LEDGERS_MAP_ENTRY_ID = -2L;\n+    static final long LEDGERS_MAP_ENTRY_ID = -2L;\n \n-    final static int MIN_SANE_ENTRY_SIZE = 8 + 8;\n-    final static long MB = 1024 * 1024;\n+    static final int MIN_SANE_ENTRY_SIZE = 8 + 8;\n+    static final long MB = 1024 * 1024;\n \n     private final long flushIntervalInBytes;\n     private final boolean doRegularFlushes;\n@@ -180,7 +181,7 @@ private static class Header {\n     /**\n      * Scan entries in a entry log file.\n      */\n-    static interface EntryLogScanner {\n+    interface EntryLogScanner {\n         /**\n          * Tests whether or not the entries belongs to the specified ledger\n          * should be processed.\n@@ -189,7 +190,7 @@ static interface EntryLogScanner {\n          *          Ledger ID.\n          * @return true if and only the entries of the ledger should be scanned.\n          */\n-        public boolean accept(long ledgerId);\n+        boolean accept(long ledgerId);\n \n         /**\n          * Process an entry.\n@@ -202,22 +203,21 @@ static interface EntryLogScanner {\n          *          Entry ByteBuffer\n          * @throws IOException\n          */\n-        public void process(long ledgerId, long offset, ByteBuffer entry) throws IOException;\n+        void process(long ledgerId, long offset, ByteBuffer entry) throws IOException;\n     }\n \n     /**\n-     * Entry Log Listener\n+     * Entry Log Listener.\n      */\n-    static interface EntryLogListener {\n+    interface EntryLogListener {\n         /**\n          * Rotate a new entry log to write.\n          */\n-        public void onRotateEntryLog();\n+        void onRotateEntryLog();\n     }\n \n     /**\n-     * Create an EntryLogger that stores it's log files in the given\n-     * directories\n+     * Create an EntryLogger that stores it's log files in the given directories.\n      */\n     public EntryLogger(ServerConfiguration conf,\n             LedgerDirsManager ledgerDirsManager) throws IOException {\n@@ -243,8 +243,8 @@ public EntryLogger(ServerConfiguration conf,\n         // within the same JVM. All of these Bookie instances access this header\n         // so there can be race conditions when entry logs are rolled over and\n         // this header buffer is cleared before writing it into the new logChannel.\n-        LOGFILE_HEADER.put(\"BKLO\".getBytes(UTF_8));\n-        LOGFILE_HEADER.putInt(HEADER_CURRENT_VERSION);\n+        logfileHeader.put(\"BKLO\".getBytes(UTF_8));\n+        logfileHeader.putInt(HEADER_CURRENT_VERSION);\n \n         // Find the largest logId\n         long logId = INVALID_LID;\n@@ -305,8 +305,8 @@ private int readFromLogChannel(long entryLogId, BufferedReadChannel channel, Byt\n      * These channels should be used only for reading. logChannel is the one\n      * that is used for writes.\n      */\n-    private final ThreadLocal<Map<Long, BufferedReadChannel>> logid2Channel\n-            = new ThreadLocal<Map<Long, BufferedReadChannel>>() {\n+    private final ThreadLocal<Map<Long, BufferedReadChannel>> logid2Channel =\n+            new ThreadLocal<Map<Long, BufferedReadChannel>>() {\n         @Override\n         public Map<Long, BufferedReadChannel> initialValue() {\n             // Since this is thread local there only one modifier\n@@ -323,8 +323,7 @@ public Map<Long, BufferedReadChannel> initialValue() {\n      * and don't cause a change in the channel's position. We use this map to store the file channels. Each\n      * file channel is mapped to a log id which represents an open log file.\n      */\n-    private final ConcurrentMap<Long, FileChannel> logid2FileChannel\n-            = new ConcurrentHashMap<Long, FileChannel>();\n+    private final ConcurrentMap<Long, FileChannel> logid2FileChannel = new ConcurrentHashMap<Long, FileChannel>();\n \n     /**\n      * Put the logId, bc pair in the map responsible for the current thread.\n@@ -431,7 +430,7 @@ synchronized void rollLog() throws IOException {\n     }\n \n     /**\n-     * Creates a new log file\n+     * Creates a new log file.\n      */\n     void createNewLog() throws IOException {\n         // first tried to create a new log channel. add current log channel to ToFlush list only when\n@@ -586,7 +585,7 @@ BufferedLogChannel allocateNewLog() throws IOException {\n             FileChannel channel = new RandomAccessFile(newLogFile, \"rw\").getChannel();\n             BufferedLogChannel logChannel = new BufferedLogChannel(channel,\n                     conf.getWriteBufferBytes(), conf.getReadBufferBytes(), preallocatedLogId);\n-            logChannel.write((ByteBuffer) LOGFILE_HEADER.clear());\n+            logChannel.write((ByteBuffer) logfileHeader.clear());\n \n             for (File f : list) {\n                 setLastLogId(f, preallocatedLogId);\n@@ -697,7 +696,7 @@ private long readLastLogId(File f) {\n             return Long.parseLong(lastIdString, 16);\n         } catch (IOException e) {\n             return INVALID_LID;\n-        } catch(NumberFormatException e) {\n+        } catch (NumberFormatException e) {\n             return INVALID_LID;\n         } finally {\n             try {\n@@ -820,20 +819,21 @@ byte[] readEntry(long ledgerId, long entryId, long location) throws IOException,\n         try {\n             fc = getChannelForLogId(entryLogId);\n         } catch (FileNotFoundException e) {\n-            FileNotFoundException newe = new FileNotFoundException(e.getMessage() + \" for \" + ledgerId + \" with location \" + location);\n+            FileNotFoundException newe = new FileNotFoundException(e.getMessage() + \" for \" + ledgerId\n+                    + \" with location \" + location);\n             newe.setStackTrace(e.getStackTrace());\n             throw newe;\n         }\n         if (readFromLogChannel(entryLogId, fc, sizeBuff, pos) != sizeBuff.capacity()) {\n-            throw new Bookie.NoEntryException(\"Short read from entrylog \" + entryLogId,\n-                                              ledgerId, entryId);\n+            throw new Bookie.NoEntryException(\"Short read from entrylog \" + entryLogId, ledgerId, entryId);\n         }\n         pos += 4;\n         sizeBuff.flip();\n         int entrySize = sizeBuff.getInt();\n         // entrySize does not include the ledgerId\n         if (entrySize > maxSaneEntrySize) {\n-            LOG.warn(\"Sanity check failed for entry size of \" + entrySize + \" at location \" + pos + \" in \" + entryLogId);\n+            LOG.warn(\"Sanity check failed for entry size of \" + entrySize + \" at location \" + pos + \" in \"\n+                    + entryLogId);\n \n         }\n         if (entrySize < MIN_SANE_ENTRY_SIZE) {\n@@ -843,7 +843,7 @@ byte[] readEntry(long ledgerId, long entryId, long location) throws IOException,\n         byte data[] = new byte[entrySize];\n         ByteBuffer buff = ByteBuffer.wrap(data);\n         int rc = readFromLogChannel(entryLogId, fc, buff, pos);\n-        if ( rc != data.length) {\n+        if (rc != data.length) {\n             // Note that throwing NoEntryException here instead of IOException is not\n             // without risk. If all bookies in a quorum throw this same exception\n             // the client will assume that it has reached the end of the ledger.\n@@ -853,23 +853,25 @@ byte[] readEntry(long ledgerId, long entryId, long location) throws IOException,\n             // returning NoEntryException is mostly safe.\n             throw new Bookie.NoEntryException(\"Short read for \" + ledgerId + \"@\"\n                                               + entryId + \" in \" + entryLogId + \"@\"\n-                                              + pos + \"(\"+rc+\"!=\"+data.length+\")\", ledgerId, entryId);\n+                                              + pos + \"(\" + rc + \"!=\" + data.length + \")\", ledgerId, entryId);\n         }\n         buff.flip();\n         long thisLedgerId = buff.getLong();\n         if (thisLedgerId != ledgerId) {\n-            throw new IOException(\"problem found in \" + entryLogId + \"@\" + entryId + \" at position + \" + pos + \" entry belongs to \" + thisLedgerId + \" not \" + ledgerId);\n+            throw new IOException(\"problem found in \" + entryLogId + \"@\" + entryId + \" at position + \" + pos\n+                    + \" entry belongs to \" + thisLedgerId + \" not \" + ledgerId);\n         }\n         long thisEntryId = buff.getLong();\n         if (thisEntryId != entryId) {\n-            throw new IOException(\"problem found in \" + entryLogId + \"@\" + entryId + \" at position + \" + pos + \" entry is \" + thisEntryId + \" not \" + entryId);\n+            throw new IOException(\"problem found in \" + entryLogId + \"@\" + entryId + \" at position + \" + pos\n+                    + \" entry is \" + thisEntryId + \" not \" + entryId);\n         }\n \n         return data;\n     }\n \n     /**\n-     * Read the header of an entry log\n+     * Read the header of an entry log.\n      */\n     private Header getHeaderForLogId(long entryLogId) throws IOException {\n         BufferedReadChannel bc = getChannelForLogId(entryLogId);\n@@ -928,7 +930,7 @@ boolean logExists(long logId) {\n \n     private File findFile(long logId) throws FileNotFoundException {\n         for (File d : ledgerDirsManager.getAllLedgerDirs()) {\n-            File f = new File(d, Long.toHexString(logId)+\".log\");\n+            File f = new File(d, Long.toHexString(logId) + \".log\");\n             if (f.exists()) {\n                 return f;\n             }\n@@ -937,12 +939,10 @@ private File findFile(long logId) throws FileNotFoundException {\n     }\n \n     /**\n-     * Scan entry log\n+     * Scan entry log.\n      *\n-     * @param entryLogId\n-     *          Entry Log Id\n-     * @param scanner\n-     *          Entry Log Scanner\n+     * @param entryLogId Entry Log Id\n+     * @param scanner Entry Log Scanner\n      * @throws IOException\n      */\n     protected void scanEntryLog(long entryLogId, EntryLogScanner scanner) throws IOException {\n@@ -1057,12 +1057,14 @@ EntryLogMetadata extractEntryLogMetadataFromIndex(long entryLogId) throws IOExce\n             // Discard ledgerId and entryId\n             long lid = ledgersMapBuffer.getLong();\n             if (lid != INVALID_LID) {\n-                throw new IOException(\"Cannot deserialize ledgers map from ledger \" + lid + \" -- entryLogId: \" + entryLogId);\n+                throw new IOException(\"Cannot deserialize ledgers map from ledger \" + lid + \" -- entryLogId: \"\n+                        + entryLogId);\n             }\n \n             long entryId = ledgersMapBuffer.getLong();\n             if (entryId != LEDGERS_MAP_ENTRY_ID) {\n-                throw new IOException(\"Cannot deserialize ledgers map from ledger \" + lid + \":\" + entryId + \" -- entryLogId: \" + entryLogId);\n+                throw new IOException(\"Cannot deserialize ledgers map from ledger \" + lid + \":\" + entryId\n+                        + \" -- entryLogId: \" + entryLogId);\n             }\n \n             // Read the number of ledgers in the current entry batch"},{"sha":"e88302c0e002d3c2edf67d5aaf8e6eb69899d8a9","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/EntryMemTable.java","status":"modified","additions":20,"deletions":22,"changes":42,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FEntryMemTable.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FEntryMemTable.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FEntryMemTable.java?ref=086537beda9427c057a286ad6c4614659da6ed7f","patch":"@@ -51,10 +51,10 @@\n  * flusher reports in that the flush succeeded. At that point we let the snapshot go.\n  */\n public class EntryMemTable {\n-    private static Logger Logger = LoggerFactory.getLogger(Journal.class);\n+    private static Logger logger = LoggerFactory.getLogger(Journal.class);\n \n     /**\n-     * Entry skip list\n+     * Entry skip list.\n      */\n     static class EntrySkipList extends ConcurrentSkipListMap<EntryKey, EntryKeyValue> {\n         final Checkpoint cp;\n@@ -107,7 +107,7 @@ public boolean equals(Object o) {\n     final long skipListSizeLimit;\n \n     SkipListArena allocator;\n-    \n+\n     // flag indicating the status of the previous flush call\n     private final AtomicBoolean previousFlushSucceeded;\n \n@@ -148,10 +148,10 @@ public EntryMemTable(final ServerConfiguration conf, final CheckpointSource sour\n \n     void dump() {\n         for (EntryKey key: this.kvmap.keySet()) {\n-            Logger.info(key.toString());\n+            logger.info(key.toString());\n         }\n         for (EntryKey key: this.snapshot.keySet()) {\n-            Logger.info(key.toString());\n+            logger.info(key.toString());\n         }\n     }\n \n@@ -171,8 +171,7 @@ Checkpoint snapshot() throws IOException {\n     Checkpoint snapshot(Checkpoint oldCp) throws IOException {\n         Checkpoint cp = null;\n         // No-op if snapshot currently has entries\n-        if (this.snapshot.isEmpty() &&\n-                this.kvmap.compareTo(oldCp) < 0) {\n+        if (this.snapshot.isEmpty() && this.kvmap.compareTo(oldCp) < 0) {\n             final long startTimeNanos = MathUtils.nowInNano();\n             this.lock.writeLock().lock();\n             try {\n@@ -246,7 +245,7 @@ private long flushSnapshot(final SkipListFlusher flusher, Checkpoint checkpoint)\n                 EntrySkipList keyValues = this.snapshot;\n                 if (keyValues.compareTo(checkpoint) < 0) {\n                     for (EntryKey key : keyValues.keySet()) {\n-                        EntryKeyValue kv = (EntryKeyValue)key;\n+                        EntryKeyValue kv = (EntryKeyValue) key;\n                         size += kv.getLength();\n                         ledger = kv.getLedgerId();\n                         if (ledgerGC != ledger) {\n@@ -285,7 +284,7 @@ private void clearSnapshot(final EntrySkipList keyValues) {\n     }\n \n     /**\n-     * Throttling writer w/ 1 ms delay\n+     * Throttling writer w/ 1 ms delay.\n      */\n     private void throttleWriters() {\n         try {\n@@ -297,11 +296,12 @@ private void throttleWriters() {\n     }\n \n     /**\n-    * Write an update\n-    * @param entry\n-    * @return approximate size of the passed key and value.\n-     * @throws IOException \n-    */\n+     * Write an update.\n+     *\n+     * @param entry\n+     * @return approximate size of the passed key and value.\n+     * @throws IOException\n+     */\n     public long addEntry(long ledgerId, long entryId, final ByteBuffer entry, final CacheCallback cb)\n             throws IOException {\n         long size = 0;\n@@ -338,7 +338,6 @@ public long addEntry(long ledgerId, long entryId, final ByteBuffer entry, final\n     /**\n     * Internal version of add() that doesn't clone KVs with the\n     * allocator, and doesn't take the lock.\n-    *\n     * Callers should ensure they already have the read lock taken\n     */\n     private long internalAdd(final EntryKeyValue toAdd) throws IOException {\n@@ -358,8 +357,7 @@ private EntryKeyValue newEntry(long ledgerId, long entryId, final ByteBuffer ent\n         if (entry.hasArray()) {\n             buf = entry.array();\n             offset = entry.arrayOffset();\n-        }\n-        else {\n+        } else {\n             buf = new byte[length];\n             entry.get(buf);\n         }\n@@ -381,7 +379,7 @@ private EntryKeyValue cloneWithAllocator(long ledgerId, long entryId, final Byte\n     }\n \n     /**\n-     * Find the entry with given key\n+     * Find the entry with given key.\n      * @param ledgerId\n      * @param entryId\n      * @return the entry kv or null if none found.\n@@ -411,7 +409,7 @@ public EntryKeyValue getEntry(long ledgerId, long entryId) throws IOException {\n     }\n \n     /**\n-     * Find the last entry with the given ledger key\n+     * Find the last entry with the given ledger key.\n      * @param ledgerId\n      * @return the entry kv or null if none found.\n      */\n@@ -439,18 +437,18 @@ public EntryKeyValue getLastEntry(long ledgerId) throws IOException {\n         if (result == null || result.getLedgerId() != ledgerId) {\n             return null;\n         }\n-        return (EntryKeyValue)result;\n+        return (EntryKeyValue) result;\n     }\n \n     /**\n-     * Check if the entire heap usage for this EntryMemTable exceeds limit\n+     * Check if the entire heap usage for this EntryMemTable exceeds limit.\n      */\n     boolean isSizeLimitReached() {\n         return size.get() >= skipListSizeLimit;\n     }\n \n     /**\n-     * Check if there is data in the mem-table\n+     * Check if there is data in the mem-table.\n      * @return\n      */\n     boolean isEmpty() {"},{"sha":"a2e23a834ebd0dcacab110b084f6adeee92e17d8","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/ExitCode.java","status":"modified","additions":7,"deletions":7,"changes":14,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FExitCode.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FExitCode.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FExitCode.java?ref=086537beda9427c057a286ad6c4614659da6ed7f","patch":"@@ -22,19 +22,19 @@\n package org.apache.bookkeeper.bookie;\n \n /**\n- * Exit code used to exit bookie server\n+ * Exit code used to exit bookie server.\n  */\n public class ExitCode {\n     // normal quit\n-    public final static int OK                  = 0;\n+    public static final int OK                  = 0;\n     // invalid configuration\n-    public final static int INVALID_CONF        = 1;\n+    public static final int INVALID_CONF        = 1;\n     // exception running bookie server\n-    public final static int SERVER_EXCEPTION    = 2;\n+    public static final int SERVER_EXCEPTION    = 2;\n     // zookeeper is expired\n-    public final static int ZK_EXPIRED          = 3;\n+    public static final int ZK_EXPIRED          = 3;\n     // register bookie on zookeeper failed\n-    public final static int ZK_REG_FAIL         = 4;\n+    public static final int ZK_REG_FAIL         = 4;\n     // exception running bookie\n-    public final static int BOOKIE_EXCEPTION    = 5;\n+    public static final int BOOKIE_EXCEPTION    = 5;\n }"},{"sha":"c14be5fe087e50a6ce9dfc69f8682471b3382e8f","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/FileInfo.java","status":"modified","additions":32,"deletions":30,"changes":62,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FFileInfo.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FFileInfo.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FFileInfo.java?ref=086537beda9427c057a286ad6c4614659da6ed7f","patch":"@@ -43,7 +43,8 @@\n  * It is used by LedgerCache.\n  *\n  * <p>\n- * Ledger index file is made of a header and several fixed-length index pages, which records the offsets of data stored in entry loggers\n+ * Ledger index file is made of a header and several fixed-length index pages, which records the offsets of data stored\n+ * in entry loggers\n  * <pre>&lt;header&gt;&lt;index pages&gt;</pre>\n  * <b>Header</b> is formated as below:\n  * <pre>&lt;magic bytes&gt;&lt;len of master key&gt;&lt;master key&gt;</pre>\n@@ -53,11 +54,12 @@\n  * <li>master key: master key\n  * <li>state: bit map to indicate the state, 32 bits.\n  * </ul>\n- * <b>Index page</b> is a fixed-length page, which contains serveral entries which point to the offsets of data stored in entry loggers.\n+ * <b>Index page</b> is a fixed-length page, which contains serveral entries which point to the offsets of data stored\n+ * in entry loggers.\n  * </p>\n  */\n class FileInfo extends Observable {\n-    private final static Logger LOG = LoggerFactory.getLogger(FileInfo.class);\n+    private static final Logger LOG = LoggerFactory.getLogger(FileInfo.class);\n \n     static final int NO_MASTER_KEY = -1;\n     static final int STATE_FENCED_BIT = 0x1;\n@@ -69,10 +71,10 @@ class FileInfo extends Observable {\n     byte[] masterKey;\n \n     /**\n-     * The fingerprint of a ledger index file\n+     * The fingerprint of a ledger index file.\n      */\n-    static final public int signature = ByteBuffer.wrap(\"BKLE\".getBytes(UTF_8)).getInt();\n-    static final public int headerVersion = 0;\n+    public static final int SIGNATURE = ByteBuffer.wrap(\"BKLE\".getBytes(UTF_8)).getInt();\n+    public static final int HEADER_VERSION = 0;\n \n     static final long START_OF_DATA = 1024;\n     private long size;\n@@ -142,13 +144,13 @@ public long getSizeSinceLastwrite() {\n \n     public ByteBuf getExplicitLac() {\n         ByteBuf retLac = null;\n-        synchronized(this) {\n+        synchronized (this) {\n             if (LOG.isDebugEnabled()) {\n                 LOG.debug(\"fileInfo:GetLac: {}\", explicitLac);\n             }\n             if (explicitLac != null) {\n                 retLac = Unpooled.buffer(explicitLac.capacity());\n-                explicitLac.rewind();//copy from the beginning\n+                explicitLac.rewind(); //copy from the beginning\n                 retLac.writeBytes(explicitLac);\n                 explicitLac.rewind();\n                 return retLac;\n@@ -158,7 +160,7 @@ public ByteBuf getExplicitLac() {\n     }\n \n     public void setExplicitLac(ByteBuf lac) {\n-        synchronized(this) {\n+        synchronized (this) {\n             if (explicitLac == null) {\n                 explicitLac = ByteBuffer.allocate(lac.capacity());\n             }\n@@ -176,7 +178,7 @@ public void setExplicitLac(ByteBuf lac) {\n         }\n     }\n \n-    synchronized public void readHeader() throws IOException {\n+    public synchronized void readHeader() throws IOException {\n         if (lf.exists()) {\n             if (fc != null) {\n                 return;\n@@ -187,16 +189,16 @@ synchronized public void readHeader() throws IOException {\n             sizeSinceLastwrite = size;\n \n             // avoid hang on reading partial index\n-            ByteBuffer bb = ByteBuffer.allocate((int)(Math.min(size, START_OF_DATA)));\n-            while(bb.hasRemaining()) {\n+            ByteBuffer bb = ByteBuffer.allocate((int) (Math.min(size, START_OF_DATA)));\n+            while (bb.hasRemaining()) {\n                 fc.read(bb);\n             }\n             bb.flip();\n-            if (bb.getInt() != signature) {\n+            if (bb.getInt() != SIGNATURE) {\n                 throw new IOException(\"Missing ledger signature while reading header for \" + lf);\n             }\n             int version = bb.getInt();\n-            if (version != headerVersion) {\n+            if (version != HEADER_VERSION) {\n                 throw new IOException(\"Incompatible ledger version \" + version + \" while reading header for \" + lf);\n             }\n             int length = bb.getInt();\n@@ -210,7 +212,7 @@ synchronized public void readHeader() throws IOException {\n             stateBits = bb.getInt();\n             needFlushHeader = false;\n         } else {\n-            throw new IOException(\"Ledger index file \" + lf +\" does not exist\");\n+            throw new IOException(\"Ledger index file \" + lf + \" does not exist\");\n         }\n     }\n \n@@ -259,9 +261,9 @@ private synchronized void checkOpen(boolean create, boolean openBeforeClose)\n     }\n \n     private void writeHeader() throws IOException {\n-        ByteBuffer bb = ByteBuffer.allocate((int)START_OF_DATA);\n-        bb.putInt(signature);\n-        bb.putInt(headerVersion);\n+        ByteBuffer bb = ByteBuffer.allocate((int) START_OF_DATA);\n+        bb.putInt(SIGNATURE);\n+        bb.putInt(HEADER_VERSION);\n         bb.putInt(masterKey.length);\n         bb.put(masterKey);\n         bb.putInt(stateBits);\n@@ -270,7 +272,7 @@ private void writeHeader() throws IOException {\n         fc.write(bb);\n     }\n \n-    synchronized public boolean isFenced() throws IOException {\n+    public synchronized boolean isFenced() throws IOException {\n         checkOpen(false);\n         return (stateBits & STATE_FENCED_BIT) == STATE_FENCED_BIT;\n     }\n@@ -301,17 +303,17 @@ public boolean setFenced() throws IOException {\n     }\n \n     // flush the header when header is changed\n-    synchronized public void flushHeader() throws IOException {\n+    public synchronized void flushHeader() throws IOException {\n         if (needFlushHeader) {\n             checkOpen(true);\n             writeHeader();\n             needFlushHeader = false;\n         }\n     }\n \n-    synchronized public long size() throws IOException {\n+    public synchronized long size() throws IOException {\n         checkOpen(false);\n-        long rc = size-START_OF_DATA;\n+        long rc = size - START_OF_DATA;\n         if (rc < 0) {\n             rc = 0;\n         }\n@@ -348,7 +350,7 @@ private int readAbsolute(ByteBuffer bb, long start, boolean bestEffort)\n         }\n         int total = 0;\n         int rc = 0;\n-        while(bb.remaining() > 0) {\n+        while (bb.remaining() > 0) {\n             synchronized (this) {\n                 rc = fc.read(bb, start);\n             }\n@@ -393,12 +395,12 @@ public void close(boolean force) throws IOException {\n         notifyObservers(new LastAddConfirmedUpdateNotification(Long.MAX_VALUE));\n     }\n \n-    synchronized public long write(ByteBuffer[] buffs, long position) throws IOException {\n+    public synchronized long write(ByteBuffer[] buffs, long position) throws IOException {\n         checkOpen(true);\n         long total = 0;\n         try {\n-            fc.position(position+START_OF_DATA);\n-            while(buffs[buffs.length-1].remaining() > 0) {\n+            fc.position(position + START_OF_DATA);\n+            while (buffs[buffs.length - 1].remaining() > 0) {\n                 long rc = fc.write(buffs);\n                 if (rc <= 0) {\n                     throw new IOException(\"Short write\");\n@@ -407,7 +409,7 @@ synchronized public long write(ByteBuffer[] buffs, long position) throws IOExcep\n             }\n         } finally {\n             fc.force(true);\n-            long newsize = position+START_OF_DATA+total;\n+            long newsize = position + START_OF_DATA + total;\n             if (newsize > size) {\n                 size = newsize;\n             }\n@@ -471,7 +473,7 @@ public synchronized void moveToNewLocation(File newFile, long size) throws IOExc\n         lf = newFile;\n     }\n \n-    synchronized public byte[] getMasterKey() throws IOException {\n+    public synchronized byte[] getMasterKey() throws IOException {\n         checkOpen(false);\n         return masterKey;\n     }\n@@ -485,7 +487,7 @@ int getUseCount() {\n         return useCount.get();\n     }\n \n-    synchronized public void release() {\n+    public synchronized void release() {\n         int count = useCount.decrementAndGet();\n         if (isClosed && (count == 0) && fc != null) {\n             try {\n@@ -500,7 +502,7 @@ public synchronized boolean delete() {\n         return lf.delete();\n     }\n \n-    static final private void checkParents(File f) throws IOException {\n+    private static void checkParents(File f) throws IOException {\n         File parent = f.getParentFile();\n         if (parent.exists()) {\n             return;"},{"sha":"4d290a5f856c3a77b641a29e43381cfc8f145aef","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/FileSystemUpgrade.java","status":"modified","additions":18,"deletions":13,"changes":31,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FFileSystemUpgrade.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FFileSystemUpgrade.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FFileSystemUpgrade.java?ref=086537beda9427c057a286ad6c4614659da6ed7f","patch":"@@ -44,18 +44,23 @@\n import java.io.File;\n import java.io.FilenameFilter;\n import java.io.IOException;\n-import java.util.*;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Scanner;\n \n import static com.google.common.base.Charsets.UTF_8;\n \n /**\n- * Application for upgrading the bookkeeper filesystem\n- * between versions\n+ * Application for upgrading the bookkeeper filesystem between versions.\n  */\n public class FileSystemUpgrade {\n-    private final static Logger LOG = LoggerFactory.getLogger(FileSystemUpgrade.class);\n+    private static final Logger LOG = LoggerFactory.getLogger(FileSystemUpgrade.class);\n \n-    static FilenameFilter BOOKIE_FILES_FILTER = new FilenameFilter() {\n+    static FilenameFilter bookieFilesFilter = new FilenameFilter() {\n             private boolean containsIndexFiles(File dir, String name) {\n                 if (name.endsWith(\".idx\")) {\n                     return true;\n@@ -93,14 +98,14 @@ public boolean accept(File dir, String name) {\n         };\n \n     private static List<File> getAllDirectories(ServerConfiguration conf) {\n-        List<File> dirs = new ArrayList<File>();\n+        List<File> dirs = new ArrayList<>();\n         dirs.addAll(Lists.newArrayList(conf.getJournalDirs()));\n         Collections.addAll(dirs, conf.getLedgerDirs());\n         return dirs;\n     }\n \n     private static int detectPreviousVersion(File directory) throws IOException {\n-        String[] files = directory.list(BOOKIE_FILES_FILTER);\n+        String[] files = directory.list(bookieFilesFilter);\n         File v2versionFile = new File(directory,\n                 BookKeeperConstants.VERSION_FILENAME);\n         if ((files == null || files.length == 0) && !v2versionFile.exists()) { // no old data, so we're ok\n@@ -151,7 +156,7 @@ private static void linkIndexDirectories(File srcPath, File targetPath) throws I\n         for (String f : files) {\n             if (f.endsWith(\".idx\")) { // this is an index dir, create the links\n                 if (!targetPath.mkdirs()) {\n-                    throw new IOException(\"Could not create target path [\"+targetPath+\"]\");\n+                    throw new IOException(\"Could not create target path [\" + targetPath + \"]\");\n                 }\n                 HardLink.createHardLinkMult(srcPath, files, targetPath);\n                 return;\n@@ -175,7 +180,7 @@ public static void upgrade(ServerConfiguration conf)\n \n         ZooKeeper zk = newZookeeper(conf);\n         try {\n-            Map<File,File> deferredMoves = new HashMap<File, File>();\n+            Map<File, File> deferredMoves = new HashMap<File, File>();\n             Cookie.Builder cookieBuilder = Cookie.generateCookie(conf);\n             Cookie c = cookieBuilder.build();\n             for (File d : getAllDirectories(conf)) {\n@@ -196,7 +201,7 @@ public static void upgrade(ServerConfiguration conf)\n \n                     String[] files = d.list(new FilenameFilter() {\n                             public boolean accept(File dir, String name) {\n-                                return BOOKIE_FILES_FILTER.accept(dir, name)\n+                                return bookieFilesFilter.accept(dir, name)\n                                     && !(new File(dir, name).isDirectory());\n                             }\n                         });\n@@ -209,7 +214,7 @@ public boolean accept(File dir, String name) {\n                 }\n             }\n \n-            for (Map.Entry<File,File> e : deferredMoves.entrySet()) {\n+            for (Map.Entry<File, File> e : deferredMoves.entrySet()) {\n                 try {\n                     FileUtils.moveDirectory(e.getValue(), e.getKey());\n                 } catch (IOException ioe) {\n@@ -254,12 +259,12 @@ public static void finalizeUpgrade(ServerConfiguration conf)\n                             LOG.warn(\"Could not delete old version file {}\", v2versionFile);\n                         }\n                     }\n-                    File[] files = d.listFiles(BOOKIE_FILES_FILTER);\n+                    File[] files = d.listFiles(bookieFilesFilter);\n                     if (files != null) {\n                         for (File f : files) {\n                             if (f.isDirectory()) {\n                                 FileUtils.deleteDirectory(f);\n-                            } else{\n+                            } else {\n                                 if (!f.delete()) {\n                                     LOG.warn(\"Could not delete {}\", f);\n                                 }"},{"sha":"87116ded493997a22ce42de58083c034ba257b44","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/GarbageCollector.java","status":"modified","additions":8,"deletions":10,"changes":18,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FGarbageCollector.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FGarbageCollector.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FGarbageCollector.java?ref=086537beda9427c057a286ad6c4614659da6ed7f","patch":"@@ -27,25 +27,23 @@\n  */\n public interface GarbageCollector {\n     /**\n-     * Do the garbage collector work\n+     * Do the garbage collector work.\n      *\n-     * @param garbageCleaner\n-     *          cleaner used to clean selected garbages\n+     * @param garbageCleaner cleaner used to clean selected garbages\n      */\n-    public abstract void gc(GarbageCleaner garbageCleaner);\n+    void gc(GarbageCleaner garbageCleaner);\n \n     /**\n-     * A interface used to define customised garbage cleaner\n+     * A interface used to define customised garbage cleaner.\n      */\n-    public interface GarbageCleaner {\n+    interface GarbageCleaner {\n \n         /**\n-         * Clean a specific ledger\n+         * Clean a specific ledger.\n          *\n-         * @param ledgerId\n-         *          Ledger ID to be cleaned\n+         * @param ledgerId Ledger ID to be cleaned\n          */\n-        public void clean(final long ledgerId) ;\n+        void clean(final long ledgerId);\n     }\n \n }"},{"sha":"c43fb5122e11621e29638efbc185bf5171a95e5e","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/GarbageCollectorThread.java","status":"modified","additions":21,"deletions":20,"changes":41,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FGarbageCollectorThread.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FGarbageCollectorThread.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FGarbageCollectorThread.java?ref=086537beda9427c057a286ad6c4614659da6ed7f","patch":"@@ -121,9 +121,8 @@ private static class Throttler {\n             this.isThrottleByBytes  = isThrottleByBytes;\n             this.compactionRateByBytes = compactionRateByBytes;\n             this.compactionRateByEntries = compactionRateByEntries;\n-            this.rateLimiter = RateLimiter.create(this.isThrottleByBytes ?\n-                                                  this.compactionRateByBytes :\n-                                                  this.compactionRateByEntries);\n+            this.rateLimiter = RateLimiter.create(this.isThrottleByBytes\n+                    ? this.compactionRateByBytes : this.compactionRateByEntries);\n         }\n \n         // acquire. if bybytes: bytes of this entry; if byentries: 1.\n@@ -133,7 +132,7 @@ void acquire(int permits) {\n     }\n \n     /**\n-     * A scanner wrapper to check whether a ledger is alive in an entry log file\n+     * A scanner wrapper to check whether a ledger is alive in an entry log file.\n      */\n     class CompactionScannerFactory {\n         List<EntryLocation> offsets = new ArrayList<EntryLocation>();\n@@ -262,8 +261,8 @@ public void clean(long ledgerId) {\n         }\n \n         if (enableMinorCompaction && enableMajorCompaction) {\n-            if (minorCompactionInterval >= majorCompactionInterval ||\n-                minorCompactionThreshold >= majorCompactionThreshold) {\n+            if (minorCompactionInterval >= majorCompactionInterval\n+                || minorCompactionThreshold >= majorCompactionThreshold) {\n                 throw new IOException(\"Invalid minor/major compaction settings : minor (\"\n                                     + minorCompactionThreshold + \", \" + minorCompactionInterval\n                                     + \"), major (\" + majorCompactionThreshold + \", \"\n@@ -294,7 +293,7 @@ public void disableForceGC() {\n     }\n \n     /**\n-     * Manually trigger GC (for testing)\n+     * Manually trigger GC (for testing).\n      */\n     Future<?> triggerGC() {\n         return gcExecutor.submit(this);\n@@ -308,7 +307,8 @@ public void suspendMajorGC() {\n \n     public void resumeMajorGC() {\n         if (suspendMajorCompaction.compareAndSet(true, false)) {\n-            LOG.info(\"{} Major Compaction back to normal since bookie has enough space now.\", Thread.currentThread().getName());\n+            LOG.info(\"{} Major Compaction back to normal since bookie has enough space now.\",\n+                    Thread.currentThread().getName());\n         }\n     }\n \n@@ -320,7 +320,8 @@ public void suspendMinorGC() {\n \n     public void resumeMinorGC() {\n         if (suspendMinorCompaction.compareAndSet(true, false)) {\n-            LOG.info(\"{} Minor Compaction back to normal since bookie has enough space now.\", Thread.currentThread().getName());\n+            LOG.info(\"{} Minor Compaction back to normal since bookie has enough space now.\",\n+                    Thread.currentThread().getName());\n         }\n     }\n \n@@ -358,8 +359,8 @@ public void safeRun() {\n         }\n \n         long curTime = MathUtils.now();\n-        if (enableMajorCompaction && (!suspendMajor) &&\n-            (force || curTime - lastMajorCompactionTime > majorCompactionInterval)) {\n+        if (enableMajorCompaction && (!suspendMajor)\n+            && (force || curTime - lastMajorCompactionTime > majorCompactionInterval)) {\n             // enter major compaction\n             LOG.info(\"Enter major compaction, suspendMajor {}\", suspendMajor);\n             doCompactEntryLogs(majorCompactionThreshold);\n@@ -370,8 +371,8 @@ public void safeRun() {\n             return;\n         }\n \n-        if (enableMinorCompaction && (!suspendMinor) &&\n-            (force || curTime - lastMinorCompactionTime > minorCompactionInterval)) {\n+        if (enableMinorCompaction && (!suspendMinor)\n+            && (force || curTime - lastMinorCompactionTime > minorCompactionInterval)) {\n             // enter minor compaction\n             LOG.info(\"Enter minor compaction, suspendMinor {}\", suspendMinor);\n             doCompactEntryLogs(minorCompactionThreshold);\n@@ -381,18 +382,18 @@ public void safeRun() {\n     }\n \n     /**\n-     * Do garbage collection ledger index files\n+     * Do garbage collection ledger index files.\n      */\n     private void doGcLedgers() {\n         garbageCollector.gc(garbageCleaner);\n     }\n \n     /**\n-     * Garbage collect those entry loggers which are not associated with any active ledgers\n+     * Garbage collect those entry loggers which are not associated with any active ledgers.\n      */\n     private void doGcEntryLogs() {\n         // Loop through all of the entry logs and remove the non-active ledgers.\n-        for (Map.Entry<Long,EntryLogMetadata> entry :  entryLogMetaMap.entrySet()) {\n+        for (Map.Entry<Long, EntryLogMetadata> entry :  entryLogMetaMap.entrySet()) {\n             long entryLogId = entry.getKey();\n             EntryLogMetadata meta = entry.getValue();\n             for (Long entryLogLedger : meta.getLedgersMap().keySet()) {\n@@ -510,8 +511,8 @@ private void removeEntryLog(long entryLogId) {\n     /**\n      * Compact an entry log.\n      *\n-     * @param entryLogId\n-     *          Entry Log File Id\n+     * @param scannerFactory\n+     * @param entryLogMeta\n      */\n     protected void compactEntryLog(CompactionScannerFactory scannerFactory,\n                                    EntryLogMetadata entryLogMeta) throws IOException {\n@@ -571,8 +572,8 @@ protected Map<Long, EntryLogMetadata> extractMetaFromEntryLogs(Map<Long, EntryLo\n                 entryLogMetaMap.put(entryLogId, entryLogMeta);\n             } catch (IOException e) {\n                 hasExceptionWhenScan = true;\n-                LOG.warn(\"Premature exception when processing \" + entryLogId +\n-                         \" recovery will take care of the problem\", e);\n+                LOG.warn(\"Premature exception when processing \" + entryLogId\n+                         + \" recovery will take care of the problem\", e);\n             }\n \n             // if scan failed on some entry log, we don't move 'scannedLogId' to next id"},{"sha":"0af0304b13e441277a0cced2d4c34461f7c7784c","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/IndexInMemPageMgr.java","status":"modified","additions":44,"deletions":61,"changes":105,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FIndexInMemPageMgr.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FIndexInMemPageMgr.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FIndexInMemPageMgr.java?ref=086537beda9427c057a286ad6c4614659da6ed7f","patch":"@@ -54,13 +54,13 @@\n import static org.apache.bookkeeper.bookie.BookKeeperServerStats.NUM_INDEX_PAGES;\n \n class IndexInMemPageMgr {\n-    private final static Logger LOG = LoggerFactory.getLogger(IndexInMemPageMgr.class);\n-    private final static ConcurrentHashMap<Long, LedgerEntryPage> EMPTY_PAGE_MAP\n-        = new ConcurrentHashMap<Long, LedgerEntryPage>();\n+    private static final Logger LOG = LoggerFactory.getLogger(IndexInMemPageMgr.class);\n+    private static final ConcurrentHashMap<Long, LedgerEntryPage> EMPTY_PAGE_MAP =\n+            new ConcurrentHashMap<Long, LedgerEntryPage>();\n \n     private static class InMemPageCollection implements LEPStateChangeCallback {\n \n-        final ConcurrentMap<Long, ConcurrentMap<Long,LedgerEntryPage>> pages;\n+        final ConcurrentMap<Long, ConcurrentMap<Long, LedgerEntryPage>> pages;\n         final Map<EntryKey, LedgerEntryPage> lruCleanPageMap;\n         final ConcurrentLinkedQueue<LedgerEntryPage> listOfFreePages;\n \n@@ -70,19 +70,18 @@ private static class InMemPageCollection implements LEPStateChangeCallback {\n \n         public InMemPageCollection(StatsLogger statsLogger) {\n             pages = new ConcurrentHashMap<Long, ConcurrentMap<Long,LedgerEntryPage>>();\n-            lruCleanPageMap = Collections.synchronizedMap(new LinkedHashMap<EntryKey, LedgerEntryPage>(16, 0.75f, true));\n+            lruCleanPageMap =\n+                    Collections.synchronizedMap(new LinkedHashMap<EntryKey, LedgerEntryPage>(16, 0.75f, true));\n             listOfFreePages = new ConcurrentLinkedQueue<LedgerEntryPage>();\n             illegalStateResetCounter = statsLogger.getCounter(INDEX_INMEM_ILLEGAL_STATE_RESET);\n             illegalStateDeleteCounter = statsLogger.getCounter(INDEX_INMEM_ILLEGAL_STATE_DELETE);\n         }\n \n         /**\n-         * Retrieve the LedgerEntryPage corresponding to the ledger and firstEntry\n+         * Retrieve the LedgerEntryPage corresponding to the ledger and firstEntry.\n          *\n-         * @param ledgerId\n-         *          Ledger id\n-         * @param firstEntry\n-         *          Id of the first entry in the page\n+         * @param ledgerId Ledger id\n+         * @param firstEntry Id of the first entry in the page\n          * @returns LedgerEntryPage if present\n          */\n         private LedgerEntryPage getPage(long ledgerId, long firstEntry) {\n@@ -94,10 +93,9 @@ private LedgerEntryPage getPage(long ledgerId, long firstEntry) {\n         }\n \n         /**\n-         * Add a LedgerEntryPage to the page map\n+         * Add a LedgerEntryPage to the page map.\n          *\n-         * @param lep\n-         *          Ledger Entry Page object\n+         * @param lep Ledger Entry Page object\n          */\n         private LedgerEntryPage putPage(LedgerEntryPage lep) {\n             // Do a get here to avoid too many new ConcurrentHashMaps() as putIntoTable is called frequently.\n@@ -121,19 +119,17 @@ private LedgerEntryPage putPage(LedgerEntryPage lep) {\n         }\n \n         /**\n-         * Traverse the pages for a given ledger in memory and find the highest\n-         * entry amongst these pages\n+         * Traverse the pages for a given ledger in memory and find the highest entry amongst these pages.\n          *\n-         * @param ledgerId\n-         *          Ledger id\n+         * @param ledgerId Ledger id\n          * @returns last entry in the in memory pages\n          */\n         private long getLastEntryInMem(long ledgerId) {\n             long lastEntry = 0;\n             // Find the last entry in the cache\n             ConcurrentMap<Long, LedgerEntryPage> map = pages.get(ledgerId);\n             if (map != null) {\n-                for(LedgerEntryPage lep: map.values()) {\n+                for (LedgerEntryPage lep: map.values()) {\n                     if (lep.getMaxPossibleEntry() < lastEntry) {\n                         continue;\n                     }\n@@ -149,19 +145,18 @@ private long getLastEntryInMem(long ledgerId) {\n         }\n \n         /**\n-         * Removes ledger entry pages for a given ledger\n+         * Removes ledger entry pages for a given ledger.\n          *\n-         * @param ledgerId\n-         *          Ledger id\n+         * @param ledgerId Ledger id\n          * @returns number of pages removed\n          */\n         private void removeEntriesForALedger(long ledgerId) {\n             // remove pages first to avoid page flushed when deleting file info\n             ConcurrentMap<Long, LedgerEntryPage> lPages = pages.remove(ledgerId);\n             if (null != lPages) {\n-                for (Map.Entry<Long, LedgerEntryPage> pageEntry : lPages.entrySet()) {\n+                for (Map.Entry<Long, LedgerEntryPage> pageEntry: lPages.entrySet()) {\n                     long entryId = pageEntry.getKey();\n-                    synchronized(lruCleanPageMap) {\n+                    synchronized (lruCleanPageMap) {\n                         lruCleanPageMap.remove(new EntryKey(ledgerId, entryId));\n                     }\n \n@@ -181,10 +176,9 @@ private void removeEntriesForALedger(long ledgerId) {\n \n         /**\n          * Gets the list of pages in memory that have been changed and hence need to\n-         * be written as a part of the flush operation that is being issued\n+         * be written as a part of the flush operation that is being issued.\n          *\n-         * @param ledgerId\n-         *          Ledger id\n+         * @param ledgerId Ledger id\n          * @returns last entry in the in memory pages.\n          */\n         private LinkedList<Long> getFirstEntryListToBeFlushed(long ledgerId) {\n@@ -194,7 +188,7 @@ private LinkedList<Long> getFirstEntryListToBeFlushed(long ledgerId) {\n             }\n \n             LinkedList<Long> firstEntryList = new LinkedList<Long>();\n-            for(ConcurrentMap.Entry<Long, LedgerEntryPage> entry: pageMap.entrySet()) {\n+            for (ConcurrentMap.Entry<Long, LedgerEntryPage> entry: pageMap.entrySet()) {\n                 LedgerEntryPage lep = entry.getValue();\n                 if (lep.isClean()) {\n                     if (!lep.inUse()) {\n@@ -211,49 +205,44 @@ private LinkedList<Long> getFirstEntryListToBeFlushed(long ledgerId) {\n         }\n \n         /**\n-         * Add the LedgerEntryPage to the clean page LRU map\n+         * Add the LedgerEntryPage to the clean page LRU map.\n          *\n-         * @param lep\n-         *          Ledger Entry Page object\n+         * @param lep Ledger Entry Page object\n          */\n         private void addToCleanPagesList(LedgerEntryPage lep) {\n-            synchronized(lruCleanPageMap) {\n+            synchronized (lruCleanPageMap) {\n                 if (lep.isClean() && !lep.inUse()) {\n                     lruCleanPageMap.put(lep.getEntryKey(), lep);\n                 }\n             }\n         }\n \n         /**\n-         * Remove the LedgerEntryPage from the clean page LRU map\n+         * Remove the LedgerEntryPage from the clean page LRU map.\n          *\n-         * @param lep\n-         *          Ledger Entry Page object\n+         * @param lep Ledger Entry Page object\n          */\n         private void removeFromCleanPageList(LedgerEntryPage lep) {\n-            synchronized(lruCleanPageMap) {\n+            synchronized (lruCleanPageMap) {\n                 if (!lep.isClean() || lep.inUse()) {\n                     lruCleanPageMap.remove(lep.getEntryKey());\n                 }\n             }\n         }\n \n         /**\n-         * Get the set of active ledgers\n+         * Get the set of active ledgers.\n          *\n          */\n         Set<Long> getActiveLedgers() {\n             return pages.keySet();\n         }\n \n         /**\n-         * Get a clean page and provision it for the specified ledger and firstEntry within\n-         * the ledger\n+         * Get a clean page and provision it for the specified ledger and firstEntry within the ledger.\n          *\n-         * @param ledgerId\n-         *          Ledger id\n-         * @param firstEntry\n-         *          Id of the first entry in the page\n+         * @param ledgerId Ledger id\n+         * @param firstEntry Id of the first entry in the page\n          * @returns LedgerEntryPage if present\n          */\n         LedgerEntryPage grabCleanPage(long ledgerId, long firstEntry) {\n@@ -266,16 +255,14 @@ LedgerEntryPage grabCleanPage(long ledgerId, long firstEntry) {\n             }\n             while (lruCleanPageMap.size() > 0) {\n                 lep = null;\n-                synchronized(lruCleanPageMap) {\n-                    Iterator<Map.Entry<EntryKey,LedgerEntryPage>> iterator = lruCleanPageMap.entrySet().iterator();\n+                synchronized (lruCleanPageMap) {\n+                    Iterator<Map.Entry<EntryKey, LedgerEntryPage>> iterator = lruCleanPageMap.entrySet().iterator();\n \n-                    Map.Entry<EntryKey,LedgerEntryPage> entry = null;\n-                    while (iterator.hasNext())\n-                    {\n+                    Map.Entry<EntryKey, LedgerEntryPage> entry = null;\n+                    while (iterator.hasNext()) {\n                         entry = iterator.next();\n                         iterator.remove();\n-                        if (entry.getValue().isClean() &&\n-                                !entry.getValue().inUse()) {\n+                        if (entry.getValue().isClean() && !entry.getValue().inUse()) {\n                             lep = entry.getValue();\n                             break;\n                         }\n@@ -360,7 +347,7 @@ public void onSetDirty(LedgerEntryPage lep) {\n     private final IndexPersistenceMgr indexPersistenceManager;\n \n     /**\n-     * the list of potentially dirty ledgers\n+     * the list of potentially dirty ledgers.\n      */\n     private final ConcurrentLinkedQueue<Long> ledgersToFlush = new ConcurrentLinkedQueue<Long>();\n     private final ConcurrentSkipListSet<Long> ledgersFlushing = new ConcurrentSkipListSet<Long>();\n@@ -475,14 +462,11 @@ LedgerEntryPage getLedgerEntryPageFromCache(long ledger,\n \n     /**\n      * Grab ledger entry page whose first entry is <code>pageEntry</code>.\n-     *\n      * If the page doesn't existed before, we allocate a memory page.\n      * Otherwise, we grab a clean page and read it from disk.\n      *\n-     * @param ledger\n-     *          Ledger Id\n-     * @param pageEntry\n-     *          Start entry of this entry page.\n+     * @param ledger Ledger Id\n+     * @param pageEntry Start entry of this entry page.\n      */\n     private LedgerEntryPage grabLedgerEntryPage(long ledger, long pageEntry) throws IOException {\n         LedgerEntryPage lep = grabCleanPage(ledger, pageEntry);\n@@ -533,7 +517,7 @@ private LedgerEntryPage grabCleanPage(long ledger, long entry) throws IOExceptio\n             throw new IllegalArgumentException(entry + \" is not a multiple of \" + entriesPerPage);\n         }\n \n-        while(true) {\n+        while (true) {\n             boolean canAllocate = false;\n             if (pageCount.incrementAndGet() <= pageLimit) {\n                 canAllocate = true;\n@@ -579,10 +563,9 @@ void flushOneOrMoreLedgers(boolean doAll) throws IOException {\n     }\n \n     /**\n-     * Flush a specified ledger\n+     * Flush a specified ledger.\n      *\n-     * @param ledger\n-     *          Ledger Id\n+     * @param ledger Ledger Id\n      * @throws IOException\n      */\n     private void flushSpecificLedger(long ledger) throws IOException {\n@@ -602,15 +585,15 @@ private void flushSpecificLedger(long ledger) throws IOException {\n         // Now flush all the pages of a ledger\n         List<LedgerEntryPage> entries = new ArrayList<LedgerEntryPage>(firstEntryList.size());\n         try {\n-            for(Long firstEntry: firstEntryList) {\n+            for (Long firstEntry: firstEntryList) {\n                 LedgerEntryPage lep = getLedgerEntryPageFromCache(ledger, firstEntry, true);\n                 if (lep != null) {\n                     entries.add(lep);\n                 }\n             }\n             indexPersistenceManager.flushLedgerEntries(ledger, entries);\n         } finally {\n-            for(LedgerEntryPage lep: entries) {\n+            for (LedgerEntryPage lep: entries) {\n                 lep.releasePage();\n             }\n         }"},{"sha":"d8bed79afcd1cdbe1a9dc9e2e4c8d4787be62d34","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/IndexPersistenceMgr.java","status":"modified","additions":7,"deletions":3,"changes":10,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FIndexPersistenceMgr.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FIndexPersistenceMgr.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FIndexPersistenceMgr.java?ref=086537beda9427c057a286ad6c4614659da6ed7f","patch":"@@ -47,8 +47,11 @@\n import static org.apache.bookkeeper.bookie.BookKeeperServerStats.LEDGER_CACHE_NUM_EVICTED_LEDGERS;\n import static org.apache.bookkeeper.bookie.BookKeeperServerStats.NUM_OPEN_LEDGERS;\n \n+/**\n+ * @TODO: Write JavaDoc comment {@link https://github.com/apache/bookkepeer/issues/247}\n+ */\n public class IndexPersistenceMgr {\n-    private final static Logger LOG = LoggerFactory.getLogger(IndexPersistenceMgr.class);\n+    private static final Logger LOG = LoggerFactory.getLogger(IndexPersistenceMgr.class);\n \n     private static final String IDX = \".idx\";\n     static final String RLOC = \".rloc\";\n@@ -363,7 +366,7 @@ Long getLastAddConfirmed(long ledgerId) throws IOException {\n             }\n         }\n     }\n-    \n+\n     Observable waitForLastAddConfirmedUpdate(long ledgerId, long previoisLAC, Observer observer) throws IOException {\n         FileInfo fi = null;\n         try {\n@@ -679,7 +682,8 @@ long getPersistEntryBeyondInMem(long ledgerId, long lastEntryInMem) throws IOExc\n                     position = 0;\n                 }\n                 // we read the last page from file size minus page size, so it should not encounter short read\n-                // exception. if it does, it is an unexpected situation, then throw the exception and fail it immediately.\n+                // exception. if it does, it is an unexpected situation, then throw the exception and fail it\n+                // immediately.\n                 try {\n                     fi.read(bb, position, false);\n                 } catch (ShortReadException sre) {"},{"sha":"2a4957068f882c048eb6bec0eb331a430d71f0bf","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/InterleavedLedgerStorage.java","status":"modified","additions":11,"deletions":7,"changes":18,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FInterleavedLedgerStorage.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FInterleavedLedgerStorage.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FInterleavedLedgerStorage.java?ref=086537beda9427c057a286ad6c4614659da6ed7f","patch":"@@ -57,9 +57,11 @@\n  * file and maintains an index file for each ledger.\n  */\n public class InterleavedLedgerStorage implements CompactableLedgerStorage, EntryLogListener {\n-    private final static Logger LOG = LoggerFactory.getLogger(InterleavedLedgerStorage.class);\n+    private static final Logger LOG = LoggerFactory.getLogger(InterleavedLedgerStorage.class);\n \n-    // Hold the last checkpoint\n+    /**\n+     * Hold the last checkpoint.\n+     */\n     protected static class CheckpointHolder {\n         Checkpoint lastCheckpoint = Checkpoint.MAX;\n \n@@ -84,7 +86,8 @@ protected synchronized Checkpoint getLastCheckpoint() {\n     LedgerCache ledgerCache;\n     private CheckpointSource checkpointSource;\n     protected final CheckpointHolder checkpointHolder = new CheckpointHolder();\n-    private final CopyOnWriteArrayList<LedgerDeletionListener> ledgerDeletionListeners = Lists.newCopyOnWriteArrayList();\n+    private final CopyOnWriteArrayList<LedgerDeletionListener> ledgerDeletionListeners =\n+            Lists.newCopyOnWriteArrayList();\n \n     // A sorted map to stored all active ledger ids\n     protected final SnapshotMap<Long, Boolean> activeLedgers;\n@@ -261,13 +264,14 @@ public long getLastAddConfirmed(long ledgerId) throws IOException {\n     }\n \n     @Override\n-    public Observable waitForLastAddConfirmedUpdate(long ledgerId, long previoisLAC, Observer observer) throws IOException {\n+    public Observable waitForLastAddConfirmedUpdate(long ledgerId, long previoisLAC, Observer observer)\n+            throws IOException {\n         return ledgerCache.waitForLastAddConfirmedUpdate(ledgerId, previoisLAC, observer);\n     }\n \n \n     @Override\n-    synchronized public long addEntry(ByteBuf entry) throws IOException {\n+    public synchronized long addEntry(ByteBuf entry) throws IOException {\n         long ledgerId = entry.getLong(entry.readerIndex() + 0);\n         long entryId = entry.getLong(entry.readerIndex() + 8);\n         long lac = entry.getLong(entry.readerIndex() + 16);\n@@ -371,7 +375,7 @@ public Checkpoint checkpoint(Checkpoint checkpoint) throws IOException {\n     }\n \n     @Override\n-    synchronized public void flush() throws IOException {\n+    public synchronized void flush() throws IOException {\n         if (!somethingWritten) {\n             return;\n         }\n@@ -431,7 +435,7 @@ protected void processEntry(long ledgerId, long entryId, ByteBuffer entry) throw\n         processEntry(ledgerId, entryId, entry, true);\n     }\n \n-    synchronized protected void processEntry(long ledgerId, long entryId, ByteBuffer entry, boolean rollLog)\n+    protected synchronized void processEntry(long ledgerId, long entryId, ByteBuffer entry, boolean rollLog)\n             throws IOException {\n         /*\n          * Touch dirty flag"},{"sha":"c94bd06e59c4410d8f72e206d5d22585d581a1a6","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Journal.java","status":"modified","additions":91,"deletions":96,"changes":187,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FJournal.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FJournal.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FJournal.java?ref=086537beda9427c057a286ad6c4614659da6ed7f","patch":"@@ -54,24 +54,22 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import static org.apache.bookkeeper.bookie.BookKeeperServerStats.*;\n-\n /**\n  * Provide journal related management.\n  */\n class Journal extends BookieCriticalThread implements CheckpointSource {\n \n-    private final static Logger LOG = LoggerFactory.getLogger(Journal.class);\n+    private static final Logger LOG = LoggerFactory.getLogger(Journal.class);\n \n     /**\n-     * Filter to pickup journals\n+     * Filter to pickup journals.\n      */\n-    private static interface JournalIdFilter {\n-        public boolean accept(long journalId);\n+    private interface JournalIdFilter {\n+        boolean accept(long journalId);\n     }\n \n     /**\n-     * List all journal ids by a specified journal id filer\n+     * List all journal ids by a specified journal id filer.\n      *\n      * @param journalDir journal dir\n      * @param filter journal id filter\n@@ -83,7 +81,7 @@ private static List<Long> listJournalIds(File journalDir, JournalIdFilter filter\n             return Collections.emptyList();\n         }\n         List<Long> logs = new ArrayList<Long>();\n-        for(File f: logFiles) {\n+        for (File f: logFiles) {\n             String name = f.getName();\n             if (!name.endsWith(\".txn\")) {\n                 continue;\n@@ -120,15 +118,15 @@ public int compareTo(Checkpoint o) {\n             } else if (o == Checkpoint.MIN) {\n                 return 1;\n             }\n-            return mark.getCurMark().compare(((LogMarkCheckpoint)o).mark.getCurMark());\n+            return mark.getCurMark().compare(((LogMarkCheckpoint) o).mark.getCurMark());\n         }\n \n         @Override\n         public boolean equals(Object o) {\n             if (!(o instanceof LogMarkCheckpoint)) {\n                 return false;\n             }\n-            return 0 == compareTo((LogMarkCheckpoint)o);\n+            return 0 == compareTo((LogMarkCheckpoint) o);\n         }\n \n         @Override\n@@ -143,7 +141,7 @@ public String toString() {\n     }\n \n     /**\n-     * Last Log Mark\n+     * Last Log Mark.\n      */\n     class LastLogMark {\n         private final LogMark curMark;\n@@ -205,7 +203,7 @@ void readLog() {\n             byte buff[] = new byte[16];\n             ByteBuffer bb = ByteBuffer.wrap(buff);\n             LogMark mark = new LogMark();\n-            for(File dir: ledgerDirsManager.getAllLedgerDirs()) {\n+            for (File dir: ledgerDirsManager.getAllLedgerDirs()) {\n                 File file = new File(dir, \"lastMark\");\n                 try {\n                     FileInputStream fis = new FileInputStream(file);\n@@ -224,7 +222,8 @@ void readLog() {\n                         curMark.setLogMark(mark.getLogFileId(), mark.getLogFileOffset());\n                     }\n                 } catch (IOException e) {\n-                    LOG.error(\"Problems reading from \" + file + \" (this is okay if it is the first time starting this bookie\");\n+                    LOG.error(\"Problems reading from \" + file + \" (this is okay if it is the first time starting this \"\n+                            + \"bookie\");\n                 }\n             }\n         }\n@@ -236,7 +235,7 @@ public String toString() {\n     }\n \n     /**\n-     * Filter to return list of journals for rolling\n+     * Filter to return list of journals for rolling.\n      */\n     private static class JournalRollingFilter implements JournalIdFilter {\n \n@@ -257,25 +256,22 @@ public boolean accept(long journalId) {\n     }\n \n     /**\n-     * Scanner used to scan a journal\n+     * Scanner used to scan a journal.\n      */\n-    public static interface JournalScanner {\n+    public interface JournalScanner {\n         /**\n          * Process a journal entry.\n          *\n-         * @param journalVersion\n-         *          Journal Version\n-         * @param offset\n-         *          File offset of the journal entry\n-         * @param entry\n-         *          Journal Entry\n+         * @param journalVersion Journal Version\n+         * @param offset File offset of the journal entry\n+         * @param entry Journal Entry\n          * @throws IOException\n          */\n-        public void process(int journalVersion, long offset, ByteBuffer entry) throws IOException;\n+        void process(int journalVersion, long offset, ByteBuffer entry) throws IOException;\n     }\n \n     /**\n-     * Journal Entry to Record\n+     * Journal Entry to Record.\n      */\n     private class QueueEntry implements Runnable {\n         ByteBuf entry;\n@@ -285,8 +281,7 @@ private class QueueEntry implements Runnable {\n         Object ctx;\n         long enqueueTime;\n \n-        QueueEntry(ByteBuf entry, long ledgerId, long entryId,\n-                   WriteCallback cb, Object ctx, long enqueueTime) {\n+        QueueEntry(ByteBuf entry, long ledgerId, long entryId, WriteCallback cb, Object ctx, long enqueueTime) {\n             this.entry = entry.duplicate();\n             this.cb = cb;\n             this.ctx = ctx;\n@@ -348,8 +343,7 @@ public int process(boolean shouldForceWrite) throws IOException {\n                 }\n \n                 return this.forceWriteWaiters.size();\n-            }\n-            finally {\n+            } finally {\n                 closeFileIfNecessary();\n             }\n         }\n@@ -363,16 +357,15 @@ public void closeFileIfNecessary() {\n                     logFile.close();\n                     // Call close only once\n                     shouldClose = false;\n-                }\n-                catch (IOException ioe) {\n+                } catch (IOException ioe) {\n                     LOG.error(\"I/O exception while closing file\", ioe);\n                 }\n             }\n         }\n     }\n \n     /**\n-     * ForceWriteThread is a background thread which makes the journal durable periodically\n+     * ForceWriteThread is a background thread which makes the journal durable periodically.\n      *\n      */\n     private class ForceWriteThread extends BookieCriticalThread {\n@@ -393,7 +386,7 @@ public void run() {\n             LOG.info(\"ForceWrite Thread started\");\n             boolean shouldForceWrite = true;\n             int numReqInLastForceWrite = 0;\n-            while(running) {\n+            while (running) {\n                 ForceWriteRequest req = null;\n                 try {\n                     req = forceWriteRequests.take();\n@@ -420,16 +413,15 @@ public void run() {\n                         numReqInLastForceWrite += req.process(shouldForceWrite);\n                     }\n \n-                    if (enableGroupForceWrites &&\n-                        // if its a marker we should switch back to flushing\n-                        !req.isMarker &&\n-                        // This indicates that this is the last request in a given file\n-                        // so subsequent requests will go to a different file so we should\n-                        // flush on the next request\n-                        !req.shouldClose) {\n+                    if (enableGroupForceWrites\n+                            // if its a marker we should switch back to flushing\n+                            && !req.isMarker\n+                            // This indicates that this is the last request in a given file\n+                            // so subsequent requests will go to a different file so we should\n+                            // flush on the next request\n+                            && !req.shouldClose) {\n                         shouldForceWrite = false;\n-                    }\n-                    else {\n+                    } else {\n                         shouldForceWrite = true;\n                     }\n                 } catch (IOException ioe) {\n@@ -458,7 +450,7 @@ void shutdown() throws InterruptedException {\n         }\n     }\n \n-    final static int PADDING_MASK = -0x100;\n+    static final int PADDING_MASK = -0x100;\n \n     static void writePaddingBytes(JournalChannel jc, ByteBuffer paddingBuffer, int journalAlignSize)\n             throws IOException {\n@@ -485,8 +477,8 @@ static void writePaddingBytes(JournalChannel jc, ByteBuffer paddingBuffer, int j\n         }\n     }\n \n-    final static long MB = 1024 * 1024L;\n-    final static int KB = 1024;\n+    static final long MB = 1024 * 1024L;\n+    static final int KB = 1024;\n     // max journal file size\n     final long maxJournalSize;\n     // pre-allocation size for the journal files\n@@ -545,7 +537,8 @@ public Journal(File journalDirectory, ServerConfiguration conf, LedgerDirsManage\n         this(journalDirectory, conf, ledgerDirsManager, NullStatsLogger.INSTANCE);\n     }\n \n-    public Journal(File journalDirectory, ServerConfiguration conf, LedgerDirsManager ledgerDirsManager, StatsLogger statsLogger) {\n+    public Journal(File journalDirectory, ServerConfiguration conf, LedgerDirsManager ledgerDirsManager,\n+                   StatsLogger statsLogger) {\n         super(\"BookieJournal-\" + conf.getBookiePort());\n         this.ledgerDirsManager = ledgerDirsManager;\n         this.conf = conf;\n@@ -573,21 +566,24 @@ public Journal(File journalDirectory, ServerConfiguration conf, LedgerDirsManage\n         }\n \n         // Expose Stats\n-        journalAddEntryStats = statsLogger.getOpStatsLogger(JOURNAL_ADD_ENTRY);\n-        journalSyncStats = statsLogger.getOpStatsLogger(JOURNAL_SYNC);\n-        journalCreationStats = statsLogger.getOpStatsLogger(JOURNAL_CREATION_LATENCY);\n-        journalFlushStats = statsLogger.getOpStatsLogger(JOURNAL_FLUSH_LATENCY);\n-        journalQueueStats = statsLogger.getOpStatsLogger(JOURNAL_QUEUE_LATENCY);\n-        journalProcessTimeStats = statsLogger.getOpStatsLogger(JOURNAL_PROCESS_TIME_LATENCY);\n-        forceWriteGroupingCountStats = statsLogger.getOpStatsLogger(JOURNAL_FORCE_WRITE_GROUPING_COUNT);\n-        forceWriteBatchEntriesStats = statsLogger.getOpStatsLogger(JOURNAL_FORCE_WRITE_BATCH_ENTRIES);\n-        forceWriteBatchBytesStats = statsLogger.getOpStatsLogger(JOURNAL_FORCE_WRITE_BATCH_BYTES);\n-        journalQueueSize = statsLogger.getCounter(JOURNAL_QUEUE_SIZE);\n-        forceWriteQueueSize = statsLogger.getCounter(JOURNAL_FORCE_WRITE_QUEUE_SIZE);\n-        flushMaxWaitCounter = statsLogger.getCounter(JOURNAL_NUM_FLUSH_MAX_WAIT);\n-        flushMaxOutstandingBytesCounter = statsLogger.getCounter(JOURNAL_NUM_FLUSH_MAX_OUTSTANDING_BYTES);\n-        flushEmptyQueueCounter = statsLogger.getCounter(JOURNAL_NUM_FLUSH_EMPTY_QUEUE);\n-        journalWriteBytes = statsLogger.getCounter(JOURNAL_WRITE_BYTES);\n+        journalAddEntryStats = statsLogger.getOpStatsLogger(BookKeeperServerStats.JOURNAL_ADD_ENTRY);\n+        journalSyncStats = statsLogger.getOpStatsLogger(BookKeeperServerStats.JOURNAL_SYNC);\n+        journalCreationStats = statsLogger.getOpStatsLogger(BookKeeperServerStats.JOURNAL_CREATION_LATENCY);\n+        journalFlushStats = statsLogger.getOpStatsLogger(BookKeeperServerStats.JOURNAL_FLUSH_LATENCY);\n+        journalQueueStats = statsLogger.getOpStatsLogger(BookKeeperServerStats.JOURNAL_QUEUE_LATENCY);\n+        journalProcessTimeStats = statsLogger.getOpStatsLogger(BookKeeperServerStats.JOURNAL_PROCESS_TIME_LATENCY);\n+        forceWriteGroupingCountStats =\n+                statsLogger.getOpStatsLogger(BookKeeperServerStats.JOURNAL_FORCE_WRITE_GROUPING_COUNT);\n+        forceWriteBatchEntriesStats =\n+                statsLogger.getOpStatsLogger(BookKeeperServerStats.JOURNAL_FORCE_WRITE_BATCH_ENTRIES);\n+        forceWriteBatchBytesStats = statsLogger.getOpStatsLogger(BookKeeperServerStats.JOURNAL_FORCE_WRITE_BATCH_BYTES);\n+        journalQueueSize = statsLogger.getCounter(BookKeeperServerStats.JOURNAL_QUEUE_SIZE);\n+        forceWriteQueueSize = statsLogger.getCounter(BookKeeperServerStats.JOURNAL_FORCE_WRITE_QUEUE_SIZE);\n+        flushMaxWaitCounter = statsLogger.getCounter(BookKeeperServerStats.JOURNAL_NUM_FLUSH_MAX_WAIT);\n+        flushMaxOutstandingBytesCounter =\n+                statsLogger.getCounter(BookKeeperServerStats.JOURNAL_NUM_FLUSH_MAX_OUTSTANDING_BYTES);\n+        flushEmptyQueueCounter = statsLogger.getCounter(BookKeeperServerStats.JOURNAL_NUM_FLUSH_EMPTY_QUEUE);\n+        journalWriteBytes = statsLogger.getCounter(BookKeeperServerStats.JOURNAL_WRITE_BYTES);\n     }\n \n     public File getJournalDirectory() {\n@@ -618,7 +614,7 @@ public void checkpointComplete(Checkpoint checkpoint, boolean compact) throws IO\n         if (!(checkpoint instanceof LogMarkCheckpoint)) {\n             return; // we didn't create this checkpoint, so dont do anything with it\n         }\n-        LogMarkCheckpoint lmcheckpoint = (LogMarkCheckpoint)checkpoint;\n+        LogMarkCheckpoint lmcheckpoint = (LogMarkCheckpoint) checkpoint;\n         LastLogMark mark = lmcheckpoint.mark;\n \n         mark.rollLog(mark);\n@@ -628,7 +624,7 @@ public void checkpointComplete(Checkpoint checkpoint, boolean compact) throws IO\n             // keep MAX_BACKUP_JOURNALS journal files before marked journal\n             if (logs.size() >= maxBackupJournals) {\n                 int maxIdx = logs.size() - maxBackupJournals;\n-                for (int i=0; i<maxIdx; i++) {\n+                for (int i = 0; i < maxIdx; i++) {\n                     long id = logs.get(i);\n                     // make sure the journal id is smaller than marked journal id\n                     if (id < mark.getCurMark().getLogFileId()) {\n@@ -644,14 +640,11 @@ public void checkpointComplete(Checkpoint checkpoint, boolean compact) throws IO\n     }\n \n     /**\n-     * Scan the journal\n+     * Scan the journal.\n      *\n-     * @param journalId\n-     *          Journal Log Id\n-     * @param journalPos\n-     *          Offset to start scanning\n-     * @param scanner\n-     *          Scanner to handle entries\n+     * @param journalId Journal Log Id\n+     * @param journalPos Offset to start scanning\n+     * @param scanner Scanner to handle entries\n      * @throws IOException\n      */\n     public void scanJournal(long journalId, long journalPos, JournalScanner scanner)\n@@ -660,13 +653,14 @@ public void scanJournal(long journalId, long journalPos, JournalScanner scanner)\n         if (journalPos <= 0) {\n             recLog = new JournalChannel(journalDirectory, journalId, journalPreAllocSize, journalWriteBufferSize);\n         } else {\n-            recLog = new JournalChannel(journalDirectory, journalId, journalPreAllocSize, journalWriteBufferSize, journalPos);\n+            recLog = new JournalChannel(journalDirectory, journalId, journalPreAllocSize, journalWriteBufferSize,\n+                    journalPos);\n         }\n         int journalVersion = recLog.getFormatVersion();\n         try {\n             ByteBuffer lenBuff = ByteBuffer.allocate(4);\n-            ByteBuffer recBuff = ByteBuffer.allocate(64*1024);\n-            while(true) {\n+            ByteBuffer recBuff = ByteBuffer.allocate(64 * 1024);\n+            while (true) {\n                 // entry start offset\n                 long offset = recLog.fc.position();\n                 // start reading entry\n@@ -720,10 +714,9 @@ public void scanJournal(long journalId, long journalPos, JournalScanner scanner)\n     }\n \n     /**\n-     * Replay journal files\n+     * Replay journal files.\n      *\n-     * @param scanner\n-     *          Scanner to process replayed entries.\n+     * @param scanner Scanner to process replayed entries.\n      * @throws IOException\n      */\n     public void replay(JournalScanner scanner) throws IOException {\n@@ -751,9 +744,9 @@ public boolean accept(long journalId) {\n         // TODO: When reading in the journal logs that need to be synced, we\n         // should use BufferedChannels instead to minimize the amount of\n         // system calls done.\n-        for(Long id: logs) {\n+        for (Long id: logs) {\n             long logPosition = 0L;\n-            if(id == markedLog.getLogFileId()) {\n+            if (id == markedLog.getLogFileId()) {\n                 logPosition = markedLog.getLogFileOffset();\n             }\n             LOG.info(\"Replaying journal {} from position {}\", id, logPosition);\n@@ -766,7 +759,7 @@ public void logAddEntry(ByteBuffer entry, WriteCallback cb, Object ctx) {\n     }\n \n     /**\n-     * record an add entry operation in journal\n+     * record an add entry operation in journal.\n      */\n     public void logAddEntry(ByteBuf entry, WriteCallback cb, Object ctx) {\n         long ledgerId = entry.getLong(entry.readerIndex() + 0);\n@@ -835,13 +828,8 @@ public void run() {\n                     logId = logId + 1;\n \n                     journalCreationWatcher.reset().start();\n-                    logFile = new JournalChannel(journalDirectory,\n-                                        logId,\n-                                        journalPreAllocSize,\n-                                        journalWriteBufferSize,\n-                                        journalAlignmentSize,\n-                                        removePagesFromCache,\n-                                        journalFormatVersionToWrite);\n+                    logFile = new JournalChannel(journalDirectory, logId, journalPreAllocSize, journalWriteBufferSize,\n+                                        journalAlignmentSize, removePagesFromCache, journalFormatVersionToWrite);\n                     journalCreationStats.registerSuccessfulEvent(\n                             journalCreationWatcher.stop().elapsed(TimeUnit.NANOSECONDS), TimeUnit.NANOSECONDS);\n \n@@ -852,23 +840,27 @@ public void run() {\n \n                 if (qe == null) {\n                     if (dequeueStartTime != 0) {\n-                        journalProcessTimeStats.registerSuccessfulEvent(MathUtils.elapsedNanos(dequeueStartTime), TimeUnit.NANOSECONDS);\n+                        journalProcessTimeStats.registerSuccessfulEvent(MathUtils.elapsedNanos(dequeueStartTime),\n+                                TimeUnit.NANOSECONDS);\n                     }\n \n                     if (toFlush.isEmpty()) {\n                         qe = queue.take();\n                         dequeueStartTime = MathUtils.nowInNano();\n-                        journalQueueStats.registerSuccessfulEvent(MathUtils.elapsedNanos(qe.enqueueTime), TimeUnit.NANOSECONDS);\n+                        journalQueueStats.registerSuccessfulEvent(MathUtils.elapsedNanos(qe.enqueueTime),\n+                                TimeUnit.NANOSECONDS);\n                     } else {\n-                        long pollWaitTimeNanos = maxGroupWaitInNanos - MathUtils.elapsedNanos(toFlush.get(0).enqueueTime);\n+                        long pollWaitTimeNanos =\n+                                maxGroupWaitInNanos - MathUtils.elapsedNanos(toFlush.get(0).enqueueTime);\n                         if (flushWhenQueueEmpty || pollWaitTimeNanos < 0) {\n                             pollWaitTimeNanos = 0;\n                         }\n                         qe = queue.poll(pollWaitTimeNanos, TimeUnit.NANOSECONDS);\n                         dequeueStartTime = MathUtils.nowInNano();\n \n                         if (qe != null) {\n-                            journalQueueStats.registerSuccessfulEvent(MathUtils.elapsedNanos(qe.enqueueTime), TimeUnit.NANOSECONDS);\n+                            journalQueueStats.registerSuccessfulEvent(MathUtils.elapsedNanos(qe.enqueueTime),\n+                                    TimeUnit.NANOSECONDS);\n                         }\n \n                         boolean shouldFlush = false;\n@@ -879,17 +871,18 @@ public void run() {\n                             groupWhenTimeout = true;\n                         } else if (maxGroupWaitInNanos > 0 && groupWhenTimeout && qe != null\n                                 && MathUtils.elapsedNanos(qe.enqueueTime) < maxGroupWaitInNanos) {\n-                            // when group timeout, it would be better to look forward, as there might be lots of entries already timeout\n+                            // when group timeout, it would be better to look forward, as there might be lots of\n+                            // entries already timeout\n                             // due to a previous slow write (writing to filesystem which impacted by force write).\n                             // Group those entries in the queue\n                             // a) already timeout\n                             // b) limit the number of entries to group\n                             groupWhenTimeout = false;\n                             shouldFlush = true;\n                             flushMaxWaitCounter.inc();\n-                        } else if (qe != null &&\n-                                ((bufferedEntriesThreshold > 0 && toFlush.size() > bufferedEntriesThreshold) ||\n-                                 (bc.position() > lastFlushPosition + bufferedWritesThreshold))) {\n+                        } else if (qe != null\n+                                && ((bufferedEntriesThreshold > 0 && toFlush.size() > bufferedEntriesThreshold)\n+                                || (bc.position() > lastFlushPosition + bufferedWritesThreshold))) {\n                             // 2. If we have buffered more than the buffWriteThreshold or bufferedEntriesThreshold\n                             shouldFlush = true;\n                             flushMaxOutstandingBytesCounter.inc();\n@@ -916,14 +909,16 @@ public void run() {\n                             // Trace the lifetime of entries through persistence\n                             if (LOG.isDebugEnabled()) {\n                                 for (QueueEntry e : toFlush) {\n-                                    LOG.debug(\"Written and queuing for flush Ledger:\" + e.ledgerId + \" Entry:\" + e.entryId);\n+                                    LOG.debug(\"Written and queuing for flush Ledger:\" + e.ledgerId + \" Entry:\"\n+                                            + e.entryId);\n                                 }\n                             }\n \n                             forceWriteBatchEntriesStats.registerSuccessfulValue(toFlush.size());\n                             forceWriteBatchBytesStats.registerSuccessfulValue(batchSize);\n \n-                            forceWriteRequests.put(new ForceWriteRequest(logFile, logId, lastFlushPosition, toFlush, (lastFlushPosition > maxJournalSize), false));\n+                            forceWriteRequests.put(new ForceWriteRequest(logFile, logId, lastFlushPosition, toFlush,\n+                                    (lastFlushPosition > maxJournalSize), false));\n                             toFlush = new LinkedList<QueueEntry>();\n                             batchSize = 0L;\n                             // check whether journal file is over file limit\n@@ -1010,7 +1005,7 @@ public synchronized void shutdown() {\n \n     private static int fullRead(JournalChannel fc, ByteBuffer bb) throws IOException {\n         int total = 0;\n-        while(bb.remaining() > 0) {\n+        while (bb.remaining() > 0) {\n             int rc = fc.read(bb);\n             if (rc <= 0) {\n                 return total;"},{"sha":"1d0c883d5225f8c6ed17f2d96b978b610cb2719d","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/JournalChannel.java","status":"modified","additions":9,"deletions":9,"changes":18,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FJournalChannel.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FJournalChannel.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FJournalChannel.java?ref=086537beda9427c057a286ad6c4614659da6ed7f","patch":"@@ -41,7 +41,7 @@\n  * information to the file.\n  */\n class JournalChannel implements Closeable {\n-    private final static Logger LOG = LoggerFactory.getLogger(JournalChannel.class);\n+    private static final Logger LOG = LoggerFactory.getLogger(JournalChannel.class);\n \n     final RandomAccessFile randomAccessFile;\n     final int fd;\n@@ -50,11 +50,11 @@ class JournalChannel implements Closeable {\n     final int formatVersion;\n     long nextPrealloc = 0;\n \n-    final byte[] MAGIC_WORD = \"BKLG\".getBytes(UTF_8);\n+    final byte[] magicWord = \"BKLG\".getBytes(UTF_8);\n \n-    final static int SECTOR_SIZE = 512;\n-    private final static int START_OF_FILE = -12345;\n-    private static long CACHE_DROP_LAG_BYTES = 8 * 1024 * 1024;\n+    static final int SECTOR_SIZE = 512;\n+    private static final int START_OF_FILE = -12345;\n+    private static long cacheDropLagBytes = 8 * 1024 * 1024;\n \n     // No header\n     static final int V1 = 1;\n@@ -156,7 +156,7 @@ private JournalChannel(File journalDirectory, long logId,\n             ByteBuffer bb = ByteBuffer.allocate(headerSize);\n             ZeroBuffer.put(bb);\n             bb.clear();\n-            bb.put(MAGIC_WORD);\n+            bb.put(magicWord);\n             bb.putInt(formatVersion);\n             bb.clear();\n             fc.write(bb);\n@@ -178,7 +178,7 @@ private JournalChannel(File journalDirectory, long logId,\n                 byte[] first4 = new byte[4];\n                 bb.get(first4);\n \n-                if (Arrays.equals(first4, MAGIC_WORD)) {\n+                if (Arrays.equals(first4, magicWord)) {\n                     formatVersion = bb.getInt();\n                 } else {\n                     // pre magic word journal, reset to 0;\n@@ -255,7 +255,7 @@ public void forceWrite(boolean forceMetadata) throws IOException {\n         // For POSIX_FADV_DONTNEED, we want to drop from the beginning\n         // of the file to a position prior to the current position.\n         //\n-        // The CACHE_DROP_LAG_BYTES is to prevent dropping a page that will\n+        // The cacheDropLagBytes is to prevent dropping a page that will\n         // be appended again, which would introduce random seeking on journal\n         // device.\n         //\n@@ -265,7 +265,7 @@ public void forceWrite(boolean forceMetadata) throws IOException {\n         // lastDropPosition     newDropPos             lastForceWritePosition\n         //\n         if (fRemoveFromPageCache) {\n-            long newDropPos = newForceWritePosition - CACHE_DROP_LAG_BYTES;\n+            long newDropPos = newForceWritePosition - cacheDropLagBytes;\n             if (lastDropPosition < newDropPos) {\n                 NativeIO.bestEffortRemoveFromPageCache(fd, lastDropPosition, newDropPos - lastDropPosition);\n             }"},{"sha":"e7eaabc0c22a1e80644939118cbf380fede94df3","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LEPStateChangeCallback.java","status":"modified","additions":4,"deletions":4,"changes":8,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLEPStateChangeCallback.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLEPStateChangeCallback.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLEPStateChangeCallback.java?ref=086537beda9427c057a286ad6c4614659da6ed7f","patch":"@@ -24,8 +24,8 @@\n  * Callback interface when state of ledger entry page changed.\n  */\n interface LEPStateChangeCallback {\n-    public void onSetInUse(LedgerEntryPage lep);\n-    public void onResetInUse(LedgerEntryPage lep);\n-    public void onSetClean(LedgerEntryPage lep);\n-    public void onSetDirty(LedgerEntryPage lep);\n+    void onSetInUse(LedgerEntryPage lep);\n+    void onResetInUse(LedgerEntryPage lep);\n+    void onSetClean(LedgerEntryPage lep);\n+    void onSetDirty(LedgerEntryPage lep);\n }"},{"sha":"f52ccf984b890362610f8b51d6d94544a98c47d4","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LastAddConfirmedUpdateNotification.java","status":"modified","additions":3,"deletions":0,"changes":3,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLastAddConfirmedUpdateNotification.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLastAddConfirmedUpdateNotification.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLastAddConfirmedUpdateNotification.java?ref=086537beda9427c057a286ad6c4614659da6ed7f","patch":"@@ -20,6 +20,9 @@\n  */\n package org.apache.bookkeeper.bookie;\n \n+/**\n+ * @TODO: Write JavaDoc comment {@link https://github.com/apache/bookkepeer/issues/247}\n+ */\n public class LastAddConfirmedUpdateNotification {\n     public long lastAddConfirmed;\n     public long timestamp;"},{"sha":"18d766614810bf743f00bc96f1969e2cd672f28c","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCacheImpl.java","status":"modified","additions":3,"deletions":2,"changes":5,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLedgerCacheImpl.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLedgerCacheImpl.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLedgerCacheImpl.java?ref=086537beda9427c057a286ad6c4614659da6ed7f","patch":"@@ -39,7 +39,7 @@\n  * This class serves two purposes.\n  */\n public class LedgerCacheImpl implements LedgerCache {\n-    private final static Logger LOG = LoggerFactory.getLogger(LedgerCacheImpl.class);\n+    private static final Logger LOG = LoggerFactory.getLogger(LedgerCacheImpl.class);\n \n     private final IndexInMemPageMgr indexPageManager;\n     private final IndexPersistenceMgr indexPersistenceManager;\n@@ -87,7 +87,8 @@ public long updateLastAddConfirmed(long ledgerId, long lac) throws IOException {\n     }\n \n     @Override\n-    public Observable waitForLastAddConfirmedUpdate(long ledgerId, long previoisLAC, Observer observer) throws IOException {\n+    public Observable waitForLastAddConfirmedUpdate(long ledgerId, long previoisLAC, Observer observer)\n+            throws IOException {\n         return indexPersistenceManager.waitForLastAddConfirmedUpdate(ledgerId, previoisLAC, observer);\n     }\n "},{"sha":"cb36e14b08eab175523c13288aa0f30c364baf72","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDescriptorImpl.java","status":"modified","additions":1,"deletions":2,"changes":3,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLedgerDescriptorImpl.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLedgerDescriptorImpl.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLedgerDescriptorImpl.java?ref=086537beda9427c057a286ad6c4614659da6ed7f","patch":"@@ -34,10 +34,9 @@\n /**\n  * Implements a ledger inside a bookie. In particular, it implements operations\n  * to write entries to a ledger and read entries from a ledger.\n- *\n  */\n public class LedgerDescriptorImpl extends LedgerDescriptor {\n-    private final static Logger LOG = LoggerFactory.getLogger(LedgerDescriptor.class);\n+    private static final Logger LOG = LoggerFactory.getLogger(LedgerDescriptor.class);\n     final LedgerStorage ledgerStorage;\n     private long ledgerId;\n     final byte[] masterKey;"},{"sha":"513d4d44ad3c2434204283fab771d33a7e0f7685","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDirsManager.java","status":"modified","additions":30,"deletions":40,"changes":70,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLedgerDirsManager.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLedgerDirsManager.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLedgerDirsManager.java?ref=086537beda9427c057a286ad6c4614659da6ed7f","patch":"@@ -45,8 +45,7 @@\n  * This class manages ledger directories used by the bookie.\n  */\n public class LedgerDirsManager {\n-    private final static Logger LOG = LoggerFactory\n-            .getLogger(LedgerDirsManager.class);\n+    private static final Logger LOG = LoggerFactory.getLogger(LedgerDirsManager.class);\n \n     private volatile List<File> filledDirs;\n     private final List<File> ledgerDirectories;\n@@ -108,23 +107,22 @@ public Number getSample() {\n     }\n \n     /**\n-     * Get all ledger dirs configured\n+     * Get all ledger dirs configured.\n      */\n     public List<File> getAllLedgerDirs() {\n         return ledgerDirectories;\n     }\n-    \n+\n     /**\n-     * Get all dir listeners\n-     * @return List<LedgerDirsListener> listeners\n+     * Get all dir listeners.\n+     * @return list of listeners\n      */\n     public List<LedgerDirsListener> getListeners() {\n         return listeners;\n     }\n \n     /**\n-     * Calculate the total amount of free space available\n-     * in all of the ledger directories put together.\n+     * Calculate the total amount of free space available in all of the ledger directories put together.\n      *\n      * @return totalDiskSpace in bytes\n      * @throws IOException \n@@ -134,8 +132,7 @@ public long getTotalFreeSpace(List<File> dirs) throws IOException {\n     }\n \n     /**\n-     * Calculate the total amount of free space available\n-     * in all of the ledger directories put together.\n+     * Calculate the total amount of free space available in all of the ledger directories put together.\n      *\n      * @return freeDiskSpace in bytes\n      * @throws IOException \n@@ -145,13 +142,13 @@ public long getTotalDiskSpace(List<File> dirs) throws IOException {\n     }\n     \n     /**\n-     * Get disk usages map\n-     * @return ConcurrentMap<File, Float> diskUsages\n+     * Get disk usages map.\n+     * @return disk usages map\n      */\n     public ConcurrentMap<File, Float> getDiskUsages() {\n         return diskUsages;\n     }\n-    \n+\n     /**\n      * Get only writable ledger dirs.\n      */\n@@ -168,7 +165,7 @@ public List<File> getWritableLedgerDirs()\n     }\n \n     /**\n-     * returns true if the writableLedgerDirs list has entries\n+     * @return true if the writableLedgerDirs list has entries\n      */\n     public boolean hasWritableLedgerDirs() {\n         return !writableLedgerDirectories.isEmpty();\n@@ -198,7 +195,7 @@ List<File> getDirsAboveUsableThresholdSize(long thresholdSize) throws NoWritable\n         List<File> fullLedgerDirsToAccomodate = new ArrayList<File>();\n         for (File dir: this.ledgerDirectories) {\n             // Pick dirs which can accommodate little more than thresholdSize\n-            if (dir.getUsableSpace() > (thresholdSize) ) {\n+            if (dir.getUsableSpace() > thresholdSize) {\n                 fullLedgerDirsToAccomodate.add(dir);\n             }\n         }\n@@ -216,7 +213,7 @@ List<File> getDirsAboveUsableThresholdSize(long thresholdSize) throws NoWritable\n         LOG.error(errMsg, e);\n         throw e;\n     }\n-    \n+\n     /**\n      * @return full-filled ledger dirs.\n      */\n@@ -225,20 +222,19 @@ public List<File> getFullFilledLedgerDirs() {\n     }\n \n     /**\n-     * Get dirs, which are full more than threshold\n+     * Get dirs, which are full more than threshold.\n      */\n     public boolean isDirFull(File dir) {\n         return filledDirs.contains(dir);\n     }\n \n     /**\n-     * Add the dir to filled dirs list\n+     * Add the dir to filled dirs list.\n      */\n     @VisibleForTesting\n     public void addToFilledDirs(File dir) {\n         if (!filledDirs.contains(dir)) {\n-            LOG.warn(dir + \" is out of space.\"\n-                    + \" Adding it to filled dirs list\");\n+            LOG.warn(dir + \" is out of space. Adding it to filled dirs list\");\n             // Update filled dirs list\n             List<File> updatedFilledDirs = new ArrayList<File>(filledDirs);\n             updatedFilledDirs.add(dir);\n@@ -306,9 +302,8 @@ File pickRandomWritableDir(File excludedDir) throws NoWritableLedgerDirException\n      * Pick up a dir randomly from writableLedgerDirectories. If writableLedgerDirectories is empty\n      * then pick up a dir randomly from the ledger/indexdirs which have usable space more than\n      * minUsableSizeForIndexFileCreation.\n-     * \n-     * @param excludedDir\n-     *          The directory to exclude during pickup.\n+     *\n+     * @param excludedDir The directory to exclude during pickup.\n      * @return\n      * @throws NoWritableLedgerDirException if there is no dir available.\n      */\n@@ -318,8 +313,8 @@ File pickRandomWritableDirForNewIndexFile(File excludedDir) throws NoWritableLed\n             writableDirsForNewIndexFile = writableLedgerDirectories;\n         } else {\n             // We don't have writable Index Dirs.\n-            // That means we must have turned readonly. But \n-            // during the Bookie restart, while replaying the journal there might be a need \n+            // That means we must have turned readonly. But\n+            // during the Bookie restart, while replaying the journal there might be a need\n             // to create new Index file and it should proceed.\n             writableDirsForNewIndexFile = getDirsAboveUsableThresholdSize(minUsableSizeForIndexFileCreation);\n         }\n@@ -372,43 +367,38 @@ public NoWritableLedgerDirException(String errMsg) {\n      * Listener for the disk check events will be notified from the\n      * {@link LedgerDirsManager} whenever disk full/failure detected.\n      */\n-    public static interface LedgerDirsListener {\n+    public interface LedgerDirsListener {\n         /**\n-         * This will be notified on disk failure/disk error\n+         * This will be notified on disk failure/disk error.\n          *\n-         * @param disk\n-         *            Failed disk\n+         * @param disk Failed disk\n          */\n         void diskFailed(File disk);\n \n         /**\n-         * Notified when the disk usage warn threshold is exceeded on\n-         * the drive.\n+         * Notified when the disk usage warn threshold is exceeded on the drive.\n          * @param disk\n          */\n         void diskAlmostFull(File disk);\n \n         /**\n-         * This will be notified on disk detected as full\n+         * This will be notified on disk detected as full.\n          *\n-         * @param disk\n-         *            Filled disk\n+         * @param disk Filled disk\n          */\n         void diskFull(File disk);\n \n         /**\n-         * This will be notified on disk detected as writable and under warn threshold\n+         * This will be notified on disk detected as writable and under warn threshold.\n          *\n-         * @param disk\n-         *          Writable disk\n+         * @param disk Writable disk\n          */\n         void diskWritable(File disk);\n \n         /**\n-         * This will be notified on disk detected as writable but still in warn threshold\n+         * This will be notified on disk detected as writable but still in warn threshold.\n          *\n-         * @param disk\n-         *          Writable disk\n+         * @param disk Writable disk\n          */\n         void diskJustWritable(File disk);\n "},{"sha":"390773ef60c0a8a58543246bc8c2b9579b515d9d","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDirsMonitor.java","status":"modified","additions":6,"deletions":7,"changes":13,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLedgerDirsMonitor.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLedgerDirsMonitor.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLedgerDirsMonitor.java?ref=086537beda9427c057a286ad6c4614659da6ed7f","patch":"@@ -41,17 +41,16 @@\n  * Thread to monitor the disk space periodically.\n  */\n class LedgerDirsMonitor extends BookieThread {\n-    private final static Logger LOG = LoggerFactory.getLogger(LedgerDirsMonitor.class);\n-    \n+    private static final Logger LOG = LoggerFactory.getLogger(LedgerDirsMonitor.class);\n+\n     private final int interval;\n     private final ServerConfiguration conf;\n     private final ConcurrentMap<File, Float> diskUsages;\n     private final DiskChecker diskChecker;\n     private final LedgerDirsManager ldm;\n \n-    public LedgerDirsMonitor(final ServerConfiguration conf, \n-            final DiskChecker diskChecker,\n-            final LedgerDirsManager ldm) {\n+    public LedgerDirsMonitor(final ServerConfiguration conf, final DiskChecker diskChecker,\n+                             final LedgerDirsManager ldm) {\n         super(\"LedgerDirsMonitorThread\");\n         this.interval = conf.getDiskCheckInterval();\n         this.conf = conf;\n@@ -90,8 +89,8 @@ public void run() {\n                 }\n                 // Let's get NoWritableLedgerDirException without waiting for the next iteration\n                 // in case we are out of writable dirs\n-                // otherwise for the duration of {interval} we end up in the state where \n-                // bookie cannot get writable dir but considered to be writable \n+                // otherwise for the duration of {interval} we end up in the state where\n+                // bookie cannot get writable dir but considered to be writable\n                 ldm.getWritableLedgerDirs();\n             } catch (NoWritableLedgerDirException e) {\n                 for (LedgerDirsListener listener : ldm.getListeners()) {"},{"sha":"333bdfc007c98787fcbf35ad693fc8151378bb30","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerEntryPage.java","status":"modified","additions":9,"deletions":9,"changes":18,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLedgerEntryPage.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLedgerEntryPage.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLedgerEntryPage.java?ref=086537beda9427c057a286ad6c4614659da6ed7f","patch":"@@ -37,15 +37,15 @@ public class LedgerEntryPage {\n \n     private static final Logger LOG = LoggerFactory.getLogger(LedgerEntryPage.class);\n \n-    private final static int indexEntrySize = 8;\n+    private static final int indexEntrySize = 8;\n     private final int pageSize;\n     private final int entriesPerPage;\n-    volatile private EntryKey entryKey = new EntryKey(-1, BookieProtocol.INVALID_ENTRY_ID);\n+    private volatile EntryKey entryKey = new EntryKey(-1, BookieProtocol.INVALID_ENTRY_ID);\n     private final ByteBuffer page;\n-    volatile private boolean clean = true;\n+    private volatile boolean clean = true;\n     private final AtomicInteger useCount = new AtomicInteger(0);\n     private final AtomicInteger version = new AtomicInteger(0);\n-    volatile private int last = -1; // Last update position\n+    private volatile int last = -1; // Last update position\n     private final LEPStateChangeCallback callback;\n \n     public static int getIndexEntrySize() {\n@@ -135,7 +135,7 @@ public boolean equals(Object other) {\n \n     @Override\n     public int hashCode() {\n-        return (int)getLedger() ^ (int)(getFirstEntry());\n+        return (int) getLedger() ^ (int) (getFirstEntry());\n     }\n \n     void setClean(int versionOfCleaning) {\n@@ -154,8 +154,8 @@ public void setOffset(long offset, int position) {\n         checkPage();\n         page.putLong(position, offset);\n         version.incrementAndGet();\n-        if (last < position/getIndexEntrySize()) {\n-            last = position/getIndexEntrySize();\n+        if (last < position / getIndexEntrySize()) {\n+            last = position / getIndexEntrySize();\n         }\n         this.clean = false;\n \n@@ -245,8 +245,8 @@ public boolean inUse() {\n     }\n \n     private int getLastEntryIndex() {\n-        for(int i = entriesPerPage - 1; i >= 0; i--) {\n-            if (getOffset(i*getIndexEntrySize()) > 0) {\n+        for (int i = entriesPerPage - 1; i >= 0; i--) {\n+            if (getOffset(i * getIndexEntrySize()) > 0) {\n                 return i;\n             }\n         }"},{"sha":"b142c2ba378e23431e807fa260de8e8030d7902f","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerStorage.java","status":"modified","additions":22,"deletions":27,"changes":49,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLedgerStorage.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLedgerStorage.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLedgerStorage.java?ref=086537beda9427c057a286ad6c4614659da6ed7f","patch":"@@ -37,81 +37,76 @@\n public interface LedgerStorage {\n \n     /**\n-     * Initialize the LedgerStorage implementation\n+     * Initialize the LedgerStorage implementation.\n      *\n      * @param conf\n      * @param ledgerManager\n      * @param ledgerDirsManager\n      */\n-    public void initialize(ServerConfiguration conf, LedgerManager ledgerManager,\n-                           LedgerDirsManager ledgerDirsManager, LedgerDirsManager indexDirsManager,\n-                           CheckpointSource checkpointSource, StatsLogger statsLogger)\n+    void initialize(ServerConfiguration conf, LedgerManager ledgerManager, LedgerDirsManager ledgerDirsManager,\n+                    LedgerDirsManager indexDirsManager, CheckpointSource checkpointSource, StatsLogger statsLogger)\n             throws IOException;\n \n     /**\n-     * Start any background threads\n-     * belonging to the storage system. For example,\n-     * garbage collection.\n+     * Start any background threads belonging to the storage system. For example, garbage collection.\n      */\n     void start();\n \n     /**\n-     * Cleanup and free any resources\n-     * being used by the storage system.\n+     * Cleanup and free any resources being used by the storage system.\n      */\n     void shutdown() throws InterruptedException;\n \n     /**\n-     * Whether a ledger exists\n+     * Whether a ledger exists.\n      */\n     boolean ledgerExists(long ledgerId) throws IOException;\n \n     /**\n      * Fenced the ledger id in ledger storage.\n      *\n-     * @param ledgerId\n-     *          Ledger Id.\n+     * @param ledgerId Ledger Id.\n      * @throws IOException when failed to fence the ledger.\n      */\n     boolean setFenced(long ledgerId) throws IOException;\n \n     /**\n      * Check whether the ledger is fenced in ledger storage or not.\n      *\n-     * @param ledgerId\n-     *          Ledger ID.\n+     * @param ledgerId Ledger ID.\n      * @throws IOException\n      */\n     boolean isFenced(long ledgerId) throws IOException;\n \n     /**\n-     * Set the master key for a ledger\n+     * Set the master key for a ledger.\n      */\n     void setMasterKey(long ledgerId, byte[] masterKey) throws IOException;\n \n     /**\n-     * Get the master key for a ledger\n+     * Get the master key for a ledger.\n+     *\n      * @throws IOException if there is an error reading the from the ledger\n      * @throws BookieException if no such ledger exists\n      */\n     byte[] readMasterKey(long ledgerId) throws IOException, BookieException;\n \n     /**\n      * Add an entry to the storage.\n+     *\n      * @return the entry id of the entry added\n      */\n     long addEntry(ByteBuf entry) throws IOException;\n \n     /**\n-     * Read an entry from storage\n+     * Read an entry from storage.\n      */\n     ByteBuf getEntry(long ledgerId, long entryId) throws IOException;\n \n     /**\n      * Get last add confirmed.\n      *\n-     * @param ledgerId\n-     *          ledger id.\n+     * @param ledgerId ledger id.\n      * @return last add confirmed.\n      * @throws IOException\n      */\n@@ -140,29 +135,29 @@ public void initialize(ServerConfiguration conf, LedgerManager ledgerManager,\n      * that it finished. The returned the checkpoint indicates that all entries added\n      * before that point already persist.\n      *\n-     * @param checkpoint\n-     *          Check Point that {@link Checkpoint} proposed.\n+     * @param checkpoint Check Point that {@link Checkpoint} proposed.\n      * @throws IOException\n      * @return the checkpoint that the ledger storage finished.\n      */\n     Checkpoint checkpoint(Checkpoint checkpoint) throws IOException;\n \n-    /*\n-     *\n+    /**\n      * @param ledgerId\n      * @throws IOException\n      */\n     void deleteLedger(long ledgerId) throws IOException;\n \n-    public static interface LedgerDeletionListener {\n+    /**\n+     * @TODO: Write JavaDoc comment {@link https://github.com/apache/bookkepeer/issues/247}\n+     */\n+    interface LedgerDeletionListener {\n         void ledgerDeleted(long ledgerId);\n     }\n \n     /**\n-     * Register a listener for ledgers deletion notifications\n+     * Register a listener for ledgers deletion notifications.\n      *\n-     * @param listener\n-     *            object that will be notified every time a ledger is deleted\n+     * @param listener object that will be notified every time a ledger is deleted\n      */\n     void registerLedgerDeletionListener(LedgerDeletionListener listener);\n "},{"sha":"6ff0ed21bb326a8618555e64871aa39fc173479b","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerStorageFactory.java","status":"modified","additions":3,"deletions":0,"changes":3,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLedgerStorageFactory.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLedgerStorageFactory.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLedgerStorageFactory.java?ref=086537beda9427c057a286ad6c4614659da6ed7f","patch":"@@ -24,6 +24,9 @@\n \n import org.apache.bookkeeper.util.ReflectionUtils;\n \n+/**\n+ * @TODO: Write JavaDoc comment {@link https://github.com/apache/bookkepeer/issues/247}\n+ */\n public class LedgerStorageFactory {\n     public static LedgerStorage createLedgerStorage(String name) throws IOException {\n         try {"},{"sha":"d74e7cd5aff8ffd3023f8b692786fb9b3f4cad5b","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LocalBookieEnsemblePlacementPolicy.java","status":"modified","additions":18,"deletions":7,"changes":25,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLocalBookieEnsemblePlacementPolicy.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLocalBookieEnsemblePlacementPolicy.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLocalBookieEnsemblePlacementPolicy.java?ref=086537beda9427c057a286ad6c4614659da6ed7f","patch":"@@ -20,7 +20,12 @@\n import com.google.common.base.Optional;\n \n import java.net.UnknownHostException;\n-import java.util.*;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n \n import org.apache.bookkeeper.client.BookieInfoReader.BookieInfo;\n import org.apache.bookkeeper.client.EnsemblePlacementPolicy;\n@@ -36,7 +41,6 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-\n import io.netty.util.HashedWheelTimer;\n \n /**\n@@ -49,7 +53,10 @@ public class LocalBookieEnsemblePlacementPolicy implements EnsemblePlacementPoli\n     private BookieSocketAddress bookieAddress;\n \n     @Override\n-    public EnsemblePlacementPolicy initialize(ClientConfiguration conf, Optional<DNSToSwitchMapping> optionalDnsResolver, HashedWheelTimer hashedWheelTimer, FeatureProvider featureProvider, StatsLogger statsLogger) {\n+    public EnsemblePlacementPolicy initialize(ClientConfiguration conf,\n+                                              Optional<DNSToSwitchMapping> optionalDnsResolver,\n+                                              HashedWheelTimer hashedWheelTimer,\n+                                              FeatureProvider featureProvider, StatsLogger statsLogger) {\n         // Configuration will have already the bookie configuration inserted\n         ServerConfiguration serverConf = new ServerConfiguration();\n         serverConf.addConfiguration(conf);\n@@ -77,23 +84,27 @@ public Set<BookieSocketAddress> onClusterChanged(Set<BookieSocketAddress> writab\n     @Override\n     public BookieSocketAddress replaceBookie(int ensembleSize, int writeQuorumSize, int ackQuorumSize,\n         java.util.Map<String, byte[]> customMetadata, Collection<BookieSocketAddress> currentEnsemble,\n-        BookieSocketAddress bookieToReplace, Set<BookieSocketAddress> excludeBookies) throws BKNotEnoughBookiesException {\n+        BookieSocketAddress bookieToReplace, Set<BookieSocketAddress> excludeBookies)\n+            throws BKNotEnoughBookiesException {\n         throw new BKNotEnoughBookiesException();\n     }\n \n     @Override\n-    public List<Integer> reorderReadSequence(ArrayList<BookieSocketAddress> ensemble, List<Integer> writeSet, Map<BookieSocketAddress, Long> bookieFailureHistory) {\n+    public List<Integer> reorderReadSequence(ArrayList<BookieSocketAddress> ensemble, List<Integer> writeSet,\n+                                             Map<BookieSocketAddress, Long> bookieFailureHistory) {\n         return null;\n     }\n \n     @Override\n-    public List<Integer> reorderReadLACSequence(ArrayList<BookieSocketAddress> ensemble, List<Integer> writeSet, Map<BookieSocketAddress, Long> bookieFailureHistory) {\n+    public List<Integer> reorderReadLACSequence(ArrayList<BookieSocketAddress> ensemble, List<Integer> writeSet,\n+                                                Map<BookieSocketAddress, Long> bookieFailureHistory) {\n         return null;\n     }\n \n     @Override\n     public ArrayList<BookieSocketAddress> newEnsemble(int ensembleSize, int writeQuorumSize, int ackQuorumSize,\n-        java.util.Map<String, byte[]> customMetadata, Set<BookieSocketAddress> excludeBookies) throws BKNotEnoughBookiesException {\n+        java.util.Map<String, byte[]> customMetadata, Set<BookieSocketAddress> excludeBookies)\n+            throws BKNotEnoughBookiesException {\n         if (ensembleSize > 1) {\n             throw new IllegalArgumentException(\"Local ensemble policy can only return 1 bookie\");\n         }"},{"sha":"adae5b285bd7ee02d00435fdf085f71e6b2d5cbf","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LogMark.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLogMark.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLogMark.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLogMark.java?ref=086537beda9427c057a286ad6c4614659da6ed7f","patch":"@@ -22,7 +22,7 @@\n import java.nio.ByteBuffer;\n \n /**\n- * Journal stream position\n+ * Journal stream position.\n  */\n class LogMark {\n     long logFileId;\n@@ -70,7 +70,7 @@ public synchronized int compare(LogMark other) {\n         if (ret == 0) {\n             ret = this.logFileOffset - other.getLogFileOffset();\n         }\n-        return (ret < 0)? -1 : ((ret > 0)? 1 : 0);\n+        return (ret < 0) ? -1 : ((ret > 0) ? 1 : 0);\n     }\n \n     @Override"},{"sha":"786508ef1fa2b1867b05b874a3e647b083b193b0","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/MarkerFileChannel.java","status":"modified","additions":1,"deletions":2,"changes":3,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FMarkerFileChannel.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FMarkerFileChannel.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FMarkerFileChannel.java?ref=086537beda9427c057a286ad6c4614659da6ed7f","patch":"@@ -30,8 +30,7 @@\n import java.nio.channels.WritableByteChannel;\n \n /**\n- * This class is just a stub that can be used in collections with\n- * FileChannels\n+ * This class is just a stub that can be used in collections with FileChannels.\n  */\n public class MarkerFileChannel extends FileChannel {\n "},{"sha":"75361209af6e458279bb6c0f0587877249217cfb","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/ReadOnlyBookie.java","status":"modified","additions":3,"deletions":3,"changes":6,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FReadOnlyBookie.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FReadOnlyBookie.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FReadOnlyBookie.java?ref=086537beda9427c057a286ad6c4614659da6ed7f","patch":"@@ -31,13 +31,13 @@\n \n /**\n  * Implements a read only bookie.\n- * \n+ * <p>\n  * ReadOnlyBookie is force started as readonly, and will not change to writable.\n- *\n+ * </p>\n  */\n public class ReadOnlyBookie extends Bookie {\n \n-    private final static Logger LOG = LoggerFactory.getLogger(ReadOnlyBookie.class);\n+    private static final Logger LOG = LoggerFactory.getLogger(ReadOnlyBookie.class);\n \n     public ReadOnlyBookie(ServerConfiguration conf, StatsLogger statsLogger)\n             throws IOException, KeeperException, InterruptedException, BookieException {"},{"sha":"d661412be362f83d5ab3abf89daf730af0263eb1","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/ReadOnlyEntryLogger.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FReadOnlyEntryLogger.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FReadOnlyEntryLogger.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FReadOnlyEntryLogger.java?ref=086537beda9427c057a286ad6c4614659da6ed7f","patch":"@@ -28,7 +28,7 @@\n import org.apache.bookkeeper.util.DiskChecker;\n \n /**\n- * Read Only Entry Logger\n+ * Read Only Entry Logger.\n  */\n public class ReadOnlyEntryLogger extends EntryLogger {\n "},{"sha":"8b87d0aea01746352caa5a78ecf4af1db44c33aa","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/ScanAndCompareGarbageCollector.java","status":"modified","additions":5,"deletions":3,"changes":8,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FScanAndCompareGarbageCollector.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FScanAndCompareGarbageCollector.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FScanAndCompareGarbageCollector.java?ref=086537beda9427c057a286ad6c4614659da6ed7f","patch":"@@ -99,7 +99,8 @@ public ScanAndCompareGarbageCollector(LedgerManager ledgerManager, CompactableLe\n     public void gc(GarbageCleaner garbageCleaner) {\n         try {\n             // Get a set of all ledgers on the bookie\n-            NavigableSet<Long> bkActiveLedgers = Sets.newTreeSet(ledgerStorage.getActiveLedgersInRange(0, Long.MAX_VALUE));\n+            NavigableSet<Long> bkActiveLedgers = Sets.newTreeSet(ledgerStorage.getActiveLedgersInRange(0,\n+                    Long.MAX_VALUE));\n \n             // Iterate over all the ledger on the metadata store\n             LedgerRangeIterator ledgerRangeIterator = ledgerManager.getLedgerRanges();\n@@ -129,7 +130,7 @@ public void gc(GarbageCleaner garbageCleaner) {\n                 lastOverReplicatedLedgerGcTimeMillis = MathUtils.now();\n             }\n \n-            while(ledgerRangeIterator.hasNext()) {\n+            while (ledgerRangeIterator.hasNext()) {\n                 LedgerRange lRange = ledgerRangeIterator.next();\n \n                 Long start = lastEnd + 1;\n@@ -182,7 +183,8 @@ private Set<Long> removeOverReplicatedledgers(Set<Long> bkActiveledgers, final G\n                 // we try to acquire the underreplicated ledger lock to not let the bookie replicate the ledger that is\n                 // already being checked for deletion, since that might change the ledger ensemble to include the\n                 // current bookie again and, in that case, we cannot remove the ledger from local storage\n-                ZkLedgerUnderreplicationManager.acquireUnderreplicatedLedgerLock(zk, zkLedgersRootPath, ledgerId, zkAcls);\n+                ZkLedgerUnderreplicationManager.acquireUnderreplicatedLedgerLock(zk, zkLedgersRootPath, ledgerId,\n+                        zkAcls);\n                 semaphore.acquire();\n                 ledgerManager.readLedgerMetadata(ledgerId, new GenericCallback<LedgerMetadata>() {\n "},{"sha":"7eafb41687eeae232ec35263d681dd0ca06f43db","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/SkipListArena.java","status":"modified","additions":14,"deletions":13,"changes":27,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FSkipListArena.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FSkipListArena.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FSkipListArena.java?ref=086537beda9427c057a286ad6c4614659da6ed7f","patch":"@@ -32,16 +32,18 @@\n  * The SkipListArena is basically a bump-the-pointer allocator that allocates\n  * big (default 2MB) byte[] chunks from and then handles it out to threads that\n  * request slices into the array.\n+ * </p>\n  * <p>\n  * The purpose of this class is to combat heap fragmentation in the\n  * bookie. By ensuring that all KeyValues in a given SkipList refer\n  * only to large chunks of contiguous memory, we ensure that large blocks\n  * get freed up when the SkipList is flushed.\n+ * </p>\n  * <p>\n  * Without the Arena, the byte array allocated during insertion end up\n  * interleaved throughout the heap, and the old generation gets progressively\n  * more fragmented until a stop-the-world compacting collection occurs.\n- * <p>\n+ * </p>\n  */\n public class SkipListArena {\n     private AtomicReference<Chunk> curChunk = new AtomicReference<Chunk>();\n@@ -57,11 +59,11 @@ public SkipListArena(ServerConfiguration cfg) {\n     }\n \n     /**\n-    * Allocate a slice of the given length.\n-    *\n-    * If the size is larger than the maximum size specified for this\n-    * allocator, returns null.\n-    */\n+     * Allocate a slice of the given length.\n+     * <p>\n+     * If the size is larger than the maximum size specified for this allocator, returns null.\n+     * </p>\n+     */\n     public MemorySlice allocateBytes(int size) {\n         assert size >= 0;\n \n@@ -125,21 +127,21 @@ private Chunk getCurrentChunk() {\n     * A chunk of memory out of which allocations are sliced.\n     */\n     private static class Chunk {\n-        /** Actual underlying data */\n+        /** Actual underlying data. */\n         private byte[] data;\n \n         private static final int UNINITIALIZED = -1;\n         private static final int OOM = -2;\n         /**\n          * Offset for the next allocation, or the sentinel value -1\n          * which implies that the chunk is still uninitialized.\n-         * */\n+         */\n         private AtomicInteger nextFreeOffset = new AtomicInteger(UNINITIALIZED);\n \n-        /** Total number of allocations satisfied from this buffer */\n+        /** Total number of allocations satisfied from this buffer. */\n         private AtomicInteger allocCount = new AtomicInteger();\n \n-        /** Size of chunk in bytes */\n+        /** Size of chunk in bytes. */\n         private final int size;\n \n         /**\n@@ -202,9 +204,8 @@ public int alloc(int size) {\n \n         @Override\n         public String toString() {\n-            return \"Chunk@\" + System.identityHashCode(this) +\n-                \": used(\" + allocCount.get() + \"), free(\" +\n-                (data.length - nextFreeOffset.get() + \")\");\n+            return \"Chunk@\" + System.identityHashCode(this) + \": used(\" + allocCount.get() + \"), free(\"\n+                    + (data.length - nextFreeOffset.get() + \")\");\n         }\n     }\n "},{"sha":"96fbbe1fdb24381859566486ae8d37e2a7a2c9a0","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/SkipListFlusher.java","status":"modified","additions":5,"deletions":8,"changes":13,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FSkipListFlusher.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FSkipListFlusher.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FSkipListFlusher.java?ref=086537beda9427c057a286ad6c4614659da6ed7f","patch":"@@ -25,19 +25,16 @@\n import java.nio.ByteBuffer;\n \n /**\n- * Flush entries from skip list\n+ * Flush entries from skip list.\n  */\n public interface SkipListFlusher {\n     /**\n      * Process an entry.\n      *\n-     * @param ledgerId\n-     *          Ledger ID.\n-     * @param entryId\n-     *          The entry id this entry.\n-     * @param entry\n-     *          Entry ByteBuffer\n+     * @param ledgerId Ledger ID.\n+     * @param entryId The entry id this entry.\n+     * @param entry Entry ByteBuffer\n      * @throws IOException\n      */\n-    public void process(long ledgerId, long entryId, ByteBuffer entry) throws IOException;\n+    void process(long ledgerId, long entryId, ByteBuffer entry) throws IOException;\n }"},{"sha":"ff2aa4293e8f410b9d54e4e068d28161b78ff947","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/SortedLedgerStorage.java","status":"modified","additions":5,"deletions":2,"changes":7,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FSortedLedgerStorage.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FSortedLedgerStorage.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FSortedLedgerStorage.java?ref=086537beda9427c057a286ad6c4614659da6ed7f","patch":"@@ -38,9 +38,12 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+/**\n+ * @TODO: Write JavaDoc comment {@link https://github.com/apache/bookkepeer/issues/247}\n+ */\n public class SortedLedgerStorage extends InterleavedLedgerStorage\n         implements LedgerStorage, CacheCallback, SkipListFlusher {\n-    private final static Logger LOG = LoggerFactory.getLogger(SortedLedgerStorage.class);\n+    private static final Logger LOG = LoggerFactory.getLogger(SortedLedgerStorage.class);\n \n     EntryMemTable memTable;\n     private ScheduledExecutorService scheduler;\n@@ -59,7 +62,7 @@ public void initialize(ServerConfiguration conf, LedgerManager ledgerManager,\n         this.scheduler = Executors.newSingleThreadScheduledExecutor(\n                 new ThreadFactoryBuilder()\n                 .setNameFormat(\"SortedLedgerStorage-%d\")\n-                .setPriority((Thread.NORM_PRIORITY + Thread.MAX_PRIORITY)/2).build());\n+                .setPriority((Thread.NORM_PRIORITY + Thread.MAX_PRIORITY) / 2).build());\n     }\n \n     @Override"},{"sha":"5eb15df3704bab72a83f849614bdf7126d09b961","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/SyncThread.java","status":"modified","additions":3,"deletions":3,"changes":6,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FSyncThread.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FSyncThread.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FSyncThread.java?ref=086537beda9427c057a286ad6c4614659da6ed7f","patch":"@@ -55,7 +55,7 @@\n  * </p>\n  */\n class SyncThread {\n-    private final static Logger LOG = LoggerFactory.getLogger(SyncThread.class);\n+    private static final Logger LOG = LoggerFactory.getLogger(SyncThread.class);\n \n     final ScheduledExecutorService executor;\n     final int flushInterval;\n@@ -152,7 +152,7 @@ public void checkpoint(Checkpoint checkpoint) {\n      */\n     @VisibleForTesting\n     public void suspendSync() {\n-        synchronized(suspensionLock) {\n+        synchronized (suspensionLock) {\n             suspended = true;\n         }\n     }\n@@ -162,7 +162,7 @@ public void suspendSync() {\n      */\n     @VisibleForTesting\n     public void resumeSync() {\n-        synchronized(suspensionLock) {\n+        synchronized (suspensionLock) {\n             suspended = false;\n             suspensionLock.notify();\n         }"},{"sha":"a44adb56066a09d382f95f587ad3c6ff185b817f","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/package-info.java","status":"added","additions":22,"deletions":0,"changes":22,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2Fpackage-info.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2Fpackage-info.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2Fpackage-info.java?ref=086537beda9427c057a286ad6c4614659da6ed7f","patch":"@@ -0,0 +1,22 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+/**\n+ * @TODO: Write JavaDoc comment {@link https://github.com/apache/bookkepeer/issues/247}\n+ */\n+package org.apache.bookkeeper.bookie;\n\\ No newline at end of file"},{"sha":"9fd739fa8f38864d21285b9a88aab57d77406b23","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/AuthHandler.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FAuthHandler.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FAuthHandler.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FAuthHandler.java?ref=086537beda9427c057a286ad6c4614659da6ed7f","patch":"@@ -278,7 +278,7 @@ public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception\n                     } else {\n                         assert (resp.hasAuthResponse());\n                         BookkeeperProtocol.AuthMessage am = resp.getAuthResponse();\n-                        if (AuthProviderFactoryFactory.authenticationDisabledPluginName.equals(am.getAuthPluginName())){\n+                        if (AuthProviderFactoryFactory.AUTHENTICATION_DISABLED_PLUGIN_NAME.equals(am.getAuthPluginName())){\n                             SocketAddress remote  = ctx.channel().remoteAddress();\n                             LOG.info(\"Authentication is not enabled.\"\n                                 + \"Considering this client {0} authenticated\", remote);"},{"sha":"90a0524533ed29fe978b3626214058543209a1bb","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieRequestProcessor.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookieRequestProcessor.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/086537beda9427c057a286ad6c4614659da6ed7f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookieRequestProcessor.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookieRequestProcessor.java?ref=086537beda9427c057a286ad6c4614659da6ed7f","patch":"@@ -196,7 +196,7 @@ public void processRequest(Object msg, Channel c) {\n                     LOG.info(\"Ignoring auth operation from client {}\",c.remoteAddress());\n                     BookkeeperProtocol.AuthMessage message = BookkeeperProtocol.AuthMessage\n                         .newBuilder()\n-                        .setAuthPluginName(AuthProviderFactoryFactory.authenticationDisabledPluginName)\n+                        .setAuthPluginName(AuthProviderFactoryFactory.AUTHENTICATION_DISABLED_PLUGIN_NAME)\n                         .setPayload(ByteString.copyFrom(AuthToken.NULL.getData()))\n                         .build();\n                     BookkeeperProtocol.Response.Builder authResponse ="}]}