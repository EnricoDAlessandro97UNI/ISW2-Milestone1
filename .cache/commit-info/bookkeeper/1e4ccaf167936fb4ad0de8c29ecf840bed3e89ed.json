{"sha":"1e4ccaf167936fb4ad0de8c29ecf840bed3e89ed","node_id":"MDY6Q29tbWl0NDc4NTkyNTI2OjFlNGNjYWYxNjc5MzZmYjRhZDBkZThjMjllY2Y4NDBiZWQzZTg5ZWQ=","commit":{"author":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2017-03-23T14:59:01Z"},"committer":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2017-03-23T14:59:01Z"},"message":"BOOKKEEPER-970: Bump the zookeeper version to 3.5\n\nin DL, we need to leverage the asynchronous version of 'multi' in zookeeper. so this jira is to bump the zookeeper version to 3.5 to support async multi.\n\nAuthor: Sijie Guo <sijie@apache.org>\n\nReviewers: Enrico Olivelli <eolivelli@gmail.com>\n\nCloses #79 from sijie/sijie/bump_zookeeper_version","tree":{"sha":"ff9a6e3df1a012d7e21d2c244b1f481365dfadc9","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/trees/ff9a6e3df1a012d7e21d2c244b1f481365dfadc9"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/commits/1e4ccaf167936fb4ad0de8c29ecf840bed3e89ed","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/1e4ccaf167936fb4ad0de8c29ecf840bed3e89ed","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/1e4ccaf167936fb4ad0de8c29ecf840bed3e89ed","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/1e4ccaf167936fb4ad0de8c29ecf840bed3e89ed/comments","author":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"committer":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"parents":[{"sha":"986110c4d03a38db81c166216cf4db81a9cb5cb7","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/986110c4d03a38db81c166216cf4db81a9cb5cb7","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/986110c4d03a38db81c166216cf4db81a9cb5cb7"}],"stats":{"total":332,"additions":299,"deletions":33},"files":[{"sha":"dac28b030945a6baf610bff6fbe89d06450e6938","filename":"bookkeeper-benchmark/pom.xml","status":"modified","additions":6,"deletions":0,"changes":6,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/1e4ccaf167936fb4ad0de8c29ecf840bed3e89ed/bookkeeper-benchmark%2Fpom.xml","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/1e4ccaf167936fb4ad0de8c29ecf840bed3e89ed/bookkeeper-benchmark%2Fpom.xml","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-benchmark%2Fpom.xml?ref=1e4ccaf167936fb4ad0de8c29ecf840bed3e89ed","patch":"@@ -74,6 +74,12 @@\n       <version>${zookeeper.version}</version>\n       <type>jar</type>\n       <scope>compile</scope>\n+      <exclusions>\n+        <exclusion>\n+          <groupId>net.java.dev.javacc</groupId>\n+          <artifactId>javacc</artifactId>\n+        </exclusion>\n+      </exclusions>\n     </dependency>\n     <dependency>\n       <groupId>org.apache.zookeeper</groupId>"},{"sha":"cc13e5930d66d941a46c8b85af615c0c5d7c07ea","filename":"bookkeeper-server/pom.xml","status":"modified","additions":6,"deletions":0,"changes":6,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/1e4ccaf167936fb4ad0de8c29ecf840bed3e89ed/bookkeeper-server%2Fpom.xml","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/1e4ccaf167936fb4ad0de8c29ecf840bed3e89ed/bookkeeper-server%2Fpom.xml","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fpom.xml?ref=1e4ccaf167936fb4ad0de8c29ecf840bed3e89ed","patch":"@@ -69,6 +69,12 @@\n       <artifactId>zookeeper</artifactId>\n       <version>${zookeeper.version}</version>\n       <scope>compile</scope>\n+      <exclusions>\n+        <exclusion>\n+          <groupId>net.java.dev.javacc</groupId>\n+          <artifactId>javacc</artifactId>\n+        </exclusion>\n+      </exclusions>\n     </dependency>\n     <dependency>\n       <groupId>org.apache.zookeeper</groupId>"},{"sha":"94df8da3f3c33103575aa6fc691a4a968aa317a0","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/zookeeper/ZooKeeperClient.java","status":"modified","additions":206,"deletions":29,"changes":235,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/1e4ccaf167936fb4ad0de8c29ecf840bed3e89ed/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fzookeeper%2FZooKeeperClient.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/1e4ccaf167936fb4ad0de8c29ecf840bed3e89ed/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fzookeeper%2FZooKeeperClient.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fzookeeper%2FZooKeeperClient.java?ref=1e4ccaf167936fb4ad0de8c29ecf840bed3e89ed","patch":"@@ -29,6 +29,7 @@\n import java.util.concurrent.RejectedExecutionException;\n import java.util.concurrent.ScheduledExecutorService;\n import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicReference;\n \n import com.google.common.annotations.VisibleForTesting;\n@@ -41,9 +42,11 @@\n import org.apache.bookkeeper.stats.StatsLogger;\n import org.apache.bookkeeper.zookeeper.ZooWorker.ZooCallable;\n import org.apache.zookeeper.AsyncCallback.ACLCallback;\n+import org.apache.zookeeper.AsyncCallback.Create2Callback;\n import org.apache.zookeeper.AsyncCallback.Children2Callback;\n import org.apache.zookeeper.AsyncCallback.ChildrenCallback;\n import org.apache.zookeeper.AsyncCallback.DataCallback;\n+import org.apache.zookeeper.AsyncCallback.MultiCallback;\n import org.apache.zookeeper.AsyncCallback.StatCallback;\n import org.apache.zookeeper.AsyncCallback.StringCallback;\n import org.apache.zookeeper.AsyncCallback.VoidCallback;\n@@ -77,6 +80,7 @@ public class ZooKeeperClient extends ZooKeeper implements Watcher {\n \n     // state for the zookeeper client\n     private final AtomicReference<ZooKeeper> zk = new AtomicReference<ZooKeeper>();\n+    private final AtomicBoolean closed = new AtomicBoolean(false);\n     private final ZooKeeperWatcherBase watcherManager;\n \n     private final ScheduledExecutorService retryExecutor;\n@@ -297,6 +301,7 @@ public static Builder newBuilder() {\n \n     @Override\n     public void close() throws InterruptedException {\n+        closed.set(true);\n         connectExecutor.shutdown();\n         retryExecutor.shutdown();\n         closeZkHandle();\n@@ -328,12 +333,19 @@ public void process(WatchedEvent event) {\n     }\n \n     private void onExpired() {\n+        if (closed.get()) {\n+            // we don't schedule any tries if the client is closed.\n+            return;\n+        }\n+\n         logger.info(\"ZooKeeper session {} is expired from {}.\",\n                 Long.toHexString(getSessionId()), connectString);\n         try {\n             connectExecutor.submit(clientCreator);\n         } catch (RejectedExecutionException ree) {\n-            logger.error(\"ZooKeeper reconnect task is rejected : \", ree);\n+            if (!closed.get()) {\n+                logger.error(\"ZooKeeper reconnect task is rejected : \", ree);\n+            }\n         } catch (Exception t) {\n             logger.error(\"Failed to submit zookeeper reconnect task due to runtime exception : \", t);\n         }\n@@ -403,6 +415,20 @@ public void addAuthInfo(String scheme, byte[] auth) {\n         zkHandle.addAuthInfo(scheme, auth);\n     }\n \n+    private void backOffAndRetry(Runnable r, long nextRetryWaitTimeMs) {\n+        try {\n+            retryExecutor.schedule(r, nextRetryWaitTimeMs, TimeUnit.MILLISECONDS);\n+        } catch (RejectedExecutionException ree) {\n+            if (!closed.get()) {\n+                logger.error(\"ZooKeeper Operation {} is rejected : \", r, ree);\n+            }\n+        }\n+    }\n+\n+    private boolean allowRetry(ZooWorker worker, int rc) {\n+        return worker.allowRetry(rc) && !closed.get();\n+    }\n+\n     @Override\n     public synchronized void register(Watcher watcher) {\n         watcherManager.addChildWatcher(watcher);\n@@ -430,6 +456,46 @@ public List<OpResult> call() throws KeeperException, InterruptedException {\n     }\n \n     @Override\n+    public void multi(final Iterable<Op> ops,\n+                      final MultiCallback cb,\n+                      final Object context) {\n+        final Runnable proc = new ZkRetryRunnable(operationRetryPolicy, rateLimiter, createStats) {\n+\n+            final MultiCallback multiCb = new MultiCallback() {\n+\n+                @Override\n+                public void processResult(int rc, String path, Object ctx, List<OpResult> results) {\n+                    ZooWorker worker = (ZooWorker)ctx;\n+                    if (allowRetry(worker, rc)) {\n+                        backOffAndRetry(that, worker.nextRetryWaitTime());\n+                    } else {\n+                        cb.processResult(rc, path, context, results);\n+                    }\n+                }\n+\n+            };\n+\n+            @Override\n+            void zkRun() {\n+                ZooKeeper zkHandle = zk.get();\n+                if (null == zkHandle) {\n+                    ZooKeeperClient.super.multi(ops, multiCb, worker);\n+                } else {\n+                    zkHandle.multi(ops, multiCb, worker);\n+                }\n+            }\n+\n+            @Override\n+            public String toString() {\n+                return \"multi\";\n+            }\n+        };\n+        // execute it immediately\n+        proc.run();\n+    }\n+\n+    @Override\n+    @Deprecated\n     public Transaction transaction() {\n         // since there is no reference about which client that the transaction could use\n         // so just use ZooKeeper instance directly.\n@@ -471,8 +537,8 @@ public void getACL(final String path, final Stat stat, final ACLCallback cb, fin\n                 @Override\n                 public void processResult(int rc, String path, Object ctx, List<ACL> acl, Stat stat) {\n                     ZooWorker worker = (ZooWorker)ctx;\n-                    if (worker.allowRetry(rc)) {\n-                        retryExecutor.schedule(that, worker.nextRetryWaitTime(), TimeUnit.MILLISECONDS);\n+                    if (allowRetry(worker, rc)) {\n+                        backOffAndRetry(that, worker.nextRetryWaitTime());\n                     } else {\n                         cb.processResult(rc, path, context, acl, stat);\n                     }\n@@ -531,8 +597,8 @@ public void setACL(final String path, final List<ACL> acl, final int version,\n                 @Override\n                 public void processResult(int rc, String path, Object ctx, Stat stat) {\n                     ZooWorker worker = (ZooWorker)ctx;\n-                    if (worker.allowRetry(rc)) {\n-                        retryExecutor.schedule(that, worker.nextRetryWaitTime(), TimeUnit.MILLISECONDS);\n+                    if (allowRetry(worker, rc)) {\n+                        backOffAndRetry(that, worker.nextRetryWaitTime());\n                     } else {\n                         cb.processResult(rc, path, context, stat);\n                     }\n@@ -568,8 +634,8 @@ public void sync(final String path, final VoidCallback cb, final Object context)\n                 @Override\n                 public void processResult(int rc, String path, Object ctx) {\n                     ZooWorker worker = (ZooWorker)ctx;\n-                    if (worker.allowRetry(rc)) {\n-                        retryExecutor.schedule(that, worker.nextRetryWaitTime(), TimeUnit.MILLISECONDS);\n+                    if (allowRetry(worker, rc)) {\n+                        backOffAndRetry(that, worker.nextRetryWaitTime());\n                     } else {\n                         cb.processResult(rc, path, context);\n                     }\n@@ -649,8 +715,8 @@ public void create(final String path, final byte[] data, final List<ACL> acl,\n                 @Override\n                 public void processResult(int rc, String path, Object ctx, String name) {\n                     ZooWorker worker = (ZooWorker)ctx;\n-                    if (worker.allowRetry(rc)) {\n-                        retryExecutor.schedule(that, worker.nextRetryWaitTime(), TimeUnit.MILLISECONDS);\n+                    if (allowRetry(worker, rc)) {\n+                        backOffAndRetry(that, worker.nextRetryWaitTime());\n                     } else {\n                         cb.processResult(rc, path, context, name);\n                     }\n@@ -677,6 +743,74 @@ public String toString() {\n         proc.run();\n     }\n \n+    @Override\n+    public String create(final String path,\n+                         final byte[] data,\n+                         final List<ACL> acl,\n+                         final CreateMode createMode,\n+                         final Stat stat)\n+            throws KeeperException, InterruptedException {\n+        return ZooWorker.syncCallWithRetries(this, new ZooCallable<String>() {\n+\n+            @Override\n+            public String call() throws KeeperException, InterruptedException {\n+                ZooKeeper zkHandle = zk.get();\n+                if (null == zkHandle) {\n+                    return ZooKeeperClient.super.create(path, data, acl, createMode);\n+                }\n+                return zkHandle.create(path, data, acl, createMode);\n+            }\n+\n+            @Override\n+            public String toString() {\n+                return String.format(\"create (%s, acl = %s, mode = %s)\", path, acl, createMode);\n+            }\n+\n+        }, operationRetryPolicy, rateLimiter, createStats);\n+    }\n+\n+    @Override\n+    public void create(final String path,\n+                       final byte[] data,\n+                       final List<ACL> acl,\n+                       final CreateMode createMode,\n+                       final Create2Callback cb,\n+                       final Object context) {\n+        final Runnable proc = new ZkRetryRunnable(operationRetryPolicy, rateLimiter, createStats) {\n+\n+            final Create2Callback createCb = new Create2Callback() {\n+\n+                @Override\n+                public void processResult(int rc, String path, Object ctx, String name, Stat stat) {\n+                    ZooWorker worker = (ZooWorker)ctx;\n+                    if (allowRetry(worker, rc)) {\n+                        backOffAndRetry(that, worker.nextRetryWaitTime());\n+                    } else {\n+                        cb.processResult(rc, path, context, name, stat);\n+                    }\n+                }\n+\n+            };\n+\n+            @Override\n+            void zkRun() {\n+                ZooKeeper zkHandle = zk.get();\n+                if (null == zkHandle) {\n+                    ZooKeeperClient.super.create(path, data, acl, createMode, createCb, worker);\n+                } else {\n+                    zkHandle.create(path, data, acl, createMode, createCb, worker);\n+                }\n+            }\n+\n+            @Override\n+            public String toString() {\n+                return String.format(\"create (%s, acl = %s, mode = %s)\", path, acl, createMode);\n+            }\n+        };\n+        // execute it immediately\n+        proc.run();\n+    }\n+\n     @Override\n     public void delete(final String path, final int version) throws KeeperException, InterruptedException {\n         ZooWorker.syncCallWithRetries(this, new ZooCallable<Void>() {\n@@ -709,8 +843,8 @@ public void delete(final String path, final int version, final VoidCallback cb,\n                 @Override\n                 public void processResult(int rc, String path, Object ctx) {\n                     ZooWorker worker = (ZooWorker)ctx;\n-                    if (worker.allowRetry(rc)) {\n-                        retryExecutor.schedule(that, worker.nextRetryWaitTime(), TimeUnit.MILLISECONDS);\n+                    if (allowRetry(worker, rc)) {\n+                        backOffAndRetry(that, worker.nextRetryWaitTime());\n                     } else {\n                         cb.processResult(rc, path, context);\n                     }\n@@ -788,8 +922,8 @@ public void exists(final String path, final Watcher watcher, final StatCallback\n                 @Override\n                 public void processResult(int rc, String path, Object ctx, Stat stat) {\n                     ZooWorker worker = (ZooWorker)ctx;\n-                    if (worker.allowRetry(rc)) {\n-                        retryExecutor.schedule(that, worker.nextRetryWaitTime(), TimeUnit.MILLISECONDS);\n+                    if (allowRetry(worker, rc)) {\n+                        backOffAndRetry(that, worker.nextRetryWaitTime());\n                     } else {\n                         cb.processResult(rc, path, context, stat);\n                     }\n@@ -825,8 +959,8 @@ public void exists(final String path, final boolean watch, final StatCallback cb\n                 @Override\n                 public void processResult(int rc, String path, Object ctx, Stat stat) {\n                     ZooWorker worker = (ZooWorker)ctx;\n-                    if (worker.allowRetry(rc)) {\n-                        retryExecutor.schedule(that, worker.nextRetryWaitTime(), TimeUnit.MILLISECONDS);\n+                    if (allowRetry(worker, rc)) {\n+                        backOffAndRetry(that, worker.nextRetryWaitTime());\n                     } else {\n                         cb.processResult(rc, path, context, stat);\n                     }\n@@ -906,8 +1040,8 @@ public void getData(final String path, final Watcher watcher, final DataCallback\n                 @Override\n                 public void processResult(int rc, String path, Object ctx, byte[] data, Stat stat) {\n                     ZooWorker worker = (ZooWorker)ctx;\n-                    if (worker.allowRetry(rc)) {\n-                        retryExecutor.schedule(that, worker.nextRetryWaitTime(), TimeUnit.MILLISECONDS);\n+                    if (allowRetry(worker, rc)) {\n+                        backOffAndRetry(that, worker.nextRetryWaitTime());\n                     } else {\n                         cb.processResult(rc, path, context, data, stat);\n                     }\n@@ -943,8 +1077,8 @@ public void getData(final String path, final boolean watch, final DataCallback c\n                 @Override\n                 public void processResult(int rc, String path, Object ctx, byte[] data, Stat stat) {\n                     ZooWorker worker = (ZooWorker)ctx;\n-                    if (worker.allowRetry(rc)) {\n-                        retryExecutor.schedule(that, worker.nextRetryWaitTime(), TimeUnit.MILLISECONDS);\n+                    if (allowRetry(worker, rc)) {\n+                        backOffAndRetry(that, worker.nextRetryWaitTime());\n                     } else {\n                         cb.processResult(rc, path, context, data, stat);\n                     }\n@@ -1003,8 +1137,8 @@ public void setData(final String path, final byte[] data, final int version,\n                 @Override\n                 public void processResult(int rc, String path, Object ctx, Stat stat) {\n                     ZooWorker worker = (ZooWorker)ctx;\n-                    if (worker.allowRetry(rc)) {\n-                        retryExecutor.schedule(that, worker.nextRetryWaitTime(), TimeUnit.MILLISECONDS);\n+                    if (allowRetry(worker, rc)) {\n+                        backOffAndRetry(that, worker.nextRetryWaitTime());\n                     } else {\n                         cb.processResult(rc, path, context, stat);\n                     }\n@@ -1086,8 +1220,8 @@ public void getChildren(final String path, final Watcher watcher,\n                 public void processResult(int rc, String path, Object ctx,\n                         List<String> children, Stat stat) {\n                     ZooWorker worker = (ZooWorker)ctx;\n-                    if (worker.allowRetry(rc)) {\n-                        retryExecutor.schedule(that, worker.nextRetryWaitTime(), TimeUnit.MILLISECONDS);\n+                    if (allowRetry(worker, rc)) {\n+                        backOffAndRetry(that, worker.nextRetryWaitTime());\n                     } else {\n                         cb.processResult(rc, path, context, children, stat);\n                     }\n@@ -1125,8 +1259,8 @@ public void getChildren(final String path, final boolean watch, final Children2C\n                 public void processResult(int rc, String path, Object ctx,\n                         List<String> children, Stat stat) {\n                     ZooWorker worker = (ZooWorker)ctx;\n-                    if (worker.allowRetry(rc)) {\n-                        retryExecutor.schedule(that, worker.nextRetryWaitTime(), TimeUnit.MILLISECONDS);\n+                    if (allowRetry(worker, rc)) {\n+                        backOffAndRetry(that, worker.nextRetryWaitTime());\n                     } else {\n                         cb.processResult(rc, path, context, children, stat);\n                     }\n@@ -1209,8 +1343,8 @@ public void getChildren(final String path, final Watcher watcher,\n                 public void processResult(int rc, String path, Object ctx,\n                         List<String> children) {\n                     ZooWorker worker = (ZooWorker)ctx;\n-                    if (worker.allowRetry(rc)) {\n-                        retryExecutor.schedule(that, worker.nextRetryWaitTime(), TimeUnit.MILLISECONDS);\n+                    if (allowRetry(worker, rc)) {\n+                        backOffAndRetry(that, worker.nextRetryWaitTime());\n                     } else {\n                         cb.processResult(rc, path, context, children);\n                     }\n@@ -1248,8 +1382,8 @@ public void getChildren(final String path, final boolean watch,\n                 public void processResult(int rc, String path, Object ctx,\n                         List<String> children) {\n                     ZooWorker worker = (ZooWorker)ctx;\n-                    if (worker.allowRetry(rc)) {\n-                        retryExecutor.schedule(that, worker.nextRetryWaitTime(), TimeUnit.MILLISECONDS);\n+                    if (allowRetry(worker, rc)) {\n+                        backOffAndRetry(that, worker.nextRetryWaitTime());\n                     } else {\n                         cb.processResult(rc, path, context, children);\n                     }\n@@ -1276,4 +1410,47 @@ public String toString() {\n         proc.run();\n     }\n \n+    @Override\n+    public void removeWatches(String path, Watcher watcher, WatcherType watcherType, boolean local)\n+            throws InterruptedException, KeeperException {\n+        ZooKeeper zkHandle = zk.get();\n+        if (null == zkHandle) {\n+            ZooKeeperClient.super.removeWatches(path, watcher, watcherType, local);\n+        } else {\n+            zkHandle.removeWatches(path, watcher, watcherType, local);\n+        }\n+    }\n+\n+    @Override\n+    public void removeWatches(String path, Watcher watcher, WatcherType watcherType, boolean local, VoidCallback cb, Object ctx) {\n+        ZooKeeper zkHandle = zk.get();\n+        if (null == zkHandle) {\n+            ZooKeeperClient.super.removeWatches(path, watcher, watcherType, local, cb, ctx);\n+        } else {\n+            zkHandle.removeWatches(path, watcher, watcherType, local, cb, ctx);\n+        }\n+    }\n+\n+    @Override\n+    public void removeAllWatches(String path, WatcherType watcherType, boolean local)\n+            throws InterruptedException, KeeperException {\n+        ZooKeeper zkHandle = zk.get();\n+        if (null == zkHandle) {\n+            ZooKeeperClient.super.removeAllWatches(path, watcherType, local);\n+        } else {\n+            zkHandle.removeAllWatches(path, watcherType, local);\n+        }\n+    }\n+\n+    @Override\n+    public void removeAllWatches(String path, WatcherType watcherType, boolean local, VoidCallback cb, Object ctx) {\n+        ZooKeeper zkHandle = zk.get();\n+        if (null == zkHandle) {\n+            ZooKeeperClient.super.removeAllWatches(path, watcherType, local, cb, ctx);\n+        } else {\n+            zkHandle.removeAllWatches(path, watcherType, local, cb, ctx);\n+        }\n+    }\n+\n+\n }"},{"sha":"7b36ed1ab43e9f175820338356350f0b824a44b8","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/zookeeper/TestRetryPolicy.java","status":"added","additions":54,"deletions":0,"changes":54,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/1e4ccaf167936fb4ad0de8c29ecf840bed3e89ed/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fzookeeper%2FTestRetryPolicy.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/1e4ccaf167936fb4ad0de8c29ecf840bed3e89ed/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fzookeeper%2FTestRetryPolicy.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fzookeeper%2FTestRetryPolicy.java?ref=1e4ccaf167936fb4ad0de8c29ecf840bed3e89ed","patch":"@@ -0,0 +1,54 @@\n+/**\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.zookeeper;\n+\n+import org.junit.Test;\n+import static org.junit.Assert.*;\n+\n+public class TestRetryPolicy {\n+\n+    private static void assertTimeRange(long waitTime, long minTime, long maxTime) {\n+        assertTrue(waitTime >= minTime);\n+        assertTrue(waitTime <= maxTime);\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testExponentialBackoffRetryPolicy() throws Exception {\n+        RetryPolicy policy = new ExponentialBackoffRetryPolicy(1000, Integer.MAX_VALUE);\n+        assertTimeRange(policy.nextRetryWaitTime(30, 2000), 1000L, (long) (1000 * Math.pow(2, 31)));\n+        assertTimeRange(policy.nextRetryWaitTime(31, 2000), 1000L, (long) (1000 * Math.pow(2, 32)));\n+        assertTimeRange(policy.nextRetryWaitTime(32, 2000), 1000L, (long) (1000 * Math.pow(2, 33)));\n+        assertTimeRange(policy.nextRetryWaitTime(127, 2000), 1000L, 1000L);\n+        assertTimeRange(policy.nextRetryWaitTime(128, 2000), 1000L, 2000L);\n+        assertTimeRange(policy.nextRetryWaitTime(129, 2000), 1000L, 4000L);\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testBoundExponentialBackoffRetryPolicy() throws Exception {\n+        RetryPolicy policy = new BoundExponentialBackoffRetryPolicy(1000, 2000, Integer.MAX_VALUE);\n+        assertTimeRange(policy.nextRetryWaitTime(30, 2000), 1000L, 2000L);\n+        assertTimeRange(policy.nextRetryWaitTime(31, 2000), 1000L, 2000L);\n+        assertTimeRange(policy.nextRetryWaitTime(32, 2000), 1000L, 2000L);\n+        assertTimeRange(policy.nextRetryWaitTime(127, 2000), 1000L, 1000L);\n+        assertTimeRange(policy.nextRetryWaitTime(128, 2000), 1000L, 2000L);\n+        assertTimeRange(policy.nextRetryWaitTime(129, 2000), 1000L, 2000L);\n+    }\n+}"},{"sha":"fae58882ef6c999dc272bd1360b805c2b21f4529","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/zookeeper/TestZooKeeperClient.java","status":"modified","additions":26,"deletions":3,"changes":29,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/1e4ccaf167936fb4ad0de8c29ecf840bed3e89ed/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fzookeeper%2FTestZooKeeperClient.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/1e4ccaf167936fb4ad0de8c29ecf840bed3e89ed/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fzookeeper%2FTestZooKeeperClient.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fzookeeper%2FTestZooKeeperClient.java?ref=1e4ccaf167936fb4ad0de8c29ecf840bed3e89ed","patch":"@@ -30,6 +30,7 @@\n \n import org.apache.bookkeeper.stats.NullStatsLogger;\n import org.apache.bookkeeper.test.ZooKeeperUtil;\n+import org.apache.zookeeper.AsyncCallback.Create2Callback;\n import org.apache.zookeeper.AsyncCallback.Children2Callback;\n import org.apache.zookeeper.AsyncCallback.DataCallback;\n import org.apache.zookeeper.AsyncCallback.StatCallback;\n@@ -164,7 +165,7 @@ public void process(WatchedEvent event) {\n \n         Assert.assertFalse(\"Client doesn't receive expire event from ZooKeeper.\",\n                 client.getState().isConnected());\n-        \n+\n         try {\n             client.exists(\"/tmp\", false);\n             Assert.fail(\"Should fail due to connection loss.\");\n@@ -222,10 +223,15 @@ public void testRetrySyncOperations() throws Exception {\n         logger.info(\"Create children under znode \" + path);\n         client.create(path + \"/children\", data, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n \n+        expireZooKeeperSession(client, timeout);\n+        logger.info(\"Create children under znode \" + path);\n+        client.create(path + \"/children2\", data, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, new Stat());\n+\n         expireZooKeeperSession(client, timeout);\n         List<String> children = client.getChildren(path, false, newStat);\n-        Assert.assertEquals(1, children.size());\n-        Assert.assertEquals(\"children\", children.get(0));\n+        Assert.assertEquals(2, children.size());\n+        Assert.assertTrue(children.contains(\"children\"));\n+        Assert.assertTrue(children.contains(\"children2\"));\n         logger.info(\"Get children under znode \" + path);\n \n         expireZooKeeperSession(client, timeout);\n@@ -286,6 +292,23 @@ public void processResult(int rc, String path, Object ctx, String name) {\n         createLatch.await();\n         logger.info(\"Created znode \" + path);\n \n+        expireZooKeeperSession(client, timeout);\n+        logger.info(\"Create znode \" + path);\n+        final CountDownLatch create2Latch = new CountDownLatch(1);\n+        client.create(path, data, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT,\n+                new Create2Callback() {\n+\n+            @Override\n+            public void processResult(int rc, String path, Object ctx, String name, Stat stat) {\n+                if (KeeperException.Code.NODEEXISTS.intValue() == rc) {\n+                    create2Latch.countDown();\n+                }\n+            }\n+\n+        }, null);\n+        create2Latch.await();\n+        logger.info(\"Created znode \" + path);\n+\n         expireZooKeeperSession(client, timeout);\n         logger.info(\"Exists znode \" + path);\n         final CountDownLatch existsLatch = new CountDownLatch(1);"},{"sha":"10e0f6779a1451578e6e8892224a7749fce91e35","filename":"pom.xml","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/1e4ccaf167936fb4ad0de8c29ecf840bed3e89ed/pom.xml","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/1e4ccaf167936fb4ad0de8c29ecf840bed3e89ed/pom.xml","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/pom.xml?ref=1e4ccaf167936fb4ad0de8c29ecf840bed3e89ed","patch":"@@ -44,7 +44,7 @@\n     <protobuf.version>2.6.1</protobuf.version>\n     <guava.version>13.0.1</guava.version>\n     <netty.version>3.9.4.Final</netty.version>\n-    <zookeeper.version>3.4.6</zookeeper.version>\n+    <zookeeper.version>3.5.1-alpha</zookeeper.version>\n   </properties>\n   <url>http://zookeeper.apache.org/bookkeeper</url>\n   <build>"}]}