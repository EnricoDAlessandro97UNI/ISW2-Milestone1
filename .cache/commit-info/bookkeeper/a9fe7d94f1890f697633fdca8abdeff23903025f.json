{"sha":"a9fe7d94f1890f697633fdca8abdeff23903025f","node_id":"MDY6Q29tbWl0NDc4NTkyNTI2OmE5ZmU3ZDk0ZjE4OTBmNjk3NjMzZmRjYThhYmRlZmYyMzkwMzAyNWY=","commit":{"author":{"name":"Matteo Merli","email":"mmerli@yahoo-inc.com","date":"2017-06-01T19:20:59Z"},"committer":{"name":"Enrico Olivelli","email":"eolivelli@localhost.localdomain","date":"2017-06-01T19:20:59Z"},"message":"BOOKKEEPER-1056: Removed PacketHeader serialization/deserialization allocation\n\nWhen parsing the request packet header, use static methods to avoid creating a `PacketHeader` instance.\n\nAuthor: Matteo Merli <mmerli@yahoo-inc.com>\n\nReviewers: Enrico Olivelli <None>, Sijie Guo <None>, Venkateswararao Jujjuri (JV) <None>\n\nCloses #175 from merlimat/packet-header-parsing","tree":{"sha":"16eb4021653eb76fc3686207800167c5350d5785","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/trees/16eb4021653eb76fc3686207800167c5350d5785"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/commits/a9fe7d94f1890f697633fdca8abdeff23903025f","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/a9fe7d94f1890f697633fdca8abdeff23903025f","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/a9fe7d94f1890f697633fdca8abdeff23903025f","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/a9fe7d94f1890f697633fdca8abdeff23903025f/comments","author":{"login":"merlimat","id":62500,"node_id":"MDQ6VXNlcjYyNTAw","avatar_url":"https://avatars.githubusercontent.com/u/62500?v=4","gravatar_id":"","url":"https://api.github.com/users/merlimat","html_url":"https://github.com/merlimat","followers_url":"https://api.github.com/users/merlimat/followers","following_url":"https://api.github.com/users/merlimat/following{/other_user}","gists_url":"https://api.github.com/users/merlimat/gists{/gist_id}","starred_url":"https://api.github.com/users/merlimat/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/merlimat/subscriptions","organizations_url":"https://api.github.com/users/merlimat/orgs","repos_url":"https://api.github.com/users/merlimat/repos","events_url":"https://api.github.com/users/merlimat/events{/privacy}","received_events_url":"https://api.github.com/users/merlimat/received_events","type":"User","site_admin":false},"committer":null,"parents":[{"sha":"dd08ce1a644de00967dd5fe34ce15caa9789d775","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/dd08ce1a644de00967dd5fe34ce15caa9789d775","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/dd08ce1a644de00967dd5fe34ce15caa9789d775"}],"stats":{"total":95,"additions":40,"deletions":55},"files":[{"sha":"8de43234025f03c6975de33b8ff14f1bb4357555","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieProtoEncoding.java","status":"modified","additions":23,"deletions":25,"changes":48,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/a9fe7d94f1890f697633fdca8abdeff23903025f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookieProtoEncoding.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/a9fe7d94f1890f697633fdca8abdeff23903025f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookieProtoEncoding.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookieProtoEncoding.java?ref=a9fe7d94f1890f697633fdca8abdeff23903025f","patch":"@@ -101,7 +101,7 @@ public Object encode(Object msg, ByteBufAllocator allocator)\n                 int totalHeaderSize = 4 // for the header\n                     + BookieProtocol.MASTER_KEY_LENGTH; // for the master key\n                 ByteBuf buf = allocator.buffer(totalHeaderSize);\n-                buf.writeInt(new PacketHeader(r.getProtocolVersion(), r.getOpCode(), r.getFlags()).toInt());\n+                buf.writeInt(PacketHeader.toInt(r.getProtocolVersion(), r.getOpCode(), r.getFlags()));\n                 buf.writeBytes(r.getMasterKey(), 0, BookieProtocol.MASTER_KEY_LENGTH);\n                 return DoubleByteBuf.get(buf, ar.getData());\n             } else if (r instanceof BookieProtocol.ReadRequest) {\n@@ -113,7 +113,7 @@ public Object encode(Object msg, ByteBufAllocator allocator)\n                 }\n \n                 ByteBuf buf = allocator.buffer(totalHeaderSize);\n-                buf.writeInt(new PacketHeader(r.getProtocolVersion(), r.getOpCode(), r.getFlags()).toInt());\n+                buf.writeInt(PacketHeader.toInt(r.getProtocolVersion(), r.getOpCode(), r.getFlags()));\n                 buf.writeLong(r.getLedgerId());\n                 buf.writeLong(r.getEntryId());\n                 if (r.hasMasterKey()) {\n@@ -126,9 +126,7 @@ public Object encode(Object msg, ByteBufAllocator allocator)\n                 int totalHeaderSize = 4; // for request type\n                 int totalSize = totalHeaderSize + am.getSerializedSize();\n                 ByteBuf buf = allocator.buffer(totalSize);\n-                buf.writeInt(new PacketHeader(r.getProtocolVersion(),\n-                                              r.getOpCode(),\n-                                              r.getFlags()).toInt());\n+                buf.writeInt(PacketHeader.toInt(r.getProtocolVersion(), r.getOpCode(), r.getFlags()));\n                 ByteBufOutputStream bufStream = new ByteBufOutputStream(buf);\n                 am.writeTo(bufStream);\n                 return buf;\n@@ -140,41 +138,43 @@ public Object encode(Object msg, ByteBufAllocator allocator)\n         @Override\n         public Object decode(ByteBuf packet)\n                 throws Exception {\n-            PacketHeader h = PacketHeader.fromInt(packet.readInt());\n+            int packetHeader = packet.readInt();\n+            byte version = PacketHeader.getVersion(packetHeader);\n+            byte opCode = PacketHeader.getOpCode(packetHeader);\n+            short flags = PacketHeader.getFlags(packetHeader);\n \n             // packet format is different between ADDENTRY and READENTRY\n             long ledgerId = -1;\n             long entryId = BookieProtocol.INVALID_ENTRY_ID;\n \n-            short flags = h.getFlags();\n-\n             ServerStats.getInstance().incrementPacketsReceived();\n \n-            switch (h.getOpCode()) {\n+            switch (opCode) {\n             case BookieProtocol.ADDENTRY: {\n                 byte[] masterKey = readMasterKey(packet);\n \n                 // Read ledger and entry id without advancing the reader index\n                 ledgerId = packet.getLong(packet.readerIndex());\n                 entryId = packet.getLong(packet.readerIndex() + 8);\n-                return new BookieProtocol.AddRequest(h.getVersion(), ledgerId, entryId, flags, masterKey, packet.retain());\n+                return new BookieProtocol.AddRequest(version, ledgerId, entryId, flags, masterKey, packet.retain());\n             }\n+\n             case BookieProtocol.READENTRY:\n                 ledgerId = packet.readLong();\n                 entryId = packet.readLong();\n \n                 if ((flags & BookieProtocol.FLAG_DO_FENCING) == BookieProtocol.FLAG_DO_FENCING\n-                    && h.getVersion() >= 2) {\n+                    && version >= 2) {\n                     byte[] masterKey = readMasterKey(packet);\n-                    return new BookieProtocol.ReadRequest(h.getVersion(), ledgerId, entryId, flags, masterKey);\n+                    return new BookieProtocol.ReadRequest(version, ledgerId, entryId, flags, masterKey);\n                 } else {\n-                    return new BookieProtocol.ReadRequest(h.getVersion(), ledgerId, entryId, flags);\n+                    return new BookieProtocol.ReadRequest(version, ledgerId, entryId, flags);\n                 }\n             case BookieProtocol.AUTH:\n                 BookkeeperProtocol.AuthMessage.Builder builder\n                     = BookkeeperProtocol.AuthMessage.newBuilder();\n                 builder.mergeFrom(new ByteBufInputStream(packet), extensionRegistry);\n-                return new BookieProtocol.AuthRequest(h.getVersion(), builder.build());\n+                return new BookieProtocol.AuthRequest(version, builder.build());\n             }\n \n             return packet;\n@@ -221,8 +221,7 @@ public Object encode(Object msg, ByteBufAllocator allocator)\n             }\n             BookieProtocol.Response r = (BookieProtocol.Response)msg;\n             ByteBuf buf = allocator.buffer(24);\n-            buf.writeInt(new PacketHeader(r.getProtocolVersion(),\n-                                          r.getOpCode(), (short)0).toInt());\n+            buf.writeInt(PacketHeader.toInt(r.getProtocolVersion(), r.getOpCode(), (short) 0));\n \n             ServerStats.getInstance().incrementPacketsSent();\n             if (msg instanceof BookieProtocol.ReadResponse) {\n@@ -255,36 +254,35 @@ public Object decode(ByteBuf buffer)\n                 throws Exception {\n             int rc;\n             long ledgerId, entryId;\n-            final PacketHeader header;\n \n-            header = PacketHeader.fromInt(buffer.readInt());\n+            int packetHeader = buffer.readInt();\n+            byte version = PacketHeader.getVersion(packetHeader);\n+            byte opCode = PacketHeader.getOpCode(packetHeader);\n \n-            switch (header.getOpCode()) {\n+            switch (opCode) {\n             case BookieProtocol.ADDENTRY:\n                 rc = buffer.readInt();\n                 ledgerId = buffer.readLong();\n                 entryId = buffer.readLong();\n-                return new BookieProtocol.AddResponse(header.getVersion(), rc, ledgerId, entryId);\n+                return new BookieProtocol.AddResponse(version, rc, ledgerId, entryId);\n             case BookieProtocol.READENTRY:\n                 rc = buffer.readInt();\n                 ledgerId = buffer.readLong();\n                 entryId = buffer.readLong();\n \n                 if (rc == BookieProtocol.EOK) {\n                     ByteBuf content = buffer.slice();\n-                    return new BookieProtocol.ReadResponse(header.getVersion(), rc,\n-                                                           ledgerId, entryId, content.retain());\n+                    return new BookieProtocol.ReadResponse(version, rc, ledgerId, entryId, content.retain());\n                 } else {\n-                    return new BookieProtocol.ReadResponse(header.getVersion(), rc,\n-                                                           ledgerId, entryId);\n+                    return new BookieProtocol.ReadResponse(version, rc, ledgerId, entryId);\n                 }\n             case BookieProtocol.AUTH:\n                 ByteBufInputStream bufStream = new ByteBufInputStream(buffer);\n                 BookkeeperProtocol.AuthMessage.Builder builder\n                     = BookkeeperProtocol.AuthMessage.newBuilder();\n                 builder.mergeFrom(bufStream, extensionRegistry);\n                 BookkeeperProtocol.AuthMessage am = builder.build();\n-                return new BookieProtocol.AuthResponse(header.getVersion(), am);\n+                return new BookieProtocol.AuthResponse(version, am);\n             default:\n                 return buffer;\n             }"},{"sha":"d744d09b65c6831d843fac771baee49a3ff7ffba","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieProtocol.java","status":"modified","additions":17,"deletions":30,"changes":47,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/a9fe7d94f1890f697633fdca8abdeff23903025f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookieProtocol.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/a9fe7d94f1890f697633fdca8abdeff23903025f/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookieProtocol.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookieProtocol.java?ref=a9fe7d94f1890f697633fdca8abdeff23903025f","patch":"@@ -69,18 +69,8 @@ public interface BookieProtocol {\n      * and just had an int representing the opCode as the \n      * first int. This handles that case also. \n      */\n-    static class PacketHeader {\n-        final byte version;\n-        final byte opCode;\n-        final short flags;\n-\n-        public PacketHeader(byte version, byte opCode, short flags) {\n-            this.version = version;\n-            this.opCode = opCode;\n-            this.flags = flags;\n-        }\n-        \n-        int toInt() {\n+    final static class PacketHeader {\n+        public static int toInt(byte version, byte opCode, short flags) {\n             if (version == 0) {\n                 return (int)opCode;\n             } else {\n@@ -90,29 +80,26 @@ int toInt() {\n             }\n         }\n \n-        static PacketHeader fromInt(int i) {\n-            byte version = (byte)(i >> 24); \n-            byte opCode = 0;\n-            short flags = 0;\n+        public static byte getVersion(int packetHeader) {\n+            return (byte)(packetHeader >> 24);\n+        }\n+\n+        public static byte getOpCode(int packetHeader) {\n+            int version = getVersion(packetHeader);\n             if (version == 0) {\n-                opCode = (byte)i;\n+                return (byte) packetHeader;\n             } else {\n-                opCode = (byte)((i >> 16) & 0xFF);\n-                flags = (short)(i & 0xFFFF);\n+                return (byte)((packetHeader >> 16) & 0xFF);\n             }\n-            return new PacketHeader(version, opCode, flags);\n-        }\n-\n-        byte getVersion() {\n-            return version;\n         }\n \n-        byte getOpCode() {\n-            return opCode;\n-        }\n-\n-        short getFlags() {\n-            return flags;\n+        public static short getFlags(int packetHeader) {\n+            byte version = (byte)(packetHeader >> 24);\n+            if (version == 0) {\n+                return 0;\n+            } else {\n+                return (short)(packetHeader & 0xFFFF);\n+            }\n         }\n     }\n "}]}