{"sha":"baa0afc059dc0a96d5fb8c902a0504cf8fd30e02","node_id":"MDY6Q29tbWl0NDc4NTkyNTI2OmJhYTBhZmMwNTlkYzBhOTZkNWZiOGM5MDJhMDUwNGNmOGZkMzBlMDI=","commit":{"author":{"name":"Khurrum Nasim","email":"khurrumnasimm@gmail.com","date":"2016-11-29T19:50:17Z"},"committer":{"name":"Sijie Guo","email":"sijieg@twitter.com","date":"2016-11-29T19:50:17Z"},"message":"Fix deadlock on BKSyncLogReaderDLSN\n\nChange the lastSeenDLSN to volatile to remove the synchronization block to avoid deadlock with sharedLock\n\nAuthor: Khurrum Nasim <khurrumnasimm@gmail.com>\n\nReviewers: Leigh Stewart <lstewart@apache.org>\n\nCloses #42 from khurrumnasimm/kn/fix_deadlock","tree":{"sha":"dfac5d4316f4f304fc8fb86e00aa9cd6c1a45598","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/trees/dfac5d4316f4f304fc8fb86e00aa9cd6c1a45598"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/commits/baa0afc059dc0a96d5fb8c902a0504cf8fd30e02","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/baa0afc059dc0a96d5fb8c902a0504cf8fd30e02","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/baa0afc059dc0a96d5fb8c902a0504cf8fd30e02","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/baa0afc059dc0a96d5fb8c902a0504cf8fd30e02/comments","author":{"login":"khurrumnasimm","id":21236134,"node_id":"MDQ6VXNlcjIxMjM2MTM0","avatar_url":"https://avatars.githubusercontent.com/u/21236134?v=4","gravatar_id":"","url":"https://api.github.com/users/khurrumnasimm","html_url":"https://github.com/khurrumnasimm","followers_url":"https://api.github.com/users/khurrumnasimm/followers","following_url":"https://api.github.com/users/khurrumnasimm/following{/other_user}","gists_url":"https://api.github.com/users/khurrumnasimm/gists{/gist_id}","starred_url":"https://api.github.com/users/khurrumnasimm/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/khurrumnasimm/subscriptions","organizations_url":"https://api.github.com/users/khurrumnasimm/orgs","repos_url":"https://api.github.com/users/khurrumnasimm/repos","events_url":"https://api.github.com/users/khurrumnasimm/events{/privacy}","received_events_url":"https://api.github.com/users/khurrumnasimm/received_events","type":"User","site_admin":false},"committer":null,"parents":[{"sha":"2b2f33f51c8d3ac78fb7b969294eab952d730a99","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/2b2f33f51c8d3ac78fb7b969294eab952d730a99","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/2b2f33f51c8d3ac78fb7b969294eab952d730a99"}],"stats":{"total":30,"additions":11,"deletions":19},"files":[{"sha":"ac670c23cc03e6e3a1c3b123f31c60d29ed3733a","filename":"src/main/java/com/twitter/distributedlog/BKSyncLogReaderDLSN.java","status":"modified","additions":11,"deletions":19,"changes":30,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/baa0afc059dc0a96d5fb8c902a0504cf8fd30e02/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FBKSyncLogReaderDLSN.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/baa0afc059dc0a96d5fb8c902a0504cf8fd30e02/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FBKSyncLogReaderDLSN.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FBKSyncLogReaderDLSN.java?ref=baa0afc059dc0a96d5fb8c902a0504cf8fd30e02","patch":"@@ -51,7 +51,7 @@ class BKSyncLogReaderDLSN implements LogReader, Runnable, FutureEventListener<Lo\n     private Promise<Void> closeFuture;\n     private final Optional<Long> startTransactionId;\n     private final DLSN startDLSN;\n-    private DLSN lastSeenDLSN = DLSN.InvalidDLSN;\n+    private volatile DLSN lastSeenDLSN = DLSN.InvalidDLSN;\n     // lock on variables that would be accessed by both background threads and foreground threads\n     private final Object sharedLock = new Object();\n \n@@ -101,12 +101,6 @@ private void setReadAheadCallback(ReadAheadCallback callback) {\n         }\n     }\n \n-    private synchronized void setLastSeenDLSN(DLSN dlsn) {\n-        synchronized (sharedLock) {\n-            this.lastSeenDLSN = dlsn;\n-        }\n-    }\n-\n     // Background Read Future Listener\n \n     @Override\n@@ -116,7 +110,7 @@ public void resumeReadAhead() {\n \n     @Override\n     public void onSuccess(LogRecordWithDLSN record) {\n-        setLastSeenDLSN(record.getDlsn());\n+        this.lastSeenDLSN = record.getDlsn();\n         if (!startTransactionId.isPresent() || record.getTransactionId() >= startTransactionId.get()) {\n             readAheadRecords.add(record);\n         }\n@@ -173,17 +167,15 @@ public synchronized LogRecordWithDLSN readNext(boolean nonBlocking)\n                     if (null != record) {\n                         break;\n                     }\n-                    synchronized (sharedLock) {\n-                        DLSN lastDLSNSeenByReadAhead =\n-                                reader.bkLedgerManager.readAheadCache.getLastReadAheadUserDLSN();\n-\n-                        // if last seen DLSN by reader is same as the one seen by ReadAhead\n-                        // that means that reader is caught up with ReadAhead and ReadAhead\n-                        // is caught up with stream\n-                        shallWait = DLSN.InitialDLSN != lastDLSNSeenByReadAhead\n-                                && lastSeenDLSN.compareTo(lastDLSNSeenByReadAhead) < 0\n-                                && startDLSN.compareTo(lastDLSNSeenByReadAhead) <= 0;\n-                    }\n+                    DLSN lastDLSNSeenByReadAhead =\n+                            reader.bkLedgerManager.readAheadCache.getLastReadAheadUserDLSN();\n+\n+                    // if last seen DLSN by reader is same as the one seen by ReadAhead\n+                    // that means that reader is caught up with ReadAhead and ReadAhead\n+                    // is caught up with stream\n+                    shallWait = DLSN.InitialDLSN != lastDLSNSeenByReadAhead\n+                            && lastSeenDLSN.compareTo(lastDLSNSeenByReadAhead) < 0\n+                            && startDLSN.compareTo(lastDLSNSeenByReadAhead) <= 0;\n                 }\n             } catch (InterruptedException e) {\n                 throw new DLInterruptedException(\"Interrupted on waiting next available log record for stream \""}]}