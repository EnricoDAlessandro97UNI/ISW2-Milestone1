{"sha":"74f795136c1fff3badb29fc982d0cc2d43096b45","node_id":"MDY6Q29tbWl0NDc4NTkyNTI2Ojc0Zjc5NTEzNmMxZmZmM2JhZGIyOWZjOTgyZDBjYzJkNDMwOTZiNDU=","commit":{"author":{"name":"Matteo Merli","email":"mmerli@apache.org","date":"2017-05-15T17:52:53Z"},"committer":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2017-05-15T17:52:53Z"},"message":"BOOKKEEPER-1008: Netty 4.1\n\nAdded more ref-count fixes from yahoo-4.3 branch on top of #116\n\nAuthor: Matteo Merli <mmerli@apache.org>\nAuthor: Matteo Merli <mmerli@yahoo-inc.com>\nAuthor: Kishore Kasi Udayashankar <kudayashankar@salesforce.com>\n\nReviewers: Jia Zhai <zhaijia03@gmail.com>, Sijie Guo <sijie@apache.org>\n\nCloses #138 from merlimat/netty-4.1","tree":{"sha":"79301fd6e43643bca7e19a0d8f90f11f6cc95155","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/trees/79301fd6e43643bca7e19a0d8f90f11f6cc95155"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/commits/74f795136c1fff3badb29fc982d0cc2d43096b45","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/74f795136c1fff3badb29fc982d0cc2d43096b45","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/74f795136c1fff3badb29fc982d0cc2d43096b45","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/74f795136c1fff3badb29fc982d0cc2d43096b45/comments","author":{"login":"merlimat","id":62500,"node_id":"MDQ6VXNlcjYyNTAw","avatar_url":"https://avatars.githubusercontent.com/u/62500?v=4","gravatar_id":"","url":"https://api.github.com/users/merlimat","html_url":"https://github.com/merlimat","followers_url":"https://api.github.com/users/merlimat/followers","following_url":"https://api.github.com/users/merlimat/following{/other_user}","gists_url":"https://api.github.com/users/merlimat/gists{/gist_id}","starred_url":"https://api.github.com/users/merlimat/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/merlimat/subscriptions","organizations_url":"https://api.github.com/users/merlimat/orgs","repos_url":"https://api.github.com/users/merlimat/repos","events_url":"https://api.github.com/users/merlimat/events{/privacy}","received_events_url":"https://api.github.com/users/merlimat/received_events","type":"User","site_admin":false},"committer":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"parents":[{"sha":"811ece53a1c975c4e768422f3d622ac9de6b3e41","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/811ece53a1c975c4e768422f3d622ac9de6b3e41","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/811ece53a1c975c4e768422f3d622ac9de6b3e41"}],"stats":{"total":2924,"additions":1865,"deletions":1059},"files":[{"sha":"43546566949d633964159b15596b5103b80485c0","filename":"bookkeeper-benchmark/pom.xml","status":"modified","additions":19,"deletions":1,"changes":20,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-benchmark%2Fpom.xml","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-benchmark%2Fpom.xml","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-benchmark%2Fpom.xml?ref=74f795136c1fff3badb29fc982d0cc2d43096b45","patch":"@@ -87,10 +87,28 @@\n       <version>${zookeeper.version}</version>\n       <type>test-jar</type>\n       <scope>test</scope>\n+      <exclusions>\n+        <exclusion>\n+          <groupId>org.slf4j</groupId>\n+          <artifactId>slf4j-log4j12</artifactId>\n+        </exclusion>\n+        <exclusion>\n+          <groupId>org.slf4j</groupId>\n+          <artifactId>slf4j-api</artifactId>\n+        </exclusion>\n+        <exclusion>\n+          <groupId>log4j</groupId>\n+          <artifactId>log4j</artifactId>\n+        </exclusion>\n+        <exclusion>\n+          <groupId>io.netty</groupId>\n+          <artifactId>netty</artifactId>\n+        </exclusion>\n+      </exclusions>\n     </dependency>\n     <dependency>\n       <groupId>io.netty</groupId>\n-      <artifactId>netty</artifactId>\n+      <artifactId>netty-all</artifactId>\n       <version>${netty.version}</version>\n       <scope>compile</scope>\n     </dependency>"},{"sha":"7ccd0348f9ced2a1d4cf49150849561800577222","filename":"bookkeeper-benchmark/src/main/java/org/apache/bookkeeper/benchmark/BenchBookie.java","status":"modified","additions":23,"deletions":15,"changes":38,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-benchmark%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbenchmark%2FBenchBookie.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-benchmark%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbenchmark%2FBenchBookie.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-benchmark%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbenchmark%2FBenchBookie.java?ref=74f795136c1fff3badb29fc982d0cc2d43096b45","patch":"@@ -20,7 +20,6 @@\n package org.apache.bookkeeper.benchmark;\n \n import java.io.IOException;\n-import java.util.concurrent.Executors;\n \n import org.apache.bookkeeper.net.BookieSocketAddress;\n import org.apache.bookkeeper.proto.BookieClient;\n@@ -32,21 +31,23 @@\n import org.apache.bookkeeper.client.LedgerHandle;\n import org.apache.bookkeeper.conf.ClientConfiguration;\n import org.apache.commons.cli.HelpFormatter;\n-import org.apache.commons.cli.Option;\n import org.apache.commons.cli.Options;\n import org.apache.commons.cli.CommandLine;\n import org.apache.commons.cli.CommandLineParser;\n import org.apache.commons.cli.PosixParser;\n+import org.apache.commons.lang.SystemUtils;\n import org.apache.commons.cli.ParseException;\n import org.apache.zookeeper.KeeperException;\n-import org.jboss.netty.buffer.ChannelBuffer;\n-import org.jboss.netty.buffer.ChannelBuffers;\n-import org.jboss.netty.channel.socket.ClientSocketChannelFactory;\n-import org.jboss.netty.channel.socket.nio.NioClientSocketChannelFactory;\n \n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.epoll.EpollEventLoopGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+\n public class BenchBookie {\n     static final Logger LOG = LoggerFactory.getLogger(BenchBookie.class);\n \n@@ -137,26 +138,33 @@ public static void main(String[] args)\n         int size = Integer.parseInt(cmd.getOptionValue(\"size\", \"1024\"));\n         String servers = cmd.getOptionValue(\"zookeeper\", \"localhost:2181\");\n \n+        EventLoopGroup eventLoop;\n+        if (SystemUtils.IS_OS_LINUX) {\n+            try {\n+                eventLoop = new EpollEventLoopGroup();\n+            } catch (Throwable t) {\n+                LOG.warn(\"Could not use Netty Epoll event loop for benchmark {}\", t.getMessage());\n+                eventLoop = new NioEventLoopGroup();\n+            }\n+        } else {\n+            eventLoop = new NioEventLoopGroup();\n+        }\n \n-\n-        ClientSocketChannelFactory channelFactory\n-            = new NioClientSocketChannelFactory(Executors.newCachedThreadPool(), Executors\n-                                                .newCachedThreadPool());\n         OrderedSafeExecutor executor = OrderedSafeExecutor.newBuilder()\n                 .name(\"BenchBookieClientScheduler\")\n                 .numThreads(1)\n                 .build();\n \n         ClientConfiguration conf = new ClientConfiguration();\n-        BookieClient bc = new BookieClient(conf, channelFactory, executor);\n+        BookieClient bc = new BookieClient(conf, eventLoop, executor);\n         LatencyCallback lc = new LatencyCallback();\n \n         ThroughputCallback tc = new ThroughputCallback();\n         int warmUpCount = 999;\n \n         long ledger = getValidLedgerId(servers);\n         for(long entry = 0; entry < warmUpCount; entry++) {\n-            ChannelBuffer toSend = ChannelBuffers.buffer(size);\n+            ByteBuf toSend = Unpooled.buffer(size);\n             toSend.resetReaderIndex();\n             toSend.resetWriterIndex();\n             toSend.writeLong(ledger);\n@@ -173,7 +181,7 @@ public static void main(String[] args)\n         int entryCount = 5000;\n         long startTime = System.nanoTime();\n         for(long entry = 0; entry < entryCount; entry++) {\n-            ChannelBuffer toSend = ChannelBuffers.buffer(size);\n+            ByteBuf toSend = Unpooled.buffer(size);\n             toSend.resetReaderIndex();\n             toSend.resetWriterIndex();\n             toSend.writeLong(ledger);\n@@ -194,7 +202,7 @@ public static void main(String[] args)\n         startTime = System.currentTimeMillis();\n         tc = new ThroughputCallback();\n         for(long entry = 0; entry < entryCount; entry++) {\n-            ChannelBuffer toSend = ChannelBuffers.buffer(size);\n+            ByteBuf toSend = Unpooled.buffer(size);\n             toSend.resetReaderIndex();\n             toSend.resetWriterIndex();\n             toSend.writeLong(ledger);\n@@ -208,7 +216,7 @@ public static void main(String[] args)\n         LOG.info(\"Throughput: \" + ((long)entryCount)*1000/(endTime-startTime));\n \n         bc.close();\n-        channelFactory.releaseExternalResources();\n+        eventLoop.shutdownGracefully();\n         executor.shutdown();\n     }\n "},{"sha":"99705f41972af8ffce755c0d097bdf6778f0f06e","filename":"bookkeeper-server/pom.xml","status":"modified","additions":39,"deletions":7,"changes":46,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fpom.xml","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fpom.xml","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fpom.xml?ref=74f795136c1fff3badb29fc982d0cc2d43096b45","patch":"@@ -23,7 +23,6 @@\n     <groupId>org.apache.bookkeeper</groupId>\n     <version>4.5.0-SNAPSHOT</version>\n   </parent>\n-  <groupId>org.apache.bookkeeper</groupId>\n   <artifactId>bookkeeper-server</artifactId>\n   <name>bookkeeper-server</name>\n   <url>http://maven.apache.org</url>\n@@ -74,6 +73,22 @@\n           <groupId>net.java.dev.javacc</groupId>\n           <artifactId>javacc</artifactId>\n         </exclusion>\n+        <exclusion>\n+          <groupId>org.slf4j</groupId>\n+          <artifactId>slf4j-log4j12</artifactId>\n+        </exclusion>\n+        <exclusion>\n+          <groupId>org.slf4j</groupId>\n+          <artifactId>slf4j-api</artifactId>\n+        </exclusion>\n+        <exclusion>\n+          <groupId>log4j</groupId>\n+          <artifactId>log4j</artifactId>\n+\t\t</exclusion>\n+        <exclusion>\n+          <groupId>io.netty</groupId>\n+          <artifactId>netty</artifactId>\n+        </exclusion>\n       </exclusions>\n     </dependency>\n     <dependency>\n@@ -82,12 +97,24 @@\n       <version>${zookeeper.version}</version>\n       <type>test-jar</type>\n       <scope>test</scope>\n-    </dependency>\n-    <dependency>\n-      <groupId>io.netty</groupId>\n-      <artifactId>netty</artifactId>\n-      <version>${netty.version}</version>\n-      <scope>compile</scope>\n+      <exclusions>\n+        <exclusion>\n+          <groupId>org.slf4j</groupId>\n+          <artifactId>slf4j-log4j12</artifactId>\n+        </exclusion>\n+        <exclusion>\n+          <groupId>org.slf4j</groupId>\n+          <artifactId>slf4j-api</artifactId>\n+        </exclusion>\n+        <exclusion>\n+          <groupId>log4j</groupId>\n+          <artifactId>log4j</artifactId>\n+        </exclusion>\n+        <exclusion>\n+          <groupId>io.netty</groupId>\n+          <artifactId>netty</artifactId>\n+        </exclusion>\n+      </exclusions>\n     </dependency>\n     <dependency>\n       <groupId>org.apache.commons</groupId>\n@@ -184,6 +211,11 @@\n         </exclusion>\n       </exclusions>\n     </dependency>\n+    <dependency>\n+      <groupId>io.netty</groupId>\n+      <artifactId>netty-all</artifactId>\n+      <version>${netty.version}</version>\n+    </dependency>\n   </dependencies>\n   <build>\n     <plugins>"},{"sha":"3969f41ded1b676022a5f5c2ed014b7289465cb7","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LocalBookieEnsemblePlacementPolicy.java","status":"modified","additions":2,"deletions":3,"changes":5,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLocalBookieEnsemblePlacementPolicy.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLocalBookieEnsemblePlacementPolicy.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLocalBookieEnsemblePlacementPolicy.java?ref=74f795136c1fff3badb29fc982d0cc2d43096b45","patch":"@@ -22,7 +22,6 @@\n import java.net.UnknownHostException;\n import java.util.*;\n \n-import org.apache.bookkeeper.client.BKException;\n import org.apache.bookkeeper.client.BookieInfoReader.BookieInfo;\n import org.apache.bookkeeper.client.EnsemblePlacementPolicy;\n import org.apache.bookkeeper.client.BKException.BKNotEnoughBookiesException;\n@@ -32,14 +31,14 @@\n import org.apache.bookkeeper.net.BookieSocketAddress;\n import org.apache.bookkeeper.net.DNSToSwitchMapping;\n import org.apache.bookkeeper.stats.StatsLogger;\n-import org.apache.commons.configuration.Configuration;\n import com.google.common.collect.Lists;\n-import org.jboss.netty.util.HashedWheelTimer;\n \n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n \n+import io.netty.util.HashedWheelTimer;\n+\n /**\n  * Special ensemble placement policy that always return local bookie. Only works with ledgers with ensemble=1.\n  */"},{"sha":"fd253614bf46a8d0f5f17b3b800438871cf5cd9b","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeper.java","status":"modified","additions":50,"deletions":35,"changes":85,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookKeeper.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookKeeper.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookKeeper.java?ref=74f795136c1fff3badb29fc982d0cc2d43096b45","patch":"@@ -20,12 +20,18 @@\n  */\n package org.apache.bookkeeper.client;\n \n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.epoll.EpollEventLoopGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.util.HashedWheelTimer;\n+\n import java.io.IOException;\n import java.util.List;\n import java.util.Map;\n import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.Executors;\n import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ThreadFactory;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.locks.ReentrantReadWriteLock;\n \n@@ -57,11 +63,9 @@\n import org.apache.bookkeeper.zookeeper.BoundExponentialBackoffRetryPolicy;\n import org.apache.bookkeeper.zookeeper.ZooKeeperClient;\n import org.apache.commons.configuration.ConfigurationException;\n+import org.apache.commons.lang.SystemUtils;\n import org.apache.zookeeper.KeeperException;\n import org.apache.zookeeper.ZooKeeper;\n-import org.jboss.netty.channel.socket.ClientSocketChannelFactory;\n-import org.jboss.netty.channel.socket.nio.NioClientSocketChannelFactory;\n-import org.jboss.netty.util.HashedWheelTimer;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -88,7 +92,7 @@ public class BookKeeper implements AutoCloseable {\n     static final Logger LOG = LoggerFactory.getLogger(BookKeeper.class);\n \n     final ZooKeeper zk;\n-    final ClientSocketChannelFactory channelFactory;\n+    final EventLoopGroup eventLoopGroup;\n \n     // The stats logger for this client.\n     private final StatsLogger statsLogger;\n@@ -101,9 +105,9 @@ public class BookKeeper implements AutoCloseable {\n     private OpStatsLogger readLacOpLogger;\n \n \n-    // whether the socket factory is one we created, or is owned by whoever\n+    // whether the event loop group is one we created, or is owned by whoever\n     // instantiated us\n-    boolean ownChannelFactory = false;\n+    boolean ownEventLoopGroup = false;\n     // whether the zk handle is one we created, or is owned by whoever\n     // instantiated us\n     boolean ownZKHandle = false;\n@@ -138,7 +142,7 @@ public static class Builder {\n         final ClientConfiguration conf;\n \n         ZooKeeper zk = null;\n-        ClientSocketChannelFactory channelFactory = null;\n+        EventLoopGroup eventLoopGroup = null;\n         StatsLogger statsLogger = NullStatsLogger.INSTANCE;\n         DNSToSwitchMapping dnsResolver = null;\n         HashedWheelTimer requestTimer = null;\n@@ -148,8 +152,8 @@ public static class Builder {\n             this.conf = conf;\n         }\n \n-        public Builder setChannelFactory(ClientSocketChannelFactory f) {\n-            channelFactory = f;\n+        public Builder setEventLoopGroup(EventLoopGroup f) {\n+            eventLoopGroup = f;\n             return this;\n         }\n \n@@ -181,7 +185,7 @@ public Builder featureProvider(FeatureProvider featureProvider) {\n \n         public BookKeeper build() throws IOException, InterruptedException, KeeperException {\n             Preconditions.checkNotNull(statsLogger, \"No stats logger provided\");\n-            return new BookKeeper(conf, zk, channelFactory, statsLogger, dnsResolver, requestTimer, featureProvider);\n+            return new BookKeeper(conf, zk, eventLoopGroup, statsLogger, dnsResolver, requestTimer, featureProvider);\n         }\n     }\n \n@@ -190,7 +194,7 @@ public static Builder forConfig(final ClientConfiguration conf) {\n     }\n \n     /**\n-     * Create a bookkeeper client. A zookeeper client and a client socket factory\n+     * Create a bookkeeper client. A zookeeper client and a client event loop group\n      * will be instantiated as part of this constructor.\n      *\n      * @param servers\n@@ -209,7 +213,7 @@ public BookKeeper(String servers) throws IOException, InterruptedException,\n \n     /**\n      * Create a bookkeeper client using a configuration object.\n-     * A zookeeper client and a client socket factory will be\n+     * A zookeeper client and a client event loop group will be\n      * instantiated as part of this constructor.\n      *\n      * @param conf\n@@ -229,10 +233,10 @@ private static ZooKeeper validateZooKeeper(ZooKeeper zk) throws NullPointerExcep\n         return zk;\n     }\n \n-    private static ClientSocketChannelFactory validateChannelFactory(ClientSocketChannelFactory factory)\n+    private static EventLoopGroup validateEventLoopGroup(EventLoopGroup eventLoopGroup)\n             throws NullPointerException {\n-        Preconditions.checkNotNull(factory, \"No Channel Factory provided\");\n-        return factory;\n+        Preconditions.checkNotNull(eventLoopGroup, \"No Event Loop Group provided\");\n+        return eventLoopGroup;\n     }\n \n     /**\n@@ -257,7 +261,7 @@ public BookKeeper(ClientConfiguration conf, ZooKeeper zk)\n \n     /**\n      * Create a bookkeeper client but use the passed in zookeeper client and\n-     * client socket channel factory instead of instantiating those.\n+     * client event loop group instead of instantiating those.\n      *\n      * @param conf\n      *          Client Configuration Object\n@@ -266,15 +270,15 @@ public BookKeeper(ClientConfiguration conf, ZooKeeper zk)\n      *          Zookeeper client instance connected to the zookeeper with which\n      *          the bookies have registered. The ZooKeeper client must be connected\n      *          before it is passed to BookKeeper. Otherwise a KeeperException is thrown.\n-     * @param channelFactory\n-     *          A factory that will be used to create connections to the bookies\n+     * @param eventLoopGroup\n+     *          An event loop group that will be used to create connections to the bookies\n      * @throws IOException\n      * @throws InterruptedException\n      * @throws KeeperException if the passed zk handle is not connected\n      */\n-    public BookKeeper(ClientConfiguration conf, ZooKeeper zk, ClientSocketChannelFactory channelFactory)\n+    public BookKeeper(ClientConfiguration conf, ZooKeeper zk, EventLoopGroup eventLoopGroup)\n             throws IOException, InterruptedException, KeeperException {\n-        this(conf, validateZooKeeper(zk), validateChannelFactory(channelFactory), NullStatsLogger.INSTANCE,\n+        this(conf, validateZooKeeper(zk), validateEventLoopGroup(eventLoopGroup), NullStatsLogger.INSTANCE,\n                 null, null, null);\n     }\n \n@@ -283,7 +287,7 @@ public BookKeeper(ClientConfiguration conf, ZooKeeper zk, ClientSocketChannelFac\n      */\n     private BookKeeper(ClientConfiguration conf,\n                        ZooKeeper zkc,\n-                       ClientSocketChannelFactory channelFactory,\n+                       EventLoopGroup eventLoopGroup,\n                        StatsLogger statsLogger,\n                        DNSToSwitchMapping dnsResolver,\n                        HashedWheelTimer requestTimer,\n@@ -310,18 +314,13 @@ private BookKeeper(ClientConfiguration conf,\n             this.ownZKHandle = false;\n         }\n \n-        // initialize channel factory\n-        if (null == channelFactory) {\n-            ThreadFactoryBuilder tfb = new ThreadFactoryBuilder();\n-            this.channelFactory = new NioClientSocketChannelFactory(\n-                    Executors.newCachedThreadPool(tfb.setNameFormat(\n-                            \"BookKeeper-NIOBoss-%d\").build()),\n-                    Executors.newCachedThreadPool(tfb.setNameFormat(\n-                            \"BookKeeper-NIOWorker-%d\").build()));\n-            this.ownChannelFactory = true;\n+        // initialize event loop group\n+        if (null == eventLoopGroup) {\n+            this.eventLoopGroup = getDefaultEventLoopGroup();\n+            this.ownEventLoopGroup = true;\n         } else {\n-            this.channelFactory = channelFactory;\n-            this.ownChannelFactory = false;\n+            this.eventLoopGroup = eventLoopGroup;\n+            this.ownEventLoopGroup = false;\n         }\n \n         if (null == requestTimer) {\n@@ -365,7 +364,7 @@ private BookKeeper(ClientConfiguration conf,\n                 .build();\n \n         // initialize bookie client\n-        this.bookieClient = new BookieClient(conf, this.channelFactory, this.mainWorkerPool, statsLogger);\n+        this.bookieClient = new BookieClient(conf, this.eventLoopGroup, this.mainWorkerPool, statsLogger);\n         this.bookieWatcher = new BookieWatcher(conf, this.scheduler, this.placementPolicy, this);\n         if (conf.getDiskWeightBasedPlacementEnabled()) {\n             LOG.info(\"Weighted ledger placement enabled\");\n@@ -1178,8 +1177,8 @@ public void close() throws InterruptedException, BKException {\n         if (ownTimer) {\n             requestTimer.stop();\n         }\n-        if (ownChannelFactory) {\n-            channelFactory.releaseExternalResources();\n+        if (ownEventLoopGroup) {\n+            eventLoopGroup.shutdownGracefully();\n         }\n         if (ownZKHandle) {\n             zk.close();\n@@ -1255,4 +1254,20 @@ private final void initOpLoggers(StatsLogger stats) {\n     OpStatsLogger getAddOpLogger() { return addOpLogger; }\n     OpStatsLogger getWriteLacOpLogger() { return writeLacOpLogger; }\n     OpStatsLogger getReadLacOpLogger() { return readLacOpLogger; }\n+\n+    static EventLoopGroup getDefaultEventLoopGroup() {\n+        ThreadFactory threadFactory = new ThreadFactoryBuilder().setNameFormat(\"bookkeeper-io-%s\").build();\n+        final int numThreads = Runtime.getRuntime().availableProcessors() * 2;\n+\n+        if (SystemUtils.IS_OS_LINUX) {\n+            try {\n+                return new EpollEventLoopGroup(numThreads, threadFactory);\n+            } catch (Throwable t) {\n+                LOG.warn(\"Could not use Netty Epoll event loop for bookie server: {}\", t.getMessage());\n+                return new NioEventLoopGroup(numThreads, threadFactory);\n+            }\n+        } else {\n+            return new NioEventLoopGroup(numThreads, threadFactory);\n+        }\n+    }\n }"},{"sha":"25a0f61bfd1294d254527699e9630edb426c545f","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/CRC32DigestManager.java","status":"modified","additions":6,"deletions":8,"changes":14,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FCRC32DigestManager.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FCRC32DigestManager.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FCRC32DigestManager.java?ref=74f795136c1fff3badb29fc982d0cc2d43096b45","patch":"@@ -19,7 +19,8 @@\n */\n \n \n-import java.nio.ByteBuffer;\n+import io.netty.buffer.ByteBuf;\n+\n import java.util.zip.CRC32;\n \n class CRC32DigestManager extends DigestManager {\n@@ -40,16 +41,13 @@ int getMacCodeLength() {\n     }\n \n     @Override\n-    byte[] getValueAndReset() {\n-        byte[] value = new byte[8];\n-        ByteBuffer buf = ByteBuffer.wrap(value);\n-        buf.putLong(crc.get().getValue());\n+    void populateValueAndReset(ByteBuf buf) {\n+        buf.writeLong(crc.get().getValue());\n         crc.get().reset();\n-        return value;\n     }\n \n     @Override\n-    void update(byte[] data, int offset, int length) {\n-        crc.get().update(data, offset, length);\n+    void update(ByteBuf data) {\n+        crc.get().update(data.nioBuffer());\n     }\n }"},{"sha":"7c3d46fd5b55ce67fe91cfa1a06d2e11a3d895e0","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/DefaultEnsemblePlacementPolicy.java","status":"modified","additions":2,"deletions":1,"changes":3,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FDefaultEnsemblePlacementPolicy.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FDefaultEnsemblePlacementPolicy.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FDefaultEnsemblePlacementPolicy.java?ref=74f795136c1fff3badb29fc982d0cc2d43096b45","patch":"@@ -28,6 +28,8 @@\n \n import com.google.common.base.Optional;\n \n+import io.netty.util.HashedWheelTimer;\n+\n import org.apache.bookkeeper.client.BKException.BKNotEnoughBookiesException;\n import org.apache.bookkeeper.client.BookieInfoReader.BookieInfo;\n import org.apache.bookkeeper.client.WeightedRandomSelection.WeightedObject;\n@@ -37,7 +39,6 @@\n import org.apache.bookkeeper.net.DNSToSwitchMapping;\n import org.apache.bookkeeper.stats.StatsLogger;\n import org.apache.commons.collections.CollectionUtils;\n-import org.jboss.netty.util.HashedWheelTimer;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n "},{"sha":"396e6d956b42fc8c2236591fe6475f23b84dae81","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/DigestManager.java","status":"modified","additions":56,"deletions":60,"changes":116,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FDigestManager.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FDigestManager.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FDigestManager.java?ref=74f795136c1fff3badb29fc982d0cc2d43096b45","patch":"@@ -18,16 +18,18 @@\n  * limitations under the License.\n  */\n \n-import java.nio.ByteBuffer;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufInputStream;\n+import io.netty.buffer.PooledByteBufAllocator;\n+import io.netty.buffer.Unpooled;\n+\n import java.security.GeneralSecurityException;\n \n import org.apache.bookkeeper.client.BKException.BKDigestMatchException;\n import org.apache.bookkeeper.client.BookKeeper.DigestType;\n+import org.apache.bookkeeper.util.DoubleByteBuf;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n-import org.jboss.netty.buffer.ChannelBuffer;\n-import org.jboss.netty.buffer.ChannelBufferInputStream;\n-import org.jboss.netty.buffer.ChannelBuffers;\n \n /**\n  * This class takes an entry, attaches a digest to it and packages it with relevant\n@@ -47,11 +49,12 @@ abstract class DigestManager {\n     abstract int getMacCodeLength();\n \n     void update(byte[] data) {\n-        update(data, 0, data.length);\n+        update(Unpooled.wrappedBuffer(data, 0, data.length));\n     }\n \n-    abstract void update(byte[] data, int offset, int length);\n-    abstract byte[] getValueAndReset();\n+    abstract void update(ByteBuf buffer);\n+\n+    abstract void populateValueAndReset(ByteBuf buffer);\n \n     final int macCodeLength;\n \n@@ -81,26 +84,21 @@ static DigestManager instantiate(long ledgerId, byte[] passwd, DigestType digest\n      * @return\n      */\n \n-    public ChannelBuffer computeDigestAndPackageForSending(long entryId, long lastAddConfirmed, long length, byte[] data, int doffset, int dlength) {\n-\n-        byte[] bufferArray = new byte[METADATA_LENGTH + macCodeLength];\n-        ByteBuffer buffer = ByteBuffer.wrap(bufferArray);\n-        buffer.putLong(ledgerId);\n-        buffer.putLong(entryId);\n-        buffer.putLong(lastAddConfirmed);\n-        buffer.putLong(length);\n-        buffer.flip();\n+    public ByteBuf computeDigestAndPackageForSending(long entryId, long lastAddConfirmed, long length, byte[] data,\n+            int doffset, int dlength) {\n+        ByteBuf headersBuffer = PooledByteBufAllocator.DEFAULT.buffer(METADATA_LENGTH + macCodeLength);\n+        headersBuffer.writeLong(ledgerId);\n+        headersBuffer.writeLong(entryId);\n+        headersBuffer.writeLong(lastAddConfirmed);\n+        headersBuffer.writeLong(length);\n \n-        update(buffer.array(), 0, METADATA_LENGTH);\n-        update(data, doffset, dlength);\n-        byte[] digest = getValueAndReset();\n+        ByteBuf dataBuffer = Unpooled.wrappedBuffer(data, doffset, dlength);\n \n-        buffer.limit(buffer.capacity());\n-        buffer.position(METADATA_LENGTH);\n-        buffer.put(digest);\n-        buffer.flip();\n+        update(headersBuffer);\n+        update(dataBuffer);\n+        populateValueAndReset(headersBuffer);\n \n-        return ChannelBuffers.wrappedBuffer(ChannelBuffers.wrappedBuffer(buffer), ChannelBuffers.wrappedBuffer(data, doffset, dlength));\n+        return DoubleByteBuf.get(headersBuffer, dataBuffer);\n     }\n \n     /**\n@@ -110,57 +108,50 @@ public ChannelBuffer computeDigestAndPackageForSending(long entryId, long lastAd\n      * @return\n      */\n \n-    public ChannelBuffer computeDigestAndPackageForSendingLac(long lac) {\n+    public ByteBuf computeDigestAndPackageForSendingLac(long lac) {\n+        ByteBuf headersBuffer = PooledByteBufAllocator.DEFAULT.buffer(LAC_METADATA_LENGTH + macCodeLength);\n+        headersBuffer.writeLong(ledgerId);\n+        headersBuffer.writeLong(lac);\n \n-        byte[] bufferArray = new byte[LAC_METADATA_LENGTH + macCodeLength];\n-        ByteBuffer buffer = ByteBuffer.wrap(bufferArray);\n-        buffer.putLong(ledgerId);\n-        buffer.putLong(lac);\n-        buffer.flip();\n+        update(headersBuffer);\n+        populateValueAndReset(headersBuffer);\n \n-        update(buffer.array(), 0, LAC_METADATA_LENGTH);\n-        byte[] digest = getValueAndReset();\n-\n-        buffer.limit(buffer.capacity());\n-        buffer.position(LAC_METADATA_LENGTH);\n-        buffer.put(digest);\n-        buffer.flip();\n-\n-        return ChannelBuffers.wrappedBuffer(ChannelBuffers.wrappedBuffer(buffer));\n+        return headersBuffer;\n     }\n \n-    private void verifyDigest(ChannelBuffer dataReceived) throws BKDigestMatchException {\n+    private void verifyDigest(ByteBuf dataReceived) throws BKDigestMatchException {\n         verifyDigest(LedgerHandle.INVALID_ENTRY_ID, dataReceived, true);\n     }\n \n-    private void verifyDigest(long entryId, ChannelBuffer dataReceived) throws BKDigestMatchException {\n+    private void verifyDigest(long entryId, ByteBuf dataReceived) throws BKDigestMatchException {\n         verifyDigest(entryId, dataReceived, false);\n     }\n \n-    private void verifyDigest(long entryId, ChannelBuffer dataReceived, boolean skipEntryIdCheck)\n+    private void verifyDigest(long entryId, ByteBuf dataReceived, boolean skipEntryIdCheck)\n             throws BKDigestMatchException {\n \n-        ByteBuffer dataReceivedBuffer = dataReceived.toByteBuffer();\n-        byte[] digest;\n-\n         if ((METADATA_LENGTH + macCodeLength) > dataReceived.readableBytes()) {\n             logger.error(\"Data received is smaller than the minimum for this digest type. \"\n                     + \" Either the packet it corrupt, or the wrong digest is configured. \"\n                     + \" Digest type: {}, Packet Length: {}\",\n                     this.getClass().getName(), dataReceived.readableBytes());\n             throw new BKDigestMatchException();\n         }\n-        update(dataReceivedBuffer.array(), dataReceivedBuffer.position(), METADATA_LENGTH);\n+        update(dataReceived.slice(0, METADATA_LENGTH));\n \n         int offset = METADATA_LENGTH + macCodeLength;\n-        update(dataReceivedBuffer.array(), dataReceivedBuffer.position() + offset, dataReceived.readableBytes() - offset);\n-        digest = getValueAndReset();\n+        update(dataReceived.slice(offset, dataReceived.readableBytes() - offset));\n \n-        for (int i = 0; i < digest.length; i++) {\n-            if (digest[i] != dataReceived.getByte(METADATA_LENGTH + i)) {\n+        ByteBuf digest = PooledByteBufAllocator.DEFAULT.buffer(macCodeLength);\n+        populateValueAndReset(digest);\n+\n+        try {\n+            if (digest.compareTo(dataReceived.slice(METADATA_LENGTH, macCodeLength)) != 0) {\n                 logger.error(\"Mac mismatch for ledger-id: \" + ledgerId + \", entry-id: \" + entryId);\n                 throw new BKDigestMatchException();\n             }\n+        } finally {\n+            digest.release();\n         }\n \n         long actualLedgerId = dataReceived.readLong();\n@@ -180,24 +171,29 @@ private void verifyDigest(long entryId, ChannelBuffer dataReceived, boolean skip\n \n     }\n \n-    long verifyDigestAndReturnLac(ChannelBuffer dataReceived) throws BKDigestMatchException{\n-        ByteBuffer dataReceivedBuffer = dataReceived.toByteBuffer();\n-        byte[] digest;\n+    long verifyDigestAndReturnLac(ByteBuf dataReceived) throws BKDigestMatchException{\n         if ((LAC_METADATA_LENGTH + macCodeLength) > dataReceived.readableBytes()) {\n             logger.error(\"Data received is smaller than the minimum for this digest type.\"\n                     + \" Either the packet it corrupt, or the wrong digest is configured. \"\n                     + \" Digest type: {}, Packet Length: {}\",\n                     this.getClass().getName(), dataReceived.readableBytes());\n             throw new BKDigestMatchException();\n         }\n-        update(dataReceivedBuffer.array(), dataReceivedBuffer.position(), LAC_METADATA_LENGTH);\n-        digest = getValueAndReset();\n-        for (int i = 0; i < digest.length; i++) {\n-            if (digest[i] != dataReceived.getByte(LAC_METADATA_LENGTH + i)) {\n+\n+        update(dataReceived.slice(0, LAC_METADATA_LENGTH));\n+\n+        ByteBuf digest = PooledByteBufAllocator.DEFAULT.buffer(macCodeLength);\n+        try {\n+            populateValueAndReset(digest);\n+\n+            if (digest.compareTo(dataReceived.slice(LAC_METADATA_LENGTH, macCodeLength)) != 0) {\n                 logger.error(\"Mac mismatch for ledger-id LAC: \" + ledgerId);\n                 throw new BKDigestMatchException();\n             }\n+        } finally {\n+            digest.release();\n         }\n+\n         long actualLedgerId = dataReceived.readLong();\n         long lac = dataReceived.readLong();\n         if (actualLedgerId != ledgerId) {\n@@ -216,11 +212,11 @@ long verifyDigestAndReturnLac(ChannelBuffer dataReceived) throws BKDigestMatchEx\n      * @return\n      * @throws BKDigestMatchException\n      */\n-    ChannelBufferInputStream verifyDigestAndReturnData(long entryId, ChannelBuffer dataReceived)\n+    ByteBufInputStream verifyDigestAndReturnData(long entryId, ByteBuf dataReceived)\n             throws BKDigestMatchException {\n         verifyDigest(entryId, dataReceived);\n         dataReceived.readerIndex(METADATA_LENGTH + macCodeLength);\n-        return new ChannelBufferInputStream(dataReceived);\n+        return new ByteBufInputStream(dataReceived);\n     }\n \n     static class RecoveryData {\n@@ -234,7 +230,7 @@ public RecoveryData(long lastAddConfirmed, long length) {\n \n     }\n \n-    RecoveryData verifyDigestAndReturnLastConfirmed(ChannelBuffer dataReceived) throws BKDigestMatchException {\n+    RecoveryData verifyDigestAndReturnLastConfirmed(ByteBuf dataReceived) throws BKDigestMatchException {\n         verifyDigest(dataReceived);\n         dataReceived.readerIndex(8);\n "},{"sha":"af49fa1466a223dc33b3538943cab60839c184c2","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/EnsemblePlacementPolicy.java","status":"modified","additions":2,"deletions":1,"changes":3,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FEnsemblePlacementPolicy.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FEnsemblePlacementPolicy.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FEnsemblePlacementPolicy.java?ref=74f795136c1fff3badb29fc982d0cc2d43096b45","patch":"@@ -25,14 +25,15 @@\n \n import com.google.common.base.Optional;\n \n+import io.netty.util.HashedWheelTimer;\n+\n import org.apache.bookkeeper.client.BKException.BKNotEnoughBookiesException;\n import org.apache.bookkeeper.client.BookieInfoReader.BookieInfo;\n import org.apache.bookkeeper.conf.ClientConfiguration;\n import org.apache.bookkeeper.feature.FeatureProvider;\n import org.apache.bookkeeper.net.BookieSocketAddress;\n import org.apache.bookkeeper.net.DNSToSwitchMapping;\n import org.apache.bookkeeper.stats.StatsLogger;\n-import org.jboss.netty.util.HashedWheelTimer;\n \n /**\n  * Encapsulation of the algorithm that selects a number of bookies from the cluster as an ensemble for storing"},{"sha":"d4a12e64b2bc88311e42b875c2ac7ca5080d6118","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ExplicitLacFlushPolicy.java","status":"modified","additions":3,"deletions":3,"changes":6,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FExplicitLacFlushPolicy.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FExplicitLacFlushPolicy.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FExplicitLacFlushPolicy.java?ref=74f795136c1fff3badb29fc982d0cc2d43096b45","patch":"@@ -26,10 +26,11 @@\n \n import org.apache.bookkeeper.client.LedgerHandle.LastAddConfirmedCallback;\n import org.apache.bookkeeper.util.SafeRunnable;\n-import org.jboss.netty.buffer.ChannelBuffer;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import io.netty.buffer.ByteBuf;\n+\n interface ExplicitLacFlushPolicy {\n     void stopExplicitLacFlush();\n \n@@ -129,8 +130,7 @@ void asyncExplicitLacFlush(final long explicitLac) {\n                 lh.bk.mainWorkerPool.submit(new SafeRunnable() {\n                     @Override\n                     public void safeRun() {\n-                        ChannelBuffer toSend = lh.macManager\n-                                .computeDigestAndPackageForSendingLac(lh.getLastAddConfirmed());\n+                        ByteBuf toSend = lh.macManager.computeDigestAndPackageForSendingLac(lh.getLastAddConfirmed());\n                         op.initiate(toSend);\n                     }\n                 });"},{"sha":"4266c90560f7a75a6f710b40cd648d8d82953bb1","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerChecker.java","status":"modified","additions":4,"deletions":3,"changes":7,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FLedgerChecker.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FLedgerChecker.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FLedgerChecker.java?ref=74f795136c1fff3badb29fc982d0cc2d43096b45","patch":"@@ -19,6 +19,8 @@\n  */\n package org.apache.bookkeeper.client;\n \n+import io.netty.buffer.ByteBuf;\n+\n import java.util.ArrayList;\n import java.util.HashSet;\n import java.util.Map;\n@@ -31,7 +33,6 @@\n import org.apache.bookkeeper.proto.BookieClient;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ReadEntryCallback;\n-import org.jboss.netty.buffer.ChannelBuffer;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -66,7 +67,7 @@ private static class ReadManyEntriesCallback implements ReadEntryCallback {\n         }\n \n         public void readEntryComplete(int rc, long ledgerId, long entryId,\n-                ChannelBuffer buffer, Object ctx) {\n+                ByteBuf buffer, Object ctx) {\n             if (rc == BKException.Code.OK) {\n                 if (numEntries.decrementAndGet() == 0\n                         && !completed.getAndSet(true)) {\n@@ -126,7 +127,7 @@ private static class EntryExistsCallback implements ReadEntryCallback {\n         }\n \n         public void readEntryComplete(int rc, long ledgerId, long entryId,\n-                                      ChannelBuffer buffer, Object ctx) {\n+                                      ByteBuf buffer, Object ctx) {\n             if (BKException.Code.NoSuchEntryException != rc &&\n                 BKException.Code.NoSuchLedgerExistsException != rc) {\n                 entryMayExist.set(true);"},{"sha":"6502e054161d590629743fb466c42ab1cf90e55b","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerEntry.java","status":"modified","additions":3,"deletions":2,"changes":5,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FLedgerEntry.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FLedgerEntry.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FLedgerEntry.java?ref=74f795136c1fff3badb29fc982d0cc2d43096b45","patch":"@@ -21,12 +21,13 @@\n  *\n  */\n \n+import io.netty.buffer.ByteBufInputStream;\n+\n import java.io.IOException;\n import java.io.InputStream;\n \n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n-import org.jboss.netty.buffer.ChannelBufferInputStream;\n \n /**\n  * Ledger entry. Its a simple tuple containing the ledger id, the entry-id, and\n@@ -40,7 +41,7 @@ public class LedgerEntry {\n     long ledgerId;\n     long entryId;\n     long length;\n-    ChannelBufferInputStream entryDataStream;\n+    ByteBufInputStream entryDataStream;\n \n     LedgerEntry(long lId, long eId) {\n         this.ledgerId = lId;"},{"sha":"0522d508f97215cedc8f4f7a2b481d39649275f1","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerFragmentReplicator.java","status":"modified","additions":3,"deletions":3,"changes":6,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FLedgerFragmentReplicator.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FLedgerFragmentReplicator.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FLedgerFragmentReplicator.java?ref=74f795136c1fff3badb29fc982d0cc2d43096b45","patch":"@@ -19,6 +19,8 @@\n  */\n package org.apache.bookkeeper.client;\n \n+import io.netty.buffer.ByteBuf;\n+\n import java.util.ArrayList;\n import java.util.Enumeration;\n import java.util.HashSet;\n@@ -40,8 +42,6 @@\n import org.apache.bookkeeper.stats.StatsLogger;\n import org.apache.bookkeeper.util.OrderedSafeExecutor.OrderedSafeGenericCallback;\n import org.apache.zookeeper.AsyncCallback;\n-import org.apache.zookeeper.KeeperException.Code;\n-import org.jboss.netty.buffer.ChannelBuffer;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -281,7 +281,7 @@ public void readComplete(int rc, LedgerHandle lh,\n                 final long dataLength = data.length;\n                 numEntriesRead.inc();\n                 numBytesRead.registerSuccessfulValue(dataLength);\n-                ChannelBuffer toSend = lh.getDigestManager()\n+                ByteBuf toSend = lh.getDigestManager()\n                         .computeDigestAndPackageForSending(entryId,\n                                 lh.getLastAddConfirmed(), entry.getLength(),\n                                 data, 0, data.length);"},{"sha":"4ae4f48f402d870785204cc2dbf7b5db91c90a03","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","status":"modified","additions":18,"deletions":13,"changes":31,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FLedgerHandle.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FLedgerHandle.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FLedgerHandle.java?ref=74f795136c1fff3badb29fc982d0cc2d43096b45","patch":"@@ -21,6 +21,7 @@\n package org.apache.bookkeeper.client;\n \n import static com.google.common.base.Charsets.UTF_8;\n+import io.netty.buffer.ByteBuf;\n \n import java.security.GeneralSecurityException;\n import java.util.ArrayList;\n@@ -51,7 +52,6 @@\n import org.apache.bookkeeper.stats.Gauge;\n import org.apache.bookkeeper.util.OrderedSafeExecutor.OrderedSafeGenericCallback;\n import org.apache.bookkeeper.util.SafeRunnable;\n-import org.jboss.netty.buffer.ChannelBuffer;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -110,7 +110,7 @@ public class LedgerHandle implements AutoCloseable {\n \n         this.ledgerId = ledgerId;\n \n-        if (bk.getConf().getThrottleValue() > 0) { \n+        if (bk.getConf().getThrottleValue() > 0) {\n             this.throttler = RateLimiter.create(bk.getConf().getThrottleValue());\n         } else {\n             this.throttler = null;\n@@ -285,7 +285,7 @@ public void close()\n         asyncClose(new SyncCloseCallback(), counter);\n \n         explicitLacFlushPolicy.stopExplicitLacFlush();\n-        \n+\n         SynchCallbackUtils.waitForResult(counter);\n     }\n \n@@ -811,12 +811,16 @@ public String toString() {\n         }\n \n         try {\n-            bk.mainWorkerPool.submit(new SafeRunnable() {\n+            bk.mainWorkerPool.submitOrdered(ledgerId, new SafeRunnable() {\n                 @Override\n                 public void safeRun() {\n-                    ChannelBuffer toSend = macManager.computeDigestAndPackageForSending(\n-                                               entryId, lastAddConfirmed, currentLength, data, offset, length);\n-                    op.initiate(toSend, length);\n+                    ByteBuf toSend = macManager.computeDigestAndPackageForSending(entryId, lastAddConfirmed,\n+                            currentLength, data, offset, length);\n+                    try {\n+                        op.initiate(toSend, length);\n+                    } finally {\n+                        toSend.release();\n+                    }\n                 }\n                 @Override\n                 public String toString() {\n@@ -1024,7 +1028,7 @@ public long tryReadLastConfirmed() throws InterruptedException, BKException {\n      * returns the value of the last add confirmed from the metadata.\n      *\n      * @see #getLastAddConfirmed()\n-     * \n+     *\n      * @param cb\n      *          callback to return read explicit last confirmed\n      * @param ctx\n@@ -1049,7 +1053,7 @@ public void asyncReadExplicitLastConfirmed(final ReadLastConfirmedCallback cb, f\n             @Override\n             public void getLacComplete(int rc, long lac) {\n                 if (rc == BKException.Code.OK) {\n-                    // here we are trying to update lac only but not length \n+                    // here we are trying to update lac only but not length\n                     updateLastConfirmed(lac, 0);\n                     cb.readLastConfirmedComplete(rc, lac, ctx);\n                 } else {\n@@ -1133,6 +1137,7 @@ void sendAddSuccessCallbacks() {\n         while ((pendingAddOp = pendingAddOps.peek()) != null\n                && blockAddCompletions.get() == 0) {\n             if (!pendingAddOp.completed) {\n+                LOG.debug(\"pending add not completed: {}\", pendingAddOp);\n                 return;\n             }\n             // Check if it is the next entry in the sequence.\n@@ -1183,9 +1188,9 @@ ArrayList<BookieSocketAddress> replaceBookieInMetadata(final BookieSocketAddress\n \n     void handleBookieFailure(final BookieSocketAddress addr, final int bookieIndex) {\n         // If this is the first failure,\n-        // try to submit completed pendingAddOps before this failure. \n+        // try to submit completed pendingAddOps before this failure.\n         if (0 == blockAddCompletions.get()) {\n-            sendAddSuccessCallbacks(); \n+            sendAddSuccessCallbacks();\n         }\n \n         blockAddCompletions.incrementAndGet();\n@@ -1197,9 +1202,9 @@ void handleBookieFailure(final BookieSocketAddress addr, final int bookieIndex)\n                          addr, bookieIndex);\n                 blockAddCompletions.decrementAndGet();\n \n-                // Try to submit completed pendingAddOps, pending by this fix. \n+                // Try to submit completed pendingAddOps, pending by this fix.\n                 if (0 == blockAddCompletions.get()) {\n-                    sendAddSuccessCallbacks(); \n+                    sendAddSuccessCallbacks();\n                 }\n \n                 return;"},{"sha":"ffc469e433e8a22213c619d1e187ecf186001b76","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandleAdv.java","status":"modified","additions":4,"deletions":2,"changes":6,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FLedgerHandleAdv.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FLedgerHandleAdv.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FLedgerHandleAdv.java?ref=74f795136c1fff3badb29fc982d0cc2d43096b45","patch":"@@ -32,10 +32,11 @@\n import org.apache.bookkeeper.client.AsyncCallback.AddCallback;\n import org.apache.bookkeeper.client.BookKeeper.DigestType;\n import org.apache.bookkeeper.util.SafeRunnable;\n-import org.jboss.netty.buffer.ChannelBuffer;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import io.netty.buffer.ByteBuf;\n+\n /**\n  * Ledger Advanced handle extends {@link LedgerHandle} to provide API to add entries with\n  * user supplied entryIds. Through this interface Ledger Length may not be accurate wile the\n@@ -213,9 +214,10 @@ public String toString() {\n             bk.mainWorkerPool.submit(new SafeRunnable() {\n                 @Override\n                 public void safeRun() {\n-                    ChannelBuffer toSend = macManager.computeDigestAndPackageForSending(\n+                    ByteBuf toSend = macManager.computeDigestAndPackageForSending(\n                                                op.getEntryId(), lastAddConfirmed, currentLength, data, offset, length);\n                     op.initiate(toSend, length);\n+                    toSend.release();\n                 }\n             });\n         } catch (RejectedExecutionException e) {"},{"sha":"920143f2f5f8cd50aadbaccb39229980efbe41f1","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/MacDigestManager.java","status":"modified","additions":6,"deletions":4,"changes":10,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FMacDigestManager.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FMacDigestManager.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FMacDigestManager.java?ref=74f795136c1fff3badb29fc982d0cc2d43096b45","patch":"@@ -18,6 +18,8 @@\n * limitations under the License.\n */\n \n+import io.netty.buffer.ByteBuf;\n+\n import java.security.GeneralSecurityException;\n import java.security.MessageDigest;\n import java.security.NoSuchAlgorithmException;\n@@ -73,13 +75,13 @@ int getMacCodeLength() {\n \n \n     @Override\n-    byte[] getValueAndReset() {\n-        return mac.get().doFinal();\n+    void populateValueAndReset(ByteBuf buffer) {\n+        buffer.writeBytes(mac.get().doFinal());\n     }\n \n     @Override\n-    void update(byte[] data, int offset, int length) {\n-        mac.get().update(data, offset, length);\n+    void update(ByteBuf data) {\n+        mac.get().update(data.nioBuffer());\n     }\n \n "},{"sha":"940718991bc98e2285bf09b3550e0d73e03152fa","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingAddOp.java","status":"modified","additions":29,"deletions":5,"changes":34,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FPendingAddOp.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FPendingAddOp.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FPendingAddOp.java?ref=74f795136c1fff3badb29fc982d0cc2d43096b45","patch":"@@ -17,6 +17,11 @@\n  */\n package org.apache.bookkeeper.client;\n \n+import io.netty.buffer.ByteBuf;\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.Timeout;\n+import io.netty.util.TimerTask;\n+\n import java.util.HashSet;\n import java.util.Set;\n import java.util.concurrent.TimeUnit;\n@@ -28,9 +33,6 @@\n import org.apache.bookkeeper.stats.OpStatsLogger;\n import org.apache.bookkeeper.util.MathUtils;\n import org.apache.bookkeeper.util.SafeRunnable;\n-import org.jboss.netty.buffer.ChannelBuffer;\n-import org.jboss.netty.util.Timeout;\n-import org.jboss.netty.util.TimerTask;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import java.util.concurrent.RejectedExecutionException;\n@@ -48,7 +50,7 @@\n class PendingAddOp implements WriteCallback, TimerTask {\n     private final static Logger LOG = LoggerFactory.getLogger(PendingAddOp.class);\n \n-    ChannelBuffer toSend;\n+    ByteBuf toSend;\n     AddCallback cb;\n     Object ctx;\n     long entryId;\n@@ -66,6 +68,7 @@ class PendingAddOp implements WriteCallback, TimerTask {\n     Timeout timeout = null;\n \n     OpStatsLogger addOpLogger;\n+    boolean callbackTriggered = false;\n \n     PendingAddOp(LedgerHandle lh, AddCallback cb, Object ctx) {\n         this.lh = lh;\n@@ -153,6 +156,10 @@ void unsetSuccessAndSendWriteRequest(int bookieIndex) {\n             return;\n         }\n \n+        if (callbackTriggered) {\n+            return;\n+        }\n+\n         if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Unsetting success for ledger: \" + lh.ledgerId + \" entry: \" + entryId + \" bookie index: \"\n                       + bookieIndex);\n@@ -167,12 +174,20 @@ void unsetSuccessAndSendWriteRequest(int bookieIndex) {\n         sendWriteRequest(bookieIndex);\n     }\n \n-    void initiate(ChannelBuffer toSend, int entryLength) {\n+    void initiate(ByteBuf toSend, int entryLength) {\n+        if (callbackTriggered) {\n+            // this should only be true if the request was failed due to another request ahead in the pending queue,\n+            // so we can just ignore this request\n+            return;\n+        }\n+\n         if (timeoutSec > -1) {\n             this.timeout = lh.bk.bookieClient.scheduleTimeout(this, timeoutSec, TimeUnit.SECONDS);\n         }\n         this.requestTimeNanos = MathUtils.nowInNano();\n         this.toSend = toSend;\n+        // Retain the buffer until all writes are complete\n+        this.toSend.retain();\n         this.entryLength = entryLength;\n         for (int bookieIndex : writeSet) {\n             sendWriteRequest(bookieIndex);\n@@ -233,6 +248,14 @@ void submitCallback(final int rc) {\n         if (null != timeout) {\n             timeout.cancel();\n         }\n+\n+\n+        ReferenceCountUtil.release(toSend);\n+\n+        if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"Submit callback (lid:{}, eid: {}). rc:{}\", new Object[] { lh.getId(), entryId, rc });\n+        }\n+\n         long latencyNanos = MathUtils.elapsedNanos(requestTimeNanos);\n         if (rc != BKException.Code.OK) {\n             addOpLogger.registerFailedEvent(latencyNanos, TimeUnit.NANOSECONDS);\n@@ -242,6 +265,7 @@ void submitCallback(final int rc) {\n             addOpLogger.registerSuccessfulEvent(latencyNanos, TimeUnit.NANOSECONDS);\n         }\n         cb.addComplete(rc, lh, entryId, ctx);\n+        callbackTriggered = true;\n     }\n \n     @Override"},{"sha":"5b484619950a35dc92b19b96df04e0e149a7c7b0","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingReadLacOp.java","status":"modified","additions":4,"deletions":5,"changes":9,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FPendingReadLacOp.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FPendingReadLacOp.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FPendingReadLacOp.java?ref=74f795136c1fff3badb29fc982d0cc2d43096b45","patch":"@@ -19,13 +19,11 @@\n \n import org.apache.bookkeeper.client.BKException.BKDigestMatchException;\n import org.apache.bookkeeper.client.DigestManager.RecoveryData;\n-import org.apache.bookkeeper.net.BookieSocketAddress;\n-import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ReadEntryCallback;\n-import org.apache.bookkeeper.proto.BookieProtocol;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ReadLacCallback;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n-import org.jboss.netty.buffer.ChannelBuffer;\n+\n+import io.netty.buffer.ByteBuf;\n \n /**\n  * This represents a pending ReadLac operation.\n@@ -74,7 +72,8 @@ public void initiate() {\n     }\n \n     @Override\n-    public void readLacComplete(int rc, long ledgerId, final ChannelBuffer lacBuffer, final ChannelBuffer lastEntryBuffer, Object ctx) {\n+    public void readLacComplete(int rc, long ledgerId, final ByteBuf lacBuffer, final ByteBuf lastEntryBuffer,\n+            Object ctx) {\n         int bookieIndex = (Integer) ctx;\n         numResponsesPending--;\n         boolean heardValidResponse = false;"},{"sha":"57a84f8a0d8e9c004b680e1d36450c9fa43f81af","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingReadOp.java","status":"modified","additions":6,"deletions":5,"changes":11,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FPendingReadOp.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FPendingReadOp.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FPendingReadOp.java?ref=74f795136c1fff3badb29fc982d0cc2d43096b45","patch":"@@ -20,6 +20,9 @@\n  */\n package org.apache.bookkeeper.client;\n \n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufInputStream;\n+\n import java.util.ArrayList;\n import java.util.BitSet;\n import java.util.Enumeration;\n@@ -41,8 +44,6 @@\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ReadEntryCallback;\n import org.apache.bookkeeper.stats.OpStatsLogger;\n import org.apache.bookkeeper.util.MathUtils;\n-import org.jboss.netty.buffer.ChannelBuffer;\n-import org.jboss.netty.buffer.ChannelBufferInputStream;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -221,8 +222,8 @@ synchronized void logErrorAndReattemptRead(BookieSocketAddress host, String errM\n \n         // return true if we managed to complete the entry\n         // return false if the read entry is not complete or it is already completed before\n-        boolean complete(BookieSocketAddress host, final ChannelBuffer buffer) {\n-            ChannelBufferInputStream is;\n+        boolean complete(BookieSocketAddress host, final ByteBuf buffer) {\n+            ByteBufInputStream is;\n             try {\n                 is = lh.macManager.verifyDigestAndReturnData(entryId, buffer);\n             } catch (BKDigestMatchException e) {\n@@ -352,7 +353,7 @@ void sendReadTo(BookieSocketAddress to, LedgerEntryRequest entry) throws Interru\n     }\n \n     @Override\n-    public void readEntryComplete(int rc, long ledgerId, final long entryId, final ChannelBuffer buffer, Object ctx) {\n+    public void readEntryComplete(int rc, long ledgerId, final long entryId, final ByteBuf buffer, Object ctx) {\n         final ReadContext rctx = (ReadContext)ctx;\n         final LedgerEntryRequest entry = rctx.entry;\n "},{"sha":"45c389853f14575023c82f302981a0d6dc507702","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingWriteLacOp.java","status":"modified","additions":4,"deletions":3,"changes":7,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FPendingWriteLacOp.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FPendingWriteLacOp.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FPendingWriteLacOp.java?ref=74f795136c1fff3badb29fc982d0cc2d43096b45","patch":"@@ -25,10 +25,11 @@\n import org.apache.bookkeeper.net.BookieSocketAddress;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteLacCallback;\n import org.apache.bookkeeper.stats.OpStatsLogger;\n-import org.jboss.netty.buffer.ChannelBuffer;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import io.netty.buffer.ByteBuf;\n+\n /**\n  * This represents a pending WriteLac operation. When it has got\n  * success from Ack Quorum bookies, sends success back to the application,\n@@ -40,7 +41,7 @@\n  */\n class PendingWriteLacOp implements WriteLacCallback {\n     private final static Logger LOG = LoggerFactory.getLogger(PendingWriteLacOp.class);\n-    ChannelBuffer toSend;\n+    ByteBuf toSend;\n     AddLacCallback cb;\n     long lac;\n     Object ctx;\n@@ -74,7 +75,7 @@ void sendWriteLacRequest(int bookieIndex) {\n                 lac, toSend, this, bookieIndex);\n     }\n \n-    void initiate(ChannelBuffer toSend) {\n+    void initiate(ByteBuf toSend) {\n         this.toSend = toSend;\n         for (int bookieIndex: writeSet) {\n             sendWriteLacRequest(bookieIndex);"},{"sha":"a72e2ca84e202566a5a0276cc5f4fe27575b504c","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/RackawareEnsemblePlacementPolicy.java","status":"modified","additions":2,"deletions":1,"changes":3,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FRackawareEnsemblePlacementPolicy.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FRackawareEnsemblePlacementPolicy.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FRackawareEnsemblePlacementPolicy.java?ref=74f795136c1fff3badb29fc982d0cc2d43096b45","patch":"@@ -26,7 +26,8 @@\n import org.apache.bookkeeper.net.DNSToSwitchMapping;\n import org.apache.bookkeeper.net.Node;\n import org.apache.bookkeeper.stats.StatsLogger;\n-import org.jboss.netty.util.HashedWheelTimer;\n+\n+import io.netty.util.HashedWheelTimer;\n \n public class RackawareEnsemblePlacementPolicy extends RackawareEnsemblePlacementPolicyImpl\n         implements ITopologyAwareEnsemblePlacementPolicy<TopologyAwareEnsemblePlacementPolicy.BookieNode> {"},{"sha":"b5fdfed0817954f5eb3295fcdcf43bb6a00ca023","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/RackawareEnsemblePlacementPolicyImpl.java","status":"modified","additions":2,"deletions":1,"changes":3,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FRackawareEnsemblePlacementPolicyImpl.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FRackawareEnsemblePlacementPolicyImpl.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FRackawareEnsemblePlacementPolicyImpl.java?ref=74f795136c1fff3badb29fc982d0cc2d43096b45","patch":"@@ -48,14 +48,15 @@\n import org.apache.bookkeeper.stats.StatsLogger;\n import org.apache.bookkeeper.util.ReflectionUtils;\n import org.apache.commons.collections.CollectionUtils;\n-import org.jboss.netty.util.HashedWheelTimer;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n import com.google.common.base.Optional;\n import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.Sets;\n \n+import io.netty.util.HashedWheelTimer;\n+\n /**\n  * Simple rackware ensemble placement policy.\n  *"},{"sha":"e95a527415defc8f6beb47425fc99215fba8b3c8","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ReadLastConfirmedOp.java","status":"modified","additions":6,"deletions":2,"changes":8,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FReadLastConfirmedOp.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FReadLastConfirmedOp.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FReadLastConfirmedOp.java?ref=74f795136c1fff3badb29fc982d0cc2d43096b45","patch":"@@ -17,13 +17,15 @@\n  */\n package org.apache.bookkeeper.client;\n \n+import io.netty.buffer.ByteBuf;\n+import io.netty.util.ReferenceCountUtil;\n+\n import org.apache.bookkeeper.client.BKException.BKDigestMatchException;\n import org.apache.bookkeeper.client.DigestManager.RecoveryData;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ReadEntryCallback;\n import org.apache.bookkeeper.proto.BookieProtocol;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n-import org.jboss.netty.buffer.ChannelBuffer;\n \n /**\n  * This class encapsulated the read last confirmed operation.\n@@ -75,7 +77,7 @@ public void initiateWithFencing() {\n     }\n \n     public synchronized void readEntryComplete(final int rc, final long ledgerId, final long entryId,\n-            final ChannelBuffer buffer, final Object ctx) {\n+            final ByteBuf buffer, final Object ctx) {\n         int bookieIndex = (Integer) ctx;\n \n         numResponsesPending--;\n@@ -96,6 +98,8 @@ public synchronized void readEntryComplete(final int rc, final long ledgerId, fi\n             }\n         }\n \n+        ReferenceCountUtil.release(buffer);\n+\n         if (rc == BKException.Code.NoSuchLedgerExistsException || rc == BKException.Code.NoSuchEntryException) {\n             // this still counts as a valid response, e.g., if the client crashed without writing any entry\n             heardValidResponse = true;"},{"sha":"787a5e3986155c293cc9234fcc351884806a6bcf","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/RegionAwareEnsemblePlacementPolicy.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FRegionAwareEnsemblePlacementPolicy.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FRegionAwareEnsemblePlacementPolicy.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FRegionAwareEnsemblePlacementPolicy.java?ref=74f795136c1fff3badb29fc982d0cc2d43096b45","patch":"@@ -30,6 +30,7 @@\n \n import com.google.common.base.Optional;\n \n+import io.netty.util.HashedWheelTimer;\n \n import org.apache.bookkeeper.conf.ClientConfiguration;\n import org.apache.bookkeeper.feature.Feature;\n@@ -42,7 +43,6 @@\n import org.apache.bookkeeper.stats.StatsLogger;\n import org.apache.bookkeeper.util.BookKeeperConstants;\n import org.apache.commons.lang3.tuple.Pair;\n-import org.jboss.netty.util.HashedWheelTimer;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n "},{"sha":"c896e935a28da3ff4c378871f6986bd1151fcf7c","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/TryReadLastConfirmedOp.java","status":"modified","additions":3,"deletions":2,"changes":5,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FTryReadLastConfirmedOp.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FTryReadLastConfirmedOp.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FTryReadLastConfirmedOp.java?ref=74f795136c1fff3badb29fc982d0cc2d43096b45","patch":"@@ -21,10 +21,11 @@\n import org.apache.bookkeeper.client.ReadLastConfirmedOp.LastConfirmedDataCallback;\n import org.apache.bookkeeper.proto.BookieProtocol;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ReadEntryCallback;\n-import org.jboss.netty.buffer.ChannelBuffer;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import io.netty.buffer.ByteBuf;\n+\n import java.util.List;\n \n /**\n@@ -60,7 +61,7 @@ public void initiate() {\n     }\n \n     @Override\n-    public void readEntryComplete(int rc, long ledgerId, long entryId, ChannelBuffer buffer, Object ctx) {\n+    public void readEntryComplete(int rc, long ledgerId, long entryId, ByteBuf buffer, Object ctx) {\n         if (LOG.isTraceEnabled()) {\n             LOG.trace(\"TryReadLastConfirmed received response for (lid={}, eid={}) : {}\",\n                     new Object[] { ledgerId, entryId, rc });"},{"sha":"ad025f28cd23234c9d5118277acec7684a66fd51","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ClientConfiguration.java","status":"modified","additions":24,"deletions":0,"changes":24,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fconf%2FClientConfiguration.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fconf%2FClientConfiguration.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fconf%2FClientConfiguration.java?ref=74f795136c1fff3badb29fc982d0cc2d43096b45","patch":"@@ -51,6 +51,7 @@ public class ClientConfiguration extends AbstractConfiguration {\n \n     // NIO Parameters\n     protected final static String CLIENT_TCP_NODELAY = \"clientTcpNoDelay\";\n+    protected final static String CLIENT_SOCK_KEEPALIVE = \"clientSockKeepalive\";\n     protected final static String CLIENT_SENDBUFFER_SIZE = \"clientSendBufferSize\";\n     protected final static String CLIENT_RECEIVEBUFFER_SIZE = \"clientReceiveBufferSize\";\n     protected final static String CLIENT_WRITEBUFFER_LOW_WATER_MARK = \"clientWriteBufferLowWaterMark\";\n@@ -266,6 +267,29 @@ public ClientConfiguration setClientTcpNoDelay(boolean noDelay) {\n         return this;\n     }\n \n+    /**\n+     * get socket keepalive\n+     * \n+     * @return socket keepalive setting\n+     */\n+    public boolean getClientSockKeepalive() {\n+        return getBoolean(CLIENT_SOCK_KEEPALIVE, true);\n+    }\n+\n+    /**\n+     * Set socket keepalive setting.\n+     * \n+     * This setting is used to send keep-alive messages on connection-oriented sockets.\n+     * \n+     * @param keepalive\n+     *            KeepAlive setting\n+     * @return client configuration\n+     */\n+    public ClientConfiguration setClientSockKeepalive(boolean keepalive) {\n+        setProperty(CLIENT_SOCK_KEEPALIVE, Boolean.toString(keepalive));\n+        return this;\n+    }\n+\n     /**\n      * Get client netty channel send buffer size.\n      *"},{"sha":"ab8bbaac5e8146d721fba714b25632e4204ea110","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ServerConfiguration.java","status":"modified","additions":112,"deletions":1,"changes":113,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fconf%2FServerConfiguration.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fconf%2FServerConfiguration.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fconf%2FServerConfiguration.java?ref=74f795136c1fff3badb29fc982d0cc2d43096b45","patch":"@@ -23,7 +23,6 @@\n \n import com.google.common.annotations.Beta;\n \n-import com.google.common.collect.Lists;\n import org.apache.bookkeeper.stats.NullStatsProvider;\n import org.apache.bookkeeper.stats.StatsProvider;\n import org.apache.bookkeeper.util.BookKeeperConstants;\n@@ -90,6 +89,8 @@ public class ServerConfiguration extends AbstractConfiguration {\n     protected final static String ALLOW_STORAGE_EXPANSION = \"allowStorageExpansion\";\n     // NIO Parameters\n     protected final static String SERVER_TCP_NODELAY = \"serverTcpNoDelay\";\n+    protected final static String SERVER_SOCK_KEEPALIVE = \"serverSockKeepalive\";\n+    protected final static String SERVER_SOCK_LINGER = \"serverTcpLinger\";\n \n     // Zookeeper Parameters\n     protected final static String ZK_TIMEOUT = \"zkTimeout\";\n@@ -133,6 +134,11 @@ public class ServerConfiguration extends AbstractConfiguration {\n \n     protected final static String LEDGER_STORAGE_CLASS = \"ledgerStorageClass\";\n \n+    // Rx adaptive ByteBuf allocator parameters\n+    protected final static String BYTEBUF_ALLOCATOR_SIZE_INITIAL = \"byteBufAllocatorSizeInitial\";\n+    protected final static String BYTEBUF_ALLOCATOR_SIZE_MIN = \"byteBufAllocatorSizeMin\";\n+    protected final static String BYTEBUF_ALLOCATOR_SIZE_MAX = \"byteBufAllocatorSizeMax\";\n+\n     // Bookie auth provider factory class name\n     protected final static String BOOKIE_AUTH_PROVIDER_FACTORY_CLASS = \"bookieAuthProviderFactoryClass\";\n \n@@ -740,6 +746,54 @@ public ServerConfiguration setServerTcpNoDelay(boolean noDelay) {\n         return this;\n     }\n \n+    /**\n+     * Timeout to drain the socket on close.\n+     *\n+     * @return socket linger setting\n+     */\n+    public int getServerSockLinger() {\n+        return getInt(SERVER_SOCK_LINGER, 0);\n+    }\n+\n+    /**\n+     * Set socket linger timeout on close.\n+     * \n+     * When enabled, a close or shutdown will not return until all queued messages for the socket have been successfully\n+     * sent or the linger timeout has been reached. Otherwise, the call returns immediately and the closing is done in\n+     * the background.\n+     *\n+     * @param noDelay\n+     *            NoDelay setting\n+     * @return server configuration\n+     */\n+    public ServerConfiguration setServerSockLinger(int linger) {\n+        setProperty(SERVER_SOCK_LINGER, Integer.toString(linger));\n+        return this;\n+    }\n+\n+    /**\n+     * get socket keepalive\n+     * \n+     * @return socket keepalive setting\n+     */\n+    public boolean getServerSockKeepalive() {\n+        return getBoolean(SERVER_SOCK_KEEPALIVE, true);\n+    }\n+\n+    /**\n+     * Set socket keepalive setting.\n+     * \n+     * This setting is used to send keep-alive messages on connection-oriented sockets.\n+     * \n+     * @param keepalive\n+     *            KeepAlive setting\n+     * @return server configuration\n+     */\n+    public ServerConfiguration setServerSockKeepalive(boolean keepalive) {\n+        setProperty(SERVER_SOCK_KEEPALIVE, Boolean.toString(keepalive));\n+        return this;\n+    }\n+\n     /**\n      * Get zookeeper servers to connect\n      *\n@@ -1749,6 +1803,63 @@ public void validate() throws ConfigurationException {\n         }\n     }\n \n+    /**\n+     * Get Recv ByteBuf allocator initial buf size\n+     * \n+     * @return initial byteBuf size\n+     */\n+    public int getRecvByteBufAllocatorSizeInitial() {\n+        return getInt(BYTEBUF_ALLOCATOR_SIZE_INITIAL, 64 * 1024);\n+    }\n+\n+    /**\n+     * Set Recv ByteBuf allocator initial buf size\n+     * \n+     * @param size\n+     *            buffer size\n+     */\n+    public void setRecvByteBufAllocatorSizeInitial(int size) {\n+        setProperty(BYTEBUF_ALLOCATOR_SIZE_INITIAL, size);\n+    }\n+\n+    /**\n+     * Get Recv ByteBuf allocator min buf size\n+     * \n+     * @return min byteBuf size\n+     */\n+    public int getRecvByteBufAllocatorSizeMin() {\n+        return getInt(BYTEBUF_ALLOCATOR_SIZE_MIN, 64 * 1024);\n+    }\n+\n+    /**\n+     * Set Recv ByteBuf allocator min buf size\n+     * \n+     * @param size\n+     *            buffer size\n+     */\n+    public void setRecvByteBufAllocatorSizeMin(int size) {\n+        setProperty(BYTEBUF_ALLOCATOR_SIZE_MIN, size);\n+    }\n+\n+    /**\n+     * Get Recv ByteBuf allocator max buf size\n+     * \n+     * @return max byteBuf size\n+     */\n+    public int getRecvByteBufAllocatorSizeMax() {\n+        return getInt(BYTEBUF_ALLOCATOR_SIZE_MAX, 1 * 1024 * 1024);\n+    }\n+\n+    /**\n+     * Set Recv ByteBuf allocator max buf size\n+     * \n+     * @param size\n+     *            buffer size\n+     */\n+    public void setRecvByteBufAllocatorSizeMax(int size) {\n+        setProperty(BYTEBUF_ALLOCATOR_SIZE_MAX, size);\n+    }\n+\n     /*\n      * Set the bookie authentication provider factory class name.\n      * If this is not set, no authentication will be used"},{"sha":"382c22101fab75fd37588a7cd2dbba16d14da2be","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/net/BookieSocketAddress.java","status":"modified","additions":2,"deletions":1,"changes":3,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fnet%2FBookieSocketAddress.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fnet%2FBookieSocketAddress.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fnet%2FBookieSocketAddress.java?ref=74f795136c1fff3badb29fc982d0cc2d43096b45","patch":"@@ -23,8 +23,9 @@\n import java.net.InetSocketAddress;\n import java.net.UnknownHostException;\n \n+import io.netty.channel.local.LocalAddress;\n+\n import static org.apache.bookkeeper.util.BookKeeperConstants.COLON;\n-import org.jboss.netty.channel.local.LocalAddress;\n \n /**\n  * This is a data wrapper class that is an InetSocketAddress, it would use the hostname"},{"sha":"e4386348c1776f292c5aab05d40019243d9c00fa","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/net/StabilizeNetworkTopology.java","status":"modified","additions":4,"deletions":3,"changes":7,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fnet%2FStabilizeNetworkTopology.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fnet%2FStabilizeNetworkTopology.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fnet%2FStabilizeNetworkTopology.java?ref=74f795136c1fff3badb29fc982d0cc2d43096b45","patch":"@@ -18,12 +18,13 @@\n package org.apache.bookkeeper.net;\n \n import org.apache.bookkeeper.util.MathUtils;\n-import org.jboss.netty.util.HashedWheelTimer;\n-import org.jboss.netty.util.Timeout;\n-import org.jboss.netty.util.TimerTask;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import io.netty.util.HashedWheelTimer;\n+import io.netty.util.Timeout;\n+import io.netty.util.TimerTask;\n+\n import java.util.Set;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.ConcurrentMap;"},{"sha":"658753c9d37184741bdfe170a7b5570abc2aa2b1","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/processor/RequestProcessor.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fprocessor%2FRequestProcessor.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fprocessor%2FRequestProcessor.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fprocessor%2FRequestProcessor.java?ref=74f795136c1fff3badb29fc982d0cc2d43096b45","patch":"@@ -20,7 +20,7 @@\n  */\n package org.apache.bookkeeper.processor;\n \n-import org.jboss.netty.channel.Channel;\n+import io.netty.channel.Channel;\n \n public interface RequestProcessor {\n "},{"sha":"419e3aa08d6dec99609a41301e4b859fde3437a8","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/AuthHandler.java","status":"modified","additions":64,"deletions":77,"changes":141,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FAuthHandler.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FAuthHandler.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FAuthHandler.java?ref=74f795136c1fff3badb29fc982d0cc2d43096b45","patch":"@@ -21,26 +21,26 @@\n package org.apache.bookkeeper.proto;\n \n import com.google.protobuf.ByteString;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+\n import java.io.IOException;\n import java.net.SocketAddress;\n import java.util.Queue;\n import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.atomic.AtomicLong;\n+\n import org.apache.bookkeeper.auth.AuthCallbacks;\n import org.apache.bookkeeper.auth.AuthProviderFactoryFactory;\n import org.apache.bookkeeper.auth.AuthToken;\n-\n import org.apache.bookkeeper.auth.BookieAuthProvider;\n import org.apache.bookkeeper.auth.ClientAuthProvider;\n import org.apache.bookkeeper.client.BKException;\n-import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n import org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessage;\n-import org.jboss.netty.channel.Channel;\n-import org.jboss.netty.channel.ChannelHandlerContext;\n-import org.jboss.netty.channel.ChannelStateEvent;\n-import org.jboss.netty.channel.DefaultExceptionEvent;\n-import org.jboss.netty.channel.MessageEvent;\n-import org.jboss.netty.channel.SimpleChannelHandler;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.apache.bookkeeper.client.ClientConnectionPeer;\n@@ -49,7 +49,7 @@\n class AuthHandler {\n     static final Logger LOG = LoggerFactory.getLogger(AuthHandler.class);\n \n-    static class ServerSideHandler extends SimpleChannelHandler {\n+    static class ServerSideHandler extends ChannelInboundHandlerAdapter {\n         volatile boolean authenticated = false;\n         final BookieAuthProvider.Factory authProviderFactory;\n         final BookieConnectionPeer connectionPeer;\n@@ -62,86 +62,82 @@ static class ServerSideHandler extends SimpleChannelHandler {\n         }\n \n         @Override\n-        public void channelOpen(ChannelHandlerContext ctx,\n-                                ChannelStateEvent e) throws Exception {\n+        public void channelActive(ChannelHandlerContext ctx) throws Exception {\n             authProvider = authProviderFactory.newProvider(connectionPeer, new AuthHandshakeCompleteCallback());\n-            super.channelOpen(ctx, e);\n+            super.channelActive(ctx);\n         }\n \n         @Override\n-        public void channelClosed(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception {\n+        public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n             if (authProvider != null) {\n                 authProvider.close();\n             }\n-            super.channelClosed(ctx, e);\n+            super.channelInactive(ctx);\n         }\n \n         @Override\n-        public void messageReceived(ChannelHandlerContext ctx,\n-                                    MessageEvent e)\n-                throws Exception {\n+        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n             if (authProvider == null) {\n                 // close the channel, authProvider should only be\n                 // null if the other end of line is an InetSocketAddress\n                 // anything else is strange, and we don't want to deal\n                 // with it\n-                ctx.getChannel().close();\n+                ctx.channel().close();\n                 return;\n             }\n \n-            Object event = e.getMessage();\n             if (authenticated) {\n-                super.messageReceived(ctx, e);\n-            } else if (event instanceof BookieProtocol.AuthRequest) { // pre-PB-client\n-                BookieProtocol.AuthRequest req = (BookieProtocol.AuthRequest)event;\n+                super.channelRead(ctx, msg);\n+            } else if (msg instanceof BookieProtocol.AuthRequest) { // pre-PB-client\n+                BookieProtocol.AuthRequest req = (BookieProtocol.AuthRequest) msg;\n                 assert (req.getOpCode() == BookieProtocol.AUTH);\n-                if (checkAuthPlugin(req.getAuthMessage(), ctx.getChannel())) {\n+                if (checkAuthPlugin(req.getAuthMessage(), ctx.channel())) {\n                     byte[] payload = req\n                         .getAuthMessage()\n                         .getPayload()\n                         .toByteArray();\n                     authProvider.process(AuthToken.wrap(payload),\n-                                new AuthResponseCallbackLegacy(req, ctx.getChannel()));\n+                                new AuthResponseCallbackLegacy(req, ctx.channel()));\n                 } else {\n-                    ctx.getChannel().close();\n+                    ctx.channel().close();\n                 }\n-            } else if (event instanceof BookieProtocol.Request) {\n-                BookieProtocol.Request req = (BookieProtocol.Request)event;\n+            } else if (msg instanceof BookieProtocol.Request) {\n+                BookieProtocol.Request req = (BookieProtocol.Request) msg;\n                 if (req.getOpCode() == BookieProtocol.ADDENTRY) {\n-                    ctx.getChannel().write(\n+                    ctx.channel().writeAndFlush(\n                             new BookieProtocol.AddResponse(\n                                     req.getProtocolVersion(), BookieProtocol.EUA,\n                                     req.getLedgerId(), req.getEntryId()));\n                 } else if (req.getOpCode() == BookieProtocol.READENTRY) {\n-                    ctx.getChannel().write(\n+                    ctx.channel().writeAndFlush(\n                             new BookieProtocol.ReadResponse(\n                                     req.getProtocolVersion(), BookieProtocol.EUA,\n                                     req.getLedgerId(), req.getEntryId()));\n                 } else {\n-                    ctx.getChannel().close();\n+                    ctx.channel().close();\n                 }\n-            } else if (event instanceof BookkeeperProtocol.Request) { // post-PB-client\n-                BookkeeperProtocol.Request req = (BookkeeperProtocol.Request)event;\n+            } else if (msg instanceof BookkeeperProtocol.Request) { // post-PB-client\n+                BookkeeperProtocol.Request req = (BookkeeperProtocol.Request) msg;\n                 if (req.getHeader().getOperation() == BookkeeperProtocol.OperationType.AUTH\n                         && req.hasAuthRequest()\n-                        && checkAuthPlugin(req.getAuthRequest(), ctx.getChannel())) {\n+                        && checkAuthPlugin(req.getAuthRequest(), ctx.channel())) {\n                     byte[] payload = req\n                         .getAuthRequest()\n                         .getPayload()\n                         .toByteArray();\n                     authProvider.process(AuthToken.wrap(payload),\n-                                         new AuthResponseCallback(req, ctx.getChannel(), authProviderFactory.getPluginName()));\n+                                         new AuthResponseCallback(req, ctx.channel(), authProviderFactory.getPluginName()));\n                 } else {\n                     BookkeeperProtocol.Response.Builder builder\n                         = BookkeeperProtocol.Response.newBuilder()\n                         .setHeader(req.getHeader())\n                         .setStatus(BookkeeperProtocol.StatusCode.EUA);\n \n-                    ctx.getChannel().write(builder.build());\n+                    ctx.channel().writeAndFlush(builder.build());\n                 }\n             } else {\n                 // close the channel, junk coming over it\n-                ctx.getChannel().close();\n+                ctx.channel().close();\n             }\n         }\n \n@@ -177,7 +173,7 @@ public void operationComplete(int rc, AuthToken newam) {\n                         .setAuthPluginName(req.authMessage.getAuthPluginName())\n                         .setPayload(ByteString.copyFrom(newam.getData()))\n                         .build();\n-                channel.write(new BookieProtocol.AuthResponse(req.getProtocolVersion(),\n+                channel.writeAndFlush(new BookieProtocol.AuthResponse(req.getProtocolVersion(),\n                                                               message));\n             }\n         }\n@@ -202,7 +198,7 @@ public void operationComplete(int rc, AuthToken newam) {\n                     LOG.error(\"Error processing auth message, closing connection\");\n \n                     builder.setStatus(BookkeeperProtocol.StatusCode.EUA);\n-                    channel.write(builder.build());\n+                    channel.writeAndFlush(builder.build());\n                     channel.close();\n                     return;\n                 } else {\n@@ -214,7 +210,7 @@ public void operationComplete(int rc, AuthToken newam) {\n                             .build();\n                     builder.setStatus(BookkeeperProtocol.StatusCode.EOK)\n                         .setAuthResponse(message);\n-                    channel.write(builder.build());\n+                    channel.writeAndFlush(builder.build());\n                 }\n             }\n         }\n@@ -232,12 +228,12 @@ public void operationComplete(int rc, Void v) {\n         }\n     }\n \n-    static class ClientSideHandler extends SimpleChannelHandler {\n+    static class ClientSideHandler extends ChannelDuplexHandler {\n         volatile boolean authenticated = false;\n         final ClientAuthProvider.Factory authProviderFactory;\n         ClientAuthProvider authProvider;\n         final AtomicLong transactionIdGenerator;\n-        final Queue<MessageEvent> waitingForAuth = new ConcurrentLinkedQueue<MessageEvent>();\n+        final Queue<Object> waitingForAuth = new ConcurrentLinkedQueue<>();\n         final ClientConnectionPeer connectionPeer;\n \n         ClientSideHandler(ClientAuthProvider.Factory authProviderFactory,\n@@ -250,44 +246,38 @@ static class ClientSideHandler extends SimpleChannelHandler {\n         }\n \n         @Override\n-        public void channelConnected(ChannelHandlerContext ctx,\n-                                     ChannelStateEvent e)\n-                throws Exception {\n+        public void channelActive(ChannelHandlerContext ctx) throws Exception {\n             authProvider = authProviderFactory.newProvider(connectionPeer,\n                         new AuthHandshakeCompleteCallback(ctx));\n             authProvider.init(new AuthRequestCallback(ctx, authProviderFactory.getPluginName()));\n \n-            super.channelConnected(ctx, e);\n+            super.channelActive(ctx);\n         }\n \n         @Override\n-        public void channelClosed(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception {\n+        public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n             if (authProvider != null) {\n                 authProvider.close();\n             }\n-            super.channelClosed(ctx, e);\n+            super.channelInactive(ctx);\n         }\n \n         @Override\n-        public void messageReceived(ChannelHandlerContext ctx,\n-                                    MessageEvent e)\n-                throws Exception {\n+        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n             assert (authProvider != null);\n \n-            Object event = e.getMessage();\n-\n             if (authenticated) {\n-                super.messageReceived(ctx, e);\n-            } else if (event instanceof BookkeeperProtocol.Response) {\n-                BookkeeperProtocol.Response resp = (BookkeeperProtocol.Response)event;\n+                super.channelRead(ctx, msg);\n+            } else if (msg instanceof BookkeeperProtocol.Response) {\n+                BookkeeperProtocol.Response resp = (BookkeeperProtocol.Response) msg;\n                 if (resp.getHeader().getOperation() == BookkeeperProtocol.OperationType.AUTH) {\n                     if (resp.getStatus() != BookkeeperProtocol.StatusCode.EOK) {\n                         authenticationError(ctx, resp.getStatus().getNumber());\n                     } else {\n                         assert (resp.hasAuthResponse());\n                         BookkeeperProtocol.AuthMessage am = resp.getAuthResponse();\n                         if (AuthProviderFactoryFactory.authenticationDisabledPluginName.equals(am.getAuthPluginName())){\n-                            SocketAddress remote  = ctx.getChannel().getRemoteAddress();\n+                            SocketAddress remote  = ctx.channel().remoteAddress();\n                             LOG.info(\"Authentication is not enabled.\"\n                                 + \"Considering this client {0} authenticated\", remote);\n                             AuthHandshakeCompleteCallback authHandshakeCompleteCallback\n@@ -307,28 +297,26 @@ public void messageReceived(ChannelHandlerContext ctx,\n         }\n \n         @Override\n-        public void writeRequested(ChannelHandlerContext ctx,\n-                                   MessageEvent e)\n-                throws Exception {\n+        public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {\n             synchronized (this) {\n                 if (authenticated) {\n-                    super.writeRequested(ctx, e);\n-                } else if (e.getMessage() instanceof BookkeeperProtocol.Request) {\n+                    super.write(ctx, msg, promise);\n+                } else if (msg instanceof BookkeeperProtocol.Request) {\n                     // let auth messages through, queue the rest\n-                    BookkeeperProtocol.Request req = (BookkeeperProtocol.Request)e.getMessage();\n+                    BookkeeperProtocol.Request req = (BookkeeperProtocol.Request) msg;\n                     if (req.getHeader().getOperation()\n                             == BookkeeperProtocol.OperationType.AUTH) {\n-                        super.writeRequested(ctx, e);\n+                        super.write(ctx, msg, promise);\n                     } else {\n-                        waitingForAuth.add(e);\n+                        waitingForAuth.add(msg);\n                     }\n-                } else if (e.getMessage() instanceof BookieProtocol.Request) {\n+                } else if (msg instanceof BookieProtocol.Request) {\n                     // let auth messages through, queue the rest\n-                    BookieProtocol.Request req = (BookieProtocol.Request)e.getMessage();\n+                    BookieProtocol.Request req = (BookieProtocol.Request)msg;\n                     if (BookkeeperProtocol.OperationType.AUTH.getNumber() == req.getOpCode()) {\n-                        super.writeRequested(ctx, e);\n+                        super.write(ctx, msg, promise);\n                     } else {\n-                        waitingForAuth.add(e);\n+                        waitingForAuth.add(msg);\n                     }\n                 } // else just drop\n             }\n@@ -340,9 +328,7 @@ long newTxnId() {\n \n         void authenticationError(ChannelHandlerContext ctx, int errorCode) {\n             LOG.error(\"Error processing auth message, erroring connection {}\", errorCode);\n-            ctx.sendUpstream(new DefaultExceptionEvent(ctx.getChannel(),\n-                                     new AuthenticationException(\n-                                             \"Auth failed with error \" + errorCode)));\n+            ctx.fireExceptionCaught(new AuthenticationException(\"Auth failed with error \" + errorCode));\n         }\n \n         class AuthRequestCallback implements AuthCallbacks.GenericCallback<AuthToken> {\n@@ -351,7 +337,7 @@ class AuthRequestCallback implements AuthCallbacks.GenericCallback<AuthToken> {\n             String pluginName;\n \n             AuthRequestCallback(ChannelHandlerContext ctx, String pluginName) {\n-                this.channel = ctx.getChannel();\n+                this.channel = ctx.channel();\n                 this.ctx = ctx;\n                 this.pluginName = pluginName;\n             }\n@@ -377,7 +363,7 @@ public void operationComplete(int rc, AuthToken newam) {\n                     .setHeader(header)\n                     .setAuthRequest(message);\n \n-                channel.write(builder.build());\n+                channel.writeAndFlush(builder.build());\n             }\n         }\n \n@@ -392,10 +378,10 @@ public void operationComplete(int rc, Void v) {\n                 if (rc == BKException.Code.OK) {\n                     synchronized (this) {\n                         authenticated = true;\n-                        MessageEvent e = waitingForAuth.poll();\n-                        while (e != null) {\n-                            ctx.sendDownstream(e);\n-                            e = waitingForAuth.poll();\n+                        Object msg = waitingForAuth.poll();\n+                        while (msg != null) {\n+                            ctx.writeAndFlush(msg);\n+                            msg = waitingForAuth.poll();\n                         }\n                     }\n                 } else {\n@@ -406,6 +392,7 @@ public void operationComplete(int rc, Void v) {\n         }\n     }\n \n+    @SuppressWarnings(\"serial\")\n     static class AuthenticationException extends IOException {\n         AuthenticationException(String reason) {\n             super(reason);"},{"sha":"4fb08e48676b385a512f205afd5060329df03aad","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieClient.java","status":"modified","additions":38,"deletions":35,"changes":73,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookieClient.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookieClient.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookieClient.java?ref=74f795136c1fff3badb29fc982d0cc2d43096b45","patch":"@@ -48,20 +48,21 @@\n import org.apache.bookkeeper.stats.StatsLogger;\n import org.apache.bookkeeper.util.OrderedSafeExecutor;\n import org.apache.bookkeeper.util.SafeRunnable;\n-import org.jboss.netty.buffer.ChannelBuffer;\n-import org.jboss.netty.buffer.ChannelBuffers;\n-import org.jboss.netty.channel.socket.ClientSocketChannelFactory;\n-import org.jboss.netty.channel.socket.nio.NioClientSocketChannelFactory;\n-import org.jboss.netty.util.HashedWheelTimer;\n-import org.jboss.netty.util.Timeout;\n-import org.jboss.netty.util.TimerTask;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n import com.google.common.collect.Lists;\n import com.google.common.util.concurrent.ThreadFactoryBuilder;\n import com.google.protobuf.ExtensionRegistry;\n \n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.util.HashedWheelTimer;\n+import io.netty.util.Timeout;\n+import io.netty.util.TimerTask;\n+\n /**\n  * Implements the client-side part of the BookKeeper protocol.\n  *\n@@ -73,7 +74,7 @@ public class BookieClient implements PerChannelBookieClientFactory {\n     AtomicLong totalBytesOutstanding = new AtomicLong();\n \n     OrderedSafeExecutor executor;\n-    ClientSocketChannelFactory channelFactory;\n+    EventLoopGroup eventLoopGroup;\n     final ConcurrentHashMap<BookieSocketAddress, PerChannelBookieClientPool> channels =\n             new ConcurrentHashMap<BookieSocketAddress, PerChannelBookieClientPool>();\n     final HashedWheelTimer requestTimer;\n@@ -89,15 +90,15 @@ public class BookieClient implements PerChannelBookieClientFactory {\n \n     private final long bookieErrorThresholdPerInterval;\n \n-    public BookieClient(ClientConfiguration conf, ClientSocketChannelFactory channelFactory,\n+    public BookieClient(ClientConfiguration conf, EventLoopGroup eventLoopGroup,\n             OrderedSafeExecutor executor) throws IOException {\n-        this(conf, channelFactory, executor, NullStatsLogger.INSTANCE);\n+        this(conf, eventLoopGroup, executor, NullStatsLogger.INSTANCE);\n     }\n \n-    public BookieClient(ClientConfiguration conf, ClientSocketChannelFactory channelFactory,\n+    public BookieClient(ClientConfiguration conf, EventLoopGroup eventLoopGroup,\n                         OrderedSafeExecutor executor, StatsLogger statsLogger) throws IOException {\n         this.conf = conf;\n-        this.channelFactory = channelFactory;\n+        this.eventLoopGroup = eventLoopGroup;\n         this.executor = executor;\n         this.closed = false;\n         this.closeLock = new ReentrantReadWriteLock();\n@@ -141,7 +142,7 @@ public List<BookieSocketAddress> getFaultyBookies() {\n \n     @Override\n     public PerChannelBookieClient create(BookieSocketAddress address, PerChannelBookieClientPool pcbcPool) {\n-        return new PerChannelBookieClient(conf, executor, channelFactory, address, requestTimer, statsLogger,\n+        return new PerChannelBookieClient(conf, executor, eventLoopGroup, address, requestTimer, statsLogger,\n                 authProviderFactory, registry, pcbcPool);\n     }\n \n@@ -172,7 +173,7 @@ private PerChannelBookieClientPool lookupClient(BookieSocketAddress addr, Object\n     }\n \n     public void writeLac(final BookieSocketAddress addr, final long ledgerId, final byte[] masterKey,\n-            final long lac, final ChannelBuffer toSend, final WriteLacCallback cb, final Object ctx) {\n+            final long lac, final ByteBuf toSend, final WriteLacCallback cb, final Object ctx) {\n         closeLock.readLock().lock();\n         try {\n             final PerChannelBookieClientPool client = lookupClient(addr, lac);\n@@ -182,6 +183,7 @@ public void writeLac(final BookieSocketAddress addr, final long ledgerId, final\n                 return;\n             }\n \n+            toSend.retain();\n             client.obtain(new GenericCallback<PerChannelBookieClient>() {\n                 @Override\n                 public void operationComplete(final int rc, PerChannelBookieClient pcbc) {\n@@ -196,19 +198,20 @@ public void safeRun() {\n                         } catch (RejectedExecutionException re) {\n                             cb.writeLacComplete(getRc(BKException.Code.InterruptedException), ledgerId, addr, ctx);\n                         }\n-                        return;\n+                    } else {\n+                        pcbc.writeLac(ledgerId, masterKey, lac, toSend, cb, ctx);\n                     }\n-                    pcbc.writeLac(ledgerId, masterKey, lac, toSend, cb, ctx);\n+\n+                    toSend.release();\n                 }\n-            });\n+            }, ledgerId);\n         } finally {\n             closeLock.readLock().unlock();\n         }\n     }\n \n     public void addEntry(final BookieSocketAddress addr, final long ledgerId, final byte[] masterKey,\n-            final long entryId,\n-            final ChannelBuffer toSend, final WriteCallback cb, final Object ctx, final int options) {\n+            final long entryId, final ByteBuf toSend, final WriteCallback cb, final Object ctx, final int options) {\n         closeLock.readLock().lock();\n         try {\n             final PerChannelBookieClientPool client = lookupClient(addr, entryId);\n@@ -218,6 +221,10 @@ public void addEntry(final BookieSocketAddress addr, final long ledgerId, final\n                 return;\n             }\n \n+            // Retain the buffer, since the connection could be obtained after the PendingApp might have already\n+            // failed\n+            toSend.retain();\n+\n             client.obtain(new GenericCallback<PerChannelBookieClient>() {\n                 @Override\n                 public void operationComplete(final int rc, PerChannelBookieClient pcbc) {\n@@ -233,11 +240,12 @@ public void safeRun() {\n                             cb.writeComplete(getRc(BKException.Code.InterruptedException),\n                                     ledgerId, entryId, addr, ctx);\n                         }\n-                        return;\n+                    } else {\n+                        pcbc.addEntry(ledgerId, masterKey, entryId, toSend, cb, ctx, options);\n                     }\n-                    pcbc.addEntry(ledgerId, masterKey, entryId, toSend, cb, ctx, options);\n+                    toSend.release();\n                 }\n-            });\n+            }, ledgerId);\n         } finally {\n             closeLock.readLock().unlock();\n         }\n@@ -277,7 +285,7 @@ public void safeRun() {\n                     }\n                     pcbc.readEntryAndFenceLedger(ledgerId, masterKey, entryId, cb, ctx);\n                 }\n-            });\n+            }, ledgerId);\n         } finally {\n             closeLock.readLock().unlock();\n         }\n@@ -310,7 +318,7 @@ public void safeRun() {\n                     }\n                     pcbc.readLac(ledgerId, cb, ctx);\n                 }\n-            });\n+            }, ledgerId);\n         } finally {\n             closeLock.readLock().unlock();\n         }\n@@ -346,7 +354,7 @@ public void safeRun() {\n                     }\n                     pcbc.readEntry(ledgerId, entryId, cb, ctx);\n                 }\n-            });\n+            }, ledgerId);\n         } finally {\n             closeLock.readLock().unlock();\n         }\n@@ -379,7 +387,7 @@ public void safeRun() {\n                     }\n                     pcbc.getBookieInfo(requested, cb, ctx);\n                 }\n-            });\n+            }, requested);\n         } finally {\n             closeLock.readLock().unlock();\n         }\n@@ -458,26 +466,21 @@ public void writeComplete(int rc, long ledger, long entry, BookieSocketAddress a\n         Counter counter = new Counter();\n         byte hello[] = \"hello\".getBytes(UTF_8);\n         long ledger = Long.parseLong(args[2]);\n-        ThreadFactoryBuilder tfb = new ThreadFactoryBuilder();\n-        ClientSocketChannelFactory channelFactory = new NioClientSocketChannelFactory(\n-                Executors.newCachedThreadPool(tfb.setNameFormat(\n-                        \"BookKeeper-NIOBoss-%d\").build()),\n-                Executors.newCachedThreadPool(tfb.setNameFormat(\n-                        \"BookKeeper-NIOWorker-%d\").build()));\n+        EventLoopGroup eventLoopGroup = new NioEventLoopGroup(1);\n         OrderedSafeExecutor executor = OrderedSafeExecutor.newBuilder()\n                 .name(\"BookieClientWorker\")\n                 .numThreads(1)\n                 .build();\n-        BookieClient bc = new BookieClient(new ClientConfiguration(), channelFactory, executor);\n+        BookieClient bc = new BookieClient(new ClientConfiguration(), eventLoopGroup, executor);\n         BookieSocketAddress addr = new BookieSocketAddress(args[0], Integer.parseInt(args[1]));\n \n         for (int i = 0; i < 100000; i++) {\n             counter.inc();\n-            bc.addEntry(addr, ledger, new byte[0], i, ChannelBuffers.wrappedBuffer(hello), cb, counter, 0);\n+            bc.addEntry(addr, ledger, new byte[0], i, Unpooled.wrappedBuffer(hello), cb, counter, 0);\n         }\n         counter.wait(0);\n         System.out.println(\"Total = \" + counter.total());\n-        channelFactory.releaseExternalResources();\n+        eventLoopGroup.shutdownGracefully();\n         executor.shutdown();\n     }\n }"},{"sha":"cf7d41944e525032da4fd539710d0674d1a19bb0","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieNettyServer.java","status":"modified","additions":206,"deletions":75,"changes":281,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookieNettyServer.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookieNettyServer.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookieNettyServer.java?ref=74f795136c1fff3badb29fc982d0cc2d43096b45","patch":"@@ -21,36 +21,56 @@\n package org.apache.bookkeeper.proto;\n \n import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.apache.bookkeeper.bookie.Bookie;\n import org.apache.bookkeeper.bookie.BookieException;\n import org.apache.bookkeeper.conf.ServerConfiguration;\n import org.apache.bookkeeper.auth.BookieAuthProvider;\n import org.apache.bookkeeper.auth.AuthProviderFactoryFactory;\n import org.apache.bookkeeper.processor.RequestProcessor;\n+import org.apache.commons.lang.SystemUtils;\n import org.apache.zookeeper.KeeperException;\n-import org.jboss.netty.channel.Channel;\n-import org.jboss.netty.channel.ChannelHandlerContext;\n-import org.jboss.netty.channel.ChannelPipeline;\n-import org.jboss.netty.channel.ChannelPipelineFactory;\n-import org.jboss.netty.channel.ChannelStateEvent;\n-import org.jboss.netty.channel.Channels;\n-import org.jboss.netty.channel.SimpleChannelHandler;\n-import org.jboss.netty.channel.group.ChannelGroup;\n-import org.jboss.netty.channel.group.ChannelGroupFuture;\n-import org.jboss.netty.channel.group.DefaultChannelGroup;\n-import org.jboss.netty.handler.codec.frame.LengthFieldBasedFrameDecoder;\n-import org.jboss.netty.handler.codec.frame.LengthFieldPrepender;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import com.google.protobuf.ExtensionRegistry;\n+\n+import io.netty.bootstrap.ServerBootstrap;\n+import io.netty.buffer.PooledByteBufAllocator;\n+import io.netty.channel.AdaptiveRecvByteBufAllocator;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInboundHandler;\n+import io.netty.channel.ChannelInboundHandlerAdapter;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelOption;\n+import io.netty.channel.ChannelPipeline;\n+import io.netty.channel.DefaultEventLoopGroup;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.epoll.EpollEventLoopGroup;\n+import io.netty.channel.epoll.EpollServerSocketChannel;\n+import io.netty.channel.group.ChannelGroup;\n+import io.netty.channel.group.ChannelGroupFuture;\n+import io.netty.channel.group.DefaultChannelGroup;\n+import io.netty.channel.local.LocalChannel;\n+import io.netty.channel.local.LocalServerChannel;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.channel.socket.nio.NioServerSocketChannel;\n+import io.netty.handler.codec.LengthFieldBasedFrameDecoder;\n+import io.netty.handler.codec.LengthFieldPrepender;\n+\n import com.google.common.annotations.VisibleForTesting;\n import java.net.SocketAddress;\n-import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n-import java.util.List;\n import org.apache.bookkeeper.auth.BookKeeperPrincipal;\n import org.apache.bookkeeper.bookie.BookieConnectionPeer;\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+import org.apache.bookkeeper.net.BookieSocketAddress;\n \n /**\n  * Netty server for serving bookie requests\n@@ -61,12 +81,14 @@ class BookieNettyServer {\n \n     final int maxFrameSize;\n     final ServerConfiguration conf;\n-    final List<ChannelManager> channels = new ArrayList<>();\n+    final EventLoopGroup eventLoopGroup;\n+    final EventLoopGroup jvmEventLoopGroup;\n     final RequestProcessor requestProcessor;\n-    final ChannelGroup allChannels = new CleanupChannelGroup();\n     final AtomicBoolean isRunning = new AtomicBoolean(false);\n     final Object suspensionLock = new Object();\n-    boolean suspended = false;\n+    volatile boolean suspended = false;\n+    ChannelGroup allChannels;\n+    final BookieSocketAddress bookieAddress;\n \n     final BookieAuthProvider.Factory authProviderFactory;\n     final BookieProtoEncoding.ResponseEncoder responseEncoder;\n@@ -85,24 +107,42 @@ class BookieNettyServer {\n         requestDecoder = new BookieProtoEncoding.RequestDecoder(registry);\n \n         if (!conf.isDisableServerSocketBind()) {\n-            channels.add(new NioServerSocketChannelManager());\n+            ThreadFactory threadFactory = new ThreadFactoryBuilder().setNameFormat(\"bookie-io-%s\").build();\n+            final int numThreads = Runtime.getRuntime().availableProcessors() * 2;\n+\n+            EventLoopGroup eventLoopGroup;\n+            if (SystemUtils.IS_OS_LINUX) {\n+                try {\n+                    eventLoopGroup = new EpollEventLoopGroup(numThreads, threadFactory);\n+                } catch (ExceptionInInitializerError | NoClassDefFoundError | UnsatisfiedLinkError e) {\n+                    LOG.warn(\"Could not use Netty Epoll event loop for bookie server: {}\", e.getMessage());\n+                    eventLoopGroup = new NioEventLoopGroup(numThreads, threadFactory);\n+                }\n+            } else {\n+                eventLoopGroup = new NioEventLoopGroup(numThreads, threadFactory);\n+            }\n+\n+            this.eventLoopGroup = eventLoopGroup;\n+            allChannels = new CleanupChannelGroup(eventLoopGroup);\n+        } else {\n+            this.eventLoopGroup = null;\n         }\n+\n         if (conf.isEnableLocalTransport()) {\n-            channels.add(new VMLocalChannelManager());\n+            jvmEventLoopGroup = new DefaultEventLoopGroup();\n+            allChannels = new CleanupChannelGroup(jvmEventLoopGroup);\n+        } else {\n+            jvmEventLoopGroup = null;\n         }\n-        try {\n-            for (ChannelManager channel : channels) {\n-                Channel nettyChannel = channel.start(conf, new BookiePipelineFactory());\n-                allChannels.add(nettyChannel);\n-            }\n-        } catch (IOException bindError) {\n-            // clean up all the channels, if this constructor throws an exception the caller code will\n-            // not be able to call close(), leading to a resource leak \n-            for (ChannelManager channel : channels) {\n-                channel.close();\n-            }\n-            throw bindError;\n+\n+        bookieAddress = Bookie.getBookieAddress(conf);\n+        InetSocketAddress bindAddress;\n+        if (conf.getListeningInterface() == null) {\n+            bindAddress = new InetSocketAddress(conf.getBookiePort());\n+        } else {\n+            bindAddress = bookieAddress.getSocketAddress();\n         }\n+        listenOn(bindAddress, bookieAddress);\n     }\n \n     boolean isRunning() {\n@@ -113,19 +153,131 @@ boolean isRunning() {\n     void suspendProcessing() {\n         synchronized (suspensionLock) {\n             suspended = true;\n-            allChannels.setReadable(false).awaitUninterruptibly();\n+            for (Channel channel : allChannels) {\n+                // To suspend processing in the bookie, submit a task\n+                // that keeps the event loop busy until resume is\n+                // explicitely invoked\n+                channel.eventLoop().submit(() -> {\n+                    while (suspended && isRunning()) {\n+                        try {\n+                            Thread.sleep(10);\n+                        } catch (InterruptedException e) {\n+                        }\n+                    }\n+                });\n+            }\n         }\n     }\n \n     @VisibleForTesting\n     void resumeProcessing() {\n         synchronized (suspensionLock) {\n             suspended = false;\n-            allChannels.setReadable(true).awaitUninterruptibly();\n+            for (Channel channel : allChannels) {\n+                channel.config().setAutoRead(true);\n+            }\n             suspensionLock.notifyAll();\n         }\n     }\n \n+    private void listenOn(InetSocketAddress address, BookieSocketAddress bookieAddress) throws InterruptedException {\n+        if (!conf.isDisableServerSocketBind()) {\n+            ServerBootstrap bootstrap = new ServerBootstrap();\n+            bootstrap.childOption(ChannelOption.ALLOCATOR, new PooledByteBufAllocator(true));\n+            bootstrap.group(eventLoopGroup, eventLoopGroup);\n+            bootstrap.childOption(ChannelOption.TCP_NODELAY, conf.getServerTcpNoDelay());\n+            bootstrap.childOption(ChannelOption.SO_LINGER, conf.getServerSockLinger());\n+            bootstrap.childOption(ChannelOption.RCVBUF_ALLOCATOR,\n+                    new AdaptiveRecvByteBufAllocator(conf.getRecvByteBufAllocatorSizeMin(),\n+                            conf.getRecvByteBufAllocatorSizeInitial(), conf.getRecvByteBufAllocatorSizeMax()));\n+\n+            if (eventLoopGroup instanceof EpollEventLoopGroup) {\n+                bootstrap.channel(EpollServerSocketChannel.class);\n+            } else {\n+                bootstrap.channel(NioServerSocketChannel.class);\n+            }\n+\n+            bootstrap.childHandler(new ChannelInitializer<SocketChannel>() {\n+                @Override\n+                protected void initChannel(SocketChannel ch) throws Exception {\n+                    synchronized (suspensionLock) {\n+                        while (suspended) {\n+                            suspensionLock.wait();\n+                        }\n+                    }\n+\n+                    BookieSideConnectionPeerContextHandler contextHandler = new BookieSideConnectionPeerContextHandler();\n+                    ChannelPipeline pipeline = ch.pipeline();\n+\n+                    pipeline.addLast(\"lengthbaseddecoder\", new LengthFieldBasedFrameDecoder(maxFrameSize, 0, 4, 0, 4));\n+                    pipeline.addLast(\"lengthprepender\", new LengthFieldPrepender(4));\n+\n+                    pipeline.addLast(\"bookieProtoDecoder\", requestDecoder);\n+                    pipeline.addLast(\"bookieProtoEncoder\", responseEncoder);\n+                    pipeline.addLast(\"bookieAuthHandler\", new AuthHandler.ServerSideHandler(contextHandler.getConnectionPeer(), authProviderFactory));\n+\n+                    ChannelInboundHandler requestHandler = isRunning.get()\n+                            ? new BookieRequestHandler(conf, requestProcessor, allChannels) : new RejectRequestHandler();\n+                    pipeline.addLast(\"bookieRequestHandler\", requestHandler);\n+\n+                }\n+            });\n+\n+            // Bind and start to accept incoming connections\n+            bootstrap.bind(address.getAddress(), address.getPort()).sync();\n+        }\n+\n+        if (conf.isEnableLocalTransport()) {\n+            ServerBootstrap jvmBootstrap = new ServerBootstrap();\n+            jvmBootstrap.childOption(ChannelOption.ALLOCATOR, new PooledByteBufAllocator(true));\n+            jvmBootstrap.group(jvmEventLoopGroup, jvmEventLoopGroup);\n+            jvmBootstrap.childOption(ChannelOption.TCP_NODELAY, conf.getServerTcpNoDelay());\n+            jvmBootstrap.childOption(ChannelOption.SO_KEEPALIVE, conf.getServerSockKeepalive());\n+            jvmBootstrap.childOption(ChannelOption.SO_LINGER, conf.getServerSockLinger());\n+            jvmBootstrap.childOption(ChannelOption.RCVBUF_ALLOCATOR,\n+                    new AdaptiveRecvByteBufAllocator(conf.getRecvByteBufAllocatorSizeMin(),\n+                            conf.getRecvByteBufAllocatorSizeInitial(), conf.getRecvByteBufAllocatorSizeMax()));\n+\n+            if (jvmEventLoopGroup instanceof DefaultEventLoopGroup) {\n+                jvmBootstrap.channel(LocalServerChannel.class);\n+            } else if (jvmEventLoopGroup instanceof EpollEventLoopGroup) {\n+                jvmBootstrap.channel(EpollServerSocketChannel.class);\n+            } else {\n+                jvmBootstrap.channel(NioServerSocketChannel.class);\n+            }\n+\n+            jvmBootstrap.childHandler(new ChannelInitializer<LocalChannel>() {\n+                @Override\n+                protected void initChannel(LocalChannel ch) throws Exception {\n+                    synchronized (suspensionLock) {\n+                        while (suspended) {\n+                            suspensionLock.wait();\n+                        }\n+                    }\n+\n+                    BookieSideConnectionPeerContextHandler contextHandler = new BookieSideConnectionPeerContextHandler();\n+                    ChannelPipeline pipeline = ch.pipeline();\n+\n+                    pipeline.addLast(\"lengthbaseddecoder\", new LengthFieldBasedFrameDecoder(maxFrameSize, 0, 4, 0, 4));\n+                    pipeline.addLast(\"lengthprepender\", new LengthFieldPrepender(4));\n+\n+                    pipeline.addLast(\"bookieProtoDecoder\", requestDecoder);\n+                    pipeline.addLast(\"bookieProtoEncoder\", responseEncoder);\n+                    pipeline.addLast(\"bookieAuthHandler\", new AuthHandler.ServerSideHandler(contextHandler.getConnectionPeer(), authProviderFactory));\n+\n+                    ChannelInboundHandler requestHandler = isRunning.get()\n+                            ? new BookieRequestHandler(conf, requestProcessor, allChannels) : new RejectRequestHandler();\n+                    pipeline.addLast(\"bookieRequestHandler\", requestHandler);\n+\n+                }\n+            });\n+\n+            // use the same address 'name', so clients can find local Bookie still discovering them using ZK\n+            jvmBootstrap.bind(bookieAddress.getLocalAddress()).sync();\n+            LocalBookiesRegistry.registerLocalBookieAddress(bookieAddress);\n+        }\n+    }\n+\n     void start() {\n         isRunning.set(true);\n     }\n@@ -134,13 +286,23 @@ void shutdown() {\n         LOG.info(\"Shutting down BookieNettyServer\");\n         isRunning.set(false);\n         allChannels.close().awaitUninterruptibly();\n-        for (ChannelManager channel : channels) {\n-            channel.close();\n+\n+        if (eventLoopGroup != null) {\n+            try {\n+                eventLoopGroup.shutdownGracefully(0, 10, TimeUnit.MILLISECONDS).await();\n+            } catch (InterruptedException e) {\n+                /// OK\n+            }\n+        }\n+        if (jvmEventLoopGroup != null) {\n+            LocalBookiesRegistry.unregisterLocalBookieAddress(bookieAddress);\n+            jvmEventLoopGroup.shutdownGracefully();\n         }\n+\n         authProviderFactory.close();\n     }\n \n-    class BookieSideConnectionPeerContextHandler extends SimpleChannelHandler {\n+    class BookieSideConnectionPeerContextHandler extends ChannelInboundHandlerAdapter {\n \n         final BookieConnectionPeer connectionPeer;\n         volatile Channel channel;\n@@ -152,7 +314,7 @@ public BookieSideConnectionPeerContextHandler() {\n                 public SocketAddress getRemoteAddr() {\n                     Channel c = channel;\n                     if (c != null) {\n-                        return c.getRemoteAddress();\n+                        return c.remoteAddress();\n                     } else {\n                         return null;\n                     }\n@@ -191,56 +353,25 @@ public BookieConnectionPeer getConnectionPeer() {\n         }\n \n         @Override\n-        public void channelBound(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception {\n-            channel = ctx.getChannel();\n+        public void channelActive(ChannelHandlerContext ctx) throws Exception {\n+            channel = ctx.channel();\n         }\n \n     }\n \n-    class BookiePipelineFactory implements ChannelPipelineFactory {\n-\n-        public ChannelPipeline getPipeline() throws Exception {\n-            synchronized (suspensionLock) {\n-                while (suspended) {\n-                    suspensionLock.wait();\n-                }\n-            }\n-            BookieSideConnectionPeerContextHandler contextHandler = new BookieSideConnectionPeerContextHandler();\n-            ChannelPipeline pipeline = Channels.pipeline();\n-            pipeline.addLast(\"lengthbaseddecoder\",\n-                new LengthFieldBasedFrameDecoder(maxFrameSize, 0, 4, 0, 4));\n-            pipeline.addLast(\"lengthprepender\", new LengthFieldPrepender(4));\n-\n-            pipeline.addLast(\"bookieProtoDecoder\", requestDecoder);\n-            pipeline.addLast(\"bookieProtoEncoder\", responseEncoder);\n-            pipeline.addLast(\"bookieAuthHandler\",\n-                new AuthHandler.ServerSideHandler(contextHandler.getConnectionPeer(), authProviderFactory));\n-\n-            SimpleChannelHandler requestHandler = isRunning.get()\n-                ? new BookieRequestHandler(conf, requestProcessor, allChannels)\n-                : new RejectRequestHandler();\n-\n-            pipeline.addLast(\"bookieRequestHandler\", requestHandler);\n-            pipeline.addLast(\"contextHandler\", contextHandler);\n-            return pipeline;\n-        }\n-    }\n-\n-    private static class RejectRequestHandler extends SimpleChannelHandler {\n-\n+    private static class RejectRequestHandler extends ChannelInboundHandlerAdapter {\n         @Override\n-        public void channelOpen(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception {\n-            ctx.getChannel().close();\n+        public void channelActive(ChannelHandlerContext ctx) throws Exception {\n+            ctx.channel().close();\n         }\n-\n     }\n \n     private static class CleanupChannelGroup extends DefaultChannelGroup {\n \n         private AtomicBoolean closed = new AtomicBoolean(false);\n \n-        CleanupChannelGroup() {\n-            super(\"BookieChannelGroup\");\n+        public CleanupChannelGroup(EventLoopGroup eventLoopGroup) {\n+            super(\"BookieChannelGroup\", eventLoopGroup.next());\n         }\n \n         @Override"},{"sha":"148b31da397989dbb491c6e3ae3d05010bd7fb82","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieProtoEncoding.java","status":"modified","additions":104,"deletions":82,"changes":186,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookieProtoEncoding.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookieProtoEncoding.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookieProtoEncoding.java?ref=74f795136c1fff3badb29fc982d0cc2d43096b45","patch":"@@ -20,23 +20,30 @@\n  */\n package org.apache.bookkeeper.proto;\n \n-import com.google.protobuf.ByteString;\n-import com.google.protobuf.ExtensionRegistry;\n-import com.google.protobuf.InvalidProtocolBufferException;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.buffer.ByteBufInputStream;\n+import io.netty.buffer.ByteBufOutputStream;\n+import io.netty.buffer.CompositeByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.handler.codec.MessageToMessageDecoder;\n+import io.netty.handler.codec.MessageToMessageEncoder;\n+\n+import java.io.IOException;\n+import java.util.List;\n \n-import org.jboss.netty.buffer.ChannelBufferFactory;\n-import org.jboss.netty.buffer.ChannelBufferInputStream;\n-import org.jboss.netty.buffer.ChannelBufferOutputStream;\n-import org.jboss.netty.buffer.ChannelBuffers;\n-import org.jboss.netty.buffer.ChannelBuffer;\n-import org.jboss.netty.channel.Channel;\n-import org.jboss.netty.channel.ChannelHandlerContext;\n import org.apache.bookkeeper.proto.BookieProtocol.PacketHeader;\n-import org.jboss.netty.handler.codec.oneone.OneToOneEncoder;\n-import org.jboss.netty.handler.codec.oneone.OneToOneDecoder;\n+import org.apache.bookkeeper.util.DoubleByteBuf;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import com.google.protobuf.CodedOutputStream;\n+import com.google.protobuf.ExtensionRegistry;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import com.google.protobuf.MessageLite;\n+\n public class BookieProtoEncoding {\n     private final static Logger LOG = LoggerFactory.getLogger(BookieProtoEncoding.class);\n \n@@ -50,7 +57,7 @@ static interface EnDecoder {\n          * @return encode buffer.\n          * @throws Exception\n          */\n-        public Object encode(Object object, ChannelBufferFactory factory) throws Exception;\n+        public Object encode(Object object, ByteBufAllocator allocator) throws Exception;\n \n         /**\n          * Decode a <i>packet</i> into an object.\n@@ -60,7 +67,7 @@ static interface EnDecoder {\n          * @return parsed object.\n          * @throws Exception\n          */\n-        public Object decode(ChannelBuffer packet) throws Exception;\n+        public Object decode(ByteBuf packet) throws Exception;\n \n     }\n \n@@ -72,7 +79,7 @@ static class RequestEnDeCoderPreV3 implements EnDecoder {\n         }\n \n         @Override\n-        public Object encode(Object msg, ChannelBufferFactory bufferFactory)\n+        public Object encode(Object msg, ByteBufAllocator allocator)\n                 throws Exception {\n             if (!(msg instanceof BookieProtocol.Request)) {\n                 return msg;\n@@ -82,10 +89,10 @@ public Object encode(Object msg, ChannelBufferFactory bufferFactory)\n                 BookieProtocol.AddRequest ar = (BookieProtocol.AddRequest)r;\n                 int totalHeaderSize = 4 // for the header\n                     + BookieProtocol.MASTER_KEY_LENGTH; // for the master key\n-                ChannelBuffer buf = bufferFactory.getBuffer(totalHeaderSize);\n+                ByteBuf buf = allocator.buffer(totalHeaderSize);\n                 buf.writeInt(new PacketHeader(r.getProtocolVersion(), r.getOpCode(), r.getFlags()).toInt());\n                 buf.writeBytes(r.getMasterKey(), 0, BookieProtocol.MASTER_KEY_LENGTH);\n-                return ChannelBuffers.wrappedBuffer(buf, ar.getData());\n+                return DoubleByteBuf.get(buf, ar.getData());\n             } else if (r instanceof BookieProtocol.ReadRequest) {\n                 int totalHeaderSize = 4 // for request type\n                     + 8 // for ledgerId\n@@ -94,7 +101,7 @@ public Object encode(Object msg, ChannelBufferFactory bufferFactory)\n                     totalHeaderSize += BookieProtocol.MASTER_KEY_LENGTH;\n                 }\n \n-                ChannelBuffer buf = bufferFactory.getBuffer(totalHeaderSize);\n+                ByteBuf buf = allocator.buffer(totalHeaderSize);\n                 buf.writeInt(new PacketHeader(r.getProtocolVersion(), r.getOpCode(), r.getFlags()).toInt());\n                 buf.writeLong(r.getLedgerId());\n                 buf.writeLong(r.getEntryId());\n@@ -107,11 +114,11 @@ public Object encode(Object msg, ChannelBufferFactory bufferFactory)\n                 BookkeeperProtocol.AuthMessage am = ((BookieProtocol.AuthRequest)r).getAuthMessage();\n                 int totalHeaderSize = 4; // for request type\n                 int totalSize = totalHeaderSize + am.getSerializedSize();\n-                ChannelBuffer buf = bufferFactory.getBuffer(totalSize);\n+                ByteBuf buf = allocator.buffer(totalSize);\n                 buf.writeInt(new PacketHeader(r.getProtocolVersion(),\n                                               r.getOpCode(),\n                                               r.getFlags()).toInt());\n-                ChannelBufferOutputStream bufStream = new ChannelBufferOutputStream(buf);\n+                ByteBufOutputStream bufStream = new ByteBufOutputStream(buf);\n                 am.writeTo(bufStream);\n                 return buf;\n             } else {\n@@ -120,7 +127,7 @@ public Object encode(Object msg, ChannelBufferFactory bufferFactory)\n         }\n \n         @Override\n-        public Object decode(ChannelBuffer packet)\n+        public Object decode(ByteBuf packet)\n                 throws Exception {\n             PacketHeader h = PacketHeader.fromInt(packet.readInt());\n \n@@ -138,12 +145,12 @@ public Object decode(ChannelBuffer packet)\n                 masterKey = new byte[BookieProtocol.MASTER_KEY_LENGTH];\n                 packet.readBytes(masterKey, 0, BookieProtocol.MASTER_KEY_LENGTH);\n \n-                ChannelBuffer bb = packet.duplicate();\n-\n-                ledgerId = bb.readLong();\n-                entryId = bb.readLong();\n-                return new BookieProtocol.AddRequest(h.getVersion(), ledgerId, entryId,\n-                        flags, masterKey, packet.slice());\n+                // Read ledger and entry id without advancing the reader index\n+                packet.markReaderIndex();\n+                ledgerId = packet.readLong();\n+                entryId = packet.readLong();\n+                packet.resetReaderIndex();\n+                return new BookieProtocol.AddRequest(h.getVersion(), ledgerId, entryId, flags, masterKey, packet.retain());\n             case BookieProtocol.READENTRY:\n                 ledgerId = packet.readLong();\n                 entryId = packet.readLong();\n@@ -159,7 +166,7 @@ public Object decode(ChannelBuffer packet)\n             case BookieProtocol.AUTH:\n                 BookkeeperProtocol.AuthMessage.Builder builder\n                     = BookkeeperProtocol.AuthMessage.newBuilder();\n-                builder.mergeFrom(new ChannelBufferInputStream(packet), extensionRegistry);\n+                builder.mergeFrom(new ByteBufInputStream(packet), extensionRegistry);\n                 return new BookieProtocol.AuthRequest(h.getVersion(), builder.build());\n             }\n             return packet;\n@@ -174,13 +181,13 @@ static class ResponseEnDeCoderPreV3 implements EnDecoder {\n         }\n \n         @Override\n-        public Object encode(Object msg, ChannelBufferFactory bufferFactory)\n+        public Object encode(Object msg, ByteBufAllocator allocator)\n                 throws Exception {\n             if (!(msg instanceof BookieProtocol.Response)) {\n                 return msg;\n             }\n             BookieProtocol.Response r = (BookieProtocol.Response)msg;\n-            ChannelBuffer buf = bufferFactory.getBuffer(24);\n+            ByteBuf buf = allocator.buffer(24);\n             buf.writeInt(new PacketHeader(r.getProtocolVersion(),\n                                           r.getOpCode(), (short)0).toInt());\n \n@@ -192,8 +199,7 @@ public Object encode(Object msg, ChannelBufferFactory bufferFactory)\n \n                 BookieProtocol.ReadResponse rr = (BookieProtocol.ReadResponse)r;\n                 if (rr.hasData()) {\n-                    return ChannelBuffers.wrappedBuffer(buf,\n-                            ChannelBuffers.wrappedBuffer(rr.getData()));\n+                    return DoubleByteBuf.get(buf, rr.getData());\n                 } else {\n                     return buf;\n                 }\n@@ -205,15 +211,14 @@ public Object encode(Object msg, ChannelBufferFactory bufferFactory)\n                 return buf;\n             } else if (msg instanceof BookieProtocol.AuthResponse) {\n                 BookkeeperProtocol.AuthMessage am = ((BookieProtocol.AuthResponse)r).getAuthMessage();\n-                return ChannelBuffers.wrappedBuffer(buf,\n-                        ChannelBuffers.wrappedBuffer(am.toByteArray()));\n+                return DoubleByteBuf.get(buf, Unpooled.wrappedBuffer(am.toByteArray()));\n             } else {\n                 LOG.error(\"Cannot encode unknown response type {}\", msg.getClass().getName());\n                 return msg;\n             }\n         }\n         @Override\n-        public Object decode(ChannelBuffer buffer)\n+        public Object decode(ByteBuf buffer)\n                 throws Exception {\n             int rc;\n             long ledgerId, entryId;\n@@ -240,7 +245,7 @@ public Object decode(ChannelBuffer buffer)\n                                                            ledgerId, entryId);\n                 }\n             case BookieProtocol.AUTH:\n-                ChannelBufferInputStream bufStream = new ChannelBufferInputStream(buffer);\n+                ByteBufInputStream bufStream = new ByteBufInputStream(buffer);\n                 BookkeeperProtocol.AuthMessage.Builder builder\n                     = BookkeeperProtocol.AuthMessage.newBuilder();\n                 builder.mergeFrom(bufStream, extensionRegistry);\n@@ -260,15 +265,14 @@ static class RequestEnDecoderV3 implements EnDecoder {\n         }\n \n         @Override\n-        public Object decode(ChannelBuffer packet) throws Exception {\n-            return BookkeeperProtocol.Request.parseFrom(new ChannelBufferInputStream(packet),\n-                                                        extensionRegistry);\n+        public Object decode(ByteBuf packet) throws Exception {\n+            return BookkeeperProtocol.Request.parseFrom(new ByteBufInputStream(packet), extensionRegistry);\n         }\n \n         @Override\n-        public Object encode(Object msg, ChannelBufferFactory factory) throws Exception {\n+        public Object encode(Object msg, ByteBufAllocator allocator) throws Exception {\n             BookkeeperProtocol.Request request = (BookkeeperProtocol.Request) msg;\n-            return ChannelBuffers.wrappedBuffer(request.toByteArray());\n+            return serializeProtobuf(request, allocator);\n         }\n \n     }\n@@ -281,20 +285,37 @@ static class ResponseEnDecoderV3 implements EnDecoder {\n         }\n \n         @Override\n-        public Object decode(ChannelBuffer packet) throws Exception {\n-            return BookkeeperProtocol.Response.parseFrom(new ChannelBufferInputStream(packet),\n+        public Object decode(ByteBuf packet) throws Exception {\n+            return BookkeeperProtocol.Response.parseFrom(new ByteBufInputStream(packet),\n                                                          extensionRegistry);\n         }\n \n         @Override\n-        public Object encode(Object msg, ChannelBufferFactory factory) throws Exception {\n+        public Object encode(Object msg, ByteBufAllocator allocator) throws Exception {\n             BookkeeperProtocol.Response response = (BookkeeperProtocol.Response) msg;\n-            return ChannelBuffers.wrappedBuffer(response.toByteArray());\n+            return serializeProtobuf(response, allocator);\n+        }\n+\n+    }\n+\n+    private static ByteBuf serializeProtobuf(MessageLite msg, ByteBufAllocator allocator) {\n+        int size = msg.getSerializedSize();\n+        ByteBuf buf = allocator.heapBuffer(size, size);\n+\n+        try {\n+            msg.writeTo(CodedOutputStream.newInstance(buf.array(), buf.arrayOffset() + buf.writerIndex(), size));\n+        } catch (IOException e) {\n+            // This is in-memory serialization, should not fail\n+            throw new RuntimeException(e);\n         }\n \n+        // Advance writer idx\n+        buf.writerIndex(buf.capacity());\n+        return buf;\n     }\n \n-    public static class RequestEncoder extends OneToOneEncoder {\n+    @Sharable\n+    public static class RequestEncoder extends MessageToMessageEncoder<Object> {\n \n         final EnDecoder REQ_PREV3;\n         final EnDecoder REQ_V3;\n@@ -305,23 +326,23 @@ public static class RequestEncoder extends OneToOneEncoder {\n         }\n \n         @Override\n-        protected Object encode(ChannelHandlerContext ctx, Channel channel, Object msg)\n-                throws Exception {\n+        protected void encode(ChannelHandlerContext ctx, Object msg, List<Object> out) throws Exception {\n             if (LOG.isDebugEnabled()) {\n-                LOG.debug(\"Encode request {} to channel {}.\", msg, channel);\n+                LOG.debug(\"Encode request {} to channel {}.\", msg, ctx.channel());\n             }\n             if (msg instanceof BookkeeperProtocol.Request) {\n-                return REQ_V3.encode(msg, ctx.getChannel().getConfig().getBufferFactory());\n+                out.add(REQ_V3.encode(msg, ctx.alloc()));\n             } else if (msg instanceof BookieProtocol.Request) {\n-                return REQ_PREV3.encode(msg, ctx.getChannel().getConfig().getBufferFactory());\n+                out.add(REQ_PREV3.encode(msg, ctx.alloc()));\n             } else {\n-                LOG.error(\"Invalid request to encode to {}: {}\", channel, msg.getClass().getName());\n-                return msg;\n+                LOG.error(\"Invalid request to encode to {}: {}\", ctx.channel(), msg.getClass().getName());\n+                out.add(msg);\n             }\n         }\n     }\n \n-    public static class RequestDecoder extends OneToOneDecoder {\n+    @Sharable\n+    public static class RequestDecoder extends MessageToMessageDecoder<Object> {\n         final EnDecoder REQ_PREV3;\n         final EnDecoder REQ_V3;\n \n@@ -331,31 +352,32 @@ public static class RequestDecoder extends OneToOneDecoder {\n         }\n \n         @Override\n-        protected Object decode(ChannelHandlerContext ctx, Channel channel, Object msg)\n-                throws Exception {\n+        protected void decode(ChannelHandlerContext ctx, Object msg, List<Object> out) throws Exception {\n             if (LOG.isDebugEnabled()) {\n-                LOG.debug(\"Received request {} from channel {} to decode.\", msg, channel);\n+                LOG.debug(\"Received request {} from channel {} to decode.\", msg, ctx.channel());\n             }\n-            if (!(msg instanceof ChannelBuffer)) {\n-                return msg;\n+            if (!(msg instanceof ByteBuf)) {\n+                out.add(msg);\n+                return;\n             }\n-            ChannelBuffer buffer = (ChannelBuffer) msg;\n+            ByteBuf buffer = (ByteBuf) msg;\n             try {\n                 buffer.markReaderIndex();\n                 try {\n-                    return REQ_V3.decode(buffer);\n+                    out.add(REQ_V3.decode(buffer));\n                 } catch (InvalidProtocolBufferException e) {\n                     buffer.resetReaderIndex();\n-                    return REQ_PREV3.decode(buffer);\n+                    out.add(REQ_PREV3.decode(buffer));\n                 }\n             } catch (Exception e) {\n-                LOG.error(\"Failed to decode a request from {} : \", channel, e);\n-                throw e;\n+                LOG.error(\"Failed to decode a request from {} : \", ctx.channel(), e);\n+                ctx.close();\n             }\n         }\n     }\n \n-    public static class ResponseEncoder extends OneToOneEncoder {\n+    @Sharable\n+    public static class ResponseEncoder extends MessageToMessageEncoder<Object> {\n         final EnDecoder REP_PREV3;\n         final EnDecoder REP_V3;\n \n@@ -365,23 +387,24 @@ public static class ResponseEncoder extends OneToOneEncoder {\n         }\n \n         @Override\n-        protected Object encode(ChannelHandlerContext ctx, Channel channel, Object msg)\n+        protected void encode(ChannelHandlerContext ctx, Object msg, List<Object> out)\n                 throws Exception {\n             if (LOG.isDebugEnabled()) {\n-                LOG.debug(\"Encode response {} to channel {}.\", msg, channel);\n+                LOG.debug(\"Encode response {} to channel {}.\", msg, ctx.channel());\n             }\n             if (msg instanceof BookkeeperProtocol.Response) {\n-                return REP_V3.encode(msg, ctx.getChannel().getConfig().getBufferFactory());\n+                out.add(REP_V3.encode(msg, ctx.alloc()));\n             } else if (msg instanceof BookieProtocol.Response) {\n-                return REP_PREV3.encode(msg, ctx.getChannel().getConfig().getBufferFactory());\n+                out.add(REP_PREV3.encode(msg, ctx.alloc()));\n             } else {\n-                LOG.error(\"Invalid response to encode to {}: {}\", channel, msg.getClass().getName());\n-                return msg;\n+                LOG.error(\"Invalid response to encode to {}: {}\", ctx.channel(), msg.getClass().getName());\n+                out.add(msg);\n             }\n         }\n     }\n \n-    public static class ResponseDecoder extends OneToOneDecoder {\n+    @Sharable\n+    public static class ResponseDecoder extends MessageToMessageDecoder<Object> {\n         final EnDecoder REP_PREV3;\n         final EnDecoder REP_V3;\n \n@@ -391,26 +414,25 @@ public static class ResponseDecoder extends OneToOneDecoder {\n         }\n \n         @Override\n-        protected Object decode(ChannelHandlerContext ctx, Channel channel, Object msg)\n-                throws Exception {\n+        protected void decode(ChannelHandlerContext ctx, Object msg, List<Object> out) throws Exception {\n             if (LOG.isDebugEnabled()) {\n-                LOG.debug(\"Received response {} from channel {} to decode.\", msg, channel);\n+                LOG.debug(\"Received response {} from channel {} to decode.\", msg, ctx.channel());\n             }\n-            if (!(msg instanceof ChannelBuffer)) {\n-                return msg;\n+            if (!(msg instanceof ByteBuf)) {\n+                out.add(msg);\n             }\n-            ChannelBuffer buffer = (ChannelBuffer) msg;\n+            ByteBuf buffer = (ByteBuf) msg;\n             try {\n                 buffer.markReaderIndex();\n                 try {\n-                    return REP_V3.decode(buffer);\n+                    out.add(REP_V3.decode(buffer));\n                 } catch (InvalidProtocolBufferException e) {\n                     buffer.resetReaderIndex();\n-                    return REP_PREV3.decode(buffer);\n+                    out.add(REP_PREV3.decode(buffer));\n                 }\n             } catch (Exception e) {\n-                LOG.error(\"Failed to decode a response from channel {} : \", channel, e);\n-                throw e;\n+                LOG.error(\"Failed to decode a response from channel {} : \", ctx.channel(), e);\n+                ctx.close();\n             }\n         }\n     }"},{"sha":"094daab89366a840a54e8fac1971e1fb4ba0b396","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieProtocol.java","status":"modified","additions":14,"deletions":9,"changes":23,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookieProtocol.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookieProtocol.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookieProtocol.java?ref=74f795136c1fff3badb29fc982d0cc2d43096b45","patch":"@@ -21,7 +21,8 @@\n  *\n  */\n \n-import org.jboss.netty.buffer.ChannelBuffer;\n+import io.netty.buffer.ByteBuf;\n+\n import java.nio.ByteBuffer;\n \n import org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessage;\n@@ -249,25 +250,29 @@ public String toString() {\n     }\n \n     static class AddRequest extends Request {\n-        final ChannelBuffer data;\n+        final ByteBuf data;\n \n         AddRequest(byte protocolVersion, long ledgerId, long entryId,\n-                   short flags, byte[] masterKey, ChannelBuffer data) {\n+                   short flags, byte[] masterKey, ByteBuf data) {\n             super(protocolVersion, ADDENTRY, ledgerId, entryId, flags, masterKey);\n-            this.data = data;\n+            this.data = data.retain();\n         }\n \n-        ChannelBuffer getData() {\n+        ByteBuf getData() {\n             return data;\n         }\n \n         ByteBuffer getDataAsByteBuffer() {\n-            return data.toByteBuffer().slice();\n+            return data.nioBuffer().slice();\n         }\n \n         boolean isRecoveryAdd() {\n             return (flags & FLAG_RECOVERY_ADD) == FLAG_RECOVERY_ADD;\n         }\n+\n+        void release() {\n+            data.release();\n+        }\n     }\n \n     static class ReadRequest extends Request {\n@@ -342,14 +347,14 @@ public String toString() {\n     }\n \n     static class ReadResponse extends Response {\n-        final ChannelBuffer data;\n+        final ByteBuf data;\n \n         ReadResponse(byte protocolVersion, int errorCode, long ledgerId, long entryId) {\n             super(protocolVersion, READENTRY, errorCode, ledgerId, entryId);\n             this.data = null;\n         }\n \n-        ReadResponse(byte protocolVersion, int errorCode, long ledgerId, long entryId, ChannelBuffer data) {\n+        ReadResponse(byte protocolVersion, int errorCode, long ledgerId, long entryId, ByteBuf data) {\n             super(protocolVersion, READENTRY, errorCode, ledgerId, entryId);\n             this.data = data;\n         }\n@@ -358,7 +363,7 @@ boolean hasData() {\n             return data != null;\n         }\n \n-        ChannelBuffer getData() {\n+        ByteBuf getData() {\n             return data;\n         }\n     }"},{"sha":"b1bc0815964a2c69e5aeeb60561b971010096a61","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieRequestHandler.java","status":"modified","additions":24,"deletions":31,"changes":55,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookieRequestHandler.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookieRequestHandler.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookieRequestHandler.java?ref=74f795136c1fff3badb29fc982d0cc2d43096b45","patch":"@@ -20,23 +20,22 @@\n  */\n package org.apache.bookkeeper.proto;\n \n+\n+import java.nio.channels.ClosedChannelException;\n+\n import org.apache.bookkeeper.conf.ServerConfiguration;\n import org.apache.bookkeeper.processor.RequestProcessor;\n-import org.jboss.netty.channel.ChannelHandlerContext;\n-import org.jboss.netty.channel.ChannelStateEvent;\n-import org.jboss.netty.channel.ExceptionEvent;\n-import org.jboss.netty.channel.MessageEvent;\n-import org.jboss.netty.channel.SimpleChannelHandler;\n-import org.jboss.netty.channel.group.ChannelGroup;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import java.nio.channels.ClosedChannelException;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInboundHandlerAdapter;\n+import io.netty.channel.group.ChannelGroup;\n \n /**\n  * Serverside handler for bookkeeper requests\n  */\n-class BookieRequestHandler extends SimpleChannelHandler {\n+class BookieRequestHandler extends ChannelInboundHandlerAdapter {\n \n     private final static Logger LOG = LoggerFactory.getLogger(BookieRequestHandler.class);\n     private final RequestProcessor requestProcessor;\n@@ -48,42 +47,36 @@ class BookieRequestHandler extends SimpleChannelHandler {\n     }\n \n     @Override\n-    public void channelOpen(ChannelHandlerContext ctx,\n-                            ChannelStateEvent e)\n-            throws Exception {\n-        allChannels.add(ctx.getChannel());\n+    public void channelActive(ChannelHandlerContext ctx) throws Exception {\n+        LOG.info(\"Channel connected: {}\", ctx.channel());\n     }\n \n     @Override\n-    public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e) throws Exception {\n-        Throwable throwable = e.getCause();\n-        if (throwable instanceof ClosedChannelException) {\n-            LOG.debug(\"Client died before request could be completed\", throwable);\n-            return;\n-        }\n-        LOG.error(\"Unhandled exception occurred in I/O thread or handler\", throwable);\n+    public void channelRegistered(ChannelHandlerContext ctx) throws Exception {\n+        allChannels.add(ctx.channel());\n     }\n \n     @Override\n-    public void channelConnected(ChannelHandlerContext ctx, ChannelStateEvent e)\n-            throws Exception {\n-        LOG.debug(\"Channel connected {}\", e);\n+    public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n+        LOG.info(\"Channels disconnected: {}\", ctx.channel());\n     }\n \n     @Override\n-    public void channelDisconnected(ChannelHandlerContext ctx, ChannelStateEvent e)\n-            throws Exception {\n-        LOG.debug(\"Channel disconnected {}\", e);\n+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n+        if (cause instanceof ClosedChannelException) {\n+            LOG.info(\"Client died before request could be completed\", cause);\n+            return;\n+        }\n+        LOG.error(\"Unhandled exception occurred in I/O thread or handler\", cause);\n+        ctx.close();\n     }\n \n     @Override\n-    public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Exception {\n-        Object event = e.getMessage();\n-        if (!(event instanceof BookkeeperProtocol.Request || event instanceof BookieProtocol.Request)) {\n-            ctx.sendUpstream(e);\n+    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n+        if (!(msg instanceof BookkeeperProtocol.Request || msg instanceof BookieProtocol.Request)) {\n+            ctx.fireChannelRead(msg);\n             return;\n         }\n-        requestProcessor.processRequest(event, ctx.getChannel());\n+        requestProcessor.processRequest(msg, ctx.channel());\n     }\n-\n }"},{"sha":"07466861f50001bc2411846baf5669a82ac50374","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieRequestProcessor.java","status":"modified","additions":7,"deletions":8,"changes":15,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookieRequestProcessor.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookieRequestProcessor.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookieRequestProcessor.java?ref=74f795136c1fff3badb29fc982d0cc2d43096b45","patch":"@@ -20,10 +20,10 @@\n  */\n package org.apache.bookkeeper.proto;\n \n-import com.google.common.util.concurrent.ThreadFactoryBuilder;\n import com.google.protobuf.ByteString;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n+\n+import io.netty.channel.Channel;\n+\n import org.apache.bookkeeper.auth.AuthProviderFactoryFactory;\n import org.apache.bookkeeper.auth.AuthToken;\n \n@@ -33,7 +33,6 @@\n import org.apache.bookkeeper.stats.OpStatsLogger;\n import org.apache.bookkeeper.stats.StatsLogger;\n import org.apache.bookkeeper.util.OrderedSafeExecutor;\n-import org.jboss.netty.channel.Channel;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -132,7 +131,7 @@ public void processRequest(Object msg, Channel c) {\n                     processReadRequestV3(r, c);\n                     break;\n                 case AUTH:\n-                    LOG.info(\"Ignoring auth operation from client {}\",c.getRemoteAddress());\n+                    LOG.info(\"Ignoring auth operation from client {}\",c.remoteAddress());\n                     BookkeeperProtocol.AuthMessage message = BookkeeperProtocol.AuthMessage\n                         .newBuilder()\n                         .setAuthPluginName(AuthProviderFactoryFactory.authenticationDisabledPluginName)\n@@ -142,7 +141,7 @@ public void processRequest(Object msg, Channel c) {\n                             BookkeeperProtocol.Response.newBuilder().setHeader(r.getHeader())\n                             .setStatus(BookkeeperProtocol.StatusCode.EOK)\n                             .setAuthResponse(message);\n-                    c.write(authResponse.build());\n+                    c.writeAndFlush(authResponse.build());\n                     break;\n                 case WRITE_LAC:\n                     processWriteLacRequestV3(r,c);\n@@ -158,7 +157,7 @@ public void processRequest(Object msg, Channel c) {\n                     BookkeeperProtocol.Response.Builder response =\n                             BookkeeperProtocol.Response.newBuilder().setHeader(r.getHeader())\n                             .setStatus(BookkeeperProtocol.StatusCode.EBADREQ);\n-                    c.write(response.build());\n+                    c.writeAndFlush(response.build());\n                     if (statsEnabled) {\n                         bkStats.getOpStats(BKStats.STATS_UNKNOWN).incrementFailedOps();\n                     }\n@@ -176,7 +175,7 @@ public void processRequest(Object msg, Channel c) {\n                     break;\n                 default:\n                     LOG.error(\"Unknown op type {}, sending error\", r.getOpCode());\n-                    c.write(ResponseBuilder.buildErrorResponse(BookieProtocol.EBADREQ, r));\n+                    c.writeAndFlush(ResponseBuilder.buildErrorResponse(BookieProtocol.EBADREQ, r));\n                     if (statsEnabled) {\n                         bkStats.getOpStats(BKStats.STATS_UNKNOWN).incrementFailedOps();\n                     }"},{"sha":"58fd451262fa20aaeedca788127d7c59d82ba7d8","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookkeeperInternalCallbacks.java","status":"modified","additions":4,"deletions":3,"changes":7,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookkeeperInternalCallbacks.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookkeeperInternalCallbacks.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookkeeperInternalCallbacks.java?ref=74f795136c1fff3badb29fc982d0cc2d43096b45","patch":"@@ -21,14 +21,15 @@\n \n package org.apache.bookkeeper.proto;\n \n+import io.netty.buffer.ByteBuf;\n+\n import java.util.concurrent.LinkedBlockingQueue;\n import java.util.concurrent.atomic.AtomicInteger;\n \n import org.apache.bookkeeper.client.LedgerMetadata;\n import org.apache.bookkeeper.client.BookieInfoReader.BookieInfo;\n import org.apache.bookkeeper.net.BookieSocketAddress;\n import org.apache.zookeeper.AsyncCallback;\n-import org.jboss.netty.buffer.ChannelBuffer;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -67,7 +68,7 @@ public interface WriteCallback {\n     }\n \n     public interface ReadLacCallback {\n-        void readLacComplete(int rc, long ledgerId, ChannelBuffer lac, ChannelBuffer buffer, Object ctx);\n+        void readLacComplete(int rc, long ledgerId, ByteBuf lac, ByteBuf buffer, Object ctx);\n     }\n \n     public interface WriteLacCallback {\n@@ -86,7 +87,7 @@ public interface WriteLacCallback {\n      */\n \n     public interface ReadEntryCallback {\n-        void readEntryComplete(int rc, long ledgerId, long entryId, ChannelBuffer buffer, Object ctx);\n+        void readEntryComplete(int rc, long ledgerId, long entryId, ByteBuf buffer, Object ctx);\n     }\n \n     public interface GetBookieInfoCallback {"},{"sha":"774086c1794d3ca083e59ed7ae2f792cd47b8949","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/ChannelManager.java","status":"removed","additions":0,"deletions":46,"changes":46,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/811ece53a1c975c4e768422f3d622ac9de6b3e41/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FChannelManager.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/811ece53a1c975c4e768422f3d622ac9de6b3e41/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FChannelManager.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FChannelManager.java?ref=811ece53a1c975c4e768422f3d622ac9de6b3e41","patch":"@@ -1,46 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.bookkeeper.proto;\n-\n-import java.io.IOException;\n-import org.apache.bookkeeper.conf.ServerConfiguration;\n-import org.apache.bookkeeper.net.BookieSocketAddress;\n-import org.jboss.netty.channel.Channel;\n-import org.jboss.netty.channel.ChannelPipelineFactory;\n-\n-/**\n- * Manages the lifycycle of a communication Channel\n- * @author enrico.olivelli\n- */\n-public abstract class ChannelManager {\n-\n-    /**\n-     * Boots the Channel\n-     * @param conf Bookie Configuration\n-     * @param channelPipelineFactory Netty Pipeline Factory\n-     * @param bookieAddress The actual address to listen on\n-     * @return the channel which is listening for incoming connections\n-     * @throws IOException \n-     */\n-    public abstract Channel start(ServerConfiguration conf, ChannelPipelineFactory channelPipelineFactory) throws IOException;\n-\n-    /**\n-     * Releases all resources\n-     */\n-    public abstract void close();\n-}"},{"sha":"36a26effa28101496e2e2914f53c12a42bb11a71","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/DefaultPerChannelBookieClientPool.java","status":"modified","additions":3,"deletions":2,"changes":5,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FDefaultPerChannelBookieClientPool.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FDefaultPerChannelBookieClientPool.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FDefaultPerChannelBookieClientPool.java?ref=74f795136c1fff3badb29fc982d0cc2d43096b45","patch":"@@ -28,6 +28,7 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+\n import java.util.concurrent.atomic.AtomicInteger;\n import com.google.common.base.Preconditions;\n \n@@ -71,12 +72,12 @@ public void intialize() {\n     }\n \n     @Override\n-    public void obtain(GenericCallback<PerChannelBookieClient> callback) {\n+    public void obtain(GenericCallback<PerChannelBookieClient> callback, long key) {\n         if (1 == clients.length) {\n             clients[0].connectIfNeededAndDoOp(callback);\n             return;\n         }\n-        int idx = MathUtils.signSafeMod(counter.getAndIncrement(), clients.length);\n+        int idx = MathUtils.signSafeMod(key, clients.length);\n         clients[idx].connectIfNeededAndDoOp(callback);\n     }\n "},{"sha":"187270101f56486b13bba0a64126b5f75e809c21","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/GetBookieInfoProcessorV3.java","status":"modified","additions":2,"deletions":1,"changes":3,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FGetBookieInfoProcessorV3.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FGetBookieInfoProcessorV3.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FGetBookieInfoProcessorV3.java?ref=74f795136c1fff3badb29fc982d0cc2d43096b45","patch":"@@ -28,10 +28,11 @@\n import org.apache.bookkeeper.proto.BookkeeperProtocol.Response;\n import org.apache.bookkeeper.proto.BookkeeperProtocol.StatusCode;\n import org.apache.bookkeeper.util.MathUtils;\n-import org.jboss.netty.channel.Channel;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import io.netty.channel.Channel;\n+\n public class GetBookieInfoProcessorV3 extends PacketProcessorBaseV3 implements Runnable {\n     private final static Logger LOG = LoggerFactory.getLogger(GetBookieInfoProcessorV3.class);\n "},{"sha":"91fde2c0acb4d135c2a971da089c92e8de741eb2","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/NioServerSocketChannelManager.java","status":"removed","additions":0,"deletions":75,"changes":75,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/811ece53a1c975c4e768422f3d622ac9de6b3e41/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FNioServerSocketChannelManager.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/811ece53a1c975c4e768422f3d622ac9de6b3e41/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FNioServerSocketChannelManager.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FNioServerSocketChannelManager.java?ref=811ece53a1c975c4e768422f3d622ac9de6b3e41","patch":"@@ -1,75 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.bookkeeper.proto;\n-\n-import com.google.common.util.concurrent.ThreadFactoryBuilder;\n-import java.io.IOException;\n-import java.net.InetSocketAddress;\n-import java.util.concurrent.Executors;\n-import org.apache.bookkeeper.bookie.Bookie;\n-import org.apache.bookkeeper.conf.ServerConfiguration;\n-import org.apache.bookkeeper.net.BookieSocketAddress;\n-import org.jboss.netty.bootstrap.ServerBootstrap;\n-import org.jboss.netty.channel.Channel;\n-import org.jboss.netty.channel.ChannelFactory;\n-import org.jboss.netty.channel.ChannelPipelineFactory;\n-import org.jboss.netty.channel.socket.nio.NioServerSocketChannelFactory;\n-\n-/**\n- * Manages a NioServerSocketChannel channel\n- *\n- * @author enrico.olivelli\n- */\n-public class NioServerSocketChannelManager extends ChannelManager {\n-\n-    private ChannelFactory channelFactory;\n-\n-    @Override\n-    public Channel start(ServerConfiguration conf, ChannelPipelineFactory bookiePipelineFactory) throws IOException {\n-        BookieSocketAddress bookieAddress = Bookie.getBookieAddress(conf);\n-        ThreadFactoryBuilder tfb = new ThreadFactoryBuilder();\n-        String base = \"bookie-\" + conf.getBookiePort() + \"-netty\";\n-        this.channelFactory = new NioServerSocketChannelFactory(\n-                Executors.newCachedThreadPool(tfb.setNameFormat(base + \"-boss-%d\").build()),\n-                Executors.newCachedThreadPool(tfb.setNameFormat(base + \"-worker-%d\").build()));\n-\n-        ServerBootstrap bootstrap = new ServerBootstrap(channelFactory);\n-        bootstrap.setPipelineFactory(bookiePipelineFactory);\n-        bootstrap.setOption(\"child.tcpNoDelay\", conf.getServerTcpNoDelay());\n-        bootstrap.setOption(\"child.soLinger\", 2);\n-\n-        InetSocketAddress bindAddress;\n-        if (conf.getListeningInterface() == null) {\n-            // listen on all interfaces\n-            bindAddress = new InetSocketAddress(conf.getBookiePort());\n-        } else {\n-            bindAddress = bookieAddress.getSocketAddress();\n-        }\n-        \n-        Channel listen = bootstrap.bind(bindAddress);\n-        return listen;\n-    }\n-\n-    @Override\n-    public void close() {\n-        if (channelFactory != null) {\n-            channelFactory.releaseExternalResources();\n-        }\n-        channelFactory = null;\n-    }\n-}\n\\ No newline at end of file"},{"sha":"4f14dcf78c71239d14bb26da0bd8c83050aef5fb","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PacketProcessorBase.java","status":"modified","additions":3,"deletions":2,"changes":5,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FPacketProcessorBase.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FPacketProcessorBase.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FPacketProcessorBase.java?ref=74f795136c1fff3badb29fc982d0cc2d43096b45","patch":"@@ -23,10 +23,11 @@\n import org.apache.bookkeeper.stats.OpStatsLogger;\n import org.apache.bookkeeper.util.MathUtils;\n import org.apache.bookkeeper.util.SafeRunnable;\n-import org.jboss.netty.channel.Channel;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import io.netty.channel.Channel;\n+\n abstract class PacketProcessorBase extends SafeRunnable {\n     private final static Logger logger = LoggerFactory.getLogger(PacketProcessorBase.class);\n     final Request request;\n@@ -55,7 +56,7 @@ protected boolean isVersionCompatible() {\n     }\n \n     protected void sendResponse(int rc, Object response, OpStatsLogger statsLogger) {\n-        channel.write(response);\n+        channel.writeAndFlush(response, channel.voidPromise());\n         if (BookieProtocol.EOK == rc) {\n             statsLogger.registerSuccessfulEvent(MathUtils.elapsedNanos(enqueueNanos), TimeUnit.NANOSECONDS);\n         } else {"},{"sha":"873ef301cdaf798196bf86bf5d636d07b2d8e189","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PacketProcessorBaseV3.java","status":"modified","additions":3,"deletions":2,"changes":5,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FPacketProcessorBaseV3.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FPacketProcessorBaseV3.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FPacketProcessorBaseV3.java?ref=74f795136c1fff3badb29fc982d0cc2d43096b45","patch":"@@ -20,6 +20,8 @@\n  */\n package org.apache.bookkeeper.proto;\n \n+import io.netty.channel.Channel;\n+\n import java.util.concurrent.TimeUnit;\n \n import org.apache.bookkeeper.proto.BookkeeperProtocol.BKPacketHeader;\n@@ -29,7 +31,6 @@\n import org.apache.bookkeeper.stats.OpStatsLogger;\n import org.apache.bookkeeper.util.MathUtils;\n import org.apache.bookkeeper.util.SafeRunnable;\n-import org.jboss.netty.channel.Channel;\n \n public abstract class PacketProcessorBaseV3 extends SafeRunnable {\n \n@@ -47,7 +48,7 @@ public PacketProcessorBaseV3(Request request, Channel channel,\n     }\n \n     protected void sendResponse(StatusCode code, Object response, OpStatsLogger statsLogger) {\n-        channel.write(response);\n+        channel.writeAndFlush(response);\n         if (StatusCode.EOK == code) {\n             statsLogger.registerSuccessfulEvent(MathUtils.elapsedNanos(enqueueNanos), TimeUnit.NANOSECONDS);\n         } else {"},{"sha":"99d257bc5e3cedfb82a45f75cdfa90dc7a14dfca","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java","status":"modified","additions":191,"deletions":168,"changes":359,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FPerChannelBookieClient.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FPerChannelBookieClient.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FPerChannelBookieClient.java?ref=74f795136c1fff3badb29fc982d0cc2d43096b45","patch":"@@ -17,9 +17,36 @@\n  */\n package org.apache.bookkeeper.proto;\n \n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.PooledByteBufAllocator;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInboundHandlerAdapter;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelOption;\n+import io.netty.channel.ChannelPipeline;\n+import io.netty.channel.DefaultEventLoopGroup;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.WriteBufferWaterMark;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.epoll.EpollEventLoopGroup;\n+import io.netty.channel.epoll.EpollSocketChannel;\n+import io.netty.channel.local.LocalChannel;\n+import io.netty.channel.socket.nio.NioSocketChannel;\n+import io.netty.handler.codec.CorruptedFrameException;\n+import io.netty.handler.codec.LengthFieldBasedFrameDecoder;\n+import io.netty.handler.codec.LengthFieldPrepender;\n+import io.netty.handler.codec.TooLongFrameException;\n+import io.netty.util.HashedWheelTimer;\n+import io.netty.util.Timeout;\n+import io.netty.util.TimerTask;\n+\n+\n import java.io.IOException;\n-import java.nio.ByteBuffer;\n-import java.nio.MappedByteBuffer;\n import java.nio.channels.ClosedChannelException;\n import java.util.ArrayDeque;\n import java.util.Collections;\n@@ -43,6 +70,8 @@\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ReadEntryCallback;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GetBookieInfoCallback;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteCallback;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteLacCallback;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ReadLacCallback;\n import org.apache.bookkeeper.proto.BookkeeperProtocol.AddRequest;\n import org.apache.bookkeeper.proto.BookkeeperProtocol.AddResponse;\n import org.apache.bookkeeper.proto.BookkeeperProtocol.BKPacketHeader;\n@@ -59,60 +88,31 @@\n import org.apache.bookkeeper.proto.BookkeeperProtocol.StatusCode;\n import org.apache.bookkeeper.proto.BookkeeperProtocol.WriteLacRequest;\n import org.apache.bookkeeper.proto.BookkeeperProtocol.WriteLacResponse;\n-import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n-import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ReadEntryCallback;\n-import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteCallback;\n-import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteLacCallback;\n-import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ReadLacCallback;\n+\n import org.apache.bookkeeper.stats.NullStatsLogger;\n import org.apache.bookkeeper.stats.OpStatsLogger;\n import org.apache.bookkeeper.stats.StatsLogger;\n import org.apache.bookkeeper.util.MathUtils;\n import org.apache.bookkeeper.util.OrderedSafeExecutor;\n import org.apache.bookkeeper.util.SafeRunnable;\n-import org.jboss.netty.bootstrap.ClientBootstrap;\n-import org.jboss.netty.buffer.ChannelBuffer;\n-import org.jboss.netty.buffer.ChannelBuffers;\n-import org.jboss.netty.channel.Channel;\n-import org.jboss.netty.channel.ChannelFuture;\n-import org.jboss.netty.channel.ChannelFutureListener;\n-import org.jboss.netty.channel.ChannelHandlerContext;\n-import org.jboss.netty.channel.ChannelPipeline;\n-import org.jboss.netty.channel.ChannelPipelineFactory;\n-import org.jboss.netty.channel.ChannelStateEvent;\n-import org.jboss.netty.channel.Channels;\n-import org.jboss.netty.channel.ExceptionEvent;\n-import org.jboss.netty.channel.MessageEvent;\n-import org.jboss.netty.channel.SimpleChannelHandler;\n-import org.jboss.netty.channel.local.DefaultLocalClientChannelFactory;\n-import org.jboss.netty.channel.local.LocalClientChannelFactory;\n-import org.jboss.netty.channel.socket.ClientSocketChannelFactory;\n-import org.jboss.netty.handler.codec.frame.CorruptedFrameException;\n-import org.jboss.netty.handler.codec.frame.LengthFieldBasedFrameDecoder;\n-import org.jboss.netty.handler.codec.frame.LengthFieldPrepender;\n-import org.jboss.netty.handler.codec.frame.TooLongFrameException;\n-import org.jboss.netty.handler.timeout.ReadTimeoutHandler;\n-import org.jboss.netty.util.HashedWheelTimer;\n-import org.jboss.netty.util.Timeout;\n-import org.jboss.netty.util.TimerTask;\n+import org.apache.commons.lang.SystemUtils;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n import com.google.common.collect.Sets;\n-import com.google.protobuf.ByteString;\n import com.google.protobuf.ExtensionRegistry;\n import java.net.SocketAddress;\n \n import org.apache.bookkeeper.auth.BookKeeperPrincipal;\n-import org.jboss.netty.channel.ChannelFactory;\n import org.apache.bookkeeper.client.ClientConnectionPeer;\n \n /**\n  * This class manages all details of connection to a particular bookie. It also\n  * has reconnect logic if a connection to a bookie fails.\n  *\n  */\n-public class PerChannelBookieClient extends SimpleChannelHandler implements ChannelPipelineFactory {\n+@Sharable\n+public class PerChannelBookieClient extends ChannelInboundHandlerAdapter {\n \n     static final Logger LOG = LoggerFactory.getLogger(PerChannelBookieClient.class);\n \n@@ -129,7 +129,7 @@ public class PerChannelBookieClient extends SimpleChannelHandler implements Chan\n     public static final AtomicLong txnIdGenerator = new AtomicLong(0);\n \n     final BookieSocketAddress addr;\n-    final ChannelFactory channelFactory;\n+    final EventLoopGroup eventLoopGroup;\n     final OrderedSafeExecutor executor;\n     final HashedWheelTimer requestTimer;\n     final int addEntryTimeout;\n@@ -175,21 +175,22 @@ enum ConnectionState {\n     private final ClientAuthProvider.Factory authProviderFactory;\n     private final ExtensionRegistry extRegistry;\n \n-    public PerChannelBookieClient(OrderedSafeExecutor executor, ClientSocketChannelFactory channelFactory,\n+    public PerChannelBookieClient(OrderedSafeExecutor executor, EventLoopGroup eventLoopGroup,\n                                   BookieSocketAddress addr) {\n-        this(new ClientConfiguration(), executor, channelFactory, addr, null, NullStatsLogger.INSTANCE, null, null, null);\n+        this(new ClientConfiguration(), executor, eventLoopGroup, addr, null, NullStatsLogger.INSTANCE, null, null,\n+                null);\n     }\n \n-    public PerChannelBookieClient(OrderedSafeExecutor executor, ClientSocketChannelFactory channelFactory,\n+    public PerChannelBookieClient(OrderedSafeExecutor executor, EventLoopGroup eventLoopGroup,\n                                   BookieSocketAddress addr,\n                                   ClientAuthProvider.Factory authProviderFactory,\n                                   ExtensionRegistry extRegistry) {\n-        this(new ClientConfiguration(), executor, channelFactory, addr, null, NullStatsLogger.INSTANCE,\n+        this(new ClientConfiguration(), executor, eventLoopGroup, addr, null, NullStatsLogger.INSTANCE,\n                 authProviderFactory, extRegistry, null);\n     }\n \n     public PerChannelBookieClient(ClientConfiguration conf, OrderedSafeExecutor executor,\n-                                  ClientSocketChannelFactory channelFactory, BookieSocketAddress addr,\n+            EventLoopGroup eventLoopGroup, BookieSocketAddress addr,\n                                   HashedWheelTimer requestTimer, StatsLogger parentStatsLogger,\n                                   ClientAuthProvider.Factory authProviderFactory,\n                                   ExtensionRegistry extRegistry,\n@@ -198,10 +199,10 @@ public PerChannelBookieClient(ClientConfiguration conf, OrderedSafeExecutor exec\n         this.conf = conf;\n         this.addr = addr;\n         this.executor = executor;\n-        if (LocalBookiesRegistry.isLocalBookie(addr)){\n-            this.channelFactory = new DefaultLocalClientChannelFactory();\n+        if (LocalBookiesRegistry.isLocalBookie(addr)) {\n+            this.eventLoopGroup = new DefaultEventLoopGroup();\n         } else {\n-            this.channelFactory = channelFactory;\n+            this.eventLoopGroup = eventLoopGroup;\n         }\n         this.state = ConnectionState.DISCONNECTED;\n         this.requestTimer = requestTimer;\n@@ -239,7 +240,7 @@ public PerChannelBookieClient(ClientConfiguration conf, OrderedSafeExecutor exec\n             public SocketAddress getRemoteAddr() {\n                 Channel c = channel;\n                 if (c != null) {\n-                    return c.getRemoteAddress();\n+                    return c.remoteAddress();\n                 } else {\n                     return null;\n                 }\n@@ -287,56 +288,94 @@ private void completeOperation(GenericCallback<PerChannelBookieClient> op, int r\n         }\n     }\n \n-    private void connect() {\n+    protected ChannelFuture connect() {\n         LOG.debug(\"Connecting to bookie: {}\", addr);\n \n-        // Set up the ClientBootStrap so we can create a new Channel connection\n-        // to the bookie.\n-        ClientBootstrap bootstrap = new ClientBootstrap(channelFactory);\n-        bootstrap.setPipelineFactory(this);\n-        bootstrap.setOption(\"tcpNoDelay\", conf.getClientTcpNoDelay());\n-        bootstrap.setOption(\"keepAlive\", true);\n-        bootstrap.setOption(\"connectTimeoutMillis\", conf.getClientConnectTimeoutMillis());\n-        bootstrap.setOption(\"child.sendBufferSize\", conf.getClientSendBufferSize());\n-        bootstrap.setOption(\"child.receiveBufferSize\", conf.getClientReceiveBufferSize());\n-        bootstrap.setOption(\"writeBufferLowWaterMark\", conf.getClientWriteBufferLowWaterMark());\n-        bootstrap.setOption(\"writeBufferHighWaterMark\", conf.getClientWriteBufferHighWaterMark());\n-        SocketAddress bookieAddr = addr.getSocketAddress();        \n-        if (channelFactory instanceof LocalClientChannelFactory) {\n+        // Set up the ClientBootStrap so we can create a new Channel connection to the bookie.\n+        Bootstrap bootstrap = new Bootstrap();\n+        bootstrap.group(eventLoopGroup);\n+        if (eventLoopGroup instanceof EpollEventLoopGroup) {\n+            bootstrap.channel(EpollSocketChannel.class);\n+        } else if (eventLoopGroup instanceof DefaultEventLoopGroup) {\n+            bootstrap.channel(LocalChannel.class);\n+        } else {\n+            bootstrap.channel(NioSocketChannel.class);\n+        }\n+\n+        bootstrap.option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT);\n+        bootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, conf.getClientConnectTimeoutMillis());\n+        bootstrap.option(ChannelOption.WRITE_BUFFER_WATER_MARK, new WriteBufferWaterMark(\n+                conf.getClientWriteBufferLowWaterMark(), conf.getClientWriteBufferHighWaterMark()));\n+\n+        if (!(eventLoopGroup instanceof DefaultEventLoopGroup)) {\n+            bootstrap.option(ChannelOption.TCP_NODELAY, conf.getClientTcpNoDelay());\n+            bootstrap.option(ChannelOption.SO_KEEPALIVE, conf.getClientSockKeepalive());\n+\n+            // if buffer sizes are 0, let OS auto-tune it\n+            if (conf.getClientSendBufferSize() > 0) {\n+                bootstrap.option(ChannelOption.SO_SNDBUF, conf.getClientSendBufferSize());\n+            }\n+\n+            if (conf.getClientReceiveBufferSize() > 0) {\n+                bootstrap.option(ChannelOption.SO_RCVBUF, conf.getClientReceiveBufferSize());\n+            }\n+        }\n+\n+        // In the netty pipeline, we need to split packets based on length, so we\n+        // use the {@link LengthFieldBasedFramDecoder}. Other than that all actions\n+        // are carried out in this class, e.g., making sense of received messages,\n+        // prepending the length to outgoing packets etc.\n+        bootstrap.handler(new ChannelInitializer<Channel>() {\n+            @Override\n+            protected void initChannel(Channel ch) throws Exception {\n+                ChannelPipeline pipeline = ch.pipeline();\n+\n+                pipeline.addLast(\"lengthbasedframedecoder\",\n+                        new LengthFieldBasedFrameDecoder(maxFrameSize, 0, 4, 0, 4));\n+                pipeline.addLast(\"lengthprepender\", new LengthFieldPrepender(4));\n+                pipeline.addLast(\"bookieProtoEncoder\", new BookieProtoEncoding.RequestEncoder(extRegistry));\n+                pipeline.addLast(\"bookieProtoDecoder\", new BookieProtoEncoding.ResponseDecoder(extRegistry));\n+                pipeline.addLast(\"authHandler\", new AuthHandler.ClientSideHandler(authProviderFactory, txnIdGenerator, connectionPeer));\n+                pipeline.addLast(\"mainhandler\", PerChannelBookieClient.this);\n+            }\n+        });\n+\n+        SocketAddress bookieAddr = addr.getSocketAddress();\n+        if (eventLoopGroup instanceof DefaultEventLoopGroup) {\n             bookieAddr = addr.getLocalAddress();\n         }\n+\n         ChannelFuture future = bootstrap.connect(bookieAddr);\n         future.addListener(new ChannelFutureListener() {\n             @Override\n             public void operationComplete(ChannelFuture future) throws Exception {\n-                LOG.debug(\"Channel connected ({}) {}\", future.isSuccess(), future.getChannel());\n+                LOG.debug(\"Channel connected ({}) {}\", future.isSuccess(), future.channel());\n                 int rc;\n                 Queue<GenericCallback<PerChannelBookieClient>> oldPendingOps;\n \n                 synchronized (PerChannelBookieClient.this) {\n                     if (future.isSuccess() && state == ConnectionState.CONNECTING) {\n-                        LOG.info(\"Successfully connected to bookie: {}\", future.getChannel());\n+                        LOG.info(\"Successfully connected to bookie: {}\", future.channel());\n                         rc = BKException.Code.OK;\n-                        channel = future.getChannel();\n+                        channel = future.channel();\n                         state = ConnectionState.CONNECTED;\n                     } else if (future.isSuccess() && (state == ConnectionState.CLOSED\n                                                       || state == ConnectionState.DISCONNECTED)) {\n                         LOG.warn(\"Closed before connection completed, clean up: {}, current state {}\",\n-                                 future.getChannel(), state);\n-                        closeChannel(future.getChannel());\n+                                future.channel(), state);\n+                        closeChannel(future.channel());\n                         rc = BKException.Code.BookieHandleNotAvailableException;\n                         channel = null;\n                     } else if (future.isSuccess() && state == ConnectionState.CONNECTED) {\n                         LOG.debug(\"Already connected with another channel({}), so close the new channel({})\",\n-                                  channel, future.getChannel());\n-                        closeChannel(future.getChannel());\n+                                channel, future.channel());\n+                        closeChannel(future.channel());\n                         return; // pendingOps should have been completed when other channel connected\n                     } else {\n                         LOG.error(\"Could not connect to bookie: {}/{}, current state {} : \",\n-                                  new Object[] { future.getChannel(), addr,\n-                                                 state, future.getCause() });\n+                                new Object[] { future.channel(), addr, state, future.cause() });\n                         rc = BKException.Code.BookieHandleNotAvailableException;\n-                        closeChannel(future.getChannel());\n+                        closeChannel(future.channel());\n                         channel = null;\n                         if (state != ConnectionState.CLOSED) {\n                             state = ConnectionState.DISCONNECTED;\n@@ -356,6 +395,8 @@ public void operationComplete(ChannelFuture future) throws Exception {\n                 }\n             }\n         });\n+\n+        return future;\n     }\n \n     void connectIfNeededAndDoOp(GenericCallback<PerChannelBookieClient> op) {\n@@ -402,7 +443,8 @@ void connectIfNeededAndDoOp(GenericCallback<PerChannelBookieClient> op) {\n \n     }\n \n-    void writeLac(final long ledgerId, final byte[] masterKey, final long lac, ChannelBuffer toSend, WriteLacCallback cb, Object ctx) {\n+    void writeLac(final long ledgerId, final byte[] masterKey, final long lac, ByteBuf toSend, WriteLacCallback cb,\n+            Object ctx) {\n         final long txnId = getTxnId();\n         final CompletionKey completionKey = new V3CompletionKey(txnId, OperationType.WRITE_LAC);\n         // writeLac is mostly like addEntry hence uses addEntryTimeout\n@@ -418,7 +460,7 @@ void writeLac(final long ledgerId, final byte[] masterKey, final long lac, Chann\n                 .setLedgerId(ledgerId)\n                 .setLac(lac)\n                 .setMasterKey(ByteString.copyFrom(masterKey))\n-                .setBody(ByteString.copyFrom(toSend.toByteBuffer()));\n+                .setBody(ByteString.copyFrom(toSend.nioBuffer()));\n \n         final Request writeLacRequest = Request.newBuilder()\n                 .setHeader(headerBuilder)\n@@ -431,19 +473,19 @@ void writeLac(final long ledgerId, final byte[] masterKey, final long lac, Chann\n             return;\n         }\n         try {\n-            ChannelFuture future = c.write(writeLacRequest);\n+            ChannelFuture future = c.writeAndFlush(writeLacRequest);\n             future.addListener(new ChannelFutureListener() {\n                 @Override\n                 public void operationComplete(ChannelFuture future) throws Exception {\n                     if (future.isSuccess()) {\n                         if (LOG.isDebugEnabled()) {\n                             LOG.debug(\"Successfully wrote request for writeLac LedgerId: {} bookie: {}\",\n-                                    ledgerId, c.getRemoteAddress());\n+                                    ledgerId, c.remoteAddress());\n                         }\n                     } else {\n-                        if (!(future.getCause() instanceof ClosedChannelException)) {\n+                        if (!(future.cause() instanceof ClosedChannelException)) {\n                             LOG.warn(\"Writing Lac(lid={} to channel {} failed : \",\n-                                    new Object[] { ledgerId, c, future.getCause() });\n+                                    new Object[] { ledgerId, c, future.cause() });\n                         }\n                         errorOutWriteLacKey(completionKey);\n                     }\n@@ -474,16 +516,14 @@ public void operationComplete(ChannelFuture future) throws Exception {\n      * @param options\n      *          Add options\n      */\n-    void addEntry(final long ledgerId, byte[] masterKey, final long entryId, ChannelBuffer toSend, WriteCallback cb,\n+    void addEntry(final long ledgerId, byte[] masterKey, final long entryId, ByteBuf toSend, WriteCallback cb,\n                   Object ctx, final int options) {\n         Object request = null;\n         CompletionKey completion = null;\n         if (useV2WireProtocol) {\n             completion = new V2CompletionKey(ledgerId, entryId, OperationType.ADD_ENTRY);\n             request = new BookieProtocol.AddRequest(BookieProtocol.CURRENT_PROTOCOL_VERSION, ledgerId, entryId,\n                     (short) options, masterKey, toSend);\n-\n-\n         } else {\n             final long txnId = getTxnId();\n             completion = new V3CompletionKey(txnId, OperationType.ADD_ENTRY);\n@@ -493,15 +533,18 @@ void addEntry(final long ledgerId, byte[] masterKey, final long entryId, Channel\n                     .setOperation(OperationType.ADD_ENTRY)\n                     .setTxnId(txnId);\n \n+            byte[] toSendArray = new byte[toSend.readableBytes()];\n+            toSend.getBytes(toSend.readerIndex(), toSendArray);\n             AddRequest.Builder addBuilder = AddRequest.newBuilder()\n                     .setLedgerId(ledgerId)\n                     .setEntryId(entryId)\n                     .setMasterKey(ByteString.copyFrom(masterKey))\n-                    .setBody(ByteString.copyFrom(toSend.toByteBuffer()));\n+                    .setBody(ByteString.copyFrom(toSendArray));\n \n             if (((short) options & BookieProtocol.FLAG_RECOVERY_ADD) == BookieProtocol.FLAG_RECOVERY_ADD) {\n                 addBuilder.setFlag(AddRequest.Flag.RECOVERY_ADD);\n             }\n+\n             request = Request.newBuilder()\n                     .setHeader(headerBuilder)\n                     .setAddRequest(addBuilder)\n@@ -519,23 +562,24 @@ void addEntry(final long ledgerId, byte[] masterKey, final long entryId, Channel\n         final Channel c = channel;\n         if (c == null) {\n             errorOutAddKey(completionKey);\n+            toSend.release();\n             return;\n         }\n         try {\n-            ChannelFuture future = c.write(addRequest);\n+            ChannelFuture future = c.writeAndFlush(addRequest);\n             future.addListener(new ChannelFutureListener() {\n                 @Override\n                 public void operationComplete(ChannelFuture future) throws Exception {\n                     if (future.isSuccess()) {\n                         if (LOG.isDebugEnabled()) {\n                             LOG.debug(\"Successfully wrote request for adding entry: \" + entryId + \" ledger-id: \" + ledgerId\n-                                                            + \" bookie: \" + c.getRemoteAddress() + \" entry length: \" + entrySize);\n+                                                            + \" bookie: \" + c.remoteAddress() + \" entry length: \" + entrySize);\n                         }\n                         // totalBytesOutstanding.addAndGet(entrySize);\n                     } else {\n-                        if (!(future.getCause() instanceof ClosedChannelException)) {\n+                        if (!(future.cause() instanceof ClosedChannelException)) {\n                             LOG.warn(\"Writing addEntry(lid={}, eid={}) to channel {} failed : \",\n-                                    new Object[] { ledgerId, entryId, c, future.getCause() });\n+                                    new Object[] { ledgerId, entryId, c, future.cause() });\n                         }\n                         errorOutAddKey(completionKey);\n                     }\n@@ -594,19 +638,19 @@ ctx, ledgerId, entryId, scheduleTimeout(completionKey, readEntryTimeout))) != nu\n \n         final Object readRequest = request;\n         try {\n-            ChannelFuture future = c.write(readRequest);\n+            ChannelFuture future = c.writeAndFlush(readRequest);\n             future.addListener(new ChannelFutureListener() {\n                     @Override\n                     public void operationComplete(ChannelFuture future) throws Exception {\n                         if (future.isSuccess()) {\n                             if (LOG.isDebugEnabled()) {\n                                 LOG.debug(\"Successfully wrote request {} to {}\",\n-                                          readRequest, c.getRemoteAddress());\n+                                          readRequest, c.remoteAddress());\n                             }\n                         } else {\n-                            if (!(future.getCause() instanceof ClosedChannelException)) {\n+                            if (!(future.cause() instanceof ClosedChannelException)) {\n                                 LOG.warn(\"Writing readEntryAndFenceLedger(lid={}, eid={}) to channel {} failed : \",\n-                                        new Object[] { ledgerId, entryId, c, future.getCause() });\n+                                        new Object[] { ledgerId, entryId, c, future.cause() });\n                             }\n                             errorOutReadKey(completionKey);\n                         }\n@@ -623,8 +667,8 @@ public void readLac(final long ledgerId, ReadLacCallback cb, Object ctx) {\n         CompletionKey completion = null;\n         if (useV2WireProtocol) {\n             request = new BookieProtocol.ReadRequest(BookieProtocol.CURRENT_PROTOCOL_VERSION,\n-                    ledgerId, (long) 0, (short) 0);\n-            completion = new V2CompletionKey(ledgerId, (long) 0, OperationType.READ_LAC);\n+                    ledgerId, 0, (short) 0);\n+            completion = new V2CompletionKey(ledgerId, 0, OperationType.READ_LAC);\n         } else {\n             final long txnId = getTxnId();\n             completion = new V3CompletionKey(txnId, OperationType.READ_LAC);\n@@ -654,17 +698,17 @@ public void readLac(final long ledgerId, ReadLacCallback cb, Object ctx) {\n         }\n \n         try {\n-            ChannelFuture future = c.write(readLacRequest);\n+            ChannelFuture future = c.writeAndFlush(readLacRequest);\n             future.addListener(new ChannelFutureListener() {\n                 @Override\n                 public void operationComplete(ChannelFuture future) throws Exception {\n                     if (future.isSuccess()) {\n                         LOG.debug(\"Succssfully wrote request {} to {}\",\n-                                    readLacRequest, c.getRemoteAddress());\n+                                readLacRequest, c.remoteAddress());\n                     } else {\n-                        if (!(future.getCause() instanceof ClosedChannelException)) {\n+                        if (!(future.cause() instanceof ClosedChannelException)) {\n                             LOG.warn(\"Writing readLac(lid = {}) to channel {} failed : \",\n-                                    new Object[] { ledgerId, c, future.getCause() });\n+                                    new Object[] { ledgerId, c, future.cause() });\n                         }\n                         errorOutReadLacKey(completionKey);\n                     }\n@@ -715,19 +759,19 @@ public void readEntry(final long ledgerId, final long entryId, ReadEntryCallback\n         }\n \n         try{\n-            ChannelFuture future = c.write(readRequest);\n+            ChannelFuture future = c.writeAndFlush(readRequest);\n             future.addListener(new ChannelFutureListener() {\n                 @Override\n                 public void operationComplete(ChannelFuture future) throws Exception {\n                     if (future.isSuccess()) {\n                         if (LOG.isDebugEnabled()) {\n                             LOG.debug(\"Successfully wrote request {} to {}\",\n-                                      readRequest, c.getRemoteAddress());\n+                                      readRequest, c.remoteAddress());\n                         }\n                     } else {\n-                        if (!(future.getCause() instanceof ClosedChannelException)) {\n+                        if (!(future.cause() instanceof ClosedChannelException)) {\n                             LOG.warn(\"Writing readEntry(lid={}, eid={}) to channel {} failed : \",\n-                                    new Object[] { ledgerId, entryId, c, future.getCause() });\n+                                    new Object[] { ledgerId, entryId, c, future.cause() });\n                         }\n                         errorOutReadKey(completionKey);\n                     }\n@@ -767,19 +811,19 @@ public void getBookieInfo(final long requested, GetBookieInfoCallback cb, Object\n         }\n \n         try{\n-            ChannelFuture future = c.write(getBookieInfoRequest);\n+            ChannelFuture future = c.writeAndFlush(getBookieInfoRequest);\n             future.addListener(new ChannelFutureListener() {\n                 @Override\n                 public void operationComplete(ChannelFuture future) throws Exception {\n                     if (future.isSuccess()) {\n                         if (LOG.isDebugEnabled()) {\n                             LOG.debug(\"Successfully wrote request {} to {}\",\n-                                    getBookieInfoRequest, c.getRemoteAddress());\n+                                    getBookieInfoRequest, c.remoteAddress());\n                         }\n                     } else {\n-                        if (!(future.getCause() instanceof ClosedChannelException)) {\n+                        if (!(future.cause() instanceof ClosedChannelException)) {\n                             LOG.warn(\"Writing GetBookieInfoRequest(flags={}) to channel {} failed : \",\n-                                    new Object[] { requested, c, future.getCause() });\n+                                    new Object[] { requested, c, future.cause() });\n                         }\n                         errorOutReadKey(completionKey);\n                     }\n@@ -846,10 +890,6 @@ private void closeInternal(boolean permanent, boolean wait) {\n \n     private ChannelFuture closeChannel(Channel c) {\n         LOG.debug(\"Closing channel {}\", c);\n-        ReadTimeoutHandler timeout = c.getPipeline().get(ReadTimeoutHandler.class);\n-        if (timeout != null) {\n-            timeout.releaseExternalResources();\n-        }\n         return c.close();\n     }\n \n@@ -868,8 +908,8 @@ void errorOutReadKey(final CompletionKey key, final int rc) {\n             public void safeRun() {\n                 String bAddress = \"null\";\n                 Channel c = channel;\n-                if (c != null && c.getRemoteAddress() != null) {\n-                    bAddress = c.getRemoteAddress().toString();\n+                if (c != null && c.remoteAddress() != null) {\n+                    bAddress = c.remoteAddress().toString();\n                 }\n \n                 LOG.debug(\"Could not write request for reading entry: {} ledger-id: {} bookie: {} rc: {}\",\n@@ -902,7 +942,7 @@ public void safeRun() {\n                 String bAddress = \"null\";\n                 Channel c = channel;\n                 if (c != null) {\n-                    bAddress = c.getRemoteAddress().toString();\n+                    bAddress = c.remoteAddress().toString();\n                 }\n                 LOG.debug(\"Could not write request writeLac for ledgerId: {} bookie: {}\",\n                           new Object[] { writeLacCompletion.ledgerId, bAddress});\n@@ -927,7 +967,7 @@ public void safeRun() {\n                 String bAddress = \"null\";\n                 Channel c = channel;\n                 if (c != null) {\n-                    bAddress = c.getRemoteAddress().toString();\n+                    bAddress = c.remoteAddress().toString();\n                 }\n                 LOG.debug(\"Could not write request readLac for ledgerId: {} bookie: {}\",\n                           new Object[] { readLacCompletion.ledgerId, bAddress});\n@@ -950,8 +990,8 @@ void errorOutAddKey(final CompletionKey key, final int rc) {\n             public void safeRun() {\n                 String bAddress = \"null\";\n                 Channel c = channel;\n-                if(c != null && c.getRemoteAddress() != null) {\n-                    bAddress = c.getRemoteAddress().toString();\n+                if (c != null && c.remoteAddress() != null) {\n+                    bAddress = c.remoteAddress().toString();\n                 }\n                 LOG.debug(\"Could not write request for adding entry: {} ledger-id: {} bookie: {} rc: {}\",\n                           new Object[] { addCompletion.entryId, addCompletion.ledgerId, bAddress, rc });\n@@ -983,7 +1023,7 @@ public void safeRun() {\n                 String bAddress = \"null\";\n                 Channel c = channel;\n                 if (c != null) {\n-                    bAddress = c.getRemoteAddress().toString();\n+                    bAddress = c.remoteAddress().toString();\n                 }\n                 LOG.debug(\"Could not write getBookieInfo request for bookie: {}\", new Object[] {bAddress});\n                 getBookieInfoCompletion.cb.getBookieInfoComplete(rc, new BookieInfo(), getBookieInfoCompletion.ctx);\n@@ -1026,41 +1066,20 @@ void recordError() {\n         }\n     }\n \n-    /**\n-     * In the netty pipeline, we need to split packets based on length, so we\n-     * use the {@link LengthFieldBasedFrameDecoder}. Other than that all actions\n-     * are carried out in this class, e.g., making sense of received messages,\n-     * prepending the length to outgoing packets etc.\n-     */\n-    @Override\n-    public ChannelPipeline getPipeline() throws Exception {\n-        ChannelPipeline pipeline = Channels.pipeline();\n-\n-        pipeline.addLast(\"lengthbasedframedecoder\", new LengthFieldBasedFrameDecoder(maxFrameSize, 0, 4, 0, 4));\n-        pipeline.addLast(\"lengthprepender\", new LengthFieldPrepender(4));\n-        pipeline.addLast(\"bookieProtoEncoder\", new BookieProtoEncoding.RequestEncoder(extRegistry));\n-        pipeline.addLast(\"bookieProtoDecoder\", new BookieProtoEncoding.ResponseDecoder(extRegistry));\n-        pipeline.addLast(\"authHandler\", new AuthHandler.ClientSideHandler(authProviderFactory, txnIdGenerator,\n-            connectionPeer));\n-        pipeline.addLast(\"mainhandler\", this);\n-        return pipeline;\n-    }\n-\n     /**\n      * If our channel has disconnected, we just error out the pending entries\n      */\n     @Override\n-    public void channelDisconnected(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception {\n-        Channel c = ctx.getChannel();\n-        LOG.info(\"Disconnected from bookie channel {}\", c);\n-        if (c != null) {\n-            closeChannel(c);\n+    public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n+        LOG.info(\"Disconnected from bookie channel {}\", ctx.channel());\n+        if (ctx.channel() != null) {\n+            closeChannel(ctx.channel());\n         }\n \n         errorOutOutstandingEntries(BKException.Code.BookieHandleNotAvailableException);\n \n         synchronized (this) {\n-            if (this.channel == c\n+            if (this.channel == ctx.channel()\n                 && state != ConnectionState.CLOSED) {\n                 state = ConnectionState.DISCONNECTED;\n             }\n@@ -1075,56 +1094,60 @@ public void channelDisconnected(ChannelHandlerContext ctx, ChannelStateEvent e)\n      * (mostly due to what we do in the netty threads)\n      */\n     @Override\n-    public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e) throws Exception {\n-        Throwable t = e.getCause();\n-        if (t instanceof CorruptedFrameException || t instanceof TooLongFrameException) {\n-            LOG.error(\"Corrupted frame received from bookie: {}\",\n-                      e.getChannel().getRemoteAddress());\n+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n+        if (cause instanceof CorruptedFrameException || cause instanceof TooLongFrameException) {\n+            LOG.error(\"Corrupted frame received from bookie: {}\", ctx.channel().remoteAddress());\n+            ctx.close();\n             return;\n         }\n \n-        if (t instanceof AuthHandler.AuthenticationException) {\n-            LOG.error(\"Error authenticating connection\", t);\n+        if (cause instanceof AuthHandler.AuthenticationException) {\n+            LOG.error(\"Error authenticating connection\", cause);\n             errorOutOutstandingEntries(BKException.Code.UnauthorizedAccessException);\n-            Channel c = ctx.getChannel();\n+            Channel c = ctx.channel();\n             if (c != null) {\n                 closeChannel(c);\n             }\n             return;\n         }\n \n-        if (t instanceof IOException) {\n+        if (cause instanceof IOException) {\n             // these are thrown when a bookie fails, logging them just pollutes\n             // the logs (the failure is logged from the listeners on the write\n             // operation), so I'll just ignore it here.\n+            ctx.close();\n             return;\n         }\n \n         synchronized (this) {\n             if (state == ConnectionState.CLOSED) {\n-                LOG.debug(\"Unexpected exception caught by bookie client channel handler, \"\n-                          + \"but the client is closed, so it isn't important\", t);\n+                if (LOG.isDebugEnabled()) {\n+                    LOG.debug(\"Unexpected exception caught by bookie client channel handler, \"\n+                            + \"but the client is closed, so it isn't important\", cause);\n+                }\n             } else {\n-                LOG.error(\"Unexpected exception caught by bookie client channel handler\", t);\n+                LOG.error(\"Unexpected exception caught by bookie client channel handler\", cause);\n             }\n         }\n+\n         // Since we are a library, cant terminate App here, can we?\n+        ctx.close();\n     }\n \n     /**\n      * Called by netty when a message is received on a channel\n      */\n     @Override\n-    public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Exception {\n+\tpublic void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n \n-        if (e.getMessage() instanceof BookieProtocol.Response) {\n-            BookieProtocol.Response response = (BookieProtocol.Response) e.getMessage();\n+        if (msg instanceof BookieProtocol.Response) {\n+            BookieProtocol.Response response = (BookieProtocol.Response) msg;\n             readV2Response(response);\n-        } else if (e.getMessage() instanceof Response) {\n-            Response response = (Response) e.getMessage();\n+        } else if (msg instanceof Response) {\n+            Response response = (Response) msg;\n             readV3Response(response);\n         } else {\n-            ctx.sendUpstream(e);\n+        \tctx.fireChannelRead(msg);\n         }\n     }\n \n@@ -1156,7 +1179,7 @@ public void safeRun() {\n                         }\n                         case READ_ENTRY: {\n                             BookieProtocol.ReadResponse readResponse = (BookieProtocol.ReadResponse) response;\n-                            ChannelBuffer data = null;\n+                            ByteBuf data = null;\n                             if (readResponse.hasData()) {\n                               data = readResponse.getData();\n                             }\n@@ -1244,9 +1267,9 @@ public void safeRun() {\n                         case READ_ENTRY: {\n                             ReadResponse readResponse = response.getReadResponse();\n                             StatusCode status = response.getStatus() == StatusCode.EOK ? readResponse.getStatus() : response.getStatus();\n-                            ChannelBuffer buffer = ChannelBuffers.buffer(0);\n+                            ByteBuf buffer = Unpooled.EMPTY_BUFFER;\n                             if (readResponse.hasBody()) {\n-                                buffer = ChannelBuffers.copiedBuffer(readResponse.getBody().asReadOnlyByteBuffer());\n+                                buffer = Unpooled.wrappedBuffer(readResponse.getBody().asReadOnlyByteBuffer());\n                             }\n                             handleReadResponse(readResponse.getLedgerId(), readResponse.getEntryId(), status, buffer, completionValue);\n                             break;\n@@ -1259,17 +1282,17 @@ public void safeRun() {\n                         }\n                         case READ_LAC: {\n                             ReadLacResponse readLacResponse = response.getReadLacResponse();\n-                            ChannelBuffer lacBuffer = ChannelBuffers.buffer(0);\n-                            ChannelBuffer lastEntryBuffer = ChannelBuffers.buffer(0);\n+                            ByteBuf lacBuffer = Unpooled.EMPTY_BUFFER;\n+                            ByteBuf lastEntryBuffer = Unpooled.EMPTY_BUFFER;\n                             StatusCode status = response.getStatus() == StatusCode.EOK ? readLacResponse.getStatus() : response.getStatus();\n                             // Thread.dumpStack();\n \n                             if (readLacResponse.hasLacBody()) {\n-                                lacBuffer = ChannelBuffers.copiedBuffer(readLacResponse.getLacBody().asReadOnlyByteBuffer());\n+                                lacBuffer = Unpooled.wrappedBuffer(readLacResponse.getLacBody().asReadOnlyByteBuffer());\n                             }\n \n                             if (readLacResponse.hasLastEntryBody()) {\n-                                lastEntryBuffer = ChannelBuffers.copiedBuffer(readLacResponse.getLastEntryBody().asReadOnlyByteBuffer());\n+                                lastEntryBuffer = Unpooled.wrappedBuffer(readLacResponse.getLastEntryBody().asReadOnlyByteBuffer());\n                             }\n                             handleReadLacResponse(readLacResponse.getLedgerId(), status, lacBuffer, lastEntryBuffer, completionValue);\n                             break;\n@@ -1335,7 +1358,7 @@ void handleAddResponse(long ledgerId, long entryId, StatusCode status, Completio\n         ac.cb.writeComplete(rcToRet, ledgerId, entryId, addr, ac.ctx);\n     }\n \n-    void handleReadLacResponse(long ledgerId, StatusCode status, ChannelBuffer lacBuffer, ChannelBuffer lastEntryBuffer, CompletionValue completionValue) {\n+    void handleReadLacResponse(long ledgerId, StatusCode status, ByteBuf lacBuffer, ByteBuf lastEntryBuffer, CompletionValue completionValue) {\n         // The completion value should always be an instance of an WriteLacCompletion object when we reach here.\n         ReadLacCompletion glac = (ReadLacCompletion)completionValue;\n \n@@ -1350,11 +1373,10 @@ void handleReadLacResponse(long ledgerId, StatusCode status, ChannelBuffer lacBu\n         glac.cb.readLacComplete(rcToRet, ledgerId, lacBuffer.slice(), lastEntryBuffer.slice(), glac.ctx);\n     }\n \n-    void handleReadResponse(long ledgerId, long entryId, StatusCode status, ChannelBuffer buffer, CompletionValue completionValue) {\n+    void handleReadResponse(long ledgerId, long entryId, StatusCode status, ByteBuf buffer, CompletionValue completionValue) {\n         // The completion value should always be an instance of a ReadCompletion object when we reach here.\n         ReadCompletion rc = (ReadCompletion)completionValue;\n \n-\n         if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Got response for read request from bookie: \" + addr + \" for ledger: \" + ledgerId + \" entry: \"\n                     + entryId + \" rc: \" + rc + \" entry length: \" + buffer.readableBytes());\n@@ -1466,7 +1488,8 @@ public ReadLacCompletion(final OpStatsLogger readLacOpLogger, final ReadLacCallb\n             final long startTime = MathUtils.nowInNano();\n             this.cb = null == readLacOpLogger ? originalCallback : new ReadLacCallback() {\n                 @Override\n-                public void readLacComplete(int rc, long ledgerId, ChannelBuffer lacBuffer, ChannelBuffer lastEntryBuffer, Object ctx) {\n+                public void readLacComplete(int rc, long ledgerId, ByteBuf lacBuffer, ByteBuf lastEntryBuffer,\n+                        Object ctx) {\n                     cancelTimeout();\n                     long latency = MathUtils.elapsedNanos(startTime);\n                     if (rc != BKException.Code.OK) {\n@@ -1497,7 +1520,7 @@ public ReadCompletion(final PerChannelBookieClient pcbc, final OpStatsLogger rea\n             final long startTime = MathUtils.nowInNano();\n             this.cb = new ReadEntryCallback() {\n                 @Override\n-                public void readEntryComplete(int rc, long ledgerId, long entryId, ChannelBuffer buffer, Object ctx) {\n+                public void readEntryComplete(int rc, long ledgerId, long entryId, ByteBuf buffer, Object ctx) {\n                     cancelTimeout();\n                     if (readEntryOpLogger != null) {\n                         long latency = MathUtils.elapsedNanos(startTime);"},{"sha":"b7618e307d89e46fab38cb5da6649a08b6fbb850","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClientPool.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FPerChannelBookieClientPool.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FPerChannelBookieClientPool.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FPerChannelBookieClientPool.java?ref=74f795136c1fff3badb29fc982d0cc2d43096b45","patch":"@@ -38,7 +38,7 @@ interface PerChannelBookieClientPool {\n      * @param callback\n      *          callback to return channel from channel pool.\n      */\n-    void obtain(GenericCallback<PerChannelBookieClient> callback);\n+    void obtain(GenericCallback<PerChannelBookieClient> callback, long key);\n \n     /**\n      * record any read/write error on {@link PerChannelBookieClientPool}"},{"sha":"bd983747e59668630ed7aab624ece7b6936d8fb5","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/ReadEntryProcessor.java","status":"modified","additions":3,"deletions":2,"changes":5,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FReadEntryProcessor.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FReadEntryProcessor.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FReadEntryProcessor.java?ref=74f795136c1fff3badb29fc982d0cc2d43096b45","patch":"@@ -17,6 +17,8 @@\n  */\n package org.apache.bookkeeper.proto;\n \n+import io.netty.channel.Channel;\n+\n import java.io.IOException;\n import java.nio.ByteBuffer;\n import java.util.concurrent.ExecutionException;\n@@ -28,7 +30,6 @@\n import org.apache.bookkeeper.bookie.BookieException;\n import org.apache.bookkeeper.proto.BookieProtocol.Request;\n import org.apache.bookkeeper.util.MathUtils;\n-import org.jboss.netty.channel.Channel;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -52,7 +53,7 @@ protected void processPacket() {\n         try {\n             Future<Boolean> fenceResult = null;\n             if (read.isFencingRequest()) {\n-                LOG.warn(\"Ledger \" + request.getLedgerId() + \" fenced by \" + channel.getRemoteAddress());\n+                LOG.warn(\"Ledger: {}  fenced by: {}\", request.getLedgerId(), channel.remoteAddress());\n \n                 if (read.hasMasterKey()) {\n                     fenceResult = requestProcessor.bookie.fenceLedger(read.getLedgerId(), read.getMasterKey());"},{"sha":"fbfa71fe116fac6e967201070e42befa61d0f96e","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/ReadEntryProcessorV3.java","status":"modified","additions":5,"deletions":4,"changes":9,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FReadEntryProcessorV3.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FReadEntryProcessorV3.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FReadEntryProcessorV3.java?ref=74f795136c1fff3badb29fc982d0cc2d43096b45","patch":"@@ -17,6 +17,8 @@\n  */\n package org.apache.bookkeeper.proto;\n \n+import io.netty.channel.Channel;\n+\n import java.io.IOException;\n import java.nio.ByteBuffer;\n import java.util.concurrent.ExecutionException;\n@@ -32,7 +34,6 @@\n import org.apache.bookkeeper.proto.BookkeeperProtocol.Response;\n import org.apache.bookkeeper.proto.BookkeeperProtocol.StatusCode;\n import org.apache.bookkeeper.util.MathUtils;\n-import org.jboss.netty.channel.Channel;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -69,14 +70,14 @@ private ReadResponse getReadResponse() {\n             Future<Boolean> fenceResult = null;\n             if (readRequest.hasFlag() && readRequest.getFlag().equals(ReadRequest.Flag.FENCE_LEDGER)) {\n                 LOG.warn(\"Ledger fence request received for ledger: {} from address: {}\", ledgerId,\n-                         channel.getRemoteAddress());\n+                         channel.remoteAddress());\n \n                 if (readRequest.hasMasterKey()) {\n                     byte[] masterKey = readRequest.getMasterKey().toByteArray();\n                     fenceResult = requestProcessor.bookie.fenceLedger(ledgerId, masterKey);\n                 } else {\n                     LOG.error(\"Fence ledger request received without master key for ledger:{} from address: {}\",\n-                              ledgerId, channel.getRemoteAddress());\n+                              ledgerId, channel.remoteAddress());\n                     throw BookieException.create(BookieException.Code.UnauthorizedAccessException);\n                 }\n             }\n@@ -129,7 +130,7 @@ private ReadResponse getReadResponse() {\n             LOG.error(\"IOException while reading entry:{} from ledger:{}\", entryId, ledgerId);\n         } catch (BookieException e) {\n             LOG.error(\"Unauthorized access to ledger:{} while reading entry:{} in request from address: {}\",\n-                    new Object[]{ledgerId, entryId, channel.getRemoteAddress()});\n+                    new Object[]{ledgerId, entryId, channel.remoteAddress()});\n             status = StatusCode.EUA;\n         }\n "},{"sha":"0fbdbec3c6ee582e9087245c0dfc9e095749d958","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/ReadLacProcessorV3.java","status":"modified","additions":3,"deletions":2,"changes":5,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FReadLacProcessorV3.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FReadLacProcessorV3.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FReadLacProcessorV3.java?ref=74f795136c1fff3badb29fc982d0cc2d43096b45","patch":"@@ -31,13 +31,14 @@\n import org.apache.bookkeeper.proto.BookkeeperProtocol.Response;\n import org.apache.bookkeeper.proto.BookkeeperProtocol.StatusCode;\n import org.apache.bookkeeper.util.MathUtils;\n-import org.jboss.netty.channel.Channel;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n import com.google.protobuf.ByteString;\n \n-class ReadLacProcessorV3 extends PacketProcessorBaseV3 {\n+import io.netty.channel.Channel;\n+\n+class ReadLacProcessorV3 extends PacketProcessorBaseV3 implements Runnable {\n     private final static Logger logger = LoggerFactory.getLogger(ReadLacProcessorV3.class);\n \n     public ReadLacProcessorV3(Request request, Channel channel,"},{"sha":"1418437248560a144bd6df48591b8daae2862a8f","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/ResponseBuilder.java","status":"modified","additions":3,"deletions":2,"changes":5,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FResponseBuilder.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FResponseBuilder.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FResponseBuilder.java?ref=74f795136c1fff3badb29fc982d0cc2d43096b45","patch":"@@ -20,8 +20,9 @@\n  */\n package org.apache.bookkeeper.proto;\n \n+import io.netty.buffer.Unpooled;\n+\n import java.nio.ByteBuffer;\n-import org.jboss.netty.buffer.ChannelBuffers;\n \n class ResponseBuilder {\n     static BookieProtocol.Response buildErrorResponse(int errorCode, BookieProtocol.Request r) {\n@@ -42,6 +43,6 @@ static BookieProtocol.Response buildAddResponse(BookieProtocol.Request r) {\n \n     static BookieProtocol.Response buildReadResponse(ByteBuffer data, BookieProtocol.Request r) {\n         return new BookieProtocol.ReadResponse(r.getProtocolVersion(), BookieProtocol.EOK,\n-                r.getLedgerId(), r.getEntryId(), ChannelBuffers.wrappedBuffer(data));\n+                r.getLedgerId(), r.getEntryId(), Unpooled.wrappedBuffer(data));\n     }\n }"},{"sha":"ab19ce09fb5735dbd35ae908942abc59709b3f9c","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/VMLocalChannelManager.java","status":"removed","additions":0,"deletions":63,"changes":63,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/811ece53a1c975c4e768422f3d622ac9de6b3e41/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FVMLocalChannelManager.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/811ece53a1c975c4e768422f3d622ac9de6b3e41/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FVMLocalChannelManager.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FVMLocalChannelManager.java?ref=811ece53a1c975c4e768422f3d622ac9de6b3e41","patch":"@@ -1,63 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.bookkeeper.proto;\n-\n-import java.io.IOException;\n-import org.apache.bookkeeper.bookie.Bookie;\n-import org.apache.bookkeeper.conf.ServerConfiguration;\n-import org.apache.bookkeeper.net.BookieSocketAddress;\n-import org.jboss.netty.bootstrap.ServerBootstrap;\n-import org.jboss.netty.channel.Channel;\n-import org.jboss.netty.channel.ChannelFactory;\n-import org.jboss.netty.channel.ChannelPipelineFactory;\n-import org.jboss.netty.channel.local.DefaultLocalServerChannelFactory;\n-\n-/**\n- * Manages VM-local channels\n- *\n- * @author enrico.olivelli\n- */\n-public class VMLocalChannelManager extends ChannelManager {\n-\n-    private ChannelFactory channelFactory;\n-    private BookieSocketAddress bookieAddress;\n-\n-    @Override\n-    public Channel start(ServerConfiguration conf, ChannelPipelineFactory bookiePipelineFactory) throws IOException {\n-        BookieSocketAddress bookieAddress = Bookie.getBookieAddress(conf);\n-        this.channelFactory = new DefaultLocalServerChannelFactory();\n-        this.bookieAddress = bookieAddress;\n-        ServerBootstrap jvmbootstrap = new ServerBootstrap(channelFactory);\n-        jvmbootstrap.setPipelineFactory(bookiePipelineFactory);\n-\n-        // use the same address 'name', so clients can find local Bookie still discovering them using ZK\n-        Channel jvmlisten = jvmbootstrap.bind(bookieAddress.getLocalAddress());\n-        LocalBookiesRegistry.registerLocalBookieAddress(bookieAddress);\n-        return jvmlisten;\n-    }\n-\n-    @Override\n-    public void close() {\n-        LocalBookiesRegistry.unregisterLocalBookieAddress(bookieAddress);\n-        if (channelFactory != null) {\n-            channelFactory.releaseExternalResources();\n-        }\n-        channelFactory = null;\n-    }\n-\n-}"},{"sha":"46f7f7dc471d093b1b8ec98094eda1f6468e75aa","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/WriteEntryProcessor.java","status":"modified","additions":5,"deletions":1,"changes":6,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FWriteEntryProcessor.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FWriteEntryProcessor.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FWriteEntryProcessor.java?ref=74f795136c1fff3badb29fc982d0cc2d43096b45","patch":"@@ -17,6 +17,8 @@\n  */\n package org.apache.bookkeeper.proto;\n \n+import io.netty.channel.Channel;\n+\n import java.io.IOException;\n import java.util.concurrent.TimeUnit;\n \n@@ -25,7 +27,6 @@\n import org.apache.bookkeeper.proto.BookieProtocol.Request;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteCallback;\n import org.apache.bookkeeper.util.MathUtils;\n-import org.jboss.netty.channel.Channel;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -76,7 +77,10 @@ protected void processPacket() {\n         } catch (BookieException e) {\n             LOG.error(\"Unauthorized access to ledger \" + add.getLedgerId(), e);\n             rc = BookieProtocol.EUA;\n+        } finally {\n+            add.release();\n         }\n+\n         if (rc != BookieProtocol.EOK) {\n             requestProcessor.addEntryStats.registerFailedEvent(MathUtils.elapsedNanos(startTimeNanos),\n                     TimeUnit.NANOSECONDS);"},{"sha":"e34e89416aa18145211829624aa3ce64f78577ca","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/WriteEntryProcessorV3.java","status":"modified","additions":2,"deletions":1,"changes":3,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FWriteEntryProcessorV3.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FWriteEntryProcessorV3.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FWriteEntryProcessorV3.java?ref=74f795136c1fff3badb29fc982d0cc2d43096b45","patch":"@@ -20,6 +20,8 @@\n  */\n package org.apache.bookkeeper.proto;\n \n+import io.netty.channel.Channel;\n+\n import java.io.IOException;\n import java.nio.ByteBuffer;\n import java.util.concurrent.TimeUnit;\n@@ -32,7 +34,6 @@\n import org.apache.bookkeeper.proto.BookkeeperProtocol.Response;\n import org.apache.bookkeeper.proto.BookkeeperProtocol.StatusCode;\n import org.apache.bookkeeper.util.MathUtils;\n-import org.jboss.netty.channel.Channel;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n "},{"sha":"097a573a26a3a5ff990a370fd7d901a55beb52ed","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/WriteLacProcessorV3.java","status":"modified","additions":3,"deletions":2,"changes":5,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FWriteLacProcessorV3.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FWriteLacProcessorV3.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FWriteLacProcessorV3.java?ref=74f795136c1fff3badb29fc982d0cc2d43096b45","patch":"@@ -31,11 +31,12 @@\n import org.apache.bookkeeper.proto.BookkeeperProtocol.Response;\n import org.apache.bookkeeper.proto.BookkeeperProtocol.StatusCode;\n import org.apache.bookkeeper.util.MathUtils;\n-import org.jboss.netty.channel.Channel;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-class WriteLacProcessorV3 extends PacketProcessorBaseV3 {\n+import io.netty.channel.Channel;\n+\n+class WriteLacProcessorV3 extends PacketProcessorBaseV3 implements Runnable {\n     private final static Logger logger = LoggerFactory.getLogger(WriteLacProcessorV3.class);\n \n     public WriteLacProcessorV3(Request request, Channel channel,"},{"sha":"3b4c83a5571e5e5519f9a2dbc4a9dd7a33c31f32","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/util/DoubleByteBuf.java","status":"added","additions":468,"deletions":0,"changes":468,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2FDoubleByteBuf.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2FDoubleByteBuf.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2FDoubleByteBuf.java?ref=74f795136c1fff3badb29fc982d0cc2d43096b45","patch":"@@ -0,0 +1,468 @@\n+/*\n+* Licensed to the Apache Software Foundation (ASF) under one\n+* or more contributor license agreements.  See the NOTICE file\n+* distributed with this work for additional information\n+* regarding copyright ownership.  The ASF licenses this file\n+* to you under the Apache License, Version 2.0 (the\n+* \"License\"); you may not use this file except in compliance\n+* with the License.  You may obtain a copy of the License at\n+*\n+*     http://www.apache.org/licenses/LICENSE-2.0\n+*\n+* Unless required by applicable law or agreed to in writing, software\n+* distributed under the License is distributed on an \"AS IS\" BASIS,\n+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+* See the License for the specific language governing permissions and\n+* limitations under the License.\n+*/\n+package org.apache.bookkeeper.util;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.lang.reflect.Constructor;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.channels.FileChannel;\n+import java.nio.channels.GatheringByteChannel;\n+import java.nio.channels.ScatteringByteChannel;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.netty.buffer.AbstractReferenceCountedByteBuf;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.buffer.PooledByteBufAllocator;\n+import io.netty.buffer.Unpooled;\n+import io.netty.util.Recycler;\n+import io.netty.util.Recycler.Handle;\n+import io.netty.util.ResourceLeakDetector;\n+import io.netty.util.ResourceLeakDetectorFactory;\n+import io.netty.util.ResourceLeakTracker;\n+\n+/**\n+ * ByteBuf that holds 2 buffers. Similar to {@see CompositeByteBuf} but doesn't allocate list to hold them.\n+ */\n+@SuppressWarnings(\"unchecked\")\n+public final class DoubleByteBuf extends AbstractReferenceCountedByteBuf {\n+\n+    private ByteBuf b1;\n+    private ByteBuf b2;\n+    private final Handle<DoubleByteBuf> recyclerHandle;\n+\n+    private static final Recycler<DoubleByteBuf> RECYCLER = new Recycler<DoubleByteBuf>() {\n+        @Override\n+        protected DoubleByteBuf newObject(Recycler.Handle<DoubleByteBuf> handle) {\n+            return new DoubleByteBuf(handle);\n+        }\n+    };\n+\n+    private DoubleByteBuf(Handle<DoubleByteBuf> recyclerHandle) {\n+        super(Integer.MAX_VALUE);\n+        this.recyclerHandle = recyclerHandle;\n+    }\n+\n+    public static ByteBuf get(ByteBuf b1, ByteBuf b2) {\n+        DoubleByteBuf buf = RECYCLER.get();\n+        buf.setRefCnt(1);\n+\n+        // Make sure the buffers are not deallocated as long as we hold them. Also, buffers can get retained/releases\n+        // outside of DoubleByteBuf scope\n+        buf.b1 = b1.retain();\n+        buf.b2 = b2.retain();\n+        buf.setIndex(0, b1.readableBytes() + b2.readableBytes());\n+        return toLeakAwareBuffer(buf);\n+    }\n+\n+    public ByteBuf getFirst() {\n+        return b1;\n+    }\n+\n+    public ByteBuf getSecond() {\n+        return b2;\n+    }\n+\n+    @Override\n+    public boolean isDirect() {\n+        return b1.isDirect() && b2.isDirect();\n+    }\n+\n+    @Override\n+    public boolean hasArray() {\n+        // There's no single array available\n+        return false;\n+    }\n+\n+    @Override\n+    public byte[] array() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public int arrayOffset() {\n+\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean hasMemoryAddress() {\n+        return false;\n+    }\n+\n+    @Override\n+    public long memoryAddress() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public int capacity() {\n+        return b1.capacity() + b2.capacity();\n+    }\n+\n+    @Override\n+    public int readableBytes() {\n+        return b1.readableBytes() + b2.readableBytes();\n+    }\n+\n+    @Override\n+    public int writableBytes() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public DoubleByteBuf capacity(int newCapacity) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public ByteBufAllocator alloc() {\n+        return PooledByteBufAllocator.DEFAULT;\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public ByteOrder order() {\n+        return ByteOrder.BIG_ENDIAN;\n+    }\n+\n+    @Override\n+    public byte getByte(int index) {\n+        if (index < b1.writerIndex()) {\n+            return b1.getByte(index);\n+        } else {\n+            return b2.getByte(index - b1.writerIndex());\n+        }\n+    }\n+\n+    @Override\n+    protected byte _getByte(int index) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    protected short _getShort(int index) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    protected short _getShortLE(int index) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    protected int _getUnsignedMediumLE(int index) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    protected int _getIntLE(int index) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    protected long _getLongLE(int index) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    protected void _setShortLE(int index, int value) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    protected void _setMediumLE(int index, int value) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    protected void _setIntLE(int index, int value) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    protected void _setLongLE(int index, long value) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public int getBytes(int index, FileChannel out, long position, int length) throws IOException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public int setBytes(int index, FileChannel in, long position, int length) throws IOException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    protected int _getUnsignedMedium(int index) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    protected int _getInt(int index) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    protected long _getLong(int index) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public DoubleByteBuf getBytes(int index, byte[] dst, int dstIndex, int length) {\n+        return getBytes(index, Unpooled.wrappedBuffer(dst), dstIndex, length);\n+    }\n+\n+    @Override\n+    public ByteBuf getBytes(int index, ByteBuffer dst) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public DoubleByteBuf getBytes(int index, ByteBuf dst, int dstIndex, int length) {\n+        checkDstIndex(index, length, dstIndex, dst.capacity());\n+        if (length == 0) {\n+            return this;\n+        }\n+\n+        int b1Length = Math.min(length, b1.readableBytes() - index);\n+        if (b1Length > 0) {\n+            b1.getBytes(b1.readerIndex() + index, dst, dstIndex, b1Length);\n+            dstIndex += b1Length;\n+            length -= b1Length;\n+            index = 0;\n+        } else {\n+            index -= b1.readableBytes();\n+        }\n+\n+        if (length > 0) {\n+            int b2Length = Math.min(length, b2.readableBytes() - index);\n+            b2.getBytes(b2.readerIndex() + index, dst, dstIndex, b2Length);\n+        }\n+        return this;\n+    }\n+\n+    @Override\n+    public int getBytes(int index, GatheringByteChannel out, int length) throws IOException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public DoubleByteBuf getBytes(int index, OutputStream out, int length) throws IOException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public DoubleByteBuf setByte(int index, int value) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    protected void _setByte(int index, int value) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public DoubleByteBuf setShort(int index, int value) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    protected void _setShort(int index, int value) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public DoubleByteBuf setMedium(int index, int value) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    protected void _setMedium(int index, int value) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public DoubleByteBuf setInt(int index, int value) {\n+        return (DoubleByteBuf) super.setInt(index, value);\n+    }\n+\n+    @Override\n+    protected void _setInt(int index, int value) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public DoubleByteBuf setLong(int index, long value) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    protected void _setLong(int index, long value) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public DoubleByteBuf setBytes(int index, byte[] src, int srcIndex, int length) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public DoubleByteBuf setBytes(int index, ByteBuffer src) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public DoubleByteBuf setBytes(int index, ByteBuf src, int srcIndex, int length) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public int setBytes(int index, InputStream in, int length) throws IOException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public int setBytes(int index, ScatteringByteChannel in, int length) throws IOException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public ByteBuf copy(int index, int length) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public int nioBufferCount() {\n+        return b1.nioBufferCount() + b2.nioBufferCount();\n+    }\n+\n+    @Override\n+    public ByteBuffer internalNioBuffer(int index, int length) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public ByteBuffer nioBuffer(int index, int length) {\n+        ByteBuffer dst = ByteBuffer.allocate(length);\n+        ByteBuf b = Unpooled.wrappedBuffer(dst);\n+        b.writerIndex(0);\n+        getBytes(index, b, length);\n+        return dst;\n+    }\n+\n+    @Override\n+    public ByteBuffer[] nioBuffers(int index, int length) {\n+        return new ByteBuffer[] { nioBuffer(index, length) };\n+    }\n+\n+    @Override\n+    public DoubleByteBuf discardReadBytes() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        String result = super.toString();\n+        result = result.substring(0, result.length() - 1);\n+        return result + \", components=2)\";\n+    }\n+\n+    @Override\n+    public ByteBuffer[] nioBuffers() {\n+        return nioBuffers(readerIndex(), readableBytes());\n+    }\n+\n+    @Override\n+    protected void deallocate() {\n+        // Double release of buffer for the initial ref-count and the internal retain() when the DoubleByteBuf was\n+        // created\n+        b1.release(2);\n+        b2.release(2);\n+        b1 = b2 = null;\n+        recyclerHandle.recycle(this);\n+    }\n+\n+    @Override\n+    public ByteBuf unwrap() {\n+        return null;\n+    }\n+\n+    private static final Logger log = LoggerFactory.getLogger(DoubleByteBuf.class);\n+\n+    private static final ResourceLeakDetector<DoubleByteBuf> leakDetector = ResourceLeakDetectorFactory.instance()\n+            .newResourceLeakDetector(DoubleByteBuf.class);\n+    private static final Constructor<ByteBuf> simpleLeakAwareByteBufConstructor;\n+    private static final Constructor<ByteBuf> advancedLeakAwareByteBufConstructor;\n+\n+    static {\n+        Constructor<ByteBuf> _simpleLeakAwareByteBufConstructor = null;\n+        Constructor<ByteBuf> _advancedLeakAwareByteBufConstructor = null;\n+        try {\n+            Class<?> simpleLeakAwareByteBufClass = Class.forName(\"io.netty.buffer.SimpleLeakAwareByteBuf\");\n+            _simpleLeakAwareByteBufConstructor = (Constructor<ByteBuf>) simpleLeakAwareByteBufClass\n+                    .getDeclaredConstructor(ByteBuf.class, ResourceLeakTracker.class);\n+            _simpleLeakAwareByteBufConstructor.setAccessible(true);\n+\n+            Class<?> advancedLeakAwareByteBufClass = Class.forName(\"io.netty.buffer.AdvancedLeakAwareByteBuf\");\n+            _advancedLeakAwareByteBufConstructor = (Constructor<ByteBuf>) advancedLeakAwareByteBufClass\n+                    .getDeclaredConstructor(ByteBuf.class, ResourceLeakTracker.class);\n+            _advancedLeakAwareByteBufConstructor.setAccessible(true);\n+        } catch (Throwable t) {\n+            log.error(\"Failed to use reflection to enable leak detection\", t);\n+        } finally {\n+            simpleLeakAwareByteBufConstructor = _simpleLeakAwareByteBufConstructor;\n+            advancedLeakAwareByteBufConstructor = _advancedLeakAwareByteBufConstructor;\n+        }\n+    }\n+\n+    private static ByteBuf toLeakAwareBuffer(DoubleByteBuf buf) {\n+        try {\n+            ResourceLeakTracker<DoubleByteBuf> leak;\n+            switch (ResourceLeakDetector.getLevel()) {\n+            case DISABLED:\n+                break;\n+\n+            case SIMPLE:\n+                leak = leakDetector.track(buf);\n+                if (leak != null) {\n+                    return simpleLeakAwareByteBufConstructor.newInstance(buf, leak);\n+                }\n+                break;\n+            case ADVANCED:\n+            case PARANOID:\n+                leak = leakDetector.track(buf);\n+                if (leak != null) {\n+                    return advancedLeakAwareByteBufConstructor.newInstance(buf, leak);\n+                }\n+                break;\n+            }\n+            return buf;\n+        } catch (Throwable t) {\n+            // Catch reflection exception\n+            throw new RuntimeException(t);\n+        }\n+    }\n+}\n\\ No newline at end of file"},{"sha":"e2b3c477d6e2a9822e02b74c9cdf4adcb3adcf88","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/BookieInitializationTest.java","status":"modified","additions":6,"deletions":5,"changes":11,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FBookieInitializationTest.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FBookieInitializationTest.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FBookieInitializationTest.java?ref=74f795136c1fff3badb29fc982d0cc2d43096b45","patch":"@@ -38,7 +38,6 @@\n import org.apache.zookeeper.ZooKeeper;\n import org.apache.zookeeper.data.Stat;\n import org.apache.zookeeper.KeeperException;\n-import org.jboss.netty.channel.ChannelException;\n import org.junit.Test;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -268,9 +267,11 @@ public void testDuplicateBookieServerStartup() throws Exception {\n             BookieServer bs2 = new BookieServer(conf);\n             bs2.start();\n             fail(\"Should throw BindException, as the bk server is already running!\");\n-        } catch (ChannelException ce) {\n-            Assert.assertTrue(\"Should be caused by a bind exception\",\n-                              ce.getCause() instanceof BindException);            \n+        } catch (BindException e) {\n+            // Ok\n+        } catch (IOException e) {\n+            Assert.assertTrue(\"BKServer allowed duplicate Startups!\",\n+                    e.getMessage().contains(\"bind\"));\n         }\n     }\n \n@@ -292,7 +293,7 @@ public void testStartBookieWithoutZKServer() throws Exception {\n             fail(\"Should throw ConnectionLossException as ZKServer is not running!\");\n         } catch (KeeperException.ConnectionLossException e) {\n             // expected behaviour\n-        } \n+        }\n     }\n \n     /**"},{"sha":"1dfa32ee70d7de248dc09a8f155098c3dffd56ef","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/BookieJournalTest.java","status":"modified","additions":27,"deletions":21,"changes":48,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FBookieJournalTest.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FBookieJournalTest.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FBookieJournalTest.java?ref=74f795136c1fff3badb29fc982d0cc2d43096b45","patch":"@@ -23,6 +23,8 @@\n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertFalse;\n import static org.junit.Assert.fail;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n \n import java.io.File;\n import java.io.IOException;\n@@ -116,14 +118,14 @@ private ByteBuffer generateFenceEntry(long ledgerId) {\n     /**\n      * Generate meta entry with given master key\n      */\n-    private ByteBuffer generateMetaEntry(long ledgerId, byte[] masterKey) {\n+    private ByteBuf generateMetaEntry(long ledgerId, byte[] masterKey) {\n         ByteBuffer bb = ByteBuffer.allocate(8 + 8 + 4 + masterKey.length);\n         bb.putLong(ledgerId);\n         bb.putLong(Bookie.METAENTRY_ID_LEDGER_KEY);\n         bb.putInt(masterKey.length);\n         bb.put(masterKey);\n         bb.flip();\n-        return bb;\n+        return Unpooled.wrappedBuffer(bb);\n     }\n \n     private void writeJunkJournal(File journalDir) throws Exception {\n@@ -154,14 +156,15 @@ private void writePreV2Journal(File journalDir, int numEntries) throws Exception\n         byte[] data = \"JournalTestData\".getBytes();\n         long lastConfirmed = LedgerHandle.INVALID_ENTRY_ID;\n         for (int i = 1; i <= numEntries; i++) {\n-            ByteBuffer packet = ClientUtil.generatePacket(1, i, lastConfirmed, i*data.length, data).toByteBuffer();\n+            ByteBuf packet = ClientUtil.generatePacket(1, i, lastConfirmed, i*data.length, data);\n             lastConfirmed = i;\n             ByteBuffer lenBuff = ByteBuffer.allocate(4);\n-            lenBuff.putInt(packet.remaining());\n+            lenBuff.putInt(packet.readableBytes());\n             lenBuff.flip();\n \n             fc.write(lenBuff);\n-            fc.write(packet);\n+            fc.write(packet.nioBuffer());\n+            packet.release();\n         }\n     }\n \n@@ -197,14 +200,15 @@ private JournalChannel writeV2Journal(File journalDir, int numEntries) throws Ex\n         Arrays.fill(data, (byte)'X');\n         long lastConfirmed = LedgerHandle.INVALID_ENTRY_ID;\n         for (int i = 1; i <= numEntries; i++) {\n-            ByteBuffer packet = ClientUtil.generatePacket(1, i, lastConfirmed, i*data.length, data).toByteBuffer();\n+            ByteBuf packet = ClientUtil.generatePacket(1, i, lastConfirmed, i*data.length, data);\n             lastConfirmed = i;\n             ByteBuffer lenBuff = ByteBuffer.allocate(4);\n-            lenBuff.putInt(packet.remaining());\n+            lenBuff.putInt(packet.readableBytes());\n             lenBuff.flip();\n \n             bc.write(lenBuff);\n-            bc.write(packet);\n+            bc.write(packet.nioBuffer());\n+            packet.release();\n         }\n         bc.flush(true);\n \n@@ -225,19 +229,20 @@ private JournalChannel writeV3Journal(File journalDir, int numEntries, byte[] ma\n         Arrays.fill(data, (byte)'X');\n         long lastConfirmed = LedgerHandle.INVALID_ENTRY_ID;\n         for (int i = 0; i <= numEntries; i++) {\n-            ByteBuffer packet;\n+            ByteBuf packet;\n             if (i == 0) {\n                 packet = generateMetaEntry(1, masterKey);\n             } else {\n-                packet = ClientUtil.generatePacket(1, i, lastConfirmed, i*data.length, data).toByteBuffer();\n+                packet = ClientUtil.generatePacket(1, i, lastConfirmed, i*data.length, data);\n             }\n             lastConfirmed = i;\n             ByteBuffer lenBuff = ByteBuffer.allocate(4);\n-            lenBuff.putInt(packet.remaining());\n+            lenBuff.putInt(packet.readableBytes());\n             lenBuff.flip();\n \n             bc.write(lenBuff);\n-            bc.write(packet);\n+            bc.write(packet.nioBuffer());\n+            packet.release();\n         }\n         bc.flush(true);\n \n@@ -258,18 +263,19 @@ private JournalChannel writeV4Journal(File journalDir, int numEntries, byte[] ma\n         Arrays.fill(data, (byte)'X');\n         long lastConfirmed = LedgerHandle.INVALID_ENTRY_ID;\n         for (int i = 0; i <= numEntries; i++) {\n-            ByteBuffer packet;\n+            ByteBuf packet;\n             if (i == 0) {\n                 packet = generateMetaEntry(1, masterKey);\n             } else {\n-                packet = ClientUtil.generatePacket(1, i, lastConfirmed, i * data.length, data).toByteBuffer();\n+                packet = ClientUtil.generatePacket(1, i, lastConfirmed, i * data.length, data);\n             }\n             lastConfirmed = i;\n             ByteBuffer lenBuff = ByteBuffer.allocate(4);\n-            lenBuff.putInt(packet.remaining());\n+            lenBuff.putInt(packet.readableBytes());\n             lenBuff.flip();\n             bc.write(lenBuff);\n-            bc.write(packet);\n+            bc.write(packet.nioBuffer());\n+            packet.release();\n         }\n         // write fence key\n         ByteBuffer packet = generateFenceEntry(1);\n@@ -296,20 +302,20 @@ private JournalChannel writeV5Journal(File journalDir, int numEntries, byte[] ma\n         long lastConfirmed = LedgerHandle.INVALID_ENTRY_ID;\n         long length = 0;\n         for (int i = 0; i <= numEntries; i++) {\n-            ByteBuffer packet;\n+            ByteBuf packet;\n             if (i == 0) {\n                 packet = generateMetaEntry(1, masterKey);\n             } else {\n-                packet = ClientUtil.generatePacket(1, i, lastConfirmed,\n-                        length, data, 0, i).toByteBuffer();\n+                packet = ClientUtil.generatePacket(1, i, lastConfirmed, length, data, 0, i);\n             }\n             lastConfirmed = i;\n             length += i;\n             ByteBuffer lenBuff = ByteBuffer.allocate(4);\n-            lenBuff.putInt(packet.remaining());\n+            lenBuff.putInt(packet.readableBytes());\n             lenBuff.flip();\n             bc.write(lenBuff);\n-            bc.write(packet);\n+            bc.write(packet.nioBuffer());\n+            packet.release();\n             Journal.writePaddingBytes(jc, paddingBuff, JournalChannel.SECTOR_SIZE);\n         }\n         // write fence key"},{"sha":"f47e7459f23c13eea93e5be4b10ac64382bbb3fb","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/UpgradeTest.java","status":"modified","additions":6,"deletions":4,"changes":10,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FUpgradeTest.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FUpgradeTest.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FUpgradeTest.java?ref=74f795136c1fff3badb29fc982d0cc2d43096b45","patch":"@@ -23,6 +23,7 @@\n \n import static org.junit.Assert.assertTrue;\n import static org.junit.Assert.fail;\n+import io.netty.buffer.ByteBuf;\n \n import java.io.BufferedWriter;\n import java.io.File;\n@@ -88,15 +89,16 @@ static JournalChannel writeJournal(File journalDir, int numEntries, byte[] maste\n         long lastConfirmed = LedgerHandle.INVALID_ENTRY_ID;\n \n         for (int i = 1; i <= numEntries; i++) {\n-            ByteBuffer packet = ClientUtil.generatePacket(ledgerId, i, lastConfirmed,\n-                                                          i*data.length, data).toByteBuffer();\n+            ByteBuf packet = ClientUtil.generatePacket(ledgerId, i, lastConfirmed,\n+                                                          i*data.length, data);\n             lastConfirmed = i;\n             ByteBuffer lenBuff = ByteBuffer.allocate(4);\n-            lenBuff.putInt(packet.remaining());\n+            lenBuff.putInt(packet.readableBytes());\n             lenBuff.flip();\n \n             bc.write(lenBuff);\n-            bc.write(packet);\n+            bc.write(packet.nioBuffer());\n+            packet.release();\n         }\n         bc.flush(true);\n "},{"sha":"9ec835d974de28e75211bcafdfb3402f21eb76b0","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookKeeperTest.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookKeeperTest.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookKeeperTest.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookKeeperTest.java?ref=74f795136c1fff3badb29fc982d0cc2d43096b45","patch":"@@ -194,7 +194,7 @@ public void addComplete(int rc, LedgerHandle lh, long entryId, Object ctx) {\n     public void testCloseDuringOp() throws Exception {\n         ClientConfiguration conf = new ClientConfiguration()\n             .setZkServers(zkUtil.getZooKeeperConnectString());\n-        for (int i = 0; i < 100; i++) {\n+        for (int i = 0; i < 10; i++) {\n             final BookKeeper client = new BookKeeper(conf);\n             final CountDownLatch l = new CountDownLatch(1);\n             final AtomicBoolean success = new AtomicBoolean(false);"},{"sha":"3fc86ad85c570fd32ae05a42653ae9b3fdcea5a8","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookKeeperTestClient.java","status":"modified","additions":0,"deletions":13,"changes":13,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookKeeperTestClient.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookKeeperTestClient.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookKeeperTestClient.java?ref=74f795136c1fff3badb29fc982d0cc2d43096b45","patch":"@@ -22,23 +22,10 @@\n  */\n \n import java.io.IOException;\n-import java.util.concurrent.Executors;\n \n import org.apache.bookkeeper.conf.ClientConfiguration;\n-import org.apache.bookkeeper.client.AsyncCallback.CreateCallback;\n-import org.apache.bookkeeper.client.AsyncCallback.DeleteCallback;\n-import org.apache.bookkeeper.client.AsyncCallback.OpenCallback;\n-import org.apache.bookkeeper.client.BKException.Code;\n-import org.apache.bookkeeper.proto.BookieClient;\n-import org.apache.bookkeeper.util.OrderedSafeExecutor;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n import org.apache.zookeeper.KeeperException;\n-import org.apache.zookeeper.WatchedEvent;\n-import org.apache.zookeeper.Watcher;\n import org.apache.zookeeper.ZooKeeper;\n-import org.jboss.netty.channel.socket.ClientSocketChannelFactory;\n-import org.jboss.netty.channel.socket.nio.NioClientSocketChannelFactory;\n \n /**\n  * Test BookKeeperClient which allows access to members we don't"},{"sha":"ae0a07ffb9cd3a48a01ad13916051b2e241470f6","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookieRecoveryTest.java","status":"modified","additions":3,"deletions":2,"changes":5,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookieRecoveryTest.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookieRecoveryTest.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookieRecoveryTest.java?ref=74f795136c1fff3badb29fc982d0cc2d43096b45","patch":"@@ -30,13 +30,14 @@\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ReadEntryCallback;\n import org.apache.bookkeeper.test.MultiLedgerManagerMultiDigestTestCase;\n-import org.jboss.netty.buffer.ChannelBuffer;\n import org.junit.After;\n import org.junit.Before;\n import org.junit.Test;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import io.netty.buffer.ByteBuf;\n+\n import java.io.IOException;\n import java.net.InetAddress;\n import java.util.ArrayList;\n@@ -483,7 +484,7 @@ private static class ReplicationVerificationCallback implements ReadEntryCallbac\n         }\n \n         @Override\n-        public void readEntryComplete(int rc, long ledgerId, long entryId, ChannelBuffer buffer, Object ctx) {\n+        public void readEntryComplete(int rc, long ledgerId, long entryId, ByteBuf buffer, Object ctx) {\n             if (LOG.isDebugEnabled()) {\n                 LOG.debug(\"Got \" + rc + \" for ledger \" + ledgerId + \" entry \" + entryId + \" from \" + ctx);\n             }"},{"sha":"25b0d6b3ce4e5e0ee4ad7a42510c69e1770d5658","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/ClientUtil.java","status":"modified","additions":3,"deletions":3,"changes":6,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FClientUtil.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FClientUtil.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FClientUtil.java?ref=74f795136c1fff3badb29fc982d0cc2d43096b45","patch":"@@ -17,15 +17,15 @@\n  */\n package org.apache.bookkeeper.client;\n \n-import org.jboss.netty.buffer.ChannelBuffer;\n+import io.netty.buffer.ByteBuf;\n \n public class ClientUtil {\n-    public static ChannelBuffer generatePacket(long ledgerId, long entryId, long lastAddConfirmed,\n+    public static ByteBuf generatePacket(long ledgerId, long entryId, long lastAddConfirmed,\n                                                long length, byte[] data) {\n         return generatePacket(ledgerId, entryId, lastAddConfirmed, length, data, 0, data.length);\n     }\n \n-    public static ChannelBuffer generatePacket(long ledgerId, long entryId, long lastAddConfirmed,\n+    public static ByteBuf generatePacket(long ledgerId, long entryId, long lastAddConfirmed,\n                                                long length, byte[] data, int offset, int len) {\n         CRC32DigestManager dm = new CRC32DigestManager(ledgerId);\n         return dm.computeDigestAndPackageForSending(entryId, lastAddConfirmed, length,"},{"sha":"d77d1841f6d591b4b646b1fa364b42c79169ed03","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/SlowBookieTest.java","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FSlowBookieTest.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FSlowBookieTest.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FSlowBookieTest.java?ref=74f795136c1fff3badb29fc982d0cc2d43096b45","patch":"@@ -165,6 +165,7 @@ public void run() {\n                     try {\n                         while (!finished.get()) {\n                             lh.addEntry(entry);\n+                            Thread.sleep(1);\n                         }\n                     } catch (Exception e) {\n                         LOG.error(\"Exception in add entry thread\", e);"},{"sha":"6ff1535134db207a96b469ef73133875fc8397ba","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestGetBookieInfoTimeout.java","status":"modified","additions":9,"deletions":9,"changes":18,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FTestGetBookieInfoTimeout.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FTestGetBookieInfoTimeout.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FTestGetBookieInfoTimeout.java?ref=74f795136c1fff3badb29fc982d0cc2d43096b45","patch":"@@ -24,34 +24,34 @@\n import static org.junit.Assert.assertTrue;\n \n import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.Executors;\n \n import org.apache.bookkeeper.client.BKException.Code;\n import org.apache.bookkeeper.client.BookKeeper.DigestType;\n import org.apache.bookkeeper.client.BookieInfoReader.BookieInfo;\n import org.apache.bookkeeper.conf.ClientConfiguration;\n import org.apache.bookkeeper.net.BookieSocketAddress;\n import org.apache.bookkeeper.proto.BookieClient;\n-import org.apache.bookkeeper.proto.BookkeeperProtocol;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GetBookieInfoCallback;\n+import org.apache.bookkeeper.proto.BookkeeperProtocol;\n import org.apache.bookkeeper.test.BookKeeperClusterTestCase;\n import org.apache.bookkeeper.util.OrderedSafeExecutor;\n-import org.jboss.netty.channel.socket.ClientSocketChannelFactory;\n-import org.jboss.netty.channel.socket.nio.NioClientSocketChannelFactory;\n import org.junit.After;\n import org.junit.Before;\n import org.junit.Test;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+\n /**\n  * This unit test tests timeout of GetBookieInfo request;\n  *\n  */\n public class TestGetBookieInfoTimeout extends BookKeeperClusterTestCase {\n     private final static Logger LOG = LoggerFactory.getLogger(TestGetBookieInfoTimeout.class);\n     DigestType digestType;\n-    public ClientSocketChannelFactory channelFactory;\n+    public EventLoopGroup eventLoopGroup;\n     public OrderedSafeExecutor executor;\n \n     public TestGetBookieInfoTimeout() {\n@@ -62,8 +62,8 @@ public TestGetBookieInfoTimeout() {\n     @Before\n     public void setUp() throws Exception {\n         super.setUp();\n-        channelFactory = new NioClientSocketChannelFactory(Executors.newCachedThreadPool(), Executors\n-                .newCachedThreadPool());\n+        eventLoopGroup = new NioEventLoopGroup();\n+\n         executor = OrderedSafeExecutor.newBuilder()\n                 .name(\"BKClientOrderedSafeExecutor\")\n                 .numThreads(2)\n@@ -72,7 +72,7 @@ public void setUp() throws Exception {\n \n     @After\n     public void tearDown() throws Exception {\n-        channelFactory.releaseExternalResources();\n+        eventLoopGroup.shutdownGracefully();\n         executor.shutdown();\n     }\n \n@@ -99,7 +99,7 @@ public void testGetBookieInfoTimeout() throws Exception {\n         // try to get bookie info from the sleeping bookie. It should fail with timeout error\n         BookieSocketAddress addr = new BookieSocketAddress(bookieToSleep.getSocketAddress().getHostString(),\n                 bookieToSleep.getPort());\n-        BookieClient bc = new BookieClient(cConf, channelFactory, executor);\n+        BookieClient bc = new BookieClient(cConf, eventLoopGroup, executor);\n         long flags = BookkeeperProtocol.GetBookieInfoRequest.Flags.FREE_DISK_SPACE_VALUE |\n                 BookkeeperProtocol.GetBookieInfoRequest.Flags.TOTAL_DISK_CAPACITY_VALUE;\n "},{"sha":"99f8f5b05f9012cc1581be72c2242f52964f48f3","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestRackawareEnsemblePlacementPolicy.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FTestRackawareEnsemblePlacementPolicy.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FTestRackawareEnsemblePlacementPolicy.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FTestRackawareEnsemblePlacementPolicy.java?ref=74f795136c1fff3badb29fc982d0cc2d43096b45","patch":"@@ -32,6 +32,7 @@\n import com.google.common.base.Optional;\n import com.google.common.util.concurrent.ThreadFactoryBuilder;\n \n+import io.netty.util.HashedWheelTimer;\n import junit.framework.TestCase;\n import org.apache.bookkeeper.client.BKException.BKNotEnoughBookiesException;\n import org.apache.bookkeeper.client.BookieInfoReader.BookieInfo;\n@@ -40,7 +41,6 @@\n import org.apache.bookkeeper.net.DNSToSwitchMapping;\n import org.apache.bookkeeper.net.NetworkTopology;\n import org.apache.bookkeeper.util.StaticDNSResolver;\n-import org.jboss.netty.util.HashedWheelTimer;\n import org.junit.Test;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -54,7 +54,7 @@ public class TestRackawareEnsemblePlacementPolicy extends TestCase {\n     final List<Integer> writeSet = new ArrayList<Integer>();\n     ClientConfiguration conf = new ClientConfiguration();\n     BookieSocketAddress addr1, addr2, addr3, addr4;\n-    HashedWheelTimer timer;\n+    io.netty.util.HashedWheelTimer timer;\n \n     @Override\n     protected void setUp() throws Exception {"},{"sha":"ef90401bfc5766821f72bcf6c8db984f06d4a0b1","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestRackawareEnsemblePlacementPolicyUsingScript.java","status":"modified","additions":2,"deletions":1,"changes":3,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FTestRackawareEnsemblePlacementPolicyUsingScript.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FTestRackawareEnsemblePlacementPolicyUsingScript.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FTestRackawareEnsemblePlacementPolicyUsingScript.java?ref=74f795136c1fff3badb29fc982d0cc2d43096b45","patch":"@@ -39,7 +39,6 @@\n import org.apache.bookkeeper.net.DNSToSwitchMapping;\n import org.apache.bookkeeper.net.ScriptBasedMapping;\n import org.apache.bookkeeper.util.Shell;\n-import org.jboss.netty.util.HashedWheelTimer;\n import org.junit.After;\n import org.junit.Assume;\n import org.junit.Before;\n@@ -50,6 +49,8 @@\n import com.google.common.base.Optional;\n import com.google.common.util.concurrent.ThreadFactoryBuilder;\n \n+import io.netty.util.HashedWheelTimer;\n+\n /**\n  * In this testsuite, ScriptBasedMapping is used as DNS_RESOLVER_CLASS for\n  * mapping nodes to racks. Shell Script -"},{"sha":"09c6262fb15b64d4333c64e093e5b69c810f1f3e","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestRegionAwareEnsemblePlacementPolicy.java","status":"modified","additions":3,"deletions":1,"changes":4,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FTestRegionAwareEnsemblePlacementPolicy.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FTestRegionAwareEnsemblePlacementPolicy.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FTestRegionAwareEnsemblePlacementPolicy.java?ref=74f795136c1fff3badb29fc982d0cc2d43096b45","patch":"@@ -27,6 +27,9 @@\n \n import com.google.common.base.Optional;\n import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+\n+import io.netty.util.HashedWheelTimer;\n+\n import org.apache.bookkeeper.client.BKException.BKNotEnoughBookiesException;\n import org.apache.bookkeeper.conf.ClientConfiguration;\n import org.apache.bookkeeper.feature.Feature;\n@@ -38,7 +41,6 @@\n import org.apache.bookkeeper.net.NetworkTopology;\n import org.apache.bookkeeper.util.BookKeeperConstants;\n import org.apache.bookkeeper.util.StaticDNSResolver;\n-import org.jboss.netty.util.HashedWheelTimer;\n import org.junit.Test;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;"},{"sha":"41f35a7e20208b46536bc14cd060d7ba4b66dd35","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/proto/NetworkLessBookieTest.java","status":"modified","additions":5,"deletions":3,"changes":8,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FNetworkLessBookieTest.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FNetworkLessBookieTest.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FNetworkLessBookieTest.java?ref=74f795136c1fff3badb29fc982d0cc2d43096b45","patch":"@@ -32,6 +32,9 @@\n import org.junit.Assert;\n import org.junit.Test;\n \n+import io.netty.channel.Channel;\n+import io.netty.channel.local.LocalChannel;\n+\n /**\n  * Tests of the main BookKeeper client using networkless comunication\n  */\n@@ -68,12 +71,11 @@ public void testUseLocalBookie() throws Exception {\n         }\n \n         for (BookieServer bk : bs) {\n-            for (ChannelManager channel : bk.nettyServer.channels) {\n-                if (! (channel instanceof VMLocalChannelManager)) {\n+            for (Channel channel : bk.nettyServer.allChannels) {\n+                if (!(channel instanceof LocalChannel)) {\n                     Assert.fail();\n                 }\n             }\n         }\n     }\n-\n }"},{"sha":"ed2a4b5e9966f4f1866bf35dd041e1977d9b4dbc","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/proto/TestBackwardCompatCMS42.java","status":"modified","additions":25,"deletions":38,"changes":63,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FTestBackwardCompatCMS42.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FTestBackwardCompatCMS42.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FTestBackwardCompatCMS42.java?ref=74f795136c1fff3badb29fc982d0cc2d43096b45","patch":"@@ -29,27 +29,22 @@\n \n import com.google.protobuf.ExtensionRegistry;\n \n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+\n import org.apache.bookkeeper.auth.ClientAuthProvider;\n import org.apache.bookkeeper.conf.ClientConfiguration;\n import org.apache.bookkeeper.net.BookieSocketAddress;\n import org.apache.bookkeeper.util.OrderedSafeExecutor;\n import org.apache.bookkeeper.auth.TestAuth;\n-import org.jboss.netty.bootstrap.ClientBootstrap;\n-import org.jboss.netty.channel.Channel;\n-import org.jboss.netty.channel.ChannelFuture;\n-import org.jboss.netty.channel.ChannelHandlerContext;\n-import org.jboss.netty.channel.ChannelStateEvent;\n-import org.jboss.netty.channel.MessageEvent;\n-import org.jboss.netty.channel.socket.ClientSocketChannelFactory;\n import org.apache.bookkeeper.auth.AuthProviderFactoryFactory;\n-import org.jboss.netty.channel.socket.nio.NioClientSocketChannelFactory;\n-\n-import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.Executors;\n \n import org.apache.bookkeeper.proto.BookieProtocol.*;\n import org.apache.bookkeeper.proto.BookkeeperProtocol.AuthMessage;\n \n+import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.ArrayBlockingQueue;\n \n import static org.junit.Assert.*;\n@@ -63,14 +58,14 @@ public class TestBackwardCompatCMS42 extends BookKeeperClusterTestCase {\n \n     ExtensionRegistry extRegistry = ExtensionRegistry.newInstance();\n     ClientAuthProvider.Factory authProvider;\n-    ClientSocketChannelFactory channelFactory\n-        = new NioClientSocketChannelFactory(Executors.newCachedThreadPool(),\n-                                            Executors.newCachedThreadPool());\n+    EventLoopGroup eventLoopGroup = new NioEventLoopGroup();\n     OrderedSafeExecutor executor = OrderedSafeExecutor.newBuilder().numThreads(1).name(\"TestBackwardCompatClient\")\n             .build();\n \n     public TestBackwardCompatCMS42() throws Exception {\n         super(0);\n+\n+        baseConf.setGcWaitTime(60000);\n         authProvider = AuthProviderFactoryFactory.newClientAuthProviderFactory(\n                 new ClientConfiguration());\n     }\n@@ -179,44 +174,36 @@ BookieServer startAndStoreBookie(ServerConfiguration conf) throws Exception {\n     }\n \n     CompatClient42 newCompatClient(BookieSocketAddress addr) throws Exception {\n-        return new CompatClient42(executor, channelFactory, addr, authProvider, extRegistry);\n+        return new CompatClient42(executor, eventLoopGroup, addr, authProvider, extRegistry);\n     }\n \n     // extending PerChannelBookieClient to get the pipeline factory\n     class CompatClient42 extends PerChannelBookieClient {\n         final ArrayBlockingQueue<Response> responses = new ArrayBlockingQueue<Response>(10);\n-        final Channel channel;\n+        Channel channel;\n         final CountDownLatch connected = new CountDownLatch(1);\n \n-        CompatClient42(OrderedSafeExecutor executor, ClientSocketChannelFactory channelFactory,\n+        CompatClient42(OrderedSafeExecutor executor, EventLoopGroup eventLoopGroup,\n                        BookieSocketAddress addr,\n                        ClientAuthProvider.Factory authProviderFactory,\n                        ExtensionRegistry extRegistry) throws Exception {\n-            super(executor, channelFactory, addr, authProviderFactory, extRegistry);\n-\n-            ClientBootstrap bootstrap = new ClientBootstrap(channelFactory);\n-            bootstrap.setPipelineFactory(this);\n-            bootstrap.setOption(\"tcpNoDelay\", false);\n-            bootstrap.setOption(\"keepAlive\", true);\n-            ChannelFuture f = bootstrap.connect(addr.getSocketAddress()).await();\n-            channel = f.getChannel();\n+            super(executor, eventLoopGroup, addr, authProviderFactory, extRegistry);\n+\n+            state = ConnectionState.CONNECTING;\n+            ChannelFuture future = connect();\n+            future.await();\n+            channel = future.channel();\n+            connected.countDown();\n         }\n \n         @Override\n-        public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Exception {\n-            if (!(e.getMessage() instanceof Response)) {\n-                LOG.error(\"Unknown message {}, passing upstream\", e.getMessage());\n-                ctx.sendUpstream(e);\n+        public void channelRead(io.netty.channel.ChannelHandlerContext ctx, Object msg) throws Exception {\n+            if (!(msg instanceof Response)) {\n+                LOG.error(\"Unknown message {}, passing upstream\", msg);\n+                ctx.fireChannelRead(msg);\n                 return;\n             }\n-            responses.add((Response)e.getMessage());\n-        }\n-\n-        @Override\n-        public void channelConnected(ChannelHandlerContext ctx,\n-                                     ChannelStateEvent e)\n-                throws Exception {\n-            connected.countDown();\n+            responses.add((Response) msg);\n         }\n \n         Response takeResponse() throws Exception {\n@@ -229,7 +216,7 @@ Response pollResponse() throws Exception {\n \n         void sendRequest(Request request) throws Exception {\n             connected.await();\n-            channel.write(request);\n+            channel.writeAndFlush(request);\n         }\n     }\n }"},{"sha":"16bbfd0851eaf698491e3298cc1a826583ed9217","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/proto/TestPerChannelBookieClient.java","status":"modified","additions":21,"deletions":30,"changes":51,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FTestPerChannelBookieClient.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FTestPerChannelBookieClient.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FTestPerChannelBookieClient.java?ref=74f795136c1fff3badb29fc982d0cc2d43096b45","patch":"@@ -33,20 +33,20 @@\n import org.apache.bookkeeper.test.BookKeeperClusterTestCase;\n import org.apache.bookkeeper.util.OrderedSafeExecutor;\n import org.apache.bookkeeper.util.SafeRunnable;\n-import org.jboss.netty.buffer.ChannelBuffer;\n-import org.jboss.netty.channel.Channel;\n-import org.jboss.netty.channel.socket.ClientSocketChannelFactory;\n-import org.jboss.netty.channel.socket.nio.NioClientSocketChannelFactory;\n import org.junit.Test;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n import com.google.protobuf.ExtensionRegistry;\n \n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.Channel;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+\n import java.io.IOException;\n import java.nio.ByteBuffer;\n import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.Executors;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicBoolean;\n \n@@ -78,14 +78,12 @@ public TestPerChannelBookieClient() throws Exception {\n      */\n     @Test(timeout=60000)\n     public void testConnectCloseRace() throws Exception {\n-        ClientSocketChannelFactory channelFactory\n-            = new NioClientSocketChannelFactory(Executors.newCachedThreadPool(),\n-                                                Executors.newCachedThreadPool());\n+        EventLoopGroup eventLoopGroup = new NioEventLoopGroup();\n         OrderedSafeExecutor executor = getOrderedSafeExecutor();\n \n         BookieSocketAddress addr = getBookie(0);\n         for (int i = 0; i < 1000; i++) {\n-            PerChannelBookieClient client = new PerChannelBookieClient(executor, channelFactory, addr,\n+            PerChannelBookieClient client = new PerChannelBookieClient(executor, eventLoopGroup, addr,\n                     authProvider, extRegistry);\n             client.connectIfNeededAndDoOp(new GenericCallback<PerChannelBookieClient>() {\n                     @Override\n@@ -96,7 +94,7 @@ public void operationComplete(int rc, PerChannelBookieClient client) {\n                 });\n             client.close();\n         }\n-        channelFactory.releaseExternalResources();\n+        eventLoopGroup.shutdownGracefully();\n         executor.shutdown();\n     }\n \n@@ -123,21 +121,19 @@ public void operationComplete(int rc, PerChannelBookieClient pcbc) {\n                 // we just want to trigger it connecting.\n             }\n         };\n-        ClientSocketChannelFactory channelFactory\n-            = new NioClientSocketChannelFactory(Executors.newCachedThreadPool(),\n-                                                Executors.newCachedThreadPool());\n+        EventLoopGroup eventLoopGroup = new NioEventLoopGroup();\n         OrderedSafeExecutor executor = getOrderedSafeExecutor();\n \n         BookieSocketAddress addr = getBookie(0);\n         for (int i = 0; i < 100; i++) {\n-            PerChannelBookieClient client = new PerChannelBookieClient(executor, channelFactory, addr,\n+            PerChannelBookieClient client = new PerChannelBookieClient(executor, eventLoopGroup, addr,\n                                                                        authProvider, extRegistry);\n             for (int j = i; j < 10; j++) {\n                 client.connectIfNeededAndDoOp(nullop);\n             }\n             client.close();\n         }\n-        channelFactory.releaseExternalResources();\n+        eventLoopGroup.shutdownGracefully();\n         executor.shutdown();\n     }\n \n@@ -157,16 +153,13 @@ public void operationComplete(int rc, PerChannelBookieClient client) {\n             }\n         };\n         final int ITERATIONS = 100000;\n-        ClientSocketChannelFactory channelFactory\n-            = new NioClientSocketChannelFactory(Executors.newCachedThreadPool(),\n-                                                Executors.newCachedThreadPool());\n+        EventLoopGroup eventLoopGroup = new NioEventLoopGroup();\n         OrderedSafeExecutor executor = getOrderedSafeExecutor();\n         BookieSocketAddress addr = getBookie(0);\n \n-        final PerChannelBookieClient client = new PerChannelBookieClient(executor, channelFactory,\n+        final PerChannelBookieClient client = new PerChannelBookieClient(executor, eventLoopGroup,\n                 addr, authProvider, extRegistry);\n         final AtomicBoolean shouldFail = new AtomicBoolean(false);\n-        final AtomicBoolean inconsistent = new AtomicBoolean(false);\n         final AtomicBoolean running = new AtomicBoolean(true);\n         final CountDownLatch disconnectRunning = new CountDownLatch(1);\n         Thread connectThread = new Thread() {\n@@ -206,12 +199,12 @@ public void run() {\n \n                             if ((state == ConnectionState.CONNECTED\n                                  && (channel == null\n-                                     || !channel.isConnected()))\n+                                     || !channel.isActive()))\n                                 || (state != ConnectionState.CONNECTED\n                                     && channel != null\n-                                    && channel.isConnected())) {\n+                                    && channel.isActive())) {\n                                 LOG.error(\"State({}) and channel({}) inconsistent \" + channel,\n-                                          state, channel == null ? null : channel.isConnected());\n+                                          state, channel == null ? null : channel.isActive());\n                                 shouldFail.set(true);\n                                 running.set(false);\n                             }\n@@ -228,7 +221,7 @@ public void run() {\n         checkThread.join();\n         assertFalse(\"Failure in threads, check logs\", shouldFail.get());\n         client.close();\n-        channelFactory.releaseExternalResources();\n+        eventLoopGroup.shutdownGracefully();\n         executor.shutdown();\n     }\n \n@@ -255,19 +248,17 @@ public ByteBuffer readEntry(long ledgerId, long entryId)\n         bsConfs.add(conf);\n         bs.add(startBookie(conf, delayBookie));\n \n-        ClientSocketChannelFactory channelFactory\n-            = new NioClientSocketChannelFactory(Executors.newCachedThreadPool(),\n-                                                Executors.newCachedThreadPool());\n+        EventLoopGroup eventLoopGroup = new NioEventLoopGroup();\n         final OrderedSafeExecutor executor = getOrderedSafeExecutor();\n         BookieSocketAddress addr = getBookie(0);\n \n-        final PerChannelBookieClient client = new PerChannelBookieClient(executor, channelFactory,\n+        final PerChannelBookieClient client = new PerChannelBookieClient(executor, eventLoopGroup,\n                 addr, authProvider, extRegistry);\n         final CountDownLatch completion = new CountDownLatch(1);\n         final ReadEntryCallback cb = new ReadEntryCallback() {\n                 @Override\n                 public void readEntryComplete(int rc, long ledgerId, long entryId,\n-                                              ChannelBuffer buffer, Object ctx) {\n+                    ByteBuf buffer, Object ctx) {\n                     completion.countDown();\n                 }\n             };\n@@ -292,7 +283,7 @@ public void safeRun() {\n         Thread.sleep(1000);\n         client.disconnect();\n         client.close();\n-        channelFactory.releaseExternalResources();\n+        eventLoopGroup.shutdownGracefully();\n         executor.shutdown();\n \n         assertTrue(\"Request should have completed\", completion.await(5, TimeUnit.SECONDS));"},{"sha":"a71dcb524297735f56dcffb547adbc39441b49b4","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookKeeperClusterTestCase.java","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Ftest%2FBookKeeperClusterTestCase.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Ftest%2FBookKeeperClusterTestCase.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Ftest%2FBookKeeperClusterTestCase.java?ref=74f795136c1fff3badb29fc982d0cc2d43096b45","patch":"@@ -446,6 +446,7 @@ public int startNewBookie()\n             throws Exception {\n         ServerConfiguration conf = newServerConfiguration();\n         bsConfs.add(conf);\n+        LOG.info(\"Starting new bookie on port: {}\", conf.getBookiePort());\n         bs.add(startBookie(conf));\n \n         return conf.getBookiePort();"},{"sha":"3d9a5408cdc813eff1455a8d5125d5a83287551f","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieClientTest.java","status":"modified","additions":22,"deletions":28,"changes":50,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Ftest%2FBookieClientTest.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Ftest%2FBookieClientTest.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Ftest%2FBookieClientTest.java?ref=74f795136c1fff3badb29fc982d0cc2d43096b45","patch":"@@ -21,12 +21,16 @@\n  *\n  */\n \n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+\n import java.io.File;\n import java.io.IOException;\n import java.nio.ByteBuffer;\n import java.util.Arrays;\n import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.Executors;\n \n import org.apache.bookkeeper.client.BKException;\n import org.apache.bookkeeper.client.BKException.Code;\n@@ -44,24 +48,18 @@\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteCallback;\n import org.apache.bookkeeper.util.OrderedSafeExecutor;\n import org.apache.bookkeeper.util.IOUtils;\n-import org.jboss.netty.buffer.ChannelBuffer;\n-import org.jboss.netty.buffer.ChannelBuffers;\n-import org.jboss.netty.channel.socket.ClientSocketChannelFactory;\n-import org.jboss.netty.channel.socket.nio.NioClientSocketChannelFactory;\n import org.junit.After;\n import org.junit.Before;\n import org.junit.Test;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n \n import static org.junit.Assert.*;\n \n public class BookieClientTest {\n-    private final static Logger LOG = LoggerFactory.getLogger(BookieClientTest.class);\n     BookieServer bs;\n     File tmpDir;\n     public int port = 13645;\n-    public ClientSocketChannelFactory channelFactory;\n+\n+    public EventLoopGroup eventLoopGroup;\n     public OrderedSafeExecutor executor;\n     ServerConfiguration conf = TestBKConfiguration.newServerConfiguration();\n \n@@ -77,8 +75,7 @@ public void setUp() throws Exception {\n             .setLedgerDirNames(new String[] { tmpDir.getPath() });\n         bs = new BookieServer(conf);\n         bs.start();\n-        channelFactory = new NioClientSocketChannelFactory(Executors.newCachedThreadPool(), Executors\n-                .newCachedThreadPool());\n+        eventLoopGroup = new NioEventLoopGroup();\n         executor = OrderedSafeExecutor.newBuilder()\n                 .name(\"BKClientOrderedSafeExecutor\")\n                 .numThreads(2)\n@@ -89,7 +86,7 @@ public void setUp() throws Exception {\n     public void tearDown() throws Exception {\n         bs.shutdown();\n         recursiveDelete(tmpDir);\n-        channelFactory.releaseExternalResources();\n+        eventLoopGroup.shutdownGracefully();\n         executor.shutdown();\n     }\n \n@@ -110,13 +107,13 @@ static class ResultStruct {\n \n     ReadEntryCallback recb = new ReadEntryCallback() {\n \n-        public void readEntryComplete(int rc, long ledgerId, long entryId, ChannelBuffer bb, Object ctx) {\n+        public void readEntryComplete(int rc, long ledgerId, long entryId, ByteBuf bb, Object ctx) {\n             ResultStruct rs = (ResultStruct) ctx;\n             synchronized (rs) {\n                 rs.rc = rc;\n                 if (BKException.Code.OK == rc && bb != null) {\n                     bb.readerIndex(24);\n-                    rs.entry = bb.toByteBuffer();\n+                    rs.entry = bb.nioBuffer();\n                 }\n                 rs.notifyAll();\n             }\n@@ -146,9 +143,8 @@ public void testWriteGaps() throws Exception {\n         BookieSocketAddress addr = new BookieSocketAddress(\"127.0.0.1\", port);\n         ResultStruct arc = new ResultStruct();\n \n-        BookieClient bc = new BookieClient(new ClientConfiguration(), channelFactory, executor);\n-        ChannelBuffer bb;\n-        bb = createByteBuffer(1, 1, 1);\n+        BookieClient bc = new BookieClient(new ClientConfiguration(), eventLoopGroup, executor);\n+        ByteBuf bb = createByteBuffer(1, 1, 1);\n         bc.addEntry(addr, 1, passwd, 1, bb, wrcb, arc, BookieProtocol.FLAG_NONE);\n         synchronized (arc) {\n             arc.wait(1000);\n@@ -234,22 +230,20 @@ public void testWriteGaps() throws Exception {\n         }\n     }\n \n-    private ChannelBuffer createByteBuffer(int i, long lid, long eid) {\n-        ByteBuffer bb;\n-        bb = ByteBuffer.allocate(4 + 24);\n-        bb.putLong(lid);\n-        bb.putLong(eid);\n-        bb.putLong(eid-1);\n-        bb.putInt(i);\n-        bb.flip();\n-        return ChannelBuffers.wrappedBuffer(bb);\n+    private ByteBuf createByteBuffer(int i, long lid, long eid) {\n+        ByteBuf bb = Unpooled.buffer(4 + 16);\n+        bb.writeLong(lid);\n+        bb.writeLong(eid);\n+        bb.writeLong(eid - 1);\n+        bb.writeInt(i);\n+        return bb;\n     }\n \n     @Test(timeout=60000)\n     public void testNoLedger() throws Exception {\n         ResultStruct arc = new ResultStruct();\n         BookieSocketAddress addr = new BookieSocketAddress(\"127.0.0.1\", port);\n-        BookieClient bc = new BookieClient(new ClientConfiguration(), channelFactory, executor);\n+        BookieClient bc = new BookieClient(new ClientConfiguration(), eventLoopGroup, executor);\n         synchronized (arc) {\n             bc.readEntry(addr, 2, 13, recb, arc);\n             arc.wait(1000);\n@@ -260,7 +254,7 @@ public void testNoLedger() throws Exception {\n     @Test(timeout=60000)\n     public void testGetBookieInfo() throws IOException, InterruptedException {\n         BookieSocketAddress addr = new BookieSocketAddress(\"127.0.0.1\", port);\n-        BookieClient bc = new BookieClient(new ClientConfiguration(), channelFactory, executor);\n+        BookieClient bc = new BookieClient(new ClientConfiguration(), new NioEventLoopGroup(), executor);\n         long flags = BookkeeperProtocol.GetBookieInfoRequest.Flags.FREE_DISK_SPACE_VALUE |\n                 BookkeeperProtocol.GetBookieInfoRequest.Flags.TOTAL_DISK_CAPACITY_VALUE;\n "},{"sha":"5f1f8395b822e02e3ff0731fbe5fbaec0415db79","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieReadWriteTest.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Ftest%2FBookieReadWriteTest.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Ftest%2FBookieReadWriteTest.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Ftest%2FBookieReadWriteTest.java?ref=74f795136c1fff3badb29fc982d0cc2d43096b45","patch":"@@ -260,7 +260,7 @@ private void testReadWriteAsyncSingleClient(int numEntries) throws IOException {\n         }\n     }\n \n-    @Test\n+    @Test(timeout=60000)\n     public void testReadWriteAsyncSingleClient200() throws IOException {\n         testReadWriteAsyncSingleClient(200);\n     }"},{"sha":"771628be82f267417e38342dcc4da57c7c47f930","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/LoopbackClient.java","status":"modified","additions":9,"deletions":10,"changes":19,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Ftest%2FLoopbackClient.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Ftest%2FLoopbackClient.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Ftest%2FLoopbackClient.java?ref=74f795136c1fff3badb29fc982d0cc2d43096b45","patch":"@@ -21,19 +21,19 @@\n  *\n  */\n \n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+\n import java.io.IOException;\n import java.util.Arrays;\n-import java.util.concurrent.Executors;\n \n import org.apache.bookkeeper.conf.ClientConfiguration;\n import org.apache.bookkeeper.net.BookieSocketAddress;\n import org.apache.bookkeeper.proto.BookieClient;\n import org.apache.bookkeeper.proto.BookieProtocol;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteCallback;\n import org.apache.bookkeeper.util.OrderedSafeExecutor;\n-import org.jboss.netty.buffer.ChannelBuffers;\n-import org.jboss.netty.channel.socket.ClientSocketChannelFactory;\n-import org.jboss.netty.channel.socket.nio.NioClientSocketChannelFactory;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -67,8 +67,8 @@ synchronized void increment() {\n         }\n     }\n \n-    LoopbackClient(ClientSocketChannelFactory channelFactory, OrderedSafeExecutor executor, long begin, int limit) throws IOException {\n-        this.client = new BookieClient(new ClientConfiguration(), channelFactory, executor);\n+    LoopbackClient(EventLoopGroup eventLoopGroup, OrderedSafeExecutor executor, long begin, int limit) throws IOException {\n+        this.client = new BookieClient(new ClientConfiguration(), eventLoopGroup, executor);\n         this.begin = begin;\n     }\n \n@@ -78,7 +78,7 @@ void write(long ledgerId, long entry, byte[] data, BookieSocketAddress addr, Wri\n         byte[] passwd = new byte[20];\n         Arrays.fill(passwd, (byte) 'a');\n \n-        client.addEntry(addr, ledgerId, passwd, entry, ChannelBuffers.wrappedBuffer(data), cb, ctx, BookieProtocol.FLAG_NONE);\n+        client.addEntry(addr, ledgerId, passwd, entry, Unpooled.wrappedBuffer(data), cb, ctx, BookieProtocol.FLAG_NONE);\n     }\n \n     public void writeComplete(int rc, long ledgerId, long entryId, BookieSocketAddress addr, Object ctx) {\n@@ -94,15 +94,14 @@ public static void main(String args[]) {\n         long begin = System.currentTimeMillis();\n \n         LoopbackClient lb;\n-        ClientSocketChannelFactory channelFactory = new NioClientSocketChannelFactory(Executors.newCachedThreadPool(), Executors\n-                .newCachedThreadPool());\n+        EventLoopGroup eventLoopGroup = new NioEventLoopGroup();\n         OrderedSafeExecutor executor = OrderedSafeExecutor.newBuilder()\n                 .name(\"BookieClientScheduler\")\n                 .numThreads(2)\n                 .build();\n         try {\n             BookieSocketAddress addr = new BookieSocketAddress(\"127.0.0.1\", Integer.valueOf(args[2]).intValue());\n-            lb = new LoopbackClient(channelFactory, executor, begin, limit.intValue());\n+            lb = new LoopbackClient(eventLoopGroup, executor, begin, limit.intValue());\n \n             for (int i = 0; i < limit; i++) {\n                 lb.write(ledgerId, i, data, addr, lb, c);"},{"sha":"b619d0ed0cd2f50de6fcc38c50db223a36cc5e86","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/util/DoubleByteBufTest.java","status":"added","additions":121,"deletions":0,"changes":121,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2FDoubleByteBufTest.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/74f795136c1fff3badb29fc982d0cc2d43096b45/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2FDoubleByteBufTest.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2FDoubleByteBufTest.java?ref=74f795136c1fff3badb29fc982d0cc2d43096b45","patch":"@@ -0,0 +1,121 @@\n+/*\n+* Licensed to the Apache Software Foundation (ASF) under one\n+* or more contributor license agreements.  See the NOTICE file\n+* distributed with this work for additional information\n+* regarding copyright ownership.  The ASF licenses this file\n+* to you under the Apache License, Version 2.0 (the\n+* \"License\"); you may not use this file except in compliance\n+* with the License.  You may obtain a copy of the License at\n+*\n+*     http://www.apache.org/licenses/LICENSE-2.0\n+*\n+* Unless required by applicable law or agreed to in writing, software\n+* distributed under the License is distributed on an \"AS IS\" BASIS,\n+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+* See the License for the specific language governing permissions and\n+* limitations under the License.\n+*/\n+package org.apache.bookkeeper.util;\n+\n+import static org.junit.Assert.assertArrayEquals;\n+import static org.junit.Assert.assertEquals;\n+\n+import java.nio.ByteBuffer;\n+\n+import org.junit.Test;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+\n+public class DoubleByteBufTest {\n+\n+    @Test(timeout = 30000)\n+    public void testGetBytes() {\n+        ByteBuf b1 = Unpooled.wrappedBuffer(new byte[] { 1, 2, 3 });\n+        ByteBuf b2 = Unpooled.wrappedBuffer(new byte[] { 4, 5, 6 });\n+        doTest(b1, b2);\n+    }\n+\n+    @Test(timeout = 30000)\n+    public void testGetBytesWithDoubleByteBufAssource() {\n+        ByteBuf b1 = Unpooled.wrappedBuffer(new byte[] { 1, 2 });\n+        ByteBuf b2 = Unpooled.wrappedBuffer(new byte[] { 3, 4 });\n+        ByteBuf b3 = Unpooled.wrappedBuffer(new byte[] { 5, 6 });\n+\n+        ByteBuf b23 = DoubleByteBuf.get(b2, b3);\n+        doTest(b1, b23);\n+    }\n+\n+    @Test(timeout = 30000)\n+    public void testGetBytesWithIndex() {\n+        ByteBuf b1 = Unpooled.wrappedBuffer(new byte[] { 1, 2, 3 });\n+        ByteBuf b2 = Unpooled.wrappedBuffer(new byte[] { 9, 9, 4, 5, 6 });\n+\n+        // Skip the two '9' from b2\n+        b2.readByte();\n+        b2.readByte();\n+\n+        doTest(b1, b2);\n+    }\n+\n+    private void doTest(ByteBuf b1, ByteBuf b2) {\n+        ByteBuf buf = DoubleByteBuf.get(b1, b2);\n+\n+        assertEquals(6, buf.readableBytes());\n+        assertEquals(0, buf.writableBytes());\n+\n+        ByteBuf dst1 = Unpooled.buffer(6);\n+        buf.getBytes(0, dst1);\n+        assertEquals(6, dst1.readableBytes());\n+        assertEquals(0, dst1.writableBytes());\n+        assertEquals(Unpooled.wrappedBuffer(new byte[] { 1, 2, 3, 4, 5, 6 }), dst1);\n+\n+        ByteBuf dst2 = Unpooled.buffer(6);\n+        buf.getBytes(0, dst2, 4);\n+        assertEquals(4, dst2.readableBytes());\n+        assertEquals(2, dst2.writableBytes());\n+        assertEquals(Unpooled.wrappedBuffer(new byte[] { 1, 2, 3, 4 }), dst2);\n+\n+        ByteBuf dst3 = Unpooled.wrappedBuffer(new byte[] { 0, 0, 0, 0, 0, 0 });\n+        buf.getBytes(0, dst3, 1, 4);\n+        assertEquals(6, dst3.readableBytes());\n+        assertEquals(0, dst3.writableBytes());\n+        assertEquals(Unpooled.wrappedBuffer(new byte[] { 0, 1, 2, 3, 4, 0 }), dst3);\n+\n+        ByteBuf dst4 = Unpooled.wrappedBuffer(new byte[] { 0, 0, 0, 0, 0, 0 });\n+        buf.getBytes(2, dst4, 1, 3);\n+        assertEquals(6, dst4.readableBytes());\n+        assertEquals(0, dst4.writableBytes());\n+        assertEquals(Unpooled.wrappedBuffer(new byte[] { 0, 3, 4, 5, 0, 0 }), dst4);\n+\n+        ByteBuf dst5 = Unpooled.wrappedBuffer(new byte[] { 0, 0, 0, 0, 0, 0 });\n+        buf.getBytes(3, dst5, 1, 3);\n+        assertEquals(6, dst5.readableBytes());\n+        assertEquals(0, dst5.writableBytes());\n+        assertEquals(Unpooled.wrappedBuffer(new byte[] { 0, 4, 5, 6, 0, 0 }), dst5);\n+    }\n+\n+    @Test(timeout = 30000)\n+    public void testCopyToArray() {\n+        ByteBuf b1 = Unpooled.wrappedBuffer(new byte[] { 1, 2 });\n+        ByteBuf b2 = Unpooled.wrappedBuffer(new byte[] { 3, 4 });\n+        ByteBuf b = DoubleByteBuf.get(b1, b2);\n+\n+        byte[] a1 = new byte[4];\n+        b.getBytes(0, a1);\n+        assertArrayEquals(new byte[] { 1, 2, 3, 4 }, a1);\n+\n+        byte[] a2 = new byte[3];\n+        b.getBytes(1, a2);\n+        assertArrayEquals(new byte[] { 2, 3, 4 }, a2);\n+    }\n+\n+    @Test(timeout = 30000)\n+    public void testToByteBuffer() {\n+        ByteBuf b1 = Unpooled.wrappedBuffer(new byte[] { 1, 2 });\n+        ByteBuf b2 = Unpooled.wrappedBuffer(new byte[] { 3, 4 });\n+        ByteBuf b = DoubleByteBuf.get(b1, b2);\n+\n+        assertEquals(ByteBuffer.wrap(new byte[] { 1, 2, 3, 4 }), b.nioBuffer());\n+    }\n+}"},{"sha":"a892ceff0aa52f36c329ab630fb424645bdb6503","filename":"pom.xml","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/74f795136c1fff3badb29fc982d0cc2d43096b45/pom.xml","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/74f795136c1fff3badb29fc982d0cc2d43096b45/pom.xml","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/pom.xml?ref=74f795136c1fff3badb29fc982d0cc2d43096b45","patch":"@@ -43,7 +43,7 @@\n     <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n     <protobuf.version>2.6.1</protobuf.version>\n     <guava.version>13.0.1</guava.version>\n-    <netty.version>3.9.4.Final</netty.version>\n+    <netty.version>4.1.10.Final</netty.version>\n     <zookeeper.version>3.5.1-alpha</zookeeper.version>\n   </properties>\n   <url>http://zookeeper.apache.org/bookkeeper</url>"}]}