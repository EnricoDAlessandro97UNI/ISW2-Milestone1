{"sha":"07852d35856dca232450135913090bac27b29abe","node_id":"MDY6Q29tbWl0NDc4NTkyNTI2OjA3ODUyZDM1ODU2ZGNhMjMyNDUwMTM1OTEzMDkwYmFjMjdiMjlhYmU=","commit":{"author":{"name":"Charan Reddy Guttapalem","email":"cguttapalem@salesforce.com","date":"2017-06-12T15:20:53Z"},"committer":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2017-06-12T15:20:53Z"},"message":"BOOKKEEPER-1096: recursive znode delete\n\nWhen ledger is deleted, along with leaf node\nall the eligible branch nodes should be\ndeleted in ZooKeeper.\n\nAuthor: Charan Reddy Guttapalem <cguttapalem@salesforce.com>\n\nReviewers: Sijie Guo <sijie@apache.org>\n\nCloses #186 from reddycharan/recursiveznodedelete","tree":{"sha":"119d0a6044d461a0e8a2fee6628b1b2352237cb3","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/trees/119d0a6044d461a0e8a2fee6628b1b2352237cb3"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/commits/07852d35856dca232450135913090bac27b29abe","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/07852d35856dca232450135913090bac27b29abe","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/07852d35856dca232450135913090bac27b29abe","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/07852d35856dca232450135913090bac27b29abe/comments","author":{"login":"reddycharan","id":13989266,"node_id":"MDQ6VXNlcjEzOTg5MjY2","avatar_url":"https://avatars.githubusercontent.com/u/13989266?v=4","gravatar_id":"","url":"https://api.github.com/users/reddycharan","html_url":"https://github.com/reddycharan","followers_url":"https://api.github.com/users/reddycharan/followers","following_url":"https://api.github.com/users/reddycharan/following{/other_user}","gists_url":"https://api.github.com/users/reddycharan/gists{/gist_id}","starred_url":"https://api.github.com/users/reddycharan/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/reddycharan/subscriptions","organizations_url":"https://api.github.com/users/reddycharan/orgs","repos_url":"https://api.github.com/users/reddycharan/repos","events_url":"https://api.github.com/users/reddycharan/events{/privacy}","received_events_url":"https://api.github.com/users/reddycharan/received_events","type":"User","site_admin":false},"committer":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"parents":[{"sha":"13c5c88f63f4b7faa63c8c7e42d95f94c6a8d204","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/13c5c88f63f4b7faa63c8c7e42d95f94c6a8d204","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/13c5c88f63f4b7faa63c8c7e42d95f94c6a8d204"}],"stats":{"total":359,"additions":346,"deletions":13},"files":[{"sha":"f3fd9e0ebe1fd5902a353ca8a63f474f083204ca","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/AbstractZkLedgerManager.java","status":"modified","additions":23,"deletions":8,"changes":31,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/07852d35856dca232450135913090bac27b29abe/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FAbstractZkLedgerManager.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/07852d35856dca232450135913090bac27b29abe/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FAbstractZkLedgerManager.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FAbstractZkLedgerManager.java?ref=07852d35856dca232450135913090bac27b29abe","patch":"@@ -259,11 +259,15 @@ public void processResult(int rc, String path, Object ctx, String name) {\n     }\n \n     /**\n-     * Removes ledger metadata from ZooKeeper if version matches.\n+     * Removes ledger metadata from ZooKeeper and deletes its parent znodes\n+     * recursively if they dont have anymore children.\n      *\n-     * @param   ledgerId    ledger identifier\n-     * @param   version     local version of metadata znode\n-     * @param   cb          callback object\n+     * @param ledgerId\n+     *            ledger identifier\n+     * @param version\n+     *            local version of metadata znode\n+     * @param cb\n+     *            callback object\n      */\n     @Override\n     public void removeLedgerMetadata(final long ledgerId, final Version version,\n@@ -282,8 +286,8 @@ public void removeLedgerMetadata(final long ledgerId, final Version version,\n                 znodeVersion = ((ZkVersion)version).getZnodeVersion();\n             }\n         }\n-\n-        zk.delete(getLedgerPath(ledgerId), znodeVersion, new VoidCallback() {\n+        \n+        VoidCallback callbackForDelete = new VoidCallback() {\n             @Override\n             public void processResult(int rc, String path, Object ctx) {\n                 int bkRc;\n@@ -308,9 +312,20 @@ public void processResult(int rc, String path, Object ctx) {\n                 } else {\n                     bkRc = BKException.Code.ZKException;\n                 }\n-                cb.operationComplete(bkRc, (Void)null);\n+                cb.operationComplete(bkRc, (Void) null);\n             }\n-        }, null);\n+        };\n+        String ledgerZnodePath = getLedgerPath(ledgerId);\n+        if (this instanceof HierarchicalLedgerManager || this instanceof LongHierarchicalLedgerManager) {\n+            /*\n+             * do recursive deletes only for HierarchicalLedgerManager and\n+             * LongHierarchicalLedgerManager\n+             */\n+            ZkUtils.asyncDeleteFullPathOptimistic(zk, ledgerZnodePath, znodeVersion, callbackForDelete,\n+                    ledgerZnodePath);\n+        } else {\n+            zk.delete(ledgerZnodePath, znodeVersion, callbackForDelete, null);\n+        }\n     }\n \n     @Override"},{"sha":"a12ba40528f252c2c20b48c4a2b5f772baf5a429","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/util/ZkUtils.java","status":"modified","additions":63,"deletions":5,"changes":68,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/07852d35856dca232450135913090bac27b29abe/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2FZkUtils.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/07852d35856dca232450135913090bac27b29abe/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2FZkUtils.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2FZkUtils.java?ref=07852d35856dca232450135913090bac27b29abe","patch":"@@ -29,17 +29,16 @@\n import org.apache.bookkeeper.conf.AbstractConfiguration;\n \n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n-import org.apache.bookkeeper.zookeeper.BoundExponentialBackoffRetryPolicy;\n-import org.apache.bookkeeper.zookeeper.ZooKeeperClient;\n-import org.apache.bookkeeper.zookeeper.ZooKeeperWatcherBase;\n-import org.apache.zookeeper.CreateMode;\n import org.apache.zookeeper.AsyncCallback;\n-import org.apache.zookeeper.KeeperException;\n import org.apache.zookeeper.AsyncCallback.StringCallback;\n+import org.apache.zookeeper.AsyncCallback.VoidCallback;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.KeeperException;\n import org.apache.zookeeper.KeeperException.Code;\n import org.apache.zookeeper.ZooDefs;\n import org.apache.zookeeper.data.ACL;\n import org.apache.zookeeper.ZooKeeper;\n+import org.apache.zookeeper.data.ACL;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -106,6 +105,48 @@ public void processResult(int rc, String path, Object ctx, String name) {\n         }, ctx);\n     }\n \n+    /**\n+     * Asynchronously deletes zookeeper path recursively and optimistically.\n+     * This method is used for deleting the leaf nodes and its corresponding\n+     * parents if they don't have anymore children after deleting the child\n+     * node. For this to work as expected, provided znodeVersion should be -1,\n+     * so that there wont be version mismatches with any of the parent nodes. If\n+     * it fails to delete the leafnode then it will callback with the received\n+     * error code, but it fails to delete the parent node for whatsoever reason\n+     * it stops proceeding further and it will callback with ok error code.\n+     * \n+     * @param zk\n+     *            Zookeeper client\n+     * @param originalPath\n+     *            Zookeeper full path\n+     * @param znodeVersion\n+     *            version of the node\n+     * @param callback\n+     *            callback\n+     * @param leafNodePath\n+     *            for actual caller this leafNodePath should be same as the\n+     *            originalPath. But when it is called recursively leafNodePath\n+     *            remains the same, but the originalPath will be internal nodes.\n+     */\n+    public static void asyncDeleteFullPathOptimistic(final ZooKeeper zk, final String originalPath,\n+            int znodeVersion, final AsyncCallback.VoidCallback callback, final String leafNodePath) {\n+        zk.delete(originalPath, znodeVersion, new VoidCallback() {\n+            @Override\n+            public void processResult(int rc, String path, Object ctx) {\n+                if (rc == Code.OK.intValue()) {\n+                    String parent = new File(originalPath).getParent().replace(\"\\\\\", \"/\");\n+                    asyncDeleteFullPathOptimistic(zk, parent, znodeVersion, callback, leafNodePath);\n+                } else {\n+                    if (path.equals(leafNodePath)) {\n+                        callback.processResult(rc, path, leafNodePath);\n+                    } else {\n+                        callback.processResult(Code.OK.intValue(), path, leafNodePath);\n+                    }\n+                }\n+            }\n+        }, leafNodePath);\n+    }\n+    \n     /**\n      * Create zookeeper path recursively and optimistically. This method can throw\n      * any of the KeeperExceptions which can be thrown by ZooKeeper#create.\n@@ -148,6 +189,23 @@ public void processResult(int rc2, String path,\n         }\n     }\n \n+    public static void deleteFullPathOptimistic(ZooKeeper zkc, String path, int znodeVersion)\n+            throws KeeperException, InterruptedException {\n+        final CountDownLatch latch = new CountDownLatch(1);\n+        final AtomicInteger rc = new AtomicInteger(Code.OK.intValue());\n+        asyncDeleteFullPathOptimistic(zkc, path, znodeVersion, new VoidCallback() {\n+            @Override\n+            public void processResult(int rc2, String path, Object ctx) {\n+                rc.set(rc2);\n+                latch.countDown();\n+            }\n+        }, path);\n+        latch.await();\n+        if (rc.get() != Code.OK.intValue()) {\n+            throw KeeperException.create(Code.get(rc.get()));\n+        }\n+    }\n+    \n     private static class GetChildrenCtx {\n         int rc;\n         boolean done = false;"},{"sha":"747398a22f3fe04d4bda00c2e3a66bfb1a4eb605","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/LedgerManagerTestCase.java","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/07852d35856dca232450135913090bac27b29abe/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FLedgerManagerTestCase.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/07852d35856dca232450135913090bac27b29abe/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FLedgerManagerTestCase.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FLedgerManagerTestCase.java?ref=07852d35856dca232450135913090bac27b29abe","patch":"@@ -68,6 +68,7 @@ public LedgerManagerTestCase(Class<? extends LedgerManagerFactory> lmFactoryCls,\n         super(numBookies);\n         activeLedgers = new SnapshotMap<Long, Boolean>();\n         baseConf.setLedgerManagerFactoryClass(lmFactoryCls);\n+        baseClientConf.setLedgerManagerFactoryClass(lmFactoryCls);\n     }\n \n     public LedgerManager getLedgerManager() {"},{"sha":"7417f99569a0893dfc1dd57d052141754dd039fb","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/LedgerMetadataCreationTest.java","status":"added","additions":172,"deletions":0,"changes":172,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/07852d35856dca232450135913090bac27b29abe/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FLedgerMetadataCreationTest.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/07852d35856dca232450135913090bac27b29abe/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FLedgerMetadataCreationTest.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FLedgerMetadataCreationTest.java?ref=07852d35856dca232450135913090bac27b29abe","patch":"@@ -0,0 +1,172 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+\n+package org.apache.bookkeeper.meta;\n+\n+import static org.junit.Assert.assertTrue;\n+\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.Vector;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentLinkedDeque;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.bookkeeper.client.BookKeeper;\n+import org.apache.bookkeeper.client.BookKeeper.DigestType;\n+import org.apache.zookeeper.ZooKeeper;\n+import org.junit.Assume;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class LedgerMetadataCreationTest extends LedgerManagerTestCase {\n+    static final Logger LOG = LoggerFactory.getLogger(LedgerMetadataCreationTest.class);\n+\n+    public LedgerMetadataCreationTest(Class<? extends LedgerManagerFactory> lmFactoryCls) {\n+        super(lmFactoryCls, 4);\n+        baseConf.setGcWaitTime(100000);\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testLedgerCreationAndDeletionWithRandomLedgerIds() throws Exception {\n+        testExecution(true);\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testLedgerCreationAndDeletion() throws Exception{\n+        testExecution(false);\n+    }\n+    \n+    public void testExecution(boolean randomLedgerId) throws Exception {\n+        Set<Long> createRequestsLedgerIds = ConcurrentHashMap.newKeySet();\n+        ConcurrentLinkedDeque<Long> existingLedgerIds = new ConcurrentLinkedDeque<Long>();\n+\n+        Vector<Long> failedCreates = new Vector<Long>();\n+        Vector<Long> failedDeletes = new Vector<Long>();\n+        BookKeeper bookKeeper = new BookKeeper(baseClientConf);\n+\n+        ExecutorService executor = Executors.newFixedThreadPool(300);\n+        Random rand = new Random();\n+        int numberOfOperations = 20000;\n+        for (int i = 0; i < numberOfOperations; i++) {\n+            int iteration = i;\n+            if (rand.nextBoolean() || existingLedgerIds.isEmpty()) {\n+                executor.submit(() -> {\n+                    long ledgerId = -1;\n+                    try {\n+                        if (randomLedgerId) {\n+                            ledgerId = Math.abs(rand.nextLong());\n+                            do {\n+                                if (!baseClientConf.getLedgerManagerFactoryClass()\n+                                        .equals(LongHierarchicalLedgerManagerFactory.class)) {\n+                                    /*\n+                                     * since LongHierarchicalLedgerManager\n+                                     * supports ledgerIds of decimal length upto\n+                                     * 19 digits but other LedgerManagers only\n+                                     * upto 10 decimals\n+                                     */\n+                                    ledgerId %= 9999999999L;\n+                                }\n+                            } while (!createRequestsLedgerIds.add(ledgerId));\n+                        } else {\n+                            ledgerId = iteration;\n+                        }\n+                        bookKeeper.createLedgerAdv(ledgerId, 3, 2, 2, DigestType.CRC32, \"passwd\".getBytes(), null);\n+                        existingLedgerIds.add(ledgerId);\n+                    } catch (Exception e) {\n+                        LOG.error(\"Got Exception while creating Ledger with ledgerId \" + ledgerId, e);\n+                        failedCreates.add(ledgerId);\n+                    }\n+                });\n+            } else {\n+                executor.submit(() -> {\n+                    Long ledgerId = null;\n+                    if (rand.nextBoolean()) {\n+                        ledgerId = existingLedgerIds.pollFirst();\n+                    } else {\n+                        ledgerId = existingLedgerIds.pollLast();\n+                    }\n+                    if (ledgerId == null) {\n+                        return;\n+                    }\n+                    try {\n+                        bookKeeper.deleteLedger(ledgerId);\n+                    } catch (Exception e) {\n+                        LOG.error(\"Got Exception while deleting Ledger with ledgerId \" + ledgerId, e);\n+                        failedDeletes.add(ledgerId);\n+                    }\n+                });\n+            }\n+        }\n+        executor.shutdown();\n+        assertTrue(\"All the ledger create/delete operations should have'been completed\",\n+                executor.awaitTermination(30, TimeUnit.SECONDS));\n+        assertTrue(\"There should be no failed creates. But there are \" + failedCreates.size() + \" failedCreates\",\n+                failedCreates.isEmpty());\n+        assertTrue(\"There should be no failed deletes. But there are \" + failedDeletes.size() + \" failedDeletes\",\n+                failedDeletes.isEmpty());\n+        bookKeeper.close();\n+    }\n+    \n+    @Test(timeout = 60000)\n+    public void testParentNodeDeletion() throws Exception {\n+        /*\n+         * run this testcase only for HierarchicalLedgerManager and\n+         * LongHierarchicalLedgerManager, since we do recursive zNode deletes\n+         * only for HierarchicalLedgerManager\n+         */\n+        Assume.assumeTrue((baseClientConf.getLedgerManagerFactoryClass().equals(HierarchicalLedgerManagerFactory.class)\n+                || baseClientConf.getLedgerManagerFactoryClass().equals(LongHierarchicalLedgerManagerFactory.class)));\n+\n+        ZooKeeper zkc = new ZooKeeper(zkUtil.getZooKeeperConnectString(), 10000, null);\n+        BookKeeper bookKeeper = new BookKeeper(baseClientConf);\n+        bookKeeper.createLedgerAdv(1, 3, 2, 2, DigestType.CRC32, \"passwd\".getBytes(), null);\n+        String ledgersRootPath = baseClientConf.getZkLedgersRootPath();\n+        String parentZnodePath;\n+        if (baseClientConf.getLedgerManagerFactoryClass().equals(HierarchicalLedgerManagerFactory.class)) {\n+            /*\n+             * in HierarchicalLedgerManager (ledgersRootPath)/00/0000/L0001\n+             * would be the path of the znode for ledger - 1. So when ledger - 1\n+             * is deleted, (ledgersRootPath)/00 should also be deleted since\n+             * there are no other children znodes\n+             */\n+            parentZnodePath = ledgersRootPath + \"/00\";\n+\n+        } else {\n+            /*\n+             * in LongHierarchicalLedgerManager\n+             * (ledgersRootPath)/000/0000/0000/0000/L0001 would be the path of\n+             * the znode for ledger - 1. So when ledger - 1 is deleted,\n+             * (ledgersRootPath)/000 should also be deleted since there are no\n+             * other children znodes\n+             */\n+            parentZnodePath = ledgersRootPath + \"/000\";\n+        }\n+        assertTrue(parentZnodePath + \" zNode should exist\", null != zkc.exists(parentZnodePath, false));\n+        bookKeeper.deleteLedger(1);\n+        assertTrue(parentZnodePath + \" zNode should not exist anymore\", null == zkc.exists(parentZnodePath, false));\n+        bookKeeper.close();\n+        zkc.close();\n+    }\n+}"},{"sha":"4faf09d7615535f3c5a2aee1e2f5a1fdb460cd15","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/util/TestZkUtils.java","status":"added","additions":87,"deletions":0,"changes":87,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/07852d35856dca232450135913090bac27b29abe/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2FTestZkUtils.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/07852d35856dca232450135913090bac27b29abe/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2FTestZkUtils.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2FTestZkUtils.java?ref=07852d35856dca232450135913090bac27b29abe","patch":"@@ -0,0 +1,87 @@\n+/**\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.util;\n+\n+import java.io.IOException;\n+\n+import org.apache.bookkeeper.test.ZooKeeperUtil;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.ZooDefs.Ids;\n+import org.apache.zookeeper.ZooKeeper;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import junit.framework.TestCase;\n+\n+public class TestZkUtils extends TestCase {\n+\n+    static final Logger logger = LoggerFactory.getLogger(TestZkUtils.class);\n+\n+    // ZooKeeper related variables\n+    protected ZooKeeperUtil zkUtil = new ZooKeeperUtil();\n+\n+    @Before\n+    @Override\n+    public void setUp() throws Exception {\n+        logger.info(\"Setting up test {}.\", getName());\n+        zkUtil.startServer();\n+    }\n+\n+    @After\n+    @Override\n+    public void tearDown() throws Exception {\n+        zkUtil.killServer();\n+        logger.info(\"Teared down test {}.\", getName());\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testAsyncCreateAndDeleteFullPathOptimistic() throws IOException, KeeperException, InterruptedException {\n+        ZooKeeper zkc = new ZooKeeper(zkUtil.getZooKeeperConnectString(), 10000, null);\n+        /*\n+         * \"/ledgers/available\" is already created in ZooKeeperUtil.startServer\n+         */\n+        String ledgerZnodePath = new String(\"/ledgers/000/000/000/001\");\n+        ZkUtils.createFullPathOptimistic(zkc, ledgerZnodePath, \"data\".getBytes(), Ids.OPEN_ACL_UNSAFE,\n+                CreateMode.PERSISTENT);\n+        assertTrue(ledgerZnodePath + \" zNode should exist\", null != zkc.exists(ledgerZnodePath, false));\n+\n+        ledgerZnodePath = new String(\"/ledgers/000/000/000/002\");\n+        ZkUtils.createFullPathOptimistic(zkc, ledgerZnodePath, \"data\".getBytes(), Ids.OPEN_ACL_UNSAFE,\n+                CreateMode.PERSISTENT);\n+        assertTrue(ledgerZnodePath + \" zNode should exist\", null != zkc.exists(ledgerZnodePath, false));\n+\n+        ZkUtils.deleteFullPathOptimistic(zkc, ledgerZnodePath, -1);\n+        assertTrue(ledgerZnodePath + \" zNode should not exist, since it is deleted\",\n+                null == zkc.exists(ledgerZnodePath, false));\n+\n+        ledgerZnodePath = new String(\"/ledgers/000/000/000/001\");\n+        assertTrue(ledgerZnodePath + \" zNode should exist\", null != zkc.exists(ledgerZnodePath, false));\n+        ZkUtils.deleteFullPathOptimistic(zkc, ledgerZnodePath, -1);\n+        assertTrue(ledgerZnodePath + \" zNode should not exist, since it is deleted\",\n+                null == zkc.exists(ledgerZnodePath, false));\n+        assertTrue(\"/ledgers/000\" + \" zNode should not exist, since it should be deleted recursively\",\n+                null == zkc.exists(ledgerZnodePath, false));\n+    }\n+}"}]}