{"sha":"ef1ca0e73e8ca832dabc46497058aeda6ca6b537","node_id":"MDY6Q29tbWl0NDc4NTkyNTI2OmVmMWNhMGU3M2U4Y2E4MzJkYWJjNDY0OTcwNThhZWRhNmNhNmI1Mzc=","commit":{"author":{"name":"xieliang","email":"xieliang007@gmail.com","date":"2017-01-05T00:09:01Z"},"committer":{"name":"Sijie Guo","email":"sijieg@twitter.com","date":"2017-01-05T00:09:01Z"},"message":"DL-165: Add TestTimedOutTestsListener to dump timed out cases thread dump\n\nAuthor: xieliang <xieliang007@gmail.com>\n\nReviewers: Leigh Stewart <lstewart@apache.org>\n\nCloses #91 from xieliang/DL-165-TimedOutTestsListener","tree":{"sha":"4d5b754609369f91940ea8daa3edcfb18d3937f0","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/trees/4d5b754609369f91940ea8daa3edcfb18d3937f0"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/commits/ef1ca0e73e8ca832dabc46497058aeda6ca6b537","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/ef1ca0e73e8ca832dabc46497058aeda6ca6b537","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/ef1ca0e73e8ca832dabc46497058aeda6ca6b537","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/ef1ca0e73e8ca832dabc46497058aeda6ca6b537/comments","author":{"login":"xieliang","id":1712953,"node_id":"MDQ6VXNlcjE3MTI5NTM=","avatar_url":"https://avatars.githubusercontent.com/u/1712953?v=4","gravatar_id":"","url":"https://api.github.com/users/xieliang","html_url":"https://github.com/xieliang","followers_url":"https://api.github.com/users/xieliang/followers","following_url":"https://api.github.com/users/xieliang/following{/other_user}","gists_url":"https://api.github.com/users/xieliang/gists{/gist_id}","starred_url":"https://api.github.com/users/xieliang/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/xieliang/subscriptions","organizations_url":"https://api.github.com/users/xieliang/orgs","repos_url":"https://api.github.com/users/xieliang/repos","events_url":"https://api.github.com/users/xieliang/events{/privacy}","received_events_url":"https://api.github.com/users/xieliang/received_events","type":"User","site_admin":false},"committer":null,"parents":[{"sha":"714ae49baff3c9f390fb65afa9b8cf801c5a5316","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/714ae49baff3c9f390fb65afa9b8cf801c5a5316","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/714ae49baff3c9f390fb65afa9b8cf801c5a5316"}],"stats":{"total":363,"additions":363,"deletions":0},"files":[{"sha":"5e554826ba989048557541352e8812ad547c6531","filename":"pom.xml","status":"modified","additions":12,"deletions":0,"changes":12,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/ef1ca0e73e8ca832dabc46497058aeda6ca6b537/pom.xml","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/ef1ca0e73e8ca832dabc46497058aeda6ca6b537/pom.xml","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/pom.xml?ref=ef1ca0e73e8ca832dabc46497058aeda6ca6b537","patch":"@@ -106,6 +106,18 @@\n           </execution>\n         </executions>\n       </plugin>\n+      <plugin>\n+        <groupId>org.apache.maven.plugins</groupId>\n+        <artifactId>maven-jar-plugin</artifactId>\n+        <version>2.2</version>\n+        <executions>\n+          <execution>\n+            <goals>\n+              <goal>test-jar</goal>\n+            </goals>\n+          </execution>\n+        </executions>\n+      </plugin>\n       <plugin>\n         <groupId>org.codehaus.mojo</groupId>\n         <artifactId>findbugs-maven-plugin</artifactId>"},{"sha":"8d200ec1983246730278d3cb93901cea0fc17379","filename":"src/test/java/com/twitter/distributedlog/TestTimedOutTestsListener.java","status":"added","additions":183,"deletions":0,"changes":183,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/ef1ca0e73e8ca832dabc46497058aeda6ca6b537/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestTimedOutTestsListener.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/ef1ca0e73e8ca832dabc46497058aeda6ca6b537/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestTimedOutTestsListener.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestTimedOutTestsListener.java?ref=ef1ca0e73e8ca832dabc46497058aeda6ca6b537","patch":"@@ -0,0 +1,183 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.twitter.distributedlog;\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.util.concurrent.CyclicBarrier;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.junit.runner.notification.Failure;\n+\n+/**\n+ * Test Case for {@link TimedOutTestsListener}.\n+ */\n+public class TestTimedOutTestsListener {\n+\n+    private static class Deadlock {\n+        private CyclicBarrier barrier = new CyclicBarrier(6);\n+\n+        public Deadlock() {\n+            DeadlockThread[] dThreads = new DeadlockThread[6];\n+\n+            Monitor a = new Monitor(\"a\");\n+            Monitor b = new Monitor(\"b\");\n+            Monitor c = new Monitor(\"c\");\n+            dThreads[0] = new DeadlockThread(\"MThread-1\", a, b);\n+            dThreads[1] = new DeadlockThread(\"MThread-2\", b, c);\n+            dThreads[2] = new DeadlockThread(\"MThread-3\", c, a);\n+\n+            Lock d = new ReentrantLock();\n+            Lock e = new ReentrantLock();\n+            Lock f = new ReentrantLock();\n+\n+            dThreads[3] = new DeadlockThread(\"SThread-4\", d, e);\n+            dThreads[4] = new DeadlockThread(\"SThread-5\", e, f);\n+            dThreads[5] = new DeadlockThread(\"SThread-6\", f, d);\n+\n+            // make them daemon threads so that the test will exit\n+            for (int i = 0; i < 6; i++) {\n+                dThreads[i].setDaemon(true);\n+                dThreads[i].start();\n+            }\n+        }\n+\n+        class DeadlockThread extends Thread {\n+            private Lock lock1 = null;\n+\n+            private Lock lock2 = null;\n+\n+            private Monitor mon1 = null;\n+\n+            private Monitor mon2 = null;\n+\n+            private boolean useSync;\n+\n+            DeadlockThread(String name, Lock lock1, Lock lock2) {\n+                super(name);\n+                this.lock1 = lock1;\n+                this.lock2 = lock2;\n+                this.useSync = true;\n+            }\n+\n+            DeadlockThread(String name, Monitor mon1, Monitor mon2) {\n+                super(name);\n+                this.mon1 = mon1;\n+                this.mon2 = mon2;\n+                this.useSync = false;\n+            }\n+\n+            public void run() {\n+                if (useSync) {\n+                    syncLock();\n+                } else {\n+                    monitorLock();\n+                }\n+            }\n+\n+            private void syncLock() {\n+                lock1.lock();\n+                try {\n+                    try {\n+                        barrier.await();\n+                    } catch (Exception e) {\n+                    }\n+                    goSyncDeadlock();\n+                } finally {\n+                    lock1.unlock();\n+                }\n+            }\n+\n+            private void goSyncDeadlock() {\n+                try {\n+                    barrier.await();\n+                } catch (Exception e) {\n+                }\n+                lock2.lock();\n+                throw new RuntimeException(\"should not reach here.\");\n+            }\n+\n+            private void monitorLock() {\n+                synchronized (mon1) {\n+                    try {\n+                        barrier.await();\n+                    } catch (Exception e) {\n+                    }\n+                    goMonitorDeadlock();\n+                }\n+            }\n+\n+            private void goMonitorDeadlock() {\n+                try {\n+                    barrier.await();\n+                } catch (Exception e) {\n+                }\n+                synchronized (mon2) {\n+                    throw new RuntimeException(getName() + \" should not reach here.\");\n+                }\n+            }\n+        }\n+\n+        class Monitor {\n+            String name;\n+\n+            Monitor(String name) {\n+                this.name = name;\n+            }\n+        }\n+\n+    }\n+\n+    @Test(timeout = 500)\n+    public void testThreadDumpAndDeadlocks() throws Exception {\n+        new Deadlock();\n+        String s = null;\n+        while (true) {\n+            s = TimedOutTestsListener.buildDeadlockInfo();\n+            if (s != null) {\n+                break;\n+            }\n+            Thread.sleep(100);\n+        }\n+\n+        Assert.assertEquals(3, countStringOccurrences(s, \"BLOCKED\"));\n+\n+        Failure failure = new Failure(null, new Exception(TimedOutTestsListener.TEST_TIMED_OUT_PREFIX));\n+        StringWriter writer = new StringWriter();\n+        new TimedOutTestsListener(new PrintWriter(writer)).testFailure(failure);\n+        String out = writer.toString();\n+\n+        Assert.assertTrue(out.contains(\"THREAD DUMP\"));\n+        Assert.assertTrue(out.contains(\"DEADLOCKS DETECTED\"));\n+\n+        System.out.println(out);\n+    }\n+\n+    private int countStringOccurrences(String s, String substr) {\n+        int n = 0;\n+        int index = 0;\n+        while ((index = s.indexOf(substr, index) + 1) != 0) {\n+            n++;\n+        }\n+        return n;\n+    }\n+\n+}\n\\ No newline at end of file"},{"sha":"f2e80d28224dbd0fac82a518c6d67e5e667829ed","filename":"src/test/java/com/twitter/distributedlog/TimedOutTestsListener.java","status":"added","additions":168,"deletions":0,"changes":168,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/ef1ca0e73e8ca832dabc46497058aeda6ca6b537/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTimedOutTestsListener.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/ef1ca0e73e8ca832dabc46497058aeda6ca6b537/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTimedOutTestsListener.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTimedOutTestsListener.java?ref=ef1ca0e73e8ca832dabc46497058aeda6ca6b537","patch":"@@ -0,0 +1,168 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.twitter.distributedlog;\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.lang.management.LockInfo;\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.MonitorInfo;\n+import java.lang.management.ThreadInfo;\n+import java.lang.management.ThreadMXBean;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Date;\n+import java.util.Map;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.junit.runner.notification.Failure;\n+import org.junit.runner.notification.RunListener;\n+\n+/**\n+ * JUnit run listener which prints full thread dump into System.err in case a test is failed due to\n+ * timeout.\n+ */\n+public class TimedOutTestsListener extends RunListener {\n+\n+    static final String TEST_TIMED_OUT_PREFIX = \"test timed out after\";\n+\n+    private static String indent = \"    \";\n+\n+    private final PrintWriter output;\n+\n+    public TimedOutTestsListener() {\n+        this.output = new PrintWriter(System.err);\n+    }\n+\n+    public TimedOutTestsListener(PrintWriter output) {\n+        this.output = output;\n+    }\n+\n+    @Override\n+    public void testFailure(Failure failure) throws Exception {\n+        if (failure != null && failure.getMessage() != null && failure.getMessage().startsWith(TEST_TIMED_OUT_PREFIX)) {\n+            output.println(\"====> TEST TIMED OUT. PRINTING THREAD DUMP. <====\");\n+            output.println();\n+            output.print(buildThreadDiagnosticString());\n+        }\n+    }\n+\n+    public static String buildThreadDiagnosticString() {\n+        StringWriter sw = new StringWriter();\n+        PrintWriter output = new PrintWriter(sw);\n+\n+        DateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd hh:mm:ss,SSS\");\n+        output.println(String.format(\"Timestamp: %s\", dateFormat.format(new Date())));\n+        output.println();\n+        output.println(buildThreadDump());\n+\n+        String deadlocksInfo = buildDeadlockInfo();\n+        if (deadlocksInfo != null) {\n+            output.println(\"====> DEADLOCKS DETECTED <====\");\n+            output.println();\n+            output.println(deadlocksInfo);\n+        }\n+\n+        return sw.toString();\n+    }\n+\n+    static String buildThreadDump() {\n+        StringBuilder dump = new StringBuilder();\n+        Map<Thread, StackTraceElement[]> stackTraces = Thread.getAllStackTraces();\n+        for (Map.Entry<Thread, StackTraceElement[]> e : stackTraces.entrySet()) {\n+            Thread thread = e.getKey();\n+            dump.append(String.format(\"\\\"%s\\\" %s prio=%d tid=%d %s\\njava.lang.Thread.State: %s\", thread.getName(),\n+                (thread.isDaemon() ? \"daemon\" : \"\"), thread.getPriority(), thread.getId(),\n+                Thread.State.WAITING.equals(thread.getState()) ? \"in Object.wait()\"\n+                        : StringUtils.lowerCase(thread.getState().name()),\n+                Thread.State.WAITING.equals(thread.getState()) ? \"WAITING (on object monitor)\" : thread.getState()));\n+            for (StackTraceElement stackTraceElement : e.getValue()) {\n+                dump.append(\"\\n        at \");\n+                dump.append(stackTraceElement);\n+            }\n+            dump.append(\"\\n\");\n+        }\n+        return dump.toString();\n+    }\n+\n+    static String buildDeadlockInfo() {\n+        ThreadMXBean threadBean = ManagementFactory.getThreadMXBean();\n+        long[] threadIds = threadBean.findMonitorDeadlockedThreads();\n+        if (threadIds != null && threadIds.length > 0) {\n+            StringWriter stringWriter = new StringWriter();\n+            PrintWriter out = new PrintWriter(stringWriter);\n+\n+            ThreadInfo[] infos = threadBean.getThreadInfo(threadIds, true, true);\n+            for (ThreadInfo ti : infos) {\n+                printThreadInfo(ti, out);\n+                printLockInfo(ti.getLockedSynchronizers(), out);\n+                out.println();\n+            }\n+\n+            out.close();\n+            return stringWriter.toString();\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    private static void printThreadInfo(ThreadInfo ti, PrintWriter out) {\n+        // print thread information\n+        printThread(ti, out);\n+\n+        // print stack trace with locks\n+        StackTraceElement[] stacktrace = ti.getStackTrace();\n+        MonitorInfo[] monitors = ti.getLockedMonitors();\n+        for (int i = 0; i < stacktrace.length; i++) {\n+            StackTraceElement ste = stacktrace[i];\n+            out.println(indent + \"at \" + ste.toString());\n+            for (MonitorInfo mi : monitors) {\n+                if (mi.getLockedStackDepth() == i) {\n+                    out.println(indent + \"  - locked \" + mi);\n+                }\n+            }\n+        }\n+        out.println();\n+    }\n+\n+    private static void printThread(ThreadInfo ti, PrintWriter out) {\n+        out.print(\"\\\"\" + ti.getThreadName() + \"\\\"\" + \" Id=\" + ti.getThreadId() + \" in \" + ti.getThreadState());\n+        if (ti.getLockName() != null) {\n+            out.print(\" on lock=\" + ti.getLockName());\n+        }\n+        if (ti.isSuspended()) {\n+            out.print(\" (suspended)\");\n+        }\n+        if (ti.isInNative()) {\n+            out.print(\" (running in native)\");\n+        }\n+        out.println();\n+        if (ti.getLockOwnerName() != null) {\n+            out.println(indent + \" owned by \" + ti.getLockOwnerName() + \" Id=\" + ti.getLockOwnerId());\n+        }\n+    }\n+\n+    private static void printLockInfo(LockInfo[] locks, PrintWriter out) {\n+        out.println(indent + \"Locked synchronizers: count = \" + locks.length);\n+        for (LockInfo li : locks) {\n+            out.println(indent + \"  - \" + li);\n+        }\n+        out.println();\n+    }\n+\n+}\n\\ No newline at end of file"}]}