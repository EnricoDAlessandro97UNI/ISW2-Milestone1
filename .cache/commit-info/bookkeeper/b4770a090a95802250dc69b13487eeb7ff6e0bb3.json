{"sha":"b4770a090a95802250dc69b13487eeb7ff6e0bb3","node_id":"MDY6Q29tbWl0NDc4NTkyNTI2OmI0NzcwYTA5MGE5NTgwMjI1MGRjNjliMTM0ODdlZWI3ZmY2ZTBiYjM=","commit":{"author":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2017-06-21T17:20:15Z"},"committer":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2017-06-21T17:20:15Z"},"message":"DL-124: Use Java8 Future rather than twitter Future\n\nSwitch to use Java8 CompletableFuture, to reduce dependencies introduced by twitter future and make it more friendly to users (users don't think of using which version of scala).\n\nThis change is based on #132 . Gitsha ce0686e is the change to review.\n\nThe changes:\n\n- Change Future to CompletableFuture\n- Map to thenApply\n- flatMap to thenCompose\n- Added a FutureEventListener, and switch addEvenListener to whenComplete (or whenCompleteAsync)\n- setValue to complete\n- setException to completeExceptionally\n- add rescue, ignore, ensure to FutureUtils as util functions.\n\nAuthor: Sijie Guo <sijie@apache.org>\n\nReviewers: Jia Zhai <None>, Leigh Stewart <lstewart@apache.org>\n\nCloses #133 from sijie/change_twitter_future_to_java_future","tree":{"sha":"174fedc43686af62642edafe4723e0fbfcda91ed","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/trees/174fedc43686af62642edafe4723e0fbfcda91ed"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/commits/b4770a090a95802250dc69b13487eeb7ff6e0bb3","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/b4770a090a95802250dc69b13487eeb7ff6e0bb3","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/b4770a090a95802250dc69b13487eeb7ff6e0bb3","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/b4770a090a95802250dc69b13487eeb7ff6e0bb3/comments","author":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"committer":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"parents":[{"sha":"46e6b70feda2e8ad61ba13928df93b2c94d3dd4e","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/46e6b70feda2e8ad61ba13928df93b2c94d3dd4e","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/46e6b70feda2e8ad61ba13928df93b2c94d3dd4e"}],"stats":{"total":10944,"additions":3427,"deletions":7517},"files":[{"sha":"af1cf5f737b32937a49c3a09e6eb3b036036d64c","filename":"conf/log4j.properties","status":"modified","additions":0,"deletions":4,"changes":4,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/conf%2Flog4j.properties","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/conf%2Flog4j.properties","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/conf%2Flog4j.properties?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -30,11 +30,7 @@ log4j.logger.org.apache.zookeeper=INFO\n log4j.logger.org.apache.bookkeeper=INFO\n \n # redirect executor output to executors.log since slow op warnings can be quite verbose\n-log4j.logger.org.apache.distributedlog.util.MonitoredFuturePool=INFO, Executors\n-log4j.logger.org.apache.distributedlog.util.MonitoredScheduledThreadPoolExecutor=INFO, Executors\n log4j.logger.org.apache.bookkeeper.util.SafeRunnable=INFO, Executors\n-log4j.additivity.org.apache.distributedlog.util.MonitoredFuturePool=false\n-log4j.additivity.org.apache.distributedlog.util.MonitoredScheduledThreadPoolExecutor=false\n log4j.additivity.org.apache.bookkeeper.util.SafeRunnable=false\n \n log4j.appender.Executors=org.apache.log4j.RollingFileAppender"},{"sha":"1ad51c24abc1aa4834ba646d90df190b9596770d","filename":"pom.xml","status":"modified","additions":30,"deletions":55,"changes":85,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/pom.xml","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/pom.xml","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/pom.xml?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -25,6 +25,16 @@\n   <artifactId>distributedlog-core</artifactId>\n   <name>Apache DistributedLog :: Core Library</name>\n   <dependencies>\n+    <dependency>\n+      <groupId>org.apache.distributedlog</groupId>\n+      <artifactId>distributedlog-common</artifactId>\n+      <version>${project.parent.version}</version>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.apache.distributedlog</groupId>\n+      <artifactId>distributedlog-protocol</artifactId>\n+      <version>${project.parent.version}</version>\n+    </dependency>\n     <dependency>\n       <groupId>org.apache.zookeeper</groupId>\n       <artifactId>zookeeper</artifactId>\n@@ -40,50 +50,6 @@\n         </exclusion>\n       </exclusions>\n     </dependency>\n-    <dependency>\n-      <groupId>junit</groupId>\n-      <artifactId>junit</artifactId>\n-      <version>${junit.version}</version>\n-      <scope>test</scope>\n-    </dependency>\n-    <dependency>\n-      <groupId>org.jmock</groupId>\n-      <artifactId>jmock</artifactId>\n-      <version>${jmock.version}</version>\n-      <scope>test</scope>\n-    </dependency>\n-    <dependency>\n-      <groupId>org.slf4j</groupId>\n-      <artifactId>slf4j-log4j12</artifactId>\n-      <version>${slf4j.version}</version>\n-      <scope>test</scope>\n-    </dependency>\n-    <dependency>\n-      <groupId>org.slf4j</groupId>\n-      <artifactId>slf4j-api</artifactId>\n-      <version>${slf4j.version}</version>\n-    </dependency>\n-    <dependency>\n-      <groupId>com.twitter.common</groupId>\n-      <artifactId>stats-util</artifactId>\n-      <version>${stats-util.version}</version>\n-      <exclusions>\n-        <exclusion>\n-          <groupId>org.slf4j</groupId>\n-          <artifactId>slf4j-jdk14</artifactId>\n-        </exclusion>\n-      </exclusions>\n-    </dependency>\n-    <dependency>\n-      <groupId>com.twitter</groupId>\n-      <artifactId>util-core_2.11</artifactId>\n-      <version>${finagle.version}</version>\n-    </dependency>\n-    <dependency>\n-      <groupId>org.apache.commons</groupId>\n-      <artifactId>commons-lang3</artifactId>\n-      <version>${commons-lang3.version}</version>\n-    </dependency>\n     <dependency>\n       <groupId>org.apache.thrift</groupId>\n       <artifactId>libthrift</artifactId>\n@@ -114,19 +80,28 @@\n       </exclusions>\n     </dependency>\n     <dependency>\n-      <groupId>commons-cli</groupId>\n-      <artifactId>commons-cli</artifactId>\n-      <version>${commons-cli.version}</version>\n+      <groupId>org.projectlombok</groupId>\n+      <artifactId>lombok</artifactId>\n+      <version>${lombok.version}</version>\n+      <scope>provided</scope>\n     </dependency>\n     <dependency>\n-      <groupId>org.apache.distributedlog</groupId>\n-      <artifactId>distributedlog-protocol</artifactId>\n-      <version>${project.parent.version}</version>\n+      <groupId>junit</groupId>\n+      <artifactId>junit</artifactId>\n+      <version>${junit.version}</version>\n+      <scope>test</scope>\n     </dependency>\n     <dependency>\n-      <groupId>net.jpountz.lz4</groupId>\n-      <artifactId>lz4</artifactId>\n-      <version>${lz4.version}</version>\n+      <groupId>org.jmock</groupId>\n+      <artifactId>jmock</artifactId>\n+      <version>${jmock.version}</version>\n+      <scope>test</scope>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.slf4j</groupId>\n+      <artifactId>slf4j-log4j12</artifactId>\n+      <version>${slf4j.version}</version>\n+      <scope>test</scope>\n     </dependency>\n     <dependency>\n       <groupId>org.mockito</groupId>\n@@ -136,7 +111,7 @@\n     </dependency> \n     <dependency>\n       <groupId>org.apache.distributedlog</groupId>\n-      <artifactId>distributedlog-protocol</artifactId>\n+      <artifactId>distributedlog-common</artifactId>\n       <version>${project.parent.version}</version>\n       <type>test-jar</type>\n       <scope>test</scope>\n@@ -172,7 +147,7 @@\n           <properties>\n             <property>\n               <name>listener</name>\n-              <value>org.apache.distributedlog.TimedOutTestsListener</value>\n+              <value>org.apache.distributedlog.common.util.TimedOutTestsListener</value>\n             </property>\n           </properties>\n         </configuration>"},{"sha":"3a31907ca306275875f3c26efd35cb0fd3c63a01","filename":"src/main/java/org/apache/distributedlog/AppendOnlyStreamReader.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FAppendOnlyStreamReader.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FAppendOnlyStreamReader.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FAppendOnlyStreamReader.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -18,10 +18,10 @@\n package org.apache.distributedlog;\n \n import com.google.common.base.Preconditions;\n-\n import java.io.IOException;\n import java.io.InputStream;\n-\n+import org.apache.distributedlog.api.DistributedLogManager;\n+import org.apache.distributedlog.api.LogReader;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n "},{"sha":"dde78c2d9320e11745c5e01a540d44ff1e677e60","filename":"src/main/java/org/apache/distributedlog/AppendOnlyStreamWriter.java","status":"modified","additions":9,"deletions":11,"changes":20,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FAppendOnlyStreamWriter.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FAppendOnlyStreamWriter.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FAppendOnlyStreamWriter.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -17,14 +17,12 @@\n  */\n package org.apache.distributedlog;\n \n-import org.apache.distributedlog.exceptions.UnexpectedException;\n-import org.apache.distributedlog.util.FutureUtils;\n-import com.twitter.util.Await;\n-import com.twitter.util.Future;\n-import com.twitter.util.FutureEventListener;\n import java.io.Closeable;\n import java.io.IOException;\n-\n+import java.util.concurrent.CompletableFuture;\n+import org.apache.distributedlog.exceptions.UnexpectedException;\n+import org.apache.distributedlog.common.concurrent.FutureEventListener;\n+import org.apache.distributedlog.common.concurrent.FutureUtils;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -44,16 +42,16 @@ public AppendOnlyStreamWriter(BKAsyncLogWriter logWriter, long pos) {\n         this.requestPos = pos;\n     }\n \n-    public Future<DLSN> write(byte[] data) {\n+    public CompletableFuture<DLSN> write(byte[] data) {\n         requestPos += data.length;\n-        Future<DLSN> writeResult = logWriter.write(new LogRecord(requestPos, data));\n-        return writeResult.addEventListener(new WriteCompleteListener(requestPos));\n+        CompletableFuture<DLSN> writeResult = logWriter.write(new LogRecord(requestPos, data));\n+        return writeResult.whenComplete(new WriteCompleteListener(requestPos));\n     }\n \n     public void force(boolean metadata) throws IOException {\n         long pos = 0;\n         try {\n-            pos = Await.result(logWriter.flushAndCommit());\n+            pos = FutureUtils.result(logWriter.flushAndCommit());\n         } catch (IOException ioe) {\n             throw ioe;\n         } catch (Exception ex) {\n@@ -78,7 +76,7 @@ public void close() throws IOException {\n \n     public void markEndOfStream() throws IOException {\n         try {\n-            Await.result(logWriter.markEndOfStream());\n+            FutureUtils.result(logWriter.markEndOfStream());\n         } catch (IOException ioe) {\n             throw ioe;\n         } catch (Exception ex) {"},{"sha":"367bb500efdba77d2cdc950801cae8811562aa8a","filename":"src/main/java/org/apache/distributedlog/AsyncNotification.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FAsyncNotification.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FAsyncNotification.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FAsyncNotification.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -17,7 +17,7 @@\n  */\n package org.apache.distributedlog;\n \n-public interface AsyncNotification {\n+interface AsyncNotification {\n     /**\n      * Triggered when the background activity encounters an exception\n      *"},{"sha":"8a0bffbee47774f280eff9f566c08fe5fe4ea77d","filename":"src/main/java/org/apache/distributedlog/BKAbstractLogWriter.java","status":"modified","additions":114,"deletions":125,"changes":239,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FBKAbstractLogWriter.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FBKAbstractLogWriter.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FBKAbstractLogWriter.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -18,6 +18,9 @@\n package org.apache.distributedlog;\n \n import com.google.common.annotations.VisibleForTesting;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n import org.apache.distributedlog.config.DynamicDistributedLogConfiguration;\n import org.apache.distributedlog.exceptions.AlreadyClosedException;\n import org.apache.distributedlog.exceptions.LockingException;\n@@ -27,18 +30,12 @@\n import org.apache.distributedlog.io.Abortables;\n import org.apache.distributedlog.io.AsyncAbortable;\n import org.apache.distributedlog.io.AsyncCloseable;\n-import org.apache.distributedlog.util.FutureUtils;\n-import org.apache.distributedlog.util.PermitManager;\n+import org.apache.distributedlog.common.concurrent.FutureEventListener;\n+import org.apache.distributedlog.common.concurrent.FutureUtils;\n+import org.apache.distributedlog.common.util.PermitManager;\n import org.apache.distributedlog.util.Utils;\n-import com.twitter.util.Function;\n-import com.twitter.util.Future;\n-import com.twitter.util.FutureEventListener;\n-import com.twitter.util.Promise;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n-import scala.runtime.AbstractFunction0;\n-import scala.runtime.AbstractFunction1;\n-import scala.runtime.BoxedUnit;\n \n import java.io.Closeable;\n import java.io.IOException;\n@@ -53,18 +50,18 @@ abstract class BKAbstractLogWriter implements Closeable, AsyncCloseable, Abortab\n     protected final BKDistributedLogManager bkDistributedLogManager;\n \n     // States\n-    private Promise<Void> closePromise = null;\n+    private CompletableFuture<Void> closePromise = null;\n     private volatile boolean forceRolling = false;\n     private boolean forceRecovery = false;\n \n     // Truncation Related\n-    private Future<List<LogSegmentMetadata>> lastTruncationAttempt = null;\n+    private CompletableFuture<List<LogSegmentMetadata>> lastTruncationAttempt = null;\n     @VisibleForTesting\n     private Long minTimestampToKeepOverride = null;\n \n     // Log Segment Writers\n     protected BKLogSegmentWriter segmentWriter = null;\n-    protected Future<BKLogSegmentWriter> segmentWriterFuture = null;\n+    protected CompletableFuture<BKLogSegmentWriter> segmentWriterFuture = null;\n     protected BKLogSegmentWriter allocatedSegmentWriter = null;\n     protected BKLogWriteHandler writeHandler = null;\n \n@@ -100,7 +97,7 @@ protected BKLogWriteHandler createAndCacheWriteHandler()\n         // This code path will be executed when the handler is not set or has been closed\n         // due to forceRecovery during testing\n         BKLogWriteHandler newHandler =\n-                FutureUtils.result(bkDistributedLogManager.asyncCreateWriteHandler(false));\n+                Utils.ioResult(bkDistributedLogManager.asyncCreateWriteHandler(false));\n         boolean success = false;\n         try {\n             synchronized (this) {\n@@ -123,13 +120,13 @@ protected synchronized BKLogSegmentWriter getCachedLogWriter() {\n         return segmentWriter;\n     }\n \n-    protected synchronized Future<BKLogSegmentWriter> getCachedLogWriterFuture() {\n+    protected synchronized CompletableFuture<BKLogSegmentWriter> getCachedLogWriterFuture() {\n         return segmentWriterFuture;\n     }\n \n     protected synchronized void cacheLogWriter(BKLogSegmentWriter logWriter) {\n         this.segmentWriter = logWriter;\n-        this.segmentWriterFuture = Future.value(logWriter);\n+        this.segmentWriterFuture = FutureUtils.value(logWriter);\n     }\n \n     protected synchronized BKLogSegmentWriter removeCachedLogWriter() {\n@@ -157,12 +154,12 @@ protected synchronized BKLogSegmentWriter removeAllocatedLogWriter() {\n         }\n     }\n \n-    private Future<Void> asyncCloseAndComplete(boolean shouldThrow) {\n+    private CompletableFuture<Void> asyncCloseAndComplete(boolean shouldThrow) {\n         BKLogSegmentWriter segmentWriter = getCachedLogWriter();\n         BKLogWriteHandler writeHandler = getCachedWriteHandler();\n         if (null != segmentWriter && null != writeHandler) {\n             cancelTruncation();\n-            Promise<Void> completePromise = new Promise<Void>();\n+            CompletableFuture<Void> completePromise = new CompletableFuture<Void>();\n             asyncCloseAndComplete(segmentWriter, writeHandler, completePromise, shouldThrow);\n             return completePromise;\n         } else {\n@@ -172,10 +169,10 @@ private Future<Void> asyncCloseAndComplete(boolean shouldThrow) {\n \n     private void asyncCloseAndComplete(final BKLogSegmentWriter segmentWriter,\n                                        final BKLogWriteHandler writeHandler,\n-                                       final Promise<Void> completePromise,\n+                                       final CompletableFuture<Void> completePromise,\n                                        final boolean shouldThrow) {\n         writeHandler.completeAndCloseLogSegment(segmentWriter)\n-                .addEventListener(new FutureEventListener<LogSegmentMetadata>() {\n+                .whenComplete(new FutureEventListener<LogSegmentMetadata>() {\n                     @Override\n                     public void onSuccess(LogSegmentMetadata segment) {\n                         removeCachedLogWriter();\n@@ -189,15 +186,11 @@ public void onFailure(Throwable cause) {\n                     }\n \n                     private void complete(final Throwable cause) {\n-                        closeNoThrow().ensure(new AbstractFunction0<BoxedUnit>() {\n-                            @Override\n-                            public BoxedUnit apply() {\n-                                if (null != cause && shouldThrow) {\n-                                    FutureUtils.setException(completePromise, cause);\n-                                } else {\n-                                    FutureUtils.setValue(completePromise, null);\n-                                }\n-                                return BoxedUnit.UNIT;\n+                        FutureUtils.ensure(closeNoThrow(), () -> {\n+                            if (null != cause && shouldThrow) {\n+                                FutureUtils.completeExceptionally(completePromise, cause);\n+                            } else {\n+                                FutureUtils.complete(completePromise, null);\n                             }\n                         });\n                     }\n@@ -206,125 +199,129 @@ public BoxedUnit apply() {\n \n     @VisibleForTesting\n     void closeAndComplete() throws IOException {\n-        FutureUtils.result(asyncCloseAndComplete(true));\n+        Utils.ioResult(asyncCloseAndComplete(true));\n     }\n \n-    protected Future<Void> asyncCloseAndComplete() {\n+    protected CompletableFuture<Void> asyncCloseAndComplete() {\n         return asyncCloseAndComplete(true);\n     }\n \n     @Override\n     public void close() throws IOException {\n-        FutureUtils.result(asyncClose());\n+        Utils.ioResult(asyncClose());\n     }\n \n     @Override\n-    public Future<Void> asyncClose() {\n+    public CompletableFuture<Void> asyncClose() {\n         return asyncCloseAndComplete(false);\n     }\n \n     /**\n      * Close the writer and release all the underlying resources\n      */\n-    protected Future<Void> closeNoThrow() {\n-        Promise<Void> closeFuture;\n+    protected CompletableFuture<Void> closeNoThrow() {\n+        CompletableFuture<Void> closeFuture;\n         synchronized (this) {\n             if (null != closePromise) {\n                 return closePromise;\n             }\n-            closeFuture = closePromise = new Promise<Void>();\n+            closeFuture = closePromise = new CompletableFuture<Void>();\n         }\n         cancelTruncation();\n-        Utils.closeSequence(bkDistributedLogManager.getScheduler(),\n-                true, /** ignore close errors **/\n-                getCachedLogWriter(),\n-                getAllocatedLogWriter(),\n-                getCachedWriteHandler()\n-        ).proxyTo(closeFuture);\n+        FutureUtils.proxyTo(\n+            Utils.closeSequence(bkDistributedLogManager.getScheduler(),\n+                    true, /** ignore close errors **/\n+                    getCachedLogWriter(),\n+                    getAllocatedLogWriter(),\n+                    getCachedWriteHandler()\n+            ),\n+            closeFuture);\n         return closeFuture;\n     }\n \n     @Override\n     public void abort() throws IOException {\n-        FutureUtils.result(asyncAbort());\n+        Utils.ioResult(asyncAbort());\n     }\n \n     @Override\n-    public Future<Void> asyncAbort() {\n-        Promise<Void> closeFuture;\n+    public CompletableFuture<Void> asyncAbort() {\n+        CompletableFuture<Void> closeFuture;\n         synchronized (this) {\n             if (null != closePromise) {\n                 return closePromise;\n             }\n-            closeFuture = closePromise = new Promise<Void>();\n+            closeFuture = closePromise = new CompletableFuture<Void>();\n         }\n         cancelTruncation();\n-        Abortables.abortSequence(bkDistributedLogManager.getScheduler(),\n-                getCachedLogWriter(),\n-                getAllocatedLogWriter(),\n-                getCachedWriteHandler()).proxyTo(closeFuture);\n+        FutureUtils.proxyTo(\n+            Abortables.abortSequence(bkDistributedLogManager.getScheduler(),\n+                    getCachedLogWriter(),\n+                    getAllocatedLogWriter(),\n+                    getCachedWriteHandler()),\n+            closeFuture);\n         return closeFuture;\n     }\n \n     // used by sync writer\n     protected BKLogSegmentWriter getLedgerWriter(final long startTxId,\n                                                  final boolean allowMaxTxID)\n             throws IOException {\n-        Future<BKLogSegmentWriter> logSegmentWriterFuture = asyncGetLedgerWriter(true);\n+        CompletableFuture<BKLogSegmentWriter> logSegmentWriterFuture = asyncGetLedgerWriter(true);\n         BKLogSegmentWriter logSegmentWriter = null;\n         if (null != logSegmentWriterFuture) {\n-            logSegmentWriter = FutureUtils.result(logSegmentWriterFuture);\n+            logSegmentWriter = Utils.ioResult(logSegmentWriterFuture);\n         }\n         if (null == logSegmentWriter || (shouldStartNewSegment(logSegmentWriter) || forceRolling)) {\n-            logSegmentWriter = FutureUtils.result(rollLogSegmentIfNecessary(\n+            logSegmentWriter = Utils.ioResult(rollLogSegmentIfNecessary(\n                     logSegmentWriter, startTxId, true /* bestEffort */, allowMaxTxID));\n         }\n         return logSegmentWriter;\n     }\n \n     // used by async writer\n-    synchronized protected Future<BKLogSegmentWriter> asyncGetLedgerWriter(boolean resetOnError) {\n+    synchronized protected CompletableFuture<BKLogSegmentWriter> asyncGetLedgerWriter(boolean resetOnError) {\n         final BKLogSegmentWriter ledgerWriter = getCachedLogWriter();\n-        Future<BKLogSegmentWriter> ledgerWriterFuture = getCachedLogWriterFuture();\n+        CompletableFuture<BKLogSegmentWriter> ledgerWriterFuture = getCachedLogWriterFuture();\n         if (null == ledgerWriterFuture || null == ledgerWriter) {\n             return null;\n         }\n \n         // Handle the case where the last call to write actually caused an error in the log\n         if ((ledgerWriter.isLogSegmentInError() || forceRecovery) && resetOnError) {\n             // Close the ledger writer so that we will recover and start a new log segment\n-            Future<Void> closeFuture;\n+            CompletableFuture<Void> closeFuture;\n             if (ledgerWriter.isLogSegmentInError()) {\n                 closeFuture = ledgerWriter.asyncAbort();\n             } else {\n                 closeFuture = ledgerWriter.asyncClose();\n             }\n-            return closeFuture.flatMap(\n-                    new AbstractFunction1<Void, Future<BKLogSegmentWriter>>() {\n+            return closeFuture.thenCompose(\n+                    new Function<Void, CompletionStage<BKLogSegmentWriter>>() {\n                 @Override\n-                public Future<BKLogSegmentWriter> apply(Void result) {\n+                public CompletableFuture<BKLogSegmentWriter> apply(Void result) {\n                     removeCachedLogWriter();\n \n                     if (ledgerWriter.isLogSegmentInError()) {\n-                        return Future.value(null);\n+                        return FutureUtils.value(null);\n                     }\n \n                     BKLogWriteHandler writeHandler;\n                     try {\n                         writeHandler = getWriteHandler();\n                     } catch (IOException e) {\n-                        return Future.exception(e);\n+                        return FutureUtils.exception(e);\n                     }\n                     if (null != writeHandler && forceRecovery) {\n                         return writeHandler.completeAndCloseLogSegment(ledgerWriter)\n-                                .map(new AbstractFunction1<LogSegmentMetadata, BKLogSegmentWriter>() {\n+                                .thenApply(new Function<LogSegmentMetadata, BKLogSegmentWriter>() {\n                             @Override\n                             public BKLogSegmentWriter apply(LogSegmentMetadata completedLogSegment) {\n                                 return null;\n                             }\n                         });\n                     } else {\n-                        return Future.value(null);\n+                        return FutureUtils.value(null);\n                     }\n                 }\n             });\n@@ -357,80 +354,72 @@ private void truncateLogSegmentsIfNecessary(BKLogWriteHandler writeHandler) {\n         // skip scheduling if there is task that's already running\n         //\n         synchronized (this) {\n-            if (truncationEnabled && ((lastTruncationAttempt == null) || lastTruncationAttempt.isDefined())) {\n+            if (truncationEnabled && ((lastTruncationAttempt == null) || lastTruncationAttempt.isDone())) {\n                 lastTruncationAttempt = writeHandler.purgeLogSegmentsOlderThanTimestamp(minTimestampToKeep);\n             }\n         }\n     }\n \n-    private Future<BKLogSegmentWriter> asyncStartNewLogSegment(final BKLogWriteHandler writeHandler,\n+    private CompletableFuture<BKLogSegmentWriter> asyncStartNewLogSegment(final BKLogWriteHandler writeHandler,\n                                                                final long startTxId,\n                                                                final boolean allowMaxTxID) {\n         return writeHandler.recoverIncompleteLogSegments()\n-                .flatMap(new AbstractFunction1<Long, Future<BKLogSegmentWriter>>() {\n-            @Override\n-            public Future<BKLogSegmentWriter> apply(Long lastTxId) {\n-                return writeHandler.asyncStartLogSegment(startTxId, false, allowMaxTxID)\n-                        .onSuccess(new AbstractFunction1<BKLogSegmentWriter, BoxedUnit>() {\n-                    @Override\n-                    public BoxedUnit apply(BKLogSegmentWriter newSegmentWriter) {\n+            .thenCompose(\n+                lastTxId -> writeHandler.asyncStartLogSegment(startTxId, false, allowMaxTxID)\n+                    .thenApply(newSegmentWriter -> {\n                         cacheLogWriter(newSegmentWriter);\n-                        return BoxedUnit.UNIT;\n-                    }\n-                });\n-            }\n-        });\n+                        return newSegmentWriter;\n+                    }));\n     }\n \n-    private Future<BKLogSegmentWriter> closeOldLogSegmentAndStartNewOneWithPermit(\n+    private CompletableFuture<BKLogSegmentWriter> closeOldLogSegmentAndStartNewOneWithPermit(\n             final BKLogSegmentWriter oldSegmentWriter,\n             final BKLogWriteHandler writeHandler,\n             final long startTxId,\n             final boolean bestEffort,\n             final boolean allowMaxTxID) {\n         final PermitManager.Permit switchPermit = bkDistributedLogManager.getLogSegmentRollingPermitManager().acquirePermit();\n         if (switchPermit.isAllowed()) {\n-            return closeOldLogSegmentAndStartNewOne(\n-                    oldSegmentWriter,\n-                    writeHandler,\n-                    startTxId,\n-                    bestEffort,\n-                    allowMaxTxID\n-            ).rescue(new Function<Throwable, Future<BKLogSegmentWriter>>() {\n-                @Override\n-                public Future<BKLogSegmentWriter> apply(Throwable cause) {\n-                    if (cause instanceof LockingException) {\n-                        LOG.warn(\"We lost lock during completeAndClose log segment for {}. Disable ledger rolling until it is recovered : \",\n-                                writeHandler.getFullyQualifiedName(), cause);\n-                        bkDistributedLogManager.getLogSegmentRollingPermitManager().disallowObtainPermits(switchPermit);\n-                        return Future.value(oldSegmentWriter);\n-                    } else if (cause instanceof ZKException) {\n-                        ZKException zke = (ZKException) cause;\n-                        if (ZKException.isRetryableZKException(zke)) {\n-                            LOG.warn(\"Encountered zookeeper connection issues during completeAndClose log segment for {}.\" +\n-                                    \" Disable ledger rolling until it is recovered : {}\", writeHandler.getFullyQualifiedName(),\n-                                    zke.getKeeperExceptionCode());\n+            return FutureUtils.ensure(\n+                FutureUtils.rescue(\n+                     closeOldLogSegmentAndStartNewOne(\n+                            oldSegmentWriter,\n+                            writeHandler,\n+                            startTxId,\n+                            bestEffort,\n+                            allowMaxTxID\n+                    ),\n+                    // rescue function\n+                    cause -> {\n+                        if (cause instanceof LockingException) {\n+                            LOG.warn(\"We lost lock during completeAndClose log segment for {}. Disable ledger rolling until it is recovered : \",\n+                                    writeHandler.getFullyQualifiedName(), cause);\n                             bkDistributedLogManager.getLogSegmentRollingPermitManager().disallowObtainPermits(switchPermit);\n-                            return Future.value(oldSegmentWriter);\n+                            return FutureUtils.value(oldSegmentWriter);\n+                        } else if (cause instanceof ZKException) {\n+                            ZKException zke = (ZKException) cause;\n+                            if (ZKException.isRetryableZKException(zke)) {\n+                                LOG.warn(\"Encountered zookeeper connection issues during completeAndClose log segment for {}.\" +\n+                                        \" Disable ledger rolling until it is recovered : {}\", writeHandler.getFullyQualifiedName(),\n+                                        zke.getKeeperExceptionCode());\n+                                bkDistributedLogManager.getLogSegmentRollingPermitManager().disallowObtainPermits(switchPermit);\n+                                return FutureUtils.value(oldSegmentWriter);\n+                            }\n                         }\n+                        return FutureUtils.exception(cause);\n                     }\n-                    return Future.exception(cause);\n-                }\n-            }).ensure(new AbstractFunction0<BoxedUnit>() {\n-                @Override\n-                public BoxedUnit apply() {\n-                    bkDistributedLogManager.getLogSegmentRollingPermitManager()\n-                            .releasePermit(switchPermit);\n-                    return BoxedUnit.UNIT;\n-                }\n-            });\n+                ),\n+                // ensure function\n+                () -> bkDistributedLogManager.getLogSegmentRollingPermitManager()\n+                                .releasePermit(switchPermit)\n+            );\n         } else {\n             bkDistributedLogManager.getLogSegmentRollingPermitManager().releasePermit(switchPermit);\n-            return Future.value(oldSegmentWriter);\n+            return FutureUtils.value(oldSegmentWriter);\n         }\n     }\n \n-    private Future<BKLogSegmentWriter> closeOldLogSegmentAndStartNewOne(\n+    private CompletableFuture<BKLogSegmentWriter> closeOldLogSegmentAndStartNewOne(\n             final BKLogSegmentWriter oldSegmentWriter,\n             final BKLogWriteHandler writeHandler,\n             final long startTxId,\n@@ -444,14 +433,14 @@ private Future<BKLogSegmentWriter> closeOldLogSegmentAndStartNewOne(\n                         writeHandler.getFullyQualifiedName());\n             }\n             return writeHandler.asyncStartLogSegment(startTxId, bestEffort, allowMaxTxID)\n-                    .flatMap(new AbstractFunction1<BKLogSegmentWriter, Future<BKLogSegmentWriter>>() {\n+                    .thenCompose(new Function<BKLogSegmentWriter, CompletableFuture<BKLogSegmentWriter>>() {\n                         @Override\n-                        public Future<BKLogSegmentWriter> apply(BKLogSegmentWriter newSegmentWriter) {\n+                        public CompletableFuture<BKLogSegmentWriter> apply(BKLogSegmentWriter newSegmentWriter) {\n                             if (null == newSegmentWriter) {\n                                 if (bestEffort) {\n-                                    return Future.value(oldSegmentWriter);\n+                                    return FutureUtils.value(oldSegmentWriter);\n                                 } else {\n-                                    return Future.exception(\n+                                    return FutureUtils.exception(\n                                             new UnexpectedException(\"StartLogSegment returns null for bestEffort rolling\"));\n                                 }\n                             }\n@@ -468,30 +457,30 @@ public Future<BKLogSegmentWriter> apply(BKLogSegmentWriter newSegmentWriter) {\n         }\n     }\n \n-    private Future<BKLogSegmentWriter> completeOldSegmentAndCacheNewLogSegmentWriter(\n+    private CompletableFuture<BKLogSegmentWriter> completeOldSegmentAndCacheNewLogSegmentWriter(\n             BKLogSegmentWriter oldSegmentWriter,\n             final BKLogSegmentWriter newSegmentWriter) {\n-        final Promise<BKLogSegmentWriter> completePromise = new Promise<BKLogSegmentWriter>();\n+        final CompletableFuture<BKLogSegmentWriter> completePromise = new CompletableFuture<BKLogSegmentWriter>();\n         // complete the old log segment\n         writeHandler.completeAndCloseLogSegment(oldSegmentWriter)\n-                .addEventListener(new FutureEventListener<LogSegmentMetadata>() {\n+                .whenComplete(new FutureEventListener<LogSegmentMetadata>() {\n \n                     @Override\n                     public void onSuccess(LogSegmentMetadata value) {\n                         cacheLogWriter(newSegmentWriter);\n                         removeAllocatedLogWriter();\n-                        FutureUtils.setValue(completePromise, newSegmentWriter);\n+                        FutureUtils.complete(completePromise, newSegmentWriter);\n                     }\n \n                     @Override\n                     public void onFailure(Throwable cause) {\n-                        FutureUtils.setException(completePromise, cause);\n+                        FutureUtils.completeExceptionally(completePromise, cause);\n                     }\n                 });\n         return completePromise;\n     }\n \n-    synchronized protected Future<BKLogSegmentWriter> rollLogSegmentIfNecessary(\n+    synchronized protected CompletableFuture<BKLogSegmentWriter> rollLogSegmentIfNecessary(\n             final BKLogSegmentWriter segmentWriter,\n             long startTxId,\n             boolean bestEffort,\n@@ -500,18 +489,18 @@ synchronized protected Future<BKLogSegmentWriter> rollLogSegmentIfNecessary(\n         try {\n             writeHandler = getWriteHandler();\n         } catch (IOException e) {\n-            return Future.exception(e);\n+            return FutureUtils.exception(e);\n         }\n-        Future<BKLogSegmentWriter> rollPromise;\n+        CompletableFuture<BKLogSegmentWriter> rollPromise;\n         if (null != segmentWriter && (writeHandler.shouldStartNewSegment(segmentWriter) || forceRolling)) {\n             rollPromise = closeOldLogSegmentAndStartNewOneWithPermit(\n                     segmentWriter, writeHandler, startTxId, bestEffort, allowMaxTxID);\n         } else if (null == segmentWriter) {\n             rollPromise = asyncStartNewLogSegment(writeHandler, startTxId, allowMaxTxID);\n         } else {\n-            rollPromise = Future.value(segmentWriter);\n+            rollPromise = FutureUtils.value(segmentWriter);\n         }\n-        return rollPromise.map(new AbstractFunction1<BKLogSegmentWriter, BKLogSegmentWriter>() {\n+        return rollPromise.thenApply(new Function<BKLogSegmentWriter, BKLogSegmentWriter>() {\n             @Override\n             public BKLogSegmentWriter apply(BKLogSegmentWriter newSegmentWriter) {\n                 if (segmentWriter == newSegmentWriter) {\n@@ -542,7 +531,7 @@ public synchronized void overRideMinTimeStampToKeep(Long minTimestampToKeepOverr\n \n     protected synchronized void cancelTruncation() {\n         if (null != lastTruncationAttempt) {\n-            FutureUtils.cancel(lastTruncationAttempt);\n+            lastTruncationAttempt.cancel(true);\n             lastTruncationAttempt = null;\n         }\n     }"},{"sha":"26a4a763a95b3d16983ca02844b82b524312b952","filename":"src/main/java/org/apache/distributedlog/BKAsyncLogReader.java","status":"modified","additions":51,"deletions":63,"changes":114,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FBKAsyncLogReader.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FBKAsyncLogReader.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FBKAsyncLogReader.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -21,39 +21,33 @@\n import com.google.common.base.Optional;\n import com.google.common.base.Stopwatch;\n import com.google.common.base.Ticker;\n-import org.apache.distributedlog.exceptions.DLIllegalStateException;\n-import org.apache.distributedlog.exceptions.DLInterruptedException;\n-import org.apache.distributedlog.exceptions.EndOfStreamException;\n-import org.apache.distributedlog.exceptions.IdleReaderException;\n-import org.apache.distributedlog.exceptions.LogNotFoundException;\n-import org.apache.distributedlog.exceptions.ReadCancelledException;\n-import org.apache.distributedlog.exceptions.UnexpectedException;\n-import org.apache.distributedlog.util.OrderedScheduler;\n-import org.apache.distributedlog.util.Utils;\n-import com.twitter.util.Future;\n-import com.twitter.util.FutureEventListener;\n-import com.twitter.util.Promise;\n-import com.twitter.util.Throw;\n-\n import java.io.IOException;\n import java.util.ArrayList;\n import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.ConcurrentLinkedQueue;\n-import java.util.concurrent.ScheduledExecutorService;\n import java.util.concurrent.ScheduledFuture;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicLong;\n import java.util.concurrent.atomic.AtomicReference;\n-\n+import java.util.function.Function;\n import org.apache.bookkeeper.stats.Counter;\n import org.apache.bookkeeper.stats.OpStatsLogger;\n import org.apache.bookkeeper.stats.StatsLogger;\n-import org.apache.bookkeeper.versioning.Versioned;\n+import org.apache.distributedlog.api.AsyncLogReader;\n+import org.apache.distributedlog.exceptions.DLIllegalStateException;\n+import org.apache.distributedlog.exceptions.DLInterruptedException;\n+import org.apache.distributedlog.exceptions.EndOfStreamException;\n+import org.apache.distributedlog.exceptions.IdleReaderException;\n+import org.apache.distributedlog.exceptions.LogNotFoundException;\n+import org.apache.distributedlog.exceptions.ReadCancelledException;\n+import org.apache.distributedlog.exceptions.UnexpectedException;\n+import org.apache.distributedlog.common.concurrent.FutureEventListener;\n+import org.apache.distributedlog.common.concurrent.FutureUtils;\n+import org.apache.distributedlog.util.OrderedScheduler;\n+import org.apache.distributedlog.util.Utils;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n-import scala.Function1;\n-import scala.runtime.AbstractFunction1;\n-import scala.runtime.BoxedUnit;\n \n /**\n  * BookKeeper based {@link AsyncLogReader} implementation.\n@@ -76,13 +70,8 @@\n class BKAsyncLogReader implements AsyncLogReader, Runnable, AsyncNotification {\n     static final Logger LOG = LoggerFactory.getLogger(BKAsyncLogReader.class);\n \n-    private static final Function1<List<LogRecordWithDLSN>, LogRecordWithDLSN> READ_NEXT_MAP_FUNCTION =\n-            new AbstractFunction1<List<LogRecordWithDLSN>, LogRecordWithDLSN>() {\n-                @Override\n-                public LogRecordWithDLSN apply(List<LogRecordWithDLSN> records) {\n-                    return records.get(0);\n-                }\n-            };\n+    private static final Function<List<LogRecordWithDLSN>, LogRecordWithDLSN> READ_NEXT_MAP_FUNCTION =\n+        records -> records.get(0);\n \n     private final String streamName;\n     protected final BKDistributedLogManager bkDistributedLogManager;\n@@ -104,7 +93,7 @@ public LogRecordWithDLSN apply(List<LogRecordWithDLSN> records) {\n     // last process time\n     private final Stopwatch lastProcessTime;\n \n-    protected Promise<Void> closeFuture = null;\n+    protected CompletableFuture<Void> closeFuture = null;\n \n     private boolean lockStream = false;\n \n@@ -143,7 +132,7 @@ private class PendingReadRequest {\n         private final Stopwatch enqueueTime;\n         private final int numEntries;\n         private final List<LogRecordWithDLSN> records;\n-        private final Promise<List<LogRecordWithDLSN>> promise;\n+        private final CompletableFuture<List<LogRecordWithDLSN>> promise;\n         private final long deadlineTime;\n         private final TimeUnit deadlineTimeUnit;\n \n@@ -158,22 +147,22 @@ private class PendingReadRequest {\n             } else {\n                 this.records = new ArrayList<LogRecordWithDLSN>();\n             }\n-            this.promise = new Promise<List<LogRecordWithDLSN>>();\n+            this.promise = new CompletableFuture<List<LogRecordWithDLSN>>();\n             this.deadlineTime = deadlineTime;\n             this.deadlineTimeUnit = deadlineTimeUnit;\n         }\n \n-        Promise<List<LogRecordWithDLSN>> getPromise() {\n+        CompletableFuture<List<LogRecordWithDLSN>> getPromise() {\n             return promise;\n         }\n \n         long elapsedSinceEnqueue(TimeUnit timeUnit) {\n             return enqueueTime.elapsed(timeUnit);\n         }\n \n-        void setException(Throwable throwable) {\n+        void completeExceptionally(Throwable throwable) {\n             Stopwatch stopwatch = Stopwatch.createStarted();\n-            if (promise.updateIfEmpty(new Throw<List<LogRecordWithDLSN>>(throwable))) {\n+            if (promise.completeExceptionally(throwable)) {\n                 futureSetLatency.registerFailedEvent(stopwatch.stop().elapsed(TimeUnit.MICROSECONDS));\n                 delayUntilPromiseSatisfied.registerFailedEvent(enqueueTime.elapsed(TimeUnit.MICROSECONDS));\n             }\n@@ -204,7 +193,7 @@ void complete() {\n             }\n             delayUntilPromiseSatisfied.registerSuccessfulEvent(enqueueTime.stop().elapsed(TimeUnit.MICROSECONDS));\n             Stopwatch stopwatch = Stopwatch.createStarted();\n-            promise.setValue(records);\n+            promise.complete(records);\n             futureSetLatency.registerSuccessfulEvent(stopwatch.stop().elapsed(TimeUnit.MICROSECONDS));\n         }\n     }\n@@ -333,7 +322,7 @@ public synchronized DLSN getStartDLSN() {\n         return startDLSN;\n     }\n \n-    public Future<Void> lockStream() {\n+    public CompletableFuture<Void> lockStream() {\n         this.lockStream = true;\n         return readHandler.lockStream();\n     }\n@@ -381,16 +370,16 @@ public String getStreamName() {\n      * @return A promise that when satisfied will contain the Log Record with its DLSN.\n      */\n     @Override\n-    public synchronized Future<LogRecordWithDLSN> readNext() {\n-        return readInternal(1, 0, TimeUnit.MILLISECONDS).map(READ_NEXT_MAP_FUNCTION);\n+    public synchronized CompletableFuture<LogRecordWithDLSN> readNext() {\n+        return readInternal(1, 0, TimeUnit.MILLISECONDS).thenApply(READ_NEXT_MAP_FUNCTION);\n     }\n \n-    public synchronized Future<List<LogRecordWithDLSN>> readBulk(int numEntries) {\n+    public synchronized CompletableFuture<List<LogRecordWithDLSN>> readBulk(int numEntries) {\n         return readInternal(numEntries, 0, TimeUnit.MILLISECONDS);\n     }\n \n     @Override\n-    public synchronized Future<List<LogRecordWithDLSN>> readBulk(int numEntries,\n+    public synchronized CompletableFuture<List<LogRecordWithDLSN>> readBulk(int numEntries,\n                                                                  long waitTime,\n                                                                  TimeUnit timeUnit) {\n         return readInternal(numEntries, waitTime, timeUnit);\n@@ -404,7 +393,7 @@ public synchronized Future<List<LogRecordWithDLSN>> readBulk(int numEntries,\n      *          num entries to read\n      * @return A promise that satisfied with a non-empty list of log records with their DLSN.\n      */\n-    private synchronized Future<List<LogRecordWithDLSN>> readInternal(int numEntries,\n+    private synchronized CompletableFuture<List<LogRecordWithDLSN>> readInternal(int numEntries,\n                                                                       long deadlineTime,\n                                                                       TimeUnit deadlineTimeUnit) {\n         timeBetweenReadNexts.registerSuccessfulEvent(readNextDelayStopwatch.elapsed(TimeUnit.MICROSECONDS));\n@@ -421,19 +410,15 @@ private synchronized Future<List<LogRecordWithDLSN>> readInternal(int numEntries\n                     bkDistributedLogManager.getScheduler(),\n                     Ticker.systemTicker(),\n                     bkDistributedLogManager.alertStatsLogger);\n-            readHandler.checkLogStreamExists().addEventListener(new FutureEventListener<Void>() {\n+            readHandler.checkLogStreamExists().whenComplete(new FutureEventListener<Void>() {\n                 @Override\n                 public void onSuccess(Void value) {\n                     try {\n                         readHandler.registerListener(readAheadEntryReader);\n                         readHandler.asyncStartFetchLogSegments()\n-                                .map(new AbstractFunction1<Versioned<List<LogSegmentMetadata>>, BoxedUnit>() {\n-                                    @Override\n-                                    public BoxedUnit apply(Versioned<List<LogSegmentMetadata>> logSegments) {\n-                                        readAheadEntryReader.addStateChangeNotification(BKAsyncLogReader.this);\n-                                        readAheadEntryReader.start(logSegments.getValue());\n-                                        return BoxedUnit.UNIT;\n-                                    }\n+                                .thenAccept(logSegments -> {\n+                                    readAheadEntryReader.addStateChangeNotification(BKAsyncLogReader.this);\n+                                    readAheadEntryReader.start(logSegments.getValue());\n                                 });\n                     } catch (Exception exc) {\n                         notifyOnError(exc);\n@@ -448,7 +433,7 @@ public void onFailure(Throwable cause) {\n         }\n \n         if (checkClosedOrInError(\"readNext\")) {\n-            readRequest.setException(lastException.get());\n+            readRequest.completeExceptionally(lastException.get());\n         } else {\n             boolean queueEmpty = pendingRequests.isEmpty();\n             pendingRequests.add(readRequest);\n@@ -478,15 +463,15 @@ public synchronized void scheduleBackgroundRead() {\n     }\n \n     @Override\n-    public Future<Void> asyncClose() {\n+    public CompletableFuture<Void> asyncClose() {\n         // Cancel the idle reader timeout task, interrupting if necessary\n         ReadCancelledException exception;\n-        Promise<Void> closePromise;\n+        CompletableFuture<Void> closePromise;\n         synchronized (this) {\n             if (null != closeFuture) {\n                 return closeFuture;\n             }\n-            closePromise = closeFuture = new Promise<Void>();\n+            closePromise = closeFuture = new CompletableFuture<Void>();\n             exception = new ReadCancelledException(readHandler.getFullyQualifiedName(), \"Reader was closed\");\n             setLastException(exception);\n         }\n@@ -507,16 +492,18 @@ public Future<Void> asyncClose() {\n             readHandler.unregisterListener(readAheadReader);\n             readAheadReader.removeStateChangeNotification(this);\n         }\n-        Utils.closeSequence(bkDistributedLogManager.getScheduler(), true,\n-                readAheadReader,\n-                readHandler\n-        ).proxyTo(closePromise);\n+        FutureUtils.proxyTo(\n+            Utils.closeSequence(bkDistributedLogManager.getScheduler(), true,\n+                    readAheadReader,\n+                    readHandler\n+            ),\n+            closePromise);\n         return closePromise;\n     }\n \n     private void cancelAllPendingReads(Throwable throwExc) {\n         for (PendingReadRequest promise : pendingRequests) {\n-            promise.setException(throwExc);\n+            promise.completeExceptionally(throwExc);\n         }\n         pendingRequests.clear();\n     }\n@@ -591,7 +578,8 @@ public void run() {\n                     }\n \n                     if (disableProcessingReadRequests) {\n-                        LOG.info(\"Reader of {} is forced to stop processing read requests\", readHandler.getFullyQualifiedName());\n+                        LOG.info(\"Reader of {} is forced to stop processing read requests\",\n+                            readHandler.getFullyQualifiedName());\n                         return;\n                     }\n                 }\n@@ -601,9 +589,9 @@ public void run() {\n                 // the reader in error and abort all pending reads since we dont\n                 // know the last consumed read\n                 if (null == lastException.get()) {\n-                    if (nextRequest.getPromise().isInterrupted().isDefined()) {\n-                        setLastException(new DLInterruptedException(\"Interrupted on reading \" + readHandler.getFullyQualifiedName() + \" : \",\n-                                nextRequest.getPromise().isInterrupted().get()));\n+                    if (nextRequest.getPromise().isCancelled()) {\n+                        setLastException(new DLInterruptedException(\"Interrupted on reading \"\n+                            + readHandler.getFullyQualifiedName()));\n                     }\n                 }\n \n@@ -680,9 +668,9 @@ public void run() {\n                     } else {\n                         DLIllegalStateException ise = new DLIllegalStateException(\"Unexpected condition at dlsn = \"\n                                 + nextRequest.records.get(0).getDlsn());\n-                        nextRequest.setException(ise);\n+                        nextRequest.completeExceptionally(ise);\n                         if (null != request) {\n-                            request.setException(ise);\n+                            request.completeExceptionally(ise);\n                         }\n                         // We should never get here as we should have exited the loop if\n                         // pendingRequests were empty"},{"sha":"62b32f24803c74ca1585ff4e009b81fd499ff30e","filename":"src/main/java/org/apache/distributedlog/BKAsyncLogWriter.java","status":"modified","additions":75,"deletions":106,"changes":181,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FBKAsyncLogWriter.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FBKAsyncLogWriter.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FBKAsyncLogWriter.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -19,33 +19,30 @@\n \n import com.google.common.base.Stopwatch;\n import com.google.common.annotations.VisibleForTesting;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Function;\n+import org.apache.bookkeeper.feature.Feature;\n+import org.apache.bookkeeper.feature.FeatureProvider;\n+import org.apache.bookkeeper.stats.Counter;\n+import org.apache.bookkeeper.stats.OpStatsLogger;\n+import org.apache.bookkeeper.stats.StatsLogger;\n+import org.apache.distributedlog.api.AsyncLogWriter;\n import org.apache.distributedlog.config.DynamicDistributedLogConfiguration;\n import org.apache.distributedlog.exceptions.StreamNotReadyException;\n import org.apache.distributedlog.exceptions.WriteCancelledException;\n import org.apache.distributedlog.exceptions.WriteException;\n import org.apache.distributedlog.feature.CoreFeatureKeys;\n import org.apache.distributedlog.util.FailpointUtils;\n-import org.apache.distributedlog.util.FutureUtils;\n-import com.twitter.util.Future;\n-import com.twitter.util.FutureEventListener;\n-import com.twitter.util.Promise;\n-import com.twitter.util.Try;\n-import org.apache.bookkeeper.feature.Feature;\n-import org.apache.bookkeeper.feature.FeatureProvider;\n-import org.apache.bookkeeper.stats.Counter;\n-import org.apache.bookkeeper.stats.OpStatsLogger;\n-import org.apache.bookkeeper.stats.StatsLogger;\n+import org.apache.distributedlog.common.concurrent.FutureEventListener;\n+import org.apache.distributedlog.common.concurrent.FutureUtils;\n+import org.apache.distributedlog.util.Utils;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n-import scala.Function1;\n-import scala.Option;\n-import scala.runtime.AbstractFunction1;\n-\n-import java.io.IOException;\n-import java.util.ArrayList;\n-import java.util.Iterator;\n-import java.util.LinkedList;\n-import java.util.List;\n \n /**\n  * BookKeeper based {@link AsyncLogWriter} implementation.\n@@ -70,35 +67,30 @@ class BKAsyncLogWriter extends BKAbstractLogWriter implements AsyncLogWriter {\n \n     static final Logger LOG = LoggerFactory.getLogger(BKAsyncLogWriter.class);\n \n-    static Function1<List<LogSegmentMetadata>, Boolean> TruncationResultConverter =\n-            new AbstractFunction1<List<LogSegmentMetadata>, Boolean>() {\n-                @Override\n-                public Boolean apply(List<LogSegmentMetadata> segments) {\n-                    return true;\n-                }\n-            };\n+    static Function<List<LogSegmentMetadata>, Boolean> TruncationResultConverter =\n+        segments -> true;\n \n     // Records pending for roll log segment.\n     class PendingLogRecord implements FutureEventListener<DLSN> {\n \n         final LogRecord record;\n-        final Promise<DLSN> promise;\n+        final CompletableFuture<DLSN> promise;\n         final boolean flush;\n \n         PendingLogRecord(LogRecord record, boolean flush) {\n             this.record = record;\n-            this.promise = new Promise<DLSN>();\n+            this.promise = new CompletableFuture<DLSN>();\n             this.flush = flush;\n         }\n \n         @Override\n         public void onSuccess(DLSN value) {\n-            promise.setValue(value);\n+            promise.complete(value);\n         }\n \n         @Override\n         public void onFailure(Throwable cause) {\n-            promise.setException(cause);\n+            promise.completeExceptionally(cause);\n             encounteredError = true;\n         }\n     }\n@@ -135,7 +127,7 @@ public void onFailure(Throwable cause) {\n     private final boolean disableRollOnSegmentError;\n     private LinkedList<PendingLogRecord> pendingRequests = null;\n     private volatile boolean encounteredError = false;\n-    private Promise<BKLogSegmentWriter> rollingFuture = null;\n+    private CompletableFuture<BKLogSegmentWriter> rollingFuture = null;\n     private long lastTxId = DistributedLogConstants.INVALID_TXID;\n \n     private final StatsLogger statsLogger;\n@@ -186,7 +178,7 @@ public synchronized long getLastTxId() {\n      *          log record\n      * @return future of the write\n      */\n-    public Future<DLSN> writeControlRecord(final LogRecord record) {\n+    public CompletableFuture<DLSN> writeControlRecord(final LogRecord record) {\n         record.setControl();\n         return write(record);\n     }\n@@ -206,7 +198,7 @@ private BKLogSegmentWriter getCachedLogSegmentWriter() throws WriteException {\n         }\n     }\n \n-    private Future<BKLogSegmentWriter> getLogSegmentWriter(long firstTxid,\n+    private CompletableFuture<BKLogSegmentWriter> getLogSegmentWriter(long firstTxid,\n                                                            boolean bestEffort,\n                                                            boolean rollLog,\n                                                            boolean allowMaxTxID) {\n@@ -217,24 +209,20 @@ private Future<BKLogSegmentWriter> getLogSegmentWriter(long firstTxid,\n                 stopwatch);\n     }\n \n-    private Future<BKLogSegmentWriter> doGetLogSegmentWriter(final long firstTxid,\n+    private CompletableFuture<BKLogSegmentWriter> doGetLogSegmentWriter(final long firstTxid,\n                                                              final boolean bestEffort,\n                                                              final boolean rollLog,\n                                                              final boolean allowMaxTxID) {\n         if (encounteredError) {\n-            return Future.exception(new WriteException(bkDistributedLogManager.getStreamName(),\n+            return FutureUtils.exception(new WriteException(bkDistributedLogManager.getStreamName(),\n                     \"writer has been closed due to error.\"));\n         }\n-        Future<BKLogSegmentWriter> writerFuture = asyncGetLedgerWriter(!disableRollOnSegmentError);\n+        CompletableFuture<BKLogSegmentWriter> writerFuture = asyncGetLedgerWriter(!disableRollOnSegmentError);\n         if (null == writerFuture) {\n             return rollLogSegmentIfNecessary(null, firstTxid, bestEffort, allowMaxTxID);\n         } else if (rollLog) {\n-            return writerFuture.flatMap(new AbstractFunction1<BKLogSegmentWriter, Future<BKLogSegmentWriter>>() {\n-                @Override\n-                public Future<BKLogSegmentWriter> apply(BKLogSegmentWriter writer) {\n-                    return rollLogSegmentIfNecessary(writer, firstTxid, bestEffort, allowMaxTxID);\n-                }\n-            });\n+            return writerFuture.thenCompose(\n+                writer -> rollLogSegmentIfNecessary(writer, firstTxid, bestEffort, allowMaxTxID));\n         } else {\n             return writerFuture;\n         }\n@@ -244,20 +232,20 @@ public Future<BKLogSegmentWriter> apply(BKLogSegmentWriter writer) {\n      * We write end of stream marker by writing a record with MAX_TXID, so we need to allow using\n      * max txid when rolling for this case only.\n      */\n-    private Future<BKLogSegmentWriter> getLogSegmentWriterForEndOfStream() {\n+    private CompletableFuture<BKLogSegmentWriter> getLogSegmentWriterForEndOfStream() {\n         return getLogSegmentWriter(DistributedLogConstants.MAX_TXID,\n                                      false /* bestEffort */,\n                                      false /* roll log */,\n                                      true /* allow max txid */);\n     }\n \n-    private Future<BKLogSegmentWriter> getLogSegmentWriter(long firstTxid,\n+    private CompletableFuture<BKLogSegmentWriter> getLogSegmentWriter(long firstTxid,\n                                                            boolean bestEffort,\n                                                            boolean rollLog) {\n         return getLogSegmentWriter(firstTxid, bestEffort, rollLog, false /* allow max txid */);\n     }\n \n-    Future<DLSN> queueRequest(LogRecord record, boolean flush) {\n+    CompletableFuture<DLSN> queueRequest(LogRecord record, boolean flush) {\n         PendingLogRecord pendingLogRecord = new PendingLogRecord(record, flush);\n         pendingRequests.add(pendingLogRecord);\n         return pendingLogRecord.promise;\n@@ -276,25 +264,25 @@ boolean shouldRollLog(BKLogSegmentWriter w) {\n     void startQueueingRequests() {\n         assert(null == pendingRequests && null == rollingFuture);\n         pendingRequests = new LinkedList<PendingLogRecord>();\n-        rollingFuture = new Promise<BKLogSegmentWriter>();\n+        rollingFuture = new CompletableFuture<BKLogSegmentWriter>();\n     }\n \n     // for ordering guarantee, we shouldn't send requests to next log segments until\n     // previous log segment is done.\n-    private synchronized Future<DLSN> asyncWrite(final LogRecord record,\n+    private synchronized CompletableFuture<DLSN> asyncWrite(final LogRecord record,\n                                                  boolean flush) {\n         // The passed in writer may be stale since we acquire the writer outside of sync\n         // lock. If we recently rolled and the new writer is cached, use that instead.\n-        Future<DLSN> result = null;\n+        CompletableFuture<DLSN> result = null;\n         BKLogSegmentWriter w;\n         try {\n             w = getCachedLogSegmentWriter();\n         } catch (WriteException we) {\n-            return Future.exception(we);\n+            return FutureUtils.exception(we);\n         }\n         if (null != rollingFuture) {\n             if (streamFailFast) {\n-                result = Future.exception(new StreamNotReadyException(\"Rolling log segment\"));\n+                result = FutureUtils.exception(new StreamNotReadyException(\"Rolling log segment\"));\n             } else {\n                 result = queueRequest(record, flush);\n             }\n@@ -303,7 +291,7 @@ private synchronized Future<DLSN> asyncWrite(final LogRecord record,\n             startQueueingRequests();\n             if (null != w) {\n                 LastPendingLogRecord lastLogRecordInCurrentSegment = new LastPendingLogRecord(record, flush);\n-                w.asyncWrite(record, true).addEventListener(lastLogRecordInCurrentSegment);\n+                w.asyncWrite(record, true).whenComplete(lastLogRecordInCurrentSegment);\n                 result = lastLogRecordInCurrentSegment.promise;\n             } else { // no log segment yet. roll the log segment and issue pending requests.\n                 result = queueRequest(record, flush);\n@@ -314,26 +302,22 @@ private synchronized Future<DLSN> asyncWrite(final LogRecord record,\n         }\n         // use map here rather than onSuccess because we want lastTxId to be updated before\n         // satisfying the future\n-        return result.map(new AbstractFunction1<DLSN, DLSN>() {\n-            @Override\n-            public DLSN apply(DLSN dlsn) {\n-                setLastTxId(record.getTransactionId());\n-                return dlsn;\n-            }\n+        return result.thenApply(dlsn -> {\n+            setLastTxId(record.getTransactionId());\n+            return dlsn;\n         });\n     }\n \n-    private List<Future<DLSN>> asyncWriteBulk(List<LogRecord> records) {\n-        final ArrayList<Future<DLSN>> results = new ArrayList<Future<DLSN>>(records.size());\n+    private List<CompletableFuture<DLSN>> asyncWriteBulk(List<LogRecord> records) {\n+        final ArrayList<CompletableFuture<DLSN>> results = new ArrayList<CompletableFuture<DLSN>>(records.size());\n         Iterator<LogRecord> iterator = records.iterator();\n         while (iterator.hasNext()) {\n             LogRecord record = iterator.next();\n-            Future<DLSN> future = asyncWrite(record, !iterator.hasNext());\n+            CompletableFuture<DLSN> future = asyncWrite(record, !iterator.hasNext());\n             results.add(future);\n \n             // Abort early if an individual write has already failed.\n-            Option<Try<DLSN>> result = future.poll();\n-            if (result.isDefined() && result.get().isThrow()) {\n+            if (future.isDone() && future.isCompletedExceptionally()) {\n                 break;\n             }\n         }\n@@ -343,26 +327,26 @@ private List<Future<DLSN>> asyncWriteBulk(List<LogRecord> records) {\n         return results;\n     }\n \n-    private void appendCancelledFutures(List<Future<DLSN>> futures, int numToAdd) {\n+    private void appendCancelledFutures(List<CompletableFuture<DLSN>> futures, int numToAdd) {\n         final WriteCancelledException cre =\n             new WriteCancelledException(getStreamName());\n         for (int i = 0; i < numToAdd; i++) {\n-            Future<DLSN> cancelledFuture = Future.exception(cre);\n+            CompletableFuture<DLSN> cancelledFuture = FutureUtils.exception(cre);\n             futures.add(cancelledFuture);\n         }\n     }\n \n     private void rollLogSegmentAndIssuePendingRequests(final long firstTxId) {\n         getLogSegmentWriter(firstTxId, true, true)\n-                .addEventListener(new FutureEventListener<BKLogSegmentWriter>() {\n+                .whenComplete(new FutureEventListener<BKLogSegmentWriter>() {\n             @Override\n             public void onSuccess(BKLogSegmentWriter writer) {\n                 try {\n                     synchronized (BKAsyncLogWriter.this) {\n                         for (PendingLogRecord pendingLogRecord : pendingRequests) {\n                             FailpointUtils.checkFailPoint(FailpointUtils.FailPointName.FP_LogWriterIssuePending);\n                             writer.asyncWrite(pendingLogRecord.record, pendingLogRecord.flush)\n-                                    .addEventListener(pendingLogRecord);\n+                                    .whenComplete(pendingLogRecord);\n                         }\n                         // if there are no records in the pending queue, let's write a control record\n                         // so that when a new log segment is rolled, a control record will be added and\n@@ -373,10 +357,10 @@ public void onSuccess(BKLogSegmentWriter writer) {\n                             controlRecord.setControl();\n                             PendingLogRecord controlReq = new PendingLogRecord(controlRecord, false);\n                             writer.asyncWrite(controlReq.record, controlReq.flush)\n-                                    .addEventListener(controlReq);\n+                                    .whenComplete(controlReq);\n                         }\n                         if (null != rollingFuture) {\n-                            FutureUtils.setValue(rollingFuture, writer);\n+                            FutureUtils.complete(rollingFuture, writer);\n                         }\n                         rollingFuture = null;\n                         pendingRequestDispatch.add(pendingRequests.size());\n@@ -401,7 +385,7 @@ void errorOutPendingRequests(Throwable cause, boolean errorOutWriter) {\n             encounteredError = errorOutWriter;\n             pendingRequests = null;\n             if (null != rollingFuture) {\n-                FutureUtils.setException(rollingFuture, cause);\n+                FutureUtils.completeExceptionally(rollingFuture, cause);\n             }\n             rollingFuture = null;\n         }\n@@ -411,7 +395,7 @@ void errorOutPendingRequests(Throwable cause, boolean errorOutWriter) {\n         // After erroring out the writer above, no more requests\n         // will be enqueued to pendingRequests\n         for (PendingLogRecord pendingLogRecord : pendingRequestsSnapshot) {\n-            pendingLogRecord.promise.setException(cause);\n+            pendingLogRecord.promise.completeExceptionally(cause);\n         }\n     }\n \n@@ -425,7 +409,7 @@ void errorOutPendingRequestsAndWriter(Throwable cause) {\n      * @param record single log record\n      */\n     @Override\n-    public Future<DLSN> write(final LogRecord record) {\n+    public CompletableFuture<DLSN> write(final LogRecord record) {\n         final Stopwatch stopwatch = Stopwatch.createStarted();\n         return FutureUtils.stats(\n                 asyncWrite(record, true),\n@@ -442,30 +426,30 @@ public Future<DLSN> write(final LogRecord record) {\n      * @param records list of records\n      */\n     @Override\n-    public Future<List<Future<DLSN>>> writeBulk(final List<LogRecord> records) {\n+    public CompletableFuture<List<CompletableFuture<DLSN>>> writeBulk(final List<LogRecord> records) {\n         final Stopwatch stopwatch = Stopwatch.createStarted();\n         return FutureUtils.stats(\n-                Future.value(asyncWriteBulk(records)),\n+                FutureUtils.value(asyncWriteBulk(records)),\n                 bulkWriteOpStatsLogger,\n                 stopwatch);\n     }\n \n     @Override\n-    public Future<Boolean> truncate(final DLSN dlsn) {\n+    public CompletableFuture<Boolean> truncate(final DLSN dlsn) {\n         if (DLSN.InvalidDLSN == dlsn) {\n-            return Future.value(false);\n+            return FutureUtils.value(false);\n         }\n         BKLogWriteHandler writeHandler;\n         try {\n             writeHandler = getWriteHandler();\n         } catch (IOException e) {\n-            return Future.exception(e);\n+            return FutureUtils.exception(e);\n         }\n-        return writeHandler.setLogSegmentsOlderThanDLSNTruncated(dlsn).map(TruncationResultConverter);\n+        return writeHandler.setLogSegmentsOlderThanDLSNTruncated(dlsn).thenApply(TruncationResultConverter);\n     }\n \n-    Future<Long> flushAndCommit() {\n-        Future<BKLogSegmentWriter> writerFuture;\n+    CompletableFuture<Long> flushAndCommit() {\n+        CompletableFuture<BKLogSegmentWriter> writerFuture;\n         synchronized (this) {\n             if (null != this.rollingFuture) {\n                 writerFuture = this.rollingFuture;\n@@ -474,19 +458,14 @@ Future<Long> flushAndCommit() {\n             }\n         }\n         if (null == writerFuture) {\n-            return Future.value(getLastTxId());\n+            return FutureUtils.value(getLastTxId());\n         }\n-        return writerFuture.flatMap(new AbstractFunction1<BKLogSegmentWriter, Future<Long>>() {\n-            @Override\n-            public Future<Long> apply(BKLogSegmentWriter writer) {\n-                return writer.flushAndCommit();\n-            }\n-        });\n+        return writerFuture.thenCompose(writer -> writer.flushAndCommit());\n     }\n \n-    Future<Long> markEndOfStream() {\n+    CompletableFuture<Long> markEndOfStream() {\n         final Stopwatch stopwatch = Stopwatch.createStarted();\n-        Future<BKLogSegmentWriter> logSegmentWriterFuture;\n+        CompletableFuture<BKLogSegmentWriter> logSegmentWriterFuture;\n         synchronized (this) {\n             logSegmentWriterFuture = this.rollingFuture;\n         }\n@@ -495,38 +474,28 @@ Future<Long> markEndOfStream() {\n         }\n \n         return FutureUtils.stats(\n-                logSegmentWriterFuture.flatMap(new AbstractFunction1<BKLogSegmentWriter, Future<Long>>() {\n-                    @Override\n-                    public Future<Long> apply(BKLogSegmentWriter w) {\n-                        return w.markEndOfStream();\n-                    }\n-                }),\n+                logSegmentWriterFuture.thenCompose(w -> w.markEndOfStream()),\n                 markEndOfStreamOpStatsLogger,\n                 stopwatch);\n     }\n \n     @Override\n-    protected Future<Void> asyncCloseAndComplete() {\n-        Future<BKLogSegmentWriter> logSegmentWriterFuture;\n+    protected CompletableFuture<Void> asyncCloseAndComplete() {\n+        CompletableFuture<BKLogSegmentWriter> logSegmentWriterFuture;\n         synchronized (this) {\n             logSegmentWriterFuture = this.rollingFuture;\n         }\n \n         if (null == logSegmentWriterFuture) {\n             return super.asyncCloseAndComplete();\n         } else {\n-            return logSegmentWriterFuture.flatMap(new AbstractFunction1<BKLogSegmentWriter, Future<Void>>() {\n-                @Override\n-                public Future<Void> apply(BKLogSegmentWriter segmentWriter) {\n-                    return BKAsyncLogWriter.super.asyncCloseAndComplete();\n-                }\n-            });\n+            return logSegmentWriterFuture.thenCompose(segmentWriter1 -> super.asyncCloseAndComplete());\n         }\n     }\n \n     @Override\n     void closeAndComplete() throws IOException {\n-        FutureUtils.result(asyncCloseAndComplete());\n+        Utils.ioResult(asyncCloseAndComplete());\n     }\n \n     /**\n@@ -539,12 +508,12 @@ public String getStreamName() {\n     }\n \n     @Override\n-    public Future<Void> asyncAbort() {\n-        Future<Void> result = super.asyncAbort();\n+    public CompletableFuture<Void> asyncAbort() {\n+        CompletableFuture<Void> result = super.asyncAbort();\n         synchronized (this) {\n             if (pendingRequests != null) {\n                 for (PendingLogRecord pendingLogRecord : pendingRequests) {\n-                    pendingLogRecord.promise.setException(new WriteException(bkDistributedLogManager.getStreamName(),\n+                    pendingLogRecord.promise.completeExceptionally(new WriteException(bkDistributedLogManager.getStreamName(),\n                             \"abort wring: writer has been closed due to error.\"));\n                 }\n             }"},{"sha":"cffe5007095bc858bfb6e305be1208940f52ac41","filename":"src/main/java/org/apache/distributedlog/BKDistributedLogManager.java","status":"modified","additions":174,"deletions":231,"changes":405,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FBKDistributedLogManager.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FBKDistributedLogManager.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FBKDistributedLogManager.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -20,14 +20,22 @@\n import com.google.common.annotations.VisibleForTesting;\n import com.google.common.base.Optional;\n import com.google.common.base.Preconditions;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Function;\n+import org.apache.bookkeeper.feature.FeatureProvider;\n+import org.apache.bookkeeper.stats.AlertStatsLogger;\n+import org.apache.bookkeeper.stats.StatsLogger;\n+import org.apache.distributedlog.api.AsyncLogReader;\n+import org.apache.distributedlog.api.AsyncLogWriter;\n+import org.apache.distributedlog.api.DistributedLogManager;\n+import org.apache.distributedlog.api.LogReader;\n import org.apache.distributedlog.callback.LogSegmentListener;\n import org.apache.distributedlog.config.DynamicDistributedLogConfiguration;\n import org.apache.distributedlog.exceptions.AlreadyClosedException;\n import org.apache.distributedlog.exceptions.LogEmptyException;\n import org.apache.distributedlog.exceptions.LogNotFoundException;\n import org.apache.distributedlog.exceptions.UnexpectedException;\n-import org.apache.distributedlog.function.CloseAsyncCloseableFunction;\n-import org.apache.distributedlog.function.GetVersionedValueFunction;\n import org.apache.distributedlog.injector.AsyncFailureInjector;\n import org.apache.distributedlog.logsegment.LogSegmentEntryStore;\n import org.apache.distributedlog.logsegment.LogSegmentEntryWriter;\n@@ -41,40 +49,25 @@\n import org.apache.distributedlog.logsegment.LogSegmentMetadataCache;\n import org.apache.distributedlog.metadata.LogStreamMetadataStore;\n import org.apache.distributedlog.namespace.NamespaceDriver;\n-import org.apache.distributedlog.stats.BroadCastStatsLogger;\n-import org.apache.distributedlog.subscription.SubscriptionsStore;\n+import org.apache.distributedlog.common.stats.BroadCastStatsLogger;\n+import org.apache.distributedlog.api.subscription.SubscriptionsStore;\n import org.apache.distributedlog.util.Allocator;\n import org.apache.distributedlog.util.DLUtils;\n-import org.apache.distributedlog.util.FutureUtils;\n-import org.apache.distributedlog.util.MonitoredFuturePool;\n+import org.apache.distributedlog.common.concurrent.FutureEventListener;\n+import org.apache.distributedlog.common.concurrent.FutureUtils;\n import org.apache.distributedlog.util.OrderedScheduler;\n-import org.apache.distributedlog.util.PermitLimiter;\n-import org.apache.distributedlog.util.PermitManager;\n-import org.apache.distributedlog.util.SchedulerUtils;\n+import org.apache.distributedlog.common.util.PermitLimiter;\n+import org.apache.distributedlog.common.util.PermitManager;\n import org.apache.distributedlog.util.Utils;\n-import com.twitter.util.ExceptionalFunction;\n-import com.twitter.util.ExceptionalFunction0;\n-import com.twitter.util.Function;\n-import com.twitter.util.Future;\n-import com.twitter.util.FutureEventListener;\n-import com.twitter.util.Promise;\n-import org.apache.bookkeeper.feature.FeatureProvider;\n-import org.apache.bookkeeper.stats.AlertStatsLogger;\n-import org.apache.bookkeeper.stats.StatsLogger;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n-import scala.runtime.AbstractFunction0;\n-import scala.runtime.AbstractFunction1;\n-import scala.runtime.BoxedUnit;\n \n-import java.io.Closeable;\n import java.io.IOException;\n import java.net.URI;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Set;\n import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.TimeUnit;\n \n import static org.apache.distributedlog.namespace.NamespaceDriver.Role.READER;\n import static org.apache.distributedlog.namespace.NamespaceDriver.Role.WRITER;\n@@ -104,20 +97,10 @@ class BKDistributedLogManager implements DistributedLogManager {\n     static final Logger LOG = LoggerFactory.getLogger(BKDistributedLogManager.class);\n \n     static final Function<LogRecordWithDLSN, Long> RECORD_2_TXID_FUNCTION =\n-            new Function<LogRecordWithDLSN, Long>() {\n-                @Override\n-                public Long apply(LogRecordWithDLSN record) {\n-                    return record.getTransactionId();\n-                }\n-            };\n+        record -> record.getTransactionId();\n \n     static final Function<LogRecordWithDLSN, DLSN> RECORD_2_DLSN_FUNCTION =\n-            new Function<LogRecordWithDLSN, DLSN>() {\n-                @Override\n-                public DLSN apply(LogRecordWithDLSN record) {\n-                    return record.getDlsn();\n-                }\n-            };\n+        record -> record.getDlsn();\n \n     private final URI uri;\n     private final String name;\n@@ -127,7 +110,7 @@ public DLSN apply(LogRecordWithDLSN record) {\n     private final DistributedLogConfiguration conf;\n     private final DynamicDistributedLogConfiguration dynConf;\n     private final NamespaceDriver driver;\n-    private Promise<Void> closePromise;\n+    private CompletableFuture<Void> closePromise;\n     private final OrderedScheduler scheduler;\n     private final FeatureProvider featureProvider;\n     private final AsyncFailureInjector failureInjector;\n@@ -272,17 +255,18 @@ private synchronized BKLogReadHandler getReadHandlerAndRegisterListener(\n \n     @Override\n     public List<LogSegmentMetadata> getLogSegments() throws IOException {\n-        return FutureUtils.result(getLogSegmentsAsync());\n+        return Utils.ioResult(getLogSegmentsAsync());\n     }\n \n-    protected Future<List<LogSegmentMetadata>> getLogSegmentsAsync() {\n+    protected CompletableFuture<List<LogSegmentMetadata>> getLogSegmentsAsync() {\n         final BKLogReadHandler readHandler = createReadHandler();\n         return readHandler.readLogSegmentsFromStore(\n                 LogSegmentMetadata.COMPARATOR,\n                 LogSegmentFilter.DEFAULT_FILTER,\n-                null)\n-                .map(GetVersionedValueFunction.GET_LOGSEGMENT_LIST_FUNC)\n-                .ensure(CloseAsyncCloseableFunction.of(readHandler));\n+                null\n+        )\n+        .thenApply((versionedList) -> versionedList.getValue())\n+        .whenComplete((value, cause) -> readHandler.asyncClose());\n     }\n \n     @Override\n@@ -353,29 +337,26 @@ synchronized BKLogReadHandler createReadHandler(Optional<String> subscriberId,\n \n     public BKLogWriteHandler createWriteHandler(boolean lockHandler)\n             throws IOException {\n-        return FutureUtils.result(asyncCreateWriteHandler(lockHandler));\n+        return Utils.ioResult(asyncCreateWriteHandler(lockHandler));\n     }\n \n-    Future<BKLogWriteHandler> asyncCreateWriteHandler(final boolean lockHandler) {\n+    CompletableFuture<BKLogWriteHandler> asyncCreateWriteHandler(final boolean lockHandler) {\n         // Fetching Log Metadata (create if not exists)\n         return driver.getLogStreamMetadataStore(WRITER).getLog(\n                 uri,\n                 name,\n                 true,\n                 conf.getCreateStreamIfNotExists()\n-        ).flatMap(new AbstractFunction1<LogMetadataForWriter, Future<BKLogWriteHandler>>() {\n-            @Override\n-            public Future<BKLogWriteHandler> apply(LogMetadataForWriter logMetadata) {\n-                Promise<BKLogWriteHandler> createPromise = new Promise<BKLogWriteHandler>();\n-                createWriteHandler(logMetadata, lockHandler, createPromise);\n-                return createPromise;\n-            }\n+        ).thenCompose(logMetadata -> {\n+            CompletableFuture<BKLogWriteHandler> createPromise = new CompletableFuture<BKLogWriteHandler>();\n+            createWriteHandler(logMetadata, lockHandler, createPromise);\n+            return createPromise;\n         });\n     }\n \n     private void createWriteHandler(LogMetadataForWriter logMetadata,\n                                     boolean lockHandler,\n-                                    final Promise<BKLogWriteHandler> createPromise) {\n+                                    final CompletableFuture<BKLogWriteHandler> createPromise) {\n         // Build the locks\n         DistributedLock lock;\n         if (conf.isWriteLockEnabled()) {\n@@ -389,7 +370,7 @@ private void createWriteHandler(LogMetadataForWriter logMetadata,\n             segmentAllocator = driver.getLogSegmentEntryStore(WRITER)\n                     .newLogSegmentAllocator(logMetadata, dynConf);\n         } catch (IOException ioe) {\n-            FutureUtils.setException(createPromise, ioe);\n+            FutureUtils.completeExceptionally(createPromise, ioe);\n             return;\n         }\n \n@@ -412,44 +393,37 @@ private void createWriteHandler(LogMetadataForWriter logMetadata,\n                 dynConf,\n                 lock);\n         if (lockHandler) {\n-            writeHandler.lockHandler().addEventListener(new FutureEventListener<DistributedLock>() {\n+            writeHandler.lockHandler().whenComplete(new FutureEventListener<DistributedLock>() {\n                 @Override\n                 public void onSuccess(DistributedLock lock) {\n-                    FutureUtils.setValue(createPromise, writeHandler);\n+                    FutureUtils.complete(createPromise, writeHandler);\n                 }\n \n                 @Override\n                 public void onFailure(final Throwable cause) {\n-                    writeHandler.asyncClose().ensure(new AbstractFunction0<BoxedUnit>() {\n-                        @Override\n-                        public BoxedUnit apply() {\n-                            FutureUtils.setException(createPromise, cause);\n-                            return BoxedUnit.UNIT;\n-                        }\n-                    });\n+                    FutureUtils.ensure(\n+                        writeHandler.asyncClose(),\n+                        () -> FutureUtils.completeExceptionally(createPromise, cause));\n                 }\n             });\n         } else {\n-            FutureUtils.setValue(createPromise, writeHandler);\n+            FutureUtils.complete(createPromise, writeHandler);\n         }\n     }\n \n     PermitManager getLogSegmentRollingPermitManager() {\n         return driver.getLogStreamMetadataStore(WRITER).getPermitManager();\n     }\n \n-    <T> Future<T> processReaderOperation(final Function<BKLogReadHandler, Future<T>> func) {\n-        return scheduler.apply(new ExceptionalFunction0<BKLogReadHandler>() {\n-            @Override\n-            public BKLogReadHandler applyE() throws Throwable {\n-                return getReadHandlerAndRegisterListener(true, null);\n-            }\n-        }).flatMap(new ExceptionalFunction<BKLogReadHandler, Future<T>>() {\n-            @Override\n-            public Future<T> applyE(final BKLogReadHandler readHandler) throws Throwable {\n-                return func.apply(readHandler);\n-            }\n+    <T> CompletableFuture<T> processReaderOperation(final Function<BKLogReadHandler, CompletableFuture<T>> func) {\n+        CompletableFuture<T> future = FutureUtils.createFuture();\n+        scheduler.submit(() -> {\n+            BKLogReadHandler readHandler = getReadHandlerAndRegisterListener(true, null);\n+            FutureUtils.proxyTo(\n+                func.apply(readHandler),\n+                future);\n         });\n+        return future;\n     }\n \n     /**\n@@ -461,7 +435,7 @@ public Future<T> applyE(final BKLogReadHandler readHandler) throws Throwable {\n     @Override\n     public boolean isEndOfStreamMarked() throws IOException {\n         checkClosedOrInError(\"isEndOfStreamMarked\");\n-        long lastTxId = FutureUtils.result(getLastLogRecordAsyncInternal(false, true)).getTransactionId();\n+        long lastTxId = Utils.ioResult(getLastLogRecordAsyncInternal(false, true)).getTransactionId();\n         return lastTxId == DistributedLogConstants.MAX_TXID;\n     }\n \n@@ -473,7 +447,7 @@ public boolean isEndOfStreamMarked() throws IOException {\n     public AppendOnlyStreamWriter getAppendOnlyStreamWriter() throws IOException {\n         long position;\n         try {\n-            position = FutureUtils.result(getLastLogRecordAsyncInternal(true, false)).getTransactionId();\n+            position = Utils.ioResult(getLastLogRecordAsyncInternal(true, false)).getTransactionId();\n             if (DistributedLogConstants.INVALID_TXID == position ||\n                 DistributedLogConstants.EMPTY_LOGSEGMENT_TX_ID == position) {\n                 position = 0;\n@@ -508,7 +482,7 @@ public BKSyncLogWriter startLogSegmentNonPartitioned() throws IOException {\n         try {\n             writer.createAndCacheWriteHandler();\n             BKLogWriteHandler writeHandler = writer.getWriteHandler();\n-            FutureUtils.result(writeHandler.lockHandler());\n+            Utils.ioResult(writeHandler.lockHandler());\n             success = true;\n             return writer;\n         } finally {\n@@ -525,75 +499,63 @@ public BKSyncLogWriter startLogSegmentNonPartitioned() throws IOException {\n      */\n     @Override\n     public BKAsyncLogWriter startAsyncLogSegmentNonPartitioned() throws IOException {\n-        return (BKAsyncLogWriter) FutureUtils.result(openAsyncLogWriter());\n+        return (BKAsyncLogWriter) Utils.ioResult(openAsyncLogWriter());\n     }\n \n     @Override\n-    public Future<AsyncLogWriter> openAsyncLogWriter() {\n+    public CompletableFuture<AsyncLogWriter> openAsyncLogWriter() {\n         try {\n             checkClosedOrInError(\"startLogSegmentNonPartitioned\");\n         } catch (AlreadyClosedException e) {\n-            return Future.exception(e);\n+            return FutureUtils.exception(e);\n         }\n \n-        Future<BKLogWriteHandler> createWriteHandleFuture;\n+        CompletableFuture<BKLogWriteHandler> createWriteHandleFuture;\n         synchronized (this) {\n             // 1. create the locked write handler\n             createWriteHandleFuture = asyncCreateWriteHandler(true);\n         }\n-        return createWriteHandleFuture.flatMap(new AbstractFunction1<BKLogWriteHandler, Future<AsyncLogWriter>>() {\n-            @Override\n-            public Future<AsyncLogWriter> apply(final BKLogWriteHandler writeHandler) {\n-                final BKAsyncLogWriter writer;\n-                synchronized (BKDistributedLogManager.this) {\n-                    // 2. create the writer with the handler\n-                    writer = new BKAsyncLogWriter(\n-                            conf,\n-                            dynConf,\n-                            BKDistributedLogManager.this,\n-                            writeHandler,\n-                            featureProvider,\n-                            statsLogger);\n-                }\n-                // 3. recover the incomplete log segments\n-                return writeHandler.recoverIncompleteLogSegments()\n-                        .map(new AbstractFunction1<Long, AsyncLogWriter>() {\n-                            @Override\n-                            public AsyncLogWriter apply(Long lastTxId) {\n-                                // 4. update last tx id if successfully recovered\n-                                writer.setLastTxId(lastTxId);\n-                                return writer;\n-                            }\n-                        }).onFailure(new AbstractFunction1<Throwable, BoxedUnit>() {\n-                            @Override\n-                            public BoxedUnit apply(Throwable cause) {\n-                                // 5. close the writer if recovery failed\n-                                writer.asyncAbort();\n-                                return BoxedUnit.UNIT;\n-                            }\n-                        });\n+        return createWriteHandleFuture.thenCompose(writeHandler -> {\n+            final BKAsyncLogWriter writer;\n+            synchronized (BKDistributedLogManager.this) {\n+                // 2. create the writer with the handler\n+                writer = new BKAsyncLogWriter(\n+                        conf,\n+                        dynConf,\n+                        BKDistributedLogManager.this,\n+                        writeHandler,\n+                        featureProvider,\n+                        statsLogger);\n             }\n+            // 3. recover the incomplete log segments\n+            return writeHandler.recoverIncompleteLogSegments()\n+                .thenApply(lastTxId -> {\n+                    // 4. update last tx id if successfully recovered\n+                    writer.setLastTxId(lastTxId);\n+                    return (AsyncLogWriter) writer;\n+                })\n+                .whenComplete((lastTxId, cause) -> {\n+                    if (null != cause) {\n+                        // 5. close the writer if recovery failed\n+                        writer.asyncAbort();\n+                    }\n+                });\n         });\n     }\n \n     @Override\n-    public Future<DLSN> getDLSNNotLessThanTxId(final long fromTxnId) {\n-        return getLogSegmentsAsync().flatMap(new AbstractFunction1<List<LogSegmentMetadata>, Future<DLSN>>() {\n-            @Override\n-            public Future<DLSN> apply(List<LogSegmentMetadata> segments) {\n-                return getDLSNNotLessThanTxId(fromTxnId, segments);\n-            }\n-        });\n+    public CompletableFuture<DLSN> getDLSNNotLessThanTxId(final long fromTxnId) {\n+        return getLogSegmentsAsync().thenCompose(segments -> getDLSNNotLessThanTxId(fromTxnId, segments));\n     }\n \n-    private Future<DLSN> getDLSNNotLessThanTxId(long fromTxnId,\n+    private CompletableFuture<DLSN> getDLSNNotLessThanTxId(long fromTxnId,\n                                                 final List<LogSegmentMetadata> segments) {\n         if (segments.isEmpty()) {\n             return getLastDLSNAsync();\n         }\n         final int segmentIdx = DLUtils.findLogSegmentNotLessThanTxnId(segments, fromTxnId);\n         if (segmentIdx < 0) {\n-            return Future.value(new DLSN(segments.get(0).getLogSegmentSequenceNumber(), 0L, 0L));\n+            return FutureUtils.value(new DLSN(segments.get(0).getLogSegmentSequenceNumber(), 0L, 0L));\n         }\n         return getDLSNNotLessThanTxIdInSegment(\n                 fromTxnId,\n@@ -603,7 +565,7 @@ private Future<DLSN> getDLSNNotLessThanTxId(long fromTxnId,\n         );\n     }\n \n-    private Future<DLSN> getDLSNNotLessThanTxIdInSegment(final long fromTxnId,\n+    private CompletableFuture<DLSN> getDLSNNotLessThanTxIdInSegment(final long fromTxnId,\n                                                          final int segmentIdx,\n                                                          final List<LogSegmentMetadata> segments,\n                                                          final LogSegmentEntryStore entryStore) {\n@@ -615,29 +577,23 @@ private Future<DLSN> getDLSNNotLessThanTxIdInSegment(final long fromTxnId,\n                 scheduler,\n                 entryStore,\n                 Math.max(2, dynConf.getReadAheadBatchSize())\n-        ).flatMap(new AbstractFunction1<Optional<LogRecordWithDLSN>, Future<DLSN>>() {\n-            @Override\n-            public Future<DLSN> apply(Optional<LogRecordWithDLSN> foundRecord) {\n-                if (foundRecord.isPresent()) {\n-                    return Future.value(foundRecord.get().getDlsn());\n-                }\n-                if ((segments.size() - 1) == segmentIdx) {\n-                    return getLastLogRecordAsync().map(new AbstractFunction1<LogRecordWithDLSN, DLSN>() {\n-                        @Override\n-                        public DLSN apply(LogRecordWithDLSN record) {\n-                            if (record.getTransactionId() >= fromTxnId) {\n-                                return record.getDlsn();\n-                            }\n-                            return record.getDlsn().getNextDLSN();\n-                        }\n-                    });\n-                } else {\n-                    return getDLSNNotLessThanTxIdInSegment(\n-                            fromTxnId,\n-                            segmentIdx + 1,\n-                            segments,\n-                            entryStore);\n-                }\n+        ).thenCompose(foundRecord -> {\n+            if (foundRecord.isPresent()) {\n+                return FutureUtils.value(foundRecord.get().getDlsn());\n+            }\n+            if ((segments.size() - 1) == segmentIdx) {\n+                return getLastLogRecordAsync().thenApply(record -> {\n+                    if (record.getTransactionId() >= fromTxnId) {\n+                        return record.getDlsn();\n+                    }\n+                    return record.getDlsn().getNextDLSN();\n+                });\n+            } else {\n+                return getDLSNNotLessThanTxIdInSegment(\n+                        fromTxnId,\n+                        segmentIdx + 1,\n+                        segments,\n+                        entryStore);\n             }\n         });\n     }\n@@ -662,7 +618,7 @@ public LogReader getInputStream(DLSN fromDLSN) throws IOException {\n \n     @Override\n     public AsyncLogReader getAsyncLogReader(long fromTxnId) throws IOException {\n-        return FutureUtils.result(openAsyncLogReader(fromTxnId));\n+        return Utils.ioResult(openAsyncLogReader(fromTxnId));\n     }\n \n     /**\n@@ -687,39 +643,34 @@ public AsyncLogReader getAsyncLogReader(long fromTxnId) throws IOException {\n      * @return future representing the open result.\n      */\n     @Override\n-    public Future<AsyncLogReader> openAsyncLogReader(long fromTxnId) {\n-        final Promise<DLSN> dlsnPromise = new Promise<DLSN>();\n-        getDLSNNotLessThanTxId(fromTxnId).addEventListener(new FutureEventListener<DLSN>() {\n+    public CompletableFuture<AsyncLogReader> openAsyncLogReader(long fromTxnId) {\n+        final CompletableFuture<DLSN> dlsnPromise = new CompletableFuture<DLSN>();\n+        getDLSNNotLessThanTxId(fromTxnId).whenComplete(new FutureEventListener<DLSN>() {\n \n             @Override\n             public void onSuccess(DLSN dlsn) {\n-                dlsnPromise.setValue(dlsn);\n+                dlsnPromise.complete(dlsn);\n             }\n \n             @Override\n             public void onFailure(Throwable cause) {\n                 if (cause instanceof LogEmptyException) {\n-                    dlsnPromise.setValue(DLSN.InitialDLSN);\n+                    dlsnPromise.complete(DLSN.InitialDLSN);\n                 } else {\n-                    dlsnPromise.setException(cause);\n+                    dlsnPromise.completeExceptionally(cause);\n                 }\n             }\n         });\n-        return dlsnPromise.flatMap(new AbstractFunction1<DLSN, Future<AsyncLogReader>>() {\n-            @Override\n-            public Future<AsyncLogReader> apply(DLSN dlsn) {\n-                return openAsyncLogReader(dlsn);\n-            }\n-        });\n+        return dlsnPromise.thenCompose(dlsn -> openAsyncLogReader(dlsn));\n     }\n \n     @Override\n     public AsyncLogReader getAsyncLogReader(DLSN fromDLSN) throws IOException {\n-        return FutureUtils.result(openAsyncLogReader(fromDLSN));\n+        return Utils.ioResult(openAsyncLogReader(fromDLSN));\n     }\n \n     @Override\n-    public Future<AsyncLogReader> openAsyncLogReader(DLSN fromDLSN) {\n+    public CompletableFuture<AsyncLogReader> openAsyncLogReader(DLSN fromDLSN) {\n         Optional<String> subscriberId = Optional.absent();\n         AsyncLogReader reader = new BKAsyncLogReader(\n                 this,\n@@ -729,7 +680,7 @@ public Future<AsyncLogReader> openAsyncLogReader(DLSN fromDLSN) {\n                 false,\n                 statsLogger);\n         pendingReaders.add(reader);\n-        return Future.value(reader);\n+        return FutureUtils.value(reader);\n     }\n \n     /**\n@@ -738,26 +689,26 @@ public Future<AsyncLogReader> openAsyncLogReader(DLSN fromDLSN) {\n      * blocked.\n      */\n     @Override\n-    public Future<AsyncLogReader> getAsyncLogReaderWithLock(final DLSN fromDLSN) {\n+    public CompletableFuture<AsyncLogReader> getAsyncLogReaderWithLock(final DLSN fromDLSN) {\n         Optional<String> subscriberId = Optional.absent();\n         return getAsyncLogReaderWithLock(Optional.of(fromDLSN), subscriberId);\n     }\n \n     @Override\n-    public Future<AsyncLogReader> getAsyncLogReaderWithLock(final DLSN fromDLSN, final String subscriberId) {\n+    public CompletableFuture<AsyncLogReader> getAsyncLogReaderWithLock(final DLSN fromDLSN, final String subscriberId) {\n         return getAsyncLogReaderWithLock(Optional.of(fromDLSN), Optional.of(subscriberId));\n     }\n \n     @Override\n-    public Future<AsyncLogReader> getAsyncLogReaderWithLock(String subscriberId) {\n+    public CompletableFuture<AsyncLogReader> getAsyncLogReaderWithLock(String subscriberId) {\n         Optional<DLSN> fromDLSN = Optional.absent();\n         return getAsyncLogReaderWithLock(fromDLSN, Optional.of(subscriberId));\n     }\n \n-    protected Future<AsyncLogReader> getAsyncLogReaderWithLock(final Optional<DLSN> fromDLSN,\n+    protected CompletableFuture<AsyncLogReader> getAsyncLogReaderWithLock(final Optional<DLSN> fromDLSN,\n                                                                final Optional<String> subscriberId) {\n         if (!fromDLSN.isPresent() && !subscriberId.isPresent()) {\n-            return Future.exception(new UnexpectedException(\"Neither from dlsn nor subscriber id is provided.\"));\n+            return FutureUtils.exception(new UnexpectedException(\"Neither from dlsn nor subscriber id is provided.\"));\n         }\n         final BKAsyncLogReader reader = new BKAsyncLogReader(\n                 BKDistributedLogManager.this,\n@@ -767,55 +718,50 @@ protected Future<AsyncLogReader> getAsyncLogReaderWithLock(final Optional<DLSN>\n                 false,\n                 statsLogger);\n         pendingReaders.add(reader);\n-        final Future<Void> lockFuture = reader.lockStream();\n-        final Promise<AsyncLogReader> createPromise = new Promise<AsyncLogReader>(\n-                new Function<Throwable, BoxedUnit>() {\n-            @Override\n-            public BoxedUnit apply(Throwable cause) {\n+        final CompletableFuture<Void> lockFuture = reader.lockStream();\n+        final CompletableFuture<AsyncLogReader> createPromise = FutureUtils.createFuture();\n+        createPromise.whenComplete((value, cause) -> {\n+            if (cause instanceof CancellationException) {\n                 // cancel the lock when the creation future is cancelled\n-                lockFuture.cancel();\n-                return BoxedUnit.UNIT;\n+                lockFuture.cancel(true);\n             }\n         });\n         // lock the stream - fetch the last commit position on success\n-        lockFuture.flatMap(new Function<Void, Future<AsyncLogReader>>() {\n+        lockFuture.thenCompose(new Function<Void, CompletableFuture<AsyncLogReader>>() {\n             @Override\n-            public Future<AsyncLogReader> apply(Void complete) {\n+            public CompletableFuture<AsyncLogReader> apply(Void complete) {\n                 if (fromDLSN.isPresent()) {\n-                    return Future.value((AsyncLogReader) reader);\n+                    return FutureUtils.value(reader);\n                 }\n                 LOG.info(\"Reader {} @ {} reading last commit position from subscription store after acquired lock.\",\n                         subscriberId.get(), name);\n                 // we acquired lock\n                 final SubscriptionsStore subscriptionsStore = driver.getSubscriptionsStore(getStreamName());\n                 return subscriptionsStore.getLastCommitPosition(subscriberId.get())\n-                        .map(new ExceptionalFunction<DLSN, AsyncLogReader>() {\n-                    @Override\n-                    public AsyncLogReader applyE(DLSN lastCommitPosition) throws UnexpectedException {\n-                        LOG.info(\"Reader {} @ {} positioned to last commit position {}.\",\n-                                new Object[] { subscriberId.get(), name, lastCommitPosition });\n-                        reader.setStartDLSN(lastCommitPosition);\n-                        return reader;\n-                    }\n-                });\n+                        .thenCompose(lastCommitPosition -> {\n+                            LOG.info(\"Reader {} @ {} positioned to last commit position {}.\",\n+                                    new Object[] { subscriberId.get(), name, lastCommitPosition });\n+                            try {\n+                                reader.setStartDLSN(lastCommitPosition);\n+                            } catch (UnexpectedException e) {\n+                                return FutureUtils.exception(e);\n+                            }\n+                            return FutureUtils.value(reader);\n+                        });\n             }\n-        }).addEventListener(new FutureEventListener<AsyncLogReader>() {\n+        }).whenComplete(new FutureEventListener<AsyncLogReader>() {\n             @Override\n             public void onSuccess(AsyncLogReader r) {\n                 pendingReaders.remove(reader);\n-                FutureUtils.setValue(createPromise, r);\n+                FutureUtils.complete(createPromise, r);\n             }\n \n             @Override\n             public void onFailure(final Throwable cause) {\n                 pendingReaders.remove(reader);\n-                reader.asyncClose().ensure(new AbstractFunction0<BoxedUnit>() {\n-                    @Override\n-                    public BoxedUnit apply() {\n-                        FutureUtils.setException(createPromise, cause);\n-                        return BoxedUnit.UNIT;\n-                    }\n-                });\n+                FutureUtils.ensure(\n+                    reader.asyncClose(),\n+                    () -> FutureUtils.completeExceptionally(createPromise, cause));\n             }\n         });\n         return createPromise;\n@@ -833,7 +779,7 @@ LogReader getInputStreamInternal(long fromTxnId)\n         throws IOException {\n         DLSN fromDLSN;\n         try {\n-            fromDLSN = FutureUtils.result(getDLSNNotLessThanTxId(fromTxnId));\n+            fromDLSN = Utils.ioResult(getDLSNNotLessThanTxId(fromTxnId));\n         } catch (LogEmptyException lee) {\n             fromDLSN = DLSN.InitialDLSN;\n         }\n@@ -861,25 +807,25 @@ LogReader getInputStreamInternal(DLSN fromDLSN, Optional<Long> fromTxnId)\n     @Override\n     public LogRecordWithDLSN getLastLogRecord() throws IOException {\n         checkClosedOrInError(\"getLastLogRecord\");\n-        return FutureUtils.result(getLastLogRecordAsync());\n+        return Utils.ioResult(getLastLogRecordAsync());\n     }\n \n     @Override\n     public long getFirstTxId() throws IOException {\n         checkClosedOrInError(\"getFirstTxId\");\n-        return FutureUtils.result(getFirstRecordAsyncInternal()).getTransactionId();\n+        return Utils.ioResult(getFirstRecordAsyncInternal()).getTransactionId();\n     }\n \n     @Override\n     public long getLastTxId() throws IOException {\n         checkClosedOrInError(\"getLastTxId\");\n-        return FutureUtils.result(getLastTxIdAsync());\n+        return Utils.ioResult(getLastTxIdAsync());\n     }\n \n     @Override\n     public DLSN getLastDLSN() throws IOException {\n         checkClosedOrInError(\"getLastDLSN\");\n-        return FutureUtils.result(getLastLogRecordAsyncInternal(false, false)).getDlsn();\n+        return Utils.ioResult(getLastLogRecordAsyncInternal(false, false)).getDlsn();\n     }\n \n     /**\n@@ -888,15 +834,15 @@ public DLSN getLastDLSN() throws IOException {\n      * @return latest log record\n      */\n     @Override\n-    public Future<LogRecordWithDLSN> getLastLogRecordAsync() {\n+    public CompletableFuture<LogRecordWithDLSN> getLastLogRecordAsync() {\n         return getLastLogRecordAsyncInternal(false, false);\n     }\n \n-    private Future<LogRecordWithDLSN> getLastLogRecordAsyncInternal(final boolean recover,\n+    private CompletableFuture<LogRecordWithDLSN> getLastLogRecordAsyncInternal(final boolean recover,\n                                                                     final boolean includeEndOfStream) {\n-        return processReaderOperation(new Function<BKLogReadHandler, Future<LogRecordWithDLSN>>() {\n+        return processReaderOperation(new Function<BKLogReadHandler, CompletableFuture<LogRecordWithDLSN>>() {\n             @Override\n-            public Future<LogRecordWithDLSN> apply(final BKLogReadHandler ledgerHandler) {\n+            public CompletableFuture<LogRecordWithDLSN> apply(final BKLogReadHandler ledgerHandler) {\n                 return ledgerHandler.getLastLogRecordAsync(recover, includeEndOfStream);\n             }\n         });\n@@ -908,9 +854,9 @@ public Future<LogRecordWithDLSN> apply(final BKLogReadHandler ledgerHandler) {\n      * @return latest transaction id\n      */\n     @Override\n-    public Future<Long> getLastTxIdAsync() {\n+    public CompletableFuture<Long> getLastTxIdAsync() {\n         return getLastLogRecordAsyncInternal(false, false)\n-                .map(RECORD_2_TXID_FUNCTION);\n+                .thenApply(RECORD_2_TXID_FUNCTION);\n     }\n \n     /**\n@@ -919,14 +865,14 @@ public Future<Long> getLastTxIdAsync() {\n      * @return first dlsn in the stream\n      */\n     @Override\n-    public Future<DLSN> getFirstDLSNAsync() {\n-        return getFirstRecordAsyncInternal().map(RECORD_2_DLSN_FUNCTION);\n+    public CompletableFuture<DLSN> getFirstDLSNAsync() {\n+        return getFirstRecordAsyncInternal().thenApply(RECORD_2_DLSN_FUNCTION);\n     }\n \n-    private Future<LogRecordWithDLSN> getFirstRecordAsyncInternal() {\n-        return processReaderOperation(new Function<BKLogReadHandler, Future<LogRecordWithDLSN>>() {\n+    private CompletableFuture<LogRecordWithDLSN> getFirstRecordAsyncInternal() {\n+        return processReaderOperation(new Function<BKLogReadHandler, CompletableFuture<LogRecordWithDLSN>>() {\n             @Override\n-            public Future<LogRecordWithDLSN> apply(final BKLogReadHandler ledgerHandler) {\n+            public CompletableFuture<LogRecordWithDLSN> apply(final BKLogReadHandler ledgerHandler) {\n                 return ledgerHandler.asyncGetFirstLogRecord();\n             }\n         });\n@@ -938,9 +884,9 @@ public Future<LogRecordWithDLSN> apply(final BKLogReadHandler ledgerHandler) {\n      * @return latest transaction id\n      */\n     @Override\n-    public Future<DLSN> getLastDLSNAsync() {\n+    public CompletableFuture<DLSN> getLastDLSNAsync() {\n         return getLastLogRecordAsyncInternal(false, false)\n-                .map(RECORD_2_DLSN_FUNCTION);\n+                .thenApply(RECORD_2_DLSN_FUNCTION);\n     }\n \n     /**\n@@ -953,7 +899,7 @@ public Future<DLSN> getLastDLSNAsync() {\n     @Override\n     public long getLogRecordCount() throws IOException {\n         checkClosedOrInError(\"getLogRecordCount\");\n-        return FutureUtils.result(getLogRecordCountAsync(DLSN.InitialDLSN));\n+        return Utils.ioResult(getLogRecordCountAsync(DLSN.InitialDLSN));\n     }\n \n     /**\n@@ -964,10 +910,10 @@ public long getLogRecordCount() throws IOException {\n      * @throws IOException\n      */\n     @Override\n-    public Future<Long> getLogRecordCountAsync(final DLSN beginDLSN) {\n-        return processReaderOperation(new Function<BKLogReadHandler, Future<Long>>() {\n+    public CompletableFuture<Long> getLogRecordCountAsync(final DLSN beginDLSN) {\n+        return processReaderOperation(new Function<BKLogReadHandler, CompletableFuture<Long>>() {\n                     @Override\n-                    public Future<Long> apply(BKLogReadHandler ledgerHandler) {\n+                    public CompletableFuture<Long> apply(BKLogReadHandler ledgerHandler) {\n                         return ledgerHandler.asyncGetLogRecordCount(beginDLSN);\n                     }\n                 });\n@@ -991,7 +937,7 @@ private void recoverInternal(String streamIdentifier) throws IOException {\n         checkClosedOrInError(\"recoverInternal\");\n         BKLogWriteHandler ledgerHandler = createWriteHandler(true);\n         try {\n-            FutureUtils.result(ledgerHandler.recoverIncompleteLogSegments());\n+            Utils.ioResult(ledgerHandler.recoverIncompleteLogSegments());\n         } finally {\n             Utils.closeQuietly(ledgerHandler);\n         }\n@@ -1004,7 +950,7 @@ private void recoverInternal(String streamIdentifier) throws IOException {\n      */\n     @Override\n     public void delete() throws IOException {\n-        FutureUtils.result(driver.getLogStreamMetadataStore(WRITER)\n+        Utils.ioResult(driver.getLogStreamMetadataStore(WRITER)\n                 .deleteLog(uri, getStreamName()));\n     }\n \n@@ -1025,7 +971,7 @@ public void purgeLogsOlderThan(long minTxIdToKeep) throws IOException {\n         BKLogWriteHandler ledgerHandler = createWriteHandler(true);\n         try {\n             LOG.info(\"Purging logs for {} older than {}\", ledgerHandler.getFullyQualifiedName(), minTxIdToKeep);\n-            FutureUtils.result(ledgerHandler.purgeLogSegmentsOlderThanTxnId(minTxIdToKeep));\n+            Utils.ioResult(ledgerHandler.purgeLogSegmentsOlderThanTxnId(minTxIdToKeep));\n         } finally {\n             Utils.closeQuietly(ledgerHandler);\n         }\n@@ -1049,14 +995,11 @@ public synchronized void add(AsyncCloseable reader) {\n         }\n \n         @Override\n-        public Future<Void> asyncClose() {\n+        public CompletableFuture<Void> asyncClose() {\n             return Utils.closeSequence(executorService, true, readers.toArray(new AsyncLogReader[readers.size()]))\n-                    .onSuccess(new AbstractFunction1<Void, BoxedUnit>() {\n-                        @Override\n-                        public BoxedUnit apply(Void value) {\n-                            readers.clear();\n-                            return BoxedUnit.UNIT;\n-                        }\n+                    .thenApply(value -> {\n+                        readers.clear();\n+                        return null;\n                     });\n         }\n     };\n@@ -1065,28 +1008,28 @@ public BoxedUnit apply(Void value) {\n      * Close the distributed log manager, freeing any resources it may hold.\n      */\n     @Override\n-    public Future<Void> asyncClose() {\n-        Promise<Void> closeFuture;\n+    public CompletableFuture<Void> asyncClose() {\n+        CompletableFuture<Void> closeFuture;\n         BKLogReadHandler readHandlerToClose;\n         synchronized (this) {\n             if (null != closePromise) {\n                 return closePromise;\n             }\n-            closeFuture = closePromise = new Promise<Void>();\n+            closeFuture = closePromise = new CompletableFuture<Void>();\n             readHandlerToClose = readHandlerForListener;\n         }\n \n-        Future<Void> closeResult = Utils.closeSequence(null, true,\n+        CompletableFuture<Void> closeResult = Utils.closeSequence(null, true,\n                 readHandlerToClose,\n                 pendingReaders,\n                 resourcesCloseable.or(AsyncCloseable.NULL));\n-        closeResult.proxyTo(closeFuture);\n+        FutureUtils.proxyTo(closeResult, closeFuture);\n         return closeFuture;\n     }\n \n     @Override\n     public void close() throws IOException {\n-        FutureUtils.result(asyncClose());\n+        Utils.ioResult(asyncClose());\n     }\n \n     @Override"},{"sha":"60ad91668d5a36239272d84c1f7af882dafc653a","filename":"src/main/java/org/apache/distributedlog/BKDistributedLogNamespace.java","status":"modified","additions":13,"deletions":16,"changes":29,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FBKDistributedLogNamespace.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FBKDistributedLogNamespace.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FBKDistributedLogNamespace.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -20,6 +20,8 @@\n import com.google.common.base.Optional;\n import com.google.common.base.Ticker;\n import org.apache.distributedlog.acl.AccessControlManager;\n+import org.apache.distributedlog.api.DistributedLogManager;\n+import org.apache.distributedlog.api.namespace.Namespace;\n import org.apache.distributedlog.callback.NamespaceListener;\n import org.apache.distributedlog.config.DynamicDistributedLogConfiguration;\n import org.apache.distributedlog.exceptions.AlreadyClosedException;\n@@ -28,14 +30,11 @@\n import org.apache.distributedlog.injector.AsyncFailureInjector;\n import org.apache.distributedlog.io.AsyncCloseable;\n import org.apache.distributedlog.logsegment.LogSegmentMetadataCache;\n-import org.apache.distributedlog.namespace.DistributedLogNamespace;\n import org.apache.distributedlog.namespace.NamespaceDriver;\n import org.apache.distributedlog.util.ConfUtils;\n-import org.apache.distributedlog.util.FutureUtils;\n-import org.apache.distributedlog.util.MonitoredScheduledThreadPoolExecutor;\n import org.apache.distributedlog.util.OrderedScheduler;\n-import org.apache.distributedlog.util.PermitLimiter;\n-import org.apache.distributedlog.util.SchedulerUtils;\n+import org.apache.distributedlog.common.util.PermitLimiter;\n+import org.apache.distributedlog.common.util.SchedulerUtils;\n import org.apache.distributedlog.util.Utils;\n import org.apache.bookkeeper.feature.FeatureProvider;\n import org.apache.bookkeeper.stats.StatsLogger;\n@@ -52,7 +51,7 @@\n import static org.apache.distributedlog.util.DLUtils.validateAndNormalizeName;\n \n /**\n- * BKDistributedLogNamespace is the default implementation of {@link DistributedLogNamespace}. It uses\n+ * BKDistributedLogNamespace is the default implementation of {@link Namespace}. It uses\n  * zookeeper for metadata storage and bookkeeper for data storage.\n  * <h3>Metrics</h3>\n  *\n@@ -74,8 +73,6 @@\n  * <ul>\n  * <li> `scope`/factory/thread_pool/* : stats about the ordered scheduler used by this namespace.\n  * See {@link OrderedScheduler}.\n- * <li> `scope`/factory/readahead_thread_pool/* : stats about the readahead thread pool executor\n- * used by this namespace. See {@link MonitoredScheduledThreadPoolExecutor}.\n  * <li> `scope`/writeLimiter/* : stats about the global write limiter used by this namespace.\n  * See {@link PermitLimiter}.\n  * </ul>\n@@ -84,7 +81,7 @@\n  *\n  * All the core stats about reader and writer are exposed under current scope via {@link BKDistributedLogManager}.\n  */\n-public class BKDistributedLogNamespace implements DistributedLogNamespace {\n+public class BKDistributedLogNamespace implements Namespace {\n     static final Logger LOG = LoggerFactory.getLogger(BKDistributedLogNamespace.class);\n \n     private final String clientId;\n@@ -149,16 +146,16 @@ public void createLog(String logName)\n             throws InvalidStreamNameException, IOException {\n         checkState();\n         logName = validateAndNormalizeName(logName);\n-        URI uri = FutureUtils.result(driver.getLogMetadataStore().createLog(logName));\n-        FutureUtils.result(driver.getLogStreamMetadataStore(WRITER).getLog(uri, logName, true, true));\n+        URI uri = Utils.ioResult(driver.getLogMetadataStore().createLog(logName));\n+        Utils.ioResult(driver.getLogStreamMetadataStore(WRITER).getLog(uri, logName, true, true));\n     }\n \n     @Override\n     public void deleteLog(String logName)\n             throws InvalidStreamNameException, LogNotFoundException, IOException {\n         checkState();\n         logName = validateAndNormalizeName(logName);\n-        Optional<URI> uri = FutureUtils.result(driver.getLogMetadataStore().getLogLocation(logName));\n+        Optional<URI> uri = Utils.ioResult(driver.getLogMetadataStore().getLogLocation(logName));\n         if (!uri.isPresent()) {\n             throw new LogNotFoundException(\"Log \" + logName + \" isn't found.\");\n         }\n@@ -187,7 +184,7 @@ public DistributedLogManager openLog(String logName,\n             throws InvalidStreamNameException, IOException {\n         checkState();\n         logName = validateAndNormalizeName(logName);\n-        Optional<URI> uri = FutureUtils.result(driver.getLogMetadataStore().getLogLocation(logName));\n+        Optional<URI> uri = Utils.ioResult(driver.getLogMetadataStore().getLogLocation(logName));\n         if (!uri.isPresent()) {\n             throw new LogNotFoundException(\"Log \" + logName + \" isn't found.\");\n         }\n@@ -202,10 +199,10 @@ public DistributedLogManager openLog(String logName,\n     public boolean logExists(String logName)\n         throws IOException, IllegalArgumentException {\n         checkState();\n-        Optional<URI> uri = FutureUtils.result(driver.getLogMetadataStore().getLogLocation(logName));\n+        Optional<URI> uri = Utils.ioResult(driver.getLogMetadataStore().getLogLocation(logName));\n         if (uri.isPresent()) {\n             try {\n-                FutureUtils.result(driver.getLogStreamMetadataStore(WRITER)\n+                Utils.ioResult(driver.getLogStreamMetadataStore(WRITER)\n                         .logExists(uri.get(), logName));\n                 return true;\n             } catch (LogNotFoundException lnfe) {\n@@ -219,7 +216,7 @@ public boolean logExists(String logName)\n     @Override\n     public Iterator<String> getLogs() throws IOException {\n         checkState();\n-        return FutureUtils.result(driver.getLogMetadataStore().getLogs());\n+        return Utils.ioResult(driver.getLogMetadataStore().getLogs());\n     }\n \n     @Override"},{"sha":"a7d0d25f7054489269b3eee8c4c490e52e5b9ffe","filename":"src/main/java/org/apache/distributedlog/BKLogHandler.java","status":"modified","additions":113,"deletions":114,"changes":227,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FBKLogHandler.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FBKLogHandler.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FBKLogHandler.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -18,6 +18,27 @@\n package org.apache.distributedlog;\n \n import com.google.common.base.Stopwatch;\n+import com.google.common.collect.Lists;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+import org.apache.bookkeeper.stats.AlertStatsLogger;\n+import org.apache.bookkeeper.stats.OpStatsLogger;\n+import org.apache.bookkeeper.stats.StatsLogger;\n+import org.apache.bookkeeper.versioning.Version;\n+import org.apache.bookkeeper.versioning.Versioned;\n+import org.apache.commons.lang3.tuple.Pair;\n import org.apache.distributedlog.callback.LogSegmentNamesListener;\n import org.apache.distributedlog.exceptions.LogEmptyException;\n import org.apache.distributedlog.exceptions.LogSegmentNotFoundException;\n@@ -31,35 +52,12 @@\n import org.apache.distributedlog.logsegment.LogSegmentFilter;\n import org.apache.distributedlog.logsegment.LogSegmentMetadataStore;\n import org.apache.distributedlog.metadata.LogStreamMetadataStore;\n-import org.apache.distributedlog.util.FutureUtils;\n+import org.apache.distributedlog.common.concurrent.FutureEventListener;\n+import org.apache.distributedlog.common.concurrent.FutureUtils;\n import org.apache.distributedlog.util.OrderedScheduler;\n-import com.twitter.util.Function;\n-import com.twitter.util.Future;\n-import com.twitter.util.FutureEventListener;\n-import com.twitter.util.Promise;\n-import org.apache.bookkeeper.stats.AlertStatsLogger;\n-import org.apache.bookkeeper.stats.OpStatsLogger;\n-import org.apache.bookkeeper.stats.StatsLogger;\n-import org.apache.bookkeeper.versioning.Version;\n-import org.apache.bookkeeper.versioning.Versioned;\n-import org.apache.commons.lang3.tuple.Pair;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import java.io.IOException;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.Comparator;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.concurrent.atomic.AtomicReference;\n-\n /**\n  * The base class about log handler on managing log segments.\n  *\n@@ -171,69 +169,73 @@ public String getLockClientId() {\n         return lockClientId;\n     }\n \n-    public Future<LogRecordWithDLSN> asyncGetFirstLogRecord() {\n-        final Promise<LogRecordWithDLSN> promise = new Promise<LogRecordWithDLSN>();\n-        streamMetadataStore.logExists(logMetadata.getUri(), logMetadata.getLogName())\n-                .addEventListener(new FutureEventListener<Void>() {\n+    public CompletableFuture<LogRecordWithDLSN> asyncGetFirstLogRecord() {\n+        final CompletableFuture<LogRecordWithDLSN> promise = new CompletableFuture<LogRecordWithDLSN>();\n+        streamMetadataStore.logExists(\n+            logMetadata.getUri(),\n+            logMetadata.getLogName()\n+        ).whenComplete(new FutureEventListener<Void>() {\n             @Override\n             public void onSuccess(Void value) {\n                 readLogSegmentsFromStore(\n                         LogSegmentMetadata.COMPARATOR,\n                         LogSegmentFilter.DEFAULT_FILTER,\n                         null\n-                ).addEventListener(new FutureEventListener<Versioned<List<LogSegmentMetadata>>>() {\n+                ).whenComplete(new FutureEventListener<Versioned<List<LogSegmentMetadata>>>() {\n \n                     @Override\n                     public void onSuccess(Versioned<List<LogSegmentMetadata>> ledgerList) {\n                         if (ledgerList.getValue().isEmpty()) {\n-                            promise.setException(new LogEmptyException(\"Log \" + getFullyQualifiedName() + \" has no records\"));\n+                            promise.completeExceptionally(new LogEmptyException(\"Log \" + getFullyQualifiedName() + \" has no records\"));\n                             return;\n                         }\n-                        Future<LogRecordWithDLSN> firstRecord = null;\n+                        CompletableFuture<LogRecordWithDLSN> firstRecord = null;\n                         for (LogSegmentMetadata ledger : ledgerList.getValue()) {\n                             if (!ledger.isTruncated() && (ledger.getRecordCount() > 0 || ledger.isInProgress())) {\n                                 firstRecord = asyncReadFirstUserRecord(ledger, DLSN.InitialDLSN);\n                                 break;\n                             }\n                         }\n                         if (null != firstRecord) {\n-                            promise.become(firstRecord);\n+                            FutureUtils.proxyTo(firstRecord, promise);\n                         } else {\n-                            promise.setException(new LogEmptyException(\"Log \" + getFullyQualifiedName() + \" has no records\"));\n+                            promise.completeExceptionally(new LogEmptyException(\"Log \" + getFullyQualifiedName() + \" has no records\"));\n                         }\n                     }\n \n                     @Override\n                     public void onFailure(Throwable cause) {\n-                        promise.setException(cause);\n+                        promise.completeExceptionally(cause);\n                     }\n                 });\n             }\n \n             @Override\n             public void onFailure(Throwable cause) {\n-                promise.setException(cause);\n+                promise.completeExceptionally(cause);\n             }\n         });\n         return promise;\n     }\n \n-    public Future<LogRecordWithDLSN> getLastLogRecordAsync(final boolean recover, final boolean includeEndOfStream) {\n-        final Promise<LogRecordWithDLSN> promise = new Promise<LogRecordWithDLSN>();\n-        streamMetadataStore.logExists(logMetadata.getUri(), logMetadata.getLogName())\n-                .addEventListener(new FutureEventListener<Void>() {\n+    public CompletableFuture<LogRecordWithDLSN> getLastLogRecordAsync(final boolean recover, final boolean includeEndOfStream) {\n+        final CompletableFuture<LogRecordWithDLSN> promise = new CompletableFuture<LogRecordWithDLSN>();\n+        streamMetadataStore.logExists(\n+            logMetadata.getUri(),\n+            logMetadata.getLogName()\n+        ).whenComplete(new FutureEventListener<Void>() {\n             @Override\n             public void onSuccess(Void value) {\n                 readLogSegmentsFromStore(\n                         LogSegmentMetadata.DESC_COMPARATOR,\n                         LogSegmentFilter.DEFAULT_FILTER,\n                         null\n-                ).addEventListener(new FutureEventListener<Versioned<List<LogSegmentMetadata>>>() {\n+                ).whenComplete(new FutureEventListener<Versioned<List<LogSegmentMetadata>>>() {\n \n                     @Override\n                     public void onSuccess(Versioned<List<LogSegmentMetadata>> ledgerList) {\n                         if (ledgerList.getValue().isEmpty()) {\n-                            promise.setException(\n+                            promise.completeExceptionally(\n                                     new LogEmptyException(\"Log \" + getFullyQualifiedName() + \" has no records\"));\n                             return;\n                         }\n@@ -247,49 +249,51 @@ public void onSuccess(Versioned<List<LogSegmentMetadata>> ledgerList) {\n \n                     @Override\n                     public void onFailure(Throwable cause) {\n-                        promise.setException(cause);\n+                        promise.completeExceptionally(cause);\n                     }\n                 });\n             }\n \n             @Override\n             public void onFailure(Throwable cause) {\n-                promise.setException(cause);\n+                promise.completeExceptionally(cause);\n             }\n         });\n         return promise;\n     }\n \n     private void asyncGetLastLogRecord(final Iterator<LogSegmentMetadata> ledgerIter,\n-                                       final Promise<LogRecordWithDLSN> promise,\n+                                       final CompletableFuture<LogRecordWithDLSN> promise,\n                                        final boolean fence,\n                                        final boolean includeControlRecord,\n                                        final boolean includeEndOfStream) {\n         if (ledgerIter.hasNext()) {\n             LogSegmentMetadata metadata = ledgerIter.next();\n-            asyncReadLastRecord(metadata, fence, includeControlRecord, includeEndOfStream).addEventListener(\n-                    new FutureEventListener<LogRecordWithDLSN>() {\n-                        @Override\n-                        public void onSuccess(LogRecordWithDLSN record) {\n-                            if (null == record) {\n-                                asyncGetLastLogRecord(ledgerIter, promise, fence, includeControlRecord, includeEndOfStream);\n-                            } else {\n-                                promise.setValue(record);\n-                            }\n-                        }\n-\n-                        @Override\n-                        public void onFailure(Throwable cause) {\n-                            promise.setException(cause);\n+            asyncReadLastRecord(\n+                metadata, fence, includeControlRecord, includeEndOfStream\n+            ).whenComplete(\n+                new FutureEventListener<LogRecordWithDLSN>() {\n+                    @Override\n+                    public void onSuccess(LogRecordWithDLSN record) {\n+                        if (null == record) {\n+                            asyncGetLastLogRecord(ledgerIter, promise, fence, includeControlRecord, includeEndOfStream);\n+                        } else {\n+                            promise.complete(record);\n                         }\n                     }\n+\n+                    @Override\n+                    public void onFailure(Throwable cause) {\n+                                                         promise.completeExceptionally(cause);\n+                                                                                              }\n+                }\n             );\n         } else {\n-            promise.setException(new LogEmptyException(\"Log \" + getFullyQualifiedName() + \" has no records\"));\n+            promise.completeExceptionally(new LogEmptyException(\"Log \" + getFullyQualifiedName() + \" has no records\"));\n         }\n     }\n \n-    private Future<LogRecordWithDLSN> asyncReadFirstUserRecord(LogSegmentMetadata ledger, DLSN beginDLSN) {\n+    private CompletableFuture<LogRecordWithDLSN> asyncReadFirstUserRecord(LogSegmentMetadata ledger, DLSN beginDLSN) {\n         return ReadUtils.asyncReadFirstUserRecord(\n                 getFullyQualifiedName(),\n                 ledger,\n@@ -307,15 +311,17 @@ private Future<LogRecordWithDLSN> asyncReadFirstUserRecord(LogSegmentMetadata le\n      * beginDLSN and the second denoted by endPosition. Its up to the caller to ensure that endPosition refers to\n      * position in the same ledger as beginDLSN.\n      */\n-    private Future<Long> asyncGetLogRecordCount(LogSegmentMetadata ledger, final DLSN beginDLSN, final long endPosition) {\n-        return asyncReadFirstUserRecord(ledger, beginDLSN).map(new Function<LogRecordWithDLSN, Long>() {\n-            public Long apply(final LogRecordWithDLSN beginRecord) {\n-                long recordCount = 0;\n-                if (null != beginRecord) {\n-                    recordCount = endPosition + 1 - beginRecord.getLastPositionWithinLogSegment();\n-                }\n-                return recordCount;\n+    private CompletableFuture<Long> asyncGetLogRecordCount(LogSegmentMetadata ledger,\n+                                                           final DLSN beginDLSN,\n+                                                           final long endPosition) {\n+        return asyncReadFirstUserRecord(\n+            ledger, beginDLSN\n+        ).thenApply(beginRecord -> {\n+            long recordCount = 0;\n+            if (null != beginRecord) {\n+                recordCount = endPosition + 1 - beginRecord.getLastPositionWithinLogSegment();\n             }\n+            return recordCount;\n         });\n     }\n \n@@ -325,31 +331,29 @@ public Long apply(final LogRecordWithDLSN beginRecord) {\n      * an interior entry. For the last entry, if it is inprogress, we need to recover it and find the last user\n      * entry.\n      */\n-    private Future<Long> asyncGetLogRecordCount(final LogSegmentMetadata ledger, final DLSN beginDLSN) {\n+    private CompletableFuture<Long> asyncGetLogRecordCount(final LogSegmentMetadata ledger, final DLSN beginDLSN) {\n         if (ledger.isInProgress() && ledger.isDLSNinThisSegment(beginDLSN)) {\n-            return asyncReadLastUserRecord(ledger).flatMap(new Function<LogRecordWithDLSN, Future<Long>>() {\n-                public Future<Long> apply(final LogRecordWithDLSN endRecord) {\n+            return asyncReadLastUserRecord(ledger).thenCompose(\n+                (Function<LogRecordWithDLSN, CompletableFuture<Long>>) endRecord -> {\n                     if (null != endRecord) {\n-                        return asyncGetLogRecordCount(ledger, beginDLSN, endRecord.getLastPositionWithinLogSegment() /* end position */);\n+                        return asyncGetLogRecordCount(\n+                            ledger, beginDLSN, endRecord.getLastPositionWithinLogSegment() /* end position */);\n                     } else {\n-                        return Future.value((long) 0);\n+                        return FutureUtils.value((long) 0);\n                     }\n-                }\n-            });\n+                });\n         } else if (ledger.isInProgress()) {\n-            return asyncReadLastUserRecord(ledger).map(new Function<LogRecordWithDLSN, Long>() {\n-                public Long apply(final LogRecordWithDLSN endRecord) {\n-                    if (null != endRecord) {\n-                        return (long) endRecord.getLastPositionWithinLogSegment();\n-                    } else {\n-                        return (long) 0;\n-                    }\n+            return asyncReadLastUserRecord(ledger).thenApply(endRecord -> {\n+                if (null != endRecord) {\n+                    return (long) endRecord.getLastPositionWithinLogSegment();\n+                } else {\n+                    return (long) 0;\n                 }\n             });\n         } else if (ledger.isDLSNinThisSegment(beginDLSN)) {\n             return asyncGetLogRecordCount(ledger, beginDLSN, ledger.getRecordCount() /* end position */);\n         } else {\n-            return Future.value((long) ledger.getRecordCount());\n+            return FutureUtils.value((long) ledger.getRecordCount());\n         }\n     }\n \n@@ -359,29 +363,26 @@ public Long apply(final LogRecordWithDLSN endRecord) {\n      * @param beginDLSN dlsn marking the start of the range\n      * @return the count of records present in the range\n      */\n-    public Future<Long> asyncGetLogRecordCount(final DLSN beginDLSN) {\n+    public CompletableFuture<Long> asyncGetLogRecordCount(final DLSN beginDLSN) {\n         return streamMetadataStore.logExists(logMetadata.getUri(), logMetadata.getLogName())\n-                .flatMap(new Function<Void, Future<Long>>() {\n-            public Future<Long> apply(Void done) {\n+                .thenCompose(new Function<Void, CompletableFuture<Long>>() {\n+            public CompletableFuture<Long> apply(Void done) {\n \n                 return readLogSegmentsFromStore(\n                         LogSegmentMetadata.COMPARATOR,\n                         LogSegmentFilter.DEFAULT_FILTER,\n                         null\n-                ).flatMap(new Function<Versioned<List<LogSegmentMetadata>>, Future<Long>>() {\n-                    public Future<Long> apply(Versioned<List<LogSegmentMetadata>> ledgerList) {\n+                ).thenCompose(new Function<Versioned<List<LogSegmentMetadata>>, CompletableFuture<Long>>() {\n+                    public CompletableFuture<Long> apply(Versioned<List<LogSegmentMetadata>> ledgerList) {\n \n-                        List<Future<Long>> futureCounts = new ArrayList<Future<Long>>(ledgerList.getValue().size());\n+                        List<CompletableFuture<Long>> futureCounts =\n+                          Lists.newArrayListWithExpectedSize(ledgerList.getValue().size());\n                         for (LogSegmentMetadata ledger : ledgerList.getValue()) {\n                             if (ledger.getLogSegmentSequenceNumber() >= beginDLSN.getLogSegmentSequenceNo()) {\n                                 futureCounts.add(asyncGetLogRecordCount(ledger, beginDLSN));\n                             }\n                         }\n-                        return Future.collect(futureCounts).map(new Function<List<Long>, Long>() {\n-                            public Long apply(List<Long> counts) {\n-                                return sum(counts);\n-                            }\n-                        });\n+                        return FutureUtils.collect(futureCounts).thenApply(counts -> sum(counts));\n                     }\n                 });\n             }\n@@ -397,15 +398,15 @@ private Long sum(List<Long> values) {\n     }\n \n     @Override\n-    public Future<Void> asyncAbort() {\n+    public CompletableFuture<Void> asyncAbort() {\n         return asyncClose();\n     }\n \n-    public Future<LogRecordWithDLSN> asyncReadLastUserRecord(final LogSegmentMetadata l) {\n+    public CompletableFuture<LogRecordWithDLSN> asyncReadLastUserRecord(final LogSegmentMetadata l) {\n         return asyncReadLastRecord(l, false, false, false);\n     }\n \n-    public Future<LogRecordWithDLSN> asyncReadLastRecord(final LogSegmentMetadata l,\n+    public CompletableFuture<LogRecordWithDLSN> asyncReadLastRecord(final LogSegmentMetadata l,\n                                                          final boolean fence,\n                                                          final boolean includeControl,\n                                                          final boolean includeEndOfStream) {\n@@ -422,7 +423,7 @@ public Future<LogRecordWithDLSN> asyncReadLastRecord(final LogSegmentMetadata l,\n                 numRecordsScanned,\n                 scheduler,\n                 entryStore\n-        ).addEventListener(new FutureEventListener<LogRecordWithDLSN>() {\n+        ).whenComplete(new FutureEventListener<LogRecordWithDLSN>() {\n             @Override\n             public void onSuccess(LogRecordWithDLSN value) {\n                 recoverLastEntryStats.registerSuccessfulEvent(stopwatch.stop().elapsed(TimeUnit.MICROSECONDS));\n@@ -572,17 +573,17 @@ protected void updateLogSegmentCache(Set<String> logSegmentsRemoved,\n      * @param logSegmentNamesListener\n      * @return future represents the result of log segments\n      */\n-    public Future<Versioned<List<LogSegmentMetadata>>> readLogSegmentsFromStore(\n+    public CompletableFuture<Versioned<List<LogSegmentMetadata>>> readLogSegmentsFromStore(\n             final Comparator<LogSegmentMetadata> comparator,\n             final LogSegmentFilter segmentFilter,\n             final LogSegmentNamesListener logSegmentNamesListener) {\n-        final Promise<Versioned<List<LogSegmentMetadata>>> readResult =\n-                new Promise<Versioned<List<LogSegmentMetadata>>>();\n+        final CompletableFuture<Versioned<List<LogSegmentMetadata>>> readResult =\n+                new CompletableFuture<Versioned<List<LogSegmentMetadata>>>();\n         metadataStore.getLogSegmentNames(logMetadata.getLogSegmentsPath(), logSegmentNamesListener)\n-                .addEventListener(new FutureEventListener<Versioned<List<String>>>() {\n+                .whenComplete(new FutureEventListener<Versioned<List<String>>>() {\n                     @Override\n                     public void onFailure(Throwable cause) {\n-                        FutureUtils.setException(readResult, cause);\n+                        readResult.completeExceptionally(cause);\n                     }\n \n                     @Override\n@@ -596,7 +597,7 @@ public void onSuccess(Versioned<List<String>> logSegmentNames) {\n     protected void readLogSegmentsFromStore(final Versioned<List<String>> logSegmentNames,\n                                             final Comparator<LogSegmentMetadata> comparator,\n                                             final LogSegmentFilter segmentFilter,\n-                                            final Promise<Versioned<List<LogSegmentMetadata>>> readResult) {\n+                                            final CompletableFuture<Versioned<List<LogSegmentMetadata>>> readResult) {\n         Set<String> segmentsReceived = new HashSet<String>();\n         segmentsReceived.addAll(segmentFilter.filter(logSegmentNames.getValue()));\n         Set<String> segmentsAdded;\n@@ -619,12 +620,11 @@ protected void readLogSegmentsFromStore(final Versioned<List<String>> logSegment\n             try {\n                 segmentList = getCachedLogSegments(comparator);\n             } catch (UnexpectedException e) {\n-                FutureUtils.setException(readResult, e);\n+                readResult.completeExceptionally(e);\n                 return;\n             }\n \n-            FutureUtils.setValue(readResult,\n-                    new Versioned<List<LogSegmentMetadata>>(segmentList, logSegmentNames.getVersion()));\n+            readResult.complete(new Versioned<List<LogSegmentMetadata>>(segmentList, logSegmentNames.getVersion()));\n             return;\n         }\n \n@@ -646,7 +646,7 @@ protected void readLogSegmentsFromStore(final Versioned<List<String>> logSegment\n                 continue;\n             }\n             metadataStore.getLogSegment(logSegmentPath)\n-                    .addEventListener(new FutureEventListener<LogSegmentMetadata>() {\n+                    .whenComplete(new FutureEventListener<LogSegmentMetadata>() {\n \n                         @Override\n                         public void onSuccess(LogSegmentMetadata result) {\n@@ -666,7 +666,7 @@ public void onFailure(Throwable cause) {\n                             } else {\n                                 // fail fast\n                                 if (1 == numFailures.incrementAndGet()) {\n-                                    FutureUtils.setException(readResult, cause);\n+                                    readResult.completeExceptionally(cause);\n                                     return;\n                                 }\n                             }\n@@ -689,7 +689,7 @@ private void complete() {\n     private void completeReadLogSegmentsFromStore(final Set<String> removedSegments,\n                                                   final Map<String, LogSegmentMetadata> addedSegments,\n                                                   final Comparator<LogSegmentMetadata> comparator,\n-                                                  final Promise<Versioned<List<LogSegmentMetadata>>> readResult,\n+                                                  final CompletableFuture<Versioned<List<LogSegmentMetadata>>> readResult,\n                                                   final Version logSegmentNamesVersion,\n                                                   final AtomicInteger numChildren,\n                                                   final AtomicInteger numFailures) {\n@@ -705,11 +705,10 @@ private void completeReadLogSegmentsFromStore(final Set<String> removedSegments,\n         try {\n             segmentList = getCachedLogSegments(comparator);\n         } catch (UnexpectedException e) {\n-            FutureUtils.setException(readResult, e);\n+            readResult.completeExceptionally(e);\n             return;\n         }\n-        FutureUtils.setValue(readResult,\n-            new Versioned<List<LogSegmentMetadata>>(segmentList, logSegmentNamesVersion));\n+        readResult.complete(new Versioned<List<LogSegmentMetadata>>(segmentList, logSegmentNamesVersion));\n     }\n \n }"},{"sha":"ff6b527200a7544fc2e120fcbc211298f089b0f8","filename":"src/main/java/org/apache/distributedlog/BKLogReadHandler.java","status":"modified","additions":46,"deletions":69,"changes":115,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FBKLogReadHandler.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FBKLogReadHandler.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FBKLogReadHandler.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -17,15 +17,22 @@\n  */\n package org.apache.distributedlog;\n \n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Optional;\n import java.io.IOException;\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.List;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.CopyOnWriteArraySet;\n import java.util.concurrent.TimeUnit;\n-\n-import com.google.common.annotations.VisibleForTesting;\n-import com.google.common.base.Optional;\n+import javax.annotation.Nullable;\n+import org.apache.bookkeeper.stats.AlertStatsLogger;\n+import org.apache.bookkeeper.stats.NullStatsLogger;\n+import org.apache.bookkeeper.stats.StatsLogger;\n+import org.apache.bookkeeper.versioning.Version;\n+import org.apache.bookkeeper.versioning.Versioned;\n import org.apache.distributedlog.callback.LogSegmentListener;\n import org.apache.distributedlog.callback.LogSegmentNamesListener;\n import org.apache.distributedlog.config.DynamicDistributedLogConfiguration;\n@@ -40,29 +47,12 @@\n import org.apache.distributedlog.logsegment.LogSegmentFilter;\n import org.apache.distributedlog.logsegment.LogSegmentMetadataCache;\n import org.apache.distributedlog.metadata.LogStreamMetadataStore;\n-import org.apache.distributedlog.util.FutureUtils;\n+import org.apache.distributedlog.common.concurrent.FutureEventListener;\n+import org.apache.distributedlog.common.concurrent.FutureUtils;\n import org.apache.distributedlog.util.OrderedScheduler;\n import org.apache.distributedlog.util.Utils;\n-import com.twitter.util.ExceptionalFunction;\n-import com.twitter.util.Function;\n-import com.twitter.util.Future;\n-import com.twitter.util.FutureEventListener;\n-import com.twitter.util.Promise;\n-import com.twitter.util.Return;\n-import com.twitter.util.Throw;\n-import com.twitter.util.Try;\n-import org.apache.bookkeeper.stats.AlertStatsLogger;\n-import org.apache.bookkeeper.stats.NullStatsLogger;\n-import org.apache.bookkeeper.stats.StatsLogger;\n-import org.apache.bookkeeper.util.SafeRunnable;\n-import org.apache.bookkeeper.versioning.Version;\n-import org.apache.bookkeeper.versioning.Versioned;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n-import scala.runtime.AbstractFunction1;\n-import scala.runtime.BoxedUnit;\n-\n-import javax.annotation.Nullable;\n \n /**\n  * Log Handler for Readers.\n@@ -112,7 +102,7 @@ class BKLogReadHandler extends BKLogHandler implements LogSegmentNamesListener {\n \n     private final Optional<String> subscriberId;\n     private DistributedLock readLock;\n-    private Future<Void> lockAcquireFuture;\n+    private CompletableFuture<Void> lockAcquireFuture;\n \n     // notify the state change about the read handler\n     protected final AsyncNotification readerStateNotification;\n@@ -166,31 +156,23 @@ String getReadLockPath() {\n         return logMetadataForReader.getReadLockPath(subscriberId);\n     }\n \n-    <T> void satisfyPromiseAsync(final Promise<T> promise, final Try<T> result) {\n-        scheduler.submit(new SafeRunnable() {\n-            @Override\n-            public void safeRun() {\n-                promise.update(result);\n-            }\n-        });\n-    }\n-\n-    Future<Void> checkLogStreamExists() {\n+    CompletableFuture<Void> checkLogStreamExists() {\n         return streamMetadataStore.logExists(logMetadata.getUri(), logMetadata.getLogName());\n     }\n \n     /**\n      * Elective stream lock--readers are not required to acquire the lock before using the stream.\n      */\n-    synchronized Future<Void> lockStream() {\n+    synchronized CompletableFuture<Void> lockStream() {\n         if (null == lockAcquireFuture) {\n             lockAcquireFuture = streamMetadataStore.createReadLock(logMetadataForReader, subscriberId)\n-                    .flatMap(new ExceptionalFunction<DistributedLock, Future<Void>>() {\n-                        @Override\n-                        public Future<Void> applyE(DistributedLock lock) throws Throwable {\n+                    .thenCompose(lock -> {\n+                        try {\n                             BKLogReadHandler.this.readLock = lock;\n                             LOG.info(\"acquiring readlock {} at {}\", getLockClientId(), getReadLockPath());\n                             return acquireLockOnExecutorThread(lock);\n+                        } catch (LockingException le) {\n+                            return FutureUtils.exception(le);\n                         }\n                     });\n         }\n@@ -201,33 +183,31 @@ public Future<Void> applyE(DistributedLock lock) throws Throwable {\n      * Begin asynchronous lock acquire, but ensure that the returned future is satisfied on an\n      * executor service thread.\n      */\n-    Future<Void> acquireLockOnExecutorThread(DistributedLock lock) throws LockingException {\n-        final Future<? extends DistributedLock> acquireFuture = lock.asyncAcquire();\n+    CompletableFuture<Void> acquireLockOnExecutorThread(DistributedLock lock) throws LockingException {\n+        final CompletableFuture<? extends DistributedLock> acquireFuture = lock.asyncAcquire();\n \n         // The future we return must be satisfied on an executor service thread. If we simply\n         // return the future returned by asyncAcquire, user callbacks may end up running in\n         // the lock state executor thread, which will cause deadlocks and introduce latency\n         // etc.\n-        final Promise<Void> threadAcquirePromise = new Promise<Void>();\n-        threadAcquirePromise.setInterruptHandler(new Function<Throwable, BoxedUnit>() {\n-            @Override\n-            public BoxedUnit apply(Throwable t) {\n-                FutureUtils.cancel(acquireFuture);\n-                return null;\n+        final CompletableFuture<Void> threadAcquirePromise = new CompletableFuture<Void>();\n+        threadAcquirePromise.whenComplete((value, cause) -> {\n+            if (cause instanceof CancellationException) {\n+                acquireFuture.cancel(true);\n             }\n         });\n-        acquireFuture.addEventListener(new FutureEventListener<DistributedLock>() {\n+        acquireFuture.whenCompleteAsync(new FutureEventListener<DistributedLock>() {\n             @Override\n             public void onSuccess(DistributedLock lock) {\n                 LOG.info(\"acquired readlock {} at {}\", getLockClientId(), getReadLockPath());\n-                satisfyPromiseAsync(threadAcquirePromise, new Return<Void>(null));\n+                threadAcquirePromise.complete(null);\n             }\n \n             @Override\n             public void onFailure(Throwable cause) {\n                 LOG.info(\"failed to acquire readlock {} at {}\",\n                         new Object[]{ getLockClientId(), getReadLockPath(), cause });\n-                satisfyPromiseAsync(threadAcquirePromise, new Throw<Void>(cause));\n+                threadAcquirePromise.completeExceptionally(cause);\n             }\n         });\n         return threadAcquirePromise;\n@@ -239,35 +219,32 @@ public void onFailure(Throwable cause) {\n     void checkReadLock() throws DLIllegalStateException, LockingException {\n         synchronized (this) {\n             if ((null == lockAcquireFuture) ||\n-                (!lockAcquireFuture.isDefined())) {\n+                (!lockAcquireFuture.isDone())) {\n                 throw new DLIllegalStateException(\"Attempt to check for lock before it has been acquired successfully\");\n             }\n         }\n \n         readLock.checkOwnership();\n     }\n \n-    public Future<Void> asyncClose() {\n+    public CompletableFuture<Void> asyncClose() {\n         DistributedLock lockToClose;\n         synchronized (this) {\n-            if (null != lockAcquireFuture && !lockAcquireFuture.isDefined()) {\n-                FutureUtils.cancel(lockAcquireFuture);\n+            if (null != lockAcquireFuture && !lockAcquireFuture.isDone()) {\n+                lockAcquireFuture.cancel(true);\n             }\n             lockToClose = readLock;\n         }\n         return Utils.closeSequence(scheduler, lockToClose)\n-                .flatMap(new AbstractFunction1<Void, Future<Void>>() {\n-            @Override\n-            public Future<Void> apply(Void result) {\n+            .thenApply((value) -> {\n                 // unregister the log segment listener\n                 metadataStore.unregisterLogSegmentListener(logMetadata.getLogSegmentsPath(), BKLogReadHandler.this);\n-                return Future.Void();\n-            }\n-        });\n+                return null;\n+            });\n     }\n \n     @Override\n-    public Future<Void> asyncAbort() {\n+    public CompletableFuture<Void> asyncAbort() {\n         return asyncClose();\n     }\n \n@@ -277,18 +254,18 @@ public Future<Void> asyncAbort() {\n      *\n      * @return future represents the fetch result\n      */\n-    Future<Versioned<List<LogSegmentMetadata>>> asyncStartFetchLogSegments() {\n-        Promise<Versioned<List<LogSegmentMetadata>>> promise =\n-                new Promise<Versioned<List<LogSegmentMetadata>>>();\n+    CompletableFuture<Versioned<List<LogSegmentMetadata>>> asyncStartFetchLogSegments() {\n+        CompletableFuture<Versioned<List<LogSegmentMetadata>>> promise =\n+                new CompletableFuture<Versioned<List<LogSegmentMetadata>>>();\n         asyncStartFetchLogSegments(promise);\n         return promise;\n     }\n \n-    void asyncStartFetchLogSegments(final Promise<Versioned<List<LogSegmentMetadata>>> promise) {\n+    void asyncStartFetchLogSegments(final CompletableFuture<Versioned<List<LogSegmentMetadata>>> promise) {\n         readLogSegmentsFromStore(\n                 LogSegmentMetadata.COMPARATOR,\n                 LogSegmentFilter.DEFAULT_FILTER,\n-                this).addEventListener(new FutureEventListener<Versioned<List<LogSegmentMetadata>>>() {\n+                this).whenComplete(new FutureEventListener<Versioned<List<LogSegmentMetadata>>>() {\n             @Override\n             public void onFailure(Throwable cause) {\n                 if (cause instanceof LogNotFoundException ||\n@@ -298,7 +275,7 @@ public void onFailure(Throwable cause) {\n                     metadataException.compareAndSet(null, (IOException) cause);\n                     // notify the reader that read handler is in error state\n                     notifyReaderOnError(cause);\n-                    FutureUtils.setException(promise, cause);\n+                    FutureUtils.completeExceptionally(promise, cause);\n                     return;\n                 }\n                 scheduler.schedule(new Runnable() {\n@@ -312,7 +289,7 @@ public void run() {\n             @Override\n             public void onSuccess(Versioned<List<LogSegmentMetadata>> segments) {\n                 // no-op\n-                FutureUtils.setValue(promise, segments);\n+                FutureUtils.complete(promise, segments);\n             }\n         });\n     }\n@@ -332,9 +309,9 @@ public void onSegmentsUpdated(final Versioned<List<String>> segments) {\n             }\n         }\n \n-        Promise<Versioned<List<LogSegmentMetadata>>> readLogSegmentsPromise =\n-                new Promise<Versioned<List<LogSegmentMetadata>>>();\n-        readLogSegmentsPromise.addEventListener(new FutureEventListener<Versioned<List<LogSegmentMetadata>>>() {\n+        CompletableFuture<Versioned<List<LogSegmentMetadata>>> readLogSegmentsPromise =\n+                new CompletableFuture<Versioned<List<LogSegmentMetadata>>>();\n+        readLogSegmentsPromise.whenComplete(new FutureEventListener<Versioned<List<LogSegmentMetadata>>>() {\n             @Override\n             public void onFailure(Throwable cause) {\n                 if (cause instanceof LogNotFoundException ||"},{"sha":"a4016c84fe8622e11ca4322efd91c70af6cbb897","filename":"src/main/java/org/apache/distributedlog/BKLogSegmentWriter.java","status":"modified","additions":80,"deletions":119,"changes":199,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FBKLogSegmentWriter.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FBKLogSegmentWriter.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FBKLogSegmentWriter.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -20,6 +20,8 @@\n import java.io.IOException;\n import java.util.List;\n import java.util.concurrent.Callable;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n import java.util.concurrent.ScheduledFuture;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicInteger;\n@@ -28,6 +30,7 @@\n \n import com.google.common.annotations.VisibleForTesting;\n import com.google.common.base.Stopwatch;\n+import java.util.function.Function;\n import org.apache.distributedlog.config.DynamicDistributedLogConfiguration;\n import org.apache.distributedlog.exceptions.BKTransmitException;\n import org.apache.distributedlog.exceptions.EndOfStreamException;\n@@ -47,20 +50,15 @@\n import org.apache.distributedlog.lock.DistributedLock;\n import org.apache.distributedlog.logsegment.LogSegmentEntryWriter;\n import org.apache.distributedlog.logsegment.LogSegmentWriter;\n-import org.apache.distributedlog.stats.BroadCastStatsLogger;\n-import org.apache.distributedlog.stats.OpStatsListener;\n+import org.apache.distributedlog.common.stats.BroadCastStatsLogger;\n+import org.apache.distributedlog.common.stats.OpStatsListener;\n import org.apache.distributedlog.util.FailpointUtils;\n-import org.apache.distributedlog.util.FutureUtils;\n+import org.apache.distributedlog.common.concurrent.FutureEventListener;\n+import org.apache.distributedlog.common.concurrent.FutureUtils;\n import org.apache.distributedlog.util.OrderedScheduler;\n-import org.apache.distributedlog.util.PermitLimiter;\n-import org.apache.distributedlog.util.SafeQueueingFuturePool;\n+import org.apache.distributedlog.common.util.PermitLimiter;\n import org.apache.distributedlog.util.SimplePermitLimiter;\n-import org.apache.distributedlog.util.Sizable;\n-import com.twitter.util.Function0;\n-import com.twitter.util.Future;\n-import com.twitter.util.FutureEventListener;\n-import com.twitter.util.FuturePool;\n-import com.twitter.util.Promise;\n+import org.apache.distributedlog.common.util.Sizable;\n import org.apache.bookkeeper.client.AsyncCallback.AddCallback;\n import org.apache.bookkeeper.client.AsyncCallback.CloseCallback;\n import org.apache.bookkeeper.client.BKException;\n@@ -73,10 +71,9 @@\n import org.apache.bookkeeper.stats.OpStatsLogger;\n import org.apache.bookkeeper.stats.StatsLogger;\n import org.apache.bookkeeper.util.MathUtils;\n+import org.apache.distributedlog.util.Utils;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n-import scala.runtime.AbstractFunction1;\n-import scala.runtime.BoxedUnit;\n \n import static com.google.common.base.Charsets.UTF_8;\n import static org.apache.distributedlog.LogRecord.MAX_LOGRECORD_SIZE;\n@@ -146,7 +143,7 @@ class BKLogSegmentWriter implements LogSegmentWriter, AddCallback, Runnable, Siz\n     final private AtomicReference<ScheduledFuture<?>> immFlushSchedFutureRef = new AtomicReference<ScheduledFuture<?>>(null);\n     final private AtomicReference<Exception> scheduledFlushException = new AtomicReference<Exception>(null);\n     private boolean enforceLock = true;\n-    private Promise<Void> closeFuture = null;\n+    private CompletableFuture<Void> closeFuture = null;\n     private final boolean enableRecordCounts;\n     private int positionWithinLogSegment = 0;\n     private final long logSegmentSequenceNumber;\n@@ -170,28 +167,17 @@ class BKLogSegmentWriter implements LogSegmentWriter, AddCallback, Runnable, Siz\n     private final OpStatsLogger addCompleteDeferredTime;\n     private final Counter pendingWrites;\n \n-    // add complete processing\n-    private final SafeQueueingFuturePool<Void> addCompleteFuturePool;\n-\n     // Functions\n-    private final AbstractFunction1<Integer, Future<Long>> GET_LAST_TXID_ACKNOWLEDGED_AFTER_TRANSMIT_FUNC =\n-            new AbstractFunction1<Integer, Future<Long>>() {\n-                @Override\n-                public Future<Long> apply(Integer transmitRc) {\n-                    if (BKException.Code.OK == transmitRc) {\n-                        return Future.value(getLastTxIdAcknowledged());\n-                    } else {\n-                        return Future.exception(new BKTransmitException(\"Failed to transmit entry\", transmitRc));\n-                    }\n-                }\n-            };\n-    final AbstractFunction1<Long, Future<Long>> COMMIT_AFTER_FLUSH_FUNC =\n-            new AbstractFunction1<Long, Future<Long>>() {\n-                @Override\n-                public Future<Long> apply(Long lastAckedTxId) {\n-                    return commit();\n-                }\n-            };\n+    private final Function<Integer, CompletableFuture<Long>> GET_LAST_TXID_ACKNOWLEDGED_AFTER_TRANSMIT_FUNC =\n+        transmitRc -> {\n+            if (BKException.Code.OK == transmitRc) {\n+                return FutureUtils.value(getLastTxIdAcknowledged());\n+            } else {\n+                return FutureUtils.exception(new BKTransmitException(\"Failed to transmit entry\", transmitRc));\n+            }\n+        };\n+    final Function<Long, CompletableFuture<Long>> COMMIT_AFTER_FLUSH_FUNC =\n+        lastAckedTxId -> commit();\n \n     private final AlertStatsLogger alertStatsLogger;\n     private final WriteLimiter writeLimiter;\n@@ -341,11 +327,6 @@ public void run() {\n         }\n \n         this.conf = conf;\n-        if (null != scheduler) {\n-            this.addCompleteFuturePool = new SafeQueueingFuturePool<Void>(scheduler.getFuturePool(streamName));\n-        } else {\n-            this.addCompleteFuturePool = null;\n-        }\n         assert(!this.immediateFlushEnabled || (null != this.scheduler));\n         this.lastTransmit = Stopwatch.createStarted();\n     }\n@@ -360,11 +341,8 @@ DistributedLock getLock() {\n     }\n \n     @VisibleForTesting\n-    FuturePool getFuturePool() {\n-        if (null == scheduler) {\n-            return null;\n-        }\n-        return scheduler.getFuturePool(streamName);\n+    ScheduledExecutorService getFuturePool() {\n+        return scheduler.chooseExecutor(streamName);\n     }\n \n     @VisibleForTesting\n@@ -471,21 +449,15 @@ private boolean envelopeBeforeTransmit() {\n     }\n \n     @Override\n-    public Future<Void> asyncClose() {\n+    public CompletableFuture<Void> asyncClose() {\n         return closeInternal(false);\n     }\n \n     @Override\n-    public Future<Void> asyncAbort() {\n+    public CompletableFuture<Void> asyncAbort() {\n         return closeInternal(true);\n     }\n \n-    private void flushAddCompletes() {\n-        if (null != addCompleteFuturePool) {\n-            addCompleteFuturePool.close();\n-        }\n-    }\n-\n     private synchronized void abortPacket(BKTransmitPacket packet) {\n         long numRecords = 0;\n         if (null != packet) {\n@@ -495,7 +467,7 @@ private synchronized void abortPacket(BKTransmitPacket packet) {\n             if (BKException.Code.OK == rc) {\n                 rc = BKException.Code.InterruptedException;\n             }\n-            Throwable reason = new WriteCancelledException(streamName, FutureUtils.transmitException(rc));\n+            Throwable reason = new WriteCancelledException(streamName, Utils.transmitException(rc));\n             recordSet.abortTransmit(reason);\n         }\n         LOG.info(\"Stream {} aborted {} writes\", fullyQualifiedLogSegment, numRecords);\n@@ -509,21 +481,13 @@ private synchronized long getWritesPendingTransmit() {\n         }\n     }\n \n-    private synchronized long getPendingAddCompleteCount() {\n-        if (null != addCompleteFuturePool) {\n-            return addCompleteFuturePool.size();\n-        } else {\n-            return 0;\n-        }\n-    }\n-\n-    private Future<Void> closeInternal(boolean abort) {\n-        Promise<Void> closePromise;\n+    private CompletableFuture<Void> closeInternal(boolean abort) {\n+        CompletableFuture<Void> closePromise;\n         synchronized (this) {\n             if (null != closeFuture) {\n                 return closeFuture;\n             }\n-            closePromise = closeFuture = new Promise<Void>();\n+            closePromise = closeFuture = new CompletableFuture<Void>();\n         }\n \n         AtomicReference<Throwable> throwExc = new AtomicReference<Throwable>(null);\n@@ -533,7 +497,7 @@ private Future<Void> closeInternal(boolean abort) {\n \n     private void closeInternal(final boolean abort,\n                                final AtomicReference<Throwable> throwExc,\n-                               final Promise<Void> closePromise) {\n+                               final CompletableFuture<Void> closePromise) {\n         // clean stats resources\n         this.transmitOutstandingLogger.unregisterGauge(\"requests\", transmitOutstandingGauge);\n         this.writeLimiter.close();\n@@ -560,7 +524,7 @@ private void closeInternal(final boolean abort,\n         if (!abort && !isLogSegmentInError()) {\n             this.enforceLock = false;\n             LOG.info(\"Flushing before closing log segment {}\", getFullyQualifiedLogSegment());\n-            flushAndCommit().addEventListener(new FutureEventListener<Long>() {\n+            flushAndCommit().whenComplete(new FutureEventListener<Long>() {\n                 @Override\n                 public void onSuccess(Long value) {\n                     abortTransmitPacketOnClose(abort, throwExc, closePromise);\n@@ -580,11 +544,11 @@ public void onFailure(Throwable cause) {\n \n     private void abortTransmitPacketOnClose(final boolean abort,\n                                             final AtomicReference<Throwable> throwExc,\n-                                            final Promise<Void> closePromise) {\n+                                            final CompletableFuture<Void> closePromise) {\n         LOG.info(\"Closing BKPerStreamLogWriter (abort={}) for {} :\" +\n-                        \" lastDLSN = {} outstandingTransmits = {} writesPendingTransmit = {} addCompletesPending = {}\",\n+                        \" lastDLSN = {} outstandingTransmits = {} writesPendingTransmit = {}\",\n                 new Object[]{abort, fullyQualifiedLogSegment, getLastDLSN(),\n-                        outstandingTransmits.get(), getWritesPendingTransmit(), getPendingAddCompleteCount()});\n+                        outstandingTransmits.get(), getWritesPendingTransmit()});\n \n         // Save the current packet to reset, leave a new empty packet to avoid a race with\n         // addCompleteDeferredProcessing.\n@@ -602,7 +566,6 @@ private void abortTransmitPacketOnClose(final boolean abort,\n             packetPreviousSaved.addTransmitCompleteListener(new FutureEventListener<Integer>() {\n                 @Override\n                 public void onSuccess(Integer transmitResult) {\n-                    flushAddCompletes();\n                     abortPacket(packetCurrentSaved);\n                 }\n                 @Override\n@@ -620,7 +583,7 @@ public void onFailure(Throwable cause) {\n \n     private void closeLedgerOnClose(final boolean abort,\n                                     final AtomicReference<Throwable> throwExc,\n-                                    final Promise<Void> closePromise) {\n+                                    final CompletableFuture<Void> closePromise) {\n         // close the log segment if it isn't in error state, so all the outstanding addEntry(s) will callback.\n         if (null == throwExc.get() && !isLogSegmentInError()) {\n             // Synchronous closing the ledger handle, if we couldn't close a ledger handle successfully.\n@@ -644,16 +607,16 @@ public void closeComplete(int rc, LedgerHandle lh, Object ctx) {\n \n     private void completeClosePromise(final boolean abort,\n                                       final AtomicReference<Throwable> throwExc,\n-                                      final Promise<Void> closePromise) {\n+                                      final CompletableFuture<Void> closePromise) {\n         // If add entry failed because of closing ledger above, we don't need to fail the close operation\n         if (!abort && null == throwExc.get() && shouldFailCompleteLogSegment()) {\n             throwExc.set(new BKTransmitException(\"Closing an errored stream : \", transmitResult.get()));\n         }\n \n         if (null == throwExc.get()) {\n-            FutureUtils.setValue(closePromise, null);\n+            FutureUtils.complete(closePromise, null);\n         } else {\n-            FutureUtils.setException(closePromise, throwExc.get());\n+            FutureUtils.completeExceptionally(closePromise, throwExc.get());\n         }\n     }\n \n@@ -664,28 +627,28 @@ synchronized public void write(LogRecord record) throws IOException {\n     }\n \n     @Override\n-    synchronized public Future<DLSN> asyncWrite(LogRecord record) {\n+    synchronized public CompletableFuture<DLSN> asyncWrite(LogRecord record) {\n         return asyncWrite(record, true);\n     }\n \n-    synchronized public Future<DLSN> asyncWrite(LogRecord record, boolean flush) {\n-        Future<DLSN> result = null;\n+    synchronized public CompletableFuture<DLSN> asyncWrite(LogRecord record, boolean flush) {\n+        CompletableFuture<DLSN> result = null;\n         try {\n             if (record.isControl()) {\n                 // we don't pack control records with user records together\n                 // so transmit current output buffer if possible\n                 try {\n                     transmit();\n                 } catch (IOException ioe) {\n-                    return Future.exception(new WriteCancelledException(fullyQualifiedLogSegment, ioe));\n+                    return FutureUtils.exception(new WriteCancelledException(fullyQualifiedLogSegment, ioe));\n                 }\n                 result = writeControlLogRecord(record);\n                 transmit();\n             } else {\n                 result = writeUserRecord(record);\n                 if (!isDurableWriteEnabled) {\n                     // we have no idea about the DLSN if durability is turned off.\n-                    result = Future.value(DLSN.InvalidDLSN);\n+                    result = FutureUtils.value(DLSN.InvalidDLSN);\n                 }\n                 if (flush) {\n                     flushIfNeeded();\n@@ -697,15 +660,15 @@ synchronized public Future<DLSN> asyncWrite(LogRecord record, boolean flush) {\n             if (null != result) {\n                 LOG.error(\"Overriding first result with flush failure {}\", result);\n             }\n-            result = Future.exception(ioe);\n+            result = FutureUtils.exception(ioe);\n \n             // Flush to ensure any prev. writes with flush=false are flushed despite failure.\n             flushIfNeededNoThrow();\n         }\n         return result;\n     }\n \n-    synchronized private Future<DLSN> writeUserRecord(LogRecord record) throws IOException {\n+    synchronized private CompletableFuture<DLSN> writeUserRecord(LogRecord record) throws IOException {\n         if (null != closeFuture) {\n             throw new WriteException(fullyQualifiedLogSegment, BKException.getMessage(BKException.Code.LedgerClosedException));\n         }\n@@ -737,7 +700,7 @@ synchronized private Future<DLSN> writeUserRecord(LogRecord record) throws IOExc\n         // Internally generated log records don't increment the count\n         // writeInternal will always set a count regardless of whether it was\n         // incremented or not.\n-        Future<DLSN> future = null;\n+        CompletableFuture<DLSN> future = null;\n         try {\n             // increment the position for the record to write\n             // if the record is failed to write, it would be decremented.\n@@ -759,12 +722,9 @@ synchronized private Future<DLSN> writeUserRecord(LogRecord record) throws IOExc\n         }\n \n         // Track outstanding requests and return the future.\n-        return future.ensure(new Function0<BoxedUnit>() {\n-            public BoxedUnit apply() {\n-                pendingWrites.dec();\n-                writeLimiter.release();\n-                return null;\n-            }\n+        return FutureUtils.ensure(future, () -> {\n+            pendingWrites.dec();\n+            writeLimiter.release();\n         });\n     }\n \n@@ -777,7 +737,7 @@ boolean shouldFailCompleteLogSegment() {\n                 (transmitResult.get() != BKException.Code.LedgerClosedException);\n     }\n \n-    synchronized public Future<DLSN> writeInternal(LogRecord record)\n+    synchronized public CompletableFuture<DLSN> writeInternal(LogRecord record)\n             throws LogRecordTooLongException, LockingException, BKTransmitException,\n                    WriteException, InvalidEnvelopedEntryException {\n         int logRecordSize = record.getPersistentSize();\n@@ -802,8 +762,8 @@ synchronized public Future<DLSN> writeInternal(LogRecord record)\n             record.setPositionWithinLogSegment(positionWithinLogSegment);\n         }\n \n-        Promise<DLSN> writePromise = new Promise<DLSN>();\n-        writePromise.addEventListener(new OpStatsListener<DLSN>(writeTime));\n+        CompletableFuture<DLSN> writePromise = new CompletableFuture<DLSN>();\n+        writePromise.whenComplete(new OpStatsListener<DLSN>(writeTime));\n         recordSetWriter.writeRecord(record, writePromise);\n \n         if (record.getTransactionId() < lastTxId) {\n@@ -818,15 +778,15 @@ synchronized public Future<DLSN> writeInternal(LogRecord record)\n         return writePromise;\n     }\n \n-    synchronized private Future<DLSN> writeControlLogRecord()\n+    synchronized private CompletableFuture<DLSN> writeControlLogRecord()\n             throws BKTransmitException, WriteException, InvalidEnvelopedEntryException,\n                    LockingException, LogRecordTooLongException {\n         LogRecord controlRec = new LogRecord(lastTxId, DistributedLogConstants.CONTROL_RECORD_CONTENT);\n         controlRec.setControl();\n         return writeControlLogRecord(controlRec);\n     }\n \n-    synchronized private Future<DLSN> writeControlLogRecord(LogRecord record)\n+    synchronized private CompletableFuture<DLSN> writeControlLogRecord(LogRecord record)\n             throws BKTransmitException, WriteException, InvalidEnvelopedEntryException,\n                    LockingException, LogRecordTooLongException {\n         return writeInternal(record);\n@@ -851,12 +811,12 @@ synchronized private void writeEndOfStreamMarker() throws IOException {\n      * as read-only in the metadata. No appends to the\n      * stream will be allowed after this point\n      */\n-    public Future<Long> markEndOfStream() {\n+    public CompletableFuture<Long> markEndOfStream() {\n         synchronized (this) {\n             try {\n                 writeEndOfStreamMarker();\n             } catch (IOException e) {\n-                return Future.exception(e);\n+                return FutureUtils.exception(e);\n             }\n             streamEnded = true;\n         }\n@@ -905,60 +865,60 @@ synchronized void checkStateAndTransmit()\n     }\n \n     @Override\n-    public synchronized Future<Long> flush() {\n+    public synchronized CompletableFuture<Long> flush() {\n         try {\n             checkStateBeforeTransmit();\n         } catch (WriteException e) {\n-            return Future.exception(e);\n+            return FutureUtils.exception(e);\n         }\n \n-        Future<Integer> transmitFuture;\n+        CompletableFuture<Integer> transmitFuture;\n         try {\n             transmitFuture = transmit();\n         } catch (BKTransmitException e) {\n-            return Future.exception(e);\n+            return FutureUtils.exception(e);\n         } catch (LockingException e) {\n-            return Future.exception(e);\n+            return FutureUtils.exception(e);\n         } catch (WriteException e) {\n-            return Future.exception(e);\n+            return FutureUtils.exception(e);\n         } catch (InvalidEnvelopedEntryException e) {\n-            return Future.exception(e);\n+            return FutureUtils.exception(e);\n         }\n \n         if (null == transmitFuture) {\n             if (null != packetPrevious) {\n                 transmitFuture = packetPrevious.getTransmitFuture();\n             }  else {\n-                return Future.value(getLastTxIdAcknowledged());\n+                return FutureUtils.value(getLastTxIdAcknowledged());\n             }\n         }\n \n-        return transmitFuture.flatMap(GET_LAST_TXID_ACKNOWLEDGED_AFTER_TRANSMIT_FUNC);\n+        return transmitFuture.thenCompose(GET_LAST_TXID_ACKNOWLEDGED_AFTER_TRANSMIT_FUNC);\n     }\n \n     @Override\n-    public synchronized Future<Long> commit() {\n+    public synchronized CompletableFuture<Long> commit() {\n         // we don't pack control records with user records together\n         // so transmit current output buffer if possible\n-        Future<Integer> transmitFuture;\n+        CompletableFuture<Integer> transmitFuture;\n         try {\n             try {\n                 transmitFuture = transmit();\n             } catch (IOException ioe) {\n-                return Future.exception(ioe);\n+                return FutureUtils.exception(ioe);\n             }\n             if (null == transmitFuture) {\n                 writeControlLogRecord();\n                 return flush();\n             }\n         } catch (IOException ioe) {\n-            return Future.exception(ioe);\n+            return FutureUtils.exception(ioe);\n         }\n-        return transmitFuture.flatMap(GET_LAST_TXID_ACKNOWLEDGED_AFTER_TRANSMIT_FUNC);\n+        return transmitFuture.thenCompose(GET_LAST_TXID_ACKNOWLEDGED_AFTER_TRANSMIT_FUNC);\n     }\n \n-    Future<Long> flushAndCommit() {\n-        return flush().flatMap(COMMIT_AFTER_FLUSH_FUNC);\n+    CompletableFuture<Long> flushAndCommit() {\n+        return flush().thenCompose(COMMIT_AFTER_FLUSH_FUNC);\n     }\n \n     void flushIfNeededNoThrow() {\n@@ -1054,7 +1014,7 @@ private void checkWriteLock() throws LockingException {\n      * @throws WriteException if failed to create the envelope for the data to transmit\n      * @throws InvalidEnvelopedEntryException when built an invalid enveloped entry\n      */\n-    private Future<Integer> transmit()\n+    private CompletableFuture<Integer> transmit()\n         throws BKTransmitException, LockingException, WriteException, InvalidEnvelopedEntryException {\n         EntryBuffer recordSetToTransmit;\n         transmitLock.lock();\n@@ -1183,10 +1143,11 @@ public void addComplete(final int rc, LedgerHandle handle,\n             }\n         }\n \n-        if (null != addCompleteFuturePool) {\n+        if (null != scheduler) {\n             final Stopwatch queuedTime = Stopwatch.createStarted();\n-            addCompleteFuturePool.apply(new Function0<Void>() {\n-                public Void apply() {\n+            scheduler.submit(streamName, new Callable<Void>() {\n+                @Override\n+                public Void call() {\n                     final Stopwatch deferredTime = Stopwatch.createStarted();\n                     addCompleteQueuedTime.registerSuccessfulEvent(queuedTime.elapsed(TimeUnit.MICROSECONDS));\n                     addCompleteDeferredProcessing(transmitPacket, entryId, effectiveRC.get());\n@@ -1198,7 +1159,7 @@ public String toString() {\n                     return String.format(\"AddComplete(Stream=%s, entryId=%d, rc=%d)\",\n                             fullyQualifiedLogSegment, entryId, rc);\n                 }\n-            }).addEventListener(new FutureEventListener<Void>() {\n+            }).whenComplete(new FutureEventListener<Void>() {\n                 @Override\n                 public void onSuccess(Void done) {\n                 }\n@@ -1278,7 +1239,7 @@ public Void call() throws Exception {\n         if (BKException.Code.OK == transmitResult.get()) {\n             recordSet.completeTransmit(logSegmentSequenceNumber, entryId);\n         } else {\n-            recordSet.abortTransmit(FutureUtils.transmitException(transmitResult.get()));\n+            recordSet.abortTransmit(Utils.transmitException(transmitResult.get()));\n         }\n \n         if (cancelPendingPromises) {\n@@ -1292,7 +1253,7 @@ public Void call() throws Exception {\n             }\n             packetCurrentSaved.getRecordSet().abortTransmit(\n                     new WriteCancelledException(streamName,\n-                            FutureUtils.transmitException(transmitResult.get())));\n+                            Utils.transmitException(transmitResult.get())));\n         }\n     }\n "},{"sha":"1293d00bff3f56b85eb499295c3f9cac66c08736","filename":"src/main/java/org/apache/distributedlog/BKLogWriteHandler.java","status":"modified","additions":150,"deletions":172,"changes":322,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FBKLogWriteHandler.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FBKLogWriteHandler.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FBKLogWriteHandler.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -17,9 +17,25 @@\n  */\n package org.apache.distributedlog;\n \n+import static org.apache.distributedlog.impl.ZKLogSegmentFilters.WRITE_HANDLE_FILTER;\n+\n import com.google.common.annotations.VisibleForTesting;\n import com.google.common.base.Stopwatch;\n import com.google.common.collect.Lists;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+import org.apache.bookkeeper.feature.FeatureProvider;\n+import org.apache.bookkeeper.stats.AlertStatsLogger;\n+import org.apache.bookkeeper.stats.OpStatsLogger;\n+import org.apache.bookkeeper.stats.StatsLogger;\n+import org.apache.bookkeeper.versioning.Version;\n+import org.apache.bookkeeper.versioning.Versioned;\n import org.apache.distributedlog.config.DynamicDistributedLogConfiguration;\n import org.apache.distributedlog.exceptions.DLIllegalStateException;\n import org.apache.distributedlog.exceptions.EndOfStreamException;\n@@ -43,34 +59,14 @@\n import org.apache.distributedlog.util.Allocator;\n import org.apache.distributedlog.util.DLUtils;\n import org.apache.distributedlog.util.FailpointUtils;\n-import org.apache.distributedlog.util.FutureUtils;\n-import org.apache.distributedlog.util.FutureUtils.FutureEventListenerRunnable;\n+import org.apache.distributedlog.common.concurrent.FutureEventListener;\n+import org.apache.distributedlog.common.concurrent.FutureUtils;\n import org.apache.distributedlog.util.OrderedScheduler;\n import org.apache.distributedlog.util.Transaction;\n-import org.apache.distributedlog.util.PermitLimiter;\n+import org.apache.distributedlog.common.util.PermitLimiter;\n import org.apache.distributedlog.util.Utils;\n-import com.twitter.util.Function;\n-import com.twitter.util.Future;\n-import com.twitter.util.FutureEventListener;\n-import com.twitter.util.Promise;\n-import org.apache.bookkeeper.feature.FeatureProvider;\n-import org.apache.bookkeeper.stats.AlertStatsLogger;\n-import org.apache.bookkeeper.stats.OpStatsLogger;\n-import org.apache.bookkeeper.stats.StatsLogger;\n-import org.apache.bookkeeper.versioning.Version;\n-import org.apache.bookkeeper.versioning.Versioned;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n-import scala.runtime.AbstractFunction1;\n-\n-import java.io.IOException;\n-import java.util.ArrayList;\n-import java.util.Comparator;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.concurrent.TimeUnit;\n-\n-import static org.apache.distributedlog.impl.ZKLogSegmentFilters.WRITE_HANDLE_FILTER;\n \n /**\n  * Log Handler for Writers.\n@@ -108,7 +104,7 @@ public void onAbort(Throwable t) {\n     protected final boolean validateLogSegmentSequenceNumber;\n     protected final int regionId;\n     protected final RollingPolicy rollingPolicy;\n-    protected Future<? extends DistributedLock> lockFuture = null;\n+    protected CompletableFuture<? extends DistributedLock> lockFuture = null;\n     protected final PermitLimiter writeLimiter;\n     protected final FeatureProvider featureProvider;\n     protected final DynamicDistributedLogConfiguration dynConf;\n@@ -117,16 +113,16 @@ public void onAbort(Throwable t) {\n     protected final LinkedList<Long> inprogressLSSNs;\n \n     // Fetch LogSegments State: write can continue without full list of log segments while truncation needs\n-    private final Future<Versioned<List<LogSegmentMetadata>>> fetchForWrite;\n-    private Future<Versioned<List<LogSegmentMetadata>>> fetchForTruncation;\n+    private final CompletableFuture<Versioned<List<LogSegmentMetadata>>> fetchForWrite;\n+    private CompletableFuture<Versioned<List<LogSegmentMetadata>>> fetchForTruncation;\n \n     // Recover Functions\n     private final RecoverLogSegmentFunction recoverLogSegmentFunction =\n             new RecoverLogSegmentFunction();\n-    private final AbstractFunction1<List<LogSegmentMetadata>, Future<Long>> recoverLogSegmentsFunction =\n-            new AbstractFunction1<List<LogSegmentMetadata>, Future<Long>>() {\n+    private final Function<List<LogSegmentMetadata>, CompletableFuture<Long>> recoverLogSegmentsFunction =\n+            new Function<List<LogSegmentMetadata>, CompletableFuture<Long>>() {\n                 @Override\n-                public Future<Long> apply(List<LogSegmentMetadata> segmentList) {\n+                public CompletableFuture<Long> apply(List<LogSegmentMetadata> segmentList) {\n                     LOG.info(\"Initiating Recovery For {} : {}\", getFullyQualifiedName(), segmentList);\n                     // if lastLedgerRollingTimeMillis is not updated, we set it to now.\n                     synchronized (BKLogWriteHandler.this) {\n@@ -145,8 +141,11 @@ public Future<Long> apply(List<LogSegmentMetadata> segmentList) {\n                         }\n                     }\n \n-                    return FutureUtils.processList(segmentList, recoverLogSegmentFunction, scheduler).map(\n-                            GetLastTxIdFunction.INSTANCE);\n+                    return FutureUtils.processList(\n+                        segmentList,\n+                        recoverLogSegmentFunction,\n+                        scheduler\n+                    ).thenApply(GetLastTxIdFunction.INSTANCE);\n                 }\n             };\n \n@@ -232,30 +231,30 @@ public Future<Long> apply(List<LogSegmentMetadata> segmentList) {\n         deleteOpStats = segmentsStatsLogger.getOpStatsLogger(\"delete\");\n     }\n \n-    private Future<List<LogSegmentMetadata>> getCachedLogSegmentsAfterFirstFetch(\n+    private CompletableFuture<List<LogSegmentMetadata>> getCachedLogSegmentsAfterFirstFetch(\n             final Comparator<LogSegmentMetadata> comparator) {\n-        final Promise<List<LogSegmentMetadata>> promise = new Promise<List<LogSegmentMetadata>>();\n-        fetchForWrite.addEventListener(new FutureEventListener<Versioned<List<LogSegmentMetadata>>>() {\n+        final CompletableFuture<List<LogSegmentMetadata>> promise = new CompletableFuture<List<LogSegmentMetadata>>();\n+        fetchForWrite.whenComplete(new FutureEventListener<Versioned<List<LogSegmentMetadata>>>() {\n             @Override\n             public void onFailure(Throwable cause) {\n-                FutureUtils.setException(promise, cause);\n+                promise.completeExceptionally(cause);\n             }\n \n             @Override\n             public void onSuccess(Versioned<List<LogSegmentMetadata>> result) {\n                 try {\n-                    FutureUtils.setValue(promise, getCachedLogSegments(comparator));\n+                    promise.complete(getCachedLogSegments(comparator));\n                 } catch (UnexpectedException e) {\n-                    FutureUtils.setException(promise, e);\n+                    promise.completeExceptionally(e);\n                 }\n             }\n         });\n         return promise;\n     }\n \n-    private Future<List<LogSegmentMetadata>> getCachedLogSegmentsAfterFirstFullFetch(\n+    private CompletableFuture<List<LogSegmentMetadata>> getCachedLogSegmentsAfterFirstFullFetch(\n             final Comparator<LogSegmentMetadata> comparator) {\n-        Future<Versioned<List<LogSegmentMetadata>>> result;\n+        CompletableFuture<Versioned<List<LogSegmentMetadata>>> result;\n         synchronized (this) {\n             if (null == fetchForTruncation) {\n                 fetchForTruncation = readLogSegmentsFromStore(\n@@ -266,19 +265,19 @@ private Future<List<LogSegmentMetadata>> getCachedLogSegmentsAfterFirstFullFetch\n             result = fetchForTruncation;\n         }\n \n-        final Promise<List<LogSegmentMetadata>> promise = new Promise<List<LogSegmentMetadata>>();\n-        result.addEventListener(new FutureEventListener<Versioned<List<LogSegmentMetadata>>>() {\n+        final CompletableFuture<List<LogSegmentMetadata>> promise = new CompletableFuture<List<LogSegmentMetadata>>();\n+        result.whenComplete(new FutureEventListener<Versioned<List<LogSegmentMetadata>>>() {\n             @Override\n             public void onFailure(Throwable cause) {\n-                FutureUtils.setException(promise, cause);\n+                FutureUtils.completeExceptionally(promise, cause);\n             }\n \n             @Override\n             public void onSuccess(Versioned<List<LogSegmentMetadata>> result) {\n                 try {\n-                    FutureUtils.setValue(promise, getCachedLogSegments(comparator));\n+                    FutureUtils.complete(promise, getCachedLogSegments(comparator));\n                 } catch (UnexpectedException e) {\n-                    FutureUtils.setException(promise, e);\n+                    FutureUtils.completeExceptionally(promise, e);\n                 }\n             }\n         });\n@@ -374,19 +373,19 @@ public void onAbort(Throwable t) {\n      *\n      * @return future represents the lock result\n      */\n-    Future<? extends DistributedLock> lockHandler() {\n+    CompletableFuture<? extends DistributedLock> lockHandler() {\n         if (null != lockFuture) {\n             return lockFuture;\n         }\n         lockFuture = lock.asyncAcquire();\n         return lockFuture;\n     }\n \n-    Future<Void> unlockHandler() {\n+    CompletableFuture<Void> unlockHandler() {\n         if (null != lockFuture) {\n             return lock.asyncClose();\n         } else {\n-            return Future.Void();\n+            return FutureUtils.Void();\n         }\n     }\n \n@@ -483,23 +482,23 @@ protected long assignLogSegmentSequenceNumber() throws IOException {\n     }\n \n     protected BKLogSegmentWriter doStartLogSegment(long txId, boolean bestEffort, boolean allowMaxTxID) throws IOException {\n-        return FutureUtils.result(asyncStartLogSegment(txId, bestEffort, allowMaxTxID));\n+        return Utils.ioResult(asyncStartLogSegment(txId, bestEffort, allowMaxTxID));\n     }\n \n-    protected Future<BKLogSegmentWriter> asyncStartLogSegment(final long txId,\n+    protected CompletableFuture<BKLogSegmentWriter> asyncStartLogSegment(final long txId,\n                                                               final boolean bestEffort,\n                                                               final boolean allowMaxTxID) {\n-        final Promise<BKLogSegmentWriter> promise = new Promise<BKLogSegmentWriter>();\n+        final CompletableFuture<BKLogSegmentWriter> promise = new CompletableFuture<BKLogSegmentWriter>();\n         try {\n             lock.checkOwnershipAndReacquire();\n         } catch (LockingException e) {\n-            FutureUtils.setException(promise, e);\n+            FutureUtils.completeExceptionally(promise, e);\n             return promise;\n         }\n-        fetchForWrite.addEventListener(new FutureEventListener<Versioned<List<LogSegmentMetadata>>>() {\n+        fetchForWrite.whenComplete(new FutureEventListener<Versioned<List<LogSegmentMetadata>>>() {\n             @Override\n             public void onFailure(Throwable cause) {\n-                FutureUtils.setException(promise, cause);\n+                FutureUtils.completeExceptionally(promise, cause);\n             }\n \n             @Override\n@@ -513,23 +512,23 @@ public void onSuccess(Versioned<List<LogSegmentMetadata>> list) {\n     protected void doStartLogSegment(final long txId,\n                                      final boolean bestEffort,\n                                      final boolean allowMaxTxID,\n-                                     final Promise<BKLogSegmentWriter> promise) {\n+                                     final CompletableFuture<BKLogSegmentWriter> promise) {\n         // validate the tx id\n         if ((txId < 0) ||\n                 (!allowMaxTxID && (txId == DistributedLogConstants.MAX_TXID))) {\n-            FutureUtils.setException(promise, new IOException(\"Invalid Transaction Id \" + txId));\n+            FutureUtils.completeExceptionally(promise, new IOException(\"Invalid Transaction Id \" + txId));\n             return;\n         }\n \n         long highestTxIdWritten = maxTxId.get();\n         if (txId < highestTxIdWritten) {\n             if (highestTxIdWritten == DistributedLogConstants.MAX_TXID) {\n                 LOG.error(\"We've already marked the stream as ended and attempting to start a new log segment\");\n-                FutureUtils.setException(promise, new EndOfStreamException(\"Writing to a stream after it has been marked as completed\"));\n+                FutureUtils.completeExceptionally(promise, new EndOfStreamException(\"Writing to a stream after it has been marked as completed\"));\n                 return;\n             } else {\n                 LOG.error(\"We've already seen TxId {} the max TXId is {}\", txId, highestTxIdWritten);\n-                FutureUtils.setException(promise, new TransactionIdOutOfOrderException(txId, highestTxIdWritten));\n+                FutureUtils.completeExceptionally(promise, new TransactionIdOutOfOrderException(txId, highestTxIdWritten));\n                 return;\n             }\n         }\n@@ -554,7 +553,7 @@ protected void doStartLogSegment(final long txId,\n         }\n \n         logSegmentAllocator.tryObtain(txn, NULL_OP_LISTENER)\n-                .addEventListener(new FutureEventListener<LogSegmentEntryWriter>() {\n+                .whenComplete(new FutureEventListener<LogSegmentEntryWriter>() {\n \n             @Override\n             public void onSuccess(LogSegmentEntryWriter entryWriter) {\n@@ -574,13 +573,13 @@ public void onFailure(Throwable cause) {\n         });\n     }\n \n-    private void failStartLogSegment(Promise<BKLogSegmentWriter> promise,\n+    private void failStartLogSegment(CompletableFuture<BKLogSegmentWriter> promise,\n                                      boolean bestEffort,\n                                      Throwable cause) {\n         if (bestEffort) {\n-            FutureUtils.setValue(promise, null);\n+            FutureUtils.complete(promise, null);\n         } else {\n-            FutureUtils.setException(promise, cause);\n+            FutureUtils.completeExceptionally(promise, cause);\n         }\n     }\n \n@@ -591,7 +590,7 @@ private void createInprogressLogSegment(Transaction<Object> txn,\n                                             final long txId,\n                                             final LogSegmentEntryWriter entryWriter,\n                                             boolean bestEffort,\n-                                            final Promise<BKLogSegmentWriter> promise) {\n+                                            final CompletableFuture<BKLogSegmentWriter> promise) {\n         final long logSegmentSeqNo;\n         try {\n             FailpointUtils.checkFailPoint(\n@@ -626,12 +625,12 @@ private void createInprogressLogSegment(Transaction<Object> txn,\n         LOG.debug(\"Try storing MaxTxId in startLogSegment  {} {}\", inprogressZnodePath, txId);\n         storeMaxTxId(txn, maxTxId, txId);\n \n-        txn.execute().addEventListener(FutureEventListenerRunnable.of(new FutureEventListener<Void>() {\n+        txn.execute().whenCompleteAsync(new FutureEventListener<Void>() {\n \n             @Override\n             public void onSuccess(Void value) {\n                 try {\n-                    FutureUtils.setValue(promise, new BKLogSegmentWriter(\n+                    FutureUtils.complete(promise, new BKLogSegmentWriter(\n                             getFullyQualifiedName(),\n                             l.getSegmentName(),\n                             conf,\n@@ -656,7 +655,7 @@ public void onSuccess(Void value) {\n             public void onFailure(Throwable cause) {\n                 failStartLogSegment(promise, false, cause);\n             }\n-        }, scheduler));\n+        }, scheduler);\n     }\n \n     boolean shouldStartNewSegment(BKLogSegmentWriter writer) {\n@@ -672,21 +671,21 @@ boolean shouldStartNewSegment(BKLogSegmentWriter writer) {\n      * the firstTxId of the ledger matches firstTxId for the segment we are\n      * trying to finalize.\n      */\n-    Future<LogSegmentMetadata> completeAndCloseLogSegment(final BKLogSegmentWriter writer) {\n-        final Promise<LogSegmentMetadata> promise = new Promise<LogSegmentMetadata>();\n+    CompletableFuture<LogSegmentMetadata> completeAndCloseLogSegment(final BKLogSegmentWriter writer) {\n+        final CompletableFuture<LogSegmentMetadata> promise = new CompletableFuture<LogSegmentMetadata>();\n         completeAndCloseLogSegment(writer, promise);\n         return promise;\n     }\n \n     private void completeAndCloseLogSegment(final BKLogSegmentWriter writer,\n-                                            final Promise<LogSegmentMetadata> promise) {\n-        writer.asyncClose().addEventListener(new FutureEventListener<Void>() {\n+                                            final CompletableFuture<LogSegmentMetadata> promise) {\n+        writer.asyncClose().whenComplete(new FutureEventListener<Void>() {\n             @Override\n             public void onSuccess(Void value) {\n                 // in theory closeToFinalize should throw exception if a stream is in error.\n                 // just in case, add another checking here to make sure we don't close log segment is a stream is in error.\n                 if (writer.shouldFailCompleteLogSegment()) {\n-                    FutureUtils.setException(promise,\n+                    FutureUtils.completeExceptionally(promise,\n                             new IOException(\"LogSegmentWriter for \" + writer.getFullyQualifiedLogSegment() + \" is already in error.\"));\n                     return;\n                 }\n@@ -704,7 +703,7 @@ public void onSuccess(Void value) {\n \n             @Override\n             public void onFailure(Throwable cause) {\n-                FutureUtils.setException(promise, cause);\n+                FutureUtils.completeExceptionally(promise, cause);\n             }\n         });\n     }\n@@ -791,7 +790,7 @@ protected LogSegmentMetadata doCompleteAndCloseLogSegment(\n             int recordCount,\n             long lastEntryId,\n             long lastSlotId) throws IOException {\n-        Promise<LogSegmentMetadata> promise = new Promise<LogSegmentMetadata>();\n+        CompletableFuture<LogSegmentMetadata> promise = new CompletableFuture<LogSegmentMetadata>();\n         doCompleteAndCloseLogSegment(\n                 inprogressZnodeName,\n                 logSegmentSeqNo,\n@@ -802,7 +801,7 @@ protected LogSegmentMetadata doCompleteAndCloseLogSegment(\n                 lastEntryId,\n                 lastSlotId,\n                 promise);\n-        return FutureUtils.result(promise);\n+        return Utils.ioResult(promise);\n     }\n \n     protected void doCompleteAndCloseLogSegment(final String inprogressZnodeName,\n@@ -813,11 +812,11 @@ protected void doCompleteAndCloseLogSegment(final String inprogressZnodeName,\n                                                 final int recordCount,\n                                                 final long lastEntryId,\n                                                 final long lastSlotId,\n-                                                final Promise<LogSegmentMetadata> promise) {\n-        fetchForWrite.addEventListener(new FutureEventListener<Versioned<List<LogSegmentMetadata>>>() {\n+                                                final CompletableFuture<LogSegmentMetadata> promise) {\n+        fetchForWrite.whenComplete(new FutureEventListener<Versioned<List<LogSegmentMetadata>>>() {\n             @Override\n             public void onFailure(Throwable cause) {\n-                FutureUtils.setException(promise, cause);\n+                FutureUtils.completeExceptionally(promise, cause);\n             }\n \n             @Override\n@@ -845,11 +844,11 @@ private void doCompleteAndCloseLogSegmentAfterLogSegmentListFetched(\n             int recordCount,\n             long lastEntryId,\n             long lastSlotId,\n-            final Promise<LogSegmentMetadata> promise) {\n+            final CompletableFuture<LogSegmentMetadata> promise) {\n         try {\n             lock.checkOwnershipAndReacquire();\n         } catch (IOException ioe) {\n-            FutureUtils.setException(promise, ioe);\n+            FutureUtils.completeExceptionally(promise, ioe);\n             return;\n         }\n \n@@ -858,23 +857,23 @@ private void doCompleteAndCloseLogSegmentAfterLogSegmentListFetched(\n \n         // validate log segment\n         if (inprogressLogSegment.getLogSegmentId() != logSegmentId) {\n-            FutureUtils.setException(promise, new IOException(\n+            FutureUtils.completeExceptionally(promise, new IOException(\n                 \"Active ledger has different ID to inprogress. \"\n                     + inprogressLogSegment.getLogSegmentId() + \" found, \"\n                     + logSegmentId + \" expected\"));\n             return;\n         }\n         // validate the transaction id\n         if (inprogressLogSegment.getFirstTxId() != firstTxId) {\n-            FutureUtils.setException(promise, new IOException(\"Transaction id not as expected, \"\n+            FutureUtils.completeExceptionally(promise, new IOException(\"Transaction id not as expected, \"\n                 + inprogressLogSegment.getFirstTxId() + \" found, \" + firstTxId + \" expected\"));\n             return;\n         }\n         // validate the log sequence number\n         if (validateLogSegmentSequenceNumber) {\n             synchronized (inprogressLSSNs) {\n                 if (inprogressLSSNs.isEmpty()) {\n-                    FutureUtils.setException(promise, new UnexpectedException(\n+                    FutureUtils.completeExceptionally(promise, new UnexpectedException(\n                             \"Didn't find matched inprogress log segments when completing inprogress \"\n                                     + inprogressLogSegment));\n                     return;\n@@ -886,7 +885,7 @@ private void doCompleteAndCloseLogSegmentAfterLogSegmentListFetched(\n                 // it should also be same as the least inprogress log segment sequence number tracked in {@link inprogressLSSNs}\n                 if ((inprogressLogSegment.getLogSegmentSequenceNumber() != logSegmentSeqNo) ||\n                         (leastInprogressLSSN != logSegmentSeqNo)) {\n-                    FutureUtils.setException(promise, new UnexpectedException(\n+                    FutureUtils.completeExceptionally(promise, new UnexpectedException(\n                             \"Didn't find matched inprogress log segments when completing inprogress \"\n                                     + inprogressLogSegment));\n                     return;\n@@ -906,7 +905,7 @@ private void doCompleteAndCloseLogSegmentAfterLogSegmentListFetched(\n             LOG.warn(\"Unexpected max ledger sequence number {} found while completing log segment {} for {}\",\n                     new Object[] { maxLogSegmentSequenceNo.getSequenceNumber(), logSegmentSeqNo, getFullyQualifiedName() });\n             if (validateLogSegmentSequenceNumber) {\n-                FutureUtils.setException(promise, new DLIllegalStateException(\"Unexpected max log segment sequence number \"\n+                FutureUtils.completeExceptionally(promise, new DLIllegalStateException(\"Unexpected max log segment sequence number \"\n                         + maxLogSegmentSequenceNo.getSequenceNumber() + \" for \" + getFullyQualifiedName()\n                         + \", expected \" + (logSegmentSeqNo - 1)));\n                 return;\n@@ -919,7 +918,7 @@ private void doCompleteAndCloseLogSegmentAfterLogSegmentListFetched(\n         try {\n             startSequenceId = computeStartSequenceId(inprogressLogSegment);\n         } catch (IOException ioe) {\n-            FutureUtils.setException(promise, ioe);\n+            FutureUtils.completeExceptionally(promise, ioe);\n             return;\n         }\n         // write completed ledger znode\n@@ -946,50 +945,45 @@ private void doCompleteAndCloseLogSegmentAfterLogSegmentListFetched(\n         LOG.debug(\"Trying storing LastTxId in Finalize Path {} LastTxId {}\", pathForCompletedLedger, lastTxId);\n         storeMaxTxId(txn, maxTxId, lastTxId);\n \n-        txn.execute().addEventListener(FutureEventListenerRunnable.of(new FutureEventListener<Void>() {\n+        txn.execute().whenCompleteAsync(new FutureEventListener<Void>() {\n             @Override\n             public void onSuccess(Void value) {\n                 LOG.info(\"Completed {} to {} for {} : {}\",\n                         new Object[] { inprogressZnodeName, completedLogSegment.getSegmentName(),\n                                 getFullyQualifiedName(), completedLogSegment });\n-                FutureUtils.setValue(promise, completedLogSegment);\n+                FutureUtils.complete(promise, completedLogSegment);\n             }\n \n             @Override\n             public void onFailure(Throwable cause) {\n-                FutureUtils.setException(promise, cause);\n+                FutureUtils.completeExceptionally(promise, cause);\n             }\n-        }, scheduler));\n+        }, scheduler);\n     }\n \n-    public Future<Long> recoverIncompleteLogSegments() {\n+    public CompletableFuture<Long> recoverIncompleteLogSegments() {\n         try {\n             FailpointUtils.checkFailPoint(FailpointUtils.FailPointName.FP_RecoverIncompleteLogSegments);\n         } catch (IOException ioe) {\n-            return Future.exception(ioe);\n+            return FutureUtils.exception(ioe);\n         }\n-        return getCachedLogSegmentsAfterFirstFetch(LogSegmentMetadata.COMPARATOR).flatMap(recoverLogSegmentsFunction);\n+        return getCachedLogSegmentsAfterFirstFetch(LogSegmentMetadata.COMPARATOR).thenCompose(recoverLogSegmentsFunction);\n     }\n \n-    class RecoverLogSegmentFunction extends Function<LogSegmentMetadata, Future<LogSegmentMetadata>> {\n+    class RecoverLogSegmentFunction implements Function<LogSegmentMetadata, CompletableFuture<LogSegmentMetadata>> {\n \n         @Override\n-        public Future<LogSegmentMetadata> apply(final LogSegmentMetadata l) {\n+        public CompletableFuture<LogSegmentMetadata> apply(final LogSegmentMetadata l) {\n             if (!l.isInProgress()) {\n-                return Future.value(l);\n+                return FutureUtils.value(l);\n             }\n \n             LOG.info(\"Recovering last record in log segment {} for {}.\", l, getFullyQualifiedName());\n-            return asyncReadLastRecord(l, true, true, true).flatMap(\n-                    new AbstractFunction1<LogRecordWithDLSN, Future<LogSegmentMetadata>>() {\n-                        @Override\n-                        public Future<LogSegmentMetadata> apply(LogRecordWithDLSN lastRecord) {\n-                            return completeLogSegment(l, lastRecord);\n-                        }\n-                    });\n+            return asyncReadLastRecord(l, true, true, true).thenCompose(\n+                lastRecord -> completeLogSegment(l, lastRecord));\n         }\n \n-        private Future<LogSegmentMetadata> completeLogSegment(LogSegmentMetadata l,\n+        private CompletableFuture<LogSegmentMetadata> completeLogSegment(LogSegmentMetadata l,\n                                                               LogRecordWithDLSN lastRecord) {\n             LOG.info(\"Recovered last record in log segment {} for {}.\", l, getFullyQualifiedName());\n \n@@ -1009,14 +1003,14 @@ private Future<LogSegmentMetadata> completeLogSegment(LogSegmentMetadata l,\n                 LOG.error(\"Unrecoverable corruption has occurred in segment \"\n                     + l.toString() + \" at path \" + l.getZkPath()\n                     + \". Unable to continue recovery.\");\n-                return Future.exception(new IOException(\"Unrecoverable corruption,\"\n+                return FutureUtils.exception(new IOException(\"Unrecoverable corruption,\"\n                     + \" please check logs.\"));\n             } else if (endTxId == DistributedLogConstants.EMPTY_LOGSEGMENT_TX_ID) {\n                 // TODO: Empty ledger - Ideally we should just remove it?\n                 endTxId = l.getFirstTxId();\n             }\n \n-            Promise<LogSegmentMetadata> promise = new Promise<LogSegmentMetadata>();\n+            CompletableFuture<LogSegmentMetadata> promise = new CompletableFuture<LogSegmentMetadata>();\n             doCompleteAndCloseLogSegment(\n                     l.getZNodeName(),\n                     l.getLogSegmentSequenceNumber(),\n@@ -1032,21 +1026,16 @@ private Future<LogSegmentMetadata> completeLogSegment(LogSegmentMetadata l,\n \n     }\n \n-    Future<List<LogSegmentMetadata>> setLogSegmentsOlderThanDLSNTruncated(final DLSN dlsn) {\n+    CompletableFuture<List<LogSegmentMetadata>> setLogSegmentsOlderThanDLSNTruncated(final DLSN dlsn) {\n         if (DLSN.InvalidDLSN == dlsn) {\n             List<LogSegmentMetadata> emptyList = new ArrayList<LogSegmentMetadata>(0);\n-            return Future.value(emptyList);\n+            return FutureUtils.value(emptyList);\n         }\n-        return getCachedLogSegmentsAfterFirstFullFetch(LogSegmentMetadata.COMPARATOR).flatMap(\n-                new AbstractFunction1<List<LogSegmentMetadata>, Future<List<LogSegmentMetadata>>>() {\n-                    @Override\n-                    public Future<List<LogSegmentMetadata>> apply(List<LogSegmentMetadata> logSegments) {\n-                        return setLogSegmentsOlderThanDLSNTruncated(logSegments, dlsn);\n-                    }\n-                });\n+        return getCachedLogSegmentsAfterFirstFullFetch(LogSegmentMetadata.COMPARATOR).thenCompose(\n+            logSegments -> setLogSegmentsOlderThanDLSNTruncated(logSegments, dlsn));\n     }\n \n-    private Future<List<LogSegmentMetadata>> setLogSegmentsOlderThanDLSNTruncated(List<LogSegmentMetadata> logSegments,\n+    private CompletableFuture<List<LogSegmentMetadata>> setLogSegmentsOlderThanDLSNTruncated(List<LogSegmentMetadata> logSegments,\n                                                                                   final DLSN dlsn) {\n         LOG.debug(\"Setting truncation status on logs older than {} from {} for {}\",\n                 new Object[]{dlsn, logSegments, getFullyQualifiedName()});\n@@ -1064,7 +1053,7 @@ private Future<List<LogSegmentMetadata>> setLogSegmentsOlderThanDLSNTruncated(Li\n                     if (null != partialTruncate) {\n                         String logMsg = String.format(\"Potential metadata inconsistency for stream %s at segment %s\", getFullyQualifiedName(), l);\n                         LOG.error(logMsg);\n-                        return Future.exception(new DLIllegalStateException(logMsg));\n+                        return FutureUtils.exception(new DLIllegalStateException(logMsg));\n                     }\n                     LOG.info(\"{}: Partially truncating log segment {} older than {}.\", new Object[] {getFullyQualifiedName(), l, dlsn});\n                     partialTruncate = l;\n@@ -1096,15 +1085,15 @@ private int getNumCandidateLogSegmentsToPurge(List<LogSegmentMetadata> logSegmen\n         }\n     }\n \n-    Future<List<LogSegmentMetadata>> purgeLogSegmentsOlderThanTimestamp(final long minTimestampToKeep) {\n+    CompletableFuture<List<LogSegmentMetadata>> purgeLogSegmentsOlderThanTimestamp(final long minTimestampToKeep) {\n         if (minTimestampToKeep >= Utils.nowInMillis()) {\n-            return Future.exception(new IllegalArgumentException(\n+            return FutureUtils.exception(new IllegalArgumentException(\n                     \"Invalid timestamp \" + minTimestampToKeep + \" to purge logs for \" + getFullyQualifiedName()));\n         }\n-        return getCachedLogSegmentsAfterFirstFullFetch(LogSegmentMetadata.COMPARATOR).flatMap(\n-                new Function<List<LogSegmentMetadata>, Future<List<LogSegmentMetadata>>>() {\n+        return getCachedLogSegmentsAfterFirstFullFetch(LogSegmentMetadata.COMPARATOR).thenCompose(\n+                new Function<List<LogSegmentMetadata>, CompletableFuture<List<LogSegmentMetadata>>>() {\n             @Override\n-            public Future<List<LogSegmentMetadata>> apply(List<LogSegmentMetadata> logSegments) {\n+            public CompletableFuture<List<LogSegmentMetadata>> apply(List<LogSegmentMetadata> logSegments) {\n                 List<LogSegmentMetadata> purgeList = new ArrayList<LogSegmentMetadata>(logSegments.size());\n \n                 int numCandidates = getNumCandidateLogSegmentsToPurge(logSegments);\n@@ -1129,38 +1118,35 @@ public Future<List<LogSegmentMetadata>> apply(List<LogSegmentMetadata> logSegmen\n         });\n     }\n \n-    Future<List<LogSegmentMetadata>> purgeLogSegmentsOlderThanTxnId(final long minTxIdToKeep) {\n-        return getCachedLogSegmentsAfterFirstFullFetch(LogSegmentMetadata.COMPARATOR).flatMap(\n-            new AbstractFunction1<List<LogSegmentMetadata>, Future<List<LogSegmentMetadata>>>() {\n-                @Override\n-                public Future<List<LogSegmentMetadata>> apply(List<LogSegmentMetadata> logSegments) {\n-                    int numLogSegmentsToProcess;\n+    CompletableFuture<List<LogSegmentMetadata>> purgeLogSegmentsOlderThanTxnId(final long minTxIdToKeep) {\n+        return getCachedLogSegmentsAfterFirstFullFetch(LogSegmentMetadata.COMPARATOR).thenCompose(\n+            logSegments -> {\n+                int numLogSegmentsToProcess;\n \n-                    if (minTxIdToKeep < 0) {\n-                        // we are deleting the log, we can remove whole log segments\n-                        numLogSegmentsToProcess = logSegments.size();\n+                if (minTxIdToKeep < 0) {\n+                    // we are deleting the log, we can remove whole log segments\n+                    numLogSegmentsToProcess = logSegments.size();\n+                } else {\n+                    numLogSegmentsToProcess = getNumCandidateLogSegmentsToPurge(logSegments);\n+                }\n+                List<LogSegmentMetadata> purgeList = Lists.newArrayListWithExpectedSize(numLogSegmentsToProcess);\n+                for (int iterator = 0; iterator < numLogSegmentsToProcess; iterator++) {\n+                    LogSegmentMetadata l = logSegments.get(iterator);\n+                    if ((minTxIdToKeep < 0) ||\n+                        ((l.isTruncated() || !conf.getExplicitTruncationByApplication()) &&\n+                        !l.isInProgress() && (l.getLastTxId() < minTxIdToKeep))) {\n+                        purgeList.add(l);\n                     } else {\n-                        numLogSegmentsToProcess = getNumCandidateLogSegmentsToPurge(logSegments);\n-                    }\n-                    List<LogSegmentMetadata> purgeList = Lists.newArrayListWithExpectedSize(numLogSegmentsToProcess);\n-                    for (int iterator = 0; iterator < numLogSegmentsToProcess; iterator++) {\n-                        LogSegmentMetadata l = logSegments.get(iterator);\n-                        if ((minTxIdToKeep < 0) ||\n-                            ((l.isTruncated() || !conf.getExplicitTruncationByApplication()) &&\n-                            !l.isInProgress() && (l.getLastTxId() < minTxIdToKeep))) {\n-                            purgeList.add(l);\n-                        } else {\n-                            // stop truncating log segments if we find either an inprogress or a partially\n-                            // truncated log segment\n-                            break;\n-                        }\n+                        // stop truncating log segments if we find either an inprogress or a partially\n+                        // truncated log segment\n+                        break;\n                     }\n-                    return deleteLogSegments(purgeList);\n                 }\n+                return deleteLogSegments(purgeList);\n             });\n     }\n \n-    private Future<List<LogSegmentMetadata>> setLogSegmentTruncationStatus(\n+    private CompletableFuture<List<LogSegmentMetadata>> setLogSegmentTruncationStatus(\n             final List<LogSegmentMetadata> truncateList,\n             LogSegmentMetadata partialTruncate,\n             DLSN minActiveDLSN) {\n@@ -1183,39 +1169,31 @@ private Future<List<LogSegmentMetadata>> setLogSegmentTruncationStatus(\n             listAfterTruncated.add(newSegment);\n         }\n \n-        return updateTxn.execute().map(new AbstractFunction1<Void, List<LogSegmentMetadata>>() {\n-            @Override\n-            public List<LogSegmentMetadata> apply(Void value) {\n-                for (int i = 0; i < listToTruncate.size(); i++) {\n-                    removeLogSegmentFromCache(listToTruncate.get(i).getSegmentName());\n-                    LogSegmentMetadata newSegment = listAfterTruncated.get(i);\n-                    addLogSegmentToCache(newSegment.getSegmentName(), newSegment);\n-                }\n-                return listAfterTruncated;\n+        return updateTxn.execute().thenApply(value -> {\n+            for (int i = 0; i < listToTruncate.size(); i++) {\n+                removeLogSegmentFromCache(listToTruncate.get(i).getSegmentName());\n+                LogSegmentMetadata newSegment = listAfterTruncated.get(i);\n+                addLogSegmentToCache(newSegment.getSegmentName(), newSegment);\n             }\n+            return listAfterTruncated;\n         });\n     }\n \n-    private Future<List<LogSegmentMetadata>> deleteLogSegments(\n+    private CompletableFuture<List<LogSegmentMetadata>> deleteLogSegments(\n             final List<LogSegmentMetadata> logs) {\n         if (LOG.isTraceEnabled()) {\n             LOG.trace(\"Purging logs for {} : {}\", getFullyQualifiedName(), logs);\n         }\n         return FutureUtils.processList(logs,\n-                new Function<LogSegmentMetadata, Future<LogSegmentMetadata>>() {\n-            @Override\n-            public Future<LogSegmentMetadata> apply(LogSegmentMetadata segment) {\n-                return deleteLogSegment(segment);\n-            }\n-        }, scheduler);\n+            segment -> deleteLogSegment(segment), scheduler);\n     }\n \n-    private Future<LogSegmentMetadata> deleteLogSegment(\n+    private CompletableFuture<LogSegmentMetadata> deleteLogSegment(\n             final LogSegmentMetadata ledgerMetadata) {\n         LOG.info(\"Deleting ledger {} for {}\", ledgerMetadata, getFullyQualifiedName());\n-        final Promise<LogSegmentMetadata> promise = new Promise<LogSegmentMetadata>();\n+        final CompletableFuture<LogSegmentMetadata> promise = new CompletableFuture<LogSegmentMetadata>();\n         final Stopwatch stopwatch = Stopwatch.createStarted();\n-        promise.addEventListener(new FutureEventListener<LogSegmentMetadata>() {\n+        promise.whenComplete(new FutureEventListener<LogSegmentMetadata>() {\n             @Override\n             public void onSuccess(LogSegmentMetadata segment) {\n                 deleteOpStats.registerSuccessfulEvent(stopwatch.stop().elapsed(TimeUnit.MICROSECONDS));\n@@ -1227,10 +1205,10 @@ public void onFailure(Throwable cause) {\n             }\n         });\n         entryStore.deleteLogSegment(ledgerMetadata)\n-                .addEventListener(new FutureEventListener<LogSegmentMetadata>() {\n+                .whenComplete(new FutureEventListener<LogSegmentMetadata>() {\n             @Override\n             public void onFailure(Throwable cause) {\n-                FutureUtils.setException(promise, cause);\n+                FutureUtils.completeExceptionally(promise, cause);\n             }\n \n             @Override\n@@ -1242,42 +1220,42 @@ public void onSuccess(LogSegmentMetadata segment) {\n     }\n \n     private void deleteLogSegmentMetadata(final LogSegmentMetadata segmentMetadata,\n-                                          final Promise<LogSegmentMetadata> promise) {\n+                                          final CompletableFuture<LogSegmentMetadata> promise) {\n         Transaction<Object> deleteTxn = metadataStore.transaction();\n         metadataStore.deleteLogSegment(deleteTxn, segmentMetadata, new Transaction.OpListener<Void>() {\n             @Override\n             public void onCommit(Void r) {\n                 // purge log segment\n                 removeLogSegmentFromCache(segmentMetadata.getZNodeName());\n-                promise.setValue(segmentMetadata);\n+                promise.complete(segmentMetadata);\n             }\n \n             @Override\n             public void onAbort(Throwable t) {\n                 if (t instanceof LogSegmentNotFoundException) {\n                     // purge log segment\n                     removeLogSegmentFromCache(segmentMetadata.getZNodeName());\n-                    promise.setValue(segmentMetadata);\n+                    promise.complete(segmentMetadata);\n                     return;\n                 } else {\n                     LOG.error(\"Couldn't purge {} for {}: with error {}\",\n                             new Object[]{ segmentMetadata, getFullyQualifiedName(), t });\n-                    promise.setException(t);\n+                    promise.completeExceptionally(t);\n                 }\n             }\n         });\n         deleteTxn.execute();\n     }\n \n     @Override\n-    public Future<Void> asyncClose() {\n+    public CompletableFuture<Void> asyncClose() {\n         return Utils.closeSequence(scheduler,\n                 lock,\n                 logSegmentAllocator);\n     }\n \n     @Override\n-    public Future<Void> asyncAbort() {\n+    public CompletableFuture<Void> asyncAbort() {\n         return asyncClose();\n     }\n "},{"sha":"47301b583f0e826dc79f63363f56fd1116b0d91a","filename":"src/main/java/org/apache/distributedlog/BKSyncLogReader.java","status":"modified","additions":19,"deletions":22,"changes":41,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FBKSyncLogReader.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FBKSyncLogReader.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FBKSyncLogReader.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -20,17 +20,15 @@\n import com.google.common.annotations.VisibleForTesting;\n import com.google.common.base.Optional;\n import com.google.common.base.Ticker;\n+import java.util.concurrent.CompletableFuture;\n+import org.apache.distributedlog.api.AsyncLogReader;\n+import org.apache.distributedlog.api.LogReader;\n import org.apache.distributedlog.exceptions.EndOfStreamException;\n import org.apache.distributedlog.exceptions.IdleReaderException;\n-import org.apache.distributedlog.util.FutureUtils;\n+import org.apache.distributedlog.common.concurrent.FutureUtils;\n import org.apache.distributedlog.util.Utils;\n-import com.twitter.util.Future;\n-import com.twitter.util.Promise;\n import org.apache.bookkeeper.stats.Counter;\n import org.apache.bookkeeper.stats.StatsLogger;\n-import org.apache.bookkeeper.versioning.Versioned;\n-import scala.runtime.AbstractFunction1;\n-import scala.runtime.BoxedUnit;\n \n import java.io.IOException;\n import java.util.LinkedList;\n@@ -48,7 +46,7 @@ class BKSyncLogReader implements LogReader, AsyncNotification {\n     private final AtomicReference<IOException> readerException =\n             new AtomicReference<IOException>(null);\n     private final int maxReadAheadWaitTime;\n-    private Promise<Void> closeFuture;\n+    private CompletableFuture<Void> closeFuture;\n     private final Optional<Long> startTransactionId;\n     private boolean positioned = false;\n     private Entry.Reader currentEntry = null;\n@@ -101,13 +99,10 @@ private void startReadAhead(DLSN startDLSN) throws IOException {\n                     bkdlm.alertStatsLogger);\n         readHandler.registerListener(readAheadReader);\n         readHandler.asyncStartFetchLogSegments()\n-                .map(new AbstractFunction1<Versioned<List<LogSegmentMetadata>>, BoxedUnit>() {\n-                    @Override\n-                    public BoxedUnit apply(Versioned<List<LogSegmentMetadata>> logSegments) {\n-                        readAheadReader.addStateChangeNotification(BKSyncLogReader.this);\n-                        readAheadReader.start(logSegments.getValue());\n-                        return BoxedUnit.UNIT;\n-                    }\n+                .thenApply(logSegments -> {\n+                    readAheadReader.addStateChangeNotification(BKSyncLogReader.this);\n+                    readAheadReader.start(logSegments.getValue());\n+                    return null;\n                 });\n     }\n \n@@ -234,26 +229,28 @@ public synchronized List<LogRecordWithDLSN> readBulk(boolean nonBlocking, int nu\n     }\n \n     @Override\n-    public Future<Void> asyncClose() {\n-        Promise<Void> closePromise;\n+    public CompletableFuture<Void> asyncClose() {\n+        CompletableFuture<Void> closePromise;\n         synchronized (this) {\n             if (null != closeFuture) {\n                 return closeFuture;\n             }\n-            closeFuture = closePromise = new Promise<Void>();\n+            closeFuture = closePromise = new CompletableFuture<Void>();\n         }\n         readHandler.unregisterListener(readAheadReader);\n         readAheadReader.removeStateChangeNotification(this);\n-        Utils.closeSequence(bkdlm.getScheduler(), true,\n-                readAheadReader,\n-                readHandler\n-        ).proxyTo(closePromise);\n+        FutureUtils.proxyTo(\n+            Utils.closeSequence(bkdlm.getScheduler(), true,\n+                    readAheadReader,\n+                    readHandler\n+            ),\n+            closePromise);\n         return closePromise;\n     }\n \n     @Override\n     public void close() throws IOException {\n-        FutureUtils.result(asyncClose());\n+        Utils.ioResult(asyncClose());\n     }\n \n     //"},{"sha":"15296b240924aa891a5a941d6e0a09a7834c8d9a","filename":"src/main/java/org/apache/distributedlog/BKSyncLogWriter.java","status":"modified","additions":6,"deletions":6,"changes":12,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FBKSyncLogWriter.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FBKSyncLogWriter.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FBKSyncLogWriter.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -17,11 +17,11 @@\n  */\n package org.apache.distributedlog;\n \n-import org.apache.distributedlog.config.DynamicDistributedLogConfiguration;\n-import org.apache.distributedlog.util.FutureUtils;\n-\n import java.io.IOException;\n import java.util.List;\n+import org.apache.distributedlog.api.LogWriter;\n+import org.apache.distributedlog.config.DynamicDistributedLogConfiguration;\n+import org.apache.distributedlog.util.Utils;\n \n class BKSyncLogWriter extends BKAbstractLogWriter implements LogWriter {\n \n@@ -59,7 +59,7 @@ public int writeBulk(List<LogRecord> records) throws IOException {\n      */\n     @Override\n     public void markEndOfStream() throws IOException {\n-        FutureUtils.result(getLedgerWriter(DistributedLogConstants.MAX_TXID, true).markEndOfStream());\n+        Utils.ioResult(getLedgerWriter(DistributedLogConstants.MAX_TXID, true).markEndOfStream());\n         closeAndComplete();\n     }\n \n@@ -73,7 +73,7 @@ public long setReadyToFlush() throws IOException {\n         long highestTransactionId = 0;\n         BKLogSegmentWriter writer = getCachedLogWriter();\n         if (null != writer) {\n-            highestTransactionId = Math.max(highestTransactionId, FutureUtils.result(writer.flush()));\n+            highestTransactionId = Math.max(highestTransactionId, Utils.ioResult(writer.flush()));\n         }\n         return highestTransactionId;\n     }\n@@ -93,7 +93,7 @@ public long flushAndSync() throws IOException {\n         long highestTransactionId = 0;\n         BKLogSegmentWriter writer = getCachedLogWriter();\n         if (null != writer) {\n-            highestTransactionId = Math.max(highestTransactionId, FutureUtils.result(writer.commit()));\n+            highestTransactionId = Math.max(highestTransactionId, Utils.ioResult(writer.commit()));\n             LOG.debug(\"FlushAndSync Completed\");\n         } else {\n             LOG.debug(\"FlushAndSync Completed - Nothing to Flush\");"},{"sha":"371532778a5970bdd65ae1065ae151b1462f66ce","filename":"src/main/java/org/apache/distributedlog/BKTransmitPacket.java","status":"modified","additions":9,"deletions":12,"changes":21,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FBKTransmitPacket.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FBKTransmitPacket.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FBKTransmitPacket.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -17,30 +17,28 @@\n  */\n package org.apache.distributedlog;\n \n-import com.twitter.util.Await;\n-import com.twitter.util.Duration;\n-import com.twitter.util.FutureEventListener;\n-import com.twitter.util.Promise;\n-\n+import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.TimeUnit;\n+import org.apache.distributedlog.common.concurrent.FutureEventListener;\n+import org.apache.distributedlog.common.concurrent.FutureUtils;\n \n class BKTransmitPacket {\n \n     private final EntryBuffer recordSet;\n     private final long transmitTime;\n-    private final Promise<Integer> transmitComplete;\n+    private final CompletableFuture<Integer> transmitComplete;\n \n     BKTransmitPacket(EntryBuffer recordSet) {\n         this.recordSet = recordSet;\n         this.transmitTime = System.nanoTime();\n-        this.transmitComplete = new Promise<Integer>();\n+        this.transmitComplete = new CompletableFuture<Integer>();\n     }\n \n     EntryBuffer getRecordSet() {\n         return recordSet;\n     }\n \n-    Promise<Integer> getTransmitFuture() {\n+    CompletableFuture<Integer> getTransmitFuture() {\n         return transmitComplete;\n     }\n \n@@ -53,7 +51,7 @@ Promise<Integer> getTransmitFuture() {\n      *          transmit result code.\n      */\n     public void notifyTransmitComplete(int transmitResult) {\n-        transmitComplete.setValue(transmitResult);\n+        transmitComplete.complete(transmitResult);\n     }\n \n     /**\n@@ -66,7 +64,7 @@ public void notifyTransmitComplete(int transmitResult) {\n      * @see #awaitTransmitComplete(long, TimeUnit)\n      */\n     void addTransmitCompleteListener(FutureEventListener<Integer> transmitCompleteListener) {\n-        transmitComplete.addEventListener(transmitCompleteListener);\n+        transmitComplete.whenComplete(transmitCompleteListener);\n     }\n \n     /**\n@@ -79,8 +77,7 @@ void addTransmitCompleteListener(FutureEventListener<Integer> transmitCompleteLi\n      */\n     int awaitTransmitComplete(long timeout, TimeUnit unit)\n         throws Exception {\n-        return Await.result(transmitComplete,\n-                Duration.fromTimeUnit(timeout, unit));\n+        return FutureUtils.result(transmitComplete, timeout, unit);\n     }\n \n     public long getTransmitTime() {"},{"sha":"2ea3b5d3517b482418460563b2dedbb702c43f49","filename":"src/main/java/org/apache/distributedlog/BookKeeperClient.java","status":"modified","additions":23,"deletions":25,"changes":48,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FBookKeeperClient.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FBookKeeperClient.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FBookKeeperClient.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -18,17 +18,7 @@\n package org.apache.distributedlog;\n \n import com.google.common.base.Optional;\n-import org.apache.distributedlog.ZooKeeperClient.Credentials;\n-import org.apache.distributedlog.ZooKeeperClient.DigestCredentials;\n-import org.apache.distributedlog.exceptions.AlreadyClosedException;\n-import org.apache.distributedlog.exceptions.DLInterruptedException;\n-import org.apache.distributedlog.exceptions.ZKException;\n-import org.apache.distributedlog.net.NetUtils;\n-import org.apache.distributedlog.util.ConfUtils;\n-import com.twitter.util.Future;\n-import com.twitter.util.Promise;\n-import com.twitter.util.Return;\n-import com.twitter.util.Throw;\n+import java.util.concurrent.CompletableFuture;\n import org.apache.bookkeeper.client.AsyncCallback;\n import org.apache.bookkeeper.client.BKException;\n import org.apache.bookkeeper.client.BookKeeper;\n@@ -41,6 +31,14 @@\n import org.apache.bookkeeper.zookeeper.BoundExponentialBackoffRetryPolicy;\n import org.apache.bookkeeper.zookeeper.RetryPolicy;\n import org.apache.commons.configuration.ConfigurationException;\n+import org.apache.distributedlog.ZooKeeperClient.Credentials;\n+import org.apache.distributedlog.ZooKeeperClient.DigestCredentials;\n+import org.apache.distributedlog.exceptions.AlreadyClosedException;\n+import org.apache.distributedlog.exceptions.DLInterruptedException;\n+import org.apache.distributedlog.exceptions.ZKException;\n+import org.apache.distributedlog.net.NetUtils;\n+import org.apache.distributedlog.util.ConfUtils;\n+import org.apache.distributedlog.common.concurrent.FutureUtils;\n import org.apache.zookeeper.KeeperException;\n import org.jboss.netty.channel.socket.ClientSocketChannelFactory;\n import org.jboss.netty.util.HashedWheelTimer;\n@@ -198,52 +196,52 @@ public synchronized BookKeeper get() throws IOException {\n     }\n \n     // Util functions\n-    public Future<LedgerHandle> createLedger(int ensembleSize,\n-                                             int writeQuorumSize,\n-                                             int ackQuorumSize) {\n+    public CompletableFuture<LedgerHandle> createLedger(int ensembleSize,\n+                                                        int writeQuorumSize,\n+                                                        int ackQuorumSize) {\n         BookKeeper bk;\n         try {\n             bk = get();\n         } catch (IOException ioe) {\n-            return Future.exception(ioe);\n+            return FutureUtils.exception(ioe);\n         }\n-        final Promise<LedgerHandle> promise = new Promise<LedgerHandle>();\n+        final CompletableFuture<LedgerHandle> promise = new CompletableFuture<LedgerHandle>();\n         bk.asyncCreateLedger(ensembleSize, writeQuorumSize, ackQuorumSize,\n                 BookKeeper.DigestType.CRC32, passwd, new AsyncCallback.CreateCallback() {\n                     @Override\n                     public void createComplete(int rc, LedgerHandle lh, Object ctx) {\n                         if (BKException.Code.OK == rc) {\n-                            promise.updateIfEmpty(new Return<LedgerHandle>(lh));\n+                            promise.complete(lh);\n                         } else {\n-                            promise.updateIfEmpty(new Throw<LedgerHandle>(BKException.create(rc)));\n+                            promise.completeExceptionally(BKException.create(rc));\n                         }\n                     }\n                 }, null);\n         return promise;\n     }\n \n-    public Future<Void> deleteLedger(long lid,\n+    public CompletableFuture<Void> deleteLedger(long lid,\n                                      final boolean ignoreNonExistentLedger) {\n         BookKeeper bk;\n         try {\n             bk = get();\n         } catch (IOException ioe) {\n-            return Future.exception(ioe);\n+            return FutureUtils.exception(ioe);\n         }\n-        final Promise<Void> promise = new Promise<Void>();\n+        final CompletableFuture<Void> promise = new CompletableFuture<Void>();\n         bk.asyncDeleteLedger(lid, new AsyncCallback.DeleteCallback() {\n             @Override\n             public void deleteComplete(int rc, Object ctx) {\n                 if (BKException.Code.OK == rc) {\n-                    promise.updateIfEmpty(new Return<Void>(null));\n+                    promise.complete(null);\n                 } else if (BKException.Code.NoSuchLedgerExistsException == rc) {\n                     if (ignoreNonExistentLedger) {\n-                        promise.updateIfEmpty(new Return<Void>(null));\n+                        promise.complete(null);\n                     } else {\n-                        promise.updateIfEmpty(new Throw<Void>(BKException.create(rc)));\n+                        promise.completeExceptionally(BKException.create(rc));\n                     }\n                 } else {\n-                    promise.updateIfEmpty(new Throw<Void>(BKException.create(rc)));\n+                    promise.completeExceptionally(BKException.create(rc));\n                 }\n             }\n         }, null);"},{"sha":"3269f57f14ec2ef8e98d9c1313ae2718dc96cb62","filename":"src/main/java/org/apache/distributedlog/DistributedLogConfiguration.java","status":"modified","additions":3,"deletions":4,"changes":7,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FDistributedLogConfiguration.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FDistributedLogConfiguration.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FDistributedLogConfiguration.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -22,7 +22,7 @@\n import com.google.common.collect.Sets;\n import org.apache.distributedlog.bk.QuorumConfig;\n import org.apache.distributedlog.feature.DefaultFeatureProvider;\n-import org.apache.distributedlog.namespace.DistributedLogNamespaceBuilder;\n+import org.apache.distributedlog.api.namespace.NamespaceBuilder;\n import org.apache.distributedlog.net.DNSResolverForRacks;\n import org.apache.distributedlog.net.DNSResolverForRows;\n import org.apache.bookkeeper.conf.ClientConfiguration;\n@@ -1351,7 +1351,6 @@ public DistributedLogConfiguration setNumLockStateThreads(int numLockStateThread\n      * <p>\n      * The setting is only applied for v2 implementation.\n      *\n-     * @see org.apache.distributedlog.util.MonitoredScheduledThreadPoolExecutor\n      * @return number of resource release threads used by distributedlog namespace.\n      */\n     public int getNumResourceReleaseThreads() {\n@@ -3048,7 +3047,7 @@ public DistributedLogConfiguration setTaskExecutionWarnTimeMicros(long warnTimeM\n     /**\n      * Whether to enable per stream stat or not.\n      *\n-     * @deprecated please use {@link DistributedLogNamespaceBuilder#perLogStatsLogger(StatsLogger)}\n+     * @deprecated please use {@link NamespaceBuilder#perLogStatsLogger(StatsLogger)}\n      * @return flag to enable per stream stat.\n      */\n     public boolean getEnablePerStreamStat() {\n@@ -3058,7 +3057,7 @@ public boolean getEnablePerStreamStat() {\n     /**\n      * Set the flag to enable per stream stat or not.\n      *\n-     * @deprecated please use {@link DistributedLogNamespaceBuilder#perLogStatsLogger(StatsLogger)}\n+     * @deprecated please use {@link NamespaceBuilder#perLogStatsLogger(StatsLogger)}\n      * @param enabled\n      *          flag to enable/disable per stream stat.\n      * @return dl configuration."},{"sha":"30cd4992a2b2b32753ef83a9d7fc09065eac897e","filename":"src/main/java/org/apache/distributedlog/Entry.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FEntry.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FEntry.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FEntry.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -19,10 +19,10 @@\n \n import com.google.common.base.Optional;\n import com.google.common.base.Preconditions;\n+import java.util.concurrent.CompletableFuture;\n import org.apache.distributedlog.exceptions.LogRecordTooLongException;\n import org.apache.distributedlog.exceptions.WriteException;\n import org.apache.distributedlog.io.CompressionCodec;\n-import com.twitter.util.Promise;\n import org.apache.bookkeeper.stats.NullStatsLogger;\n import org.apache.bookkeeper.stats.StatsLogger;\n \n@@ -342,7 +342,7 @@ public interface Writer extends EntryBuffer {\n          * @throws LogRecordTooLongException if the record is too long\n          * @throws WriteException when encountered exception writing the record\n          */\n-        void writeRecord(LogRecord record, Promise<DLSN> transmitPromise)\n+        void writeRecord(LogRecord record, CompletableFuture<DLSN> transmitPromise)\n                 throws LogRecordTooLongException, WriteException;\n \n         /**"},{"sha":"09301aa7b3d4818b17f7045e81b7b749d3d3e377","filename":"src/main/java/org/apache/distributedlog/EnvelopedEntry.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FEnvelopedEntry.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FEnvelopedEntry.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FEnvelopedEntry.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -30,10 +30,10 @@\n import org.apache.bookkeeper.stats.OpStatsLogger;\n import org.apache.bookkeeper.stats.StatsLogger;\n \n-import org.apache.distributedlog.annotations.DistributedLogAnnotations.Compression;\n+import org.apache.distributedlog.common.annotations.DistributedLogAnnotations.Compression;\n import org.apache.distributedlog.io.CompressionCodec;\n import org.apache.distributedlog.io.CompressionUtils;\n-import org.apache.distributedlog.util.BitMaskUtils;\n+import org.apache.distributedlog.common.util.BitMaskUtils;\n \n /**\n  * An enveloped entry written to BookKeeper."},{"sha":"18645d42a7667e18069d7f515b4fcacf7639472d","filename":"src/main/java/org/apache/distributedlog/EnvelopedEntryWriter.java","status":"modified","additions":6,"deletions":6,"changes":12,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FEnvelopedEntryWriter.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FEnvelopedEntryWriter.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FEnvelopedEntryWriter.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -17,14 +17,14 @@\n  */\n package org.apache.distributedlog;\n \n+import java.util.concurrent.CompletableFuture;\n import org.apache.distributedlog.Entry.Writer;\n import org.apache.distributedlog.exceptions.InvalidEnvelopedEntryException;\n import org.apache.distributedlog.exceptions.LogRecordTooLongException;\n import org.apache.distributedlog.exceptions.WriteCancelledException;\n import org.apache.distributedlog.exceptions.WriteException;\n import org.apache.distributedlog.io.Buffer;\n import org.apache.distributedlog.io.CompressionCodec;\n-import com.twitter.util.Promise;\n import org.apache.bookkeeper.stats.StatsLogger;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -46,9 +46,9 @@ class EnvelopedEntryWriter implements Writer {\n     private static class WriteRequest {\n \n         private final int numRecords;\n-        private final Promise<DLSN> promise;\n+        private final CompletableFuture<DLSN> promise;\n \n-        WriteRequest(int numRecords, Promise<DLSN> promise) {\n+        WriteRequest(int numRecords, CompletableFuture<DLSN> promise) {\n             this.numRecords = numRecords;\n             this.promise = promise;\n         }\n@@ -89,7 +89,7 @@ public synchronized void reset() {\n \n     @Override\n     public synchronized void writeRecord(LogRecord record,\n-                                         Promise<DLSN> transmitPromise)\n+                                         CompletableFuture<DLSN> transmitPromise)\n             throws LogRecordTooLongException, WriteException {\n         int logRecordSize = record.getPersistentSize();\n         if (logRecordSize > MAX_LOGRECORD_SIZE) {\n@@ -121,15 +121,15 @@ public synchronized void writeRecord(LogRecord record,\n     private synchronized void satisfyPromises(long lssn, long entryId) {\n         long nextSlotId = 0;\n         for (WriteRequest request : writeRequests) {\n-            request.promise.setValue(new DLSN(lssn, entryId, nextSlotId));\n+            request.promise.complete(new DLSN(lssn, entryId, nextSlotId));\n             nextSlotId += request.numRecords;\n         }\n         writeRequests.clear();\n     }\n \n     private synchronized void cancelPromises(Throwable reason) {\n         for (WriteRequest request : writeRequests) {\n-            request.promise.setException(reason);\n+            request.promise.completeExceptionally(reason);\n         }\n         writeRequests.clear();\n     }"},{"sha":"462ddaaeede83c2d6f6a4748c065767aa9069d42","filename":"src/main/java/org/apache/distributedlog/LogSegmentMetadata.java","status":"modified","additions":11,"deletions":12,"changes":23,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FLogSegmentMetadata.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FLogSegmentMetadata.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FLogSegmentMetadata.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -23,14 +23,13 @@\n \n import com.google.common.annotations.VisibleForTesting;\n import com.google.common.base.Objects;\n+import java.util.concurrent.CompletableFuture;\n import org.apache.distributedlog.exceptions.DLInterruptedException;\n import org.apache.distributedlog.exceptions.LogSegmentNotFoundException;\n import org.apache.distributedlog.exceptions.UnsupportedMetadataVersionException;\n import org.apache.distributedlog.exceptions.ZKException;\n-import org.apache.distributedlog.util.FutureUtils;\n+import org.apache.distributedlog.common.concurrent.FutureUtils;\n import org.apache.distributedlog.util.Utils;\n-import com.twitter.util.Future;\n-import com.twitter.util.Promise;\n import org.apache.zookeeper.AsyncCallback;\n import org.apache.zookeeper.CreateMode;\n import org.apache.zookeeper.KeeperException;\n@@ -590,39 +589,39 @@ LogSegmentMetadata completeLogSegment(String zkPath,\n                 .build();\n     }\n \n-    public static Future<LogSegmentMetadata> read(ZooKeeperClient zkc, String path) {\n+    public static CompletableFuture<LogSegmentMetadata> read(ZooKeeperClient zkc, String path) {\n         return read(zkc, path, false);\n     }\n \n-    public static Future<LogSegmentMetadata> read(ZooKeeperClient zkc, String path, final boolean skipMinVersionCheck) {\n-        final Promise<LogSegmentMetadata> result = new Promise<LogSegmentMetadata>();\n+    public static CompletableFuture<LogSegmentMetadata> read(ZooKeeperClient zkc, String path, final boolean skipMinVersionCheck) {\n+        final CompletableFuture<LogSegmentMetadata> result = new CompletableFuture<LogSegmentMetadata>();\n         try {\n             zkc.get().getData(path, false, new AsyncCallback.DataCallback() {\n                 @Override\n                 public void processResult(int rc, String path, Object ctx, byte[] data, Stat stat) {\n                     if (KeeperException.Code.OK.intValue() != rc) {\n                         if (KeeperException.Code.NONODE.intValue() == rc) {\n-                            FutureUtils.setException(result, new LogSegmentNotFoundException(path));\n+                            FutureUtils.completeExceptionally(result, new LogSegmentNotFoundException(path));\n                         } else {\n-                            FutureUtils.setException(result,\n+                            FutureUtils.completeExceptionally(result,\n                                     new ZKException(\"Failed to read log segment metadata from \" + path,\n                                             KeeperException.Code.get(rc)));\n                         }\n                         return;\n                     }\n                     try {\n                         LogSegmentMetadata metadata = parseData(path, data, skipMinVersionCheck);\n-                        FutureUtils.setValue(result, metadata);\n+                        FutureUtils.complete(result, metadata);\n                     } catch (IOException ie) {\n                         LOG.error(\"Error on parsing log segment metadata from {} : \", path, ie);\n-                        result.setException(ie);\n+                        result.completeExceptionally(ie);\n                     }\n                 }\n             }, null);\n         } catch (ZooKeeperClient.ZooKeeperConnectionException e) {\n-            result.setException(FutureUtils.zkException(e, path));\n+            result.completeExceptionally(Utils.zkException(e, path));\n         } catch (InterruptedException e) {\n-            result.setException(FutureUtils.zkException(e, path));\n+            result.completeExceptionally(Utils.zkException(e, path));\n         }\n         return result;\n     }"},{"sha":"386a9a17bf7f4f18d61d6dd0c23c4b08546d6f59","filename":"src/main/java/org/apache/distributedlog/ReadAheadEntryReader.java","status":"modified","additions":46,"deletions":69,"changes":115,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FReadAheadEntryReader.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FReadAheadEntryReader.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FReadAheadEntryReader.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -21,6 +21,9 @@\n import com.google.common.base.Stopwatch;\n import com.google.common.base.Ticker;\n import com.google.common.collect.Lists;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.function.Function;\n import org.apache.distributedlog.callback.LogSegmentListener;\n import org.apache.distributedlog.exceptions.AlreadyTruncatedTransactionException;\n import org.apache.distributedlog.exceptions.DLIllegalStateException;\n@@ -32,27 +35,20 @@\n import org.apache.distributedlog.logsegment.LogSegmentEntryReader;\n import org.apache.distributedlog.logsegment.LogSegmentEntryStore;\n import org.apache.distributedlog.logsegment.LogSegmentFilter;\n+import org.apache.distributedlog.common.concurrent.FutureEventListener;\n+import org.apache.distributedlog.common.concurrent.FutureUtils;\n import org.apache.distributedlog.util.OrderedScheduler;\n-import com.twitter.util.Function0;\n-import com.twitter.util.Future;\n-import com.twitter.util.FutureEventListener;\n-import com.twitter.util.Futures;\n-import com.twitter.util.Promise;\n import org.apache.bookkeeper.stats.AlertStatsLogger;\n import org.apache.bookkeeper.versioning.Versioned;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n-import scala.Function1;\n-import scala.runtime.AbstractFunction1;\n-import scala.runtime.BoxedUnit;\n \n import java.io.IOException;\n import java.util.LinkedList;\n import java.util.List;\n import java.util.concurrent.CopyOnWriteArraySet;\n import java.util.concurrent.LinkedBlockingQueue;\n import java.util.concurrent.RejectedExecutionException;\n-import java.util.concurrent.ScheduledFuture;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicReference;\n@@ -75,12 +71,9 @@ class ReadAheadEntryReader implements\n     // Static Functions\n     //\n \n-    private static AbstractFunction1<LogSegmentEntryReader, BoxedUnit> START_READER_FUNC = new AbstractFunction1<LogSegmentEntryReader, BoxedUnit>() {\n-        @Override\n-        public BoxedUnit apply(LogSegmentEntryReader reader) {\n-            reader.start();\n-            return BoxedUnit.UNIT;\n-        }\n+    private static Function<LogSegmentEntryReader, Void> START_READER_FUNC = reader -> {\n+        reader.start();\n+        return null;\n     };\n \n     //\n@@ -91,7 +84,7 @@ class SegmentReader implements FutureEventListener<LogSegmentEntryReader> {\n \n         private LogSegmentMetadata metadata;\n         private final long startEntryId;\n-        private Future<LogSegmentEntryReader> openFuture = null;\n+        private CompletableFuture<LogSegmentEntryReader> openFuture = null;\n         private LogSegmentEntryReader reader = null;\n         private boolean isStarted = false;\n         private boolean isClosed = false;\n@@ -122,7 +115,7 @@ synchronized void openReader() {\n             if (null != openFuture) {\n                 return;\n             }\n-            openFuture = entryStore.openReader(metadata, startEntryId).addEventListener(this);\n+            openFuture = entryStore.openReader(metadata, startEntryId).whenComplete(this);\n         }\n \n         synchronized boolean isReaderStarted() {\n@@ -137,16 +130,16 @@ synchronized void startRead() {\n             if (null != reader) {\n                 reader.start();\n             } else {\n-                openFuture.onSuccess(START_READER_FUNC);\n+                openFuture.thenApply(START_READER_FUNC);\n             }\n         }\n \n-        synchronized Future<List<Entry.Reader>> readNext() {\n+        synchronized CompletableFuture<List<Entry.Reader>> readNext() {\n             if (null != reader) {\n                 checkCatchingUpStatus(reader);\n                 return reader.readNext(numReadAheadEntries);\n             } else {\n-                return openFuture.flatMap(readFunc);\n+                return openFuture.thenCompose(readFunc);\n             }\n         }\n \n@@ -155,14 +148,10 @@ synchronized void updateLogSegmentMetadata(final LogSegmentMetadata segment) {\n                 reader.onLogSegmentMetadataUpdated(segment);\n                 this.metadata = segment;\n             } else {\n-                openFuture.onSuccess(new AbstractFunction1<LogSegmentEntryReader, BoxedUnit>() {\n-                    @Override\n-                    public BoxedUnit apply(LogSegmentEntryReader reader) {\n-                        reader.onLogSegmentMetadataUpdated(segment);\n-                        synchronized (SegmentReader.this) {\n-                            SegmentReader.this.metadata = segment;\n-                        }\n-                        return BoxedUnit.UNIT;\n+                openFuture.thenAccept(reader1 -> {\n+                    reader1.onLogSegmentMetadataUpdated(segment);\n+                    synchronized (SegmentReader.this) {\n+                        SegmentReader.this.metadata = segment;\n                     }\n                 });\n             }\n@@ -185,28 +174,21 @@ synchronized boolean isClosed() {\n             return isClosed;\n         }\n \n-        synchronized Future<Void> close() {\n+        synchronized CompletableFuture<Void> close() {\n             if (null == openFuture) {\n-                return Future.Void();\n+                return FutureUtils.Void();\n             }\n-            return openFuture.flatMap(new AbstractFunction1<LogSegmentEntryReader, Future<Void>>() {\n-                @Override\n-                public Future<Void> apply(LogSegmentEntryReader reader) {\n-                    return reader.asyncClose();\n-                }\n-            }).ensure(new Function0<BoxedUnit>() {\n-                @Override\n-                public BoxedUnit apply() {\n+            return FutureUtils.ensure(\n+                openFuture.thenCompose(reader1 -> reader1.asyncClose()),\n+                () -> {\n                     synchronized (SegmentReader.this) {\n                         isClosed = true;\n                     }\n-                    return null;\n-                }\n-            });\n+                });\n         }\n     }\n \n-    private class ReadEntriesFunc extends AbstractFunction1<LogSegmentEntryReader, Future<List<Entry.Reader>>> {\n+    private class ReadEntriesFunc implements Function<LogSegmentEntryReader, CompletableFuture<List<Entry.Reader>>> {\n \n         private final int numEntries;\n \n@@ -215,7 +197,7 @@ private class ReadEntriesFunc extends AbstractFunction1<LogSegmentEntryReader, F\n         }\n \n         @Override\n-        public Future<List<Entry.Reader>> apply(LogSegmentEntryReader reader) {\n+        public CompletableFuture<List<Entry.Reader>> apply(LogSegmentEntryReader reader) {\n             checkCatchingUpStatus(reader);\n             return reader.readNext(numEntries);\n         }\n@@ -244,14 +226,8 @@ public void run() {\n     //\n     // Functions\n     //\n-    private final Function1<LogSegmentEntryReader, Future<List<Entry.Reader>>> readFunc;\n-    private final Function0<BoxedUnit> removeClosedSegmentReadersFunc = new Function0<BoxedUnit>() {\n-        @Override\n-        public BoxedUnit apply() {\n-            removeClosedSegmentReaders();\n-            return BoxedUnit.UNIT;\n-        }\n-    };\n+    private final Function<LogSegmentEntryReader, CompletableFuture<List<Entry.Reader>>> readFunc;\n+    private final Runnable removeClosedSegmentReadersFunc = () -> removeClosedSegmentReaders();\n \n     //\n     // Resources\n@@ -282,7 +258,7 @@ public BoxedUnit apply() {\n     private final AtomicBoolean started = new AtomicBoolean(false);\n     private boolean isInitialized = false;\n     private boolean readAheadPaused = false;\n-    private Promise<Void> closePromise = null;\n+    private CompletableFuture<Void> closePromise = null;\n     // segment readers\n     private long currentSegmentSequenceNumber;\n     private SegmentReader currentSegmentReader;\n@@ -344,15 +320,12 @@ public ReadAheadEntryReader(String streamName,\n \n     private ScheduledFuture<?> scheduleIdleReaderTaskIfNecessary() {\n         if (idleWarnThresholdMillis < Integer.MAX_VALUE && idleWarnThresholdMillis > 0) {\n-            return scheduler.scheduleAtFixedRate(streamName, new Runnable() {\n-                @Override\n-                public void run() {\n-                    if (!isReaderIdle(idleWarnThresholdMillis, TimeUnit.MILLISECONDS)) {\n-                        return;\n-                    }\n-                    // the readahead has been idle\n-                    unsafeCheckIfReadAheadIsIdle();\n+            return scheduler.scheduleAtFixedRate(streamName, () -> {\n+                if (!isReaderIdle(idleWarnThresholdMillis, TimeUnit.MILLISECONDS)) {\n+                    return;\n                 }\n+                // the readahead has been idle\n+                unsafeCheckIfReadAheadIsIdle();\n             }, idleWarnThresholdMillis, idleWarnThresholdMillis, TimeUnit.MILLISECONDS);\n         }\n         return null;\n@@ -366,7 +339,7 @@ private void unsafeCheckIfReadAheadIsIdle() {\n                     LogSegmentMetadata.COMPARATOR,\n                     LogSegmentFilter.DEFAULT_FILTER,\n                     null\n-            ).addEventListener(new FutureEventListener<Versioned<List<LogSegmentMetadata>>>() {\n+            ).whenComplete(new FutureEventListener<Versioned<List<LogSegmentMetadata>>>() {\n                 @Override\n                 public void onFailure(Throwable cause) {\n                     // do nothing here since it would be retried on next idle reader check task\n@@ -459,13 +432,13 @@ private void unsafeRemoveClosedSegmentReaders() {\n     }\n \n     @Override\n-    public Future<Void> asyncClose() {\n-        final Promise<Void> closeFuture;\n+    public CompletableFuture<Void> asyncClose() {\n+        final CompletableFuture<Void> closeFuture;\n         synchronized (this) {\n             if (null != closePromise) {\n                 return closePromise;\n             }\n-            closePromise = closeFuture = new Promise<Void>();\n+            closePromise = closeFuture = new CompletableFuture<Void>();\n         }\n \n         // cancel the idle reader task\n@@ -489,8 +462,8 @@ public void run() {\n         return closeFuture;\n     }\n \n-    private void unsafeAsyncClose(Promise<Void> closePromise) {\n-        List<Future<Void>> closeFutures = Lists.newArrayListWithExpectedSize(\n+    private void unsafeAsyncClose(CompletableFuture<Void> closePromise) {\n+        List<CompletableFuture<Void>> closeFutures = Lists.newArrayListWithExpectedSize(\n                 segmentReaders.size() + segmentReadersToClose.size() + 1);\n         if (null != currentSegmentReader) {\n             segmentReadersToClose.add(currentSegmentReader);\n@@ -505,7 +478,9 @@ private void unsafeAsyncClose(Promise<Void> closePromise) {\n         for (SegmentReader reader : segmentReadersToClose) {\n             closeFutures.add(reader.close());\n         }\n-        Futures.collect(closeFutures).proxyTo(closePromise);\n+        FutureUtils.proxyTo(\n+            FutureUtils.collect(closeFutures).thenApply((value) -> null),\n+            closePromise);\n     }\n \n     //\n@@ -921,7 +896,9 @@ void safeRun() {\n     private void unsafeMoveToNextLogSegment() {\n         if (null != currentSegmentReader) {\n             segmentReadersToClose.add(currentSegmentReader);\n-            currentSegmentReader.close().ensure(removeClosedSegmentReadersFunc);\n+            FutureUtils.ensure(\n+                currentSegmentReader.close(),\n+                removeClosedSegmentReadersFunc);\n             logger.debug(\"close current segment reader {}\", currentSegmentReader.getSegment());\n             currentSegmentReader = null;\n         }\n@@ -971,7 +948,7 @@ void safeRun() {\n     }\n \n     private void unsafeReadNext(SegmentReader reader) {\n-        reader.readNext().addEventListener(this);\n+        reader.readNext().whenComplete(this);\n     }\n \n     @Override"},{"sha":"bf4e140b92ed523982a5cdd388c309617891fb6d","filename":"src/main/java/org/apache/distributedlog/ReadUtils.java","status":"modified","additions":44,"deletions":60,"changes":104,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FReadUtils.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FReadUtils.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FReadUtils.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -19,6 +19,7 @@\n \n import java.io.IOException;\n import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.ExecutorService;\n import java.util.concurrent.atomic.AtomicInteger;\n import java.util.concurrent.atomic.AtomicLong;\n@@ -31,14 +32,10 @@\n import org.apache.distributedlog.selector.FirstTxIdNotLessThanSelector;\n import org.apache.distributedlog.selector.LastRecordSelector;\n import org.apache.distributedlog.selector.LogRecordSelector;\n-import org.apache.distributedlog.util.FutureUtils.FutureEventListenerRunnable;\n-import com.twitter.util.Future;\n-import com.twitter.util.FutureEventListener;\n-import com.twitter.util.Promise;\n+import org.apache.distributedlog.common.concurrent.FutureEventListener;\n+import org.apache.distributedlog.common.concurrent.FutureUtils;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n-import scala.runtime.AbstractFunction0;\n-import scala.runtime.BoxedUnit;\n \n /**\n  * Utility function for readers\n@@ -78,7 +75,7 @@ public class ReadUtils {\n      *          log segment entry store\n      * @return a future with last record.\n      */\n-    public static Future<LogRecordWithDLSN> asyncReadLastRecord(\n+    public static CompletableFuture<LogRecordWithDLSN> asyncReadLastRecord(\n             final String streamName,\n             final LogSegmentMetadata l,\n             final boolean fence,\n@@ -116,7 +113,7 @@ public static Future<LogRecordWithDLSN> asyncReadLastRecord(\n      *          threshold dlsn\n      * @return a future with last record.\n      */\n-    public static Future<LogRecordWithDLSN> asyncReadFirstUserRecord(\n+    public static CompletableFuture<LogRecordWithDLSN> asyncReadFirstUserRecord(\n             final String streamName,\n             final LogSegmentMetadata l,\n             final int scanStartBatchSize,\n@@ -243,14 +240,14 @@ private static class SingleEntryScanContext extends ScanContext {\n      *          scan context\n      * @return a future with the log record.\n      */\n-    private static Future<LogRecordWithDLSN> asyncReadRecordFromEntries(\n+    private static CompletableFuture<LogRecordWithDLSN> asyncReadRecordFromEntries(\n             final String streamName,\n             final LogSegmentRandomAccessEntryReader reader,\n             final LogSegmentMetadata metadata,\n             final ExecutorService executorService,\n             final ScanContext context,\n             final LogRecordSelector selector) {\n-        final Promise<LogRecordWithDLSN> promise = new Promise<LogRecordWithDLSN>();\n+        final CompletableFuture<LogRecordWithDLSN> promise = new CompletableFuture<LogRecordWithDLSN>();\n         final long startEntryId = context.curStartEntryId.get();\n         final long endEntryId = context.curEndEntryId.get();\n         if (LOG.isDebugEnabled()) {\n@@ -271,7 +268,7 @@ public void onSuccess(final List<Entry.Reader> entries) {\n                         } catch (IOException ioe) {\n                             // exception is only thrown due to bad ledger entry, so it might be corrupted\n                             // we shouldn't do anything beyond this point. throw the exception to application\n-                            promise.setException(ioe);\n+                            promise.completeExceptionally(ioe);\n                             return;\n                         }\n                     }\n@@ -282,16 +279,16 @@ public void onSuccess(final List<Entry.Reader> entries) {\n                                 new Object[]{streamName, startEntryId, endEntryId,\n                                         metadata, record});\n                     }\n-                    promise.setValue(record);\n+                    promise.complete(record);\n                 }\n \n                 @Override\n                 public void onFailure(final Throwable cause) {\n-                    promise.setException(cause);\n+                    promise.completeExceptionally(cause);\n                 }\n             };\n         reader.readEntries(startEntryId, endEntryId)\n-                .addEventListener(FutureEventListenerRunnable.of(readEntriesListener, executorService));\n+                .whenCompleteAsync(readEntriesListener, executorService);\n         return promise;\n     }\n \n@@ -343,7 +340,7 @@ private static void asyncReadRecordFromEntries(\n             final LogSegmentRandomAccessEntryReader reader,\n             final LogSegmentMetadata metadata,\n             final ExecutorService executorService,\n-            final Promise<LogRecordWithDLSN> promise,\n+            final CompletableFuture<LogRecordWithDLSN> promise,\n             final ScanContext context,\n             final LogRecordSelector selector) {\n         FutureEventListener<LogRecordWithDLSN> readEntriesListener =\n@@ -356,12 +353,12 @@ public void onSuccess(LogRecordWithDLSN value) {\n                                         metadata, value});\n                     }\n                     if (null != value) {\n-                        promise.setValue(value);\n+                        promise.complete(value);\n                         return;\n                     }\n                     if (!context.moveToNextRange()) {\n                         // no entries to read again\n-                        promise.setValue(null);\n+                        promise.complete(null);\n                         return;\n                     }\n                     // scan next range\n@@ -376,11 +373,11 @@ public void onSuccess(LogRecordWithDLSN value) {\n \n                 @Override\n                 public void onFailure(Throwable cause) {\n-                    promise.setException(cause);\n+                    promise.completeExceptionally(cause);\n                 }\n             };\n         asyncReadRecordFromEntries(streamName, reader, metadata, executorService, context, selector)\n-                .addEventListener(FutureEventListenerRunnable.of(readEntriesListener, executorService));\n+                .whenCompleteAsync(readEntriesListener, executorService);\n     }\n \n     private static void asyncReadRecordFromLogSegment(\n@@ -392,7 +389,7 @@ private static void asyncReadRecordFromLogSegment(\n             final int scanMaxBatchSize,\n             final boolean includeControl,\n             final boolean includeEndOfStream,\n-            final Promise<LogRecordWithDLSN> promise,\n+            final CompletableFuture<LogRecordWithDLSN> promise,\n             final AtomicInteger numRecordsScanned,\n             final LogRecordSelector selector,\n             final boolean backward,\n@@ -402,7 +399,7 @@ private static void asyncReadRecordFromLogSegment(\n             if (LOG.isDebugEnabled()) {\n                 LOG.debug(\"Log segment {} is empty for {}.\", new Object[] { metadata, streamName });\n             }\n-            promise.setValue(null);\n+            promise.complete(null);\n             return;\n         }\n         final ScanContext context = new ScanContext(\n@@ -413,7 +410,7 @@ private static void asyncReadRecordFromLogSegment(\n                                    promise, context, selector);\n     }\n \n-    private static Future<LogRecordWithDLSN> asyncReadRecord(\n+    private static CompletableFuture<LogRecordWithDLSN> asyncReadRecord(\n             final String streamName,\n             final LogSegmentMetadata l,\n             final boolean fence,\n@@ -428,7 +425,7 @@ private static Future<LogRecordWithDLSN> asyncReadRecord(\n             final boolean backward,\n             final long startEntryId) {\n \n-        final Promise<LogRecordWithDLSN> promise = new Promise<LogRecordWithDLSN>();\n+        final CompletableFuture<LogRecordWithDLSN> promise = new CompletableFuture<LogRecordWithDLSN>();\n \n         FutureEventListener<LogSegmentRandomAccessEntryReader> openReaderListener =\n             new FutureEventListener<LogSegmentRandomAccessEntryReader>() {\n@@ -438,13 +435,7 @@ public void onSuccess(final LogSegmentRandomAccessEntryReader reader) {\n                         LOG.debug(\"{} Opened log segment {} for reading record\",\n                                 streamName, l);\n                     }\n-                    promise.ensure(new AbstractFunction0<BoxedUnit>() {\n-                        @Override\n-                        public BoxedUnit apply() {\n-                            reader.asyncClose();\n-                            return BoxedUnit.UNIT;\n-                        }\n-                    });\n+                    promise.whenComplete((value, cause) -> reader.asyncClose());\n                     if (LOG.isDebugEnabled()) {\n                         LOG.debug(\"{} {} scanning {}.\", new Object[]{\n                                 (backward ? \"backward\" : \"forward\"), streamName, l});\n@@ -458,11 +449,11 @@ public BoxedUnit apply() {\n \n                 @Override\n                 public void onFailure(final Throwable cause) {\n-                    promise.setException(cause);\n+                    promise.completeExceptionally(cause);\n                 }\n             };\n         entryStore.openRandomAccessReader(l, fence)\n-                .addEventListener(FutureEventListenerRunnable.of(openReaderListener, executorService));\n+                .whenCompleteAsync(openReaderListener, executorService);\n         return promise;\n     }\n \n@@ -499,7 +490,7 @@ public void onFailure(final Throwable cause) {\n      *          how many number of entries to search in parallel\n      * @return found log record. none if all transaction ids are less than provided <code>transactionId</code>.\n      */\n-    public static Future<Optional<LogRecordWithDLSN>> getLogRecordNotLessThanTxId(\n+    public static CompletableFuture<Optional<LogRecordWithDLSN>> getLogRecordNotLessThanTxId(\n             final String logName,\n             final LogSegmentMetadata segment,\n             final long transactionId,\n@@ -511,30 +502,23 @@ public static Future<Optional<LogRecordWithDLSN>> getLogRecordNotLessThanTxId(\n                 // all log records whose transaction id is less than provided transactionId\n                 // then return none\n                 Optional<LogRecordWithDLSN> noneRecord = Optional.absent();\n-                return Future.value(noneRecord);\n+                return FutureUtils.value(noneRecord);\n             }\n         }\n \n-        final Promise<Optional<LogRecordWithDLSN>> promise =\n-                new Promise<Optional<LogRecordWithDLSN>>();\n+        final CompletableFuture<Optional<LogRecordWithDLSN>> promise =\n+                new CompletableFuture<Optional<LogRecordWithDLSN>>();\n         final FutureEventListener<LogSegmentRandomAccessEntryReader> openReaderListener =\n             new FutureEventListener<LogSegmentRandomAccessEntryReader>() {\n                 @Override\n                 public void onSuccess(final LogSegmentRandomAccessEntryReader reader) {\n-                    promise.ensure(new AbstractFunction0<BoxedUnit>() {\n-                        @Override\n-                        public BoxedUnit apply() {\n-                            reader.asyncClose();\n-                            return BoxedUnit.UNIT;\n-                        }\n-\n-                    });\n+                    promise.whenComplete((value, cause) -> reader.asyncClose());\n                     long lastEntryId = reader.getLastAddConfirmed();\n                     if (lastEntryId < 0) {\n                         // it means that the log segment is created but not written yet or an empty log segment.\n                         // it is equivalent to 'all log records whose transaction id is less than provided transactionId'\n                         Optional<LogRecordWithDLSN> nonRecord = Optional.absent();\n-                        promise.setValue(nonRecord);\n+                        promise.complete(nonRecord);\n                         return;\n                     }\n                     // all log records whose transaction id is not less than provided transactionId\n@@ -548,15 +532,15 @@ public BoxedUnit apply() {\n                                 executorService,\n                                 new SingleEntryScanContext(0L),\n                                 selector\n-                        ).addEventListener(new FutureEventListener<LogRecordWithDLSN>() {\n+                        ).whenComplete(new FutureEventListener<LogRecordWithDLSN>() {\n                             @Override\n                             public void onSuccess(LogRecordWithDLSN value) {\n-                                promise.setValue(Optional.of(selector.result()));\n+                                promise.complete(Optional.of(selector.result()));\n                             }\n \n                             @Override\n                             public void onFailure(Throwable cause) {\n-                                promise.setException(cause);\n+                                promise.completeExceptionally(cause);\n                             }\n                         });\n \n@@ -576,12 +560,12 @@ public void onFailure(Throwable cause) {\n \n                 @Override\n                 public void onFailure(final Throwable cause) {\n-                    promise.setException(cause);\n+                    promise.completeExceptionally(cause);\n                 }\n             };\n \n         entryStore.openRandomAccessReader(segment, false)\n-                .addEventListener(FutureEventListenerRunnable.of(openReaderListener, executorService));\n+                .whenCompleteAsync(openReaderListener, executorService);\n         return promise;\n     }\n \n@@ -617,12 +601,12 @@ private static void getLogRecordNotLessThanTxIdFromEntries(\n             final List<Long> entriesToSearch,\n             final int nWays,\n             final Optional<LogRecordWithDLSN> prevFoundRecord,\n-            final Promise<Optional<LogRecordWithDLSN>> promise) {\n-        final List<Future<LogRecordWithDLSN>> searchResults =\n+            final CompletableFuture<Optional<LogRecordWithDLSN>> promise) {\n+        final List<CompletableFuture<LogRecordWithDLSN>> searchResults =\n                 Lists.newArrayListWithExpectedSize(entriesToSearch.size());\n         for (Long entryId : entriesToSearch) {\n             LogRecordSelector selector = new FirstTxIdNotLessThanSelector(transactionId);\n-            Future<LogRecordWithDLSN> searchResult = asyncReadRecordFromEntries(\n+            CompletableFuture<LogRecordWithDLSN> searchResult = asyncReadRecordFromEntries(\n                     logName,\n                     reader,\n                     segment,\n@@ -649,11 +633,11 @@ public void onSuccess(List<LogRecordWithDLSN> resultList) {\n \n                     @Override\n                     public void onFailure(Throwable cause) {\n-                        promise.setException(cause);\n+                        promise.completeExceptionally(cause);\n                     }\n                 };\n-        Future.collect(searchResults).addEventListener(\n-                FutureEventListenerRunnable.of(processSearchResultsListener, executorService));\n+        FutureUtils.collect(searchResults).whenCompleteAsync(\n+                processSearchResultsListener, executorService);\n     }\n \n     /**\n@@ -668,7 +652,7 @@ static void processSearchResults(\n             final List<LogRecordWithDLSN> searchResults,\n             final int nWays,\n             final Optional<LogRecordWithDLSN> prevFoundRecord,\n-            final Promise<Optional<LogRecordWithDLSN>> promise) {\n+            final CompletableFuture<Optional<LogRecordWithDLSN>> promise) {\n         int found = -1;\n         for (int i = 0; i < searchResults.size(); i++) {\n             LogRecordWithDLSN record = searchResults.get(i);\n@@ -678,7 +662,7 @@ static void processSearchResults(\n             }\n         }\n         if (found == -1) { // all log records' transaction id is less than provided transaction id\n-            promise.setValue(prevFoundRecord);\n+            promise.complete(prevFoundRecord);\n             return;\n         }\n         // we found a log record\n@@ -691,7 +675,7 @@ static void processSearchResults(\n         if (foundRecord.getDlsn().getSlotId() != 0L\n                 || found == 0\n                 || foundRecord.getDlsn().getEntryId() == (searchResults.get(found - 1).getDlsn().getEntryId() + 1)) {\n-            promise.setValue(Optional.of(foundRecord));\n+            promise.complete(Optional.of(foundRecord));\n             return;\n         }\n \n@@ -702,7 +686,7 @@ static void processSearchResults(\n                 searchResults.get(found),\n                 nWays);\n         if (nextSearchBatch.isEmpty()) {\n-            promise.setValue(prevFoundRecord);\n+            promise.complete(prevFoundRecord);\n             return;\n         }\n         getLogRecordNotLessThanTxIdFromEntries("},{"sha":"04bb9e48da098ad16e6b85fa25b704d1bae0f711","filename":"src/main/java/org/apache/distributedlog/WriteLimiter.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FWriteLimiter.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FWriteLimiter.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FWriteLimiter.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -18,7 +18,7 @@\n package org.apache.distributedlog;\n \n import org.apache.distributedlog.exceptions.OverCapacityException;\n-import org.apache.distributedlog.util.PermitLimiter;\n+import org.apache.distributedlog.common.util.PermitLimiter;\n \n class WriteLimiter {\n "},{"sha":"c4939c0eb0d615a730a2506d1914cda408106d79","filename":"src/main/java/org/apache/distributedlog/admin/DistributedLogAdmin.java","status":"modified","additions":28,"deletions":30,"changes":58,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fadmin%2FDistributedLogAdmin.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fadmin%2FDistributedLogAdmin.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fadmin%2FDistributedLogAdmin.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -19,12 +19,19 @@\n \n import com.google.common.base.Preconditions;\n import com.google.common.collect.Lists;\n-import org.apache.distributedlog.DistributedLogManager;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Function;\n+import org.apache.bookkeeper.util.IOUtils;\n+import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.Options;\n+import org.apache.commons.cli.ParseException;\n+import org.apache.distributedlog.api.DistributedLogManager;\n import org.apache.distributedlog.LogRecordWithDLSN;\n import org.apache.distributedlog.LogSegmentMetadata;\n import org.apache.distributedlog.ReadUtils;\n import org.apache.distributedlog.ZooKeeperClient;\n import org.apache.distributedlog.ZooKeeperClientBuilder;\n+import org.apache.distributedlog.api.namespace.Namespace;\n import org.apache.distributedlog.impl.BKNamespaceDriver;\n import org.apache.distributedlog.impl.acl.ZKAccessControl;\n import org.apache.distributedlog.exceptions.DLIllegalStateException;\n@@ -35,21 +42,12 @@\n import org.apache.distributedlog.metadata.DryrunLogSegmentMetadataStoreUpdater;\n import org.apache.distributedlog.metadata.MetadataUpdater;\n import org.apache.distributedlog.metadata.LogSegmentMetadataStoreUpdater;\n-import org.apache.distributedlog.namespace.DistributedLogNamespace;\n import org.apache.distributedlog.namespace.NamespaceDriver;\n import org.apache.distributedlog.thrift.AccessControlEntry;\n import org.apache.distributedlog.tools.DistributedLogTool;\n-import org.apache.distributedlog.util.FutureUtils;\n+import org.apache.distributedlog.common.concurrent.FutureUtils;\n import org.apache.distributedlog.util.OrderedScheduler;\n-import org.apache.distributedlog.util.SchedulerUtils;\n-import com.twitter.util.Await;\n-import com.twitter.util.Function;\n-import com.twitter.util.Future;\n-import org.apache.bookkeeper.stats.NullStatsLogger;\n-import org.apache.bookkeeper.util.IOUtils;\n-import org.apache.commons.cli.CommandLine;\n-import org.apache.commons.cli.Options;\n-import org.apache.commons.cli.ParseException;\n+import org.apache.distributedlog.common.util.SchedulerUtils;\n import org.apache.zookeeper.KeeperException;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -95,11 +93,11 @@ public class DistributedLogAdmin extends DistributedLogTool {\n      *          is confirmation needed before executing actual action.\n      * @throws IOException\n      */\n-    public static void fixInprogressSegmentWithLowerSequenceNumber(final DistributedLogNamespace namespace,\n+    public static void fixInprogressSegmentWithLowerSequenceNumber(final Namespace namespace,\n                                                                    final MetadataUpdater metadataUpdater,\n                                                                    final String streamName,\n                                                                    final boolean verbose,\n-                                                                   final boolean interactive) throws IOException {\n+                                                                   final boolean interactive) throws Exception {\n         DistributedLogManager dlm = namespace.openLog(streamName);\n         try {\n             List<LogSegmentMetadata> segments = dlm.getLogSegments();\n@@ -193,21 +191,21 @@ public String toString() {\n     }\n \n     public static void checkAndRepairDLNamespace(final URI uri,\n-                                                 final DistributedLogNamespace namespace,\n+                                                 final Namespace namespace,\n                                                  final MetadataUpdater metadataUpdater,\n                                                  final OrderedScheduler scheduler,\n                                                  final boolean verbose,\n-                                                 final boolean interactive) throws IOException {\n+                                                 final boolean interactive) throws Exception {\n         checkAndRepairDLNamespace(uri, namespace, metadataUpdater, scheduler, verbose, interactive, 1);\n     }\n \n     public static void checkAndRepairDLNamespace(final URI uri,\n-                                                 final DistributedLogNamespace namespace,\n+                                                 final Namespace namespace,\n                                                  final MetadataUpdater metadataUpdater,\n                                                  final OrderedScheduler scheduler,\n                                                  final boolean verbose,\n                                                  final boolean interactive,\n-                                                 final int concurrency) throws IOException {\n+                                                 final int concurrency) throws Exception {\n         Preconditions.checkArgument(concurrency > 0, \"Invalid concurrency \" + concurrency + \" found.\");\n         // 0. getting streams under a given uri.\n         Iterator<String> streamsIter = namespace.getLogs();\n@@ -247,7 +245,7 @@ public static void checkAndRepairDLNamespace(final URI uri,\n     }\n \n     private static Map<String, StreamCandidate> checkStreams(\n-            final DistributedLogNamespace namespace,\n+            final Namespace namespace,\n             final Collection<String> streams,\n             final OrderedScheduler scheduler,\n             final int concurrency) throws IOException {\n@@ -274,7 +272,7 @@ public void run() {\n                         LOG.info(\"Checking stream {}.\", stream);\n                         candidate = checkStream(namespace, stream, scheduler);\n                         LOG.info(\"Checked stream {} - {}.\", stream, candidate);\n-                    } catch (IOException e) {\n+                    } catch (Throwable e) {\n                         LOG.error(\"Error on checking stream {} : \", stream, e);\n                         doneLatch.countDown();\n                         break;\n@@ -313,7 +311,7 @@ public void run() {\n     }\n \n     private static StreamCandidate checkStream(\n-            final DistributedLogNamespace namespace,\n+            final Namespace namespace,\n             final String streamName,\n             final OrderedScheduler scheduler) throws IOException {\n         DistributedLogManager dlm = namespace.openLog(streamName);\n@@ -322,14 +320,14 @@ private static StreamCandidate checkStream(\n             if (segments.isEmpty()) {\n                 return null;\n             }\n-            List<Future<LogSegmentCandidate>> futures =\n-                    new ArrayList<Future<LogSegmentCandidate>>(segments.size());\n+            List<CompletableFuture<LogSegmentCandidate>> futures =\n+                    new ArrayList<CompletableFuture<LogSegmentCandidate>>(segments.size());\n             for (LogSegmentMetadata segment : segments) {\n                 futures.add(checkLogSegment(namespace, streamName, segment, scheduler));\n             }\n             List<LogSegmentCandidate> segmentCandidates;\n             try {\n-                segmentCandidates = Await.result(Future.collect(futures));\n+                segmentCandidates = FutureUtils.result(FutureUtils.collect(futures));\n             } catch (Exception e) {\n                 throw new IOException(\"Failed on checking stream \" + streamName, e);\n             }\n@@ -348,13 +346,13 @@ private static StreamCandidate checkStream(\n         }\n     }\n \n-    private static Future<LogSegmentCandidate> checkLogSegment(\n-            final DistributedLogNamespace namespace,\n+    private static CompletableFuture<LogSegmentCandidate> checkLogSegment(\n+            final Namespace namespace,\n             final String streamName,\n             final LogSegmentMetadata metadata,\n             final OrderedScheduler scheduler) {\n         if (metadata.isInProgress()) {\n-            return Future.value(null);\n+            return FutureUtils.value(null);\n         }\n \n         final LogSegmentEntryStore entryStore = namespace.getNamespaceDriver()\n@@ -370,7 +368,7 @@ private static Future<LogSegmentCandidate> checkLogSegment(\n                 new AtomicInteger(0),\n                 scheduler,\n                 entryStore\n-        ).map(new Function<LogRecordWithDLSN, LogSegmentCandidate>() {\n+        ).thenApply(new Function<LogRecordWithDLSN, LogSegmentCandidate>() {\n             @Override\n             public LogSegmentCandidate apply(LogRecordWithDLSN record) {\n                 if (null != record &&\n@@ -388,7 +386,7 @@ public LogSegmentCandidate apply(LogRecordWithDLSN record) {\n     private static boolean repairStream(MetadataUpdater metadataUpdater,\n                                         StreamCandidate streamCandidate,\n                                         boolean verbose,\n-                                        boolean interactive) throws IOException {\n+                                        boolean interactive) throws Exception {\n         if (verbose) {\n             System.out.println(\"Stream \" + streamCandidate.streamName + \" : \");\n             for (LogSegmentCandidate segmentCandidate : streamCandidate.segmentCandidates) {\n@@ -863,7 +861,7 @@ protected void parseCommandLine(CommandLine cmdline) throws ParseException {\n         protected ZKAccessControl getZKAccessControl(ZooKeeperClient zkc, String zkPath) throws Exception {\n             ZKAccessControl accessControl;\n             try {\n-                accessControl = Await.result(ZKAccessControl.read(zkc, zkPath, null));\n+                accessControl = FutureUtils.result(ZKAccessControl.read(zkc, zkPath, null));\n             } catch (KeeperException.NoNodeException nne) {\n                 accessControl = new ZKAccessControl(new AccessControlEntry(), zkPath);\n             }"},{"sha":"3838bf75b05cbbaf3b8033051734b24360d65112","filename":"src/main/java/org/apache/distributedlog/api/AsyncLogReader.java","status":"renamed","additions":8,"deletions":8,"changes":16,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fapi%2FAsyncLogReader.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fapi%2FAsyncLogReader.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fapi%2FAsyncLogReader.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -1,4 +1,4 @@\n-/**\n+/*\n  * Licensed to the Apache Software Foundation (ASF) under one\n  * or more contributor license agreements.  See the NOTICE file\n  * distributed with this work for additional information\n@@ -15,13 +15,13 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package org.apache.distributedlog;\n-\n-import org.apache.distributedlog.io.AsyncCloseable;\n-import com.twitter.util.Future;\n+package org.apache.distributedlog.api;\n \n import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.TimeUnit;\n+import org.apache.distributedlog.LogRecordWithDLSN;\n+import org.apache.distributedlog.io.AsyncCloseable;\n \n public interface AsyncLogReader extends AsyncCloseable {\n \n@@ -37,7 +37,7 @@ public interface AsyncLogReader extends AsyncCloseable {\n      *\n      * @return A promise that when satisfied will contain the Log Record with its DLSN.\n      */\n-    public Future<LogRecordWithDLSN> readNext();\n+    public CompletableFuture<LogRecordWithDLSN> readNext();\n \n     /**\n      * Read next <i>numEntries</i> entries. The future is only satisfied with non-empty list\n@@ -48,7 +48,7 @@ public interface AsyncLogReader extends AsyncCloseable {\n      *          num entries\n      * @return A promise that when satisfied will contain a non-empty list of records with their DLSN.\n      */\n-    public Future<List<LogRecordWithDLSN>> readBulk(int numEntries);\n+    public CompletableFuture<List<LogRecordWithDLSN>> readBulk(int numEntries);\n \n     /**\n      * Read next <i>numEntries</i> entries in a given <i>waitTime</i>.\n@@ -65,5 +65,5 @@ public interface AsyncLogReader extends AsyncCloseable {\n      *          wait time unit\n      * @return A promise that when satisfied will contain a non-empty list of records with their DLSN.\n      */\n-    public Future<List<LogRecordWithDLSN>> readBulk(int numEntries, long waitTime, TimeUnit timeUnit);\n+    public CompletableFuture<List<LogRecordWithDLSN>> readBulk(int numEntries, long waitTime, TimeUnit timeUnit);\n }","previous_filename":"src/main/java/org/apache/distributedlog/AsyncLogReader.java"},{"sha":"9e12de22f4e1787bd477fc1296fbdb2912ce26c6","filename":"src/main/java/org/apache/distributedlog/api/AsyncLogWriter.java","status":"renamed","additions":9,"deletions":9,"changes":18,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fapi%2FAsyncLogWriter.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fapi%2FAsyncLogWriter.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fapi%2FAsyncLogWriter.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -1,4 +1,4 @@\n-/**\n+/*\n  * Licensed to the Apache Software Foundation (ASF) under one\n  * or more contributor license agreements.  See the NOTICE file\n  * distributed with this work for additional information\n@@ -15,14 +15,14 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package org.apache.distributedlog;\n+package org.apache.distributedlog.api;\n \n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import org.apache.distributedlog.DLSN;\n+import org.apache.distributedlog.LogRecord;\n import org.apache.distributedlog.io.AsyncAbortable;\n import org.apache.distributedlog.io.AsyncCloseable;\n-import com.twitter.util.Future;\n-\n-import java.io.Closeable;\n-import java.util.List;\n \n public interface AsyncLogWriter extends AsyncCloseable, AsyncAbortable {\n \n@@ -40,7 +40,7 @@ public interface AsyncLogWriter extends AsyncCloseable, AsyncAbortable {\n      * @return A Future which contains a DLSN if the record was successfully written\n      * or an exception if the write fails\n      */\n-    public Future<DLSN> write(LogRecord record);\n+    public CompletableFuture<DLSN> write(LogRecord record);\n \n     /**\n      * Write log records to the stream in bulk. Each future in the list represents the result of\n@@ -51,7 +51,7 @@ public interface AsyncLogWriter extends AsyncCloseable, AsyncAbortable {\n      * @return A Future which contains a list of Future DLSNs if the record was successfully written\n      * or an exception if the operation fails.\n      */\n-    public Future<List<Future<DLSN>>> writeBulk(List<LogRecord> record);\n+    public CompletableFuture<List<CompletableFuture<DLSN>>> writeBulk(List<LogRecord> record);\n \n     /**\n      * Truncate the log until <i>dlsn</i>.\n@@ -61,7 +61,7 @@ public interface AsyncLogWriter extends AsyncCloseable, AsyncAbortable {\n      * @return A Future indicates whether the operation succeeds or not, or an exception\n      * if the truncation fails.\n      */\n-    public Future<Boolean> truncate(DLSN dlsn);\n+    public CompletableFuture<Boolean> truncate(DLSN dlsn);\n \n     /**\n      * Get the name of the stream this writer writes data to","previous_filename":"src/main/java/org/apache/distributedlog/AsyncLogWriter.java"},{"sha":"60f629de943960611aa78f19f14be8b7724049a8","filename":"src/main/java/org/apache/distributedlog/api/DistributedLogManager.java","status":"renamed","additions":24,"deletions":21,"changes":45,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fapi%2FDistributedLogManager.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fapi%2FDistributedLogManager.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fapi%2FDistributedLogManager.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -1,4 +1,4 @@\n-/**\n+/*\n  * Licensed to the Apache Software Foundation (ASF) under one\n  * or more contributor license agreements.  See the NOTICE file\n  * distributed with this work for additional information\n@@ -15,18 +15,21 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package org.apache.distributedlog;\n-\n-import org.apache.distributedlog.callback.LogSegmentListener;\n-import org.apache.distributedlog.io.AsyncCloseable;\n-import org.apache.distributedlog.namespace.NamespaceDriver;\n-import org.apache.distributedlog.subscription.SubscriptionStateStore;\n-import org.apache.distributedlog.subscription.SubscriptionsStore;\n-import com.twitter.util.Future;\n+package org.apache.distributedlog.api;\n \n import java.io.Closeable;\n import java.io.IOException;\n import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import org.apache.distributedlog.AppendOnlyStreamReader;\n+import org.apache.distributedlog.AppendOnlyStreamWriter;\n+import org.apache.distributedlog.DLSN;\n+import org.apache.distributedlog.LogRecordWithDLSN;\n+import org.apache.distributedlog.LogSegmentMetadata;\n+import org.apache.distributedlog.callback.LogSegmentListener;\n+import org.apache.distributedlog.io.AsyncCloseable;\n+import org.apache.distributedlog.namespace.NamespaceDriver;\n+import org.apache.distributedlog.api.subscription.SubscriptionsStore;\n \n /**\n  * A DistributedLogManager is responsible for managing a single place of storing\n@@ -79,7 +82,7 @@ public interface DistributedLogManager extends AsyncCloseable, Closeable {\n      *\n      * @return result represents the open result\n      */\n-    public Future<AsyncLogWriter> openAsyncLogWriter();\n+    public CompletableFuture<AsyncLogWriter> openAsyncLogWriter();\n \n     /**\n      * Begin writing to the log stream identified by the name\n@@ -129,7 +132,7 @@ public LogReader getInputStream(long fromTxnId)\n      *          transaction id to start reading from\n      * @return async log reader\n      */\n-    public Future<AsyncLogReader> openAsyncLogReader(long fromTxnId);\n+    public CompletableFuture<AsyncLogReader> openAsyncLogReader(long fromTxnId);\n \n     /**\n      * Open an async log reader to read records from a log starting from <code>fromDLSN</code>\n@@ -138,15 +141,15 @@ public LogReader getInputStream(long fromTxnId)\n      *          dlsn to start reading from\n      * @return async log reader\n      */\n-    public Future<AsyncLogReader> openAsyncLogReader(DLSN fromDLSN);\n+    public CompletableFuture<AsyncLogReader> openAsyncLogReader(DLSN fromDLSN);\n \n     // @Deprecated\n     public AsyncLogReader getAsyncLogReader(long fromTxnId) throws IOException;\n \n     // @Deprecated\n     public AsyncLogReader getAsyncLogReader(DLSN fromDLSN) throws IOException;\n \n-    public Future<AsyncLogReader> getAsyncLogReaderWithLock(DLSN fromDLSN);\n+    public CompletableFuture<AsyncLogReader> getAsyncLogReaderWithLock(DLSN fromDLSN);\n \n     /**\n      * Get a log reader with lock starting from <i>fromDLSN</i> and using <i>subscriberId</i>.\n@@ -159,7 +162,7 @@ public LogReader getInputStream(long fromTxnId)\n      *          subscriber id\n      * @return async log reader\n      */\n-    public Future<AsyncLogReader> getAsyncLogReaderWithLock(DLSN fromDLSN, String subscriberId);\n+    public CompletableFuture<AsyncLogReader> getAsyncLogReaderWithLock(DLSN fromDLSN, String subscriberId);\n \n     /**\n      * Get a log reader using <i>subscriberId</i> with lock. The reader will start reading from\n@@ -173,7 +176,7 @@ public LogReader getInputStream(long fromTxnId)\n      *          subscriber id\n      * @return async log reader\n      */\n-    public Future<AsyncLogReader> getAsyncLogReaderWithLock(String subscriberId);\n+    public CompletableFuture<AsyncLogReader> getAsyncLogReaderWithLock(String subscriberId);\n \n     /**\n      * Get the {@link DLSN} of first log record whose transaction id is not less than <code>transactionId</code>.\n@@ -182,7 +185,7 @@ public LogReader getInputStream(long fromTxnId)\n      *          transaction id\n      * @return dlsn of first log record whose transaction id is not less than transactionId.\n      */\n-    public Future<DLSN> getDLSNNotLessThanTxId(long transactionId);\n+    public CompletableFuture<DLSN> getDLSNNotLessThanTxId(long transactionId);\n \n     /**\n      * Get the last log record in the stream\n@@ -222,28 +225,28 @@ public LogRecordWithDLSN getLastLogRecord()\n      *\n      * @return latest log record with DLSN\n      */\n-    public Future<LogRecordWithDLSN> getLastLogRecordAsync();\n+    public CompletableFuture<LogRecordWithDLSN> getLastLogRecordAsync();\n \n     /**\n      * Get Latest Transaction Id in the log - async\n      *\n      * @return latest transaction id\n      */\n-    public Future<Long> getLastTxIdAsync();\n+    public CompletableFuture<Long> getLastTxIdAsync();\n \n     /**\n      * Get first DLSN in the log.\n      *\n      * @return first dlsn in the stream\n      */\n-    public Future<DLSN> getFirstDLSNAsync();\n+    public CompletableFuture<DLSN> getFirstDLSNAsync();\n \n     /**\n      * Get Latest DLSN in the log - async\n      *\n      * @return latest transaction id\n      */\n-    public Future<DLSN> getLastDLSNAsync();\n+    public CompletableFuture<DLSN> getLastDLSNAsync();\n \n     /**\n      * Get the number of log records in the active portion of the log\n@@ -261,7 +264,7 @@ public LogRecordWithDLSN getLastLogRecord()\n      * @return future number of log records\n      * @throws IOException\n      */\n-    public Future<Long> getLogRecordCountAsync(final DLSN beginDLSN);\n+    public CompletableFuture<Long> getLogRecordCountAsync(final DLSN beginDLSN);\n \n     /**\n      * Run recovery on the log.","previous_filename":"src/main/java/org/apache/distributedlog/DistributedLogManager.java"},{"sha":"631a8a990ac449ad9b967d97e1f9d5b244d8054c","filename":"src/main/java/org/apache/distributedlog/api/LogReader.java","status":"renamed","additions":5,"deletions":2,"changes":7,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fapi%2FLogReader.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fapi%2FLogReader.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fapi%2FLogReader.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -1,4 +1,4 @@\n-/**\n+/*\n  * Licensed to the Apache Software Foundation (ASF) under one\n  * or more contributor license agreements.  See the NOTICE file\n  * distributed with this work for additional information\n@@ -15,8 +15,11 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package org.apache.distributedlog;\n+package org.apache.distributedlog.api;\n \n+import org.apache.distributedlog.DLSN;\n+import org.apache.distributedlog.DistributedLogConfiguration;\n+import org.apache.distributedlog.LogRecordWithDLSN;\n import org.apache.distributedlog.io.AsyncCloseable;\n \n import java.io.Closeable;","previous_filename":"src/main/java/org/apache/distributedlog/LogReader.java"},{"sha":"46ad1f07a87ded3be82ad786a7d617efb9813afc","filename":"src/main/java/org/apache/distributedlog/api/LogWriter.java","status":"renamed","additions":3,"deletions":2,"changes":5,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fapi%2FLogWriter.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fapi%2FLogWriter.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fapi%2FLogWriter.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -1,4 +1,4 @@\n-/**\n+/*\n  * Licensed to the Apache Software Foundation (ASF) under one\n  * or more contributor license agreements.  See the NOTICE file\n  * distributed with this work for additional information\n@@ -15,8 +15,9 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package org.apache.distributedlog;\n+package org.apache.distributedlog.api;\n \n+import org.apache.distributedlog.LogRecord;\n import org.apache.distributedlog.io.Abortable;\n \n import java.io.Closeable;","previous_filename":"src/main/java/org/apache/distributedlog/LogWriter.java"},{"sha":"76ef700e924abee57277a1c6766d1af2f3e21be1","filename":"src/main/java/org/apache/distributedlog/api/MetadataAccessor.java","status":"renamed","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fapi%2FMetadataAccessor.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fapi%2FMetadataAccessor.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fapi%2FMetadataAccessor.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -1,4 +1,4 @@\n-/**\n+/*\n  * Licensed to the Apache Software Foundation (ASF) under one\n  * or more contributor license agreements.  See the NOTICE file\n  * distributed with this work for additional information\n@@ -15,7 +15,7 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package org.apache.distributedlog;\n+package org.apache.distributedlog.api;\n \n import org.apache.distributedlog.io.AsyncCloseable;\n ","previous_filename":"src/main/java/org/apache/distributedlog/MetadataAccessor.java"},{"sha":"818824dbccbb678696665db2f3dce8222f9832d1","filename":"src/main/java/org/apache/distributedlog/api/namespace/Namespace.java","status":"renamed","additions":7,"deletions":6,"changes":13,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fapi%2Fnamespace%2FNamespace.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fapi%2Fnamespace%2FNamespace.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fapi%2Fnamespace%2FNamespace.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -1,4 +1,4 @@\n-/**\n+/*\n  * Licensed to the Apache Software Foundation (ASF) under one\n  * or more contributor license agreements.  See the NOTICE file\n  * distributed with this work for additional information\n@@ -15,12 +15,12 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package org.apache.distributedlog.namespace;\n+package org.apache.distributedlog.api.namespace;\n \n import com.google.common.annotations.Beta;\n import com.google.common.base.Optional;\n import org.apache.distributedlog.DistributedLogConfiguration;\n-import org.apache.distributedlog.DistributedLogManager;\n+import org.apache.distributedlog.api.DistributedLogManager;\n import org.apache.distributedlog.exceptions.LogNotFoundException;\n import org.apache.distributedlog.acl.AccessControlManager;\n import org.apache.distributedlog.callback.NamespaceListener;\n@@ -31,14 +31,15 @@\n import java.util.Iterator;\n \n import org.apache.bookkeeper.stats.StatsLogger;\n+import org.apache.distributedlog.namespace.NamespaceDriver;\n \n /**\n  * A namespace is the basic unit for managing a set of distributedlogs.\n  *\n  * <h4>Namespace Interface</h4>\n  *\n  * <P>\n- * The <code>DistributedLogNamespace</code> interface is implemented by different backend providers.\n+ * The <code>Namespace</code> interface is implemented by different backend providers.\n  * There are several components are required for an implementation:\n  * <OL>\n  *     <LI>Log Management -- manage logs in a given namespace. e.g. create/open/delete log, list of logs,\n@@ -49,7 +50,7 @@\n  *\n  * <h4>Namespace Location</h4>\n  *\n- * At the highest level, a <code>DistributedLogNamespace</code> is located by a <code>URI</code>. The location\n+ * At the highest level, a <code>Namespace</code> is located by a <code>URI</code>. The location\n  * URI is in string form has the syntax\n  *\n  * <blockquote>\n@@ -68,7 +69,7 @@\n  * @since 0.3.32\n  */\n @Beta\n-public interface DistributedLogNamespace {\n+public interface Namespace {\n \n     /**\n      * Get the namespace driver used by this namespace.","previous_filename":"src/main/java/org/apache/distributedlog/namespace/DistributedLogNamespace.java"},{"sha":"45dc0219d0a78250d8fb2fefa7c072e0d89f1f48","filename":"src/main/java/org/apache/distributedlog/api/namespace/NamespaceBuilder.java","status":"renamed","additions":22,"deletions":25,"changes":47,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fapi%2Fnamespace%2FNamespaceBuilder.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fapi%2Fnamespace%2FNamespaceBuilder.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fapi%2Fnamespace%2FNamespaceBuilder.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -1,4 +1,4 @@\n-/**\n+/*\n  * Licensed to the Apache Software Foundation (ASF) under one\n  * or more contributor license agreements.  See the NOTICE file\n  * distributed with this work for additional information\n@@ -15,7 +15,7 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package org.apache.distributedlog.namespace;\n+package org.apache.distributedlog.api.namespace;\n \n import com.google.common.base.Preconditions;\n import org.apache.distributedlog.BKDistributedLogNamespace;\n@@ -25,10 +25,12 @@\n import org.apache.distributedlog.feature.CoreFeatureKeys;\n import org.apache.distributedlog.injector.AsyncFailureInjector;\n import org.apache.distributedlog.injector.AsyncRandomFailureInjector;\n+import org.apache.distributedlog.namespace.NamespaceDriver;\n+import org.apache.distributedlog.namespace.NamespaceDriverManager;\n import org.apache.distributedlog.util.ConfUtils;\n import org.apache.distributedlog.util.DLUtils;\n import org.apache.distributedlog.util.OrderedScheduler;\n-import org.apache.distributedlog.util.PermitLimiter;\n+import org.apache.distributedlog.common.util.PermitLimiter;\n import org.apache.distributedlog.util.SimplePermitLimiter;\n import org.apache.bookkeeper.feature.Feature;\n import org.apache.bookkeeper.feature.FeatureProvider;\n@@ -42,18 +44,18 @@\n import java.net.URI;\n \n /**\n- * Builder to construct a <code>DistributedLogNamespace</code>.\n+ * Builder to construct a <code>Namespace</code>.\n  * The builder takes the responsibility of loading backend according to the uri.\n  *\n- * @see DistributedLogNamespace\n+ * @see Namespace\n  * @since 0.3.32\n  */\n-public class DistributedLogNamespaceBuilder {\n+public class NamespaceBuilder {\n \n-    private static final Logger logger = LoggerFactory.getLogger(DistributedLogNamespaceBuilder.class);\n+    private static final Logger logger = LoggerFactory.getLogger(NamespaceBuilder.class);\n \n-    public static DistributedLogNamespaceBuilder newBuilder() {\n-        return new DistributedLogNamespaceBuilder();\n+    public static NamespaceBuilder newBuilder() {\n+        return new NamespaceBuilder();\n     }\n \n     private DistributedLogConfiguration _conf = null;\n@@ -66,7 +68,7 @@ public static DistributedLogNamespaceBuilder newBuilder() {\n     private int _regionId = DistributedLogConstants.LOCAL_REGION_ID;\n \n     // private constructor\n-    private DistributedLogNamespaceBuilder() {}\n+    private NamespaceBuilder() {}\n \n     /**\n      * DistributedLog Configuration used for the namespace.\n@@ -75,7 +77,7 @@ private DistributedLogNamespaceBuilder() {}\n      *          distributedlog configuration\n      * @return namespace builder.\n      */\n-    public DistributedLogNamespaceBuilder conf(DistributedLogConfiguration conf) {\n+    public NamespaceBuilder conf(DistributedLogConfiguration conf) {\n         this._conf = conf;\n         return this;\n     }\n@@ -86,7 +88,7 @@ public DistributedLogNamespaceBuilder conf(DistributedLogConfiguration conf) {\n      * @param dynConf dynamic distributedlog configuration\n      * @return namespace builder\n      */\n-    public DistributedLogNamespaceBuilder dynConf(DynamicDistributedLogConfiguration dynConf) {\n+    public NamespaceBuilder dynConf(DynamicDistributedLogConfiguration dynConf) {\n         this._dynConf = dynConf;\n         return this;\n     }\n@@ -96,10 +98,10 @@ public DistributedLogNamespaceBuilder dynConf(DynamicDistributedLogConfiguration\n      *\n      * @param uri\n      *          namespace location uri.\n-     * @see DistributedLogNamespace\n+     * @see Namespace\n      * @return namespace builder.\n      */\n-    public DistributedLogNamespaceBuilder uri(URI uri) {\n+    public NamespaceBuilder uri(URI uri) {\n         this._uri = uri;\n         return this;\n     }\n@@ -111,7 +113,7 @@ public DistributedLogNamespaceBuilder uri(URI uri) {\n      *          stats logger\n      * @return namespace builder.\n      */\n-    public DistributedLogNamespaceBuilder statsLogger(StatsLogger statsLogger) {\n+    public NamespaceBuilder statsLogger(StatsLogger statsLogger) {\n         this._statsLogger = statsLogger;\n         return this;\n     }\n@@ -123,7 +125,7 @@ public DistributedLogNamespaceBuilder statsLogger(StatsLogger statsLogger) {\n      *          stats logger for collecting per log stats\n      * @return namespace builder.\n      */\n-    public DistributedLogNamespaceBuilder perLogStatsLogger(StatsLogger statsLogger) {\n+    public NamespaceBuilder perLogStatsLogger(StatsLogger statsLogger) {\n         this._perLogStatsLogger = statsLogger;\n         return this;\n     }\n@@ -135,7 +137,7 @@ public DistributedLogNamespaceBuilder perLogStatsLogger(StatsLogger statsLogger)\n      *          feature provider to control availabilities of features.\n      * @return namespace builder.\n      */\n-    public DistributedLogNamespaceBuilder featureProvider(FeatureProvider featureProvider) {\n+    public NamespaceBuilder featureProvider(FeatureProvider featureProvider) {\n         this._featureProvider = featureProvider;\n         return this;\n     }\n@@ -147,7 +149,7 @@ public DistributedLogNamespaceBuilder featureProvider(FeatureProvider featurePro\n      *          client id used for accessing the namespace\n      * @return namespace builder.\n      */\n-    public DistributedLogNamespaceBuilder clientId(String clientId) {\n+    public NamespaceBuilder clientId(String clientId) {\n         this._clientId = clientId;\n         return this;\n     }\n@@ -160,7 +162,7 @@ public DistributedLogNamespaceBuilder clientId(String clientId) {\n      *          region id.\n      * @return namespace builder.\n      */\n-    public DistributedLogNamespaceBuilder regionId(int regionId) {\n+    public NamespaceBuilder regionId(int regionId) {\n         this._regionId = regionId;\n         return this;\n     }\n@@ -185,7 +187,7 @@ private static StatsLogger normalizePerLogStatsLogger(StatsLogger statsLogger,\n      * @throws NullPointerException when there is null argument provided in the builder\n      * @throws IOException when fail to build the backend\n      */\n-    public DistributedLogNamespace build()\n+    public Namespace build()\n             throws IllegalArgumentException, NullPointerException, IOException {\n         // Check arguments\n         Preconditions.checkNotNull(_conf, \"No DistributedLog Configuration.\");\n@@ -224,14 +226,9 @@ public DistributedLogNamespace build()\n         StatsLogger perLogStatsLogger = normalizePerLogStatsLogger(_statsLogger, _perLogStatsLogger, _conf);\n \n         // build the scheduler\n-        StatsLogger schedulerStatsLogger = _statsLogger.scope(\"factory\").scope(\"thread_pool\");\n         OrderedScheduler scheduler = OrderedScheduler.newBuilder()\n                 .name(\"DLM-\" + normalizedUri.getPath())\n                 .corePoolSize(_conf.getNumWorkerThreads())\n-                .statsLogger(schedulerStatsLogger)\n-                .perExecutorStatsLogger(schedulerStatsLogger)\n-                .traceTaskExecution(_conf.getEnableTaskExecutionStats())\n-                .traceTaskExecutionWarnTimeUs(_conf.getTaskExecutionWarnTimeMicros())\n                 .build();\n \n         // initialize the namespace driver","previous_filename":"src/main/java/org/apache/distributedlog/namespace/DistributedLogNamespaceBuilder.java"},{"sha":"fa8f288a654b07203fa82553d1ce698955a4221a","filename":"src/main/java/org/apache/distributedlog/api/namespace/package-info.java","status":"renamed","additions":4,"deletions":3,"changes":7,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fapi%2Fnamespace%2Fpackage-info.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fapi%2Fnamespace%2Fpackage-info.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fapi%2Fnamespace%2Fpackage-info.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -1,4 +1,4 @@\n-/**\n+/*\n  * Licensed to the Apache Software Foundation (ASF) under one\n  * or more contributor license agreements.  See the NOTICE file\n  * distributed with this work for additional information\n@@ -15,7 +15,8 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n+\n /**\n- * IO Utils for distributedlog\n+ * Namespace API and the builder to build namespace instance.\n  */\n-package org.apache.distributedlog.io;\n+package org.apache.distributedlog.api.namespace;\n\\ No newline at end of file","previous_filename":"src/main/java/org/apache/distributedlog/io/package-info.java"},{"sha":"eca11fd928e43ee5eecfc0733d0145fe17fc39e5","filename":"src/main/java/org/apache/distributedlog/api/package-info.java","status":"renamed","additions":6,"deletions":6,"changes":12,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fapi%2Fpackage-info.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fapi%2Fpackage-info.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fapi%2Fpackage-info.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -1,4 +1,4 @@\n-/**\n+/*\n  * Licensed to the Apache Software Foundation (ASF) under one\n  * or more contributor license agreements.  See the NOTICE file\n  * distributed with this work for additional information\n@@ -15,11 +15,11 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package org.apache.distributedlog.callback;\n \n /**\n- * ReadAhead Callback\n+ * DistributedLog NEW API.\n+ *\n+ * <p>This is the new Java8 {@link java.util.concurrent.CompletableFuture} based API. It is\n+ * <strong>experimental</strong> and still under developing.\n  */\n-public interface ReadAheadCallback {\n-    void resumeReadAhead();\n-}\n+package org.apache.distributedlog.api;","previous_filename":"src/main/java/org/apache/distributedlog/callback/ReadAheadCallback.java"},{"sha":"bf4a8d3d962f9451c89a3a8d94cf29999fd6da33","filename":"src/main/java/org/apache/distributedlog/api/subscription/SubscriptionStateStore.java","status":"renamed","additions":4,"deletions":7,"changes":11,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fapi%2Fsubscription%2FSubscriptionStateStore.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fapi%2Fsubscription%2FSubscriptionStateStore.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fapi%2Fsubscription%2FSubscriptionStateStore.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -15,28 +15,25 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package org.apache.distributedlog.subscription;\n+package org.apache.distributedlog.api.subscription;\n \n import java.io.Closeable;\n-\n-import scala.runtime.BoxedUnit;\n-\n+import java.util.concurrent.CompletableFuture;\n import org.apache.distributedlog.DLSN;\n-import com.twitter.util.Future;\n \n public interface SubscriptionStateStore extends Closeable {\n     /**\n      * Get the last committed position stored for this subscription\n      *\n      * @return future represents the last commit position\n      */\n-    public Future<DLSN> getLastCommitPosition();\n+    public CompletableFuture<DLSN> getLastCommitPosition();\n \n     /**\n      * Advances the position associated with the subscriber\n      *\n      * @param newPosition - new commit position\n      * @return future represents the advance result\n      */\n-    public Future<BoxedUnit> advanceCommitPosition(DLSN newPosition);\n+    public CompletableFuture<Void> advanceCommitPosition(DLSN newPosition);\n }","previous_filename":"src/main/java/org/apache/distributedlog/subscription/SubscriptionStateStore.java"},{"sha":"b6a0ed16bd5b85d30f95d8f76dcc85cdfb568ff5","filename":"src/main/java/org/apache/distributedlog/api/subscription/SubscriptionsStore.java","status":"renamed","additions":7,"deletions":9,"changes":16,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fapi%2Fsubscription%2FSubscriptionsStore.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fapi%2Fsubscription%2FSubscriptionsStore.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fapi%2Fsubscription%2FSubscriptionsStore.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -15,14 +15,12 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package org.apache.distributedlog.subscription;\n-\n-import org.apache.distributedlog.DLSN;\n-import com.twitter.util.Future;\n-import scala.runtime.BoxedUnit;\n+package org.apache.distributedlog.api.subscription;\n \n import java.io.Closeable;\n import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import org.apache.distributedlog.DLSN;\n \n /**\n  * Store to manage subscriptions\n@@ -36,14 +34,14 @@ public interface SubscriptionsStore extends Closeable {\n      *          subscriber id\n      * @return future representing last committed position.\n      */\n-    public Future<DLSN> getLastCommitPosition(String subscriberId);\n+    public CompletableFuture<DLSN> getLastCommitPosition(String subscriberId);\n \n     /**\n      * Get the last committed positions for all subscribers.\n      *\n      * @return future representing last committed positions for all subscribers.\n      */\n-    public Future<Map<String, DLSN>> getLastCommitPositions();\n+    public CompletableFuture<Map<String, DLSN>> getLastCommitPositions();\n \n     /**\n      * Advance the last committed position for <i>subscriberId</i>.\n@@ -54,7 +52,7 @@ public interface SubscriptionsStore extends Closeable {\n      *          new committed position.\n      * @return future representing advancing result.\n      */\n-    public Future<BoxedUnit> advanceCommitPosition(String subscriberId, DLSN newPosition);\n+    public CompletableFuture<Void> advanceCommitPosition(String subscriberId, DLSN newPosition);\n \n     /**\n      * Delete the subscriber <i>subscriberId</i> permanently. Once the subscriber is deleted, all the\n@@ -64,6 +62,6 @@ public interface SubscriptionsStore extends Closeable {\n      * return true only if there's such subscriber and we removed it successfully.\n      * return false if there's no such subscriber, or we failed to remove.\n      */\n-    public Future<Boolean> deleteSubscriber(String subscriberId);\n+    public CompletableFuture<Boolean> deleteSubscriber(String subscriberId);\n \n }","previous_filename":"src/main/java/org/apache/distributedlog/subscription/SubscriptionsStore.java"},{"sha":"34011b5e9989a0d46de147f2e9418cacc41a12ca","filename":"src/main/java/org/apache/distributedlog/auditor/DLAuditor.java","status":"modified","additions":25,"deletions":24,"changes":49,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fauditor%2FDLAuditor.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fauditor%2FDLAuditor.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fauditor%2FDLAuditor.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -20,20 +20,20 @@\n import com.google.common.base.Objects;\n import com.google.common.base.Preconditions;\n import com.google.common.collect.Lists;\n-import com.google.common.util.concurrent.SettableFuture;\n+import java.util.concurrent.CompletableFuture;\n import org.apache.distributedlog.BookKeeperClient;\n import org.apache.distributedlog.BookKeeperClientBuilder;\n import org.apache.distributedlog.DistributedLogConfiguration;\n-import org.apache.distributedlog.DistributedLogManager;\n+import org.apache.distributedlog.api.DistributedLogManager;\n import org.apache.distributedlog.LogSegmentMetadata;\n+import org.apache.distributedlog.api.namespace.Namespace;\n import org.apache.distributedlog.impl.BKNamespaceDriver;\n-import org.apache.distributedlog.namespace.DistributedLogNamespace;\n import org.apache.distributedlog.ZooKeeperClient;\n import org.apache.distributedlog.ZooKeeperClientBuilder;\n import org.apache.distributedlog.exceptions.DLInterruptedException;\n import org.apache.distributedlog.exceptions.ZKException;\n import org.apache.distributedlog.impl.metadata.BKDLConfig;\n-import org.apache.distributedlog.namespace.DistributedLogNamespaceBuilder;\n+import org.apache.distributedlog.api.namespace.NamespaceBuilder;\n import org.apache.distributedlog.namespace.NamespaceDriver;\n import org.apache.distributedlog.util.DLUtils;\n import org.apache.bookkeeper.client.BKException;\n@@ -45,6 +45,7 @@\n import org.apache.bookkeeper.zookeeper.BoundExponentialBackoffRetryPolicy;\n import org.apache.bookkeeper.zookeeper.RetryPolicy;\n import org.apache.commons.lang3.tuple.Pair;\n+import org.apache.distributedlog.common.concurrent.FutureUtils;\n import org.apache.zookeeper.AsyncCallback;\n import org.apache.zookeeper.KeeperException;\n import org.apache.zookeeper.data.Stat;\n@@ -84,13 +85,13 @@ public DLAuditor(DistributedLogConfiguration conf) {\n         this.conf = conf;\n     }\n \n-    private ZooKeeperClient getZooKeeperClient(DistributedLogNamespace namespace) {\n+    private ZooKeeperClient getZooKeeperClient(Namespace namespace) {\n         NamespaceDriver driver = namespace.getNamespaceDriver();\n         assert(driver instanceof BKNamespaceDriver);\n         return ((BKNamespaceDriver) driver).getWriterZKC();\n     }\n \n-    private BookKeeperClient getBookKeeperClient(DistributedLogNamespace namespace) {\n+    private BookKeeperClient getBookKeeperClient(Namespace namespace) {\n         NamespaceDriver driver = namespace.getNamespaceDriver();\n         assert(driver instanceof BKNamespaceDriver);\n         return ((BKNamespaceDriver) driver).getReaderBKC();\n@@ -169,7 +170,7 @@ private Set<Long> collectLedgersFromBK(BookKeeperClient bkc,\n         LedgerManager lm = BookKeeperAccessor.getLedgerManager(bkc.get());\n \n         final Set<Long> ledgers = new HashSet<Long>();\n-        final SettableFuture<Void> doneFuture = SettableFuture.create();\n+        final CompletableFuture<Void> doneFuture = FutureUtils.createFuture();\n \n         BookkeeperInternalCallbacks.Processor<Long> collector =\n                 new BookkeeperInternalCallbacks.Processor<Long>() {\n@@ -195,9 +196,9 @@ public void run() {\n             @Override\n             public void processResult(int rc, String path, Object ctx) {\n                 if (BKException.Code.OK == rc) {\n-                    doneFuture.set(null);\n+                    doneFuture.complete(null);\n                 } else {\n-                    doneFuture.setException(BKException.create(rc));\n+                    doneFuture.completeExceptionally(BKException.create(rc));\n                 }\n             }\n         };\n@@ -225,12 +226,12 @@ public void processResult(int rc, String path, Object ctx) {\n     private Set<Long> collectLedgersFromDL(List<URI> uris, List<List<String>> allocationPaths)\n             throws IOException {\n         final Set<Long> ledgers = new TreeSet<Long>();\n-        List<DistributedLogNamespace> namespaces =\n-                new ArrayList<DistributedLogNamespace>(uris.size());\n+        List<Namespace> namespaces =\n+                new ArrayList<Namespace>(uris.size());\n         try {\n             for (URI uri : uris) {\n                 namespaces.add(\n-                        DistributedLogNamespaceBuilder.newBuilder()\n+                        NamespaceBuilder.newBuilder()\n                                 .conf(conf)\n                                 .uri(uri)\n                                 .build());\n@@ -240,8 +241,8 @@ private Set<Long> collectLedgersFromDL(List<URI> uris, List<List<String>> alloca\n             ExecutorService executor = Executors.newFixedThreadPool(uris.size());\n             try {\n                 int i = 0;\n-                for (final DistributedLogNamespace namespace : namespaces) {\n-                    final DistributedLogNamespace dlNamespace = namespace;\n+                for (final Namespace namespace : namespaces) {\n+                    final Namespace dlNamespace = namespace;\n                     final URI uri = uris.get(i);\n                     final List<String> aps = allocationPaths.get(i);\n                     i++;\n@@ -278,15 +279,15 @@ public void run() {\n                 executor.shutdown();\n             }\n         } finally {\n-            for (DistributedLogNamespace namespace : namespaces) {\n+            for (Namespace namespace : namespaces) {\n                 namespace.close();\n             }\n         }\n         return ledgers;\n     }\n \n     private void collectLedgersFromAllocator(final URI uri,\n-                                             final DistributedLogNamespace namespace,\n+                                             final Namespace namespace,\n                                              final List<String> allocationPaths,\n                                              final Set<Long> ledgers) throws IOException {\n         final LinkedBlockingQueue<String> poolQueue =\n@@ -346,7 +347,7 @@ private void collectLedgersFromPool(String poolPath)\n     }\n \n     private void collectLedgersFromDL(final URI uri,\n-                                      final DistributedLogNamespace namespace,\n+                                      final Namespace namespace,\n                                       final Set<Long> ledgers) throws IOException {\n         logger.info(\"Enumerating {} to collect streams.\", uri);\n         Iterator<String> streams = namespace.getLogs();\n@@ -366,7 +367,7 @@ public void execute(String stream) throws IOException {\n         });\n     }\n \n-    private List<Long> collectLedgersFromStream(DistributedLogNamespace namespace,\n+    private List<Long> collectLedgersFromStream(Namespace namespace,\n                                                 String stream,\n                                                 Set<Long> ledgers)\n             throws IOException {\n@@ -394,7 +395,7 @@ private List<Long> collectLedgersFromStream(DistributedLogNamespace namespace,\n      */\n     public Map<String, Long> calculateStreamSpaceUsage(final URI uri) throws IOException {\n         logger.info(\"Collecting stream space usage for {}.\", uri);\n-        DistributedLogNamespace namespace = DistributedLogNamespaceBuilder.newBuilder()\n+        Namespace namespace = NamespaceBuilder.newBuilder()\n                 .conf(conf)\n                 .uri(uri)\n                 .build();\n@@ -406,7 +407,7 @@ public Map<String, Long> calculateStreamSpaceUsage(final URI uri) throws IOExcep\n     }\n \n     private Map<String, Long> calculateStreamSpaceUsage(\n-            final URI uri, final DistributedLogNamespace namespace)\n+            final URI uri, final Namespace namespace)\n         throws IOException {\n         Iterator<String> streams = namespace.getLogs();\n         final LinkedBlockingQueue<String> streamQueue = new LinkedBlockingQueue<String>();\n@@ -432,7 +433,7 @@ public void execute(String stream) throws IOException {\n         return streamSpaceUsageMap;\n     }\n \n-    private long calculateStreamSpaceUsage(final DistributedLogNamespace namespace,\n+    private long calculateStreamSpaceUsage(final Namespace namespace,\n                                            final String stream) throws IOException {\n         DistributedLogManager dlm = namespace.openLog(stream);\n         long totalBytes = 0;\n@@ -504,7 +505,7 @@ private long calculateLedgerSpaceUsage(BookKeeperClient bkc,\n \n         LedgerManager lm = BookKeeperAccessor.getLedgerManager(bkc.get());\n \n-        final SettableFuture<Void> doneFuture = SettableFuture.create();\n+        final CompletableFuture<Void> doneFuture = FutureUtils.createFuture();\n         final BookKeeper bk = bkc.get();\n \n         BookkeeperInternalCallbacks.Processor<Long> collector =\n@@ -544,9 +545,9 @@ public void run() {\n             @Override\n             public void processResult(int rc, String path, Object ctx) {\n                 if (BKException.Code.OK == rc) {\n-                    doneFuture.set(null);\n+                    doneFuture.complete(null);\n                 } else {\n-                    doneFuture.setException(BKException.create(rc));\n+                    doneFuture.completeExceptionally(BKException.create(rc));\n                 }\n             }\n         };"},{"sha":"ee33dc3138784e920438d25e05948d2e86bdaf9f","filename":"src/main/java/org/apache/distributedlog/bk/LedgerAllocatorDelegator.java","status":"modified","additions":7,"deletions":6,"changes":13,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fbk%2FLedgerAllocatorDelegator.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fbk%2FLedgerAllocatorDelegator.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fbk%2FLedgerAllocatorDelegator.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -17,9 +17,10 @@\n  */\n package org.apache.distributedlog.bk;\n \n+import java.util.concurrent.CompletableFuture;\n+import org.apache.distributedlog.common.concurrent.FutureUtils;\n import org.apache.distributedlog.util.Transaction;\n import org.apache.distributedlog.util.Transaction.OpListener;\n-import com.twitter.util.Future;\n import org.apache.bookkeeper.client.LedgerHandle;\n \n import java.io.IOException;\n@@ -57,8 +58,8 @@ public void start() throws IOException {\n     }\n \n     @Override\n-    public Future<Void> delete() {\n-        return Future.exception(new UnsupportedOperationException(\"Can't delete an allocator by delegator\"));\n+    public CompletableFuture<Void> delete() {\n+        return FutureUtils.exception(new UnsupportedOperationException(\"Can't delete an allocator by delegator\"));\n     }\n \n     @Override\n@@ -67,17 +68,17 @@ public void allocate() throws IOException {\n     }\n \n     @Override\n-    public Future<LedgerHandle> tryObtain(Transaction<Object> txn,\n+    public CompletableFuture<LedgerHandle> tryObtain(Transaction<Object> txn,\n                                           OpListener<LedgerHandle> listener) {\n         return this.allocator.tryObtain(txn, listener);\n     }\n \n     @Override\n-    public Future<Void> asyncClose() {\n+    public CompletableFuture<Void> asyncClose() {\n         if (ownAllocator) {\n             return this.allocator.asyncClose();\n         } else {\n-            return Future.value(null);\n+            return FutureUtils.value(null);\n         }\n     }\n }"},{"sha":"19c5546b7ea1b0098737a7bb2b9ad38255e3a829","filename":"src/main/java/org/apache/distributedlog/bk/LedgerAllocatorPool.java","status":"modified","additions":22,"deletions":37,"changes":59,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fbk%2FLedgerAllocatorPool.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fbk%2FLedgerAllocatorPool.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fbk%2FLedgerAllocatorPool.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -19,17 +19,15 @@\n \n import com.google.common.annotations.VisibleForTesting;\n import com.google.common.collect.Lists;\n+import java.util.concurrent.CompletableFuture;\n import org.apache.distributedlog.BookKeeperClient;\n import org.apache.distributedlog.DistributedLogConfiguration;\n import org.apache.distributedlog.ZooKeeperClient;\n import org.apache.distributedlog.exceptions.DLInterruptedException;\n-import org.apache.distributedlog.util.FutureUtils;\n+import org.apache.distributedlog.common.concurrent.FutureEventListener;\n+import org.apache.distributedlog.common.concurrent.FutureUtils;\n import org.apache.distributedlog.util.Transaction;\n import org.apache.distributedlog.util.Utils;\n-import com.twitter.util.Function;\n-import com.twitter.util.Future;\n-import com.twitter.util.FutureEventListener;\n-import com.twitter.util.Promise;\n import org.apache.bookkeeper.client.LedgerHandle;\n import org.apache.bookkeeper.meta.ZkVersion;\n import org.apache.bookkeeper.util.ZkUtils;\n@@ -40,7 +38,6 @@\n import org.apache.zookeeper.data.Stat;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n-import scala.runtime.AbstractFunction1;\n \n import java.io.IOException;\n import java.util.ArrayList;\n@@ -320,25 +317,25 @@ public void allocate() throws IOException {\n     }\n \n     @Override\n-    public Future<LedgerHandle> tryObtain(final Transaction<Object> txn,\n-                                          final Transaction.OpListener<LedgerHandle> listener) {\n+    public CompletableFuture<LedgerHandle> tryObtain(final Transaction<Object> txn,\n+                                                     final Transaction.OpListener<LedgerHandle> listener) {\n         final SimpleLedgerAllocator allocator;\n         synchronized (this) {\n             if (allocatingList.isEmpty()) {\n-                return Future.exception(new IOException(\"No ledger allocator available under \" + poolPath + \".\"));\n+                return FutureUtils.exception(new IOException(\"No ledger allocator available under \" + poolPath + \".\"));\n             } else {\n                 allocator = allocatingList.removeFirst();\n             }\n         }\n \n-        final Promise<LedgerHandle> tryObtainPromise = new Promise<LedgerHandle>();\n+        final CompletableFuture<LedgerHandle> tryObtainPromise = new CompletableFuture<LedgerHandle>();\n         final FutureEventListener<LedgerHandle> tryObtainListener = new FutureEventListener<LedgerHandle>() {\n             @Override\n             public void onSuccess(LedgerHandle lh) {\n                 synchronized (LedgerAllocatorPool.this) {\n                     obtainMap.put(lh, allocator);\n                     reverseObtainMap.put(allocator, lh);\n-                    tryObtainPromise.setValue(lh);\n+                    tryObtainPromise.complete(lh);\n                 }\n             }\n \n@@ -349,7 +346,7 @@ public void onFailure(Throwable cause) {\n                 } catch (IOException ioe) {\n                     logger.info(\"Failed to rescue allocator {}\", allocator.allocatePath, ioe);\n                 }\n-                tryObtainPromise.setException(cause);\n+                tryObtainPromise.completeExceptionally(cause);\n             }\n         };\n \n@@ -365,7 +362,7 @@ public void onAbort(Throwable t) {\n                 abortObtain(allocator);\n                 listener.onAbort(t);\n             }\n-        }).addEventListener(tryObtainListener);\n+        }).whenComplete(tryObtainListener);\n         return tryObtainPromise;\n     }\n \n@@ -399,7 +396,7 @@ void abortObtain(SimpleLedgerAllocator allocator) {\n     }\n \n     @Override\n-    public Future<Void> asyncClose() {\n+    public CompletableFuture<Void> asyncClose() {\n         List<LedgerAllocator> allocatorsToClose;\n         synchronized (this) {\n             allocatorsToClose = Lists.newArrayListWithExpectedSize(\n@@ -414,21 +411,15 @@ public Future<Void> asyncClose() {\n                 allocatorsToClose.add(allocator);\n             }\n         }\n-        return FutureUtils.processList(allocatorsToClose, new Function<LedgerAllocator, Future<Void>>() {\n-            @Override\n-            public Future<Void> apply(LedgerAllocator allocator) {\n-                return allocator.asyncClose();\n-            }\n-        }, scheduledExecutorService).map(new AbstractFunction1<List<Void>, Void>() {\n-            @Override\n-            public Void apply(List<Void> values) {\n-                return null;\n-            }\n-        });\n+        return FutureUtils.processList(\n+            allocatorsToClose,\n+            allocator -> allocator.asyncClose(),\n+            scheduledExecutorService\n+        ).thenApply(values -> null);\n     }\n \n     @Override\n-    public Future<Void> delete() {\n+    public CompletableFuture<Void> delete() {\n         List<LedgerAllocator> allocatorsToDelete;\n         synchronized (this) {\n             allocatorsToDelete = Lists.newArrayListWithExpectedSize(\n@@ -443,16 +434,10 @@ public Future<Void> delete() {\n                 allocatorsToDelete.add(allocator);\n             }\n         }\n-        return FutureUtils.processList(allocatorsToDelete, new Function<LedgerAllocator, Future<Void>>() {\n-            @Override\n-            public Future<Void> apply(LedgerAllocator allocator) {\n-                return allocator.delete();\n-            }\n-        }, scheduledExecutorService).flatMap(new AbstractFunction1<List<Void>, Future<Void>>() {\n-            @Override\n-            public Future<Void> apply(List<Void> values) {\n-                return Utils.zkDelete(zkc, poolPath, new ZkVersion(-1));\n-            }\n-        });\n+        return FutureUtils.processList(\n+            allocatorsToDelete,\n+            allocator -> allocator.delete(),\n+            scheduledExecutorService\n+        ).thenCompose(values -> Utils.zkDelete(zkc, poolPath, new ZkVersion(-1)));\n     }\n }"},{"sha":"144b0a6e2a0b9523f5f201da3ced4e4facbb945b","filename":"src/main/java/org/apache/distributedlog/bk/SimpleLedgerAllocator.java","status":"modified","additions":55,"deletions":71,"changes":126,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fbk%2FSimpleLedgerAllocator.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fbk%2FSimpleLedgerAllocator.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fbk%2FSimpleLedgerAllocator.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -18,19 +18,20 @@\n package org.apache.distributedlog.bk;\n \n import com.google.common.collect.Lists;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n import org.apache.distributedlog.BookKeeperClient;\n import org.apache.distributedlog.DistributedLogConstants;\n import org.apache.distributedlog.util.DLUtils;\n+import org.apache.distributedlog.common.concurrent.FutureEventListener;\n import org.apache.distributedlog.util.Transaction;\n import org.apache.distributedlog.util.Transaction.OpListener;\n import org.apache.distributedlog.ZooKeeperClient;\n-import org.apache.distributedlog.util.FutureUtils;\n+import org.apache.distributedlog.common.concurrent.FutureUtils;\n import org.apache.distributedlog.util.Utils;\n import org.apache.distributedlog.zk.ZKTransaction;\n import org.apache.distributedlog.zk.ZKVersionedSetOp;\n-import com.twitter.util.Future;\n-import com.twitter.util.FutureEventListener;\n-import com.twitter.util.Promise;\n import org.apache.bookkeeper.client.LedgerHandle;\n import org.apache.bookkeeper.meta.ZkVersion;\n import org.apache.bookkeeper.versioning.Version;\n@@ -40,9 +41,6 @@\n import org.apache.zookeeper.data.Stat;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n-import scala.runtime.AbstractFunction0;\n-import scala.runtime.AbstractFunction1;\n-import scala.runtime.BoxedUnit;\n \n import java.io.IOException;\n import java.util.LinkedList;\n@@ -96,7 +94,7 @@ public ConcurrentObtainException(Phase phase, String msg) {\n     // version\n     ZkVersion version = new ZkVersion(-1);\n     // outstanding allocation\n-    Promise<LedgerHandle> allocatePromise;\n+    CompletableFuture<LedgerHandle> allocatePromise;\n     // outstanding tryObtain transaction\n     Transaction<Object> tryObtainTxn = null;\n     OpListener<LedgerHandle> tryObtainListener = null;\n@@ -105,73 +103,71 @@ public ConcurrentObtainException(Phase phase, String msg) {\n     // Allocated Ledger\n     LedgerHandle allocatedLh = null;\n \n-    Future<Void> closeFuture = null;\n-    final LinkedList<Future<Void>> ledgerDeletions =\n-            new LinkedList<Future<Void>>();\n+    CompletableFuture<Void> closeFuture = null;\n+    final LinkedList<CompletableFuture<Void>> ledgerDeletions =\n+            new LinkedList<CompletableFuture<Void>>();\n \n     // Ledger configuration\n     private final QuorumConfigProvider quorumConfigProvider;\n \n-    static Future<Versioned<byte[]>> getAndCreateAllocationData(final String allocatePath,\n+    static CompletableFuture<Versioned<byte[]>> getAndCreateAllocationData(final String allocatePath,\n                                                                 final ZooKeeperClient zkc) {\n         return Utils.zkGetData(zkc, allocatePath, false)\n-                .flatMap(new AbstractFunction1<Versioned<byte[]>, Future<Versioned<byte[]>>>() {\n+                .thenCompose(new Function<Versioned<byte[]>, CompletionStage<Versioned<byte[]>>>() {\n             @Override\n-            public Future<Versioned<byte[]>> apply(Versioned<byte[]> result) {\n+            public CompletableFuture<Versioned<byte[]>> apply(Versioned<byte[]> result) {\n                 if (null != result && null != result.getVersion() && null != result.getValue()) {\n-                    return Future.value(result);\n+                    return FutureUtils.value(result);\n                 }\n                 return createAllocationData(allocatePath, zkc);\n             }\n         });\n     }\n \n-    private static Future<Versioned<byte[]>> createAllocationData(final String allocatePath,\n+    private static CompletableFuture<Versioned<byte[]>> createAllocationData(final String allocatePath,\n                                                                   final ZooKeeperClient zkc) {\n         try {\n-            final Promise<Versioned<byte[]>> promise = new Promise<Versioned<byte[]>>();\n+            final CompletableFuture<Versioned<byte[]>> promise = new CompletableFuture<Versioned<byte[]>>();\n             zkc.get().create(allocatePath, DistributedLogConstants.EMPTY_BYTES,\n                     zkc.getDefaultACL(), CreateMode.PERSISTENT,\n                     new org.apache.zookeeper.AsyncCallback.Create2Callback() {\n                         @Override\n                         public void processResult(int rc, String path, Object ctx, String name, Stat stat) {\n                             if (KeeperException.Code.OK.intValue() == rc) {\n-                                promise.setValue(new Versioned<byte[]>(DistributedLogConstants.EMPTY_BYTES,\n+                                promise.complete(new Versioned<byte[]>(DistributedLogConstants.EMPTY_BYTES,\n                                         new ZkVersion(stat.getVersion())));\n                             } else if (KeeperException.Code.NODEEXISTS.intValue() == rc) {\n-                                Utils.zkGetData(zkc, allocatePath, false).proxyTo(promise);\n+                                FutureUtils.proxyTo(\n+                                  Utils.zkGetData(zkc, allocatePath, false),\n+                                  promise\n+                                );\n                             } else {\n-                                promise.setException(FutureUtils.zkException(\n+                                promise.completeExceptionally(Utils.zkException(\n                                         KeeperException.create(KeeperException.Code.get(rc)), allocatePath));\n                             }\n                         }\n                     }, null);\n             return promise;\n         } catch (ZooKeeperClient.ZooKeeperConnectionException e) {\n-            return Future.exception(FutureUtils.zkException(e, allocatePath));\n+            return FutureUtils.exception(Utils.zkException(e, allocatePath));\n         } catch (InterruptedException e) {\n-            return Future.exception(FutureUtils.zkException(e, allocatePath));\n+            return FutureUtils.exception(Utils.zkException(e, allocatePath));\n         }\n     }\n \n-    public static Future<SimpleLedgerAllocator> of(final String allocatePath,\n+    public static CompletableFuture<SimpleLedgerAllocator> of(final String allocatePath,\n                                                    final Versioned<byte[]> allocationData,\n                                                    final QuorumConfigProvider quorumConfigProvider,\n                                                    final ZooKeeperClient zkc,\n                                                    final BookKeeperClient bkc) {\n         if (null != allocationData && null != allocationData.getValue()\n                 && null != allocationData.getVersion()) {\n-            return Future.value(new SimpleLedgerAllocator(allocatePath, allocationData,\n+            return FutureUtils.value(new SimpleLedgerAllocator(allocatePath, allocationData,\n                     quorumConfigProvider, zkc, bkc));\n         }\n         return getAndCreateAllocationData(allocatePath, zkc)\n-                .map(new AbstractFunction1<Versioned<byte[]>, SimpleLedgerAllocator>() {\n-            @Override\n-            public SimpleLedgerAllocator apply(Versioned<byte[]> allocationData) {\n-                return new SimpleLedgerAllocator(allocatePath, allocationData,\n-                        quorumConfigProvider, zkc, bkc);\n-            }\n-        });\n+            .thenApply(allocationData1 -> new SimpleLedgerAllocator(allocatePath, allocationData1,\n+                        quorumConfigProvider, zkc, bkc));\n     }\n \n     /**\n@@ -240,14 +236,14 @@ public synchronized void allocate() throws IOException {\n     }\n \n     @Override\n-    public synchronized Future<LedgerHandle> tryObtain(final Transaction<Object> txn,\n-                                                       final OpListener<LedgerHandle> listener) {\n+    public synchronized CompletableFuture<LedgerHandle> tryObtain(final Transaction<Object> txn,\n+                                                                  final OpListener<LedgerHandle> listener) {\n         if (Phase.ERROR == phase) {\n-            return Future.exception(new AllocationException(Phase.ERROR,\n+            return FutureUtils.exception(new AllocationException(Phase.ERROR,\n                     \"Error on allocating ledger under \" + allocatePath));\n         }\n         if (Phase.HANDING_OVER == phase || Phase.HANDED_OVER == phase || null != tryObtainTxn) {\n-            return Future.exception(new ConcurrentObtainException(phase,\n+            return FutureUtils.exception(new ConcurrentObtainException(phase,\n                     \"Ledger handle is handling over to another thread : \" + phase));\n         }\n         tryObtainTxn = txn;\n@@ -328,13 +324,13 @@ private synchronized void allocateLedger() {\n             return;\n         }\n         setPhase(Phase.ALLOCATING);\n-        allocatePromise = new Promise<LedgerHandle>();\n+        allocatePromise = new CompletableFuture<LedgerHandle>();\n         QuorumConfig quorumConfig = quorumConfigProvider.getQuorumConfig();\n         bkc.createLedger(\n                 quorumConfig.getEnsembleSize(),\n                 quorumConfig.getWriteQuorumSize(),\n                 quorumConfig.getAckQuorumSize()\n-        ).addEventListener(this);\n+        ).whenComplete(this);\n     }\n \n     private synchronized void completeAllocation(LedgerHandle lh) {\n@@ -347,11 +343,11 @@ private synchronized void completeAllocation(LedgerHandle lh) {\n         ZKVersionedSetOp commitOp = new ZKVersionedSetOp(zkSetDataOp, this);\n         tryObtainTxn.addOp(commitOp);\n         setPhase(Phase.HANDING_OVER);\n-        FutureUtils.setValue(allocatePromise, lh);\n+        allocatePromise.complete(lh);\n     }\n \n     private synchronized void failAllocation(Throwable cause) {\n-        FutureUtils.setException(allocatePromise, cause);\n+        allocatePromise.completeExceptionally(cause);\n     }\n \n     @Override\n@@ -386,7 +382,7 @@ private synchronized void setVersion(ZkVersion newVersion) {\n     private void markAsAllocated(final LedgerHandle lh) {\n         byte[] data = DLUtils.logSegmentId2Bytes(lh.getId());\n         Utils.zkSetData(zkc, allocatePath, data, getVersion())\n-            .addEventListener(new FutureEventListener<ZkVersion>() {\n+            .whenComplete(new FutureEventListener<ZkVersion>() {\n                 @Override\n                 public void onSuccess(ZkVersion version) {\n                     // we only issue deleting ledger left from previous allocation when we could allocate first ledger\n@@ -411,27 +407,20 @@ public void onFailure(Throwable cause) {\n     }\n \n     void deleteLedger(final long ledgerId) {\n-        final Future<Void> deleteFuture = bkc.deleteLedger(ledgerId, true);\n+        final CompletableFuture<Void> deleteFuture = bkc.deleteLedger(ledgerId, true);\n         synchronized (ledgerDeletions) {\n             ledgerDeletions.add(deleteFuture);\n         }\n-        deleteFuture.onFailure(new AbstractFunction1<Throwable, BoxedUnit>() {\n-            @Override\n-            public BoxedUnit apply(Throwable cause) {\n+        deleteFuture.whenComplete((value, cause) -> {\n+            if (null != cause) {\n                 LOG.error(\"Error deleting ledger {} for ledger allocator {}, retrying : \",\n                         new Object[] { ledgerId, allocatePath, cause });\n                 if (!isClosing()) {\n                     deleteLedger(ledgerId);\n                 }\n-                return BoxedUnit.UNIT;\n             }\n-        }).ensure(new AbstractFunction0<BoxedUnit>() {\n-            @Override\n-            public BoxedUnit apply() {\n-                synchronized (ledgerDeletions) {\n-                    ledgerDeletions.remove(deleteFuture);\n-                }\n-                return BoxedUnit.UNIT;\n+            synchronized (ledgerDeletions) {\n+                ledgerDeletions.remove(deleteFuture);\n             }\n         });\n     }\n@@ -440,25 +429,25 @@ private synchronized boolean isClosing() {\n         return closeFuture != null;\n     }\n \n-    private Future<Void> closeInternal(boolean cleanup) {\n-        Promise<Void> closePromise;\n+    private CompletableFuture<Void> closeInternal(boolean cleanup) {\n+        CompletableFuture<Void> closePromise;\n         synchronized (this) {\n             if (null != closeFuture) {\n                 return closeFuture;\n             }\n-            closePromise = new Promise<Void>();\n+            closePromise = new CompletableFuture<Void>();\n             closeFuture = closePromise;\n         }\n         if (!cleanup) {\n             LOG.info(\"Abort ledger allocator without cleaning up on {}.\", allocatePath);\n-            FutureUtils.setValue(closePromise, null);\n+            closePromise.complete(null);\n             return closePromise;\n         }\n         cleanupAndClose(closePromise);\n         return closePromise;\n     }\n \n-    private void cleanupAndClose(final Promise<Void> closePromise) {\n+    private void cleanupAndClose(final CompletableFuture<Void> closePromise) {\n         LOG.info(\"Closing ledger allocator on {}.\", allocatePath);\n         final ZKTransaction txn = new ZKTransaction(zkc);\n         // try obtain ledger handle\n@@ -476,21 +465,21 @@ public void onAbort(Throwable t) {\n             }\n \n             private void complete() {\n-                FutureUtils.setValue(closePromise, null);\n+                closePromise.complete(null);\n                 LOG.info(\"Closed ledger allocator on {}.\", allocatePath);\n             }\n-        }).addEventListener(new FutureEventListener<LedgerHandle>() {\n+        }).whenComplete(new FutureEventListener<LedgerHandle>() {\n             @Override\n             public void onSuccess(LedgerHandle lh) {\n                 // try obtain succeed\n                 // if we could obtain the ledger handle, we have the responsibility to close it\n                 deleteLedger(lh.getId());\n                 // wait for deletion to be completed\n-                List<Future<Void>> outstandingDeletions;\n+                List<CompletableFuture<Void>> outstandingDeletions;\n                 synchronized (ledgerDeletions) {\n                     outstandingDeletions = Lists.newArrayList(ledgerDeletions);\n                 }\n-                Future.collect(outstandingDeletions).addEventListener(new FutureEventListener<List<Void>>() {\n+                FutureUtils.collect(outstandingDeletions).whenComplete(new FutureEventListener<List<Void>>() {\n                     @Override\n                     public void onSuccess(List<Void> values) {\n                         txn.execute();\n@@ -499,15 +488,15 @@ public void onSuccess(List<Void> values) {\n                     @Override\n                     public void onFailure(Throwable cause) {\n                         LOG.debug(\"Fail to obtain the allocated ledger handle when closing the allocator : \", cause);\n-                        FutureUtils.setValue(closePromise, null);\n+                        closePromise.complete(null);\n                     }\n                 });\n             }\n \n             @Override\n             public void onFailure(Throwable cause) {\n                 LOG.debug(\"Fail to obtain the allocated ledger handle when closing the allocator : \", cause);\n-                FutureUtils.setValue(closePromise, null);\n+                closePromise.complete(null);\n             }\n         });\n \n@@ -519,18 +508,13 @@ public void start() {\n     }\n \n     @Override\n-    public Future<Void> asyncClose() {\n+    public CompletableFuture<Void> asyncClose() {\n         return closeInternal(false);\n     }\n \n     @Override\n-    public Future<Void> delete() {\n-        return closeInternal(true).flatMap(new AbstractFunction1<Void, Future<Void>>() {\n-            @Override\n-            public Future<Void> apply(Void value) {\n-                return Utils.zkDelete(zkc, allocatePath, getVersion());\n-            }\n-        });\n+    public CompletableFuture<Void> delete() {\n+        return closeInternal(true).thenCompose(value -> Utils.zkDelete(zkc, allocatePath, getVersion()));\n     }\n \n }"},{"sha":"f189ad34830f825b94004168cebbce75c3cb88f1","filename":"src/main/java/org/apache/distributedlog/config/ConcurrentBaseConfiguration.java","status":"removed","additions":0,"deletions":76,"changes":76,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/46e6b70feda2e8ad61ba13928df93b2c94d3dd4e/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fconfig%2FConcurrentBaseConfiguration.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/46e6b70feda2e8ad61ba13928df93b2c94d3dd4e/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fconfig%2FConcurrentBaseConfiguration.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fconfig%2FConcurrentBaseConfiguration.java?ref=46e6b70feda2e8ad61ba13928df93b2c94d3dd4e","patch":"@@ -1,76 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.distributedlog.config;\n-\n-import com.google.common.base.Preconditions;\n-\n-import org.apache.commons.configuration.AbstractConfiguration;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import java.util.Iterator;\n-import java.util.concurrent.ConcurrentHashMap;\n-\n-/**\n- * Configuration view built on concurrent hash map for fast thread-safe access.\n- * Notes:\n- * 1. Multi-property list aggregation will not work in this class. I.e. commons config\n- * normally combines all properties with the same key into one list property automatically.\n- * This class simply overwrites any existing mapping.\n- */\n-public class ConcurrentBaseConfiguration extends AbstractConfiguration {\n-    static final Logger LOG = LoggerFactory.getLogger(ConcurrentBaseConfiguration.class);\n-\n-    private final ConcurrentHashMap<String, Object> map;\n-\n-    public ConcurrentBaseConfiguration() {\n-        this.map = new ConcurrentHashMap<String, Object>();\n-    }\n-\n-    @Override\n-    protected void addPropertyDirect(String key, Object value) {\n-        Preconditions.checkNotNull(value);\n-        map.put(key, value);\n-    }\n-\n-    @Override\n-    public Object getProperty(String key) {\n-        return map.get(key);\n-    }\n-\n-    @Override\n-    public Iterator getKeys() {\n-        return map.keySet().iterator();\n-    }\n-\n-    @Override\n-    public boolean containsKey(String key) {\n-        return map.containsKey(key);\n-    }\n-\n-    @Override\n-    public boolean isEmpty() {\n-        return map.isEmpty();\n-    }\n-\n-    @Override\n-    protected void clearPropertyDirect(String key) {\n-        map.remove(key);\n-    }\n-}"},{"sha":"4e7f886439ed8b52ea03d649dc465ac9f25ee1a6","filename":"src/main/java/org/apache/distributedlog/config/ConcurrentConstConfiguration.java","status":"removed","additions":0,"deletions":31,"changes":31,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/46e6b70feda2e8ad61ba13928df93b2c94d3dd4e/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fconfig%2FConcurrentConstConfiguration.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/46e6b70feda2e8ad61ba13928df93b2c94d3dd4e/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fconfig%2FConcurrentConstConfiguration.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fconfig%2FConcurrentConstConfiguration.java?ref=46e6b70feda2e8ad61ba13928df93b2c94d3dd4e","patch":"@@ -1,31 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.distributedlog.config;\n-\n-import com.google.common.base.Preconditions;\n-import org.apache.commons.configuration.Configuration;\n-\n-/**\n- * Invariant thread-safe view of some configuration.\n- */\n-public class ConcurrentConstConfiguration extends ConcurrentBaseConfiguration {\n-    public ConcurrentConstConfiguration(Configuration conf) {\n-        Preconditions.checkNotNull(conf);\n-        copy(conf);\n-    }\n-}"},{"sha":"70059d4f470d39fc17b8122e04d7b0dee65c3dd7","filename":"src/main/java/org/apache/distributedlog/config/ConfigurationListener.java","status":"removed","additions":0,"deletions":32,"changes":32,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/46e6b70feda2e8ad61ba13928df93b2c94d3dd4e/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fconfig%2FConfigurationListener.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/46e6b70feda2e8ad61ba13928df93b2c94d3dd4e/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fconfig%2FConfigurationListener.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fconfig%2FConfigurationListener.java?ref=46e6b70feda2e8ad61ba13928df93b2c94d3dd4e","patch":"@@ -1,32 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.distributedlog.config;\n-\n-/**\n- * Configuration listener triggered when reloading configuration settings.\n- */\n-public interface ConfigurationListener {\n-\n-    /**\n-     * Reload the configuration.\n-     *\n-     * @param conf configuration to reload\n-     */\n-    void onReload(ConcurrentBaseConfiguration conf);\n-\n-}"},{"sha":"0e5c8975c502826f2c0facf8d2a73c929c207536","filename":"src/main/java/org/apache/distributedlog/config/ConfigurationSubscription.java","status":"removed","additions":0,"deletions":186,"changes":186,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/46e6b70feda2e8ad61ba13928df93b2c94d3dd4e/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fconfig%2FConfigurationSubscription.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/46e6b70feda2e8ad61ba13928df93b2c94d3dd4e/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fconfig%2FConfigurationSubscription.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fconfig%2FConfigurationSubscription.java?ref=46e6b70feda2e8ad61ba13928df93b2c94d3dd4e","patch":"@@ -1,186 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.distributedlog.config;\n-\n-import java.io.FileNotFoundException;\n-import java.util.List;\n-import java.util.Set;\n-import java.util.concurrent.CopyOnWriteArraySet;\n-import java.util.concurrent.ScheduledExecutorService;\n-import java.util.concurrent.TimeUnit;\n-import java.util.Iterator;\n-\n-import com.google.common.annotations.VisibleForTesting;\n-import com.google.common.collect.Lists;\n-import com.google.common.base.Preconditions;\n-import com.google.common.collect.Sets;\n-import org.apache.commons.configuration.ConfigurationException;\n-import org.apache.commons.configuration.FileConfiguration;\n-import org.apache.commons.configuration.reloading.FileChangedReloadingStrategy;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-/**\n- * ConfigurationSubscription publishes a reloading, thread-safe view of file configuration. The class\n- * periodically calls FileConfiguration.reload on the underlying conf, and propagates changes to the\n- * concurrent config. The configured FileChangedReloadingStrategy ensures that file config will only\n- * be reloaded if something changed.\n- * Notes:\n- * 1. Reload schedule is never terminated. The assumption is a finite number of these are started\n- * at the calling layer, and terminated only once the executor service is shut down.\n- * 2. The underlying FileConfiguration is not at all thread-safe, so its important to ensure access\n- * to this object is always single threaded.\n- */\n-public class ConfigurationSubscription {\n-    static final Logger LOG = LoggerFactory.getLogger(ConfigurationSubscription.class);\n-\n-    private final ConcurrentBaseConfiguration viewConfig;\n-    private final ScheduledExecutorService executorService;\n-    private final int reloadPeriod;\n-    private final TimeUnit reloadUnit;\n-    private final List<FileConfigurationBuilder> fileConfigBuilders;\n-    private final List<FileConfiguration> fileConfigs;\n-    private final CopyOnWriteArraySet<ConfigurationListener> confListeners;\n-\n-    public ConfigurationSubscription(ConcurrentBaseConfiguration viewConfig,\n-                                     List<FileConfigurationBuilder> fileConfigBuilders,\n-                                     ScheduledExecutorService executorService,\n-                                     int reloadPeriod,\n-                                     TimeUnit reloadUnit)\n-            throws ConfigurationException {\n-        Preconditions.checkNotNull(fileConfigBuilders);\n-        Preconditions.checkArgument(!fileConfigBuilders.isEmpty());\n-        Preconditions.checkNotNull(executorService);\n-        Preconditions.checkNotNull(viewConfig);\n-        this.viewConfig = viewConfig;\n-        this.executorService = executorService;\n-        this.reloadPeriod = reloadPeriod;\n-        this.reloadUnit = reloadUnit;\n-        this.fileConfigBuilders = fileConfigBuilders;\n-        this.fileConfigs = Lists.newArrayListWithExpectedSize(this.fileConfigBuilders.size());\n-        this.confListeners = new CopyOnWriteArraySet<ConfigurationListener>();\n-        reload();\n-        scheduleReload();\n-    }\n-\n-    public void registerListener(ConfigurationListener listener) {\n-        this.confListeners.add(listener);\n-    }\n-\n-    public void unregisterListener(ConfigurationListener listener) {\n-        this.confListeners.remove(listener);\n-    }\n-\n-    private boolean initConfig() {\n-        if (fileConfigs.isEmpty()) {\n-            try {\n-                for (FileConfigurationBuilder fileConfigBuilder : fileConfigBuilders) {\n-                    FileConfiguration fileConfig = fileConfigBuilder.getConfiguration();\n-                    FileChangedReloadingStrategy reloadingStrategy = new FileChangedReloadingStrategy();\n-                    reloadingStrategy.setRefreshDelay(0);\n-                    fileConfig.setReloadingStrategy(reloadingStrategy);\n-                    fileConfigs.add(fileConfig);\n-                }\n-            } catch (ConfigurationException ex) {\n-                if (!fileNotFound(ex)) {\n-                    LOG.error(\"Config init failed {}\", ex);\n-                }\n-            }\n-        }\n-        return !fileConfigs.isEmpty();\n-    }\n-\n-    private void scheduleReload() {\n-        executorService.scheduleAtFixedRate(new Runnable() {\n-            @Override\n-            public void run() {\n-                reload();\n-            }\n-        }, 0, reloadPeriod, reloadUnit);\n-    }\n-\n-    @VisibleForTesting\n-    void reload() {\n-        // No-op if already loaded.\n-        if (!initConfig()) {\n-            return;\n-        }\n-        // Reload if config exists.\n-        Set<String> confKeys = Sets.newHashSet();\n-        for (FileConfiguration fileConfig : fileConfigs) {\n-            LOG.debug(\"Check and reload config, file={}, lastModified={}\", fileConfig.getFile(),\n-                    fileConfig.getFile().lastModified());\n-            fileConfig.reload();\n-            // load keys\n-            Iterator keyIter = fileConfig.getKeys();\n-            while (keyIter.hasNext()) {\n-                String key = (String) keyIter.next();\n-                confKeys.add(key);\n-            }\n-        }\n-        // clear unexisted keys\n-        Iterator viewIter = viewConfig.getKeys();\n-        while (viewIter.hasNext()) {\n-            String key = (String) viewIter.next();\n-            if (!confKeys.contains(key)) {\n-                clearViewProperty(key);\n-            }\n-        }\n-        LOG.info(\"Reload features : {}\", confKeys);\n-        // load keys from files\n-        for (FileConfiguration fileConfig : fileConfigs) {\n-            try {\n-                loadView(fileConfig);\n-            } catch (Exception ex) {\n-                if (!fileNotFound(ex)) {\n-                    LOG.error(\"Config reload failed for file {}\", fileConfig.getFileName(), ex);\n-                }\n-            }\n-        }\n-        for (ConfigurationListener listener : confListeners) {\n-            listener.onReload(viewConfig);\n-        }\n-    }\n-\n-    private boolean fileNotFound(Exception ex) {\n-        return ex instanceof FileNotFoundException ||\n-                ex.getCause() != null && ex.getCause() instanceof FileNotFoundException;\n-    }\n-\n-    private void loadView(FileConfiguration fileConfig) {\n-        Iterator fileIter = fileConfig.getKeys();\n-        while (fileIter.hasNext()) {\n-            String key = (String) fileIter.next();\n-            setViewProperty(fileConfig, key, fileConfig.getProperty(key));\n-        }\n-    }\n-\n-    private void clearViewProperty(String key) {\n-        LOG.debug(\"Removing property, key={}\", key);\n-        viewConfig.clearProperty(key);\n-    }\n-\n-    private void setViewProperty(FileConfiguration fileConfig,\n-                                 String key,\n-                                 Object value) {\n-        if (!viewConfig.containsKey(key) || !viewConfig.getProperty(key).equals(value)) {\n-            LOG.debug(\"Setting property, key={} value={}\", key, fileConfig.getProperty(key));\n-            viewConfig.setProperty(key, fileConfig.getProperty(key));\n-        }\n-    }\n-}"},{"sha":"c69b7a5f786d94feee14849baae909a58a46620b","filename":"src/main/java/org/apache/distributedlog/config/DynamicConfigurationFactory.java","status":"modified","additions":5,"deletions":1,"changes":6,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fconfig%2FDynamicConfigurationFactory.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fconfig%2FDynamicConfigurationFactory.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fconfig%2FDynamicConfigurationFactory.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -24,7 +24,6 @@\n import org.apache.distributedlog.DistributedLogConfiguration;\n \n import java.io.File;\n-import java.io.FileNotFoundException;\n import java.net.MalformedURLException;\n import java.util.HashMap;\n import java.util.LinkedList;\n@@ -35,6 +34,11 @@\n \n import org.apache.commons.configuration.ConfigurationException;\n \n+import org.apache.distributedlog.common.config.ConcurrentBaseConfiguration;\n+import org.apache.distributedlog.common.config.ConcurrentConstConfiguration;\n+import org.apache.distributedlog.common.config.ConfigurationSubscription;\n+import org.apache.distributedlog.common.config.FileConfigurationBuilder;\n+import org.apache.distributedlog.common.config.PropertiesConfigurationBuilder;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n "},{"sha":"9e760c583b1f0bacec192a2631182cea118948a2","filename":"src/main/java/org/apache/distributedlog/config/DynamicDistributedLogConfiguration.java","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fconfig%2FDynamicDistributedLogConfiguration.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fconfig%2FDynamicDistributedLogConfiguration.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fconfig%2FDynamicDistributedLogConfiguration.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -19,6 +19,7 @@\n \n import org.apache.distributedlog.DistributedLogConfiguration;\n import org.apache.distributedlog.bk.QuorumConfig;\n+import org.apache.distributedlog.common.config.ConcurrentBaseConfiguration;\n \n import static org.apache.distributedlog.DistributedLogConfiguration.*;\n "},{"sha":"dbf8fe7eeecccb233496967ee9b4ffd084da8b97","filename":"src/main/java/org/apache/distributedlog/config/FileConfigurationBuilder.java","status":"removed","additions":0,"deletions":28,"changes":28,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/46e6b70feda2e8ad61ba13928df93b2c94d3dd4e/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fconfig%2FFileConfigurationBuilder.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/46e6b70feda2e8ad61ba13928df93b2c94d3dd4e/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fconfig%2FFileConfigurationBuilder.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fconfig%2FFileConfigurationBuilder.java?ref=46e6b70feda2e8ad61ba13928df93b2c94d3dd4e","patch":"@@ -1,28 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.distributedlog.config;\n-\n-import org.apache.commons.configuration.ConfigurationException;\n-import org.apache.commons.configuration.FileConfiguration;\n-\n-/**\n- * Abstract out FileConfiguration subclass construction.\n- */\n-public interface FileConfigurationBuilder {\n-    FileConfiguration getConfiguration() throws ConfigurationException;\n-}"},{"sha":"df1408ce26380f733c70bf5027f1a1fc6ac13695","filename":"src/main/java/org/apache/distributedlog/config/PropertiesConfigurationBuilder.java","status":"removed","additions":0,"deletions":40,"changes":40,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/46e6b70feda2e8ad61ba13928df93b2c94d3dd4e/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fconfig%2FPropertiesConfigurationBuilder.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/46e6b70feda2e8ad61ba13928df93b2c94d3dd4e/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fconfig%2FPropertiesConfigurationBuilder.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fconfig%2FPropertiesConfigurationBuilder.java?ref=46e6b70feda2e8ad61ba13928df93b2c94d3dd4e","patch":"@@ -1,40 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.distributedlog.config;\n-\n-import java.net.URL;\n-\n-import org.apache.commons.configuration.ConfigurationException;\n-import org.apache.commons.configuration.FileConfiguration;\n-import org.apache.commons.configuration.PropertiesConfiguration;\n-\n-/**\n- * Hide PropertiesConfiguration dependency.\n- */\n-public class PropertiesConfigurationBuilder implements FileConfigurationBuilder {\n-    private URL url;\n-\n-    public PropertiesConfigurationBuilder(URL url) {\n-        this.url = url;\n-    }\n-\n-    @Override\n-    public FileConfiguration getConfiguration() throws ConfigurationException {\n-        return new PropertiesConfiguration(url);\n-    }\n-}"},{"sha":"f51302e8fdbdf7ea4f81f50accc02a5a5a5c9c24","filename":"src/main/java/org/apache/distributedlog/feature/ConfigurationFeatureProvider.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Ffeature%2FConfigurationFeatureProvider.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Ffeature%2FConfigurationFeatureProvider.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Ffeature%2FConfigurationFeatureProvider.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -17,7 +17,7 @@\n  */\n package org.apache.distributedlog.feature;\n \n-import org.apache.distributedlog.config.ConcurrentBaseConfiguration;\n+import org.apache.distributedlog.common.config.ConcurrentBaseConfiguration;\n import org.apache.bookkeeper.feature.CacheableFeatureProvider;\n import org.apache.bookkeeper.feature.Feature;\n import org.apache.bookkeeper.feature.FeatureProvider;"},{"sha":"201ed8ae45a169bc8b44bc7cfb4c1d52724b62a6","filename":"src/main/java/org/apache/distributedlog/feature/DynamicConfigurationFeatureProvider.java","status":"modified","additions":5,"deletions":5,"changes":10,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Ffeature%2FDynamicConfigurationFeatureProvider.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Ffeature%2FDynamicConfigurationFeatureProvider.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Ffeature%2FDynamicConfigurationFeatureProvider.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -21,11 +21,11 @@\n import com.google.common.collect.Lists;\n import com.google.common.util.concurrent.ThreadFactoryBuilder;\n import org.apache.distributedlog.DistributedLogConfiguration;\n-import org.apache.distributedlog.config.ConcurrentBaseConfiguration;\n-import org.apache.distributedlog.config.ConfigurationListener;\n-import org.apache.distributedlog.config.ConfigurationSubscription;\n-import org.apache.distributedlog.config.FileConfigurationBuilder;\n-import org.apache.distributedlog.config.PropertiesConfigurationBuilder;\n+import org.apache.distributedlog.common.config.ConcurrentBaseConfiguration;\n+import org.apache.distributedlog.common.config.ConfigurationListener;\n+import org.apache.distributedlog.common.config.ConfigurationSubscription;\n+import org.apache.distributedlog.common.config.FileConfigurationBuilder;\n+import org.apache.distributedlog.common.config.PropertiesConfigurationBuilder;\n import org.apache.bookkeeper.feature.Feature;\n import org.apache.bookkeeper.feature.FeatureProvider;\n import org.apache.bookkeeper.feature.SettableFeature;"},{"sha":"b1adf4ad7f5ff9748197262da8fb2c98376f07b8","filename":"src/main/java/org/apache/distributedlog/function/CloseAsyncCloseableFunction.java","status":"removed","additions":0,"deletions":51,"changes":51,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/46e6b70feda2e8ad61ba13928df93b2c94d3dd4e/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Ffunction%2FCloseAsyncCloseableFunction.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/46e6b70feda2e8ad61ba13928df93b2c94d3dd4e/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Ffunction%2FCloseAsyncCloseableFunction.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Ffunction%2FCloseAsyncCloseableFunction.java?ref=46e6b70feda2e8ad61ba13928df93b2c94d3dd4e","patch":"@@ -1,51 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.distributedlog.function;\n-\n-import org.apache.distributedlog.io.AsyncCloseable;\n-import scala.Function0;\n-import scala.runtime.AbstractFunction0;\n-import scala.runtime.BoxedUnit;\n-\n-/**\n- * Function to close {@link org.apache.distributedlog.io.AsyncCloseable}\n- */\n-public class CloseAsyncCloseableFunction extends AbstractFunction0<BoxedUnit> {\n-\n-    /**\n-     * Return a function to close an {@link AsyncCloseable}.\n-     *\n-     * @param closeable closeable to close\n-     * @return function to close an {@link AsyncCloseable}\n-     */\n-    public static Function0<BoxedUnit> of(AsyncCloseable closeable) {\n-        return new CloseAsyncCloseableFunction(closeable);\n-    }\n-\n-    private final AsyncCloseable closeable;\n-\n-    private CloseAsyncCloseableFunction(AsyncCloseable closeable) {\n-        this.closeable = closeable;\n-    }\n-\n-    @Override\n-    public BoxedUnit apply() {\n-        closeable.asyncClose();\n-        return BoxedUnit.UNIT;\n-    }\n-}"},{"sha":"6360f2cb54ca156106734778e4a9ed083e849621","filename":"src/main/java/org/apache/distributedlog/function/DefaultValueMapFunction.java","status":"removed","additions":0,"deletions":41,"changes":41,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/46e6b70feda2e8ad61ba13928df93b2c94d3dd4e/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Ffunction%2FDefaultValueMapFunction.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/46e6b70feda2e8ad61ba13928df93b2c94d3dd4e/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Ffunction%2FDefaultValueMapFunction.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Ffunction%2FDefaultValueMapFunction.java?ref=46e6b70feda2e8ad61ba13928df93b2c94d3dd4e","patch":"@@ -1,41 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.distributedlog.function;\n-\n-import scala.runtime.AbstractFunction1;\n-\n-/**\n- * Map Function return default value\n- */\n-public class DefaultValueMapFunction<T, R> extends AbstractFunction1<T, R> {\n-\n-    public static <T, R> DefaultValueMapFunction<T, R> of(R defaultValue) {\n-        return new DefaultValueMapFunction<T, R>(defaultValue);\n-    }\n-\n-    private final R defaultValue;\n-\n-    private DefaultValueMapFunction(R defaultValue) {\n-        this.defaultValue = defaultValue;\n-    }\n-\n-    @Override\n-    public R apply(T any) {\n-        return defaultValue;\n-    }\n-}"},{"sha":"00703e3b66fab8d6661c100b7ba709f3b36be539","filename":"src/main/java/org/apache/distributedlog/function/GetLastTxIdFunction.java","status":"modified","additions":3,"deletions":4,"changes":7,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Ffunction%2FGetLastTxIdFunction.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Ffunction%2FGetLastTxIdFunction.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Ffunction%2FGetLastTxIdFunction.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -17,16 +17,15 @@\n  */\n package org.apache.distributedlog.function;\n \n+import java.util.List;\n+import java.util.function.Function;\n import org.apache.distributedlog.DistributedLogConstants;\n import org.apache.distributedlog.LogSegmentMetadata;\n-import scala.runtime.AbstractFunction1;\n-\n-import java.util.List;\n \n /**\n  * Retrieve the last tx id from list of log segments\n  */\n-public class GetLastTxIdFunction extends AbstractFunction1<List<LogSegmentMetadata>, Long> {\n+public class GetLastTxIdFunction implements Function<List<LogSegmentMetadata>, Long> {\n \n     public static final GetLastTxIdFunction INSTANCE = new GetLastTxIdFunction();\n "},{"sha":"98164de5544744661f2405b823dac7dc32c17e08","filename":"src/main/java/org/apache/distributedlog/function/GetVersionedValueFunction.java","status":"removed","additions":0,"deletions":39,"changes":39,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/46e6b70feda2e8ad61ba13928df93b2c94d3dd4e/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Ffunction%2FGetVersionedValueFunction.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/46e6b70feda2e8ad61ba13928df93b2c94d3dd4e/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Ffunction%2FGetVersionedValueFunction.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Ffunction%2FGetVersionedValueFunction.java?ref=46e6b70feda2e8ad61ba13928df93b2c94d3dd4e","patch":"@@ -1,39 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.distributedlog.function;\n-\n-import org.apache.distributedlog.LogSegmentMetadata;\n-import org.apache.bookkeeper.versioning.Versioned;\n-import scala.Function1;\n-import scala.runtime.AbstractFunction1;\n-\n-import java.util.List;\n-\n-/**\n- * Function to get the versioned value from {@link org.apache.bookkeeper.versioning.Versioned}\n- */\n-public class GetVersionedValueFunction<T> extends AbstractFunction1<Versioned<T>, T> {\n-\n-    public static final Function1<Versioned<List<LogSegmentMetadata>>, List<LogSegmentMetadata>>\n-            GET_LOGSEGMENT_LIST_FUNC = new GetVersionedValueFunction<List<LogSegmentMetadata>>();\n-\n-    @Override\n-    public T apply(Versioned<T> versionedValue) {\n-        return versionedValue.getValue();\n-    }\n-}"},{"sha":"79f9c3231a73d56e7ddf0edc385b358ad5e383d6","filename":"src/main/java/org/apache/distributedlog/function/VoidFunctions.java","status":"removed","additions":0,"deletions":34,"changes":34,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/46e6b70feda2e8ad61ba13928df93b2c94d3dd4e/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Ffunction%2FVoidFunctions.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/46e6b70feda2e8ad61ba13928df93b2c94d3dd4e/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Ffunction%2FVoidFunctions.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Ffunction%2FVoidFunctions.java?ref=46e6b70feda2e8ad61ba13928df93b2c94d3dd4e","patch":"@@ -1,34 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.distributedlog.function;\n-\n-import scala.runtime.AbstractFunction1;\n-\n-import java.util.List;\n-\n-public class VoidFunctions {\n-\n-    public static final AbstractFunction1<List<Void>, Void> LIST_TO_VOID_FUNC =\n-            new AbstractFunction1<List<Void>, Void>() {\n-                @Override\n-                public Void apply(List<Void> list) {\n-                    return null;\n-                }\n-            };\n-\n-}"},{"sha":"21fe2279a52f1df4742a76ef703e54e4f0a4bedc","filename":"src/main/java/org/apache/distributedlog/impl/BKNamespaceDriver.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fimpl%2FBKNamespaceDriver.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fimpl%2FBKNamespaceDriver.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fimpl%2FBKNamespaceDriver.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -24,7 +24,7 @@\n import org.apache.distributedlog.BookKeeperClientBuilder;\n import org.apache.distributedlog.DistributedLogConfiguration;\n import org.apache.distributedlog.DistributedLogConstants;\n-import org.apache.distributedlog.MetadataAccessor;\n+import org.apache.distributedlog.api.MetadataAccessor;\n import org.apache.distributedlog.ZooKeeperClient;\n import org.apache.distributedlog.ZooKeeperClientBuilder;\n import org.apache.distributedlog.acl.AccessControlManager;\n@@ -47,7 +47,7 @@\n import org.apache.distributedlog.metadata.LogStreamMetadataStore;\n import org.apache.distributedlog.namespace.NamespaceDriver;\n import org.apache.distributedlog.namespace.NamespaceDriverManager;\n-import org.apache.distributedlog.subscription.SubscriptionsStore;\n+import org.apache.distributedlog.api.subscription.SubscriptionsStore;\n import org.apache.distributedlog.util.OrderedScheduler;\n import org.apache.distributedlog.util.Utils;\n import org.apache.bookkeeper.feature.FeatureProvider;"},{"sha":"7069cbb8d670d9d27b138a5323059f907da7102d","filename":"src/main/java/org/apache/distributedlog/impl/ZKLogMetadataStore.java","status":"modified","additions":18,"deletions":19,"changes":37,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fimpl%2FZKLogMetadataStore.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fimpl%2FZKLogMetadataStore.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fimpl%2FZKLogMetadataStore.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -19,23 +19,22 @@\n \n import com.google.common.base.Optional;\n import com.google.common.collect.Lists;\n+import java.net.URI;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n import org.apache.distributedlog.DistributedLogConfiguration;\n import org.apache.distributedlog.ZooKeeperClient;\n import org.apache.distributedlog.callback.NamespaceListener;\n import org.apache.distributedlog.exceptions.ZKException;\n import org.apache.distributedlog.metadata.LogMetadataStore;\n+import org.apache.distributedlog.common.concurrent.FutureUtils;\n import org.apache.distributedlog.util.OrderedScheduler;\n-import com.twitter.util.Future;\n-import com.twitter.util.Promise;\n import org.apache.zookeeper.AsyncCallback;\n import org.apache.zookeeper.KeeperException;\n import org.apache.zookeeper.ZooKeeper;\n import org.apache.zookeeper.data.Stat;\n \n-import java.net.URI;\n-import java.util.Iterator;\n-import java.util.List;\n-\n import static org.apache.distributedlog.util.DLUtils.*;\n \n /**\n@@ -60,18 +59,18 @@ public ZKLogMetadataStore(\n     }\n \n     @Override\n-    public Future<URI> createLog(String logName) {\n-        return Future.value(namespace);\n+    public CompletableFuture<URI> createLog(String logName) {\n+        return FutureUtils.value(namespace);\n     }\n \n     @Override\n-    public Future<Optional<URI>> getLogLocation(String logName) {\n-        return Future.value(nsOptional);\n+    public CompletableFuture<Optional<URI>> getLogLocation(String logName) {\n+        return FutureUtils.value(nsOptional);\n     }\n \n     @Override\n-    public Future<Iterator<String>> getLogs() {\n-        final Promise<Iterator<String>> promise = new Promise<Iterator<String>>();\n+    public CompletableFuture<Iterator<String>> getLogs() {\n+        final CompletableFuture<Iterator<String>> promise = new CompletableFuture<Iterator<String>>();\n         final String nsRootPath = namespace.getPath();\n         try {\n             final ZooKeeper zk = zkc.get();\n@@ -89,30 +88,30 @@ public void processResult(int rc, String path, Object ctx, List<String> children\n                                             results.add(child);\n                                         }\n                                     }\n-                                    promise.setValue(results.iterator());\n+                                    promise.complete(results.iterator());\n                                 } else if (KeeperException.Code.NONODE.intValue() == rc) {\n                                     List<String> streams = Lists.newLinkedList();\n-                                    promise.setValue(streams.iterator());\n+                                    promise.complete(streams.iterator());\n                                 } else {\n-                                    promise.setException(new ZKException(\"Error reading namespace \" + nsRootPath,\n+                                    promise.completeExceptionally(new ZKException(\"Error reading namespace \" + nsRootPath,\n                                             KeeperException.Code.get(rc)));\n                                 }\n                             }\n                         }, null);\n                     } else if (KeeperException.Code.NONODE.intValue() == syncRc) {\n                         List<String> streams = Lists.newLinkedList();\n-                        promise.setValue(streams.iterator());\n+                        promise.complete(streams.iterator());\n                     } else {\n-                        promise.setException(new ZKException(\"Error reading namespace \" + nsRootPath,\n+                        promise.completeExceptionally(new ZKException(\"Error reading namespace \" + nsRootPath,\n                                 KeeperException.Code.get(syncRc)));\n                     }\n                 }\n             }, null);\n             zkc.get();\n         } catch (ZooKeeperClient.ZooKeeperConnectionException e) {\n-            promise.setException(e);\n+            promise.completeExceptionally(e);\n         } catch (InterruptedException e) {\n-            promise.setException(e);\n+            promise.completeExceptionally(e);\n         }\n         return promise;\n     }"},{"sha":"f7470454b5b1495527795cf3380501643762c462","filename":"src/main/java/org/apache/distributedlog/impl/ZKLogSegmentMetadataStore.java","status":"modified","additions":16,"deletions":17,"changes":33,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fimpl%2FZKLogSegmentMetadataStore.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fimpl%2FZKLogSegmentMetadataStore.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fimpl%2FZKLogSegmentMetadataStore.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -18,6 +18,7 @@\n package org.apache.distributedlog.impl;\n \n import com.google.common.collect.ImmutableList;\n+import java.util.concurrent.CompletableFuture;\n import org.apache.distributedlog.DistributedLogConfiguration;\n import org.apache.distributedlog.LogSegmentMetadata;\n import org.apache.distributedlog.ZooKeeperClient;\n@@ -29,17 +30,15 @@\n import org.apache.distributedlog.metadata.LogMetadataForWriter;\n import org.apache.distributedlog.logsegment.LogSegmentMetadataStore;\n import org.apache.distributedlog.util.DLUtils;\n-import org.apache.distributedlog.util.FutureUtils;\n+import org.apache.distributedlog.common.concurrent.FutureEventListener;\n import org.apache.distributedlog.util.OrderedScheduler;\n import org.apache.distributedlog.util.Transaction;\n import org.apache.distributedlog.util.Transaction.OpListener;\n+import org.apache.distributedlog.util.Utils;\n import org.apache.distributedlog.zk.DefaultZKOp;\n import org.apache.distributedlog.zk.ZKOp;\n import org.apache.distributedlog.zk.ZKTransaction;\n import org.apache.distributedlog.zk.ZKVersionedSetOp;\n-import com.twitter.util.Future;\n-import com.twitter.util.FutureEventListener;\n-import com.twitter.util.Promise;\n import org.apache.bookkeeper.meta.ZkVersion;\n import org.apache.bookkeeper.versioning.Version;\n import org.apache.bookkeeper.versioning.Versioned;\n@@ -116,7 +115,7 @@ public void onFailure(Throwable cause) {\n         @Override\n         public void run() {\n             if (null != store.listeners.get(logSegmentsPath)) {\n-                store.zkGetLogSegmentNames(logSegmentsPath, store).addEventListener(this);\n+                store.zkGetLogSegmentNames(logSegmentsPath, store).whenComplete(this);\n             } else {\n                 logger.debug(\"Log segments listener for {} has been removed.\", logSegmentsPath);\n             }\n@@ -350,40 +349,40 @@ public void process(WatchedEvent event) {\n     }\n \n     @Override\n-    public Future<LogSegmentMetadata> getLogSegment(String logSegmentPath) {\n+    public CompletableFuture<LogSegmentMetadata> getLogSegment(String logSegmentPath) {\n         return LogSegmentMetadata.read(zkc, logSegmentPath, skipMinVersionCheck);\n     }\n \n-    Future<Versioned<List<String>>> zkGetLogSegmentNames(String logSegmentsPath, Watcher watcher) {\n-        Promise<Versioned<List<String>>> result = new Promise<Versioned<List<String>>>();\n+    CompletableFuture<Versioned<List<String>>> zkGetLogSegmentNames(String logSegmentsPath, Watcher watcher) {\n+        CompletableFuture<Versioned<List<String>>> result = new CompletableFuture<Versioned<List<String>>>();\n         try {\n             zkc.get().getChildren(logSegmentsPath, watcher, this, result);\n         } catch (ZooKeeperClient.ZooKeeperConnectionException e) {\n-            result.setException(FutureUtils.zkException(e, logSegmentsPath));\n+            result.completeExceptionally(Utils.zkException(e, logSegmentsPath));\n         } catch (InterruptedException e) {\n-            result.setException(FutureUtils.zkException(e, logSegmentsPath));\n+            result.completeExceptionally(Utils.zkException(e, logSegmentsPath));\n         }\n         return result;\n     }\n \n     @Override\n     @SuppressWarnings(\"unchecked\")\n     public void processResult(int rc, String path, Object ctx, List<String> children, Stat stat) {\n-        Promise<Versioned<List<String>>> result = ((Promise<Versioned<List<String>>>) ctx);\n+        CompletableFuture<Versioned<List<String>>> result = ((CompletableFuture<Versioned<List<String>>>) ctx);\n         if (KeeperException.Code.OK.intValue() == rc) {\n             /** cversion: the number of changes to the children of this znode **/\n             ZkVersion zkVersion = new ZkVersion(stat.getCversion());\n-            result.setValue(new Versioned(children, zkVersion));\n+            result.complete(new Versioned(children, zkVersion));\n         } else if (KeeperException.Code.NONODE.intValue() == rc) {\n-            result.setException(new LogNotFoundException(\"Log \" + path + \" not found\"));\n+            result.completeExceptionally(new LogNotFoundException(\"Log \" + path + \" not found\"));\n         } else {\n-            result.setException(new ZKException(\"Failed to get log segments from \" + path,\n+            result.completeExceptionally(new ZKException(\"Failed to get log segments from \" + path,\n                     KeeperException.Code.get(rc)));\n         }\n     }\n \n     @Override\n-    public Future<Versioned<List<String>>> getLogSegmentNames(String logSegmentsPath,\n+    public CompletableFuture<Versioned<List<String>>> getLogSegmentNames(String logSegmentsPath,\n                                                               LogSegmentNamesListener listener) {\n         Watcher zkWatcher;\n         if (null == listener) {\n@@ -422,9 +421,9 @@ public Future<Versioned<List<String>>> getLogSegmentNames(String logSegmentsPath\n                 closeLock.readLock().unlock();\n             }\n         }\n-        Future<Versioned<List<String>>> getLogSegmentNamesResult = zkGetLogSegmentNames(logSegmentsPath, zkWatcher);\n+        CompletableFuture<Versioned<List<String>>> getLogSegmentNamesResult = zkGetLogSegmentNames(logSegmentsPath, zkWatcher);\n         if (null != listener) {\n-            getLogSegmentNamesResult.addEventListener(new ReadLogSegmentsTask(logSegmentsPath, this));\n+            getLogSegmentNamesResult.whenComplete(new ReadLogSegmentsTask(logSegmentsPath, this));\n         }\n         return zkGetLogSegmentNames(logSegmentsPath, zkWatcher);\n     }"},{"sha":"b3fe456e7011088258b4c897e0335a86bcfe6a06","filename":"src/main/java/org/apache/distributedlog/impl/ZKMetadataAccessor.java","status":"modified","additions":9,"deletions":10,"changes":19,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fimpl%2FZKMetadataAccessor.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fimpl%2FZKMetadataAccessor.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fimpl%2FZKMetadataAccessor.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -21,17 +21,16 @@\n import java.net.URI;\n \n import com.google.common.annotations.VisibleForTesting;\n+import java.util.concurrent.CompletableFuture;\n import org.apache.distributedlog.DistributedLogConfiguration;\n-import org.apache.distributedlog.MetadataAccessor;\n+import org.apache.distributedlog.api.MetadataAccessor;\n import org.apache.distributedlog.ZooKeeperClient;\n import org.apache.distributedlog.ZooKeeperClientBuilder;\n import org.apache.distributedlog.exceptions.AlreadyClosedException;\n import org.apache.distributedlog.exceptions.DLInterruptedException;\n import org.apache.distributedlog.impl.metadata.BKDLConfig;\n-import org.apache.distributedlog.util.FutureUtils;\n+import org.apache.distributedlog.common.concurrent.FutureUtils;\n import org.apache.distributedlog.util.Utils;\n-import com.twitter.util.Future;\n-import com.twitter.util.Promise;\n import org.apache.bookkeeper.stats.StatsLogger;\n import org.apache.bookkeeper.zookeeper.BoundExponentialBackoffRetryPolicy;\n import org.apache.bookkeeper.zookeeper.RetryPolicy;\n@@ -45,7 +44,7 @@\n public class ZKMetadataAccessor implements MetadataAccessor {\n     static final Logger LOG = LoggerFactory.getLogger(ZKMetadataAccessor.class);\n     protected final String name;\n-    protected Promise<Void> closePromise;\n+    protected CompletableFuture<Void> closePromise;\n     protected final URI uri;\n     // zookeeper clients\n     // NOTE: The actual zookeeper client is initialized lazily when it is referenced by\n@@ -213,13 +212,13 @@ public byte[] getMetadata() throws IOException {\n      * @return future represents the close result.\n      */\n     @Override\n-    public Future<Void> asyncClose() {\n-        Promise<Void> closeFuture;\n+    public CompletableFuture<Void> asyncClose() {\n+        CompletableFuture<Void> closeFuture;\n         synchronized (this) {\n             if (null != closePromise) {\n                 return closePromise;\n             }\n-            closeFuture = closePromise = new Promise<Void>();\n+            closeFuture = closePromise = new CompletableFuture<Void>();\n         }\n         // NOTE: ownWriterZKC and ownReaderZKC are mostly used by tests\n         //       the managers created by the namespace - whose zkc will be closed by namespace\n@@ -233,13 +232,13 @@ public Future<Void> asyncClose() {\n         } catch (Exception e) {\n             LOG.warn(\"Exception while closing distributed log manager\", e);\n         }\n-        FutureUtils.setValue(closeFuture, null);\n+        FutureUtils.complete(closeFuture, null);\n         return closeFuture;\n     }\n \n     @Override\n     public void close() throws IOException {\n-        FutureUtils.result(asyncClose());\n+        Utils.ioResult(asyncClose());\n     }\n \n     public synchronized void checkClosedOrInError(String operation) throws AlreadyClosedException {"},{"sha":"e4a175cdade2f585bb4fdcd2e8cb5acc5ab895f7","filename":"src/main/java/org/apache/distributedlog/impl/acl/ZKAccessControl.java","status":"modified","additions":28,"deletions":29,"changes":57,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fimpl%2Facl%2FZKAccessControl.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fimpl%2Facl%2FZKAccessControl.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fimpl%2Facl%2FZKAccessControl.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -19,10 +19,9 @@\n \n import com.google.common.annotations.VisibleForTesting;\n import com.google.common.base.Objects;\n+import java.util.concurrent.CompletableFuture;\n import org.apache.distributedlog.ZooKeeperClient;\n import org.apache.distributedlog.thrift.AccessControlEntry;\n-import com.twitter.util.Future;\n-import com.twitter.util.Promise;\n import org.apache.thrift.TException;\n import org.apache.thrift.protocol.TJSONProtocol;\n import org.apache.thrift.transport.TMemoryBuffer;\n@@ -100,57 +99,57 @@ public AccessControlEntry getAccessControlEntry() {\n         return accessControlEntry;\n     }\n \n-    public Future<ZKAccessControl> create(ZooKeeperClient zkc) {\n-        final Promise<ZKAccessControl> promise = new Promise<ZKAccessControl>();\n+    public CompletableFuture<ZKAccessControl> create(ZooKeeperClient zkc) {\n+        final CompletableFuture<ZKAccessControl> promise = new CompletableFuture<ZKAccessControl>();\n         try {\n             zkc.get().create(zkPath, serialize(accessControlEntry), zkc.getDefaultACL(), CreateMode.PERSISTENT,\n                     new AsyncCallback.StringCallback() {\n                         @Override\n                         public void processResult(int rc, String path, Object ctx, String name) {\n                             if (KeeperException.Code.OK.intValue() == rc) {\n                                 ZKAccessControl.this.zkVersion = 0;\n-                                promise.setValue(ZKAccessControl.this);\n+                                promise.complete(ZKAccessControl.this);\n                             } else {\n-                                promise.setException(KeeperException.create(KeeperException.Code.get(rc)));\n+                                promise.completeExceptionally(KeeperException.create(KeeperException.Code.get(rc)));\n                             }\n                         }\n                     }, null);\n         } catch (ZooKeeperClient.ZooKeeperConnectionException e) {\n-            promise.setException(e);\n+            promise.completeExceptionally(e);\n         } catch (InterruptedException e) {\n-            promise.setException(e);\n+            promise.completeExceptionally(e);\n         } catch (IOException e) {\n-            promise.setException(e);\n+            promise.completeExceptionally(e);\n         }\n         return promise;\n     }\n \n-    public Future<ZKAccessControl> update(ZooKeeperClient zkc) {\n-        final Promise<ZKAccessControl> promise = new Promise<ZKAccessControl>();\n+    public CompletableFuture<ZKAccessControl> update(ZooKeeperClient zkc) {\n+        final CompletableFuture<ZKAccessControl> promise = new CompletableFuture<ZKAccessControl>();\n         try {\n             zkc.get().setData(zkPath, serialize(accessControlEntry), zkVersion, new AsyncCallback.StatCallback() {\n                 @Override\n                 public void processResult(int rc, String path, Object ctx, Stat stat) {\n                     if (KeeperException.Code.OK.intValue() == rc) {\n                         ZKAccessControl.this.zkVersion = stat.getVersion();\n-                        promise.setValue(ZKAccessControl.this);\n+                        promise.complete(ZKAccessControl.this);\n                     } else {\n-                        promise.setException(KeeperException.create(KeeperException.Code.get(rc)));\n+                        promise.completeExceptionally(KeeperException.create(KeeperException.Code.get(rc)));\n                     }\n                 }\n             }, null);\n         } catch (ZooKeeperClient.ZooKeeperConnectionException e) {\n-            promise.setException(e);\n+            promise.completeExceptionally(e);\n         } catch (InterruptedException e) {\n-            promise.setException(e);\n+            promise.completeExceptionally(e);\n         } catch (IOException e) {\n-            promise.setException(e);\n+            promise.completeExceptionally(e);\n         }\n         return promise;\n     }\n \n-    public static Future<ZKAccessControl> read(final ZooKeeperClient zkc, final String zkPath, Watcher watcher) {\n-        final Promise<ZKAccessControl> promise = new Promise<ZKAccessControl>();\n+    public static CompletableFuture<ZKAccessControl> read(final ZooKeeperClient zkc, final String zkPath, Watcher watcher) {\n+        final CompletableFuture<ZKAccessControl> promise = new CompletableFuture<ZKAccessControl>();\n \n         try {\n             zkc.get().getData(zkPath, watcher, new AsyncCallback.DataCallback() {\n@@ -159,42 +158,42 @@ public void processResult(int rc, String path, Object ctx, byte[] data, Stat sta\n                     if (KeeperException.Code.OK.intValue() == rc) {\n                         try {\n                             AccessControlEntry ace = deserialize(zkPath, data);\n-                            promise.setValue(new ZKAccessControl(ace, zkPath, stat.getVersion()));\n+                            promise.complete(new ZKAccessControl(ace, zkPath, stat.getVersion()));\n                         } catch (IOException ioe) {\n-                            promise.setException(ioe);\n+                            promise.completeExceptionally(ioe);\n                         }\n                     } else {\n-                        promise.setException(KeeperException.create(KeeperException.Code.get(rc)));\n+                        promise.completeExceptionally(KeeperException.create(KeeperException.Code.get(rc)));\n                     }\n                 }\n             }, null);\n         } catch (ZooKeeperClient.ZooKeeperConnectionException e) {\n-            promise.setException(e);\n+            promise.completeExceptionally(e);\n         } catch (InterruptedException e) {\n-            promise.setException(e);\n+            promise.completeExceptionally(e);\n         }\n         return promise;\n     }\n \n-    public static Future<Void> delete(final ZooKeeperClient zkc, final String zkPath) {\n-        final Promise<Void> promise = new Promise<Void>();\n+    public static CompletableFuture<Void> delete(final ZooKeeperClient zkc, final String zkPath) {\n+        final CompletableFuture<Void> promise = new CompletableFuture<Void>();\n \n         try {\n             zkc.get().delete(zkPath, -1, new AsyncCallback.VoidCallback() {\n                 @Override\n                 public void processResult(int rc, String path, Object ctx) {\n                     if (KeeperException.Code.OK.intValue() == rc ||\n                             KeeperException.Code.NONODE.intValue() == rc) {\n-                        promise.setValue(null);\n+                        promise.complete(null);\n                     } else {\n-                        promise.setException(KeeperException.create(KeeperException.Code.get(rc)));\n+                        promise.completeExceptionally(KeeperException.create(KeeperException.Code.get(rc)));\n                     }\n                 }\n             }, null);\n         } catch (ZooKeeperClient.ZooKeeperConnectionException e) {\n-            promise.setException(e);\n+            promise.completeExceptionally(e);\n         } catch (InterruptedException e) {\n-            promise.setException(e);\n+            promise.completeExceptionally(e);\n         }\n         return promise;\n     }"},{"sha":"3dbde6ad267eb62692fd7491c3a1997747b8f336","filename":"src/main/java/org/apache/distributedlog/impl/acl/ZKAccessControlManager.java","status":"modified","additions":29,"deletions":30,"changes":59,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fimpl%2Facl%2FZKAccessControlManager.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fimpl%2Facl%2FZKAccessControlManager.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fimpl%2Facl%2FZKAccessControlManager.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -18,16 +18,15 @@\n package org.apache.distributedlog.impl.acl;\n \n import com.google.common.collect.Sets;\n+import java.util.concurrent.CompletableFuture;\n import org.apache.distributedlog.DistributedLogConfiguration;\n import org.apache.distributedlog.ZooKeeperClient;\n import org.apache.distributedlog.acl.AccessControlManager;\n import org.apache.distributedlog.exceptions.DLInterruptedException;\n import org.apache.distributedlog.thrift.AccessControlEntry;\n-import com.twitter.util.Await;\n-import com.twitter.util.Future;\n-import com.twitter.util.FutureEventListener;\n-import com.twitter.util.Promise;\n import org.apache.bookkeeper.util.ZkUtils;\n+import org.apache.distributedlog.common.concurrent.FutureEventListener;\n+import org.apache.distributedlog.common.concurrent.FutureUtils;\n import org.apache.zookeeper.AsyncCallback;\n import org.apache.zookeeper.CreateMode;\n import org.apache.zookeeper.KeeperException;\n@@ -76,7 +75,7 @@ public ZKAccessControlManager(DistributedLogConfiguration conf,\n         this.scheduledExecutorService = scheduledExecutorService;\n         this.streamEntries = new ConcurrentHashMap<String, ZKAccessControl>();\n         try {\n-            Await.result(fetchDefaultAccessControlEntry());\n+            FutureUtils.result(fetchDefaultAccessControlEntry());\n         } catch (Throwable t) {\n             if (t instanceof InterruptedException) {\n                 throw new DLInterruptedException(\"Interrupted on getting default access control entry for \" + zkRootPath, t);\n@@ -90,7 +89,7 @@ public ZKAccessControlManager(DistributedLogConfiguration conf,\n         }\n \n         try {\n-            Await.result(fetchAccessControlEntries());\n+            FutureUtils.result(fetchAccessControlEntries());\n         } catch (Throwable t) {\n             if (t instanceof InterruptedException) {\n                 throw new DLInterruptedException(\"Interrupted on getting access control entries for \" + zkRootPath, t);\n@@ -140,19 +139,19 @@ public void close() {\n         closed = true;\n     }\n \n-    private Future<Void> fetchAccessControlEntries() {\n-        final Promise<Void> promise = new Promise<Void>();\n+    private CompletableFuture<Void> fetchAccessControlEntries() {\n+        final CompletableFuture<Void> promise = new CompletableFuture<Void>();\n         fetchAccessControlEntries(promise);\n         return promise;\n     }\n \n-    private void fetchAccessControlEntries(final Promise<Void> promise) {\n+    private void fetchAccessControlEntries(final CompletableFuture<Void> promise) {\n         try {\n             zkc.get().getChildren(zkRootPath, this, new AsyncCallback.Children2Callback() {\n                 @Override\n                 public void processResult(int rc, String path, Object ctx, List<String> children, Stat stat) {\n                     if (KeeperException.Code.OK.intValue() != rc) {\n-                        promise.setException(KeeperException.create(KeeperException.Code.get(rc)));\n+                        promise.completeExceptionally(KeeperException.create(KeeperException.Code.get(rc)));\n                         return;\n                     }\n                     Set<String> streamsReceived = new HashSet<String>();\n@@ -166,15 +165,15 @@ public void processResult(int rc, String path, Object ctx, List<String> children\n                         }\n                     }\n                     if (streamsReceived.isEmpty()) {\n-                        promise.setValue(null);\n+                        promise.complete(null);\n                         return;\n                     }\n                     final AtomicInteger numPendings = new AtomicInteger(streamsReceived.size());\n                     final AtomicInteger numFailures = new AtomicInteger(0);\n                     for (String s : streamsReceived) {\n                         final String streamName = s;\n                         ZKAccessControl.read(zkc, zkRootPath + \"/\" + streamName, null)\n-                                .addEventListener(new FutureEventListener<ZKAccessControl>() {\n+                                .whenComplete(new FutureEventListener<ZKAccessControl>() {\n \n                                     @Override\n                                     public void onSuccess(ZKAccessControl accessControl) {\n@@ -193,44 +192,44 @@ public void onFailure(Throwable cause) {\n                                             streamEntries.remove(streamName);\n                                         } else {\n                                             if (1 == numFailures.incrementAndGet()) {\n-                                                promise.setException(cause);\n+                                                promise.completeExceptionally(cause);\n                                             }\n                                         }\n                                         complete();\n                                     }\n \n                                     private void complete() {\n                                         if (0 == numPendings.decrementAndGet() && numFailures.get() == 0) {\n-                                            promise.setValue(null);\n+                                            promise.complete(null);\n                                         }\n                                     }\n                                 });\n                     }\n                 }\n             }, null);\n         } catch (ZooKeeperClient.ZooKeeperConnectionException e) {\n-            promise.setException(e);\n+            promise.completeExceptionally(e);\n         } catch (InterruptedException e) {\n-            promise.setException(e);\n+            promise.completeExceptionally(e);\n         }\n     }\n \n-    private Future<ZKAccessControl> fetchDefaultAccessControlEntry() {\n-        final Promise<ZKAccessControl> promise = new Promise<ZKAccessControl>();\n+    private CompletableFuture<ZKAccessControl> fetchDefaultAccessControlEntry() {\n+        final CompletableFuture<ZKAccessControl> promise = new CompletableFuture<ZKAccessControl>();\n         fetchDefaultAccessControlEntry(promise);\n         return promise;\n     }\n \n-    private void fetchDefaultAccessControlEntry(final Promise<ZKAccessControl> promise) {\n+    private void fetchDefaultAccessControlEntry(final CompletableFuture<ZKAccessControl> promise) {\n         ZKAccessControl.read(zkc, zkRootPath, this)\n-            .addEventListener(new FutureEventListener<ZKAccessControl>() {\n+            .whenComplete(new FutureEventListener<ZKAccessControl>() {\n                 @Override\n                 public void onSuccess(ZKAccessControl accessControl) {\n                     logger.info(\"Default Access Control will be changed from {} to {}\",\n                                 ZKAccessControlManager.this.defaultAccessControl,\n                                 accessControl);\n                     ZKAccessControlManager.this.defaultAccessControl = accessControl;\n-                    promise.setValue(accessControl);\n+                    promise.complete(accessControl);\n                 }\n \n                 @Override\n@@ -239,21 +238,21 @@ public void onFailure(Throwable cause) {\n                         logger.info(\"Default Access Control is missing, creating one for {} ...\", zkRootPath);\n                         createDefaultAccessControlEntryIfNeeded(promise);\n                     } else {\n-                        promise.setException(cause);\n+                        promise.completeExceptionally(cause);\n                     }\n                 }\n             });\n     }\n \n-    private void createDefaultAccessControlEntryIfNeeded(final Promise<ZKAccessControl> promise) {\n+    private void createDefaultAccessControlEntryIfNeeded(final CompletableFuture<ZKAccessControl> promise) {\n         ZooKeeper zk;\n         try {\n             zk = zkc.get();\n         } catch (ZooKeeperClient.ZooKeeperConnectionException e) {\n-            promise.setException(e);\n+            promise.completeExceptionally(e);\n             return;\n         } catch (InterruptedException e) {\n-            promise.setException(e);\n+            promise.completeExceptionally(e);\n             return;\n         }\n         ZkUtils.asyncCreateFullPathOptimistic(zk, zkRootPath, new byte[0], zkc.getDefaultACL(),\n@@ -264,7 +263,7 @@ public void processResult(int rc, String path, Object ctx, String name) {\n                     logger.info(\"Created zk path {} for default ACL.\", zkRootPath);\n                     fetchDefaultAccessControlEntry(promise);\n                 } else {\n-                    promise.setException(KeeperException.create(KeeperException.Code.get(rc)));\n+                    promise.completeExceptionally(KeeperException.create(KeeperException.Code.get(rc)));\n                 }\n             }\n         }, null);\n@@ -277,7 +276,7 @@ private void refetchDefaultAccessControlEntry(final int delayMs) {\n         scheduledExecutorService.schedule(new Runnable() {\n             @Override\n             public void run() {\n-                fetchDefaultAccessControlEntry().addEventListener(new FutureEventListener<ZKAccessControl>() {\n+                fetchDefaultAccessControlEntry().whenComplete(new FutureEventListener<ZKAccessControl>() {\n                     @Override\n                     public void onSuccess(ZKAccessControl value) {\n                         // no-op\n@@ -305,7 +304,7 @@ private void refetchAccessControlEntries(final int delayMs) {\n         scheduledExecutorService.schedule(new Runnable() {\n             @Override\n             public void run() {\n-                fetchAccessControlEntries().addEventListener(new FutureEventListener<Void>() {\n+                fetchAccessControlEntries().whenComplete(new FutureEventListener<Void>() {\n                     @Override\n                     public void onSuccess(Void value) {\n                         // no-op\n@@ -328,10 +327,10 @@ private void refetchAllAccessControlEntries(final int delayMs) {\n         scheduledExecutorService.schedule(new Runnable() {\n             @Override\n             public void run() {\n-                fetchDefaultAccessControlEntry().addEventListener(new FutureEventListener<ZKAccessControl>() {\n+                fetchDefaultAccessControlEntry().whenComplete(new FutureEventListener<ZKAccessControl>() {\n                     @Override\n                     public void onSuccess(ZKAccessControl value) {\n-                        fetchAccessControlEntries().addEventListener(new FutureEventListener<Void>() {\n+                        fetchAccessControlEntries().whenComplete(new FutureEventListener<Void>() {\n                             @Override\n                             public void onSuccess(Void value) {\n                                 // no-op"},{"sha":"17515c3500f2978cf8a2873d91952ddb6cc5d8dd","filename":"src/main/java/org/apache/distributedlog/impl/federated/FederatedZKLogMetadataStore.java","status":"modified","additions":111,"deletions":117,"changes":228,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fimpl%2Ffederated%2FFederatedZKLogMetadataStore.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fimpl%2Ffederated%2FFederatedZKLogMetadataStore.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fimpl%2Ffederated%2FFederatedZKLogMetadataStore.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -23,6 +23,7 @@\n import com.google.common.collect.Iterators;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Sets;\n+import java.util.concurrent.CompletableFuture;\n import org.apache.distributedlog.DistributedLogConfiguration;\n import org.apache.distributedlog.ZooKeeperClient;\n import org.apache.distributedlog.callback.NamespaceListener;\n@@ -32,12 +33,10 @@\n import org.apache.distributedlog.impl.ZKNamespaceWatcher;\n import org.apache.distributedlog.metadata.LogMetadataStore;\n import org.apache.distributedlog.namespace.NamespaceWatcher;\n-import org.apache.distributedlog.util.FutureUtils;\n+import org.apache.distributedlog.common.concurrent.FutureEventListener;\n+import org.apache.distributedlog.common.concurrent.FutureUtils;\n import org.apache.distributedlog.util.OrderedScheduler;\n import org.apache.distributedlog.util.Utils;\n-import com.twitter.util.Future;\n-import com.twitter.util.FutureEventListener;\n-import com.twitter.util.Promise;\n import org.apache.zookeeper.AsyncCallback;\n import org.apache.zookeeper.CreateMode;\n import org.apache.zookeeper.KeeperException;\n@@ -49,8 +48,6 @@\n import org.apache.zookeeper.data.Stat;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n-import scala.runtime.AbstractFunction1;\n-import scala.runtime.BoxedUnit;\n \n import java.io.IOException;\n import java.net.URI;\n@@ -80,8 +77,9 @@\n  * NOTE: current federated namespace isn't optimized for deletion/creation. so don't use it in the workloads\n  *       that have lots of creations or deletions.\n  */\n-public class FederatedZKLogMetadataStore extends NamespaceWatcher implements LogMetadataStore, Watcher, Runnable,\n-        FutureEventListener<Set<URI>> {\n+public class FederatedZKLogMetadataStore\n+        extends NamespaceWatcher\n+        implements LogMetadataStore, Watcher, Runnable, FutureEventListener<Set<URI>> {\n \n     static final Logger logger = LoggerFactory.getLogger(FederatedZKLogMetadataStore.class);\n \n@@ -100,7 +98,7 @@ public class FederatedZKLogMetadataStore extends NamespaceWatcher implements Log\n      * @throws KeeperException\n      */\n     public static void createFederatedNamespace(URI namespace, ZooKeeperClient zkc)\n-            throws InterruptedException, ZooKeeperClient.ZooKeeperConnectionException, KeeperException {\n+            throws IOException, KeeperException {\n         String zkSubNamespacesPath = namespace.getPath() + \"/\" + ZNODE_SUB_NAMESPACES;\n         Utils.zkCreateFullPathOptimistic(zkc, zkSubNamespacesPath, new byte[0],\n                 zkc.getDefaultACL(), CreateMode.PERSISTENT);\n@@ -112,7 +110,7 @@ public static void createFederatedNamespace(URI namespace, ZooKeeperClient zkc)\n     class SubNamespace implements NamespaceListener {\n         final URI uri;\n         final ZKNamespaceWatcher watcher;\n-        Promise<Set<String>> logsFuture = new Promise<Set<String>>();\n+        CompletableFuture<Set<String>> logsFuture = new CompletableFuture<Set<String>>();\n \n         SubNamespace(URI uri) {\n             this.uri = uri;\n@@ -124,7 +122,7 @@ void watch() {\n             this.watcher.watchNamespaceChanges();\n         }\n \n-        synchronized Future<Set<String>> getLogs() {\n+        synchronized CompletableFuture<Set<String>> getLogs() {\n             return logsFuture;\n         }\n \n@@ -134,16 +132,16 @@ public void onStreamsChanged(Iterator<String> newLogsIter) {\n             Set<String> oldLogs = Sets.newHashSet();\n \n             // update the sub namespace cache\n-            Promise<Set<String>> newLogsPromise;\n+            CompletableFuture<Set<String>> newLogsPromise;\n             synchronized (this) {\n-                if (logsFuture.isDefined()) { // the promise is already satisfied\n+                if (logsFuture.isDone()) { // the promise is already satisfied\n                     try {\n                         oldLogs = FutureUtils.result(logsFuture);\n-                    } catch (IOException e) {\n+                    } catch (Exception e) {\n                         logger.error(\"Unexpected exception when getting logs from a satisified future of {} : \",\n                                 uri, e);\n                     }\n-                    logsFuture = new Promise<Set<String>>();\n+                    logsFuture = new CompletableFuture<Set<String>>();\n                 }\n \n                 // update the reverse cache\n@@ -163,7 +161,7 @@ public void onStreamsChanged(Iterator<String> newLogsIter) {\n                 }\n                 newLogsPromise = logsFuture;\n             }\n-            newLogsPromise.setValue(newLogs);\n+            newLogsPromise.complete(newLogs);\n \n             // notify namespace changes\n             notifyOnNamespaceChanges();\n@@ -203,7 +201,16 @@ public FederatedZKLogMetadataStore(\n         this.maxLogsPerSubnamespace = conf.getFederatedMaxLogsPerSubnamespace();\n \n         // fetch the sub namespace\n-        Set<URI> uris = FutureUtils.result(fetchSubNamespaces(this));\n+        Set<URI> uris;\n+        try {\n+            uris = FutureUtils.result(fetchSubNamespaces(this));\n+        } catch (Exception e) {\n+            if (e instanceof IOException) {\n+                throw (IOException) e;\n+            } else {\n+                throw new IOException(e);\n+            }\n+        }\n         for (URI uri : uris) {\n             SubNamespace subNs = new SubNamespace(uri);\n             if (null == subNamespaces.putIfAbsent(uri, subNs)) {\n@@ -228,21 +235,21 @@ private void scheduleTask(Runnable r, long ms) {\n         }\n     }\n \n-    private <T> Future<T> postStateCheck(Future<T> future) {\n-        final Promise<T> postCheckedPromise = new Promise<T>();\n-        future.addEventListener(new FutureEventListener<T>() {\n+    private <T> CompletableFuture<T> postStateCheck(CompletableFuture<T> future) {\n+        final CompletableFuture<T> postCheckedPromise = new CompletableFuture<T>();\n+        future.whenComplete(new FutureEventListener<T>() {\n             @Override\n             public void onSuccess(T value) {\n                 if (duplicatedLogFound.get()) {\n-                    postCheckedPromise.setException(new UnexpectedException(\"Duplicate log found under \" + namespace));\n+                    postCheckedPromise.completeExceptionally(new UnexpectedException(\"Duplicate log found under \" + namespace));\n                 } else {\n-                    postCheckedPromise.setValue(value);\n+                    postCheckedPromise.complete(value);\n                 }\n             }\n \n             @Override\n             public void onFailure(Throwable cause) {\n-                postCheckedPromise.setException(cause);\n+                postCheckedPromise.completeExceptionally(cause);\n             }\n         });\n         return postCheckedPromise;\n@@ -273,41 +280,41 @@ private URI getSubNamespaceURI(String ns) throws URISyntaxException {\n                 namespace.getFragment());\n     }\n \n-    Future<Set<URI>> getCachedSubNamespaces() {\n+    CompletableFuture<Set<URI>> getCachedSubNamespaces() {\n         Set<URI> nsSet = subNamespaces.keySet();\n-        return Future.value(nsSet);\n+        return FutureUtils.value(nsSet);\n     }\n \n-    Future<Set<URI>> fetchSubNamespaces(final Watcher watcher) {\n-        final Promise<Set<URI>> promise = new Promise<Set<URI>>();\n+    CompletableFuture<Set<URI>> fetchSubNamespaces(final Watcher watcher) {\n+        final CompletableFuture<Set<URI>> promise = new CompletableFuture<Set<URI>>();\n         try {\n             zkc.get().sync(this.zkSubnamespacesPath, new AsyncCallback.VoidCallback() {\n                 @Override\n                 public void processResult(int rc, String path, Object ctx) {\n                     if (Code.OK.intValue() == rc) {\n                         fetchSubNamespaces(watcher, promise);\n                     } else {\n-                        promise.setException(KeeperException.create(Code.get(rc)));\n+                        promise.completeExceptionally(KeeperException.create(Code.get(rc)));\n                     }\n                 }\n             }, null);\n         } catch (ZooKeeperClient.ZooKeeperConnectionException e) {\n-            promise.setException(e);\n+            promise.completeExceptionally(e);\n         } catch (InterruptedException e) {\n-            promise.setException(e);\n+            promise.completeExceptionally(e);\n         }\n         return promise;\n     }\n \n     private void fetchSubNamespaces(Watcher watcher,\n-                                    final Promise<Set<URI>> promise) {\n+                                    final CompletableFuture<Set<URI>> promise) {\n         try {\n             zkc.get().getChildren(this.zkSubnamespacesPath, watcher,\n                     new AsyncCallback.Children2Callback() {\n                         @Override\n                         public void processResult(int rc, String path, Object ctx, List<String> children, Stat stat) {\n                             if (Code.NONODE.intValue() == rc) {\n-                                promise.setException(new UnexpectedException(\n+                                promise.completeExceptionally(new UnexpectedException(\n                                         \"The subnamespaces don't exist for the federated namespace \" + namespace));\n                             } else if (Code.OK.intValue() == rc) {\n                                 Set<URI> subnamespaces = Sets.newHashSet();\n@@ -318,26 +325,26 @@ public void processResult(int rc, String path, Object ctx, List<String> children\n                                     }\n                                 } catch (URISyntaxException use) {\n                                     logger.error(\"Invalid sub namespace uri found : \", use);\n-                                    promise.setException(new UnexpectedException(\n+                                    promise.completeExceptionally(new UnexpectedException(\n                                             \"Invalid sub namespace uri found in \" + namespace, use));\n                                     return;\n                                 }\n                                 // update the sub namespaces set before update version\n                                 setZkSubnamespacesVersion(stat.getVersion());\n-                                promise.setValue(subnamespaces);\n+                                promise.complete(subnamespaces);\n                             }\n                         }\n                     }, null);\n         } catch (ZooKeeperClient.ZooKeeperConnectionException e) {\n-            promise.setException(e);\n+            promise.completeExceptionally(e);\n         } catch (InterruptedException e) {\n-            promise.setException(e);\n+            promise.completeExceptionally(e);\n         }\n     }\n \n     @Override\n     public void run() {\n-        fetchSubNamespaces(this).addEventListener(this);\n+        fetchSubNamespaces(this).whenComplete(this);\n     }\n \n     @Override\n@@ -370,92 +377,92 @@ public void process(WatchedEvent watchedEvent) {\n         }\n         if (Event.EventType.NodeChildrenChanged == watchedEvent.getType()) {\n             // fetch the namespace\n-            fetchSubNamespaces(this).addEventListener(this);\n+            fetchSubNamespaces(this).whenComplete(this);\n         }\n     }\n \n     //\n     // Log Related Methods\n     //\n \n-    private <A> Future<A> duplicatedLogException(String logName) {\n-        return Future.exception(new UnexpectedException(\"Duplicated log \" + logName\n+    private <A> CompletableFuture<A> duplicatedLogException(String logName) {\n+        return FutureUtils.exception(new UnexpectedException(\"Duplicated log \" + logName\n                 + \" found in namespace \" + namespace));\n     }\n \n     @Override\n-    public Future<URI> createLog(final String logName) {\n+    public CompletableFuture<URI> createLog(final String logName) {\n         if (duplicatedLogFound.get()) {\n             return duplicatedLogException(duplicatedLogName.get());\n         }\n-        Promise<URI> createPromise = new Promise<URI>();\n+        CompletableFuture<URI> createPromise = new CompletableFuture<URI>();\n         doCreateLog(logName, createPromise);\n         return postStateCheck(createPromise);\n     }\n \n-    void doCreateLog(final String logName, final Promise<URI> createPromise) {\n-        getLogLocation(logName).addEventListener(new FutureEventListener<Optional<URI>>() {\n+    void doCreateLog(final String logName, final CompletableFuture<URI> createPromise) {\n+        getLogLocation(logName).whenComplete(new FutureEventListener<Optional<URI>>() {\n             @Override\n             public void onSuccess(Optional<URI> uriOptional) {\n                 if (uriOptional.isPresent()) {\n-                    createPromise.setException(new LogExistsException(\"Log \" + logName + \" already exists in \" + uriOptional.get()));\n+                    createPromise.completeExceptionally(new LogExistsException(\"Log \" + logName + \" already exists in \" + uriOptional.get()));\n                 } else {\n                     getCachedSubNamespacesAndCreateLog(logName, createPromise);\n                 }\n             }\n \n             @Override\n             public void onFailure(Throwable cause) {\n-                createPromise.setException(cause);\n+                createPromise.completeExceptionally(cause);\n             }\n         });\n     }\n \n     private void getCachedSubNamespacesAndCreateLog(final String logName,\n-                                                    final Promise<URI> createPromise) {\n-        getCachedSubNamespaces().addEventListener(new FutureEventListener<Set<URI>>() {\n+                                                    final CompletableFuture<URI> createPromise) {\n+        getCachedSubNamespaces().whenComplete(new FutureEventListener<Set<URI>>() {\n             @Override\n             public void onSuccess(Set<URI> uris) {\n                 findSubNamespaceToCreateLog(logName, uris, createPromise);\n             }\n \n             @Override\n             public void onFailure(Throwable cause) {\n-                createPromise.setException(cause);\n+                createPromise.completeExceptionally(cause);\n             }\n         });\n     }\n \n     private void fetchSubNamespacesAndCreateLog(final String logName,\n-                                                final Promise<URI> createPromise) {\n-        fetchSubNamespaces(null).addEventListener(new FutureEventListener<Set<URI>>() {\n+                                                final CompletableFuture<URI> createPromise) {\n+        fetchSubNamespaces(null).whenComplete(new FutureEventListener<Set<URI>>() {\n             @Override\n             public void onSuccess(Set<URI> uris) {\n                 findSubNamespaceToCreateLog(logName, uris, createPromise);\n             }\n \n             @Override\n             public void onFailure(Throwable cause) {\n-                createPromise.setException(cause);\n+                createPromise.completeExceptionally(cause);\n             }\n         });\n     }\n \n     private void findSubNamespaceToCreateLog(final String logName,\n                                              final Set<URI> uris,\n-                                             final Promise<URI> createPromise) {\n+                                             final CompletableFuture<URI> createPromise) {\n         final List<URI> uriList = Lists.newArrayListWithExpectedSize(uris.size());\n-        List<Future<Set<String>>> futureList = Lists.newArrayListWithExpectedSize(uris.size());\n+        List<CompletableFuture<Set<String>>> futureList = Lists.newArrayListWithExpectedSize(uris.size());\n         for (URI uri : uris) {\n             SubNamespace subNs = subNamespaces.get(uri);\n             if (null == subNs) {\n-                createPromise.setException(new UnexpectedException(\"No sub namespace \" + uri + \" found\"));\n+                createPromise.completeExceptionally(new UnexpectedException(\"No sub namespace \" + uri + \" found\"));\n                 return;\n             }\n             futureList.add(subNs.getLogs());\n             uriList.add(uri);\n         }\n-        Future.collect(futureList).addEventListener(new FutureEventListener<List<Set<String>>>() {\n+        FutureUtils.collect(futureList).whenComplete(new FutureEventListener<List<Set<String>>>() {\n             @Override\n             public void onSuccess(List<Set<String>> resultList) {\n                 for (int i = resultList.size() - 1; i >= 0; i--) {\n@@ -467,7 +474,7 @@ public void onSuccess(List<Set<String>> resultList) {\n                     }\n                 }\n                 // All sub namespaces are full\n-                createSubNamespace().addEventListener(new FutureEventListener<URI>() {\n+                createSubNamespace().whenComplete(new FutureEventListener<URI>() {\n                     @Override\n                     public void onSuccess(URI uri) {\n                         // the new namespace will be propagated to the namespace cache by the namespace listener\n@@ -479,14 +486,14 @@ public void onSuccess(URI uri) {\n \n                     @Override\n                     public void onFailure(Throwable cause) {\n-                        createPromise.setException(cause);\n+                        createPromise.completeExceptionally(cause);\n                     }\n                 });\n             }\n \n             @Override\n             public void onFailure(Throwable cause) {\n-                createPromise.setException(cause);\n+                createPromise.completeExceptionally(cause);\n             }\n         });\n     }\n@@ -499,8 +506,8 @@ private String getNamespaceFromZkPath(String zkPath) throws UnexpectedException\n         return SUB_NAMESPACE_PREFIX + parts[parts.length - 1];\n     }\n \n-    Future<URI> createSubNamespace() {\n-        final Promise<URI> promise = new Promise<URI>();\n+    CompletableFuture<URI> createSubNamespace() {\n+        final CompletableFuture<URI> promise = new CompletableFuture<URI>();\n \n         final String nsPath = namespace.getPath() + \"/\" + ZNODE_SUB_NAMESPACES + \"/\" + SUB_NAMESPACE_PREFIX;\n         try {\n@@ -512,21 +519,21 @@ public void processResult(int rc, String path, Object ctx, String name) {\n                                 try {\n                                     URI newUri = getSubNamespaceURI(getNamespaceFromZkPath(name));\n                                     logger.info(\"Created sub namespace {}\", newUri);\n-                                    promise.setValue(newUri);\n+                                    promise.complete(newUri);\n                                 } catch (UnexpectedException ue) {\n-                                    promise.setException(ue);\n+                                    promise.completeExceptionally(ue);\n                                 } catch (URISyntaxException e) {\n-                                    promise.setException(new UnexpectedException(\"Invalid namespace \" + name + \" is created.\"));\n+                                    promise.completeExceptionally(new UnexpectedException(\"Invalid namespace \" + name + \" is created.\"));\n                                 }\n                             } else {\n-                                promise.setException(KeeperException.create(Code.get(rc)));\n+                                promise.completeExceptionally(KeeperException.create(Code.get(rc)));\n                             }\n                         }\n                     }, null);\n         } catch (ZooKeeperClient.ZooKeeperConnectionException e) {\n-            promise.setException(e);\n+            promise.completeExceptionally(e);\n         } catch (InterruptedException e) {\n-            promise.setException(e);\n+            promise.completeExceptionally(e);\n         }\n \n         return promise;\n@@ -545,22 +552,22 @@ public void processResult(int rc, String path, Object ctx, String name) {\n      */\n     private void createLogInNamespace(final URI uri,\n                                       final String logName,\n-                                      final Promise<URI> createPromise) {\n+                                      final CompletableFuture<URI> createPromise) {\n         // TODO: rewrite this after we bump to zk 3.5, where we will have asynchronous version of multi\n         scheduler.submit(new Runnable() {\n             @Override\n             public void run() {\n                 try {\n                     createLogInNamespaceSync(uri, logName);\n-                    createPromise.setValue(uri);\n+                    createPromise.complete(uri);\n                 } catch (InterruptedException e) {\n-                    createPromise.setException(e);\n+                    createPromise.completeExceptionally(e);\n                 } catch (IOException e) {\n-                    createPromise.setException(e);\n+                    createPromise.completeExceptionally(e);\n                 } catch (KeeperException.BadVersionException bve) {\n                     fetchSubNamespacesAndCreateLog(logName, createPromise);\n                 } catch (KeeperException e) {\n-                    createPromise.setException(e);\n+                    createPromise.completeExceptionally(e);\n                 }\n             }\n         });\n@@ -617,39 +624,35 @@ void setZkSubnamespacesVersion(int zkVersion) {\n     }\n \n     @Override\n-    public Future<Optional<URI>> getLogLocation(final String logName) {\n+    public CompletableFuture<Optional<URI>> getLogLocation(final String logName) {\n         if (duplicatedLogFound.get()) {\n             return duplicatedLogException(duplicatedLogName.get());\n         }\n         URI location = log2Locations.get(logName);\n         if (null != location) {\n-            return postStateCheck(Future.value(Optional.of(location)));\n+            return postStateCheck(FutureUtils.value(Optional.of(location)));\n         }\n         if (!forceCheckLogExistence) {\n             Optional<URI> result = Optional.absent();\n-            return Future.value(result);\n+            return FutureUtils.value(result);\n         }\n-        return postStateCheck(fetchLogLocation(logName).onSuccess(\n-                new AbstractFunction1<Optional<URI>, BoxedUnit>() {\n-                    @Override\n-                    public BoxedUnit apply(Optional<URI> uriOptional) {\n-                        if (uriOptional.isPresent()) {\n-                            log2Locations.putIfAbsent(logName, uriOptional.get());\n-                        }\n-                        return BoxedUnit.UNIT;\n-                    }\n-                }));\n+        return postStateCheck(fetchLogLocation(logName).thenApply((uriOptional) -> {\n+            if (uriOptional.isPresent()) {\n+                log2Locations.putIfAbsent(logName, uriOptional.get());\n+            }\n+            return uriOptional;\n+        }));\n     }\n \n-    private Future<Optional<URI>> fetchLogLocation(final String logName) {\n-        final Promise<Optional<URI>> fetchPromise = new Promise<Optional<URI>>();\n+    private CompletableFuture<Optional<URI>> fetchLogLocation(final String logName) {\n+        final CompletableFuture<Optional<URI>> fetchPromise = new CompletableFuture<Optional<URI>>();\n \n         Set<URI> uris = subNamespaces.keySet();\n-        List<Future<Optional<URI>>> fetchFutures = Lists.newArrayListWithExpectedSize(uris.size());\n+        List<CompletableFuture<Optional<URI>>> fetchFutures = Lists.newArrayListWithExpectedSize(uris.size());\n         for (URI uri : uris) {\n             fetchFutures.add(fetchLogLocation(uri, logName));\n         }\n-        Future.collect(fetchFutures).addEventListener(new FutureEventListener<List<Optional<URI>>>() {\n+        FutureUtils.collect(fetchFutures).whenComplete(new FutureEventListener<List<Optional<URI>>>() {\n             @Override\n             public void onSuccess(List<Optional<URI>> fetchResults) {\n                 Optional<URI> result = Optional.absent();\n@@ -660,7 +663,7 @@ public void onSuccess(List<Optional<URI>> fetchResults) {\n                                     new Object[] { logName, result.get(), fetchResult.get() });\n                             duplicatedLogName.compareAndSet(null, logName);\n                             duplicatedLogFound.set(true);\n-                            fetchPromise.setException(new UnexpectedException(\"Log \" + logName\n+                            fetchPromise.completeExceptionally(new UnexpectedException(\"Log \" + logName\n                                     + \" is found in multiple sub namespaces : \"\n                                     + result.get() + \" & \" + fetchResult.get()));\n                             return;\n@@ -669,62 +672,57 @@ public void onSuccess(List<Optional<URI>> fetchResults) {\n                         result = fetchResult;\n                     }\n                 }\n-                fetchPromise.setValue(result);\n+                fetchPromise.complete(result);\n             }\n \n             @Override\n             public void onFailure(Throwable cause) {\n-                fetchPromise.setException(cause);\n+                fetchPromise.completeExceptionally(cause);\n             }\n         });\n         return fetchPromise;\n     }\n \n-    private Future<Optional<URI>> fetchLogLocation(final URI uri, String logName) {\n-        final Promise<Optional<URI>> fetchPromise = new Promise<Optional<URI>>();\n+    private CompletableFuture<Optional<URI>> fetchLogLocation(final URI uri, String logName) {\n+        final CompletableFuture<Optional<URI>> fetchPromise = new CompletableFuture<Optional<URI>>();\n         final String logRootPath = uri.getPath() + \"/\" + logName;\n         try {\n             zkc.get().exists(logRootPath, false, new AsyncCallback.StatCallback() {\n                 @Override\n                 public void processResult(int rc, String path, Object ctx, Stat stat) {\n                     if (Code.OK.intValue() == rc) {\n-                        fetchPromise.setValue(Optional.of(uri));\n+                        fetchPromise.complete(Optional.of(uri));\n                     } else if (Code.NONODE.intValue() == rc) {\n-                        fetchPromise.setValue(Optional.<URI>absent());\n+                        fetchPromise.complete(Optional.<URI>absent());\n                     } else {\n-                        fetchPromise.setException(KeeperException.create(Code.get(rc)));\n+                        fetchPromise.completeExceptionally(KeeperException.create(Code.get(rc)));\n                     }\n                 }\n             }, null);\n         } catch (ZooKeeperClient.ZooKeeperConnectionException e) {\n-            fetchPromise.setException(e);\n+            fetchPromise.completeExceptionally(e);\n         } catch (InterruptedException e) {\n-            fetchPromise.setException(e);\n+            fetchPromise.completeExceptionally(e);\n         }\n         return fetchPromise;\n     }\n \n     @Override\n-    public Future<Iterator<String>> getLogs() {\n+    public CompletableFuture<Iterator<String>> getLogs() {\n         if (duplicatedLogFound.get()) {\n             return duplicatedLogException(duplicatedLogName.get());\n         }\n-        return postStateCheck(retrieveLogs().map(\n-                new AbstractFunction1<List<Set<String>>, Iterator<String>>() {\n-                    @Override\n-                    public Iterator<String> apply(List<Set<String>> resultList) {\n-                        return getIterator(resultList);\n-                    }\n-                }));\n+        return postStateCheck(retrieveLogs().thenApply(\n+            resultList -> getIterator(resultList)));\n     }\n \n-    private Future<List<Set<String>>> retrieveLogs() {\n+    private CompletableFuture<List<Set<String>>> retrieveLogs() {\n         Collection<SubNamespace> subNss = subNamespaces.values();\n-        List<Future<Set<String>>> logsList = Lists.newArrayListWithExpectedSize(subNss.size());\n+        List<CompletableFuture<Set<String>>> logsList = Lists.newArrayListWithExpectedSize(subNss.size());\n         for (SubNamespace subNs : subNss) {\n             logsList.add(subNs.getLogs());\n         }\n-        return Future.collect(logsList);\n+        return FutureUtils.collect(logsList);\n     }\n \n     private Iterator<String> getIterator(List<Set<String>> resultList) {\n@@ -747,13 +745,9 @@ protected void watchNamespaceChanges() {\n     }\n \n     private void notifyOnNamespaceChanges() {\n-        retrieveLogs().onSuccess(new AbstractFunction1<List<Set<String>>, BoxedUnit>() {\n-            @Override\n-            public BoxedUnit apply(List<Set<String>> resultList) {\n-                for (NamespaceListener listener : listeners) {\n-                    listener.onStreamsChanged(getIterator(resultList));\n-                }\n-                return BoxedUnit.UNIT;\n+        retrieveLogs().thenAccept(resultList -> {\n+            for (NamespaceListener listener : listeners) {\n+                listener.onStreamsChanged(getIterator(resultList));\n             }\n         });\n     }"},{"sha":"e45c7554cedf34b121007be6e6fc9e432b5055c2","filename":"src/main/java/org/apache/distributedlog/impl/logsegment/BKLogSegmentAllocator.java","status":"modified","additions":10,"deletions":12,"changes":22,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fimpl%2Flogsegment%2FBKLogSegmentAllocator.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fimpl%2Flogsegment%2FBKLogSegmentAllocator.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fimpl%2Flogsegment%2FBKLogSegmentAllocator.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -17,25 +17,23 @@\n  */\n package org.apache.distributedlog.impl.logsegment;\n \n+import java.io.IOException;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Function;\n import org.apache.distributedlog.bk.LedgerAllocator;\n import org.apache.distributedlog.logsegment.LogSegmentEntryWriter;\n import org.apache.distributedlog.util.Allocator;\n import org.apache.distributedlog.util.Transaction;\n-import com.twitter.util.Future;\n import org.apache.bookkeeper.client.LedgerHandle;\n-import scala.Function1;\n-import scala.runtime.AbstractFunction1;\n-\n-import java.io.IOException;\n \n /**\n  * Allocate log segments\n  */\n class BKLogSegmentAllocator implements Allocator<LogSegmentEntryWriter, Object> {\n \n-    private static class NewLogSegmentEntryWriterFn extends AbstractFunction1<LedgerHandle, LogSegmentEntryWriter> {\n+    private static class NewLogSegmentEntryWriterFn implements Function<LedgerHandle, LogSegmentEntryWriter> {\n \n-        static final Function1<LedgerHandle, LogSegmentEntryWriter> INSTANCE =\n+        static final Function<LedgerHandle, LogSegmentEntryWriter> INSTANCE =\n                 new NewLogSegmentEntryWriterFn();\n \n         private NewLogSegmentEntryWriterFn() {}\n@@ -58,8 +56,8 @@ public void allocate() throws IOException {\n     }\n \n     @Override\n-    public Future<LogSegmentEntryWriter> tryObtain(Transaction<Object> txn,\n-                                                   final Transaction.OpListener<LogSegmentEntryWriter> listener) {\n+    public CompletableFuture<LogSegmentEntryWriter> tryObtain(Transaction<Object> txn,\n+                                                              final Transaction.OpListener<LogSegmentEntryWriter> listener) {\n         return allocator.tryObtain(txn, new Transaction.OpListener<LedgerHandle>() {\n             @Override\n             public void onCommit(LedgerHandle lh) {\n@@ -70,16 +68,16 @@ public void onCommit(LedgerHandle lh) {\n             public void onAbort(Throwable t) {\n                 listener.onAbort(t);\n             }\n-        }).map(NewLogSegmentEntryWriterFn.INSTANCE);\n+        }).thenApply(NewLogSegmentEntryWriterFn.INSTANCE);\n     }\n \n     @Override\n-    public Future<Void> asyncClose() {\n+    public CompletableFuture<Void> asyncClose() {\n         return allocator.asyncClose();\n     }\n \n     @Override\n-    public Future<Void> delete() {\n+    public CompletableFuture<Void> delete() {\n         return allocator.delete();\n     }\n }"},{"sha":"0bb91ae44502b5ae5e0687b31c7d0e6f0032bf4e","filename":"src/main/java/org/apache/distributedlog/impl/logsegment/BKLogSegmentEntryReader.java","status":"modified","additions":40,"deletions":38,"changes":78,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fimpl%2Flogsegment%2FBKLogSegmentEntryReader.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fimpl%2Flogsegment%2FBKLogSegmentEntryReader.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fimpl%2Flogsegment%2FBKLogSegmentEntryReader.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -19,6 +19,7 @@\n \n import com.google.common.annotations.VisibleForTesting;\n import com.google.common.collect.Lists;\n+import java.util.concurrent.CompletableFuture;\n import org.apache.distributedlog.DistributedLogConfiguration;\n import org.apache.distributedlog.Entry;\n import org.apache.distributedlog.LogSegmentMetadata;\n@@ -29,10 +30,8 @@\n import org.apache.distributedlog.exceptions.ReadCancelledException;\n import org.apache.distributedlog.injector.AsyncFailureInjector;\n import org.apache.distributedlog.logsegment.LogSegmentEntryReader;\n-import org.apache.distributedlog.util.FutureUtils;\n+import org.apache.distributedlog.common.concurrent.FutureUtils;\n import org.apache.distributedlog.util.OrderedScheduler;\n-import com.twitter.util.Future;\n-import com.twitter.util.Promise;\n import org.apache.bookkeeper.client.AsyncCallback;\n import org.apache.bookkeeper.client.BKException;\n import org.apache.bookkeeper.client.BookKeeper;\n@@ -87,7 +86,7 @@ synchronized boolean isDone() {\n             return done;\n         }\n \n-        void setValue(LedgerEntry entry) {\n+        void complete(LedgerEntry entry) {\n             synchronized (this) {\n                 if (done) {\n                     return;\n@@ -98,7 +97,7 @@ void setValue(LedgerEntry entry) {\n             setDone(true);\n         }\n \n-        void setException(int rc) {\n+        void completeExceptionally(int rc) {\n             synchronized (this) {\n                 if (done) {\n                     return;\n@@ -152,16 +151,16 @@ void processReadEntries(int rc,\n             while (entries.hasMoreElements()) {\n                 // more entries are returned\n                 if (null != entry) {\n-                    setException(BKException.Code.UnexpectedConditionException);\n+                    completeExceptionally(BKException.Code.UnexpectedConditionException);\n                     return;\n                 }\n                 entry = entries.nextElement();\n             }\n             if (null == entry || entry.getEntryId() != entryId) {\n-                setException(BKException.Code.UnexpectedConditionException);\n+                completeExceptionally(BKException.Code.UnexpectedConditionException);\n                 return;\n             }\n-            setValue(entry);\n+            complete(entry);\n         }\n \n         @Override\n@@ -186,7 +185,7 @@ void processReadEntry(int rc,\n                 return;\n             }\n             if (null != entry && this.entryId == entryId) {\n-                setValue(entry);\n+                complete(entry);\n                 return;\n             }\n             // the long poll is timeout or interrupted; we will retry it again.\n@@ -215,7 +214,7 @@ boolean checkReturnCodeAndHandleFailure(int rc, boolean isLongPoll) {\n                         nextReadBackoffTime,\n                         TimeUnit.MILLISECONDS);\n             } else {\n-                setException(rc);\n+                completeExceptionally(rc);\n             }\n             return false;\n         }\n@@ -229,7 +228,7 @@ public void run() {\n     private class PendingReadRequest {\n         private final int numEntries;\n         private final List<Entry.Reader> entries;\n-        private final Promise<List<Entry.Reader>> promise;\n+        private final CompletableFuture<List<Entry.Reader>> promise;\n \n         PendingReadRequest(int numEntries) {\n             this.numEntries = numEntries;\n@@ -238,23 +237,23 @@ private class PendingReadRequest {\n             } else {\n                 this.entries = new ArrayList<Entry.Reader>();\n             }\n-            this.promise = new Promise<List<Entry.Reader>>();\n+            this.promise = new CompletableFuture<List<Entry.Reader>>();\n         }\n \n-        Promise<List<Entry.Reader>> getPromise() {\n+        CompletableFuture<List<Entry.Reader>> getPromise() {\n             return promise;\n         }\n \n-        void setException(Throwable throwable) {\n-            FutureUtils.setException(promise, throwable);\n+        void completeExceptionally(Throwable throwable) {\n+            FutureUtils.completeExceptionally(promise, throwable);\n         }\n \n         void addEntry(Entry.Reader entry) {\n             entries.add(entry);\n         }\n \n         void complete() {\n-            FutureUtils.setValue(promise, entries);\n+            FutureUtils.complete(promise, entries);\n             onEntriesConsumed(entries.size());\n         }\n \n@@ -277,7 +276,7 @@ boolean hasReadEnoughEntries() {\n     private final int numPrefetchEntries;\n     private final int maxPrefetchEntries;\n     // state\n-    private Promise<Void> closePromise = null;\n+    private CompletableFuture<Void> closePromise = null;\n     private LogSegmentMetadata metadata;\n     private LedgerHandle lh;\n     private final List<LedgerHandle> openLedgerHandles;\n@@ -457,7 +456,7 @@ private void failOrRetryOpenLedger(int rc, final LogSegmentMetadata segment) {\n         if (isBeyondLastAddConfirmed()) {\n             // if the reader is already caught up, let's fail the reader immediately\n             // as we need to pull the latest metadata of this log segment.\n-            setException(new BKTransmitException(\"Failed to open ledger for reading log segment \" + getSegment(), rc),\n+            completeExceptionally(new BKTransmitException(\"Failed to open ledger for reading log segment \" + getSegment(), rc),\n                     true);\n             return;\n         }\n@@ -488,7 +487,7 @@ private boolean checkClosedOrInError() {\n      * @param throwable exception indicating the error\n      * @param isBackground is the reader set exception by background reads or foreground reads\n      */\n-    private void setException(Throwable throwable, boolean isBackground) {\n+    private void completeExceptionally(Throwable throwable, boolean isBackground) {\n         lastException.compareAndSet(null, throwable);\n         if (isBackground) {\n             notifyReaders();\n@@ -510,7 +509,7 @@ private void cancelAllPendingReads(Throwable throwExc) {\n             readQueue.clear();\n         }\n         for (PendingReadRequest request : requestsToCancel) {\n-            request.setException(throwExc);\n+            request.completeExceptionally(throwExc);\n         }\n     }\n \n@@ -630,11 +629,11 @@ Entry.Reader processReadEntry(LedgerEntry entry) throws IOException {\n     }\n \n     @Override\n-    public Future<List<Entry.Reader>> readNext(int numEntries) {\n+    public CompletableFuture<List<Entry.Reader>> readNext(int numEntries) {\n         final PendingReadRequest readRequest = new PendingReadRequest(numEntries);\n \n         if (checkClosedOrInError()) {\n-            readRequest.setException(lastException.get());\n+            readRequest.completeExceptionally(lastException.get());\n         } else {\n             boolean wasQueueEmpty;\n             synchronized (readQueue) {\n@@ -682,9 +681,9 @@ public void run() {\n             // mark the reader in error and abort all pending reads since\n             // we don't know the last consumed read\n             if (null == lastException.get()) {\n-                if (nextRequest.getPromise().isInterrupted().isDefined()) {\n-                    setException(new DLInterruptedException(\"Interrupted on reading log segment \"\n-                            + getSegment() + \" : \" + nextRequest.getPromise().isInterrupted().get()), false);\n+                if (nextRequest.getPromise().isCancelled()) {\n+                    completeExceptionally(new DLInterruptedException(\"Interrupted on reading log segment \"\n+                            + getSegment() + \" : \" + nextRequest.getPromise().isCancelled()), false);\n                 }\n             }\n \n@@ -707,11 +706,11 @@ public void run() {\n                 } else {\n                     DLIllegalStateException ise = new DLIllegalStateException(\"Unexpected condition at reading from \"\n                             + getSegment());\n-                    nextRequest.setException(ise);\n+                    nextRequest.completeExceptionally(ise);\n                     if (null != request) {\n-                        request.setException(ise);\n+                        request.completeExceptionally(ise);\n                     }\n-                    setException(ise, false);\n+                    completeExceptionally(ise, false);\n                 }\n             } else {\n                 if (0 == scheduleCountLocal) {\n@@ -732,7 +731,7 @@ private void readEntriesFromReadAheadCache(PendingReadRequest nextRequest) {\n             }\n             // reach end of log segment\n             if (hitEndOfLogSegment) {\n-                setException(new EndOfLogSegmentException(getSegment().getZNodeName()), false);\n+                completeExceptionally(new EndOfLogSegmentException(getSegment().getZNodeName()), false);\n                 return;\n             }\n             if (null == entry) {\n@@ -742,7 +741,7 @@ private void readEntriesFromReadAheadCache(PendingReadRequest nextRequest) {\n             if (!entry.isDone()) {\n                 // we already reached end of the log segment\n                 if (isEndOfLogSegment(entry.getEntryId())) {\n-                    setException(new EndOfLogSegmentException(getSegment().getZNodeName()), false);\n+                    completeExceptionally(new EndOfLogSegmentException(getSegment().getZNodeName()), false);\n                 }\n                 return;\n             }\n@@ -751,13 +750,13 @@ private void readEntriesFromReadAheadCache(PendingReadRequest nextRequest) {\n                 if (entry != removedEntry) {\n                     DLIllegalStateException ise = new DLIllegalStateException(\"Unexpected condition at reading from \"\n                             + getSegment());\n-                    setException(ise, false);\n+                    completeExceptionally(ise, false);\n                     return;\n                 }\n                 try {\n                     nextRequest.addEntry(processReadEntry(entry.getEntry()));\n                 } catch (IOException e) {\n-                    setException(e, false);\n+                    completeExceptionally(e, false);\n                     return;\n                 }\n             } else if (skipBrokenEntries && BKException.Code.DigestMatchException == entry.getRc()) {\n@@ -766,7 +765,7 @@ private void readEntriesFromReadAheadCache(PendingReadRequest nextRequest) {\n                 readAheadEntries.poll();\n                 continue;\n             } else {\n-                setException(new BKTransmitException(\"Encountered issue on reading entry \" + entry.getEntryId()\n+                completeExceptionally(new BKTransmitException(\"Encountered issue on reading entry \" + entry.getEntryId()\n                         + \" @ log segment \" + getSegment(), entry.getRc()), false);\n                 return;\n             }\n@@ -812,26 +811,29 @@ synchronized boolean isClosed() {\n     }\n \n     @Override\n-    public Future<Void> asyncClose() {\n-        final Promise<Void> closeFuture;\n+    public CompletableFuture<Void> asyncClose() {\n+        final CompletableFuture<Void> closeFuture;\n         ReadCancelledException exception;\n         LedgerHandle[] lhsToClose;\n         synchronized (this) {\n             if (null != closePromise) {\n                 return closePromise;\n             }\n-            closeFuture = closePromise = new Promise<Void>();\n+            closeFuture = closePromise = new CompletableFuture<Void>();\n             lhsToClose = openLedgerHandles.toArray(new LedgerHandle[openLedgerHandles.size()]);\n             // set the exception to cancel pending and subsequent reads\n             exception = new ReadCancelledException(getSegment().getZNodeName(), \"Reader was closed\");\n-            setException(exception, false);\n+            completeExceptionally(exception, false);\n         }\n \n         // cancel all pending reads\n         cancelAllPendingReads(exception);\n \n         // close all the open ledger\n-        BKUtils.closeLedgers(lhsToClose).proxyTo(closeFuture);\n+        FutureUtils.proxyTo(\n+            BKUtils.closeLedgers(lhsToClose),\n+            closeFuture\n+        );\n         return closeFuture;\n     }\n }"},{"sha":"14ebf4ae555ec13531d08f2da1bd03981afda402","filename":"src/main/java/org/apache/distributedlog/impl/logsegment/BKLogSegmentEntryStore.java","status":"modified","additions":20,"deletions":21,"changes":41,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fimpl%2Flogsegment%2FBKLogSegmentEntryStore.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fimpl%2Flogsegment%2FBKLogSegmentEntryStore.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fimpl%2Flogsegment%2FBKLogSegmentEntryStore.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -17,6 +17,7 @@\n  */\n package org.apache.distributedlog.impl.logsegment;\n \n+import java.util.concurrent.CompletableFuture;\n import org.apache.distributedlog.BookKeeperClient;\n import org.apache.distributedlog.DistributedLogConfiguration;\n import org.apache.distributedlog.LogSegmentMetadata;\n@@ -35,10 +36,8 @@\n import org.apache.distributedlog.logsegment.LogSegmentRandomAccessEntryReader;\n import org.apache.distributedlog.metadata.LogMetadataForWriter;\n import org.apache.distributedlog.util.Allocator;\n-import org.apache.distributedlog.util.FutureUtils;\n+import org.apache.distributedlog.common.concurrent.FutureUtils;\n import org.apache.distributedlog.util.OrderedScheduler;\n-import com.twitter.util.Future;\n-import com.twitter.util.Promise;\n import org.apache.bookkeeper.client.AsyncCallback;\n import org.apache.bookkeeper.client.BKException;\n import org.apache.bookkeeper.client.BookKeeper;\n@@ -65,25 +64,25 @@ private static class OpenReaderRequest {\n \n         private final LogSegmentMetadata segment;\n         private final long startEntryId;\n-        private final Promise<LogSegmentEntryReader> openPromise;\n+        private final CompletableFuture<LogSegmentEntryReader> openPromise;\n \n         OpenReaderRequest(LogSegmentMetadata segment,\n                           long startEntryId) {\n             this.segment = segment;\n             this.startEntryId = startEntryId;\n-            this.openPromise = new Promise<LogSegmentEntryReader>();\n+            this.openPromise = new CompletableFuture<LogSegmentEntryReader>();\n         }\n \n     }\n \n     private static class DeleteLogSegmentRequest {\n \n         private final LogSegmentMetadata segment;\n-        private final Promise<LogSegmentMetadata> deletePromise;\n+        private final CompletableFuture<LogSegmentMetadata> deletePromise;\n \n         DeleteLogSegmentRequest(LogSegmentMetadata segment) {\n             this.segment = segment;\n-            this.deletePromise = new Promise<LogSegmentMetadata>();\n+            this.deletePromise = new CompletableFuture<LogSegmentMetadata>();\n         }\n \n     }\n@@ -119,13 +118,13 @@ public BKLogSegmentEntryStore(DistributedLogConfiguration conf,\n     }\n \n     @Override\n-    public Future<LogSegmentMetadata> deleteLogSegment(LogSegmentMetadata segment) {\n+    public CompletableFuture<LogSegmentMetadata> deleteLogSegment(LogSegmentMetadata segment) {\n         DeleteLogSegmentRequest request = new DeleteLogSegmentRequest(segment);\n         BookKeeper bk;\n         try {\n             bk = this.bkc.get();\n         } catch (IOException e) {\n-            return Future.exception(e);\n+            return FutureUtils.exception(e);\n         }\n         bk.asyncDeleteLedger(segment.getLogSegmentId(), this, request);\n         return request.deletePromise;\n@@ -141,11 +140,11 @@ public void deleteComplete(int rc, Object ctx) {\n             logger.error(\"Couldn't delete ledger {} from bookkeeper for {} : {}\",\n                     new Object[]{ deleteRequest.segment.getLogSegmentId(), deleteRequest.segment,\n                             BKException.getMessage(rc) });\n-            FutureUtils.setException(deleteRequest.deletePromise,\n+            FutureUtils.completeExceptionally(deleteRequest.deletePromise,\n                     new BKTransmitException(\"Couldn't delete log segment \" + deleteRequest.segment, rc));\n             return;\n         }\n-        FutureUtils.setValue(deleteRequest.deletePromise, deleteRequest.segment);\n+        FutureUtils.complete(deleteRequest.deletePromise, deleteRequest.segment);\n     }\n \n     //\n@@ -186,13 +185,13 @@ public Allocator<LogSegmentEntryWriter, Object> newLogSegmentAllocator(\n     //\n \n     @Override\n-    public Future<LogSegmentEntryReader> openReader(LogSegmentMetadata segment,\n+    public CompletableFuture<LogSegmentEntryReader> openReader(LogSegmentMetadata segment,\n                                                     long startEntryId) {\n         BookKeeper bk;\n         try {\n             bk = this.bkc.get();\n         } catch (IOException e) {\n-            return Future.exception(e);\n+            return FutureUtils.exception(e);\n         }\n         OpenReaderRequest request = new OpenReaderRequest(segment, startEntryId);\n         if (segment.isInProgress()) {\n@@ -217,7 +216,7 @@ public Future<LogSegmentEntryReader> openReader(LogSegmentMetadata segment,\n     public void openComplete(int rc, LedgerHandle lh, Object ctx) {\n         OpenReaderRequest request = (OpenReaderRequest) ctx;\n         if (BKException.Code.OK != rc) {\n-            FutureUtils.setException(\n+            FutureUtils.completeExceptionally(\n                     request.openPromise,\n                     new BKTransmitException(\"Failed to open ledger handle for log segment \" + request.segment, rc));\n             return;\n@@ -233,28 +232,28 @@ public void openComplete(int rc, LedgerHandle lh, Object ctx) {\n                     conf,\n                     statsLogger,\n                     failureInjector);\n-            FutureUtils.setValue(request.openPromise, reader);\n+            FutureUtils.complete(request.openPromise, reader);\n         } catch (IOException e) {\n-            FutureUtils.setException(request.openPromise, e);\n+            FutureUtils.completeExceptionally(request.openPromise, e);\n         }\n \n     }\n \n     @Override\n-    public Future<LogSegmentRandomAccessEntryReader> openRandomAccessReader(final LogSegmentMetadata segment,\n+    public CompletableFuture<LogSegmentRandomAccessEntryReader> openRandomAccessReader(final LogSegmentMetadata segment,\n                                                                             final boolean fence) {\n         final BookKeeper bk;\n         try {\n             bk = this.bkc.get();\n         } catch (IOException e) {\n-            return Future.exception(e);\n+            return FutureUtils.exception(e);\n         }\n-        final Promise<LogSegmentRandomAccessEntryReader> openPromise = new Promise<LogSegmentRandomAccessEntryReader>();\n+        final CompletableFuture<LogSegmentRandomAccessEntryReader> openPromise = new CompletableFuture<LogSegmentRandomAccessEntryReader>();\n         AsyncCallback.OpenCallback openCallback = new AsyncCallback.OpenCallback() {\n             @Override\n             public void openComplete(int rc, LedgerHandle lh, Object ctx) {\n                 if (BKException.Code.OK != rc) {\n-                    FutureUtils.setException(\n+                    FutureUtils.completeExceptionally(\n                             openPromise,\n                             new BKTransmitException(\"Failed to open ledger handle for log segment \" + segment, rc));\n                     return;\n@@ -263,7 +262,7 @@ public void openComplete(int rc, LedgerHandle lh, Object ctx) {\n                         segment,\n                         lh,\n                         conf);\n-                FutureUtils.setValue(openPromise, reader);\n+                FutureUtils.complete(openPromise, reader);\n             }\n         };\n         if (segment.isInProgress() && !fence) {"},{"sha":"254345e8a770a895ad3e1425eb3b7d84b45fa033","filename":"src/main/java/org/apache/distributedlog/impl/logsegment/BKLogSegmentRandomAccessEntryReader.java","status":"modified","additions":16,"deletions":14,"changes":30,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fimpl%2Flogsegment%2FBKLogSegmentRandomAccessEntryReader.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fimpl%2Flogsegment%2FBKLogSegmentRandomAccessEntryReader.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fimpl%2Flogsegment%2FBKLogSegmentRandomAccessEntryReader.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -18,14 +18,13 @@\n package org.apache.distributedlog.impl.logsegment;\n \n import com.google.common.collect.Lists;\n+import java.util.concurrent.CompletableFuture;\n import org.apache.distributedlog.DistributedLogConfiguration;\n import org.apache.distributedlog.Entry;\n import org.apache.distributedlog.LogSegmentMetadata;\n import org.apache.distributedlog.exceptions.BKTransmitException;\n import org.apache.distributedlog.logsegment.LogSegmentRandomAccessEntryReader;\n-import org.apache.distributedlog.util.FutureUtils;\n-import com.twitter.util.Future;\n-import com.twitter.util.Promise;\n+import org.apache.distributedlog.common.concurrent.FutureUtils;\n import org.apache.bookkeeper.client.AsyncCallback.ReadCallback;\n import org.apache.bookkeeper.client.BKException;\n import org.apache.bookkeeper.client.LedgerEntry;\n@@ -49,7 +48,7 @@ class BKLogSegmentRandomAccessEntryReader implements\n     // state\n     private final LogSegmentMetadata metadata;\n     private final LedgerHandle lh;\n-    private Promise<Void> closePromise = null;\n+    private CompletableFuture<Void> closePromise = null;\n \n     BKLogSegmentRandomAccessEntryReader(LogSegmentMetadata metadata,\n                                         LedgerHandle lh,\n@@ -68,8 +67,8 @@ public long getLastAddConfirmed() {\n     }\n \n     @Override\n-    public Future<List<Entry.Reader>> readEntries(long startEntryId, long endEntryId) {\n-        Promise<List<Entry.Reader>> promise = new Promise<List<Entry.Reader>>();\n+    public CompletableFuture<List<Entry.Reader>> readEntries(long startEntryId, long endEntryId) {\n+        CompletableFuture<List<Entry.Reader>> promise = new CompletableFuture<List<Entry.Reader>>();\n         lh.asyncReadEntries(startEntryId, endEntryId, this, promise);\n         return promise;\n     }\n@@ -86,34 +85,37 @@ Entry.Reader processReadEntry(LedgerEntry entry) throws IOException {\n \n     @Override\n     public void readComplete(int rc, LedgerHandle lh, Enumeration<LedgerEntry> entries, Object ctx) {\n-        Promise<List<Entry.Reader>> promise = (Promise<List<Entry.Reader>>) ctx;\n+        CompletableFuture<List<Entry.Reader>> promise = (CompletableFuture<List<Entry.Reader>>) ctx;\n         if (BKException.Code.OK == rc) {\n             List<Entry.Reader> entryList = Lists.newArrayList();\n             while (entries.hasMoreElements()) {\n                 try {\n                     entryList.add(processReadEntry(entries.nextElement()));\n                 } catch (IOException ioe) {\n-                    FutureUtils.setException(promise, ioe);\n+                    FutureUtils.completeExceptionally(promise, ioe);\n                     return;\n                 }\n             }\n-            FutureUtils.setValue(promise, entryList);\n+            FutureUtils.complete(promise, entryList);\n         } else {\n-            FutureUtils.setException(promise,\n+            FutureUtils.completeExceptionally(promise,\n                     new BKTransmitException(\"Failed to read entries :\", rc));\n         }\n     }\n \n     @Override\n-    public Future<Void> asyncClose() {\n-        final Promise<Void> closeFuture;\n+    public CompletableFuture<Void> asyncClose() {\n+        final CompletableFuture<Void> closeFuture;\n         synchronized (this) {\n             if (null != closePromise) {\n                 return closePromise;\n             }\n-            closeFuture = closePromise = new Promise<Void>();\n+            closeFuture = closePromise = new CompletableFuture<Void>();\n         }\n-        BKUtils.closeLedgers(lh).proxyTo(closeFuture);\n+        FutureUtils.proxyTo(\n+            BKUtils.closeLedgers(lh),\n+            closeFuture\n+        );\n         return closeFuture;\n     }\n }"},{"sha":"82ba7757cae83e6183d7b81a0dfe488f30b84892","filename":"src/main/java/org/apache/distributedlog/impl/logsegment/BKUtils.java","status":"modified","additions":10,"deletions":12,"changes":22,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fimpl%2Flogsegment%2FBKUtils.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fimpl%2Flogsegment%2FBKUtils.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fimpl%2Flogsegment%2FBKUtils.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -18,11 +18,9 @@\n package org.apache.distributedlog.impl.logsegment;\n \n import com.google.common.collect.Lists;\n-import org.apache.distributedlog.function.VoidFunctions;\n-import org.apache.distributedlog.util.FutureUtils;\n-import com.twitter.util.Future;\n-import com.twitter.util.Futures;\n-import com.twitter.util.Promise;\n+import java.util.concurrent.CompletableFuture;\n+import org.apache.distributedlog.common.functions.VoidFunctions;\n+import org.apache.distributedlog.common.concurrent.FutureUtils;\n import org.apache.bookkeeper.client.AsyncCallback;\n import org.apache.bookkeeper.client.BKException;\n import org.apache.bookkeeper.client.LedgerHandle;\n@@ -40,15 +38,15 @@ public class BKUtils {\n      * @param lh ledger handle\n      * @return future represents close result.\n      */\n-    public static Future<Void> closeLedger(LedgerHandle lh) {\n-        final Promise<Void> closePromise = new Promise<Void>();\n+    public static CompletableFuture<Void> closeLedger(LedgerHandle lh) {\n+        final CompletableFuture<Void> closePromise = new CompletableFuture<Void>();\n         lh.asyncClose(new AsyncCallback.CloseCallback() {\n             @Override\n             public void closeComplete(int rc, LedgerHandle lh, Object ctx) {\n                 if (BKException.Code.OK != rc) {\n-                    FutureUtils.setException(closePromise, BKException.create(rc));\n+                    FutureUtils.completeExceptionally(closePromise, BKException.create(rc));\n                 } else {\n-                    FutureUtils.setValue(closePromise, null);\n+                    FutureUtils.complete(closePromise, null);\n                 }\n             }\n         }, null);\n@@ -61,12 +59,12 @@ public void closeComplete(int rc, LedgerHandle lh, Object ctx) {\n      * @param lhs a list of ledgers\n      * @return future represents close results.\n      */\n-    public static Future<Void> closeLedgers(LedgerHandle ... lhs) {\n-        List<Future<Void>> closeResults = Lists.newArrayListWithExpectedSize(lhs.length);\n+    public static CompletableFuture<Void> closeLedgers(LedgerHandle ... lhs) {\n+        List<CompletableFuture<Void>> closeResults = Lists.newArrayListWithExpectedSize(lhs.length);\n         for (LedgerHandle lh : lhs) {\n             closeResults.add(closeLedger(lh));\n         }\n-        return Futures.collect(closeResults).map(VoidFunctions.LIST_TO_VOID_FUNC);\n+        return FutureUtils.collect(closeResults).thenApply(VoidFunctions.LIST_TO_VOID_FUNC);\n     }\n \n }"},{"sha":"9b02462972f08055022b08ca95a88b545c52e7fb","filename":"src/main/java/org/apache/distributedlog/impl/metadata/ZKLogStreamMetadataStore.java","status":"modified","additions":76,"deletions":92,"changes":168,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fimpl%2Fmetadata%2FZKLogStreamMetadataStore.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fimpl%2Fmetadata%2FZKLogStreamMetadataStore.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fimpl%2Fmetadata%2FZKLogStreamMetadataStore.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -20,10 +20,12 @@\n import com.google.common.base.Optional;\n import com.google.common.base.Preconditions;\n import com.google.common.collect.Lists;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Function;\n import org.apache.distributedlog.DistributedLogConfiguration;\n import org.apache.distributedlog.DistributedLogConstants;\n import org.apache.distributedlog.ZooKeeperClient;\n-import org.apache.distributedlog.exceptions.DLException;\n import org.apache.distributedlog.exceptions.DLInterruptedException;\n import org.apache.distributedlog.exceptions.InvalidStreamNameException;\n import org.apache.distributedlog.exceptions.LockCancelledException;\n@@ -42,18 +44,14 @@\n import org.apache.distributedlog.metadata.LogMetadataForReader;\n import org.apache.distributedlog.metadata.LogMetadataForWriter;\n import org.apache.distributedlog.util.DLUtils;\n-import org.apache.distributedlog.util.FutureUtils;\n-import org.apache.distributedlog.util.SchedulerUtils;\n+import org.apache.distributedlog.common.concurrent.FutureUtils;\n+import org.apache.distributedlog.common.util.SchedulerUtils;\n import org.apache.distributedlog.zk.LimitedPermitManager;\n import org.apache.distributedlog.util.OrderedScheduler;\n-import org.apache.distributedlog.util.PermitManager;\n+import org.apache.distributedlog.common.util.PermitManager;\n import org.apache.distributedlog.util.Transaction;\n import org.apache.distributedlog.util.Utils;\n import org.apache.distributedlog.zk.ZKTransaction;\n-import com.twitter.util.ExceptionalFunction;\n-import com.twitter.util.ExceptionalFunction0;\n-import com.twitter.util.Future;\n-import com.twitter.util.Promise;\n import org.apache.bookkeeper.meta.ZkVersion;\n import org.apache.bookkeeper.stats.StatsLogger;\n import org.apache.bookkeeper.versioning.Versioned;\n@@ -69,10 +67,7 @@\n import org.apache.zookeeper.data.Stat;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n-import scala.runtime.AbstractFunction1;\n-import scala.runtime.BoxedUnit;\n \n-import java.io.File;\n import java.io.IOException;\n import java.net.URI;\n import java.util.List;\n@@ -120,14 +115,9 @@ public ZKLogStreamMetadataStore(String clientId,\n \n     private synchronized OrderedScheduler getLockStateExecutor(boolean createIfNull) {\n         if (createIfNull && null == lockStateExecutor) {\n-            StatsLogger lockStateStatsLogger = statsLogger.scope(\"lock_scheduler\");\n             lockStateExecutor = OrderedScheduler.newBuilder()\n                     .name(\"DLM-LockState\")\n                     .corePoolSize(conf.getNumLockStateThreads())\n-                    .statsLogger(lockStateStatsLogger)\n-                    .perExecutorStatsLogger(lockStateStatsLogger)\n-                    .traceTaskExecution(conf.getEnableTaskExecutionStats())\n-                    .traceTaskExecutionWarnTimeUs(conf.getTaskExecutionWarnTimeMicros())\n                     .build();\n         }\n         return lockStateExecutor;\n@@ -174,34 +164,34 @@ public Transaction<Object> newTransaction() {\n     }\n \n     @Override\n-    public Future<Void> logExists(URI uri, final String logName) {\n+    public CompletableFuture<Void> logExists(URI uri, final String logName) {\n         final String logSegmentsPath = LogMetadata.getLogSegmentsPath(\n                 uri, logName, conf.getUnpartitionedStreamName());\n-        final Promise<Void> promise = new Promise<Void>();\n+        final CompletableFuture<Void> promise = new CompletableFuture<Void>();\n         try {\n             final ZooKeeper zk = zooKeeperClient.get();\n             zk.sync(logSegmentsPath, new AsyncCallback.VoidCallback() {\n                 @Override\n                 public void processResult(int syncRc, String path, Object syncCtx) {\n                     if (KeeperException.Code.NONODE.intValue() == syncRc) {\n-                        promise.setException(new LogNotFoundException(\n+                        promise.completeExceptionally(new LogNotFoundException(\n                                 String.format(\"Log %s does not exist or has been deleted\", logName)));\n                         return;\n                     } else if (KeeperException.Code.OK.intValue() != syncRc){\n-                        promise.setException(new ZKException(\"Error on checking log existence for \" + logName,\n+                        promise.completeExceptionally(new ZKException(\"Error on checking log existence for \" + logName,\n                                 KeeperException.create(KeeperException.Code.get(syncRc))));\n                         return;\n                     }\n                     zk.exists(logSegmentsPath, false, new AsyncCallback.StatCallback() {\n                         @Override\n                         public void processResult(int rc, String path, Object ctx, Stat stat) {\n                             if (KeeperException.Code.OK.intValue() == rc) {\n-                                promise.setValue(null);\n+                                promise.complete(null);\n                             } else if (KeeperException.Code.NONODE.intValue() == rc) {\n-                                promise.setException(new LogNotFoundException(\n+                                promise.completeExceptionally(new LogNotFoundException(\n                                         String.format(\"Log %s does not exist or has been deleted\", logName)));\n                             } else {\n-                                promise.setException(new ZKException(\"Error on checking log existence for \" + logName,\n+                                promise.completeExceptionally(new ZKException(\"Error on checking log existence for \" + logName,\n                                         KeeperException.create(KeeperException.Code.get(rc))));\n                             }\n                         }\n@@ -211,10 +201,10 @@ public void processResult(int rc, String path, Object ctx, Stat stat) {\n \n         } catch (InterruptedException ie) {\n             LOG.error(\"Interrupted while reading {}\", logSegmentsPath, ie);\n-            promise.setException(new DLInterruptedException(\"Interrupted while checking \"\n+            promise.completeExceptionally(new DLInterruptedException(\"Interrupted while checking \"\n                     + logSegmentsPath, ie));\n         } catch (ZooKeeperClient.ZooKeeperConnectionException e) {\n-            promise.setException(e);\n+            promise.completeExceptionally(e);\n         }\n         return promise;\n     }\n@@ -237,15 +227,13 @@ public DistributedLock createWriteLock(LogMetadataForWriter metadata) {\n     // Create Read Lock\n     //\n \n-    private Future<Void> ensureReadLockPathExist(final LogMetadata logMetadata,\n+    private CompletableFuture<Void> ensureReadLockPathExist(final LogMetadata logMetadata,\n                                                  final String readLockPath) {\n-        final Promise<Void> promise = new Promise<Void>();\n-        promise.setInterruptHandler(new com.twitter.util.Function<Throwable, BoxedUnit>() {\n-            @Override\n-            public BoxedUnit apply(Throwable t) {\n-                FutureUtils.setException(promise, new LockCancelledException(readLockPath,\n-                        \"Could not ensure read lock path\", t));\n-                return null;\n+        final CompletableFuture<Void> promise = new CompletableFuture<Void>();\n+        promise.whenComplete((value, cause) -> {\n+            if (cause instanceof CancellationException) {\n+                FutureUtils.completeExceptionally(promise, new LockCancelledException(readLockPath,\n+                        \"Could not ensure read lock path\", cause));\n             }\n         });\n         Optional<String> parentPathShouldNotCreate = Optional.of(logMetadata.getLogRootPath());\n@@ -255,50 +243,41 @@ public BoxedUnit apply(Throwable t) {\n                     @Override\n                     public void processResult(final int rc, final String path, Object ctx, String name) {\n                         if (KeeperException.Code.NONODE.intValue() == rc) {\n-                            FutureUtils.setException(promise, new LogNotFoundException(\n+                            FutureUtils.completeExceptionally(promise, new LogNotFoundException(\n                                     String.format(\"Log %s does not exist or has been deleted\",\n                                             logMetadata.getFullyQualifiedName())));\n                         } else if (KeeperException.Code.OK.intValue() == rc) {\n-                            FutureUtils.setValue(promise, null);\n+                            FutureUtils.complete(promise, null);\n                             LOG.trace(\"Created path {}.\", path);\n                         } else if (KeeperException.Code.NODEEXISTS.intValue() == rc) {\n-                            FutureUtils.setValue(promise, null);\n+                            FutureUtils.complete(promise, null);\n                             LOG.trace(\"Path {} is already existed.\", path);\n                         } else if (DistributedLogConstants.ZK_CONNECTION_EXCEPTION_RESULT_CODE == rc) {\n-                            FutureUtils.setException(promise, new ZooKeeperClient.ZooKeeperConnectionException(path));\n+                            FutureUtils.completeExceptionally(promise, new ZooKeeperClient.ZooKeeperConnectionException(path));\n                         } else if (DistributedLogConstants.DL_INTERRUPTED_EXCEPTION_RESULT_CODE == rc) {\n-                            FutureUtils.setException(promise, new DLInterruptedException(path));\n+                            FutureUtils.completeExceptionally(promise, new DLInterruptedException(path));\n                         } else {\n-                            FutureUtils.setException(promise, KeeperException.create(KeeperException.Code.get(rc)));\n+                            FutureUtils.completeExceptionally(promise, KeeperException.create(KeeperException.Code.get(rc)));\n                         }\n                     }\n                 }, null);\n         return promise;\n     }\n \n     @Override\n-    public Future<DistributedLock> createReadLock(final LogMetadataForReader metadata,\n+    public CompletableFuture<DistributedLock> createReadLock(final LogMetadataForReader metadata,\n                                                   Optional<String> readerId) {\n         final String readLockPath = metadata.getReadLockPath(readerId);\n-        return ensureReadLockPathExist(metadata, readLockPath).flatMap(\n-                new ExceptionalFunction<Void, Future<DistributedLock>>() {\n-            @Override\n-            public Future<DistributedLock> applyE(Void value) throws Throwable {\n-                // Unfortunately this has a blocking call which we should not execute on the\n-                // ZK completion thread\n-                return scheduler.apply(new ExceptionalFunction0<DistributedLock>() {\n-                    @Override\n-                    public DistributedLock applyE() throws Throwable {\n-                        return new ZKDistributedLock(\n-                            getLockStateExecutor(true),\n-                            getLockFactory(true),\n-                            readLockPath,\n-                            conf.getLockTimeoutMilliSeconds(),\n-                            statsLogger.scope(\"read_lock\"));\n-                    }\n-                });\n-            }\n-        });\n+        return ensureReadLockPathExist(metadata, readLockPath)\n+            .thenApplyAsync((value) -> {\n+                DistributedLock lock = new ZKDistributedLock(\n+                    getLockStateExecutor(true),\n+                    getLockFactory(true),\n+                    readLockPath,\n+                    conf.getLockTimeoutMilliSeconds(),\n+                    statsLogger.scope(\"read_lock\"));\n+                return lock;\n+            }, scheduler.chooseExecutor(readLockPath));\n     }\n \n     //\n@@ -329,7 +308,7 @@ static byte[] intToBytes(int i) {\n             (byte) (i)};\n     }\n \n-    static Future<List<Versioned<byte[]>>> checkLogMetadataPaths(ZooKeeper zk,\n+    static CompletableFuture<List<Versioned<byte[]>>> checkLogMetadataPaths(ZooKeeper zk,\n                                                                  String logRootPath,\n                                                                  boolean ownAllocator) {\n         // Note re. persistent lock state initialization: the read lock persistent state (path) is\n@@ -344,7 +323,7 @@ static Future<List<Versioned<byte[]>>> checkLogMetadataPaths(ZooKeeper zk,\n         final String allocationPath = logRootPath + ALLOCATION_PATH;\n \n         int numPaths = ownAllocator ? MetadataIndex.ALLOCATION + 1 : MetadataIndex.LOGSEGMENTS + 1;\n-        List<Future<Versioned<byte[]>>> checkFutures = Lists.newArrayListWithExpectedSize(numPaths);\n+        List<CompletableFuture<Versioned<byte[]>>> checkFutures = Lists.newArrayListWithExpectedSize(numPaths);\n         checkFutures.add(Utils.zkGetData(zk, logRootParentPath, false));\n         checkFutures.add(Utils.zkGetData(zk, logRootPath, false));\n         checkFutures.add(Utils.zkGetData(zk, maxTxIdPath, false));\n@@ -356,7 +335,7 @@ static Future<List<Versioned<byte[]>>> checkLogMetadataPaths(ZooKeeper zk,\n             checkFutures.add(Utils.zkGetData(zk, allocationPath, false));\n         }\n \n-        return Future.collect(checkFutures);\n+        return FutureUtils.collect(checkFutures);\n     }\n \n     static boolean pathExists(Versioned<byte[]> metadata) {\n@@ -374,7 +353,7 @@ static void createMissingMetadata(final ZooKeeper zk,\n                                       final List<ACL> acl,\n                                       final boolean ownAllocator,\n                                       final boolean createIfNotExists,\n-                                      final Promise<List<Versioned<byte[]>>> promise) {\n+                                      final CompletableFuture<List<Versioned<byte[]>>> promise) {\n         final List<byte[]> pathsToCreate = Lists.newArrayListWithExpectedSize(metadatas.size());\n         final List<Op> zkOps = Lists.newArrayListWithExpectedSize(metadatas.size());\n         CreateMode createMode = CreateMode.PERSISTENT;\n@@ -447,11 +426,11 @@ static void createMissingMetadata(final ZooKeeper zk,\n         }\n         if (zkOps.isEmpty()) {\n             // nothing missed\n-            promise.setValue(metadatas);\n+            promise.complete(metadatas);\n             return;\n         }\n         if (!createIfNotExists) {\n-            promise.setException(new LogNotFoundException(\"Log \" + logRootPath + \" not found\"));\n+            promise.completeExceptionally(new LogNotFoundException(\"Log \" + logRootPath + \" not found\"));\n             return;\n         }\n \n@@ -469,9 +448,9 @@ public void processResult(int rc, String path, Object ctx, List<OpResult> result\n                             finalMetadatas.add(new Versioned<byte[]>(dataCreated, new ZkVersion(0)));\n                         }\n                     }\n-                    promise.setValue(finalMetadatas);\n+                    promise.complete(finalMetadatas);\n                 } else if (KeeperException.Code.NODEEXISTS.intValue() == rc) {\n-                    promise.setException(new LogExistsException(\"Someone just created log \"\n+                    promise.completeExceptionally(new LogExistsException(\"Someone just created log \"\n                             + logRootPath));\n                 } else {\n                     if (LOG.isDebugEnabled()) {\n@@ -488,7 +467,7 @@ public void processResult(int rc, String path, Object ctx, List<OpResult> result\n                         LOG.debug(\"Failed to create log, full rc list = {}\", resultCodeList);\n                     }\n \n-                    promise.setException(new ZKException(\"Failed to create log \" + logRootPath,\n+                    promise.completeExceptionally(new ZKException(\"Failed to create log \" + logRootPath,\n                             KeeperException.Code.get(rc)));\n                 }\n             }\n@@ -538,7 +517,7 @@ static LogMetadataForWriter processLogMetadatas(URI uri,\n         }\n     }\n \n-    static Future<LogMetadataForWriter> getLog(final URI uri,\n+    static CompletableFuture<LogMetadataForWriter> getLog(final URI uri,\n                                                final String logName,\n                                                final String logIdentifier,\n                                                final ZooKeeperClient zooKeeperClient,\n@@ -549,42 +528,47 @@ static Future<LogMetadataForWriter> getLog(final URI uri,\n             PathUtils.validatePath(logRootPath);\n         } catch (IllegalArgumentException e) {\n             LOG.error(\"Illegal path value {} for stream {}\", new Object[]{logRootPath, logName, e});\n-            return Future.exception(new InvalidStreamNameException(logName, \"Log name is invalid\"));\n+            return FutureUtils.exception(new InvalidStreamNameException(logName, \"Log name is invalid\"));\n         }\n \n         try {\n             final ZooKeeper zk = zooKeeperClient.get();\n             return checkLogMetadataPaths(zk, logRootPath, ownAllocator)\n-                    .flatMap(new AbstractFunction1<List<Versioned<byte[]>>, Future<List<Versioned<byte[]>>>>() {\n+                    .thenCompose(new Function<List<Versioned<byte[]>>, CompletableFuture<List<Versioned<byte[]>>>>() {\n                         @Override\n-                        public Future<List<Versioned<byte[]>>> apply(List<Versioned<byte[]>> metadatas) {\n-                            Promise<List<Versioned<byte[]>>> promise =\n-                                    new Promise<List<Versioned<byte[]>>>();\n+                        public CompletableFuture<List<Versioned<byte[]>>> apply(List<Versioned<byte[]>> metadatas) {\n+                            CompletableFuture<List<Versioned<byte[]>>> promise =\n+                                    new CompletableFuture<List<Versioned<byte[]>>>();\n                             createMissingMetadata(zk, logRootPath, metadatas, zooKeeperClient.getDefaultACL(),\n                                     ownAllocator, createIfNotExists, promise);\n                             return promise;\n                         }\n-                    }).map(new ExceptionalFunction<List<Versioned<byte[]>>, LogMetadataForWriter>() {\n+                    }).thenCompose(new Function<List<Versioned<byte[]>>, CompletableFuture<LogMetadataForWriter>>() {\n                         @Override\n-                        public LogMetadataForWriter applyE(List<Versioned<byte[]>> metadatas) throws DLException {\n-                            return processLogMetadatas(\n-                                    uri,\n-                                    logName,\n-                                    logIdentifier,\n-                                    metadatas,\n-                                    ownAllocator);\n+                        public CompletableFuture<LogMetadataForWriter> apply(List<Versioned<byte[]>> metadatas) {\n+                            try {\n+                                return FutureUtils.value(\n+                                    processLogMetadatas(\n+                                        uri,\n+                                        logName,\n+                                        logIdentifier,\n+                                        metadatas,\n+                                        ownAllocator));\n+                            } catch (UnexpectedException e) {\n+                                return FutureUtils.exception(e);\n+                            }\n                         }\n                     });\n         } catch (ZooKeeperClient.ZooKeeperConnectionException e) {\n-            return Future.exception(new ZKException(\"Encountered zookeeper connection issue on creating log \" + logName,\n+            return FutureUtils.exception(new ZKException(\"Encountered zookeeper connection issue on creating log \" + logName,\n                     KeeperException.Code.CONNECTIONLOSS));\n         } catch (InterruptedException e) {\n-            return Future.exception(new DLInterruptedException(\"Interrupted on creating log \" + logName, e));\n+            return FutureUtils.exception(new DLInterruptedException(\"Interrupted on creating log \" + logName, e));\n         }\n     }\n \n     @Override\n-    public Future<LogMetadataForWriter> getLog(final URI uri,\n+    public CompletableFuture<LogMetadataForWriter> getLog(final URI uri,\n                                                final String logName,\n                                                final boolean ownAllocator,\n                                                final boolean createIfNotExists) {\n@@ -602,30 +586,30 @@ public Future<LogMetadataForWriter> getLog(final URI uri,\n     //\n \n     @Override\n-    public Future<Void> deleteLog(URI uri, final String logName) {\n-        final Promise<Void> promise = new Promise<Void>();\n+    public CompletableFuture<Void> deleteLog(URI uri, final String logName) {\n+        final CompletableFuture<Void> promise = new CompletableFuture<Void>();\n         try {\n             String streamPath = LogMetadata.getLogStreamPath(uri, logName);\n             ZKUtil.deleteRecursive(zooKeeperClient.get(), streamPath, new AsyncCallback.VoidCallback() {\n                 @Override\n                 public void processResult(int rc, String path, Object ctx) {\n                     if (KeeperException.Code.OK.intValue() != rc) {\n-                        FutureUtils.setException(promise,\n+                        FutureUtils.completeExceptionally(promise,\n                                 new ZKException(\"Encountered zookeeper issue on deleting log stream \"\n                                         + logName, KeeperException.Code.get(rc)));\n                         return;\n                     }\n-                    FutureUtils.setValue(promise, null);\n+                    FutureUtils.complete(promise, null);\n                 }\n             }, null);\n         } catch (ZooKeeperClient.ZooKeeperConnectionException e) {\n-            FutureUtils.setException(promise, new ZKException(\"Encountered zookeeper issue on deleting log stream \"\n+            FutureUtils.completeExceptionally(promise, new ZKException(\"Encountered zookeeper issue on deleting log stream \"\n                     + logName, KeeperException.Code.CONNECTIONLOSS));\n         } catch (InterruptedException e) {\n-            FutureUtils.setException(promise, new DLInterruptedException(\"Interrupted while deleting log stream \"\n+            FutureUtils.completeExceptionally(promise, new DLInterruptedException(\"Interrupted while deleting log stream \"\n                     + logName));\n         } catch (KeeperException e) {\n-            FutureUtils.setException(promise, new ZKException(\"Encountered zookeeper issue on deleting log stream \"\n+            FutureUtils.completeExceptionally(promise, new ZKException(\"Encountered zookeeper issue on deleting log stream \"\n                     + logName, e));\n         }\n         return promise;"},{"sha":"302c666409c63fde32b23e9e441c56fb737cccb4","filename":"src/main/java/org/apache/distributedlog/impl/subscription/ZKSubscriptionStateStore.java","status":"modified","additions":22,"deletions":27,"changes":49,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fimpl%2Fsubscription%2FZKSubscriptionStateStore.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fimpl%2Fsubscription%2FZKSubscriptionStateStore.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fimpl%2Fsubscription%2FZKSubscriptionStateStore.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -17,27 +17,22 @@\n  */\n package org.apache.distributedlog.impl.subscription;\n \n+import com.google.common.base.Charsets;\n import java.io.IOException;\n+import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.atomic.AtomicReference;\n-\n-import org.apache.distributedlog.subscription.SubscriptionStateStore;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-import scala.runtime.BoxedUnit;\n-\n-import com.google.common.base.Charsets;\n-\n+import org.apache.distributedlog.DLSN;\n+import org.apache.distributedlog.ZooKeeperClient;\n+import org.apache.distributedlog.exceptions.DLInterruptedException;\n+import org.apache.distributedlog.api.subscription.SubscriptionStateStore;\n+import org.apache.distributedlog.common.concurrent.FutureUtils;\n+import org.apache.distributedlog.util.Utils;\n import org.apache.zookeeper.AsyncCallback;\n import org.apache.zookeeper.CreateMode;\n import org.apache.zookeeper.KeeperException;\n import org.apache.zookeeper.data.Stat;\n-\n-import org.apache.distributedlog.DLSN;\n-import org.apache.distributedlog.util.Utils;\n-import org.apache.distributedlog.ZooKeeperClient;\n-import org.apache.distributedlog.exceptions.DLInterruptedException;\n-import com.twitter.util.Future;\n-import com.twitter.util.Promise;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n public class ZKSubscriptionStateStore implements SubscriptionStateStore {\n \n@@ -60,42 +55,42 @@ public void close() throws IOException {\n      * Get the last committed position stored for this subscription\n      */\n     @Override\n-    public Future<DLSN> getLastCommitPosition() {\n+    public CompletableFuture<DLSN> getLastCommitPosition() {\n         if (null != lastCommittedPosition.get()) {\n-            return Future.value(lastCommittedPosition.get());\n+            return FutureUtils.value(lastCommittedPosition.get());\n         } else {\n             return getLastCommitPositionFromZK();\n         }\n     }\n \n-    Future<DLSN> getLastCommitPositionFromZK() {\n-        final Promise<DLSN> result = new Promise<DLSN>();\n+    CompletableFuture<DLSN> getLastCommitPositionFromZK() {\n+        final CompletableFuture<DLSN> result = new CompletableFuture<DLSN>();\n         try {\n             logger.debug(\"Reading last commit position from path {}\", zkPath);\n             zooKeeperClient.get().getData(zkPath, false, new AsyncCallback.DataCallback() {\n                 @Override\n                 public void processResult(int rc, String path, Object ctx, byte[] data, Stat stat) {\n                     logger.debug(\"Read last commit position from path {}: rc = {}\", zkPath, rc);\n                     if (KeeperException.Code.NONODE.intValue() == rc) {\n-                        result.setValue(DLSN.NonInclusiveLowerBound);\n+                        result.complete(DLSN.NonInclusiveLowerBound);\n                     } else if (KeeperException.Code.OK.intValue() != rc) {\n-                        result.setException(KeeperException.create(KeeperException.Code.get(rc), path));\n+                        result.completeExceptionally(KeeperException.create(KeeperException.Code.get(rc), path));\n                     } else {\n                         try {\n                             DLSN dlsn = DLSN.deserialize(new String(data, Charsets.UTF_8));\n-                            result.setValue(dlsn);\n+                            result.complete(dlsn);\n                         } catch (Exception t) {\n                             logger.warn(\"Invalid last commit position found from path {}\", zkPath, t);\n                             // invalid dlsn recorded in subscription state store\n-                            result.setValue(DLSN.NonInclusiveLowerBound);\n+                            result.complete(DLSN.NonInclusiveLowerBound);\n                         }\n                     }\n                 }\n             }, null);\n         } catch (ZooKeeperClient.ZooKeeperConnectionException zkce) {\n-            result.setException(zkce);\n+            result.completeExceptionally(zkce);\n         } catch (InterruptedException ie) {\n-            result.setException(new DLInterruptedException(\"getLastCommitPosition was interrupted\", ie));\n+            result.completeExceptionally(new DLInterruptedException(\"getLastCommitPosition was interrupted\", ie));\n         }\n         return result;\n     }\n@@ -106,7 +101,7 @@ public void processResult(int rc, String path, Object ctx, byte[] data, Stat sta\n      * @param newPosition - new commit position\n      */\n     @Override\n-    public Future<BoxedUnit> advanceCommitPosition(DLSN newPosition) {\n+    public CompletableFuture<Void> advanceCommitPosition(DLSN newPosition) {\n         if (null == lastCommittedPosition.get() ||\n             (newPosition.compareTo(lastCommittedPosition.get()) > 0)) {\n             lastCommittedPosition.set(newPosition);\n@@ -115,7 +110,7 @@ public Future<BoxedUnit> advanceCommitPosition(DLSN newPosition) {\n                 zooKeeperClient.getDefaultACL(),\n                 CreateMode.PERSISTENT);\n         } else {\n-            return Future.Done();\n+            return FutureUtils.Void();\n         }\n     }\n }"},{"sha":"039226471a88cdaa775f1a717e1d9e8716e42f64","filename":"src/main/java/org/apache/distributedlog/impl/subscription/ZKSubscriptionsStore.java","status":"modified","additions":35,"deletions":49,"changes":84,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fimpl%2Fsubscription%2FZKSubscriptionsStore.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fimpl%2Fsubscription%2FZKSubscriptionsStore.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fimpl%2Fsubscription%2FZKSubscriptionsStore.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -17,30 +17,26 @@\n  */\n package org.apache.distributedlog.impl.subscription;\n \n-import org.apache.distributedlog.DLSN;\n-import org.apache.distributedlog.ZooKeeperClient;\n-import org.apache.distributedlog.exceptions.DLInterruptedException;\n-import org.apache.distributedlog.subscription.SubscriptionStateStore;\n-import org.apache.distributedlog.subscription.SubscriptionsStore;\n-import org.apache.distributedlog.util.Utils;\n-import com.twitter.util.Future;\n-import com.twitter.util.Promise;\n-\n-import org.apache.bookkeeper.meta.ZkVersion;\n-import org.apache.commons.lang3.tuple.Pair;\n-import org.apache.zookeeper.AsyncCallback;\n-import org.apache.zookeeper.KeeperException;\n-import org.apache.zookeeper.data.Stat;\n-import scala.runtime.AbstractFunction1;\n-import scala.runtime.BoxedUnit;\n-\n import java.io.IOException;\n import java.util.ArrayList;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.ConcurrentMap;\n+import org.apache.bookkeeper.meta.ZkVersion;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.apache.distributedlog.DLSN;\n+import org.apache.distributedlog.ZooKeeperClient;\n+import org.apache.distributedlog.exceptions.DLInterruptedException;\n+import org.apache.distributedlog.api.subscription.SubscriptionStateStore;\n+import org.apache.distributedlog.api.subscription.SubscriptionsStore;\n+import org.apache.distributedlog.common.concurrent.FutureUtils;\n+import org.apache.distributedlog.util.Utils;\n+import org.apache.zookeeper.AsyncCallback;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.data.Stat;\n \n /**\n  * ZooKeeper Based Subscriptions Store.\n@@ -82,72 +78,62 @@ private String getSubscriberZKPath(String subscriberId) {\n     }\n \n     @Override\n-    public Future<DLSN> getLastCommitPosition(String subscriberId) {\n+    public CompletableFuture<DLSN> getLastCommitPosition(String subscriberId) {\n         return getSubscriber(subscriberId).getLastCommitPosition();\n     }\n \n     @Override\n-    public Future<Map<String, DLSN>> getLastCommitPositions() {\n-        final Promise<Map<String, DLSN>> result = new Promise<Map<String, DLSN>>();\n+    public CompletableFuture<Map<String, DLSN>> getLastCommitPositions() {\n+        final CompletableFuture<Map<String, DLSN>> result = new CompletableFuture<Map<String, DLSN>>();\n         try {\n             this.zkc.get().getChildren(this.zkPath, false, new AsyncCallback.Children2Callback() {\n                 @Override\n                 public void processResult(int rc, String path, Object ctx, List<String> children, Stat stat) {\n                     if (KeeperException.Code.NONODE.intValue() == rc) {\n-                        result.setValue(new HashMap<String, DLSN>());\n+                        result.complete(new HashMap<String, DLSN>());\n                     } else if (KeeperException.Code.OK.intValue() != rc) {\n-                        result.setException(KeeperException.create(KeeperException.Code.get(rc), path));\n+                        result.completeExceptionally(KeeperException.create(KeeperException.Code.get(rc), path));\n                     } else {\n                         getLastCommitPositions(result, children);\n                     }\n                 }\n             }, null);\n         } catch (ZooKeeperClient.ZooKeeperConnectionException zkce) {\n-            result.setException(zkce);\n+            result.completeExceptionally(zkce);\n         } catch (InterruptedException ie) {\n-            result.setException(new DLInterruptedException(\"getLastCommitPositions was interrupted\", ie));\n+            result.completeExceptionally(new DLInterruptedException(\"getLastCommitPositions was interrupted\", ie));\n         }\n         return result;\n     }\n \n-    private void getLastCommitPositions(final Promise<Map<String, DLSN>> result,\n+    private void getLastCommitPositions(final CompletableFuture<Map<String, DLSN>> result,\n                                         List<String> subscribers) {\n-        List<Future<Pair<String, DLSN>>> futures =\n-                new ArrayList<Future<Pair<String, DLSN>>>(subscribers.size());\n+        List<CompletableFuture<Pair<String, DLSN>>> futures =\n+                new ArrayList<CompletableFuture<Pair<String, DLSN>>>(subscribers.size());\n         for (String s : subscribers) {\n             final String subscriber = s;\n-            Future<Pair<String, DLSN>> future =\n+            CompletableFuture<Pair<String, DLSN>> future =\n                 // Get the last commit position from zookeeper\n-                getSubscriber(subscriber).getLastCommitPositionFromZK().map(\n-                        new AbstractFunction1<DLSN, Pair<String, DLSN>>() {\n-                            @Override\n-                            public Pair<String, DLSN> apply(DLSN dlsn) {\n-                                return Pair.of(subscriber, dlsn);\n-                            }\n-                        });\n+                getSubscriber(subscriber).getLastCommitPositionFromZK().thenApply(\n+                    dlsn -> Pair.of(subscriber, dlsn));\n             futures.add(future);\n         }\n-        Future.collect(futures).foreach(\n-            new AbstractFunction1<List<Pair<String, DLSN>>, BoxedUnit>() {\n-                @Override\n-                public BoxedUnit apply(List<Pair<String, DLSN>> subscriptions) {\n-                    Map<String, DLSN> subscriptionMap = new HashMap<String, DLSN>();\n-                    for (Pair<String, DLSN> pair : subscriptions) {\n-                        subscriptionMap.put(pair.getLeft(), pair.getRight());\n-                    }\n-                    result.setValue(subscriptionMap);\n-                    return BoxedUnit.UNIT;\n-                }\n-            });\n+        FutureUtils.collect(futures).thenAccept((subscriptions) -> {\n+            Map<String, DLSN> subscriptionMap = new HashMap<String, DLSN>();\n+            for (Pair<String, DLSN> pair : subscriptions) {\n+                subscriptionMap.put(pair.getLeft(), pair.getRight());\n+            }\n+            result.complete(subscriptionMap);\n+        });\n     }\n \n     @Override\n-    public Future<BoxedUnit> advanceCommitPosition(String subscriberId, DLSN newPosition) {\n+    public CompletableFuture<Void> advanceCommitPosition(String subscriberId, DLSN newPosition) {\n         return getSubscriber(subscriberId).advanceCommitPosition(newPosition);\n     }\n \n     @Override\n-    public Future<Boolean> deleteSubscriber(String subscriberId) {\n+    public CompletableFuture<Boolean> deleteSubscriber(String subscriberId) {\n         subscribers.remove(subscriberId);\n         String path = getSubscriberZKPath(subscriberId);\n         return Utils.zkDeleteIfNotExist(zkc, path, new ZkVersion(-1));"},{"sha":"b2b430de05faefc145f31b256ce792917a650c3b","filename":"src/main/java/org/apache/distributedlog/io/Abortable.java","status":"removed","additions":0,"deletions":41,"changes":41,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/46e6b70feda2e8ad61ba13928df93b2c94d3dd4e/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fio%2FAbortable.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/46e6b70feda2e8ad61ba13928df93b2c94d3dd4e/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fio%2FAbortable.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fio%2FAbortable.java?ref=46e6b70feda2e8ad61ba13928df93b2c94d3dd4e","patch":"@@ -1,41 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.distributedlog.io;\n-\n-import java.io.IOException;\n-\n-/**\n- * An {@code Abortable} is a source or destination of data that can be aborted.\n- * The abort method is invoked to release resources that the object is holding\n- * (such as open files). The abort happens when the object is in an error state,\n- * which it couldn't be closed gracefully.\n- *\n- * @see java.io.Closeable\n- * @since 0.3.32\n- */\n-public interface Abortable {\n-\n-    /**\n-     * Aborts the object and releases any resources associated with it.\n-     * If the object is already aborted then invoking this method has no\n-     * effect.\n-     *\n-     * @throws IOException if an I/O error occurs.\n-     */\n-    public void abort() throws IOException;\n-}"},{"sha":"a4838b1ff18fc2032c1ac241d6a540eb46c5a5cd","filename":"src/main/java/org/apache/distributedlog/io/Abortables.java","status":"removed","additions":0,"deletions":183,"changes":183,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/46e6b70feda2e8ad61ba13928df93b2c94d3dd4e/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fio%2FAbortables.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/46e6b70feda2e8ad61ba13928df93b2c94d3dd4e/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fio%2FAbortables.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fio%2FAbortables.java?ref=46e6b70feda2e8ad61ba13928df93b2c94d3dd4e","patch":"@@ -1,183 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.distributedlog.io;\n-\n-import com.google.common.collect.Lists;\n-import org.apache.distributedlog.function.VoidFunctions;\n-import org.apache.distributedlog.util.FutureUtils;\n-import com.twitter.util.Future;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import javax.annotation.Nullable;\n-import java.io.IOException;\n-import java.util.List;\n-import java.util.concurrent.ExecutorService;\n-\n-/**\n- * Utility methods for working with {@link Abortable} objects.\n- *\n- * @since 0.3.32\n- */\n-public final class Abortables {\n-\n-    static final Logger logger = LoggerFactory.getLogger(Abortables.class);\n-\n-    private Abortables() {}\n-\n-    public static Future<Void> asyncAbort(@Nullable AsyncAbortable abortable,\n-                                          boolean swallowIOException) {\n-        if (null == abortable) {\n-            return Future.Void();\n-        } else if (swallowIOException) {\n-            return FutureUtils.ignore(abortable.asyncAbort());\n-        } else {\n-            return abortable.asyncAbort();\n-        }\n-    }\n-\n-    /**\n-     * Aborts a {@link Abortable}, with control over whether an {@link IOException} may be thrown.\n-     * This is primarily useful in a finally block, where a thrown exception needs to be logged but\n-     * not propagated (otherwise the original exception will be lost).\n-     *\n-     * <p>If {@code swallowIOException} is true then we never throw {@code IOException} but merely log it.\n-     *\n-     * <p>Example: <pre>   {@code\n-     *\n-     *   public void abortStreamNicely() throws IOException {\n-     *      SomeStream stream = new SomeStream(\"foo\");\n-     *      try {\n-     *          // ... code which does something with the stream ...\n-     *      } catch (IOException ioe) {\n-     *          // If an exception occurs, we might abort the stream.\n-     *          Abortables.abort(stream, true);\n-     *      }\n-     *   }}</pre>\n-     *\n-     * @param abortable the {@code Abortable} object to be aborted, or null, in which case this method\n-     *                  does nothing.\n-     * @param swallowIOException if true, don't propagate IO exceptions thrown by the {@code abort} methods\n-     * @throws IOException if {@code swallowIOException} is false and {@code abort} throws an {@code IOException}\n-     */\n-    public static void abort(@Nullable Abortable abortable,\n-                             boolean swallowIOException)\n-        throws IOException {\n-        if (null == abortable) {\n-            return;\n-        }\n-        try {\n-            abortable.abort();\n-        } catch (IOException ioe) {\n-            if (swallowIOException) {\n-                logger.warn(\"IOException thrown while aborting Abortable {} : \", abortable, ioe);\n-            } else {\n-                throw ioe;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Abort async <i>abortable</i>\n-     *\n-     * @param abortable the {@code AsyncAbortable} object to be aborted, or null, in which case this method\n-     *                  does nothing.\n-     * @param swallowIOException if true, don't propagate IO exceptions thrown by the {@code abort} methods\n-     * @throws IOException if {@code swallowIOException} is false and {@code abort} throws an {@code IOException}\n-     * @see #abort(Abortable, boolean)\n-     */\n-    public static void abort(@Nullable AsyncAbortable abortable,\n-                             boolean swallowIOException)\n-            throws IOException {\n-        if (null == abortable) {\n-            return;\n-        }\n-        try {\n-            FutureUtils.result(abortable.asyncAbort());\n-        } catch (IOException ioe) {\n-            if (swallowIOException) {\n-                logger.warn(\"IOException thrown while aborting Abortable {} : \", abortable, ioe);\n-            } else {\n-                throw ioe;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Aborts the given {@code abortable}, logging any {@code IOException} that's thrown rather than\n-     * propagating it.\n-     *\n-     * While it's not safe in the general case to ignore exceptions that are thrown when aborting an\n-     * I/O resource, it should generally be safe in the case of a resource that's being used only for\n-     * reading.\n-     *\n-     * @param abortable the {@code Abortable} to be closed, or {@code null} in which case this method\n-     *                  does nothing.\n-     */\n-    public static void abortQuietly(@Nullable Abortable abortable) {\n-        try {\n-            abort(abortable, true);\n-        } catch (IOException e) {\n-            logger.error(\"Unexpected IOException thrown while aborting Abortable {} quietly : \", abortable, e);\n-        }\n-    }\n-\n-    /**\n-     * Aborts the given {@code abortable}, logging any {@code IOException} that's thrown rather than\n-     * propagating it.\n-     *\n-     * While it's not safe in the general case to ignore exceptions that are thrown when aborting an\n-     * I/O resource, it should generally be safe in the case of a resource that's being used only for\n-     * reading.\n-     *\n-     * @param abortable the {@code AsyncAbortable} to be closed, or {@code null} in which case this method\n-     *                  does nothing.\n-     */\n-    public static void abortQuietly(@Nullable AsyncAbortable abortable) {\n-        try {\n-            abort(abortable, true);\n-        } catch (IOException e) {\n-            logger.error(\"Unexpected IOException thrown while aborting Abortable {} quietly : \", abortable, e);\n-        }\n-    }\n-\n-    /**\n-     * Abort the abortables in sequence.\n-     *\n-     * @param executorService\n-     *          executor service to execute\n-     * @param abortables\n-     *          abortables to abort\n-     * @return future represents the abort future\n-     */\n-    public static Future<Void> abortSequence(ExecutorService executorService,\n-                                             AsyncAbortable... abortables) {\n-        List<AsyncAbortable> abortableList = Lists.newArrayListWithExpectedSize(abortables.length);\n-        for (AsyncAbortable abortable : abortables) {\n-            if (null == abortable) {\n-                abortableList.add(AsyncAbortable.NULL);\n-            } else {\n-                abortableList.add(abortable);\n-            }\n-        }\n-        return FutureUtils.processList(\n-                abortableList,\n-                AsyncAbortable.ABORT_FUNC,\n-                executorService).map(VoidFunctions.LIST_TO_VOID_FUNC);\n-    }\n-}"},{"sha":"7ec26a1d93749617b2a55d70c4e4f194874d86ba","filename":"src/main/java/org/apache/distributedlog/io/AsyncAbortable.java","status":"removed","additions":0,"deletions":57,"changes":57,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/46e6b70feda2e8ad61ba13928df93b2c94d3dd4e/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fio%2FAsyncAbortable.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/46e6b70feda2e8ad61ba13928df93b2c94d3dd4e/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fio%2FAsyncAbortable.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fio%2FAsyncAbortable.java?ref=46e6b70feda2e8ad61ba13928df93b2c94d3dd4e","patch":"@@ -1,57 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.distributedlog.io;\n-\n-import com.twitter.util.Function;\n-import com.twitter.util.Future;\n-\n-/**\n- * An {@code Abortable} is a source or destination of data that can be aborted.\n- * The abort method is invoked to release resources that the object is holding\n- * (such as open files). The abort happens when the object is in an error state,\n- * which it couldn't be closed gracefully.\n- *\n- * @see AsyncCloseable\n- * @see Abortable\n- * @since 0.3.43\n- */\n-public interface AsyncAbortable {\n-\n-    Function<AsyncAbortable, Future<Void>> ABORT_FUNC = new Function<AsyncAbortable, Future<Void>>() {\n-        @Override\n-        public Future<Void> apply(AsyncAbortable abortable) {\n-            return abortable.asyncAbort();\n-        }\n-    };\n-\n-    AsyncAbortable NULL = new AsyncAbortable() {\n-        @Override\n-        public Future<Void> asyncAbort() {\n-            return Future.Void();\n-        }\n-    };\n-\n-    /**\n-     * Aborts the object and releases any resources associated with it.\n-     * If the object is already aborted then invoking this method has no\n-     * effect.\n-     *\n-     * @return future represents the abort result\n-     */\n-    Future<Void> asyncAbort();\n-}"},{"sha":"2bf01196c124e014f6c4fb7d1c33946bd7f94688","filename":"src/main/java/org/apache/distributedlog/io/AsyncCloseable.java","status":"removed","additions":0,"deletions":60,"changes":60,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/46e6b70feda2e8ad61ba13928df93b2c94d3dd4e/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fio%2FAsyncCloseable.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/46e6b70feda2e8ad61ba13928df93b2c94d3dd4e/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fio%2FAsyncCloseable.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fio%2FAsyncCloseable.java?ref=46e6b70feda2e8ad61ba13928df93b2c94d3dd4e","patch":"@@ -1,60 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.distributedlog.io;\n-\n-import org.apache.distributedlog.util.FutureUtils;\n-import com.twitter.util.Function;\n-import com.twitter.util.Future;\n-\n-/**\n- * A {@code AsyncCloseable} is a source or destination of data that can be closed asynchronously.\n- * The close method is invoked to release resources that the object is\n- * holding (such as open files).\n- */\n-public interface AsyncCloseable {\n-\n-    Function<AsyncCloseable, Future<Void>> CLOSE_FUNC = new Function<AsyncCloseable, Future<Void>>() {\n-        @Override\n-        public Future<Void> apply(AsyncCloseable closeable) {\n-            return closeable.asyncClose();\n-        }\n-    };\n-\n-    Function<AsyncCloseable, Future<Void>> CLOSE_FUNC_IGNORE_ERRORS = new Function<AsyncCloseable, Future<Void>>() {\n-        @Override\n-        public Future<Void> apply(AsyncCloseable closeable) {\n-            return FutureUtils.ignore(closeable.asyncClose());\n-        }\n-    };\n-\n-    AsyncCloseable NULL = new AsyncCloseable() {\n-        @Override\n-        public Future<Void> asyncClose() {\n-            return Future.Void();\n-        }\n-    };\n-\n-    /**\n-     * Closes this source and releases any system resources associated\n-     * with it. If the source is already closed then invoking this\n-     * method has no effect.\n-     *\n-     * @return future representing the close result.\n-     */\n-    Future<Void> asyncClose();\n-}"},{"sha":"046c731243fa4f2c5c11fdf0a02242b775900bcd","filename":"src/main/java/org/apache/distributedlog/io/AsyncDeleteable.java","status":"removed","additions":0,"deletions":34,"changes":34,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/46e6b70feda2e8ad61ba13928df93b2c94d3dd4e/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fio%2FAsyncDeleteable.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/46e6b70feda2e8ad61ba13928df93b2c94d3dd4e/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fio%2FAsyncDeleteable.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fio%2FAsyncDeleteable.java?ref=46e6b70feda2e8ad61ba13928df93b2c94d3dd4e","patch":"@@ -1,34 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.distributedlog.io;\n-\n-import com.twitter.util.Future;\n-\n-/**\n- * A {@code AsyncDeleteable} is a source or destination of data that can be deleted asynchronously.\n- * This delete method is invoked to delete the source.\n- */\n-public interface AsyncDeleteable {\n-    /**\n-     * Releases any system resources associated with this and delete the source. If the source is\n-     * already deleted then invoking this method has no effect.\n-     *\n-     * @return future representing the deletion result.\n-     */\n-    Future<Void> delete();\n-}"},{"sha":"ae01bf7481e1a803eeb718aec0c08a838e14dbfc","filename":"src/main/java/org/apache/distributedlog/limiter/ComposableRequestLimiter.java","status":"modified","additions":1,"deletions":7,"changes":8,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Flimiter%2FComposableRequestLimiter.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Flimiter%2FComposableRequestLimiter.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Flimiter%2FComposableRequestLimiter.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -17,16 +17,10 @@\n  */\n package org.apache.distributedlog.limiter;\n \n-import com.google.common.annotations.VisibleForTesting;\n import com.google.common.base.Preconditions;\n-\n-import org.apache.distributedlog.exceptions.OverCapacityException;\n-import org.apache.distributedlog.limiter.GuavaRateLimiter;\n-import org.apache.distributedlog.limiter.RateLimiter;\n-\n import org.apache.bookkeeper.stats.Counter;\n import org.apache.bookkeeper.stats.StatsLogger;\n-\n+import org.apache.distributedlog.exceptions.OverCapacityException;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n "},{"sha":"156d6dd5f4d9bf594805474ec16ea705832c6011","filename":"src/main/java/org/apache/distributedlog/lock/DistributedLock.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Flock%2FDistributedLock.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Flock%2FDistributedLock.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Flock%2FDistributedLock.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -17,9 +17,9 @@\n  */\n package org.apache.distributedlog.lock;\n \n+import java.util.concurrent.CompletableFuture;\n import org.apache.distributedlog.exceptions.LockingException;\n import org.apache.distributedlog.io.AsyncCloseable;\n-import com.twitter.util.Future;\n \n /**\n  * Interface for distributed locking\n@@ -31,7 +31,7 @@ public interface DistributedLock extends AsyncCloseable {\n      *\n      * @return future represents the acquire result.\n      */\n-    Future<? extends DistributedLock> asyncAcquire();\n+    CompletableFuture<? extends DistributedLock> asyncAcquire();\n \n     /**\n      * Check if hold lock. If it doesn't, then re-acquire the lock."},{"sha":"1cb336450369c4df8e535b1eef021908113ab190","filename":"src/main/java/org/apache/distributedlog/lock/LockWaiter.java","status":"modified","additions":15,"deletions":11,"changes":26,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Flock%2FLockWaiter.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Flock%2FLockWaiter.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Flock%2FLockWaiter.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -17,10 +17,13 @@\n  */\n package org.apache.distributedlog.lock;\n \n-import com.twitter.util.Await;\n-import com.twitter.util.Duration;\n-import com.twitter.util.Future;\n-import com.twitter.util.Timer;\n+import java.io.IOException;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.distributedlog.exceptions.DLInterruptedException;\n+import org.apache.distributedlog.common.concurrent.FutureUtils;\n+import org.apache.distributedlog.util.OrderedScheduler;\n+import org.apache.distributedlog.util.Utils;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -33,11 +36,11 @@ public class LockWaiter {\n \n     private final String lockId;\n     private final String currentOwner;\n-    private final Future<Boolean> acquireFuture;\n+    private final CompletableFuture<Boolean> acquireFuture;\n \n     public LockWaiter(String lockId,\n                       String currentOwner,\n-                      Future<Boolean> acquireFuture) {\n+                      CompletableFuture<Boolean> acquireFuture) {\n         this.lockId = lockId;\n         this.currentOwner = currentOwner;\n         this.acquireFuture = acquireFuture;\n@@ -64,12 +67,13 @@ public String getCurrentOwner() {\n     /**\n      * Return the future representing the waiting result.\n      *\n-     * <p>If the future is interrupted (e.g. {@link Future#within(Duration, Timer)}),\n+     * <p>If the future is interrupted\n+     * (e.g. {@link FutureUtils#within(CompletableFuture, long, TimeUnit, Throwable, OrderedScheduler, Object)}),\n      * the waiter will automatically clean up its waiting state.\n      *\n      * @return the future representing the acquire result.\n      */\n-    public Future<Boolean> getAcquireFuture() {\n+    public CompletableFuture<Boolean> getAcquireFuture() {\n         return acquireFuture;\n     }\n \n@@ -81,12 +85,12 @@ public Future<Boolean> getAcquireFuture() {\n     public boolean waitForAcquireQuietly() {\n         boolean success = false;\n         try {\n-            success = Await.result(acquireFuture);\n-        } catch (InterruptedException ie) {\n+            success = Utils.ioResult(acquireFuture);\n+        } catch (DLInterruptedException ie) {\n             Thread.currentThread().interrupt();\n         } catch (LockTimeoutException lte) {\n             logger.debug(\"Timeout on lock acquiring\", lte);\n-        } catch (Exception e) {\n+        } catch (IOException e) {\n             logger.error(\"Caught exception waiting for lock acquired\", e);\n         }\n         return success;"},{"sha":"7f770ad14ac024397641351fe760f58a1536121b","filename":"src/main/java/org/apache/distributedlog/lock/NopDistributedLock.java","status":"modified","additions":6,"deletions":5,"changes":11,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Flock%2FNopDistributedLock.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Flock%2FNopDistributedLock.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Flock%2FNopDistributedLock.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -17,8 +17,9 @@\n  */\n package org.apache.distributedlog.lock;\n \n+import java.util.concurrent.CompletableFuture;\n import org.apache.distributedlog.exceptions.LockingException;\n-import com.twitter.util.Future;\n+import org.apache.distributedlog.common.concurrent.FutureUtils;\n \n /**\n  * An implementation of {@link DistributedLock} which does nothing.\n@@ -30,8 +31,8 @@ public class NopDistributedLock implements DistributedLock {\n     private NopDistributedLock() {}\n \n     @Override\n-    public Future<? extends DistributedLock> asyncAcquire() {\n-        return Future.value(this);\n+    public CompletableFuture<? extends DistributedLock> asyncAcquire() {\n+        return FutureUtils.value(this);\n     }\n \n     @Override\n@@ -45,7 +46,7 @@ public void checkOwnership() throws LockingException {\n     }\n \n     @Override\n-    public Future<Void> asyncClose() {\n-        return Future.Void();\n+    public CompletableFuture<Void> asyncClose() {\n+        return FutureUtils.Void();\n     }\n }"},{"sha":"3a46a13f564dd9fbc25cde0b072dede79fbcb051","filename":"src/main/java/org/apache/distributedlog/lock/SessionLock.java","status":"modified","additions":5,"deletions":7,"changes":12,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Flock%2FSessionLock.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Flock%2FSessionLock.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Flock%2FSessionLock.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -17,12 +17,10 @@\n  */\n package org.apache.distributedlog.lock;\n \n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n import org.apache.distributedlog.exceptions.LockingException;\n import org.apache.distributedlog.exceptions.OwnershipAcquireFailedException;\n-import com.twitter.util.Future;\n-import scala.runtime.BoxedUnit;\n-\n-import java.util.concurrent.TimeUnit;\n \n /**\n  * One time lock.\n@@ -71,7 +69,7 @@ public interface SessionLock {\n      * <i>tryLock</i> here is effectively the combination of following asynchronous calls.\n      * <pre>\n      *     ZKDistributedLock lock = ...;\n-     *     Future<LockWaiter> attemptFuture = lock.asyncTryLock(...);\n+     *     CompletableFuture<LockWaiter> attemptFuture = lock.asyncTryLock(...);\n      *\n      *     boolean acquired = waiter.waitForAcquireQuietly();\n      *     if (acquired) {\n@@ -106,7 +104,7 @@ void tryLock(long timeout, TimeUnit unit)\n      * @return lock waiter representing this attempt of acquiring lock.\n      * @see #tryLock(long, TimeUnit)\n      */\n-    Future<LockWaiter> asyncTryLock(long timeout, TimeUnit unit);\n+    CompletableFuture<LockWaiter> asyncTryLock(long timeout, TimeUnit unit);\n \n     /**\n      * Release a claimed lock.\n@@ -121,6 +119,6 @@ void tryLock(long timeout, TimeUnit unit)\n      * @return future representing the result of unlock operation.\n      * @see #unlock()\n      */\n-    Future<BoxedUnit> asyncUnlock();\n+    CompletableFuture<Void> asyncUnlock();\n \n }"},{"sha":"9d3159e0d92e662a69a7940964b73c09a192cfe8","filename":"src/main/java/org/apache/distributedlog/lock/SessionLockFactory.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Flock%2FSessionLockFactory.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Flock%2FSessionLockFactory.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Flock%2FSessionLockFactory.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -17,7 +17,7 @@\n  */\n package org.apache.distributedlog.lock;\n \n-import com.twitter.util.Future;\n+import java.util.concurrent.CompletableFuture;\n \n /**\n  * Factory to create {@link SessionLock}\n@@ -33,6 +33,6 @@ public interface SessionLockFactory {\n      *          lock context\n      * @return future represents the creation result.\n      */\n-    Future<SessionLock> createLock(String lockPath, DistributedLockContext context);\n+    CompletableFuture<SessionLock> createLock(String lockPath, DistributedLockContext context);\n \n }"},{"sha":"77151df2ed2a156010261a8f3dcf9491e24c87c9","filename":"src/main/java/org/apache/distributedlog/lock/ZKDistributedLock.java","status":"modified","additions":130,"deletions":146,"changes":276,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Flock%2FZKDistributedLock.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Flock%2FZKDistributedLock.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Flock%2FZKDistributedLock.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -19,28 +19,24 @@\n \n import com.google.common.annotations.VisibleForTesting;\n import com.google.common.base.Stopwatch;\n-import com.twitter.concurrent.AsyncSemaphore;\n+import java.io.IOException;\n+import java.util.Optional;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.apache.bookkeeper.stats.Counter;\n+import org.apache.bookkeeper.stats.OpStatsLogger;\n+import org.apache.bookkeeper.stats.StatsLogger;\n import org.apache.distributedlog.exceptions.LockingException;\n import org.apache.distributedlog.exceptions.OwnershipAcquireFailedException;\n import org.apache.distributedlog.exceptions.UnexpectedException;\n-import org.apache.distributedlog.util.FutureUtils;\n-import org.apache.distributedlog.util.FutureUtils.OrderedFutureEventListener;\n+import org.apache.distributedlog.common.concurrent.AsyncSemaphore;\n+import org.apache.distributedlog.common.concurrent.FutureEventListener;\n+import org.apache.distributedlog.common.concurrent.FutureUtils;\n import org.apache.distributedlog.util.OrderedScheduler;\n-import com.twitter.util.Function;\n-import com.twitter.util.Future;\n-import com.twitter.util.FutureEventListener;\n-import com.twitter.util.Promise;\n-import org.apache.bookkeeper.stats.Counter;\n-import org.apache.bookkeeper.stats.OpStatsLogger;\n-import org.apache.bookkeeper.stats.StatsLogger;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n-import scala.runtime.AbstractFunction0;\n-import scala.runtime.BoxedUnit;\n-\n-import java.io.IOException;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicInteger;\n \n /**\n  * Distributed lock, using ZooKeeper.\n@@ -78,22 +74,22 @@ public class ZKDistributedLock implements LockListener, DistributedLock {\n     private final long lockTimeout;\n     private final DistributedLockContext lockContext = new DistributedLockContext();\n \n-    private final AsyncSemaphore lockSemaphore = new AsyncSemaphore(1);\n+    private final AsyncSemaphore lockSemaphore = new AsyncSemaphore(1, Optional.empty());\n     // We have two lock acquire futures:\n     // 1. lock acquire future: for the initial acquire op\n     // 2. lock reacquire future: for reacquire necessary when session expires, lock is closed\n-    private Future<ZKDistributedLock> lockAcquireFuture = null;\n-    private Future<ZKDistributedLock> lockReacquireFuture = null;\n+    private CompletableFuture<ZKDistributedLock> lockAcquireFuture = null;\n+    private CompletableFuture<ZKDistributedLock> lockReacquireFuture = null;\n     // following variable tracking the status of acquire process\n     //   => create (internalLock) => tryLock (tryLockFuture) => waitForAcquire (lockWaiter)\n     private SessionLock internalLock = null;\n-    private Future<LockWaiter> tryLockFuture = null;\n+    private CompletableFuture<LockWaiter> tryLockFuture = null;\n     private LockWaiter lockWaiter = null;\n     // exception indicating if the reacquire failed\n     private LockingException lockReacquireException = null;\n     // closeFuture\n     private volatile boolean closed = false;\n-    private Future<Void> closeFuture = null;\n+    private CompletableFuture<Void> closeFuture = null;\n \n     // A counter to track how many re-acquires happened during a lock's life cycle.\n     private final AtomicInteger reacquireCount = new AtomicInteger(0);\n@@ -136,25 +132,19 @@ private synchronized void checkLockState() throws LockingException {\n      * Asynchronously acquire the lock. Technically the try phase of this operation--which adds us to the waiter\n      * list--is executed synchronously, but the lock wait itself doesn't block.\n      */\n-    public synchronized Future<ZKDistributedLock> asyncAcquire() {\n+    public synchronized CompletableFuture<ZKDistributedLock> asyncAcquire() {\n         if (null != lockAcquireFuture) {\n-            return Future.exception(new UnexpectedException(\"Someone is already acquiring/acquired lock \" + lockPath));\n+            return FutureUtils.exception(new UnexpectedException(\"Someone is already acquiring/acquired lock \" + lockPath));\n         }\n-        final Promise<ZKDistributedLock> promise =\n-                new Promise<ZKDistributedLock>(new Function<Throwable, BoxedUnit>() {\n-            @Override\n-            public BoxedUnit apply(Throwable cause) {\n-                lockStateExecutor.submit(lockPath, new Runnable() {\n-                    @Override\n-                    public void run() {\n-                        asyncClose();\n-                    }\n-                });\n-                return BoxedUnit.UNIT;\n+        final CompletableFuture<ZKDistributedLock> promise = FutureUtils.createFuture();\n+        promise.whenComplete((zkDistributedLock, throwable) -> {\n+            if (null == throwable || !(throwable instanceof CancellationException)) {\n+                return;\n             }\n+            lockStateExecutor.submit(lockPath, () -> asyncClose());\n         });\n         final Stopwatch stopwatch = Stopwatch.createStarted();\n-        promise.addEventListener(new FutureEventListener<ZKDistributedLock>() {\n+        promise.whenComplete(new FutureEventListener<ZKDistributedLock>() {\n             @Override\n             public void onSuccess(ZKDistributedLock lock) {\n                 acquireStats.registerSuccessfulEvent(stopwatch.stop().elapsed(TimeUnit.MICROSECONDS));\n@@ -176,41 +166,39 @@ public void run() {\n         return promise;\n     }\n \n-    void doAsyncAcquireWithSemaphore(final Promise<ZKDistributedLock> acquirePromise,\n+    void doAsyncAcquireWithSemaphore(final CompletableFuture<ZKDistributedLock> acquirePromise,\n                                      final long lockTimeout) {\n-        lockSemaphore.acquireAndRun(new AbstractFunction0<Future<ZKDistributedLock>>() {\n-            @Override\n-            public Future<ZKDistributedLock> apply() {\n-                doAsyncAcquire(acquirePromise, lockTimeout);\n-                return acquirePromise;\n-            }\n+        lockSemaphore.acquireAndRun(() -> {\n+            doAsyncAcquire(acquirePromise, lockTimeout);\n+            return acquirePromise;\n         });\n     }\n \n-    void doAsyncAcquire(final Promise<ZKDistributedLock> acquirePromise,\n+    void doAsyncAcquire(final CompletableFuture<ZKDistributedLock> acquirePromise,\n                         final long lockTimeout) {\n         LOG.trace(\"Async Lock Acquire {}\", lockPath);\n         try {\n             checkLockState();\n         } catch (IOException ioe) {\n-            FutureUtils.setException(acquirePromise, ioe);\n+            FutureUtils.completeExceptionally(acquirePromise, ioe);\n             return;\n         }\n \n         if (haveLock()) {\n             // it already hold the lock\n-            FutureUtils.setValue(acquirePromise, this);\n+            FutureUtils.complete(acquirePromise, this);\n             return;\n         }\n \n-        lockFactory.createLock(lockPath, lockContext).addEventListener(OrderedFutureEventListener.of(\n-                new FutureEventListener<SessionLock>() {\n+        lockFactory\n+            .createLock(lockPath, lockContext)\n+            .whenCompleteAsync(new FutureEventListener<SessionLock>() {\n             @Override\n             public void onSuccess(SessionLock lock) {\n                 synchronized (ZKDistributedLock.this) {\n                     if (closed) {\n                         LOG.info(\"Skipping tryLocking lock {} since it is already closed\", lockPath);\n-                        FutureUtils.setException(acquirePromise, newLockClosedException());\n+                        FutureUtils.completeExceptionally(acquirePromise, newLockClosedException());\n                         return;\n                     }\n                 }\n@@ -223,62 +211,64 @@ public void onSuccess(SessionLock lock) {\n \n             @Override\n             public void onFailure(Throwable cause) {\n-                FutureUtils.setException(acquirePromise, cause);\n+                FutureUtils.completeExceptionally(acquirePromise, cause);\n             }\n-        }, lockStateExecutor, lockPath));\n+        }, lockStateExecutor.chooseExecutor(lockPath));\n     }\n \n     void asyncTryLock(SessionLock lock,\n-                      final Promise<ZKDistributedLock> acquirePromise,\n+                      final CompletableFuture<ZKDistributedLock> acquirePromise,\n                       final long lockTimeout) {\n         if (null != tryLockFuture) {\n-            tryLockFuture.cancel();\n+            tryLockFuture.cancel(true);\n         }\n         tryLockFuture = lock.asyncTryLock(lockTimeout, TimeUnit.MILLISECONDS);\n-        tryLockFuture.addEventListener(OrderedFutureEventListener.of(\n-                new FutureEventListener<LockWaiter>() {\n-                    @Override\n-                    public void onSuccess(LockWaiter waiter) {\n-                        synchronized (ZKDistributedLock.this) {\n-                            if (closed) {\n-                                LOG.info(\"Skipping acquiring lock {} since it is already closed\", lockPath);\n-                                waiter.getAcquireFuture().raise(new LockingException(lockPath, \"lock is already closed.\"));\n-                                FutureUtils.setException(acquirePromise, newLockClosedException());\n-                                return;\n-                            }\n+        tryLockFuture.whenCompleteAsync(\n+            new FutureEventListener<LockWaiter>() {\n+                @Override\n+                public void onSuccess(LockWaiter waiter) {\n+                    synchronized (ZKDistributedLock.this) {\n+                        if (closed) {\n+                            LOG.info(\"Skipping acquiring lock {} since it is already closed\", lockPath);\n+                            waiter\n+                                .getAcquireFuture()\n+                                .completeExceptionally(new LockingException(lockPath, \"lock is already closed.\"));\n+                            FutureUtils.completeExceptionally(acquirePromise, newLockClosedException());\n+                            return;\n                         }\n-                        tryLockFuture = null;\n-                        lockWaiter = waiter;\n-                        waitForAcquire(waiter, acquirePromise);\n                     }\n+                    tryLockFuture = null;\n+                    lockWaiter = waiter;\n+                    waitForAcquire(waiter, acquirePromise);\n+                }\n \n-                    @Override\n-                    public void onFailure(Throwable cause) {\n-                        FutureUtils.setException(acquirePromise, cause);\n-                    }\n-                }, lockStateExecutor, lockPath));\n+                @Override\n+                public void onFailure(Throwable cause) {\n+                    FutureUtils.completeExceptionally(acquirePromise, cause);\n+                }\n+            }, lockStateExecutor.chooseExecutor(lockPath));\n     }\n \n     void waitForAcquire(final LockWaiter waiter,\n-                        final Promise<ZKDistributedLock> acquirePromise) {\n-        waiter.getAcquireFuture().addEventListener(OrderedFutureEventListener.of(\n-                new FutureEventListener<Boolean>() {\n-                    @Override\n-                    public void onSuccess(Boolean acquired) {\n-                        LOG.info(\"{} acquired lock {}\", waiter, lockPath);\n-                        if (acquired) {\n-                            FutureUtils.setValue(acquirePromise, ZKDistributedLock.this);\n-                        } else {\n-                            FutureUtils.setException(acquirePromise,\n-                                    new OwnershipAcquireFailedException(lockPath, waiter.getCurrentOwner()));\n-                        }\n+                        final CompletableFuture<ZKDistributedLock> acquirePromise) {\n+        waiter.getAcquireFuture().whenCompleteAsync(\n+            new FutureEventListener<Boolean>() {\n+                @Override\n+                public void onSuccess(Boolean acquired) {\n+                    LOG.info(\"{} acquired lock {}\", waiter, lockPath);\n+                    if (acquired) {\n+                        FutureUtils.complete(acquirePromise, ZKDistributedLock.this);\n+                    } else {\n+                        FutureUtils.completeExceptionally(acquirePromise,\n+                                new OwnershipAcquireFailedException(lockPath, waiter.getCurrentOwner()));\n                     }\n+                }\n \n-                    @Override\n-                    public void onFailure(Throwable cause) {\n-                        FutureUtils.setException(acquirePromise, cause);\n-                    }\n-                }, lockStateExecutor, lockPath));\n+                @Override\n+                public void onFailure(Throwable cause) {\n+                    FutureUtils.completeExceptionally(acquirePromise, cause);\n+                }\n+            }, lockStateExecutor.chooseExecutor(lockPath));\n     }\n \n     /**\n@@ -300,7 +290,7 @@ public void onExpired() {\n      * @throws LockingException     if the lock attempt fails\n      */\n     public synchronized void checkOwnershipAndReacquire() throws LockingException {\n-        if (null == lockAcquireFuture || !lockAcquireFuture.isDefined()) {\n+        if (null == lockAcquireFuture || !lockAcquireFuture.isDone()) {\n             throw new LockingException(lockPath, \"check ownership before acquiring\");\n         }\n \n@@ -322,7 +312,7 @@ public synchronized void checkOwnershipAndReacquire() throws LockingException {\n      * @throws LockingException     if the lock attempt fails\n      */\n     public synchronized void checkOwnership() throws LockingException {\n-        if (null == lockAcquireFuture || !lockAcquireFuture.isDefined()) {\n+        if (null == lockAcquireFuture || !lockAcquireFuture.isDone()) {\n             throw new LockingException(lockPath, \"check ownership before acquiring\");\n         }\n         if (!haveLock()) {\n@@ -336,12 +326,12 @@ int getReacquireCount() {\n     }\n \n     @VisibleForTesting\n-    synchronized Future<ZKDistributedLock> getLockReacquireFuture() {\n+    synchronized CompletableFuture<ZKDistributedLock> getLockReacquireFuture() {\n         return lockReacquireFuture;\n     }\n \n     @VisibleForTesting\n-    synchronized Future<ZKDistributedLock> getLockAcquireFuture() {\n+    synchronized CompletableFuture<ZKDistributedLock> getLockAcquireFuture() {\n         return lockAcquireFuture;\n     }\n \n@@ -360,71 +350,65 @@ synchronized boolean haveLock() {\n     }\n \n     void closeWaiter(final LockWaiter waiter,\n-                     final Promise<Void> closePromise) {\n+                     final CompletableFuture<Void> closePromise) {\n         if (null == waiter) {\n             interruptTryLock(tryLockFuture, closePromise);\n         } else {\n-            waiter.getAcquireFuture().addEventListener(OrderedFutureEventListener.of(\n-                    new FutureEventListener<Boolean>() {\n-                        @Override\n-                        public void onSuccess(Boolean value) {\n-                            unlockInternalLock(closePromise);\n-                        }\n-                        @Override\n-                        public void onFailure(Throwable cause) {\n-                            unlockInternalLock(closePromise);\n-                        }\n-                    }, lockStateExecutor, lockPath));\n-            FutureUtils.cancel(waiter.getAcquireFuture());\n+            waiter.getAcquireFuture().whenCompleteAsync(\n+                new FutureEventListener<Boolean>() {\n+                    @Override\n+                    public void onSuccess(Boolean value) {\n+                        unlockInternalLock(closePromise);\n+                    }\n+                    @Override\n+                    public void onFailure(Throwable cause) {\n+                        unlockInternalLock(closePromise);\n+                    }\n+                }, lockStateExecutor.chooseExecutor(lockPath));\n+            waiter.getAcquireFuture().cancel(true);\n         }\n     }\n \n-    void interruptTryLock(final Future<LockWaiter> tryLockFuture,\n-                          final Promise<Void> closePromise) {\n+    void interruptTryLock(final CompletableFuture<LockWaiter> tryLockFuture,\n+                          final CompletableFuture<Void> closePromise) {\n         if (null == tryLockFuture) {\n             unlockInternalLock(closePromise);\n         } else {\n-            tryLockFuture.addEventListener(OrderedFutureEventListener.of(\n-                    new FutureEventListener<LockWaiter>() {\n-                        @Override\n-                        public void onSuccess(LockWaiter waiter) {\n-                            closeWaiter(waiter, closePromise);\n-                        }\n-                        @Override\n-                        public void onFailure(Throwable cause) {\n-                            unlockInternalLock(closePromise);\n-                        }\n-                    }, lockStateExecutor, lockPath));\n-            FutureUtils.cancel(tryLockFuture);\n+            tryLockFuture.whenCompleteAsync(\n+                new FutureEventListener<LockWaiter>() {\n+                    @Override\n+                    public void onSuccess(LockWaiter waiter) {\n+                        closeWaiter(waiter, closePromise);\n+                    }\n+                    @Override\n+                    public void onFailure(Throwable cause) {\n+                        unlockInternalLock(closePromise);\n+                    }\n+                }, lockStateExecutor.chooseExecutor(lockPath));\n+            tryLockFuture.cancel(true);\n         }\n     }\n \n-    synchronized void unlockInternalLock(final Promise<Void> closePromise) {\n+    synchronized void unlockInternalLock(final CompletableFuture<Void> closePromise) {\n         if (internalLock == null) {\n-            FutureUtils.setValue(closePromise, null);\n+            FutureUtils.complete(closePromise, null);\n         } else {\n-            internalLock.asyncUnlock().ensure(new AbstractFunction0<BoxedUnit>() {\n-                @Override\n-                public BoxedUnit apply() {\n-                    FutureUtils.setValue(closePromise, null);\n-                    return BoxedUnit.UNIT;\n-                }\n-            });\n+            internalLock.asyncUnlock().whenComplete((value, cause) -> closePromise.complete(null));\n         }\n     }\n \n     @Override\n-    public Future<Void> asyncClose() {\n-        final Promise<Void> closePromise;\n+    public CompletableFuture<Void> asyncClose() {\n+        final CompletableFuture<Void> closePromise;\n         synchronized (this) {\n             if (closed) {\n                 return closeFuture;\n             }\n             closed = true;\n-            closeFuture = closePromise = new Promise<Void>();\n+            closeFuture = closePromise = new CompletableFuture<Void>();\n         }\n-        final Promise<Void> closeWaiterFuture = new Promise<Void>();\n-        closeWaiterFuture.addEventListener(OrderedFutureEventListener.of(new FutureEventListener<Void>() {\n+        final CompletableFuture<Void> closeWaiterFuture = new CompletableFuture<Void>();\n+        closeWaiterFuture.whenCompleteAsync(new FutureEventListener<Void>() {\n             @Override\n             public void onSuccess(Void value) {\n                 complete();\n@@ -435,9 +419,9 @@ public void onFailure(Throwable cause) {\n             }\n \n             private void complete() {\n-                FutureUtils.setValue(closePromise, null);\n+                FutureUtils.complete(closePromise, null);\n             }\n-        }, lockStateExecutor, lockPath));\n+        }, lockStateExecutor.chooseExecutor(lockPath));\n         lockStateExecutor.submit(lockPath, new Runnable() {\n             @Override\n             public void run() {\n@@ -449,7 +433,7 @@ public void run() {\n \n     void internalReacquireLock(final AtomicInteger numRetries,\n                                final long lockTimeout,\n-                               final Promise<ZKDistributedLock> reacquirePromise) {\n+                               final CompletableFuture<ZKDistributedLock> reacquirePromise) {\n         lockStateExecutor.submit(lockPath, new Runnable() {\n             @Override\n             public void run() {\n@@ -460,35 +444,35 @@ public void run() {\n \n     void doInternalReacquireLock(final AtomicInteger numRetries,\n                                  final long lockTimeout,\n-                                 final Promise<ZKDistributedLock> reacquirePromise) {\n+                                 final CompletableFuture<ZKDistributedLock> reacquirePromise) {\n         internalTryRetries.inc();\n-        Promise<ZKDistributedLock> tryPromise = new Promise<ZKDistributedLock>();\n-        tryPromise.addEventListener(new FutureEventListener<ZKDistributedLock>() {\n+        CompletableFuture<ZKDistributedLock> tryPromise = new CompletableFuture<ZKDistributedLock>();\n+        tryPromise.whenComplete(new FutureEventListener<ZKDistributedLock>() {\n             @Override\n             public void onSuccess(ZKDistributedLock lock) {\n-                FutureUtils.setValue(reacquirePromise, lock);\n+                FutureUtils.complete(reacquirePromise, lock);\n             }\n \n             @Override\n             public void onFailure(Throwable cause) {\n                 if (cause instanceof OwnershipAcquireFailedException) {\n                     // the lock has been acquired by others\n-                    FutureUtils.setException(reacquirePromise, cause);\n+                    FutureUtils.completeExceptionally(reacquirePromise, cause);\n                 } else {\n                     if (numRetries.getAndDecrement() > 0 && !closed) {\n                         internalReacquireLock(numRetries, lockTimeout, reacquirePromise);\n                     } else {\n-                        FutureUtils.setException(reacquirePromise, cause);\n+                        FutureUtils.completeExceptionally(reacquirePromise, cause);\n                     }\n                 }\n             }\n         });\n         doAsyncAcquireWithSemaphore(tryPromise, 0);\n     }\n \n-    private Future<ZKDistributedLock> reacquireLock(boolean throwLockAcquireException) throws LockingException {\n+    private CompletableFuture<ZKDistributedLock> reacquireLock(boolean throwLockAcquireException) throws LockingException {\n         final Stopwatch stopwatch = Stopwatch.createStarted();\n-        Promise<ZKDistributedLock> lockPromise;\n+        CompletableFuture<ZKDistributedLock> lockPromise;\n         synchronized (this) {\n             if (closed) {\n                 throw newLockClosedException();\n@@ -504,8 +488,8 @@ private Future<ZKDistributedLock> reacquireLock(boolean throwLockAcquireExceptio\n                 return lockReacquireFuture;\n             }\n             LOG.info(\"reacquiring lock at {}\", lockPath);\n-            lockReacquireFuture = lockPromise = new Promise<ZKDistributedLock>();\n-            lockReacquireFuture.addEventListener(new FutureEventListener<ZKDistributedLock>() {\n+            lockReacquireFuture = lockPromise = new CompletableFuture<ZKDistributedLock>();\n+            lockReacquireFuture.whenComplete(new FutureEventListener<ZKDistributedLock>() {\n                 @Override\n                 public void onSuccess(ZKDistributedLock lock) {\n                     // if re-acquire successfully, clear the state."},{"sha":"9fdcbf1214ab5745f5ddf397f5aad06ca5cd48ea","filename":"src/main/java/org/apache/distributedlog/lock/ZKSessionLock.java","status":"modified","additions":111,"deletions":137,"changes":248,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Flock%2FZKSessionLock.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Flock%2FZKSessionLock.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Flock%2FZKSessionLock.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -17,8 +17,22 @@\n  */\n package org.apache.distributedlog.lock;\n \n+import static com.google.common.base.Charsets.UTF_8;\n+\n import com.google.common.annotations.VisibleForTesting;\n import com.google.common.base.Stopwatch;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLDecoder;\n+import java.net.URLEncoder;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n import org.apache.distributedlog.DistributedLogConstants;\n import org.apache.distributedlog.util.FailpointUtils;\n import org.apache.distributedlog.exceptions.LockingException;\n@@ -27,18 +41,10 @@\n import org.apache.distributedlog.exceptions.OwnershipAcquireFailedException;\n import org.apache.distributedlog.exceptions.UnexpectedException;\n import org.apache.distributedlog.exceptions.ZKException;\n-import org.apache.distributedlog.stats.OpStatsListener;\n-import org.apache.distributedlog.util.FutureUtils;\n+import org.apache.distributedlog.common.stats.OpStatsListener;\n+import org.apache.distributedlog.common.concurrent.FutureEventListener;\n+import org.apache.distributedlog.common.concurrent.FutureUtils;\n import org.apache.distributedlog.util.OrderedScheduler;\n-import com.twitter.util.Await;\n-import com.twitter.util.Duration;\n-import com.twitter.util.Function0;\n-import com.twitter.util.Future;\n-import com.twitter.util.FutureEventListener;\n-import com.twitter.util.Promise;\n-import com.twitter.util.Return;\n-import com.twitter.util.Throw;\n-import com.twitter.util.TimeoutException;\n import org.apache.bookkeeper.stats.Counter;\n import org.apache.bookkeeper.stats.NullStatsLogger;\n import org.apache.bookkeeper.stats.OpStatsLogger;\n@@ -54,20 +60,6 @@\n import org.apache.zookeeper.data.Stat;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n-import scala.runtime.AbstractFunction1;\n-import scala.runtime.BoxedUnit;\n-\n-import java.io.IOException;\n-import java.io.UnsupportedEncodingException;\n-import java.net.URLDecoder;\n-import java.net.URLEncoder;\n-import java.util.Collections;\n-import java.util.Comparator;\n-import java.util.List;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicInteger;\n-\n-import static com.google.common.base.Charsets.UTF_8;\n \n /**\n  * A lock under a given zookeeper session. This is a one-time lock.\n@@ -276,7 +268,7 @@ private Exception getStack() {\n     private StateManagement lockState;\n     private final DistributedLockContext lockContext;\n \n-    private final Promise<Boolean> acquireFuture;\n+    private final CompletableFuture<Boolean> acquireFuture;\n     private String currentId;\n     private String currentNode;\n     private String watchedNode;\n@@ -342,15 +334,14 @@ public ZKSessionLock(ZooKeeperClient zkClient,\n         this.unlockStats = statsLogger.getOpStatsLogger(\"unlock\");\n \n         // Attach interrupt handler to acquire future so clients can abort the future.\n-        this.acquireFuture = new Promise<Boolean>(new com.twitter.util.Function<Throwable, BoxedUnit>() {\n-            @Override\n-            public BoxedUnit apply(Throwable t) {\n+        this.acquireFuture = FutureUtils.createFuture();\n+        this.acquireFuture.whenComplete((value, cause) -> {\n+            if (null != cause) {\n                 // This will set the lock state to closed, and begin to cleanup the zk lock node.\n                 // We have to be careful not to block here since doing so blocks the ordered lock\n                 // state executor which can cause deadlocks depending on how futures are chained.\n-                ZKSessionLock.this.asyncUnlock(t);\n+                ZKSessionLock.this.asyncUnlock(cause);\n                 // Note re. logging and exceptions: errors are already logged by unlockAsync.\n-                return BoxedUnit.UNIT;\n             }\n         });\n     }\n@@ -433,7 +424,7 @@ public void safeRun() {\n      * @param promise\n      *          promise\n      */\n-    protected <T> void executeLockAction(final int lockEpoch, final LockAction func, final Promise<T> promise) {\n+    protected <T> void executeLockAction(final int lockEpoch, final LockAction func, final CompletableFuture<T> promise) {\n         lockStateExecutor.submit(lockPath, new SafeRunnable() {\n             @Override\n             public void safeRun() {\n@@ -453,7 +444,7 @@ public void safeRun() {\n                         LOG.trace(\"{} skipped executing lock action '{}' for lock {}, since epoch is changed from {} to {}.\",\n                                 new Object[]{lockId, func.getActionName(), lockPath, lockEpoch, currentEpoch});\n                     }\n-                    promise.setException(new EpochChangedException(lockPath, lockEpoch, currentEpoch));\n+                    promise.completeExceptionally(new EpochChangedException(lockPath, lockEpoch, currentEpoch));\n                 }\n             }\n         });\n@@ -516,36 +507,36 @@ static boolean areLockWaitersInSameSession(String node1, String node2) {\n      *          node name\n      * @return client id and its ephemeral owner.\n      */\n-    static Future<Pair<String, Long>> asyncParseClientID(ZooKeeper zkClient, String lockPath, String nodeName) {\n+    static CompletableFuture<Pair<String, Long>> asyncParseClientID(ZooKeeper zkClient, String lockPath, String nodeName) {\n         String[] parts = nodeName.split(\"_\");\n         // member_<clientid>_s<owner_session>_\n         if (4 == parts.length && parts[2].startsWith(\"s\")) {\n             long sessionOwner = Long.parseLong(parts[2].substring(1));\n             String clientId;\n             try {\n                 clientId = URLDecoder.decode(parts[1], UTF_8.name());\n-                return Future.value(Pair.of(clientId, sessionOwner));\n+                return FutureUtils.value(Pair.of(clientId, sessionOwner));\n             } catch (UnsupportedEncodingException e) {\n                 // if failed to parse client id, we have to get client id by zookeeper#getData.\n             }\n         }\n-        final Promise<Pair<String, Long>> promise = new Promise<Pair<String, Long>>();\n+        final CompletableFuture<Pair<String, Long>> promise = new CompletableFuture<Pair<String, Long>>();\n         zkClient.getData(lockPath + \"/\" + nodeName, false, new AsyncCallback.DataCallback() {\n             @Override\n             public void processResult(int rc, String path, Object ctx, byte[] data, Stat stat) {\n                 if (KeeperException.Code.OK.intValue() != rc) {\n-                    promise.setException(KeeperException.create(KeeperException.Code.get(rc)));\n+                    promise.completeExceptionally(KeeperException.create(KeeperException.Code.get(rc)));\n                 } else {\n-                    promise.setValue(Pair.of(deserializeClientId(data), stat.getEphemeralOwner()));\n+                    promise.complete(Pair.of(deserializeClientId(data), stat.getEphemeralOwner()));\n                 }\n             }\n         }, null);\n         return promise;\n     }\n \n     @Override\n-    public Future<LockWaiter> asyncTryLock(final long timeout, final TimeUnit unit) {\n-        final Promise<String> result = new Promise<String>();\n+    public CompletableFuture<LockWaiter> asyncTryLock(final long timeout, final TimeUnit unit) {\n+        final CompletableFuture<String> result = new CompletableFuture<String>();\n         final boolean wait = DistributedLogConstants.LOCK_IMMEDIATE != timeout;\n         if (wait) {\n             asyncTryLock(wait, result);\n@@ -559,37 +550,32 @@ public void processResult(final int rc, String path, Object ctx,\n                         @Override\n                         public void safeRun() {\n                             if (!lockState.inState(State.INIT)) {\n-                                result.setException(new LockStateChangedException(lockPath, lockId, State.INIT, lockState.getState()));\n+                                result.completeExceptionally(new LockStateChangedException(lockPath, lockId, State.INIT, lockState.getState()));\n                                 return;\n                             }\n                             if (KeeperException.Code.OK.intValue() != rc) {\n-                                result.setException(KeeperException.create(KeeperException.Code.get(rc)));\n+                                result.completeExceptionally(KeeperException.create(KeeperException.Code.get(rc)));\n                                 return;\n                             }\n \n                             FailpointUtils.checkFailPointNoThrow(FailpointUtils.FailPointName.FP_LockTryAcquire);\n \n                             Collections.sort(children, MEMBER_COMPARATOR);\n                             if (children.size() > 0) {\n-                                asyncParseClientID(zk, lockPath, children.get(0)).addEventListener(\n+                                asyncParseClientID(zk, lockPath, children.get(0)).whenCompleteAsync(\n                                         new FutureEventListener<Pair<String, Long>>() {\n                                             @Override\n                                             public void onSuccess(Pair<String, Long> owner) {\n                                                 if (!checkOrClaimLockOwner(owner, result)) {\n-                                                    acquireFuture.updateIfEmpty(new Return<Boolean>(false));\n+                                                    acquireFuture.complete(false);\n                                                 }\n                                             }\n \n                                             @Override\n                                             public void onFailure(final Throwable cause) {\n-                                                lockStateExecutor.submit(lockPath, new SafeRunnable() {\n-                                                    @Override\n-                                                    public void safeRun() {\n-                                                        result.setException(cause);\n-                                                    }\n-                                                });\n+                                                result.completeExceptionally(cause);\n                                             }\n-                                        });\n+                                        }, lockStateExecutor.chooseExecutor(lockPath));\n                             } else {\n                                 asyncTryLock(wait, result);\n                             }\n@@ -599,14 +585,9 @@ public void safeRun() {\n             }, null);\n         }\n \n-        final Promise<Boolean> waiterAcquireFuture = new Promise<Boolean>(new com.twitter.util.Function<Throwable, BoxedUnit>() {\n-            @Override\n-            public BoxedUnit apply(Throwable t) {\n-                acquireFuture.raise(t);\n-                return BoxedUnit.UNIT;\n-            }\n-        });\n-        return result.map(new AbstractFunction1<String, LockWaiter>() {\n+        final CompletableFuture<Boolean> waiterAcquireFuture = FutureUtils.createFuture();\n+        waiterAcquireFuture.whenComplete((value, cause) -> acquireFuture.completeExceptionally(cause));\n+        return result.thenApply(new Function<String, LockWaiter>() {\n             @Override\n             public LockWaiter apply(final String currentOwner) {\n                 final Exception acquireException = new OwnershipAcquireFailedException(lockPath, currentOwner);\n@@ -617,7 +598,7 @@ public LockWaiter apply(final String currentOwner) {\n                         acquireException,\n                         lockStateExecutor,\n                         lockPath\n-                ).addEventListener(new FutureEventListener<Boolean>() {\n+                ).whenComplete(new FutureEventListener<Boolean>() {\n \n                     @Override\n                     public void onSuccess(Boolean acquired) {\n@@ -631,17 +612,17 @@ public void onFailure(final Throwable acquireCause) {\n \n                     private void completeOrFail(final Throwable acquireCause) {\n                         if (isLockHeld()) {\n-                            waiterAcquireFuture.setValue(true);\n+                            waiterAcquireFuture.complete(true);\n                         } else {\n-                            asyncUnlock().addEventListener(new FutureEventListener<BoxedUnit>() {\n+                            asyncUnlock().whenComplete(new FutureEventListener<Void>() {\n                                 @Override\n-                                public void onSuccess(BoxedUnit value) {\n-                                    waiterAcquireFuture.setException(acquireCause);\n+                                public void onSuccess(Void value) {\n+                                    waiterAcquireFuture.completeExceptionally(acquireCause);\n                                 }\n \n                                 @Override\n                                 public void onFailure(Throwable cause) {\n-                                    waiterAcquireFuture.setException(acquireCause);\n+                                    waiterAcquireFuture.completeExceptionally(acquireCause);\n                                 }\n                             });\n                         }\n@@ -656,12 +637,12 @@ public void onFailure(Throwable cause) {\n     }\n \n     private boolean checkOrClaimLockOwner(final Pair<String, Long> currentOwner,\n-                                          final Promise<String> result) {\n+                                          final CompletableFuture<String> result) {\n         if (lockId.compareTo(currentOwner) != 0 && !lockContext.hasLockId(currentOwner)) {\n             lockStateExecutor.submit(lockPath, new SafeRunnable() {\n                 @Override\n                 public void safeRun() {\n-                    result.setValue(currentOwner.getLeft());\n+                    result.complete(currentOwner.getLeft());\n                 }\n             });\n             return false;\n@@ -672,7 +653,7 @@ public void safeRun() {\n             @Override\n             public void execute() {\n                 if (!lockState.inState(State.INIT)) {\n-                    result.setException(new LockStateChangedException(lockPath, lockId, State.INIT, lockState.getState()));\n+                    result.completeExceptionally(new LockStateChangedException(lockPath, lockId, State.INIT, lockState.getState()));\n                     return;\n                 }\n                 asyncTryLock(false, result);\n@@ -693,12 +674,12 @@ public String getActionName() {\n      * @param result\n      *          promise to satisfy with current lock owner\n      */\n-    private void asyncTryLock(boolean wait, final Promise<String> result) {\n-        final Promise<String> lockResult = new Promise<String>();\n-        lockResult.addEventListener(new FutureEventListener<String>() {\n+    private void asyncTryLock(boolean wait, final CompletableFuture<String> result) {\n+        final CompletableFuture<String> lockResult = new CompletableFuture<String>();\n+        lockResult.whenComplete(new FutureEventListener<String>() {\n             @Override\n             public void onSuccess(String currentOwner) {\n-                result.setValue(currentOwner);\n+                result.complete(currentOwner);\n             }\n \n             @Override\n@@ -707,7 +688,7 @@ public void onFailure(final Throwable lockCause) {\n                 if (lockCause instanceof LockStateChangedException) {\n                     LOG.info(\"skipping cleanup for {} at {} after encountering lock \" +\n                             \"state change exception : \", new Object[] { lockId, lockPath, lockCause });\n-                    result.setException(lockCause);\n+                    result.completeExceptionally(lockCause);\n                     return;\n                 }\n                 if (LOG.isDebugEnabled()) {\n@@ -716,15 +697,15 @@ public void onFailure(final Throwable lockCause) {\n                 }\n \n                 // If we encountered any exception we should cleanup\n-                Future<BoxedUnit> unlockResult = asyncUnlock();\n-                unlockResult.addEventListener(new FutureEventListener<BoxedUnit>() {\n+                CompletableFuture<Void> unlockResult = asyncUnlock();\n+                unlockResult.whenComplete(new FutureEventListener<Void>() {\n                     @Override\n-                    public void onSuccess(BoxedUnit value) {\n-                        result.setException(lockCause);\n+                    public void onSuccess(Void value) {\n+                        result.completeExceptionally(lockCause);\n                     }\n                     @Override\n                     public void onFailure(Throwable cause) {\n-                        result.setException(lockCause);\n+                        result.completeExceptionally(lockCause);\n                     }\n                 });\n             }\n@@ -734,7 +715,7 @@ public void onFailure(Throwable cause) {\n \n     /**\n      * Try lock. If wait is true, it would wait and watch sibling to acquire lock when\n-     * the sibling is dead. <i>acquireFuture</i> will be notified either it locked successfully\n+     * the sibling is dead. <i>acquireCompletableFuture</i> will be notified either it locked successfully\n      * or the lock failed. The promise will only satisfy with current lock owner.\n      *\n      * NOTE: the <i>promise</i> is only satisfied on <i>lockStateExecutor</i>, so any\n@@ -745,12 +726,12 @@ public void onFailure(Throwable cause) {\n      * @param promise\n      *          promise to satisfy with current lock owner.\n      */\n-    private void asyncTryLockWithoutCleanup(final boolean wait, final Promise<String> promise) {\n+    private void asyncTryLockWithoutCleanup(final boolean wait, final CompletableFuture<String> promise) {\n         executeLockAction(epoch.get(), new LockAction() {\n             @Override\n             public void execute() {\n                 if (!lockState.inState(State.INIT)) {\n-                    promise.setException(new LockStateChangedException(lockPath, lockId, State.INIT, lockState.getState()));\n+                    promise.completeExceptionally(new LockStateChangedException(lockPath, lockId, State.INIT, lockState.getState()));\n                     return;\n                 }\n                 lockState.transition(State.PREPARING);\n@@ -776,7 +757,7 @@ public void processResult(final int rc, String path, Object ctx, final String na\n                                     public void execute() {\n                                         if (KeeperException.Code.OK.intValue() != rc) {\n                                             KeeperException ke = KeeperException.create(KeeperException.Code.get(rc));\n-                                            promise.setException(ke);\n+                                            promise.completeExceptionally(ke);\n                                             return;\n                                         }\n \n@@ -797,14 +778,12 @@ public void execute() {\n                                         if (lockState.isExpiredOrClosing()) {\n                                             // Delete node attempt may have come after PREPARING but before create node, in which case\n                                             // we'd be left with a dangling node unless we clean up.\n-                                            Promise<BoxedUnit> deletePromise = new Promise<BoxedUnit>();\n+                                            CompletableFuture<Void> deletePromise = new CompletableFuture<Void>();\n                                             deleteLockNode(deletePromise);\n-                                            deletePromise.ensure(new Function0<BoxedUnit>() {\n-                                                public BoxedUnit apply() {\n-                                                    promise.setException(new LockClosedException(lockPath, lockId, lockState.getState()));\n-                                                    return BoxedUnit.UNIT;\n-                                                }\n-                                            });\n+                                            FutureUtils.ensure(\n+                                                deletePromise,\n+                                                () -> promise.completeExceptionally(\n+                                                    new LockClosedException(lockPath, lockId, lockState.getState())));\n                                             return;\n                                         }\n \n@@ -830,21 +809,21 @@ public String getActionName() {\n     @Override\n     public void tryLock(long timeout, TimeUnit unit) throws LockingException {\n         final Stopwatch stopwatch = Stopwatch.createStarted();\n-        Future<LockWaiter> tryFuture = asyncTryLock(timeout, unit);\n+        CompletableFuture<LockWaiter> tryFuture = asyncTryLock(timeout, unit);\n         LockWaiter waiter = waitForTry(stopwatch, tryFuture);\n         boolean acquired = waiter.waitForAcquireQuietly();\n         if (!acquired) {\n             throw new OwnershipAcquireFailedException(lockPath, waiter.getCurrentOwner());\n         }\n     }\n \n-    synchronized LockWaiter waitForTry(Stopwatch stopwatch, Future<LockWaiter> tryFuture)\n+    synchronized LockWaiter waitForTry(Stopwatch stopwatch, CompletableFuture<LockWaiter> tryFuture)\n             throws LockingException {\n         boolean success = false;\n         boolean stateChanged = false;\n         LockWaiter waiter;\n         try {\n-            waiter = Await.result(tryFuture, Duration.fromMilliseconds(lockOpTimeout));\n+            waiter = FutureUtils.result(tryFuture, lockOpTimeout, TimeUnit.MILLISECONDS);\n             success = true;\n         } catch (LockStateChangedException ex) {\n             stateChanged = true;\n@@ -873,22 +852,22 @@ synchronized LockWaiter waitForTry(Stopwatch stopwatch, Future<LockWaiter> tryFu\n     }\n \n     @Override\n-    public Future<BoxedUnit> asyncUnlock() {\n+    public CompletableFuture<Void> asyncUnlock() {\n         return asyncUnlock(new LockClosedException(lockPath, lockId, lockState.getState()));\n     }\n \n-    Future<BoxedUnit> asyncUnlock(final Throwable cause) {\n-        final Promise<BoxedUnit> promise = new Promise<BoxedUnit>();\n+    CompletableFuture<Void> asyncUnlock(final Throwable cause) {\n+        final CompletableFuture<Void> promise = new CompletableFuture<Void>();\n \n         // Use lock executor here rather than lock action, because we want this opertaion to be applied\n         // whether the epoch has changed or not. The member node is EPHEMERAL_SEQUENTIAL so there's no\n         // risk of an ABA problem where we delete and recreate a node and then delete it again here.\n         lockStateExecutor.submit(lockPath, new SafeRunnable() {\n             @Override\n             public void safeRun() {\n-                acquireFuture.updateIfEmpty(new Throw<Boolean>(cause));\n+                acquireFuture.completeExceptionally(cause);\n                 unlockInternal(promise);\n-                promise.addEventListener(new OpStatsListener<BoxedUnit>(unlockStats));\n+                promise.whenComplete(new OpStatsListener<Void>(unlockStats));\n             }\n         });\n \n@@ -897,9 +876,9 @@ public void safeRun() {\n \n     @Override\n     public void unlock() {\n-        Future<BoxedUnit> unlockResult = asyncUnlock();\n+        CompletableFuture<Void> unlockResult = asyncUnlock();\n         try {\n-            Await.result(unlockResult, Duration.fromMilliseconds(lockOpTimeout));\n+            FutureUtils.result(unlockResult, lockOpTimeout, TimeUnit.MILLISECONDS);\n         } catch (TimeoutException toe) {\n             // This shouldn't happen unless we lose a watch, and may result in a leaked lock.\n             LOG.error(\"Timeout unlocking {} owned by {} : \", new Object[] { lockPath, lockId, toe });\n@@ -921,13 +900,13 @@ private void claimOwnership(int lockEpoch) {\n                     new Object[] { lockPath, System.currentTimeMillis(),\n                             lockEpoch, ZKSessionLock.this.epoch.get() });\n         }\n-        acquireFuture.updateIfEmpty(new Return<Boolean>(true));\n+        acquireFuture.complete(true);\n     }\n \n     /**\n      * NOTE: unlockInternal should only after try lock.\n      */\n-    private void unlockInternal(final Promise<BoxedUnit> promise) {\n+    private void unlockInternal(final CompletableFuture<Void> promise) {\n \n         // already closed or expired, nothing to cleanup\n         this.epoch.incrementAndGet();\n@@ -936,7 +915,7 @@ private void unlockInternal(final Promise<BoxedUnit> promise) {\n         }\n \n         if (lockState.inState(State.CLOSED)) {\n-            promise.setValue(BoxedUnit.UNIT);\n+            promise.complete(null);\n             return;\n         }\n \n@@ -951,39 +930,34 @@ private void unlockInternal(final Promise<BoxedUnit> promise) {\n             // Nothing to cleanup if INIT (never tried) or EXPIRED (ephemeral node\n             // auto-removed)\n             lockState.transition(State.CLOSED);\n-            promise.setValue(BoxedUnit.UNIT);\n+            promise.complete(null);\n             return;\n         }\n \n         // In any other state, we should clean up the member node\n-        Promise<BoxedUnit> deletePromise = new Promise<BoxedUnit>();\n+        CompletableFuture<Void> deletePromise = new CompletableFuture<Void>();\n         deleteLockNode(deletePromise);\n \n         // Set the state to closed after we've cleaned up\n-        deletePromise.addEventListener(new FutureEventListener<BoxedUnit>() {\n+        deletePromise.whenCompleteAsync(new FutureEventListener<Void>() {\n             @Override\n-            public void onSuccess(BoxedUnit complete) {\n-                lockStateExecutor.submit(lockPath, new SafeRunnable() {\n-                    @Override\n-                    public void safeRun() {\n-                        lockState.transition(State.CLOSED);\n-                        promise.setValue(BoxedUnit.UNIT);\n-                    }\n-                });\n+            public void onSuccess(Void complete) {\n+                lockState.transition(State.CLOSED);\n+                promise.complete(null);\n             }\n             @Override\n             public void onFailure(Throwable cause) {\n                 // Delete failure is quite serious (causes lock leak) and should be\n                 // handled better\n                 LOG.error(\"lock node delete failed {} {}\", lockId, lockPath);\n-                promise.setValue(BoxedUnit.UNIT);\n+                promise.complete(null);\n             }\n-        });\n+        }, lockStateExecutor.chooseExecutor(lockPath));\n     }\n \n-    private void deleteLockNode(final Promise<BoxedUnit> promise) {\n+    private void deleteLockNode(final CompletableFuture<Void> promise) {\n         if (null == currentNode) {\n-            promise.setValue(BoxedUnit.UNIT);\n+            promise.complete(null);\n             return;\n         }\n \n@@ -1005,7 +979,7 @@ public void safeRun() {\n                         }\n \n                         FailpointUtils.checkFailPointNoThrow(FailpointUtils.FailPointName.FP_LockUnlockCleanup);\n-                        promise.setValue(BoxedUnit.UNIT);\n+                        promise.complete(null);\n                     }\n                 });\n             }\n@@ -1041,8 +1015,8 @@ public void execute() {\n \n                 // if session expired, just notify the waiter. as the lock acquire doesn't succeed.\n                 // we don't even need to clean up the lock as the znode will disappear after session expired\n-                acquireFuture.updateIfEmpty(new Throw<Boolean>(\n-                        new LockSessionExpiredException(lockPath, lockId, lockState.getState())));\n+                acquireFuture.completeExceptionally(\n+                    new LockSessionExpiredException(lockPath, lockId, lockState.getState()));\n \n                 // session expired, ephemeral node is gone.\n                 currentNode = null;\n@@ -1088,9 +1062,9 @@ public String getActionName() {\n         });\n     }\n \n-    private Future<String> checkLockOwnerAndWaitIfPossible(final LockWatcher lockWatcher,\n+    private CompletableFuture<String> checkLockOwnerAndWaitIfPossible(final LockWatcher lockWatcher,\n                                                            final boolean wait) {\n-        final Promise<String> promise = new Promise<String>();\n+        final CompletableFuture<String> promise = new CompletableFuture<String>();\n         checkLockOwnerAndWaitIfPossible(lockWatcher, wait, promise);\n         return promise;\n     }\n@@ -1107,7 +1081,7 @@ private Future<String> checkLockOwnerAndWaitIfPossible(final LockWatcher lockWat\n      */\n     private void checkLockOwnerAndWaitIfPossible(final LockWatcher lockWatcher,\n                                                  final boolean wait,\n-                                                 final Promise<String> promise) {\n+                                                 final CompletableFuture<String> promise) {\n         zk.getChildren(lockPath, false, new AsyncCallback.Children2Callback() {\n             @Override\n             public void processResult(int rc, String path, Object ctx, List<String> children, Stat stat) {\n@@ -1134,22 +1108,22 @@ private void processLockWaiters(final LockWatcher lockWatcher,\n                                     final boolean wait,\n                                     final int getChildrenRc,\n                                     final List<String> children,\n-                                    final Promise<String> promise) {\n+                                    final CompletableFuture<String> promise) {\n         executeLockAction(lockWatcher.epoch, new LockAction() {\n             @Override\n             public void execute() {\n                 if (!lockState.inState(State.PREPARED)) { // e.g. lock closed or session expired after prepared\n-                    promise.setException(new LockStateChangedException(lockPath, lockId, State.PREPARED, lockState.getState()));\n+                    promise.completeExceptionally(new LockStateChangedException(lockPath, lockId, State.PREPARED, lockState.getState()));\n                     return;\n                 }\n \n                 if (KeeperException.Code.OK.intValue() != getChildrenRc) {\n-                    promise.setException(KeeperException.create(KeeperException.Code.get(getChildrenRc)));\n+                    promise.completeExceptionally(KeeperException.create(KeeperException.Code.get(getChildrenRc)));\n                     return;\n                 }\n                 if (children.isEmpty()) {\n                     LOG.error(\"Error, member list is empty for lock {}.\", lockPath);\n-                    promise.setException(new UnexpectedException(\"Empty member list for lock \" + lockPath));\n+                    promise.completeExceptionally(new UnexpectedException(\"Empty member list for lock \" + lockPath));\n                     return;\n                 }\n \n@@ -1164,10 +1138,10 @@ public void execute() {\n                 if (memberIndex == 0) {\n                     LOG.info(\"{} acquired the lock {}.\", cid, lockPath);\n                     claimOwnership(lockWatcher.epoch);\n-                    promise.setValue(cid);\n+                    promise.complete(cid);\n                 } else if (memberIndex > 0) { // we are in the member list but we didn't hold the lock\n                     // get ownership of current owner\n-                    asyncParseClientID(zk, lockPath, children.get(0)).addEventListener(new FutureEventListener<Pair<String, Long>>() {\n+                    asyncParseClientID(zk, lockPath, children.get(0)).whenComplete(new FutureEventListener<Pair<String, Long>>() {\n                         @Override\n                         public void onSuccess(Pair<String, Long> currentOwner) {\n                             watchLockOwner(lockWatcher, wait,\n@@ -1179,7 +1153,7 @@ public void onFailure(final Throwable cause) {\n                             executeLockAction(lockWatcher.epoch, new LockAction() {\n                                 @Override\n                                 public void execute() {\n-                                    promise.setException(cause);\n+                                    promise.completeExceptionally(cause);\n                                 }\n \n                                 @Override\n@@ -1192,7 +1166,7 @@ public String getActionName() {\n                 } else {\n                     LOG.error(\"Member {} doesn't exist in the members list {} for lock {}.\",\n                             new Object[]{ cid, children, lockPath});\n-                    promise.setException(\n+                    promise.completeExceptionally(\n                             new UnexpectedException(\"Member \" + cid + \" doesn't exist in member list \" +\n                                     children + \" for lock \" + lockPath));\n                 }\n@@ -1229,7 +1203,7 @@ private void watchLockOwner(final LockWatcher lockWatcher,\n                                 final String siblingNode,\n                                 final String ownerNode,\n                                 final Pair<String, Long> currentOwner,\n-                                final Promise<String> promise) {\n+                                final CompletableFuture<String> promise) {\n         executeLockAction(lockWatcher.epoch, new LockAction() {\n             @Override\n             public void execute() {\n@@ -1270,7 +1244,7 @@ public void processResult(final int rc, String path, Object ctx, final Stat stat\n                                 @Override\n                                 public void execute() {\n                                     if (!lockState.inState(State.PREPARED)) {\n-                                        promise.setException(new LockStateChangedException(lockPath, lockId, State.PREPARED, lockState.getState()));\n+                                        promise.completeExceptionally(new LockStateChangedException(lockPath, lockId, State.PREPARED, lockState.getState()));\n                                         return;\n                                     }\n \n@@ -1280,17 +1254,17 @@ public void execute() {\n                                             LOG.info(\"LockWatcher {} claimed ownership for {} after set watcher on {}.\",\n                                                     new Object[]{ myNode, lockPath, ownerNode });\n                                             claimOwnership(lockWatcher.epoch);\n-                                            promise.setValue(currentOwner.getLeft());\n+                                            promise.complete(currentOwner.getLeft());\n                                         } else {\n                                             // watch sibling successfully\n                                             lockState.transition(State.WAITING);\n-                                            promise.setValue(currentOwner.getLeft());\n+                                            promise.complete(currentOwner.getLeft());\n                                         }\n                                     } else if (KeeperException.Code.NONODE.intValue() == rc) {\n                                         // sibling just disappeared, it might be the chance to claim ownership\n                                         checkLockOwnerAndWaitIfPossible(lockWatcher, wait, promise);\n                                     } else {\n-                                        promise.setException(KeeperException.create(KeeperException.Code.get(rc)));\n+                                        promise.completeExceptionally(KeeperException.create(KeeperException.Code.get(rc)));\n                                     }\n                                 }\n \n@@ -1305,7 +1279,7 @@ public String getActionName() {\n                         }\n                     }, null);\n                 } else {\n-                    promise.setValue(currentOwner.getLeft());\n+                    promise.complete(currentOwner.getLeft());\n                 }\n             }\n "},{"sha":"223a3a442be899480cebd24c069dc2bd88925681","filename":"src/main/java/org/apache/distributedlog/lock/ZKSessionLockFactory.java","status":"modified","additions":18,"deletions":23,"changes":41,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Flock%2FZKSessionLockFactory.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Flock%2FZKSessionLockFactory.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Flock%2FZKSessionLockFactory.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -17,20 +17,17 @@\n  */\n package org.apache.distributedlog.lock;\n \n-import org.apache.distributedlog.ZooKeeperClient;\n-import org.apache.distributedlog.exceptions.DLInterruptedException;\n-import org.apache.distributedlog.util.OrderedScheduler;\n-import com.twitter.util.Future;\n-import com.twitter.util.Promise;\n-import com.twitter.util.Return;\n-import com.twitter.util.Throw;\n-import org.apache.bookkeeper.stats.StatsLogger;\n-import scala.runtime.BoxedUnit;\n-\n import java.io.IOException;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicInteger;\n import java.util.concurrent.atomic.AtomicReference;\n+import org.apache.distributedlog.ZooKeeperClient;\n+import org.apache.distributedlog.exceptions.DLInterruptedException;\n+import org.apache.distributedlog.common.concurrent.FutureUtils;\n+import org.apache.distributedlog.util.OrderedScheduler;\n+import org.apache.bookkeeper.stats.StatsLogger;\n \n /**\n  * Factory to create zookeeper based locks.\n@@ -65,16 +62,14 @@ public ZKSessionLockFactory(ZooKeeperClient zkc,\n     }\n \n     @Override\n-    public Future<SessionLock> createLock(String lockPath,\n-                                          DistributedLockContext context) {\n+    public CompletableFuture<SessionLock> createLock(String lockPath,\n+                                                     DistributedLockContext context) {\n         AtomicInteger numRetries = new AtomicInteger(lockCreationRetries);\n         final AtomicReference<Throwable> interruptedException = new AtomicReference<Throwable>(null);\n-        Promise<SessionLock> createPromise =\n-                new Promise<SessionLock>(new com.twitter.util.Function<Throwable, BoxedUnit>() {\n-            @Override\n-            public BoxedUnit apply(Throwable t) {\n-                interruptedException.set(t);\n-                return BoxedUnit.UNIT;\n+        CompletableFuture<SessionLock> createPromise = FutureUtils.createFuture();\n+        createPromise.whenComplete((value, cause) -> {\n+            if (null != cause && cause instanceof CancellationException) {\n+                interruptedException.set(cause);\n             }\n         });\n         createLock(\n@@ -91,13 +86,13 @@ void createLock(final String lockPath,\n                     final DistributedLockContext context,\n                     final AtomicReference<Throwable> interruptedException,\n                     final AtomicInteger numRetries,\n-                    final Promise<SessionLock> createPromise,\n+                    final CompletableFuture<SessionLock> createPromise,\n                     final long delayMs) {\n         lockStateExecutor.schedule(lockPath, new Runnable() {\n             @Override\n             public void run() {\n                 if (null != interruptedException.get()) {\n-                    createPromise.updateIfEmpty(new Throw<SessionLock>(interruptedException.get()));\n+                    createPromise.completeExceptionally(interruptedException.get());\n                     return;\n                 }\n                 try {\n@@ -109,14 +104,14 @@ public void run() {\n                             lockOpTimeout,\n                             lockStatsLogger,\n                             context);\n-                    createPromise.updateIfEmpty(new Return<SessionLock>(lock));\n+                    createPromise.complete(lock);\n                 } catch (DLInterruptedException dlie) {\n                     // if the creation is interrupted, throw the exception without retrie.\n-                    createPromise.updateIfEmpty(new Throw<SessionLock>(dlie));\n+                    createPromise.completeExceptionally(dlie);\n                     return;\n                 } catch (IOException e) {\n                     if (numRetries.getAndDecrement() < 0) {\n-                        createPromise.updateIfEmpty(new Throw<SessionLock>(e));\n+                        createPromise.completeExceptionally(e);\n                         return;\n                     }\n                     createLock("},{"sha":"1b292e3ab37d919afcd4478e7b346483fff6bd40","filename":"src/main/java/org/apache/distributedlog/logsegment/LogSegmentEntryReader.java","status":"modified","additions":3,"deletions":4,"changes":7,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Flogsegment%2FLogSegmentEntryReader.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Flogsegment%2FLogSegmentEntryReader.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Flogsegment%2FLogSegmentEntryReader.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -18,12 +18,11 @@\n package org.apache.distributedlog.logsegment;\n \n import com.google.common.annotations.Beta;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n import org.apache.distributedlog.Entry;\n import org.apache.distributedlog.LogSegmentMetadata;\n import org.apache.distributedlog.io.AsyncCloseable;\n-import com.twitter.util.Future;\n-\n-import java.util.List;\n \n /**\n  * An interface class to read the enveloped entry (serialized bytes of\n@@ -87,7 +86,7 @@ interface StateChangeListener {\n      * @throws {@link org.apache.distributedlog.exceptions.EndOfLogSegmentException} when\n      *          read entries beyond the end of a <i>closed</i> log segment.\n      */\n-    Future<List<Entry.Reader>> readNext(int numEntries);\n+    CompletableFuture<List<Entry.Reader>> readNext(int numEntries);\n \n     /**\n      * Return the last add confirmed entry id (LAC)."},{"sha":"ab2d898d28b9fb591a87e5fc2c9d3d6e372f7378","filename":"src/main/java/org/apache/distributedlog/logsegment/LogSegmentEntryStore.java","status":"modified","additions":4,"deletions":5,"changes":9,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Flogsegment%2FLogSegmentEntryStore.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Flogsegment%2FLogSegmentEntryStore.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Flogsegment%2FLogSegmentEntryStore.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -18,12 +18,11 @@\n package org.apache.distributedlog.logsegment;\n \n import com.google.common.annotations.Beta;\n+import java.util.concurrent.CompletableFuture;\n import org.apache.distributedlog.LogSegmentMetadata;\n import org.apache.distributedlog.config.DynamicDistributedLogConfiguration;\n import org.apache.distributedlog.metadata.LogMetadataForWriter;\n import org.apache.distributedlog.util.Allocator;\n-import org.apache.distributedlog.util.Transaction;\n-import com.twitter.util.Future;\n \n import java.io.IOException;\n \n@@ -39,7 +38,7 @@ public interface LogSegmentEntryStore {\n      * @param segment log segment metadata\n      * @return future represent the delete result\n      */\n-    Future<LogSegmentMetadata> deleteLogSegment(LogSegmentMetadata segment);\n+    CompletableFuture<LogSegmentMetadata> deleteLogSegment(LogSegmentMetadata segment);\n \n     /**\n      * Create a new log segment allocator for allocating log segment entry writers.\n@@ -58,7 +57,7 @@ Allocator<LogSegmentEntryWriter, Object> newLogSegmentAllocator(\n      * @param startEntryId the start entry id\n      * @return future represent the opened reader\n      */\n-    Future<LogSegmentEntryReader> openReader(LogSegmentMetadata segment,\n+    CompletableFuture<LogSegmentEntryReader> openReader(LogSegmentMetadata segment,\n                                              long startEntryId);\n \n     /**\n@@ -68,6 +67,6 @@ Future<LogSegmentEntryReader> openReader(LogSegmentMetadata segment,\n      * @param fence the flag to fence log segment\n      * @return future represent the opened random access reader\n      */\n-    Future<LogSegmentRandomAccessEntryReader> openRandomAccessReader(LogSegmentMetadata segment,\n+    CompletableFuture<LogSegmentRandomAccessEntryReader> openRandomAccessReader(LogSegmentMetadata segment,\n                                                                      boolean fence);\n }"},{"sha":"70f0da000c2047e7e7282b31a871440ecc4dfd9d","filename":"src/main/java/org/apache/distributedlog/logsegment/LogSegmentEntryWriter.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Flogsegment%2FLogSegmentEntryWriter.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Flogsegment%2FLogSegmentEntryWriter.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Flogsegment%2FLogSegmentEntryWriter.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -19,7 +19,7 @@\n \n import com.google.common.annotations.Beta;\n import org.apache.distributedlog.Entry;\n-import org.apache.distributedlog.util.Sizable;\n+import org.apache.distributedlog.common.util.Sizable;\n import org.apache.bookkeeper.client.AsyncCallback;\n \n /**"},{"sha":"a58264c0dd1b7313618fa04ddf92f868598adcc8","filename":"src/main/java/org/apache/distributedlog/logsegment/LogSegmentMetadataStore.java","status":"modified","additions":6,"deletions":6,"changes":12,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Flogsegment%2FLogSegmentMetadataStore.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Flogsegment%2FLogSegmentMetadataStore.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Flogsegment%2FLogSegmentMetadataStore.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -18,15 +18,15 @@\n package org.apache.distributedlog.logsegment;\n \n import com.google.common.annotations.Beta;\n+import java.util.concurrent.CompletableFuture;\n+import org.apache.bookkeeper.versioning.Version;\n+import org.apache.bookkeeper.versioning.Versioned;\n import org.apache.distributedlog.LogSegmentMetadata;\n import org.apache.distributedlog.callback.LogSegmentNamesListener;\n import org.apache.distributedlog.metadata.LogMetadata;\n import org.apache.distributedlog.metadata.LogMetadataForWriter;\n import org.apache.distributedlog.util.Transaction;\n import org.apache.distributedlog.util.Transaction.OpListener;\n-import com.twitter.util.Future;\n-import org.apache.bookkeeper.versioning.Version;\n-import org.apache.bookkeeper.versioning.Versioned;\n \n import java.io.Closeable;\n import java.util.List;\n@@ -135,7 +135,7 @@ void deleteLogSegment(Transaction<Object> txn,\n      *          path to store log segment metadata\n      * @return future of the retrieved log segment metadata\n      */\n-    Future<LogSegmentMetadata> getLogSegment(String logSegmentPath);\n+    CompletableFuture<LogSegmentMetadata> getLogSegment(String logSegmentPath);\n \n     /**\n      * Retrieve the list of log segments under <code>logSegmentsPath</code> and register a <i>listener</i>\n@@ -147,8 +147,8 @@ void deleteLogSegment(Transaction<Object> txn,\n      *          log segment listener on log segment changes\n      * @return future of the retrieved list of log segment names\n      */\n-    Future<Versioned<List<String>>> getLogSegmentNames(String logSegmentsPath,\n-                                                       LogSegmentNamesListener listener);\n+    CompletableFuture<Versioned<List<String>>> getLogSegmentNames(String logSegmentsPath,\n+                                                                  LogSegmentNamesListener listener);\n \n     /**\n      * Unregister a log segment <code>listener</code> on log segment changes under <code>logSegmentsPath</code>."},{"sha":"23c784e7fedc75eb1f613b1d2d89ea47c2569fdd","filename":"src/main/java/org/apache/distributedlog/logsegment/LogSegmentRandomAccessEntryReader.java","status":"modified","additions":3,"deletions":4,"changes":7,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Flogsegment%2FLogSegmentRandomAccessEntryReader.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Flogsegment%2FLogSegmentRandomAccessEntryReader.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Flogsegment%2FLogSegmentRandomAccessEntryReader.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -17,11 +17,10 @@\n  */\n package org.apache.distributedlog.logsegment;\n \n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n import org.apache.distributedlog.Entry;\n import org.apache.distributedlog.io.AsyncCloseable;\n-import com.twitter.util.Future;\n-\n-import java.util.List;\n \n /**\n  * An interface class to read entries {@link org.apache.distributedlog.Entry}\n@@ -36,7 +35,7 @@ public interface LogSegmentRandomAccessEntryReader extends AsyncCloseable {\n      * @param endEntryId end entry id\n      * @return A promise that when satisfied will contain a list of entries of [startEntryId, endEntryId].\n      */\n-    Future<List<Entry.Reader>> readEntries(long startEntryId, long endEntryId);\n+    CompletableFuture<List<Entry.Reader>> readEntries(long startEntryId, long endEntryId);\n \n     /**\n      * Return the last add confirmed entry id (LAC)."},{"sha":"c48340317f0ad84b8a356e81e2cc1e10f8a5990e","filename":"src/main/java/org/apache/distributedlog/logsegment/LogSegmentWriter.java","status":"modified","additions":5,"deletions":6,"changes":11,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Flogsegment%2FLogSegmentWriter.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Flogsegment%2FLogSegmentWriter.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Flogsegment%2FLogSegmentWriter.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -18,15 +18,14 @@\n package org.apache.distributedlog.logsegment;\n \n import com.google.common.annotations.Beta;\n+import java.io.IOException;\n+import java.util.concurrent.CompletableFuture;\n import org.apache.distributedlog.DLSN;\n import org.apache.distributedlog.LogRecord;\n import org.apache.distributedlog.exceptions.BKTransmitException;\n import org.apache.distributedlog.exceptions.LockingException;\n import org.apache.distributedlog.io.AsyncAbortable;\n import org.apache.distributedlog.io.AsyncCloseable;\n-import com.twitter.util.Future;\n-\n-import java.io.IOException;\n \n /**\n  * An interface class to write log records into a log segment.\n@@ -53,7 +52,7 @@ public interface LogSegmentWriter extends AsyncCloseable, AsyncAbortable {\n      * @throws BKTransmitException if failed to transmit data to bk\n      * @throws org.apache.distributedlog.exceptions.WriteException if failed to write to bk\n      */\n-    public Future<DLSN> asyncWrite(LogRecord record);\n+    public CompletableFuture<DLSN> asyncWrite(LogRecord record);\n \n     /**\n      * This isn't a simple synchronous version of {@code asyncWrite}. It has different semantic.\n@@ -74,14 +73,14 @@ public interface LogSegmentWriter extends AsyncCloseable, AsyncAbortable {\n      *\n      * @return future representing the transmit result with last acknowledged transaction id.\n      */\n-    public Future<Long> flush();\n+    public CompletableFuture<Long> flush();\n \n     /**\n      * Commit the current acknowledged data. It is the consequent operation of {@link #flush()},\n      * which makes all the acknowledged data visible to\n      *\n      * @return future representing the commit result.\n      */\n-    public Future<Long> commit();\n+    public CompletableFuture<Long> commit();\n \n }"},{"sha":"4844ad4800069c91e406c65452499803ab2bfa93","filename":"src/main/java/org/apache/distributedlog/logsegment/RollingPolicy.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Flogsegment%2FRollingPolicy.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Flogsegment%2FRollingPolicy.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Flogsegment%2FRollingPolicy.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -17,7 +17,7 @@\n  */\n package org.apache.distributedlog.logsegment;\n \n-import org.apache.distributedlog.util.Sizable;\n+import org.apache.distributedlog.common.util.Sizable;\n \n public interface RollingPolicy {\n     /**"},{"sha":"1c3794af165fe2cc48b561cb605997a767bad34f","filename":"src/main/java/org/apache/distributedlog/logsegment/SizeBasedRollingPolicy.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Flogsegment%2FSizeBasedRollingPolicy.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Flogsegment%2FSizeBasedRollingPolicy.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Flogsegment%2FSizeBasedRollingPolicy.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -17,7 +17,7 @@\n  */\n package org.apache.distributedlog.logsegment;\n \n-import org.apache.distributedlog.util.Sizable;\n+import org.apache.distributedlog.common.util.Sizable;\n \n public class SizeBasedRollingPolicy implements RollingPolicy {\n "},{"sha":"80c09be3136e6ef665f741c620617eedd07223c0","filename":"src/main/java/org/apache/distributedlog/logsegment/TimeBasedRollingPolicy.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Flogsegment%2FTimeBasedRollingPolicy.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Flogsegment%2FTimeBasedRollingPolicy.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Flogsegment%2FTimeBasedRollingPolicy.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -17,7 +17,7 @@\n  */\n package org.apache.distributedlog.logsegment;\n \n-import org.apache.distributedlog.util.Sizable;\n+import org.apache.distributedlog.common.util.Sizable;\n import org.apache.distributedlog.util.Utils;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;"},{"sha":"948f2bf981da8521c5bea30b201c3ca429deaa31","filename":"src/main/java/org/apache/distributedlog/metadata/DLMetadata.java","status":"modified","additions":4,"deletions":7,"changes":11,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fmetadata%2FDLMetadata.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fmetadata%2FDLMetadata.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fmetadata%2FDLMetadata.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -18,6 +18,7 @@\n package org.apache.distributedlog.metadata;\n \n import org.apache.distributedlog.DistributedLogConfiguration;\n+import org.apache.distributedlog.exceptions.ZKException;\n import org.apache.distributedlog.impl.metadata.BKDLConfig;\n import org.apache.distributedlog.util.Utils;\n import org.apache.distributedlog.ZooKeeperClient;\n@@ -144,13 +145,9 @@ public void create(URI uri) throws IOException {\n         byte[] data = serialize();\n         try {\n             Utils.zkCreateFullPathOptimistic(zkc, uri.getPath(), data,\n-                    zkc.getDefaultACL(), CreateMode.PERSISTENT);\n-        } catch (KeeperException e) {\n-            throw new IOException(\"Fail to write dl metadata \" + new String(data, UTF_8)\n-                    +  \" to uri \" + uri, e);\n-        } catch (InterruptedException e) {\n-            throw new IOException(\"Interrupted when writing dl metadata \" + new String(data, UTF_8)\n-                    + \" to uri \" + uri, e);\n+                zkc.getDefaultACL(), CreateMode.PERSISTENT);\n+        } catch (KeeperException ke) {\n+            throw new ZKException(\"Encountered zookeeper exception on creating dl metadata\", ke);\n         } finally {\n             zkc.close();\n         }"},{"sha":"fe528040208b9e1bf40e253ab77a40cb8702088d","filename":"src/main/java/org/apache/distributedlog/metadata/DryrunLogSegmentMetadataStoreUpdater.java","status":"modified","additions":4,"deletions":3,"changes":7,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fmetadata%2FDryrunLogSegmentMetadataStoreUpdater.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fmetadata%2FDryrunLogSegmentMetadataStoreUpdater.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fmetadata%2FDryrunLogSegmentMetadataStoreUpdater.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -17,10 +17,11 @@\n  */\n package org.apache.distributedlog.metadata;\n \n+import java.util.concurrent.CompletableFuture;\n import org.apache.distributedlog.DistributedLogConfiguration;\n import org.apache.distributedlog.logsegment.LogSegmentMetadataStore;\n+import org.apache.distributedlog.common.concurrent.FutureUtils;\n import org.apache.distributedlog.util.Transaction;\n-import com.twitter.util.Future;\n \n public class DryrunLogSegmentMetadataStoreUpdater extends LogSegmentMetadataStoreUpdater {\n \n@@ -38,8 +39,8 @@ public void addOp(Op<Object> operation) {\n             }\n \n             @Override\n-            public Future<Void> execute() {\n-                return Future.Void();\n+            public CompletableFuture<Void> execute() {\n+                return FutureUtils.Void();\n             }\n \n             @Override"},{"sha":"8135678802d6963a2f4a995fe1e2e1e1bc025f5b","filename":"src/main/java/org/apache/distributedlog/metadata/LogMetadataStore.java","status":"modified","additions":5,"deletions":6,"changes":11,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fmetadata%2FLogMetadataStore.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fmetadata%2FLogMetadataStore.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fmetadata%2FLogMetadataStore.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -19,11 +19,10 @@\n \n import com.google.common.annotations.Beta;\n import com.google.common.base.Optional;\n-import org.apache.distributedlog.callback.NamespaceListener;\n-import com.twitter.util.Future;\n-\n import java.net.URI;\n import java.util.Iterator;\n+import java.util.concurrent.CompletableFuture;\n+import org.apache.distributedlog.callback.NamespaceListener;\n \n /**\n  * Interface for log metadata store.\n@@ -38,7 +37,7 @@ public interface LogMetadataStore {\n      *          name of the log\n      * @return namespace location that stores this stream.\n      */\n-    Future<URI> createLog(String logName);\n+    CompletableFuture<URI> createLog(String logName);\n \n     /**\n      * Get the location of the log.\n@@ -47,14 +46,14 @@ public interface LogMetadataStore {\n      *          name of the log\n      * @return namespace location that stores this stream.\n      */\n-    Future<Optional<URI>> getLogLocation(String logName);\n+    CompletableFuture<Optional<URI>> getLogLocation(String logName);\n \n     /**\n      * Retrieves logs from the namespace.\n      *\n      * @return iterator of logs of the namespace.\n      */\n-    Future<Iterator<String>> getLogs();\n+    CompletableFuture<Iterator<String>> getLogs();\n \n     /**\n      * Register a namespace listener on streams changes."},{"sha":"71a1f98d336ad6b9e0dd3c7f937203c346dee1fc","filename":"src/main/java/org/apache/distributedlog/metadata/LogSegmentMetadataStoreUpdater.java","status":"modified","additions":11,"deletions":22,"changes":33,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fmetadata%2FLogSegmentMetadataStoreUpdater.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fmetadata%2FLogSegmentMetadataStoreUpdater.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fmetadata%2FLogSegmentMetadataStoreUpdater.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -18,16 +18,15 @@\n package org.apache.distributedlog.metadata;\n \n import com.google.common.base.Preconditions;\n+import java.util.concurrent.CompletableFuture;\n import org.apache.distributedlog.DLSN;\n import org.apache.distributedlog.DistributedLogConfiguration;\n import org.apache.distributedlog.LogRecordWithDLSN;\n import org.apache.distributedlog.LogSegmentMetadata;\n import org.apache.distributedlog.logsegment.LogSegmentMetadataStore;\n import org.apache.distributedlog.util.Transaction;\n-import com.twitter.util.Future;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n-import scala.runtime.AbstractFunction1;\n \n public class LogSegmentMetadataStoreUpdater implements MetadataUpdater {\n \n@@ -57,8 +56,8 @@ public Transaction<Object> transaction() {\n     }\n \n     @Override\n-    public Future<LogSegmentMetadata> updateLastRecord(LogSegmentMetadata segment,\n-                                                       LogRecordWithDLSN record) {\n+    public CompletableFuture<LogSegmentMetadata> updateLastRecord(LogSegmentMetadata segment,\n+                                                                  LogRecordWithDLSN record) {\n         DLSN dlsn = record.getDlsn();\n         Preconditions.checkState(!segment.isInProgress(),\n                 \"Updating last dlsn for an inprogress log segment isn't supported.\");\n@@ -73,7 +72,7 @@ public Future<LogSegmentMetadata> updateLastRecord(LogSegmentMetadata segment,\n     }\n \n     @Override\n-    public Future<LogSegmentMetadata> changeSequenceNumber(LogSegmentMetadata segment,\n+    public CompletableFuture<LogSegmentMetadata> changeSequenceNumber(LogSegmentMetadata segment,\n                                                            long logSegmentSeqNo) {\n         String newZkPath = segment.getZkPath()\n                 .replace(formatLogSegmentSequenceNumber(segment.getLogSegmentSequenceNumber()),\n@@ -92,7 +91,7 @@ public Future<LogSegmentMetadata> changeSequenceNumber(LogSegmentMetadata segmen\n      * @return new log segment\n      */\n     @Override\n-    public Future<LogSegmentMetadata> setLogSegmentActive(LogSegmentMetadata segment) {\n+    public CompletableFuture<LogSegmentMetadata> setLogSegmentActive(LogSegmentMetadata segment) {\n         final LogSegmentMetadata newSegment = segment.mutator()\n             .setTruncationStatus(LogSegmentMetadata.TruncationStatus.ACTIVE)\n             .build();\n@@ -106,7 +105,7 @@ public Future<LogSegmentMetadata> setLogSegmentActive(LogSegmentMetadata segment\n      * @return new log segment\n      */\n     @Override\n-    public Future<LogSegmentMetadata> setLogSegmentTruncated(LogSegmentMetadata segment) {\n+    public CompletableFuture<LogSegmentMetadata> setLogSegmentTruncated(LogSegmentMetadata segment) {\n         final LogSegmentMetadata newSegment = segment.mutator()\n             .setTruncationStatus(LogSegmentMetadata.TruncationStatus.TRUNCATED)\n             .build();\n@@ -130,7 +129,7 @@ public LogSegmentMetadata setLogSegmentTruncated(Transaction<Object> txn, LogSeg\n      * @return new log segment\n      */\n     @Override\n-    public Future<LogSegmentMetadata> setLogSegmentPartiallyTruncated(LogSegmentMetadata segment, DLSN minActiveDLSN) {\n+    public CompletableFuture<LogSegmentMetadata> setLogSegmentPartiallyTruncated(LogSegmentMetadata segment, DLSN minActiveDLSN) {\n         final LogSegmentMetadata newSegment = segment.mutator()\n             .setTruncationStatus(LogSegmentMetadata.TruncationStatus.PARTIALLY_TRUNCATED)\n             .setMinActiveDLSN(minActiveDLSN)\n@@ -150,28 +149,18 @@ public LogSegmentMetadata setLogSegmentPartiallyTruncated(Transaction<Object> tx\n         return newSegment;\n     }\n \n-    protected Future<LogSegmentMetadata> updateSegmentMetadata(final LogSegmentMetadata segment) {\n+    protected CompletableFuture<LogSegmentMetadata> updateSegmentMetadata(final LogSegmentMetadata segment) {\n         Transaction<Object> txn = transaction();\n         metadataStore.updateLogSegment(txn, segment);\n-        return txn.execute().map(new AbstractFunction1<Void, LogSegmentMetadata>() {\n-            @Override\n-            public LogSegmentMetadata apply(Void value) {\n-                return segment;\n-            }\n-        });\n+        return txn.execute().thenApply((value) -> segment);\n     }\n \n-    protected Future<LogSegmentMetadata> addNewSegmentAndDeleteOldSegment(\n+    protected CompletableFuture<LogSegmentMetadata> addNewSegmentAndDeleteOldSegment(\n             final LogSegmentMetadata newSegment, LogSegmentMetadata oldSegment) {\n         LOG.info(\"old segment {} new segment {}\", oldSegment, newSegment);\n         Transaction<Object> txn = transaction();\n         addNewSegmentAndDeleteOldSegment(txn, newSegment, oldSegment);\n-        return txn.execute().map(new AbstractFunction1<Void, LogSegmentMetadata>() {\n-            @Override\n-            public LogSegmentMetadata apply(Void value) {\n-                return newSegment;\n-            }\n-        });\n+        return txn.execute().thenApply((value) -> newSegment);\n     }\n \n     protected void addNewSegmentAndDeleteOldSegment(Transaction<Object> txn,"},{"sha":"37ecab494f5cde82c2006cdb0dd680a5f747f0f3","filename":"src/main/java/org/apache/distributedlog/metadata/LogStreamMetadataStore.java","status":"modified","additions":8,"deletions":8,"changes":16,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fmetadata%2FLogStreamMetadataStore.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fmetadata%2FLogStreamMetadataStore.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fmetadata%2FLogStreamMetadataStore.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -19,11 +19,11 @@\n \n import com.google.common.annotations.Beta;\n import com.google.common.base.Optional;\n+import java.util.concurrent.CompletableFuture;\n import org.apache.distributedlog.lock.DistributedLock;\n import org.apache.distributedlog.logsegment.LogSegmentMetadataStore;\n-import org.apache.distributedlog.util.PermitManager;\n+import org.apache.distributedlog.common.util.PermitManager;\n import org.apache.distributedlog.util.Transaction;\n-import com.twitter.util.Future;\n \n import java.io.Closeable;\n import java.net.URI;\n@@ -47,10 +47,10 @@ public interface LogStreamMetadataStore extends Closeable {\n      *\n      * @param uri the location of the log stream\n      * @param logName the name of the log stream\n-     * @return future represents the existence of a log stream. {@link org.apache.distributedlog.LogNotFoundException}\n-     *         is thrown if the log doesn't exist\n+     * @return future represents the existence of a log stream.\n+     *         {@link org.apache.distributedlog.exceptions.LogNotFoundException} is thrown if the log doesn't exist\n      */\n-    Future<Void> logExists(URI uri, String logName);\n+    CompletableFuture<Void> logExists(URI uri, String logName);\n \n     /**\n      * Create the read lock for the log stream.\n@@ -59,7 +59,7 @@ public interface LogStreamMetadataStore extends Closeable {\n      * @param readerId the reader id used for lock\n      * @return the read lock\n      */\n-    Future<DistributedLock> createReadLock(LogMetadataForReader metadata,\n+    CompletableFuture<DistributedLock> createReadLock(LogMetadataForReader metadata,\n                                            Optional<String> readerId);\n \n     /**\n@@ -79,7 +79,7 @@ Future<DistributedLock> createReadLock(LogMetadataForReader metadata,\n      * @param createIfNotExists flag to create the stream if it doesn't exist\n      * @return the metadata of the log\n      */\n-    Future<LogMetadataForWriter> getLog(URI uri,\n+    CompletableFuture<LogMetadataForWriter> getLog(URI uri,\n                                         String streamName,\n                                         boolean ownAllocator,\n                                         boolean createIfNotExists);\n@@ -91,7 +91,7 @@ Future<LogMetadataForWriter> getLog(URI uri,\n      * @param streamName the name of the log stream\n      * @return future represents the result of the deletion.\n      */\n-    Future<Void> deleteLog(URI uri, String streamName);\n+    CompletableFuture<Void> deleteLog(URI uri, String streamName);\n \n     /**\n      * Get the log segment metadata store."},{"sha":"793a2c96c67784e6cd79cc21f4bb256fc3a625b7","filename":"src/main/java/org/apache/distributedlog/metadata/MetadataUpdater.java","status":"modified","additions":7,"deletions":7,"changes":14,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fmetadata%2FMetadataUpdater.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fmetadata%2FMetadataUpdater.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fmetadata%2FMetadataUpdater.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -17,11 +17,11 @@\n  */\n package org.apache.distributedlog.metadata;\n \n+import java.util.concurrent.CompletableFuture;\n import org.apache.distributedlog.DLSN;\n import org.apache.distributedlog.LogRecordWithDLSN;\n import org.apache.distributedlog.LogSegmentMetadata;\n import org.apache.distributedlog.util.Transaction;\n-import com.twitter.util.Future;\n \n /**\n  * An updater to update metadata. It contains utility functions on mutating metadata.\n@@ -44,8 +44,8 @@ public interface MetadataUpdater {\n      *          correct last record.\n      * @return new log segment\n      */\n-    Future<LogSegmentMetadata> updateLastRecord(LogSegmentMetadata segment,\n-                                                LogRecordWithDLSN record);\n+    CompletableFuture<LogSegmentMetadata> updateLastRecord(LogSegmentMetadata segment,\n+                                                           LogRecordWithDLSN record);\n \n     /**\n      * Change ledger sequence number of <i>segment</i> to given <i>logSegmentSeqNo</i>.\n@@ -56,7 +56,7 @@ Future<LogSegmentMetadata> updateLastRecord(LogSegmentMetadata segment,\n      *          ledger sequence number to change.\n      * @return new log segment\n      */\n-    Future<LogSegmentMetadata> changeSequenceNumber(LogSegmentMetadata segment,\n+    CompletableFuture<LogSegmentMetadata> changeSequenceNumber(LogSegmentMetadata segment,\n                                                     long logSegmentSeqNo);\n \n     /**\n@@ -66,7 +66,7 @@ Future<LogSegmentMetadata> changeSequenceNumber(LogSegmentMetadata segment,\n      *          log segment to change truncation status to active.\n      * @return new log segment\n      */\n-    Future<LogSegmentMetadata> setLogSegmentActive(LogSegmentMetadata segment);\n+    CompletableFuture<LogSegmentMetadata> setLogSegmentActive(LogSegmentMetadata segment);\n \n     /**\n      * Change the truncation status of a <i>log segment</i> to truncated\n@@ -75,7 +75,7 @@ Future<LogSegmentMetadata> changeSequenceNumber(LogSegmentMetadata segment,\n      *          log segment to change truncation status to truncated.\n      * @return new log segment\n      */\n-    Future<LogSegmentMetadata> setLogSegmentTruncated(LogSegmentMetadata segment);\n+    CompletableFuture<LogSegmentMetadata> setLogSegmentTruncated(LogSegmentMetadata segment);\n \n     /**\n      * Change the truncation status of a <i>log segment</i> to truncated. The operation won't be executed\n@@ -98,7 +98,7 @@ Future<LogSegmentMetadata> changeSequenceNumber(LogSegmentMetadata segment,\n      *          DLSN within the log segment before which log has been truncated\n      * @return new log segment\n      */\n-    Future<LogSegmentMetadata> setLogSegmentPartiallyTruncated(LogSegmentMetadata segment,\n+    CompletableFuture<LogSegmentMetadata> setLogSegmentPartiallyTruncated(LogSegmentMetadata segment,\n                                                                DLSN minActiveDLSN);\n \n     /**"},{"sha":"cf970ef70ce1a5dd7c0b731a5069ebe95e4acfff","filename":"src/main/java/org/apache/distributedlog/namespace/NamespaceDriver.java","status":"modified","additions":2,"deletions":3,"changes":5,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fnamespace%2FNamespaceDriver.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fnamespace%2FNamespaceDriver.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fnamespace%2FNamespaceDriver.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -18,16 +18,15 @@\n package org.apache.distributedlog.namespace;\n \n import org.apache.distributedlog.DistributedLogConfiguration;\n-import org.apache.distributedlog.MetadataAccessor;\n+import org.apache.distributedlog.api.MetadataAccessor;\n import org.apache.distributedlog.acl.AccessControlManager;\n import org.apache.distributedlog.config.DynamicDistributedLogConfiguration;\n import org.apache.distributedlog.exceptions.InvalidStreamNameException;\n import org.apache.distributedlog.injector.AsyncFailureInjector;\n import org.apache.distributedlog.logsegment.LogSegmentEntryStore;\n-import org.apache.distributedlog.logsegment.LogSegmentMetadataStore;\n import org.apache.distributedlog.metadata.LogMetadataStore;\n import org.apache.distributedlog.metadata.LogStreamMetadataStore;\n-import org.apache.distributedlog.subscription.SubscriptionsStore;\n+import org.apache.distributedlog.api.subscription.SubscriptionsStore;\n import org.apache.distributedlog.util.OrderedScheduler;\n import org.apache.bookkeeper.feature.FeatureProvider;\n import org.apache.bookkeeper.stats.StatsLogger;"},{"sha":"14db5475b13d87eec5c781d9df8f62b90c82e489","filename":"src/main/java/org/apache/distributedlog/rate/MovingAverageRate.java","status":"removed","additions":0,"deletions":24,"changes":24,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/46e6b70feda2e8ad61ba13928df93b2c94d3dd4e/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Frate%2FMovingAverageRate.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/46e6b70feda2e8ad61ba13928df93b2c94d3dd4e/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Frate%2FMovingAverageRate.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Frate%2FMovingAverageRate.java?ref=46e6b70feda2e8ad61ba13928df93b2c94d3dd4e","patch":"@@ -1,24 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.distributedlog.rate;\n-\n-public interface MovingAverageRate {\n-    double get();\n-    void add(long amount);\n-    void inc();\n-}"},{"sha":"cd33e24b5f66d8bde34a68c3e65a598d670c4cf5","filename":"src/main/java/org/apache/distributedlog/rate/MovingAverageRateFactory.java","status":"removed","additions":0,"deletions":65,"changes":65,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/46e6b70feda2e8ad61ba13928df93b2c94d3dd4e/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Frate%2FMovingAverageRateFactory.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/46e6b70feda2e8ad61ba13928df93b2c94d3dd4e/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Frate%2FMovingAverageRateFactory.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Frate%2FMovingAverageRateFactory.java?ref=46e6b70feda2e8ad61ba13928df93b2c94d3dd4e","patch":"@@ -1,65 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.distributedlog.rate;\n-\n-import com.twitter.util.Duration;\n-import com.twitter.util.Function0;\n-import com.twitter.util.TimerTask;\n-import com.twitter.util.Timer;\n-import com.twitter.util.Time;\n-import java.util.concurrent.CopyOnWriteArrayList;\n-import scala.runtime.BoxedUnit;\n-\n-public class MovingAverageRateFactory {\n-\n-    private static final int DEFAULT_INTERVAL_SECS = 1;\n-\n-    private final Timer timer;\n-    private final TimerTask timerTask;\n-    private final CopyOnWriteArrayList<SampledMovingAverageRate> avgs;\n-\n-    public MovingAverageRateFactory(Timer timer) {\n-        this.avgs = new CopyOnWriteArrayList<SampledMovingAverageRate>();\n-        this.timer = timer;\n-        Function0<BoxedUnit> sampleTask = new Function0<BoxedUnit>() {\n-            public BoxedUnit apply() {\n-                sampleAll();\n-                return null;\n-            }\n-        };\n-        this.timerTask = timer.schedulePeriodically(\n-            Time.now(), Duration.fromSeconds(DEFAULT_INTERVAL_SECS), sampleTask);\n-    }\n-\n-    public MovingAverageRate create(int intervalSecs) {\n-        SampledMovingAverageRate avg = new SampledMovingAverageRate(intervalSecs);\n-        avgs.add(avg);\n-        return avg;\n-    }\n-\n-    public void close() {\n-        timerTask.cancel();\n-        avgs.clear();\n-    }\n-\n-    private void sampleAll() {\n-        for (SampledMovingAverageRate avg : avgs) {\n-            avg.sample();\n-        }\n-    }\n-}"},{"sha":"0b3ccac08b9ed8acda594a14da2685a8c45e086a","filename":"src/main/java/org/apache/distributedlog/rate/SampledMovingAverageRate.java","status":"removed","additions":0,"deletions":58,"changes":58,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/46e6b70feda2e8ad61ba13928df93b2c94d3dd4e/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Frate%2FSampledMovingAverageRate.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/46e6b70feda2e8ad61ba13928df93b2c94d3dd4e/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Frate%2FSampledMovingAverageRate.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Frate%2FSampledMovingAverageRate.java?ref=46e6b70feda2e8ad61ba13928df93b2c94d3dd4e","patch":"@@ -1,58 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.distributedlog.rate;\n-\n-import com.twitter.common.stats.Rate;\n-import com.twitter.util.TimerTask;\n-import com.twitter.util.Timer;\n-import com.twitter.util.Time;\n-import java.util.concurrent.atomic.AtomicLong;\n-\n-class SampledMovingAverageRate implements MovingAverageRate {\n-    private final Rate rate;\n-    private final AtomicLong total;\n-\n-    private double value;\n-\n-    public SampledMovingAverageRate(int intervalSecs) {\n-        this.total = new AtomicLong(0);\n-        this.rate = Rate.of(\"Ignore\", total)\n-            .withWindowSize(intervalSecs)\n-            .build();\n-        this.value = 0;\n-    }\n-\n-    @Override\n-    public double get() {\n-        return value;\n-    }\n-\n-    @Override\n-    public void add(long amount) {\n-        total.getAndAdd(amount);\n-    }\n-\n-    @Override\n-    public void inc() {\n-        add(1);\n-    }\n-\n-    void sample() {\n-        value = rate.doSample();\n-    }\n-}"},{"sha":"d81f8a492bfe407bd4e3f777c733c7ea43f3f5fc","filename":"src/main/java/org/apache/distributedlog/readahead/package-info.java","status":"removed","additions":0,"deletions":21,"changes":21,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/46e6b70feda2e8ad61ba13928df93b2c94d3dd4e/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Freadahead%2Fpackage-info.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/46e6b70feda2e8ad61ba13928df93b2c94d3dd4e/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Freadahead%2Fpackage-info.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Freadahead%2Fpackage-info.java?ref=46e6b70feda2e8ad61ba13928df93b2c94d3dd4e","patch":"@@ -1,21 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-/**\n- * ReadAhead Mechanism for distributedlog streaming reads\n- */\n-package org.apache.distributedlog.readahead;"},{"sha":"199aa4c3fc764e9535d2e484e14d233dfa3eb29b","filename":"src/main/java/org/apache/distributedlog/stats/BKExceptionStatsLogger.java","status":"removed","additions":0,"deletions":109,"changes":109,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/46e6b70feda2e8ad61ba13928df93b2c94d3dd4e/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fstats%2FBKExceptionStatsLogger.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/46e6b70feda2e8ad61ba13928df93b2c94d3dd4e/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fstats%2FBKExceptionStatsLogger.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fstats%2FBKExceptionStatsLogger.java?ref=46e6b70feda2e8ad61ba13928df93b2c94d3dd4e","patch":"@@ -1,109 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.distributedlog.stats;\n-\n-import org.apache.bookkeeper.client.BKException.Code;\n-import org.apache.bookkeeper.stats.Counter;\n-import org.apache.bookkeeper.stats.StatsLogger;\n-\n-import java.util.HashMap;\n-import java.util.Map;\n-\n-/**\n- * A Util to logger stats on bk exceptions.\n- */\n-public class BKExceptionStatsLogger {\n-\n-    public static String getMessage(int code) {\n-        switch (code) {\n-            case Code.OK:\n-                return \"OK\";\n-            case Code.ReadException:\n-                return \"ReadException\";\n-            case Code.QuorumException:\n-                return \"QuorumException\";\n-            case Code.NoBookieAvailableException:\n-                return \"NoBookieAvailableException\";\n-            case Code.DigestNotInitializedException:\n-                return \"DigestNotInitializedException\";\n-            case Code.DigestMatchException:\n-                return \"DigestMatchException\";\n-            case Code.NotEnoughBookiesException:\n-                return \"NotEnoughBookiesException\";\n-            case Code.NoSuchLedgerExistsException:\n-                return \"NoSuchLedgerExistsException\";\n-            case Code.BookieHandleNotAvailableException:\n-                return \"BookieHandleNotAvailableException\";\n-            case Code.ZKException:\n-                return \"ZKException\";\n-            case Code.LedgerRecoveryException:\n-                return \"LedgerRecoveryException\";\n-            case Code.LedgerClosedException:\n-                return \"LedgerClosedException\";\n-            case Code.WriteException:\n-                return \"WriteException\";\n-            case Code.NoSuchEntryException:\n-                return \"NoSuchEntryException\";\n-            case Code.IncorrectParameterException:\n-                return \"IncorrectParameterException\";\n-            case Code.InterruptedException:\n-                return \"InterruptedException\";\n-            case Code.ProtocolVersionException:\n-                return \"ProtocolVersionException\";\n-            case Code.MetadataVersionException:\n-                return \"MetadataVersionException\";\n-            case Code.LedgerFencedException:\n-                return \"LedgerFencedException\";\n-            case Code.UnauthorizedAccessException:\n-                return \"UnauthorizedAccessException\";\n-            case Code.UnclosedFragmentException:\n-                return \"UnclosedFragmentException\";\n-            case Code.WriteOnReadOnlyBookieException:\n-                return \"WriteOnReadOnlyBookieException\";\n-            case Code.IllegalOpException:\n-                return \"IllegalOpException\";\n-            default:\n-                return \"UnexpectedException\";\n-        }\n-    }\n-\n-    private final StatsLogger parentLogger;\n-    private final Map<Integer, Counter> exceptionCounters;\n-\n-    public BKExceptionStatsLogger(StatsLogger parentLogger) {\n-        this.parentLogger = parentLogger;\n-        this.exceptionCounters = new HashMap<Integer, Counter>();\n-    }\n-\n-    public Counter getExceptionCounter(int rc) {\n-        Counter counter = exceptionCounters.get(rc);\n-        if (null != counter) {\n-            return counter;\n-        }\n-        // TODO: it would be better to have BKException.Code.get(rc)\n-        synchronized (exceptionCounters) {\n-            counter = exceptionCounters.get(rc);\n-            if (null != counter) {\n-                return counter;\n-            }\n-            counter = parentLogger.getCounter(getMessage(rc));\n-            exceptionCounters.put(rc, counter);\n-        }\n-        return counter;\n-    }\n-}"},{"sha":"b6ca7334ba5ca1659a1d820d9df726025aa015d7","filename":"src/main/java/org/apache/distributedlog/stats/BroadCastStatsLogger.java","status":"removed","additions":0,"deletions":194,"changes":194,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/46e6b70feda2e8ad61ba13928df93b2c94d3dd4e/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fstats%2FBroadCastStatsLogger.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/46e6b70feda2e8ad61ba13928df93b2c94d3dd4e/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fstats%2FBroadCastStatsLogger.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fstats%2FBroadCastStatsLogger.java?ref=46e6b70feda2e8ad61ba13928df93b2c94d3dd4e","patch":"@@ -1,194 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.distributedlog.stats;\n-\n-import com.google.common.base.Preconditions;\n-\n-import org.apache.bookkeeper.stats.CachingStatsLogger;\n-import org.apache.bookkeeper.stats.Counter;\n-import org.apache.bookkeeper.stats.Gauge;\n-import org.apache.bookkeeper.stats.OpStatsData;\n-import org.apache.bookkeeper.stats.OpStatsLogger;\n-import org.apache.bookkeeper.stats.StatsLogger;\n-\n-/**\n- * Stats Loggers that broadcast stats to multiple {@link StatsLogger}.\n- */\n-public class BroadCastStatsLogger {\n-\n-    /**\n-     * Create a broadcast stats logger of two stats loggers `<code>first</code>` and\n-     * `<code>second</code>`. The returned stats logger doesn't allow registering any\n-     * {@link Gauge}.\n-     *\n-     * @param first\n-     *          first stats logger\n-     * @param second\n-     *          second stats logger\n-     * @return broadcast stats logger\n-     */\n-    public static StatsLogger two(StatsLogger first, StatsLogger second) {\n-        return new CachingStatsLogger(new Two(first, second));\n-    }\n-\n-    static class Two implements StatsLogger {\n-        protected final StatsLogger first;\n-        protected final StatsLogger second;\n-\n-        private Two(StatsLogger first, StatsLogger second) {\n-            super();\n-            Preconditions.checkNotNull(first);\n-            Preconditions.checkNotNull(second);\n-            this.first = first;\n-            this.second = second;\n-        }\n-\n-        @Override\n-        public OpStatsLogger getOpStatsLogger(final String statName) {\n-            final OpStatsLogger firstLogger = first.getOpStatsLogger(statName);\n-            final OpStatsLogger secondLogger = second.getOpStatsLogger(statName);\n-            return new OpStatsLogger() {\n-                @Override\n-                public void registerFailedEvent(long l) {\n-                    firstLogger.registerFailedEvent(l);\n-                    secondLogger.registerFailedEvent(l);\n-                }\n-\n-                @Override\n-                public void registerSuccessfulEvent(long l) {\n-                    firstLogger.registerSuccessfulEvent(l);\n-                    secondLogger.registerSuccessfulEvent(l);\n-                }\n-\n-                @Override\n-                public OpStatsData toOpStatsData() {\n-                    // Eventually consistent.\n-                    return firstLogger.toOpStatsData();\n-                }\n-\n-                @Override\n-                public void clear() {\n-                    firstLogger.clear();\n-                    secondLogger.clear();\n-                }\n-            };\n-        }\n-\n-        @Override\n-        public Counter getCounter(final String statName) {\n-            final Counter firstCounter = first.getCounter(statName);\n-            final Counter secondCounter = second.getCounter(statName);\n-            return new Counter() {\n-                @Override\n-                public void clear() {\n-                    firstCounter.clear();\n-                    secondCounter.clear();\n-                }\n-\n-                @Override\n-                public void inc() {\n-                    firstCounter.inc();\n-                    secondCounter.inc();\n-                }\n-\n-                @Override\n-                public void dec() {\n-                    firstCounter.dec();\n-                    secondCounter.dec();\n-                }\n-\n-                @Override\n-                public void add(long l) {\n-                    firstCounter.add(l);\n-                    secondCounter.add(l);\n-                }\n-\n-                @Override\n-                public Long get() {\n-                    // Eventually consistent.\n-                    return firstCounter.get();\n-                }\n-            };\n-        }\n-\n-        @Override\n-        public <T extends Number> void registerGauge(String statName, Gauge<T> gauge) {\n-            // Different underlying stats loggers have different semantics wrt. gauge registration.\n-            throw new RuntimeException(\"Cannot register a gauge on BroadCastStatsLogger.Two\");\n-        }\n-\n-        @Override\n-        public <T extends Number> void unregisterGauge(String statName, Gauge<T> gauge) {\n-            // no-op\n-        }\n-\n-        @Override\n-        public StatsLogger scope(final String scope) {\n-            return new Two(first.scope(scope), second.scope(scope));\n-        }\n-\n-        @Override\n-        public void removeScope(String scope, StatsLogger statsLogger) {\n-            if (!(statsLogger instanceof Two)) {\n-                return;\n-            }\n-\n-            Two another = (Two) statsLogger;\n-\n-            first.removeScope(scope, another.first);\n-            second.removeScope(scope, another.second);\n-        }\n-    }\n-\n-    /**\n-     * Create a broadcast stats logger of two stats loggers <code>master</code> and <code>slave</code>.\n-     * It is similar as {@link #two(StatsLogger, StatsLogger)}, but it allows registering {@link Gauge}s.\n-     * The {@link Gauge} will be registered under master.\n-     *\n-     * @param master\n-     *          master stats logger to receive {@link Counter}, {@link OpStatsLogger} and {@link Gauge}.\n-     * @param slave\n-     *          slave stats logger to receive only {@link Counter} and {@link OpStatsLogger}.\n-     * @return broadcast stats logger\n-     */\n-    public static StatsLogger masterslave(StatsLogger master, StatsLogger slave) {\n-        return new CachingStatsLogger(new MasterSlave(master, slave));\n-    }\n-\n-    static class MasterSlave extends Two {\n-\n-        private MasterSlave(StatsLogger master, StatsLogger slave) {\n-            super(master, slave);\n-        }\n-\n-        @Override\n-        public <T extends Number> void registerGauge(String statName, Gauge<T> gauge) {\n-            first.registerGauge(statName, gauge);\n-        }\n-\n-        @Override\n-        public <T extends Number> void unregisterGauge(String statName, Gauge<T> gauge) {\n-            first.unregisterGauge(statName, gauge);\n-        }\n-\n-        @Override\n-        public StatsLogger scope(String scope) {\n-            return new MasterSlave(first.scope(scope), second.scope(scope));\n-        }\n-    }\n-}"},{"sha":"43641f0d1d4b127e47be25f72e4bd09f338bb32a","filename":"src/main/java/org/apache/distributedlog/stats/OpStatsListener.java","status":"removed","additions":0,"deletions":51,"changes":51,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/46e6b70feda2e8ad61ba13928df93b2c94d3dd4e/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fstats%2FOpStatsListener.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/46e6b70feda2e8ad61ba13928df93b2c94d3dd4e/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fstats%2FOpStatsListener.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fstats%2FOpStatsListener.java?ref=46e6b70feda2e8ad61ba13928df93b2c94d3dd4e","patch":"@@ -1,51 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.distributedlog.stats;\n-\n-import com.google.common.base.Stopwatch;\n-import com.twitter.util.FutureEventListener;\n-import org.apache.bookkeeper.stats.OpStatsLogger;\n-import java.util.concurrent.TimeUnit;\n-\n-public class OpStatsListener<T> implements FutureEventListener<T> {\n-    OpStatsLogger opStatsLogger;\n-    Stopwatch stopwatch;\n-\n-    public OpStatsListener(OpStatsLogger opStatsLogger, Stopwatch stopwatch) {\n-        this.opStatsLogger = opStatsLogger;\n-        if (null == stopwatch) {\n-            this.stopwatch = Stopwatch.createStarted();\n-        } else {\n-            this.stopwatch = stopwatch;\n-        }\n-    }\n-\n-    public OpStatsListener(OpStatsLogger opStatsLogger) {\n-        this(opStatsLogger, null);\n-    }\n-\n-    @Override\n-    public void onSuccess(T value) {\n-        opStatsLogger.registerSuccessfulEvent(stopwatch.elapsed(TimeUnit.MICROSECONDS));\n-    }\n-\n-    @Override\n-    public void onFailure(Throwable cause) {\n-        opStatsLogger.registerFailedEvent(stopwatch.elapsed(TimeUnit.MICROSECONDS));\n-    }\n-}"},{"sha":"ffe2303a0c22418687a29cf6fc31449932b34612","filename":"src/main/java/org/apache/distributedlog/thrift/package-info.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fthrift%2Fpackage-info.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fthrift%2Fpackage-info.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fthrift%2Fpackage-info.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -18,4 +18,4 @@\n /**\n  * Generated thrift code.\n  */\n-package org.apache.distributedlog.thrift;\n\\ No newline at end of file\n+package org.apache.distributedlog.thrift;"},{"sha":"64229d1eea876d78feb74f6292b060c8178f41b6","filename":"src/main/java/org/apache/distributedlog/tools/DistributedLogTool.java","status":"modified","additions":28,"deletions":28,"changes":56,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Ftools%2FDistributedLogTool.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Ftools%2FDistributedLogTool.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Ftools%2FDistributedLogTool.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -55,13 +55,15 @@\n import com.google.common.base.Preconditions;\n import org.apache.distributedlog.BKDistributedLogNamespace;\n import org.apache.distributedlog.Entry;\n-import org.apache.distributedlog.MetadataAccessor;\n+import org.apache.distributedlog.api.MetadataAccessor;\n+import org.apache.distributedlog.api.namespace.Namespace;\n import org.apache.distributedlog.callback.NamespaceListener;\n import org.apache.distributedlog.impl.BKNamespaceDriver;\n import org.apache.distributedlog.logsegment.LogSegmentMetadataStore;\n-import org.apache.distributedlog.namespace.DistributedLogNamespace;\n-import org.apache.distributedlog.namespace.DistributedLogNamespaceBuilder;\n+import org.apache.distributedlog.api.namespace.NamespaceBuilder;\n import org.apache.distributedlog.namespace.NamespaceDriver;\n+import org.apache.distributedlog.common.concurrent.FutureEventListener;\n+import org.apache.distributedlog.common.concurrent.FutureUtils;\n import org.apache.distributedlog.util.Utils;\n import org.apache.bookkeeper.client.BKException;\n import org.apache.bookkeeper.client.BookKeeper;\n@@ -86,16 +88,16 @@\n import com.google.common.collect.Lists;\n import com.google.common.collect.Sets;\n import com.google.common.util.concurrent.RateLimiter;\n-import org.apache.distributedlog.AsyncLogReader;\n-import org.apache.distributedlog.AsyncLogWriter;\n+import org.apache.distributedlog.api.AsyncLogReader;\n+import org.apache.distributedlog.api.AsyncLogWriter;\n import org.apache.distributedlog.BookKeeperClient;\n import org.apache.distributedlog.BookKeeperClientBuilder;\n import org.apache.distributedlog.DLSN;\n import org.apache.distributedlog.DistributedLogConfiguration;\n import org.apache.distributedlog.DistributedLogConstants;\n-import org.apache.distributedlog.DistributedLogManager;\n+import org.apache.distributedlog.api.DistributedLogManager;\n import org.apache.distributedlog.exceptions.LogNotFoundException;\n-import org.apache.distributedlog.LogReader;\n+import org.apache.distributedlog.api.LogReader;\n import org.apache.distributedlog.LogRecord;\n import org.apache.distributedlog.LogRecordWithDLSN;\n import org.apache.distributedlog.LogSegmentMetadata;\n@@ -107,9 +109,7 @@\n import org.apache.distributedlog.impl.metadata.BKDLConfig;\n import org.apache.distributedlog.metadata.MetadataUpdater;\n import org.apache.distributedlog.metadata.LogSegmentMetadataStoreUpdater;\n-import org.apache.distributedlog.util.SchedulerUtils;\n-import com.twitter.util.Await;\n-import com.twitter.util.FutureEventListener;\n+import org.apache.distributedlog.common.util.SchedulerUtils;\n \n import static com.google.common.base.Charsets.UTF_8;\n \n@@ -163,7 +163,7 @@ protected abstract static class PerDLCommand extends OptsCommand {\n         protected URI uri;\n         protected String zkAclId = null;\n         protected boolean force = false;\n-        protected DistributedLogNamespace namespace = null;\n+        protected Namespace namespace = null;\n \n         protected PerDLCommand(String name, String description) {\n             super(name, description);\n@@ -252,9 +252,9 @@ protected void setForce(boolean force) {\n             this.force = force;\n         }\n \n-        protected DistributedLogNamespace getNamespace() throws IOException {\n+        protected Namespace getNamespace() throws IOException {\n             if (null == this.namespace) {\n-                this.namespace = DistributedLogNamespaceBuilder.newBuilder()\n+                this.namespace = NamespaceBuilder.newBuilder()\n                         .uri(getUri())\n                         .conf(getConf())\n                         .build();\n@@ -464,7 +464,7 @@ protected int runCmd() throws Exception {\n             return 0;\n         }\n \n-        protected void printStreams(DistributedLogNamespace namespace) throws Exception {\n+        protected void printStreams(Namespace namespace) throws Exception {\n             Iterator<String> streams = namespace.getLogs();\n             System.out.println(\"Streams under \" + getUri() + \" : \");\n             System.out.println(\"--------------------------------\");\n@@ -536,7 +536,7 @@ public synchronized void onStreamsChanged(Iterator<String> streams) {\n             System.out.println(\"\");\n         }\n \n-        protected void watchAndReportChanges(DistributedLogNamespace namespace) throws Exception {\n+        protected void watchAndReportChanges(Namespace namespace) throws Exception {\n             namespace.registerNamespaceListener(this);\n         }\n     }\n@@ -783,7 +783,7 @@ protected int runCmd() throws Exception {\n             return truncateStreams(getNamespace());\n         }\n \n-        private int truncateStreams(final DistributedLogNamespace namespace) throws Exception {\n+        private int truncateStreams(final Namespace namespace) throws Exception {\n             Iterator<String> streamCollection = namespace.getLogs();\n             final List<String> streams = new ArrayList<String>();\n             while (streamCollection.hasNext()) {\n@@ -827,7 +827,7 @@ public void run() {\n             return 0;\n         }\n \n-        private void truncateStreams(DistributedLogNamespace namespace, List<String> streams,\n+        private void truncateStreams(Namespace namespace, List<String> streams,\n                                      int tid, int numStreamsPerThreads) throws IOException {\n             int startIdx = tid * numStreamsPerThreads;\n             int endIdx = Math.min(streams.size(), (tid + 1) * numStreamsPerThreads);\n@@ -957,7 +957,7 @@ private void printMetadata(DistributedLogManager dlm) throws Exception {\n         }\n \n         private void printHeader(DistributedLogManager dlm) throws Exception {\n-            DLSN firstDlsn = Await.result(dlm.getFirstDLSNAsync());\n+            DLSN firstDlsn = FutureUtils.result(dlm.getFirstDLSNAsync());\n             boolean endOfStreamMarked = dlm.isEndOfStreamMarked();\n             DLSN lastDlsn = dlm.getLastDLSN();\n             long firstTxnId = dlm.getFirstTxId();\n@@ -1121,7 +1121,7 @@ int countFromStartToEnd(DistributedLogManager dlm) throws Exception {\n         }\n \n         long countToLastRecord(DistributedLogManager dlm) throws Exception {\n-            return Await.result(dlm.getLogRecordCountAsync(startDLSN)).longValue();\n+            return FutureUtils.result(dlm.getLogRecordCountAsync(startDLSN)).longValue();\n         }\n \n         @Override\n@@ -1439,7 +1439,7 @@ protected int runCmd() throws Exception {\n                 AsyncLogReader reader;\n                 Object startOffset;\n                 try {\n-                    DLSN lastDLSN = Await.result(dlm.getLastDLSNAsync());\n+                    DLSN lastDLSN = FutureUtils.result(dlm.getLastDLSNAsync());\n                     System.out.println(\"Last DLSN : \" + lastDLSN);\n                     if (null == fromDLSN) {\n                         reader = dlm.getAsyncLogReader(fromTxnId);\n@@ -1468,15 +1468,15 @@ protected int runCmd() throws Exception {\n \n         private void dumpRecords(AsyncLogReader reader) throws Exception {\n             int numRead = 0;\n-            LogRecord record = Await.result(reader.readNext());\n+            LogRecord record = FutureUtils.result(reader.readNext());\n             while (record != null) {\n                 // dump the record\n                 dumpRecord(record);\n                 ++numRead;\n                 if (numRead >= count) {\n                     break;\n                 }\n-                record = Await.result(reader.readNext());\n+                record = FutureUtils.result(reader.readNext());\n             }\n             if (numRead == 0) {\n                 System.out.println(\"No records.\");\n@@ -2641,18 +2641,18 @@ protected int runCmd() throws Exception {\n             return truncateStream(getNamespace(), getStreamName(), dlsn);\n         }\n \n-        private int truncateStream(final DistributedLogNamespace namespace, String streamName, DLSN dlsn) throws Exception {\n+        private int truncateStream(final Namespace namespace, String streamName, DLSN dlsn) throws Exception {\n             DistributedLogManager dlm = namespace.openLog(streamName);\n             try {\n                 long totalRecords = dlm.getLogRecordCount();\n-                long recordsAfterTruncate = Await.result(dlm.getLogRecordCountAsync(dlsn));\n+                long recordsAfterTruncate = FutureUtils.result(dlm.getLogRecordCountAsync(dlsn));\n                 long recordsToTruncate = totalRecords - recordsAfterTruncate;\n                 if (!getForce() && !IOUtils.confirmPrompt(\"Do you want to truncate \" + streamName + \" at dlsn \" + dlsn + \" (\" + recordsToTruncate + \" records)?\")) {\n                     return 0;\n                 } else {\n                     AsyncLogWriter writer = dlm.startAsyncLogSegmentNonPartitioned();\n                     try {\n-                        if (!Await.result(writer.truncate(dlsn))) {\n+                        if (!FutureUtils.result(writer.truncate(dlsn))) {\n                             System.out.println(\"Failed to truncate.\");\n                         }\n                         return 0;\n@@ -2764,7 +2764,7 @@ protected int runCmd() throws Exception {\n             return deleteSubscriber(getNamespace());\n         }\n \n-        private int deleteSubscriber(final DistributedLogNamespace namespace) throws Exception {\n+        private int deleteSubscriber(final Namespace namespace) throws Exception {\n             Iterator<String> streamCollection = namespace.getLogs();\n             final List<String> streams = new ArrayList<String>();\n             while (streamCollection.hasNext()) {\n@@ -2809,7 +2809,7 @@ public void run() {\n             return 0;\n         }\n \n-        private void deleteSubscriber(DistributedLogNamespace namespace, List<String> streams,\n+        private void deleteSubscriber(Namespace namespace, List<String> streams,\n                                       int tid, int numStreamsPerThreads) throws Exception {\n             int startIdx = tid * numStreamsPerThreads;\n             int endIdx = Math.min(streams.size(), (tid + 1) * numStreamsPerThreads);\n@@ -2818,7 +2818,7 @@ private void deleteSubscriber(DistributedLogNamespace namespace, List<String> st\n                 DistributedLogManager dlm = namespace.openLog(s);\n                 final CountDownLatch countDownLatch = new CountDownLatch(1);\n                 dlm.getSubscriptionsStore().deleteSubscriber(subscriberId)\n-                    .addEventListener(new FutureEventListener<Boolean>() {\n+                    .whenComplete(new FutureEventListener<Boolean>() {\n                         @Override\n                         public void onFailure(Throwable cause) {\n                             System.out.println(\"Failed to delete subscriber for stream \" + s);"},{"sha":"a9b81e2675fb01fabb862170712c136bebcf3ce8","filename":"src/main/java/org/apache/distributedlog/util/Allocator.java","status":"modified","additions":4,"deletions":5,"changes":9,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Futil%2FAllocator.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Futil%2FAllocator.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Futil%2FAllocator.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -17,12 +17,11 @@\n  */\n package org.apache.distributedlog.util;\n \n+import java.io.IOException;\n+import java.util.concurrent.CompletableFuture;\n import org.apache.distributedlog.io.AsyncCloseable;\n import org.apache.distributedlog.io.AsyncDeleteable;\n import org.apache.distributedlog.util.Transaction.OpListener;\n-import com.twitter.util.Future;\n-\n-import java.io.IOException;\n \n /**\n  * A common interface to allocate <i>I</i> under transaction <i>T</i>.\n@@ -47,7 +46,7 @@\n  * final Transaction<T> txn = ...;\n  *\n  * // Try obtain object I\n- * Future<I> tryObtainFuture = allocator.tryObtain(txn, new OpListener<I>() {\n+ * CompletableFuture<I> tryObtainFuture = allocator.tryObtain(txn, new OpListener<I>() {\n  *     public void onCommit(I resource) {\n  *         // the obtain succeed, process with the resource\n  *     }\n@@ -97,6 +96,6 @@\n      *          transaction.\n      * @return future result returning <i>I</i> that would be obtained under transaction <code>txn</code>.\n      */\n-    Future<I> tryObtain(Transaction<T> txn, OpListener<I> listener);\n+    CompletableFuture<I> tryObtain(Transaction<T> txn, OpListener<I> listener);\n \n }"},{"sha":"aa7cefe8a82a4e879176a132256a27f0c1e407d9","filename":"src/main/java/org/apache/distributedlog/util/ConfUtils.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Futil%2FConfUtils.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Futil%2FConfUtils.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Futil%2FConfUtils.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -18,7 +18,7 @@\n package org.apache.distributedlog.util;\n \n import org.apache.distributedlog.DistributedLogConfiguration;\n-import org.apache.distributedlog.config.ConcurrentConstConfiguration;\n+import org.apache.distributedlog.common.config.ConcurrentConstConfiguration;\n import org.apache.distributedlog.config.DynamicDistributedLogConfiguration;\n import org.apache.commons.configuration.Configuration;\n "},{"sha":"8e4a8be688414eed8bfb60c79849392100e697e3","filename":"src/main/java/org/apache/distributedlog/util/FutureUtils.java","status":"removed","additions":0,"deletions":534,"changes":534,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/46e6b70feda2e8ad61ba13928df93b2c94d3dd4e/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Futil%2FFutureUtils.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/46e6b70feda2e8ad61ba13928df93b2c94d3dd4e/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Futil%2FFutureUtils.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Futil%2FFutureUtils.java?ref=46e6b70feda2e8ad61ba13928df93b2c94d3dd4e","patch":"@@ -1,534 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.distributedlog.util;\n-\n-import com.google.common.base.Stopwatch;\n-import org.apache.distributedlog.DistributedLogConstants;\n-import org.apache.distributedlog.exceptions.BKTransmitException;\n-import org.apache.distributedlog.exceptions.LockingException;\n-import org.apache.distributedlog.ZooKeeperClient;\n-import org.apache.distributedlog.exceptions.DLInterruptedException;\n-import org.apache.distributedlog.exceptions.UnexpectedException;\n-import org.apache.distributedlog.exceptions.ZKException;\n-import org.apache.distributedlog.stats.OpStatsListener;\n-import com.twitter.util.Await;\n-import com.twitter.util.Duration;\n-import com.twitter.util.Function;\n-import com.twitter.util.Future;\n-import com.twitter.util.FutureCancelledException;\n-import com.twitter.util.FutureEventListener;\n-import com.twitter.util.Promise;\n-import com.twitter.util.Return;\n-import com.twitter.util.Throw;\n-import com.twitter.util.Try;\n-import org.apache.bookkeeper.client.BKException;\n-import org.apache.bookkeeper.stats.OpStatsLogger;\n-import org.apache.zookeeper.KeeperException;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-import scala.runtime.AbstractFunction1;\n-import scala.runtime.BoxedUnit;\n-\n-import javax.annotation.Nullable;\n-import java.io.IOException;\n-import java.util.ArrayList;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.TimeUnit;\n-\n-/**\n- * Utilities to process future\n- */\n-public class FutureUtils {\n-\n-    private static final Logger logger = LoggerFactory.getLogger(FutureUtils.class);\n-\n-    public static class OrderedFutureEventListener<R>\n-            implements FutureEventListener<R> {\n-\n-        public static <R> OrderedFutureEventListener<R> of(\n-                FutureEventListener<R> listener,\n-                OrderedScheduler scheduler,\n-                Object key) {\n-            return new OrderedFutureEventListener<R>(scheduler, key, listener);\n-        }\n-\n-        private final OrderedScheduler scheduler;\n-        private final Object key;\n-        private final FutureEventListener<R> listener;\n-\n-        private OrderedFutureEventListener(OrderedScheduler scheduler,\n-                                           Object key,\n-                                           FutureEventListener<R> listener) {\n-            this.scheduler = scheduler;\n-            this.key = key;\n-            this.listener = listener;\n-        }\n-\n-        @Override\n-        public void onSuccess(final R value) {\n-            scheduler.submit(key, new Runnable() {\n-                @Override\n-                public void run() {\n-                    listener.onSuccess(value);\n-                }\n-            });\n-        }\n-\n-        @Override\n-        public void onFailure(final Throwable cause) {\n-            scheduler.submit(key, new Runnable() {\n-                @Override\n-                public void run() {\n-                    listener.onFailure(cause);\n-                }\n-            });\n-        }\n-    }\n-\n-    public static class FutureEventListenerRunnable<R>\n-            implements FutureEventListener<R> {\n-\n-        public static <R> FutureEventListenerRunnable<R> of(\n-                FutureEventListener<R> listener,\n-                ExecutorService executorService) {\n-            return new FutureEventListenerRunnable<R>(executorService, listener);\n-        }\n-\n-        private final ExecutorService executorService;\n-        private final FutureEventListener<R> listener;\n-\n-        private FutureEventListenerRunnable(ExecutorService executorService,\n-                                            FutureEventListener<R> listener) {\n-            this.executorService = executorService;\n-            this.listener = listener;\n-        }\n-\n-        @Override\n-        public void onSuccess(final R value) {\n-            executorService.submit(new Runnable() {\n-                @Override\n-                public void run() {\n-                    listener.onSuccess(value);\n-                }\n-            });\n-        }\n-\n-        @Override\n-        public void onFailure(final Throwable cause) {\n-            executorService.submit(new Runnable() {\n-                @Override\n-                public void run() {\n-                    listener.onFailure(cause);\n-                }\n-            });\n-        }\n-    }\n-\n-    private static class ListFutureProcessor<T, R>\n-            extends Function<Throwable, BoxedUnit>\n-            implements FutureEventListener<R>, Runnable {\n-\n-        private volatile boolean interrupted = false;\n-        private final Iterator<T> itemsIter;\n-        private final Function<T, Future<R>> processFunc;\n-        private final Promise<List<R>> promise;\n-        private final List<R> results;\n-        private final ExecutorService callbackExecutor;\n-\n-        ListFutureProcessor(List<T> items,\n-                            Function<T, Future<R>> processFunc,\n-                            ExecutorService callbackExecutor) {\n-            this.itemsIter = items.iterator();\n-            this.processFunc = processFunc;\n-            this.promise = new Promise<List<R>>();\n-            this.promise.setInterruptHandler(this);\n-            this.results = new ArrayList<R>();\n-            this.callbackExecutor = callbackExecutor;\n-        }\n-\n-        @Override\n-        public BoxedUnit apply(Throwable cause) {\n-            interrupted = true;\n-            return BoxedUnit.UNIT;\n-        }\n-\n-        @Override\n-        public void onSuccess(R value) {\n-            results.add(value);\n-            if (null == callbackExecutor) {\n-                run();\n-            } else {\n-                callbackExecutor.submit(this);\n-            }\n-        }\n-\n-        @Override\n-        public void onFailure(final Throwable cause) {\n-            if (null == callbackExecutor) {\n-                promise.setException(cause);\n-            } else {\n-                callbackExecutor.submit(new Runnable() {\n-                    @Override\n-                    public void run() {\n-                        promise.setException(cause);\n-                    }\n-                });\n-            }\n-        }\n-\n-        @Override\n-        public void run() {\n-            if (interrupted) {\n-                logger.debug(\"ListFutureProcessor is interrupted.\");\n-                return;\n-            }\n-            if (!itemsIter.hasNext()) {\n-                promise.setValue(results);\n-                return;\n-            }\n-            processFunc.apply(itemsIter.next()).addEventListener(this);\n-        }\n-    }\n-\n-    /**\n-     * Process the list of items one by one using the process function <i>processFunc</i>.\n-     * The process will be stopped immediately if it fails on processing any one.\n-     *\n-     * @param collection list of items\n-     * @param processFunc process function\n-     * @param callbackExecutor executor to process the item\n-     * @return future presents the list of processed results\n-     */\n-    public static <T, R> Future<List<R>> processList(List<T> collection,\n-                                                     Function<T, Future<R>> processFunc,\n-                                                     @Nullable ExecutorService callbackExecutor) {\n-        ListFutureProcessor<T, R> processor =\n-                new ListFutureProcessor<T, R>(collection, processFunc, callbackExecutor);\n-        if (null != callbackExecutor) {\n-            callbackExecutor.submit(processor);\n-        } else {\n-            processor.run();\n-        }\n-        return processor.promise;\n-    }\n-\n-    /**\n-     * Add a event listener over <i>result</i> for collecting the operation stats.\n-     *\n-     * @param result result to listen on\n-     * @param opStatsLogger stats logger to record operations stats\n-     * @param stopwatch stop watch to time operation\n-     * @param <T>\n-     * @return result after registered the event listener\n-     */\n-    public static <T> Future<T> stats(Future<T> result,\n-                                      OpStatsLogger opStatsLogger,\n-                                      Stopwatch stopwatch) {\n-        return result.addEventListener(new OpStatsListener<T>(opStatsLogger, stopwatch));\n-    }\n-\n-    /**\n-     * Await for the result of the future and thrown bk related exceptions.\n-     *\n-     * @param result future to wait for\n-     * @return the result of future\n-     * @throws BKException when exceptions are thrown by the future. If there is unkown exceptions\n-     *         thrown from the future, the exceptions will be wrapped into\n-     *         {@link org.apache.bookkeeper.client.BKException.BKUnexpectedConditionException}.\n-     */\n-    public static <T> T bkResult(Future<T> result) throws BKException {\n-        try {\n-            return Await.result(result);\n-        } catch (BKException bke) {\n-            throw bke;\n-        } catch (InterruptedException ie) {\n-            throw BKException.create(BKException.Code.InterruptedException);\n-        } catch (Exception e) {\n-            logger.warn(\"Encountered unexpected exception on waiting bookkeeper results : \", e);\n-            throw BKException.create(BKException.Code.UnexpectedConditionException);\n-        }\n-    }\n-\n-    /**\n-     * Return the bk exception return code for a <i>throwable</i>.\n-     *\n-     * @param throwable the cause of the exception\n-     * @return the bk exception return code. if the exception isn't bk exceptions,\n-     *         it would return {@link BKException.Code#UnexpectedConditionException}.\n-     */\n-    public static int bkResultCode(Throwable throwable) {\n-        if (throwable instanceof BKException) {\n-            return ((BKException)throwable).getCode();\n-        }\n-        return BKException.Code.UnexpectedConditionException;\n-    }\n-\n-    /**\n-     * Wait for the result until it completes.\n-     *\n-     * @param result result to wait\n-     * @return the result\n-     * @throws IOException when encountered exceptions on the result\n-     */\n-    public static <T> T result(Future<T> result) throws IOException {\n-        return result(result, Duration.Top());\n-    }\n-\n-    /**\n-     * Wait for the result for a given <i>duration</i>.\n-     * <p>If the result is not ready within `duration`, an IOException will thrown wrapping with\n-     * corresponding {@link com.twitter.util.TimeoutException}.\n-     *\n-     * @param result result to wait\n-     * @param duration duration to wait\n-     * @return the result\n-     * @throws IOException when encountered exceptions on the result or waiting for the result.\n-     */\n-    public static <T> T result(Future<T> result, Duration duration)\n-            throws IOException {\n-        try {\n-            return Await.result(result, duration);\n-        } catch (KeeperException ke) {\n-            throw new ZKException(\"Encountered zookeeper exception on waiting result\", ke);\n-        } catch (BKException bke) {\n-            throw new BKTransmitException(\"Encountered bookkeeper exception on waiting result\", bke.getCode());\n-        } catch (IOException ioe) {\n-            throw ioe;\n-        } catch (InterruptedException ie) {\n-            throw new DLInterruptedException(\"Interrupted on waiting result\", ie);\n-        } catch (Exception e) {\n-            throw new IOException(\"Encountered exception on waiting result\", e);\n-        }\n-    }\n-\n-    /**\n-     * Wait for the result of a lock operation.\n-     *\n-     * @param result result to wait\n-     * @param lockPath path of the lock\n-     * @return the result\n-     * @throws LockingException when encountered exceptions on the result of lock operation\n-     */\n-    public static <T> T lockResult(Future<T> result, String lockPath) throws LockingException {\n-        try {\n-            return Await.result(result);\n-        } catch (LockingException le) {\n-            throw le;\n-        } catch (Exception e) {\n-            throw new LockingException(lockPath, \"Encountered exception on locking \", e);\n-        }\n-    }\n-\n-    /**\n-     * Convert the <i>throwable</i> to zookeeper related exceptions.\n-     *\n-     * @param throwable cause\n-     * @param path zookeeper path\n-     * @return zookeeper related exceptions\n-     */\n-    public static Throwable zkException(Throwable throwable, String path) {\n-        if (throwable instanceof KeeperException) {\n-            return new ZKException(\"Encountered zookeeper exception on \" + path, (KeeperException) throwable);\n-        } else if (throwable instanceof ZooKeeperClient.ZooKeeperConnectionException) {\n-            return new ZKException(\"Encountered zookeeper connection loss on \" + path,\n-                    KeeperException.Code.CONNECTIONLOSS);\n-        } else if (throwable instanceof InterruptedException) {\n-            return new DLInterruptedException(\"Interrupted on operating \" + path, throwable);\n-        } else {\n-            return new UnexpectedException(\"Encountered unexpected exception on operatiing \" + path, throwable);\n-        }\n-    }\n-\n-    /**\n-     * Cancel the future. It would interrupt the future.\n-     *\n-     * @param future future to cancel\n-     */\n-    public static <T> void cancel(Future<T> future) {\n-        future.raise(new FutureCancelledException());\n-    }\n-\n-    /**\n-     * Raise an exception to the <i>promise</i> within a given <i>timeout</i> period.\n-     * If the promise has been satisfied before raising, it won't change the state of the promise.\n-     *\n-     * @param promise promise to raise exception\n-     * @param timeout timeout period\n-     * @param unit timeout period unit\n-     * @param cause cause to raise\n-     * @param scheduler scheduler to execute raising exception\n-     * @param key the submit key used by the scheduler\n-     * @return the promise applied with the raise logic\n-     */\n-    public static <T> Promise<T> within(final Promise<T> promise,\n-                                        final long timeout,\n-                                        final TimeUnit unit,\n-                                        final Throwable cause,\n-                                        final OrderedScheduler scheduler,\n-                                        final Object key) {\n-        if (timeout < DistributedLogConstants.FUTURE_TIMEOUT_IMMEDIATE || promise.isDefined()) {\n-            return promise;\n-        }\n-        // schedule a timeout to raise timeout exception\n-        final java.util.concurrent.ScheduledFuture<?> task = scheduler.schedule(key, new Runnable() {\n-            @Override\n-            public void run() {\n-                if (!promise.isDefined() && FutureUtils.setException(promise, cause)) {\n-                    logger.info(\"Raise exception\", cause);\n-                }\n-            }\n-        }, timeout, unit);\n-        // when the promise is satisfied, cancel the timeout task\n-        promise.respond(new AbstractFunction1<Try<T>, BoxedUnit>() {\n-            @Override\n-            public BoxedUnit apply(Try<T> value) {\n-                if (!task.cancel(true)) {\n-                    logger.debug(\"Failed to cancel the timeout task\");\n-                }\n-                return BoxedUnit.UNIT;\n-            }\n-        });\n-        return promise;\n-    }\n-\n-    /**\n-     * Satisfy the <i>promise</i> with provide value in an ordered scheduler.\n-     * <p>If the promise was already satisfied, nothing will be changed.\n-     *\n-     * @param promise promise to satisfy\n-     * @param value value to satisfy\n-     * @param scheduler scheduler to satisfy the promise with provided value\n-     * @param key the submit key of the ordered scheduler\n-     */\n-    public static <T> void setValue(final Promise<T> promise,\n-                                    final T value,\n-                                    OrderedScheduler scheduler,\n-                                    Object key) {\n-        scheduler.submit(key, new Runnable() {\n-            @Override\n-            public void run() {\n-                setValue(promise, value);\n-            }\n-        });\n-    }\n-\n-    /**\n-     * Satisfy the <i>promise</i> with provide value.\n-     * <p>If the promise was already satisfied, nothing will be changed.\n-     *\n-     * @param promise promise to satisfy\n-     * @param value value to satisfy\n-     * @return true if successfully satisfy the future. false if the promise has been satisfied.\n-     */\n-    public static <T> boolean setValue(Promise<T> promise, T value) {\n-        boolean success = promise.updateIfEmpty(new Return<T>(value));\n-        if (!success) {\n-            logger.info(\"Result set multiple times. Value = '{}', New = 'Return({})'\",\n-                    promise.poll(), value);\n-        }\n-        return success;\n-    }\n-\n-    /**\n-     * Satisfy the <i>promise</i> with provided <i>cause</i> in an ordered scheduler.\n-     *\n-     * @param promise promise to satisfy\n-     * @param throwable cause to satisfy\n-     * @param scheduler the scheduler to satisfy the promise\n-     * @param key submit key of the ordered scheduler\n-     */\n-    public static <T> void setException(final Promise<T> promise,\n-                                        final Throwable cause,\n-                                        OrderedScheduler scheduler,\n-                                        Object key) {\n-        scheduler.submit(key, new Runnable() {\n-            @Override\n-            public void run() {\n-                setException(promise, cause);\n-            }\n-        });\n-    }\n-\n-    /**\n-     * Satisfy the <i>promise</i> with provided <i>cause</i>.\n-     *\n-     * @param promise promise to satisfy\n-     * @param cause cause to satisfy\n-     * @return true if successfully satisfy the future. false if the promise has been satisfied.\n-     */\n-    public static <T> boolean setException(Promise<T> promise, Throwable cause) {\n-        boolean success = promise.updateIfEmpty(new Throw<T>(cause));\n-        if (!success) {\n-            logger.info(\"Result set multiple times. Value = '{}', New = 'Throw({})'\",\n-                    promise.poll(), cause);\n-        }\n-        return success;\n-    }\n-\n-    /**\n-     * Ignore exception from the <i>future</i>.\n-     *\n-     * @param future the original future\n-     * @return a transformed future ignores exceptions\n-     */\n-    public static <T> Promise<Void> ignore(Future<T> future) {\n-        return ignore(future, null);\n-    }\n-\n-    /**\n-     * Ignore exception from the <i>future</i> and log <i>errorMsg</i> on exceptions\n-     *\n-     * @param future the original future\n-     * @param errorMsg the error message to log on exceptions\n-     * @return a transformed future ignores exceptions\n-     */\n-    public static <T> Promise<Void> ignore(Future<T> future, final String errorMsg) {\n-        final Promise<Void> promise = new Promise<Void>();\n-        future.addEventListener(new FutureEventListener<T>() {\n-            @Override\n-            public void onSuccess(T value) {\n-                setValue(promise, null);\n-            }\n-\n-            @Override\n-            public void onFailure(Throwable cause) {\n-                if (null != errorMsg) {\n-                    logger.error(errorMsg, cause);\n-                }\n-                setValue(promise, null);\n-            }\n-        });\n-        return promise;\n-    }\n-\n-    /**\n-     * Create transmit exception from transmit result.\n-     *\n-     * @param transmitResult\n-     *          transmit result (basically bk exception code)\n-     * @return transmit exception\n-     */\n-    public static BKTransmitException transmitException(int transmitResult) {\n-        return new BKTransmitException(\"Failed to write to bookkeeper; Error is (\"\n-            + transmitResult + \") \"\n-            + BKException.getMessage(transmitResult), transmitResult);\n-    }\n-\n-}"},{"sha":"337247673e24133cb5d4148a7913e47e618753b8","filename":"src/main/java/org/apache/distributedlog/util/MonitoredFuturePool.java","status":"removed","additions":0,"deletions":131,"changes":131,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/46e6b70feda2e8ad61ba13928df93b2c94d3dd4e/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Futil%2FMonitoredFuturePool.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/46e6b70feda2e8ad61ba13928df93b2c94d3dd4e/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Futil%2FMonitoredFuturePool.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Futil%2FMonitoredFuturePool.java?ref=46e6b70feda2e8ad61ba13928df93b2c94d3dd4e","patch":"@@ -1,131 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.distributedlog.util;\n-\n-import com.google.common.base.Stopwatch;\n-\n-import com.twitter.util.FuturePool;\n-import com.twitter.util.FuturePool$;\n-import com.twitter.util.Future;\n-\n-import org.apache.bookkeeper.stats.Counter;\n-import org.apache.bookkeeper.stats.OpStatsLogger;\n-import org.apache.bookkeeper.stats.StatsLogger;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicLong;\n-\n-import scala.runtime.BoxedUnit;\n-import scala.Function0;\n-\n-/**\n- * {@link FuturePool} with exposed stats. This class is exposing following stats for helping understanding\n- * the healthy of this thread pool executor.\n- * <h3>Metrics</h3>\n- * Stats are only exposed when <code>traceTaskExecution</code> is true.\n- * <ul>\n- * <li>task_pending_time: opstats. measuring the characteristics about the time that tasks spent on waiting\n- * being executed.\n- * <li>task_execution_time: opstats. measuring the characteristics about the time that tasks spent on executing.\n- * <li>task_enqueue_time: opstats. measuring the characteristics about the time that tasks spent on submitting.\n- * <li>tasks_pending: gauge. how many tasks are pending in this future pool.\n- * </ul>\n- */\n-public class MonitoredFuturePool implements FuturePool {\n-    static final Logger LOG = LoggerFactory.getLogger(MonitoredFuturePool.class);\n-\n-    private final FuturePool futurePool;\n-\n-    private final StatsLogger statsLogger;\n-    private final OpStatsLogger taskPendingTime;\n-    private final OpStatsLogger taskExecutionTime;\n-    private final OpStatsLogger taskEnqueueTime;\n-    private final Counter taskPendingCounter;\n-\n-    private final boolean traceTaskExecution;\n-    private final long traceTaskExecutionWarnTimeUs;\n-\n-    class TimedFunction0<T> extends com.twitter.util.Function0<T> {\n-        private final Function0<T> function0;\n-        private Stopwatch pendingStopwatch = Stopwatch.createStarted();\n-\n-        TimedFunction0(Function0<T> function0) {\n-            this.function0 = function0;\n-            this.pendingStopwatch = Stopwatch.createStarted();\n-        }\n-\n-        @Override\n-        public T apply() {\n-            taskPendingTime.registerSuccessfulEvent(pendingStopwatch.elapsed(TimeUnit.MICROSECONDS));\n-            Stopwatch executionStopwatch = Stopwatch.createStarted();\n-            T result = function0.apply();\n-            taskExecutionTime.registerSuccessfulEvent(executionStopwatch.elapsed(TimeUnit.MICROSECONDS));\n-            long elapsed = executionStopwatch.elapsed(TimeUnit.MICROSECONDS);\n-            if (elapsed > traceTaskExecutionWarnTimeUs) {\n-                LOG.info(\"{} took too long {} microseconds\", function0.toString(), elapsed);\n-            }\n-            return result;\n-        }\n-    }\n-\n-    /**\n-     * Create a future pool with stats exposed.\n-     *\n-     * @param futurePool underlying future pool to execute futures\n-     * @param statsLogger stats logger to receive exposed stats\n-     * @param traceTaskExecution flag to enable/disable exposing stats about task execution\n-     * @param traceTaskExecutionWarnTimeUs flag to enable/disable logging slow tasks\n-     *                                     whose execution time is above this value\n-     */\n-    public MonitoredFuturePool(FuturePool futurePool,\n-                               StatsLogger statsLogger,\n-                               boolean traceTaskExecution,\n-                               long traceTaskExecutionWarnTimeUs) {\n-        this.futurePool = futurePool;\n-        this.traceTaskExecution = traceTaskExecution;\n-        this.traceTaskExecutionWarnTimeUs = traceTaskExecutionWarnTimeUs;\n-        this.statsLogger = statsLogger;\n-        this.taskPendingTime = statsLogger.getOpStatsLogger(\"task_pending_time\");\n-        this.taskExecutionTime = statsLogger.getOpStatsLogger(\"task_execution_time\");\n-        this.taskEnqueueTime = statsLogger.getOpStatsLogger(\"task_enqueue_time\");\n-        this.taskPendingCounter = statsLogger.getCounter(\"tasks_pending\");\n-    }\n-\n-    @Override\n-    public <T> Future<T> apply(Function0<T> function0) {\n-        if (traceTaskExecution) {\n-            taskPendingCounter.inc();\n-            Stopwatch taskEnqueueStopwatch = Stopwatch.createStarted();\n-            Future<T> futureResult = futurePool.apply(new TimedFunction0<T>(function0));\n-            taskEnqueueTime.registerSuccessfulEvent(taskEnqueueStopwatch.elapsed(TimeUnit.MICROSECONDS));\n-            futureResult.ensure(new com.twitter.util.Function0<BoxedUnit>() {\n-                @Override\n-                public BoxedUnit apply() {\n-                    taskPendingCounter.dec();\n-                    return null;\n-                }\n-            });\n-            return futureResult;\n-        } else {\n-            return futurePool.apply(function0);\n-        }\n-    }\n-}"},{"sha":"3121a19f377ffe7a0c58fdf3a375ceb55155a01e","filename":"src/main/java/org/apache/distributedlog/util/MonitoredScheduledThreadPoolExecutor.java","status":"removed","additions":0,"deletions":257,"changes":257,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/46e6b70feda2e8ad61ba13928df93b2c94d3dd4e/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Futil%2FMonitoredScheduledThreadPoolExecutor.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/46e6b70feda2e8ad61ba13928df93b2c94d3dd4e/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Futil%2FMonitoredScheduledThreadPoolExecutor.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Futil%2FMonitoredScheduledThreadPoolExecutor.java?ref=46e6b70feda2e8ad61ba13928df93b2c94d3dd4e","patch":"@@ -1,257 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.distributedlog.util;\n-\n-import org.apache.bookkeeper.stats.Gauge;\n-import org.apache.bookkeeper.stats.OpStatsLogger;\n-import org.apache.bookkeeper.stats.StatsLogger;\n-import org.apache.bookkeeper.util.MathUtils;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import java.util.concurrent.Callable;\n-import java.util.concurrent.CancellationException;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.Future;\n-import java.util.concurrent.ScheduledThreadPoolExecutor;\n-import java.util.concurrent.ThreadFactory;\n-import java.util.concurrent.TimeUnit;\n-\n-/**\n- * {@link ScheduledThreadPoolExecutor} with exposed stats. This class is exposing following stats for\n- * helping understanding the healthy of this thread pool executor.\n- * <h3>Metrics</h3>\n- * <ul>\n- * <li>pending_tasks: gauge. how many tasks are pending in this executor.\n- * <li>completed_tasks: gauge. how many tasks are completed in this executor.\n- * <li>total_tasks: gauge. how many tasks are submitted to this executor.\n- * <li>task_pending_time: opstats. measuring the characteristics about the time that tasks spent on\n- * waiting being executed.\n- * <li>task_execution_time: opstats. measuring the characteristics about the time that tasks spent on\n- * executing.\n- * </ul>\n- */\n-public class MonitoredScheduledThreadPoolExecutor extends ScheduledThreadPoolExecutor {\n-    static final Logger LOG = LoggerFactory.getLogger(MonitoredScheduledThreadPoolExecutor.class);\n-\n-    private class TimedRunnable implements Runnable {\n-\n-        final Runnable runnable;\n-        final long enqueueNanos;\n-\n-        TimedRunnable(Runnable runnable) {\n-            this.runnable = runnable;\n-            this.enqueueNanos = MathUtils.nowInNano();\n-        }\n-\n-        @Override\n-        public void run() {\n-            long startNanos = MathUtils.nowInNano();\n-            long pendingMicros = TimeUnit.NANOSECONDS.toMicros(startNanos - enqueueNanos);\n-            taskPendingStats.registerSuccessfulEvent(pendingMicros);\n-            try {\n-                runnable.run();\n-            } finally {\n-                long executionMicros = TimeUnit.NANOSECONDS.toMicros(MathUtils.nowInNano() - startNanos);\n-                taskExecutionStats.registerSuccessfulEvent(executionMicros);\n-            }\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return runnable.toString();\n-        }\n-\n-        @Override\n-        public int hashCode() {\n-            return runnable.hashCode();\n-        }\n-    }\n-\n-    private class TimedCallable<T> implements Callable<T> {\n-\n-        final Callable<T> task;\n-        final long enqueueNanos;\n-\n-        TimedCallable(Callable<T> task) {\n-            this.task = task;\n-            this.enqueueNanos = MathUtils.nowInNano();\n-        }\n-\n-        @Override\n-        public T call() throws Exception {\n-            long startNanos = MathUtils.nowInNano();\n-            long pendingMicros = TimeUnit.NANOSECONDS.toMicros(startNanos - enqueueNanos);\n-            taskPendingStats.registerSuccessfulEvent(pendingMicros);\n-            try {\n-                return task.call();\n-            } finally {\n-                long executionMicros = TimeUnit.NANOSECONDS.toMicros(MathUtils.nowInNano() - startNanos);\n-                taskExecutionStats.registerSuccessfulEvent(executionMicros);\n-            }\n-        }\n-    }\n-\n-    protected final boolean traceTaskExecution;\n-    protected final OpStatsLogger taskExecutionStats;\n-    protected final OpStatsLogger taskPendingStats;\n-    protected final StatsLogger statsLogger;\n-    // Gauges and their labels\n-    private static final String pendingTasksGaugeLabel = \"pending_tasks\";\n-    private final Gauge<Number> pendingTasksGauge;\n-    private static final String completedTasksGaugeLabel = \"completed_tasks\";\n-    protected final Gauge<Number> completedTasksGauge;\n-    private static final String totalTasksGaugeLabel = \"total_tasks\";\n-    protected final Gauge<Number> totalTasksGauge;\n-\n-    public MonitoredScheduledThreadPoolExecutor(int corePoolSize,\n-                                                ThreadFactory threadFactory,\n-                                                StatsLogger statsLogger,\n-                                                boolean traceTaskExecution) {\n-        super(corePoolSize, threadFactory);\n-        this.traceTaskExecution = traceTaskExecution;\n-        this.statsLogger = statsLogger;\n-        this.taskPendingStats = this.statsLogger.getOpStatsLogger(\"task_pending_time\");\n-        this.taskExecutionStats = this.statsLogger.getOpStatsLogger(\"task_execution_time\");\n-        this.pendingTasksGauge = new Gauge<Number>() {\n-            @Override\n-            public Number getDefaultValue() {\n-                return 0;\n-            }\n-\n-            @Override\n-            public Number getSample() {\n-                return getQueue().size();\n-            }\n-        };\n-        this.completedTasksGauge = new Gauge<Number>() {\n-            @Override\n-            public Number getDefaultValue() {\n-                return 0;\n-            }\n-\n-            @Override\n-            public Number getSample() {\n-                return getCompletedTaskCount();\n-            }\n-        };\n-        this.totalTasksGauge = new Gauge<Number>() {\n-            @Override\n-            public Number getDefaultValue() {\n-                return 0;\n-            }\n-\n-            @Override\n-            public Number getSample() {\n-                return getTaskCount();\n-            }\n-        };\n-\n-        // outstanding tasks\n-        this.statsLogger.registerGauge(pendingTasksGaugeLabel, pendingTasksGauge);\n-        // completed tasks\n-        this.statsLogger.registerGauge(completedTasksGaugeLabel, completedTasksGauge);\n-        // total tasks\n-        this.statsLogger.registerGauge(totalTasksGaugeLabel, pendingTasksGauge);\n-    }\n-\n-    private Runnable timedRunnable(Runnable r) {\n-        return traceTaskExecution ? new TimedRunnable(r) : r;\n-    }\n-\n-    private <T> Callable<T> timedCallable(Callable<T> task) {\n-        return traceTaskExecution ? new TimedCallable<T>(task) : task;\n-    }\n-\n-    @Override\n-    public Future<?> submit(Runnable task) {\n-        return super.submit(timedRunnable(task));\n-    }\n-\n-    @Override\n-    public <T> Future<T> submit(Runnable task, T result) {\n-        return super.submit(timedRunnable(task), result);\n-    }\n-\n-    @Override\n-    public <T> Future<T> submit(Callable<T> task) {\n-        return super.submit(timedCallable(task));\n-    }\n-\n-    @Override\n-    protected void afterExecute(Runnable r, Throwable t) {\n-        super.afterExecute(r, t);\n-        Throwable hiddenThrowable = extractThrowable(r);\n-        if (hiddenThrowable != null)\n-            logAndHandle(hiddenThrowable, true);\n-\n-        // The executor re-throws exceptions thrown by the task to the uncaught exception handler\n-        // so we don't need to pass the exception to the handler explicitly\n-        if (null != t) {\n-            logAndHandle(t, false);\n-        }\n-    }\n-\n-    /**\n-     * The executor re-throws exceptions thrown by the task to the uncaught exception handler\n-     * so we only need to do anything if uncaught exception handler has not been se\n-     */\n-    private void logAndHandle(Throwable t, boolean passToHandler) {\n-        if (Thread.getDefaultUncaughtExceptionHandler() == null) {\n-            LOG.error(\"Unhandled exception on thread {}\", Thread.currentThread().getName(), t);\n-        }\n-        else {\n-            LOG.info(\"Unhandled exception on thread {}\", Thread.currentThread().getName(), t);\n-            if (passToHandler) {\n-                Thread.getDefaultUncaughtExceptionHandler().uncaughtException(Thread.currentThread(), t);\n-            }\n-        }\n-    }\n-\n-\n-    /**\n-     * Extract the exception (throwable) inside the ScheduledFutureTask\n-     * @param runnable - The runable that was executed\n-     * @return exception enclosed in the Runnable if any; null otherwise\n-     */\n-    private Throwable extractThrowable(Runnable runnable) {\n-        // Check for exceptions wrapped by FutureTask.\n-        // We do this by calling get(), which will cause it to throw any saved exception.\n-        // Check for isDone to prevent blocking\n-        if ((runnable instanceof Future<?>) && ((Future<?>) runnable).isDone()) {\n-            try {\n-                ((Future<?>) runnable).get();\n-            } catch (CancellationException e) {\n-                LOG.debug(\"Task {} cancelled\", runnable, e.getCause());\n-            } catch (InterruptedException e) {\n-                LOG.debug(\"Task {} was interrupted\", runnable, e);\n-            } catch (ExecutionException e) {\n-                return e.getCause();\n-            }\n-        }\n-\n-        return null;\n-    }\n-\n-    void unregisterGauges() {\n-        this.statsLogger.unregisterGauge(pendingTasksGaugeLabel, pendingTasksGauge);\n-        this.statsLogger.unregisterGauge(completedTasksGaugeLabel, completedTasksGauge);\n-        this.statsLogger.unregisterGauge(totalTasksGaugeLabel, totalTasksGauge);\n-    }\n-\n-}"},{"sha":"ad1ba4e0ad38325afe5745d162db788c8461abcb","filename":"src/main/java/org/apache/distributedlog/util/OrderedScheduler.java","status":"removed","additions":0,"deletions":490,"changes":490,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/46e6b70feda2e8ad61ba13928df93b2c94d3dd4e/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Futil%2FOrderedScheduler.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/46e6b70feda2e8ad61ba13928df93b2c94d3dd4e/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Futil%2FOrderedScheduler.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Futil%2FOrderedScheduler.java?ref=46e6b70feda2e8ad61ba13928df93b2c94d3dd4e","patch":"@@ -1,490 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.distributedlog.util;\n-\n-import com.google.common.base.Objects;\n-import com.google.common.util.concurrent.ThreadFactoryBuilder;\n-import org.apache.distributedlog.stats.BroadCastStatsLogger;\n-import com.twitter.util.ExecutorServiceFuturePool;\n-import com.twitter.util.FuturePool;\n-import com.twitter.util.Time;\n-import com.twitter.util.Timer;\n-import com.twitter.util.TimerTask;\n-import org.apache.bookkeeper.stats.NullStatsLogger;\n-import org.apache.bookkeeper.stats.StatsLogger;\n-import org.apache.bookkeeper.util.MathUtils;\n-import scala.Function0;\n-\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.List;\n-import java.util.Random;\n-import java.util.concurrent.Callable;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.Future;\n-import java.util.concurrent.ScheduledExecutorService;\n-import java.util.concurrent.ScheduledFuture;\n-import java.util.concurrent.ThreadFactory;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.TimeoutException;\n-\n-/**\n- * Ordered Scheduler. It is thread pool based {@link ScheduledExecutorService}, additionally providing\n- * the ability to execute/schedule tasks by <code>key</code>. Hence the tasks submitted by same <i>key</i>\n- * will be executed in order.\n- * <p>\n- * The scheduler is comprised of multiple {@link MonitoredScheduledThreadPoolExecutor}s. Each\n- * {@link MonitoredScheduledThreadPoolExecutor} is a single thread executor. Normal task submissions will\n- * be submitted to executors in a random manner to guarantee load balancing. Keyed task submissions (e.g\n- * {@link OrderedScheduler#apply(Object, Function0)} will be submitted to a dedicated executor based on\n- * the hash value of submit <i>key</i>.\n- *\n- * <h3>Metrics</h3>\n- *\n- * <h4>Per Executor Metrics</h4>\n- *\n- * Metrics about individual executors are exposed via {@link Builder#perExecutorStatsLogger}\n- * under <i>`scope`/`name`-executor-`id`-0</i>. `name` is the scheduler name provided by {@link Builder#name}\n- * while `id` is the index of this executor in the pool. And corresponding stats of future pool of\n- * that executor are exposed under <i>`scope`/`name`-executor-`id`-0/futurepool</i>.\n- * <p>\n- * See {@link MonitoredScheduledThreadPoolExecutor} and {@link MonitoredFuturePool} for per executor metrics\n- * exposed.\n- *\n- * <h4>Aggregated Metrics</h4>\n- * <ul>\n- * <li>task_pending_time: opstats. measuring the characteristics about the time that tasks spent on\n- * waiting being executed.\n- * <li>task_execution_time: opstats. measuring the characteristics about the time that tasks spent on\n- * executing.\n- * <li>futurepool/task_pending_time: opstats. measuring the characteristics about the time that tasks spent\n- * on waiting in future pool being executed.\n- * <li>futurepool/task_execution_time: opstats. measuring the characteristics about the time that tasks spent\n- * on executing.\n- * <li>futurepool/task_enqueue_time: opstats. measuring the characteristics about the time that tasks spent on\n- * submitting to future pool.\n- * <li>futurepool/tasks_pending: gauge. how many tasks are pending in this future pool.\n- * </ul>\n- */\n-public class OrderedScheduler implements ScheduledExecutorService {\n-\n-    /**\n-     * Create a builder to build scheduler.\n-     *\n-     * @return scheduler builder\n-     */\n-    public static Builder newBuilder() {\n-        return new Builder();\n-    }\n-\n-    /**\n-     * Builder for {@link OrderedScheduler}.\n-     */\n-    public static class Builder {\n-\n-        private String name = \"OrderedScheduler\";\n-        private int corePoolSize = -1;\n-        private ThreadFactory threadFactory = null;\n-        private boolean traceTaskExecution = false;\n-        private long traceTaskExecutionWarnTimeUs = Long.MAX_VALUE;\n-        private StatsLogger statsLogger = NullStatsLogger.INSTANCE;\n-        private StatsLogger perExecutorStatsLogger = NullStatsLogger.INSTANCE;\n-\n-        /**\n-         * Set the name of this scheduler. It would be used as part of stats scope and thread name.\n-         *\n-         * @param name\n-         *          name of the scheduler.\n-         * @return scheduler builder\n-         */\n-        public Builder name(String name) {\n-            this.name = name;\n-            return this;\n-        }\n-\n-        /**\n-         * Set the number of threads to be used in this scheduler.\n-         *\n-         * @param corePoolSize the number of threads to keep in the pool, even\n-         *        if they are idle\n-         * @return scheduler builder\n-         */\n-        public Builder corePoolSize(int corePoolSize) {\n-            this.corePoolSize = corePoolSize;\n-            return this;\n-        }\n-\n-        /**\n-         * Set the thread factory that the scheduler uses to create a new thread.\n-         *\n-         * @param threadFactory the factory to use when the executor\n-         *        creates a new thread\n-         * @return scheduler builder\n-         */\n-        public Builder threadFactory(ThreadFactory threadFactory) {\n-            this.threadFactory = threadFactory;\n-            return this;\n-        }\n-\n-        /**\n-         * Enable/Disable exposing task execution stats.\n-         *\n-         * @param trace\n-         *          flag to enable/disable exposing task execution stats.\n-         * @return scheduler builder\n-         */\n-        public Builder traceTaskExecution(boolean trace) {\n-            this.traceTaskExecution = trace;\n-            return this;\n-        }\n-\n-        /**\n-         * Enable/Disable logging slow tasks whose execution time is above <code>timeUs</code>.\n-         *\n-         * @param timeUs\n-         *          slow task execution time threshold in us.\n-         * @return scheduler builder.\n-         */\n-        public Builder traceTaskExecutionWarnTimeUs(long timeUs) {\n-            this.traceTaskExecutionWarnTimeUs = timeUs;\n-            return this;\n-        }\n-\n-        /**\n-         * Expose the aggregated stats over <code>statsLogger</code>.\n-         *\n-         * @param statsLogger\n-         *          stats logger to receive aggregated stats.\n-         * @return scheduler builder\n-         */\n-        public Builder statsLogger(StatsLogger statsLogger) {\n-            this.statsLogger = statsLogger;\n-            return this;\n-        }\n-\n-        /**\n-         * Expose stats of individual executors over <code>perExecutorStatsLogger</code>.\n-         * Each executor's stats will be exposed under a sub-scope `name`-executor-`id`-0.\n-         * `name` is the scheduler name, while `id` is the index of the scheduler in the pool.\n-         *\n-         * @param perExecutorStatsLogger\n-         *          stats logger to receive per executor stats.\n-         * @return scheduler builder\n-         */\n-        public Builder perExecutorStatsLogger(StatsLogger perExecutorStatsLogger) {\n-            this.perExecutorStatsLogger = perExecutorStatsLogger;\n-            return this;\n-        }\n-\n-        /**\n-         * Build the ordered scheduler.\n-         *\n-         * @return ordered scheduler\n-         */\n-        public OrderedScheduler build() {\n-            if (corePoolSize <= 0) {\n-                corePoolSize = Runtime.getRuntime().availableProcessors();\n-            }\n-            if (null == threadFactory) {\n-                threadFactory = Executors.defaultThreadFactory();\n-            }\n-\n-            return new OrderedScheduler(\n-                    name,\n-                    corePoolSize,\n-                    threadFactory,\n-                    traceTaskExecution,\n-                    traceTaskExecutionWarnTimeUs,\n-                    statsLogger,\n-                    perExecutorStatsLogger);\n-        }\n-\n-    }\n-\n-    protected final String name;\n-    protected final int corePoolSize;\n-    protected final MonitoredScheduledThreadPoolExecutor[] executors;\n-    protected final MonitoredFuturePool[] futurePools;\n-    protected final Random random;\n-\n-    private OrderedScheduler(String name,\n-                             int corePoolSize,\n-                             ThreadFactory threadFactory,\n-                             boolean traceTaskExecution,\n-                             long traceTaskExecutionWarnTimeUs,\n-                             StatsLogger statsLogger,\n-                             StatsLogger perExecutorStatsLogger) {\n-        this.name = name;\n-        this.corePoolSize = corePoolSize;\n-        this.executors = new MonitoredScheduledThreadPoolExecutor[corePoolSize];\n-        this.futurePools = new MonitoredFuturePool[corePoolSize];\n-        for (int i = 0; i < corePoolSize; i++) {\n-            ThreadFactory tf = new ThreadFactoryBuilder()\n-                    .setNameFormat(name + \"-executor-\" + i + \"-%d\")\n-                    .setThreadFactory(threadFactory)\n-                    .build();\n-            StatsLogger broadcastStatsLogger =\n-                    BroadCastStatsLogger.masterslave(perExecutorStatsLogger.scope(\"executor-\" + i), statsLogger);\n-            executors[i] = new MonitoredScheduledThreadPoolExecutor(\n-                    1, tf, broadcastStatsLogger, traceTaskExecution);\n-            futurePools[i] = new MonitoredFuturePool(\n-                    new ExecutorServiceFuturePool(executors[i]),\n-                    broadcastStatsLogger.scope(\"futurepool\"),\n-                    traceTaskExecution,\n-                    traceTaskExecutionWarnTimeUs);\n-        }\n-        this.random = new Random(System.currentTimeMillis());\n-    }\n-\n-    protected MonitoredScheduledThreadPoolExecutor chooseExecutor() {\n-        return corePoolSize == 1 ? executors[0] : executors[random.nextInt(corePoolSize)];\n-    }\n-\n-    protected MonitoredScheduledThreadPoolExecutor chooseExecutor(Object key) {\n-        return corePoolSize == 1 ? executors[0] :\n-                executors[MathUtils.signSafeMod(Objects.hashCode(key), corePoolSize)];\n-    }\n-\n-    protected FuturePool chooseFuturePool(Object key) {\n-        return corePoolSize == 1 ? futurePools[0] :\n-                futurePools[MathUtils.signSafeMod(Objects.hashCode(key), corePoolSize)];\n-    }\n-\n-    protected FuturePool chooseFuturePool() {\n-        return corePoolSize == 1 ? futurePools[0] : futurePools[random.nextInt(corePoolSize)];\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     */\n-    @Override\n-    public ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit) {\n-        return chooseExecutor().schedule(command, delay, unit);\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     */\n-    @Override\n-    public <V> ScheduledFuture<V> schedule(Callable<V> callable, long delay, TimeUnit unit) {\n-        return chooseExecutor().schedule(callable, delay, unit);\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     */\n-    @Override\n-    public ScheduledFuture<?> scheduleAtFixedRate(Runnable command,\n-                                                  long initialDelay, long period, TimeUnit unit) {\n-        return chooseExecutor().scheduleAtFixedRate(command, initialDelay, period, unit);\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     */\n-    @Override\n-    public ScheduledFuture<?> scheduleWithFixedDelay(Runnable command,\n-                                                     long initialDelay, long delay, TimeUnit unit) {\n-        return chooseExecutor().scheduleWithFixedDelay(command, initialDelay, delay, unit);\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     */\n-    @Override\n-    public void shutdown() {\n-        for (MonitoredScheduledThreadPoolExecutor executor : executors) {\n-            // Unregister gauges\n-            executor.unregisterGauges();\n-            executor.shutdown();\n-        }\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     */\n-    @Override\n-    public List<Runnable> shutdownNow() {\n-        List<Runnable> runnables = new ArrayList<Runnable>();\n-        for (MonitoredScheduledThreadPoolExecutor executor : executors) {\n-            runnables.addAll(executor.shutdownNow());\n-        }\n-        return runnables;\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     */\n-    @Override\n-    public boolean isShutdown() {\n-        for (MonitoredScheduledThreadPoolExecutor executor : executors) {\n-            if (!executor.isShutdown()) {\n-                return false;\n-            }\n-        }\n-        return true;\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     */\n-    @Override\n-    public boolean isTerminated() {\n-        for (MonitoredScheduledThreadPoolExecutor executor : executors) {\n-            if (!executor.isTerminated()) {\n-                return false;\n-            }\n-        }\n-        return true;\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     */\n-    @Override\n-    public boolean awaitTermination(long timeout, TimeUnit unit)\n-            throws InterruptedException {\n-        for (MonitoredScheduledThreadPoolExecutor executor : executors) {\n-            if (!executor.awaitTermination(timeout, unit)) {\n-                return false;\n-            }\n-        }\n-        return true;\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     */\n-    @Override\n-    public <T> Future<T> submit(Callable<T> task) {\n-        return chooseExecutor().submit(task);\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     */\n-    @Override\n-    public <T> Future<T> submit(Runnable task, T result) {\n-        return chooseExecutor().submit(task, result);\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     */\n-    @Override\n-    public Future<?> submit(Runnable task) {\n-        return chooseExecutor().submit(task);\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     */\n-    @Override\n-    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)\n-            throws InterruptedException {\n-        return chooseExecutor().invokeAll(tasks);\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     */\n-    @Override\n-    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n-            throws InterruptedException {\n-        return chooseExecutor().invokeAll(tasks, timeout, unit);\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     */\n-    @Override\n-    public <T> T invokeAny(Collection<? extends Callable<T>> tasks)\n-            throws InterruptedException, ExecutionException {\n-        return chooseExecutor().invokeAny(tasks);\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     */\n-    @Override\n-    public <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n-            throws InterruptedException, ExecutionException, TimeoutException {\n-        return chooseExecutor().invokeAny(tasks, timeout, unit);\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     */\n-    @Override\n-    public void execute(Runnable command) {\n-        chooseExecutor().execute(command);\n-    }\n-\n-    // Ordered Functions\n-\n-    /**\n-     * Return a future pool used by <code>key</code>.\n-     *\n-     * @param key\n-     *          key to order in the future pool\n-     * @return future pool\n-     */\n-    public FuturePool getFuturePool(Object key) {\n-        return chooseFuturePool(key);\n-    }\n-\n-    /**\n-     * Execute the <code>function</code> in the executor that assigned by <code>key</code>.\n-     *\n-     * @see com.twitter.util.Future\n-     * @param key key of the <i>function</i> to run\n-     * @param function function to run\n-     * @return future representing the result of the <i>function</i>\n-     */\n-    public <T> com.twitter.util.Future<T> apply(Object key, Function0<T> function) {\n-        return chooseFuturePool(key).apply(function);\n-    }\n-\n-    /**\n-     * Execute the <code>function</code> by the scheduler. It would be submitted to any executor randomly.\n-     *\n-     * @param function function to run\n-     * @return future representing the result of the <i>function</i>\n-     */\n-    public <T> com.twitter.util.Future<T> apply(Function0<T> function) {\n-        return chooseFuturePool().apply(function);\n-    }\n-\n-    public ScheduledFuture<?> schedule(Object key, Runnable command, long delay, TimeUnit unit) {\n-        return chooseExecutor(key).schedule(command, delay, unit);\n-    }\n-\n-    public ScheduledFuture<?> scheduleAtFixedRate(Object key,\n-                                                  Runnable command,\n-                                                  long initialDelay,\n-                                                  long period,\n-                                                  TimeUnit unit) {\n-        return chooseExecutor(key).scheduleAtFixedRate(command, initialDelay, period, unit);\n-    }\n-\n-    public Future<?> submit(Object key, Runnable command) {\n-        return chooseExecutor(key).submit(command);\n-    }\n-\n-}"},{"sha":"15394dcb89132f9290730828bc1bb570b97e6606","filename":"src/main/java/org/apache/distributedlog/util/PermitLimiter.java","status":"removed","additions":0,"deletions":57,"changes":57,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/46e6b70feda2e8ad61ba13928df93b2c94d3dd4e/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Futil%2FPermitLimiter.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/46e6b70feda2e8ad61ba13928df93b2c94d3dd4e/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Futil%2FPermitLimiter.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Futil%2FPermitLimiter.java?ref=46e6b70feda2e8ad61ba13928df93b2c94d3dd4e","patch":"@@ -1,57 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.distributedlog.util;\n-\n-/**\n- * A simple limiter interface which tracks acquire/release of permits, for\n- * example for tracking outstanding writes.\n- */\n-public interface PermitLimiter {\n-\n-    public static PermitLimiter NULL_PERMIT_LIMITER = new PermitLimiter() {\n-        @Override\n-        public boolean acquire() {\n-            return true;\n-        }\n-        @Override\n-        public void release(int permits) {\n-        }\n-\n-        @Override\n-        public void close() {\n-\n-        }\n-    };\n-\n-    /**\n-     * Acquire a permit.\n-     *\n-     * @return true if successfully acquire a permit, otherwise false.\n-     */\n-    boolean acquire();\n-\n-    /**\n-     * Release a permit.\n-     */\n-    void release(int permits);\n-\n-    /**\n-     * Close the resources created by the limiter\n-     */\n-    void close();\n-}"},{"sha":"24c7860437d80d1be142967d6c5f66ca939c142c","filename":"src/main/java/org/apache/distributedlog/util/PermitManager.java","status":"removed","additions":0,"deletions":93,"changes":93,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/46e6b70feda2e8ad61ba13928df93b2c94d3dd4e/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Futil%2FPermitManager.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/46e6b70feda2e8ad61ba13928df93b2c94d3dd4e/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Futil%2FPermitManager.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Futil%2FPermitManager.java?ref=46e6b70feda2e8ad61ba13928df93b2c94d3dd4e","patch":"@@ -1,93 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.distributedlog.util;\n-\n-public interface PermitManager {\n-\n-    public static interface Permit {\n-        static final Permit ALLOWED = new Permit() {\n-            @Override\n-            public boolean isAllowed() {\n-                return true;\n-            }\n-        };\n-        boolean isAllowed();\n-    }\n-\n-    public static PermitManager UNLIMITED_PERMIT_MANAGER = new PermitManager() {\n-        @Override\n-        public Permit acquirePermit() {\n-            return Permit.ALLOWED;\n-        }\n-\n-        @Override\n-        public void releasePermit(Permit permit) {\n-            // nop\n-        }\n-\n-        @Override\n-        public boolean allowObtainPermits() {\n-            return true;\n-        }\n-\n-        @Override\n-        public boolean disallowObtainPermits(Permit permit) {\n-            return false;\n-        }\n-\n-        @Override\n-        public void close() {\n-            // nop\n-        }\n-\n-    };\n-\n-    /**\n-     * Obetain a permit from permit manager.\n-     *\n-     * @return permit.\n-     */\n-    Permit acquirePermit();\n-\n-    /**\n-     * Release a given permit.\n-     *\n-     * @param permit\n-     *          permit to release\n-     */\n-    void releasePermit(Permit permit);\n-\n-    /**\n-     * Allow obtaining permits.\n-     */\n-    boolean allowObtainPermits();\n-\n-    /**\n-     * Disallow obtaining permits. Disallow needs to be performed under the context\n-     * of <i>permit</i>.\n-     *\n-     * @param permit\n-     *          permit context to disallow\n-     */\n-    boolean disallowObtainPermits(Permit permit);\n-\n-    /**\n-     * Release the resources\n-     */\n-    void close();\n-}"},{"sha":"a467d269122aafee16f4db52b5921dd926e77379","filename":"src/main/java/org/apache/distributedlog/util/SafeQueueingFuturePool.java","status":"removed","additions":0,"deletions":115,"changes":115,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/46e6b70feda2e8ad61ba13928df93b2c94d3dd4e/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Futil%2FSafeQueueingFuturePool.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/46e6b70feda2e8ad61ba13928df93b2c94d3dd4e/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Futil%2FSafeQueueingFuturePool.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Futil%2FSafeQueueingFuturePool.java?ref=46e6b70feda2e8ad61ba13928df93b2c94d3dd4e","patch":"@@ -1,115 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.distributedlog.util;\n-\n-import com.google.common.base.Preconditions;\n-\n-import com.twitter.util.Function0;\n-import com.twitter.util.FuturePool;\n-import com.twitter.util.Future;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import java.util.concurrent.ConcurrentLinkedQueue;\n-import java.util.concurrent.RejectedExecutionException;\n-import java.util.concurrent.atomic.AtomicInteger;\n-\n-import scala.runtime.BoxedUnit;\n-\n-/**\n- * Acts like a future pool, but collects failed apply calls into a queue to be applied\n- * in-order on close. This happens either in the close thread or after close is called,\n- * in the last operation to complete execution.\n- * Ops submitted after close will not be scheduled, so its important to ensure no more\n- * ops will be applied once close has been called.\n- */\n-public class SafeQueueingFuturePool<T> {\n-\n-    static final Logger LOG = LoggerFactory.getLogger(SafeQueueingFuturePool.class);\n-\n-    private boolean closed;\n-    private int outstanding;\n-    private ConcurrentLinkedQueue<Function0<T>> queue;\n-    private FuturePool orderedFuturePool;\n-\n-    public SafeQueueingFuturePool(FuturePool orderedFuturePool) {\n-        this.closed = false;\n-        this.outstanding = 0;\n-        this.queue = new ConcurrentLinkedQueue<Function0<T>>();\n-        this.orderedFuturePool = orderedFuturePool;\n-    }\n-\n-    public synchronized Future<T> apply(final Function0<T> fn) {\n-        Preconditions.checkNotNull(fn);\n-        if (closed) {\n-            return Future.exception(new RejectedExecutionException(\"Operation submitted to closed SafeQueueingFuturePool\"));\n-        }\n-        ++outstanding;\n-        queue.add(fn);\n-        Future<T> result = orderedFuturePool.apply(new Function0<T>() {\n-            @Override\n-            public T apply() {\n-                return queue.poll().apply();\n-            }\n-            @Override\n-            public String toString() {\n-                return fn.toString();\n-            }\n-        }).ensure(new Function0<BoxedUnit>() {\n-            public BoxedUnit apply() {\n-                if (decrOutstandingAndCheckDone()) {\n-                    applyAll();\n-                }\n-                return null;\n-            }\n-        });\n-        return result;\n-    }\n-\n-    private synchronized boolean decrOutstandingAndCheckDone() {\n-        return --outstanding == 0 && closed;\n-    }\n-\n-    public void close() {\n-        final boolean done;\n-        synchronized (this) {\n-            if (closed) {\n-                return;\n-            }\n-            closed = true;\n-            done = (outstanding == 0);\n-        }\n-        if (done) {\n-            applyAll();\n-        }\n-    }\n-\n-    private void applyAll() {\n-        if (!queue.isEmpty()) {\n-            LOG.info(\"Applying {} items\", queue.size());\n-        }\n-        while (!queue.isEmpty()) {\n-            queue.poll().apply();\n-        }\n-    }\n-\n-    public synchronized int size() {\n-        return queue.size();\n-    }\n-}"},{"sha":"66e382cdc3f7bde513775676cb0a86b3ae1ae448","filename":"src/main/java/org/apache/distributedlog/util/SchedulerUtils.java","status":"removed","additions":0,"deletions":56,"changes":56,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/46e6b70feda2e8ad61ba13928df93b2c94d3dd4e/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Futil%2FSchedulerUtils.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/46e6b70feda2e8ad61ba13928df93b2c94d3dd4e/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Futil%2FSchedulerUtils.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Futil%2FSchedulerUtils.java?ref=46e6b70feda2e8ad61ba13928df93b2c94d3dd4e","patch":"@@ -1,56 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.distributedlog.util;\n-\n-import org.apache.bookkeeper.util.OrderedSafeExecutor;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.TimeUnit;\n-\n-public class SchedulerUtils {\n-\n-    static final Logger logger = LoggerFactory.getLogger(SchedulerUtils.class);\n-\n-    public static void shutdownScheduler(ExecutorService service, long timeout, TimeUnit timeUnit) {\n-        if (null == service) {\n-            return;\n-        }\n-        service.shutdown();\n-        try {\n-            service.awaitTermination(timeout, timeUnit);\n-        } catch (InterruptedException e) {\n-            logger.warn(\"Interrupted when shutting down scheduler : \", e);\n-        }\n-        service.shutdownNow();\n-    }\n-\n-    public static void shutdownScheduler(OrderedSafeExecutor service, long timeout, TimeUnit timeUnit) {\n-        if (null == service) {\n-            return;\n-        }\n-        service.shutdown();\n-        try {\n-            service.awaitTermination(timeout, timeUnit);\n-        } catch (InterruptedException e) {\n-            logger.warn(\"Interrupted when shutting down scheduler : \", e);\n-        }\n-        service.forceShutdown(timeout, timeUnit);\n-    }\n-}"},{"sha":"ab8de35b0430401d1b8d2ea1903646a9799548f1","filename":"src/main/java/org/apache/distributedlog/util/Sequencer.java","status":"removed","additions":0,"deletions":31,"changes":31,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/46e6b70feda2e8ad61ba13928df93b2c94d3dd4e/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Futil%2FSequencer.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/46e6b70feda2e8ad61ba13928df93b2c94d3dd4e/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Futil%2FSequencer.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Futil%2FSequencer.java?ref=46e6b70feda2e8ad61ba13928df93b2c94d3dd4e","patch":"@@ -1,31 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.distributedlog.util;\n-\n-/**\n- * Sequencer generating transaction id.\n- */\n-public interface Sequencer {\n-\n-    /**\n-     * Return next transaction id generated by the sequencer.\n-     *\n-     * @return next transaction id generated by the sequencer.\n-     */\n-    long nextId();\n-}"},{"sha":"3697b3f82f7d011397fef0f50746c418c2ec846e","filename":"src/main/java/org/apache/distributedlog/util/SimplePermitLimiter.java","status":"modified","additions":2,"deletions":3,"changes":5,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Futil%2FSimplePermitLimiter.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Futil%2FSimplePermitLimiter.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Futil%2FSimplePermitLimiter.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -1,4 +1,4 @@\n-/**\n+/*\n  * Licensed to the Apache Software Foundation (ASF) under one\n  * or more contributor license agreements.  See the NOTICE file\n  * distributed with this work for additional information\n@@ -25,8 +25,7 @@\n import org.apache.bookkeeper.stats.StatsLogger;\n import org.apache.bookkeeper.stats.Counter;\n import org.apache.bookkeeper.stats.Gauge;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n+import org.apache.distributedlog.common.util.PermitLimiter;\n \n /**\n  * Simple counter based {@link PermitLimiter}."},{"sha":"2f606e2a87124f6b0525290ecb76102cbbe44c6c","filename":"src/main/java/org/apache/distributedlog/util/Sizable.java","status":"removed","additions":0,"deletions":31,"changes":31,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/46e6b70feda2e8ad61ba13928df93b2c94d3dd4e/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Futil%2FSizable.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/46e6b70feda2e8ad61ba13928df93b2c94d3dd4e/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Futil%2FSizable.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Futil%2FSizable.java?ref=46e6b70feda2e8ad61ba13928df93b2c94d3dd4e","patch":"@@ -1,31 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.distributedlog.util;\n-\n-/**\n- * The {@code Sizable} interface is to provide the capability of calculating size\n- * of any objects.\n- */\n-public interface Sizable {\n-    /**\n-     * Calculate the size for this instance.\n-     *\n-     * @return size of the instance.\n-     */\n-    long size();\n-}"},{"sha":"5bc5af20ec5e95ba7b26ccc6a825eac91f56ac64","filename":"src/main/java/org/apache/distributedlog/util/TimeSequencer.java","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Futil%2FTimeSequencer.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Futil%2FTimeSequencer.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Futil%2FTimeSequencer.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -18,6 +18,7 @@\n package org.apache.distributedlog.util;\n \n import org.apache.distributedlog.DistributedLogConstants;\n+import org.apache.distributedlog.common.util.Sequencer;\n \n /**\n  * Time based sequencer. It generated non-decreasing transaction id using milliseconds."},{"sha":"d90a7f8b2ee588c770728f6a26556d59a74dc4e6","filename":"src/main/java/org/apache/distributedlog/util/Transaction.java","status":"modified","additions":5,"deletions":5,"changes":10,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Futil%2FTransaction.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Futil%2FTransaction.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Futil%2FTransaction.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -1,4 +1,4 @@\n-/**\n+/*\n  * Licensed to the Apache Software Foundation (ASF) under one\n  * or more contributor license agreements.  See the NOTICE file\n  * distributed with this work for additional information\n@@ -18,7 +18,7 @@\n package org.apache.distributedlog.util;\n \n import com.google.common.annotations.Beta;\n-import com.twitter.util.Future;\n+import java.util.concurrent.CompletableFuture;\n \n /**\n  * Util class represents a transaction\n@@ -44,7 +44,7 @@\n     }\n \n     /**\n-     * Listener on the result of an {@link org.apache.distributedlog.util.Transaction.Op}.\n+     * Listener on the result of an {@link Transaction.Op}.\n      *\n      * @param <OpResult>\n      */\n@@ -77,12 +77,12 @@\n \n     /**\n      * Execute the current transaction. If the transaction succeed, all operations will be\n-     * committed (via {@link org.apache.distributedlog.util.Transaction.Op#commit(Object)}.\n+     * committed (via {@link Transaction.Op#commit(Object)}.\n      * Otherwise, all operations will be aborted (via {@link Op#abort(Throwable, Object)}).\n      *\n      * @return future representing the result of transaction execution.\n      */\n-    Future<Void> execute();\n+    CompletableFuture<Void> execute();\n \n     /**\n      * Abort current transaction. If this is called and the transaction haven't been executed by"},{"sha":"99a4155cef0f9c7672e30195067ac13382cbd410","filename":"src/main/java/org/apache/distributedlog/util/Utils.java","status":"modified","additions":173,"deletions":66,"changes":239,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Futil%2FUtils.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Futil%2FUtils.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Futil%2FUtils.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -20,27 +20,30 @@\n import java.io.Closeable;\n import java.io.IOException;\n import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n import java.util.concurrent.atomic.AtomicInteger;\n import javax.annotation.Nullable;\n \n import com.google.common.base.Objects;\n import com.google.common.base.Optional;\n import com.google.common.collect.Lists;\n import com.google.common.io.Closeables;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.bookkeeper.client.BKException;\n import org.apache.distributedlog.DistributedLogConstants;\n import org.apache.distributedlog.ZooKeeperClient;\n+import org.apache.distributedlog.common.concurrent.FutureUtils;\n+import org.apache.distributedlog.exceptions.BKTransmitException;\n import org.apache.distributedlog.exceptions.DLInterruptedException;\n-import org.apache.distributedlog.exceptions.InvalidStreamNameException;\n+import org.apache.distributedlog.exceptions.UnexpectedException;\n import org.apache.distributedlog.exceptions.ZKException;\n-import org.apache.distributedlog.function.VoidFunctions;\n+import org.apache.distributedlog.common.functions.VoidFunctions;\n+import org.apache.distributedlog.io.AsyncAbortable;\n import org.apache.distributedlog.io.AsyncCloseable;\n-import com.twitter.util.Await;\n-import com.twitter.util.Future;\n-import com.twitter.util.Promise;\n-import com.twitter.util.Return;\n-import com.twitter.util.Throw;\n import org.apache.bookkeeper.meta.ZkVersion;\n import org.apache.bookkeeper.versioning.Versioned;\n import org.apache.zookeeper.ZooKeeper;\n@@ -49,17 +52,13 @@\n import org.apache.zookeeper.KeeperException;\n import org.apache.zookeeper.data.ACL;\n import org.apache.zookeeper.data.Stat;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-import scala.runtime.BoxedUnit;\n \n /**\n  * Basic Utilities.\n  */\n+@Slf4j\n public class Utils {\n \n-    private static final Logger logger = LoggerFactory.getLogger(Utils.class);\n-\n     /**\n      * Current time from some arbitrary time base in the past, counting in\n      * nanoseconds, and not affected by settimeofday or similar system clock\n@@ -115,16 +114,15 @@ public static void zkCreateFullPathOptimistic(\n         String path,\n         byte[] data,\n         final List<ACL> acl,\n-        final CreateMode createMode)\n-        throws ZooKeeperClient.ZooKeeperConnectionException, KeeperException, InterruptedException {\n+        final CreateMode createMode) throws IOException, KeeperException {\n         try {\n-            Await.result(zkAsyncCreateFullPathOptimistic(zkc, path, data, acl, createMode));\n+            FutureUtils.result(zkAsyncCreateFullPathOptimistic(zkc, path, data, acl, createMode));\n         } catch (ZooKeeperClient.ZooKeeperConnectionException zkce) {\n             throw zkce;\n         } catch (KeeperException ke) {\n             throw ke;\n         } catch (InterruptedException ie) {\n-            throw ie;\n+            throw new DLInterruptedException(\"Interrupted on create zookeeper path \" + path, ie);\n         } catch (RuntimeException rte) {\n             throw rte;\n         } catch (Exception exc) {\n@@ -208,7 +206,7 @@ public void processResult(int rc, String path, Object ctx, String name) {\n      * @param acl Acl of the zk path\n      * @param createMode Create mode of zk path\n      */\n-    public static Future<BoxedUnit> zkAsyncCreateFullPathOptimistic(\n+    public static CompletableFuture<Void> zkAsyncCreateFullPathOptimistic(\n         final ZooKeeperClient zkc,\n         final String pathToCreate,\n         final byte[] data,\n@@ -234,14 +232,14 @@ public static Future<BoxedUnit> zkAsyncCreateFullPathOptimistic(\n      * @param acl Acl of the zk path\n      * @param createMode Create mode of zk path\n      */\n-    public static Future<BoxedUnit> zkAsyncCreateFullPathOptimistic(\n+    public static CompletableFuture<Void> zkAsyncCreateFullPathOptimistic(\n         final ZooKeeperClient zkc,\n         final String pathToCreate,\n         final Optional<String> parentPathShouldNotCreate,\n         final byte[] data,\n         final List<ACL> acl,\n         final CreateMode createMode) {\n-        final Promise<BoxedUnit> result = new Promise<BoxedUnit>();\n+        final CompletableFuture<Void> result = new CompletableFuture<Void>();\n \n         zkAsyncCreateFullPathOptimisticRecursive(zkc, pathToCreate, parentPathShouldNotCreate,\n                 data, acl, createMode, new AsyncCallback.StringCallback() {\n@@ -263,13 +261,13 @@ public void processResult(int rc, String path, Object ctx, String name) {\n      * @param acl Acl of the zk path\n      * @param createMode Create mode of zk path\n      */\n-    public static Future<BoxedUnit> zkAsyncCreateFullPathOptimisticAndSetData(\n+    public static CompletableFuture<Void> zkAsyncCreateFullPathOptimisticAndSetData(\n         final ZooKeeperClient zkc,\n         final String pathToCreate,\n         final byte[] data,\n         final List<ACL> acl,\n         final CreateMode createMode) {\n-        final Promise<BoxedUnit> result = new Promise<BoxedUnit>();\n+        final CompletableFuture<Void> result = new CompletableFuture<Void>();\n \n         try {\n             zkc.get().setData(pathToCreate, data, -1, new AsyncCallback.StatCallback() {\n@@ -291,32 +289,32 @@ public void processResult(int rc, String path, Object ctx, String name) {\n                 }\n             }, result);\n         } catch (Exception exc) {\n-            result.setException(exc);\n+            result.completeExceptionally(exc);\n         }\n \n         return result;\n     }\n \n-    private static void handleKeeperExceptionCode(int rc, String pathOrMessage, Promise<BoxedUnit> result) {\n+    private static void handleKeeperExceptionCode(int rc, String pathOrMessage, CompletableFuture<Void> result) {\n         if (KeeperException.Code.OK.intValue() == rc) {\n-            result.setValue(BoxedUnit.UNIT);\n+            result.complete(null);\n         } else if (DistributedLogConstants.ZK_CONNECTION_EXCEPTION_RESULT_CODE == rc) {\n-            result.setException(new ZooKeeperClient.ZooKeeperConnectionException(pathOrMessage));\n+            result.completeExceptionally(new ZooKeeperClient.ZooKeeperConnectionException(pathOrMessage));\n         } else if (DistributedLogConstants.DL_INTERRUPTED_EXCEPTION_RESULT_CODE == rc) {\n-            result.setException(new DLInterruptedException(pathOrMessage));\n+            result.completeExceptionally(new DLInterruptedException(pathOrMessage));\n         } else {\n-            result.setException(KeeperException.create(KeeperException.Code.get(rc), pathOrMessage));\n+            result.completeExceptionally(KeeperException.create(KeeperException.Code.get(rc), pathOrMessage));\n         }\n     }\n \n-    public static Future<Versioned<byte[]>> zkGetData(ZooKeeperClient zkc, String path, boolean watch) {\n+    public static CompletableFuture<Versioned<byte[]>> zkGetData(ZooKeeperClient zkc, String path, boolean watch) {\n         ZooKeeper zk;\n         try {\n             zk = zkc.get();\n         } catch (ZooKeeperClient.ZooKeeperConnectionException e) {\n-            return Future.exception(FutureUtils.zkException(e, path));\n+            return FutureUtils.exception(zkException(e, path));\n         } catch (InterruptedException e) {\n-            return Future.exception(FutureUtils.zkException(e, path));\n+            return FutureUtils.exception(zkException(e, path));\n         }\n         return zkGetData(zk, path, watch);\n     }\n@@ -330,35 +328,35 @@ public static Future<Versioned<byte[]>> zkGetData(ZooKeeperClient zkc, String pa\n      *          whether to watch the path\n      * @return future representing the versioned value. null version or null value means path doesn't exist.\n      */\n-    public static Future<Versioned<byte[]>> zkGetData(ZooKeeper zk, String path, boolean watch) {\n-        final Promise<Versioned<byte[]>> promise = new Promise<Versioned<byte[]>>();\n+    public static CompletableFuture<Versioned<byte[]>> zkGetData(ZooKeeper zk, String path, boolean watch) {\n+        final CompletableFuture<Versioned<byte[]>> promise = new CompletableFuture<Versioned<byte[]>>();\n         zk.getData(path, watch, new AsyncCallback.DataCallback() {\n             @Override\n             public void processResult(int rc, String path, Object ctx, byte[] data, Stat stat) {\n                 if (KeeperException.Code.OK.intValue() == rc) {\n                     if (null == stat) {\n-                        promise.setValue(new Versioned<byte[]>(null, null));\n+                        promise.complete(new Versioned<byte[]>(null, null));\n                     } else {\n-                        promise.setValue(new Versioned<byte[]>(data, new ZkVersion(stat.getVersion())));\n+                        promise.complete(new Versioned<byte[]>(data, new ZkVersion(stat.getVersion())));\n                     }\n                 } else if (KeeperException.Code.NONODE.intValue() == rc) {\n-                    promise.setValue(new Versioned<byte[]>(null, null));\n+                    promise.complete(new Versioned<byte[]>(null, null));\n                 } else {\n-                    promise.setException(KeeperException.create(KeeperException.Code.get(rc)));\n+                    promise.completeExceptionally(KeeperException.create(KeeperException.Code.get(rc)));\n                 }\n             }\n         }, null);\n         return promise;\n     }\n \n-    public static Future<ZkVersion> zkSetData(ZooKeeperClient zkc, String path, byte[] data, ZkVersion version) {\n+    public static CompletableFuture<ZkVersion> zkSetData(ZooKeeperClient zkc, String path, byte[] data, ZkVersion version) {\n         ZooKeeper zk;\n         try {\n             zk = zkc.get();\n         } catch (ZooKeeperClient.ZooKeeperConnectionException e) {\n-            return Future.exception(FutureUtils.zkException(e, path));\n+            return FutureUtils.exception(zkException(e, path));\n         } catch (InterruptedException e) {\n-            return Future.exception(FutureUtils.zkException(e, path));\n+            return FutureUtils.exception(zkException(e, path));\n         }\n         return zkSetData(zk, path, data, version);\n     }\n@@ -376,31 +374,31 @@ public static Future<ZkVersion> zkSetData(ZooKeeperClient zkc, String path, byte\n      *          version used to set data\n      * @return future representing the version after this operation.\n      */\n-    public static Future<ZkVersion> zkSetData(ZooKeeper zk, String path, byte[] data, ZkVersion version) {\n-        final Promise<ZkVersion> promise = new Promise<ZkVersion>();\n+    public static CompletableFuture<ZkVersion> zkSetData(ZooKeeper zk, String path, byte[] data, ZkVersion version) {\n+        final CompletableFuture<ZkVersion> promise = new CompletableFuture<ZkVersion>();\n         zk.setData(path, data, version.getZnodeVersion(), new AsyncCallback.StatCallback() {\n             @Override\n             public void processResult(int rc, String path, Object ctx, Stat stat) {\n                 if (KeeperException.Code.OK.intValue() == rc) {\n-                    promise.updateIfEmpty(new Return<ZkVersion>(new ZkVersion(stat.getVersion())));\n+                    promise.complete(new ZkVersion(stat.getVersion()));\n                     return;\n                 }\n-                promise.updateIfEmpty(new Throw<ZkVersion>(\n-                        KeeperException.create(KeeperException.Code.get(rc))));\n+                promise.completeExceptionally(\n+                        KeeperException.create(KeeperException.Code.get(rc)));\n                 return;\n             }\n         }, null);\n         return promise;\n     }\n \n-    public static Future<Void> zkDelete(ZooKeeperClient zkc, String path, ZkVersion version) {\n+    public static CompletableFuture<Void> zkDelete(ZooKeeperClient zkc, String path, ZkVersion version) {\n         ZooKeeper zk;\n         try {\n             zk = zkc.get();\n         } catch (ZooKeeperClient.ZooKeeperConnectionException e) {\n-            return Future.exception(FutureUtils.zkException(e, path));\n+            return FutureUtils.exception(zkException(e, path));\n         } catch (InterruptedException e) {\n-            return Future.exception(FutureUtils.zkException(e, path));\n+            return FutureUtils.exception(zkException(e, path));\n         }\n         return zkDelete(zk, path, version);\n     }\n@@ -416,17 +414,17 @@ public static Future<Void> zkDelete(ZooKeeperClient zkc, String path, ZkVersion\n      *          version used to set data\n      * @return future representing the version after this operation.\n      */\n-    public static Future<Void> zkDelete(ZooKeeper zk, String path, ZkVersion version) {\n-        final Promise<Void> promise = new Promise<Void>();\n+    public static CompletableFuture<Void> zkDelete(ZooKeeper zk, String path, ZkVersion version) {\n+        final CompletableFuture<Void> promise = new CompletableFuture<Void>();\n         zk.delete(path, version.getZnodeVersion(), new AsyncCallback.VoidCallback() {\n             @Override\n             public void processResult(int rc, String path, Object ctx) {\n                 if (KeeperException.Code.OK.intValue() == rc) {\n-                    promise.updateIfEmpty(new Return<Void>(null));\n+                    promise.complete(null);\n                     return;\n                 }\n-                promise.updateIfEmpty(new Throw<Void>(\n-                        KeeperException.create(KeeperException.Code.get(rc))));\n+                promise.completeExceptionally(\n+                        KeeperException.create(KeeperException.Code.get(rc)));\n                 return;\n             }\n         }, null);\n@@ -446,35 +444,35 @@ public void processResult(int rc, String path, Object ctx) {\n      * false if the node doesn't exist, otherwise future will throw exception\n      *\n      */\n-    public static Future<Boolean> zkDeleteIfNotExist(ZooKeeperClient zkc, String path, ZkVersion version) {\n+    public static CompletableFuture<Boolean> zkDeleteIfNotExist(ZooKeeperClient zkc, String path, ZkVersion version) {\n         ZooKeeper zk;\n         try {\n             zk = zkc.get();\n         } catch (ZooKeeperClient.ZooKeeperConnectionException e) {\n-            return Future.exception(FutureUtils.zkException(e, path));\n+            return FutureUtils.exception(zkException(e, path));\n         } catch (InterruptedException e) {\n-            return Future.exception(FutureUtils.zkException(e, path));\n+            return FutureUtils.exception(zkException(e, path));\n         }\n-        final Promise<Boolean> promise = new Promise<Boolean>();\n+        final CompletableFuture<Boolean> promise = new CompletableFuture<Boolean>();\n         zk.delete(path, version.getZnodeVersion(), new AsyncCallback.VoidCallback() {\n             @Override\n             public void processResult(int rc, String path, Object ctx) {\n                 if (KeeperException.Code.OK.intValue() == rc ) {\n-                    promise.setValue(true);\n+                    promise.complete(true);\n                 } else if (KeeperException.Code.NONODE.intValue() == rc) {\n-                    promise.setValue(false);\n+                    promise.complete(false);\n                 } else {\n-                    promise.setException(KeeperException.create(KeeperException.Code.get(rc)));\n+                    promise.completeExceptionally(KeeperException.create(KeeperException.Code.get(rc)));\n                 }\n             }\n         }, null);\n         return promise;\n     }\n \n-    public static Future<Void> asyncClose(@Nullable AsyncCloseable closeable,\n+    public static CompletableFuture<Void> asyncClose(@Nullable AsyncCloseable closeable,\n                                           boolean swallowIOException) {\n         if (null == closeable) {\n-            return Future.Void();\n+            return FutureUtils.Void();\n         } else if (swallowIOException) {\n             return FutureUtils.ignore(closeable.asyncClose());\n         } else {\n@@ -548,7 +546,7 @@ public static void close(@Nullable AsyncCloseable closeable)\n         if (null == closeable) {\n             return;\n         }\n-        FutureUtils.result(closeable.asyncClose());\n+        Utils.ioResult(closeable.asyncClose());\n     }\n \n     /**\n@@ -562,7 +560,7 @@ public static void closeQuietly(@Nullable AsyncCloseable closeable) {\n             return;\n         }\n         try {\n-            FutureUtils.result(closeable.asyncClose());\n+            Utils.ioResult(closeable.asyncClose());\n         } catch (IOException e) {\n             // no-op. the exception is swallowed.\n         }\n@@ -575,7 +573,7 @@ public static void closeQuietly(@Nullable AsyncCloseable closeable) {\n      *          closeables to close\n      * @return future represents the close future\n      */\n-    public static Future<Void> closeSequence(ExecutorService executorService,\n+    public static CompletableFuture<Void> closeSequence(ExecutorService executorService,\n                                              AsyncCloseable... closeables) {\n         return closeSequence(executorService, false, closeables);\n     }\n@@ -588,7 +586,7 @@ public static Future<Void> closeSequence(ExecutorService executorService,\n      * @param closeables list of closeables\n      * @return future represents the close future.\n      */\n-    public static Future<Void> closeSequence(ExecutorService executorService,\n+    public static CompletableFuture<Void> closeSequence(ExecutorService executorService,\n                                              boolean ignoreCloseError,\n                                              AsyncCloseable... closeables) {\n         List<AsyncCloseable> closeableList = Lists.newArrayListWithExpectedSize(closeables.length);\n@@ -602,7 +600,8 @@ public static Future<Void> closeSequence(ExecutorService executorService,\n         return FutureUtils.processList(\n                 closeableList,\n                 ignoreCloseError ? AsyncCloseable.CLOSE_FUNC_IGNORE_ERRORS : AsyncCloseable.CLOSE_FUNC,\n-                executorService).map(VoidFunctions.LIST_TO_VOID_FUNC);\n+                executorService\n+        ).thenApply(VoidFunctions.LIST_TO_VOID_FUNC);\n     }\n \n     /**\n@@ -636,4 +635,112 @@ public static String getParent(final String path) {\n         return path.substring(0, lastIndex);\n     }\n \n+    /**\n+     * Convert the <i>throwable</i> to zookeeper related exceptions.\n+     *\n+     * @param throwable cause\n+     * @param path zookeeper path\n+     * @return zookeeper related exceptions\n+     */\n+    public static Throwable zkException(Throwable throwable, String path) {\n+        if (throwable instanceof KeeperException) {\n+            return new ZKException(\"Encountered zookeeper exception on \" + path, (KeeperException) throwable);\n+        } else if (throwable instanceof ZooKeeperClient.ZooKeeperConnectionException) {\n+            return new ZKException(\"Encountered zookeeper connection loss on \" + path,\n+                    KeeperException.Code.CONNECTIONLOSS);\n+        } else if (throwable instanceof InterruptedException) {\n+            return new DLInterruptedException(\"Interrupted on operating \" + path, throwable);\n+        } else {\n+            return new UnexpectedException(\"Encountered unexpected exception on operatiing \" + path, throwable);\n+        }\n+    }\n+\n+    /**\n+     * Create transmit exception from transmit result.\n+     *\n+     * @param transmitResult\n+     *          transmit result (basically bk exception code)\n+     * @return transmit exception\n+     */\n+    public static BKTransmitException transmitException(int transmitResult) {\n+        return new BKTransmitException(\"Failed to write to bookkeeper; Error is (\"\n+            + transmitResult + \") \"\n+            + BKException.getMessage(transmitResult), transmitResult);\n+    }\n+\n+    /**\n+     * A specific version of {@link FutureUtils#result(CompletableFuture)} to handle known exception issues.\n+     */\n+    public static <T> T ioResult(CompletableFuture<T> result) throws IOException {\n+        return FutureUtils.result(\n+            result,\n+            (cause) -> {\n+                if (cause instanceof IOException) {\n+                    return (IOException) cause;\n+                } else if (cause instanceof KeeperException) {\n+                    return new ZKException(\"Encountered zookeeper exception on waiting result\",\n+                        (KeeperException) cause);\n+                } else if (cause instanceof BKException) {\n+                    return new BKTransmitException(\"Encountered bookkeeper exception on waiting result\",\n+                        ((BKException) cause).getCode());\n+                } else if (cause instanceof InterruptedException) {\n+                    return new DLInterruptedException(\"Interrupted on waiting result\", cause);\n+                } else {\n+                    return new IOException(\"Encountered exception on waiting result\", cause);\n+                }\n+            });\n+    }\n+\n+    /**\n+     * A specific version of {@link FutureUtils#result(CompletableFuture, long, TimeUnit)}\n+     * to handle known exception issues.\n+     */\n+    public static <T> T ioResult(CompletableFuture<T> result, long timeout, TimeUnit timeUnit)\n+            throws IOException, TimeoutException {\n+        return FutureUtils.result(\n+            result,\n+            (cause) -> {\n+                if (cause instanceof IOException) {\n+                    return (IOException) cause;\n+                } else if (cause instanceof KeeperException) {\n+                    return new ZKException(\"Encountered zookeeper exception on waiting result\",\n+                        (KeeperException) cause);\n+                } else if (cause instanceof BKException) {\n+                    return new BKTransmitException(\"Encountered bookkeeper exception on waiting result\",\n+                        ((BKException) cause).getCode());\n+                } else if (cause instanceof InterruptedException) {\n+                    return new DLInterruptedException(\"Interrupted on waiting result\", cause);\n+                } else {\n+                    return new IOException(\"Encountered exception on waiting result\", cause);\n+                }\n+            },\n+            timeout,\n+            timeUnit);\n+    }\n+\n+    /**\n+     * Abort async <i>abortable</i>\n+     *\n+     * @param abortable the {@code AsyncAbortable} object to be aborted, or null, in which case this method\n+     *                  does nothing.\n+     * @param swallowIOException if true, don't propagate IO exceptions thrown by the {@code abort} methods\n+     * @throws IOException if {@code swallowIOException} is false and {@code abort} throws an {@code IOException}\n+     */\n+    public static void abort(@Nullable AsyncAbortable abortable,\n+                             boolean swallowIOException)\n+            throws IOException {\n+        if (null == abortable) {\n+            return;\n+        }\n+        try {\n+            ioResult(abortable.asyncAbort());\n+        } catch (Exception ioe) {\n+            if (swallowIOException) {\n+                log.warn(\"IOException thrown while aborting Abortable {} : \", abortable, ioe);\n+            } else {\n+                throw ioe;\n+            }\n+        }\n+    }\n+\n }"},{"sha":"1dd702f1639c48489a01f019c1e1de277a3ec758","filename":"src/main/java/org/apache/distributedlog/zk/LimitedPermitManager.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fzk%2FLimitedPermitManager.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fzk%2FLimitedPermitManager.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fzk%2FLimitedPermitManager.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -17,7 +17,7 @@\n  */\n package org.apache.distributedlog.zk;\n \n-import org.apache.distributedlog.util.PermitManager;\n+import org.apache.distributedlog.common.util.PermitManager;\n import org.apache.bookkeeper.stats.Gauge;\n import org.apache.bookkeeper.stats.NullStatsLogger;\n import org.apache.bookkeeper.stats.StatsLogger;"},{"sha":"aeabbfa4eb098d8cbc51ca054d2c8902b37fdc9e","filename":"src/main/java/org/apache/distributedlog/zk/ZKTransaction.java","status":"modified","additions":13,"deletions":14,"changes":27,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fzk%2FZKTransaction.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fzk%2FZKTransaction.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fzk%2FZKTransaction.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -18,18 +18,17 @@\n package org.apache.distributedlog.zk;\n \n import com.google.common.collect.Lists;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicBoolean;\n import org.apache.distributedlog.ZooKeeperClient;\n-import org.apache.distributedlog.util.FutureUtils;\n+import org.apache.distributedlog.common.concurrent.FutureUtils;\n import org.apache.distributedlog.util.Transaction;\n-import com.twitter.util.Future;\n-import com.twitter.util.Promise;\n+import org.apache.distributedlog.util.Utils;\n import org.apache.zookeeper.AsyncCallback;\n import org.apache.zookeeper.KeeperException;\n import org.apache.zookeeper.OpResult;\n \n-import java.util.List;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-\n /**\n  * ZooKeeper Transaction\n  */\n@@ -38,14 +37,14 @@ public class ZKTransaction implements Transaction<Object>, AsyncCallback.MultiCa\n     private final ZooKeeperClient zkc;\n     private final List<ZKOp> ops;\n     private final List<org.apache.zookeeper.Op> zkOps;\n-    private final Promise<Void> result;\n+    private final CompletableFuture<Void> result;\n     private final AtomicBoolean done = new AtomicBoolean(false);\n \n     public ZKTransaction(ZooKeeperClient zkc) {\n         this.zkc = zkc;\n         this.ops = Lists.newArrayList();\n         this.zkOps = Lists.newArrayList();\n-        this.result = new Promise<Void>();\n+        this.result = new CompletableFuture<Void>();\n     }\n \n     @Override\n@@ -60,16 +59,16 @@ public void addOp(Op<Object> operation) {\n     }\n \n     @Override\n-    public Future<Void> execute() {\n+    public CompletableFuture<Void> execute() {\n         if (!done.compareAndSet(false, true)) {\n             return result;\n         }\n         try {\n             zkc.get().multi(zkOps, this, result);\n         } catch (ZooKeeperClient.ZooKeeperConnectionException e) {\n-            result.setException(FutureUtils.zkException(e, \"\"));\n+            result.completeExceptionally(Utils.zkException(e, \"\"));\n         } catch (InterruptedException e) {\n-            result.setException(FutureUtils.zkException(e, \"\"));\n+            result.completeExceptionally(Utils.zkException(e, \"\"));\n         }\n         return result;\n     }\n@@ -82,7 +81,7 @@ public void abort(Throwable cause) {\n         for (int i = 0; i < ops.size(); i++) {\n             ops.get(i).abortOpResult(cause, null);\n         }\n-        FutureUtils.setException(result, cause);\n+        FutureUtils.completeExceptionally(result, cause);\n     }\n \n     @Override\n@@ -91,13 +90,13 @@ public void processResult(int rc, String path, Object ctx, List<OpResult> result\n             for (int i = 0; i < ops.size(); i++) {\n                 ops.get(i).commitOpResult(results.get(i));\n             }\n-            FutureUtils.setValue(result, null);\n+            FutureUtils.complete(result, null);\n         } else {\n             KeeperException ke = KeeperException.create(KeeperException.Code.get(rc));\n             for (int i = 0; i < ops.size(); i++) {\n                 ops.get(i).abortOpResult(ke, null != results ? results.get(i) : null);\n             }\n-            FutureUtils.setException(result, ke);\n+            FutureUtils.completeExceptionally(result, ke);\n         }\n     }\n }"},{"sha":"40920db1bcd1c271452d42c10c388ad3577767bc","filename":"src/main/resources/findbugsExclude.xml","status":"modified","additions":73,"deletions":0,"changes":73,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fresources%2FfindbugsExclude.xml","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Fmain%2Fresources%2FfindbugsExclude.xml","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fresources%2FfindbugsExclude.xml?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -37,4 +37,77 @@\n     <Method name=\"run\" />\n     <Bug pattern=\"JLM_JSR166_UTILCONCURRENT_MONITORENTER\" />\n   </Match>\n+  <Match>\n+    <Class name=\"org.apache.distributedlog.BKLogReadHandler$1\" />\n+    <Method name=\"onSuccess\" />\n+    <Bug pattern=\"NP_NONNULL_PARAM_VIOLATION\" />\n+  </Match>\n+  <Match>\n+    <Class name=\"org.apache.distributedlog.BookKeeperClient$2\" />\n+    <Bug pattern=\"NP_NONNULL_PARAM_VIOLATION\" />\n+  </Match>\n+  <Match>\n+    <Class name=\"org.apache.distributedlog.ReadUtils\" />\n+    <Bug pattern=\"NP_NONNULL_PARAM_VIOLATION\" />\n+  </Match>\n+  <Match>\n+    <Class name=\"org.apache.distributedlog.ReadUtils$2\" />\n+    <Bug pattern=\"NP_NONNULL_PARAM_VIOLATION\" />\n+  </Match>\n+  <Match>\n+    <Class name=\"org.apache.distributedlog.auditor.DLAuditor$2\" />\n+    <Bug pattern=\"NP_NONNULL_PARAM_VIOLATION\" />\n+  </Match>\n+  <Match>\n+    <Class name=\"org.apache.distributedlog.auditor.DLAuditor$8\" />\n+    <Bug pattern=\"NP_NONNULL_PARAM_VIOLATION\" />\n+  </Match>\n+  <Match>\n+    <Class name=\"org.apache.distributedlog.bk.SimpleLedgerAllocator$4\" />\n+    <Bug pattern=\"NP_NONNULL_PARAM_VIOLATION\" />\n+  </Match>\n+  <Match>\n+    <Class name=\"org.apache.distributedlog.bk.SimpleLedgerAllocator$4$1\" />\n+    <Bug pattern=\"NP_NONNULL_PARAM_VIOLATION\" />\n+  </Match>\n+  <Match>\n+    <Class name=\"org.apache.distributedlog.bk.SimpleLedgerAllocator$5\" />\n+    <Bug pattern=\"NP_NONNULL_PARAM_VIOLATION\" />\n+  </Match>\n+  <Match>\n+    <Class name=\"org.apache.distributedlog.impl.acl.ZKAccessControl$4\" />\n+    <Bug pattern=\"NP_NONNULL_PARAM_VIOLATION\" />\n+  </Match>\n+  <Match>\n+    <Class name=\"org.apache.distributedlog.impl.acl.ZKAccessControlManager$1\" />\n+    <Bug pattern=\"NP_NONNULL_PARAM_VIOLATION\" />\n+  </Match>\n+  <Match>\n+    <Class name=\"org.apache.distributedlog.impl.acl.ZKAccessControlManager$1$1\" />\n+    <Bug pattern=\"NP_NONNULL_PARAM_VIOLATION\" />\n+  </Match>\n+  <Match>\n+    <Class name=\"org.apache.distributedlog.impl.metadata.ZKLogStreamMetadataStore$1$1\" />\n+    <Bug pattern=\"NP_NONNULL_PARAM_VIOLATION\" />\n+  </Match>\n+  <Match>\n+    <Class name=\"org.apache.distributedlog.lock.ZKSessionLock\" />\n+    <Bug pattern=\"NP_NONNULL_PARAM_VIOLATION\" />\n+  </Match>\n+  <Match>\n+    <Class name=\"org.apache.distributedlog.lock.ZKSessionLock$12\" />\n+    <Bug pattern=\"NP_NONNULL_PARAM_VIOLATION\" />\n+  </Match>\n+  <Match>\n+    <Class name=\"org.apache.distributedlog.lock.ZKSessionLock$13$1\" />\n+    <Bug pattern=\"NP_NONNULL_PARAM_VIOLATION\" />\n+  </Match>\n+  <Match>\n+    <Class name=\"org.apache.distributedlog.util.Utils\" />\n+    <Bug pattern=\"NP_NONNULL_PARAM_VIOLATION\" />\n+  </Match>\n+  <Match>\n+    <Class name=\"org.apache.distributedlog.util.Utils$6\" />\n+    <Bug pattern=\"NP_NONNULL_PARAM_VIOLATION\" />\n+  </Match>\n </FindBugsFilter>"},{"sha":"d821b050bbe544ac33901656ec9dc874758f8157","filename":"src/test/java/org/apache/distributedlog/DLMTestUtil.java","status":"modified","additions":28,"deletions":27,"changes":55,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FDLMTestUtil.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FDLMTestUtil.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FDLMTestUtil.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -17,20 +17,21 @@\n  */\n package org.apache.distributedlog;\n \n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.distributedlog.api.AsyncLogWriter;\n+import org.apache.distributedlog.api.DistributedLogManager;\n+import org.apache.distributedlog.api.LogReader;\n+import org.apache.distributedlog.api.MetadataAccessor;\n+import org.apache.distributedlog.api.namespace.Namespace;\n import org.apache.distributedlog.impl.BKNamespaceDriver;\n import org.apache.distributedlog.impl.logsegment.BKLogSegmentEntryWriter;\n import org.apache.distributedlog.logsegment.LogSegmentEntryStore;\n-import org.apache.distributedlog.namespace.DistributedLogNamespace;\n-import org.apache.distributedlog.namespace.DistributedLogNamespaceBuilder;\n+import org.apache.distributedlog.api.namespace.NamespaceBuilder;\n import org.apache.distributedlog.namespace.NamespaceDriver;\n import org.apache.distributedlog.util.ConfUtils;\n-import org.apache.distributedlog.util.FutureUtils;\n-import org.apache.distributedlog.util.PermitLimiter;\n-import org.apache.distributedlog.util.RetryPolicyUtils;\n+import org.apache.distributedlog.common.util.PermitLimiter;\n import org.apache.distributedlog.util.Utils;\n-import com.twitter.util.Await;\n-import com.twitter.util.Duration;\n-import com.twitter.util.Future;\n import org.apache.bookkeeper.client.BookKeeper;\n import org.apache.bookkeeper.client.LedgerHandle;\n import org.apache.bookkeeper.conf.ServerConfiguration;\n@@ -78,7 +79,7 @@ public static Map<Long, LogSegmentMetadata> readLogSegments(ZooKeeperClient zkc,\n             new HashMap<Long, LogSegmentMetadata>(children.size());\n         for (String child : children) {\n             LogSegmentMetadata segment =\n-                    FutureUtils.result(LogSegmentMetadata.read(zkc, ledgerPath + \"/\" + child));\n+                    Utils.ioResult(LogSegmentMetadata.read(zkc, ledgerPath + \"/\" + child));\n             LOG.info(\"Read segment {} : {}\", child, segment);\n             segments.put(segment.getLogSegmentSequenceNumber(), segment);\n         }\n@@ -92,7 +93,7 @@ public static URI createDLMURI(int port, String path) throws Exception {\n     public static DistributedLogManager createNewDLM(String name,\n                                                      DistributedLogConfiguration conf,\n                                                      URI uri) throws Exception {\n-        DistributedLogNamespace namespace = DistributedLogNamespaceBuilder.newBuilder()\n+        Namespace namespace = NamespaceBuilder.newBuilder()\n                 .conf(conf).uri(uri).build();\n         return namespace.openLog(name);\n     }\n@@ -102,7 +103,7 @@ static MetadataAccessor createNewMetadataAccessor(DistributedLogConfiguration co\n                                                       URI uri) throws Exception {\n         // TODO: Metadata Accessor seems to be a legacy object which only used by kestrel\n         //       (we might consider deprecating this)\n-        DistributedLogNamespace namespace = DistributedLogNamespaceBuilder.newBuilder()\n+        Namespace namespace = NamespaceBuilder.newBuilder()\n                 .conf(conf).uri(uri).build();\n         return namespace.getNamespaceDriver().getMetadataAccessor(name);\n     }\n@@ -113,7 +114,7 @@ public static void fenceStream(DistributedLogConfiguration conf, URI uri, String\n             List<LogSegmentMetadata> logSegmentList = dlm.getLogSegments();\n             LogSegmentMetadata lastSegment = logSegmentList.get(logSegmentList.size() - 1);\n             LogSegmentEntryStore entryStore = dlm.getNamespaceDriver().getLogSegmentEntryStore(NamespaceDriver.Role.READER);\n-            Utils.close(FutureUtils.result(entryStore.openRandomAccessReader(lastSegment, true)));\n+            Utils.close(Utils.ioResult(entryStore.openRandomAccessReader(lastSegment, true)));\n         } finally {\n             dlm.close();\n         }\n@@ -313,12 +314,12 @@ public static long generateLogSegmentNonPartitioned(DistributedLogManager dlm, i\n         for (int i = 0; i < controlEntries; ++i) {\n             LogRecord record = DLMTestUtil.getLargeLogRecordInstance(txid);\n             record.setControl();\n-            Await.result(out.write(record));\n+            Utils.ioResult(out.write(record));\n             txid += txidStep;\n         }\n         for (int i = 0; i < userEntries; ++i) {\n             LogRecord record = DLMTestUtil.getLargeLogRecordInstance(txid);\n-            Await.result(out.write(record));\n+            Utils.ioResult(out.write(record));\n             txid += txidStep;\n         }\n         Utils.close(out);\n@@ -339,7 +340,7 @@ public static void injectLogSegmentWithGivenLogSegmentSeqNo(DistributedLogManage\n             throws Exception {\n         BKDistributedLogManager dlm = (BKDistributedLogManager) manager;\n         BKLogWriteHandler writeHandler = dlm.createWriteHandler(false);\n-        FutureUtils.result(writeHandler.lockHandler());\n+        Utils.ioResult(writeHandler.lockHandler());\n         // Start a log segment with a given ledger seq number.\n         BookKeeperClient bkc = getBookKeeperClient(dlm);\n         LedgerHandle lh = bkc.get().createLedger(conf.getEnsembleSize(), conf.getWriteQuorumSize(),\n@@ -377,20 +378,20 @@ public static void injectLogSegmentWithGivenLogSegmentSeqNo(DistributedLogManage\n             for (long j = 1; j <= segmentSize; j++) {\n                 writer.write(DLMTestUtil.getLogRecordInstance(txid++));\n             }\n-            FutureUtils.result(writer.flushAndCommit());\n+            Utils.ioResult(writer.flushAndCommit());\n         }\n         if (completeLogSegment) {\n-            FutureUtils.result(writeHandler.completeAndCloseLogSegment(writer));\n+            Utils.ioResult(writeHandler.completeAndCloseLogSegment(writer));\n         }\n-        FutureUtils.result(writeHandler.unlockHandler());\n+        Utils.ioResult(writeHandler.unlockHandler());\n     }\n \n     public static void injectLogSegmentWithLastDLSN(DistributedLogManager manager, DistributedLogConfiguration conf,\n                                                     long logSegmentSeqNo, long startTxID, long segmentSize,\n                                                     boolean recordWrongLastDLSN) throws Exception {\n         BKDistributedLogManager dlm = (BKDistributedLogManager) manager;\n         BKLogWriteHandler writeHandler = dlm.createWriteHandler(false);\n-        FutureUtils.result(writeHandler.lockHandler());\n+        Utils.ioResult(writeHandler.lockHandler());\n         // Start a log segment with a given ledger seq number.\n         BookKeeperClient bkc = getBookKeeperClient(dlm);\n         LedgerHandle lh = bkc.get().createLedger(conf.getEnsembleSize(), conf.getWriteQuorumSize(),\n@@ -425,14 +426,14 @@ public static void injectLogSegmentWithLastDLSN(DistributedLogManager manager, D\n         long txid = startTxID;\n         DLSN wrongDLSN = null;\n         for (long j = 1; j <= segmentSize; j++) {\n-            DLSN dlsn = Await.result(writer.asyncWrite(DLMTestUtil.getLogRecordInstance(txid++)));\n+            DLSN dlsn = Utils.ioResult(writer.asyncWrite(DLMTestUtil.getLogRecordInstance(txid++)));\n             if (j == (segmentSize - 1)) {\n                 wrongDLSN = dlsn;\n             }\n         }\n         assertNotNull(wrongDLSN);\n         if (recordWrongLastDLSN) {\n-            FutureUtils.result(writer.asyncClose());\n+            Utils.ioResult(writer.asyncClose());\n             writeHandler.completeAndCloseLogSegment(\n                     writeHandler.inprogressZNodeName(writer.getLogSegmentId(), writer.getStartTxId(), writer.getLogSegmentSequenceNumber()),\n                     writer.getLogSegmentSequenceNumber(),\n@@ -443,9 +444,9 @@ public static void injectLogSegmentWithLastDLSN(DistributedLogManager manager, D\n                     wrongDLSN.getEntryId(),\n                     wrongDLSN.getSlotId());\n         } else {\n-            FutureUtils.result(writeHandler.completeAndCloseLogSegment(writer));\n+            Utils.ioResult(writeHandler.completeAndCloseLogSegment(writer));\n         }\n-        FutureUtils.result(writeHandler.unlockHandler());\n+        Utils.ioResult(writeHandler.unlockHandler());\n     }\n \n     public static void updateSegmentMetadata(ZooKeeperClient zkc, LogSegmentMetadata segment) throws Exception {\n@@ -469,18 +470,18 @@ public static ServerConfiguration loadTestBkConf() {\n         return conf;\n     }\n \n-    public static <T> void validateFutureFailed(Future<T> future, Class exClass) {\n+    public static <T> void validateFutureFailed(CompletableFuture<T> future, Class exClass) {\n         try {\n-            Await.result(future);\n+            Utils.ioResult(future);\n         } catch (Exception ex) {\n             LOG.info(\"Expected: {} Actual: {}\", exClass.getName(), ex.getClass().getName());\n             assertTrue(\"exceptions types equal\", exClass.isInstance(ex));\n         }\n     }\n \n-    public static <T> T validateFutureSucceededAndGetResult(Future<T> future) throws Exception {\n+    public static <T> T validateFutureSucceededAndGetResult(CompletableFuture<T> future) throws Exception {\n         try {\n-            return Await.result(future, Duration.fromSeconds(10));\n+            return Utils.ioResult(future, 10, TimeUnit.SECONDS);\n         } catch (Exception ex) {\n             fail(\"unexpected exception \" + ex.getClass().getName());\n             throw ex;"},{"sha":"126d3372514dd178ba225f9f8c95534b6fbfd616","filename":"src/test/java/org/apache/distributedlog/NonBlockingReadsTestUtil.java","status":"modified","additions":7,"deletions":6,"changes":13,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FNonBlockingReadsTestUtil.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FNonBlockingReadsTestUtil.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FNonBlockingReadsTestUtil.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -17,10 +17,11 @@\n  */\n package org.apache.distributedlog;\n \n+import org.apache.distributedlog.api.DistributedLogManager;\n import org.apache.distributedlog.exceptions.LogEmptyException;\n import org.apache.distributedlog.exceptions.LogNotFoundException;\n import org.apache.distributedlog.exceptions.LogReadException;\n-import org.apache.distributedlog.util.FutureUtils;\n+import org.apache.distributedlog.util.Utils;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -123,19 +124,19 @@ static void writeRecordsForNonBlockingReads(DistributedLogConfiguration conf,\n         for (long i = 0; i < 3; i++) {\n             BKAsyncLogWriter writer = (BKAsyncLogWriter) dlm.startAsyncLogSegmentNonPartitioned();\n             for (long j = 1; j < segmentSize; j++) {\n-                FutureUtils.result(writer.write(DLMTestUtil.getLogRecordInstance(txId++)));\n+                Utils.ioResult(writer.write(DLMTestUtil.getLogRecordInstance(txId++)));\n             }\n             if (recover) {\n-                FutureUtils.result(writer.write(DLMTestUtil.getLogRecordInstance(txId++)));\n+                Utils.ioResult(writer.write(DLMTestUtil.getLogRecordInstance(txId++)));\n                 TimeUnit.MILLISECONDS.sleep(300);\n                 writer.abort();\n                 LOG.debug(\"Recovering Segments\");\n                 BKLogWriteHandler blplm = ((BKDistributedLogManager) (dlm)).createWriteHandler(true);\n-                FutureUtils.result(blplm.recoverIncompleteLogSegments());\n-                FutureUtils.result(blplm.asyncClose());\n+                Utils.ioResult(blplm.recoverIncompleteLogSegments());\n+                Utils.ioResult(blplm.asyncClose());\n                 LOG.debug(\"Recovered Segments\");\n             } else {\n-                FutureUtils.result(writer.write(DLMTestUtil.getLogRecordInstance(txId++)));\n+                Utils.ioResult(writer.write(DLMTestUtil.getLogRecordInstance(txId++)));\n                 writer.closeAndComplete();\n             }\n             TimeUnit.MILLISECONDS.sleep(300);"},{"sha":"ae775221a1fea3d48dd3e24ad0ed5f7b5df78bbc","filename":"src/test/java/org/apache/distributedlog/TestAppendOnlyStreamReader.java","status":"modified","additions":1,"deletions":4,"changes":5,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FTestAppendOnlyStreamReader.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FTestAppendOnlyStreamReader.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FTestAppendOnlyStreamReader.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -17,17 +17,14 @@\n  */\n package org.apache.distributedlog;\n \n-import java.io.ByteArrayInputStream;\n-import java.net.URI;\n import java.util.Arrays;\n \n+import org.apache.distributedlog.api.DistributedLogManager;\n import org.junit.Rule;\n import org.junit.Test;\n import org.junit.rules.TestName;\n \n import org.apache.distributedlog.exceptions.EndOfStreamException;\n-import com.twitter.util.Await;\n-import com.twitter.util.Duration;\n \n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;"},{"sha":"fc1f241f0b13457aeb1d88fadc77c4bf03c9f4a0","filename":"src/test/java/org/apache/distributedlog/TestAppendOnlyStreamWriter.java","status":"modified","additions":14,"deletions":14,"changes":28,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FTestAppendOnlyStreamWriter.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FTestAppendOnlyStreamWriter.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FTestAppendOnlyStreamWriter.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -20,18 +20,18 @@\n import java.io.ByteArrayInputStream;\n import java.net.URI;\n \n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.distributedlog.api.DistributedLogManager;\n import org.apache.distributedlog.exceptions.BKTransmitException;\n-import org.apache.distributedlog.util.FutureUtils;\n+import org.apache.distributedlog.util.Utils;\n import org.junit.Rule;\n import org.junit.Test;\n import org.junit.rules.TestName;\n \n import org.apache.distributedlog.exceptions.EndOfStreamException;\n import org.apache.distributedlog.exceptions.WriteException;\n import org.apache.distributedlog.util.FailpointUtils;\n-import com.twitter.util.Await;\n-import com.twitter.util.Duration;\n-import com.twitter.util.Future;\n \n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -90,14 +90,14 @@ public void testWriteFutureDoesNotCompleteUntilWritePersisted() throws Exception\n         // happen very quickly. But we can test that the mechanics of the future write and api are basically\n         // correct.\n         AppendOnlyStreamWriter writer = dlmwriter.getAppendOnlyStreamWriter();\n-        Future<DLSN> dlsnFuture = writer.write(DLMTestUtil.repeatString(\"abc\", 11).getBytes());\n+        CompletableFuture<DLSN> dlsnFuture = writer.write(DLMTestUtil.repeatString(\"abc\", 11).getBytes());\n \n         // The real problem is the fsync completes before writes are submitted, so it never takes effect.\n         Thread.sleep(1000);\n-        assertFalse(dlsnFuture.isDefined());\n+        assertFalse(dlsnFuture.isDone());\n         writer.force(false);\n         // Must not throw.\n-        Await.result(dlsnFuture, Duration.fromSeconds(5));\n+        Utils.ioResult(dlsnFuture, 5, TimeUnit.SECONDS);\n         writer.close();\n         dlmwriter.close();\n \n@@ -124,11 +124,11 @@ public void testPositionUpdatesOnlyAfterWriteCompletion() throws Exception {\n         // happen very quickly. But we can test that the mechanics of the future write and api are basically\n         // correct.\n         AppendOnlyStreamWriter writer = dlmwriter.getAppendOnlyStreamWriter();\n-        Future<DLSN> dlsnFuture = writer.write(byteStream);\n+        CompletableFuture<DLSN> dlsnFuture = writer.write(byteStream);\n         Thread.sleep(100);\n \n         // Write hasn't been persisted, position better not be updated.\n-        assertFalse(dlsnFuture.isDefined());\n+        assertFalse(dlsnFuture.isDone());\n         assertEquals(0, writer.position());\n         writer.force(false);\n         // Position guaranteed to be accurate after writer.force().\n@@ -167,7 +167,7 @@ public void testPositionDoesntUpdateBeforeWriteCompletion() throws Exception {\n         // Much much less than the flush time, small enough not to slow down tests too much, just\n         // gives a little more confidence.\n         Thread.sleep(500);\n-        Future<DLSN> dlsnFuture = writer.write(byteStream);\n+        CompletableFuture<DLSN> dlsnFuture = writer.write(byteStream);\n         assertEquals(0, writer.position());\n \n         writer.close();\n@@ -188,7 +188,7 @@ public void testPositionUpdatesOnlyAfterWriteCompletionWithoutFsync() throws Exc\n         AppendOnlyStreamWriter writer = dlmwriter.getAppendOnlyStreamWriter();\n         assertEquals(0, writer.position());\n \n-        Await.result(writer.write(byteStream));\n+        Utils.ioResult(writer.write(byteStream));\n         Thread.sleep(100); // let WriteCompleteListener have time to run\n         assertEquals(33, writer.position());\n \n@@ -205,12 +205,12 @@ public void testWriterStartsAtTxidZeroForEmptyStream() throws Exception {\n         BKDistributedLogManager dlm = (BKDistributedLogManager) createNewDLM(conf, name);\n \n         URI uri = createDLMURI(\"/\" + name);\n-        FutureUtils.result(dlm.getWriterMetadataStore().getLog(uri, name, true, true));\n+        Utils.ioResult(dlm.getWriterMetadataStore().getLog(uri, name, true, true));\n \n         // Log exists but is empty, better not throw.\n         AppendOnlyStreamWriter writer = dlm.getAppendOnlyStreamWriter();\n         byte[] byteStream = DLMTestUtil.repeatString(\"a\", 1025).getBytes();\n-        Await.result(writer.write(byteStream));\n+        Utils.ioResult(writer.write(byteStream));\n \n         writer.close();\n         dlm.close();\n@@ -266,7 +266,7 @@ long writeRecordsAndReadThemBackAfterInjectingAFailedTransmit(\n         BKDistributedLogManager dlm = (BKDistributedLogManager) createNewDLM(conf, name);\n \n         URI uri = createDLMURI(\"/\" + name);\n-        FutureUtils.result(dlm.getWriterMetadataStore().getLog(uri, name, true, true));\n+        Utils.ioResult(dlm.getWriterMetadataStore().getLog(uri, name, true, true));\n \n         // Log exists but is empty, better not throw.\n         AppendOnlyStreamWriter writer = dlm.getAppendOnlyStreamWriter();"},{"sha":"6efd0c13ae7bdf686daedeeaa3581e9a25729a8f","filename":"src/test/java/org/apache/distributedlog/TestAsyncBulkWrite.java","status":"modified","additions":16,"deletions":16,"changes":32,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FTestAsyncBulkWrite.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FTestAsyncBulkWrite.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FTestAsyncBulkWrite.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -17,14 +17,14 @@\n  */\n package org.apache.distributedlog;\n \n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.distributedlog.api.DistributedLogManager;\n import org.apache.distributedlog.exceptions.LogRecordTooLongException;\n import org.apache.distributedlog.exceptions.WriteCancelledException;\n import org.apache.distributedlog.exceptions.WriteException;\n import org.apache.distributedlog.util.FailpointUtils;\n-import org.apache.distributedlog.util.FutureUtils;\n-import com.twitter.util.Await;\n-import com.twitter.util.Duration;\n-import com.twitter.util.Future;\n+import org.apache.distributedlog.util.Utils;\n import org.junit.Rule;\n import org.junit.Test;\n import org.junit.rules.TestName;\n@@ -83,8 +83,8 @@ public void testAsyncBulkWritePartialFailureBufferFailure() throws Exception {\n         records.add(DLMTestUtil.getLogRecordInstance(goodRecs, MAX_LOGRECORD_SIZE + 1));\n         records.addAll(DLMTestUtil.getLargeLogRecordInstanceList(1, goodRecs));\n \n-        Future<List<Future<DLSN>>> futureResults = writer.writeBulk(records);\n-        List<Future<DLSN>> results = validateFutureSucceededAndGetResult(futureResults);\n+        CompletableFuture<List<CompletableFuture<DLSN>>> futureResults = writer.writeBulk(records);\n+        List<CompletableFuture<DLSN>> results = validateFutureSucceededAndGetResult(futureResults);\n \n         // One future returned for each write.\n         assertEquals(2*goodRecs + 1, results.size());\n@@ -160,14 +160,14 @@ public void testAsyncBulkWriteNoLedgerRollWithPartialFailures() throws Exception\n         // Write one record larger than max seg size. Ledger doesn't roll until next write.\n         int txid = 1;\n         LogRecord record = DLMTestUtil.getLogRecordInstance(txid++, 2048);\n-        Future<DLSN> result = writer.write(record);\n+        CompletableFuture<DLSN> result = writer.write(record);\n         DLSN dlsn = validateFutureSucceededAndGetResult(result);\n         assertEquals(1, dlsn.getLogSegmentSequenceNo());\n \n         // Write two more via bulk. Ledger doesn't roll because there's a partial failure.\n         List<LogRecord> records = null;\n-        Future<List<Future<DLSN>>> futureResults = null;\n-        List<Future<DLSN>> results = null;\n+        CompletableFuture<List<CompletableFuture<DLSN>>> futureResults = null;\n+        List<CompletableFuture<DLSN>> results = null;\n         records = new ArrayList<LogRecord>(2);\n         records.add(DLMTestUtil.getLogRecordInstance(txid++, 2048));\n         records.add(DLMTestUtil.getLogRecordInstance(txid++, MAX_LOGRECORD_SIZE + 1));\n@@ -309,15 +309,15 @@ private DLSN checkAllSucceeded(BKAsyncLogWriter writer,\n                                    long txIndex) throws Exception {\n \n         List<LogRecord> records = DLMTestUtil.getLogRecordInstanceList(txIndex, batchSize, recSize);\n-        Future<List<Future<DLSN>>> futureResults = writer.writeBulk(records);\n+        CompletableFuture<List<CompletableFuture<DLSN>>> futureResults = writer.writeBulk(records);\n         assertNotNull(futureResults);\n-        List<Future<DLSN>> results = Await.result(futureResults, Duration.fromSeconds(10));\n+        List<CompletableFuture<DLSN>> results = Utils.ioResult(futureResults, 10, TimeUnit.SECONDS);\n         assertNotNull(results);\n         assertEquals(results.size(), records.size());\n         long prevEntryId = 0;\n         DLSN lastDlsn = null;\n-        for (Future<DLSN> result : results) {\n-            DLSN dlsn = Await.result(result, Duration.fromSeconds(10));\n+        for (CompletableFuture<DLSN> result : results) {\n+            DLSN dlsn = Utils.ioResult(result, 10, TimeUnit.SECONDS);\n             lastDlsn = dlsn;\n \n             // If we cross a transmission boundary, slot id gets reset.\n@@ -338,12 +338,12 @@ private void checkAllSubmittedButFailed(BKAsyncLogWriter writer,\n                                             long txIndex) throws Exception {\n \n         List<LogRecord> records = DLMTestUtil.getLogRecordInstanceList(txIndex, batchSize, recSize);\n-        Future<List<Future<DLSN>>> futureResults = writer.writeBulk(records);\n+        CompletableFuture<List<CompletableFuture<DLSN>>> futureResults = writer.writeBulk(records);\n         assertNotNull(futureResults);\n-        List<Future<DLSN>> results = Await.result(futureResults, Duration.fromSeconds(10));\n+        List<CompletableFuture<DLSN>> results = Utils.ioResult(futureResults, 10, TimeUnit.SECONDS);\n         assertNotNull(results);\n         assertEquals(results.size(), records.size());\n-        for (Future<DLSN> result : results) {\n+        for (CompletableFuture<DLSN> result : results) {\n             validateFutureFailed(result, IOException.class);\n         }\n     }"},{"sha":"62ac5ef8303efcd4a94dee8c4d2ef2965f90a65c","filename":"src/test/java/org/apache/distributedlog/TestAsyncReaderLock.java","status":"modified","additions":80,"deletions":85,"changes":165,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FTestAsyncReaderLock.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FTestAsyncReaderLock.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FTestAsyncReaderLock.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -17,36 +17,34 @@\n  */\n package org.apache.distributedlog;\n \n-import java.io.IOException;\n import java.net.URI;\n import java.util.ArrayList;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.ExecutorService;\n import java.util.concurrent.Executors;\n import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicReference;\n \n+import org.apache.distributedlog.api.AsyncLogReader;\n+import org.apache.distributedlog.api.DistributedLogManager;\n+import org.apache.distributedlog.api.namespace.Namespace;\n import org.apache.distributedlog.exceptions.LockCancelledException;\n import org.apache.distributedlog.exceptions.LockingException;\n import org.apache.distributedlog.exceptions.OwnershipAcquireFailedException;\n import org.apache.distributedlog.impl.BKNamespaceDriver;\n import org.apache.distributedlog.lock.LockClosedException;\n-import org.apache.distributedlog.namespace.DistributedLogNamespace;\n-import org.apache.distributedlog.namespace.DistributedLogNamespaceBuilder;\n+import org.apache.distributedlog.api.namespace.NamespaceBuilder;\n import org.apache.distributedlog.namespace.NamespaceDriver;\n-import org.apache.distributedlog.subscription.SubscriptionsStore;\n-import org.apache.distributedlog.util.FutureUtils;\n+import org.apache.distributedlog.api.subscription.SubscriptionsStore;\n+import org.apache.distributedlog.common.concurrent.FutureEventListener;\n import org.apache.distributedlog.util.Utils;\n-import com.twitter.util.Await;\n-import com.twitter.util.ExceptionalFunction;\n-import com.twitter.util.Future;\n-import com.twitter.util.FutureEventListener;\n import org.junit.Rule;\n import org.junit.Test;\n import org.junit.rules.TestName;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n-import scala.runtime.AbstractFunction1;\n \n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertTrue;\n@@ -76,9 +74,9 @@ public void testReaderLockIfLockPathDoesntExist() throws Exception {\n         writer.write(DLMTestUtil.getLogRecordInstance(1L));\n         writer.closeAndComplete();\n \n-        Future<AsyncLogReader> futureReader1 = dlm.getAsyncLogReaderWithLock(DLSN.InitialDLSN);\n-        BKAsyncLogReader reader1 = (BKAsyncLogReader) Await.result(futureReader1);\n-        LogRecordWithDLSN record = Await.result(reader1.readNext());\n+        CompletableFuture<AsyncLogReader> futureReader1 = dlm.getAsyncLogReaderWithLock(DLSN.InitialDLSN);\n+        BKAsyncLogReader reader1 = (BKAsyncLogReader) Utils.ioResult(futureReader1);\n+        LogRecordWithDLSN record = Utils.ioResult(reader1.readNext());\n         assertEquals(1L, record.getTransactionId());\n         assertEquals(0L, record.getSequenceId());\n         DLMTestUtil.verifyLogRecord(record);\n@@ -89,9 +87,9 @@ public void testReaderLockIfLockPathDoesntExist() throws Exception {\n         // simulate a old stream created without readlock path\n         NamespaceDriver driver = dlm.getNamespaceDriver();\n         ((BKNamespaceDriver) driver).getWriterZKC().get().delete(readLockPath, -1);\n-        Future<AsyncLogReader> futureReader2 = dlm.getAsyncLogReaderWithLock(DLSN.InitialDLSN);\n-        AsyncLogReader reader2 = Await.result(futureReader2);\n-        record = Await.result(reader2.readNext());\n+        CompletableFuture<AsyncLogReader> futureReader2 = dlm.getAsyncLogReaderWithLock(DLSN.InitialDLSN);\n+        AsyncLogReader reader2 = Utils.ioResult(futureReader2);\n+        record = Utils.ioResult(reader2.readNext());\n         assertEquals(1L, record.getTransactionId());\n         assertEquals(0L, record.getSequenceId());\n         DLMTestUtil.verifyLogRecord(record);\n@@ -107,19 +105,14 @@ public void testReaderLockCloseInAcquireCallback() throws Exception {\n \n         final CountDownLatch latch = new CountDownLatch(1);\n \n-        Future<AsyncLogReader> futureReader1 = dlm.getAsyncLogReaderWithLock(DLSN.InitialDLSN);\n-        futureReader1.flatMap(new ExceptionalFunction<AsyncLogReader, Future<Void>>() {\n-            @Override\n-            public Future<Void> applyE(AsyncLogReader reader) throws IOException {\n-                return reader.asyncClose().map(new AbstractFunction1<Void, Void>() {\n-                    @Override\n-                    public Void apply(Void result) {\n+        CompletableFuture<AsyncLogReader> futureReader1 = dlm.getAsyncLogReaderWithLock(DLSN.InitialDLSN);\n+        futureReader1\n+            .thenCompose(\n+                reader -> reader.asyncClose()\n+                    .thenApply(result -> {\n                         latch.countDown();\n                         return null;\n-                    }\n-                });\n-            }\n-        });\n+                    }));\n \n         latch.await();\n         dlm.close();\n@@ -133,21 +126,21 @@ public void testReaderLockBackgroundReaderLockAcquire() throws Exception {\n         writer.write(DLMTestUtil.getLogRecordInstance(1L));\n         writer.closeAndComplete();\n \n-        Future<AsyncLogReader> futureReader1 = dlm.getAsyncLogReaderWithLock(DLSN.InitialDLSN);\n-        AsyncLogReader reader1 = Await.result(futureReader1);\n+        CompletableFuture<AsyncLogReader> futureReader1 = dlm.getAsyncLogReaderWithLock(DLSN.InitialDLSN);\n+        AsyncLogReader reader1 = Utils.ioResult(futureReader1);\n         reader1.readNext();\n \n         final CountDownLatch acquiredLatch = new CountDownLatch(1);\n         final AtomicBoolean acquired = new AtomicBoolean(false);\n         Thread acquireThread = new Thread(new Runnable() {\n             @Override\n             public void run() {\n-                Future<AsyncLogReader> futureReader2 = null;\n+                CompletableFuture<AsyncLogReader> futureReader2 = null;\n                 DistributedLogManager dlm2 = null;\n                 try {\n                     dlm2 = createNewDLM(conf, name);\n                     futureReader2 = dlm2.getAsyncLogReaderWithLock(DLSN.InitialDLSN);\n-                    AsyncLogReader reader2 = Await.result(futureReader2);\n+                    AsyncLogReader reader2 = Utils.ioResult(futureReader2);\n                     acquired.set(true);\n                     acquiredLatch.countDown();\n                 } catch (Exception ex) {\n@@ -172,10 +165,10 @@ public void run() {\n         dlm.close();\n     }\n \n-    int countDefined(ArrayList<Future<AsyncLogReader>> readers) {\n+    int countDefined(ArrayList<CompletableFuture<AsyncLogReader>> readers) {\n         int done = 0;\n-        for (Future<AsyncLogReader> futureReader : readers) {\n-            if (futureReader.isDefined()) {\n+        for (CompletableFuture<AsyncLogReader> futureReader : readers) {\n+            if (futureReader.isDone()) {\n                 done++;\n             }\n         }\n@@ -193,15 +186,15 @@ public void testReaderLockManyLocks() throws Exception {\n \n         int count = 5;\n         final CountDownLatch acquiredLatch = new CountDownLatch(count);\n-        final ArrayList<Future<AsyncLogReader>> readers = new ArrayList<Future<AsyncLogReader>>(count);\n+        final ArrayList<CompletableFuture<AsyncLogReader>> readers = new ArrayList<CompletableFuture<AsyncLogReader>>(count);\n         for (int i = 0; i < count; i++) {\n             readers.add(null);\n         }\n         final DistributedLogManager[] dlms = new DistributedLogManager[count];\n         for (int i = 0; i < count; i++) {\n             dlms[i] = createNewDLM(conf, name);\n             readers.set(i, dlms[i].getAsyncLogReaderWithLock(DLSN.InitialDLSN));\n-            readers.get(i).addEventListener(new FutureEventListener<AsyncLogReader>() {\n+            readers.get(i).whenComplete(new FutureEventListener<AsyncLogReader>() {\n                 @Override\n                 public void onSuccess(AsyncLogReader reader) {\n                     acquiredLatch.countDown();\n@@ -232,16 +225,17 @@ public void testReaderLockDlmClosed() throws Exception {\n         writer.closeAndComplete();\n \n         DistributedLogManager dlm1 = createNewDLM(conf, name);\n-        Future<AsyncLogReader> futureReader1 = dlm1.getAsyncLogReaderWithLock(DLSN.InitialDLSN);\n-        AsyncLogReader reader1 = Await.result(futureReader1);\n+        CompletableFuture<AsyncLogReader> futureReader1 = dlm1.getAsyncLogReaderWithLock(DLSN.InitialDLSN);\n+        AsyncLogReader reader1 = Utils.ioResult(futureReader1);\n \n         BKDistributedLogManager dlm2 = (BKDistributedLogManager) createNewDLM(conf, name);\n-        Future<AsyncLogReader> futureReader2 = dlm2.getAsyncLogReaderWithLock(DLSN.InitialDLSN);\n+        CompletableFuture<AsyncLogReader> futureReader2 = dlm2.getAsyncLogReaderWithLock(DLSN.InitialDLSN);\n \n         dlm2.close();\n         try {\n-            Await.result(futureReader2);\n+            Utils.ioResult(futureReader2);\n             fail(\"should have thrown exception!\");\n+        } catch (CancellationException ce) {\n         } catch (LockClosedException ex) {\n         } catch (LockCancelledException ex) {\n         }\n@@ -256,7 +250,7 @@ public void testReaderLockSessionExpires() throws Exception {\n         String name = runtime.getMethodName();\n         URI uri = createDLMURI(\"/\" + name);\n         ensureURICreated(uri);\n-        DistributedLogNamespace ns0 = DistributedLogNamespaceBuilder.newBuilder()\n+        Namespace ns0 = NamespaceBuilder.newBuilder()\n                 .conf(conf)\n                 .uri(uri)\n                 .build();\n@@ -266,26 +260,26 @@ public void testReaderLockSessionExpires() throws Exception {\n         writer.write(DLMTestUtil.getLogRecordInstance(2L));\n         writer.closeAndComplete();\n \n-        DistributedLogNamespace ns1 = DistributedLogNamespaceBuilder.newBuilder()\n+        Namespace ns1 = NamespaceBuilder.newBuilder()\n                 .conf(conf)\n                 .uri(uri)\n                 .build();\n         DistributedLogManager dlm1 = ns1.openLog(name);\n-        Future<AsyncLogReader> futureReader1 = dlm1.getAsyncLogReaderWithLock(DLSN.InitialDLSN);\n-        AsyncLogReader reader1 = Await.result(futureReader1);\n+        CompletableFuture<AsyncLogReader> futureReader1 = dlm1.getAsyncLogReaderWithLock(DLSN.InitialDLSN);\n+        AsyncLogReader reader1 = Utils.ioResult(futureReader1);\n         ZooKeeperClientUtils.expireSession(((BKNamespaceDriver) ns1.getNamespaceDriver()).getWriterZKC(), zkServers, 1000);\n \n         // The result of expireSession is somewhat non-deterministic with this lock.\n         // It may fail with LockingException or it may succesfully reacquire, so for\n         // the moment rather than make it deterministic we accept either result.\n         boolean success = false;\n         try {\n-            Await.result(reader1.readNext());\n+            Utils.ioResult(reader1.readNext());\n             success = true;\n         } catch (LockingException ex) {\n         }\n         if (success) {\n-            Await.result(reader1.readNext());\n+            Utils.ioResult(reader1.readNext());\n         }\n \n         Utils.close(reader1);\n@@ -305,15 +299,16 @@ public void testReaderLockFutureCancelledWhileWaiting() throws Exception {\n         writer.closeAndComplete();\n \n         DistributedLogManager dlm1 = createNewDLM(conf, name);\n-        Future<AsyncLogReader> futureReader1 = dlm1.getAsyncLogReaderWithLock(DLSN.InitialDLSN);\n-        AsyncLogReader reader1 = Await.result(futureReader1);\n+        CompletableFuture<AsyncLogReader> futureReader1 = dlm1.getAsyncLogReaderWithLock(DLSN.InitialDLSN);\n+        AsyncLogReader reader1 = Utils.ioResult(futureReader1);\n \n         DistributedLogManager dlm2 = createNewDLM(conf, name);\n-        Future<AsyncLogReader> futureReader2 = dlm2.getAsyncLogReaderWithLock(DLSN.InitialDLSN);\n+        CompletableFuture<AsyncLogReader> futureReader2 = dlm2.getAsyncLogReaderWithLock(DLSN.InitialDLSN);\n         try {\n-            FutureUtils.cancel(futureReader2);\n-            Await.result(futureReader2);\n+            futureReader2.cancel(true);\n+            Utils.ioResult(futureReader2);\n             fail(\"Should fail getting log reader as it is cancelled\");\n+        } catch (CancellationException ce) {\n         } catch (LockClosedException ex) {\n         } catch (LockCancelledException ex) {\n         } catch (OwnershipAcquireFailedException oafe) {\n@@ -322,7 +317,7 @@ public void testReaderLockFutureCancelledWhileWaiting() throws Exception {\n         futureReader2 = dlm2.getAsyncLogReaderWithLock(DLSN.InitialDLSN);\n         Utils.close(reader1);\n \n-        Await.result(futureReader2);\n+        Utils.ioResult(futureReader2);\n \n         dlm0.close();\n         dlm1.close();\n@@ -339,13 +334,13 @@ public void testReaderLockFutureCancelledWhileLocked() throws Exception {\n         writer.closeAndComplete();\n \n         DistributedLogManager dlm1 = createNewDLM(conf, name);\n-        Future<AsyncLogReader> futureReader1 = dlm1.getAsyncLogReaderWithLock(DLSN.InitialDLSN);\n+        CompletableFuture<AsyncLogReader> futureReader1 = dlm1.getAsyncLogReaderWithLock(DLSN.InitialDLSN);\n \n         // Must not throw or cancel or do anything bad, future already completed.\n-        Await.result(futureReader1);\n-        FutureUtils.cancel(futureReader1);\n-        AsyncLogReader reader1 = Await.result(futureReader1);\n-        Await.result(reader1.readNext());\n+        Utils.ioResult(futureReader1);\n+        futureReader1.cancel(true);\n+        AsyncLogReader reader1 = Utils.ioResult(futureReader1);\n+        Utils.ioResult(reader1.readNext());\n \n         dlm0.close();\n         dlm1.close();\n@@ -361,13 +356,13 @@ public void testReaderLockSharedDlmDoesNotConflict() throws Exception {\n         writer.closeAndComplete();\n \n         DistributedLogManager dlm1 = createNewDLM(conf, name);\n-        Future<AsyncLogReader> futureReader1 = dlm1.getAsyncLogReaderWithLock(DLSN.InitialDLSN);\n-        Future<AsyncLogReader> futureReader2 = dlm1.getAsyncLogReaderWithLock(DLSN.InitialDLSN);\n+        CompletableFuture<AsyncLogReader> futureReader1 = dlm1.getAsyncLogReaderWithLock(DLSN.InitialDLSN);\n+        CompletableFuture<AsyncLogReader> futureReader2 = dlm1.getAsyncLogReaderWithLock(DLSN.InitialDLSN);\n \n         // Both use the same client id, so there's no lock conflict. Not necessarily ideal, but how the\n         // system currently works.\n-        Await.result(futureReader1);\n-        Await.result(futureReader2);\n+        Utils.ioResult(futureReader1);\n+        Utils.ioResult(futureReader2);\n \n         dlm0.close();\n         dlm1.close();\n@@ -413,7 +408,7 @@ public void run() {\n         private void readEntries(AsyncLogReader reader) {\n             try {\n                 for (int i = 0; i < 300; i++) {\n-                    LogRecordWithDLSN record = Await.result(reader.readNext());\n+                    LogRecordWithDLSN record = Utils.ioResult(reader.readNext());\n                     currentDLSN.set(record.getDlsn());\n                 }\n             } catch (Exception ex) {\n@@ -446,7 +441,7 @@ public void testReaderLockMultiReadersScenario() throws Exception {\n         localConf.setNumWorkerThreads(2);\n         localConf.setLockTimeout(Long.MAX_VALUE);\n \n-        DistributedLogNamespace namespace = DistributedLogNamespaceBuilder.newBuilder()\n+        Namespace namespace = NamespaceBuilder.newBuilder()\n                 .conf(localConf).uri(uri).clientId(\"main\").build();\n \n         DistributedLogManager dlm0 = namespace.openLog(name);\n@@ -457,54 +452,54 @@ public void testReaderLockMultiReadersScenario() throws Exception {\n         AtomicReference<DLSN> currentDLSN = new AtomicReference<DLSN>(DLSN.InitialDLSN);\n \n         String clientId1 = \"reader1\";\n-        DistributedLogNamespace namespace1 = DistributedLogNamespaceBuilder.newBuilder()\n+        Namespace namespace1 = NamespaceBuilder.newBuilder()\n                 .conf(localConf).uri(uri).clientId(clientId1).build();\n         DistributedLogManager dlm1 = namespace1.openLog(name);\n         String clientId2 = \"reader2\";\n-        DistributedLogNamespace namespace2 = DistributedLogNamespaceBuilder.newBuilder()\n+        Namespace namespace2 = NamespaceBuilder.newBuilder()\n                 .conf(localConf).uri(uri).clientId(clientId2).build();\n         DistributedLogManager dlm2 = namespace2.openLog(name);\n         String clientId3 = \"reader3\";\n-        DistributedLogNamespace namespace3 = DistributedLogNamespaceBuilder.newBuilder()\n+        Namespace namespace3 = NamespaceBuilder.newBuilder()\n                 .conf(localConf).uri(uri).clientId(clientId3).build();\n         DistributedLogManager dlm3 = namespace3.openLog(name);\n \n         LOG.info(\"{} is opening reader on stream {}\", clientId1, name);\n-        Future<AsyncLogReader> futureReader1 = dlm1.getAsyncLogReaderWithLock(DLSN.InitialDLSN);\n-        AsyncLogReader reader1 = Await.result(futureReader1);\n+        CompletableFuture<AsyncLogReader> futureReader1 = dlm1.getAsyncLogReaderWithLock(DLSN.InitialDLSN);\n+        AsyncLogReader reader1 = Utils.ioResult(futureReader1);\n         LOG.info(\"{} opened reader on stream {}\", clientId1, name);\n \n         LOG.info(\"{} is opening reader on stream {}\", clientId2, name);\n-        Future<AsyncLogReader> futureReader2 = dlm2.getAsyncLogReaderWithLock(DLSN.InitialDLSN);\n+        CompletableFuture<AsyncLogReader> futureReader2 = dlm2.getAsyncLogReaderWithLock(DLSN.InitialDLSN);\n         LOG.info(\"{} is opening reader on stream {}\", clientId3, name);\n-        Future<AsyncLogReader> futureReader3 = dlm3.getAsyncLogReaderWithLock(DLSN.InitialDLSN);\n+        CompletableFuture<AsyncLogReader> futureReader3 = dlm3.getAsyncLogReaderWithLock(DLSN.InitialDLSN);\n \n         ExecutorService executorService = Executors.newCachedThreadPool();\n \n         ReadRecordsListener listener2 =\n                 new ReadRecordsListener(currentDLSN, clientId2, executorService);\n         ReadRecordsListener listener3 =\n                 new ReadRecordsListener(currentDLSN, clientId3, executorService);\n-        futureReader2.addEventListener(listener2);\n-        futureReader3.addEventListener(listener3);\n+        futureReader2.whenComplete(listener2);\n+        futureReader3.whenComplete(listener3);\n \n         // Get reader1 and start reading.\n         for ( ; recordCount < 200; recordCount++) {\n-            LogRecordWithDLSN record = Await.result(reader1.readNext());\n+            LogRecordWithDLSN record = Utils.ioResult(reader1.readNext());\n             currentDLSN.set(record.getDlsn());\n         }\n \n         // Take a break, reader2 decides to stop waiting and cancels.\n         Thread.sleep(1000);\n         assertFalse(listener2.done());\n-        FutureUtils.cancel(futureReader2);\n+        futureReader2.cancel(true);\n         listener2.getLatch().await();\n         assertTrue(listener2.done());\n         assertTrue(listener2.failed());\n \n         // Reader1 starts reading again.\n         for (; recordCount < 300; recordCount++) {\n-            LogRecordWithDLSN record = Await.result(reader1.readNext());\n+            LogRecordWithDLSN record = Utils.ioResult(reader1.readNext());\n             currentDLSN.set(record.getDlsn());\n         }\n \n@@ -519,12 +514,12 @@ public void testReaderLockMultiReadersScenario() throws Exception {\n         assertEquals(new DLSN(3, 99, 0), currentDLSN.get());\n \n         try {\n-            Await.result(futureReader2);\n+            Utils.ioResult(futureReader2);\n         } catch (Exception ex) {\n             // Can't get this one to close it--the dlm will take care of it.\n         }\n \n-        Utils.close(Await.result(futureReader3));\n+        Utils.close(Utils.ioResult(futureReader3));\n \n         dlm1.close();\n         namespace1.close();\n@@ -553,18 +548,18 @@ public void testAsyncReadWithSubscriberId() throws Exception {\n         for (long i = 0; i < 3; i++) {\n             BKAsyncLogWriter writer = (BKAsyncLogWriter) dlm.startAsyncLogSegmentNonPartitioned();\n             for (long j = 1; j <= 10; j++) {\n-                DLSN dlsn = Await.result(writer.write(DLMTestUtil.getEmptyLogRecordInstance(txid++)));\n+                DLSN dlsn = Utils.ioResult(writer.write(DLMTestUtil.getEmptyLogRecordInstance(txid++)));\n                 if (i == 1 && j == 1L) {\n                     readDLSN = dlsn;\n                 }\n             }\n             writer.closeAndComplete();\n         }\n \n-        BKAsyncLogReader reader0 = (BKAsyncLogReader) Await.result(dlm.getAsyncLogReaderWithLock(subscriberId));\n+        BKAsyncLogReader reader0 = (BKAsyncLogReader) Utils.ioResult(dlm.getAsyncLogReaderWithLock(subscriberId));\n         assertEquals(DLSN.NonInclusiveLowerBound, reader0.getStartDLSN());\n         long numTxns = 0;\n-        LogRecordWithDLSN record = Await.result(reader0.readNext());\n+        LogRecordWithDLSN record = Utils.ioResult(reader0.readNext());\n         while (null != record) {\n             DLMTestUtil.verifyEmptyLogRecord(record);\n             ++numTxns;\n@@ -574,18 +569,18 @@ public void testAsyncReadWithSubscriberId() throws Exception {\n             if (txid - 1 == numTxns) {\n                 break;\n             }\n-            record = Await.result(reader0.readNext());\n+            record = Utils.ioResult(reader0.readNext());\n         }\n         assertEquals(txid - 1, numTxns);\n         Utils.close(reader0);\n \n         SubscriptionsStore subscriptionsStore = dlm.getSubscriptionsStore();\n-        Await.result(subscriptionsStore.advanceCommitPosition(subscriberId, readDLSN));\n-        BKAsyncLogReader reader1 = (BKAsyncLogReader) Await.result(dlm.getAsyncLogReaderWithLock(subscriberId));\n+        Utils.ioResult(subscriptionsStore.advanceCommitPosition(subscriberId, readDLSN));\n+        BKAsyncLogReader reader1 = (BKAsyncLogReader) Utils.ioResult(dlm.getAsyncLogReaderWithLock(subscriberId));\n         assertEquals(readDLSN, reader1.getStartDLSN());\n         numTxns = 0;\n         long startTxID =  10L;\n-        record = Await.result(reader1.readNext());\n+        record = Utils.ioResult(reader1.readNext());\n         while (null != record) {\n             DLMTestUtil.verifyEmptyLogRecord(record);\n             ++numTxns;\n@@ -596,7 +591,7 @@ public void testAsyncReadWithSubscriberId() throws Exception {\n             if (startTxID == txid - 1) {\n                 break;\n             }\n-            record = Await.result(reader1.readNext());\n+            record = Utils.ioResult(reader1.readNext());\n         }\n         assertEquals(txid - 1, startTxID);\n         assertEquals(20, numTxns);"},{"sha":"51231786422b02a76237ebd74688b14cac13768a","filename":"src/test/java/org/apache/distributedlog/TestAsyncReaderWriter.java","status":"modified","additions":117,"deletions":115,"changes":232,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FTestAsyncReaderWriter.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FTestAsyncReaderWriter.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FTestAsyncReaderWriter.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -22,6 +22,7 @@\n import java.nio.ByteBuffer;\n import java.util.ArrayList;\n import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.ScheduledThreadPoolExecutor;\n import java.util.concurrent.TimeUnit;\n@@ -30,16 +31,22 @@\n \n import com.google.common.base.Optional;\n import com.google.common.collect.Lists;\n-import org.apache.distributedlog.annotations.DistributedLogAnnotations;\n-import org.apache.distributedlog.config.ConcurrentBaseConfiguration;\n-import org.apache.distributedlog.config.ConcurrentConstConfiguration;\n+import org.apache.distributedlog.api.AsyncLogReader;\n+import org.apache.distributedlog.api.AsyncLogWriter;\n+import org.apache.distributedlog.api.DistributedLogManager;\n+import org.apache.distributedlog.api.LogReader;\n+import org.apache.distributedlog.api.LogWriter;\n+import org.apache.distributedlog.api.namespace.Namespace;\n+import org.apache.distributedlog.common.annotations.DistributedLogAnnotations;\n+import org.apache.distributedlog.common.config.ConcurrentBaseConfiguration;\n+import org.apache.distributedlog.common.config.ConcurrentConstConfiguration;\n import org.apache.distributedlog.config.DynamicDistributedLogConfiguration;\n import org.apache.distributedlog.exceptions.BKTransmitException;\n import org.apache.distributedlog.exceptions.LockingException;\n import org.apache.distributedlog.impl.BKNamespaceDriver;\n import org.apache.distributedlog.io.CompressionCodec;\n+import org.apache.distributedlog.common.concurrent.FutureEventListener;\n import org.apache.distributedlog.util.Utils;\n-import com.twitter.util.Promise;\n import org.apache.bookkeeper.client.BookKeeper;\n import org.apache.bookkeeper.client.BookKeeperAccessor;\n import org.apache.bookkeeper.client.LedgerHandle;\n@@ -63,15 +70,10 @@\n import org.apache.distributedlog.exceptions.ReadCancelledException;\n import org.apache.distributedlog.exceptions.WriteException;\n import org.apache.distributedlog.lock.DistributedLock;\n-import org.apache.distributedlog.namespace.DistributedLogNamespace;\n-import org.apache.distributedlog.namespace.DistributedLogNamespaceBuilder;\n+import org.apache.distributedlog.api.namespace.NamespaceBuilder;\n import org.apache.distributedlog.util.FailpointUtils;\n-import org.apache.distributedlog.util.FutureUtils;\n+import org.apache.distributedlog.common.concurrent.FutureUtils;\n import org.apache.distributedlog.util.SimplePermitLimiter;\n-import com.twitter.util.Await;\n-import com.twitter.util.Duration;\n-import com.twitter.util.Future;\n-import com.twitter.util.FutureEventListener;\n \n import junit.framework.Assert;\n import static com.google.common.base.Charsets.UTF_8;\n@@ -111,13 +113,13 @@ public void testWriteControlRecord() throws Exception {\n         for (long i = 0; i < 3; i++) {\n             final long currentLogSegmentSeqNo = i + 1;\n             BKAsyncLogWriter writer = (BKAsyncLogWriter)(dlm.startAsyncLogSegmentNonPartitioned());\n-            DLSN dlsn = Await.result(writer.writeControlRecord(new LogRecord(txid++, \"control\".getBytes(UTF_8))));\n+            DLSN dlsn = Utils.ioResult(writer.writeControlRecord(new LogRecord(txid++, \"control\".getBytes(UTF_8))));\n             assertEquals(currentLogSegmentSeqNo, dlsn.getLogSegmentSequenceNo());\n             assertEquals(0, dlsn.getEntryId());\n             assertEquals(0, dlsn.getSlotId());\n             for (long j = 1; j < 10; j++) {\n                 final LogRecord record = DLMTestUtil.getLargeLogRecordInstance(txid++);\n-                Await.result(writer.write(record));\n+                Utils.ioResult(writer.write(record));\n             }\n             writer.closeAndComplete();\n         }\n@@ -161,8 +163,8 @@ public void testAsyncWritePendingWritesAbortedWhenLedgerRollTriggerFails() throw\n         // Write one record larger than max seg size. Ledger doesn't roll until next write.\n         int txid = 1;\n         LogRecord record = DLMTestUtil.getLogRecordInstance(txid++, 2048);\n-        Future<DLSN> result = writer.write(record);\n-        DLSN dlsn = Await.result(result, Duration.fromSeconds(10));\n+        CompletableFuture<DLSN> result = writer.write(record);\n+        DLSN dlsn = Utils.ioResult(result, 10, TimeUnit.SECONDS);\n         assertEquals(1, dlsn.getLogSegmentSequenceNo());\n \n         record = DLMTestUtil.getLogRecordInstance(txid++, MAX_LOGRECORD_SIZE + 1);\n@@ -207,8 +209,8 @@ public void testSimpleAsyncWrite() throws Exception {\n             for (long j = 0; j < numRecordsPerLogSegment; j++) {\n                 final long currentEntryId = j;\n                 final LogRecord record = DLMTestUtil.getLargeLogRecordInstance(txid++);\n-                Future<DLSN> dlsnFuture = writer.write(record);\n-                dlsnFuture.addEventListener(new FutureEventListener<DLSN>() {\n+                CompletableFuture<DLSN> dlsnFuture = writer.write(record);\n+                dlsnFuture.whenComplete(new FutureEventListener<DLSN>() {\n                     @Override\n                     public void onSuccess(DLSN value) {\n                         if(value.getLogSegmentSequenceNo() != currentLogSegmentSeqNo) {\n@@ -245,7 +247,7 @@ public void onFailure(Throwable cause) {\n         assertEquals(\"Last DLSN\" + last.getDlsn() + \" isn't the maximum DLSN \" + maxDLSN.get(),\n                 last.getDlsn(), maxDLSN.get());\n         assertEquals(last.getDlsn(), dlm.getLastDLSN());\n-        assertEquals(last.getDlsn(), Await.result(dlm.getLastDLSNAsync()));\n+        assertEquals(last.getDlsn(), Utils.ioResult(dlm.getLastDLSNAsync()));\n         DLMTestUtil.verifyLargeLogRecord(last);\n \n         dlm.close();\n@@ -330,8 +332,8 @@ private static void readNext(final AsyncLogReader reader,\n                                  final CountDownLatch syncLatch,\n                                  final CountDownLatch completionLatch,\n                                  final AtomicBoolean errorsFound) {\n-        Future<LogRecordWithDLSN> record = reader.readNext();\n-        record.addEventListener(new FutureEventListener<LogRecordWithDLSN>() {\n+        CompletableFuture<LogRecordWithDLSN> record = reader.readNext();\n+        record.whenComplete(new FutureEventListener<LogRecordWithDLSN>() {\n             @Override\n             public void onSuccess(LogRecordWithDLSN value) {\n                 try {\n@@ -455,7 +457,7 @@ public void testBulkAsyncRead() throws Exception {\n             if (expectedTxID == numLogSegments * numRecordsPerLogSegment) {\n                 break;\n             }\n-            List<LogRecordWithDLSN> records = Await.result(reader.readBulk(20));\n+            List<LogRecordWithDLSN> records = Utils.ioResult(reader.readBulk(20));\n             LOG.info(\"Bulk read {} entries.\", records.size());\n \n             assertTrue(records.size() >= 1);\n@@ -495,7 +497,7 @@ public void testBulkAsyncReadWithWriteBatch() throws Exception {\n         for (long i = 0; i < 3; i++) {\n             // since we batched 20 entries into single bookkeeper entry\n             // we should be able to read 20 entries as a batch.\n-            List<LogRecordWithDLSN> records = Await.result(reader.readBulk(20));\n+            List<LogRecordWithDLSN> records = Utils.ioResult(reader.readBulk(20));\n             assertEquals(20, records.size());\n             for (LogRecordWithDLSN record : records) {\n                 assertEquals(expectedTxID, record.getTransactionId());\n@@ -531,7 +533,7 @@ public void testAsyncReadEmptyRecords() throws Exception {\n                 name, asyncReader.getStreamName());\n         long numTrans = 0;\n         DLSN lastDLSN = DLSN.InvalidDLSN;\n-        LogRecordWithDLSN record = Await.result(asyncReader.readNext());\n+        LogRecordWithDLSN record = Utils.ioResult(asyncReader.readNext());\n         while (null != record) {\n             DLMTestUtil.verifyEmptyLogRecord(record);\n             assertEquals(0, record.getDlsn().getSlotId());\n@@ -541,7 +543,7 @@ public void testAsyncReadEmptyRecords() throws Exception {\n             if (numTrans >= (txid - 1)) {\n                 break;\n             }\n-            record = Await.result(asyncReader.readNext());\n+            record = Utils.ioResult(asyncReader.readNext());\n         }\n         assertEquals((txid - 1), numTrans);\n         Utils.close(asyncReader);\n@@ -715,8 +717,8 @@ void testSimpleAsyncReadWriteInternal(String name, boolean immediateFlush,\n             for (long j = 0; j < 10; j++) {\n                 final long currentEntryId = j;\n                 final LogRecord record = DLMTestUtil.getLargeLogRecordInstance(txid++);\n-                Future<DLSN> dlsnFuture = writer.write(record);\n-                dlsnFuture.addEventListener(new WriteFutureEventListener(\n+                CompletableFuture<DLSN> dlsnFuture = writer.write(record);\n+                dlsnFuture.whenComplete(new WriteFutureEventListener(\n                         record, currentLogSegmentSeqNo, currentEntryId, writeLatch, writeErrors, true));\n                 if (i == 0 && j == 0) {\n                     boolean monotonic = LogSegmentMetadata.supportsSequenceId(logSegmentVersion);\n@@ -793,8 +795,8 @@ public void testSimpleAsyncReadWriteStartEmpty() throws Exception {\n             for (long j = 0; j < 10; j++) {\n                 final long currentEntryId = j;\n                 final LogRecord record = DLMTestUtil.getLargeLogRecordInstance(txid++);\n-                Future<DLSN> dlsnFuture = writer.write(record);\n-                dlsnFuture.addEventListener(new WriteFutureEventListener(\n+                CompletableFuture<DLSN> dlsnFuture = writer.write(record);\n+                dlsnFuture.whenComplete(new WriteFutureEventListener(\n                         record, currentLogSegmentSeqNo, currentEntryId, writeLatch, writeErrors, true));\n             }\n             writer.closeAndComplete();\n@@ -835,7 +837,7 @@ public void testSimpleAsyncReadWriteStartEmptyFactory() throws Exception {\n \n         URI uri = createDLMURI(\"/\" + name);\n         ensureURICreated(uri);\n-        DistributedLogNamespace namespace = DistributedLogNamespaceBuilder.newBuilder()\n+        Namespace namespace = NamespaceBuilder.newBuilder()\n                 .conf(confLocal).uri(uri).build();\n         final DistributedLogManager[] dlms = new DistributedLogManager[count];\n         final TestReader[] readers = new TestReader[count];\n@@ -868,8 +870,8 @@ public void testSimpleAsyncReadWriteStartEmptyFactory() throws Exception {\n                 final long currentEntryId = j;\n                 final LogRecord record = DLMTestUtil.getLargeLogRecordInstance(txid++);\n                 for (int s = 0; s < count; s++) {\n-                    Future<DLSN> dlsnFuture = writers[s].write(record);\n-                    dlsnFuture.addEventListener(new WriteFutureEventListener(\n+                    CompletableFuture<DLSN> dlsnFuture = writers[s].write(record);\n+                    dlsnFuture.whenComplete(new WriteFutureEventListener(\n                             record, currentLogSegmentSeqNo, currentEntryId, writeLatch, writeErrors, true));\n                 }\n             }\n@@ -937,8 +939,8 @@ public void testSimpleAsyncReadWriteSimulateErrors() throws Exception {\n             for (long j = 0; j < numRecordsPerLogSegment; j++) {\n                 final long currentEntryId = j;\n                 final LogRecord record = DLMTestUtil.getLargeLogRecordInstance(txid++);\n-                Future<DLSN> dlsnFuture = writer.write(record);\n-                dlsnFuture.addEventListener(new WriteFutureEventListener(\n+                CompletableFuture<DLSN> dlsnFuture = writer.write(record);\n+                dlsnFuture.whenComplete(new WriteFutureEventListener(\n                         record, currentLogSegmentSeqNo, currentEntryId, writeLatch, writeErrors, true));\n             }\n             writer.closeAndComplete();\n@@ -988,8 +990,8 @@ public void testSimpleAsyncReadWritePiggyBack() throws Exception {\n             for (long j = 0; j < numRecordsPerLogSegment; j++) {\n                 Thread.sleep(50);\n                 final LogRecord record = DLMTestUtil.getLargeLogRecordInstance(txid++);\n-                Future<DLSN> dlsnFuture = writer.write(record);\n-                dlsnFuture.addEventListener(new WriteFutureEventListener(\n+                CompletableFuture<DLSN> dlsnFuture = writer.write(record);\n+                dlsnFuture.whenComplete(new WriteFutureEventListener(\n                         record, currentLogSegmentSeqNo, j, writeLatch, writeErrors, false));\n                 if (i == 0 && j == 0) {\n                     boolean monotonic = LogSegmentMetadata.supportsSequenceId(confLocal.getDLLedgerMetadataLayoutVersion());\n@@ -1027,7 +1029,7 @@ public void testCancelReadRequestOnReaderClosed() throws Exception {\n         writer.closeAndComplete();\n \n         final AsyncLogReader reader = dlm.getAsyncLogReader(DLSN.InitialDLSN);\n-        LogRecordWithDLSN record = Await.result(reader.readNext());\n+        LogRecordWithDLSN record = Utils.ioResult(reader.readNext());\n         assertEquals(1L, record.getTransactionId());\n         DLMTestUtil.verifyLogRecord(record);\n \n@@ -1037,7 +1039,7 @@ public void testCancelReadRequestOnReaderClosed() throws Exception {\n             @Override\n             public void run() {\n                 try {\n-                    Await.result(reader.readNext());\n+                    Utils.ioResult(reader.readNext());\n                 } catch (ReadCancelledException rce) {\n                     receiveExpectedException.set(true);\n                 } catch (Throwable t) {\n@@ -1060,7 +1062,7 @@ public void run() {\n \n         // closed reader should reject any readNext\n         try {\n-            Await.result(reader.readNext());\n+            Utils.ioResult(reader.readNext());\n             fail(\"Reader should reject readNext if it is closed.\");\n         } catch (ReadCancelledException rce) {\n             // expected\n@@ -1087,8 +1089,8 @@ public void testAsyncWriteWithMinDelayBetweenFlushes() throws Exception {\n         for (long i = 0; i < COUNT; i++) {\n             Thread.sleep(1);\n             final LogRecord record = DLMTestUtil.getLogRecordInstance(txid++);\n-            Future<DLSN> dlsnFuture = writer.write(record);\n-            dlsnFuture.addEventListener(new FutureEventListener<DLSN>() {\n+            CompletableFuture<DLSN> dlsnFuture = writer.write(record);\n+            dlsnFuture.whenComplete(new FutureEventListener<DLSN>() {\n                 @Override\n                 public void onSuccess(DLSN value) {\n                     syncLatch.countDown();\n@@ -1142,23 +1144,23 @@ public void testAsyncWriteWithMinDelayBetweenFlushesFlushFailure() throws Except\n         URI uri = createDLMURI(\"/\" + name);\n         ensureURICreated(uri);\n \n-        DistributedLogNamespace namespace = DistributedLogNamespaceBuilder.newBuilder()\n+        Namespace namespace = NamespaceBuilder.newBuilder()\n                 .conf(confLocal).uri(uri).clientId(\"gabbagoo\").build();\n         DistributedLogManager dlm = namespace.openLog(name);\n-        DistributedLogNamespace namespace1 = DistributedLogNamespaceBuilder.newBuilder()\n+        Namespace namespace1 = NamespaceBuilder.newBuilder()\n                 .conf(confLocal).uri(uri).clientId(\"tortellini\").build();\n         DistributedLogManager dlm1 = namespace1.openLog(name);\n \n         int txid = 1;\n         BKAsyncLogWriter writer = (BKAsyncLogWriter)(dlm.startAsyncLogSegmentNonPartitioned());\n \n         // First write succeeds since lock isnt checked until transmit, which is scheduled\n-        Await.result(writer.write(DLMTestUtil.getLogRecordInstance(txid++)));\n+        Utils.ioResult(writer.write(DLMTestUtil.getLogRecordInstance(txid++)));\n         writer.flushAndCommit();\n \n         BKLogSegmentWriter perStreamWriter = writer.getCachedLogWriter();\n         DistributedLock lock = perStreamWriter.getLock();\n-        FutureUtils.result(lock.asyncClose());\n+        Utils.ioResult(lock.asyncClose());\n \n         // Get second writer, steal lock\n         BKAsyncLogWriter writer2 = (BKAsyncLogWriter)(dlm1.startAsyncLogSegmentNonPartitioned());\n@@ -1169,7 +1171,7 @@ public void testAsyncWriteWithMinDelayBetweenFlushesFlushFailure() throws Except\n \n             // Succeeds, kicks off scheduled flush\n             Thread.sleep(100);\n-            Await.result(writer.write(DLMTestUtil.getLogRecordInstance(txid++)));\n+            Utils.ioResult(writer.write(DLMTestUtil.getLogRecordInstance(txid++)));\n             fail(\"should have thrown\");\n         } catch (LockingException ex) {\n             LOG.debug(\"caught exception \", ex);\n@@ -1194,13 +1196,13 @@ public void writeRecordsWithOutstandingWriteLimit(int stream, int global, boolea\n             dlm = createNewDLM(confLocal, runtime.getMethodName());\n         }\n         BKAsyncLogWriter writer = (BKAsyncLogWriter)(dlm.startAsyncLogSegmentNonPartitioned());\n-        ArrayList<Future<DLSN>> results = new ArrayList<Future<DLSN>>(1000);\n+        ArrayList<CompletableFuture<DLSN>> results = new ArrayList<CompletableFuture<DLSN>>(1000);\n         for (int i = 0; i < 1000; i++) {\n             results.add(writer.write(DLMTestUtil.getLogRecordInstance(1L)));\n         }\n-        for (Future<DLSN> result : results) {\n+        for (CompletableFuture<DLSN> result : results) {\n             try {\n-                Await.result(result);\n+                Utils.ioResult(result);\n                 if (shouldFail) {\n                     fail(\"should fail due to no outstanding writes permitted\");\n                 }\n@@ -1242,12 +1244,12 @@ public void testOutstandingWriteLimitBlockAllLimitWithDarkmode() throws Exceptio\n         confLocal.setOutstandingWriteLimitDarkmode(true);\n         DistributedLogManager dlm = createNewDLM(confLocal, runtime.getMethodName());\n         BKAsyncLogWriter writer = (BKAsyncLogWriter)(dlm.startAsyncLogSegmentNonPartitioned());\n-        ArrayList<Future<DLSN>> results = new ArrayList<Future<DLSN>>(1000);\n+        ArrayList<CompletableFuture<DLSN>> results = new ArrayList<CompletableFuture<DLSN>>(1000);\n         for (int i = 0; i < 1000; i++) {\n             results.add(writer.write(DLMTestUtil.getLogRecordInstance(1L)));\n         }\n-        for (Future<DLSN> result : results) {\n-            Await.result(result);\n+        for (CompletableFuture<DLSN> result : results) {\n+            Utils.ioResult(result);\n         }\n         writer.closeAndComplete();\n         dlm.close();\n@@ -1266,7 +1268,7 @@ public void testCloseAndCompleteLogSegmentWhenStreamIsInError() throws Exception\n \n         long txId = 1L;\n         for (int i = 0; i < 5; i++) {\n-            Await.result(writer.write(DLMTestUtil.getLogRecordInstance(txId++)));\n+            Utils.ioResult(writer.write(DLMTestUtil.getLogRecordInstance(txId++)));\n         }\n \n         BKLogSegmentWriter logWriter = writer.getCachedLogWriter();\n@@ -1277,7 +1279,7 @@ public void testCloseAndCompleteLogSegmentWhenStreamIsInError() throws Exception\n                 BookKeeper.DigestType.CRC32, confLocal.getBKDigestPW().getBytes(UTF_8));\n \n         try {\n-            Await.result(writer.write(DLMTestUtil.getLogRecordInstance(txId++)));\n+            Utils.ioResult(writer.write(DLMTestUtil.getLogRecordInstance(txId++)));\n             fail(\"Should fail write to a fenced ledger with BKTransmitException\");\n         } catch (BKTransmitException bkte) {\n             // expected\n@@ -1310,7 +1312,7 @@ public void testCloseAndCompleteLogSegmentWhenCloseFailed() throws Exception {\n \n         long txId = 1L;\n         for (int i = 0; i < 5; i++) {\n-            Await.result(writer.write(DLMTestUtil.getLogRecordInstance(txId++)));\n+            Utils.ioResult(writer.write(DLMTestUtil.getLogRecordInstance(txId++)));\n         }\n \n         BKLogSegmentWriter logWriter = writer.getCachedLogWriter();\n@@ -1408,8 +1410,8 @@ public void run() {\n         int recordCount = 0;\n         try {\n             while (true) {\n-                Future<LogRecordWithDLSN> record = reader.readNext();\n-                Await.result(record);\n+                CompletableFuture<LogRecordWithDLSN> record = reader.readNext();\n+                Utils.ioResult(record);\n                 recordCount++;\n \n                 if (recordCount >= segmentSize * numSegments) {\n@@ -1465,7 +1467,7 @@ public void testReleaseLockAfterFailedToRecover() throws Exception {\n         BKAsyncLogWriter writer =\n                 (BKAsyncLogWriter)(dlm.startAsyncLogSegmentNonPartitioned());\n \n-        Await.result(writer.write(DLMTestUtil.getLogRecordInstance(1L)));\n+        Utils.ioResult(writer.write(DLMTestUtil.getLogRecordInstance(1L)));\n         writer.abort();\n \n         for (int i = 0; i < 2; i++) {\n@@ -1548,8 +1550,8 @@ public void run() {\n         int recordCount = 0;\n         try {\n             while (true) {\n-                Future<LogRecordWithDLSN> record = reader.readNext();\n-                Await.result(record);\n+                CompletableFuture<LogRecordWithDLSN> record = reader.readNext();\n+                Utils.ioResult(record);\n                 if (recordCount == 0) {\n                     readLatch.countDown();\n                 }\n@@ -1582,7 +1584,7 @@ public void testGetLastTxId() throws Exception {\n \n         int numRecords = 10;\n         for (int i = 0; i < numRecords; i++) {\n-            Await.result(writer.write(DLMTestUtil.getLogRecordInstance(i)));\n+            Utils.ioResult(writer.write(DLMTestUtil.getLogRecordInstance(i)));\n             assertEquals(\"last tx id should become \" + i,\n                     i, writer.getLastTxId());\n         }\n@@ -1612,24 +1614,24 @@ public void testMaxReadAheadRecords() throws Exception {\n \n         int numRecords = 40;\n         for (int i = 1; i <= numRecords; i++) {\n-            Await.result(writer.write(DLMTestUtil.getLogRecordInstance(i)));\n+            Utils.ioResult(writer.write(DLMTestUtil.getLogRecordInstance(i)));\n             assertEquals(\"last tx id should become \" + i,\n                     i, writer.getLastTxId());\n         }\n         LogRecord record = DLMTestUtil.getLogRecordInstance(numRecords);\n         record.setControl();\n-        Await.result(writer.write(record));\n+        Utils.ioResult(writer.write(record));\n \n         BKAsyncLogReader reader = (BKAsyncLogReader) dlm.getAsyncLogReader(DLSN.InitialDLSN);\n-        record = Await.result(reader.readNext());\n+        record = Utils.ioResult(reader.readNext());\n         LOG.info(\"Read record {}\", record);\n         assertEquals(1L, record.getTransactionId());\n \n         assertNotNull(reader.getReadAheadReader());\n         assertTrue(reader.getReadAheadReader().getNumCachedEntries() <= maxAllowedCachedRecords);\n \n         for (int i = 2; i <= numRecords; i++) {\n-            record = Await.result(reader.readNext());\n+            record = Utils.ioResult(reader.readNext());\n             LOG.info(\"Read record {}\", record);\n             assertEquals((long) i, record.getTransactionId());\n             TimeUnit.MILLISECONDS.sleep(20);\n@@ -1656,31 +1658,31 @@ public void testMarkEndOfStream() throws Exception {\n         final int NUM_RECORDS = 10;\n         int i = 1;\n         for (; i <= NUM_RECORDS; i++) {\n-            Await.result(writer.write(DLMTestUtil.getLogRecordInstance(i)));\n+            Utils.ioResult(writer.write(DLMTestUtil.getLogRecordInstance(i)));\n             assertEquals(\"last tx id should become \" + i,\n                     i, writer.getLastTxId());\n         }\n \n-        Await.result(writer.markEndOfStream());\n+        Utils.ioResult(writer.markEndOfStream());\n \n         // Multiple end of streams are ok.\n-        Await.result(writer.markEndOfStream());\n+        Utils.ioResult(writer.markEndOfStream());\n \n         try {\n-            Await.result(writer.write(DLMTestUtil.getLogRecordInstance(i)));\n+            Utils.ioResult(writer.write(DLMTestUtil.getLogRecordInstance(i)));\n             fail(\"Should have thrown\");\n         } catch (EndOfStreamException ex) {\n         }\n \n         BKAsyncLogReader reader = (BKAsyncLogReader) dlm.getAsyncLogReader(DLSN.InitialDLSN);\n         LogRecord record = null;\n         for (int j = 0; j < NUM_RECORDS; j++) {\n-            record = Await.result(reader.readNext());\n+            record = Utils.ioResult(reader.readNext());\n             assertEquals(j+1, record.getTransactionId());\n         }\n \n         try {\n-            record = Await.result(reader.readNext());\n+            record = Utils.ioResult(reader.readNext());\n             fail(\"Should have thrown\");\n         } catch (EndOfStreamException ex) {\n         }\n@@ -1698,17 +1700,17 @@ public void testMarkEndOfStreamAtBeginningOfSegment() throws Exception {\n \n         DistributedLogManager dlm = createNewDLM(confLocal, name);\n         BKAsyncLogWriter writer = (BKAsyncLogWriter) dlm.startAsyncLogSegmentNonPartitioned();\n-        Await.result(writer.markEndOfStream());\n+        Utils.ioResult(writer.markEndOfStream());\n         try {\n-            Await.result(writer.write(DLMTestUtil.getLogRecordInstance(1)));\n+            Utils.ioResult(writer.write(DLMTestUtil.getLogRecordInstance(1)));\n             fail(\"Should have thrown\");\n         } catch (EndOfStreamException ex) {\n         }\n         writer.close();\n \n         BKAsyncLogReader reader = (BKAsyncLogReader) dlm.getAsyncLogReader(DLSN.InitialDLSN);\n         try {\n-            LogRecord record = Await.result(reader.readNext());\n+            LogRecord record = Utils.ioResult(reader.readNext());\n             fail(\"Should have thrown\");\n         } catch (EndOfStreamException ex) {\n         }\n@@ -1726,32 +1728,32 @@ public void testBulkReadWaitingMoreRecords() throws Exception {\n \n         DistributedLogManager dlm = createNewDLM(confLocal, name);\n         BKAsyncLogWriter writer = (BKAsyncLogWriter) dlm.startAsyncLogSegmentNonPartitioned();\n-        FutureUtils.result(writer.write(DLMTestUtil.getLogRecordInstance(1L)));\n+        Utils.ioResult(writer.write(DLMTestUtil.getLogRecordInstance(1L)));\n         LogRecord controlRecord = DLMTestUtil.getLogRecordInstance(1L);\n         controlRecord.setControl();\n-        FutureUtils.result(writer.write(controlRecord));\n+        Utils.ioResult(writer.write(controlRecord));\n \n         BKAsyncLogReader reader = (BKAsyncLogReader) dlm.getAsyncLogReader(DLSN.InitialDLSN);\n-        Future<List<LogRecordWithDLSN>> bulkReadFuture = reader.readBulk(2, Long.MAX_VALUE, TimeUnit.MILLISECONDS);\n-        Future<LogRecordWithDLSN> readFuture = reader.readNext();\n+        CompletableFuture<List<LogRecordWithDLSN>> bulkReadFuture = reader.readBulk(2, Long.MAX_VALUE, TimeUnit.MILLISECONDS);\n+        CompletableFuture<LogRecordWithDLSN> readFuture = reader.readNext();\n \n         // write another records\n         for (int i = 0; i < 5; i++) {\n             long txid = 2L + i;\n-            FutureUtils.result(writer.write(DLMTestUtil.getLogRecordInstance(txid)));\n+            Utils.ioResult(writer.write(DLMTestUtil.getLogRecordInstance(txid)));\n             controlRecord = DLMTestUtil.getLogRecordInstance(txid);\n             controlRecord.setControl();\n-            FutureUtils.result(writer.write(controlRecord));\n+            Utils.ioResult(writer.write(controlRecord));\n         }\n \n-        List<LogRecordWithDLSN> bulkReadRecords = FutureUtils.result(bulkReadFuture);\n+        List<LogRecordWithDLSN> bulkReadRecords = Utils.ioResult(bulkReadFuture);\n         assertEquals(2, bulkReadRecords.size());\n         assertEquals(1L, bulkReadRecords.get(0).getTransactionId());\n         assertEquals(2L, bulkReadRecords.get(1).getTransactionId());\n         for (LogRecordWithDLSN record : bulkReadRecords) {\n             DLMTestUtil.verifyLogRecord(record);\n         }\n-        LogRecordWithDLSN record = FutureUtils.result(readFuture);\n+        LogRecordWithDLSN record = Utils.ioResult(readFuture);\n         assertEquals(3L, record.getTransactionId());\n         DLMTestUtil.verifyLogRecord(record);\n \n@@ -1771,16 +1773,16 @@ public void testBulkReadNotWaitingMoreRecords() throws Exception {\n \n         DistributedLogManager dlm = createNewDLM(confLocal, name);\n         BKAsyncLogWriter writer = (BKAsyncLogWriter) dlm.startAsyncLogSegmentNonPartitioned();\n-        FutureUtils.result(writer.write(DLMTestUtil.getLogRecordInstance(1L)));\n+        Utils.ioResult(writer.write(DLMTestUtil.getLogRecordInstance(1L)));\n         LogRecord controlRecord = DLMTestUtil.getLogRecordInstance(1L);\n         controlRecord.setControl();\n-        FutureUtils.result(writer.write(controlRecord));\n+        Utils.ioResult(writer.write(controlRecord));\n \n         BKAsyncLogReader reader = (BKAsyncLogReader) dlm.getAsyncLogReader(DLSN.InitialDLSN);\n-        Future<List<LogRecordWithDLSN>> bulkReadFuture = reader.readBulk(2, 0, TimeUnit.MILLISECONDS);\n-        Future<LogRecordWithDLSN> readFuture = reader.readNext();\n+        CompletableFuture<List<LogRecordWithDLSN>> bulkReadFuture = reader.readBulk(2, 0, TimeUnit.MILLISECONDS);\n+        CompletableFuture<LogRecordWithDLSN> readFuture = reader.readNext();\n \n-        List<LogRecordWithDLSN> bulkReadRecords = FutureUtils.result(bulkReadFuture);\n+        List<LogRecordWithDLSN> bulkReadRecords = Utils.ioResult(bulkReadFuture);\n         assertEquals(1, bulkReadRecords.size());\n         assertEquals(1L, bulkReadRecords.get(0).getTransactionId());\n         for (LogRecordWithDLSN record : bulkReadRecords) {\n@@ -1790,13 +1792,13 @@ public void testBulkReadNotWaitingMoreRecords() throws Exception {\n         // write another records\n         for (int i = 0; i < 5; i++) {\n             long txid = 2L + i;\n-            FutureUtils.result(writer.write(DLMTestUtil.getLogRecordInstance(txid)));\n+            Utils.ioResult(writer.write(DLMTestUtil.getLogRecordInstance(txid)));\n             controlRecord = DLMTestUtil.getLogRecordInstance(txid);\n             controlRecord.setControl();\n-            FutureUtils.result(writer.write(controlRecord));\n+            Utils.ioResult(writer.write(controlRecord));\n         }\n \n-        LogRecordWithDLSN record = FutureUtils.result(readFuture);\n+        LogRecordWithDLSN record = Utils.ioResult(readFuture);\n         assertEquals(2L, record.getTransactionId());\n         DLMTestUtil.verifyLogRecord(record);\n \n@@ -1832,7 +1834,7 @@ public void testReadBrokenEntries() throws Exception {\n         // 3 segments, 10 records each, immediate flush, batch size 1, so just the first\n         // record in each ledger is discarded, for 30 - 3 = 27 records.\n         for (int i = 0; i < 27; i++) {\n-            LogRecordWithDLSN record = Await.result(reader.readNext());\n+            LogRecordWithDLSN record = Utils.ioResult(reader.readNext());\n             assertFalse(record.getDlsn().getEntryId() % 10 == 0);\n         }\n \n@@ -1868,7 +1870,7 @@ public void testReadBrokenEntriesWithGapDetection() throws Exception {\n             // 3 segments, 10 records each, immediate flush, batch size 1, so just the first\n             // record in each ledger is discarded, for 30 - 3 = 27 records.\n             for (int i = 0; i < 30; i++) {\n-                LogRecordWithDLSN record = Await.result(reader.readNext());\n+                LogRecordWithDLSN record = Utils.ioResult(reader.readNext());\n                 assertFalse(record.getDlsn().getEntryId() % 10 == 0);\n             }\n             fail(\"should have thrown\");\n@@ -1909,7 +1911,7 @@ public void testReadBrokenEntriesAndLargeBatchSize() throws Exception {\n         // 3. ranges 6-10, 7-11, 8-12, 9-13 will be bad\n         // And so on, so 5 records in each 10 will be discarded, for 50 good records.\n         for (int i = 0; i < 50; i++) {\n-            LogRecordWithDLSN record = Await.result(reader.readNext());\n+            LogRecordWithDLSN record = Utils.ioResult(reader.readNext());\n             assertFalse(record.getDlsn().getEntryId() % 10 == 0);\n         }\n \n@@ -1946,7 +1948,7 @@ public void testReadBrokenEntriesAndLargeBatchSizeCrossSegment() throws Exceptio\n         // 2. range 1-8 will be good, but only contain 4 records\n         // And so on for the next segment, so 4 records in each segment, for 12 good records\n         for (int i = 0; i < 12; i++) {\n-            LogRecordWithDLSN record = Await.result(reader.readNext());\n+            LogRecordWithDLSN record = Utils.ioResult(reader.readNext());\n             assertFalse(record.getDlsn().getEntryId() % 10 == 0);\n         }\n \n@@ -1970,13 +1972,13 @@ public void testCreateLogStreamWithDifferentReplicationFactor() throws Exception\n \n         URI uri = createDLMURI(\"/\" + name);\n         ensureURICreated(uri);\n-        DistributedLogNamespace namespace = DistributedLogNamespaceBuilder.newBuilder()\n+        Namespace namespace = NamespaceBuilder.newBuilder()\n                 .conf(confLocal).uri(uri).build();\n \n         // use the pool\n         DistributedLogManager dlm = namespace.openLog(name + \"-pool\");\n         AsyncLogWriter writer = dlm.startAsyncLogSegmentNonPartitioned();\n-        FutureUtils.result(writer.write(DLMTestUtil.getLogRecordInstance(1L)));\n+        Utils.ioResult(writer.write(DLMTestUtil.getLogRecordInstance(1L)));\n         List<LogSegmentMetadata> segments = dlm.getLogSegments();\n         assertEquals(1, segments.size());\n         long ledgerId = segments.get(0).getLogSegmentId();\n@@ -1995,7 +1997,7 @@ public void testCreateLogStreamWithDifferentReplicationFactor() throws Exception\n                 Optional.of(dynConf),\n                 Optional.<StatsLogger>absent());\n         writer = dlm.startAsyncLogSegmentNonPartitioned();\n-        FutureUtils.result(writer.write(DLMTestUtil.getLogRecordInstance(1L)));\n+        Utils.ioResult(writer.write(DLMTestUtil.getLogRecordInstance(1L)));\n         segments = dlm.getLogSegments();\n         assertEquals(1, segments.size());\n         ledgerId = segments.get(0).getLogSegmentId();\n@@ -2023,17 +2025,17 @@ public void testWriteRecordSet() throws Exception {\n \n         DistributedLogManager dlm = createNewDLM(confLocal, name);\n         BKAsyncLogWriter writer = (BKAsyncLogWriter) dlm.startAsyncLogSegmentNonPartitioned();\n-        List<Future<DLSN>> writeFutures = Lists.newArrayList();\n+        List<CompletableFuture<DLSN>> writeFutures = Lists.newArrayList();\n         for (int i = 0; i < 5; i++) {\n             LogRecord record = DLMTestUtil.getLogRecordInstance(1L + i);\n             writeFutures.add(writer.write(record));\n         }\n-        List<Future<DLSN>> recordSetFutures = Lists.newArrayList();\n+        List<CompletableFuture<DLSN>> recordSetFutures = Lists.newArrayList();\n         // write another 5 records\n         final LogRecordSet.Writer recordSetWriter = LogRecordSet.newWriter(4096, CompressionCodec.Type.LZ4);\n         for (int i = 0; i < 5; i++) {\n             LogRecord record = DLMTestUtil.getLogRecordInstance(6L + i);\n-            Promise<DLSN> writePromise = new Promise<DLSN>();\n+            CompletableFuture<DLSN> writePromise = new CompletableFuture<DLSN>();\n             recordSetWriter.writeRecord(ByteBuffer.wrap(record.getPayload()), writePromise);\n             recordSetFutures.add(writePromise);\n         }\n@@ -2042,8 +2044,8 @@ public void testWriteRecordSet() throws Exception {\n         recordSetBuffer.get(data);\n         LogRecord setRecord = new LogRecord(6L, data);\n         setRecord.setRecordSet();\n-        Future<DLSN> writeRecordSetFuture = writer.write(setRecord);\n-        writeRecordSetFuture.addEventListener(new FutureEventListener<DLSN>() {\n+        CompletableFuture<DLSN> writeRecordSetFuture = writer.write(setRecord);\n+        writeRecordSetFuture.whenComplete(new FutureEventListener<DLSN>() {\n             @Override\n             public void onSuccess(DLSN dlsn) {\n                 recordSetWriter.completeTransmit(\n@@ -2058,20 +2060,20 @@ public void onFailure(Throwable cause) {\n             }\n         });\n         writeFutures.add(writeRecordSetFuture);\n-        FutureUtils.result(writeRecordSetFuture);\n+        Utils.ioResult(writeRecordSetFuture);\n         // write last 5 records\n         for (int i = 0; i < 5; i++) {\n             LogRecord record = DLMTestUtil.getLogRecordInstance(11L + i);\n-            Future<DLSN> writeFuture = writer.write(record);\n+            CompletableFuture<DLSN> writeFuture = writer.write(record);\n             writeFutures.add(writeFuture);\n             // make sure get log record count returns the right count\n             if (i == 0) {\n-                FutureUtils.result(writeFuture);\n+                Utils.ioResult(writeFuture);\n                 assertEquals(10, dlm.getLogRecordCount());\n             }\n         }\n \n-        List<DLSN> writeResults = FutureUtils.result(Future.collect(writeFutures));\n+        List<DLSN> writeResults = Utils.ioResult(FutureUtils.collect(writeFutures));\n \n         for (int i = 0; i < 5; i++) {\n             Assert.assertEquals(new DLSN(1L, i, 0L), writeResults.get(i));\n@@ -2080,12 +2082,12 @@ public void onFailure(Throwable cause) {\n         for (int i = 0; i < 5; i++) {\n             Assert.assertEquals(new DLSN(1L, 6L + i, 0L), writeResults.get(6 + i));\n         }\n-        List<DLSN> recordSetWriteResults = Await.result(Future.collect(recordSetFutures));\n+        List<DLSN> recordSetWriteResults = Utils.ioResult(FutureUtils.collect(recordSetFutures));\n         for (int i = 0; i < 5; i++) {\n             Assert.assertEquals(new DLSN(1L, 5L, i), recordSetWriteResults.get(i));\n         }\n \n-        FutureUtils.result(writer.flushAndCommit());\n+        Utils.ioResult(writer.flushAndCommit());\n \n         DistributedLogConfiguration readConf1 = new DistributedLogConfiguration();\n         readConf1.addConfiguration(confLocal);\n@@ -2094,7 +2096,7 @@ public void onFailure(Throwable cause) {\n         DistributedLogManager readDLM1 = createNewDLM(readConf1, name);\n         AsyncLogReader reader1 = readDLM1.getAsyncLogReader(DLSN.InitialDLSN);\n         for (int i = 0; i < 15; i++) {\n-            LogRecordWithDLSN record = FutureUtils.result(reader1.readNext());\n+            LogRecordWithDLSN record = Utils.ioResult(reader1.readNext());\n             if (i < 5) {\n                 assertEquals(new DLSN(1L, i, 0L), record.getDlsn());\n                 assertEquals(1L + i, record.getTransactionId());\n@@ -2118,7 +2120,7 @@ public void onFailure(Throwable cause) {\n         DistributedLogManager readDLM2 = createNewDLM(readConf2, name);\n         AsyncLogReader reader2 = readDLM2.getAsyncLogReader(DLSN.InitialDLSN);\n         for (int i = 0; i < 11; i++) {\n-            LogRecordWithDLSN record = FutureUtils.result(reader2.readNext());\n+            LogRecordWithDLSN record = Utils.ioResult(reader2.readNext());\n             LOG.info(\"Read record {}\", record);\n             if (i < 5) {\n                 assertEquals(new DLSN(1L, i, 0L), record.getDlsn());\n@@ -2159,12 +2161,12 @@ public void testIdleReaderExceptionWhenKeepAliveIsDisabled() throws Exception {\n         ensureURICreated(uri);\n \n         DistributedLogManager dlm = createNewDLM(confLocal, name);\n-        BKAsyncLogWriter writer = (BKAsyncLogWriter) FutureUtils.result(dlm.openAsyncLogWriter());\n+        BKAsyncLogWriter writer = (BKAsyncLogWriter) Utils.ioResult(dlm.openAsyncLogWriter());\n         writer.write(DLMTestUtil.getLogRecordInstance(1L));\n \n-        AsyncLogReader reader = FutureUtils.result(dlm.openAsyncLogReader(DLSN.InitialDLSN));\n+        AsyncLogReader reader = Utils.ioResult(dlm.openAsyncLogReader(DLSN.InitialDLSN));\n         try {\n-            FutureUtils.result(reader.readNext());\n+            Utils.ioResult(reader.readNext());\n             fail(\"Should fail when stream is idle\");\n         } catch (IdleReaderException ire) {\n             // expected\n@@ -2191,11 +2193,11 @@ public void testIdleReaderExceptionWhenKeepAliveIsEnabled() throws Exception {\n         ensureURICreated(uri);\n \n         DistributedLogManager dlm = createNewDLM(confLocal, name);\n-        BKAsyncLogWriter writer = (BKAsyncLogWriter) FutureUtils.result(dlm.openAsyncLogWriter());\n+        BKAsyncLogWriter writer = (BKAsyncLogWriter) Utils.ioResult(dlm.openAsyncLogWriter());\n         writer.write(DLMTestUtil.getLogRecordInstance(1L));\n \n-        AsyncLogReader reader = FutureUtils.result(dlm.openAsyncLogReader(DLSN.InitialDLSN));\n-        LogRecordWithDLSN record = FutureUtils.result(reader.readNext());\n+        AsyncLogReader reader = Utils.ioResult(dlm.openAsyncLogReader(DLSN.InitialDLSN));\n+        LogRecordWithDLSN record = Utils.ioResult(reader.readNext());\n         assertEquals(1L, record.getTransactionId());\n         DLMTestUtil.verifyLogRecord(record);\n "},{"sha":"18e097fa11cd665258f35226176917f02b326d8f","filename":"src/test/java/org/apache/distributedlog/TestBKDistributedLogManager.java","status":"modified","additions":69,"deletions":65,"changes":134,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FTestBKDistributedLogManager.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FTestBKDistributedLogManager.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FTestBKDistributedLogManager.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -23,10 +23,19 @@\n import java.util.List;\n import java.util.Map;\n import java.util.Random;\n+import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicInteger;\n import java.util.concurrent.atomic.AtomicReference;\n \n+import org.apache.distributedlog.api.AsyncLogReader;\n+import org.apache.distributedlog.api.AsyncLogWriter;\n+import org.apache.distributedlog.api.DistributedLogManager;\n+import org.apache.distributedlog.api.LogReader;\n+import org.apache.distributedlog.api.LogWriter;\n+import org.apache.distributedlog.api.MetadataAccessor;\n+import org.apache.distributedlog.api.namespace.Namespace;\n import org.apache.distributedlog.exceptions.AlreadyTruncatedTransactionException;\n import org.apache.distributedlog.exceptions.BKTransmitException;\n import org.apache.distributedlog.exceptions.LogEmptyException;\n@@ -35,7 +44,6 @@\n import org.apache.distributedlog.impl.ZKLogSegmentMetadataStore;\n import org.apache.distributedlog.io.Abortables;\n import org.apache.distributedlog.logsegment.LogSegmentMetadataStore;\n-import org.apache.distributedlog.util.FutureUtils;\n import org.apache.distributedlog.util.OrderedScheduler;\n import org.apache.distributedlog.util.Utils;\n import org.apache.bookkeeper.client.BKException;\n@@ -54,12 +62,8 @@\n import org.apache.distributedlog.metadata.LogMetadata;\n import org.apache.distributedlog.metadata.MetadataUpdater;\n import org.apache.distributedlog.metadata.LogSegmentMetadataStoreUpdater;\n-import org.apache.distributedlog.namespace.DistributedLogNamespace;\n-import org.apache.distributedlog.namespace.DistributedLogNamespaceBuilder;\n-import org.apache.distributedlog.subscription.SubscriptionsStore;\n-import com.twitter.util.Await;\n-import com.twitter.util.Duration;\n-import com.twitter.util.Future;\n+import org.apache.distributedlog.api.namespace.NamespaceBuilder;\n+import org.apache.distributedlog.api.subscription.SubscriptionsStore;\n \n import static org.junit.Assert.*;\n import static org.junit.Assert.assertEquals;\n@@ -89,7 +93,7 @@ private void testNonPartitionedWritesInternal(String name, DistributedLogConfigu\n             BKLogWriteHandler blplm = dlm.createWriteHandler(true);\n             assertNotNull(zkc.exists(blplm.completedLedgerZNode(start, txid - 1,\n                                                                 perStreamLogWriter.getLogSegmentSequenceNumber()), false));\n-            FutureUtils.result(blplm.asyncClose());\n+            Utils.ioResult(blplm.asyncClose());\n         }\n \n         LogWriter writer = dlm.startLogSegmentNonPartitioned();\n@@ -129,7 +133,7 @@ public void testSimpleWrite() throws Exception {\n         BKLogWriteHandler blplm = dlm.createWriteHandler(true);\n         assertNotNull(zkc.exists(blplm.completedLedgerZNode(1, 100,\n                 perStreamLogWriter.getLogSegmentSequenceNumber()), false));\n-        FutureUtils.result(blplm.asyncClose());\n+        Utils.ioResult(blplm.asyncClose());\n     }\n \n     @Test(timeout = 60000)\n@@ -167,7 +171,7 @@ public void testContinuousReaders() throws Exception {\n             assertNotNull(\n                 zkc.exists(blplm.completedLedgerZNode(start, txid - 1,\n                                                       perStreamLogWriter.getLogSegmentSequenceNumber()), false));\n-            FutureUtils.result(blplm.asyncClose());\n+            Utils.ioResult(blplm.asyncClose());\n         }\n \n         BKSyncLogWriter out = dlm.startLogSegmentNonPartitioned();\n@@ -263,14 +267,14 @@ public void testTwoWritersOnLockDisabled() throws Exception {\n         confLocal.setWriteLockEnabled(false);\n         String name = \"distrlog-two-writers-lock-disabled\";\n         DistributedLogManager manager = createNewDLM(confLocal, name);\n-        AsyncLogWriter writer1 = FutureUtils.result(manager.openAsyncLogWriter());\n-        FutureUtils.result(writer1.write(DLMTestUtil.getLogRecordInstance(1L)));\n-        AsyncLogWriter writer2 = FutureUtils.result(manager.openAsyncLogWriter());\n-        FutureUtils.result(writer2.write(DLMTestUtil.getLogRecordInstance(2L)));\n+        AsyncLogWriter writer1 = Utils.ioResult(manager.openAsyncLogWriter());\n+        Utils.ioResult(writer1.write(DLMTestUtil.getLogRecordInstance(1L)));\n+        AsyncLogWriter writer2 = Utils.ioResult(manager.openAsyncLogWriter());\n+        Utils.ioResult(writer2.write(DLMTestUtil.getLogRecordInstance(2L)));\n \n         // write a record to writer 1 again\n         try {\n-            FutureUtils.result(writer1.write(DLMTestUtil.getLogRecordInstance(3L)));\n+            Utils.ioResult(writer1.write(DLMTestUtil.getLogRecordInstance(3L)));\n             fail(\"Should fail writing record to writer 1 again as writer 2 took over the ownership\");\n         } catch (BKTransmitException bkte) {\n             assertEquals(BKException.Code.LedgerFencedException, bkte.getBKResultCode());\n@@ -311,7 +315,7 @@ public void testNumberOfTransactionsWithInprogressAtEnd() throws Exception {\n             assertNotNull(\n                 zkc.exists(blplm.completedLedgerZNode(start, txid - 1,\n                                                       perStreamLogWriter.getLogSegmentSequenceNumber()), false));\n-            FutureUtils.result(blplm.asyncClose());\n+            Utils.ioResult(blplm.asyncClose());\n         }\n         BKSyncLogWriter out = (BKSyncLogWriter)dlm.startLogSegmentNonPartitioned();\n         for (long j = 1; j <= DEFAULT_SEGMENT_SIZE / 2; j++) {\n@@ -394,7 +398,7 @@ public void testContinuousReadersWithEmptyLedgers() throws Exception {\n             assertNotNull(\n                 zkc.exists(blplm.completedLedgerZNode(txid - 1, txid - 1,\n                                                       perStreamLogWriter.getLogSegmentSequenceNumber()), false));\n-            FutureUtils.result(blplm.asyncClose());\n+            Utils.ioResult(blplm.asyncClose());\n         }\n \n         BKSyncLogWriter out = (BKSyncLogWriter)dlm.startLogSegmentNonPartitioned();\n@@ -411,14 +415,14 @@ public void testContinuousReadersWithEmptyLedgers() throws Exception {\n \n         AsyncLogReader asyncreader = dlm.getAsyncLogReader(DLSN.InvalidDLSN);\n         long numTrans = 0;\n-        LogRecordWithDLSN record = Await.result(asyncreader.readNext());\n+        LogRecordWithDLSN record = Utils.ioResult(asyncreader.readNext());\n         while (null != record) {\n             DLMTestUtil.verifyLogRecord(record);\n             numTrans++;\n             if (numTrans >= (txid - 1)) {\n                 break;\n             }\n-            record = Await.result(asyncreader.readNext());\n+            record = Utils.ioResult(asyncreader.readNext());\n         }\n         assertEquals((txid - 1), numTrans);\n         Utils.close(asyncreader);\n@@ -459,12 +463,12 @@ public void testCheckLogExists() throws Exception {\n         dlm.close();\n \n         URI uri = createDLMURI(\"/\" + name);\n-        DistributedLogNamespace namespace = DistributedLogNamespaceBuilder.newBuilder()\n+        Namespace namespace = NamespaceBuilder.newBuilder()\n                 .conf(conf).uri(uri).build();\n         assertTrue(namespace.logExists(name));\n         assertFalse(namespace.logExists(\"non-existent-log\"));\n         URI nonExistentUri = createDLMURI(\"/\" + \"non-existent-ns\");\n-        DistributedLogNamespace nonExistentNS = DistributedLogNamespaceBuilder.newBuilder()\n+        Namespace nonExistentNS = NamespaceBuilder.newBuilder()\n                 .conf(conf).uri(nonExistentUri).build();\n         assertFalse(nonExistentNS.logExists(name));\n \n@@ -508,31 +512,31 @@ public void testSubscriptionsStore() throws Exception {\n         SubscriptionsStore store = dlm.getSubscriptionsStore();\n \n         // no data\n-        assertEquals(Await.result(store.getLastCommitPosition(subscriber0)), DLSN.NonInclusiveLowerBound);\n-        assertEquals(Await.result(store.getLastCommitPosition(subscriber1)), DLSN.NonInclusiveLowerBound);\n-        assertEquals(Await.result(store.getLastCommitPosition(subscriber2)), DLSN.NonInclusiveLowerBound);\n+        assertEquals(Utils.ioResult(store.getLastCommitPosition(subscriber0)), DLSN.NonInclusiveLowerBound);\n+        assertEquals(Utils.ioResult(store.getLastCommitPosition(subscriber1)), DLSN.NonInclusiveLowerBound);\n+        assertEquals(Utils.ioResult(store.getLastCommitPosition(subscriber2)), DLSN.NonInclusiveLowerBound);\n         // empty\n-        assertTrue(Await.result(store.getLastCommitPositions()).isEmpty());\n+        assertTrue(Utils.ioResult(store.getLastCommitPositions()).isEmpty());\n \n         // subscriber 0 advance\n-        Await.result(store.advanceCommitPosition(subscriber0, commitPosition0));\n-        assertEquals(commitPosition0, Await.result(store.getLastCommitPosition(subscriber0)));\n-        Map<String, DLSN> committedPositions = Await.result(store.getLastCommitPositions());\n+        Utils.ioResult(store.advanceCommitPosition(subscriber0, commitPosition0));\n+        assertEquals(commitPosition0, Utils.ioResult(store.getLastCommitPosition(subscriber0)));\n+        Map<String, DLSN> committedPositions = Utils.ioResult(store.getLastCommitPositions());\n         assertEquals(1, committedPositions.size());\n         assertEquals(commitPosition0, committedPositions.get(subscriber0));\n \n         // subscriber 1 advance\n-        Await.result(store.advanceCommitPosition(subscriber1, commitPosition1));\n-        assertEquals(commitPosition1, Await.result(store.getLastCommitPosition(subscriber1)));\n-        committedPositions = Await.result(store.getLastCommitPositions());\n+        Utils.ioResult(store.advanceCommitPosition(subscriber1, commitPosition1));\n+        assertEquals(commitPosition1, Utils.ioResult(store.getLastCommitPosition(subscriber1)));\n+        committedPositions = Utils.ioResult(store.getLastCommitPositions());\n         assertEquals(2, committedPositions.size());\n         assertEquals(commitPosition0, committedPositions.get(subscriber0));\n         assertEquals(commitPosition1, committedPositions.get(subscriber1));\n \n         // subscriber 2 advance\n-        Await.result(store.advanceCommitPosition(subscriber2, commitPosition2));\n-        assertEquals(commitPosition2, Await.result(store.getLastCommitPosition(subscriber2)));\n-        committedPositions = Await.result(store.getLastCommitPositions());\n+        Utils.ioResult(store.advanceCommitPosition(subscriber2, commitPosition2));\n+        assertEquals(commitPosition2, Utils.ioResult(store.getLastCommitPosition(subscriber2)));\n+        committedPositions = Utils.ioResult(store.getLastCommitPositions());\n         assertEquals(3, committedPositions.size());\n         assertEquals(commitPosition0, committedPositions.get(subscriber0));\n         assertEquals(commitPosition1, committedPositions.get(subscriber1));\n@@ -541,11 +545,11 @@ public void testSubscriptionsStore() throws Exception {\n         // subscriber 2 advance again\n         DistributedLogManager newDLM = createNewDLM(conf, name);\n         SubscriptionsStore newStore = newDLM.getSubscriptionsStore();\n-        Await.result(newStore.advanceCommitPosition(subscriber2, commitPosition3));\n+        Utils.ioResult(newStore.advanceCommitPosition(subscriber2, commitPosition3));\n         newStore.close();\n         newDLM.close();\n \n-        committedPositions = Await.result(store.getLastCommitPositions());\n+        committedPositions = Utils.ioResult(store.getLastCommitPositions());\n         assertEquals(3, committedPositions.size());\n         assertEquals(commitPosition0, committedPositions.get(subscriber0));\n         assertEquals(commitPosition1, committedPositions.get(subscriber1));\n@@ -570,13 +574,13 @@ private long writeAndMarkEndOfStream(DistributedLogManager dlm, long txid) throw\n                 BKLogWriteHandler blplm = ((BKDistributedLogManager) (dlm)).createWriteHandler(true);\n                 assertNotNull(zkc.exists(blplm.completedLedgerZNode(start, txid - 1,\n                                                                     perStreamLogWriter.getLogSegmentSequenceNumber()), false));\n-                FutureUtils.result(blplm.asyncClose());\n+                Utils.ioResult(blplm.asyncClose());\n             } else {\n                 writer.markEndOfStream();\n                 BKLogWriteHandler blplm = ((BKDistributedLogManager) (dlm)).createWriteHandler(true);\n                 assertNotNull(zkc.exists(blplm.completedLedgerZNode(start, DistributedLogConstants.MAX_TXID,\n                                                                     perStreamLogWriter.getLogSegmentSequenceNumber()), false));\n-                FutureUtils.result(blplm.asyncClose());\n+                Utils.ioResult(blplm.asyncClose());\n             }\n         }\n         return txid;\n@@ -698,8 +702,8 @@ private void markEndOfStreamOnEmptyLogSegment(int numCompletedSegments) throws E\n     @Test(timeout = 60000, expected = LogRecordTooLongException.class)\n     public void testMaxLogRecSize() throws Exception {\n         DistributedLogManager dlm = createNewDLM(conf, \"distrlog-maxlogRecSize\");\n-        AsyncLogWriter writer = FutureUtils.result(dlm.openAsyncLogWriter());\n-        FutureUtils.result(writer.write(new LogRecord(1L, DLMTestUtil.repeatString(\n+        AsyncLogWriter writer = Utils.ioResult(dlm.openAsyncLogWriter());\n+        Utils.ioResult(writer.write(new LogRecord(1L, DLMTestUtil.repeatString(\n                                 DLMTestUtil.repeatString(\"abcdefgh\", 256), 512).getBytes())));\n     }\n \n@@ -710,21 +714,21 @@ public void testMaxTransmissionSize() throws Exception {\n         confLocal.setOutputBufferSize(1024 * 1024);\n         BKDistributedLogManager dlm =\n                 createNewDLM(confLocal, \"distrlog-transmissionSize\");\n-        AsyncLogWriter out = FutureUtils.result(dlm.openAsyncLogWriter());\n+        AsyncLogWriter out = Utils.ioResult(dlm.openAsyncLogWriter());\n         boolean exceptionEncountered = false;\n         byte[] largePayload = new byte[(LogRecord.MAX_LOGRECORDSET_SIZE / 2) + 2];\n         RAND.nextBytes(largePayload);\n         try {\n             LogRecord op = new LogRecord(1L, largePayload);\n-            Future<DLSN> firstWriteFuture = out.write(op);\n+            CompletableFuture<DLSN> firstWriteFuture = out.write(op);\n             op = new LogRecord(2L, largePayload);\n             // the second write will flush the first one, since we reached the maximum transmission size.\n             out.write(op);\n-            FutureUtils.result(firstWriteFuture);\n+            Utils.ioResult(firstWriteFuture);\n         } catch (LogRecordTooLongException exc) {\n             exceptionEncountered = true;\n         } finally {\n-            FutureUtils.result(out.asyncClose());\n+            Utils.ioResult(out.asyncClose());\n         }\n         assertFalse(exceptionEncountered);\n         Abortables.abortQuietly(out);\n@@ -750,7 +754,7 @@ public void deleteDuringRead() throws Exception {\n             BKLogWriteHandler blplm = ((BKDistributedLogManager) (dlm)).createWriteHandler(true);\n             assertNotNull(zkc.exists(blplm.completedLedgerZNode(start, txid - 1,\n                                                                 perStreamLogWriter.getLogSegmentSequenceNumber()), false));\n-            FutureUtils.result(blplm.asyncClose());\n+            Utils.ioResult(blplm.asyncClose());\n         }\n \n         LogReader reader = dlm.getInputStream(1);\n@@ -819,7 +823,7 @@ public void testLastLogRecordWithEmptyLedgers() throws Exception {\n             assertNotNull(\n                 zkc.exists(blplm.completedLedgerZNode(txid - 1, txid - 1,\n                                                       writer.getLogSegmentSequenceNumber()), false));\n-            FutureUtils.result(blplm.asyncClose());\n+            Utils.ioResult(blplm.asyncClose());\n         }\n \n         BKSyncLogWriter out = (BKSyncLogWriter)dlm.startLogSegmentNonPartitioned();\n@@ -857,7 +861,7 @@ public void testLogSegmentListener() throws Exception {\n \n         BKDistributedLogManager dlm = (BKDistributedLogManager) createNewDLM(conf, name);\n \n-        FutureUtils.result(dlm.getWriterMetadataStore().getLog(dlm.getUri(), name, true, true));\n+        Utils.ioResult(dlm.getWriterMetadataStore().getLog(dlm.getUri(), name, true, true));\n         dlm.registerListener(new LogSegmentListener() {\n             @Override\n             public void onSegmentsUpdated(List<LogSegmentMetadata> segments) {\n@@ -931,7 +935,7 @@ public void testGetLastDLSN() throws Exception {\n         for (int i = 0; i < 10; i++) {\n             LogRecord record = DLMTestUtil.getLogRecordInstance(txid++);\n             record.setControl();\n-            Await.result(writer.writeControlRecord(record));\n+            Utils.ioResult(writer.writeControlRecord(record));\n         }\n         LOG.info(\"10 control records are written\");\n \n@@ -946,14 +950,14 @@ public void testGetLastDLSN() throws Exception {\n         LOG.info(\"Completed first log segment\");\n \n         writer = (BKAsyncLogWriter) dlm.startAsyncLogSegmentNonPartitioned();\n-        Await.result(writer.write(DLMTestUtil.getLogRecordInstance(txid++)));\n+        Utils.ioResult(writer.write(DLMTestUtil.getLogRecordInstance(txid++)));\n         LOG.info(\"Completed second log segment\");\n \n         LOG.info(\"Writing another 10 control records\");\n         for (int i = 1; i < 10; i++) {\n             LogRecord record = DLMTestUtil.getLogRecordInstance(txid++);\n             record.setControl();\n-            Await.result(writer.write(record));\n+            Utils.ioResult(writer.write(record));\n         }\n \n         assertEquals(new DLSN(2, 0, 0), dlm.getLastDLSN());\n@@ -973,8 +977,8 @@ public void testGetLogRecordCountAsync() throws Exception {\n         BKAsyncLogWriter writer = (BKAsyncLogWriter) dlm.startAsyncLogSegmentNonPartitioned();\n         DLMTestUtil.generateCompletedLogSegments(dlm, conf, 2, 10);\n \n-        Future<Long> futureCount = dlm.getLogRecordCountAsync(DLSN.InitialDLSN);\n-        Long count = Await.result(futureCount, Duration.fromSeconds(2));\n+        CompletableFuture<Long> futureCount = dlm.getLogRecordCountAsync(DLSN.InitialDLSN);\n+        Long count = Utils.ioResult(futureCount, 2, TimeUnit.SECONDS);\n         assertEquals(20, count.longValue());\n \n         writer.close();\n@@ -986,7 +990,7 @@ public void testInvalidStreamFromInvalidZkPath() throws Exception {\n         String baseName = testNames.getMethodName();\n         String streamName = \"\\0blah\";\n         URI uri = createDLMURI(\"/\" + baseName);\n-        DistributedLogNamespace namespace = DistributedLogNamespaceBuilder.newBuilder()\n+        Namespace namespace = NamespaceBuilder.newBuilder()\n                 .conf(conf).uri(uri).build();\n \n         DistributedLogManager dlm = null;\n@@ -1036,15 +1040,15 @@ public void testTruncationValidation() throws Exception {\n             BKAsyncLogWriter writer = dlm.startAsyncLogSegmentNonPartitioned();\n             for (long j = 1; j <= 10; j++) {\n                 LogRecord record = DLMTestUtil.getLargeLogRecordInstance(txid++);\n-                Future<DLSN> dlsn = writer.write(record);\n+                CompletableFuture<DLSN> dlsn = writer.write(record);\n \n                 if (i == 1 && j == 2) {\n-                    truncDLSN = Await.result(dlsn);\n+                    truncDLSN = Utils.ioResult(dlsn);\n                 } else if (i == 2 && j == 3) {\n-                    beyondTruncDLSN = Await.result(dlsn);\n+                    beyondTruncDLSN = Utils.ioResult(dlsn);\n                     beyondTruncTxId = record.getTransactionId();\n                 } else if (j == 10) {\n-                    Await.ready(dlsn);\n+                    Utils.ioResult(dlsn);\n                 }\n             }\n \n@@ -1065,7 +1069,7 @@ public void testTruncationValidation() throws Exception {\n \n         MetadataUpdater updater = LogSegmentMetadataStoreUpdater.createMetadataUpdater(\n                 confLocal, metadataStore);\n-        FutureUtils.result(updater.setLogSegmentTruncated(segmentList.get(1L)));\n+        Utils.ioResult(updater.setLogSegmentTruncated(segmentList.get(1L)));\n \n         segmentList = DLMTestUtil.readLogSegments(zookeeperClient,\n                 LogMetadata.getLogSegmentsPath(uri, name, confLocal.getUnpartitionedStreamName()));\n@@ -1088,15 +1092,15 @@ public void testTruncationValidation() throws Exception {\n         }\n \n         updater = LogSegmentMetadataStoreUpdater.createMetadataUpdater(confLocal, metadataStore);\n-        FutureUtils.result(updater.setLogSegmentActive(segmentList.get(1L)));\n+        Utils.ioResult(updater.setLogSegmentActive(segmentList.get(1L)));\n \n         segmentList = DLMTestUtil.readLogSegments(zookeeperClient,\n                 LogMetadata.getLogSegmentsPath(uri, name, confLocal.getUnpartitionedStreamName()));\n \n         LOG.info(\"Read segments after marked first segment as active : {}\", segmentList);\n \n         updater = LogSegmentMetadataStoreUpdater.createMetadataUpdater(confLocal, metadataStore);\n-        FutureUtils.result(updater.setLogSegmentTruncated(segmentList.get(2L)));\n+        Utils.ioResult(updater.setLogSegmentTruncated(segmentList.get(2L)));\n \n         segmentList = DLMTestUtil.readLogSegments(zookeeperClient,\n                 LogMetadata.getLogSegmentsPath(uri, name, confLocal.getUnpartitionedStreamName()));\n@@ -1109,7 +1113,7 @@ public void testTruncationValidation() throws Exception {\n             boolean exceptionEncountered = false;\n             try {\n                 for (int i = 0; i < 3 * 10; i++) {\n-                    LogRecordWithDLSN record = Await.result(reader.readNext());\n+                    LogRecordWithDLSN record = Utils.ioResult(reader.readNext());\n                     DLMTestUtil.verifyLargeLogRecord(record);\n                     assertEquals(expectedTxId, record.getTransactionId());\n                     expectedTxId++;\n@@ -1122,10 +1126,10 @@ public void testTruncationValidation() throws Exception {\n         }\n \n         updater = LogSegmentMetadataStoreUpdater.createMetadataUpdater(conf, metadataStore);\n-        FutureUtils.result(updater.setLogSegmentActive(segmentList.get(2L)));\n+        Utils.ioResult(updater.setLogSegmentActive(segmentList.get(2L)));\n \n         BKAsyncLogWriter writer = dlm.startAsyncLogSegmentNonPartitioned();\n-        Assert.assertTrue(Await.result(writer.truncate(truncDLSN)));\n+        Assert.assertTrue(Utils.ioResult(writer.truncate(truncDLSN)));\n         BKLogWriteHandler handler = writer.getCachedWriteHandler();\n         List<LogSegmentMetadata> cachedSegments = handler.getCachedLogSegments(LogSegmentMetadata.COMPARATOR);\n         for (LogSegmentMetadata segment: cachedSegments) {\n@@ -1164,7 +1168,7 @@ public void testTruncationValidation() throws Exception {\n \n         {\n             AsyncLogReader reader = dlm.getAsyncLogReader(DLSN.InitialDLSN);\n-            LogRecordWithDLSN record = Await.result(reader.readNext());\n+            LogRecordWithDLSN record = Utils.ioResult(reader.readNext());\n             assertTrue(record != null);\n             assertEquals(truncDLSN, record.getDlsn());\n             Utils.close(reader);\n@@ -1190,7 +1194,7 @@ public void testTruncationValidation() throws Exception {\n \n         {\n             AsyncLogReader reader = dlm.getAsyncLogReader(beyondTruncDLSN);\n-            LogRecordWithDLSN record = Await.result(reader.readNext());\n+            LogRecordWithDLSN record = Utils.ioResult(reader.readNext());\n             assertTrue(record != null);\n             assertEquals(beyondTruncDLSN, record.getDlsn());\n             Utils.close(reader);"},{"sha":"2078a88ff293055b6705087b8928f6c0381803d0","filename":"src/test/java/org/apache/distributedlog/TestBKDistributedLogNamespace.java","status":"modified","additions":12,"deletions":9,"changes":21,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FTestBKDistributedLogNamespace.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FTestBKDistributedLogNamespace.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FTestBKDistributedLogNamespace.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -28,14 +28,17 @@\n import java.util.concurrent.atomic.AtomicReference;\n \n import com.google.common.collect.Sets;\n+import org.apache.distributedlog.api.DistributedLogManager;\n+import org.apache.distributedlog.api.LogReader;\n+import org.apache.distributedlog.api.LogWriter;\n+import org.apache.distributedlog.api.namespace.Namespace;\n import org.apache.distributedlog.callback.NamespaceListener;\n import org.apache.distributedlog.exceptions.AlreadyClosedException;\n import org.apache.distributedlog.exceptions.InvalidStreamNameException;\n import org.apache.distributedlog.exceptions.LockingException;\n import org.apache.distributedlog.exceptions.ZKException;\n import org.apache.distributedlog.impl.BKNamespaceDriver;\n-import org.apache.distributedlog.namespace.DistributedLogNamespace;\n-import org.apache.distributedlog.namespace.DistributedLogNamespaceBuilder;\n+import org.apache.distributedlog.api.namespace.NamespaceBuilder;\n import org.apache.distributedlog.util.DLUtils;\n import org.apache.zookeeper.CreateMode;\n import org.apache.zookeeper.KeeperException;\n@@ -95,8 +98,8 @@ private void createLogPathTest(String logName) throws Exception {\n         DistributedLogConfiguration newConf = new DistributedLogConfiguration();\n         newConf.addConfiguration(conf);\n         newConf.setCreateStreamIfNotExists(false);\n-        DistributedLogNamespace namespace = DistributedLogNamespaceBuilder.newBuilder()\n-                .conf(newConf).uri(uri).build();\n+        Namespace namespace = NamespaceBuilder.newBuilder()\n+            .conf(newConf).uri(uri).build();\n         DistributedLogManager dlm = namespace.openLog(logName);\n         LogWriter writer;\n         try {\n@@ -118,7 +121,7 @@ public void testCreateIfNotExists() throws Exception {\n         newConf.addConfiguration(conf);\n         newConf.setCreateStreamIfNotExists(false);\n         String streamName = \"test-stream\";\n-        DistributedLogNamespace namespace = DistributedLogNamespaceBuilder.newBuilder()\n+        Namespace namespace = NamespaceBuilder.newBuilder()\n                 .conf(newConf).uri(uri).build();\n         DistributedLogManager dlm = namespace.openLog(streamName);\n         LogWriter writer;\n@@ -148,7 +151,7 @@ public void testInvalidStreamName() throws Exception {\n \n         URI uri = createDLMURI(\"/\" + runtime.getMethodName());\n \n-        DistributedLogNamespace namespace = DistributedLogNamespaceBuilder.newBuilder()\n+        Namespace namespace = NamespaceBuilder.newBuilder()\n                 .conf(conf).uri(uri).build();\n \n         try {\n@@ -225,7 +228,7 @@ public void testInvalidStreamName() throws Exception {\n     public void testNamespaceListener() throws Exception {\n         URI uri = createDLMURI(\"/\" + runtime.getMethodName());\n         zooKeeperClient.get().create(uri.getPath(), new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n-        DistributedLogNamespace namespace = DistributedLogNamespaceBuilder.newBuilder()\n+        Namespace namespace = NamespaceBuilder.newBuilder()\n                 .conf(conf).uri(uri).build();\n         final CountDownLatch[] latches = new CountDownLatch[3];\n         for (int i = 0; i < 3; i++) {\n@@ -268,7 +271,7 @@ private void initDlogMeta(String dlNamespace, String un, String streamName) thro\n         newConf.addConfiguration(conf);\n         newConf.setCreateStreamIfNotExists(true);\n         newConf.setZkAclId(un);\n-        DistributedLogNamespace namespace = DistributedLogNamespaceBuilder.newBuilder()\n+        Namespace namespace = NamespaceBuilder.newBuilder()\n                 .conf(newConf).uri(uri).build();\n         DistributedLogManager dlm = namespace.openLog(streamName);\n         LogWriter writer = dlm.startLogSegmentNonPartitioned();\n@@ -400,7 +403,7 @@ public void testValidateAndGetFullLedgerAllocatorPoolPath() throws Exception {\n     @Test(timeout = 60000)\n     public void testUseNamespaceAfterCloseShouldFailFast() throws Exception {\n         URI uri = createDLMURI(\"/\" + runtime.getMethodName());\n-        DistributedLogNamespace namespace = DistributedLogNamespaceBuilder.newBuilder()\n+        Namespace namespace = NamespaceBuilder.newBuilder()\n             .conf(conf)\n             .uri(uri)\n             .build();"},{"sha":"4915137642bf633e8c40a9470a07a752189d0608","filename":"src/test/java/org/apache/distributedlog/TestBKLogReadHandler.java","status":"modified","additions":60,"deletions":59,"changes":119,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FTestBKLogReadHandler.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FTestBKLogReadHandler.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FTestBKLogReadHandler.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -18,20 +18,21 @@\n package org.apache.distributedlog;\n \n import com.google.common.base.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeoutException;\n+import org.apache.distributedlog.api.AsyncLogWriter;\n+import org.apache.distributedlog.api.DistributedLogManager;\n+import org.apache.distributedlog.api.LogWriter;\n import org.apache.distributedlog.exceptions.LogNotFoundException;\n import org.apache.distributedlog.exceptions.OwnershipAcquireFailedException;\n import org.apache.distributedlog.logsegment.LogSegmentFilter;\n-import org.apache.distributedlog.util.FutureUtils;\n+import org.apache.distributedlog.common.concurrent.FutureUtils;\n import org.apache.distributedlog.util.Utils;\n-import com.twitter.util.Duration;\n-import com.twitter.util.Future;\n-import com.twitter.util.Await;\n \n import java.util.List;\n import java.util.ArrayList;\n import java.util.concurrent.TimeUnit;\n \n-import com.twitter.util.TimeoutException;\n import org.junit.Rule;\n import org.junit.Test;\n import org.junit.rules.TestName;\n@@ -78,21 +79,21 @@ public void testGetFirstDLSNWithOpenLedger() throws Exception {\n         DistributedLogManager dlm1 = createNewDLM(confLocal, dlName);\n         long txid = 1;\n \n-        ArrayList<Future<DLSN>> futures = new ArrayList<Future<DLSN>>(numEntriesPerSegment);\n+        ArrayList<CompletableFuture<DLSN>> futures = new ArrayList<CompletableFuture<DLSN>>(numEntriesPerSegment);\n         AsyncLogWriter out = dlm1.startAsyncLogSegmentNonPartitioned();\n         for (int eid = 0; eid < numEntriesPerSegment; ++eid) {\n             futures.add(out.write(DLMTestUtil.getLogRecordInstance(txid)));\n             ++txid;\n         }\n-        FutureUtils.result(Future.collect(futures));\n+        Utils.ioResult(FutureUtils.collect(futures));\n         // commit\n         LogRecord controlRecord = new LogRecord(txid, DistributedLogConstants.CONTROL_RECORD_CONTENT);\n         controlRecord.setControl();\n-        FutureUtils.result(out.write(controlRecord));\n+        Utils.ioResult(out.write(controlRecord));\n \n         DLSN last = dlm1.getLastDLSN();\n         assertEquals(new DLSN(1,9,0), last);\n-        DLSN first = Await.result(dlm1.getFirstDLSNAsync());\n+        DLSN first = Utils.ioResult(dlm1.getFirstDLSNAsync());\n         assertEquals(new DLSN(1,0,0), first);\n         Utils.close(out);\n     }\n@@ -102,9 +103,9 @@ public void testGetFirstDLSNNoLogSegments() throws Exception {\n         String dlName = runtime.getMethodName();\n         BKDistributedLogManager dlm = createNewDLM(conf, dlName);\n         BKLogReadHandler readHandler = dlm.createReadHandler();\n-        Future<LogRecordWithDLSN> futureRecord = readHandler.asyncGetFirstLogRecord();\n+        CompletableFuture<LogRecordWithDLSN> futureRecord = readHandler.asyncGetFirstLogRecord();\n         try {\n-            Await.result(futureRecord);\n+            Utils.ioResult(futureRecord);\n             fail(\"should have thrown exception\");\n         } catch (LogNotFoundException ex) {\n         }\n@@ -116,9 +117,9 @@ public void testGetFirstDLSNWithLogSegments() throws Exception {\n         BKDistributedLogManager dlm = createNewDLM(conf, dlName);\n         DLMTestUtil.generateCompletedLogSegments(dlm, conf, 3, 3);\n         BKLogReadHandler readHandler = dlm.createReadHandler();\n-        Future<LogRecordWithDLSN> futureRecord = readHandler.asyncGetFirstLogRecord();\n+        CompletableFuture<LogRecordWithDLSN> futureRecord = readHandler.asyncGetFirstLogRecord();\n         try {\n-            LogRecordWithDLSN record = Await.result(futureRecord);\n+            LogRecordWithDLSN record = Utils.ioResult(futureRecord);\n             assertEquals(new DLSN(1, 0, 0), record.getDlsn());\n         } catch (Exception ex) {\n             fail(\"should not have thrown exception: \" + ex);\n@@ -133,11 +134,11 @@ public void testGetFirstDLSNAfterCleanTruncation() throws Exception {\n         BKLogReadHandler readHandler =\n             ((BKDistributedLogManager) dlm).createReadHandler();\n         AsyncLogWriter writer = dlm.startAsyncLogSegmentNonPartitioned();\n-        Future<Boolean> futureSuccess = writer.truncate(new DLSN(2, 0, 0));\n-        Boolean success = Await.result(futureSuccess);\n+        CompletableFuture<Boolean> futureSuccess = writer.truncate(new DLSN(2, 0, 0));\n+        Boolean success = Utils.ioResult(futureSuccess);\n         assertTrue(success);\n-        Future<LogRecordWithDLSN> futureRecord = readHandler.asyncGetFirstLogRecord();\n-        LogRecordWithDLSN record = Await.result(futureRecord);\n+        CompletableFuture<LogRecordWithDLSN> futureRecord = readHandler.asyncGetFirstLogRecord();\n+        LogRecordWithDLSN record = Utils.ioResult(futureRecord);\n         assertEquals(new DLSN(2, 0, 0), record.getDlsn());\n     }\n \n@@ -151,11 +152,11 @@ public void testGetFirstDLSNAfterPartialTruncation() throws Exception {\n         AsyncLogWriter writer = dlm.startAsyncLogSegmentNonPartitioned();\n \n         // Only truncates at ledger boundary.\n-        Future<Boolean> futureSuccess = writer.truncate(new DLSN(2, 5, 0));\n-        Boolean success = Await.result(futureSuccess);\n+        CompletableFuture<Boolean> futureSuccess = writer.truncate(new DLSN(2, 5, 0));\n+        Boolean success = Utils.ioResult(futureSuccess);\n         assertTrue(success);\n-        Future<LogRecordWithDLSN> futureRecord = readHandler.asyncGetFirstLogRecord();\n-        LogRecordWithDLSN record = Await.result(futureRecord);\n+        CompletableFuture<LogRecordWithDLSN> futureRecord = readHandler.asyncGetFirstLogRecord();\n+        LogRecordWithDLSN record = Utils.ioResult(futureRecord);\n         assertEquals(new DLSN(2, 0, 0), record.getDlsn());\n     }\n \n@@ -164,10 +165,10 @@ public void testGetLogRecordCountEmptyLedger() throws Exception {\n         String dlName = runtime.getMethodName();\n         DistributedLogManager dlm = createNewDLM(conf, dlName);\n         BKLogReadHandler readHandler = ((BKDistributedLogManager) dlm).createReadHandler();\n-        Future<Long> count = null;\n+        CompletableFuture<Long> count = null;\n         count = readHandler.asyncGetLogRecordCount(DLSN.InitialDLSN);\n         try {\n-            Await.result(count);\n+            Utils.ioResult(count);\n             fail(\"log is empty, should have returned log empty ex\");\n         } catch (LogNotFoundException ex) {\n         }\n@@ -179,9 +180,9 @@ public void testGetLogRecordCountTotalCount() throws Exception {\n         prepareLogSegmentsNonPartitioned(dlName, 11, 3);\n         DistributedLogManager dlm = createNewDLM(conf, dlName);\n         BKLogReadHandler readHandler = ((BKDistributedLogManager) dlm).createReadHandler();\n-        Future<Long> count = null;\n+        CompletableFuture<Long> count = null;\n         count = readHandler.asyncGetLogRecordCount(DLSN.InitialDLSN);\n-        assertEquals(33, Await.result(count).longValue());\n+        assertEquals(33, Utils.ioResult(count).longValue());\n     }\n \n     @Test(timeout = 60000)\n@@ -190,11 +191,11 @@ public void testGetLogRecordCountAtLedgerBoundary() throws Exception {\n         prepareLogSegmentsNonPartitioned(dlName, 11, 3);\n         DistributedLogManager dlm = createNewDLM(conf, dlName);\n         BKLogReadHandler readHandler = ((BKDistributedLogManager) dlm).createReadHandler();\n-        Future<Long> count = null;\n+        CompletableFuture<Long> count = null;\n         count = readHandler.asyncGetLogRecordCount(new DLSN(2, 0, 0));\n-        assertEquals(30, Await.result(count).longValue());\n+        assertEquals(30, Utils.ioResult(count).longValue());\n         count = readHandler.asyncGetLogRecordCount(new DLSN(3, 0, 0));\n-        assertEquals(27, Await.result(count).longValue());\n+        assertEquals(27, Utils.ioResult(count).longValue());\n     }\n \n     @Test(timeout = 60000)\n@@ -203,9 +204,9 @@ public void testGetLogRecordCountPastEnd() throws Exception {\n         prepareLogSegmentsNonPartitioned(dlName, 11, 3);\n         DistributedLogManager dlm = createNewDLM(conf, dlName);\n         BKLogReadHandler readHandler = ((BKDistributedLogManager) dlm).createReadHandler();\n-        Future<Long> count = null;\n+        CompletableFuture<Long> count = null;\n         count = readHandler.asyncGetLogRecordCount(new DLSN(12, 0, 0));\n-        assertEquals(0, Await.result(count).longValue());\n+        assertEquals(0, Utils.ioResult(count).longValue());\n     }\n \n     @Test(timeout = 60000)\n@@ -214,9 +215,9 @@ public void testGetLogRecordCountLastRecord() throws Exception {\n         prepareLogSegmentsNonPartitioned(dlName, 11, 3);\n         DistributedLogManager dlm = createNewDLM(conf, dlName);\n         BKLogReadHandler readHandler = ((BKDistributedLogManager) dlm).createReadHandler();\n-        Future<Long> count = null;\n+        CompletableFuture<Long> count = null;\n         count = readHandler.asyncGetLogRecordCount(new DLSN(11, 2, 0));\n-        assertEquals(1, Await.result(count).longValue());\n+        assertEquals(1, Utils.ioResult(count).longValue());\n     }\n \n     @Test(timeout = 60000)\n@@ -225,11 +226,11 @@ public void testGetLogRecordCountInteriorRecords() throws Exception {\n         prepareLogSegmentsNonPartitioned(dlName, 5, 10);\n         DistributedLogManager dlm = createNewDLM(conf, dlName);\n         BKLogReadHandler readHandler = ((BKDistributedLogManager) dlm).createReadHandler();\n-        Future<Long> count = null;\n+        CompletableFuture<Long> count = null;\n         count = readHandler.asyncGetLogRecordCount(new DLSN(3, 5, 0));\n-        assertEquals(25, Await.result(count).longValue());\n+        assertEquals(25, Utils.ioResult(count).longValue());\n         count = readHandler.asyncGetLogRecordCount(new DLSN(2, 5, 0));\n-        assertEquals(35, Await.result(count).longValue());\n+        assertEquals(35, Utils.ioResult(count).longValue());\n     }\n \n     @Test(timeout = 60000)\n@@ -239,9 +240,9 @@ public void testGetLogRecordCountWithControlRecords() throws Exception {\n         txid += DLMTestUtil.generateLogSegmentNonPartitioned(dlm, 5, 5, txid);\n         txid += DLMTestUtil.generateLogSegmentNonPartitioned(dlm, 0, 10, txid);\n         BKLogReadHandler readHandler = ((BKDistributedLogManager) dlm).createReadHandler();\n-        Future<Long> count = null;\n+        CompletableFuture<Long> count = null;\n         count = readHandler.asyncGetLogRecordCount(new DLSN(1, 0, 0));\n-        assertEquals(15, Await.result(count).longValue());\n+        assertEquals(15, Utils.ioResult(count).longValue());\n     }\n \n     @Test(timeout = 60000)\n@@ -251,9 +252,9 @@ public void testGetLogRecordCountWithAllControlRecords() throws Exception {\n         txid += DLMTestUtil.generateLogSegmentNonPartitioned(dlm, 5, 0, txid);\n         txid += DLMTestUtil.generateLogSegmentNonPartitioned(dlm, 10, 0, txid);\n         BKLogReadHandler readHandler = ((BKDistributedLogManager) dlm).createReadHandler();\n-        Future<Long> count = null;\n+        CompletableFuture<Long> count = null;\n         count = readHandler.asyncGetLogRecordCount(new DLSN(1, 0, 0));\n-        assertEquals(0, Await.result(count).longValue());\n+        assertEquals(0, Utils.ioResult(count).longValue());\n     }\n \n     @Test(timeout = 60000)\n@@ -264,12 +265,12 @@ public void testGetLogRecordCountWithSingleInProgressLedger() throws Exception {\n         AsyncLogWriter out = bkdlm.startAsyncLogSegmentNonPartitioned();\n         int txid = 1;\n \n-        Await.result(out.write(DLMTestUtil.getLargeLogRecordInstance(txid++, false)));\n-        Await.result(out.write(DLMTestUtil.getLargeLogRecordInstance(txid++, false)));\n-        Await.result(out.write(DLMTestUtil.getLargeLogRecordInstance(txid++, false)));\n+        Utils.ioResult(out.write(DLMTestUtil.getLargeLogRecordInstance(txid++, false)));\n+        Utils.ioResult(out.write(DLMTestUtil.getLargeLogRecordInstance(txid++, false)));\n+        Utils.ioResult(out.write(DLMTestUtil.getLargeLogRecordInstance(txid++, false)));\n \n         BKLogReadHandler readHandler = bkdlm.createReadHandler();\n-        List<LogSegmentMetadata> ledgerList = FutureUtils.result(\n+        List<LogSegmentMetadata> ledgerList = Utils.ioResult(\n                 readHandler.readLogSegmentsFromStore(\n                         LogSegmentMetadata.COMPARATOR,\n                         LogSegmentFilter.DEFAULT_FILTER,\n@@ -279,9 +280,9 @@ public void testGetLogRecordCountWithSingleInProgressLedger() throws Exception {\n         assertEquals(1, ledgerList.size());\n         assertTrue(ledgerList.get(0).isInProgress());\n \n-        Future<Long> count = null;\n+        CompletableFuture<Long> count = null;\n         count = readHandler.asyncGetLogRecordCount(new DLSN(1, 0, 0));\n-        assertEquals(2, Await.result(count).longValue());\n+        assertEquals(2, Utils.ioResult(count).longValue());\n \n         Utils.close(out);\n     }\n@@ -294,12 +295,12 @@ public void testGetLogRecordCountWithCompletedAndInprogressLedgers() throws Exce\n         long txid = 1;\n         txid += DLMTestUtil.generateLogSegmentNonPartitioned(bkdlm, 0, 5, txid);\n         AsyncLogWriter out = bkdlm.startAsyncLogSegmentNonPartitioned();\n-        Await.result(out.write(DLMTestUtil.getLargeLogRecordInstance(txid++, false)));\n-        Await.result(out.write(DLMTestUtil.getLargeLogRecordInstance(txid++, false)));\n-        Await.result(out.write(DLMTestUtil.getLargeLogRecordInstance(txid++, false)));\n+        Utils.ioResult(out.write(DLMTestUtil.getLargeLogRecordInstance(txid++, false)));\n+        Utils.ioResult(out.write(DLMTestUtil.getLargeLogRecordInstance(txid++, false)));\n+        Utils.ioResult(out.write(DLMTestUtil.getLargeLogRecordInstance(txid++, false)));\n \n         BKLogReadHandler readHandler = bkdlm.createReadHandler();\n-        List<LogSegmentMetadata> ledgerList = FutureUtils.result(\n+        List<LogSegmentMetadata> ledgerList = Utils.ioResult(\n                 readHandler.readLogSegmentsFromStore(\n                         LogSegmentMetadata.COMPARATOR,\n                         LogSegmentFilter.DEFAULT_FILTER,\n@@ -309,9 +310,9 @@ public void testGetLogRecordCountWithCompletedAndInprogressLedgers() throws Exce\n         assertFalse(ledgerList.get(0).isInProgress());\n         assertTrue(ledgerList.get(1).isInProgress());\n \n-        Future<Long> count = null;\n+        CompletableFuture<Long> count = null;\n         count = readHandler.asyncGetLogRecordCount(new DLSN(1, 0, 0));\n-        assertEquals(7, Await.result(count).longValue());\n+        assertEquals(7, Utils.ioResult(count).longValue());\n \n         Utils.close(out);\n     }\n@@ -322,14 +323,14 @@ public void testLockStreamWithMissingLog() throws Exception {\n         BKDistributedLogManager bkdlm = (BKDistributedLogManager) createNewDLM(conf, streamName);\n         BKLogReadHandler readHandler = bkdlm.createReadHandler();\n         try {\n-            Await.result(readHandler.lockStream());\n+            Utils.ioResult(readHandler.lockStream());\n             fail(\"Should fail lock stream if log not found\");\n         } catch (LogNotFoundException ex) {\n         }\n \n         BKLogReadHandler subscriberReadHandler = bkdlm.createReadHandler(Optional.of(\"test-subscriber\"));\n         try {\n-            Await.result(subscriberReadHandler.lockStream());\n+            Utils.ioResult(subscriberReadHandler.lockStream());\n             fail(\"Subscriber should fail lock stream if log not found\");\n         } catch (LogNotFoundException ex) {\n             // expected\n@@ -342,17 +343,17 @@ public void testLockStreamDifferentSubscribers() throws Exception {\n         BKDistributedLogManager bkdlm = createNewDLM(conf, streamName);\n         DLMTestUtil.generateLogSegmentNonPartitioned(bkdlm, 0, 5, 1);\n         BKLogReadHandler readHandler = bkdlm.createReadHandler();\n-        Await.result(readHandler.lockStream());\n+        Utils.ioResult(readHandler.lockStream());\n \n         // two subscribers could lock stream in parallel\n         BKDistributedLogManager bkdlm10 = createNewDLM(conf, streamName);\n         BKLogReadHandler s10Handler =\n                 bkdlm10.createReadHandler(Optional.of(\"s1\"));\n-        Await.result(s10Handler.lockStream());\n+        Utils.ioResult(s10Handler.lockStream());\n         BKDistributedLogManager bkdlm20 = createNewDLM(conf, streamName);\n         BKLogReadHandler s20Handler =\n                 bkdlm20.createReadHandler(Optional.of(\"s2\"));\n-        Await.result(s20Handler.lockStream());\n+        Utils.ioResult(s20Handler.lockStream());\n \n         readHandler.asyncClose();\n         bkdlm.close();\n@@ -368,19 +369,19 @@ public void testLockStreamSameSubscriber() throws Exception {\n         BKDistributedLogManager bkdlm = createNewDLM(conf, streamName);\n         DLMTestUtil.generateLogSegmentNonPartitioned(bkdlm, 0, 5, 1);\n         BKLogReadHandler readHandler = bkdlm.createReadHandler();\n-        Await.result(readHandler.lockStream());\n+        Utils.ioResult(readHandler.lockStream());\n \n         // same subscrbiers couldn't lock stream in parallel\n         BKDistributedLogManager bkdlm10 = createNewDLM(conf, streamName);\n         BKLogReadHandler s10Handler =\n                 bkdlm10.createReadHandler(Optional.of(\"s1\"));\n-        Await.result(s10Handler.lockStream());\n+        Utils.ioResult(s10Handler.lockStream());\n \n         BKDistributedLogManager bkdlm11 = createNewDLM(conf, streamName);\n         BKLogReadHandler s11Handler =\n                 bkdlm11.createReadHandler(Optional.of(\"s1\"));\n         try {\n-            Await.result(s11Handler.lockStream(), Duration.apply(10000, TimeUnit.MILLISECONDS));\n+            Utils.ioResult(s11Handler.lockStream(), 10000, TimeUnit.MILLISECONDS);\n             fail(\"Should fail lock stream using same subscriber id\");\n         } catch (OwnershipAcquireFailedException oafe) {\n             // expected"},{"sha":"4ad0bc0584e41086bbac93e6b86067e6e9565604","filename":"src/test/java/org/apache/distributedlog/TestBKLogSegmentWriter.java","status":"modified","additions":47,"deletions":54,"changes":101,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FTestBKLogSegmentWriter.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FTestBKLogSegmentWriter.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FTestBKLogSegmentWriter.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -17,39 +17,36 @@\n  */\n package org.apache.distributedlog;\n \n+import java.util.concurrent.CompletableFuture;\n import org.apache.distributedlog.exceptions.BKTransmitException;\n import org.apache.distributedlog.exceptions.EndOfStreamException;\n import org.apache.distributedlog.exceptions.WriteCancelledException;\n import org.apache.distributedlog.exceptions.WriteException;\n+import org.apache.distributedlog.exceptions.ZKException;\n import org.apache.distributedlog.impl.BKNamespaceDriver;\n import org.apache.distributedlog.impl.logsegment.BKLogSegmentEntryWriter;\n-import org.apache.distributedlog.io.Abortables;\n import org.apache.distributedlog.lock.SessionLockFactory;\n import org.apache.distributedlog.lock.ZKDistributedLock;\n import org.apache.distributedlog.lock.ZKSessionLockFactory;\n import org.apache.distributedlog.impl.metadata.BKDLConfig;\n import org.apache.distributedlog.util.ConfUtils;\n-import org.apache.distributedlog.util.FutureUtils;\n+import org.apache.distributedlog.common.concurrent.FutureUtils;\n import org.apache.distributedlog.util.OrderedScheduler;\n-import org.apache.distributedlog.util.PermitLimiter;\n+import org.apache.distributedlog.common.util.PermitLimiter;\n import org.apache.distributedlog.util.Utils;\n-import com.twitter.util.Await;\n-import com.twitter.util.Future;\n import org.apache.bookkeeper.client.BKException;\n import org.apache.bookkeeper.client.BookKeeper;\n import org.apache.bookkeeper.client.LedgerHandle;\n import org.apache.bookkeeper.feature.SettableFeatureProvider;\n import org.apache.bookkeeper.stats.AlertStatsLogger;\n import org.apache.bookkeeper.stats.NullStatsLogger;\n import org.apache.zookeeper.CreateMode;\n-import org.apache.zookeeper.KeeperException;\n import org.apache.zookeeper.ZooDefs;\n import org.junit.After;\n import org.junit.Before;\n import org.junit.Rule;\n import org.junit.Test;\n import org.junit.rules.TestName;\n-import scala.runtime.AbstractFunction0;\n \n import java.io.IOException;\n import java.net.URI;\n@@ -129,9 +126,9 @@ private ZKDistributedLock createLock(String path,\n                                          boolean acquireLock)\n             throws Exception {\n         try {\n-            Await.result(Utils.zkAsyncCreateFullPathOptimistic(zkClient, path, new byte[0],\n+            Utils.ioResult(Utils.zkAsyncCreateFullPathOptimistic(zkClient, path, new byte[0],\n                     ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT));\n-        } catch (KeeperException.NodeExistsException nee) {\n+        } catch (ZKException zke) {\n             // node already exists\n         }\n         SessionLockFactory lockFactory = new ZKSessionLockFactory(\n@@ -150,17 +147,17 @@ private ZKDistributedLock createLock(String path,\n                 Long.MAX_VALUE,\n                 NullStatsLogger.INSTANCE);\n         if (acquireLock) {\n-            return FutureUtils.result(lock.asyncAcquire());\n+            return Utils.ioResult(lock.asyncAcquire());\n         } else {\n             return lock;\n         }\n     }\n \n     private void closeWriterAndLock(BKLogSegmentWriter writer,\n                                     ZKDistributedLock lock)\n-            throws IOException {\n+            throws Exception {\n         try {\n-            FutureUtils.result(writer.asyncClose());\n+            Utils.ioResult(writer.asyncClose());\n         } finally {\n             Utils.closeQuietly(lock);\n         }\n@@ -170,7 +167,7 @@ private void abortWriterAndLock(BKLogSegmentWriter writer,\n                                     ZKDistributedLock lock)\n             throws IOException {\n         try {\n-            Abortables.abort(writer, false);\n+            Utils.abort(writer, false);\n         } finally {\n             Utils.closeQuietly(lock);\n         }\n@@ -231,10 +228,10 @@ public void testCloseShouldFlush() throws Exception {\n                 createLogSegmentWriter(confLocal, 0L, -1L, lock);\n         // Use another lock to wait for writer releasing lock\n         ZKDistributedLock lock0 = createLock(\"/test/lock-\" + runtime.getMethodName(), zkc0, false);\n-        Future<ZKDistributedLock> lockFuture0 = lock0.asyncAcquire();\n+        CompletableFuture<ZKDistributedLock> lockFuture0 = lock0.asyncAcquire();\n         // add 10 records\n         int numRecords = 10;\n-        List<Future<DLSN>> futureList = new ArrayList<Future<DLSN>>(numRecords);\n+        List<CompletableFuture<DLSN>> futureList = new ArrayList<CompletableFuture<DLSN>>(numRecords);\n         for (int i = 0; i < numRecords; i++) {\n             futureList.add(writer.asyncWrite(DLMTestUtil.getLogRecordInstance(i)));\n         }\n@@ -248,15 +245,15 @@ public void testCloseShouldFlush() throws Exception {\n                 10, writer.getPositionWithinLogSegment());\n         // close the writer should flush buffered data and release lock\n         closeWriterAndLock(writer, lock);\n-        Await.result(lockFuture0);\n+        Utils.ioResult(lockFuture0);\n         lock0.checkOwnership();\n         assertEquals(\"Last tx id should still be \" + (numRecords - 1),\n                 numRecords - 1, writer.getLastTxId());\n         assertEquals(\"Last acked tx id should become \" + (numRecords - 1),\n                 numRecords - 1, writer.getLastTxIdAcknowledged());\n         assertEquals(\"Position should still be \" + numRecords,\n                 10, writer.getPositionWithinLogSegment());\n-        List<DLSN> dlsns = Await.result(Future.collect(futureList));\n+        List<DLSN> dlsns = Utils.ioResult(FutureUtils.collect(futureList));\n         assertEquals(\"All records should be written\",\n                 numRecords, dlsns.size());\n         for (int i = 0; i < numRecords; i++) {\n@@ -293,10 +290,10 @@ public void testAbortShouldNotFlush() throws Exception {\n                 createLogSegmentWriter(confLocal, 0L, -1L, lock);\n         // Use another lock to wait for writer releasing lock\n         ZKDistributedLock lock0 = createLock(\"/test/lock-\" + runtime.getMethodName(), zkc0, false);\n-        Future<ZKDistributedLock> lockFuture0 = lock0.asyncAcquire();\n+        CompletableFuture<ZKDistributedLock> lockFuture0 = lock0.asyncAcquire();\n         // add 10 records\n         int numRecords = 10;\n-        List<Future<DLSN>> futureList = new ArrayList<Future<DLSN>>(numRecords);\n+        List<CompletableFuture<DLSN>> futureList = new ArrayList<CompletableFuture<DLSN>>(numRecords);\n         for (int i = 0; i < numRecords; i++) {\n             futureList.add(writer.asyncWrite(DLMTestUtil.getLogRecordInstance(i)));\n         }\n@@ -310,7 +307,7 @@ public void testAbortShouldNotFlush() throws Exception {\n                 10, writer.getPositionWithinLogSegment());\n         // close the writer should flush buffered data and release lock\n         abortWriterAndLock(writer, lock);\n-        Await.result(lockFuture0);\n+        Utils.ioResult(lockFuture0);\n         lock0.checkOwnership();\n         assertEquals(\"Last tx id should still be \" + (numRecords - 1),\n                 numRecords - 1, writer.getLastTxId());\n@@ -323,7 +320,7 @@ public void testAbortShouldNotFlush() throws Exception {\n \n         for (int i = 0; i < numRecords; i++) {\n             try {\n-                Await.result(futureList.get(i));\n+                Utils.ioResult(futureList.get(i));\n                 fail(\"Should be aborted record \" + i + \" with transmit exception\");\n             } catch (WriteCancelledException wce) {\n                 assertTrue(\"Record \" + i + \" should be aborted because of ledger fenced\",\n@@ -369,10 +366,10 @@ void testCloseShouldNotFlushIfInErrorState(int rcToFailComplete) throws Exceptio\n                 createLogSegmentWriter(confLocal, 0L, -1L, lock);\n         // Use another lock to wait for writer releasing lock\n         ZKDistributedLock lock0 = createLock(\"/test/lock-\" + runtime.getMethodName(), zkc0, false);\n-        Future<ZKDistributedLock> lockFuture0 = lock0.asyncAcquire();\n+        CompletableFuture<ZKDistributedLock> lockFuture0 = lock0.asyncAcquire();\n         // add 10 records\n         int numRecords = 10;\n-        List<Future<DLSN>> futureList = new ArrayList<Future<DLSN>>(numRecords);\n+        List<CompletableFuture<DLSN>> futureList = new ArrayList<CompletableFuture<DLSN>>(numRecords);\n         for (int i = 0; i < numRecords; i++) {\n             futureList.add(writer.asyncWrite(DLMTestUtil.getLogRecordInstance(i)));\n         }\n@@ -393,7 +390,7 @@ void testCloseShouldNotFlushIfInErrorState(int rcToFailComplete) throws Exceptio\n             assertEquals(\"Inconsistent rc is thrown\",\n                     rcToFailComplete, bkte.getBKResultCode());\n         }\n-        Await.result(lockFuture0);\n+        Utils.ioResult(lockFuture0);\n         lock0.checkOwnership();\n         assertEquals(\"Last tx id should still be \" + (numRecords - 1),\n                 numRecords - 1, writer.getLastTxId());\n@@ -406,7 +403,7 @@ void testCloseShouldNotFlushIfInErrorState(int rcToFailComplete) throws Exceptio\n \n         for (int i = 0; i < numRecords; i++) {\n             try {\n-                Await.result(futureList.get(i));\n+                Utils.ioResult(futureList.get(i));\n                 fail(\"Should be aborted record \" + i + \" with transmit exception\");\n             } catch (WriteCancelledException wce) {\n                 assertTrue(\"Record \" + i + \" should be aborted because of ledger fenced\",\n@@ -441,10 +438,10 @@ public void testCloseShouldFailIfLedgerFenced() throws Exception {\n                 createLogSegmentWriter(confLocal, 0L, -1L, lock);\n         // Use another lock to wait for writer releasing lock\n         ZKDistributedLock lock0 = createLock(\"/test/lock-\" + runtime.getMethodName(), zkc0, false);\n-        Future<ZKDistributedLock> lockFuture0 = lock0.asyncAcquire();\n+        CompletableFuture<ZKDistributedLock> lockFuture0 = lock0.asyncAcquire();\n         // add 10 records\n         int numRecords = 10;\n-        List<Future<DLSN>> futureList = new ArrayList<Future<DLSN>>(numRecords);\n+        List<CompletableFuture<DLSN>> futureList = new ArrayList<CompletableFuture<DLSN>>(numRecords);\n         for (int i = 0; i < numRecords; i++) {\n             futureList.add(writer.asyncWrite(DLMTestUtil.getLogRecordInstance(i)));\n         }\n@@ -467,7 +464,7 @@ public void testCloseShouldFailIfLedgerFenced() throws Exception {\n                     BKException.Code.LedgerFencedException, bkte.getBKResultCode());\n         }\n \n-        Await.result(lockFuture0);\n+        Utils.ioResult(lockFuture0);\n         lock0.checkOwnership();\n \n         assertEquals(\"Last tx id should still be \" + (numRecords - 1),\n@@ -481,7 +478,7 @@ public void testCloseShouldFailIfLedgerFenced() throws Exception {\n \n         for (int i = 0; i < numRecords; i++) {\n             try {\n-                Await.result(futureList.get(i));\n+                Utils.ioResult(futureList.get(i));\n                 fail(\"Should be aborted record \" + i + \" with transmit exception\");\n             } catch (BKTransmitException bkte) {\n                 assertEquals(\"Record \" + i + \" should be aborted\",\n@@ -513,10 +510,10 @@ public void testAbortShouldFailAllWrites() throws Exception {\n                 createLogSegmentWriter(confLocal, 0L, -1L, lock);\n         // Use another lock to wait for writer releasing lock\n         ZKDistributedLock lock0 = createLock(\"/test/lock-\" + runtime.getMethodName(), zkc0, false);\n-        Future<ZKDistributedLock> lockFuture0 = lock0.asyncAcquire();\n+        CompletableFuture<ZKDistributedLock> lockFuture0 = lock0.asyncAcquire();\n         // add 10 records\n         int numRecords = 10;\n-        List<Future<DLSN>> futureList = new ArrayList<Future<DLSN>>(numRecords);\n+        List<CompletableFuture<DLSN>> futureList = new ArrayList<CompletableFuture<DLSN>>(numRecords);\n         for (int i = 0; i < numRecords; i++) {\n             futureList.add(writer.asyncWrite(DLMTestUtil.getLogRecordInstance(i)));\n         }\n@@ -530,23 +527,19 @@ public void testAbortShouldFailAllWrites() throws Exception {\n                 numRecords, writer.getPositionWithinLogSegment());\n \n         final CountDownLatch deferLatch = new CountDownLatch(1);\n-        writer.getFuturePool().apply(new AbstractFunction0<Object>() {\n-            @Override\n-            public Object apply() {\n-                try {\n-                    deferLatch.await();\n-                } catch (InterruptedException e) {\n-                    LOG.warn(\"Interrupted on deferring completion : \", e);\n-                }\n-                return null;\n+        writer.getFuturePool().submit(() -> {\n+            try {\n+                deferLatch.await();\n+            } catch (InterruptedException e) {\n+                LOG.warn(\"Interrupted on deferring completion : \", e);\n             }\n         });\n \n         // transmit the buffered data\n-        FutureUtils.result(writer.flush());\n+        Utils.ioResult(writer.flush());\n \n         // add another 10 records\n-        List<Future<DLSN>> anotherFutureList = new ArrayList<Future<DLSN>>(numRecords);\n+        List<CompletableFuture<DLSN>> anotherFutureList = new ArrayList<CompletableFuture<DLSN>>(numRecords);\n         for (int i = numRecords; i < 2 * numRecords; i++) {\n             anotherFutureList.add(writer.asyncWrite(DLMTestUtil.getLogRecordInstance(i)));\n         }\n@@ -562,13 +555,13 @@ public Object apply() {\n         // abort the writer: it waits for outstanding transmits and abort buffered data\n         abortWriterAndLock(writer, lock);\n \n-        Await.result(lockFuture0);\n+        Utils.ioResult(lockFuture0);\n         lock0.checkOwnership();\n \n         // release defer latch so completion would go through\n         deferLatch.countDown();\n \n-        List<DLSN> dlsns = Await.result(Future.collect(futureList));\n+        List<DLSN> dlsns = Utils.ioResult(FutureUtils.collect(futureList));\n         assertEquals(\"All first 10 records should be written\",\n                 numRecords, dlsns.size());\n         for (int i = 0; i < numRecords; i++) {\n@@ -582,7 +575,7 @@ public Object apply() {\n         }\n         for (int i = 0; i < numRecords; i++) {\n             try {\n-                Await.result(anotherFutureList.get(i));\n+                Utils.ioResult(anotherFutureList.get(i));\n                 fail(\"Should be aborted record \" + (numRecords + i) + \" with transmit exception\");\n             } catch (WriteCancelledException wce) {\n                 // writes should be cancelled.\n@@ -622,7 +615,7 @@ public void testUpdateLastTxIdForUserRecords() throws Exception {\n                 createLogSegmentWriter(confLocal, 0L, -1L, lock);\n         // add 10 records\n         int numRecords = 10;\n-        List<Future<DLSN>> futureList = new ArrayList<Future<DLSN>>(numRecords);\n+        List<CompletableFuture<DLSN>> futureList = new ArrayList<CompletableFuture<DLSN>>(numRecords);\n         for (int i = 0; i < numRecords; i++) {\n             futureList.add(writer.asyncWrite(DLMTestUtil.getLogRecordInstance(i)));\n         }\n@@ -639,7 +632,7 @@ public void testUpdateLastTxIdForUserRecords() throws Exception {\n         // close the writer to flush the output buffer\n         closeWriterAndLock(writer, lock);\n \n-        List<DLSN> dlsns = Await.result(Future.collect(futureList));\n+        List<DLSN> dlsns = Utils.ioResult(FutureUtils.collect(futureList));\n         assertEquals(\"All 11 records should be written\",\n                 numRecords + 1, dlsns.size());\n         for (int i = 0; i < numRecords; i++) {\n@@ -687,10 +680,10 @@ public void testNondurableWriteAfterWriterIsClosed() throws Exception {\n \n         // close the writer\n         closeWriterAndLock(writer, lock);\n-        FutureUtils.result(writer.asyncClose());\n+        Utils.ioResult(writer.asyncClose());\n \n         try {\n-            Await.result(writer.asyncWrite(DLMTestUtil.getLogRecordInstance(1)));\n+            Utils.ioResult(writer.asyncWrite(DLMTestUtil.getLogRecordInstance(1)));\n             fail(\"Should fail the write if the writer is closed\");\n         } catch (WriteException we) {\n             // expected\n@@ -713,10 +706,10 @@ public void testNondurableWriteAfterEndOfStream() throws Exception {\n         BKLogSegmentWriter writer =\n                 createLogSegmentWriter(confLocal, 0L, -1L, lock);\n \n-        FutureUtils.result(writer.markEndOfStream());\n+        Utils.ioResult(writer.markEndOfStream());\n \n         try {\n-            Await.result(writer.asyncWrite(DLMTestUtil.getLogRecordInstance(1)));\n+            Utils.ioResult(writer.asyncWrite(DLMTestUtil.getLogRecordInstance(1)));\n             fail(\"Should fail the write if the writer is marked as end of stream\");\n         } catch (EndOfStreamException we) {\n             // expected\n@@ -747,15 +740,15 @@ public void testNondurableWriteAfterLedgerIsFenced() throws Exception {\n         LogRecord record = DLMTestUtil.getLogRecordInstance(1);\n         record.setControl();\n         try {\n-            Await.result(writer.asyncWrite(record));\n+            Utils.ioResult(writer.asyncWrite(record));\n             fail(\"Should fail the writer if the log segment is already fenced\");\n         } catch (BKTransmitException bkte) {\n             // expected\n             assertEquals(BKException.Code.LedgerFencedException, bkte.getBKResultCode());\n         }\n \n         try {\n-            Await.result(writer.asyncWrite(DLMTestUtil.getLogRecordInstance(2)));\n+            Utils.ioResult(writer.asyncWrite(DLMTestUtil.getLogRecordInstance(2)));\n             fail(\"Should fail the writer if the log segment is already fenced\");\n         } catch (WriteException we) {\n             // expected\n@@ -781,7 +774,7 @@ public void testNondurableWrite() throws Exception {\n                 createLogSegmentWriter(confLocal, 0L, -1L, lock);\n \n         assertEquals(DLSN.InvalidDLSN,\n-                Await.result(writer.asyncWrite(DLMTestUtil.getLogRecordInstance(2))));\n+                Utils.ioResult(writer.asyncWrite(DLMTestUtil.getLogRecordInstance(2))));\n         assertEquals(-1L, ((BKLogSegmentEntryWriter) writer.getEntryWriter())\n                 .getLedgerHandle().getLastAddPushed());\n "},{"sha":"c0f208f00437cd2a1c78cc33216803f7e18bec8d","filename":"src/test/java/org/apache/distributedlog/TestBKLogWriteHandler.java","status":"modified","additions":7,"deletions":6,"changes":13,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FTestBKLogWriteHandler.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FTestBKLogWriteHandler.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FTestBKLogWriteHandler.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -17,12 +17,13 @@\n  */\n package org.apache.distributedlog;\n \n+import org.apache.distributedlog.api.AsyncLogWriter;\n+import org.apache.distributedlog.api.DistributedLogManager;\n import org.apache.distributedlog.bk.LedgerAllocator;\n import org.apache.distributedlog.bk.LedgerAllocatorPool;\n import org.apache.distributedlog.impl.BKNamespaceDriver;\n-import org.apache.distributedlog.namespace.DistributedLogNamespaceBuilder;\n+import org.apache.distributedlog.api.namespace.NamespaceBuilder;\n import org.apache.distributedlog.util.FailpointUtils;\n-import org.apache.distributedlog.util.FutureUtils;\n import org.apache.distributedlog.util.Utils;\n import org.junit.Rule;\n import org.junit.Test;\n@@ -58,16 +59,16 @@ public void testAbortTransactionOnStartLogSegment() throws Exception {\n         confLocal.setLedgerAllocatorPoolName(\"test-allocator-pool\");\n \n         BKDistributedLogNamespace namespace = (BKDistributedLogNamespace)\n-                DistributedLogNamespaceBuilder.newBuilder()\n+                NamespaceBuilder.newBuilder()\n                         .conf(confLocal)\n                         .uri(uri)\n                         .build();\n         DistributedLogManager dlm = namespace.openLog(\"test-stream\");\n         FailpointUtils.setFailpoint(FailpointUtils.FailPointName.FP_StartLogSegmentOnAssignLogSegmentSequenceNumber,\n                 FailpointUtils.FailPointActions.FailPointAction_Throw);\n         try {\n-            AsyncLogWriter writer =  FutureUtils.result(dlm.openAsyncLogWriter());\n-            FutureUtils.result(writer.write(DLMTestUtil.getLogRecordInstance(1L)));\n+            AsyncLogWriter writer =  Utils.ioResult(dlm.openAsyncLogWriter());\n+            Utils.ioResult(writer.write(DLMTestUtil.getLogRecordInstance(1L)));\n             fail(\"Should fail opening the writer\");\n         } catch (IOException ioe) {\n             // expected\n@@ -82,7 +83,7 @@ public void testAbortTransactionOnStartLogSegment() throws Exception {\n         LedgerAllocatorPool allocatorPool = (LedgerAllocatorPool) allocator;\n         assertEquals(0, allocatorPool.obtainMapSize());\n \n-        AsyncLogWriter writer = FutureUtils.result(dlm.openAsyncLogWriter());\n+        AsyncLogWriter writer = Utils.ioResult(dlm.openAsyncLogWriter());\n         writer.write(DLMTestUtil.getLogRecordInstance(1L));\n         Utils.close(writer);\n     }"},{"sha":"07f0db5632516aa940e1900933476c76659ba676","filename":"src/test/java/org/apache/distributedlog/TestBKSyncLogReader.java","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FTestBKSyncLogReader.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FTestBKSyncLogReader.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FTestBKSyncLogReader.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -17,6 +17,8 @@\n  */\n package org.apache.distributedlog;\n \n+import org.apache.distributedlog.api.DistributedLogManager;\n+import org.apache.distributedlog.api.LogReader;\n import org.apache.distributedlog.exceptions.LogNotFoundException;\n import org.junit.Rule;\n import org.junit.Test;"},{"sha":"5e4ba07b7c161d79975a6580ed65c93b6bc1e1ab","filename":"src/test/java/org/apache/distributedlog/TestDistributedLogBase.java","status":"modified","additions":13,"deletions":11,"changes":24,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FTestDistributedLogBase.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FTestDistributedLogBase.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FTestDistributedLogBase.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -21,6 +21,9 @@\n \n import com.google.common.base.Optional;\n import com.google.common.base.Ticker;\n+import java.util.concurrent.CompletableFuture;\n+import org.apache.distributedlog.api.LogReader;\n+import org.apache.distributedlog.api.namespace.Namespace;\n import org.apache.distributedlog.impl.BKNamespaceDriver;\n import org.apache.distributedlog.impl.logsegment.BKLogSegmentEntryWriter;\n import org.apache.distributedlog.injector.AsyncFailureInjector;\n@@ -29,14 +32,13 @@\n import org.apache.distributedlog.logsegment.LogSegmentEntryWriter;\n import org.apache.distributedlog.logsegment.LogSegmentMetadataCache;\n import org.apache.distributedlog.logsegment.LogSegmentMetadataStore;\n-import org.apache.distributedlog.namespace.DistributedLogNamespace;\n-import org.apache.distributedlog.namespace.DistributedLogNamespaceBuilder;\n+import org.apache.distributedlog.api.namespace.NamespaceBuilder;\n import org.apache.distributedlog.namespace.NamespaceDriver;\n import org.apache.distributedlog.util.ConfUtils;\n+import org.apache.distributedlog.common.concurrent.FutureUtils;\n import org.apache.distributedlog.util.OrderedScheduler;\n-import org.apache.distributedlog.util.PermitLimiter;\n-import org.apache.distributedlog.util.SchedulerUtils;\n-import com.twitter.util.Future;\n+import org.apache.distributedlog.common.util.PermitLimiter;\n+import org.apache.distributedlog.common.util.SchedulerUtils;\n import org.apache.bookkeeper.client.LedgerHandle;\n import org.apache.bookkeeper.feature.SettableFeatureProvider;\n import org.apache.bookkeeper.shims.zk.ZooKeeperServerShim;\n@@ -171,7 +173,7 @@ public BKDistributedLogManager createNewDLM(DistributedLogConfiguration conf,\n             throws Exception {\n         URI uri = createDLMURI(\"/\" + name);\n         ensureURICreated(uri);\n-        final DistributedLogNamespace namespace = DistributedLogNamespaceBuilder.newBuilder()\n+        final Namespace namespace = NamespaceBuilder.newBuilder()\n                 .uri(uri)\n                 .conf(conf)\n                 .build();\n@@ -181,14 +183,14 @@ public BKDistributedLogManager createNewDLM(DistributedLogConfiguration conf,\n                 .build();\n         AsyncCloseable resourcesCloseable = new AsyncCloseable() {\n             @Override\n-            public Future<Void> asyncClose() {\n+            public CompletableFuture<Void> asyncClose() {\n                 LOG.info(\"Shutting down the scheduler\");\n                 SchedulerUtils.shutdownScheduler(scheduler, 1, TimeUnit.SECONDS);\n                 LOG.info(\"Shut down the scheduler\");\n                 LOG.info(\"Closing the namespace\");\n                 namespace.close();\n                 LOG.info(\"Closed the namespace\");\n-                return Future.Void();\n+                return FutureUtils.Void();\n             }\n         };\n         AsyncFailureInjector failureInjector = AsyncRandomFailureInjector.newBuilder()\n@@ -217,20 +219,20 @@ public Future<Void> asyncClose() {\n                 Optional.of(resourcesCloseable));\n     }\n \n-    protected LogSegmentMetadataStore getLogSegmentMetadataStore(DistributedLogNamespace namespace)\n+    protected LogSegmentMetadataStore getLogSegmentMetadataStore(Namespace namespace)\n             throws IOException {\n         return namespace.getNamespaceDriver().getLogStreamMetadataStore(NamespaceDriver.Role.READER)\n                 .getLogSegmentMetadataStore();\n     }\n \n-    protected ZooKeeperClient getZooKeeperClient(DistributedLogNamespace namespace) throws Exception {\n+    protected ZooKeeperClient getZooKeeperClient(Namespace namespace) throws Exception {\n         NamespaceDriver driver = namespace.getNamespaceDriver();\n         assertTrue(driver instanceof BKNamespaceDriver);\n         return ((BKNamespaceDriver) driver).getWriterZKC();\n     }\n \n     @SuppressWarnings(\"deprecation\")\n-    protected BookKeeperClient getBookKeeperClient(DistributedLogNamespace namespace) throws Exception {\n+    protected BookKeeperClient getBookKeeperClient(Namespace namespace) throws Exception {\n         NamespaceDriver driver = namespace.getNamespaceDriver();\n         assertTrue(driver instanceof BKNamespaceDriver);\n         return ((BKNamespaceDriver) driver).getReaderBKC();"},{"sha":"30ef4816ecf461e0679e82df6a42445da37054b7","filename":"src/test/java/org/apache/distributedlog/TestEntry.java","status":"modified","additions":19,"deletions":21,"changes":40,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FTestEntry.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FTestEntry.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FTestEntry.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -17,19 +17,17 @@\n  */\n package org.apache.distributedlog;\n \n-import com.google.common.base.Optional;\n import com.google.common.collect.Lists;\n+import java.util.concurrent.CompletableFuture;\n import org.apache.distributedlog.Entry.Reader;\n import org.apache.distributedlog.Entry.Writer;\n import org.apache.distributedlog.exceptions.LogRecordTooLongException;\n import org.apache.distributedlog.io.Buffer;\n import org.apache.distributedlog.io.CompressionCodec;\n-import com.twitter.io.Buf;\n-import com.twitter.util.Await;\n-import com.twitter.util.Future;\n-import com.twitter.util.FutureEventListener;\n-import com.twitter.util.Promise;\n import org.apache.bookkeeper.stats.NullStatsLogger;\n+import org.apache.distributedlog.common.concurrent.FutureEventListener;\n+import org.apache.distributedlog.common.concurrent.FutureUtils;\n+import org.apache.distributedlog.util.Utils;\n import org.junit.Assert;\n import org.junit.Test;\n \n@@ -80,7 +78,7 @@ public void testWriteTooLongRecord() throws Exception {\n \n         LogRecord largeRecord = new LogRecord(1L, new byte[MAX_LOGRECORD_SIZE + 1]);\n         try {\n-            writer.writeRecord(largeRecord, new Promise<DLSN>());\n+            writer.writeRecord(largeRecord, new CompletableFuture<DLSN>());\n             Assert.fail(\"Should fail on writing large record\");\n         } catch (LogRecordTooLongException lrtle) {\n             // expected\n@@ -103,12 +101,12 @@ public void testWriteRecords() throws Exception {\n         assertEquals(\"zero bytes\", 0, writer.getNumBytes());\n         assertEquals(\"zero records\", 0, writer.getNumRecords());\n \n-        List<Future<DLSN>> writePromiseList = Lists.newArrayList();\n+        List<CompletableFuture<DLSN>> writePromiseList = Lists.newArrayList();\n         // write first 5 records\n         for (int i = 0; i < 5; i++) {\n             LogRecord record = new LogRecord(i, (\"record-\" + i).getBytes(UTF_8));\n             record.setPositionWithinLogSegment(i);\n-            Promise<DLSN> writePromise = new Promise<DLSN>();\n+            CompletableFuture<DLSN> writePromise = new CompletableFuture<DLSN>();\n             writer.writeRecord(record, writePromise);\n             writePromiseList.add(writePromise);\n             assertEquals((i + 1) + \" records\", (i + 1), writer.getNumRecords());\n@@ -117,7 +115,7 @@ public void testWriteRecords() throws Exception {\n         // write large record\n         LogRecord largeRecord = new LogRecord(1L, new byte[MAX_LOGRECORD_SIZE + 1]);\n         try {\n-            writer.writeRecord(largeRecord, new Promise<DLSN>());\n+            writer.writeRecord(largeRecord, new CompletableFuture<DLSN>());\n             Assert.fail(\"Should fail on writing large record\");\n         } catch (LogRecordTooLongException lrtle) {\n             // expected\n@@ -128,7 +126,7 @@ public void testWriteRecords() throws Exception {\n         for (int i = 0; i < 5; i++) {\n             LogRecord record = new LogRecord(i + 5, (\"record-\" + (i + 5)).getBytes(UTF_8));\n             record.setPositionWithinLogSegment(i + 5);\n-            Promise<DLSN> writePromise = new Promise<DLSN>();\n+            CompletableFuture<DLSN> writePromise = new CompletableFuture<DLSN>();\n             writer.writeRecord(record, writePromise);\n             writePromiseList.add(writePromise);\n             assertEquals((i + 6) + \" records\", (i + 6), writer.getNumRecords());\n@@ -138,7 +136,7 @@ public void testWriteRecords() throws Exception {\n \n         // Test transmit complete\n         writer.completeTransmit(1L, 1L);\n-        List<DLSN> writeResults = Await.result(Future.collect(writePromiseList));\n+        List<DLSN> writeResults = Utils.ioResult(FutureUtils.collect(writePromiseList));\n         for (int i = 0; i < 10; i++) {\n             Assert.assertEquals(new DLSN(1L, 1L, i), writeResults.get(i));\n         }\n@@ -175,23 +173,23 @@ public void testWriteRecordSet() throws Exception {\n         assertEquals(\"zero bytes\", 0, writer.getNumBytes());\n         assertEquals(\"zero records\", 0, writer.getNumRecords());\n \n-        List<Future<DLSN>> writePromiseList = Lists.newArrayList();\n+        List<CompletableFuture<DLSN>> writePromiseList = Lists.newArrayList();\n         // write first 5 records\n         for (int i = 0; i < 5; i++) {\n             LogRecord record = new LogRecord(i, (\"record-\" + i).getBytes(UTF_8));\n             record.setPositionWithinLogSegment(i);\n-            Promise<DLSN> writePromise = new Promise<DLSN>();\n+            CompletableFuture<DLSN> writePromise = new CompletableFuture<DLSN>();\n             writer.writeRecord(record, writePromise);\n             writePromiseList.add(writePromise);\n             assertEquals((i + 1) + \" records\", (i + 1), writer.getNumRecords());\n         }\n \n         final LogRecordSet.Writer recordSetWriter = LogRecordSet.newWriter(1024, CompressionCodec.Type.NONE);\n-        List<Future<DLSN>> recordSetPromiseList = Lists.newArrayList();\n+        List<CompletableFuture<DLSN>> recordSetPromiseList = Lists.newArrayList();\n         // write another 5 records as a batch\n         for (int i = 0; i < 5; i++) {\n             ByteBuffer record = ByteBuffer.wrap((\"record-\" + (i + 5)).getBytes(UTF_8));\n-            Promise<DLSN> writePromise = new Promise<DLSN>();\n+            CompletableFuture<DLSN> writePromise = new CompletableFuture<DLSN>();\n             recordSetWriter.writeRecord(record, writePromise);\n             recordSetPromiseList.add(writePromise);\n             assertEquals((i + 1) + \" records\", (i + 1), recordSetWriter.getNumRecords());\n@@ -202,8 +200,8 @@ public void testWriteRecordSet() throws Exception {\n         LogRecord setRecord = new LogRecord(5L, data);\n         setRecord.setPositionWithinLogSegment(5);\n         setRecord.setRecordSet();\n-        Promise<DLSN> writePromise = new Promise<DLSN>();\n-        writePromise.addEventListener(new FutureEventListener<DLSN>() {\n+        CompletableFuture<DLSN> writePromise = new CompletableFuture<DLSN>();\n+        writePromise.whenComplete(new FutureEventListener<DLSN>() {\n             @Override\n             public void onSuccess(DLSN dlsn) {\n                 recordSetWriter.completeTransmit(\n@@ -224,7 +222,7 @@ public void onFailure(Throwable cause) {\n         for (int i = 0; i < 5; i++) {\n             LogRecord record = new LogRecord(i + 10, (\"record-\" + (i + 10)).getBytes(UTF_8));\n             record.setPositionWithinLogSegment(i + 10);\n-            writePromise = new Promise<DLSN>();\n+            writePromise = new CompletableFuture<DLSN>();\n             writer.writeRecord(record, writePromise);\n             writePromiseList.add(writePromise);\n             assertEquals((i + 11) + \" records\", (i + 11), writer.getNumRecords());\n@@ -234,15 +232,15 @@ public void onFailure(Throwable cause) {\n \n         // Test transmit complete\n         writer.completeTransmit(1L, 1L);\n-        List<DLSN> writeResults = Await.result(Future.collect(writePromiseList));\n+        List<DLSN> writeResults = Utils.ioResult(FutureUtils.collect(writePromiseList));\n         for (int i = 0; i < 5; i++) {\n             Assert.assertEquals(new DLSN(1L, 1L, i), writeResults.get(i));\n         }\n         Assert.assertEquals(new DLSN(1L, 1L, 5), writeResults.get(5));\n         for (int i = 0; i < 5; i++) {\n             Assert.assertEquals(new DLSN(1L, 1L, (10 + i)), writeResults.get(6 + i));\n         }\n-        List<DLSN> recordSetWriteResults = Await.result(Future.collect(recordSetPromiseList));\n+        List<DLSN> recordSetWriteResults = Utils.ioResult(FutureUtils.collect(recordSetPromiseList));\n         for (int i = 0; i < 5; i++) {\n             Assert.assertEquals(new DLSN(1L, 1L, (5 + i)), recordSetWriteResults.get(i));\n         }"},{"sha":"c111baff7ca6a5a29ea0c5922667bbcbcbaa26f6","filename":"src/test/java/org/apache/distributedlog/TestInterleavedReaders.java","status":"modified","additions":27,"deletions":25,"changes":52,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FTestInterleavedReaders.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FTestInterleavedReaders.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FTestInterleavedReaders.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -17,7 +17,9 @@\n  */\n package org.apache.distributedlog;\n \n-import org.apache.distributedlog.util.FutureUtils;\n+import org.apache.distributedlog.api.DistributedLogManager;\n+import org.apache.distributedlog.api.LogReader;\n+import org.apache.distributedlog.util.Utils;\n import org.junit.Test;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -81,11 +83,11 @@ public void testInterleavedReaders() throws Exception {\n         BKAsyncLogWriter writer1 = dlmwrite1.startAsyncLogSegmentNonPartitioned();\n         for (long j = 1; j <= 4; j++) {\n             for (int k = 1; k <= 10; k++) {\n-                FutureUtils.result(writer1.write(DLMTestUtil.getLogRecordInstance(txid++)));\n-                FutureUtils.result(writer0.write(DLMTestUtil.getLogRecordInstance(txid++)));\n+                Utils.ioResult(writer1.write(DLMTestUtil.getLogRecordInstance(txid++)));\n+                Utils.ioResult(writer0.write(DLMTestUtil.getLogRecordInstance(txid++)));\n             }\n-            FutureUtils.result(writer1.writeControlRecord(DLMTestUtil.getLogRecordInstance(txid-1)));\n-            FutureUtils.result(writer0.writeControlRecord(DLMTestUtil.getLogRecordInstance(txid-1)));\n+            Utils.ioResult(writer1.writeControlRecord(DLMTestUtil.getLogRecordInstance(txid-1)));\n+            Utils.ioResult(writer0.writeControlRecord(DLMTestUtil.getLogRecordInstance(txid-1)));\n             if (null == reader0) {\n                 reader0 = dlmreader0.getInputStream(1);\n             }\n@@ -124,13 +126,13 @@ public void testInterleavedReadersWithRollingEdge() throws Exception {\n                 writer1.setForceRolling(true);\n             }\n             for (int k = 1; k <= 2; k++) {\n-                FutureUtils.result(writer1.write(DLMTestUtil.getLogRecordInstance(txid++)));\n-                FutureUtils.result(writer0.write(DLMTestUtil.getLogRecordInstance(txid++)));\n+                Utils.ioResult(writer1.write(DLMTestUtil.getLogRecordInstance(txid++)));\n+                Utils.ioResult(writer0.write(DLMTestUtil.getLogRecordInstance(txid++)));\n                 writer0.setForceRolling(false);\n                 writer1.setForceRolling(false);\n             }\n-            FutureUtils.result(writer1.writeControlRecord(DLMTestUtil.getLogRecordInstance(txid-1)));\n-            FutureUtils.result(writer0.writeControlRecord(DLMTestUtil.getLogRecordInstance(txid-1)));\n+            Utils.ioResult(writer1.writeControlRecord(DLMTestUtil.getLogRecordInstance(txid-1)));\n+            Utils.ioResult(writer0.writeControlRecord(DLMTestUtil.getLogRecordInstance(txid-1)));\n             LOG.info(\"Completed {} write\", j);\n             if (null == reader0) {\n                 reader0 = dlmreader0.getInputStream(1);\n@@ -170,13 +172,13 @@ public void testInterleavedReadersWithRolling() throws Exception {\n                     writer0.setForceRolling(true);\n                     writer1.setForceRolling(true);\n                 }\n-                FutureUtils.result(writer1.write(DLMTestUtil.getLogRecordInstance(txid++)));\n-                FutureUtils.result(writer0.write(DLMTestUtil.getLogRecordInstance(txid++)));\n+                Utils.ioResult(writer1.write(DLMTestUtil.getLogRecordInstance(txid++)));\n+                Utils.ioResult(writer0.write(DLMTestUtil.getLogRecordInstance(txid++)));\n                 writer0.setForceRolling(false);\n                 writer1.setForceRolling(false);\n             }\n-            FutureUtils.result(writer1.writeControlRecord(DLMTestUtil.getLogRecordInstance(txid-1)));\n-            FutureUtils.result(writer0.writeControlRecord(DLMTestUtil.getLogRecordInstance(txid-1)));\n+            Utils.ioResult(writer1.writeControlRecord(DLMTestUtil.getLogRecordInstance(txid-1)));\n+            Utils.ioResult(writer0.writeControlRecord(DLMTestUtil.getLogRecordInstance(txid-1)));\n             if (null == reader0) {\n                 reader0 = dlmreader0.getInputStream(1);\n             }\n@@ -212,9 +214,9 @@ public void testInterleavedReadersWithCleanup() throws Exception {\n                     writer1.setForceRolling(true);\n                     writer1.overRideMinTimeStampToKeep(retentionPeriodOverride);\n                 }\n-                DLSN dlsn1 = FutureUtils.result(writer1.write(DLMTestUtil.getLogRecordInstance(txid++)));\n+                DLSN dlsn1 = Utils.ioResult(writer1.write(DLMTestUtil.getLogRecordInstance(txid++)));\n                 LOG.info(\"writer1 write record {}\", dlsn1);\n-                DLSN dlsn0 = FutureUtils.result(writer0.write(DLMTestUtil.getLogRecordInstance(txid++)));\n+                DLSN dlsn0 = Utils.ioResult(writer0.write(DLMTestUtil.getLogRecordInstance(txid++)));\n                 LOG.info(\"writer0 write record {}\", dlsn0);\n                 if (k == 5) {\n                     writer0.setForceRolling(false);\n@@ -223,8 +225,8 @@ public void testInterleavedReadersWithCleanup() throws Exception {\n                 }\n                 Thread.sleep(5);\n             }\n-            FutureUtils.result(writer1.writeControlRecord(DLMTestUtil.getLogRecordInstance(txid-1)));\n-            FutureUtils.result(writer0.writeControlRecord(DLMTestUtil.getLogRecordInstance(txid-1)));\n+            Utils.ioResult(writer1.writeControlRecord(DLMTestUtil.getLogRecordInstance(txid-1)));\n+            Utils.ioResult(writer0.writeControlRecord(DLMTestUtil.getLogRecordInstance(txid-1)));\n         }\n         writer0.close();\n         writer1.close();\n@@ -264,15 +266,15 @@ public void testInterleavedReadersWithRecovery() throws Exception {\n                     writer0.setForceRecovery(true);\n                     writer1.setForceRecovery(true);\n                 }\n-                DLSN dlsn1 = FutureUtils.result(writer1.write(DLMTestUtil.getLogRecordInstance(txid++)));\n+                DLSN dlsn1 = Utils.ioResult(writer1.write(DLMTestUtil.getLogRecordInstance(txid++)));\n                 LOG.info(\"writer1 write record {} - txid = {}\", dlsn1, txid-1);\n-                DLSN dlsn0 = FutureUtils.result(writer0.write(DLMTestUtil.getLogRecordInstance(txid++)));\n+                DLSN dlsn0 = Utils.ioResult(writer0.write(DLMTestUtil.getLogRecordInstance(txid++)));\n                 LOG.info(\"writer0 write record {} - txid = {}\", dlsn0, txid-1);\n                 writer0.setForceRecovery(false);\n                 writer1.setForceRecovery(false);\n             }\n-            FutureUtils.result(writer1.writeControlRecord(DLMTestUtil.getLogRecordInstance(txid-1)));\n-            FutureUtils.result(writer0.writeControlRecord(DLMTestUtil.getLogRecordInstance(txid-1)));\n+            Utils.ioResult(writer1.writeControlRecord(DLMTestUtil.getLogRecordInstance(txid-1)));\n+            Utils.ioResult(writer0.writeControlRecord(DLMTestUtil.getLogRecordInstance(txid-1)));\n             if (null == reader0) {\n                 reader0 = dlmreader0.getInputStream(1);\n             }\n@@ -313,13 +315,13 @@ public void testInterleavedReadersWithRollingEdgeUnPartitioned() throws Exceptio\n                 writer1.setForceRolling(true);\n             }\n             for (int k = 1; k <= 2; k++) {\n-                FutureUtils.result(writer1.write(DLMTestUtil.getLogRecordInstance(txid++)));\n-                FutureUtils.result(writer0.write(DLMTestUtil.getLogRecordInstance(txid++)));\n+                Utils.ioResult(writer1.write(DLMTestUtil.getLogRecordInstance(txid++)));\n+                Utils.ioResult(writer0.write(DLMTestUtil.getLogRecordInstance(txid++)));\n                 writer0.setForceRolling(false);\n                 writer1.setForceRolling(false);\n             }\n-            FutureUtils.result(writer1.writeControlRecord(DLMTestUtil.getLogRecordInstance(txid-1)));\n-            FutureUtils.result(writer0.writeControlRecord(DLMTestUtil.getLogRecordInstance(txid-1)));\n+            Utils.ioResult(writer1.writeControlRecord(DLMTestUtil.getLogRecordInstance(txid-1)));\n+            Utils.ioResult(writer0.writeControlRecord(DLMTestUtil.getLogRecordInstance(txid-1)));\n             if (null == reader0) {\n                 reader0 = dlmreader0.getInputStream(1);\n             }"},{"sha":"8bdf86d925c163c608b9135433ad0f64b5e61405","filename":"src/test/java/org/apache/distributedlog/TestLogSegmentCreation.java","status":"modified","additions":6,"deletions":5,"changes":11,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FTestLogSegmentCreation.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FTestLogSegmentCreation.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FTestLogSegmentCreation.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -20,9 +20,10 @@\n import java.net.URI;\n import java.util.List;\n \n-import org.apache.distributedlog.namespace.DistributedLogNamespace;\n-import org.apache.distributedlog.namespace.DistributedLogNamespaceBuilder;\n-import com.twitter.util.Await;\n+import org.apache.distributedlog.api.DistributedLogManager;\n+import org.apache.distributedlog.api.namespace.Namespace;\n+import org.apache.distributedlog.api.namespace.NamespaceBuilder;\n+import org.apache.distributedlog.util.Utils;\n import org.junit.Test;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -43,7 +44,7 @@ public void testCreateLogSegmentAfterLoseLock() throws Exception {\n                 .setImmediateFlushEnabled(true)\n                 .setEnableLedgerAllocatorPool(true)\n                 .setLedgerAllocatorPoolName(\"test\");\n-        DistributedLogNamespace namespace = DistributedLogNamespaceBuilder.newBuilder()\n+        Namespace namespace = NamespaceBuilder.newBuilder()\n                 .conf(conf).uri(uri).build();\n         DistributedLogManager dlm = namespace.openLog(name);\n         final int numSegments = 3;\n@@ -68,7 +69,7 @@ public void testCreateLogSegmentAfterLoseLock() throws Exception {\n         writer2.closeAndComplete();\n \n         try {\n-            Await.result(writer1.write(DLMTestUtil.getLogRecordInstance(numSegments + 1)));\n+            Utils.ioResult(writer1.write(DLMTestUtil.getLogRecordInstance(numSegments + 1)));\n             fail(\"Should fail on writing new log records.\");\n         } catch (Throwable t) {\n             LOG.error(\"Failed to write entry : \", t);"},{"sha":"39ffe85756278637b60526ec6857cbb880560d9d","filename":"src/test/java/org/apache/distributedlog/TestLogSegmentMetadata.java","status":"modified","additions":4,"deletions":5,"changes":9,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FTestLogSegmentMetadata.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FTestLogSegmentMetadata.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FTestLogSegmentMetadata.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -21,8 +21,7 @@\n import org.apache.distributedlog.LogSegmentMetadata.LogSegmentMetadataVersion;\n import org.apache.distributedlog.LogSegmentMetadata.TruncationStatus;\n import org.apache.distributedlog.exceptions.UnsupportedMetadataVersionException;\n-\n-import org.apache.distributedlog.util.FutureUtils;\n+import org.apache.distributedlog.util.Utils;\n import org.junit.After;\n import org.junit.Before;\n import org.junit.Test;\n@@ -64,7 +63,7 @@ public void testReadMetadata() throws Exception {\n         LogSegmentMetadata metadata1 = new LogSegmentMetadataBuilder(\"/metadata1\",\n             LogSegmentMetadata.LEDGER_METADATA_CURRENT_LAYOUT_VERSION, 1000, 1).setRegionId(TEST_REGION_ID).build();\n         metadata1.write(zkc);\n-        LogSegmentMetadata read1 = FutureUtils.result(LogSegmentMetadata.read(zkc, \"/metadata1\"));\n+        LogSegmentMetadata read1 = Utils.ioResult(LogSegmentMetadata.read(zkc, \"/metadata1\"));\n         assertEquals(metadata1, read1);\n         assertEquals(TEST_REGION_ID, read1.getRegionId());\n     }\n@@ -75,7 +74,7 @@ public void testReadMetadataCrossVersion() throws Exception {\n             1, 1000, 1).setRegionId(TEST_REGION_ID).build();\n         metadata1.write(zkc);\n         // synchronous read\n-        LogSegmentMetadata read1 = FutureUtils.result(LogSegmentMetadata.read(zkc, \"/metadata2\", true));\n+        LogSegmentMetadata read1 = Utils.ioResult(LogSegmentMetadata.read(zkc, \"/metadata2\", true));\n         assertEquals(read1.getLogSegmentId(), metadata1.getLogSegmentId());\n         assertEquals(read1.getFirstTxId(), metadata1.getFirstTxId());\n         assertEquals(read1.getLastTxId(), metadata1.getLastTxId());\n@@ -90,7 +89,7 @@ public void testReadMetadataCrossVersionFailure() throws Exception {\n         metadata1.write(zkc);\n         // synchronous read\n         try {\n-            LogSegmentMetadata read1 = FutureUtils.result(LogSegmentMetadata.read(zkc, \"/metadata-failure\"));\n+            LogSegmentMetadata read1 = Utils.ioResult(LogSegmentMetadata.read(zkc, \"/metadata-failure\"));\n             fail(\"The previous statement should throw an exception\");\n         } catch (UnsupportedMetadataVersionException e) {\n             // Expected"},{"sha":"fcc3395a62f84cf74ebe213dbf8cf30d69dbeac5","filename":"src/test/java/org/apache/distributedlog/TestLogSegmentsZK.java","status":"modified","additions":7,"deletions":6,"changes":13,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FTestLogSegmentsZK.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FTestLogSegmentsZK.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FTestLogSegmentsZK.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -17,11 +17,12 @@\n  */\n package org.apache.distributedlog;\n \n+import org.apache.distributedlog.api.DistributedLogManager;\n+import org.apache.distributedlog.api.namespace.Namespace;\n import org.apache.distributedlog.exceptions.DLIllegalStateException;\n import org.apache.distributedlog.exceptions.UnexpectedException;\n import org.apache.distributedlog.metadata.LogMetadata;\n-import org.apache.distributedlog.namespace.DistributedLogNamespace;\n-import org.apache.distributedlog.namespace.DistributedLogNamespaceBuilder;\n+import org.apache.distributedlog.api.namespace.NamespaceBuilder;\n import org.apache.distributedlog.util.DLUtils;\n import org.apache.bookkeeper.meta.ZkVersion;\n import org.apache.bookkeeper.versioning.Versioned;\n@@ -80,7 +81,7 @@ public void testCreateLogSegmentOnPrecreatedStream() throws Exception {\n                 .setImmediateFlushEnabled(true)\n                 .setEnableLedgerAllocatorPool(true)\n                 .setLedgerAllocatorPoolName(\"test\");\n-        DistributedLogNamespace namespace = DistributedLogNamespaceBuilder.newBuilder().conf(conf).uri(uri).build();\n+        Namespace namespace = NamespaceBuilder.newBuilder().conf(conf).uri(uri).build();\n \n         namespace.createLog(streamName);\n         MaxLogSegmentSequenceNo max1 = getMaxLogSegmentSequenceNo(getZooKeeperClient(namespace), uri, streamName, conf);\n@@ -111,7 +112,7 @@ public void testCreateLogSegmentMissingMaxSequenceNumber() throws Exception {\n                 .setImmediateFlushEnabled(true)\n                 .setEnableLedgerAllocatorPool(true)\n                 .setLedgerAllocatorPoolName(\"test\");\n-        DistributedLogNamespace namespace = DistributedLogNamespaceBuilder.newBuilder().conf(conf).uri(uri).build();\n+        Namespace namespace = NamespaceBuilder.newBuilder().conf(conf).uri(uri).build();\n \n         namespace.createLog(streamName);\n         MaxLogSegmentSequenceNo max1 = getMaxLogSegmentSequenceNo(getZooKeeperClient(namespace), uri, streamName, conf);\n@@ -167,7 +168,7 @@ public void testCreateLogSegmentUnmatchMaxSequenceNumber() throws Exception {\n                 .setImmediateFlushEnabled(true)\n                 .setEnableLedgerAllocatorPool(true)\n                 .setLedgerAllocatorPoolName(\"test\");\n-        DistributedLogNamespace namespace = DistributedLogNamespaceBuilder.newBuilder().conf(conf).uri(uri).build();\n+        Namespace namespace = NamespaceBuilder.newBuilder().conf(conf).uri(uri).build();\n \n         namespace.createLog(streamName);\n         MaxLogSegmentSequenceNo max1 = getMaxLogSegmentSequenceNo(getZooKeeperClient(namespace), uri, streamName, conf);\n@@ -223,7 +224,7 @@ public void testCompleteLogSegmentConflicts() throws Exception {\n                 .setImmediateFlushEnabled(true)\n                 .setEnableLedgerAllocatorPool(true)\n                 .setLedgerAllocatorPoolName(\"test\");\n-        DistributedLogNamespace namespace = DistributedLogNamespaceBuilder.newBuilder().conf(conf).uri(uri).build();\n+        Namespace namespace = NamespaceBuilder.newBuilder().conf(conf).uri(uri).build();\n \n         namespace.createLog(streamName);\n         DistributedLogManager dlm1 = namespace.openLog(streamName);"},{"sha":"2b02704e074ea39275e667263eee0a5647cd9625","filename":"src/test/java/org/apache/distributedlog/TestNonBlockingReads.java","status":"modified","additions":7,"deletions":5,"changes":12,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FTestNonBlockingReads.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FTestNonBlockingReads.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FTestNonBlockingReads.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -21,9 +21,11 @@\n import java.util.concurrent.ScheduledThreadPoolExecutor;\n import java.util.concurrent.TimeUnit;\n \n-import org.apache.distributedlog.annotations.DistributedLogAnnotations;\n+import org.apache.distributedlog.api.DistributedLogManager;\n+import org.apache.distributedlog.api.LogReader;\n+import org.apache.distributedlog.common.annotations.DistributedLogAnnotations;\n import org.apache.distributedlog.exceptions.IdleReaderException;\n-import org.apache.distributedlog.util.FutureUtils;\n+import org.apache.distributedlog.util.Utils;\n import org.junit.Assert;\n import org.junit.Ignore;\n import org.junit.Test;\n@@ -229,15 +231,15 @@ private long createStreamWithInconsistentMetadata(String name) throws Exception\n             BKAsyncLogWriter out = (BKAsyncLogWriter) dlm.startAsyncLogSegmentNonPartitioned();\n             for (long j = 1; j <= segmentSize; j++) {\n                 LogRecord op = DLMTestUtil.getLogRecordInstance(txid++);\n-                FutureUtils.result(out.write(op));\n+                Utils.ioResult(out.write(op));\n                 numRecordsWritten++;\n             }\n             out.closeAndComplete();\n         }\n \n         BKLogWriteHandler blplm = ((BKDistributedLogManager) (dlm)).createWriteHandler(true);\n         String completedZNode = blplm.completedLedgerZNode(txid - segmentSize, txid - 1, 3);\n-        LogSegmentMetadata metadata = FutureUtils.result(LogSegmentMetadata.read(zkClient, completedZNode));\n+        LogSegmentMetadata metadata = Utils.ioResult(LogSegmentMetadata.read(zkClient, completedZNode));\n         zkClient.get().delete(completedZNode, -1);\n         LogSegmentMetadata metadataToChange =\n                 metadata.mutator()\n@@ -253,7 +255,7 @@ private long createStreamWithInconsistentMetadata(String name) throws Exception\n             BKAsyncLogWriter out = (BKAsyncLogWriter) dlm.startAsyncLogSegmentNonPartitioned();\n             for (long j = 1; j <= segmentSize; j++) {\n                 LogRecord op = DLMTestUtil.getLogRecordInstance(txid++);\n-                FutureUtils.result(out.write(op));\n+                Utils.ioResult(out.write(op));\n                 numRecordsWritten++;\n             }\n             out.closeAndComplete();"},{"sha":"6c9e3549d8968dadc976b443fd61a7ed630ec166","filename":"src/test/java/org/apache/distributedlog/TestNonBlockingReadsMultiReader.java","status":"modified","additions":7,"deletions":5,"changes":12,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FTestNonBlockingReadsMultiReader.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FTestNonBlockingReadsMultiReader.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FTestNonBlockingReadsMultiReader.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -18,8 +18,10 @@\n package org.apache.distributedlog;\n \n import com.google.common.util.concurrent.RateLimiter;\n+import org.apache.distributedlog.api.AsyncLogWriter;\n+import org.apache.distributedlog.api.DistributedLogManager;\n+import org.apache.distributedlog.api.LogReader;\n import org.apache.distributedlog.exceptions.DLInterruptedException;\n-import org.apache.distributedlog.util.FutureUtils;\n import org.apache.distributedlog.util.Utils;\n import org.junit.Test;\n \n@@ -93,8 +95,8 @@ public void testMultiReaders() throws Exception {\n         DistributedLogManager dlmwrite = createNewDLM(confLocal, name);\n \n         final AsyncLogWriter writer = dlmwrite.startAsyncLogSegmentNonPartitioned();\n-        FutureUtils.result(writer.write(DLMTestUtil.getLogRecordInstance(0)));\n-        FutureUtils.result(writer.write(DLMTestUtil.getLogRecordInstance(1)));\n+        Utils.ioResult(writer.write(DLMTestUtil.getLogRecordInstance(0)));\n+        Utils.ioResult(writer.write(DLMTestUtil.getLogRecordInstance(1)));\n         final AtomicInteger writeCount = new AtomicInteger(2);\n \n         DistributedLogManager dlmread = createNewDLM(conf, name);\n@@ -116,7 +118,7 @@ public void run() {\n                         while (running.get()) {\n                             limiter.acquire();\n                             long curTxId = txid++;\n-                            dlsn = FutureUtils.result(writer.write(DLMTestUtil.getLogRecordInstance(curTxId)));\n+                            dlsn = Utils.ioResult(writer.write(DLMTestUtil.getLogRecordInstance(curTxId)));\n                             writeCount.incrementAndGet();\n                             if (curTxId % 1000 == 0) {\n                                 LOG.info(\"writer write {}\", curTxId);\n@@ -126,7 +128,7 @@ public void run() {\n                         Utils.close(writer);\n                     } catch (DLInterruptedException die) {\n                         Thread.currentThread().interrupt();\n-                    } catch (IOException e) {\n+                    } catch (Exception e) {\n \n                     }\n                 }"},{"sha":"eda8eb2a25a7c62caa7f407f7fe292fd6c3fda61","filename":"src/test/java/org/apache/distributedlog/TestReadAheadEntryReader.java","status":"modified","additions":17,"deletions":15,"changes":32,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FTestReadAheadEntryReader.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FTestReadAheadEntryReader.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FTestReadAheadEntryReader.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -20,16 +20,18 @@\n import com.google.common.base.Optional;\n import com.google.common.base.Ticker;\n import com.google.common.collect.Lists;\n+import java.util.concurrent.CompletableFuture;\n+import org.apache.distributedlog.api.AsyncLogWriter;\n+import org.apache.distributedlog.api.DistributedLogManager;\n import org.apache.distributedlog.exceptions.AlreadyTruncatedTransactionException;\n import org.apache.distributedlog.exceptions.DLIllegalStateException;\n import org.apache.distributedlog.impl.logsegment.BKLogSegmentEntryStore;\n import org.apache.distributedlog.injector.AsyncFailureInjector;\n import org.apache.distributedlog.logsegment.LogSegmentEntryStore;\n import org.apache.distributedlog.util.ConfUtils;\n-import org.apache.distributedlog.util.FutureUtils;\n+import org.apache.distributedlog.common.concurrent.FutureUtils;\n import org.apache.distributedlog.util.OrderedScheduler;\n import org.apache.distributedlog.util.Utils;\n-import com.twitter.util.Promise;\n import org.apache.bookkeeper.stats.AlertStatsLogger;\n import org.apache.bookkeeper.stats.NullStatsLogger;\n import org.junit.After;\n@@ -130,14 +132,14 @@ private ReadAheadEntryReader createEntryReader(String streamName,\n     }\n \n     private void ensureOrderSchedulerEmpty(String streamName) throws Exception {\n-        final Promise<Void> promise = new Promise<Void>();\n+        final CompletableFuture<Void> promise = new CompletableFuture<Void>();\n         scheduler.submit(streamName, new Runnable() {\n             @Override\n             public void run() {\n-                FutureUtils.setValue(promise, null);\n+                FutureUtils.complete(promise, null);\n             }\n         });\n-        FutureUtils.result(promise);\n+        Utils.ioResult(promise);\n     }\n \n     void generateCompletedLogSegments(DistributedLogManager dlm,\n@@ -153,12 +155,12 @@ void generateCompletedLogSegments(DistributedLogManager dlm,\n \n         long txid = startTxId;\n         for (long i = 0; i < numCompletedSegments; i++) {\n-            AsyncLogWriter writer = FutureUtils.result(dlm.openAsyncLogWriter());\n+            AsyncLogWriter writer = Utils.ioResult(dlm.openAsyncLogWriter());\n             for (long j = 1; j <= segmentSize; j++) {\n-                FutureUtils.result(writer.write(DLMTestUtil.getLogRecordInstance(txid++)));\n+                Utils.ioResult(writer.write(DLMTestUtil.getLogRecordInstance(txid++)));\n                 LogRecord ctrlRecord = DLMTestUtil.getLogRecordInstance(txid);\n                 ctrlRecord.setControl();\n-                FutureUtils.result(writer.write(ctrlRecord));\n+                Utils.ioResult(writer.write(ctrlRecord));\n             }\n             Utils.close(writer);\n         }\n@@ -167,12 +169,12 @@ void generateCompletedLogSegments(DistributedLogManager dlm,\n     AsyncLogWriter createInprogressLogSegment(DistributedLogManager dlm,\n                                               DistributedLogConfiguration conf,\n                                               long segmentSize) throws Exception {\n-        AsyncLogWriter writer = FutureUtils.result(dlm.openAsyncLogWriter());\n+        AsyncLogWriter writer = Utils.ioResult(dlm.openAsyncLogWriter());\n         for (long i = 1L; i <= segmentSize; i++) {\n-            FutureUtils.result(writer.write(DLMTestUtil.getLogRecordInstance(i)));\n+            Utils.ioResult(writer.write(DLMTestUtil.getLogRecordInstance(i)));\n             LogRecord ctrlRecord = DLMTestUtil.getLogRecordInstance(i);\n             ctrlRecord.setControl();\n-            FutureUtils.result(writer.write(ctrlRecord));\n+            Utils.ioResult(writer.write(ctrlRecord));\n         }\n         return writer;\n     }\n@@ -325,8 +327,8 @@ public void testPositioningAtInvalidLogSegment() throws Exception {\n \n         // generate list of log segments\n         generateCompletedLogSegments(dlm, 3, 3);\n-        AsyncLogWriter writer = FutureUtils.result(dlm.openAsyncLogWriter());\n-        FutureUtils.result(writer.truncate(new DLSN(2L, 1L, 0L)));\n+        AsyncLogWriter writer = Utils.ioResult(dlm.openAsyncLogWriter());\n+        Utils.ioResult(writer.truncate(new DLSN(2L, 1L, 0L)));\n \n         List<LogSegmentMetadata> segments = dlm.getLogSegments();\n \n@@ -382,8 +384,8 @@ public void testPositioningIgnoreTruncationStatus() throws Exception {\n \n         // generate list of log segments\n         generateCompletedLogSegments(dlm, 3, 2);\n-        AsyncLogWriter writer = FutureUtils.result(dlm.openAsyncLogWriter());\n-        FutureUtils.result(writer.truncate(new DLSN(2L, 1L, 0L)));\n+        AsyncLogWriter writer = Utils.ioResult(dlm.openAsyncLogWriter());\n+        Utils.ioResult(writer.truncate(new DLSN(2L, 1L, 0L)));\n \n         List<LogSegmentMetadata> segments = dlm.getLogSegments();\n "},{"sha":"efc9ac6af99c5acf25fa14ad1d1410aebdfe5f42","filename":"src/test/java/org/apache/distributedlog/TestReadUtils.java","status":"modified","additions":38,"deletions":39,"changes":77,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FTestReadUtils.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FTestReadUtils.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FTestReadUtils.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -18,16 +18,15 @@\n package org.apache.distributedlog;\n \n import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.Executors;\n import java.util.concurrent.atomic.AtomicInteger;\n \n import com.google.common.base.Optional;\n import com.google.common.collect.Lists;\n+import org.apache.distributedlog.api.AsyncLogWriter;\n import org.apache.distributedlog.logsegment.LogSegmentFilter;\n-import org.apache.distributedlog.util.FutureUtils;\n import org.apache.distributedlog.util.Utils;\n-import com.twitter.util.Await;\n-import com.twitter.util.Future;\n \n import org.junit.Rule;\n import org.junit.Test;\n@@ -47,7 +46,7 @@ public class TestReadUtils extends TestDistributedLogBase {\n     @Rule\n     public TestName runtime = new TestName();\n \n-    private Future<Optional<LogRecordWithDLSN>> getLogRecordNotLessThanTxId(\n+    private CompletableFuture<Optional<LogRecordWithDLSN>> getLogRecordNotLessThanTxId(\n             BKDistributedLogManager bkdlm, int logsegmentIdx, long transactionId) throws Exception {\n         List<LogSegmentMetadata> logSegments = bkdlm.getLogSegments();\n         return ReadUtils.getLogRecordNotLessThanTxId(\n@@ -60,17 +59,17 @@ private Future<Optional<LogRecordWithDLSN>> getLogRecordNotLessThanTxId(\n         );\n     }\n \n-    private Future<LogRecordWithDLSN> getFirstGreaterThanRecord(BKDistributedLogManager bkdlm, int ledgerNo, DLSN dlsn) throws Exception {\n+    private CompletableFuture<LogRecordWithDLSN> getFirstGreaterThanRecord(BKDistributedLogManager bkdlm, int ledgerNo, DLSN dlsn) throws Exception {\n         List<LogSegmentMetadata> ledgerList = bkdlm.getLogSegments();\n         return ReadUtils.asyncReadFirstUserRecord(\n                 bkdlm.getStreamName(), ledgerList.get(ledgerNo), 2, 16, new AtomicInteger(0), Executors.newFixedThreadPool(1),\n                 bkdlm.getReaderEntryStore(), dlsn\n         );\n     }\n \n-    private Future<LogRecordWithDLSN> getLastUserRecord(BKDistributedLogManager bkdlm, int ledgerNo) throws Exception {\n+    private CompletableFuture<LogRecordWithDLSN> getLastUserRecord(BKDistributedLogManager bkdlm, int ledgerNo) throws Exception {\n         BKLogReadHandler readHandler = bkdlm.createReadHandler();\n-        List<LogSegmentMetadata> ledgerList = FutureUtils.result(\n+        List<LogSegmentMetadata> ledgerList = Utils.ioResult(\n                 readHandler.readLogSegmentsFromStore(\n                         LogSegmentMetadata.COMPARATOR,\n                         LogSegmentFilter.DEFAULT_FILTER,\n@@ -89,8 +88,8 @@ public void testForwardScanFirstRecord() throws Exception {\n         DLMTestUtil.generateLogSegmentNonPartitioned(bkdlm, 0, 5, 1 /* txid */);\n \n         DLSN dlsn = new DLSN(1,0,0);\n-        Future<LogRecordWithDLSN> futureLogrec = getFirstGreaterThanRecord(bkdlm, 0, dlsn);\n-        LogRecordWithDLSN logrec = Await.result(futureLogrec);\n+        CompletableFuture<LogRecordWithDLSN> futureLogrec = getFirstGreaterThanRecord(bkdlm, 0, dlsn);\n+        LogRecordWithDLSN logrec = Utils.ioResult(futureLogrec);\n         assertEquals(\"should be an exact match\", dlsn, logrec.getDlsn());\n         bkdlm.close();\n     }\n@@ -102,8 +101,8 @@ public void testForwardScanNotFirstRecord() throws Exception {\n         DLMTestUtil.generateLogSegmentNonPartitioned(bkdlm, 0, 5, 1 /* txid */);\n \n         DLSN dlsn = new DLSN(1,1,0);\n-        Future<LogRecordWithDLSN> futureLogrec = getFirstGreaterThanRecord(bkdlm, 0, dlsn);\n-        LogRecordWithDLSN logrec = Await.result(futureLogrec);\n+        CompletableFuture<LogRecordWithDLSN> futureLogrec = getFirstGreaterThanRecord(bkdlm, 0, dlsn);\n+        LogRecordWithDLSN logrec = Utils.ioResult(futureLogrec);\n         assertEquals(\"should be an exact match\", dlsn, logrec.getDlsn());\n         bkdlm.close();\n     }\n@@ -115,8 +114,8 @@ public void testForwardScanValidButNonExistentRecord() throws Exception {\n         DLMTestUtil.generateLogSegmentNonPartitioned(bkdlm, 0, 5, 1 /* txid */);\n \n         DLSN dlsn = new DLSN(1,0,1);\n-        Future<LogRecordWithDLSN> futureLogrec = getFirstGreaterThanRecord(bkdlm, 0, dlsn);\n-        LogRecordWithDLSN logrec = Await.result(futureLogrec);\n+        CompletableFuture<LogRecordWithDLSN> futureLogrec = getFirstGreaterThanRecord(bkdlm, 0, dlsn);\n+        LogRecordWithDLSN logrec = Utils.ioResult(futureLogrec);\n         assertEquals(new DLSN(1,1,0), logrec.getDlsn());\n         bkdlm.close();\n     }\n@@ -128,8 +127,8 @@ public void testForwardScanForRecordAfterLedger() throws Exception {\n         DLMTestUtil.generateLogSegmentNonPartitioned(bkdlm, 0, 5 /* user recs */ , 1 /* txid */);\n \n         DLSN dlsn = new DLSN(2,0,0);\n-        Future<LogRecordWithDLSN> futureLogrec = getFirstGreaterThanRecord(bkdlm, 0, dlsn);\n-        LogRecordWithDLSN logrec = Await.result(futureLogrec);\n+        CompletableFuture<LogRecordWithDLSN> futureLogrec = getFirstGreaterThanRecord(bkdlm, 0, dlsn);\n+        LogRecordWithDLSN logrec = Utils.ioResult(futureLogrec);\n         assertEquals(null, logrec);\n         bkdlm.close();\n     }\n@@ -144,8 +143,8 @@ public void testForwardScanForRecordBeforeLedger() throws Exception {\n         txid += DLMTestUtil.generateLogSegmentNonPartitioned(bkdlm, 0, 5 /* user recs */ , txid);\n \n         DLSN dlsn = new DLSN(1,3,0);\n-        Future<LogRecordWithDLSN> futureLogrec = getFirstGreaterThanRecord(bkdlm, 1, dlsn);\n-        LogRecordWithDLSN logrec = Await.result(futureLogrec);\n+        CompletableFuture<LogRecordWithDLSN> futureLogrec = getFirstGreaterThanRecord(bkdlm, 1, dlsn);\n+        LogRecordWithDLSN logrec = Utils.ioResult(futureLogrec);\n         assertEquals(new DLSN(2,0,0), logrec.getDlsn());\n         bkdlm.close();\n     }\n@@ -157,8 +156,8 @@ public void testForwardScanControlRecord() throws Exception {\n         DLMTestUtil.generateLogSegmentNonPartitioned(bkdlm, 5 /* control recs */, 5, 1 /* txid */);\n \n         DLSN dlsn = new DLSN(1,3,0);\n-        Future<LogRecordWithDLSN> futureLogrec = getFirstGreaterThanRecord(bkdlm, 0, dlsn);\n-        LogRecordWithDLSN logrec = Await.result(futureLogrec);\n+        CompletableFuture<LogRecordWithDLSN> futureLogrec = getFirstGreaterThanRecord(bkdlm, 0, dlsn);\n+        LogRecordWithDLSN logrec = Utils.ioResult(futureLogrec);\n         assertEquals(new DLSN(1,5,0), logrec.getDlsn());\n         bkdlm.close();\n     }\n@@ -169,8 +168,8 @@ public void testGetLastRecordUserRecord() throws Exception {\n         BKDistributedLogManager bkdlm = (BKDistributedLogManager) createNewDLM(conf, streamName);\n         DLMTestUtil.generateLogSegmentNonPartitioned(bkdlm, 5 /* control recs */, 5, 1 /* txid */);\n \n-        Future<LogRecordWithDLSN> futureLogrec = getLastUserRecord(bkdlm, 0);\n-        LogRecordWithDLSN logrec = Await.result(futureLogrec);\n+        CompletableFuture<LogRecordWithDLSN> futureLogrec = getLastUserRecord(bkdlm, 0);\n+        LogRecordWithDLSN logrec = Utils.ioResult(futureLogrec);\n         assertEquals(new DLSN(1,9,0), logrec.getDlsn());\n         bkdlm.close();\n     }\n@@ -182,15 +181,15 @@ public void testGetLastRecordControlRecord() throws Exception {\n \n         AsyncLogWriter out = bkdlm.startAsyncLogSegmentNonPartitioned();\n         int txid = 1;\n-        Await.result(out.write(DLMTestUtil.getLargeLogRecordInstance(txid++, false)));\n-        Await.result(out.write(DLMTestUtil.getLargeLogRecordInstance(txid++, false)));\n-        Await.result(out.write(DLMTestUtil.getLargeLogRecordInstance(txid++, false)));\n-        Await.result(out.write(DLMTestUtil.getLargeLogRecordInstance(txid++, true)));\n-        Await.result(out.write(DLMTestUtil.getLargeLogRecordInstance(txid++, true)));\n+        Utils.ioResult(out.write(DLMTestUtil.getLargeLogRecordInstance(txid++, false)));\n+        Utils.ioResult(out.write(DLMTestUtil.getLargeLogRecordInstance(txid++, false)));\n+        Utils.ioResult(out.write(DLMTestUtil.getLargeLogRecordInstance(txid++, false)));\n+        Utils.ioResult(out.write(DLMTestUtil.getLargeLogRecordInstance(txid++, true)));\n+        Utils.ioResult(out.write(DLMTestUtil.getLargeLogRecordInstance(txid++, true)));\n         Utils.close(out);\n \n-        Future<LogRecordWithDLSN> futureLogrec = getLastUserRecord(bkdlm, 0);\n-        LogRecordWithDLSN logrec = Await.result(futureLogrec);\n+        CompletableFuture<LogRecordWithDLSN> futureLogrec = getLastUserRecord(bkdlm, 0);\n+        LogRecordWithDLSN logrec = Utils.ioResult(futureLogrec);\n         assertEquals(new DLSN(1,2,0), logrec.getDlsn());\n         bkdlm.close();\n     }\n@@ -201,8 +200,8 @@ public void testGetLastRecordAllControlRecords() throws Exception {\n         BKDistributedLogManager bkdlm = (BKDistributedLogManager) createNewDLM(conf, streamName);\n         DLMTestUtil.generateLogSegmentNonPartitioned(bkdlm, 5 /* control recs */, 0, 1 /* txid */);\n \n-        Future<LogRecordWithDLSN> futureLogrec = getLastUserRecord(bkdlm, 0);\n-        LogRecordWithDLSN logrec = Await.result(futureLogrec);\n+        CompletableFuture<LogRecordWithDLSN> futureLogrec = getLastUserRecord(bkdlm, 0);\n+        LogRecordWithDLSN logrec = Utils.ioResult(futureLogrec);\n         assertEquals(null, logrec);\n         bkdlm.close();\n     }\n@@ -259,7 +258,7 @@ public void testGetLogRecordNotLessThanTxIdWithGreaterTxId() throws Exception {\n         DLMTestUtil.generateLogSegmentNonPartitioned(bkdlm, 0 /* control recs */, 1, 1 /* txid */);\n \n         Optional<LogRecordWithDLSN> result =\n-                FutureUtils.result(getLogRecordNotLessThanTxId(bkdlm, 0, 999L));\n+                Utils.ioResult(getLogRecordNotLessThanTxId(bkdlm, 0, 999L));\n         assertFalse(result.isPresent());\n     }\n \n@@ -270,7 +269,7 @@ public void testGetLogRecordNotLessThanTxIdWithLessTxId() throws Exception {\n         DLMTestUtil.generateLogSegmentNonPartitioned(bkdlm, 0 /* control recs */, 1, 999L /* txid */);\n \n         Optional<LogRecordWithDLSN> result =\n-                FutureUtils.result(getLogRecordNotLessThanTxId(bkdlm, 0, 99L));\n+                Utils.ioResult(getLogRecordNotLessThanTxId(bkdlm, 0, 99L));\n         assertTrue(result.isPresent());\n         assertEquals(999L, result.get().getTransactionId());\n         assertEquals(0L, result.get().getDlsn().getEntryId());\n@@ -284,7 +283,7 @@ public void testGetLogRecordNotLessThanTxIdOnSmallSegment() throws Exception {\n         DLMTestUtil.generateLogSegmentNonPartitioned(bkdlm, 0 /* control recs */, 5, 1L /* txid */);\n \n         Optional<LogRecordWithDLSN> result =\n-                FutureUtils.result(getLogRecordNotLessThanTxId(bkdlm, 0, 3L));\n+                Utils.ioResult(getLogRecordNotLessThanTxId(bkdlm, 0, 3L));\n         assertTrue(result.isPresent());\n         assertEquals(3L, result.get().getTransactionId());\n     }\n@@ -296,7 +295,7 @@ public void testGetLogRecordNotLessThanTxIdOnLargeSegment() throws Exception {\n         DLMTestUtil.generateLogSegmentNonPartitioned(bkdlm, 0 /* control recs */, 100, 1L /* txid */);\n \n         Optional<LogRecordWithDLSN> result =\n-                FutureUtils.result(getLogRecordNotLessThanTxId(bkdlm, 0, 9L));\n+                Utils.ioResult(getLogRecordNotLessThanTxId(bkdlm, 0, 9L));\n         assertTrue(result.isPresent());\n         assertEquals(9L, result.get().getTransactionId());\n     }\n@@ -308,7 +307,7 @@ public void testGetLogRecordGreaterThanTxIdOnLargeSegment() throws Exception {\n         DLMTestUtil.generateLogSegmentNonPartitioned(bkdlm, 0 /* control recs */, 100, 1L /* txid */, 3L);\n \n         Optional<LogRecordWithDLSN> result =\n-                FutureUtils.result(getLogRecordNotLessThanTxId(bkdlm, 0, 23L));\n+                Utils.ioResult(getLogRecordNotLessThanTxId(bkdlm, 0, 23L));\n         assertTrue(result.isPresent());\n         assertEquals(25L, result.get().getTransactionId());\n     }\n@@ -321,22 +320,22 @@ public void testGetLogRecordGreaterThanTxIdOnSameTxId() throws Exception {\n         long txid = 1L;\n         for (int i = 0; i < 10; ++i) {\n             LogRecord record = DLMTestUtil.getLargeLogRecordInstance(txid);\n-            Await.result(out.write(record));\n+            Utils.ioResult(out.write(record));\n             txid += 1;\n         }\n         long txidToSearch = txid;\n         for (int i = 0; i < 10; ++i) {\n             LogRecord record = DLMTestUtil.getLargeLogRecordInstance(txidToSearch);\n-            Await.result(out.write(record));\n+            Utils.ioResult(out.write(record));\n         }\n         for (int i = 0; i < 10; ++i) {\n             LogRecord record = DLMTestUtil.getLargeLogRecordInstance(txid);\n-            Await.result(out.write(record));\n+            Utils.ioResult(out.write(record));\n             txid += 1;\n         }\n         Utils.close(out);\n         Optional<LogRecordWithDLSN> result =\n-                FutureUtils.result(getLogRecordNotLessThanTxId(bkdlm, 0, txidToSearch));\n+                Utils.ioResult(getLogRecordNotLessThanTxId(bkdlm, 0, txidToSearch));\n         assertTrue(result.isPresent());\n         assertEquals(10L, result.get().getDlsn().getEntryId());\n     }"},{"sha":"8d9f84641afdff6d38cb2f73b67086aa62c03349","filename":"src/test/java/org/apache/distributedlog/TestReader.java","status":"modified","additions":8,"deletions":12,"changes":20,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FTestReader.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FTestReader.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FTestReader.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -17,13 +17,13 @@\n  */\n package org.apache.distributedlog;\n \n+import java.util.concurrent.CompletableFuture;\n+import org.apache.distributedlog.api.AsyncLogReader;\n+import org.apache.distributedlog.api.DistributedLogManager;\n+import org.apache.distributedlog.common.concurrent.FutureEventListener;\n import org.apache.distributedlog.util.Utils;\n-import com.twitter.util.Future;\n-import com.twitter.util.FutureEventListener;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n-import scala.runtime.AbstractFunction1;\n-import scala.runtime.BoxedUnit;\n \n import java.io.IOException;\n import java.util.concurrent.CountDownLatch;\n@@ -140,8 +140,8 @@ public void run() {\n     }\n \n     private void readNext() {\n-        Future<LogRecordWithDLSN> record = reader.readNext();\n-        record.addEventListener(this);\n+        CompletableFuture<LogRecordWithDLSN> record = reader.readNext();\n+        record.whenComplete(this);\n     }\n \n     @Override\n@@ -184,12 +184,8 @@ public void onFailure(Throwable cause) {\n \n     private void closeReader() {\n         if (null != reader) {\n-            reader.asyncClose().onFailure(new AbstractFunction1<Throwable, BoxedUnit>() {\n-                @Override\n-                public BoxedUnit apply(Throwable cause) {\n-                    LOG.warn(\"Exception on closing reader {} : \", readerName, cause);\n-                    return BoxedUnit.UNIT;\n-                }\n+            reader.asyncClose().whenComplete((value, cause) -> {\n+                LOG.warn(\"Exception on closing reader {} : \", readerName, cause);\n             });\n         }\n     }"},{"sha":"0111e4d6dbf112e8f12a3005ff7eb86ba8cffdaa","filename":"src/test/java/org/apache/distributedlog/TestRollLogSegments.java","status":"modified","additions":17,"deletions":15,"changes":32,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FTestRollLogSegments.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FTestRollLogSegments.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FTestRollLogSegments.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -20,24 +20,24 @@\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.CountDownLatch;\n \n+import org.apache.distributedlog.api.DistributedLogManager;\n+import org.apache.distributedlog.api.LogReader;\n import org.apache.distributedlog.feature.CoreFeatureKeys;\n import org.apache.distributedlog.impl.logsegment.BKLogSegmentEntryReader;\n import org.apache.distributedlog.util.FailpointUtils;\n-import org.apache.distributedlog.util.FutureUtils;\n+import org.apache.distributedlog.common.concurrent.FutureEventListener;\n import org.apache.distributedlog.util.Utils;\n-import com.twitter.util.Future;\n import org.apache.bookkeeper.client.BookKeeper;\n import org.apache.bookkeeper.client.LedgerHandle;\n import org.apache.bookkeeper.feature.SettableFeature;\n import org.junit.Test;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import org.apache.distributedlog.annotations.DistributedLogAnnotations.FlakyTest;\n-import com.twitter.util.Await;\n-import com.twitter.util.FutureEventListener;\n+import org.apache.distributedlog.common.annotations.DistributedLogAnnotations.FlakyTest;\n \n import static com.google.common.base.Charsets.UTF_8;\n import static org.junit.Assert.*;\n@@ -79,7 +79,7 @@ public void testDisableRollingLogSegments() throws Exception {\n         // send requests in parallel\n         for (int i = 1; i <= numEntries; i++) {\n             final int entryId = i;\n-            writer.write(DLMTestUtil.getLogRecordInstance(entryId)).addEventListener(new FutureEventListener<DLSN>() {\n+            writer.write(DLMTestUtil.getLogRecordInstance(entryId)).whenComplete(new FutureEventListener<DLSN>() {\n \n                 @Override\n                 public void onSuccess(DLSN value) {\n@@ -125,7 +125,9 @@ public void testLastDLSNInRollingLogSegments() throws Exception {\n         // send requests in parallel to have outstanding requests\n         for (int i = 1; i <= numEntries; i++) {\n             final int entryId = i;\n-            Future<DLSN> writeFuture = writer.write(DLMTestUtil.getLogRecordInstance(entryId)).addEventListener(new FutureEventListener<DLSN>() {\n+            CompletableFuture<DLSN> writeFuture =\n+                writer.write(DLMTestUtil.getLogRecordInstance(entryId))\n+                    .whenComplete(new FutureEventListener<DLSN>() {\n \n                 @Override\n                 public void onSuccess(DLSN value) {\n@@ -146,7 +148,7 @@ public void onFailure(Throwable cause) {\n             });\n             if (i == 1) {\n                 // wait for first log segment created\n-                FutureUtils.result(writeFuture);\n+                Utils.ioResult(writeFuture);\n             }\n         }\n         latch.await();\n@@ -191,7 +193,7 @@ public void testUnableToRollLogSegments() throws Exception {\n         long txId = 1L;\n \n         // Create Log Segments\n-        Await.result(writer.write(DLMTestUtil.getLogRecordInstance(txId)));\n+        Utils.ioResult(writer.write(DLMTestUtil.getLogRecordInstance(txId)));\n \n         FailpointUtils.setFailpoint(FailpointUtils.FailPointName.FP_StartLogSegmentBeforeLedgerCreate,\n                 FailpointUtils.FailPointActions.FailPointAction_Throw);\n@@ -201,7 +203,7 @@ public void testUnableToRollLogSegments() throws Exception {\n             final int numRecords = 10;\n             final CountDownLatch latch = new CountDownLatch(numRecords);\n             for (int i = 0; i < numRecords; i++) {\n-                writer.write(DLMTestUtil.getLogRecordInstance(++txId)).addEventListener(new FutureEventListener<DLSN>() {\n+                writer.write(DLMTestUtil.getLogRecordInstance(++txId)).whenComplete(new FutureEventListener<DLSN>() {\n                     @Override\n                     public void onSuccess(DLSN value) {\n                         logger.info(\"Completed entry : {}.\", value);\n@@ -266,7 +268,7 @@ public void testRollingLogSegments() throws Exception {\n         // send requests in parallel to have outstanding requests\n         for (int i = 1; i <= numLogSegments; i++) {\n             final int entryId = i;\n-            Future<DLSN> writeFuture = writer.write(DLMTestUtil.getLogRecordInstance(entryId)).addEventListener(new FutureEventListener<DLSN>() {\n+            CompletableFuture<DLSN> writeFuture = writer.write(DLMTestUtil.getLogRecordInstance(entryId)).whenComplete(new FutureEventListener<DLSN>() {\n                 @Override\n                 public void onSuccess(DLSN value) {\n                     logger.info(\"Completed entry {} : {}.\", entryId, value);\n@@ -279,7 +281,7 @@ public void onFailure(Throwable cause) {\n             });\n             if (i == 1) {\n                 // wait for first log segment created\n-                FutureUtils.result(writeFuture);\n+                Utils.ioResult(writeFuture);\n             }\n         }\n         latch.await();\n@@ -297,7 +299,7 @@ public void onFailure(Throwable cause) {\n         // writer should work after rolling log segments\n         // there would be (numLogSegments/2) segments based on current rolling policy\n         for (int i = 1; i <= numLogSegments; i++) {\n-            DLSN newDLSN = Await.result(writer.write(DLMTestUtil.getLogRecordInstance(numLogSegments + i)));\n+            DLSN newDLSN = Utils.ioResult(writer.write(DLMTestUtil.getLogRecordInstance(numLogSegments + i)));\n             logger.info(\"Completed entry {} : {}\", numLogSegments + i, newDLSN);\n         }\n \n@@ -364,7 +366,7 @@ public void testCaughtUpReaderOnLogSegmentRolling() throws Exception {\n \n         // 2) reader should be able to read 5 entries.\n         for (long i = 1; i <= numEntries; i++) {\n-            LogRecordWithDLSN record = Await.result(reader.readNext());\n+            LogRecordWithDLSN record = Utils.ioResult(reader.readNext());\n             DLMTestUtil.verifyLogRecord(record);\n             assertEquals(i, record.getTransactionId());\n             assertEquals(record.getTransactionId() - 1, record.getSequenceId());\n@@ -418,7 +420,7 @@ public void testCaughtUpReaderOnLogSegmentRolling() throws Exception {\n         anotherWriter.closeAndComplete();\n \n         for (long i = numEntries + 1; i <= numEntries + 3; i++) {\n-            LogRecordWithDLSN record = Await.result(reader.readNext());\n+            LogRecordWithDLSN record = Utils.ioResult(reader.readNext());\n             DLMTestUtil.verifyLogRecord(record);\n             assertEquals(i, record.getTransactionId());\n         }"},{"sha":"da4ef81e6001b83f31275290a8d2aa7f2c14c008","filename":"src/test/java/org/apache/distributedlog/TestSequenceID.java","status":"modified","additions":11,"deletions":10,"changes":21,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FTestSequenceID.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FTestSequenceID.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FTestSequenceID.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -18,8 +18,9 @@\n package org.apache.distributedlog;\n \n import org.apache.distributedlog.LogSegmentMetadata.LogSegmentMetadataVersion;\n-import com.twitter.util.Await;\n-import com.twitter.util.FutureEventListener;\n+import org.apache.distributedlog.api.AsyncLogReader;\n+import org.apache.distributedlog.common.concurrent.FutureEventListener;\n+import org.apache.distributedlog.util.Utils;\n import org.junit.Test;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -72,7 +73,7 @@ private void completeSingleInprogressSegment(int writeVersion, int completeVersi\n \n         BKDistributedLogManager dlm = (BKDistributedLogManager) createNewDLM(confLocal, name);\n         BKAsyncLogWriter writer = dlm.startAsyncLogSegmentNonPartitioned();\n-        Await.result(writer.write(DLMTestUtil.getLogRecordInstance(0L)));\n+        Utils.ioResult(writer.write(DLMTestUtil.getLogRecordInstance(0L)));\n \n         dlm.close();\n \n@@ -126,16 +127,16 @@ public void testSequenceID() throws Exception {\n         for (int i = 0; i < 3; i++) {\n             BKAsyncLogWriter writer = dlm.startAsyncLogSegmentNonPartitioned();\n             for (int j = 0; j < 2; j++) {\n-                Await.result(writer.write(DLMTestUtil.getLogRecordInstance(txId++)));\n+                Utils.ioResult(writer.write(DLMTestUtil.getLogRecordInstance(txId++)));\n \n                 if (null == reader) {\n                     reader = readDLM.getAsyncLogReader(DLSN.InitialDLSN);\n                     final AsyncLogReader r = reader;\n-                    reader.readNext().addEventListener(new FutureEventListener<LogRecordWithDLSN>() {\n+                    reader.readNext().whenComplete(new FutureEventListener<LogRecordWithDLSN>() {\n                         @Override\n                         public void onSuccess(LogRecordWithDLSN record) {\n                             readRecords.add(record);\n-                            r.readNext().addEventListener(this);\n+                            r.readNext().whenComplete(this);\n                         }\n \n                         @Override\n@@ -149,7 +150,7 @@ public void onFailure(Throwable cause) {\n         }\n \n         BKAsyncLogWriter writer = dlm.startAsyncLogSegmentNonPartitioned();\n-        Await.result(writer.write(DLMTestUtil.getLogRecordInstance(txId++)));\n+        Utils.ioResult(writer.write(DLMTestUtil.getLogRecordInstance(txId++)));\n \n         List<LogSegmentMetadata> segments = dlm.getLogSegments();\n         assertEquals(4, segments.size());\n@@ -174,12 +175,12 @@ public void onFailure(Throwable cause) {\n         for (int i = 0; i < 3; i++) {\n             BKAsyncLogWriter writerv5 = dlmv5.startAsyncLogSegmentNonPartitioned();\n             for (int j = 0; j < 2; j++) {\n-                Await.result(writerv5.write(DLMTestUtil.getLogRecordInstance(txId++)));\n+                Utils.ioResult(writerv5.write(DLMTestUtil.getLogRecordInstance(txId++)));\n             }\n             writerv5.closeAndComplete();\n         }\n         BKAsyncLogWriter writerv5 = dlmv5.startAsyncLogSegmentNonPartitioned();\n-        Await.result(writerv5.write(DLMTestUtil.getLogRecordInstance(txId++)));\n+        Utils.ioResult(writerv5.write(DLMTestUtil.getLogRecordInstance(txId++)));\n \n         List<LogSegmentMetadata> segmentsv5 = dlmv5.getLogSegments();\n         assertEquals(8, segmentsv5.size());\n@@ -205,7 +206,7 @@ public void onFailure(Throwable cause) {\n         for (int i = 0; i < 3; i++) {\n             BKAsyncLogWriter writerv4 = dlmv4.startAsyncLogSegmentNonPartitioned();\n             for (int j = 0; j < 2; j++) {\n-                Await.result(writerv4.write(DLMTestUtil.getLogRecordInstance(txId++)));\n+                Utils.ioResult(writerv4.write(DLMTestUtil.getLogRecordInstance(txId++)));\n             }\n             writerv4.closeAndComplete();\n         }"},{"sha":"06708c85efd53f5614b54b1860b2cd1a4edbe6ef","filename":"src/test/java/org/apache/distributedlog/TestTruncate.java","status":"modified","additions":16,"deletions":15,"changes":31,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FTestTruncate.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FTestTruncate.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FTestTruncate.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -22,7 +22,9 @@\n import java.util.List;\n import java.util.Map;\n \n-import org.apache.distributedlog.util.FutureUtils;\n+import org.apache.distributedlog.api.AsyncLogWriter;\n+import org.apache.distributedlog.api.DistributedLogManager;\n+import org.apache.distributedlog.api.LogReader;\n import org.apache.distributedlog.util.Utils;\n import org.apache.commons.lang3.tuple.ImmutablePair;\n import org.apache.commons.lang3.tuple.Pair;\n@@ -31,7 +33,6 @@\n import org.slf4j.LoggerFactory;\n \n import org.apache.distributedlog.LogSegmentMetadata.TruncationStatus;\n-import com.twitter.util.Await;\n \n import static org.junit.Assert.*;\n \n@@ -96,11 +97,11 @@ public void testPurgeLogs() throws Exception {\n         AsyncLogWriter writer = dlm.startAsyncLogSegmentNonPartitioned();\n         long txid = 1 + 10 * 10;\n         for (int j = 1; j <= 10; j++) {\n-            Await.result(writer.write(DLMTestUtil.getLogRecordInstance(txid++)));\n+            Utils.ioResult(writer.write(DLMTestUtil.getLogRecordInstance(txid++)));\n         }\n \n         // to make sure the truncation task is executed\n-        DLSN lastDLSN = Await.result(dlm.getLastDLSNAsync());\n+        DLSN lastDLSN = Utils.ioResult(dlm.getLastDLSNAsync());\n         LOG.info(\"Get last dlsn of stream {} : {}\", name, lastDLSN);\n \n         assertEquals(6, distributedLogManager.getLogSegments().size());\n@@ -123,20 +124,20 @@ public void testTruncation() throws Exception {\n         Thread.sleep(1000);\n \n         // delete invalid dlsn\n-        assertFalse(Await.result(pair.getRight().truncate(DLSN.InvalidDLSN)));\n+        assertFalse(Utils.ioResult(pair.getRight().truncate(DLSN.InvalidDLSN)));\n         verifyEntries(name, 1, 1, 5 * 10);\n \n         for (int i = 1; i <= 4; i++) {\n             int txn = (i-1) * 10 + i;\n             DLSN dlsn = txid2DLSN.get((long)txn);\n-            assertTrue(Await.result(pair.getRight().truncate(dlsn)));\n+            assertTrue(Utils.ioResult(pair.getRight().truncate(dlsn)));\n             verifyEntries(name, 1, (i - 1) * 10 + 1, (5 - i + 1) * 10);\n         }\n \n         // Delete higher dlsn\n         int txn = 43;\n         DLSN dlsn = txid2DLSN.get((long) txn);\n-        assertTrue(Await.result(pair.getRight().truncate(dlsn)));\n+        assertTrue(Utils.ioResult(pair.getRight().truncate(dlsn)));\n         verifyEntries(name, 1, 41, 10);\n \n         Utils.close(pair.getRight());\n@@ -160,14 +161,14 @@ public void testExplicitTruncation() throws Exception {\n         for (int i = 1; i <= 4; i++) {\n             int txn = (i-1) * 10 + i;\n             DLSN dlsn = txid2DLSN.get((long)txn);\n-            assertTrue(Await.result(pair.getRight().truncate(dlsn)));\n+            assertTrue(Utils.ioResult(pair.getRight().truncate(dlsn)));\n             verifyEntries(name, 1, (i - 1) * 10 + 1, (5 - i + 1) * 10);\n         }\n \n         // Delete higher dlsn\n         int txn = 43;\n         DLSN dlsn = txid2DLSN.get((long) txn);\n-        assertTrue(Await.result(pair.getRight().truncate(dlsn)));\n+        assertTrue(Utils.ioResult(pair.getRight().truncate(dlsn)));\n         verifyEntries(name, 1, 41, 10);\n \n         Utils.close(pair.getRight());\n@@ -176,7 +177,7 @@ public void testExplicitTruncation() throws Exception {\n         // Try force truncation\n         BKDistributedLogManager dlm = (BKDistributedLogManager)createNewDLM(confLocal, name);\n         BKLogWriteHandler handler = dlm.createWriteHandler(true);\n-        FutureUtils.result(handler.purgeLogSegmentsOlderThanTxnId(Integer.MAX_VALUE));\n+        Utils.ioResult(handler.purgeLogSegmentsOlderThanTxnId(Integer.MAX_VALUE));\n \n         verifyEntries(name, 1, 41, 10);\n     }\n@@ -230,11 +231,11 @@ public void testOnlyPurgeSegmentsBeforeNoneFullyTruncatedSegment() throws Except\n         AsyncLogWriter newWriter = newDLM.startAsyncLogSegmentNonPartitioned();\n         long txid = 1 + 4 * 10;\n         for (int j = 1; j <= 10; j++) {\n-            Await.result(newWriter.write(DLMTestUtil.getLogRecordInstance(txid++)));\n+            Utils.ioResult(newWriter.write(DLMTestUtil.getLogRecordInstance(txid++)));\n         }\n \n         // to make sure the truncation task is executed\n-        DLSN lastDLSN = Await.result(newDLM.getLastDLSNAsync());\n+        DLSN lastDLSN = Utils.ioResult(newDLM.getLastDLSNAsync());\n         LOG.info(\"Get last dlsn of stream {} : {}\", name, lastDLSN);\n \n         assertEquals(5, newDLM.getLogSegments().size());\n@@ -277,7 +278,7 @@ public void testPartiallyTruncateTruncatedSegments() throws Exception {\n \n         DistributedLogManager newDLM = createNewDLM(confLocal, name);\n         AsyncLogWriter newWriter = newDLM.startAsyncLogSegmentNonPartitioned();\n-        Await.result(newWriter.truncate(dlsnMap.get(15L)));\n+        Utils.ioResult(newWriter.truncate(dlsnMap.get(15L)));\n \n         List<LogSegmentMetadata> newSegments2 = newDLM.getLogSegments();\n         assertArrayEquals(newSegments.toArray(new LogSegmentMetadata[4]),\n@@ -299,7 +300,7 @@ private Pair<DistributedLogManager, AsyncLogWriter> populateData(\n             AsyncLogWriter writer = dlm.startAsyncLogSegmentNonPartitioned();\n             for (int j = 1; j <= numEntriesPerLogSegment; j++) {\n                 long curTxId = txid++;\n-                DLSN dlsn = Await.result(writer.write(DLMTestUtil.getLogRecordInstance(curTxId)));\n+                DLSN dlsn = Utils.ioResult(writer.write(DLMTestUtil.getLogRecordInstance(curTxId)));\n                 txid2DLSN.put(curTxId, dlsn);\n             }\n             Utils.close(writer);\n@@ -311,7 +312,7 @@ private Pair<DistributedLogManager, AsyncLogWriter> populateData(\n             AsyncLogWriter writer = dlm.startAsyncLogSegmentNonPartitioned();\n             for (int j = 1; j <= 10; j++) {\n                 long curTxId = txid++;\n-                DLSN dlsn = Await.result(writer.write(DLMTestUtil.getLogRecordInstance(curTxId)));\n+                DLSN dlsn = Utils.ioResult(writer.write(DLMTestUtil.getLogRecordInstance(curTxId)));\n                 txid2DLSN.put(curTxId, dlsn);\n             }\n             return new ImmutablePair<DistributedLogManager, AsyncLogWriter>(dlm, writer);"},{"sha":"0d0ca99db1d2686ffa699672631a754e89724f41","filename":"src/test/java/org/apache/distributedlog/TestWriteLimiter.java","status":"modified","additions":0,"deletions":2,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FTestWriteLimiter.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FTestWriteLimiter.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FTestWriteLimiter.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -18,7 +18,6 @@\n package org.apache.distributedlog;\n \n import org.apache.distributedlog.exceptions.OverCapacityException;\n-import org.apache.distributedlog.util.PermitLimiter;\n import org.apache.distributedlog.util.SimplePermitLimiter;\n import org.apache.bookkeeper.feature.Feature;\n import org.apache.bookkeeper.feature.SettableFeature;\n@@ -30,7 +29,6 @@\n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.fail;\n \n-import scala.runtime.BoxedUnit;\n \n public class TestWriteLimiter {\n     static final Logger LOG = LoggerFactory.getLogger(TestWriteLimiter.class);"},{"sha":"75bcda243b243bd1db949fd83b1fb818b8bb5178","filename":"src/test/java/org/apache/distributedlog/TestZooKeeperClient.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FTestZooKeeperClient.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FTestZooKeeperClient.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2FTestZooKeeperClient.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -19,7 +19,7 @@\n \n import org.apache.distributedlog.ZooKeeperClient.Credentials;\n import org.apache.distributedlog.ZooKeeperClient.DigestCredentials;\n-import org.apache.distributedlog.annotations.DistributedLogAnnotations;\n+import org.apache.distributedlog.common.annotations.DistributedLogAnnotations;\n import org.apache.bookkeeper.stats.NullStatsLogger;\n import org.apache.bookkeeper.zookeeper.BoundExponentialBackoffRetryPolicy;\n import org.apache.zookeeper.CreateMode;"},{"sha":"45fc1f3eb30f06f23f1bab3036d6756951579dee","filename":"src/test/java/org/apache/distributedlog/acl/TestZKAccessControl.java","status":"modified","additions":20,"deletions":20,"changes":40,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Facl%2FTestZKAccessControl.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Facl%2FTestZKAccessControl.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Facl%2FTestZKAccessControl.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -17,20 +17,20 @@\n  */\n package org.apache.distributedlog.acl;\n \n+import java.net.URI;\n import org.apache.distributedlog.TestZooKeeperClientBuilder;\n import org.apache.distributedlog.ZooKeeperClient;\n import org.apache.distributedlog.ZooKeeperClusterTestCase;\n import org.apache.distributedlog.impl.acl.ZKAccessControl;\n import org.apache.distributedlog.thrift.AccessControlEntry;\n-import com.twitter.util.Await;\n+import org.apache.distributedlog.common.concurrent.FutureUtils;\n+import org.apache.distributedlog.util.Utils;\n import org.apache.zookeeper.CreateMode;\n import org.apache.zookeeper.KeeperException;\n import org.junit.After;\n import org.junit.Before;\n import org.junit.Test;\n \n-import java.net.URI;\n-\n import static com.google.common.base.Charsets.UTF_8;\n import static org.junit.Assert.*;\n \n@@ -60,14 +60,14 @@ public void testCreateZKAccessControl() throws Exception {\n         ace.setDenyWrite(true);\n         String zkPath = \"/create-zk-access-control\";\n         ZKAccessControl zkac = new ZKAccessControl(ace, zkPath);\n-        Await.result(zkac.create(zkc));\n+        Utils.ioResult(zkac.create(zkc));\n \n-        ZKAccessControl readZKAC = Await.result(ZKAccessControl.read(zkc, zkPath, null));\n+        ZKAccessControl readZKAC = Utils.ioResult(ZKAccessControl.read(zkc, zkPath, null));\n         assertEquals(zkac, readZKAC);\n \n         ZKAccessControl another = new ZKAccessControl(ace, zkPath);\n         try {\n-            Await.result(another.create(zkc));\n+            FutureUtils.result(another.create(zkc));\n         } catch (KeeperException.NodeExistsException ke) {\n             // expected\n         }\n@@ -81,19 +81,19 @@ public void testDeleteZKAccessControl() throws Exception {\n         ace.setDenyDelete(true);\n \n         ZKAccessControl zkac = new ZKAccessControl(ace, zkPath);\n-        Await.result(zkac.create(zkc));\n+        Utils.ioResult(zkac.create(zkc));\n \n-        ZKAccessControl readZKAC = Await.result(ZKAccessControl.read(zkc, zkPath, null));\n+        ZKAccessControl readZKAC = Utils.ioResult(ZKAccessControl.read(zkc, zkPath, null));\n         assertEquals(zkac, readZKAC);\n \n-        Await.result(ZKAccessControl.delete(zkc, zkPath));\n+        Utils.ioResult(ZKAccessControl.delete(zkc, zkPath));\n \n         try {\n-            Await.result(ZKAccessControl.read(zkc, zkPath, null));\n+            FutureUtils.result(ZKAccessControl.read(zkc, zkPath, null));\n         } catch (KeeperException.NoNodeException nne) {\n             // expected.\n         }\n-        Await.result(ZKAccessControl.delete(zkc, zkPath));\n+        Utils.ioResult(ZKAccessControl.delete(zkc, zkPath));\n     }\n \n     @Test(timeout = 60000)\n@@ -102,7 +102,7 @@ public void testEmptyZKAccessControl() throws Exception {\n \n         zkc.get().create(zkPath, new byte[0], zkc.getDefaultACL(), CreateMode.PERSISTENT);\n \n-        ZKAccessControl readZKAC = Await.result(ZKAccessControl.read(zkc, zkPath, null));\n+        ZKAccessControl readZKAC = Utils.ioResult(ZKAccessControl.read(zkc, zkPath, null));\n \n         assertEquals(zkPath, readZKAC.getZKPath());\n         assertEquals(ZKAccessControl.DEFAULT_ACCESS_CONTROL_ENTRY, readZKAC.getAccessControlEntry());\n@@ -116,7 +116,7 @@ public void testCorruptedZKAccessControl() throws Exception {\n         zkc.get().create(zkPath, \"corrupted-data\".getBytes(UTF_8), zkc.getDefaultACL(), CreateMode.PERSISTENT);\n \n         try {\n-            Await.result(ZKAccessControl.read(zkc, zkPath, null));\n+            Utils.ioResult(ZKAccessControl.read(zkc, zkPath, null));\n         } catch (ZKAccessControl.CorruptedAccessControlException cace) {\n             // expected\n         }\n@@ -130,25 +130,25 @@ public void testUpdateZKAccessControl() throws Exception {\n         ace.setDenyDelete(true);\n \n         ZKAccessControl zkac = new ZKAccessControl(ace, zkPath);\n-        Await.result(zkac.create(zkc));\n+        Utils.ioResult(zkac.create(zkc));\n \n-        ZKAccessControl readZKAC = Await.result(ZKAccessControl.read(zkc, zkPath, null));\n+        ZKAccessControl readZKAC = Utils.ioResult(ZKAccessControl.read(zkc, zkPath, null));\n         assertEquals(zkac, readZKAC);\n \n         ace.setDenyRelease(true);\n         ZKAccessControl newZKAC = new ZKAccessControl(ace, zkPath);\n-        Await.result(newZKAC.update(zkc));\n-        ZKAccessControl readZKAC2 = Await.result(ZKAccessControl.read(zkc, zkPath, null));\n+        Utils.ioResult(newZKAC.update(zkc));\n+        ZKAccessControl readZKAC2 = Utils.ioResult(ZKAccessControl.read(zkc, zkPath, null));\n         assertEquals(newZKAC, readZKAC2);\n \n         try {\n-            Await.result(readZKAC.update(zkc));\n+            FutureUtils.result(readZKAC.update(zkc));\n         } catch (KeeperException.BadVersionException bve) {\n             // expected\n         }\n         readZKAC2.getAccessControlEntry().setDenyTruncate(true);\n-        Await.result(readZKAC2.update(zkc));\n-        ZKAccessControl readZKAC3 = Await.result(ZKAccessControl.read(zkc, zkPath, null));\n+        Utils.ioResult(readZKAC2.update(zkc));\n+        ZKAccessControl readZKAC3 = Utils.ioResult(ZKAccessControl.read(zkc, zkPath, null));\n         assertEquals(readZKAC2, readZKAC3);\n     }\n }"},{"sha":"868549ecc77d9b3c690841dca860ae35ec7d2f75","filename":"src/test/java/org/apache/distributedlog/acl/TestZKAccessControlManager.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Facl%2FTestZKAccessControlManager.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Facl%2FTestZKAccessControlManager.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Facl%2FTestZKAccessControlManager.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -25,7 +25,7 @@\n import org.apache.distributedlog.impl.acl.ZKAccessControl;\n import org.apache.distributedlog.impl.acl.ZKAccessControlManager;\n import org.apache.distributedlog.thrift.AccessControlEntry;\n-import com.twitter.util.Await;\n+import org.apache.distributedlog.util.Utils;\n import org.junit.After;\n import org.junit.Before;\n import org.junit.Test;\n@@ -136,7 +136,7 @@ public void testZKAccessControlManager() throws Exception {\n             verifyStreamPermissions(zkcm, stream2, true, false, true, true, true);\n \n             // delete stream2\n-            Await.result(ZKAccessControl.delete(zkc, zkPath2));\n+            Utils.ioResult(ZKAccessControl.delete(zkc, zkPath2));\n             logger.info(\"Delete ACL for stream {}\", stream2);\n             while (!zkcm.allowTruncate(stream2)) {\n                 Thread.sleep(100);"},{"sha":"8a2c4764fb6b12ba9038a6008b60808aabdb1767","filename":"src/test/java/org/apache/distributedlog/admin/TestDLCK.java","status":"modified","additions":5,"deletions":6,"changes":11,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fadmin%2FTestDLCK.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fadmin%2FTestDLCK.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fadmin%2FTestDLCK.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -17,21 +17,20 @@\n  */\n package org.apache.distributedlog.admin;\n \n-import org.apache.distributedlog.BookKeeperClient;\n import org.apache.distributedlog.DLMTestUtil;\n import org.apache.distributedlog.DLSN;\n import org.apache.distributedlog.DistributedLogConfiguration;\n-import org.apache.distributedlog.DistributedLogManager;\n+import org.apache.distributedlog.api.DistributedLogManager;\n import org.apache.distributedlog.LogSegmentMetadata;\n import org.apache.distributedlog.TestDistributedLogBase;\n import org.apache.distributedlog.TestZooKeeperClientBuilder;\n import org.apache.distributedlog.ZooKeeperClient;\n+import org.apache.distributedlog.api.namespace.Namespace;\n import org.apache.distributedlog.metadata.DryrunLogSegmentMetadataStoreUpdater;\n import org.apache.distributedlog.metadata.LogSegmentMetadataStoreUpdater;\n-import org.apache.distributedlog.namespace.DistributedLogNamespace;\n-import org.apache.distributedlog.namespace.DistributedLogNamespaceBuilder;\n+import org.apache.distributedlog.api.namespace.NamespaceBuilder;\n import org.apache.distributedlog.util.OrderedScheduler;\n-import org.apache.distributedlog.util.SchedulerUtils;\n+import org.apache.distributedlog.common.util.SchedulerUtils;\n import org.apache.zookeeper.CreateMode;\n import org.apache.zookeeper.ZooDefs;\n import org.junit.After;\n@@ -105,7 +104,7 @@ public void testCheckAndRepairDLNamespace() throws Exception {\n         confLocal.setLogSegmentCacheEnabled(false);\n         URI uri = createDLMURI(\"/check-and-repair-dl-namespace\");\n         zkc.get().create(uri.getPath(), new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n-        DistributedLogNamespace namespace = DistributedLogNamespaceBuilder.newBuilder()\n+        Namespace namespace = NamespaceBuilder.newBuilder()\n                 .conf(confLocal)\n                 .uri(uri)\n                 .build();"},{"sha":"f7f859c848e154823c85009ed3981065c9add668","filename":"src/test/java/org/apache/distributedlog/admin/TestDistributedLogAdmin.java","status":"modified","additions":15,"deletions":18,"changes":33,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fadmin%2FTestDistributedLogAdmin.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fadmin%2FTestDistributedLogAdmin.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fadmin%2FTestDistributedLogAdmin.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","patch":"@@ -18,14 +18,14 @@\n package org.apache.distributedlog.admin;\n \n import java.net.URI;\n-import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.CompletableFuture;\n \n import org.apache.distributedlog.DistributedLogConfiguration;\n import org.apache.distributedlog.TestZooKeeperClientBuilder;\n-import org.apache.distributedlog.annotations.DistributedLogAnnotations;\n+import org.apache.distributedlog.api.namespace.Namespace;\n+import org.apache.distributedlog.common.annotations.DistributedLogAnnotations;\n import org.apache.distributedlog.exceptions.UnexpectedException;\n-import org.apache.distributedlog.namespace.DistributedLogNamespace;\n-import org.apache.distributedlog.namespace.DistributedLogNamespaceBuilder;\n+import org.apache.distributedlog.api.namespace.NamespaceBuilder;\n import org.apache.distributedlog.util.Utils;\n import org.apache.zookeeper.CreateMode;\n import org.apache.zookeeper.ZooDefs;\n@@ -36,19 +36,16 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import org.apache.distributedlog.AsyncLogReader;\n+import org.apache.distributedlog.api.AsyncLogReader;\n import org.apache.distributedlog.DLMTestUtil;\n import org.apache.distributedlog.DLSN;\n-import org.apache.distributedlog.DistributedLogManager;\n+import org.apache.distributedlog.api.DistributedLogManager;\n import org.apache.distributedlog.LogRecord;\n import org.apache.distributedlog.LogRecordWithDLSN;\n import org.apache.distributedlog.TestDistributedLogBase;\n import org.apache.distributedlog.ZooKeeperClient;\n import org.apache.distributedlog.metadata.DryrunLogSegmentMetadataStoreUpdater;\n import org.apache.distributedlog.metadata.LogSegmentMetadataStoreUpdater;\n-import com.twitter.util.Await;\n-import com.twitter.util.Duration;\n-import com.twitter.util.Future;\n \n import static org.junit.Assert.*;\n \n@@ -92,11 +89,11 @@ public void testChangeSequenceNumber() throws Exception {\n \n         URI uri = createDLMURI(\"/change-sequence-number\");\n         zooKeeperClient.get().create(uri.getPath(), new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n-        DistributedLogNamespace namespace = DistributedLogNamespaceBuilder.newBuilder()\n+        Namespace namespace = NamespaceBuilder.newBuilder()\n                 .conf(confLocal)\n                 .uri(uri)\n                 .build();\n-        DistributedLogNamespace readNamespace = DistributedLogNamespaceBuilder.newBuilder()\n+        Namespace readNamespace = NamespaceBuilder.newBuilder()\n                 .conf(readConf)\n                 .uri(uri)\n                 .build();\n@@ -117,7 +114,7 @@ public void testChangeSequenceNumber() throws Exception {\n         long expectedTxId = 1L;\n         DLSN lastDLSN = DLSN.InitialDLSN;\n         for (int i = 0; i < 4 * 10; i++) {\n-            LogRecordWithDLSN record = Await.result(reader.readNext());\n+            LogRecordWithDLSN record = Utils.ioResult(reader.readNext());\n             assertNotNull(record);\n             DLMTestUtil.verifyLogRecord(record);\n             assertEquals(expectedTxId, record.getTransactionId());\n@@ -133,9 +130,9 @@ public void testChangeSequenceNumber() throws Exception {\n         LOG.info(\"Injected bad log segment '3'\");\n \n         // there isn't records should be read\n-        Future<LogRecordWithDLSN> readFuture = reader.readNext();\n+        CompletableFuture<LogRecordWithDLSN> readFuture = reader.readNext();\n         try {\n-            LogRecordWithDLSN record = Await.result(readFuture);\n+            LogRecordWithDLSN record = Utils.ioResult(readFuture);\n             fail(\"Should fail reading next record \"\n                     + record\n                     + \" when there is a corrupted log segment\");\n@@ -151,7 +148,7 @@ public void testChangeSequenceNumber() throws Exception {\n \n         try {\n             reader = readDLM.getAsyncLogReader(lastDLSN);\n-            Await.result(reader.readNext());\n+            Utils.ioResult(reader.readNext());\n             fail(\"Should fail reading next when there is a corrupted log segment\");\n         } catch (UnexpectedException ue) {\n             // expected\n@@ -166,18 +163,18 @@ public void testChangeSequenceNumber() throws Exception {\n         // be able to read more after fix\n         reader = readDLM.getAsyncLogReader(lastDLSN);\n         // skip the first record\n-        Await.result(reader.readNext());\n+        Utils.ioResult(reader.readNext());\n         readFuture = reader.readNext();\n \n         expectedTxId = 51L;\n-        LogRecord record = Await.result(readFuture);\n+        LogRecord record = Utils.ioResult(readFuture);\n         assertNotNull(record);\n         DLMTestUtil.verifyLogRecord(record);\n         assertEquals(expectedTxId, record.getTransactionId());\n         expectedTxId++;\n \n         for (int i = 1; i < 10; i++) {\n-            record = Await.result(reader.readNext());\n+            record = Utils.ioResult(reader.readNext());\n             assertNotNull(record);\n             DLMTestUtil.verifyLogRecord(record);\n             assertEquals(expectedTxId, record.getTransactionId());"},{"sha":"925cad5abcce6d253190673eea60c95e0cea297b","filename":"src/test/java/org/apache/distributedlog/bk/TestLedgerAllocator.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fbk%2FTestLedgerAllocator.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fbk%2FTestLedgerAllocator.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fbk%2FTestLedgerAllocator.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3"},{"sha":"a42d688dbd2a2bcf36664f9b9906df6f0242d501","filename":"src/test/java/org/apache/distributedlog/bk/TestLedgerAllocatorPool.java","status":"modified","additions":11,"deletions":12,"changes":23,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fbk%2FTestLedgerAllocatorPool.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fbk%2FTestLedgerAllocatorPool.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fbk%2FTestLedgerAllocatorPool.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3"},{"sha":"5efa7e4bd07dabfde309f2e92277132eb8bc6453","filename":"src/test/java/org/apache/distributedlog/config/PropertiesWriter.java","status":"modified","additions":5,"deletions":3,"changes":8,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fconfig%2FPropertiesWriter.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fconfig%2FPropertiesWriter.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fconfig%2FPropertiesWriter.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3"},{"sha":"95635117d89a10fa3a60e81d6075eecdab5f797a","filename":"src/test/java/org/apache/distributedlog/config/TestConcurrentBaseConfiguration.java","status":"removed","additions":0,"deletions":46,"changes":46,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/46e6b70feda2e8ad61ba13928df93b2c94d3dd4e/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fconfig%2FTestConcurrentBaseConfiguration.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/46e6b70feda2e8ad61ba13928df93b2c94d3dd4e/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fconfig%2FTestConcurrentBaseConfiguration.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fconfig%2FTestConcurrentBaseConfiguration.java?ref=46e6b70feda2e8ad61ba13928df93b2c94d3dd4e"},{"sha":"8420a971e5058ca7b4d62b5ae8bd06d2ed7a1000","filename":"src/test/java/org/apache/distributedlog/config/TestConfigurationSubscription.java","status":"removed","additions":0,"deletions":171,"changes":171,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/46e6b70feda2e8ad61ba13928df93b2c94d3dd4e/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fconfig%2FTestConfigurationSubscription.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/46e6b70feda2e8ad61ba13928df93b2c94d3dd4e/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fconfig%2FTestConfigurationSubscription.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fconfig%2FTestConfigurationSubscription.java?ref=46e6b70feda2e8ad61ba13928df93b2c94d3dd4e"},{"sha":"21aa1c9f960efe3efcba2bc3a021f2a5b307743f","filename":"src/test/java/org/apache/distributedlog/config/TestDynamicConfigurationFactory.java","status":"modified","additions":3,"deletions":2,"changes":5,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fconfig%2FTestDynamicConfigurationFactory.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fconfig%2FTestDynamicConfigurationFactory.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fconfig%2FTestDynamicConfigurationFactory.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3"},{"sha":"2731af397c501a39f21ee1d3418e003ef9d4d7d7","filename":"src/test/java/org/apache/distributedlog/config/TestDynamicDistributedLogConfiguration.java","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fconfig%2FTestDynamicDistributedLogConfiguration.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fconfig%2FTestDynamicDistributedLogConfiguration.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fconfig%2FTestDynamicDistributedLogConfiguration.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3"},{"sha":"1064a6f4311a3ce0fb6e2ab624e499c5bec7e244","filename":"src/test/java/org/apache/distributedlog/feature/TestConfigurationFeatureProvider.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Ffeature%2FTestConfigurationFeatureProvider.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Ffeature%2FTestConfigurationFeatureProvider.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Ffeature%2FTestConfigurationFeatureProvider.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3"},{"sha":"f8dd24561abdc2d13ae152f845d6b800eb744642","filename":"src/test/java/org/apache/distributedlog/feature/TestDynamicConfigurationFeatureProvider.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Ffeature%2FTestDynamicConfigurationFeatureProvider.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Ffeature%2FTestDynamicConfigurationFeatureProvider.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Ffeature%2FTestDynamicConfigurationFeatureProvider.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3"},{"sha":"db9fb311f8dff2205b9210336890eed068616c83","filename":"src/test/java/org/apache/distributedlog/impl/TestZKLogMetadataStore.java","status":"modified","additions":3,"deletions":4,"changes":7,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fimpl%2FTestZKLogMetadataStore.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fimpl%2FTestZKLogMetadataStore.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fimpl%2FTestZKLogMetadataStore.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3"},{"sha":"721bfbf08acc57263ac5f4ab79ed5f25a7023e55","filename":"src/test/java/org/apache/distributedlog/impl/TestZKLogSegmentMetadataStore.java","status":"modified","additions":68,"deletions":69,"changes":137,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fimpl%2FTestZKLogSegmentMetadataStore.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fimpl%2FTestZKLogSegmentMetadataStore.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fimpl%2FTestZKLogSegmentMetadataStore.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3"},{"sha":"4bd513b3d1878c78cc7fcb1bd23761ceb5af0b58","filename":"src/test/java/org/apache/distributedlog/impl/TestZKNamespaceWatcher.java","status":"modified","additions":0,"deletions":1,"changes":1,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fimpl%2FTestZKNamespaceWatcher.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fimpl%2FTestZKNamespaceWatcher.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fimpl%2FTestZKNamespaceWatcher.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3"},{"sha":"c81eb1da95adc8abe3d0b0e4653903589ef32328","filename":"src/test/java/org/apache/distributedlog/impl/federated/TestFederatedZKLogMetadataStore.java","status":"modified","additions":34,"deletions":36,"changes":70,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fimpl%2Ffederated%2FTestFederatedZKLogMetadataStore.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fimpl%2Ffederated%2FTestFederatedZKLogMetadataStore.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fimpl%2Ffederated%2FTestFederatedZKLogMetadataStore.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3"},{"sha":"a70edf5b2d11d58b662d9143ad12a5e91bc66733","filename":"src/test/java/org/apache/distributedlog/impl/logsegment/TestBKLogSegmentEntryReader.java","status":"modified","additions":28,"deletions":29,"changes":57,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fimpl%2Flogsegment%2FTestBKLogSegmentEntryReader.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fimpl%2Flogsegment%2FTestBKLogSegmentEntryReader.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fimpl%2Flogsegment%2FTestBKLogSegmentEntryReader.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3"},{"sha":"813501b86e8434c82e4824e35dfe70321740c620","filename":"src/test/java/org/apache/distributedlog/impl/metadata/TestZKLogStreamMetadataStore.java","status":"modified","additions":9,"deletions":11,"changes":20,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fimpl%2Fmetadata%2FTestZKLogStreamMetadataStore.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fimpl%2Fmetadata%2FTestZKLogStreamMetadataStore.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fimpl%2Fmetadata%2FTestZKLogStreamMetadataStore.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3"},{"sha":"26cf979366bd4f7c93d4172da2f0d42bf53cbba3","filename":"src/test/java/org/apache/distributedlog/lock/TestDistributedLock.java","status":"modified","additions":68,"deletions":70,"changes":138,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Flock%2FTestDistributedLock.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Flock%2FTestDistributedLock.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Flock%2FTestDistributedLock.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3"},{"sha":"51891043185a36cf2c83ad43462ea2b12dc3e88b","filename":"src/test/java/org/apache/distributedlog/lock/TestZKSessionLock.java","status":"modified","additions":45,"deletions":46,"changes":91,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Flock%2FTestZKSessionLock.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Flock%2FTestZKSessionLock.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Flock%2FTestZKSessionLock.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3"},{"sha":"6687b7bf0d4d1244348f407ae3242b7f1cd5e4b3","filename":"src/test/java/org/apache/distributedlog/logsegment/TestRollingPolicy.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Flogsegment%2FTestRollingPolicy.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Flogsegment%2FTestRollingPolicy.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Flogsegment%2FTestRollingPolicy.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3"},{"sha":"2090828a8d6b635cbdcbfeb8fd628ab59542c69a","filename":"src/test/java/org/apache/distributedlog/metadata/TestLogSegmentMetadataStoreUpdater.java","status":"modified","additions":14,"deletions":15,"changes":29,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fmetadata%2FTestLogSegmentMetadataStoreUpdater.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fmetadata%2FTestLogSegmentMetadataStoreUpdater.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fmetadata%2FTestLogSegmentMetadataStoreUpdater.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3"},{"sha":"89b48529a3181a166ac94da75a006ec940e26cb8","filename":"src/test/java/org/apache/distributedlog/namespace/TestNamespaceBuilder.java","status":"renamed","additions":13,"deletions":11,"changes":24,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fnamespace%2FTestNamespaceBuilder.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fnamespace%2FTestNamespaceBuilder.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fnamespace%2FTestNamespaceBuilder.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3","previous_filename":"src/test/java/org/apache/distributedlog/namespace/TestDistributedLogNamespaceBuilder.java"},{"sha":"8949bec83d597d8788d37dd49af133390f43b465","filename":"src/test/java/org/apache/distributedlog/rate/TestMovingAverageRate.java","status":"removed","additions":0,"deletions":99,"changes":99,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/46e6b70feda2e8ad61ba13928df93b2c94d3dd4e/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Frate%2FTestMovingAverageRate.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/46e6b70feda2e8ad61ba13928df93b2c94d3dd4e/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Frate%2FTestMovingAverageRate.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Frate%2FTestMovingAverageRate.java?ref=46e6b70feda2e8ad61ba13928df93b2c94d3dd4e"},{"sha":"71bf68d9e2c327ddf04cf7ec0412dc736dbd0093","filename":"src/test/java/org/apache/distributedlog/tools/TestDistributedLogTool.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Ftools%2FTestDistributedLogTool.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Ftools%2FTestDistributedLogTool.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Ftools%2FTestDistributedLogTool.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3"},{"sha":"f9e4eb8cb47ab968fdb226cf0964064f6d95e67d","filename":"src/test/java/org/apache/distributedlog/util/TestFutureUtils.java","status":"removed","additions":0,"deletions":71,"changes":71,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/46e6b70feda2e8ad61ba13928df93b2c94d3dd4e/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Futil%2FTestFutureUtils.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/46e6b70feda2e8ad61ba13928df93b2c94d3dd4e/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Futil%2FTestFutureUtils.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Futil%2FTestFutureUtils.java?ref=46e6b70feda2e8ad61ba13928df93b2c94d3dd4e"},{"sha":"807ce02223ad8536622d0a69281a7f1f0a888075","filename":"src/test/java/org/apache/distributedlog/util/TestPermitManager.java","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Futil%2FTestPermitManager.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Futil%2FTestPermitManager.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Futil%2FTestPermitManager.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3"},{"sha":"7bfe5eda6c2966b7eb2d175b1b3a36bed81e8c72","filename":"src/test/java/org/apache/distributedlog/util/TestSafeQueueingFuturePool.java","status":"removed","additions":0,"deletions":205,"changes":205,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/46e6b70feda2e8ad61ba13928df93b2c94d3dd4e/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Futil%2FTestSafeQueueingFuturePool.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/46e6b70feda2e8ad61ba13928df93b2c94d3dd4e/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Futil%2FTestSafeQueueingFuturePool.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Futil%2FTestSafeQueueingFuturePool.java?ref=46e6b70feda2e8ad61ba13928df93b2c94d3dd4e"},{"sha":"acd441cff26b353efb91df6e9ff99cd629dc60fd","filename":"src/test/java/org/apache/distributedlog/util/TestUtils.java","status":"modified","additions":3,"deletions":3,"changes":6,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Futil%2FTestUtils.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b4770a090a95802250dc69b13487eeb7ff6e0bb3/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Futil%2FTestUtils.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Futil%2FTestUtils.java?ref=b4770a090a95802250dc69b13487eeb7ff6e0bb3"}]}