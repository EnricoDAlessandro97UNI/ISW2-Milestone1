{"sha":"b42a8c34511612bef539d30d7ade5f68234297af","node_id":"MDY6Q29tbWl0NDc4NTkyNTI2OmI0MmE4YzM0NTExNjEyYmVmNTM5ZDMwZDdhZGU1ZjY4MjM0Mjk3YWY=","commit":{"author":{"name":"Yiming Zang","email":"yzang@twitter.com","date":"2016-08-12T17:30:39Z"},"committer":{"name":"Sijie Guo","email":"sijieg@twitter.com","date":"2016-12-28T00:49:28Z"},"message":"DL-106: Use namespace after it is closed will throw AlreadyClosedException","tree":{"sha":"f7ca3e6f6aad65bf1f9e2e5b428ea993d5f0ceb7","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/trees/f7ca3e6f6aad65bf1f9e2e5b428ea993d5f0ceb7"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/commits/b42a8c34511612bef539d30d7ade5f68234297af","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/b42a8c34511612bef539d30d7ade5f68234297af","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/b42a8c34511612bef539d30d7ade5f68234297af","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/b42a8c34511612bef539d30d7ade5f68234297af/comments","author":null,"committer":null,"parents":[{"sha":"1eb1b1e94407de828694c1caead6b865b7e28887","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/1eb1b1e94407de828694c1caead6b865b7e28887","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/1eb1b1e94407de828694c1caead6b865b7e28887"}],"stats":{"total":115,"additions":101,"deletions":14},"files":[{"sha":"cae6f6a1a87ba3f7acc562eb168636f4b917205c","filename":"src/main/java/com/twitter/distributedlog/BKDistributedLogNamespace.java","status":"modified","additions":29,"deletions":14,"changes":43,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b42a8c34511612bef539d30d7ade5f68234297af/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FBKDistributedLogNamespace.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b42a8c34511612bef539d30d7ade5f68234297af/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FBKDistributedLogNamespace.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FBKDistributedLogNamespace.java?ref=b42a8c34511612bef539d30d7ade5f68234297af","patch":"@@ -32,6 +32,7 @@\n import com.twitter.distributedlog.bk.LedgerAllocatorUtils;\n import com.twitter.distributedlog.callback.NamespaceListener;\n import com.twitter.distributedlog.config.DynamicDistributedLogConfiguration;\n+import com.twitter.distributedlog.exceptions.AlreadyClosedException;\n import com.twitter.distributedlog.exceptions.DLInterruptedException;\n import com.twitter.distributedlog.exceptions.InvalidStreamNameException;\n import com.twitter.distributedlog.exceptions.LogNotFoundException;\n@@ -86,6 +87,7 @@\n import java.util.Map;\n import java.util.concurrent.Executors;\n import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n \n import static com.twitter.distributedlog.impl.BKDLUtils.*;\n \n@@ -317,7 +319,7 @@ private static String getHostIpLockClientId() {\n     private final StatsLogger perLogStatsLogger;\n     private final ReadAheadExceptionsLogger readAheadExceptionsLogger;\n \n-    protected boolean closed = false;\n+    protected AtomicBoolean closed = new AtomicBoolean(false);\n \n     private final PermitLimiter writeLimiter;\n \n@@ -494,6 +496,7 @@ private BKDistributedLogNamespace(\n     @Override\n     public void createLog(String logName)\n             throws InvalidStreamNameException, IOException {\n+        checkState();\n         validateName(logName);\n         URI uri = FutureUtils.result(metadataStore.createLog(logName));\n         createUnpartitionedStreams(conf, uri, Lists.newArrayList(logName));\n@@ -502,6 +505,7 @@ public void createLog(String logName)\n     @Override\n     public void deleteLog(String logName)\n             throws InvalidStreamNameException, LogNotFoundException, IOException {\n+        checkState();\n         validateName(logName);\n         Optional<URI> uri = FutureUtils.result(metadataStore.getLogLocation(logName));\n         if (!uri.isPresent()) {\n@@ -532,6 +536,7 @@ public DistributedLogManager openLog(String logName,\n                                          Optional<DynamicDistributedLogConfiguration> dynamicLogConf,\n                                          Optional<StatsLogger> perStreamStatsLogger)\n             throws InvalidStreamNameException, IOException {\n+        checkState();\n         validateName(logName);\n         Optional<URI> uri = FutureUtils.result(metadataStore.getLogLocation(logName));\n         if (!uri.isPresent()) {\n@@ -549,12 +554,14 @@ public DistributedLogManager openLog(String logName,\n     @Override\n     public boolean logExists(String logName)\n         throws IOException, IllegalArgumentException {\n+        checkState();\n         Optional<URI> uri = FutureUtils.result(metadataStore.getLogLocation(logName));\n         return uri.isPresent() && checkIfLogExists(conf, uri.get(), logName);\n     }\n \n     @Override\n     public Iterator<String> getLogs() throws IOException {\n+        checkState();\n         return FutureUtils.result(metadataStore.getLogs());\n     }\n \n@@ -565,6 +572,7 @@ public void registerNamespaceListener(NamespaceListener listener) {\n \n     @Override\n     public synchronized AccessControlManager createAccessControlManager() throws IOException {\n+        checkState();\n         if (null == accessControlManager) {\n             String aclRootPath = bkdlConfig.getACLRootPath();\n             // Build the access control manager\n@@ -614,9 +622,9 @@ static String validateAndGetFullLedgerAllocatorPoolPath(DistributedLogConfigurat\n     }\n \n     private static ZooKeeperClientBuilder createDLZKClientBuilder(String zkcName,\n-                                                                DistributedLogConfiguration conf,\n-                                                                String zkServers,\n-                                                                StatsLogger statsLogger) {\n+                                                                  DistributedLogConfiguration conf,\n+                                                                  String zkServers,\n+                                                                  StatsLogger statsLogger) {\n         RetryPolicy retryPolicy = null;\n         if (conf.getZKNumRetries() > 0) {\n             retryPolicy = new BoundExponentialBackoffRetryPolicy(\n@@ -633,7 +641,7 @@ private static ZooKeeperClientBuilder createDLZKClientBuilder(String zkcName,\n             .statsLogger(statsLogger)\n             .zkAclId(conf.getZkAclId());\n         LOG.info(\"Created shared zooKeeper client builder {}: zkServers = {}, numRetries = {}, sessionTimeout = {}, retryBackoff = {},\"\n-                 + \" maxRetryBackoff = {}, zkAclId = {}.\", new Object[] { zkcName, zkServers, conf.getZKNumRetries(),\n+                + \" maxRetryBackoff = {}, zkAclId = {}.\", new Object[] { zkcName, zkServers, conf.getZKNumRetries(),\n                 conf.getZKSessionTimeoutMilliseconds(), conf.getZKRetryBackoffStartMillis(),\n                 conf.getZKRetryBackoffMaxMillis(), conf.getZkAclId() });\n         return builder;\n@@ -678,7 +686,7 @@ private BookKeeperClientBuilder createBKCBuilder(String bkcName,\n                 .featureProvider(featureProviderOptional)\n                 .statsLogger(statsLogger);\n         LOG.info(\"Created shared client builder {} : zkServers = {}, ledgersPath = {}, numIOThreads = {}\",\n-                 new Object[] { bkcName, zkServers, ledgersPath, conf.getBKClientNumberIOThreads() });\n+                new Object[] { bkcName, zkServers, ledgersPath, conf.getBKClientNumberIOThreads() });\n         return builder;\n     }\n \n@@ -711,6 +719,7 @@ public LedgerAllocator getLedgerAllocator() {\n      * @throws IOException\n      */\n     private <T> T withZooKeeperClient(ZooKeeperClientHandler<T> handler) throws IOException {\n+        checkState();\n         return handler.handle(sharedWriterZKCForDL);\n     }\n \n@@ -815,6 +824,7 @@ protected DistributedLogManager createDistributedLogManager(\n             Optional<StatsLogger> perStreamStatsLogger)\n         throws InvalidStreamNameException, IOException {\n         // Make sure the name is well formed\n+        checkState();\n         validateName(nameOfLogStream);\n \n         DistributedLogConfiguration mergedConfiguration = new DistributedLogConfiguration();\n@@ -918,6 +928,7 @@ public MetadataAccessor createMetadataAccessor(String nameOfMetadataNode)\n         if (bkdlConfig.isFederatedNamespace()) {\n             throw new UnsupportedOperationException(\"Use DistributedLogNamespace methods for federated namespace\");\n         }\n+        checkState();\n         validateName(nameOfMetadataNode);\n         return new ZKMetadataAccessor(nameOfMetadataNode, conf, namespace,\n                 sharedWriterZKCBuilderForDL, sharedReaderZKCBuilderForDL, statsLogger);\n@@ -1035,6 +1046,13 @@ public Void handle(ZooKeeperClient zkc) throws IOException {\n         }, conf, uri);\n     }\n \n+    private void checkState() throws IOException {\n+        if (closed.get()) {\n+            LOG.error(\"BKDistributedLogNamespace {} is already closed\", namespace);\n+            throw new AlreadyClosedException(\"Namespace \" + namespace + \" is already closed\");\n+        }\n+    }\n+\n     /**\n      * Close the distributed log manager factory, freeing any resources it may hold.\n      */\n@@ -1043,16 +1061,13 @@ public void close() {\n         ZooKeeperClient writerZKC;\n         ZooKeeperClient readerZKC;\n         AccessControlManager acm;\n-        synchronized (this) {\n-            if (closed) {\n-                return;\n-            }\n-            closed = true;\n+        if (closed.compareAndSet(false, true)) {\n             writerZKC = sharedWriterZKCForBK;\n             readerZKC = sharedReaderZKCForBK;\n             acm = accessControlManager;\n+        } else {\n+            return;\n         }\n-\n         if (null != acm) {\n             acm.close();\n             LOG.info(\"Access Control Manager Stopped.\");\n@@ -1070,11 +1085,11 @@ public void close() {\n \n         // Shutdown the schedulers\n         SchedulerUtils.shutdownScheduler(scheduler, conf.getSchedulerShutdownTimeoutMs(),\n-                TimeUnit.MILLISECONDS);\n+            TimeUnit.MILLISECONDS);\n         LOG.info(\"Executor Service Stopped.\");\n         if (scheduler != readAheadExecutor) {\n             SchedulerUtils.shutdownScheduler(readAheadExecutor, conf.getSchedulerShutdownTimeoutMs(),\n-                    TimeUnit.MILLISECONDS);\n+                TimeUnit.MILLISECONDS);\n             LOG.info(\"ReadAhead Executor Service Stopped.\");\n         }\n "},{"sha":"e68b9168cb6bc1f6030d45c37c79ff302713634c","filename":"src/test/java/com/twitter/distributedlog/TestBKDistributedLogNamespace.java","status":"modified","additions":72,"deletions":0,"changes":72,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b42a8c34511612bef539d30d7ade5f68234297af/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestBKDistributedLogNamespace.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b42a8c34511612bef539d30d7ade5f68234297af/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestBKDistributedLogNamespace.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestBKDistributedLogNamespace.java?ref=b42a8c34511612bef539d30d7ade5f68234297af","patch":"@@ -30,6 +30,7 @@\n \n import com.google.common.collect.Sets;\n import com.twitter.distributedlog.callback.NamespaceListener;\n+import com.twitter.distributedlog.exceptions.AlreadyClosedException;\n import com.twitter.distributedlog.exceptions.InvalidStreamNameException;\n import com.twitter.distributedlog.exceptions.LockingException;\n import com.twitter.distributedlog.exceptions.ZKException;\n@@ -41,6 +42,7 @@\n import org.apache.zookeeper.ZooDefs;\n import org.apache.zookeeper.data.Stat;\n import org.junit.After;\n+import org.junit.Assert;\n import org.junit.Before;\n import org.junit.Rule;\n import org.junit.Test;\n@@ -419,4 +421,74 @@ public void testValidateAndGetFullLedgerAllocatorPoolPath() throws Exception {\n         testConf.setLedgerAllocatorPoolName(null);\n         validateBadAllocatorConfiguration(testConf, uri);\n     }\n+\n+    @Test(timeout = 60000)\n+    public void testUseNamespaceAfterCloseShouldFailFast() throws Exception {\n+        URI uri = createDLMURI(\"/\" + runtime.getMethodName());\n+        BKDistributedLogNamespace namespace = BKDistributedLogNamespace.newBuilder()\n+            .conf(conf)\n+            .uri(uri)\n+            .build();\n+        // before closing the namespace, no exception should be thrown\n+        String logName = \"test-stream\";\n+        // create a log\n+        namespace.createLog(logName);\n+        // log exists\n+        Assert.assertTrue(namespace.logExists(logName));\n+        // create a dlm\n+        DistributedLogManager dlm = namespace.openLog(logName);\n+        // do some writes\n+        BKAsyncLogWriter writer = (BKAsyncLogWriter) (dlm.startAsyncLogSegmentNonPartitioned());\n+        for (long i = 0; i < 3; i++) {\n+            LogRecord record = DLMTestUtil.getLargeLogRecordInstance(i);\n+            writer.write(record);\n+        }\n+        writer.closeAndComplete();\n+        // do some reads\n+        LogReader reader = dlm.getInputStream(0);\n+        for (long i = 0; i < 3; i++) {\n+            Assert.assertEquals(reader.readNext(false).getTransactionId(), i);\n+        }\n+        namespace.deleteLog(logName);\n+        Assert.assertFalse(namespace.logExists(logName));\n+\n+        // now try to close the namespace\n+        namespace.close();\n+        try {\n+            namespace.createLog(logName);\n+            fail(\"Should throw exception after namespace is closed\");\n+        } catch (AlreadyClosedException e) {\n+            // No-ops\n+        }\n+        try {\n+            namespace.openLog(logName);\n+            fail(\"Should throw exception after namespace is closed\");\n+        } catch (AlreadyClosedException e) {\n+            // No-ops\n+        }\n+        try {\n+            namespace.logExists(logName);\n+            fail(\"Should throw exception after namespace is closed\");\n+        } catch (AlreadyClosedException e) {\n+            // No-ops\n+        }\n+        try {\n+            namespace.getLogs();\n+            fail(\"Should throw exception after namespace is closed\");\n+        } catch (AlreadyClosedException e) {\n+            // No-ops\n+        }\n+        try {\n+            namespace.deleteLog(logName);\n+            fail(\"Should throw exception after namespace is closed\");\n+        } catch (AlreadyClosedException e) {\n+            // No-ops\n+        }\n+        try {\n+            namespace.createAccessControlManager();\n+            fail(\"Should throw exception after namespace is closed\");\n+        } catch (AlreadyClosedException e) {\n+            // No-ops\n+        }\n+    }\n }"}]}