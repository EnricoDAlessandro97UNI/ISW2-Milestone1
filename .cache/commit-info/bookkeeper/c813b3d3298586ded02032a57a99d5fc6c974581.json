{"sha":"c813b3d3298586ded02032a57a99d5fc6c974581","node_id":"MDY6Q29tbWl0NDc4NTkyNTI2OmM4MTNiM2QzMjk4NTg2ZGVkMDIwMzJhNTdhOTlkNWZjNmM5NzQ1ODE=","commit":{"author":{"name":"JV","email":"vjujjuri@salesforce.com","date":"2017-01-31T03:01:48Z"},"committer":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2017-01-31T03:01:48Z"},"message":"BOOKKEEPER-874: Explict LAC from Writer to Bookies\n\nIntroduce a new feature for sending explicit LAC to bookies.\nA writable LedgerHandle creates a timer thread to send explicit LACs\nat the intervals specified through configuration paramenter,\nexplicitLacInterval. If this is set to zero, this feature is disabled,\nno timer thread is created.\n\nExplicit LAC is sent only if the client did not get a chance to send\nLAC through piggyback method for \"explicitLacInterval\" time.\nTo implement this, introduced two new protocol messages to the\nBookkeeper protocol -  WRITE_LAC and READ_LAC, in addition to its\ncurrent READ_ENTRY and ADD_ENTRY.\n\nReviewed-by: Charan Reddy Guttapalem <cguttapalemsalesforce.com>\nSigned-off-by: Venkateswararao Jujjuri (JV) <vjujjurisalesforce.com>\nCo-Author : Charan Reddy Guttapalem <cguttapalemsalesforce.com>\n\nAuthor: JV <vjujjuri@salesforce.com>\n\nReviewers: Sijie Guo <sijie@apache.org>\n\nCloses #89 from reddycharan/explicitlacsinglecommit","tree":{"sha":"ec09df8672ca6bf63684e6f9f462c4cbc95c48de","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/trees/ec09df8672ca6bf63684e6f9f462c4cbc95c48de"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/commits/c813b3d3298586ded02032a57a99d5fc6c974581","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/c813b3d3298586ded02032a57a99d5fc6c974581","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/c813b3d3298586ded02032a57a99d5fc6c974581","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/c813b3d3298586ded02032a57a99d5fc6c974581/comments","author":{"login":"jvrao","id":41390,"node_id":"MDQ6VXNlcjQxMzkw","avatar_url":"https://avatars.githubusercontent.com/u/41390?v=4","gravatar_id":"","url":"https://api.github.com/users/jvrao","html_url":"https://github.com/jvrao","followers_url":"https://api.github.com/users/jvrao/followers","following_url":"https://api.github.com/users/jvrao/following{/other_user}","gists_url":"https://api.github.com/users/jvrao/gists{/gist_id}","starred_url":"https://api.github.com/users/jvrao/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jvrao/subscriptions","organizations_url":"https://api.github.com/users/jvrao/orgs","repos_url":"https://api.github.com/users/jvrao/repos","events_url":"https://api.github.com/users/jvrao/events{/privacy}","received_events_url":"https://api.github.com/users/jvrao/received_events","type":"User","site_admin":false},"committer":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"parents":[{"sha":"42e8f1294f206cbe51a6af669cf605833b78bf42","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/42e8f1294f206cbe51a6af669cf605833b78bf42","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/42e8f1294f206cbe51a6af669cf605833b78bf42"}],"stats":{"total":7847,"additions":6354,"deletions":1493},"files":[{"sha":"c7fd2ca11d124fdc54de756962ad411da1d03625","filename":"bookkeeper-server/conf/bk_server.conf","status":"modified","additions":3,"deletions":0,"changes":3,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/c813b3d3298586ded02032a57a99d5fc6c974581/bookkeeper-server%2Fconf%2Fbk_server.conf","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/c813b3d3298586ded02032a57a99d5fc6c974581/bookkeeper-server%2Fconf%2Fbk_server.conf","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fconf%2Fbk_server.conf?ref=c813b3d3298586ded02032a57a99d5fc6c974581","patch":"@@ -91,6 +91,9 @@ ledgerDirectories=/tmp/bk-data\n # If it is set to less than zero, the minor compaction is disabled. \n # minorCompactionInterval=3600\n \n+# Interval between sending an explicit LAC in seconds\n+explicitLacInterval = 1\n+\n # Threshold of major compaction\n # For those entry log files whose remaining size percentage reaches below\n # this threshold will be compacted in a major compaction."},{"sha":"9f1dbbb28051e10c26172fa5bdd006c3c67098b3","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BookKeeperServerStats.java","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/c813b3d3298586ded02032a57a99d5fc6c974581/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FBookKeeperServerStats.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/c813b3d3298586ded02032a57a99d5fc6c974581/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FBookKeeperServerStats.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FBookKeeperServerStats.java?ref=c813b3d3298586ded02032a57a99d5fc6c974581","patch":"@@ -35,6 +35,8 @@ public interface BookKeeperServerStats {\n     public final static String READ_ENTRY_FENCE_REQUEST = \"READ_ENTRY_FENCE_REQUEST\";\n     public final static String READ_ENTRY_FENCE_WAIT = \"READ_ENTRY_FENCE_WAIT\";\n     public final static String READ_ENTRY_FENCE_READ = \"READ_ENTRY_FENCE_READ\";\n+    public final static String WRITE_LAC = \"WRITE_LAC\";\n+    public final static String READ_LAC = \"READ_LAC\";\n \n     // Bookie Operations\n     public final static String BOOKIE_ADD_ENTRY_BYTES = \"BOOKIE_ADD_ENTRY_BYTES\";"},{"sha":"bbbfa51ebca267df97edd1fd8abe85443b0b274b","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java","status":"modified","additions":26,"deletions":0,"changes":26,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/c813b3d3298586ded02032a57a99d5fc6c974581/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FBookie.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/c813b3d3298586ded02032a57a99d5fc6c974581/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FBookie.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FBookie.java?ref=c813b3d3298586ded02032a57a99d5fc6c974581","patch":"@@ -57,6 +57,7 @@\n import org.apache.bookkeeper.net.BookieSocketAddress;\n import org.apache.bookkeeper.net.DNS;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteCallback;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteLacCallback;\n import org.apache.bookkeeper.stats.Counter;\n import org.apache.bookkeeper.stats.Gauge;\n import org.apache.bookkeeper.stats.NullStatsLogger;\n@@ -1325,6 +1326,30 @@ public void recoveryAddEntry(ByteBuffer entry, WriteCallback cb, Object ctx, byt\n         }\n     }\n \n+    public void setExplicitLac(ByteBuffer entry, Object ctx, byte[] masterKey)\n+            throws IOException, BookieException {\n+        try {\n+            long ledgerId = entry.getLong();\n+            LedgerDescriptor handle = handles.getHandle(ledgerId, masterKey);\n+            entry.rewind();\n+            synchronized (handle) {\n+                handle.setExplicitLac(entry);\n+            }\n+        } catch (NoWritableLedgerDirException e) {\n+            transitionToReadOnlyMode();\n+            throw new IOException(e);\n+        }\n+    }\n+\n+    public ByteBuffer getExplicitLac(long ledgerId) throws IOException, Bookie.NoLedgerException {\n+        ByteBuffer lac;\n+        LedgerDescriptor handle = handles.getReadOnlyHandle(ledgerId);\n+        synchronized (handle) {\n+            lac = handle.getExplicitLac();\n+        }\n+        return lac;\n+    }\n+\n     /**\n      * Add entry to a ledger.\n      * @throws BookieException.LedgerFencedException if the ledger is fenced\n@@ -1566,4 +1591,5 @@ public static void main(String[] args)\n     public int getExitCode() {\n         return exitCode;\n     }\n+\n }"},{"sha":"307b46b5093e2fa382ff5108478dc57331784257","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/FileInfo.java","status":"modified","additions":33,"deletions":0,"changes":33,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/c813b3d3298586ded02032a57a99d5fc6c974581/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FFileInfo.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/c813b3d3298586ded02032a57a99d5fc6c974581/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FFileInfo.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FFileInfo.java?ref=c813b3d3298586ded02032a57a99d5fc6c974581","patch":"@@ -62,6 +62,8 @@ class FileInfo {\n \n     private FileChannel fc;\n     private File lf;\n+    private ByteBuffer explicitLac = null;\n+\n     byte[] masterKey;\n \n     /**\n@@ -112,6 +114,37 @@ public long getSizeSinceLastwrite() {\n         return sizeSinceLastwrite;\n     }\n \n+    public ByteBuffer getExplicitLac() {\n+        LOG.debug(\"fileInfo:GetLac: {}\", explicitLac);\n+        ByteBuffer retLac = null;\n+        synchronized(this) {\n+            if (explicitLac != null) {\n+                retLac = ByteBuffer.allocate(explicitLac.capacity());\n+                explicitLac.rewind();//copy from the beginning\n+                retLac.put(explicitLac);\n+                explicitLac.rewind();\n+                retLac.flip();\n+            }\n+        }\n+        return retLac;\n+    }\n+\n+    public void setExplicitLac(ByteBuffer lac) {\n+        synchronized(this) {\n+            if (explicitLac == null) {\n+                explicitLac = ByteBuffer.allocate(lac.capacity());\n+            }\n+            explicitLac.put(lac);\n+            explicitLac.rewind();\n+            \n+            long ledgerId = explicitLac.getLong();            \n+            long explicitLacValue = explicitLac.getLong();\n+            setLastAddConfirmed(explicitLacValue);\n+            explicitLac.rewind();\n+        }\n+        LOG.debug(\"fileInfo:SetLac: {}\", explicitLac);\n+    }\n+\n     synchronized public void readHeader() throws IOException {\n         if (lf.exists()) {\n             if (fc != null) {"},{"sha":"1ea000c9e103b1df92fa61f168be28f6ed1a6878","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/IndexPersistenceMgr.java","status":"modified","additions":28,"deletions":0,"changes":28,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/c813b3d3298586ded02032a57a99d5fc6c974581/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FIndexPersistenceMgr.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/c813b3d3298586ded02032a57a99d5fc6c974581/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FIndexPersistenceMgr.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FIndexPersistenceMgr.java?ref=c813b3d3298586ded02032a57a99d5fc6c974581","patch":"@@ -389,6 +389,34 @@ boolean isFenced(long ledgerId) throws IOException {\n         }\n     }\n \n+    void setExplicitLac(long ledgerId, ByteBuffer lac) throws IOException {\n+        FileInfo fi = null;\n+        try {\n+            fi = getFileInfo(ledgerId, null);\n+            fi.setExplicitLac(lac);\n+            return;\n+        } finally {\n+            if (null != fi) {\n+                fi.release();\n+            }\n+        }\n+    }\n+\n+    public ByteBuffer getExplicitLac(long ledgerId) {\n+        FileInfo fi = null;\n+        try {\n+            fi = getFileInfo(ledgerId, null);\n+            return fi.getExplicitLac();\n+        } catch (IOException e) {\n+            LOG.error(\"Exception during getLastAddConfirmed: {}\", e);\n+            return null;\n+        } finally {\n+            if (null != fi) {\n+                fi.release();\n+            }\n+        }\n+    }\n+\n     int getOpenFileLimit() {\n         return openFileLimit;\n     }"},{"sha":"308110bcc93f09db9b2a4be204f7a5b10b692fa9","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/InterleavedLedgerStorage.java","status":"modified","additions":8,"deletions":0,"changes":8,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/c813b3d3298586ded02032a57a99d5fc6c974581/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FInterleavedLedgerStorage.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/c813b3d3298586ded02032a57a99d5fc6c974581/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FInterleavedLedgerStorage.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FInterleavedLedgerStorage.java?ref=c813b3d3298586ded02032a57a99d5fc6c974581","patch":"@@ -215,6 +215,14 @@ public boolean isFenced(long ledgerId) throws IOException {\n         return ledgerCache.isFenced(ledgerId);\n     }\n \n+    public void setExplicitlac(long ledgerId, ByteBuffer lac) throws IOException {\n+        ledgerCache.setExplicitLac(ledgerId, lac);\n+    }\n+\n+    public ByteBuffer getExplicitLac(long ledgerId) {\n+        return ledgerCache.getExplicitLac(ledgerId);\n+    }\n+\n     @Override\n     public void setMasterKey(long ledgerId, byte[] masterKey) throws IOException {\n         ledgerCache.setMasterKey(ledgerId, masterKey);"},{"sha":"e004cb6ffbe86df52adb46502381a9e3fb146280","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCache.java","status":"modified","additions":3,"deletions":0,"changes":3,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/c813b3d3298586ded02032a57a99d5fc6c974581/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLedgerCache.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/c813b3d3298586ded02032a57a99d5fc6c974581/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLedgerCache.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLedgerCache.java?ref=c813b3d3298586ded02032a57a99d5fc6c974581","patch":"@@ -23,6 +23,7 @@\n \n import java.io.Closeable;\n import java.io.IOException;\n+import java.nio.ByteBuffer;\n \n /**\n  * This class maps a ledger entry number into a location (entrylogid, offset) in\n@@ -50,4 +51,6 @@ interface LedgerCache extends Closeable {\n     void deleteLedger(long ledgerId) throws IOException;\n \n     LedgerCacheBean getJMXBean();\n+    void setExplicitLac(long ledgerId, ByteBuffer lac) throws IOException;\n+    ByteBuffer getExplicitLac(long ledgerId);\n }"},{"sha":"cece79fa0bc0951892108918d39fe200d8e4fe25","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCacheImpl.java","status":"modified","additions":9,"deletions":0,"changes":9,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/c813b3d3298586ded02032a57a99d5fc6c974581/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLedgerCacheImpl.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/c813b3d3298586ded02032a57a99d5fc6c974581/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLedgerCacheImpl.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLedgerCacheImpl.java?ref=c813b3d3298586ded02032a57a99d5fc6c974581","patch":"@@ -22,6 +22,7 @@\n package org.apache.bookkeeper.bookie;\n \n import java.io.IOException;\n+import java.nio.ByteBuffer;\n \n import org.apache.bookkeeper.conf.ServerConfiguration;\n import org.apache.bookkeeper.stats.NullStatsLogger;\n@@ -136,6 +137,14 @@ public boolean isFenced(long ledgerId) throws IOException {\n         return indexPersistenceManager.isFenced(ledgerId);\n     }\n \n+    public void setExplicitLac(long ledgerId, ByteBuffer lac) throws IOException {\n+        indexPersistenceManager.setExplicitLac(ledgerId, lac);\n+    }\n+\n+    public ByteBuffer getExplicitLac(long ledgerId) {\n+        return indexPersistenceManager.getExplicitLac(ledgerId);\n+    }\n+\n     @Override\n     public void setMasterKey(long ledgerId, byte[] masterKey) throws IOException {\n         indexPersistenceManager.setMasterKey(ledgerId, masterKey);"},{"sha":"bcb0c30f5435f4b16ee3b86abff376e2467215e8","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDescriptor.java","status":"modified","additions":5,"deletions":0,"changes":5,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/c813b3d3298586ded02032a57a99d5fc6c974581/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLedgerDescriptor.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/c813b3d3298586ded02032a57a99d5fc6c974581/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLedgerDescriptor.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLedgerDescriptor.java?ref=c813b3d3298586ded02032a57a99d5fc6c974581","patch":"@@ -59,5 +59,10 @@ static LedgerDescriptor createReadOnly(long ledgerId,\n \n     abstract long addEntry(ByteBuffer entry) throws IOException;\n     abstract ByteBuffer readEntry(long entryId) throws IOException;\n+\n     abstract long getLastAddConfirmed() throws IOException;\n+\n+    abstract void setExplicitLac(ByteBuffer entry) throws IOException;\n+\n+    abstract  ByteBuffer getExplicitLac();\n }"},{"sha":"bf1c1297d2b911cc8426d18d3ca2ab4f6db7a825","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDescriptorImpl.java","status":"modified","additions":9,"deletions":0,"changes":9,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/c813b3d3298586ded02032a57a99d5fc6c974581/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLedgerDescriptorImpl.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/c813b3d3298586ded02032a57a99d5fc6c974581/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLedgerDescriptorImpl.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLedgerDescriptorImpl.java?ref=c813b3d3298586ded02032a57a99d5fc6c974581","patch":"@@ -68,6 +68,15 @@ boolean isFenced() throws IOException {\n         return ledgerStorage.isFenced(ledgerId);\n     }\n \n+    @Override\n+    void setExplicitLac(ByteBuffer lac) throws IOException {\n+        ledgerStorage.setExplicitlac(ledgerId, lac);\n+    }\n+\n+    @Override\n+    ByteBuffer getExplicitLac() {\n+        return ledgerStorage.getExplicitLac(ledgerId);\n+    }\n     @Override\n     long addEntry(ByteBuffer entry) throws IOException {\n         long ledgerId = entry.getLong();"},{"sha":"84a309f819de664a12d130142359eda2694cb8cf","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerStorage.java","status":"modified","additions":4,"deletions":0,"changes":4,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/c813b3d3298586ded02032a57a99d5fc6c974581/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLedgerStorage.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/c813b3d3298586ded02032a57a99d5fc6c974581/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLedgerStorage.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLedgerStorage.java?ref=c813b3d3298586ded02032a57a99d5fc6c974581","patch":"@@ -149,4 +149,8 @@ public void initialize(ServerConfiguration conf, LedgerManager ledgerManager,\n      * Get the JMX management bean for this LedgerStorage\n      */\n     BKMBeanInfo getJMXBean();\n+\n+    void setExplicitlac(long ledgerId, ByteBuffer lac) throws IOException;\n+\n+    ByteBuffer getExplicitLac(long ledgerId);\n }"},{"sha":"05067d021b60a9a263f5d8ddc922327a4ada044f","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/AsyncCallback.java","status":"modified","additions":14,"deletions":0,"changes":14,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/c813b3d3298586ded02032a57a99d5fc6c974581/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FAsyncCallback.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/c813b3d3298586ded02032a57a99d5fc6c974581/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FAsyncCallback.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FAsyncCallback.java?ref=c813b3d3298586ded02032a57a99d5fc6c974581","patch":"@@ -36,6 +36,20 @@ public interface AddCallback {\n         void addComplete(int rc, LedgerHandle lh, long entryId, Object ctx);\n     }\n \n+    public interface AddLacCallback {\n+        /**\n+         * Callback declaration\n+         *\n+         * @param rc\n+         *          return code\n+         * @param lh\n+         *          ledger handle\n+         * @param ctx\n+         *          context object\n+         */\n+        void addLacComplete(int rc, LedgerHandle lh, Object ctx);\n+    }\n+\n     public interface CloseCallback {\n         /**\n          * Callback definition"},{"sha":"2377c1c4bec4c6e413d1146935357038def292e0","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BKException.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/c813b3d3298586ded02032a57a99d5fc6c974581/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBKException.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/c813b3d3298586ded02032a57a99d5fc6c974581/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBKException.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBKException.java?ref=c813b3d3298586ded02032a57a99d5fc6c974581","patch":"@@ -40,7 +40,7 @@ public abstract class BKException extends Exception {\n     /**\n      * Create an exception from an error code\n      * @param code return error code\n-     * @return correponding exception\n+     * @return corresponding exception\n      */\n     public static BKException create(int code) {\n         switch (code) {"},{"sha":"8959462265422fc7fd25977de60553b200b0b4ed","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeper.java","status":"modified","additions":19,"deletions":2,"changes":21,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/c813b3d3298586ded02032a57a99d5fc6c974581/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookKeeper.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/c813b3d3298586ded02032a57a99d5fc6c974581/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookKeeper.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookKeeper.java?ref=c813b3d3298586ded02032a57a99d5fc6c974581","patch":"@@ -95,6 +95,9 @@ public class BookKeeper implements AutoCloseable {\n     private OpStatsLogger deleteOpLogger;\n     private OpStatsLogger readOpLogger;\n     private OpStatsLogger addOpLogger;\n+    private OpStatsLogger writeLacOpLogger;\n+    private OpStatsLogger readLacOpLogger;\n+\n \n     // whether the socket factory is one we created, or is owned by whoever\n     // instantiated us\n@@ -121,6 +124,7 @@ public class BookKeeper implements AutoCloseable {\n     final EnsemblePlacementPolicy placementPolicy;\n \n     final ClientConfiguration conf;\n+    final int explicitLacInterval;\n \n     // Close State\n     boolean closed = false;\n@@ -275,7 +279,7 @@ public BookKeeper(ClientConfiguration conf, ZooKeeper zk, ClientSocketChannelFac\n     }\n \n     /**\n-     * Contructor for use with the builder. Other constructors also use it.\n+     * Constructor for use with the builder. Other constructors also use it.\n      */\n     private BookKeeper(ClientConfiguration conf,\n                        ZooKeeper zkc,\n@@ -369,10 +373,16 @@ private BookKeeper(ClientConfiguration conf,\n         this.ledgerManagerFactory = LedgerManagerFactory.newLedgerManagerFactory(conf, this.zk);\n         this.ledgerManager = new CleanupLedgerManager(ledgerManagerFactory.newLedgerManager());\n         this.ledgerIdGenerator = ledgerManagerFactory.newLedgerIdGenerator();\n+        this.explicitLacInterval = conf.getExplictLacInterval();\n+        LOG.debug(\"Explicit LAC Interval : {}\", this.explicitLacInterval);\n \n         scheduleBookieHealthCheckIfEnabled();\n     }\n \n+    public int getExplicitLacInterval() {\n+        return explicitLacInterval;\n+    }\n+\n     private EnsemblePlacementPolicy initializeEnsemblePlacementPolicy(ClientConfiguration conf,\n                                                                       DNSToSwitchMapping dnsResolver,\n                                                                       HashedWheelTimer timer,\n@@ -906,8 +916,11 @@ public void asyncOpenLedger(final long lId, final DigestType digestType, final b\n      * to add entries to the ledger. Any attempt to add entries will throw an\n      * exception.\n      *\n-     * Reads from the returned ledger will only be able to read entries up until\n+     * Reads from the returned ledger will be able to read entries up until\n      * the lastConfirmedEntry at the point in time at which the ledger was opened.\n+     * If an attempt is made to read beyond the ledger handle's LAC, an attempt is made\n+     * to get the latest LAC from bookies or metadata, and if the entry_id of the read request\n+     * is less than or equal to the new LAC, read will be allowed to proceed.\n      *\n      * @param lId\n      *          ledger identifier\n@@ -1199,11 +1212,15 @@ private final void initOpLoggers(StatsLogger stats) {\n         openOpLogger = stats.getOpStatsLogger(BookKeeperClientStats.OPEN_OP);\n         readOpLogger = stats.getOpStatsLogger(BookKeeperClientStats.READ_OP);\n         addOpLogger = stats.getOpStatsLogger(BookKeeperClientStats.ADD_OP);\n+        writeLacOpLogger = stats.getOpStatsLogger(BookKeeperClientStats.WRITE_LAC_OP);\n+        readLacOpLogger = stats.getOpStatsLogger(BookKeeperClientStats.READ_LAC_OP);\n     }\n \n     OpStatsLogger getCreateOpLogger() { return createOpLogger; }\n     OpStatsLogger getOpenOpLogger() { return openOpLogger; }\n     OpStatsLogger getDeleteOpLogger() { return deleteOpLogger; }\n     OpStatsLogger getReadOpLogger() { return readOpLogger; }\n     OpStatsLogger getAddOpLogger() { return addOpLogger; }\n+    OpStatsLogger getWriteLacOpLogger() { return writeLacOpLogger; }\n+    OpStatsLogger getReadLacOpLogger() { return readLacOpLogger; }\n }"},{"sha":"a02042507e4d459b420929fdc13e1e3e9a00aed1","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeperClientStats.java","status":"modified","additions":6,"deletions":0,"changes":6,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/c813b3d3298586ded02032a57a99d5fc6c974581/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookKeeperClientStats.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/c813b3d3298586ded02032a57a99d5fc6c974581/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookKeeperClientStats.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookKeeperClientStats.java?ref=c813b3d3298586ded02032a57a99d5fc6c974581","patch":"@@ -28,6 +28,8 @@ public interface BookKeeperClientStats {\n     public final static String OPEN_OP = \"LEDGER_OPEN\";\n     public final static String ADD_OP = \"ADD_ENTRY\";\n     public final static String READ_OP = \"READ_ENTRY\";\n+    public final static String WRITE_LAC_OP = \"WRITE_LAC\";\n+    public final static String READ_LAC_OP = \"READ_LAC\";\n     public final static String PENDING_ADDS = \"NUM_PENDING_ADD\";\n     public final static String ENSEMBLE_CHANGES = \"NUM_ENSEMBLE_CHANGE\";\n     public final static String LAC_UPDATE_HITS = \"LAC_UPDATE_HITS\";\n@@ -40,4 +42,8 @@ public interface BookKeeperClientStats {\n     public final static String CHANNEL_TIMEOUT_READ = \"TIMEOUT_READ_ENTRY\";\n     public final static String CHANNEL_ADD_OP = \"ADD_ENTRY\";\n     public final static String CHANNEL_TIMEOUT_ADD = \"TIMEOUT_ADD_ENTRY\";\n+    public final static String CHANNEL_WRITE_LAC_OP = \"WRITE_LAC\";\n+    public final static String CHANNEL_TIMEOUT_WRITE_LAC = \"TIMEOUT_WRITE_LAC\";\n+    public final static String CHANNEL_READ_LAC_OP = \"READ_LAC\";\n+    public final static String CHANNEL_TIMEOUT_READ_LAC = \"TIMEOUT_READ_LAC\";\n }"},{"sha":"c72f31aafe55e71a8c170a36044aefbea0fc401c","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/DigestManager.java","status":"modified","additions":55,"deletions":0,"changes":55,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/c813b3d3298586ded02032a57a99d5fc6c974581/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FDigestManager.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/c813b3d3298586ded02032a57a99d5fc6c974581/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FDigestManager.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FDigestManager.java?ref=c813b3d3298586ded02032a57a99d5fc6c974581","patch":"@@ -40,6 +40,7 @@ abstract class DigestManager {\n     static final Logger logger = LoggerFactory.getLogger(DigestManager.class);\n \n     static final int METADATA_LENGTH = 32;\n+    static final int LAC_METADATA_LENGTH = 16;\n \n     long ledgerId;\n \n@@ -102,6 +103,32 @@ public ChannelBuffer computeDigestAndPackageForSending(long entryId, long lastAd\n         return ChannelBuffers.wrappedBuffer(ChannelBuffers.wrappedBuffer(buffer), ChannelBuffers.wrappedBuffer(data, doffset, dlength));\n     }\n \n+    /**\n+     * Computes the digest for writeLac for sending.\n+     *\n+     * @param lac\n+     * @return\n+     */\n+\n+    public ChannelBuffer computeDigestAndPackageForSendingLac(long lac) {\n+\n+        byte[] bufferArray = new byte[LAC_METADATA_LENGTH + macCodeLength];\n+        ByteBuffer buffer = ByteBuffer.wrap(bufferArray);\n+        buffer.putLong(ledgerId);\n+        buffer.putLong(lac);\n+        buffer.flip();\n+\n+        update(buffer.array(), 0, LAC_METADATA_LENGTH);\n+        byte[] digest = getValueAndReset();\n+\n+        buffer.limit(buffer.capacity());\n+        buffer.position(LAC_METADATA_LENGTH);\n+        buffer.put(digest);\n+        buffer.flip();\n+\n+        return ChannelBuffers.wrappedBuffer(ChannelBuffers.wrappedBuffer(buffer));\n+    }\n+\n     private void verifyDigest(ChannelBuffer dataReceived) throws BKDigestMatchException {\n         verifyDigest(LedgerHandle.INVALID_ENTRY_ID, dataReceived, true);\n     }\n@@ -153,6 +180,34 @@ private void verifyDigest(long entryId, ChannelBuffer dataReceived, boolean skip\n \n     }\n \n+    long verifyDigestAndReturnLac(ChannelBuffer dataReceived) throws BKDigestMatchException{\n+        ByteBuffer dataReceivedBuffer = dataReceived.toByteBuffer();\n+        byte[] digest;\n+        if ((LAC_METADATA_LENGTH + macCodeLength) > dataReceived.readableBytes()) {\n+            logger.error(\"Data received is smaller than the minimum for this digest type.\"\n+                    + \" Either the packet it corrupt, or the wrong digest is configured. \"\n+                    + \" Digest type: {}, Packet Length: {}\",\n+                    this.getClass().getName(), dataReceived.readableBytes());\n+            throw new BKDigestMatchException();\n+        }\n+        update(dataReceivedBuffer.array(), dataReceivedBuffer.position(), LAC_METADATA_LENGTH);\n+        digest = getValueAndReset();\n+        for (int i = 0; i < digest.length; i++) {\n+            if (digest[i] != dataReceived.getByte(LAC_METADATA_LENGTH + i)) {\n+                logger.error(\"Mac mismatch for ledger-id LAC: \" + ledgerId);\n+                throw new BKDigestMatchException();\n+            }\n+        }\n+        long actualLedgerId = dataReceived.readLong();\n+        long lac = dataReceived.readLong();\n+        if (actualLedgerId != ledgerId) {\n+            logger.error(\"Ledger-id mismatch in authenticated message, expected: \" + ledgerId + \" , actual: \"\n+                         + actualLedgerId);\n+            throw new BKDigestMatchException();\n+        }\n+        return lac;\n+    }\n+\n     /**\n      * Verify that the digest matches and returns the data in the entry.\n      *"},{"sha":"65ef8afcfb0669d46375b153979b18ece2b43fb5","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ExplicitLacFlushPolicy.java","status":"added","additions":153,"deletions":0,"changes":153,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/c813b3d3298586ded02032a57a99d5fc6c974581/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FExplicitLacFlushPolicy.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/c813b3d3298586ded02032a57a99d5fc6c974581/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FExplicitLacFlushPolicy.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FExplicitLacFlushPolicy.java?ref=c813b3d3298586ded02032a57a99d5fc6c974581","patch":"@@ -0,0 +1,153 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.client;\n+\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+\n+import java.util.concurrent.RejectedExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+\n+import org.apache.bookkeeper.client.LedgerHandle.LastAddConfirmedCallback;\n+import org.apache.bookkeeper.util.SafeRunnable;\n+import org.jboss.netty.buffer.ChannelBuffer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+interface ExplicitLacFlushPolicy {\n+    void stopExplicitLacFlush();\n+\n+    void updatePiggyBackedLac(long piggyBackedLac);\n+\n+    static final ExplicitLacFlushPolicy VOID_EXPLICITLAC_FLUSH_POLICY = new ExplicitLacFlushPolicy() {\n+        @Override\n+        public void stopExplicitLacFlush() {\n+            // void method\n+        }\n+\n+        @Override\n+        public void updatePiggyBackedLac(long piggyBackedLac) {\n+            // void method\n+        }\n+    };\n+\n+    class ExplicitLacFlushPolicyImpl implements ExplicitLacFlushPolicy {\n+        final static Logger LOG = LoggerFactory.getLogger(ExplicitLacFlushPolicyImpl.class);\n+\n+        volatile long piggyBackedLac = LedgerHandle.INVALID_ENTRY_ID;\n+        volatile long explicitLac = LedgerHandle.INVALID_ENTRY_ID;\n+        final LedgerHandle lh;\n+        ScheduledFuture<?> scheduledFuture;\n+\n+        ExplicitLacFlushPolicyImpl(LedgerHandle lh) {\n+            this.lh = lh;\n+            scheduleExplictLacFlush();\n+            LOG.debug(\"Scheduled Explicit Last Add Confirmed Update\");\n+        }\n+\n+        private long getExplicitLac() {\n+            return explicitLac;\n+        }\n+\n+        private void setExplicitLac(long explicitLac) {\n+            this.explicitLac = explicitLac;\n+        }\n+\n+        private long getPiggyBackedLac() {\n+            return piggyBackedLac;\n+        }\n+\n+        public void setPiggyBackedLac(long piggyBackedLac) {\n+            this.piggyBackedLac = piggyBackedLac;\n+        }\n+\n+        private void scheduleExplictLacFlush() {\n+            int explicitLacIntervalInSec = lh.bk.getExplicitLacInterval();\n+            final SafeRunnable updateLacTask = new SafeRunnable() {\n+                @Override\n+                public void safeRun() {\n+                    // Made progress since previous explicitLAC through\n+                    // Piggyback, so no need to send an explicit LAC update to\n+                    // bookies.\n+                    if (getExplicitLac() < getPiggyBackedLac()) {\n+                        LOG.debug(\"ledgerid: {}\", lh.getId());\n+                        LOG.debug(\"explicitLac:{} piggybackLac:{}\", getExplicitLac(),\n+                                getPiggyBackedLac());\n+                        setExplicitLac(getPiggyBackedLac());\n+                        return;\n+                    }\n+\n+                    if (lh.getLastAddConfirmed() > getExplicitLac()) {\n+                        // Send Explicit LAC\n+                        LOG.debug(\"ledgerid: {}\", lh.getId());\n+                        asyncExplicitLacFlush(lh.getLastAddConfirmed());\n+                        setExplicitLac(lh.getLastAddConfirmed());\n+                        LOG.debug(\"After sending explict LAC lac: {}  explicitLac:{}\", lh.getLastAddConfirmed(),\n+                                getExplicitLac());\n+                    }\n+                }\n+\n+                @Override\n+                public String toString() {\n+                    return String.format(\"UpdateLacTask ledgerId - (%d)\", lh.getId());\n+                }\n+            };\n+            try {\n+                scheduledFuture = lh.bk.mainWorkerPool.scheduleAtFixedRateOrdered(lh.getId(), updateLacTask,\n+                        explicitLacIntervalInSec, explicitLacIntervalInSec, SECONDS);\n+            } catch (RejectedExecutionException re) {\n+                LOG.error(\"Scheduling of ExplictLastAddConfirmedFlush for ledger: {} has failed because of {}\",\n+                        lh.getId(), re);\n+            }\n+        }\n+\n+        /**\n+         * Make a LastAddUpdate request.\n+         */\n+        void asyncExplicitLacFlush(final long explicitLac) {\n+            final LastAddConfirmedCallback cb = LastAddConfirmedCallback.INSTANCE;\n+            final PendingWriteLacOp op = new PendingWriteLacOp(lh, cb, null);\n+            op.setLac(explicitLac);\n+            try {\n+                LOG.debug(\"Sending Explicit LAC: {}\", explicitLac);\n+                lh.bk.mainWorkerPool.submit(new SafeRunnable() {\n+                    @Override\n+                    public void safeRun() {\n+                        ChannelBuffer toSend = lh.macManager\n+                                .computeDigestAndPackageForSendingLac(lh.getLastAddConfirmed());\n+                        op.initiate(toSend);\n+                    }\n+                });\n+            } catch (RejectedExecutionException e) {\n+                cb.addLacComplete(lh.bk.getReturnRc(BKException.Code.InterruptedException), lh, null);\n+            }\n+        }\n+\n+        @Override\n+        public void stopExplicitLacFlush() {\n+            scheduledFuture.cancel(true);\n+        }\n+\n+        @Override\n+        public void updatePiggyBackedLac(long piggyBackedLac) {\n+            setPiggyBackedLac(piggyBackedLac);\n+        }\n+    }\n+}"},{"sha":"290caa9248c6f3262da22e30f30776691d55ebea","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","status":"modified","additions":134,"deletions":6,"changes":140,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/c813b3d3298586ded02032a57a99d5fc6c974581/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FLedgerHandle.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/c813b3d3298586ded02032a57a99d5fc6c974581/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FLedgerHandle.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FLedgerHandle.java?ref=c813b3d3298586ded02032a57a99d5fc6c974581","patch":"@@ -31,12 +31,14 @@\n import java.util.Map;\n import java.util.Queue;\n import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.RejectedExecutionException;\n import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicInteger;\n \n import org.apache.bookkeeper.client.AsyncCallback.AddCallback;\n+import org.apache.bookkeeper.client.AsyncCallback.AddLacCallback;\n import org.apache.bookkeeper.client.AsyncCallback.CloseCallback;\n import org.apache.bookkeeper.client.AsyncCallback.ReadCallback;\n import org.apache.bookkeeper.client.AsyncCallback.ReadLastConfirmedCallback;\n@@ -55,8 +57,6 @@\n \n import com.google.common.collect.Sets;\n import com.google.common.util.concurrent.RateLimiter;\n-import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.ExecutionException;\n \n /**\n  * Ledger handle contains ledger metadata and is used to access the read and\n@@ -71,6 +71,7 @@ public class LedgerHandle implements AutoCloseable {\n     final long ledgerId;\n     long lastAddPushed;\n     volatile long lastAddConfirmed;\n+\n     long length;\n     final DigestManager macManager;\n     final DistributionSchedule distributionSchedule;\n@@ -85,6 +86,7 @@ public class LedgerHandle implements AutoCloseable {\n \n     final AtomicInteger blockAddCompletions = new AtomicInteger(0);\n     Queue<PendingAddOp> pendingAddOps;\n+    ExplicitLacFlushPolicy explicitLacFlushPolicy;\n \n     final Counter ensembleChangeCounter;\n     final Counter lacUpdateHitsCounter;\n@@ -97,6 +99,7 @@ public class LedgerHandle implements AutoCloseable {\n         this.metadata = metadata;\n         this.pendingAddOps = new ConcurrentLinkedQueue<PendingAddOp>();\n \n+\n         if (metadata.isClosed()) {\n             lastAddConfirmed = lastAddPushed = metadata.getLastEntryId();\n             length = metadata.getLength();\n@@ -130,6 +133,15 @@ public Integer getSample() {\n                                                   return pendingAddOps.size();\n                                               }\n                                           });\n+        initializeExplicitLacFlushPolicy();\n+    }\n+\n+    protected void initializeExplicitLacFlushPolicy() {\n+        if (!metadata.isClosed() && bk.getExplicitLacInterval() > 0) {\n+            explicitLacFlushPolicy = new ExplicitLacFlushPolicy.ExplicitLacFlushPolicyImpl(this);\n+        } else {\n+            explicitLacFlushPolicy = ExplicitLacFlushPolicy.VOID_EXPLICITLAC_FLUSH_POLICY;\n+        }\n     }\n \n     /**\n@@ -272,6 +284,8 @@ public void close()\n \n         asyncClose(new SyncCloseCallback(), counter);\n \n+        explicitLacFlushPolicy.stopExplicitLacFlush();\n+        \n         SynchCallbackUtils.waitForResult(counter);\n     }\n \n@@ -478,11 +492,18 @@ public Enumeration<LedgerEntry> readEntries(long firstEntry, long lastEntry)\n      * @param ctx\n      *          control object\n      */\n-    public void asyncReadEntries(long firstEntry, long lastEntry,\n-                                 ReadCallback cb, Object ctx) {\n+    public void asyncReadEntries(long firstEntry, long lastEntry, ReadCallback cb, Object ctx) {\n         // Little sanity check\n-        if (firstEntry < 0 || lastEntry > lastAddConfirmed\n-                || firstEntry > lastEntry) {\n+        if (firstEntry < 0 || firstEntry > lastEntry) {\n+            LOG.error(\"IncorrectParameterException on ledgerId:{} firstEntry:{} lastEntry:{}\",\n+                    new Object[] { ledgerId, firstEntry, lastEntry });\n+            cb.readComplete(BKException.Code.IncorrectParameterException, this, null, ctx);\n+            return;\n+        }\n+\n+        if (lastEntry > lastAddConfirmed) {\n+            LOG.error(\"ReadException on ledgerId:{} firstEntry:{} lastEntry:{}\",\n+                    new Object[] { ledgerId, firstEntry, lastEntry });\n             cb.readComplete(BKException.Code.ReadException, this, null, ctx);\n             return;\n         }\n@@ -929,6 +950,86 @@ public long tryReadLastConfirmed() throws InterruptedException, BKException {\n         return ctx.getlastConfirmed();\n     }\n \n+    /**\n+     * Obtains asynchronously the explicit last add confirmed from a quorum of\n+     * bookies. This call obtains the the explicit last add confirmed each\n+     * bookie has received for this ledger and returns the maximum. If in the\n+     * write LedgerHandle, explicitLAC feature is not enabled then this will\n+     * return {@link #INVALID_ENTRY_ID INVALID_ENTRY_ID}. If the read explicit\n+     * lastaddconfirmed is greater than getLastAddConfirmed, then it updates the\n+     * lastAddConfirmed of this ledgerhandle. If the ledger has been closed, it\n+     * returns the value of the last add confirmed from the metadata.\n+     *\n+     * @see #getLastAddConfirmed()\n+     * \n+     * @param cb\n+     *          callback to return read explicit last confirmed\n+     * @param ctx\n+     *          callback context\n+     */\n+    public void asyncReadExplicitLastConfirmed(final ReadLastConfirmedCallback cb, final Object ctx) {\n+        boolean isClosed;\n+        synchronized (this) {\n+            isClosed = metadata.isClosed();\n+            if (isClosed) {\n+                lastAddConfirmed = metadata.getLastEntryId();\n+                length = metadata.getLength();\n+            }\n+        }\n+        if (isClosed) {\n+            cb.readLastConfirmedComplete(BKException.Code.OK, lastAddConfirmed, ctx);\n+            return;\n+        }\n+\n+        PendingReadLacOp.LacCallback innercb = new PendingReadLacOp.LacCallback() {\n+\n+            @Override\n+            public void getLacComplete(int rc, long lac) {\n+                if (rc == BKException.Code.OK) {\n+                    // here we are trying to update lac only but not length \n+                    updateLastConfirmed(lac, 0);\n+                    cb.readLastConfirmedComplete(rc, lac, ctx);\n+                } else {\n+                    cb.readLastConfirmedComplete(rc, INVALID_ENTRY_ID, ctx);\n+                }\n+            }\n+        };\n+        new PendingReadLacOp(this, innercb).initiate();\n+    }\n+\n+    /**\n+     * Obtains synchronously the explicit last add confirmed from a quorum of\n+     * bookies. This call obtains the the explicit last add confirmed each\n+     * bookie has received for this ledger and returns the maximum. If in the\n+     * write LedgerHandle, explicitLAC feature is not enabled then this will\n+     * return {@link #INVALID_ENTRY_ID INVALID_ENTRY_ID}. If the read explicit\n+     * lastaddconfirmed is greater than getLastAddConfirmed, then it updates the\n+     * lastAddConfirmed of this ledgerhandle. If the ledger has been closed, it\n+     * returns the value of the last add confirmed from the metadata.\n+     *\n+     * @see #getLastAddConfirmed()\n+     *\n+     * @return The entry id of the explicit last confirmed write or\n+     *         {@link #INVALID_ENTRY_ID INVALID_ENTRY_ID} if no entry has been\n+     *         confirmed or if explicitLAC feature is not enabled in write\n+     *         LedgerHandle.\n+     * @throws InterruptedException\n+     * @throws BKException\n+     */\n+    public long readExplicitLastConfirmed() throws InterruptedException, BKException {\n+        LastConfirmedCtx ctx = new LastConfirmedCtx();\n+        asyncReadExplicitLastConfirmed(new SyncReadLastConfirmedCallback(), ctx);\n+        synchronized (ctx) {\n+            while (!ctx.ready()) {\n+                ctx.wait();\n+            }\n+        }\n+        if (ctx.getRC() != BKException.Code.OK) {\n+            throw BKException.create(ctx.getRC());\n+        }\n+        return ctx.getlastConfirmed();\n+    }\n+\n     // close the ledger and send fails to all the adds in the pipeline\n     void handleUnrecoverableErrorDuringAdd(int rc) {\n         if (metadata.isInRecovery()) {\n@@ -976,8 +1077,11 @@ void sendAddSuccessCallbacks() {\n                 LOG.debug(\"Head of the queue entryId: {} is not lac: {} + 1\", pendingAddOp.entryId, lastAddConfirmed);\n                 return;\n             }\n+\n             pendingAddOps.remove();\n+            explicitLacFlushPolicy.updatePiggyBackedLac(lastAddConfirmed);\n             lastAddConfirmed = pendingAddOp.entryId;\n+\n             pendingAddOp.submitCallback(BKException.Code.OK);\n         }\n \n@@ -1327,6 +1431,30 @@ public void closeComplete(int rc, LedgerHandle lh, Object ctx) {\n         }\n     }\n \n+    static class LastAddConfirmedCallback implements AddLacCallback {\n+        static final LastAddConfirmedCallback INSTANCE = new LastAddConfirmedCallback();\n+        /**\n+         * Implementation of callback interface for synchronous read method.\n+         *\n+         * @param rc\n+         *          return code\n+         * @param leder\n+         *          ledger identifier\n+         * @param entry\n+         *          entry identifier\n+         * @param ctx\n+         *          control object\n+         */\n+        @Override\n+        public void addLacComplete(int rc, LedgerHandle lh, Object ctx) {\n+            if (rc != BKException.Code.OK) {\n+                LOG.warn(\"LastAddConfirmedUpdate failed: {} \", BKException.getMessage(rc));\n+            } else {\n+                LOG.debug(\"Callback LAC Updated for: {} \", lh.getId());\n+            }\n+        }\n+    }\n+\n     static class SyncReadCallback implements ReadCallback {\n         /**\n          * Implementation of callback interface for synchronous read method."},{"sha":"64e266f9a023370d7f4166e2a58b6f87f6ae3963","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingReadLacOp.java","status":"added","additions":145,"deletions":0,"changes":145,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/c813b3d3298586ded02032a57a99d5fc6c974581/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FPendingReadLacOp.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/c813b3d3298586ded02032a57a99d5fc6c974581/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FPendingReadLacOp.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FPendingReadLacOp.java?ref=c813b3d3298586ded02032a57a99d5fc6c974581","patch":"@@ -0,0 +1,145 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.bookkeeper.client;\n+\n+import org.apache.bookkeeper.client.BKException.BKDigestMatchException;\n+import org.apache.bookkeeper.client.DigestManager.RecoveryData;\n+import org.apache.bookkeeper.net.BookieSocketAddress;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ReadEntryCallback;\n+import org.apache.bookkeeper.proto.BookieProtocol;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ReadLacCallback;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.jboss.netty.buffer.ChannelBuffer;\n+\n+/**\n+ * This represents a pending ReadLac operation.\n+ *\n+ * LAC is stored in two places on bookies.\n+ * 1. WriteLac operation sends Explicit LAC and is stored in memory on each bookie.\n+ * 2. Each AddEntry operation piggy-backs LAC which is stored on bookie's disk.\n+ *\n+ * This operation returns both of those entries and we pick the latest LAC out of\n+ * available answers.\n+ *\n+ * This is an optional protocol operations to facilitate tailing readers\n+ * to be up to date with the writer. This is best effort to get latest LAC\n+ * from bookies, and doesn't affect the correctness of the protocol.\n+ */\n+\n+class PendingReadLacOp implements ReadLacCallback {\n+    static final Logger LOG = LoggerFactory.getLogger(PendingReadLacOp.class);\n+    LedgerHandle lh;\n+    LacCallback cb;\n+    int numResponsesPending;\n+    volatile boolean completed = false;\n+    int lastSeenError = BKException.Code.ReadException;\n+    final DistributionSchedule.QuorumCoverageSet coverageSet;\n+    long maxLac = LedgerHandle.INVALID_ENTRY_ID;\n+\n+    /*\n+     * Wrapper to get Lac from the request\n+     */\n+    interface LacCallback {\n+        public void getLacComplete(int rc, long lac);\n+    }\n+\n+    PendingReadLacOp(LedgerHandle lh, LacCallback cb) {\n+        this.lh = lh;\n+        this.cb = cb;\n+        this.numResponsesPending = lh.metadata.getEnsembleSize();\n+        this.coverageSet = lh.distributionSchedule.getCoverageSet();\n+    }\n+\n+    public void initiate() {\n+        for (int i = 0; i < lh.metadata.currentEnsemble.size(); i++) {\n+            lh.bk.bookieClient.readLac(lh.metadata.currentEnsemble.get(i),\n+                    lh.ledgerId, this, i);\n+        }\n+    }\n+\n+    @Override\n+    public void readLacComplete(int rc, long ledgerId, final ChannelBuffer lacBuffer, final ChannelBuffer lastEntryBuffer, Object ctx) {\n+        int bookieIndex = (Integer) ctx;\n+        numResponsesPending--;\n+        boolean heardValidResponse = false;\n+\n+        if (completed) {\n+            return;\n+        }\n+\n+        if (rc == BKException.Code.OK) {\n+            try {\n+                // Each bookie may have two store LAC in two places.\n+                // One is in-memory copy in FileInfo and other is\n+                // piggy-backed LAC on the last entry.\n+                // This routine picks both of them and compares to return\n+                // the latest Lac.\n+\n+                // Extract lac from FileInfo on the ledger.\n+                long lac = lh.macManager.verifyDigestAndReturnLac(lacBuffer);\n+                if (lac > maxLac) {\n+                    maxLac = lac;\n+                }\n+\n+                // Extract lac from last entry on the disk\n+                RecoveryData recoveryData = lh.macManager.verifyDigestAndReturnLastConfirmed(lastEntryBuffer);\n+                if (recoveryData.lastAddConfirmed > maxLac) {\n+                    maxLac = recoveryData.lastAddConfirmed;\n+                }\n+                heardValidResponse = true;\n+            } catch (BKDigestMatchException e) {\n+                // Too bad, this bookie did not give us a valid answer, we\n+                // still might be able to recover. So, continue\n+                LOG.error(\"Mac mismatch while reading  ledger: \" + ledgerId + \" LAC from bookie: \"\n+                        + lh.metadata.currentEnsemble.get(bookieIndex));\n+                rc = BKException.Code.DigestMatchException;\n+            }\n+        }\n+\n+        if (rc == BKException.Code.NoSuchLedgerExistsException || rc == BKException.Code.NoSuchEntryException) {\n+            heardValidResponse = true;\n+        }\n+\n+        if (rc == BKException.Code.UnauthorizedAccessException && !completed) {\n+            cb.getLacComplete(rc, maxLac);\n+            completed = true;\n+            return;\n+        }\n+\n+        if (!heardValidResponse && BKException.Code.OK != rc) {\n+            lastSeenError = rc;\n+        }\n+\n+        // We don't consider a success until we have coverage set responses.\n+        if (heardValidResponse\n+                && coverageSet.addBookieAndCheckCovered(bookieIndex)\n+                && !completed) {\n+            completed = true;\n+            LOG.debug(\"Read LAC complete with enough validResponse for ledger: {} LAC: {}\",\n+                    ledgerId, maxLac);\n+            cb.getLacComplete(BKException.Code.OK, maxLac);\n+            return;\n+        }\n+\n+        if (numResponsesPending == 0 && !completed) {\n+            LOG.info(\"While readLac ledger: \" + ledgerId + \" did not hear success responses from all of ensemble\");\n+            cb.getLacComplete(lastSeenError, maxLac);\n+        }\n+    }\n+}"},{"sha":"dc7368b254002f0b1b23b18527e3edfe681d1ac4","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingWriteLacOp.java","status":"added","additions":114,"deletions":0,"changes":114,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/c813b3d3298586ded02032a57a99d5fc6c974581/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FPendingWriteLacOp.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/c813b3d3298586ded02032a57a99d5fc6c974581/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FPendingWriteLacOp.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FPendingWriteLacOp.java?ref=c813b3d3298586ded02032a57a99d5fc6c974581","patch":"@@ -0,0 +1,114 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.bookkeeper.client;\n+\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.apache.bookkeeper.client.AsyncCallback.AddLacCallback;\n+import org.apache.bookkeeper.net.BookieSocketAddress;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteLacCallback;\n+import org.apache.bookkeeper.stats.OpStatsLogger;\n+import org.jboss.netty.buffer.ChannelBuffer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This represents a pending WriteLac operation. When it has got\n+ * success from Ack Quorum bookies, sends success back to the application,\n+ * otherwise failure is sent back to the caller.\n+ *\n+ * This is an optional protocol operations to facilitate tailing readers\n+ * to be up to date with the writer. This is best effort to get latest LAC\n+ * from bookies, and doesn't affect the correctness of the protocol.\n+ */\n+class PendingWriteLacOp implements WriteLacCallback {\n+    private final static Logger LOG = LoggerFactory.getLogger(PendingWriteLacOp.class);\n+    ChannelBuffer toSend;\n+    AddLacCallback cb;\n+    long lac;\n+    Object ctx;\n+    Set<Integer> writeSet;\n+    Set<Integer> receivedResponseSet;\n+\n+    DistributionSchedule.AckSet ackSet;\n+    boolean completed = false;\n+    int lastSeenError = BKException.Code.WriteException;\n+\n+    LedgerHandle lh;\n+    OpStatsLogger putLacOpLogger;\n+\n+    PendingWriteLacOp(LedgerHandle lh, AddLacCallback cb, Object ctx) {\n+        this.lh = lh;\n+        this.cb = cb;\n+        this.ctx = ctx;\n+        this.lac = LedgerHandle.INVALID_ENTRY_ID;\n+        ackSet = lh.distributionSchedule.getAckSet();\n+        putLacOpLogger = lh.bk.getWriteLacOpLogger();\n+    }\n+\n+    void setLac(long lac) {\n+        this.lac = lac;\n+        this.writeSet = new HashSet<Integer>(lh.distributionSchedule.getWriteSet(lac));\n+        this.receivedResponseSet = new HashSet<Integer>(writeSet);\n+    }\n+\n+    void sendWriteLacRequest(int bookieIndex) {\n+        lh.bk.bookieClient.writeLac(lh.metadata.currentEnsemble.get(bookieIndex), lh.ledgerId, lh.ledgerKey,\n+                lac, toSend, this, bookieIndex);\n+    }\n+\n+    void initiate(ChannelBuffer toSend) {\n+        this.toSend = toSend;\n+        for (int bookieIndex: writeSet) {\n+            sendWriteLacRequest(bookieIndex);\n+        }\n+    }\n+\n+    @Override\n+    public void writeLacComplete(int rc, long ledgerId, BookieSocketAddress addr, Object ctx) {\n+        int bookieIndex = (Integer) ctx;\n+\n+        if (completed) {\n+            return;\n+        }\n+\n+        if (BKException.Code.OK != rc) {\n+            lastSeenError = rc;\n+        }\n+\n+        // We got response.\n+        receivedResponseSet.remove(bookieIndex);\n+\n+        if (rc == BKException.Code.OK) {\n+            if (ackSet.addBookieAndCheck(bookieIndex) && !completed) {\n+                completed = true;\n+                cb.addLacComplete(rc, lh, ctx);\n+                return;\n+            }\n+        } else {\n+            LOG.warn(\"WriteLac did not succeed: Ledger {} on {}\", new Object[] { ledgerId, addr });\n+        }\n+        \n+        if(receivedResponseSet.isEmpty()){\n+            completed = true;\n+            cb.addLacComplete(lastSeenError, lh, ctx);\n+        }\n+    }\n+}"},{"sha":"1834eff6c5437c8867fcb29d032ad1453099fd47","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ReadOnlyLedgerHandle.java","status":"modified","additions":8,"deletions":0,"changes":8,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/c813b3d3298586ded02032a57a99d5fc6c974581/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FReadOnlyLedgerHandle.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/c813b3d3298586ded02032a57a99d5fc6c974581/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FReadOnlyLedgerHandle.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FReadOnlyLedgerHandle.java?ref=c813b3d3298586ded02032a57a99d5fc6c974581","patch":"@@ -54,6 +54,10 @@ public void safeRun() {\n                     ReadOnlyLedgerHandle.this.metadata.getVersion().compare(this.m.getVersion());\n             if (Version.Occurred.BEFORE == occurred) {\n                 LOG.info(\"Updated ledger metadata for ledger {} to {}.\", ledgerId, this.m);\n+                if (this.m.isClosed()) {\n+                        ReadOnlyLedgerHandle.this.lastAddConfirmed = this.m.getLastEntryId();\n+                        ReadOnlyLedgerHandle.this.length = this.m.getLength();\n+                }\n                 ReadOnlyLedgerHandle.this.metadata = this.m;\n             }\n         }\n@@ -170,4 +174,8 @@ public String toString() {\n         return String.format(\"ReadOnlyLedgerHandle(lid = %d, id = %d)\", ledgerId, super.hashCode());\n     }\n \n+    @Override\n+    protected void initializeExplicitLacFlushPolicy() {\n+        explicitLacFlushPolicy = ExplicitLacFlushPolicy.VOID_EXPLICITLAC_FLUSH_POLICY;\n+    }\n }"},{"sha":"fa42dc98d931773ad9d8a70320cef0a833f040dd","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ClientConfiguration.java","status":"modified","additions":25,"deletions":1,"changes":26,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/c813b3d3298586ded02032a57a99d5fc6c974581/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fconf%2FClientConfiguration.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/c813b3d3298586ded02032a57a99d5fc6c974581/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fconf%2FClientConfiguration.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fconf%2FClientConfiguration.java?ref=c813b3d3298586ded02032a57a99d5fc6c974581","patch":"@@ -65,6 +65,7 @@ public class ClientConfiguration extends AbstractConfiguration {\n     protected final static String ADD_ENTRY_QUORUM_TIMEOUT_SEC = \"addEntryQuorumTimeoutSec\";\n     protected final static String READ_ENTRY_TIMEOUT_SEC = \"readEntryTimeoutSec\";\n     protected final static String TIMEOUT_TASK_INTERVAL_MILLIS = \"timeoutTaskIntervalMillis\";\n+    protected final static String EXPLICIT_LAC_INTERVAL = \"explicitLacInterval\";\n     protected final static String PCBC_TIMEOUT_TIMER_TICK_DURATION_MS = \"pcbcTimeoutTimerTickDurationMs\";\n     protected final static String PCBC_TIMEOUT_TIMER_NUM_TICKS = \"pcbcTimeoutTimerNumTicks\";\n     protected final static String TIMEOUT_TIMER_TICK_DURATION_MS = \"timeoutTimerTickDurationMs\";\n@@ -76,7 +77,7 @@ public class ClientConfiguration extends AbstractConfiguration {\n     protected final static String BOOKIE_ERROR_THRESHOLD_PER_INTERVAL = \"bookieErrorThresholdPerInterval\";\n     protected final static String BOOKIE_QUARANTINE_TIME_SECONDS = \"bookieQuarantineTimeSeconds\";\n \n-    // Number Woker Threads\n+    // Number Worker Threads\n     protected final static String NUM_WORKER_THREADS = \"numWorkerThreads\";\n \n     // Ensemble Placement Policy\n@@ -594,6 +595,29 @@ public ClientConfiguration setTimeoutTaskIntervalMillis(long timeoutMillis) {\n         return this;\n     }\n \n+    /**\n+     * Get the configured interval between  explicit LACs to bookies.\n+     * Generally LACs are piggy-backed on writes, and user can configure\n+     * the interval between these protocol messages. A value of '0' disables\n+     * sending any explicit LACs.\n+     *\n+     * @return interval between explicit LACs\n+     */\n+    public int getExplictLacInterval() {\n+        return getInt(EXPLICIT_LAC_INTERVAL, 0);\n+    }\n+\n+    /**\n+     * Set the interval to check the need for sending an explicit LAC.\n+     * @param interval\n+     *        Number of seconds between checking the need for sending an explict LAC.\n+     * @return Client configuration.\n+     */\n+    public ClientConfiguration setExplictLacInterval(int interval) {\n+        setProperty(EXPLICIT_LAC_INTERVAL, interval);\n+        return this;\n+    }\n+\n     /**\n      * Get the tick duration in milliseconds that used for the\n      * {@link org.jboss.netty.util.HashedWheelTimer} that used by PCBC to timeout"},{"sha":"4a742daefdc5782beae0eced3a5c716023e855cc","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieClient.java","status":"modified","additions":71,"deletions":0,"changes":71,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/c813b3d3298586ded02032a57a99d5fc6c974581/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookieClient.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/c813b3d3298586ded02032a57a99d5fc6c974581/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookieClient.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookieClient.java?ref=c813b3d3298586ded02032a57a99d5fc6c974581","patch":"@@ -33,10 +33,13 @@\n \n import org.apache.bookkeeper.auth.AuthProviderFactoryFactory;\n import org.apache.bookkeeper.auth.ClientAuthProvider;\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n import org.apache.bookkeeper.client.BKException;\n import org.apache.bookkeeper.conf.ClientConfiguration;\n import org.apache.bookkeeper.net.BookieSocketAddress;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ReadLacCallback;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteLacCallback;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ReadEntryCallback;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteCallback;\n import org.apache.bookkeeper.stats.NullStatsLogger;\n@@ -166,6 +169,41 @@ private PerChannelBookieClientPool lookupClient(BookieSocketAddress addr, Object\n         return clientPool;\n     }\n \n+    public void writeLac(final BookieSocketAddress addr, final long ledgerId, final byte[] masterKey,\n+            final long lac, final ChannelBuffer toSend, final WriteLacCallback cb, final Object ctx) {\n+        closeLock.readLock().lock();\n+        try {\n+            final PerChannelBookieClientPool client = lookupClient(addr, lac);\n+            if (client == null) {\n+                cb.writeLacComplete(getRc(BKException.Code.BookieHandleNotAvailableException),\n+                                  ledgerId, addr, ctx);\n+                return;\n+            }\n+\n+            client.obtain(new GenericCallback<PerChannelBookieClient>() {\n+                @Override\n+                public void operationComplete(final int rc, PerChannelBookieClient pcbc) {\n+                    if (rc != BKException.Code.OK) {\n+                        try {\n+                            executor.submitOrdered(ledgerId, new SafeRunnable() {\n+                                @Override\n+                                public void safeRun() {\n+                                    cb.writeLacComplete(rc, ledgerId, addr, ctx);\n+                                }\n+                            });\n+                        } catch (RejectedExecutionException re) {\n+                            cb.writeLacComplete(getRc(BKException.Code.InterruptedException), ledgerId, addr, ctx);\n+                        }\n+                        return;\n+                    }\n+                    pcbc.writeLac(ledgerId, masterKey, lac, toSend, cb, ctx);\n+                }\n+            });\n+        } finally {\n+            closeLock.readLock().unlock();\n+        }\n+    }\n+\n     public void addEntry(final BookieSocketAddress addr, final long ledgerId, final byte[] masterKey,\n             final long entryId,\n             final ChannelBuffer toSend, final WriteCallback cb, final Object ctx, final int options) {\n@@ -243,6 +281,39 @@ public void safeRun() {\n         }\n     }\n \n+    public void readLac(final BookieSocketAddress addr, final long ledgerId, final ReadLacCallback cb, final Object ctx) {\n+        closeLock.readLock().lock();\n+        try {\n+            final PerChannelBookieClientPool client = lookupClient(addr, BookieProtocol.LAST_ADD_CONFIRMED);\n+            if (client == null) {\n+                cb.readLacComplete(getRc(BKException.Code.BookieHandleNotAvailableException), ledgerId, null, null, ctx);\n+                return;\n+            }\n+            client.obtain(new GenericCallback<PerChannelBookieClient>() {\n+                @Override\n+                public void operationComplete(final int rc,PerChannelBookieClient pcbc) {\n+                    if (rc != BKException.Code.OK) {\n+                        try {\n+                            executor.submitOrdered(ledgerId, new SafeRunnable() {\n+                                @Override\n+                                public void safeRun() {\n+                                    cb.readLacComplete(rc, ledgerId, null, null, ctx);\n+                                }\n+                            });\n+                        } catch (RejectedExecutionException re) {\n+                            cb.readLacComplete(getRc(BKException.Code.InterruptedException),\n+                                    ledgerId, null, null, ctx);\n+                        }\n+                        return;\n+                    }\n+                    pcbc.readLac(ledgerId, cb, ctx);\n+                }\n+            });\n+        } finally {\n+            closeLock.readLock().unlock();\n+        }\n+    }\n+\n     public void readEntry(final BookieSocketAddress addr, final long ledgerId, final long entryId,\n                           final ReadEntryCallback cb, final Object ctx) {\n         closeLock.readLock().lock();"},{"sha":"210bc7223e2ae66a01595f96941099bbec9dd2f7","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieRequestProcessor.java","status":"modified","additions":31,"deletions":0,"changes":31,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/c813b3d3298586ded02032a57a99d5fc6c974581/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookieRequestProcessor.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/c813b3d3298586ded02032a57a99d5fc6c974581/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookieRequestProcessor.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookieRequestProcessor.java?ref=c813b3d3298586ded02032a57a99d5fc6c974581","patch":"@@ -41,6 +41,9 @@\n import static org.apache.bookkeeper.bookie.BookKeeperServerStats.ADD_ENTRY_REQUEST;\n import static org.apache.bookkeeper.bookie.BookKeeperServerStats.READ_ENTRY;\n import static org.apache.bookkeeper.bookie.BookKeeperServerStats.READ_ENTRY_REQUEST;\n+import static org.apache.bookkeeper.bookie.BookKeeperServerStats.WRITE_LAC;\n+import static org.apache.bookkeeper.bookie.BookKeeperServerStats.READ_LAC;\n+\n \n public class BookieRequestProcessor implements RequestProcessor {\n \n@@ -73,6 +76,8 @@ public class BookieRequestProcessor implements RequestProcessor {\n     final OpStatsLogger addEntryStats;\n     final OpStatsLogger readRequestStats;\n     final OpStatsLogger readEntryStats;\n+    final OpStatsLogger writeLacStats;\n+    final OpStatsLogger readLacStats;\n \n     public BookieRequestProcessor(ServerConfiguration serverCfg, Bookie bookie,\n                                   StatsLogger statsLogger) {\n@@ -86,6 +91,8 @@ public BookieRequestProcessor(ServerConfiguration serverCfg, Bookie bookie,\n         this.addRequestStats = statsLogger.getOpStatsLogger(ADD_ENTRY_REQUEST);\n         this.readEntryStats = statsLogger.getOpStatsLogger(READ_ENTRY);\n         this.readRequestStats = statsLogger.getOpStatsLogger(READ_ENTRY_REQUEST);\n+        this.writeLacStats = statsLogger.getOpStatsLogger(WRITE_LAC);\n+        this.readLacStats = statsLogger.getOpStatsLogger(READ_LAC);\n     }\n \n     @Override\n@@ -135,6 +142,12 @@ public void processRequest(Object msg, Channel c) {\n                             .setAuthResponse(message);\n                     c.write(authResponse.build());\n                     break;\n+                case WRITE_LAC:\n+                    processWriteLacRequestV3(r,c);\n+                    break;\n+                case READ_LAC:\n+                    processReadLacRequestV3(r,c);\n+                    break;\n                 default:\n                     LOG.info(\"Unknown operation type {}\", header.getOperation());\n                     BookkeeperProtocol.Response.Builder response =\n@@ -185,6 +198,24 @@ private void processReadRequestV3(final BookkeeperProtocol.Request r, final Chan\n         }\n     }\n \n+    private void processWriteLacRequestV3(final BookkeeperProtocol.Request r, final Channel c) {\n+        WriteLacProcessorV3 writeLac = new WriteLacProcessorV3(r, c, this);\n+        if (null == writeThreadPool) {\n+            writeLac.run();\n+        } else {\n+            writeThreadPool.submit(writeLac);\n+        }\n+    }\n+\n+    private void processReadLacRequestV3(final BookkeeperProtocol.Request r, final Channel c) {\n+        ReadLacProcessorV3 readLac = new ReadLacProcessorV3(r, c, this);\n+        if (null == readThreadPool) {\n+            readLac.run();\n+        } else {\n+            readThreadPool.submit(readLac);\n+        }\n+    }\n+\n     private void processAddRequest(final BookieProtocol.Request r, final Channel c) {\n         WriteEntryProcessor write = new WriteEntryProcessor(r, c, this);\n         if (null == writeThreadPool) {"},{"sha":"261c93d0438b4c731491b2d0d0ef890e4db89cd8","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookkeeperInternalCallbacks.java","status":"modified","additions":8,"deletions":0,"changes":8,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/c813b3d3298586ded02032a57a99d5fc6c974581/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookkeeperInternalCallbacks.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/c813b3d3298586ded02032a57a99d5fc6c974581/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookkeeperInternalCallbacks.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookkeeperInternalCallbacks.java?ref=c813b3d3298586ded02032a57a99d5fc6c974581","patch":"@@ -65,6 +65,14 @@ public interface WriteCallback {\n         void writeComplete(int rc, long ledgerId, long entryId, BookieSocketAddress addr, Object ctx);\n     }\n \n+    public interface ReadLacCallback {\n+        void readLacComplete(int rc, long ledgerId, ChannelBuffer lac, ChannelBuffer buffer, Object ctx);\n+    }\n+\n+    public interface WriteLacCallback {\n+        void writeLacComplete(int rc, long ledgerId, BookieSocketAddress addr, Object ctx);\n+    }\n+\n     public interface GenericCallback<T> {\n         void operationComplete(int rc, T result);\n     }"},{"sha":"b5c0008e787fae8e274dbb22bd819091dcbb1a0f","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookkeeperProtocol.java","status":"modified","additions":4647,"deletions":1468,"changes":6115,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/c813b3d3298586ded02032a57a99d5fc6c974581/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookkeeperProtocol.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/c813b3d3298586ded02032a57a99d5fc6c974581/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookkeeperProtocol.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookkeeperProtocol.java?ref=c813b3d3298586ded02032a57a99d5fc6c974581"},{"sha":"3fb73e481b32b7efaadbbcf5aaf6ac20d56923e5","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java","status":"modified","additions":289,"deletions":4,"changes":293,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/c813b3d3298586ded02032a57a99d5fc6c974581/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FPerChannelBookieClient.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/c813b3d3298586ded02032a57a99d5fc6c974581/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FPerChannelBookieClient.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FPerChannelBookieClient.java?ref=c813b3d3298586ded02032a57a99d5fc6c974581","patch":"@@ -29,6 +29,7 @@\n import java.util.concurrent.locks.ReentrantReadWriteLock;\n \n import org.apache.bookkeeper.auth.ClientAuthProvider;\n+import com.google.protobuf.ByteString;\n import org.apache.bookkeeper.client.BKException;\n import org.apache.bookkeeper.client.BookKeeperClientStats;\n import org.apache.bookkeeper.conf.ClientConfiguration;\n@@ -39,13 +40,22 @@\n import org.apache.bookkeeper.proto.BookkeeperProtocol.AddRequest;\n import org.apache.bookkeeper.proto.BookkeeperProtocol.AddResponse;\n import org.apache.bookkeeper.proto.BookkeeperProtocol.BKPacketHeader;\n+import org.apache.bookkeeper.proto.BookkeeperProtocol.ReadLacRequest;\n+import org.apache.bookkeeper.proto.BookkeeperProtocol.ReadLacResponse;\n import org.apache.bookkeeper.proto.BookkeeperProtocol.OperationType;\n import org.apache.bookkeeper.proto.BookkeeperProtocol.ProtocolVersion;\n+import org.apache.bookkeeper.proto.BookkeeperProtocol.WriteLacRequest;\n+import org.apache.bookkeeper.proto.BookkeeperProtocol.WriteLacResponse;\n import org.apache.bookkeeper.proto.BookkeeperProtocol.ReadRequest;\n import org.apache.bookkeeper.proto.BookkeeperProtocol.ReadResponse;\n import org.apache.bookkeeper.proto.BookkeeperProtocol.Request;\n import org.apache.bookkeeper.proto.BookkeeperProtocol.Response;\n import org.apache.bookkeeper.proto.BookkeeperProtocol.StatusCode;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ReadEntryCallback;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteCallback;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteLacCallback;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ReadLacCallback;\n import org.apache.bookkeeper.stats.NullStatsLogger;\n import org.apache.bookkeeper.stats.OpStatsLogger;\n import org.apache.bookkeeper.stats.StatsLogger;\n@@ -124,7 +134,11 @@ public class PerChannelBookieClient extends SimpleChannelHandler implements Chan\n     private final OpStatsLogger readEntryOpLogger;\n     private final OpStatsLogger readTimeoutOpLogger;\n     private final OpStatsLogger addEntryOpLogger;\n+    private final OpStatsLogger writeLacOpLogger;\n+    private final OpStatsLogger readLacOpLogger;\n     private final OpStatsLogger addTimeoutOpLogger;\n+    private final OpStatsLogger writeLacTimeoutOpLogger;\n+    private final OpStatsLogger readLacTimeoutOpLogger;\n \n     /**\n      * The following member variables do not need to be concurrent, or volatile\n@@ -192,8 +206,12 @@ public PerChannelBookieClient(ClientConfiguration conf, OrderedSafeExecutor exec\n \n         readEntryOpLogger = statsLogger.getOpStatsLogger(BookKeeperClientStats.CHANNEL_READ_OP);\n         addEntryOpLogger = statsLogger.getOpStatsLogger(BookKeeperClientStats.CHANNEL_ADD_OP);\n+        writeLacOpLogger = statsLogger.getOpStatsLogger(BookKeeperClientStats.CHANNEL_WRITE_LAC_OP);\n+        readLacOpLogger = statsLogger.getOpStatsLogger(BookKeeperClientStats.CHANNEL_READ_LAC_OP);\n         readTimeoutOpLogger = statsLogger.getOpStatsLogger(BookKeeperClientStats.CHANNEL_TIMEOUT_READ);\n         addTimeoutOpLogger = statsLogger.getOpStatsLogger(BookKeeperClientStats.CHANNEL_TIMEOUT_ADD);\n+        writeLacTimeoutOpLogger = statsLogger.getOpStatsLogger(BookKeeperClientStats.CHANNEL_TIMEOUT_WRITE_LAC);\n+        readLacTimeoutOpLogger = statsLogger.getOpStatsLogger(BookKeeperClientStats.CHANNEL_TIMEOUT_READ_LAC);\n \n         this.pcbcPool = pcbcPool;\n \n@@ -238,6 +256,7 @@ public BookKeeperPrincipal getAuthorizedId() {\n     }\n \n     private void completeOperation(GenericCallback<PerChannelBookieClient> op, int rc) {\n+        //Thread.dumpStack();\n         closeLock.readLock().lock();\n         try {\n             if (ConnectionState.CLOSED == state) {\n@@ -365,6 +384,60 @@ void connectIfNeededAndDoOp(GenericCallback<PerChannelBookieClient> op) {\n \n     }\n \n+    void writeLac(final long ledgerId, final byte[] masterKey, final long lac, ChannelBuffer toSend, WriteLacCallback cb, Object ctx) {\n+        final long txnId = getTxnId();\n+        final int entrySize = toSend.readableBytes();\n+        final CompletionKey completionKey = new CompletionKey(txnId, OperationType.WRITE_LAC);\n+        // writeLac is mostly like addEntry hence uses addEntryTimeout\n+        completionObjects.put(completionKey,\n+                new WriteLacCompletion(writeLacOpLogger, cb, ctx, lac, scheduleTimeout(completionKey, addEntryTimeout)));\n+\n+        // Build the request\n+        BKPacketHeader.Builder headerBuilder = BKPacketHeader.newBuilder()\n+                .setVersion(ProtocolVersion.VERSION_THREE)\n+                .setOperation(OperationType.WRITE_LAC)\n+                .setTxnId(txnId);\n+        WriteLacRequest.Builder writeLacBuilder = WriteLacRequest.newBuilder()\n+                .setLedgerId(ledgerId)\n+                .setLac(lac)\n+                .setMasterKey(ByteString.copyFrom(masterKey))\n+                .setBody(ByteString.copyFrom(toSend.toByteBuffer()));\n+\n+        final Request writeLacRequest = Request.newBuilder()\n+                .setHeader(headerBuilder)\n+                .setWriteLacRequest(writeLacBuilder)\n+                .build();\n+\n+        final Channel c = channel;\n+        if (c == null) {\n+            errorOutWriteLacKey(completionKey);\n+            return;\n+        }\n+        try {\n+            ChannelFuture future = c.write(writeLacRequest);\n+            future.addListener(new ChannelFutureListener() {\n+                @Override\n+                public void operationComplete(ChannelFuture future) throws Exception {\n+                    if (future.isSuccess()) {\n+                        if (LOG.isDebugEnabled()) {\n+                            LOG.debug(\"Successfully wrote request for writeLac LedgerId: {} bookie: {}\",\n+                                    ledgerId, c.getRemoteAddress());\n+                        }\n+                    } else {\n+                        if (!(future.getCause() instanceof ClosedChannelException)) {\n+                            LOG.warn(\"Writing Lac(lid={} to channel {} failed : \",\n+                                    new Object[] { ledgerId, c, future.getCause() });\n+                        }\n+                        errorOutWriteLacKey(completionKey);\n+                    }\n+                }\n+            });\n+        } catch (Throwable e) {\n+            LOG.warn(\"writeLac operation failed\", e);\n+            errorOutWriteLacKey(completionKey);\n+        }\n+    }\n+\n     /**\n      * This method should be called only after connection has been checked for\n      * {@link #connectIfNeededAndDoOp(GenericCallback)}\n@@ -502,6 +575,52 @@ public void operationComplete(ChannelFuture future) throws Exception {\n         }\n     }\n \n+    public void readLac(final long ledgerId, ReadLacCallback cb, Object ctx) {\n+        final long txnId = getTxnId();\n+        final CompletionKey completionKey = new CompletionKey(txnId, OperationType.READ_LAC);\n+        completionObjects.put(completionKey,\n+                new ReadLacCompletion(readLacOpLogger, cb, ctx, ledgerId,\n+                        scheduleTimeout(completionKey, readEntryTimeout)));\n+        // Build the request and calculate the total size to be included in the packet.\n+        BKPacketHeader.Builder headerBuilder = BKPacketHeader.newBuilder()\n+                .setVersion(ProtocolVersion.VERSION_THREE)\n+                .setOperation(OperationType.READ_LAC)\n+                .setTxnId(txnId);\n+        ReadLacRequest.Builder readLacBuilder = ReadLacRequest.newBuilder()\n+                .setLedgerId(ledgerId);\n+        final Request readLacRequest = Request.newBuilder()\n+                .setHeader(headerBuilder)\n+                .setReadLacRequest(readLacBuilder)\n+                .build();\n+        final Channel c = channel;\n+        if (c == null) {\n+            errorOutReadLacKey(completionKey);\n+            return;\n+        }\n+\n+        try {\n+            ChannelFuture future = c.write(readLacRequest);\n+            future.addListener(new ChannelFutureListener() {\n+                @Override\n+                public void operationComplete(ChannelFuture future) throws Exception {\n+                    if (future.isSuccess()) {\n+                        LOG.debug(\"Succssfully wrote request {} to {}\",\n+                                    readLacRequest, c.getRemoteAddress());\n+                    } else {\n+                        if (!(future.getCause() instanceof ClosedChannelException)) {\n+                            LOG.warn(\"Writing readLac(lid = {}) to channel {} failed : \",\n+                                    new Object[] { ledgerId, c, future.getCause() });\n+                        }\n+                        errorOutReadLacKey(completionKey);\n+                    }\n+                }\n+            });\n+        } catch(Throwable e) {\n+            LOG.warn(\"Read LAC operation {} failed\", readLacRequest, e);\n+            errorOutReadLacKey(completionKey);\n+        }\n+    }\n+\n     public void readEntry(final long ledgerId, final long entryId, ReadEntryCallback cb, Object ctx) {\n         final long txnId = getTxnId();\n         final CompletionKey completionKey = new CompletionKey(txnId, OperationType.READ_ENTRY);\n@@ -649,6 +768,54 @@ public String toString() {\n         });\n     }\n \n+    void errorOutWriteLacKey(final CompletionKey key) {\n+        errorOutWriteLacKey(key, BKException.Code.BookieHandleNotAvailableException);\n+    }\n+\n+    void errorOutWriteLacKey(final CompletionKey key, final int rc) {\n+        final WriteLacCompletion writeLacCompletion = (WriteLacCompletion)completionObjects.remove(key);\n+        if (null == writeLacCompletion) {\n+            return;\n+        }\n+        executor.submitOrdered(writeLacCompletion.ledgerId, new SafeRunnable() {\n+            @Override\n+            public void safeRun() {\n+                String bAddress = \"null\";\n+                Channel c = channel;\n+                if (c != null) {\n+                    bAddress = c.getRemoteAddress().toString();\n+                }\n+                LOG.debug(\"Could not write request writeLac for ledgerId: {} bookie: {}\",\n+                          new Object[] { writeLacCompletion.ledgerId, bAddress});\n+                writeLacCompletion.cb.writeLacComplete(rc, writeLacCompletion.ledgerId, addr, writeLacCompletion.ctx);\n+            }\n+        });\n+    }\n+\n+    void errorOutReadLacKey(final CompletionKey key) {\n+        errorOutReadLacKey(key, BKException.Code.BookieHandleNotAvailableException);\n+    }\n+\n+    void errorOutReadLacKey(final CompletionKey key, final int rc) {\n+        final ReadLacCompletion readLacCompletion = (ReadLacCompletion)completionObjects.remove(key);\n+        if (null == readLacCompletion) {\n+            return;\n+        }\n+        executor.submitOrdered(readLacCompletion.ledgerId, new SafeRunnable() {\n+            @Override\n+            public void safeRun() {\n+                String bAddress = \"null\";\n+                Channel c = channel;\n+                if (c != null) {\n+                    bAddress = c.getRemoteAddress().toString();\n+                }\n+                LOG.debug(\"Could not write request readLac for ledgerId: {} bookie: {}\",\n+                          new Object[] { readLacCompletion.ledgerId, bAddress});\n+                readLacCompletion.cb.readLacComplete(rc, readLacCompletion.ledgerId, null, null, readLacCompletion.ctx);\n+            }\n+        });\n+    }\n+\n     void errorOutAddKey(final CompletionKey key) {\n         errorOutAddKey(key, BKException.Code.BookieHandleNotAvailableException);\n     }\n@@ -836,6 +1003,12 @@ public void safeRun() {\n                         case READ_ENTRY:\n                             handleReadResponse(response, completionValue);\n                             break;\n+                        case WRITE_LAC:\n+                            handleWriteLacResponse(response.getWriteLacResponse(), completionValue);\n+                            break;\n+                        case READ_LAC:\n+                            handleReadLacResponse(response.getReadLacResponse(), completionValue);\n+                            break;\n                         default:\n                             LOG.error(\"Unexpected response, type:{} received from bookie:{}, ignoring\",\n                                       type, addr);\n@@ -853,7 +1026,26 @@ public String toString() {\n         }\n     }\n \n-    void handleAddResponse(Response response, CompletionValue completionValue) {\n+    void handleWriteLacResponse(WriteLacResponse writeLacResponse, CompletionValue completionValue) {\n+        // The completion value should always be an instance of an WriteLacCompletion object when we reach here.\n+        WriteLacCompletion plc = (WriteLacCompletion)completionValue;\n+\n+        long ledgerId = writeLacResponse.getLedgerId();\n+        StatusCode status = writeLacResponse.getStatus();\n+\n+        LOG.debug(\"Got response for writeLac request from bookie: \" + addr + \" for ledger: \" + ledgerId + \" rc: \" + status);\n+\n+        // convert to BKException code\n+        Integer rcToRet = statusCodeToExceptionCode(status);\n+        if (null == rcToRet) {\n+            LOG.error(\"writeLac for ledger: \" + ledgerId + \" failed on bookie: \" + addr\n+                        + \" with code:\" + status);\n+            rcToRet = BKException.Code.WriteException;\n+        }\n+        plc.cb.writeLacComplete(rcToRet, ledgerId, addr, plc.ctx);\n+    }\n+\n+ void handleAddResponse(Response response, CompletionValue completionValue) {\n         // The completion value should always be an instance of an AddCompletion object when we reach here.\n         AddCompletion ac = (AddCompletion)completionValue;\n         AddResponse addResponse = response.getAddResponse();\n@@ -866,7 +1058,7 @@ void handleAddResponse(Response response, CompletionValue completionValue) {\n             LOG.debug(\"Got response for add request from bookie: \" + addr + \" for ledger: \" + ledgerId + \" entry: \"\n                     + entryId + \" rc: \" + status);\n         }\n-        // convert to BKException code because thats what the uppper\n+        // convert to BKException code because thats what the upper\n         // layers expect. This is UGLY, there should just be one set of\n         // error codes.\n         Integer rcToRet = statusCodeToExceptionCode(status);\n@@ -880,6 +1072,36 @@ void handleAddResponse(Response response, CompletionValue completionValue) {\n         ac.cb.writeComplete(rcToRet, ledgerId, entryId, addr, ac.ctx);\n     }\n \n+    void handleReadLacResponse(ReadLacResponse readLacResponse, CompletionValue completionValue) {\n+        // The completion value should always be an instance of an WriteLacCompletion object when we reach here.\n+        ReadLacCompletion glac = (ReadLacCompletion)completionValue;\n+\n+        long ledgerId = readLacResponse.getLedgerId();\n+        StatusCode status = readLacResponse.getStatus();\n+        ChannelBuffer lacBuffer = ChannelBuffers.buffer(0);\n+        ChannelBuffer lastEntryBuffer = ChannelBuffers.buffer(0);\n+\n+       // Thread.dumpStack();\n+\n+        if (readLacResponse.hasLacBody()) {\n+            lacBuffer = ChannelBuffers.copiedBuffer(readLacResponse.getLacBody().asReadOnlyByteBuffer());\n+        }\n+\n+        if (readLacResponse.hasLastEntryBody()) {\n+            lastEntryBuffer = ChannelBuffers.copiedBuffer(readLacResponse.getLastEntryBody().asReadOnlyByteBuffer());\n+        }\n+\n+        LOG.debug(\"Got response for readLac request from bookie: \" + addr + \" for ledger: \" + ledgerId + \" rc: \" + status);\n+        // convert to BKException code\n+        Integer rcToRet = statusCodeToExceptionCode(status);\n+        if (null == rcToRet) {\n+            LOG.debug(\"readLac for ledger: \" + ledgerId + \" failed on bookie: \" + addr\n+                      + \" with code:\" + status);\n+            rcToRet = BKException.Code.ReadException;\n+        }\n+        glac.cb.readLacComplete(rcToRet, ledgerId, lacBuffer.slice(), lastEntryBuffer.slice(), glac.ctx);\n+    }\n+\n     void handleReadResponse(Response response, CompletionValue completionValue) {\n         // The completion value should always be an instance of a ReadCompletion object when we reach here.\n         ReadCompletion rc = (ReadCompletion)completionValue;\n@@ -939,6 +1161,63 @@ void cancelTimeout() {\n         }\n     }\n \n+    // visible for testing\n+    static class WriteLacCompletion extends CompletionValue {\n+        final WriteLacCallback cb;\n+\n+        public WriteLacCompletion(WriteLacCallback cb, Object ctx, long ledgerId) {\n+            this(null, cb, ctx, ledgerId, null);\n+        }\n+\n+        public WriteLacCompletion(final OpStatsLogger writeLacOpLogger, final WriteLacCallback originalCallback,\n+                final Object originalCtx, final long ledgerId, final Timeout timeout) {\n+            super(originalCtx, ledgerId, BookieProtocol.LAST_ADD_CONFIRMED, timeout);\n+            final long startTime = MathUtils.nowInNano();\n+            this.cb = null == writeLacOpLogger ? originalCallback : new WriteLacCallback() {\n+                @Override\n+                public void writeLacComplete(int rc, long ledgerId, BookieSocketAddress addr, Object ctx) {\n+                    cancelTimeout();\n+                    long latency = MathUtils.elapsedNanos(startTime);\n+                    if (rc != BKException.Code.OK) {\n+                        writeLacOpLogger.registerFailedEvent(latency, TimeUnit.NANOSECONDS);\n+                    } else {\n+                        writeLacOpLogger.registerSuccessfulEvent(latency, TimeUnit.NANOSECONDS);\n+                    }\n+                    originalCallback.writeLacComplete(rc, ledgerId, addr, originalCtx);\n+                }\n+            };\n+\n+        }\n+    }\n+\n+    // visible for testing\n+    static class ReadLacCompletion extends CompletionValue {\n+        final ReadLacCallback cb;\n+\n+        public ReadLacCompletion(ReadLacCallback cb, Object ctx, long ledgerId) {\n+            this (null, cb, ctx, ledgerId, null);\n+        }\n+\n+        public ReadLacCompletion(final OpStatsLogger readLacOpLogger, final ReadLacCallback originalCallback,\n+                final Object ctx, final long ledgerId, final Timeout timeout) {\n+            super(ctx, ledgerId, BookieProtocol.LAST_ADD_CONFIRMED, timeout);\n+            final long startTime = MathUtils.nowInNano();\n+            this.cb = null == readLacOpLogger ? originalCallback : new ReadLacCallback() {\n+                @Override\n+                public void readLacComplete(int rc, long ledgerId, ChannelBuffer lacBuffer, ChannelBuffer lastEntryBuffer, Object ctx) {\n+                    cancelTimeout();\n+                    long latency = MathUtils.elapsedNanos(startTime);\n+                    if (rc != BKException.Code.OK) {\n+                        readLacOpLogger.registerFailedEvent(latency, TimeUnit.NANOSECONDS);\n+                    } else {\n+                        readLacOpLogger.registerSuccessfulEvent(latency, TimeUnit.NANOSECONDS);\n+                    }\n+                    originalCallback.readLacComplete(rc, ledgerId, lacBuffer, lastEntryBuffer, ctx);\n+                }\n+            };\n+        }\n+    }\n+\n     // visible for testing\n     static class ReadCompletion extends CompletionValue {\n         final ReadEntryCallback cb;\n@@ -1070,11 +1349,17 @@ public void run(Timeout timeout) throws Exception {\n             if (OperationType.ADD_ENTRY == operationType) {\n                 errorOutAddKey(this, BKException.Code.TimeoutException);\n                 addTimeoutOpLogger.registerSuccessfulEvent(elapsedTime(), TimeUnit.NANOSECONDS);\n-            } else {\n+            } else if (OperationType.READ_ENTRY == operationType) {\n                 errorOutReadKey(this, BKException.Code.TimeoutException);\n                 readTimeoutOpLogger.registerSuccessfulEvent(elapsedTime(), TimeUnit.NANOSECONDS);\n+            } else if (OperationType.WRITE_LAC == operationType) {\n+                errorOutWriteLacKey(this, BKException.Code.TimeoutException);\n+                writeLacTimeoutOpLogger.registerSuccessfulEvent(elapsedTime(), TimeUnit.NANOSECONDS);\n+            } else {\n+                errorOutReadLacKey(this, BKException.Code.TimeoutException);\n+                readLacTimeoutOpLogger.registerSuccessfulEvent(elapsedTime(), TimeUnit.NANOSECONDS);\n             }\n-        }\n+\t}\n     }\n \n "},{"sha":"e9a4c13681bf6d7660ccf5db32e85244e1ceccd2","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/ReadLacProcessorV3.java","status":"added","additions":108,"deletions":0,"changes":108,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/c813b3d3298586ded02032a57a99d5fc6c974581/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FReadLacProcessorV3.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/c813b3d3298586ded02032a57a99d5fc6c974581/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FReadLacProcessorV3.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FReadLacProcessorV3.java?ref=c813b3d3298586ded02032a57a99d5fc6c974581","patch":"@@ -0,0 +1,108 @@\n+/**\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.proto;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.bookkeeper.bookie.Bookie;\n+import org.apache.bookkeeper.proto.BookkeeperProtocol.ReadLacRequest;\n+import org.apache.bookkeeper.proto.BookkeeperProtocol.ReadLacResponse;\n+import org.apache.bookkeeper.proto.BookkeeperProtocol.Request;\n+import org.apache.bookkeeper.proto.BookkeeperProtocol.Response;\n+import org.apache.bookkeeper.proto.BookkeeperProtocol.StatusCode;\n+import org.apache.bookkeeper.util.MathUtils;\n+import org.jboss.netty.channel.Channel;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.protobuf.ByteString;\n+\n+class ReadLacProcessorV3 extends PacketProcessorBaseV3 {\n+    private final static Logger logger = LoggerFactory.getLogger(ReadLacProcessorV3.class);\n+\n+    public ReadLacProcessorV3(Request request, Channel channel,\n+                             BookieRequestProcessor requestProcessor) {\n+        super(request, channel, requestProcessor);\n+    }\n+\n+    // Returns null if there is no exception thrown\n+    private ReadLacResponse getReadLacResponse() {\n+        final long startTimeNanos = MathUtils.nowInNano();\n+        ReadLacRequest readLacRequest = request.getReadLacRequest();\n+        long ledgerId = readLacRequest.getLedgerId();\n+\n+        final ReadLacResponse.Builder readLacResponse = ReadLacResponse.newBuilder().setLedgerId(ledgerId);\n+\n+        if (!isVersionCompatible()) {\n+            readLacResponse.setStatus(StatusCode.EBADVERSION);\n+            return readLacResponse.build();\n+        }\n+\n+        logger.debug(\"Received ReadLac request: {}\", request);\n+        StatusCode status = StatusCode.EOK;\n+        ByteBuffer lastEntry;\n+        ByteBuffer lac;\n+        try {\n+            lastEntry = requestProcessor.bookie.readEntry(ledgerId, BookieProtocol.LAST_ADD_CONFIRMED);\n+            lac = requestProcessor.bookie.getExplicitLac(ledgerId);\n+            if (lac != null) {\n+                readLacResponse.setLacBody(ByteString.copyFrom(lac));\n+                readLacResponse.setLastEntryBody(ByteString.copyFrom(lastEntry));\n+            } else {\n+                status = StatusCode.ENOENTRY;\n+            }\n+        } catch (Bookie.NoLedgerException e) {\n+            status = StatusCode.ENOLEDGER;\n+            logger.error(\"No ledger found while performing readLac from ledger: {}\", ledgerId);\n+        } catch (IOException e) {\n+            status = StatusCode.EIO;\n+            logger.error(\"IOException while performing readLac from ledger: {}\", ledgerId);\n+        }\n+        if (status == StatusCode.EOK) {\n+            requestProcessor.readLacStats.registerSuccessfulEvent(MathUtils.elapsedNanos(startTimeNanos),\n+                    TimeUnit.NANOSECONDS);\n+        } else {\n+            requestProcessor.readLacStats.registerFailedEvent(MathUtils.elapsedNanos(startTimeNanos),\n+                    TimeUnit.NANOSECONDS);\n+        }\n+        // Finally set the status and return\n+        readLacResponse.setStatus(status);\n+        return readLacResponse.build();\n+    }\n+\n+    @Override\n+    public void safeRun() {\n+        ReadLacResponse readLacResponse = getReadLacResponse();\n+        sendResponse(readLacResponse);\n+    }\n+\n+    private void sendResponse(ReadLacResponse readLacResponse) {\n+        Response.Builder response = Response.newBuilder()\n+            .setHeader(getHeader())\n+            .setStatus(readLacResponse.getStatus())\n+            .setReadLacResponse(readLacResponse);\n+        sendResponse(response.getStatus(),\n+                response.build(),\n+                requestProcessor.readRequestStats);\n+    }\n+}"},{"sha":"104f561abcd1eb8bd54b8b52ac8d78d9636c9119","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/WriteLacProcessorV3.java","status":"added","additions":113,"deletions":0,"changes":113,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/c813b3d3298586ded02032a57a99d5fc6c974581/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FWriteLacProcessorV3.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/c813b3d3298586ded02032a57a99d5fc6c974581/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FWriteLacProcessorV3.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FWriteLacProcessorV3.java?ref=c813b3d3298586ded02032a57a99d5fc6c974581","patch":"@@ -0,0 +1,113 @@\n+/**\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.proto;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.bookkeeper.bookie.BookieException;\n+import org.apache.bookkeeper.proto.BookkeeperProtocol.WriteLacRequest;\n+import org.apache.bookkeeper.proto.BookkeeperProtocol.WriteLacResponse;\n+import org.apache.bookkeeper.proto.BookkeeperProtocol.Request;\n+import org.apache.bookkeeper.proto.BookkeeperProtocol.Response;\n+import org.apache.bookkeeper.proto.BookkeeperProtocol.StatusCode;\n+import org.apache.bookkeeper.util.MathUtils;\n+import org.jboss.netty.channel.Channel;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+class WriteLacProcessorV3 extends PacketProcessorBaseV3 {\n+    private final static Logger logger = LoggerFactory.getLogger(WriteLacProcessorV3.class);\n+\n+    public WriteLacProcessorV3(Request request, Channel channel,\n+                             BookieRequestProcessor requestProcessor) {\n+        super(request, channel, requestProcessor);\n+    }\n+\n+    // Returns null if there is no exception thrown\n+    private WriteLacResponse getWriteLacResponse() {\n+        final long startTimeNanos = MathUtils.nowInNano();\n+        WriteLacRequest writeLacRequest = request.getWriteLacRequest();\n+        long lac = writeLacRequest.getLac();\n+        long ledgerId = writeLacRequest.getLedgerId();\n+\n+        final WriteLacResponse.Builder writeLacResponse = WriteLacResponse.newBuilder().setLedgerId(ledgerId);\n+\n+        if (!isVersionCompatible()) {\n+            writeLacResponse.setStatus(StatusCode.EBADVERSION);\n+            return writeLacResponse.build();\n+        }\n+\n+        if (requestProcessor.bookie.isReadOnly()) {\n+            logger.warn(\"BookieServer is running as readonly mode, so rejecting the request from the client!\");\n+            writeLacResponse.setStatus(StatusCode.EREADONLY);\n+            return writeLacResponse.build();\n+        }\n+\n+        StatusCode status = null;\n+        ByteBuffer lacToAdd = writeLacRequest.getBody().asReadOnlyByteBuffer();\n+        byte[] masterKey = writeLacRequest.getMasterKey().toByteArray();\n+\n+        try {\n+            requestProcessor.bookie.setExplicitLac(lacToAdd, channel, masterKey);\n+            status = StatusCode.EOK;\n+        } catch (IOException e) {\n+            logger.error(\"Error saving lac for ledger:{}\",\n+                          new Object[] { lac, ledgerId, e });\n+            status = StatusCode.EIO;\n+        } catch (BookieException e) {\n+            logger.error(\"Unauthorized access to ledger:{} while adding lac:{}\",\n+                                                  ledgerId, lac);\n+            status = StatusCode.EUA;\n+        } catch (Throwable t) {\n+            logger.error(\"Unexpected exception while writing {}@{} : \",\n+                    new Object[] { lac, t });\n+            // some bad request which cause unexpected exception\n+            status = StatusCode.EBADREQ;\n+        }\n+\n+        // If everything is okay, we return null so that the calling function\n+        // dosn't return a response back to the caller.\n+        if (status.equals(StatusCode.EOK)) {\n+            requestProcessor.writeLacStats.registerSuccessfulEvent(MathUtils.elapsedNanos(startTimeNanos), TimeUnit.NANOSECONDS);\n+        } else {\n+            requestProcessor.writeLacStats.registerFailedEvent(MathUtils.elapsedNanos(startTimeNanos), TimeUnit.NANOSECONDS);\n+        }\n+        writeLacResponse.setStatus(status);\n+        return writeLacResponse.build();\n+    }\n+\n+    @Override\n+    public void safeRun() {\n+        WriteLacResponse writeLacResponse = getWriteLacResponse();\n+        if (null != writeLacResponse) {\n+            Response.Builder response = Response.newBuilder()\n+                    .setHeader(getHeader())\n+                    .setStatus(writeLacResponse.getStatus())\n+                    .setWriteLacResponse(writeLacResponse);\n+            Response resp = response.build();\n+            sendResponse(writeLacResponse.getStatus(), resp, requestProcessor.writeLacStats);\n+        }\n+    }\n+}\n+\n+"},{"sha":"64e524db0e8386e9c64a5dacd0dc3402984a9ced","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/util/OrderedSafeExecutor.java","status":"modified","additions":108,"deletions":10,"changes":118,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/c813b3d3298586ded02032a57a99d5fc6c974581/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2FOrderedSafeExecutor.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/c813b3d3298586ded02032a57a99d5fc6c974581/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2FOrderedSafeExecutor.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2FOrderedSafeExecutor.java?ref=c813b3d3298586ded02032a57a99d5fc6c974581","patch":"@@ -21,12 +21,15 @@\n import com.google.common.util.concurrent.ThreadFactoryBuilder;\n import java.util.Random;\n import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.Callable;\n import java.util.concurrent.ExecutionException;\n import java.util.concurrent.ExecutorService;\n import java.util.concurrent.Executors;\n import java.util.concurrent.LinkedBlockingQueue;\n import java.util.concurrent.RejectedExecutionException;\n import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n import java.util.concurrent.ThreadFactory;\n import java.util.concurrent.ThreadPoolExecutor;\n import java.util.concurrent.TimeUnit;\n@@ -58,9 +61,8 @@\n public class OrderedSafeExecutor {\n     final static long WARN_TIME_MICRO_SEC_DEFAULT = TimeUnit.SECONDS.toMicros(1);\n     final String name;\n-    final ThreadPoolExecutor threads[];\n+    final ScheduledThreadPoolExecutor threads[];\n     final long threadIds[];\n-    final BlockingQueue<Runnable> queues[];\n     final Random rand = new Random();\n     final OpStatsLogger taskExecutionStats;\n     final OpStatsLogger taskPendingStats;\n@@ -173,17 +175,15 @@ private OrderedSafeExecutor(String baseName, int numThreads, ThreadFactory threa\n \n         this.warnTimeMicroSec = warnTimeMicroSec;\n         name = baseName;\n-        threads = new ThreadPoolExecutor[numThreads];\n+        threads = new ScheduledThreadPoolExecutor[numThreads];\n         threadIds = new long[numThreads];\n-        queues = new BlockingQueue[numThreads];\n         for (int i = 0; i < numThreads; i++) {\n-            queues[i] = new LinkedBlockingQueue<Runnable>();\n-            threads[i] =  new ThreadPoolExecutor(1, 1,\n-                    0L, TimeUnit.MILLISECONDS, queues[i],\n+            threads[i] =  new ScheduledThreadPoolExecutor(1,\n                     new ThreadFactoryBuilder()\n                         .setNameFormat(name + \"-orderedsafeexecutor-\" + i + \"-%d\")\n                         .setThreadFactory(threadFactory)\n                         .build());\n+            threads[i].setMaximumPoolSize(1);\n \n             // Save thread ids\n             final int idx = i;\n@@ -209,7 +209,7 @@ public Number getDefaultValue() {\n \n                 @Override\n                 public Number getSample() {\n-                    return queues[idx].size();\n+                    return threads[idx].getQueue().size();\n                 }\n             });\n             statsLogger.registerGauge(String.format(\"%s-completed-tasks-%d\", name, idx), new Gauge<Number>() {\n@@ -242,7 +242,7 @@ public Number getSample() {\n         this.traceTaskExecution = traceTaskExecution;\n     }\n \n-    ExecutorService chooseThread() {\n+    ScheduledExecutorService chooseThread() {\n         // skip random # generation in this special case\n         if (threads.length == 1) {\n             return threads[0];\n@@ -252,7 +252,7 @@ ExecutorService chooseThread() {\n \n     }\n \n-    ExecutorService chooseThread(Object orderingKey) {\n+    ScheduledExecutorService chooseThread(Object orderingKey) {\n         // skip hashcode generation in this special case\n         if (threads.length == 1) {\n             return threads[0];\n@@ -286,6 +286,104 @@ public void submitOrdered(Object orderingKey, SafeRunnable r) {\n         chooseThread(orderingKey).submit(timedRunnable(r));\n     }\n \n+    /**\n+     * Creates and executes a one-shot action that becomes enabled after the given delay.\n+     * \n+     * @param command - the SafeRunnable to execute\n+     * @param delay - the time from now to delay execution\n+     * @param unit - the time unit of the delay parameter\n+     * @return a ScheduledFuture representing pending completion of the task and whose get() method will return null upon completion\n+     */\n+    public ScheduledFuture<?> schedule(SafeRunnable command, long delay, TimeUnit unit) {\n+        return chooseThread().schedule(command, delay, unit);\n+    }\n+\n+    /**\n+     * Creates and executes a one-shot action that becomes enabled after the given delay.\n+     * \n+     * @param orderingKey - the key used for ordering \n+     * @param command - the SafeRunnable to execute\n+     * @param delay - the time from now to delay execution\n+     * @param unit - the time unit of the delay parameter\n+     * @return a ScheduledFuture representing pending completion of the task and whose get() method will return null upon completion\n+     */\n+    public ScheduledFuture<?> scheduleOrdered(Object orderingKey, SafeRunnable command, long delay, TimeUnit unit) {\n+        return chooseThread(orderingKey).schedule(command, delay, unit);\n+    }\n+\n+    /** \n+     * Creates and executes a periodic action that becomes enabled first after\n+     * the given initial delay, and subsequently with the given period; \n+     * \n+     * For more details check scheduleAtFixedRate in interface ScheduledExecutorService\n+     * \n+     * @param command - the SafeRunnable to execute\n+     * @param initialDelay - the time to delay first execution\n+     * @param period - the period between successive executions\n+     * @param unit - the time unit of the initialDelay and period parameters\n+     * @return a ScheduledFuture representing pending completion of the task, and whose get() \n+     * method will throw an exception upon cancellation\n+     */\n+    public ScheduledFuture<?> scheduleAtFixedRate(SafeRunnable command, long initialDelay, long period, TimeUnit unit) {\n+        return chooseThread().scheduleAtFixedRate(command, initialDelay, period, unit);\n+    }\n+\n+    /** \n+     * Creates and executes a periodic action that becomes enabled first after\n+     * the given initial delay, and subsequently with the given period; \n+     * \n+     * For more details check scheduleAtFixedRate in interface ScheduledExecutorService\n+     * \n+     * @param orderingKey - the key used for ordering\n+     * @param command - the SafeRunnable to execute\n+     * @param initialDelay - the time to delay first execution\n+     * @param period - the period between successive executions\n+     * @param unit - the time unit of the initialDelay and period parameters\n+     * @return a ScheduledFuture representing pending completion of the task, and whose get() method \n+     * will throw an exception upon cancellation\n+     */\n+    public ScheduledFuture<?> scheduleAtFixedRateOrdered(Object orderingKey, SafeRunnable command, long initialDelay,\n+            long period, TimeUnit unit) {\n+        return chooseThread(orderingKey).scheduleAtFixedRate(command, initialDelay, period, unit);\n+    }\n+\n+    /**\n+     * Creates and executes a periodic action that becomes enabled first after the given initial delay, and subsequently \n+     * with the given delay between the termination of one execution and the commencement of the next.\n+     * \n+     * For more details check scheduleWithFixedDelay in interface ScheduledExecutorService\n+     * \n+     * @param command - the SafeRunnable to execute\n+     * @param initialDelay - the time to delay first execution\n+     * @param delay - the delay between the termination of one execution and the commencement of the next\n+     * @param unit - the time unit of the initialDelay and delay parameters\n+     * @return a ScheduledFuture representing pending completion of the task, and whose get() method \n+     * will throw an exception upon cancellation\n+     */\n+    public ScheduledFuture<?> scheduleWithFixedDelay(SafeRunnable command, long initialDelay, long delay,\n+            TimeUnit unit) {\n+        return chooseThread().scheduleWithFixedDelay(command, initialDelay, delay, unit);\n+    }\n+\n+    /**\n+     * Creates and executes a periodic action that becomes enabled first after the given initial delay, and subsequently \n+     * with the given delay between the termination of one execution and the commencement of the next.\n+     * \n+     * For more details check scheduleWithFixedDelay in interface ScheduledExecutorService\n+     * \n+     * @param orderingKey - the key used for ordering\n+     * @param command - the SafeRunnable to execute\n+     * @param initialDelay - the time to delay first execution\n+     * @param delay - the delay between the termination of one execution and the commencement of the next\n+     * @param unit - the time unit of the initialDelay and delay parameters\n+     * @return a ScheduledFuture representing pending completion of the task, and whose get() method \n+     * will throw an exception upon cancellation\n+     */\n+    public ScheduledFuture<?> scheduleWithFixedDelayOrdered(Object orderingKey, SafeRunnable command, long initialDelay,\n+            long delay, TimeUnit unit) {\n+        return chooseThread(orderingKey).scheduleWithFixedDelay(command, initialDelay, delay, unit);\n+    }\n+\n     private long getThreadID(Object orderingKey) {\n         // skip hashcode generation in this special case\n         if (threadIds.length == 1) {"},{"sha":"9ce9baff32702b4ee5243b01b5d7e26ec753f402","filename":"bookkeeper-server/src/main/proto/BookkeeperProtocol.proto","status":"modified","additions":30,"deletions":1,"changes":31,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/c813b3d3298586ded02032a57a99d5fc6c974581/bookkeeper-server%2Fsrc%2Fmain%2Fproto%2FBookkeeperProtocol.proto","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/c813b3d3298586ded02032a57a99d5fc6c974581/bookkeeper-server%2Fsrc%2Fmain%2Fproto%2FBookkeeperProtocol.proto","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fproto%2FBookkeeperProtocol.proto?ref=c813b3d3298586ded02032a57a99d5fc6c974581","patch":"@@ -57,6 +57,8 @@ enum OperationType {\n     RANGE_ADD_ENTRY = 4;\n \n     AUTH = 5;\n+    WRITE_LAC = 6;\n+    READ_LAC = 7;\n }\n \n /**\n@@ -74,6 +76,8 @@ message Request {\n     optional ReadRequest readRequest = 100;\n     optional AddRequest addRequest = 101;\n     optional AuthMessage authRequest = 102;\n+    optional WriteLacRequest writeLacRequest = 103;\n+    optional ReadLacRequest readLacRequest = 104;\n }\n \n message ReadRequest {\n@@ -99,6 +103,17 @@ message AddRequest {\n     required bytes body = 4;\n }\n \n+message WriteLacRequest {\n+    required int64 ledgerId = 1;\n+    required int64 lac = 2;\n+    required bytes masterKey = 3;\n+    required bytes body = 4;\n+}\n+\n+message ReadLacRequest {\n+    required int64 ledgerId = 1;\n+}\n+\n message Response {\n \n     required BKPacketHeader header = 1;\n@@ -109,6 +124,8 @@ message Response {\n     optional ReadResponse readResponse = 100;\n     optional AddResponse addResponse = 101;\n     optional AuthMessage authResponse = 102;\n+    optional WriteLacResponse writeLacResponse = 103;\n+    optional ReadLacResponse readLacResponse = 104;\n }\n \n message ReadResponse {\n@@ -127,4 +144,16 @@ message AddResponse {\n message AuthMessage {\n     required string authPluginName = 1;\n     required bytes payload = 2;\n-}\n\\ No newline at end of file\n+}\n+\n+message WriteLacResponse {\n+    required StatusCode status = 1;\n+    required int64 ledgerId = 2;\n+}\n+\n+message ReadLacResponse {\n+    required StatusCode status = 1;\n+    required int64 ledgerId = 2;\n+    optional bytes lacBody = 3; // lac sent by PutLacRequest\n+    optional bytes lastEntryBody = 4; // Actual last entry on the disk\n+}"},{"sha":"1ce30e990286763436919e206e0dcbf12a9c9885","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/TestSyncThread.java","status":"modified","additions":9,"deletions":0,"changes":9,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/c813b3d3298586ded02032a57a99d5fc6c974581/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FTestSyncThread.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/c813b3d3298586ded02032a57a99d5fc6c974581/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FTestSyncThread.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FTestSyncThread.java?ref=c813b3d3298586ded02032a57a99d5fc6c974581","patch":"@@ -333,6 +333,15 @@ public long getLastAddConfirmed(long ledgerId) throws IOException {\n         public void flush() throws IOException {\n         }\n \n+        @Override\n+        public void setExplicitlac(long ledgerId, ByteBuffer lac) {\n+        }\n+\n+        @Override\n+        public ByteBuffer getExplicitLac(long ledgerId) {\n+            return null;\n+        }\n+\n         @Override\n         public Checkpoint checkpoint(Checkpoint checkpoint)\n                 throws IOException {"},{"sha":"a2532c9a645b7559a1789f842c3187bc32eb406f","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookKeeperTest.java","status":"modified","additions":124,"deletions":0,"changes":124,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/c813b3d3298586ded02032a57a99d5fc6c974581/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookKeeperTest.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/c813b3d3298586ded02032a57a99d5fc6c974581/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookKeeperTest.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookKeeperTest.java?ref=c813b3d3298586ded02032a57a99d5fc6c974581","patch":"@@ -309,4 +309,128 @@ public void testAutoCloseableBookKeeper() throws Exception {\n         }\n         Assert.assertTrue(\"BookKeeper should be closed!\", _bkc.closed);\n     }\n+\n+    @Test(timeout = 60000)\n+    public void testReadHandleWithNoExplicitLAC() throws Exception {\n+        ClientConfiguration confWithNoExplicitLAC = new ClientConfiguration()\n+                .setZkServers(zkUtil.getZooKeeperConnectString());\n+        confWithNoExplicitLAC.setExplictLacInterval(0);\n+\n+        BookKeeper bkcWithNoExplicitLAC = new BookKeeper(confWithNoExplicitLAC);\n+\n+        LedgerHandle wlh = bkcWithNoExplicitLAC.createLedger(digestType, \"testPasswd\".getBytes());\n+        long ledgerId = wlh.getId();\n+        int numOfEntries = 5;\n+        for (int i = 0; i < numOfEntries; i++) {\n+            wlh.addEntry((\"foobar\" + i).getBytes());\n+        }\n+\n+        LedgerHandle rlh = bkcWithNoExplicitLAC.openLedgerNoRecovery(ledgerId, digestType, \"testPasswd\".getBytes());\n+        Assert.assertTrue(\n+                \"Expected LAC of rlh: \" + (numOfEntries - 2) + \" actual LAC of rlh: \" + rlh.getLastAddConfirmed(),\n+                (rlh.getLastAddConfirmed() == (numOfEntries - 2)));\n+\n+        Enumeration<LedgerEntry> entries = rlh.readEntries(0, numOfEntries - 2);\n+        int entryId = 0;\n+        while (entries.hasMoreElements()) {\n+            LedgerEntry entry = entries.nextElement();\n+            String entryString = new String(entry.getEntry());\n+            Assert.assertTrue(\"Expected entry String: \" + (\"foobar\" + entryId) + \" actual entry String: \" + entryString,\n+                    entryString.equals(\"foobar\" + entryId));\n+            entryId++;\n+        }\n+\n+        for (int i = numOfEntries; i < 2 * numOfEntries; i++) {\n+            wlh.addEntry((\"foobar\" + i).getBytes());\n+        }\n+\n+        Thread.sleep(3000);\n+        // since explicitlacflush policy is not enabled for writeledgerhandle, when we try\n+        // to read explicitlac for rlh, it will be LedgerHandle.INVALID_ENTRY_ID. But it\n+        // wont throw some exception.\n+        long explicitlac = rlh.readExplicitLastConfirmed();\n+        Assert.assertTrue(\n+                \"Expected Explicit LAC of rlh: \" + LedgerHandle.INVALID_ENTRY_ID + \" actual ExplicitLAC of rlh: \" + explicitlac,\n+                (explicitlac == LedgerHandle.INVALID_ENTRY_ID));\n+        Assert.assertTrue(\n+                \"Expected LAC of wlh: \" + (2 * numOfEntries - 1) + \" actual LAC of rlh: \" + wlh.getLastAddConfirmed(),\n+                (wlh.getLastAddConfirmed() == (2 * numOfEntries - 1)));\n+        Assert.assertTrue(\n+                \"Expected LAC of rlh: \" + (numOfEntries - 2) + \" actual LAC of rlh: \" + rlh.getLastAddConfirmed(),\n+                (rlh.getLastAddConfirmed() == (numOfEntries - 2)));\n+\n+        try {\n+            rlh.readEntries(numOfEntries - 1, numOfEntries - 1);\n+            fail(\"rlh readEntries beyond \" + (numOfEntries - 2) + \" should fail with ReadException\");\n+        } catch (BKException.BKReadException readException) {\n+        }\n+\n+        rlh.close();\n+        wlh.close();\n+        bkcWithNoExplicitLAC.close();\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testReadHandleWithExplicitLAC() throws Exception {\n+        ClientConfiguration confWithExplicitLAC = new ClientConfiguration()\n+                .setZkServers(zkUtil.getZooKeeperConnectString());\n+        int explictLacInterval = 1;\n+        confWithExplicitLAC.setExplictLacInterval(explictLacInterval);\n+\n+        BookKeeper bkcWithExplicitLAC = new BookKeeper(confWithExplicitLAC);\n+\n+        LedgerHandle wlh = bkcWithExplicitLAC.createLedger(digestType, \"testPasswd\".getBytes());\n+        long ledgerId = wlh.getId();\n+        int numOfEntries = 5;\n+        for (int i = 0; i < numOfEntries; i++) {\n+            wlh.addEntry((\"foobar\" + i).getBytes());\n+        }\n+\n+        LedgerHandle rlh = bkcWithExplicitLAC.openLedgerNoRecovery(ledgerId, digestType, \"testPasswd\".getBytes());\n+\n+        Assert.assertTrue(\n+                \"Expected LAC of rlh: \" + (numOfEntries - 2) + \" actual LAC of rlh: \" + rlh.getLastAddConfirmed(),\n+                (rlh.getLastAddConfirmed() == (numOfEntries - 2)));\n+\n+        for (int i = numOfEntries; i < 2 * numOfEntries; i++) {\n+            wlh.addEntry((\"foobar\" + i).getBytes());\n+        }\n+\n+        // we need to wait for atleast 2 explicitlacintervals,\n+        // since in writehandle for the first call\n+        // lh.getExplicitLastAddConfirmed() will be <\n+        // lh.getPiggyBackedLastAddConfirmed(),\n+        // so it wont make explicit writelac in the first run\n+        Thread.sleep((2 * explictLacInterval + 1) * 1000);\n+        Assert.assertTrue(\n+                \"Expected LAC of wlh: \" + (2 * numOfEntries - 1) + \" actual LAC of wlh: \" + wlh.getLastAddConfirmed(),\n+                (wlh.getLastAddConfirmed() == (2 * numOfEntries - 1)));\n+        // readhandle's lastaddconfirmed wont be updated until readExplicitLastConfirmed call is made   \n+        Assert.assertTrue(\n+                \"Expected LAC of rlh: \" + (numOfEntries - 2) + \" actual LAC of rlh: \" + rlh.getLastAddConfirmed(),\n+                (rlh.getLastAddConfirmed() == (numOfEntries - 2)));\n+        \n+        long explicitlac = rlh.readExplicitLastConfirmed();\n+        Assert.assertTrue(\n+                \"Expected Explicit LAC of rlh: \" + (2 * numOfEntries - 1) + \" actual ExplicitLAC of rlh: \" + explicitlac,\n+                (explicitlac == (2 * numOfEntries - 1)));\n+        // readExplicitLastConfirmed updates the lac of rlh.\n+        Assert.assertTrue(\n+                \"Expected LAC of rlh: \" + (2 * numOfEntries - 1) + \" actual LAC of rlh: \" + rlh.getLastAddConfirmed(),\n+                (rlh.getLastAddConfirmed() == (2 * numOfEntries - 1)));\n+        \n+        Enumeration<LedgerEntry> entries = rlh.readEntries(numOfEntries, 2 * numOfEntries - 1);\n+        int entryId = numOfEntries;\n+        while (entries.hasMoreElements()) {\n+            LedgerEntry entry = entries.nextElement();\n+            String entryString = new String(entry.getEntry());\n+            Assert.assertTrue(\"Expected entry String: \" + (\"foobar\" + entryId) + \" actual entry String: \" + entryString,\n+                    entryString.equals(\"foobar\" + entryId));\n+            entryId++;\n+        }\n+\n+        rlh.close();\n+        wlh.close();\n+        bkcWithExplicitLAC.close();\n+    }\t\n }"},{"sha":"4c2ddaa15a327b343c630a8a2d98194f87d8ed3f","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/LedgerManagerTestCase.java","status":"modified","additions":12,"deletions":0,"changes":12,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/c813b3d3298586ded02032a57a99d5fc6c974581/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FLedgerManagerTestCase.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/c813b3d3298586ded02032a57a99d5fc6c974581/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FLedgerManagerTestCase.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FLedgerManagerTestCase.java?ref=c813b3d3298586ded02032a57a99d5fc6c974581","patch":"@@ -206,5 +206,17 @@ public void updateEntriesLocations(Iterable<EntryLocation> locations) throws IOE\n         @Override\n         public void flushEntriesLocationsIndex() throws IOException {\n         }\n+\n+        @Override\n+        public void setExplicitlac(long ledgerId, ByteBuffer lac) throws IOException {\n+            // TODO Auto-generated method stub\n+\n+        }\n+\n+        @Override\n+        public ByteBuffer getExplicitLac(long ledgerId) {\n+            // TODO Auto-generated method stub\n+            return null;\n+        }\n     }\n }"}]}