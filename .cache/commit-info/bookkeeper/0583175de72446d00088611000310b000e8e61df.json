{"sha":"0583175de72446d00088611000310b000e8e61df","node_id":"MDY6Q29tbWl0NDc4NTkyNTI2OjA1ODMxNzVkZTcyNDQ2ZDAwMDg4NjExMDAwMzEwYjAwMGU4ZTYxZGY=","commit":{"author":{"name":"Rithin","email":"rithin.shetty@salesforce.com","date":"2017-03-28T20:35:30Z"},"committer":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2017-03-28T20:35:30Z"},"message":"BOOKKEEPER-950: Ledger placement policy to accomodate different storage capacity of bookies\n\nâ€¦ge capacity of bookies\n\nThis change introduces Disk weight based ledger placement. Currently free disk space is the only supported\nweight for a bookie. This change also introduces a new protocol message between bk client and server\ncalled GET_BOOKIE_INFO. This message is used by the client to retrieve the free disk space info from\nall the bookies. The existing placement policies: DefaultPlacementPolicy and RackAwarePlacementPolicy\nhave been enhanced to make use of the weight while selecting bookies. New test cases have been added to\ntest RackawarePlacement with weights. A new test class has been added to test the weight based selection\nalgorithm in a stand alone fashion.\n\nAuthor: Rithin <rithin.shetty@salesforce.com>\n\nReviewers: Enrico Olivelli <eolivelli@gmail.com>, Sijie Guo <sijie@apache.org>\n\nCloses #93 from rithin-shetty/weightBasedPlacementDec13","tree":{"sha":"5bf5cccebb6da57735683713345b1fa674d461b2","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/trees/5bf5cccebb6da57735683713345b1fa674d461b2"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/commits/0583175de72446d00088611000310b000e8e61df","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/0583175de72446d00088611000310b000e8e61df","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/0583175de72446d00088611000310b000e8e61df","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/0583175de72446d00088611000310b000e8e61df/comments","author":{"login":"rithin-shetty","id":19738357,"node_id":"MDQ6VXNlcjE5NzM4MzU3","avatar_url":"https://avatars.githubusercontent.com/u/19738357?v=4","gravatar_id":"","url":"https://api.github.com/users/rithin-shetty","html_url":"https://github.com/rithin-shetty","followers_url":"https://api.github.com/users/rithin-shetty/followers","following_url":"https://api.github.com/users/rithin-shetty/following{/other_user}","gists_url":"https://api.github.com/users/rithin-shetty/gists{/gist_id}","starred_url":"https://api.github.com/users/rithin-shetty/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/rithin-shetty/subscriptions","organizations_url":"https://api.github.com/users/rithin-shetty/orgs","repos_url":"https://api.github.com/users/rithin-shetty/repos","events_url":"https://api.github.com/users/rithin-shetty/events{/privacy}","received_events_url":"https://api.github.com/users/rithin-shetty/received_events","type":"User","site_admin":false},"committer":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"parents":[{"sha":"1e4ccaf167936fb4ad0de8c29ecf840bed3e89ed","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/1e4ccaf167936fb4ad0de8c29ecf840bed3e89ed","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/1e4ccaf167936fb4ad0de8c29ecf840bed3e89ed"}],"stats":{"total":8519,"additions":6210,"deletions":2309},"files":[{"sha":"99a2db13755623f9a37f6733adc8bca0421230e1","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BookKeeperServerStats.java","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/0583175de72446d00088611000310b000e8e61df/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FBookKeeperServerStats.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/0583175de72446d00088611000310b000e8e61df/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FBookKeeperServerStats.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FBookKeeperServerStats.java?ref=0583175de72446d00088611000310b000e8e61df","patch":"@@ -37,6 +37,7 @@ public interface BookKeeperServerStats {\n     public final static String READ_ENTRY_FENCE_READ = \"READ_ENTRY_FENCE_READ\";\n     public final static String WRITE_LAC = \"WRITE_LAC\";\n     public final static String READ_LAC = \"READ_LAC\";\n+    public final static String GET_BOOKIE_INFO = \"GET_BOOKIE_INFO\";\n \n     // Bookie Operations\n     public final static String BOOKIE_ADD_ENTRY_BYTES = \"BOOKIE_ADD_ENTRY_BYTES\";"},{"sha":"0338db7599458967a501e9fb0b28092c49799275","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java","status":"modified","additions":8,"deletions":0,"changes":8,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/0583175de72446d00088611000310b000e8e61df/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FBookie.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/0583175de72446d00088611000310b000e8e61df/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FBookie.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FBookie.java?ref=0583175de72446d00088611000310b000e8e61df","patch":"@@ -622,6 +622,14 @@ LedgerDirsManager getIndexDirsManager() {\n         return indexDirsManager;\n     }\n \n+    public long getTotalDiskSpace() {\n+        return getLedgerDirsManager().getTotalDiskSpace();\n+    }\n+\n+    public long getTotalFreeSpace() {\n+        return getLedgerDirsManager().getTotalFreeSpace();\n+    }\n+\n     public static File getCurrentDirectory(File dir) {\n         return new File(dir, BookKeeperConstants.CURRENT_DIR);\n     }"},{"sha":"1400fcb27c35566d3fee28bf50ec96db13fc8466","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BookieShell.java","status":"modified","additions":79,"deletions":0,"changes":79,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/0583175de72446d00088611000310b000e8e61df/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FBookieShell.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/0583175de72446d00088611000310b000e8e61df/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FBookieShell.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FBookieShell.java?ref=0583175de72446d00088611000310b000e8e61df","patch":"@@ -24,12 +24,14 @@\n import java.io.FileNotFoundException;\n import java.io.IOException;\n import java.io.Serializable;\n+import java.math.RoundingMode;\n import java.nio.ByteBuffer;\n import java.nio.file.Files;\n import java.nio.file.Path;\n import java.nio.file.Paths;\n import java.nio.file.attribute.BasicFileAttributes;\n import java.nio.file.attribute.FileTime;\n+import java.text.DecimalFormat;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collection;\n@@ -41,13 +43,16 @@\n import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.TimeUnit;\n \n import org.apache.bookkeeper.bookie.BookieException.InvalidCookieException;\n import org.apache.bookkeeper.bookie.EntryLogger.EntryLogScanner;\n import org.apache.bookkeeper.bookie.Journal.JournalScanner;\n import org.apache.bookkeeper.bookie.Journal;\n import org.apache.bookkeeper.client.BKException;\n+import org.apache.bookkeeper.client.BookieInfoReader;\n+import org.apache.bookkeeper.client.BookieInfoReader.BookieInfo;\n import org.apache.bookkeeper.client.BookKeeper;\n import org.apache.bookkeeper.client.BookKeeper.DigestType;\n import org.apache.bookkeeper.client.BookKeeperAdmin;\n@@ -63,7 +68,10 @@\n import org.apache.bookkeeper.meta.LedgerManagerFactory;\n import org.apache.bookkeeper.meta.LedgerUnderreplicationManager;\n import org.apache.bookkeeper.net.BookieSocketAddress;\n+import org.apache.bookkeeper.proto.BookieClient;\n+import org.apache.bookkeeper.proto.BookkeeperProtocol;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GetBookieInfoCallback;\n import org.apache.bookkeeper.replication.AuditorElector;\n import org.apache.bookkeeper.util.EntryFormatter;\n import org.apache.bookkeeper.util.IOUtils;\n@@ -78,6 +86,7 @@\n import org.apache.commons.cli.MissingArgumentException;\n import org.apache.commons.cli.Options;\n import org.apache.commons.cli.ParseException;\n+import org.apache.commons.collections.CollectionUtils;\n import org.apache.commons.configuration.CompositeConfiguration;\n import org.apache.commons.configuration.Configuration;\n import org.apache.commons.configuration.PropertiesConfiguration;\n@@ -126,6 +135,7 @@ public class BookieShell implements Tool {\n     static final String CMD_EXPANDSTORAGE = \"expandstorage\";\n     static final String CMD_UPDATELEDGER = \"updateledgers\";\n     static final String CMD_DELETELEDGER = \"deleteledger\";\n+    static final String CMD_BOOKIEINFO = \"bookieinfo\";\n     static final String CMD_HELP = \"help\";\n \n     final ServerConfiguration bkConf = new ServerConfiguration();\n@@ -1752,6 +1762,74 @@ Options getOptions() {\n         }\n     }\n \n+    /*\n+     * Command to retrieve bookie information like free disk space, etc from all\n+     * the bookies in the cluster.\n+     */\n+    class BookieInfoCmd extends MyCommand {\n+        Options lOpts = new Options();\n+\n+        BookieInfoCmd() {\n+            super(CMD_BOOKIEINFO);\n+        }\n+\n+        @Override\n+        String getDescription() {\n+            return \"Retrieve bookie info such as free and total disk space\";\n+        }\n+\n+        @Override\n+        String getUsage() {\n+            return \"bookieinfo\";\n+        }\n+\n+        @Override\n+        Options getOptions() {\n+            return lOpts;\n+        }\n+\n+        String getReadable(long val) {\n+            String unit[] = {\"\", \"KB\", \"MB\", \"GB\", \"TB\" };\n+            int cnt = 0;\n+            double d = val;\n+            while (d >= 1000 && cnt < unit.length-1) {\n+                d = d/1000;\n+                cnt++;\n+            }\n+            DecimalFormat df = new DecimalFormat(\"#.###\");\n+            df.setRoundingMode(RoundingMode.DOWN);\n+            return cnt > 0 ? \"(\" + df.format(d) + unit[cnt] + \")\" : unit[cnt];\n+        }\n+\n+        @Override\n+        public int runCmd(CommandLine cmdLine) throws Exception {\n+            ClientConfiguration clientConf = new ClientConfiguration(bkConf);\n+            clientConf.setDiskWeightBasedPlacementEnabled(true);\n+            BookKeeper bk = new BookKeeper(clientConf);\n+\n+            Map<BookieSocketAddress, BookieInfo> map = bk.getBookieInfo();\n+            if (map.size() == 0) {\n+                System.out.println(\"Failed to retrieve bookie information from any of the bookies\");\n+                bk.close();\n+                return 0;\n+            }\n+\n+            System.out.println(\"Free disk space info:\");\n+            long totalFree = 0, total=0;\n+            for (Map.Entry<BookieSocketAddress, BookieInfo> e : map.entrySet()) {\n+                BookieInfo bInfo = e.getValue();\n+                System.out.println(e.getKey() + \":\\tFree: \" + bInfo.getFreeDiskSpace() +  getReadable(bInfo.getFreeDiskSpace()) +\n+                        \"\\tTotal: \" + bInfo.getTotalDiskSpace() +  getReadable(bInfo.getTotalDiskSpace()));\n+                totalFree += bInfo.getFreeDiskSpace();\n+                total += bInfo.getTotalDiskSpace();\n+            }\n+            System.out.println(\"Total free disk space in the cluster:\\t\" + totalFree + getReadable(totalFree));\n+            System.out.println(\"Total disk capacity in the cluster:\\t\" + total + getReadable(total));\n+            bk.close();\n+            return 0;\n+        }\n+    }\n+\n     /**\n      * A facility for reporting update ledger progress.\n      */\n@@ -1782,6 +1860,7 @@ public interface UpdateLedgerNotifier {\n         commands.put(CMD_EXPANDSTORAGE, new ExpandStorageCmd());\n         commands.put(CMD_UPDATELEDGER, new UpdateLedgerCmd());\n         commands.put(CMD_DELETELEDGER, new DeleteLedgerCmd());\n+        commands.put(CMD_BOOKIEINFO, new BookieInfoCmd());\n         commands.put(CMD_HELP, new HelpCmd());\n     }\n "},{"sha":"8f65c6ba3117636e6f4f64da624fc8970da780b2","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDirsManager.java","status":"modified","additions":28,"deletions":0,"changes":28,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/0583175de72446d00088611000310b000e8e61df/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLedgerDirsManager.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/0583175de72446d00088611000310b000e8e61df/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLedgerDirsManager.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLedgerDirsManager.java?ref=0583175de72446d00088611000310b000e8e61df","patch":"@@ -118,6 +118,34 @@ public List<File> getAllLedgerDirs() {\n         return ledgerDirectories;\n     }\n \n+    /**\n+     * Calculate the total amount of free space available\n+     * in all of the ledger directories put together.\n+     *\n+     * @return totalDiskSpace in bytes\n+     */\n+    public long getTotalFreeSpace() {\n+        long totalFreeSpace = 0;\n+        for (File dir: this.ledgerDirectories) {\n+            totalFreeSpace += dir.getFreeSpace();\n+        }\n+        return totalFreeSpace;\n+    }\n+\n+    /**\n+     * Calculate the total amount of free space available\n+     * in all of the ledger directories put together.\n+     *\n+     * @return freeDiskSpace in bytes\n+     */\n+    public long getTotalDiskSpace() {\n+        long totalDiskSpace = 0;\n+        for (File dir: this.ledgerDirectories) {\n+            totalDiskSpace += dir.getTotalSpace();\n+        }\n+        return totalDiskSpace;\n+    }\n+\n     /**\n      * Get only writable ledger dirs.\n      */"},{"sha":"00ac0d06bdc9d44b983020b522d26db5b93d2039","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LocalBookieEnsemblePlacementPolicy.java","status":"modified","additions":9,"deletions":3,"changes":12,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/0583175de72446d00088611000310b000e8e61df/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLocalBookieEnsemblePlacementPolicy.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/0583175de72446d00088611000310b000e8e61df/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLocalBookieEnsemblePlacementPolicy.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLocalBookieEnsemblePlacementPolicy.java?ref=0583175de72446d00088611000310b000e8e61df","patch":"@@ -23,20 +23,22 @@\n import java.util.*;\n \n import org.apache.bookkeeper.client.BKException;\n+import org.apache.bookkeeper.client.BookieInfoReader.BookieInfo;\n import org.apache.bookkeeper.client.EnsemblePlacementPolicy;\n import org.apache.bookkeeper.client.BKException.BKNotEnoughBookiesException;\n import org.apache.bookkeeper.conf.ClientConfiguration;\n import org.apache.bookkeeper.conf.ServerConfiguration;\n import org.apache.bookkeeper.feature.FeatureProvider;\n import org.apache.bookkeeper.net.BookieSocketAddress;\n-import org.apache.bookkeeper.stats.StatsLogger;\n import org.apache.bookkeeper.net.DNSToSwitchMapping;\n-import org.jboss.netty.util.HashedWheelTimer;\n+import org.apache.bookkeeper.stats.StatsLogger;\n import org.apache.commons.configuration.Configuration;\n+import com.google.common.collect.Lists;\n+import org.jboss.netty.util.HashedWheelTimer;\n+\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import com.google.common.collect.Lists;\n \n /**\n  * Special ensemble placement policy that always return local bookie. Only works with ledgers with ensemble=1.\n@@ -100,4 +102,8 @@ public ArrayList<BookieSocketAddress> newEnsemble(int ensembleSize, int writeQuo\n         return Lists.newArrayList(bookieAddress);\n     }\n \n+    @Override\n+    public void updateBookieInfo(Map<BookieSocketAddress, BookieInfo> bookieToFreeSpaceMap) {\n+        return;\n+    }\n }"},{"sha":"a42db175f0cdcd0b1c806ca5229dd4d3a09fd29a","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeper.java","status":"modified","additions":37,"deletions":1,"changes":38,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/0583175de72446d00088611000310b000e8e61df/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookKeeper.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/0583175de72446d00088611000310b000e8e61df/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookKeeper.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookKeeper.java?ref=0583175de72446d00088611000310b000e8e61df","patch":"@@ -36,6 +36,7 @@\n import org.apache.bookkeeper.client.AsyncCallback.DeleteCallback;\n import org.apache.bookkeeper.client.AsyncCallback.OpenCallback;\n import org.apache.bookkeeper.client.AsyncCallback.IsClosedCallback;\n+import org.apache.bookkeeper.client.BookieInfoReader.BookieInfo;\n import org.apache.bookkeeper.conf.ClientConfiguration;\n import org.apache.bookkeeper.feature.FeatureProvider;\n import org.apache.bookkeeper.feature.SettableFeatureProvider;\n@@ -65,6 +66,7 @@\n import org.slf4j.LoggerFactory;\n \n import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+\n import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.ExecutionException;\n \n@@ -114,6 +116,7 @@ public class BookKeeper implements AutoCloseable {\n     final HashedWheelTimer requestTimer;\n     final boolean ownTimer;\n     final FeatureProvider featureProvider;\n+    ScheduledExecutorService bookieInfoScheduler;\n \n     // Ledger manager responsible for how to store ledger meta data\n     final LedgerManagerFactory ledgerManagerFactory;\n@@ -122,6 +125,7 @@ public class BookKeeper implements AutoCloseable {\n \n     // Ensemble Placement Policy\n     final EnsemblePlacementPolicy placementPolicy;\n+    BookieInfoReader bookieInfoReader;\n \n     final ClientConfiguration conf;\n     final int explicitLacInterval;\n@@ -363,7 +367,19 @@ private BookKeeper(ClientConfiguration conf,\n         // initialize bookie client\n         this.bookieClient = new BookieClient(conf, this.channelFactory, this.mainWorkerPool, statsLogger);\n         this.bookieWatcher = new BookieWatcher(conf, this.scheduler, this.placementPolicy, this);\n-        this.bookieWatcher.readBookiesBlocking();\n+        if (conf.getDiskWeightBasedPlacementEnabled()) {\n+            LOG.info(\"Weighted ledger placement enabled\");\n+            ThreadFactoryBuilder tFBuilder = new ThreadFactoryBuilder()\n+                    .setNameFormat(\"BKClientMetaDataPollScheduler-%d\");\n+            this.bookieInfoScheduler = Executors.newSingleThreadScheduledExecutor(tFBuilder.build());\n+            this.bookieInfoReader = new BookieInfoReader(this, conf, this.bookieInfoScheduler);\n+            this.bookieWatcher.readBookiesBlocking();\n+            this.bookieInfoReader.start();\n+        } else {\n+            LOG.info(\"Weighted ledger placement is not enabled\");\n+            this.bookieInfoReader = new BookieInfoReader(this, conf, null);\n+            this.bookieWatcher.readBookiesBlocking();\n+        }\n \n         // initialize ledger manager\n         this.ledgerManagerFactory = LedgerManagerFactory.newLedgerManagerFactory(conf, this.zk);\n@@ -466,6 +482,20 @@ BookieClient getBookieClient() {\n         return bookieClient;\n     }\n \n+    /**\n+     * Retrieves BookieInfo from all the bookies in the cluster. It sends requests\n+     * to all the bookies in parallel and returns the info from the bookies that responded.\n+     * If there was an error in reading from any bookie, nothing will be returned for\n+     * that bookie in the map.\n+     * @return map\n+     *             A map of bookieSocketAddress to its BookiInfo\n+     * @throws BKException\n+     * @throws InterruptedException\n+     */\n+    public Map<BookieSocketAddress, BookieInfo> getBookieInfo() throws BKException, InterruptedException {\n+        return bookieInfoReader.getBookieInfo();\n+    }\n+\n     /**\n      * Creates a new ledger asynchronously. To create a ledger, we need to specify\n      * the ensemble size, the quorum size, the digest type, a password, a callback\n@@ -1138,6 +1168,12 @@ public void close() throws InterruptedException, BKException {\n         if (!mainWorkerPool.awaitTermination(10, TimeUnit.SECONDS)) {\n             LOG.warn(\"The mainWorkerPool did not shutdown cleanly\");\n         }\n+        if (this.bookieInfoScheduler != null) {\n+            this.bookieInfoScheduler.shutdown();\n+            if (!bookieInfoScheduler.awaitTermination(10, TimeUnit.SECONDS)) {\n+                LOG.warn(\"The bookieInfoScheduler did not shutdown cleanly\");\n+            }\n+        }\n \n         if (ownTimer) {\n             requestTimer.stop();"},{"sha":"dc193a79b8cf93050c3c2c81027da4abd7c4ba7c","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeperClientStats.java","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/0583175de72446d00088611000310b000e8e61df/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookKeeperClientStats.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/0583175de72446d00088611000310b000e8e61df/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookKeeperClientStats.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookKeeperClientStats.java?ref=0583175de72446d00088611000310b000e8e61df","patch":"@@ -34,6 +34,7 @@ public interface BookKeeperClientStats {\n     public final static String ENSEMBLE_CHANGES = \"NUM_ENSEMBLE_CHANGE\";\n     public final static String LAC_UPDATE_HITS = \"LAC_UPDATE_HITS\";\n     public final static String LAC_UPDATE_MISSES = \"LAC_UPDATE_MISSES\";\n+    public final static String GET_BOOKIE_INFO_OP = \"GET_BOOKIE_INFO\";\n \n     // per channel stats\n     public final static String CHANNEL_SCOPE = \"per_channel_bookie_client\";\n@@ -46,4 +47,5 @@ public interface BookKeeperClientStats {\n     public final static String CHANNEL_TIMEOUT_WRITE_LAC = \"TIMEOUT_WRITE_LAC\";\n     public final static String CHANNEL_READ_LAC_OP = \"READ_LAC\";\n     public final static String CHANNEL_TIMEOUT_READ_LAC = \"TIMEOUT_READ_LAC\";\n+    public final static String TIMEOUT_GET_BOOKIE_INFO = \"TIMEOUT_GET_BOOKIE_INFO\";\n }"},{"sha":"7ef1b7665f6f4b19659ccc66421c9f63f558265d","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookieInfoReader.java","status":"added","additions":261,"deletions":0,"changes":261,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/0583175de72446d00088611000310b000e8e61df/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookieInfoReader.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/0583175de72446d00088611000310b000e8e61df/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookieInfoReader.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookieInfoReader.java?ref=0583175de72446d00088611000310b000e8e61df","patch":"@@ -0,0 +1,261 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.bookkeeper.client;\n+\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.bookkeeper.client.WeightedRandomSelection.WeightedObject;\n+import org.apache.bookkeeper.conf.ClientConfiguration;\n+import org.apache.bookkeeper.net.BookieSocketAddress;\n+import org.apache.bookkeeper.proto.BookieClient;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GetBookieInfoCallback;\n+import org.apache.bookkeeper.proto.BookkeeperProtocol;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class BookieInfoReader {\n+    private static final Logger LOG = LoggerFactory.getLogger(BookieInfoReader.class);\n+    private final ScheduledExecutorService scheduler;\n+    private final BookKeeper bk;\n+    private final ClientConfiguration conf;\n+    private ConcurrentMap<BookieSocketAddress, BookieInfo> bookieInfoMap = new ConcurrentHashMap<BookieSocketAddress, BookieInfo>();\n+    private Collection<BookieSocketAddress> bookies;\n+    private final AtomicInteger totalSent = new AtomicInteger();\n+    private final AtomicInteger completedCnt = new AtomicInteger();\n+    private final AtomicBoolean instanceRunning = new AtomicBoolean();\n+    private final AtomicBoolean isQueued = new AtomicBoolean();\n+    private final AtomicBoolean refreshBookieList = new AtomicBoolean();\n+\n+    public static class BookieInfo implements WeightedObject {\n+        private final long freeDiskSpace;\n+        private final long totalDiskSpace;\n+        public BookieInfo() {\n+            this(0L, 0L);\n+        }\n+        public BookieInfo(long totalDiskSpace, long freeDiskSpace) {\n+            this.totalDiskSpace = totalDiskSpace;\n+            this.freeDiskSpace = freeDiskSpace;\n+        }\n+        public long getFreeDiskSpace() {\n+            return freeDiskSpace;\n+        }\n+        public long getTotalDiskSpace() {\n+            return totalDiskSpace;\n+        }\n+        @Override\n+        public long getWeight() {\n+            return freeDiskSpace;\n+        }\n+        public String toString() {\n+            return \"FreeDiskSpace: \" + this.freeDiskSpace + \" TotalDiskCapacity: \" + this.totalDiskSpace;\n+        }\n+    }\n+\n+    BookieInfoReader(BookKeeper bk,\n+                          ClientConfiguration conf,\n+                          ScheduledExecutorService scheduler) {\n+        this.bk = bk;\n+        this.conf = conf;\n+        this.scheduler = scheduler;\n+    }\n+    void start() {\n+        scheduler.scheduleAtFixedRate(new Runnable() {\n+            @Override\n+            public void run() {\n+                LOG.debug(\"Running periodic BookieInfo scan\");\n+                getReadWriteBookieInfo(null);\n+            }\n+        }, 0, conf.getGetBookieInfoIntervalSeconds(), TimeUnit.SECONDS);\n+    }\n+    void submitTask(final Collection<BookieSocketAddress> newBookies) {\n+        scheduler.submit(new Runnable() {\n+            @Override\n+            public void run() {\n+                getReadWriteBookieInfo(newBookies);\n+            }\n+        });\n+    }\n+    void availableBookiesChanged(Set<BookieSocketAddress> newBookies) {\n+        LOG.info(\"Scheduling bookie info read due to changes in available bookies.\");\n+        submitTask(newBookies);\n+    }\n+\n+    /*\n+     * This routine is responsible for issuing bookieInfoGet messages to all the read write bookies.\n+     * instanceRunning will be true until we have sent the bookieInfoGet requests to\n+     * all the readwrite bookies and have processed all the callbacks. Only then is it reset to\n+     * false. At that time, if any pending tasks are queued, they are scheduled by the\n+     * last callback processing task. isQueued variable is used to indicate the pending\n+     * tasks. refreshBookieList is used to indicate that we need to read we need to explicitly\n+     * retireve the bookies list from zk because we don't remember the bookie list for\n+     * queued ops.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    void getReadWriteBookieInfo(Collection<BookieSocketAddress> newBookiesList) {\n+        if (instanceRunning.get() == false) {\n+            instanceRunning.compareAndSet(false, true);\n+        } else {\n+            isQueued.set(true);\n+            if (newBookiesList != null) {\n+                refreshBookieList.set(true);\n+            }\n+            LOG.debug(\"Exiting due to running instance\");\n+            return;\n+        }\n+        Collection<BookieSocketAddress> deadBookies = null, joinedBookies=null;\n+        if (newBookiesList == null) {\n+            try {\n+                if (this.bookies == null) {\n+                    joinedBookies = this.bookies = bk.bookieWatcher.getBookies();\n+                } else if (refreshBookieList.get()) {\n+                    LOG.debug(\"Refreshing bookie list\");\n+                    newBookiesList = bk.bookieWatcher.getBookies();\n+                    refreshBookieList.set(false);\n+                } else {\n+                    // the bookie list is already up to date, just retrieve their info\n+                    joinedBookies = this.bookies;\n+                }\n+            } catch (BKException e) {\n+                LOG.error(\"Unable to get the available bookies \", e);\n+                onExit();\n+                return;\n+            }\n+        }\n+        if (newBookiesList != null) {\n+            if (this.bookies != null) {\n+                joinedBookies = CollectionUtils.subtract(newBookiesList, this.bookies);\n+                deadBookies = CollectionUtils.subtract(this.bookies, newBookiesList);\n+                for (BookieSocketAddress b : deadBookies) {\n+                    bookieInfoMap.remove(b);\n+                    this.bookies.remove(b);\n+                }\n+                for (BookieSocketAddress b : joinedBookies) {\n+                    this.bookies.add(b);\n+                }\n+            } else {\n+                joinedBookies = this.bookies = newBookiesList;\n+            }\n+        }\n+\n+        BookieClient bkc = bk.getBookieClient();\n+        final long requested = BookkeeperProtocol.GetBookieInfoRequest.Flags.TOTAL_DISK_CAPACITY_VALUE |\n+                               BookkeeperProtocol.GetBookieInfoRequest.Flags.FREE_DISK_SPACE_VALUE;\n+        totalSent.set(0);\n+        completedCnt.set(0);\n+        LOG.debug(\"Getting bookie info for: {}\", joinedBookies);\n+        for (BookieSocketAddress b : joinedBookies) {\n+            bkc.getBookieInfo(b, requested,\n+                    new GetBookieInfoCallback() {\n+                        void processReadInfoComplete(int rc, BookieInfo bInfo, Object ctx) {\n+                            BookieSocketAddress b = (BookieSocketAddress) ctx;\n+                            if (rc != BKException.Code.OK) {\n+                                LOG.error(\"Reading bookie info from bookie {} failed due to error: {}.\", b, rc);\n+                                // if there was data earlier, don't overwrite it\n+                                // create a new one only if the key was missing\n+                                bookieInfoMap.putIfAbsent(b, new BookieInfo());\n+                            } else {\n+                                LOG.debug(\"Bookie Info for bookie {} is {}\", b, bInfo);\n+                                bookieInfoMap.put(b, bInfo);\n+                            }\n+                            if (completedCnt.incrementAndGet() == totalSent.get()) {\n+                                bk.placementPolicy.updateBookieInfo(bookieInfoMap);\n+                                onExit();\n+                            }\n+                        }\n+                        @Override\n+                        public void getBookieInfoComplete(final int rc, final BookieInfo bInfo, final Object ctx) {\n+                            scheduler.submit(\n+                                new Runnable() {\n+                                    @Override\n+                                    public void run() {\n+                                        processReadInfoComplete(rc, bInfo, ctx);\n+                                    }\n+                                });\n+                        }\n+                    }, b);\n+            totalSent.incrementAndGet();\n+        }\n+        if (totalSent.get() == 0) {\n+            if (deadBookies != null) {\n+                // if no new bookies joined but some existing bookies went away\n+                // we need to inform the placementPloicy\n+                bk.placementPolicy.updateBookieInfo(bookieInfoMap);\n+            }\n+            onExit();\n+        }\n+    }\n+\n+    void onExit() {\n+        if (isQueued.get()) {\n+            LOG.debug(\"Scheduling a queued task\");\n+            submitTask(null);\n+        }\n+        isQueued.set(false);\n+        instanceRunning.set(false);\n+    }\n+\n+    Map<BookieSocketAddress, BookieInfo> getBookieInfo() throws BKException, InterruptedException {\n+        BookieClient bkc = bk.getBookieClient();\n+        final AtomicInteger totalSent = new AtomicInteger();\n+        final AtomicInteger totalCompleted = new AtomicInteger();\n+        final ConcurrentMap<BookieSocketAddress, BookieInfo> map = new ConcurrentHashMap<BookieSocketAddress, BookieInfo>();\n+        final CountDownLatch latch = new CountDownLatch(1);\n+        long requested = BookkeeperProtocol.GetBookieInfoRequest.Flags.TOTAL_DISK_CAPACITY_VALUE |\n+                         BookkeeperProtocol.GetBookieInfoRequest.Flags.FREE_DISK_SPACE_VALUE;\n+\n+        Collection<BookieSocketAddress> bookies;\n+        bookies = bk.bookieWatcher.getBookies();\n+        bookies.addAll(bk.bookieWatcher.getReadOnlyBookies());\n+\n+        totalSent.set(bookies.size());\n+        for (BookieSocketAddress b : bookies) {\n+            bkc.getBookieInfo(b, requested, new GetBookieInfoCallback() {\n+                        @Override\n+                        public void getBookieInfoComplete(int rc, BookieInfo bInfo, Object ctx) {\n+                            BookieSocketAddress b = (BookieSocketAddress) ctx;\n+                            if (rc != BKException.Code.OK) {\n+                                LOG.error(\"Reading bookie info from bookie {} failed due to error: {}.\", b, rc);\n+                            } else {\n+                                LOG.debug(\"Free disk space on bookie {} is {}.\", b, bInfo.getFreeDiskSpace());\n+                                map.put(b, bInfo);\n+                            }\n+                            if (totalCompleted.incrementAndGet() == totalSent.get()) {\n+                                latch.countDown();\n+                            }\n+                        }\n+                    }, b);\n+        }\n+        try {\n+            latch.await();\n+        } catch (InterruptedException e) {\n+            LOG.error(\"Received InterruptedException \", e);\n+            throw e;\n+        }\n+        return map;\n+    }\n+}"},{"sha":"04499eb104d765787c50a675d3d11ce9d862ebcb","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookieWatcher.java","status":"modified","additions":4,"deletions":0,"changes":4,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/0583175de72446d00088611000310b000e8e61df/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookieWatcher.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/0583175de72446d00088611000310b000e8e61df/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookieWatcher.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookieWatcher.java?ref=0583175de72446d00088611000310b000e8e61df","patch":"@@ -184,6 +184,10 @@ public void processResult(int rc, String path, Object ctx, List<String> children\n         synchronized (this) {\n             Set<BookieSocketAddress> readonlyBookies = readOnlyBookieWatcher.getReadOnlyBookies();\n             placementPolicy.onClusterChanged(newBookieAddrs, readonlyBookies);\n+            if (bk.conf.getDiskWeightBasedPlacementEnabled()) {\n+                // start collecting bookieInfo for the newly joined bookies, if any\n+                bk.bookieInfoReader.availableBookiesChanged(newBookieAddrs);\n+            }\n         }\n \n         // we don't need to close clients here, because:"},{"sha":"2b13a29a2100bdbad9d66770644132bb9de6cf84","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/DefaultEnsemblePlacementPolicy.java","status":"modified","additions":94,"deletions":18,"changes":112,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/0583175de72446d00088611000310b000e8e61df/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FDefaultEnsemblePlacementPolicy.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/0583175de72446d00088611000310b000e8e61df/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FDefaultEnsemblePlacementPolicy.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FDefaultEnsemblePlacementPolicy.java?ref=0583175de72446d00088611000310b000e8e61df","patch":"@@ -24,25 +24,40 @@\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n \n import com.google.common.base.Optional;\n \n import org.apache.bookkeeper.client.BKException.BKNotEnoughBookiesException;\n+import org.apache.bookkeeper.client.BookieInfoReader.BookieInfo;\n+import org.apache.bookkeeper.client.WeightedRandomSelection.WeightedObject;\n import org.apache.bookkeeper.conf.ClientConfiguration;\n import org.apache.bookkeeper.feature.FeatureProvider;\n import org.apache.bookkeeper.net.BookieSocketAddress;\n import org.apache.bookkeeper.net.DNSToSwitchMapping;\n import org.apache.bookkeeper.stats.StatsLogger;\n+import org.apache.commons.collections.CollectionUtils;\n import org.jboss.netty.util.HashedWheelTimer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n /**\n  * Default Ensemble Placement Policy, which picks bookies randomly\n  */\n public class DefaultEnsemblePlacementPolicy implements EnsemblePlacementPolicy {\n-\n+    static final Logger LOG = LoggerFactory.getLogger(DefaultEnsemblePlacementPolicy.class);\n     static final Set<BookieSocketAddress> EMPTY_SET = new HashSet<BookieSocketAddress>();\n \n+    private boolean isWeighted;\n+    private int maxWeightMultiple;\n     private Set<BookieSocketAddress> knownBookies = new HashSet<BookieSocketAddress>();\n+    private Map<BookieSocketAddress, WeightedObject> bookieInfoMap;\n+    private WeightedRandomSelection<BookieSocketAddress> weightedSelection;\n+    private final ReentrantReadWriteLock rwLock;\n+\n+    DefaultEnsemblePlacementPolicy() {\n+        rwLock = new ReentrantReadWriteLock();\n+    }\n \n     @Override\n     public ArrayList<BookieSocketAddress> newEnsemble(int ensembleSize, int quorumSize, int ackQuorumSize, java.util.Map<String, byte[]> customMetadata, Set<BookieSocketAddress> excludeBookies) throws BKNotEnoughBookiesException {\n@@ -51,18 +66,43 @@ public ArrayList<BookieSocketAddress> newEnsemble(int ensembleSize, int quorumSi\n             return newBookies;\n         }\n         List<BookieSocketAddress> allBookies;\n-        synchronized (this) {\n+        rwLock.readLock().lock();\n+        try {\n             allBookies = new ArrayList<BookieSocketAddress>(knownBookies);\n+        } finally {\n+            rwLock.readLock().unlock();\n         }\n-        Collections.shuffle(allBookies);\n-        for (BookieSocketAddress bookie : allBookies) {\n-            if (excludeBookies.contains(bookie)) {\n-                continue;\n+\n+        if (isWeighted) {\n+            // hold the readlock while selecting bookies. We don't want the list of bookies\n+            // changing while we are creating the ensemble\n+            rwLock.readLock().lock();\n+            try {\n+                if (CollectionUtils.subtract(allBookies, excludeBookies).size() < ensembleSize) {\n+                    throw new BKNotEnoughBookiesException();\n+                }\n+                while (ensembleSize > 0) {\n+                    BookieSocketAddress b = weightedSelection.getNextRandom();\n+                    if (newBookies.contains(b) || excludeBookies.contains(b)) {\n+                        continue;\n+                    }\n+                    newBookies.add(b);\n+                    --ensembleSize;\n+                }\n+            } finally {\n+                rwLock.readLock().unlock();\n             }\n-            newBookies.add(bookie);\n-            --ensembleSize;\n-            if (ensembleSize == 0) {\n-                return newBookies;\n+        } else {\n+            Collections.shuffle(allBookies);\n+            for (BookieSocketAddress bookie : allBookies) {\n+                if (excludeBookies.contains(bookie)) {\n+                    continue;\n+                }\n+                newBookies.add(bookie);\n+                --ensembleSize;\n+                if (ensembleSize == 0) {\n+                    return newBookies;\n+                }\n             }\n         }\n         throw new BKNotEnoughBookiesException();\n@@ -76,15 +116,33 @@ public BookieSocketAddress replaceBookie(int ensembleSize, int writeQuorumSize,\n     }\n \n     @Override\n-    public synchronized Set<BookieSocketAddress> onClusterChanged(Set<BookieSocketAddress> writableBookies,\n+    public Set<BookieSocketAddress> onClusterChanged(Set<BookieSocketAddress> writableBookies,\n             Set<BookieSocketAddress> readOnlyBookies) {\n-        HashSet<BookieSocketAddress> deadBookies;\n-        deadBookies = new HashSet<BookieSocketAddress>(knownBookies);\n-        deadBookies.removeAll(writableBookies);\n-        // readonly bookies should not be treated as dead bookies\n-        deadBookies.removeAll(readOnlyBookies);\n-        knownBookies = writableBookies;\n-        return deadBookies;\n+        rwLock.writeLock().lock();\n+        try {\n+            HashSet<BookieSocketAddress> deadBookies;\n+            deadBookies = new HashSet<BookieSocketAddress>(knownBookies);\n+            deadBookies.removeAll(writableBookies);\n+            // readonly bookies should not be treated as dead bookies\n+            deadBookies.removeAll(readOnlyBookies);\n+            if (this.isWeighted) {\n+                for (BookieSocketAddress b : deadBookies) {\n+                    this.bookieInfoMap.remove(b);\n+                }\n+                @SuppressWarnings(\"unchecked\")\n+                Collection<BookieSocketAddress> newBookies = CollectionUtils.subtract(writableBookies, knownBookies);\n+                for (BookieSocketAddress b : newBookies) {\n+                    this.bookieInfoMap.put(b, new BookieInfo());\n+                }\n+                if (deadBookies.size() > 0 || newBookies.size() > 0) {\n+                    this.weightedSelection.updateMap(this.bookieInfoMap);\n+                }\n+            }\n+            knownBookies = writableBookies;\n+            return deadBookies;\n+        } finally {\n+            rwLock.writeLock().unlock();\n+        }\n     }\n \n     @Override\n@@ -111,9 +169,27 @@ public EnsemblePlacementPolicy initialize(ClientConfiguration conf,\n                                               HashedWheelTimer timer,\n                                               FeatureProvider featureProvider,\n                                               StatsLogger statsLogger) {\n+        this.isWeighted = conf.getDiskWeightBasedPlacementEnabled();\n+        if (this.isWeighted) {\n+            this.maxWeightMultiple = conf.getBookieMaxWeightMultipleForWeightBasedPlacement();\n+            this.weightedSelection = new WeightedRandomSelection<BookieSocketAddress>(this.maxWeightMultiple);\n+        }\n         return this;\n     }\n \n+    @Override\n+    public void updateBookieInfo(Map<BookieSocketAddress, BookieInfo> bookieInfoMap) {\n+        rwLock.writeLock().lock();\n+        try {\n+            for (Map.Entry<BookieSocketAddress, BookieInfo> e : bookieInfoMap.entrySet()) {\n+                this.bookieInfoMap.put(e.getKey(), e.getValue());\n+            }\n+            this.weightedSelection.updateMap(this.bookieInfoMap);\n+        } finally {\n+            rwLock.writeLock().unlock();\n+        }\n+    }\n+\n     @Override\n     public void uninitalize() {\n         // do nothing"},{"sha":"d2e16e8b8f3516e49b71cafefdbc3e884e0ee03b","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/EnsemblePlacementPolicy.java","status":"modified","additions":10,"deletions":0,"changes":10,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/0583175de72446d00088611000310b000e8e61df/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FEnsemblePlacementPolicy.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/0583175de72446d00088611000310b000e8e61df/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FEnsemblePlacementPolicy.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FEnsemblePlacementPolicy.java?ref=0583175de72446d00088611000310b000e8e61df","patch":"@@ -26,6 +26,7 @@\n import com.google.common.base.Optional;\n \n import org.apache.bookkeeper.client.BKException.BKNotEnoughBookiesException;\n+import org.apache.bookkeeper.client.BookieInfoReader.BookieInfo;\n import org.apache.bookkeeper.conf.ClientConfiguration;\n import org.apache.bookkeeper.feature.FeatureProvider;\n import org.apache.bookkeeper.net.BookieSocketAddress;\n@@ -135,4 +136,13 @@ public List<Integer> reorderReadSequence(ArrayList<BookieSocketAddress> ensemble\n      */\n     public List<Integer> reorderReadLACSequence(ArrayList<BookieSocketAddress> ensemble,\n                                                 List<Integer> writeSet, Map<BookieSocketAddress, Long> bookieFailureHistory);\n+\n+    /**\n+     * Send the bookie info details.\n+     * \n+     * @param bookieInfoMap\n+     *          A map that has the bookie to BookieInfo\n+     */\n+    default public void updateBookieInfo(Map<BookieSocketAddress, BookieInfo> bookieInfoMap) {\n+    }\n }"},{"sha":"7272447343e74977db26d2cc78bc8961544e52fc","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/RackawareEnsemblePlacementPolicy.java","status":"modified","additions":8,"deletions":7,"changes":15,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/0583175de72446d00088611000310b000e8e61df/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FRackawareEnsemblePlacementPolicy.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/0583175de72446d00088611000310b000e8e61df/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FRackawareEnsemblePlacementPolicy.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FRackawareEnsemblePlacementPolicy.java?ref=0583175de72446d00088611000310b000e8e61df","patch":"@@ -22,8 +22,6 @@\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n-\n-import org.apache.bookkeeper.client.BKException.BKNotEnoughBookiesException;\n import org.apache.bookkeeper.net.BookieSocketAddress;\n import org.apache.bookkeeper.net.DNSToSwitchMapping;\n import org.apache.bookkeeper.net.Node;\n@@ -32,7 +30,6 @@\n \n public class RackawareEnsemblePlacementPolicy extends RackawareEnsemblePlacementPolicyImpl\n         implements ITopologyAwareEnsemblePlacementPolicy<TopologyAwareEnsemblePlacementPolicy.BookieNode> {\n-\n     RackawareEnsemblePlacementPolicyImpl slave = null;\n \n     RackawareEnsemblePlacementPolicy() {\n@@ -48,13 +45,17 @@ protected RackawareEnsemblePlacementPolicy initialize(DNSToSwitchMapping dnsReso\n                                                           HashedWheelTimer timer,\n                                                           boolean reorderReadsRandom,\n                                                           int stabilizePeriodSeconds,\n+                                                          boolean isWeighted,\n+                                                          int maxWeightMultiple,\n                                                           StatsLogger statsLogger) {\n         if (stabilizePeriodSeconds > 0) {\n-            super.initialize(dnsResolver, timer, reorderReadsRandom, 0, statsLogger);\n+            super.initialize(dnsResolver, timer, reorderReadsRandom, 0, isWeighted, maxWeightMultiple, statsLogger);\n             slave = new RackawareEnsemblePlacementPolicyImpl(enforceDurability);\n-            slave.initialize(dnsResolver, timer, reorderReadsRandom, stabilizePeriodSeconds, statsLogger);\n+            slave.initialize(dnsResolver, timer, reorderReadsRandom, stabilizePeriodSeconds, isWeighted,\n+                    maxWeightMultiple, statsLogger);\n         } else {\n-            super.initialize(dnsResolver, timer, reorderReadsRandom, stabilizePeriodSeconds, statsLogger);\n+            super.initialize(dnsResolver, timer, reorderReadsRandom, stabilizePeriodSeconds, isWeighted,\n+                    maxWeightMultiple, statsLogger);\n             slave = null;\n         }\n         return this;\n@@ -96,7 +97,7 @@ public ArrayList<BookieSocketAddress> newEnsemble(\n     public BookieSocketAddress replaceBookie(\n         int ensembleSize, int writeQuorumSize, int ackQuorumSize, java.util.Map<String, byte[]> customMetadata, Collection<BookieSocketAddress> currentEnsemble, BookieSocketAddress bookieToReplace, Set<BookieSocketAddress> excludeBookies)\n             throws BKException.BKNotEnoughBookiesException {\n-        try {\n+       try {\n             return super.replaceBookie(ensembleSize, writeQuorumSize, ackQuorumSize, customMetadata,\n                     currentEnsemble, bookieToReplace, excludeBookies);\n         } catch (BKException.BKNotEnoughBookiesException bnebe) {"},{"sha":"8d56f7aa95e4ff13271c301356a52339cb11ca7d","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/RackawareEnsemblePlacementPolicyImpl.java","status":"modified","additions":165,"deletions":12,"changes":177,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/0583175de72446d00088611000310b000e8e61df/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FRackawareEnsemblePlacementPolicyImpl.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/0583175de72446d00088611000310b000e8e61df/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FRackawareEnsemblePlacementPolicyImpl.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FRackawareEnsemblePlacementPolicyImpl.java?ref=0583175de72446d00088611000310b000e8e61df","patch":"@@ -24,12 +24,15 @@\n import java.util.Collections;\n import java.util.HashMap;\n import java.util.HashSet;\n+import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n import java.util.concurrent.locks.ReentrantReadWriteLock;\n \n import org.apache.bookkeeper.client.BKException.BKNotEnoughBookiesException;\n+import org.apache.bookkeeper.client.BookieInfoReader.BookieInfo;\n+import org.apache.bookkeeper.client.WeightedRandomSelection.WeightedObject;\n import org.apache.bookkeeper.conf.ClientConfiguration;\n import org.apache.bookkeeper.conf.Configurable;\n import org.apache.bookkeeper.feature.FeatureProvider;\n@@ -44,6 +47,7 @@\n import org.apache.bookkeeper.net.StabilizeNetworkTopology;\n import org.apache.bookkeeper.stats.StatsLogger;\n import org.apache.bookkeeper.util.ReflectionUtils;\n+import org.apache.commons.collections.CollectionUtils;\n import org.jboss.netty.util.HashedWheelTimer;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -60,6 +64,10 @@\n class RackawareEnsemblePlacementPolicyImpl extends TopologyAwareEnsemblePlacementPolicy {\n \n     static final Logger LOG = LoggerFactory.getLogger(RackawareEnsemblePlacementPolicyImpl.class);\n+    boolean isWeighted;\n+    int maxWeightMultiple;\n+    private Map<BookieNode, WeightedObject> bookieInfoMap = new HashMap<BookieNode, WeightedObject>();\n+    private WeightedRandomSelection<BookieNode> weightedSelection;\n \n     public static final String REPP_DNS_RESOLVER_CLASS = \"reppDnsResolverClass\";\n     public static final String REPP_RANDOM_READ_REORDERING = \"ensembleRandomReadReordering\";\n@@ -123,6 +131,8 @@ protected RackawareEnsemblePlacementPolicyImpl initialize(DNSToSwitchMapping dns\n                                                               HashedWheelTimer timer,\n                                                               boolean reorderReadsRandom,\n                                                               int stabilizePeriodSeconds,\n+                                                              boolean isWeighted,\n+                                                              int maxWeightMultiple,\n                                                               StatsLogger statsLogger) {\n         this.statsLogger = statsLogger;\n         this.reorderReadsRandom = reorderReadsRandom;\n@@ -148,6 +158,15 @@ protected RackawareEnsemblePlacementPolicyImpl initialize(DNSToSwitchMapping dns\n         LOG.info(\"Initialize rackaware ensemble placement policy @ {} @ {} : {}.\",\n             new Object[] { localNode, null == localNode ? \"Unknown\" : localNode.getNetworkLocation(),\n                 dnsResolver.getClass().getName() });\n+\n+        this.isWeighted = isWeighted;\n+        if (this.isWeighted) {\n+            this.maxWeightMultiple = maxWeightMultiple;\n+            this.weightedSelection = new WeightedRandomSelection<BookieNode>(this.maxWeightMultiple);\n+            LOG.info(\"Weight based placement with max multiple of \" + this.maxWeightMultiple);\n+        } else {\n+            LOG.info(\"Not weighted\");\n+        }\n         return this;\n     }\n \n@@ -177,6 +196,8 @@ public RackawareEnsemblePlacementPolicyImpl initialize(ClientConfiguration conf,\n                 timer,\n                 conf.getBoolean(REPP_RANDOM_READ_REORDERING, false),\n                 conf.getNetworkTopologyStabilizePeriodSeconds(),\n+                conf.getDiskWeightBasedPlacementEnabled(),\n+                conf.getBookieMaxWeightMultipleForWeightBasedPlacement(),\n                 statsLogger);\n     }\n \n@@ -209,7 +230,9 @@ public Set<BookieSocketAddress> onClusterChanged(Set<BookieSocketAddress> writab\n             }\n             handleBookiesThatLeft(leftBookies);\n             handleBookiesThatJoined(joinedBookies);\n-\n+            if (this.isWeighted && (leftBookies.size() > 0 || joinedBookies.size() > 0)) {\n+                this.weightedSelection.updateMap(this.bookieInfoMap);\n+            }\n             if (!readOnlyBookies.isEmpty()) {\n                 this.readOnlyBookies = ImmutableSet.copyOf(readOnlyBookies);\n             }\n@@ -226,6 +249,9 @@ public void handleBookiesThatLeft(Set<BookieSocketAddress> leftBookies) {\n             BookieNode node = knownBookies.remove(addr);\n             if(null != node) {\n                 topology.remove(node);\n+                if (this.isWeighted) {\n+                    this.bookieInfoMap.remove(node);\n+                }\n                 if (LOG.isDebugEnabled()) {\n                     LOG.debug(\"Cluster changed : bookie {} left from cluster.\", addr);\n                 }\n@@ -240,6 +266,9 @@ public void handleBookiesThatJoined(Set<BookieSocketAddress> joinedBookies) {\n             BookieNode node = createBookieNode(addr);\n             topology.add(node);\n             knownBookies.put(addr, node);\n+            if (this.isWeighted) {\n+                this.bookieInfoMap.putIfAbsent(node, new BookieInfo());\n+            }\n             if (LOG.isDebugEnabled()) {\n                 LOG.debug(\"Cluster changed : bookie {} joined the cluster.\", addr);\n             }\n@@ -386,6 +415,32 @@ public BookieSocketAddress replaceBookie(int ensembleSize, int writeQuorumSize,\n         }\n     }\n \n+    @Override\n+    public void updateBookieInfo(Map<BookieSocketAddress, BookieInfo> bookieInfoMap) {\n+        if (!isWeighted) {\n+            LOG.info(\"bookieFreeDiskInfo callback called even without weighted placement policy being used.\");\n+            return;\n+        }\n+         List<BookieNode> allBookies = new ArrayList<BookieNode>(knownBookies.values());\n+\n+         // create a new map to reflect the new mapping\n+        Map<BookieNode, WeightedObject> map = new HashMap<BookieNode, WeightedObject>();\n+        for (BookieNode bookie : allBookies) {\n+            if (bookieInfoMap.containsKey(bookie.getAddr())) {\n+                map.put(bookie, bookieInfoMap.get(bookie.getAddr()));\n+            } else {\n+                map.put(bookie, new BookieInfo());\n+            }\n+        }\n+        rwLock.writeLock().lock();\n+        try {\n+            this.bookieInfoMap = map;\n+            this.weightedSelection.updateMap(this.bookieInfoMap);\n+        } finally {\n+            rwLock.writeLock().unlock();\n+        }\n+    }\n+\n     @Override\n     public BookieNode selectFromNetworkLocation(\n             String networkLoc,\n@@ -409,6 +464,31 @@ protected String getRemoteRack(BookieNode node) {\n         return \"~\" + node.getNetworkLocation();\n     }\n \n+    private WeightedRandomSelection<BookieNode> prepareForWeightedSelection(List<Node> leaves) {\n+        // create a map of bookieNode->freeDiskSpace for this rack. The assumption is that\n+        // the number of nodes in a rack is of the order of 40, so it shouldn't be too bad\n+        // to build it every time during a ledger creation\n+        Map<BookieNode, WeightedObject> rackMap = new HashMap<BookieNode, WeightedObject>();\n+        for (Node n : leaves) {\n+            if (!(n instanceof BookieNode)) {\n+                continue;\n+            }\n+            BookieNode bookie = (BookieNode) n;\n+            if (this.bookieInfoMap.containsKey(bookie)) {\n+                rackMap.put(bookie, this.bookieInfoMap.get(bookie));\n+            } else {\n+                rackMap.put(bookie, new BookieInfo());\n+            }\n+        }\n+        if (rackMap.size() == 0) {\n+            return null;\n+        }\n+\n+        WeightedRandomSelection<BookieNode> wRSelection = new WeightedRandomSelection<BookieNode>(this.maxWeightMultiple);\n+        wRSelection.updateMap(rackMap);\n+        return wRSelection;\n+    }\n+\n     /**\n      * Choose random node under a given network path.\n      *\n@@ -424,9 +504,38 @@ protected String getRemoteRack(BookieNode node) {\n      */\n     protected BookieNode selectRandomFromRack(String netPath, Set<Node> excludeBookies, Predicate<BookieNode> predicate,\n             Ensemble<BookieNode> ensemble) throws BKNotEnoughBookiesException {\n+        WeightedRandomSelection<BookieNode> wRSelection = null;\n         List<Node> leaves = new ArrayList<Node>(topology.getLeaves(netPath));\n-        Collections.shuffle(leaves);\n-        for (Node n : leaves) {\n+        if (!this.isWeighted) {\n+            Collections.shuffle(leaves);\n+        } else {\n+            if (CollectionUtils.subtract(leaves, excludeBookies).size() < 1) {\n+                throw new BKNotEnoughBookiesException();\n+            }\n+            wRSelection = prepareForWeightedSelection(leaves);\n+            if (wRSelection == null) {\n+                throw new BKNotEnoughBookiesException();\n+            }\n+        }\n+\n+        Iterator<Node> it = leaves.iterator();\n+        Set<Node> bookiesSeenSoFar = new HashSet<Node>();\n+        while (true) {\n+            Node n;\n+            if (isWeighted) {\n+                if (bookiesSeenSoFar.size() == leaves.size()) {\n+                    // Don't loop infinitely.\n+                    break;\n+                }\n+                n = wRSelection.getNextRandom();\n+                bookiesSeenSoFar.add(n);\n+            } else {\n+                if (it.hasNext()) {\n+                    n = it.next();\n+                } else {\n+                    break;\n+                }\n+            }\n             if (excludeBookies.contains(n)) {\n                 continue;\n             }\n@@ -461,7 +570,7 @@ protected List<BookieNode> selectRandom(int numBookies,\n                                             Predicate<BookieNode> predicate,\n                                             Ensemble<BookieNode> ensemble)\n             throws BKNotEnoughBookiesException {\n-        return selectRandomInternal(new ArrayList<BookieNode>(knownBookies.values()),  numBookies, excludeBookies, predicate, ensemble);\n+        return selectRandomInternal(null,  numBookies, excludeBookies, predicate, ensemble);\n     }\n \n     protected List<BookieNode> selectRandomInternal(List<BookieNode> bookiesToSelectFrom,\n@@ -470,9 +579,56 @@ protected List<BookieNode> selectRandomInternal(List<BookieNode> bookiesToSelect\n                                                     Predicate<BookieNode> predicate,\n                                                     Ensemble<BookieNode> ensemble)\n         throws BKNotEnoughBookiesException {\n-        Collections.shuffle(bookiesToSelectFrom);\n+        WeightedRandomSelection<BookieNode> wRSelection = null;\n+        if (bookiesToSelectFrom == null) {\n+            // If the list is null, we need to select from the entire knownBookies set\n+            wRSelection = this.weightedSelection;\n+            bookiesToSelectFrom = new ArrayList<BookieNode>(knownBookies.values());\n+        }\n+        if (isWeighted) {\n+            if (CollectionUtils.subtract(bookiesToSelectFrom, excludeBookies).size() < numBookies) {\n+                throw new BKNotEnoughBookiesException();\n+            }\n+            if (wRSelection == null) {\n+                Map<BookieNode, WeightedObject> rackMap = new HashMap<BookieNode, WeightedObject>();\n+                for (BookieNode n : bookiesToSelectFrom) {\n+                    if (excludeBookies.contains(n)) {\n+                        continue;\n+                    }\n+                    if (this.bookieInfoMap.containsKey(n)) {\n+                        rackMap.put(n, this.bookieInfoMap.get(n));\n+                    } else {\n+                        rackMap.put(n, new BookieInfo());\n+                    }\n+                }\n+                wRSelection = new WeightedRandomSelection<BookieNode>(this.maxWeightMultiple);\n+                wRSelection.updateMap(rackMap);\n+            }\n+        } else {\n+            Collections.shuffle(bookiesToSelectFrom);\n+        }\n+\n+        BookieNode bookie;\n         List<BookieNode> newBookies = new ArrayList<BookieNode>(numBookies);\n-        for (BookieNode bookie : bookiesToSelectFrom) {\n+        Iterator<BookieNode> it = bookiesToSelectFrom.iterator();\n+        Set<BookieNode> bookiesSeenSoFar = new HashSet<BookieNode>();\n+        while (numBookies > 0) {\n+            if (isWeighted) {\n+                if (bookiesSeenSoFar.size() == bookiesToSelectFrom.size()) {\n+                    // If we have gone through the whole available list of bookies,\n+                    // and yet haven't been able to satisfy the ensemble request, bail out.\n+                    // We don't want to loop infinitely.\n+                    break;\n+                }\n+                bookie = wRSelection.getNextRandom();\n+                bookiesSeenSoFar.add(bookie);\n+            } else {\n+                if (it.hasNext()) {\n+                    bookie = it.next();\n+                } else {\n+                    break;\n+                }\n+            }\n             if (excludeBookies.contains(bookie)) {\n                 continue;\n             }\n@@ -489,10 +645,9 @@ protected List<BookieNode> selectRandomInternal(List<BookieNode> bookiesToSelect\n                 newBookies.add(bookie);\n                 --numBookies;\n             }\n-\n-            if (numBookies == 0) {\n-                return newBookies;\n-            }\n+        }\n+        if (numBookies == 0) {\n+            return newBookies;\n         }\n         if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Failed to find {} bookies : excludeBookies {}, allBookies {}.\", new Object[] {\n@@ -501,8 +656,6 @@ protected List<BookieNode> selectRandomInternal(List<BookieNode> bookiesToSelect\n         throw new BKNotEnoughBookiesException();\n     }\n \n-\n-\n     @Override\n     public List<Integer> reorderReadSequence(ArrayList<BookieSocketAddress> ensemble, List<Integer> writeSet, Map<BookieSocketAddress, Long> bookieFailureHistory) {\n         int ensembleSize = ensemble.size();"},{"sha":"ed9985fb99e620acfa6110bab09cae8301d152b3","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/RegionAwareEnsemblePlacementPolicy.java","status":"modified","additions":4,"deletions":3,"changes":7,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/0583175de72446d00088611000310b000e8e61df/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FRegionAwareEnsemblePlacementPolicy.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/0583175de72446d00088611000310b000e8e61df/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FRegionAwareEnsemblePlacementPolicy.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FRegionAwareEnsemblePlacementPolicy.java?ref=0583175de72446d00088611000310b000e8e61df","patch":"@@ -125,7 +125,8 @@ public void handleBookiesThatJoined(Set<BookieSocketAddress> joinedBookies) {\n             String region = getLocalRegion(node);\n             if (null == perRegionPlacement.get(region)) {\n                 perRegionPlacement.put(region, new RackawareEnsemblePlacementPolicy()\n-                        .initialize(dnsResolver, timer, this.reorderReadsRandom, this.stabilizePeriodSeconds, statsLogger));\n+                        .initialize(dnsResolver, timer, this.reorderReadsRandom, this.stabilizePeriodSeconds, \n+                                this.isWeighted, this.maxWeightMultiple, statsLogger));\n             }\n \n             Set<BookieSocketAddress> regionSet = perRegionClusterChange.get(region);\n@@ -160,7 +161,6 @@ public RegionAwareEnsemblePlacementPolicy initialize(ClientConfiguration conf,\n         super.initialize(conf, optionalDnsResolver, timer, featureProvider, statsLogger);\n         myRegion = getLocalRegion(localNode);\n         enableValidation = conf.getBoolean(REPP_ENABLE_VALIDATION, true);\n-\n         // We have to statically provide regions we want the writes to go through and how many regions\n         // are required for durability. This decision cannot be driven by the active bookies as the\n         // current topology will not be indicative of constraints that must be enforced for durability\n@@ -171,7 +171,8 @@ public RegionAwareEnsemblePlacementPolicy initialize(ClientConfiguration conf,\n             String[] regions = regionsString.split(\";\");\n             for (String region: regions) {\n                 perRegionPlacement.put(region, new RackawareEnsemblePlacementPolicy(true)\n-                        .initialize(dnsResolver, timer, this.reorderReadsRandom, this.stabilizePeriodSeconds, statsLogger));\n+                        .initialize(dnsResolver, timer, this.reorderReadsRandom, this.stabilizePeriodSeconds,\n+                                this.isWeighted, this.maxWeightMultiple, statsLogger));\n             }\n             minRegionsForDurability = conf.getInt(REPP_MINIMUM_REGIONS_FOR_DURABILITY, MINIMUM_REGIONS_FOR_DURABILITY_DEFAULT);\n             if (minRegionsForDurability > 0) {"},{"sha":"02fac1a6681e06062d1e32cb6d479fd0fe72daa7","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/WeightedRandomSelection.java","status":"added","additions":156,"deletions":0,"changes":156,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/0583175de72446d00088611000310b000e8e61df/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FWeightedRandomSelection.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/0583175de72446d00088611000310b000e8e61df/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FWeightedRandomSelection.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FWeightedRandomSelection.java?ref=0583175de72446d00088611000310b000e8e61df","patch":"@@ -0,0 +1,156 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.bookkeeper.client;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import org.apache.bookkeeper.client.BookieInfoReader.BookieInfo;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class WeightedRandomSelection<T> {\n+    static final Logger LOG = LoggerFactory.getLogger(WeightedRandomSelection.class);\n+\n+    interface WeightedObject {\n+        long getWeight();\n+    }\n+    Double randomMax;\n+    int maxProbabilityMultiplier;\n+    Map<T, WeightedObject> map;\n+    TreeMap<Double, T> cummulativeMap = new TreeMap<Double, T>();\n+    ReadWriteLock rwLock = new ReentrantReadWriteLock(true);\n+\n+    WeightedRandomSelection() {\n+        maxProbabilityMultiplier = -1;\n+    }\n+\n+    WeightedRandomSelection(int maxMultiplier) {\n+        this.maxProbabilityMultiplier = maxMultiplier;\n+    }\n+\n+    public void setMaxProbabilityMultiplier(int max) {\n+        this.maxProbabilityMultiplier = max;\n+    }\n+\n+    void updateMap(Map<T, WeightedObject> map) {\n+        // get the sum total of all the values; this will be used to\n+        // calculate the weighted probability later on\n+        Long totalWeight = 0L, min= Long.MAX_VALUE;\n+        List<WeightedObject> values = new ArrayList<WeightedObject>(map.values());\n+        Collections.sort(values, new Comparator<WeightedObject>() {\n+            public int compare(WeightedObject o1, WeightedObject o2) {\n+                long diff = o1.getWeight() - o2.getWeight();\n+                if (diff < 0L) {\n+                    return -1;\n+                } else if (diff > 0L) {\n+                    return 1;\n+                } else {\n+                    return 0;\n+                }\n+            }\n+        });\n+        for (int i=0; i < values.size(); i++) {\n+            totalWeight += values.get(i).getWeight();\n+            if (values.get(i).getWeight() != 0 && min > values.get(i).getWeight()) {\n+                min = values.get(i).getWeight();\n+            }\n+        }\n+\n+        double median = 0;\n+        if (totalWeight == 0) {\n+            // all the values are zeros; assign a value of 1 to all and the totalWeight equal\n+            // to the size of the values\n+            min = 1L;\n+            median = 1;\n+            totalWeight = (long)values.size();\n+        } else {\n+            int mid = values.size()/2;\n+            if ((values.size() % 2) == 1) {\n+                median = values.get(mid).getWeight();\n+            } else {\n+                median = (double)(values.get(mid-1).getWeight() + values.get(mid).getWeight())/2;\n+            }\n+        }\n+\n+        double medianWeight, minWeight;\n+        medianWeight = median/(double)totalWeight;\n+        minWeight = (double)min/totalWeight;\n+\n+        LOG.debug(\"Updating weights map. MediaWeight: \" + medianWeight + \" MinWeight: \" + minWeight);\n+\n+        double maxWeight = maxProbabilityMultiplier*medianWeight;\n+        Map<T, Double> weightMap = new HashMap<T, Double>();\n+        for (Map.Entry<T, WeightedObject> e : map.entrySet()) {\n+            double weightedProbability;\n+            if (e.getValue().getWeight() > 0) {\n+                weightedProbability = (double)e.getValue().getWeight()/(double)totalWeight;\n+            } else {\n+                weightedProbability = minWeight;\n+            }\n+            if (maxWeight > 0 && weightedProbability > maxWeight) {\n+                weightedProbability=maxWeight;\n+                LOG.debug(\"Capping the probability to \" + weightedProbability + \" for \" + e.getKey() + \" Value: \" + e.getValue());\n+            }\n+            weightMap.put(e.getKey(), weightedProbability);\n+        }\n+\n+        // The probability of picking a bookie randomly is defaultPickProbability\n+        // but we change that priority by looking at the weight that each bookie\n+        // carries.\n+        TreeMap<Double, T> tmpCummulativeMap = new TreeMap<Double, T>();\n+        Double key=0.0;\n+        for (Map.Entry<T, Double> e : weightMap.entrySet()) {\n+            tmpCummulativeMap.put(key, e.getKey());\n+            LOG.debug(\"Key: \" + e.getKey() + \" Value: \" + e.getValue()\n+                    + \" AssignedKey: \" + key + \" AssignedWeight: \" + e.getValue());\n+            key += e.getValue();\n+        }\n+\n+        rwLock.writeLock().lock();\n+        try {\n+            this.map = map;\n+            cummulativeMap = tmpCummulativeMap;\n+            randomMax = key;\n+        } finally {\n+            rwLock.writeLock().unlock();\n+        }\n+    }\n+\n+    T getNextRandom() {\n+        rwLock.readLock().lock();\n+        try {\n+            // pick a random number between 0 and randMax\n+            Double randomNum = randomMax*Math.random();\n+            // find the nearest key in the map corresponding to the randomNum\n+            Double key = cummulativeMap.floorKey(randomNum);\n+            //LOG.info(\"Random max: \" + randomMax + \" CummulativeMap size: \" + cummulativeMap.size() + \" selected key: \" + key);\n+            return cummulativeMap.get(key);\n+        } finally {\n+            rwLock.readLock().unlock();\n+        }\n+    }\n+}"},{"sha":"ee137c004d269f440c639f08efcedae6258c28c4","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ClientConfiguration.java","status":"modified","additions":83,"deletions":1,"changes":84,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/0583175de72446d00088611000310b000e8e61df/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fconf%2FClientConfiguration.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/0583175de72446d00088611000310b000e8e61df/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fconf%2FClientConfiguration.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fconf%2FClientConfiguration.java?ref=0583175de72446d00088611000310b000e8e61df","patch":"@@ -78,7 +78,13 @@ public class ClientConfiguration extends AbstractConfiguration {\n     protected final static String BOOKIE_ERROR_THRESHOLD_PER_INTERVAL = \"bookieErrorThresholdPerInterval\";\n     protected final static String BOOKIE_QUARANTINE_TIME_SECONDS = \"bookieQuarantineTimeSeconds\";\n \n-    // Number Worker Threads\n+    // Bookie info poll interval\n+    protected final static String DISK_WEIGHT_BASED_PLACEMENT_ENABLED = \"diskWeightBasedPlacementEnabled\";\n+    protected final static String GET_BOOKIE_INFO_INTERVAL_SECONDS = \"getBookieInfoIntervalSeconds\";\n+    protected final static String BOOKIE_MAX_MULTIPLE_FOR_WEIGHTED_PLACEMENT = \"bookieMaxMultipleForWeightBasedPlacement\";\n+    protected final static String GET_BOOKIE_INFO_TIMEOUT_SECS = \"getBookieInfoTimeoutSecs\";\n+\n+    // Number Woker Threads\n     protected final static String NUM_WORKER_THREADS = \"numWorkerThreads\";\n \n     // Ensemble Placement Policy\n@@ -939,6 +945,82 @@ public ClientConfiguration setNettyMaxFrameSizeBytes(int maxSize) {\n         super.setNettyMaxFrameSizeBytes(maxSize);\n         return this;\n     }\n+ \n+    /**\n+     * Get the time interval between successive calls for bookie get info. Default is 24 hours.\n+     *\n+     * @return\n+     */\n+    public int getGetBookieInfoIntervalSeconds() {\n+        return getInt(GET_BOOKIE_INFO_INTERVAL_SECONDS, 24*60*60);\n+    }\n+\n+    /**\n+     * Return whether disk weight based placement policy is enabled\n+     * @return\n+     */\n+    public boolean getDiskWeightBasedPlacementEnabled() {\n+        return getBoolean(DISK_WEIGHT_BASED_PLACEMENT_ENABLED, false);\n+    }\n+\n+    /**\n+     * Returns the max multiple to use for nodes with very high weight\n+     * @return max multiple\n+     */\n+    public int getBookieMaxWeightMultipleForWeightBasedPlacement() {\n+        return getInt(BOOKIE_MAX_MULTIPLE_FOR_WEIGHTED_PLACEMENT, 3);\n+    }\n+\n+    /**\n+     * Return the timeout value for getBookieInfo request\n+     * @return\n+     */\n+    public int getBookieInfoTimeout() {\n+        return getInteger(GET_BOOKIE_INFO_TIMEOUT_SECS, 5);\n+    }\n+\n+    /**\n+     * Set whether or not disk weight based placement is enabled.\n+     *\n+     * @param isEnabled - boolean indicating enabled or not\n+     * @return client configuration\n+     */\n+    public ClientConfiguration setDiskWeightBasedPlacementEnabled(boolean isEnabled) {\n+        setProperty(DISK_WEIGHT_BASED_PLACEMENT_ENABLED, isEnabled);\n+        return this;\n+    }\n+\n+    /**\n+     * Set the time interval between successive polls for bookie get info.\n+     *\n+     * @param pollInterval\n+     * @param unit\n+     * @return client configuration\n+     */\n+    public ClientConfiguration setGetBookieInfoIntervalSeconds(int pollInterval, TimeUnit unit) {\n+        setProperty(GET_BOOKIE_INFO_INTERVAL_SECONDS, unit.toSeconds(pollInterval));\n+        return this;\n+    }\n+\n+    /**\n+     * Set the max multiple to use for nodes with very high weight\n+     * @param multiple\n+     * @return client configuration\n+     */\n+    public ClientConfiguration setBookieMaxWeightMultipleForWeightBasedPlacement(int multiple) {\n+        setProperty(BOOKIE_MAX_MULTIPLE_FOR_WEIGHTED_PLACEMENT, multiple);\n+        return this;\n+    }\n+\n+    /**\n+     * Set the timeout value in secs for the GET_BOOKIE_INFO request\n+     * @param timeout\n+     * @return client configuration\n+     */\n+    public ClientConfiguration setGetBookieInfoTimeout(int timeoutSecs) {\n+        setProperty(GET_BOOKIE_INFO_TIMEOUT_SECS, timeoutSecs);\n+        return this;\n+    }\n \n     /**\n      * Set the client role"},{"sha":"ce85aef7180efcd139d7e1132767f3b459f54044","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieClient.java","status":"modified","additions":37,"deletions":2,"changes":39,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/0583175de72446d00088611000310b000e8e61df/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookieClient.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/0583175de72446d00088611000310b000e8e61df/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookieClient.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookieClient.java?ref=0583175de72446d00088611000310b000e8e61df","patch":"@@ -35,14 +35,16 @@\n import org.apache.bookkeeper.auth.ClientAuthProvider;\n import com.google.common.util.concurrent.ThreadFactoryBuilder;\n import org.apache.bookkeeper.client.BKException;\n+import org.apache.bookkeeper.client.BookieInfoReader.BookieInfo;\n import org.apache.bookkeeper.conf.ClientConfiguration;\n import org.apache.bookkeeper.net.BookieSocketAddress;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GetBookieInfoCallback;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ReadEntryCallback;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ReadLacCallback;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteLacCallback;\n-import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ReadEntryCallback;\n-import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteCallback;\n import org.apache.bookkeeper.stats.NullStatsLogger;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteCallback;\n import org.apache.bookkeeper.stats.StatsLogger;\n import org.apache.bookkeeper.util.OrderedSafeExecutor;\n import org.apache.bookkeeper.util.SafeRunnable;\n@@ -350,6 +352,39 @@ public void safeRun() {\n         }\n     }\n \n+    public void getBookieInfo(final BookieSocketAddress addr, final long requested, final GetBookieInfoCallback cb, final Object ctx) {\n+        closeLock.readLock().lock();\n+        try {\n+            final PerChannelBookieClientPool client = lookupClient(addr, BookkeeperProtocol.OperationType.GET_BOOKIE_INFO);\n+            if (client == null) {\n+                cb.getBookieInfoComplete(getRc(BKException.Code.BookieHandleNotAvailableException), new BookieInfo(), ctx);\n+                return;\n+            }\n+            client.obtain(new GenericCallback<PerChannelBookieClient>() {\n+                @Override\n+                public void operationComplete(final int rc, PerChannelBookieClient pcbc) {\n+                    if (rc != BKException.Code.OK) {\n+                        try {\n+                            executor.submit(new SafeRunnable() {\n+                                @Override\n+                                public void safeRun() {\n+                                    cb.getBookieInfoComplete(rc, new BookieInfo(), ctx);\n+                                }\n+                            });\n+                        } catch (RejectedExecutionException re) {\n+                            cb.getBookieInfoComplete(getRc(BKException.Code.InterruptedException),\n+                                    new BookieInfo(), ctx);\n+                        }\n+                        return;\n+                    }\n+                    pcbc.getBookieInfo(requested, cb, ctx);\n+                }\n+            });\n+        } finally {\n+            closeLock.readLock().unlock();\n+        }\n+    }\n+\n     public boolean isClosed() {\n         return closed;\n     }"},{"sha":"38f40f83a74a85440dae68cc30d11a24ddf4b154","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieRequestProcessor.java","status":"modified","additions":15,"deletions":1,"changes":16,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/0583175de72446d00088611000310b000e8e61df/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookieRequestProcessor.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/0583175de72446d00088611000310b000e8e61df/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookieRequestProcessor.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookieRequestProcessor.java?ref=0583175de72446d00088611000310b000e8e61df","patch":"@@ -43,7 +43,7 @@\n import static org.apache.bookkeeper.bookie.BookKeeperServerStats.READ_ENTRY_REQUEST;\n import static org.apache.bookkeeper.bookie.BookKeeperServerStats.WRITE_LAC;\n import static org.apache.bookkeeper.bookie.BookKeeperServerStats.READ_LAC;\n-\n+import static org.apache.bookkeeper.bookie.BookKeeperServerStats.GET_BOOKIE_INFO;\n \n public class BookieRequestProcessor implements RequestProcessor {\n \n@@ -78,6 +78,7 @@ public class BookieRequestProcessor implements RequestProcessor {\n     final OpStatsLogger readEntryStats;\n     final OpStatsLogger writeLacStats;\n     final OpStatsLogger readLacStats;\n+    final OpStatsLogger getBookieInfoStats;\n \n     public BookieRequestProcessor(ServerConfiguration serverCfg, Bookie bookie,\n                                   StatsLogger statsLogger) {\n@@ -93,6 +94,7 @@ public BookieRequestProcessor(ServerConfiguration serverCfg, Bookie bookie,\n         this.readRequestStats = statsLogger.getOpStatsLogger(READ_ENTRY_REQUEST);\n         this.writeLacStats = statsLogger.getOpStatsLogger(WRITE_LAC);\n         this.readLacStats = statsLogger.getOpStatsLogger(READ_LAC);\n+        this.getBookieInfoStats = statsLogger.getOpStatsLogger(GET_BOOKIE_INFO);\n     }\n \n     @Override\n@@ -148,6 +150,9 @@ public void processRequest(Object msg, Channel c) {\n                 case READ_LAC:\n                     processReadLacRequestV3(r,c);\n                     break;\n+                case GET_BOOKIE_INFO:\n+                    processGetBookieInfoRequestV3(r,c);\n+                    break;\n                 default:\n                     LOG.info(\"Unknown operation type {}\", header.getOperation());\n                     BookkeeperProtocol.Response.Builder response =\n@@ -216,6 +221,15 @@ private void processReadLacRequestV3(final BookkeeperProtocol.Request r, final C\n         }\n     }\n \n+    private void processGetBookieInfoRequestV3(final BookkeeperProtocol.Request r, final Channel c) {\n+        GetBookieInfoProcessorV3 getBookieInfo = new GetBookieInfoProcessorV3(r, c, this);\n+        if (null == readThreadPool) {\n+            getBookieInfo.run();\n+        } else {\n+            readThreadPool.submit(getBookieInfo);\n+        }\n+    }\n+\n     private void processAddRequest(final BookieProtocol.Request r, final Channel c) {\n         WriteEntryProcessor write = new WriteEntryProcessor(r, c, this);\n         if (null == writeThreadPool) {"},{"sha":"b2d6d82a1aab8118552d43db2d508cbc68a2c027","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookkeeperInternalCallbacks.java","status":"modified","additions":5,"deletions":0,"changes":5,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/0583175de72446d00088611000310b000e8e61df/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookkeeperInternalCallbacks.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/0583175de72446d00088611000310b000e8e61df/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookkeeperInternalCallbacks.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookkeeperInternalCallbacks.java?ref=0583175de72446d00088611000310b000e8e61df","patch":"@@ -25,6 +25,7 @@\n import java.util.concurrent.atomic.AtomicInteger;\n \n import org.apache.bookkeeper.client.LedgerMetadata;\n+import org.apache.bookkeeper.client.BookieInfoReader.BookieInfo;\n import org.apache.bookkeeper.net.BookieSocketAddress;\n import org.apache.zookeeper.AsyncCallback;\n import org.jboss.netty.buffer.ChannelBuffer;\n@@ -88,6 +89,10 @@ public interface ReadEntryCallback {\n         void readEntryComplete(int rc, long ledgerId, long entryId, ChannelBuffer buffer, Object ctx);\n     }\n \n+    public interface GetBookieInfoCallback {\n+        void getBookieInfoComplete(int rc, BookieInfo bInfo, Object ctx);\n+    }\n+\n     /**\n      * This is a multi callback object that waits for all of\n      * the multiple async operations to complete. If any fail, then we invoke"},{"sha":"07e4d677b606a002f53d03fe6d486a2b5e8706eb","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookkeeperProtocol.java","status":"modified","additions":3766,"deletions":2256,"changes":6022,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/0583175de72446d00088611000310b000e8e61df/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookkeeperProtocol.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/0583175de72446d00088611000310b000e8e61df/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookkeeperProtocol.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookkeeperProtocol.java?ref=0583175de72446d00088611000310b000e8e61df"},{"sha":"88c5eb155fb99760c8b1e8068b553eb74df4fc42","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/GetBookieInfoProcessorV3.java","status":"added","additions":90,"deletions":0,"changes":90,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/0583175de72446d00088611000310b000e8e61df/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FGetBookieInfoProcessorV3.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/0583175de72446d00088611000310b000e8e61df/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FGetBookieInfoProcessorV3.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FGetBookieInfoProcessorV3.java?ref=0583175de72446d00088611000310b000e8e61df","patch":"@@ -0,0 +1,90 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.proto;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.bookkeeper.proto.BookkeeperProtocol.GetBookieInfoRequest;\n+import org.apache.bookkeeper.proto.BookkeeperProtocol.GetBookieInfoResponse;\n+import org.apache.bookkeeper.proto.BookkeeperProtocol.Request;\n+import org.apache.bookkeeper.proto.BookkeeperProtocol.Response;\n+import org.apache.bookkeeper.proto.BookkeeperProtocol.StatusCode;\n+import org.apache.bookkeeper.util.MathUtils;\n+import org.jboss.netty.channel.Channel;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class GetBookieInfoProcessorV3 extends PacketProcessorBaseV3 implements Runnable {\n+    private final static Logger LOG = LoggerFactory.getLogger(GetBookieInfoProcessorV3.class);\n+\n+    public GetBookieInfoProcessorV3(Request request, Channel channel,\n+                                     BookieRequestProcessor requestProcessor) {\n+        super(request, channel, requestProcessor);\n+    }\n+\n+    private GetBookieInfoResponse getGetBookieInfoResponse() {\n+        long startTimeNanos = MathUtils.nowInNano();\n+        GetBookieInfoRequest getBookieInfoRequest = request.getGetBookieInfoRequest();\n+        long requested = getBookieInfoRequest.getRequested();\n+\n+        GetBookieInfoResponse.Builder getBookieInfoResponse = GetBookieInfoResponse.newBuilder();\n+\n+        if (!isVersionCompatible()) {\n+            getBookieInfoResponse.setStatus(StatusCode.EBADVERSION);\n+            requestProcessor.getBookieInfoStats.registerFailedEvent(MathUtils.elapsedNanos(startTimeNanos),\n+                    TimeUnit.NANOSECONDS);\n+            return getBookieInfoResponse.build();\n+        }\n+\n+        LOG.debug(\"Received new getBookieInfo request: {}\", request);\n+        StatusCode status = StatusCode.EOK;\n+        long freeDiskSpace = 0L, totalDiskSpace = 0L;\n+        if ((requested & GetBookieInfoRequest.Flags.FREE_DISK_SPACE_VALUE) != 0) {\n+            freeDiskSpace = requestProcessor.bookie.getTotalFreeSpace();\n+            getBookieInfoResponse.setFreeDiskSpace(freeDiskSpace);\n+        }\n+        if ((requested & GetBookieInfoRequest.Flags.TOTAL_DISK_CAPACITY_VALUE) != 0) {\n+            totalDiskSpace = requestProcessor.bookie.getTotalDiskSpace();\n+            getBookieInfoResponse.setTotalDiskCapacity(totalDiskSpace);\n+        }\n+        LOG.debug(\"FreeDiskSpace info is \" + freeDiskSpace + \" totalDiskSpace is: \" + totalDiskSpace);\n+        getBookieInfoResponse.setStatus(status);\n+        requestProcessor.getBookieInfoStats.registerSuccessfulEvent(MathUtils.elapsedNanos(startTimeNanos),\n+                TimeUnit.NANOSECONDS);\n+        return getBookieInfoResponse.build();\n+    }\n+\n+    @Override\n+    public void safeRun() {\n+        GetBookieInfoResponse getBookieInfoResponse = getGetBookieInfoResponse();\n+        sendResponse(getBookieInfoResponse);\n+    }\n+\n+    private void sendResponse(GetBookieInfoResponse getBookieInfoResponse) {\n+        Response.Builder response = Response.newBuilder()\n+                .setHeader(getHeader())\n+                .setStatus(getBookieInfoResponse.getStatus())\n+                .setGetBookieInfoResponse(getBookieInfoResponse);\n+        sendResponse(response.getStatus(),\n+                     response.build(),\n+                     requestProcessor.getBookieInfoStats);\n+    }\n+}"},{"sha":"f6e9e8f7b053386ade3a4fd0c99492ed4231bb92","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java","status":"modified","additions":159,"deletions":5,"changes":164,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/0583175de72446d00088611000310b000e8e61df/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FPerChannelBookieClient.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/0583175de72446d00088611000310b000e8e61df/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FPerChannelBookieClient.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FPerChannelBookieClient.java?ref=0583175de72446d00088611000310b000e8e61df","patch":"@@ -32,25 +32,29 @@\n import com.google.protobuf.ByteString;\n import org.apache.bookkeeper.client.BKException;\n import org.apache.bookkeeper.client.BookKeeperClientStats;\n+import org.apache.bookkeeper.client.BookieInfoReader.BookieInfo;\n import org.apache.bookkeeper.conf.ClientConfiguration;\n import org.apache.bookkeeper.net.BookieSocketAddress;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ReadEntryCallback;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GetBookieInfoCallback;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteCallback;\n import org.apache.bookkeeper.proto.BookkeeperProtocol.AddRequest;\n import org.apache.bookkeeper.proto.BookkeeperProtocol.AddResponse;\n import org.apache.bookkeeper.proto.BookkeeperProtocol.BKPacketHeader;\n-import org.apache.bookkeeper.proto.BookkeeperProtocol.ReadLacRequest;\n-import org.apache.bookkeeper.proto.BookkeeperProtocol.ReadLacResponse;\n+import org.apache.bookkeeper.proto.BookkeeperProtocol.GetBookieInfoRequest;\n+import org.apache.bookkeeper.proto.BookkeeperProtocol.GetBookieInfoResponse;\n import org.apache.bookkeeper.proto.BookkeeperProtocol.OperationType;\n import org.apache.bookkeeper.proto.BookkeeperProtocol.ProtocolVersion;\n-import org.apache.bookkeeper.proto.BookkeeperProtocol.WriteLacRequest;\n-import org.apache.bookkeeper.proto.BookkeeperProtocol.WriteLacResponse;\n+import org.apache.bookkeeper.proto.BookkeeperProtocol.ReadLacRequest;\n+import org.apache.bookkeeper.proto.BookkeeperProtocol.ReadLacResponse;\n import org.apache.bookkeeper.proto.BookkeeperProtocol.ReadRequest;\n import org.apache.bookkeeper.proto.BookkeeperProtocol.ReadResponse;\n import org.apache.bookkeeper.proto.BookkeeperProtocol.Request;\n import org.apache.bookkeeper.proto.BookkeeperProtocol.Response;\n import org.apache.bookkeeper.proto.BookkeeperProtocol.StatusCode;\n+import org.apache.bookkeeper.proto.BookkeeperProtocol.WriteLacRequest;\n+import org.apache.bookkeeper.proto.BookkeeperProtocol.WriteLacResponse;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ReadEntryCallback;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteCallback;\n@@ -127,6 +131,7 @@ public class PerChannelBookieClient extends SimpleChannelHandler implements Chan\n     final int addEntryTimeout;\n     final int readEntryTimeout;\n     final int maxFrameSize;\n+    final int getBookieInfoTimeout;\n \n     private final ConcurrentHashMap<CompletionKey, CompletionValue> completionObjects = new ConcurrentHashMap<CompletionKey, CompletionValue>();\n \n@@ -139,6 +144,8 @@ public class PerChannelBookieClient extends SimpleChannelHandler implements Chan\n     private final OpStatsLogger addTimeoutOpLogger;\n     private final OpStatsLogger writeLacTimeoutOpLogger;\n     private final OpStatsLogger readLacTimeoutOpLogger;\n+    private final OpStatsLogger getBookieInfoOpLogger;\n+    private final OpStatsLogger getBookieInfoTimeoutOpLogger;\n \n     /**\n      * The following member variables do not need to be concurrent, or volatile\n@@ -194,6 +201,7 @@ public PerChannelBookieClient(ClientConfiguration conf, OrderedSafeExecutor exec\n         this.requestTimer = requestTimer;\n         this.addEntryTimeout = conf.getAddEntryTimeout();\n         this.readEntryTimeout = conf.getReadEntryTimeout();\n+        this.getBookieInfoTimeout = conf.getBookieInfoTimeout();\n \n         this.authProviderFactory = authProviderFactory;\n         this.extRegistry = extRegistry;\n@@ -209,10 +217,12 @@ public PerChannelBookieClient(ClientConfiguration conf, OrderedSafeExecutor exec\n         addEntryOpLogger = statsLogger.getOpStatsLogger(BookKeeperClientStats.CHANNEL_ADD_OP);\n         writeLacOpLogger = statsLogger.getOpStatsLogger(BookKeeperClientStats.CHANNEL_WRITE_LAC_OP);\n         readLacOpLogger = statsLogger.getOpStatsLogger(BookKeeperClientStats.CHANNEL_READ_LAC_OP);\n+        getBookieInfoOpLogger = statsLogger.getOpStatsLogger(BookKeeperClientStats.GET_BOOKIE_INFO_OP);\n         readTimeoutOpLogger = statsLogger.getOpStatsLogger(BookKeeperClientStats.CHANNEL_TIMEOUT_READ);\n         addTimeoutOpLogger = statsLogger.getOpStatsLogger(BookKeeperClientStats.CHANNEL_TIMEOUT_ADD);\n         writeLacTimeoutOpLogger = statsLogger.getOpStatsLogger(BookKeeperClientStats.CHANNEL_TIMEOUT_WRITE_LAC);\n         readLacTimeoutOpLogger = statsLogger.getOpStatsLogger(BookKeeperClientStats.CHANNEL_TIMEOUT_READ_LAC);\n+        getBookieInfoTimeoutOpLogger = statsLogger.getOpStatsLogger(BookKeeperClientStats.TIMEOUT_GET_BOOKIE_INFO);\n \n         this.pcbcPool = pcbcPool;\n \n@@ -674,6 +684,58 @@ public void operationComplete(ChannelFuture future) throws Exception {\n         }\n     }\n \n+    public void getBookieInfo(final long requested, GetBookieInfoCallback cb, Object ctx) {\n+        final long txnId = getTxnId();\n+        final CompletionKey completionKey = new CompletionKey(txnId, OperationType.GET_BOOKIE_INFO);\n+        completionObjects.put(completionKey,\n+                new GetBookieInfoCompletion(this, getBookieInfoOpLogger, cb, ctx,\n+                                   scheduleTimeout(completionKey, getBookieInfoTimeout)));\n+\n+        // Build the request and calculate the total size to be included in the packet.\n+        BKPacketHeader.Builder headerBuilder = BKPacketHeader.newBuilder()\n+                .setVersion(ProtocolVersion.VERSION_THREE)\n+                .setOperation(OperationType.GET_BOOKIE_INFO)\n+                .setTxnId(txnId);\n+\n+        GetBookieInfoRequest.Builder getBookieInfoBuilder = GetBookieInfoRequest.newBuilder()\n+                .setRequested(requested);\n+\n+        final Request getBookieInfoRequest = Request.newBuilder()\n+                .setHeader(headerBuilder)\n+                .setGetBookieInfoRequest(getBookieInfoBuilder)\n+                .build();\n+\n+        final Channel c = channel;\n+        if (c == null) {\n+            errorOutReadKey(completionKey);\n+            return;\n+        }\n+\n+        try{\n+            ChannelFuture future = c.write(getBookieInfoRequest);\n+            future.addListener(new ChannelFutureListener() {\n+                @Override\n+                public void operationComplete(ChannelFuture future) throws Exception {\n+                    if (future.isSuccess()) {\n+                        if (LOG.isDebugEnabled()) {\n+                            LOG.debug(\"Successfully wrote request {} to {}\",\n+                                    getBookieInfoRequest, c.getRemoteAddress());\n+                        }\n+                    } else {\n+                        if (!(future.getCause() instanceof ClosedChannelException)) {\n+                            LOG.warn(\"Writing GetBookieInfoRequest(flags={}) to channel {} failed : \",\n+                                    new Object[] { requested, c, future.getCause() });\n+                        }\n+                        errorOutReadKey(completionKey);\n+                    }\n+                }\n+            });\n+        } catch(Throwable e) {\n+            LOG.warn(\"Get metadata operation {} failed\", getBookieInfoRequest, e);\n+            errorOutReadKey(completionKey);\n+        }\n+    }\n+\n     /**\n      * Disconnects the bookie client. It can be reused.\n      */\n@@ -848,6 +910,29 @@ public String toString() {\n         });\n     }\n \n+    void errorOutGetBookieInfoKey(final CompletionKey key) {\n+        errorOutGetBookieInfoKey(key, BKException.Code.BookieHandleNotAvailableException);\n+    }\n+\n+    void errorOutGetBookieInfoKey(final CompletionKey key, final int rc) {\n+        final GetBookieInfoCompletion getBookieInfoCompletion = (GetBookieInfoCompletion)completionObjects.remove(key);\n+        if (null == getBookieInfoCompletion) {\n+            return;\n+        }\n+        executor.submit(new SafeRunnable() {\n+            @Override\n+            public void safeRun() {\n+                String bAddress = \"null\";\n+                Channel c = channel;\n+                if (c != null) {\n+                    bAddress = c.getRemoteAddress().toString();\n+                }\n+                LOG.debug(\"Could not write getBookieInfo request for bookie: {}\", new Object[] {bAddress});\n+                getBookieInfoCompletion.cb.getBookieInfoComplete(rc, new BookieInfo(), getBookieInfoCompletion.ctx);\n+            }\n+        });\n+    }\n+\n     /**\n      * Errors out pending entries. We call this method from one thread to avoid\n      * concurrent executions to QuorumOpMonitor (implements callbacks). It seems\n@@ -1009,6 +1094,9 @@ public void safeRun() {\n                         case READ_LAC:\n                             handleReadLacResponse(response.getReadLacResponse(), completionValue);\n                             break;\n+                        case GET_BOOKIE_INFO:\n+                            handleGetBookieInfoResponse(response, completionValue);\n+                            break;\n                         default:\n                             LOG.error(\"Unexpected response, type:{} received from bookie:{}, ignoring\",\n                                       type, addr);\n@@ -1134,6 +1222,33 @@ void handleReadResponse(Response response, CompletionValue completionValue) {\n         rc.cb.readEntryComplete(rcToRet, ledgerId, entryId, buffer.slice(), rc.ctx);\n     }\n \n+    void handleGetBookieInfoResponse(Response response, CompletionValue completionValue) {\n+        // The completion value should always be an instance of a GetBookieInfoCompletion object when we reach here.\n+        GetBookieInfoCompletion rc = (GetBookieInfoCompletion)completionValue;\n+        GetBookieInfoResponse getBookieInfoResponse = response.getGetBookieInfoResponse();\n+\n+        long freeDiskSpace = getBookieInfoResponse.hasFreeDiskSpace() ? getBookieInfoResponse.getFreeDiskSpace() : 0L;\n+        long totalDiskCapacity = getBookieInfoResponse.hasTotalDiskCapacity() ? getBookieInfoResponse.getTotalDiskCapacity() : 0L;\n+\n+        StatusCode status = response.getStatus() == StatusCode.EOK ? getBookieInfoResponse.getStatus() : response.getStatus();\n+\n+        if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"Got response for read metadata request from bookie: {} rc {}\", addr, rc);\n+        }\n+\n+        // convert to BKException code because thats what the upper\n+        // layers expect. This is UGLY, there should just be one set of\n+        // error codes.\n+        Integer rcToRet = statusCodeToExceptionCode(status);\n+        if (null == rcToRet) {\n+            LOG.error(\"Read metadata failed on bookie:{} with code:{}\",\n+                      new Object[] { addr, status });\n+            rcToRet = BKException.Code.ReadException;\n+        }\n+        LOG.debug(\"Response received from bookie info read: freeDiskSpace=\" +  freeDiskSpace + \" totalDiskSpace:\" + totalDiskCapacity);\n+        rc.cb.getBookieInfoComplete(rcToRet, new BookieInfo(totalDiskCapacity, freeDiskSpace), rc.ctx);\n+    }\n+\n     /**\n      * Boiler-plate wrapper classes follow\n      *\n@@ -1256,6 +1371,42 @@ public void readEntryComplete(int rc, long ledgerId, long entryId, ChannelBuffer\n         }\n     }\n \n+    // visible for testing\n+    static class GetBookieInfoCompletion extends CompletionValue {\n+        final GetBookieInfoCallback cb;\n+\n+        public GetBookieInfoCompletion(final PerChannelBookieClient pcbc, GetBookieInfoCallback cb, Object ctx) {\n+            this(pcbc, null, cb, ctx, null);\n+        }\n+\n+        public GetBookieInfoCompletion(final PerChannelBookieClient pcbc, final OpStatsLogger getBookieInfoOpLogger,\n+                              final GetBookieInfoCallback originalCallback,\n+                              final Object originalCtx, final Timeout timeout) {\n+            super(originalCtx, 0L, 0L, timeout);\n+            final long startTime = MathUtils.nowInNano();\n+            this.cb = (null == getBookieInfoOpLogger) ? originalCallback : new GetBookieInfoCallback() {\n+                @Override\n+                public void getBookieInfoComplete(int rc, BookieInfo bInfo, Object ctx) {\n+                    cancelTimeout();\n+                    if (getBookieInfoOpLogger != null) {\n+                        long latency = MathUtils.elapsedNanos(startTime);\n+                        if (rc != BKException.Code.OK) {\n+                            getBookieInfoOpLogger.registerFailedEvent(latency, TimeUnit.NANOSECONDS);\n+                        } else {\n+                            getBookieInfoOpLogger.registerSuccessfulEvent(latency, TimeUnit.NANOSECONDS);\n+                        }\n+                    }\n+\n+                    if (rc != BKException.Code.OK && !expectedBkOperationErrors.contains(rc)) {\n+                        pcbc.recordError();\n+                    }\n+\n+                    originalCallback.getBookieInfoComplete(rc, bInfo, originalCtx);\n+                }\n+            };\n+        }\n+    }\n+\n     // visible for testing\n     static class AddCompletion extends CompletionValue {\n         final WriteCallback cb;\n@@ -1355,9 +1506,12 @@ public void run(Timeout timeout) throws Exception {\n             } else if (OperationType.WRITE_LAC == operationType) {\n                 errorOutWriteLacKey(this, BKException.Code.TimeoutException);\n                 writeLacTimeoutOpLogger.registerSuccessfulEvent(elapsedTime(), TimeUnit.NANOSECONDS);\n-            } else {\n+            } else if (OperationType.READ_LAC == operationType) {\n                 errorOutReadLacKey(this, BKException.Code.TimeoutException);\n                 readLacTimeoutOpLogger.registerSuccessfulEvent(elapsedTime(), TimeUnit.NANOSECONDS);\n+            } else {\n+                errorOutGetBookieInfoKey(this, BKException.Code.TimeoutException);\n+                getBookieInfoTimeoutOpLogger.registerSuccessfulEvent(elapsedTime(), TimeUnit.NANOSECONDS);\n             }\n \t}\n     }"},{"sha":"504e231b9897e826a13cfaadbcbb84bf8cf4395b","filename":"bookkeeper-server/src/main/proto/BookkeeperProtocol.proto","status":"modified","additions":18,"deletions":0,"changes":18,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/0583175de72446d00088611000310b000e8e61df/bookkeeper-server%2Fsrc%2Fmain%2Fproto%2FBookkeeperProtocol.proto","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/0583175de72446d00088611000310b000e8e61df/bookkeeper-server%2Fsrc%2Fmain%2Fproto%2FBookkeeperProtocol.proto","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fproto%2FBookkeeperProtocol.proto?ref=0583175de72446d00088611000310b000e8e61df","patch":"@@ -59,6 +59,7 @@ enum OperationType {\n     AUTH = 5;\n     WRITE_LAC = 6;\n     READ_LAC = 7;\n+    GET_BOOKIE_INFO = 8;\n }\n \n /**\n@@ -78,6 +79,7 @@ message Request {\n     optional AuthMessage authRequest = 102;\n     optional WriteLacRequest writeLacRequest = 103;\n     optional ReadLacRequest readLacRequest = 104;\n+    optional GetBookieInfoRequest getBookieInfoRequest = 105;\n }\n \n message ReadRequest {\n@@ -114,6 +116,15 @@ message ReadLacRequest {\n     required int64 ledgerId = 1;\n }\n \n+message GetBookieInfoRequest {\n+    enum Flags {\n+        TOTAL_DISK_CAPACITY = 0x01;\n+        FREE_DISK_SPACE = 0x02;\n+    }\n+    // bitwise OR of Flags\n+    optional int64 requested = 1;\n+}\n+\n message Response {\n \n     required BKPacketHeader header = 1;\n@@ -126,6 +137,7 @@ message Response {\n     optional AuthMessage authResponse = 102;\n     optional WriteLacResponse writeLacResponse = 103;\n     optional ReadLacResponse readLacResponse = 104;\n+    optional GetBookieInfoResponse getBookieInfoResponse = 105;\n }\n \n message ReadResponse {\n@@ -157,3 +169,9 @@ message ReadLacResponse {\n     optional bytes lacBody = 3; // lac sent by PutLacRequest\n     optional bytes lastEntryBody = 4; // Actual last entry on the disk\n }\n+\n+message GetBookieInfoResponse {\n+    required StatusCode status = 1;\n+    optional int64 totalDiskCapacity = 2;\n+    optional int64 freeDiskSpace = 3;\n+}"},{"sha":"2f885c0e6d4a0d96e27929cf24db05b88f5354ee","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookKeeperDiskSpaceWeightedLedgerPlacementTest.java","status":"added","additions":452,"deletions":0,"changes":452,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/0583175de72446d00088611000310b000e8e61df/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookKeeperDiskSpaceWeightedLedgerPlacementTest.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/0583175de72446d00088611000310b000e8e61df/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookKeeperDiskSpaceWeightedLedgerPlacementTest.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookKeeperDiskSpaceWeightedLedgerPlacementTest.java?ref=0583175de72446d00088611000310b000e8e61df","patch":"@@ -0,0 +1,452 @@\n+package org.apache.bookkeeper.client;\n+/*\n+*\n+* Licensed to the Apache Software Foundation (ASF) under one\n+* or more contributor license agreements.  See the NOTICE file\n+* distributed with this work for additional information\n+* regarding copyright ownership.  The ASF licenses this file\n+* to you under the Apache License, Version 2.0 (the\n+* \"License\"); you may not use this file except in compliance\n+* with the License.  You may obtain a copy of the License at\n+*\n+*   http://www.apache.org/licenses/LICENSE-2.0\n+*\n+* Unless required by applicable law or agreed to in writing,\n+* software distributed under the License is distributed on an\n+* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+* KIND, either express or implied.  See the License for the\n+* specific language governing permissions and limitations\n+* under the License.\n+*\n+*/\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.bookkeeper.bookie.Bookie;\n+import org.apache.bookkeeper.conf.ClientConfiguration;\n+import org.apache.bookkeeper.conf.ServerConfiguration;\n+import org.apache.bookkeeper.client.BookKeeper.DigestType;\n+import org.apache.bookkeeper.net.BookieSocketAddress;\n+import org.apache.bookkeeper.proto.BookieServer;\n+import org.apache.bookkeeper.test.BookKeeperClusterTestCase;\n+import org.apache.bookkeeper.util.MathUtils;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.junit.Assert.*;\n+\n+/**\n+ * Tests of the main BookKeeper client\n+ */\n+public class BookKeeperDiskSpaceWeightedLedgerPlacementTest extends BookKeeperClusterTestCase {\n+    private final static Logger LOG = LoggerFactory.getLogger(BookKeeperDiskSpaceWeightedLedgerPlacementTest.class);\n+\n+    public BookKeeperDiskSpaceWeightedLedgerPlacementTest() {\n+        super(10);\n+    }\n+    \n+    private BookieServer restartBookie(ServerConfiguration conf, final long initialFreeDiskSpace,\n+            final long finallFreeDiskSpace, final int delaySecs) throws Exception {\n+        Bookie bookieWithCustomFreeDiskSpace = new Bookie(conf) {\n+            long startTime = System.currentTimeMillis();\n+            @Override\n+            public long getTotalFreeSpace() {\n+                if (startTime == 0) {\n+                    startTime = System.currentTimeMillis();\n+                }\n+                if (delaySecs == 0 || ((System.currentTimeMillis()) - startTime < delaySecs*1000)) {\n+                    return initialFreeDiskSpace;\n+                } else {\n+                    // after delaySecs, advertise finallFreeDiskSpace; before that advertise initialFreeDiskSpace\n+                    return finallFreeDiskSpace;\n+                }\n+            }\n+        };\n+        bsConfs.add(conf);\n+        BookieServer server = startBookie(conf, bookieWithCustomFreeDiskSpace);\n+        bs.add(server);\n+        return server;\n+    }\n+\n+    private BookieServer replaceBookieWithCustomFreeDiskSpaceBookie(int bookieIdx, final long freeDiskSpace)\n+            throws Exception {\n+        LOG.info(\"Killing bookie \" + bs.get(bookieIdx).getLocalAddress());\n+        bs.get(bookieIdx).getLocalAddress();\n+        ServerConfiguration conf = killBookie(bookieIdx);\n+        return restartBookie(conf, freeDiskSpace, freeDiskSpace, 0);\n+    }\n+\n+    private BookieServer replaceBookieWithCustomFreeDiskSpaceBookie(BookieServer bookie, final long freeDiskSpace)\n+            throws Exception {\n+        for (int i=0; i < bs.size(); i++) {\n+            if (bs.get(i).getLocalAddress().equals(bookie.getLocalAddress())) {\n+                return replaceBookieWithCustomFreeDiskSpaceBookie(i, freeDiskSpace);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private BookieServer replaceBookieWithCustomFreeDiskSpaceBookie(int bookieIdx, long initialFreeDiskSpace,\n+             long finalFreeDiskSpace, int delay) throws Exception {\n+        LOG.info(\"Killing bookie \" + bs.get(bookieIdx).getLocalAddress());\n+        bs.get(bookieIdx).getLocalAddress();\n+        ServerConfiguration conf = killBookie(bookieIdx);\n+        return restartBookie(conf, initialFreeDiskSpace, finalFreeDiskSpace, delay);\n+    }\n+\n+    /**\n+     * Test to show that weight based selection honors the disk weight of bookies\n+     */\n+    @Test(timeout=60000)\n+    public void testDiskSpaceWeightedBookieSelection() throws Exception {\n+        long freeDiskSpace=1000000L;\n+        int multiple=3;\n+        for (int i=0; i < numBookies; i++) {\n+            // the first 8 bookies have freeDiskSpace of 1MB; While the remaining 2 have 3MB\n+            if (i < numBookies-2) {\n+                replaceBookieWithCustomFreeDiskSpaceBookie(0, freeDiskSpace);\n+            } else {\n+                replaceBookieWithCustomFreeDiskSpaceBookie(0, multiple*freeDiskSpace);\n+            }\n+        }\n+        Map<BookieSocketAddress, Integer> m = new HashMap<BookieSocketAddress, Integer>();\n+        for (BookieServer b : bs) {\n+            m.put(b.getLocalAddress(), 0);\n+        }\n+\n+        // wait a 100 msecs each for the bookies to come up and the bookieInfo to be retrieved by the client\n+        ClientConfiguration conf = new ClientConfiguration()\n+            .setZkServers(zkUtil.getZooKeeperConnectString()).setDiskWeightBasedPlacementEnabled(true).\n+            setBookieMaxWeightMultipleForWeightBasedPlacement(multiple);\n+        Thread.sleep(200);\n+        final BookKeeper client = new BookKeeper(conf);\n+        Thread.sleep(200);\n+        for (int i = 0; i < 2000; i++) {\n+            LedgerHandle lh = client.createLedger(3, 3, DigestType.CRC32, \"testPasswd\".getBytes());\n+            for (BookieSocketAddress b : lh.getLedgerMetadata().getEnsemble(0)) {\n+                m.put(b, m.get(b)+1);\n+            }\n+        }\n+        client.close();\n+        // make sure that bookies with higher weight(the last 2 bookies) are chosen 3X as often as the median;\n+        // since the number of ledgers created is small (2000), we allow a range of 2X to 4X instead of the exact 3X\n+        for (int i=0; i < numBookies-2; i++) {\n+            double ratio1 = (double)m.get(bs.get(numBookies-2).getLocalAddress())/(double)m.get(bs.get(i).getLocalAddress());\n+            assertTrue(\"Weigheted placement is not honored: \" + Math.abs(ratio1-multiple), Math.abs(ratio1-multiple) < 1);\n+            double ratio2 = (double)m.get(bs.get(numBookies-1).getLocalAddress())/(double)m.get(bs.get(i).getLocalAddress());\n+            assertTrue(\"Weigheted placement is not honored: \" + Math.abs(ratio2-multiple), Math.abs(ratio2-multiple) < 1);\n+        }\n+    }\n+\n+    /**\n+     * Test to show that weight based selection honors the disk weight of bookies and also adapts\n+     * when the bookies's weight changes.\n+     */\n+    @Test(timeout=60000)\n+    public void testDiskSpaceWeightedBookieSelectionWithChangingWeights() throws Exception {\n+        long freeDiskSpace=1000000L;\n+        int multiple=3;\n+        for (int i=0; i < numBookies; i++) {\n+            // the first 8 bookies have freeDiskSpace of 1MB; While the remaining 2 have 3MB\n+            if (i < numBookies-2) {\n+                replaceBookieWithCustomFreeDiskSpaceBookie(0, freeDiskSpace);\n+            } else {\n+                replaceBookieWithCustomFreeDiskSpaceBookie(0, multiple*freeDiskSpace);\n+            }\n+        }\n+        Map<BookieSocketAddress, Integer> m = new HashMap<BookieSocketAddress, Integer>();\n+        for (BookieServer b : bs) {\n+            m.put(b.getLocalAddress(), 0);\n+        }\n+\n+        // wait a 100 msecs each for the bookies to come up and the bookieInfo to be retrieved by the client\n+        ClientConfiguration conf = new ClientConfiguration()\n+            .setZkServers(zkUtil.getZooKeeperConnectString()).setDiskWeightBasedPlacementEnabled(true).\n+            setBookieMaxWeightMultipleForWeightBasedPlacement(multiple);\n+        Thread.sleep(100);\n+        final BookKeeper client = new BookKeeper(conf);\n+        Thread.sleep(100);\n+        for (int i = 0; i < 2000; i++) {\n+            LedgerHandle lh = client.createLedger(3, 3, DigestType.CRC32, \"testPasswd\".getBytes());\n+            for (BookieSocketAddress b : lh.getLedgerMetadata().getEnsemble(0)) {\n+                m.put(b, m.get(b)+1);\n+            }\n+        }\n+\n+        // make sure that bookies with higher weight(the last 2 bookies) are chosen 3X as often as the median;\n+        // since the number of ledgers created is small (2000), we allow a range of 2X to 4X instead of the exact 3X\n+        for (int i=0; i < numBookies-2; i++) {\n+            double ratio1 = (double)m.get(bs.get(numBookies-2).getLocalAddress())/(double)m.get(bs.get(i).getLocalAddress());\n+            assertTrue(\"Weigheted placement is not honored: \" + Math.abs(ratio1-multiple), Math.abs(ratio1-multiple) < 1);\n+            double ratio2 = (double)m.get(bs.get(numBookies-1).getLocalAddress())/(double)m.get(bs.get(i).getLocalAddress());\n+            assertTrue(\"Weigheted placement is not honored: \" + Math.abs(ratio2-multiple), Math.abs(ratio2-multiple) < 1);\n+        }\n+\n+        // Restart the bookies in such a way that the first 2 bookies go from 1MB to 3MB free space and the last\n+        // 2 bookies go from 3MB to 1MB\n+        BookieServer server1 = bs.get(0);\n+        BookieServer server2 = bs.get(1);\n+        BookieServer server3 = bs.get(numBookies-2);\n+        BookieServer server4 = bs.get(numBookies-1);\n+\n+        server1 = replaceBookieWithCustomFreeDiskSpaceBookie(server1, multiple*freeDiskSpace);\n+        server2 = replaceBookieWithCustomFreeDiskSpaceBookie(server2, multiple*freeDiskSpace);\n+        server3 = replaceBookieWithCustomFreeDiskSpaceBookie(server3, freeDiskSpace);\n+        server4 = replaceBookieWithCustomFreeDiskSpaceBookie(server4, freeDiskSpace);\n+\n+        Thread.sleep(100);\n+        for (BookieServer b : bs) {\n+            m.put(b.getLocalAddress(), 0);\n+        }\n+        for (int i = 0; i < 2000; i++) {\n+            LedgerHandle lh = client.createLedger(3, 3, DigestType.CRC32, \"testPasswd\".getBytes());\n+            for (BookieSocketAddress b : lh.getLedgerMetadata().getEnsemble(0)) {\n+                m.put(b, m.get(b)+1);\n+            }\n+        }\n+\n+        // make sure that bookies with higher weight(the last 2 bookies) are chosen 3X as often as the median;\n+        // since the number of ledgers created is small (2000), we allow a range of 2X to 4X instead of the exact 3X\n+        for (int i=0; i < numBookies; i++) {\n+            if (server1.getLocalAddress().equals(bs.get(i).getLocalAddress()) ||\n+                server2.getLocalAddress().equals(bs.get(i).getLocalAddress())) {\n+                continue;\n+            }\n+            double ratio1 = (double)m.get(server1.getLocalAddress())/(double)m.get(bs.get(i).getLocalAddress());\n+            assertTrue(\"Weigheted placement is not honored: \" + Math.abs(ratio1-multiple), Math.abs(ratio1-multiple) < 1);\n+            double ratio2 = (double)m.get(server2.getLocalAddress())/(double)m.get(bs.get(i).getLocalAddress());\n+            assertTrue(\"Weigheted placement is not honored: \" + Math.abs(ratio2-multiple), Math.abs(ratio2-multiple) < 1);\n+        }\n+        client.close();\n+    }\n+\n+    /**\n+     * Test to show that weight based selection honors the disk weight of bookies and also adapts\n+     * when bookies go away permanently.\n+     */\n+    @Test(timeout=60000)\n+    public void testDiskSpaceWeightedBookieSelectionWithBookiesDying() throws Exception {\n+        long freeDiskSpace=1000000L;\n+        int multiple=3;\n+        for (int i=0; i < numBookies; i++) {\n+            // the first 8 bookies have freeDiskSpace of 1MB; While the remaining 2 have 1GB\n+            if (i < numBookies-2) {\n+                replaceBookieWithCustomFreeDiskSpaceBookie(0, freeDiskSpace);\n+            } else {\n+                replaceBookieWithCustomFreeDiskSpaceBookie(0, multiple*freeDiskSpace);\n+            }\n+        }\n+        Map<BookieSocketAddress, Integer> m = new HashMap<BookieSocketAddress, Integer>();\n+        for (BookieServer b : bs) {\n+            m.put(b.getLocalAddress(), 0);\n+        }\n+\n+        // wait a couple of 100 msecs each for the bookies to come up and the bookieInfo to be retrieved by the client\n+        ClientConfiguration conf = new ClientConfiguration()\n+            .setZkServers(zkUtil.getZooKeeperConnectString()).setDiskWeightBasedPlacementEnabled(true).\n+            setBookieMaxWeightMultipleForWeightBasedPlacement(multiple);\n+        Thread.sleep(100);\n+        final BookKeeper client = new BookKeeper(conf);\n+        Thread.sleep(100);\n+        for (int i = 0; i < 2000; i++) {\n+            LedgerHandle lh = client.createLedger(3, 3, DigestType.CRC32, \"testPasswd\".getBytes());\n+            for (BookieSocketAddress b : lh.getLedgerMetadata().getEnsemble(0)) {\n+                m.put(b, m.get(b)+1);\n+            }\n+        }\n+\n+        // make sure that bookies with higher weight are chosen 3X as often as the median;\n+        // since the number of ledgers is small (2000), there may be variation \n+        double ratio1 = (double)m.get(bs.get(numBookies-2).getLocalAddress())/(double)m.get(bs.get(0).getLocalAddress());\n+        assertTrue(\"Weigheted placement is not honored: \" + Math.abs(ratio1-multiple), Math.abs(ratio1-multiple) < 1);\n+        double ratio2 = (double)m.get(bs.get(numBookies-1).getLocalAddress())/(double)m.get(bs.get(1).getLocalAddress());\n+        assertTrue(\"Weigheted placement is not honored: \" + Math.abs(ratio2-multiple), Math.abs(ratio2-multiple) < 1);\n+\n+        // Bring down the 2 bookies that had higher weight; after this the allocation to all\n+        // the remaining bookies should be uniform\n+        for (BookieServer b : bs) {\n+            m.put(b.getLocalAddress(), 0);\n+        }\n+        BookieServer server1 = bs.get(numBookies-2);\n+        BookieServer server2 = bs.get(numBookies-1);\n+        killBookie(numBookies-1);\n+        killBookie(numBookies-2);\n+\n+        // give some time for the cluster to become stable\n+        Thread.sleep(100);\n+        for (int i = 0; i < 2000; i++) {\n+            LedgerHandle lh = client.createLedger(3, 3, DigestType.CRC32, \"testPasswd\".getBytes());\n+            for (BookieSocketAddress b : lh.getLedgerMetadata().getEnsemble(0)) {\n+                m.put(b, m.get(b)+1);\n+            }\n+        }\n+\n+        // make sure that bookies with higher weight are chosen 3X as often as the median;\n+        for (int i=0; i < numBookies-3; i++) {\n+            double delta = Math.abs((double)m.get(bs.get(i).getLocalAddress())-(double)m.get(bs.get(i+1).getLocalAddress()));\n+            delta = (delta*100)/(double)m.get(bs.get(i+1).getLocalAddress());\n+            assertTrue(\"Weigheted placement is not honored: \" + delta, delta <= 30); // the deviation should be less than 30%\n+        }\n+        // since the following 2 bookies were down, they shouldn't ever be selected\n+        assertTrue(\"Weigheted placement is not honored\" + m.get(server1.getLocalAddress()),\n+                m.get(server1.getLocalAddress()) == 0);\n+        assertTrue(\"Weigheted placement is not honored\" + m.get(server2.getLocalAddress()),\n+                m.get(server2.getLocalAddress()) == 0);\n+\n+        client.close();\n+    }\n+\n+    /**\n+     * Test to show that weight based selection honors the disk weight of bookies and also adapts\n+     * when bookies are added.\n+     */\n+    @Test(timeout=60000)\n+    public void testDiskSpaceWeightedBookieSelectionWithBookiesBeingAdded() throws Exception {\n+        long freeDiskSpace=1000000L;\n+        int multiple=3;\n+        for (int i=0; i < numBookies; i++) {\n+            // all the bookies have freeDiskSpace of 1MB\n+            replaceBookieWithCustomFreeDiskSpaceBookie(0, freeDiskSpace);\n+        }\n+        // let the last two bookies be down initially\n+        ServerConfiguration conf1 = killBookie(numBookies-1);\n+        ServerConfiguration conf2 = killBookie(numBookies-2);\n+        Map<BookieSocketAddress, Integer> m = new HashMap<BookieSocketAddress, Integer>();\n+        for (BookieServer b : bs) {\n+            m.put(b.getLocalAddress(), 0);\n+        }\n+\n+        // wait a bit for the bookies to come up and the bookieInfo to be retrieved by the client\n+        ClientConfiguration conf = new ClientConfiguration()\n+            .setZkServers(zkUtil.getZooKeeperConnectString()).setDiskWeightBasedPlacementEnabled(true).\n+            setBookieMaxWeightMultipleForWeightBasedPlacement(multiple);\n+        Thread.sleep(100);\n+        final BookKeeper client = new BookKeeper(conf);\n+        Thread.sleep(100);\n+        for (int i = 0; i < 2000; i++) {\n+            LedgerHandle lh = client.createLedger(3, 3, DigestType.CRC32, \"testPasswd\".getBytes());\n+            for (BookieSocketAddress b : lh.getLedgerMetadata().getEnsemble(0)) {\n+                m.put(b, m.get(b)+1);\n+            }\n+        }\n+\n+        // make sure that bookies with higher weight are chosen 3X as often as the median;\n+        // since the number of ledgers is small (2000), there may be variation\n+        for (int i=0; i < numBookies-3; i++) {\n+            double delta = Math.abs((double)m.get(bs.get(i).getLocalAddress())-(double)m.get(bs.get(i+1).getLocalAddress()));\n+            delta = (delta*100)/(double)m.get(bs.get(i+1).getLocalAddress());\n+            assertTrue(\"Weigheted placement is not honored: \" + delta, delta <= 30); // the deviation should be less than 30%\n+        }\n+\n+        // bring up the two dead bookies; they'll also have 3X more free space than the rest of the bookies\n+        restartBookie(conf1, multiple*freeDiskSpace, multiple*freeDiskSpace, 0);\n+        restartBookie(conf2, multiple*freeDiskSpace, multiple*freeDiskSpace, 0);\n+\n+        // give some time for the cluster to become stable\n+        Thread.sleep(100);\n+        for (BookieServer b : bs) {\n+            m.put(b.getLocalAddress(), 0);\n+        }\n+        for (int i = 0; i < 2000; i++) {\n+            LedgerHandle lh = client.createLedger(3, 3, DigestType.CRC32, \"testPasswd\".getBytes());\n+            for (BookieSocketAddress b : lh.getLedgerMetadata().getEnsemble(0)) {\n+                m.put(b, m.get(b)+1);\n+            }\n+        }\n+\n+        // make sure that bookies with higher weight(the last 2 bookies) are chosen 3X as often as the median;\n+        // since the number of ledgers created is small (2000), we allow a range of 2X to 4X instead of the exact 3X\n+        for (int i=0; i < numBookies-2; i++) {\n+            double ratio1 = (double)m.get(bs.get(numBookies-2).getLocalAddress())/(double)m.get(bs.get(i).getLocalAddress());\n+            assertTrue(\"Weigheted placement is not honored: \" + Math.abs(ratio1-multiple), Math.abs(ratio1-multiple) < 1);\n+            double ratio2 = (double)m.get(bs.get(numBookies-1).getLocalAddress())/(double)m.get(bs.get(i).getLocalAddress());\n+            assertTrue(\"Weigheted placement is not honored: \" + Math.abs(ratio2-multiple), Math.abs(ratio2-multiple) < 1);\n+        }\n+        client.close();\n+    }\n+\n+    /**\n+     * Tests that the bookie selection is based on the amount of free disk space a bookie has. Also make sure that\n+     * the periodic bookieInfo read is working and causes the new weights to be taken into account.\n+     */\n+    @Test(timeout=60000)\n+    public void testDiskSpaceWeightedBookieSelectionWithPeriodicBookieInfoUpdate() throws Exception {\n+        long freeDiskSpace=1000000L;\n+        int multiple=3;\n+        for (int i=0; i < numBookies; i++) {\n+            // the first 8 bookies have freeDiskSpace of 1MB; the remaining 2 will advertise 1MB for\n+            // the first 3 seconds but then they'll advertise 3MB after the first 3 seconds\n+            if (i < numBookies-2) {\n+                replaceBookieWithCustomFreeDiskSpaceBookie(0, freeDiskSpace);\n+            } else {\n+                replaceBookieWithCustomFreeDiskSpaceBookie(0, freeDiskSpace, multiple*freeDiskSpace, 2);\n+            }\n+        }\n+        Map<BookieSocketAddress, Integer> m = new HashMap<BookieSocketAddress, Integer>();\n+        for (BookieServer b : bs) {\n+            m.put(b.getLocalAddress(), 0);\n+        }\n+\n+        // the periodic bookieInfo is read once every 7 seconds\n+        int updateIntervalSecs = 6;\n+        ClientConfiguration conf = new ClientConfiguration()\n+            .setZkServers(zkUtil.getZooKeeperConnectString()).setDiskWeightBasedPlacementEnabled(true).\n+            setBookieMaxWeightMultipleForWeightBasedPlacement(multiple).\n+            setGetBookieInfoIntervalSeconds(updateIntervalSecs, TimeUnit.SECONDS);\n+        // wait a bit for the bookies to come up and the bookieInfo to be retrieved by the client\n+        Thread.sleep(100);\n+        final BookKeeper client = new BookKeeper(conf);\n+        Thread.sleep(100);\n+        long startMsecs = MathUtils.now();\n+        for (int i = 0; i < 2000; i++) {\n+            LedgerHandle lh = client.createLedger(3, 3, DigestType.CRC32, \"testPasswd\".getBytes());\n+            for (BookieSocketAddress b : lh.getLedgerMetadata().getEnsemble(0)) {\n+                m.put(b, m.get(b)+1);\n+            }\n+        }\n+        long elapsedMsecs = MathUtils.now() - startMsecs;\n+\n+        // make sure that all the bookies are chosen pretty much uniformly\n+        int bookiesToCheck = numBookies-1;\n+        if (elapsedMsecs > updateIntervalSecs*1000) {\n+            // if this task longer than updateIntervalSecs, the weight for the last 2 bookies will be\n+            // higher, so skip checking them\n+            bookiesToCheck = numBookies-3;\n+        }\n+        for (int i=0; i < bookiesToCheck; i++) {\n+            double delta = Math.abs((double)m.get(bs.get(i).getLocalAddress())-(double)m.get(bs.get(i+1).getLocalAddress()));\n+            delta = (delta*100)/(double)m.get(bs.get(i+1).getLocalAddress());\n+            assertTrue(\"Weigheted placement is not honored: \" + delta, delta <= 30); // the deviation should be <30%\n+        }\n+\n+        if (elapsedMsecs < updateIntervalSecs*1000) {\n+            // sleep until periodic bookie info retrieval kicks in and it gets the updated\n+            // freeDiskSpace for the last 2 bookies\n+            Thread.sleep(updateIntervalSecs*1000 - elapsedMsecs);\n+        }\n+\n+        for (BookieServer b : bs) {\n+            m.put(b.getLocalAddress(), 0);\n+        }\n+        for (int i = 0; i < 2000; i++) {\n+            LedgerHandle lh = client.createLedger(3, 3, DigestType.CRC32, \"testPasswd\".getBytes());\n+            for (BookieSocketAddress b : lh.getLedgerMetadata().getEnsemble(0)) {\n+                m.put(b, m.get(b)+1);\n+            }\n+        }\n+\n+        // make sure that bookies with higher weight(the last 2 bookies) are chosen 3X as often as the median;\n+        // since the number of ledgers created is small (2000), we allow a range of 2X to 4X instead of the exact 3X\n+        for (int i=0; i < numBookies-2; i++) {\n+            double ratio1 = (double)m.get(bs.get(numBookies-2).getLocalAddress())/(double)m.get(bs.get(i).getLocalAddress());\n+            assertTrue(\"Weigheted placement is not honored: \" + Math.abs(ratio1-multiple), Math.abs(ratio1-multiple) < 1);\n+            double ratio2 = (double)m.get(bs.get(numBookies-1).getLocalAddress())/(double)m.get(bs.get(i).getLocalAddress());\n+            assertTrue(\"Weigheted placement is not honored: \" + Math.abs(ratio2-multiple), Math.abs(ratio2-multiple) < 1);\n+        }\n+\n+        client.close();\n+    }\n+}"},{"sha":"ed41cb2ea1b61c2657cc7646b4c724e669483129","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestGetBookieInfoTimeout.java","status":"added","additions":141,"deletions":0,"changes":141,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/0583175de72446d00088611000310b000e8e61df/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FTestGetBookieInfoTimeout.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/0583175de72446d00088611000310b000e8e61df/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FTestGetBookieInfoTimeout.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FTestGetBookieInfoTimeout.java?ref=0583175de72446d00088611000310b000e8e61df","patch":"@@ -0,0 +1,141 @@\n+package org.apache.bookkeeper.client;\n+\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+\n+import static org.junit.Assert.assertTrue;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Executors;\n+\n+import org.apache.bookkeeper.client.BKException.Code;\n+import org.apache.bookkeeper.client.BookKeeper.DigestType;\n+import org.apache.bookkeeper.client.BookieInfoReader.BookieInfo;\n+import org.apache.bookkeeper.conf.ClientConfiguration;\n+import org.apache.bookkeeper.net.BookieSocketAddress;\n+import org.apache.bookkeeper.proto.BookieClient;\n+import org.apache.bookkeeper.proto.BookkeeperProtocol;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GetBookieInfoCallback;\n+import org.apache.bookkeeper.test.BookKeeperClusterTestCase;\n+import org.apache.bookkeeper.util.OrderedSafeExecutor;\n+import org.jboss.netty.channel.socket.ClientSocketChannelFactory;\n+import org.jboss.netty.channel.socket.nio.NioClientSocketChannelFactory;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This unit test tests timeout of GetBookieInfo request;\n+ *\n+ */\n+public class TestGetBookieInfoTimeout extends BookKeeperClusterTestCase {\n+    private final static Logger LOG = LoggerFactory.getLogger(TestGetBookieInfoTimeout.class);\n+    DigestType digestType;\n+    public ClientSocketChannelFactory channelFactory;\n+    public OrderedSafeExecutor executor;\n+\n+    public TestGetBookieInfoTimeout() {\n+        super(10);\n+        this.digestType = DigestType.CRC32;\n+    }\n+\n+    @Before\n+    public void setUp() throws Exception {\n+        super.setUp();\n+        channelFactory = new NioClientSocketChannelFactory(Executors.newCachedThreadPool(), Executors\n+                .newCachedThreadPool());\n+        executor = OrderedSafeExecutor.newBuilder()\n+                .name(\"BKClientOrderedSafeExecutor\")\n+                .numThreads(2)\n+                .build();\n+    }\n+\n+    @After\n+    public void tearDown() throws Exception {\n+        channelFactory.releaseExternalResources();\n+        executor.shutdown();\n+    }\n+\n+    @Test(timeout=60000)\n+    public void testGetBookieInfoTimeout() throws Exception {\n+\n+        // connect to the bookies and create a ledger\n+        LedgerHandle writelh = bkc.createLedger(3,3,digestType, \"testPasswd\".getBytes());\n+        String tmp = \"Foobar\";\n+        final int numEntries = 10;\n+        for (int i = 0; i < numEntries; i++) {\n+            writelh.addEntry(tmp.getBytes());\n+        }\n+\n+        // set timeout for getBookieInfo to be 2 secs and cause one of the bookies to go to sleep for 3X that time\n+        ClientConfiguration cConf = new ClientConfiguration();\n+        cConf.setGetBookieInfoTimeout(2);\n+\n+        final BookieSocketAddress bookieToSleep = writelh.getLedgerMetadata().getEnsemble(0).get(0);\n+        int sleeptime = cConf.getBookieInfoTimeout()*3;\n+        CountDownLatch latch = sleepBookie(bookieToSleep, sleeptime);\n+        latch.await();\n+\n+        // try to get bookie info from the sleeping bookie. It should fail with timeout error\n+        BookieSocketAddress addr = new BookieSocketAddress(bookieToSleep.getSocketAddress().getHostString(),\n+                bookieToSleep.getPort());\n+        BookieClient bc = new BookieClient(cConf, channelFactory, executor);\n+        long flags = BookkeeperProtocol.GetBookieInfoRequest.Flags.FREE_DISK_SPACE_VALUE |\n+                BookkeeperProtocol.GetBookieInfoRequest.Flags.TOTAL_DISK_CAPACITY_VALUE;\n+\n+        class CallbackObj {\n+            int rc;\n+            long requested;\n+            @SuppressWarnings(\"unused\")\n+            long freeDiskSpace, totalDiskCapacity;\n+            CountDownLatch latch = new CountDownLatch(1);\n+            CallbackObj(long requested) {\n+                this.requested = requested;\n+                this.rc = 0;\n+                this.freeDiskSpace = 0L;\n+                this.totalDiskCapacity = 0L;\n+            }\n+        };\n+        CallbackObj obj = new CallbackObj(flags);\n+        bc.getBookieInfo(addr, flags, new GetBookieInfoCallback() {\n+            @Override\n+            public void getBookieInfoComplete(int rc, BookieInfo bInfo, Object ctx) {\n+                CallbackObj obj = (CallbackObj)ctx;\n+                obj.rc=rc;\n+                if (rc == Code.OK) {\n+                    if ((obj.requested & BookkeeperProtocol.GetBookieInfoRequest.Flags.FREE_DISK_SPACE_VALUE) != 0) {\n+                        obj.freeDiskSpace = bInfo.getFreeDiskSpace();\n+                    }\n+                    if ((obj.requested & BookkeeperProtocol.GetBookieInfoRequest.Flags.TOTAL_DISK_CAPACITY_VALUE) != 0) {\n+                        obj.totalDiskCapacity = bInfo.getTotalDiskSpace();\n+                    }\n+                }\n+                obj.latch.countDown();\n+            }\n+\n+        }, obj);\n+        obj.latch.await();\n+        LOG.debug(\"Return code: \" + obj.rc);\n+        assertTrue(\"GetBookieInfo failed with unexpected error code: \" + obj.rc, obj.rc == Code.TimeoutException);\n+    }\n+}"},{"sha":"6739ea47a1e7caf2827f053c48ea31f0ba4cf446","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestRackawareEnsemblePlacementPolicy.java","status":"modified","additions":248,"deletions":0,"changes":248,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/0583175de72446d00088611000310b000e8e61df/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FTestRackawareEnsemblePlacementPolicy.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/0583175de72446d00088611000310b000e8e61df/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FTestRackawareEnsemblePlacementPolicy.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FTestRackawareEnsemblePlacementPolicy.java?ref=0583175de72446d00088611000310b000e8e61df","patch":"@@ -25,6 +25,7 @@\n import java.util.HashMap;\n import java.util.HashSet;\n import java.util.List;\n+import java.util.Map;\n import java.util.Set;\n import java.util.concurrent.TimeUnit;\n \n@@ -33,6 +34,7 @@\n \n import junit.framework.TestCase;\n import org.apache.bookkeeper.client.BKException.BKNotEnoughBookiesException;\n+import org.apache.bookkeeper.client.BookieInfoReader.BookieInfo;\n import org.apache.bookkeeper.conf.ClientConfiguration;\n import org.apache.bookkeeper.net.BookieSocketAddress;\n import org.apache.bookkeeper.net.DNSToSwitchMapping;\n@@ -420,6 +422,252 @@ public void testRemoveBookieFromCluster() {\n         repp.onClusterChanged(addrs, new HashSet<BookieSocketAddress>());\n     }\n \n+    @Test(timeout = 60000)\n+    public void testWeightedPlacementAndReplaceBookieWithEnoughBookiesInSameRack() throws Exception {\n+        BookieSocketAddress addr1 = new BookieSocketAddress(\"127.0.0.1\", 3181);\n+        BookieSocketAddress addr2 = new BookieSocketAddress(\"127.0.0.2\", 3181);\n+        BookieSocketAddress addr3 = new BookieSocketAddress(\"127.0.0.3\", 3181);\n+        BookieSocketAddress addr4 = new BookieSocketAddress(\"127.0.0.4\", 3181);\n+        // update dns mapping\n+        StaticDNSResolver.addNodeToRack(addr1.getSocketAddress().getAddress().getHostAddress(),\n+                NetworkTopology.DEFAULT_RACK);\n+        StaticDNSResolver.addNodeToRack(addr2.getSocketAddress().getAddress().getHostAddress(), NetworkTopology.DEFAULT_REGION + \"/r2\");\n+        StaticDNSResolver.addNodeToRack(addr3.getSocketAddress().getAddress().getHostAddress(), NetworkTopology.DEFAULT_REGION + \"/r2\");\n+        StaticDNSResolver.addNodeToRack(addr4.getSocketAddress().getAddress().getHostAddress(), NetworkTopology.DEFAULT_REGION + \"/r2\");\n+        // Update cluster\n+        Set<BookieSocketAddress> addrs = new HashSet<BookieSocketAddress>();\n+        addrs.add(addr1);\n+        addrs.add(addr2);\n+        addrs.add(addr3);\n+        addrs.add(addr4);\n+\n+        int multiple = 10;\n+        conf.setDiskWeightBasedPlacementEnabled(true);\n+        conf.setBookieMaxWeightMultipleForWeightBasedPlacement(-1); // no max cap on weight\n+        repp.initialize(conf, Optional.<DNSToSwitchMapping>absent(), timer, DISABLE_ALL, null);\n+\n+        repp.onClusterChanged(addrs, new HashSet<BookieSocketAddress>());\n+        Map<BookieSocketAddress, BookieInfo> bookieInfoMap = new HashMap<BookieSocketAddress, BookieInfo>();\n+        bookieInfoMap.put(addr1, new BookieInfo(100L, 100L));\n+        bookieInfoMap.put(addr2, new BookieInfo(100L, 100L));\n+        bookieInfoMap.put(addr3, new BookieInfo(100L, 100L));\n+        bookieInfoMap.put(addr4, new BookieInfo(multiple*100L, multiple*100L));\n+        repp.updateBookieInfo(bookieInfoMap);\n+\n+        Map<BookieSocketAddress, Long> selectionCounts = new HashMap<BookieSocketAddress, Long>();\n+        selectionCounts.put(addr3, 0L);\n+        selectionCounts.put(addr4, 0L);\n+        int numTries = 50000;\n+        BookieSocketAddress replacedBookie;\n+        for (int i = 0; i < numTries; i++) {\n+            // replace node under r2\n+            replacedBookie = repp.replaceBookie(1, 1, 1, null, new HashSet<BookieSocketAddress>(), addr2, new HashSet<BookieSocketAddress>());\n+            assertTrue(addr3.equals(replacedBookie) || addr4.equals(replacedBookie));\n+            selectionCounts.put(replacedBookie, selectionCounts.get(replacedBookie)+1);\n+        }\n+        double observedMultiple = ((double)selectionCounts.get(addr4)/(double)selectionCounts.get(addr3));\n+        assertTrue(\"Weights not being honored \" + observedMultiple, Math.abs(observedMultiple-multiple) < 1);\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testWeightedPlacementAndReplaceBookieWithoutEnoughBookiesInSameRack() throws Exception {\n+        BookieSocketAddress addr1 = new BookieSocketAddress(\"127.0.0.1\", 3181);\n+        BookieSocketAddress addr2 = new BookieSocketAddress(\"127.0.0.2\", 3181);\n+        BookieSocketAddress addr3 = new BookieSocketAddress(\"127.0.0.3\", 3181);\n+        BookieSocketAddress addr4 = new BookieSocketAddress(\"127.0.0.4\", 3181);\n+        // update dns mapping\n+        StaticDNSResolver.reset();\n+        StaticDNSResolver.addNodeToRack(addr1.getSocketAddress().getAddress().getHostAddress(), NetworkTopology.DEFAULT_RACK);\n+        StaticDNSResolver.addNodeToRack(addr2.getSocketAddress().getAddress().getHostAddress(), NetworkTopology.DEFAULT_REGION + \"/r2\");\n+        StaticDNSResolver.addNodeToRack(addr3.getSocketAddress().getAddress().getHostAddress(), NetworkTopology.DEFAULT_REGION + \"/r3\");\n+        StaticDNSResolver.addNodeToRack(addr4.getSocketAddress().getAddress().getHostAddress(), NetworkTopology.DEFAULT_REGION + \"/r4\");\n+        // Update cluster\n+        Set<BookieSocketAddress> addrs = new HashSet<BookieSocketAddress>();\n+        addrs.add(addr1);\n+        addrs.add(addr2);\n+        addrs.add(addr3);\n+        addrs.add(addr4);\n+\n+        int multiple = 10, maxMultiple = 4;\n+        conf.setDiskWeightBasedPlacementEnabled(true);\n+        conf.setBookieMaxWeightMultipleForWeightBasedPlacement(maxMultiple);\n+        repp.initialize(conf, Optional.<DNSToSwitchMapping>absent(), timer, DISABLE_ALL, null);\n+\n+        repp.onClusterChanged(addrs, new HashSet<BookieSocketAddress>());\n+        Map<BookieSocketAddress, BookieInfo> bookieInfoMap = new HashMap<BookieSocketAddress, BookieInfo>();\n+        bookieInfoMap.put(addr1, new BookieInfo(100L, 100L));\n+        bookieInfoMap.put(addr2, new BookieInfo(100L, 100L));\n+        bookieInfoMap.put(addr3, new BookieInfo(200L, 200L));\n+        bookieInfoMap.put(addr4, new BookieInfo(multiple*100L, multiple*100L));\n+        repp.updateBookieInfo(bookieInfoMap);\n+\n+        Map<BookieSocketAddress, Long> selectionCounts = new HashMap<BookieSocketAddress, Long>();\n+        selectionCounts.put(addr1, 0L);\n+        selectionCounts.put(addr2, 0L);\n+        selectionCounts.put(addr3, 0L);\n+        selectionCounts.put(addr4, 0L);\n+        int numTries = 50000;\n+        BookieSocketAddress replacedBookie;\n+        for (int i = 0; i < numTries; i++) {\n+            // addr2 is on /r2 and this is the only one on this rack. So the replacement\n+            // will come from other racks. However, the weight should be honored in such\n+            // selections as well\n+            replacedBookie = repp.replaceBookie(1, 1, 1, null, new HashSet<BookieSocketAddress>(), addr2, new HashSet<BookieSocketAddress>());\n+            assertTrue(addr1.equals(replacedBookie) || addr3.equals(replacedBookie) || addr4.equals(replacedBookie));\n+            selectionCounts.put(replacedBookie, selectionCounts.get(replacedBookie)+1);\n+        }\n+\n+        double medianWeight = 150;\n+        double medianSelectionCounts = (double)(medianWeight/bookieInfoMap.get(addr1).getWeight())*selectionCounts.get(addr1);\n+        double observedMultiple1 = ((double)selectionCounts.get(addr4)/(double)medianSelectionCounts);\n+        double observedMultiple2 = ((double)selectionCounts.get(addr4)/(double)selectionCounts.get(addr3));\n+        LOG.info(\"oM1 \" + observedMultiple1 + \" oM2 \" + observedMultiple2);\n+        assertTrue(\"Weights not being honored expected \" + maxMultiple + \" observed \" + observedMultiple1,\n+                Math.abs(observedMultiple1-maxMultiple) < 1);\n+        double expected = (medianWeight*maxMultiple)/bookieInfoMap.get(addr3).getWeight();// expected multiple for addr3\n+        assertTrue(\"Weights not being honored expected \" + expected + \" observed \" + observedMultiple2,\n+                Math.abs(observedMultiple2-expected) < 1);\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testWeightedPlacementAndNewEnsembleWithEnoughBookiesInSameRack() throws Exception {\n+        BookieSocketAddress addr1 = new BookieSocketAddress(\"127.0.0.1\", 3181);\n+        BookieSocketAddress addr2 = new BookieSocketAddress(\"127.0.0.2\", 3181);\n+        BookieSocketAddress addr3 = new BookieSocketAddress(\"127.0.0.3\", 3181);\n+        BookieSocketAddress addr4 = new BookieSocketAddress(\"127.0.0.4\", 3181);\n+        BookieSocketAddress addr5 = new BookieSocketAddress(\"127.0.0.5\", 3181);\n+        BookieSocketAddress addr6 = new BookieSocketAddress(\"127.0.0.6\", 3181);\n+        BookieSocketAddress addr7 = new BookieSocketAddress(\"127.0.0.7\", 3181);\n+        BookieSocketAddress addr8 = new BookieSocketAddress(\"127.0.0.8\", 3181);\n+        BookieSocketAddress addr9 = new BookieSocketAddress(\"127.0.0.9\", 3181);\n+\n+        // update dns mapping\n+        StaticDNSResolver.addNodeToRack(addr1.getSocketAddress().getAddress().getHostAddress(), NetworkTopology.DEFAULT_RACK);\n+        StaticDNSResolver.addNodeToRack(addr2.getSocketAddress().getAddress().getHostAddress(), NetworkTopology.DEFAULT_REGION + \"/r2\");\n+        StaticDNSResolver.addNodeToRack(addr3.getSocketAddress().getAddress().getHostAddress(), NetworkTopology.DEFAULT_REGION + \"/r2\");\n+        StaticDNSResolver.addNodeToRack(addr4.getSocketAddress().getAddress().getHostAddress(), NetworkTopology.DEFAULT_REGION + \"/r2\");\n+        StaticDNSResolver.addNodeToRack(addr5.getSocketAddress().getAddress().getHostAddress(), NetworkTopology.DEFAULT_REGION + \"/r2\");\n+        StaticDNSResolver.addNodeToRack(addr6.getSocketAddress().getAddress().getHostAddress(), NetworkTopology.DEFAULT_REGION + \"/r3\");\n+        StaticDNSResolver.addNodeToRack(addr7.getSocketAddress().getAddress().getHostAddress(), NetworkTopology.DEFAULT_REGION + \"/r3\");\n+        StaticDNSResolver.addNodeToRack(addr8.getSocketAddress().getAddress().getHostAddress(), NetworkTopology.DEFAULT_REGION + \"/r3\");\n+        StaticDNSResolver.addNodeToRack(addr9.getSocketAddress().getAddress().getHostAddress(), NetworkTopology.DEFAULT_REGION + \"/r3\");\n+\n+        // Update cluster\n+        Set<BookieSocketAddress> addrs = new HashSet<BookieSocketAddress>();\n+        addrs.add(addr1);\n+        addrs.add(addr2);\n+        addrs.add(addr3);\n+        addrs.add(addr4);\n+        addrs.add(addr5);\n+        addrs.add(addr6);\n+        addrs.add(addr7);\n+        addrs.add(addr8);\n+        addrs.add(addr9);\n+\n+        int maxMultiple = 4;\n+        conf.setDiskWeightBasedPlacementEnabled(true);\n+        conf.setBookieMaxWeightMultipleForWeightBasedPlacement(maxMultiple);\n+        repp.initialize(conf, Optional.<DNSToSwitchMapping>absent(), timer, DISABLE_ALL, null);\n+\n+        repp.onClusterChanged(addrs, new HashSet<BookieSocketAddress>());\n+        Map<BookieSocketAddress, BookieInfo> bookieInfoMap = new HashMap<BookieSocketAddress, BookieInfo>();\n+        bookieInfoMap.put(addr1, new BookieInfo(100L, 100L));\n+        bookieInfoMap.put(addr2, new BookieInfo(100L, 100L));\n+        bookieInfoMap.put(addr3, new BookieInfo(100L, 100L));\n+        bookieInfoMap.put(addr4, new BookieInfo(100L, 100L));\n+        bookieInfoMap.put(addr5, new BookieInfo(1000L, 1000L));\n+        bookieInfoMap.put(addr6, new BookieInfo(100L, 100L));\n+        bookieInfoMap.put(addr7, new BookieInfo(100L, 100L));\n+        bookieInfoMap.put(addr8, new BookieInfo(100L, 100L));\n+        bookieInfoMap.put(addr9, new BookieInfo(1000L, 1000L));\n+\n+        repp.updateBookieInfo(bookieInfoMap);\n+\n+        Map<BookieSocketAddress, Long> selectionCounts = new HashMap<BookieSocketAddress, Long>();\n+        for (BookieSocketAddress b : addrs) {\n+            selectionCounts.put(b, 0L);\n+        }\n+        int numTries = 10000;\n+\n+        Set<BookieSocketAddress> excludeList = new HashSet<BookieSocketAddress>();\n+        ArrayList<BookieSocketAddress> ensemble;\n+        for (int i = 0; i < numTries; i++) {\n+            // addr2 is on /r2 and this is the only one on this rack. So the replacement\n+            // will come from other racks. However, the weight should be honored in such\n+            // selections as well\n+            ensemble = repp.newEnsemble(3, 2, 2, null, excludeList);\n+            assertTrue(\"Rackaware selection not happening \" + getNumCoveredWriteQuorums(ensemble, 2), getNumCoveredWriteQuorums(ensemble, 2) >= 2);\n+            for (BookieSocketAddress b : ensemble) {\n+                selectionCounts.put(b, selectionCounts.get(b)+1);\n+            }\n+        }\n+\n+        // the median weight used is 100 since addr2 and addr6 have the same weight, we use their\n+        // selection counts as the same as median\n+        double observedMultiple1 = ((double)selectionCounts.get(addr5)/(double)selectionCounts.get(addr2));\n+        double observedMultiple2 = ((double)selectionCounts.get(addr9)/(double)selectionCounts.get(addr6));\n+        assertTrue(\"Weights not being honored expected 2 observed \" + observedMultiple1,\n+                Math.abs(observedMultiple1-maxMultiple) < 0.5);\n+        assertTrue(\"Weights not being honored expected 4 observed \" + observedMultiple2,\n+                Math.abs(observedMultiple2-maxMultiple) < 0.5);\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testWeightedPlacementAndNewEnsembleWithoutEnoughBookies() throws Exception {\n+        BookieSocketAddress addr1 = new BookieSocketAddress(\"127.0.0.1\", 3181);\n+        BookieSocketAddress addr2 = new BookieSocketAddress(\"127.0.0.2\", 3181);\n+        BookieSocketAddress addr3 = new BookieSocketAddress(\"127.0.0.3\", 3181);\n+        BookieSocketAddress addr4 = new BookieSocketAddress(\"127.0.0.4\", 3181);\n+        BookieSocketAddress addr5 = new BookieSocketAddress(\"127.0.0.5\", 3181);\n+\n+        // update dns mapping\n+        StaticDNSResolver.addNodeToRack(addr1.getSocketAddress().getAddress().getHostAddress(), NetworkTopology.DEFAULT_RACK);\n+        StaticDNSResolver.addNodeToRack(addr2.getSocketAddress().getAddress().getHostAddress(), NetworkTopology.DEFAULT_REGION + \"/r2\");\n+        StaticDNSResolver.addNodeToRack(addr3.getSocketAddress().getAddress().getHostAddress(), NetworkTopology.DEFAULT_REGION + \"/r2\");\n+        StaticDNSResolver.addNodeToRack(addr4.getSocketAddress().getAddress().getHostAddress(), NetworkTopology.DEFAULT_REGION + \"/r3\");\n+        StaticDNSResolver.addNodeToRack(addr5.getSocketAddress().getAddress().getHostAddress(), NetworkTopology.DEFAULT_REGION + \"/r3\");\n+        // Update cluster\n+        Set<BookieSocketAddress> addrs = new HashSet<BookieSocketAddress>();\n+        addrs.add(addr1);\n+        addrs.add(addr2);\n+        addrs.add(addr3);\n+        addrs.add(addr4);\n+        addrs.add(addr5);\n+\n+        int maxMultiple = 4;\n+        conf.setDiskWeightBasedPlacementEnabled(true);\n+        conf.setBookieMaxWeightMultipleForWeightBasedPlacement(maxMultiple);\n+        repp.initialize(conf, Optional.<DNSToSwitchMapping>absent(), timer, DISABLE_ALL, null);\n+\n+        repp.onClusterChanged(addrs, new HashSet<BookieSocketAddress>());\n+        Map<BookieSocketAddress, BookieInfo> bookieInfoMap = new HashMap<BookieSocketAddress, BookieInfo>();\n+        bookieInfoMap.put(addr1, new BookieInfo(100L, 100L));\n+        bookieInfoMap.put(addr2, new BookieInfo(100L, 100L));\n+        bookieInfoMap.put(addr3, new BookieInfo(1000L, 1000L));\n+        bookieInfoMap.put(addr4, new BookieInfo(100L, 100L));\n+        bookieInfoMap.put(addr5, new BookieInfo(1000L, 1000L));\n+\n+        repp.updateBookieInfo(bookieInfoMap);\n+\n+        ArrayList<BookieSocketAddress> ensemble = new ArrayList<BookieSocketAddress>();\n+        Set<BookieSocketAddress> excludeList = new HashSet<BookieSocketAddress>();\n+        try {\n+            excludeList.add(addr1);\n+            excludeList.add(addr2);\n+            excludeList.add(addr3);\n+            excludeList.add(addr4);\n+            ensemble = repp.newEnsemble(3, 2, 2, null, excludeList);\n+            fail(\"Should throw BKNotEnoughBookiesException when there is not enough bookies\" + ensemble);\n+        } catch (BKNotEnoughBookiesException e) {\n+            // this is expected\n+        }\n+        try {\n+            ensemble = repp.newEnsemble(1, 1, 1, null, excludeList);\n+        } catch (BKNotEnoughBookiesException e) {\n+            fail(\"Should not throw BKNotEnoughBookiesException when there are enough bookies for the ensemble\");\n+        }\n+    }\n+\n     private int getNumCoveredWriteQuorums(ArrayList<BookieSocketAddress> ensemble, int writeQuorumSize)\n             throws Exception {\n         int ensembleSize = ensemble.size();"},{"sha":"037ac80b7cc4b63e39e48ca51645e06a66274dbb","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestWeightedRandomSelection.java","status":"added","additions":280,"deletions":0,"changes":280,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/0583175de72446d00088611000310b000e8e61df/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FTestWeightedRandomSelection.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/0583175de72446d00088611000310b000e8e61df/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FTestWeightedRandomSelection.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FTestWeightedRandomSelection.java?ref=0583175de72446d00088611000310b000e8e61df","patch":"@@ -0,0 +1,280 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.bookkeeper.client;\n+\n+import static org.junit.Assert.*;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.bookkeeper.client.WeightedRandomSelection.WeightedObject;\n+import org.apache.commons.configuration.CompositeConfiguration;\n+import org.apache.commons.configuration.Configuration;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class TestWeightedRandomSelection {\n+\n+    static final Logger LOG = LoggerFactory.getLogger(TestWeightedRandomSelection.class);\n+\n+    static class TestObj implements WeightedObject {\n+        long val;\n+        TestObj(long value) {\n+            this.val = value;\n+        }\n+        @Override\n+        public long getWeight() {\n+            return val;\n+        }\n+    }\n+\n+    WeightedRandomSelection<String> wRS;\n+    Configuration conf = new CompositeConfiguration();\n+    int multiplier = 3;\n+\n+    @Before\n+    public void setUp() throws Exception {\n+        wRS = new WeightedRandomSelection<String>();\n+    }\n+\n+    @After\n+    public void tearDown() throws Exception {\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testSelectionWithEqualWeights() throws Exception {\n+        Map<String, WeightedObject> map = new HashMap<String, WeightedObject>();\n+\n+        Long val=100L;\n+        int numKeys = 50,  totalTries = 1000000;\n+        Map<String, Integer> randomSelection = new HashMap<String, Integer>();\n+        for (Integer i=0; i < numKeys; i++) {\n+            map.put(i.toString(), new TestObj(val));\n+            randomSelection.put(i.toString(), 0);\n+        }\n+\n+        wRS.updateMap(map);\n+        for (int i = 0; i < totalTries; i++) {\n+            String key = wRS.getNextRandom();\n+            randomSelection.put(key, randomSelection.get(key)+1);\n+        }\n+\n+        // there should be uniform distribution\n+        double expectedPct = ((double)1/(double)numKeys)*100;\n+        for (Map.Entry<String, Integer> e : randomSelection.entrySet()) {\n+            double actualPct = ((double)e.getValue()/(double)totalTries)*100;\n+            double delta = (Math.abs(expectedPct-actualPct)/expectedPct)*100;\n+            System.out.println(\"Key:\" + e.getKey() + \" Value:\" + e.getValue() + \" Expected: \" + expectedPct + \" Actual: \" + actualPct);\n+            // should be within 5% of expected\n+            assertTrue(\"Not doing uniform selection when weights are equal\", delta < 5);\n+        }\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testSelectionWithAllZeroWeights() throws Exception {\n+        Map<String, WeightedObject> map = new HashMap<String, WeightedObject>();\n+\n+        int numKeys = 50,  totalTries = 1000000;\n+        Map<String, Integer> randomSelection = new HashMap<String, Integer>();\n+        for (Integer i=0; i < numKeys; i++) {\n+            map.put(i.toString(), new TestObj(0L));\n+            randomSelection.put(i.toString(), 0);\n+        }\n+\n+        wRS.updateMap(map);\n+        for (int i = 0; i < totalTries; i++) {\n+            String key = wRS.getNextRandom();\n+            randomSelection.put(key, randomSelection.get(key)+1);\n+        }\n+\n+        // when all the values are zeros, there should be uniform distribution\n+        double expectedPct = ((double)1/(double)numKeys)*100;\n+        for (Map.Entry<String, Integer> e : randomSelection.entrySet()) {\n+            double actualPct = ((double)e.getValue()/(double)totalTries)*100;\n+            double delta = (Math.abs(expectedPct-actualPct)/expectedPct)*100;\n+            System.out.println(\"Key:\" + e.getKey() + \" Value:\" + e.getValue() + \" Expected: \" + expectedPct + \" Actual: \" + actualPct);\n+            // should be within 5% of expected\n+            assertTrue(\"Not doing uniform selection when weights are equal\", delta < 5);\n+        }\n+    }\n+\n+    void verifyResult(Map<String, WeightedObject> map, Map<String, Integer> randomSelection, int multiplier,\n+            long minWeight, long medianWeight, long totalWeight, int totalTries) {\n+        List<Integer> values = new ArrayList<Integer>(randomSelection.values());\n+        Collections.sort(values);\n+        double medianObserved, medianObservedWeight, medianExpectedWeight;\n+        int mid = values.size()/2;\n+        if ((values.size() % 2) == 1) {\n+            medianObserved = values.get(mid);\n+        } else {\n+            medianObserved = (double)(values.get(mid-1) + values.get(mid))/2;\n+        }\n+\n+        medianObservedWeight = (double)medianObserved/(double)totalTries;\n+        medianExpectedWeight = (double)medianWeight/totalWeight;\n+\n+        for (Map.Entry<String, Integer> e : randomSelection.entrySet()) {\n+            double observed = (((double)e.getValue()/(double)totalTries));\n+\n+            double expected;\n+            if (map.get(e.getKey()).getWeight() == 0) {\n+                // if the value is 0 for any key, we make it equal to the first non zero value\n+                expected = (double)minWeight/(double)totalWeight;\n+            } else {\n+                expected = (double)map.get(e.getKey()).getWeight()/(double)totalWeight;\n+            }\n+            if (multiplier > 0 && expected > multiplier*medianExpectedWeight) {\n+                expected = multiplier*medianExpectedWeight;\n+            }\n+            // We can't compare these weights because they are derived from different\n+            // values. But if we express them as a multiple of the min in each, then\n+            // they should be comparable\n+            double expectedMultiple = expected/medianExpectedWeight;\n+            double observedMultiple = observed/medianObservedWeight;\n+            double delta = (Math.abs(expectedMultiple-observedMultiple)/expectedMultiple)*100;\n+            System.out.println(\"Key:\" + e.getKey() + \" Value:\" + e.getValue() \n+                    + \" Expected \" + expectedMultiple + \" actual \" + observedMultiple + \" delta \" + delta + \"%\");\n+\n+            // the observed should be within 5% of expected\n+            assertTrue(\"Not doing uniform selection when weights are equal\", delta < 5);\n+        }\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testSelectionWithSomeZeroWeights() throws Exception {\n+        Map<String, WeightedObject> map = new HashMap<String, WeightedObject>();\n+        Map<String, Integer> randomSelection = new HashMap<String, Integer>();\n+        int numKeys = 50;\n+        multiplier=3;\n+        long val=0L, total=0L, minWeight = 100L, medianWeight=minWeight;\n+        wRS.setMaxProbabilityMultiplier(multiplier);\n+        for (Integer i=0; i < numKeys; i++) {\n+            if (i < numKeys/3) {\n+                val = 0L;\n+            } else if (i < 2*(numKeys/3)){\n+                val = minWeight;\n+            } else {\n+                val = 2*minWeight;\n+            }\n+            total += val;\n+            map.put(i.toString(), new TestObj(val));\n+            randomSelection.put(i.toString(), 0);\n+        }\n+\n+        wRS.updateMap(map);\n+        int totalTries = 10000000;\n+        for (int i = 0; i < totalTries; i++) {\n+            String key = wRS.getNextRandom();\n+            randomSelection.put(key, randomSelection.get(key)+1);\n+        }\n+        verifyResult(map, randomSelection, multiplier, minWeight, medianWeight, total, totalTries);\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testSelectionWithUnequalWeights() throws Exception {\n+        Map<String, WeightedObject> map = new HashMap<String, WeightedObject>();\n+        Map<String, Integer> randomSelection = new HashMap<String, Integer>();\n+        int numKeys = 50;\n+        multiplier=4;\n+        long val=0L, total=0L, minWeight=100L, medianWeight=2*minWeight;\n+        wRS.setMaxProbabilityMultiplier(multiplier);\n+        for (Integer i=0; i < numKeys; i++) {\n+            if (i < numKeys/3) {\n+                val = minWeight;\n+            } else if (i < 2*(numKeys/3)){\n+                val = 2*minWeight;\n+            } else {\n+                val = 10*minWeight;\n+            }\n+            total += val;\n+            map.put(i.toString(), new TestObj(val));\n+            randomSelection.put(i.toString(), 0);\n+        }\n+\n+        wRS.updateMap(map);\n+        int totalTries = 10000000;\n+        for (int i = 0; i < totalTries; i++) {\n+            String key = wRS.getNextRandom();\n+            randomSelection.put(key, randomSelection.get(key)+1);\n+        }\n+        verifyResult(map, randomSelection, multiplier, minWeight, medianWeight, total, totalTries);\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testSelectionWithHotNode() throws Exception {\n+        Map<String, WeightedObject> map = new HashMap<String, WeightedObject>();\n+        Map<String, Integer> randomSelection = new HashMap<String, Integer>();\n+\n+        multiplier=3; // no max\n+        int numKeys = 50;\n+        long total=0L, minWeight = 100L, val = minWeight, medianWeight=minWeight;\n+        wRS.setMaxProbabilityMultiplier(multiplier);\n+        for (Integer i=0; i < numKeys; i++) {\n+            if (i == numKeys-1) {\n+                // last one has 10X more weight than the rest put together\n+                val=10*(numKeys-1)*100L;\n+            }\n+            total += val;\n+            map.put(i.toString(), new TestObj(val));\n+            randomSelection.put(i.toString(), 0);\n+        }\n+\n+        wRS.updateMap(map);\n+        int totalTries = 10000000;\n+        for (int i = 0; i < totalTries; i++) {\n+            String key = wRS.getNextRandom();\n+            randomSelection.put(key, randomSelection.get(key)+1);\n+        }\n+        verifyResult(map, randomSelection, multiplier, minWeight, medianWeight, total, totalTries);\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testSelectionWithHotNodeWithLimit() throws Exception {\n+        Map<String, WeightedObject> map = new HashMap<String, WeightedObject>();\n+        Map<String, Integer> randomSelection = new HashMap<String, Integer>();\n+\n+        multiplier=3; // limit the max load on hot node to be 3X\n+        int numKeys = 50;\n+        long total=0L, minWeight = 100L, val = minWeight, medianWeight=minWeight;\n+        wRS.setMaxProbabilityMultiplier(multiplier);\n+        for (Integer i=0; i < numKeys; i++) {\n+            if (i == numKeys-1) {\n+                // last one has 10X more weight than the rest put together\n+                val=10*(numKeys-1)*100L;\n+            }\n+            total += val;\n+            map.put(i.toString(), new TestObj(val));\n+            randomSelection.put(i.toString(), 0);\n+        }\n+\n+        wRS.updateMap(map);\n+        int totalTries = 10000000;\n+        for (int i = 0; i < totalTries; i++) {\n+            String key = wRS.getNextRandom();\n+            randomSelection.put(key, randomSelection.get(key)+1);\n+        }\n+        verifyResult(map, randomSelection, multiplier, minWeight, medianWeight, total, totalTries);\n+    }\n+}"},{"sha":"069878080bafae3a0a8637bb27df16f4a42a526b","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookieClientTest.java","status":"modified","additions":50,"deletions":0,"changes":50,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/0583175de72446d00088611000310b000e8e61df/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Ftest%2FBookieClientTest.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/0583175de72446d00088611000310b000e8e61df/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Ftest%2FBookieClientTest.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Ftest%2FBookieClientTest.java?ref=0583175de72446d00088611000310b000e8e61df","patch":"@@ -22,18 +22,24 @@\n  */\n \n import java.io.File;\n+import java.io.IOException;\n import java.nio.ByteBuffer;\n import java.util.Arrays;\n+import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.Executors;\n \n import org.apache.bookkeeper.client.BKException;\n+import org.apache.bookkeeper.client.BKException.Code;\n+import org.apache.bookkeeper.client.BookieInfoReader.BookieInfo;\n import org.apache.bookkeeper.conf.ClientConfiguration;\n import org.apache.bookkeeper.conf.ServerConfiguration;\n import org.apache.bookkeeper.net.BookieSocketAddress;\n import org.apache.bookkeeper.conf.TestBKConfiguration;\n import org.apache.bookkeeper.proto.BookieClient;\n import org.apache.bookkeeper.proto.BookieProtocol;\n import org.apache.bookkeeper.proto.BookieServer;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GetBookieInfoCallback;\n+import org.apache.bookkeeper.proto.BookkeeperProtocol;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ReadEntryCallback;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteCallback;\n import org.apache.bookkeeper.util.OrderedSafeExecutor;\n@@ -250,4 +256,48 @@ public void testNoLedger() throws Exception {\n             assertEquals(BKException.Code.NoSuchLedgerExistsException, arc.rc);\n         }\n     }\n+\n+    @Test(timeout=60000)\n+    public void testGetBookieInfo() throws IOException, InterruptedException {\n+        BookieSocketAddress addr = new BookieSocketAddress(\"127.0.0.1\", port);\n+        BookieClient bc = new BookieClient(new ClientConfiguration(), channelFactory, executor);\n+        long flags = BookkeeperProtocol.GetBookieInfoRequest.Flags.FREE_DISK_SPACE_VALUE |\n+                BookkeeperProtocol.GetBookieInfoRequest.Flags.TOTAL_DISK_CAPACITY_VALUE;\n+\n+        class CallbackObj {\n+            int rc;\n+            long requested;\n+            long freeDiskSpace, totalDiskCapacity;\n+            CountDownLatch latch = new CountDownLatch(1);\n+            CallbackObj(long requested) {\n+                this.requested = requested;\n+                this.rc = 0;\n+                this.freeDiskSpace = 0L;\n+                this.totalDiskCapacity = 0L;\n+            }\n+        };\n+        CallbackObj obj = new CallbackObj(flags);\n+        bc.getBookieInfo(addr, flags, new GetBookieInfoCallback() {\n+            @Override\n+            public void getBookieInfoComplete(int rc, BookieInfo bInfo, Object ctx) {\n+                CallbackObj obj = (CallbackObj)ctx;\n+                obj.rc=rc;\n+                if (rc == Code.OK) {\n+                    if ((obj.requested & BookkeeperProtocol.GetBookieInfoRequest.Flags.FREE_DISK_SPACE_VALUE) != 0) {\n+                        obj.freeDiskSpace = bInfo.getFreeDiskSpace();\n+                    }\n+                    if ((obj.requested & BookkeeperProtocol.GetBookieInfoRequest.Flags.TOTAL_DISK_CAPACITY_VALUE) != 0) {\n+                        obj.totalDiskCapacity = bInfo.getTotalDiskSpace();\n+                    }\n+                }\n+                obj.latch.countDown();\n+            }\n+\n+        }, obj);\n+        obj.latch.await();\n+        System.out.println(\"Return code: \" + obj.rc + \"FreeDiskSpace: \" + obj.freeDiskSpace + \" TotalCapacity: \" + obj.totalDiskCapacity);\n+        assertTrue(\"GetBookieInfo failed with error \" + obj.rc, obj.rc == Code.OK);\n+        assertTrue(\"GetBookieInfo failed with error \" + obj.rc, obj.freeDiskSpace <= obj.totalDiskCapacity);\n+        assertTrue(\"GetBookieInfo failed with error \" + obj.rc, obj.totalDiskCapacity > 0);\n+    }\n }"}]}