{"sha":"d606ee4ba0080431c5ec67b8805ff3bb269005d6","node_id":"MDY6Q29tbWl0NDc4NTkyNTI2OmQ2MDZlZTRiYTAwODA0MzFjNWVjNjdiODgwNWZmM2JiMjY5MDA1ZDY=","commit":{"author":{"name":"Yiming Zang","email":"yzang@twitter.com","date":"2016-11-16T22:14:52Z"},"committer":{"name":"Sijie Guo","email":"sijieg@twitter.com","date":"2016-12-29T10:06:55Z"},"message":"DL-115: fix force get log segment logic\n\nSummary:\n\nWe should remove the ledger closed check:\n\n- force to get log segments if the reader has been idle for a while after open the ledger\n- idleReaderWarnThreshold should be 2x larger than readLACLongPollTimeout","tree":{"sha":"431547f3be655371c782a7cde16ff20a5e64c82d","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/trees/431547f3be655371c782a7cde16ff20a5e64c82d"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/commits/d606ee4ba0080431c5ec67b8805ff3bb269005d6","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/d606ee4ba0080431c5ec67b8805ff3bb269005d6","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/d606ee4ba0080431c5ec67b8805ff3bb269005d6","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/d606ee4ba0080431c5ec67b8805ff3bb269005d6/comments","author":null,"committer":null,"parents":[{"sha":"aa60a4e830183f6d9a61ab9100cf845712e281b7","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/aa60a4e830183f6d9a61ab9100cf845712e281b7","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/aa60a4e830183f6d9a61ab9100cf845712e281b7"}],"stats":{"total":50,"additions":23,"deletions":27},"files":[{"sha":"46a056b2e8d29913746447243d7f076497dbf8d9","filename":"src/main/java/com/twitter/distributedlog/DistributedLogConfiguration.java","status":"modified","additions":3,"deletions":1,"changes":4,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d606ee4ba0080431c5ec67b8805ff3bb269005d6/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FDistributedLogConfiguration.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d606ee4ba0080431c5ec67b8805ff3bb269005d6/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FDistributedLogConfiguration.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FDistributedLogConfiguration.java?ref=d606ee4ba0080431c5ec67b8805ff3bb269005d6","patch":"@@ -3467,8 +3467,10 @@ public DistributedLogConfiguration setEIInjectReadAheadDelayPercent(int percent)\n      */\n     public void validate() {\n         Preconditions.checkArgument(getBKClientReadTimeout() * 1000 >= getReadLACLongPollTimeout(),\n-            \"Invalid timeout configuration : bkcReadTimeoutSeconds (\"+getBKClientReadTimeout()+\n+            \"Invalid timeout configuration: bkcReadTimeoutSeconds (\"+getBKClientReadTimeout()+\n                 \") should be longer than readLACLongPollTimeout (\"+getReadLACLongPollTimeout()+\")\");\n+        Preconditions.checkArgument(getReaderIdleWarnThresholdMillis() > 2 * getReadLACLongPollTimeout(),\n+            \"Invalid configuration: ReaderIdleWarnThreshold should be 2x larget than readLACLongPollTimeout\");\n     }\n \n "},{"sha":"021756003f0cab3694902ab4152f7336947b3ed0","filename":"src/main/java/com/twitter/distributedlog/readahead/ReadAheadWorker.java","status":"modified","additions":20,"deletions":26,"changes":46,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d606ee4ba0080431c5ec67b8805ff3bb269005d6/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Freadahead%2FReadAheadWorker.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d606ee4ba0080431c5ec67b8805ff3bb269005d6/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Freadahead%2FReadAheadWorker.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Freadahead%2FReadAheadWorker.java?ref=d606ee4ba0080431c5ec67b8805ff3bb269005d6","patch":"@@ -180,7 +180,7 @@ public class ReadAheadWorker implements ReadAheadCallback, Runnable, AsyncClosea\n     protected final long metadataLatencyWarnThresholdMillis;\n     final ReadAheadTracker tracker;\n     final Stopwatch resumeStopWatch;\n-    final Stopwatch lastLedgerCloseDetected = Stopwatch.createUnstarted();\n+    final Stopwatch LACNotAdvancedStopWatch = Stopwatch.createUnstarted();\n     // Misc\n     private final boolean readAheadSkipBrokenEntries;\n     // Stats\n@@ -901,9 +901,7 @@ public void onFailure(Throwable cause) {\n                             });\n                 } else {\n                     final long lastAddConfirmed;\n-                    boolean isClosed;\n                     try {\n-                        isClosed = handleCache.isLedgerHandleClosed(currentLH);\n                         lastAddConfirmed = handleCache.getLastAddConfirmed(currentLH);\n                     } catch (BKException ie) {\n                         // Exception is thrown due to no ledger handle\n@@ -912,30 +910,26 @@ public void onFailure(Throwable cause) {\n                     }\n \n                     if (lastAddConfirmed < nextReadAheadPosition.getEntryId()) {\n-                        if (isClosed) {\n-                            // This indicates that the currentMetadata is still marked in\n-                            // progress while the ledger has been closed. This specific ledger\n-                            // is not going to produce any more entries - so we should\n-                            // be reading metadata entries to mark the current metadata\n-                            // as complete\n-                            if (lastLedgerCloseDetected.isRunning()) {\n-                                if (lastLedgerCloseDetected.elapsed(TimeUnit.MILLISECONDS)\n-                                    > conf.getReaderIdleWarnThresholdMillis()) {\n-                                    idleReaderWarn.inc();\n-                                    LOG.info(\"{} Ledger {} for inprogress segment {} closed for idle reader warn threshold\",\n-                                        new Object[] { fullyQualifiedName, currentMetadata, currentLH });\n-                                    reInitializeMetadata = true;\n-                                    forceReadLogSegments = true;\n-                                }\n-                            } else {\n-                                lastLedgerCloseDetected.reset().start();\n-                                if (conf.getTraceReadAheadMetadataChanges()) {\n-                                    LOG.info(\"{} Ledger {} for inprogress segment {} closed\",\n-                                        new Object[] { fullyQualifiedName, currentMetadata, currentLH });\n-                                }\n+                        // This indicates that the currentMetadata is still marked in\n+                        // progress while we have already read all the entries. It might\n+                        // indicate a failure to detect metadata change. So we\n+                        // should probably try force read log segments if the reader has\n+                        // been idle for after a while.\n+                        if (LACNotAdvancedStopWatch.isRunning()) {\n+                            if (LACNotAdvancedStopWatch.elapsed(TimeUnit.MILLISECONDS)\n+                                > conf.getReaderIdleWarnThresholdMillis()) {\n+                                idleReaderWarn.inc();\n+                                LOG.info(\"{} Ledger {} for inprogress segment {}, reader has been idle for warn threshold {}\",\n+                                    new Object[] { fullyQualifiedName, currentMetadata, currentLH, conf.getReaderIdleWarnThresholdMillis() });\n+                                reInitializeMetadata = true;\n+                                forceReadLogSegments = true;\n                             }\n                         } else {\n-                            lastLedgerCloseDetected.reset();\n+                            LACNotAdvancedStopWatch.reset().start();\n+                            if (conf.getTraceReadAheadMetadataChanges()) {\n+                                LOG.info(\"{} Ledger {} for inprogress segment {} closed\",\n+                                    new Object[] { fullyQualifiedName, currentMetadata, currentLH });\n+                            }\n                         }\n \n                         tracker.enterPhase(ReadAheadPhase.READ_LAST_CONFIRMED);\n@@ -966,7 +960,7 @@ public void onFailure(Throwable cause) {\n                     }\n                 }\n             } else {\n-                lastLedgerCloseDetected.reset();\n+                LACNotAdvancedStopWatch.reset();\n                 if (null != currentLH) {\n                     try {\n                         if (inProgressChanged) {"}]}