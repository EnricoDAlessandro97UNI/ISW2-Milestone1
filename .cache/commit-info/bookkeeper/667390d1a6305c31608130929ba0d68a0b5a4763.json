{"sha":"667390d1a6305c31608130929ba0d68a0b5a4763","node_id":"MDY6Q29tbWl0NDc4NTkyNTI2OjY2NzM5MGQxYTYzMDVjMzE2MDgxMzA5MjliYTBkNjhhMGI1YTQ3NjM=","commit":{"author":{"name":"Enrico Olivelli","email":"eolivelli@apache.org","date":"2017-05-25T11:31:04Z"},"committer":{"name":"eolivelli","email":"eolivelli@apache.org","date":"2017-05-25T11:31:04Z"},"message":"BOOKKEEPER-391: Support Kerberos authentication of bookkeeper\n\nThis patch contains a very basic AuthProvider which uses JAAS and so enables the usage or GSSAPI/Kerberos for BookKeeper authentication\n\nAuthor: eolivelli <eolivelli@apache.org>\nAuthor: eolivelli <eolivelli@gmail.com>\n\nReviewers: Robert (Bobby) Evans <None>, Sijie Guo <None>\n\nCloses #110 from eolivelli/BOOKKEEPER-391-kerberos","tree":{"sha":"e72b262526a46f59e83339aaabc785c4de9c6456","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/trees/e72b262526a46f59e83339aaabc785c4de9c6456"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/commits/667390d1a6305c31608130929ba0d68a0b5a4763","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/667390d1a6305c31608130929ba0d68a0b5a4763","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/667390d1a6305c31608130929ba0d68a0b5a4763","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/667390d1a6305c31608130929ba0d68a0b5a4763/comments","author":{"login":"eolivelli","id":9469110,"node_id":"MDQ6VXNlcjk0NjkxMTA=","avatar_url":"https://avatars.githubusercontent.com/u/9469110?v=4","gravatar_id":"","url":"https://api.github.com/users/eolivelli","html_url":"https://github.com/eolivelli","followers_url":"https://api.github.com/users/eolivelli/followers","following_url":"https://api.github.com/users/eolivelli/following{/other_user}","gists_url":"https://api.github.com/users/eolivelli/gists{/gist_id}","starred_url":"https://api.github.com/users/eolivelli/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/eolivelli/subscriptions","organizations_url":"https://api.github.com/users/eolivelli/orgs","repos_url":"https://api.github.com/users/eolivelli/repos","events_url":"https://api.github.com/users/eolivelli/events{/privacy}","received_events_url":"https://api.github.com/users/eolivelli/received_events","type":"User","site_admin":false},"committer":{"login":"eolivelli","id":9469110,"node_id":"MDQ6VXNlcjk0NjkxMTA=","avatar_url":"https://avatars.githubusercontent.com/u/9469110?v=4","gravatar_id":"","url":"https://api.github.com/users/eolivelli","html_url":"https://github.com/eolivelli","followers_url":"https://api.github.com/users/eolivelli/followers","following_url":"https://api.github.com/users/eolivelli/following{/other_user}","gists_url":"https://api.github.com/users/eolivelli/gists{/gist_id}","starred_url":"https://api.github.com/users/eolivelli/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/eolivelli/subscriptions","organizations_url":"https://api.github.com/users/eolivelli/orgs","repos_url":"https://api.github.com/users/eolivelli/repos","events_url":"https://api.github.com/users/eolivelli/events{/privacy}","received_events_url":"https://api.github.com/users/eolivelli/received_events","type":"User","site_admin":false},"parents":[{"sha":"7da9ed293db87103efcc28b7e706c0b386131ec1","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/7da9ed293db87103efcc28b7e706c0b386131ec1","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/7da9ed293db87103efcc28b7e706c0b386131ec1"}],"stats":{"total":1811,"additions":1810,"deletions":1},"files":[{"sha":"36a9b570ec9645b50eb7d2a1ea8820c6771b1887","filename":"bookkeeper-server/pom.xml","status":"modified","additions":15,"deletions":1,"changes":16,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/667390d1a6305c31608130929ba0d68a0b5a4763/bookkeeper-server%2Fpom.xml","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/667390d1a6305c31608130929ba0d68a0b5a4763/bookkeeper-server%2Fpom.xml","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fpom.xml?ref=667390d1a6305c31608130929ba0d68a0b5a4763","patch":"@@ -139,7 +139,7 @@\n     <dependency>\n       <groupId>commons-io</groupId>\n       <artifactId>commons-io</artifactId>\n-      <version>2.1</version>\n+      <version>2.4</version>\n     </dependency>\n     <dependency>\n       <groupId>net.java.dev.jna</groupId>\n@@ -216,9 +216,23 @@\n       <artifactId>netty-all</artifactId>\n       <version>${netty.version}</version>\n     </dependency>\n+    <dependency>\n+        <groupId>org.apache.hadoop</groupId>\n+        <artifactId>hadoop-minikdc</artifactId>\n+        <version>2.7.3</version>\n+        <scope>test</scope>\n+    </dependency>          \n   </dependencies>\n   <build>\n     <plugins>\n+      <plugin>\n+            <!-- for mini-kdc -->\n+            <groupId>org.apache.felix</groupId>\n+            <artifactId>maven-bundle-plugin</artifactId>\n+            <version>3.2.0</version>\n+            <inherited>true</inherited>\n+            <extensions>true</extensions>\n+      </plugin>\n       <plugin>\n         <groupId>org.apache.maven.plugins</groupId>\n         <artifactId>maven-shade-plugin</artifactId>"},{"sha":"791f10694dda0ca2fd1433484648329d5e1a975d","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/sasl/JAASCredentialsContainer.java","status":"added","additions":42,"deletions":0,"changes":42,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/667390d1a6305c31608130929ba0d68a0b5a4763/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fsasl%2FJAASCredentialsContainer.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/667390d1a6305c31608130929ba0d68a0b5a4763/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fsasl%2FJAASCredentialsContainer.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fsasl%2FJAASCredentialsContainer.java?ref=667390d1a6305c31608130929ba0d68a0b5a4763","patch":"@@ -0,0 +1,42 @@\n+/**\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.sasl;\n+\n+import javax.security.auth.Subject;\n+import javax.security.auth.login.LoginContext;\n+import org.apache.bookkeeper.conf.AbstractConfiguration;\n+\n+public interface JAASCredentialsContainer {\n+\n+    Subject getSubject();\n+\n+    LoginContext getLogin();\n+\n+    void setLogin(LoginContext login);\n+\n+    boolean isUsingTicketCache();\n+\n+    String getPrincipal();\n+\n+    AbstractConfiguration getConfiguration();\n+\n+    String getLoginContextName();\n+}"},{"sha":"488e1f665d8c95f4616bbf3adcf16fbc436f0b13","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/sasl/SASLBookieAuthProvider.java","status":"added","additions":73,"deletions":0,"changes":73,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/667390d1a6305c31608130929ba0d68a0b5a4763/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fsasl%2FSASLBookieAuthProvider.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/667390d1a6305c31608130929ba0d68a0b5a4763/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fsasl%2FSASLBookieAuthProvider.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fsasl%2FSASLBookieAuthProvider.java?ref=667390d1a6305c31608130929ba0d68a0b5a4763","patch":"@@ -0,0 +1,73 @@\n+/**\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.sasl;\n+\n+import java.io.IOException;\n+import java.util.regex.Pattern;\n+import javax.security.auth.Subject;\n+import javax.security.auth.login.LoginException;\n+import javax.security.sasl.SaslException;\n+import org.apache.bookkeeper.auth.AuthCallbacks;\n+import org.apache.bookkeeper.auth.AuthToken;\n+import org.apache.bookkeeper.auth.BookieAuthProvider;\n+import org.apache.bookkeeper.bookie.BookieConnectionPeer;\n+import org.apache.bookkeeper.client.BKException;\n+import org.apache.bookkeeper.conf.ServerConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class SASLBookieAuthProvider implements BookieAuthProvider {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(SASLBookieAuthProvider.class);\n+\n+    private SaslServerState server;\n+    private final AuthCallbacks.GenericCallback<Void> completeCb;\n+    \n+    SASLBookieAuthProvider(BookieConnectionPeer addr, AuthCallbacks.GenericCallback<Void> completeCb,\n+        ServerConfiguration serverConfiguration, Subject subject, Pattern allowedIdsPattern) {\n+        this.completeCb = completeCb;\n+        try {\n+            server = new SaslServerState(serverConfiguration, subject, allowedIdsPattern);\n+        } catch (IOException | LoginException error) {\n+            LOG.error(\"Error while booting SASL server\", error);\n+            completeCb.operationComplete(BKException.Code.UnauthorizedAccessException, null);\n+        }\n+    }\n+\n+    @Override\n+    public void process(AuthToken m, AuthCallbacks.GenericCallback<AuthToken> cb) {\n+        try {\n+            byte[] clientSideToken = m.getData();\n+            byte[] response = server.response(clientSideToken);\n+            if (response != null) {\n+                cb.operationComplete(BKException.Code.OK, AuthToken.wrap(response));\n+            }\n+            if (server.isComplete()) {\n+                completeCb.operationComplete(BKException.Code.OK, null);\n+            }\n+        } catch (SaslException err) {\n+            LOG.debug(\"SASL error\", err);\n+            completeCb.operationComplete(BKException.Code.UnauthorizedAccessException, null);\n+        }\n+\n+    }\n+\n+}"},{"sha":"23a29a245be4954aaf467533cc24789c4a5b15ea","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/sasl/SASLBookieAuthProviderFactory.java","status":"added","additions":217,"deletions":0,"changes":217,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/667390d1a6305c31608130929ba0d68a0b5a4763/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fsasl%2FSASLBookieAuthProviderFactory.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/667390d1a6305c31608130929ba0d68a0b5a4763/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fsasl%2FSASLBookieAuthProviderFactory.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fsasl%2FSASLBookieAuthProviderFactory.java?ref=667390d1a6305c31608130929ba0d68a0b5a4763","patch":"@@ -0,0 +1,217 @@\n+/**\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.sasl;\n+\n+import java.io.IOException;\n+import java.util.regex.Pattern;\n+import java.util.regex.PatternSyntaxException;\n+import javax.security.auth.Subject;\n+import javax.security.auth.callback.Callback;\n+import javax.security.auth.callback.CallbackHandler;\n+import javax.security.auth.callback.NameCallback;\n+import javax.security.auth.callback.PasswordCallback;\n+import javax.security.auth.callback.UnsupportedCallbackException;\n+import javax.security.auth.kerberos.KerberosTicket;\n+import javax.security.auth.login.AppConfigurationEntry;\n+import javax.security.auth.login.Configuration;\n+import javax.security.auth.login.LoginContext;\n+import javax.security.auth.login.LoginException;\n+import javax.security.sasl.AuthorizeCallback;\n+import javax.security.sasl.RealmCallback;\n+import javax.security.sasl.SaslException;\n+import org.apache.bookkeeper.auth.AuthCallbacks;\n+import org.apache.bookkeeper.bookie.BookieConnectionPeer;\n+import org.apache.bookkeeper.conf.AbstractConfiguration;\n+import org.apache.bookkeeper.conf.ServerConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * BookieAuthProvider which uses JDK-bundled SASL\n+ */\n+public class SASLBookieAuthProviderFactory implements org.apache.bookkeeper.auth.BookieAuthProvider.Factory,\n+    JAASCredentialsContainer {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(SASLBookieAuthProviderFactory.class);\n+\n+    private Pattern allowedIdsPattern;\n+    private ServerConfiguration serverConfiguration;\n+    private Subject subject;\n+    private boolean isKrbTicket;\n+    private boolean isUsingTicketCache;\n+    private String principal;\n+    private String loginContextName;\n+    private LoginContext login;\n+    private TGTRefreshThread ticketRefreshThread;\n+\n+    @Override\n+    public void init(ServerConfiguration conf) throws IOException {\n+        this.serverConfiguration = conf;\n+\n+        final String allowedIdsPatternRegExp = conf.getString(SaslConstants.JAAS_CLIENT_ALLOWED_IDS,\n+            SaslConstants.JAAS_CLIENT_ALLOWED_IDS_DEFAULT);\n+        try {\n+            this.allowedIdsPattern = Pattern.compile(allowedIdsPatternRegExp);\n+        } catch (PatternSyntaxException error) {\n+            LOG.error(\"Invalid regular expression \" + allowedIdsPatternRegExp, error);\n+            throw new IOException(error);\n+        }\n+\n+        try {\n+            loginContextName = serverConfiguration.getString(SaslConstants.JAAS_BOOKIE_SECTION_NAME,\n+                SaslConstants.JAAS_DEFAULT_BOOKIE_SECTION_NAME);\n+\n+            this.login = loginServer();\n+            this.subject = login.getSubject();\n+            this.isKrbTicket = !subject.getPrivateCredentials(KerberosTicket.class).isEmpty();\n+            if (isKrbTicket) {\n+                this.isUsingTicketCache = SaslConstants.isUsingTicketCache(loginContextName);\n+                this.principal = SaslConstants.getPrincipal(loginContextName);\n+                this.ticketRefreshThread = new TGTRefreshThread(this);\n+                ticketRefreshThread.start();\n+            }\n+        } catch (SaslException | LoginException error) {\n+            throw new IOException(error);\n+        }\n+    }\n+\n+    @Override\n+    public org.apache.bookkeeper.auth.BookieAuthProvider newProvider(BookieConnectionPeer addr,\n+        AuthCallbacks.GenericCallback<Void> completeCb) {\n+        return new SASLBookieAuthProvider(addr, completeCb, serverConfiguration,\n+            subject, allowedIdsPattern);\n+    }\n+\n+    @Override\n+    public String getPluginName() {\n+        return SaslConstants.PLUGIN_NAME;\n+    }\n+\n+    @Override\n+    public void close() {\n+        if (ticketRefreshThread != null) {\n+            ticketRefreshThread.interrupt();\n+            try {\n+                ticketRefreshThread.join(10000);\n+            } catch (InterruptedException exit) {\n+                LOG.debug(\"interrupted while waiting for TGT reresh thread to stop\", exit);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public Subject getSubject() {\n+        return subject;\n+    }\n+\n+    @Override\n+    public LoginContext getLogin() {\n+        return login;\n+    }\n+\n+    @Override\n+    public void setLogin(LoginContext login) {\n+        this.login = login;\n+    }\n+\n+    @Override\n+    public boolean isUsingTicketCache() {\n+        return isUsingTicketCache;\n+    }\n+\n+    @Override\n+    public String getPrincipal() {\n+        return principal;\n+    }\n+\n+    @Override\n+    public AbstractConfiguration getConfiguration() {\n+        return serverConfiguration;\n+    }\n+\n+    @Override\n+    public String getLoginContextName() {\n+        return loginContextName;\n+    }\n+\n+    private LoginContext loginServer() throws SaslException, LoginException {\n+\n+        AppConfigurationEntry[] entries = Configuration.getConfiguration()\n+            .getAppConfigurationEntry(loginContextName);\n+        if (entries == null) {\n+            LOG.info(\"JAAS not configured or no \"\n+                + loginContextName + \" present in JAAS Configuration file\");\n+            return null;\n+        }\n+        LoginContext loginContext = new LoginContext(loginContextName, new ClientCallbackHandler(null));\n+        loginContext.login();\n+        return loginContext;\n+\n+    }\n+\n+    private static class ClientCallbackHandler implements CallbackHandler {\n+\n+        private String password = null;\n+\n+        public ClientCallbackHandler(String password) {\n+            this.password = password;\n+        }\n+\n+        @Override\n+        public void handle(Callback[] callbacks) throws\n+            UnsupportedCallbackException {\n+            for (Callback callback : callbacks) {\n+                if (callback instanceof NameCallback) {\n+                    NameCallback nc = (NameCallback) callback;\n+                    nc.setName(nc.getDefaultName());\n+                } else {\n+                    if (callback instanceof PasswordCallback) {\n+                        PasswordCallback pc = (PasswordCallback) callback;\n+                        if (password != null) {\n+                            pc.setPassword(this.password.toCharArray());\n+                        }\n+                    } else {\n+                        if (callback instanceof RealmCallback) {\n+                            RealmCallback rc = (RealmCallback) callback;\n+                            rc.setText(rc.getDefaultText());\n+                        } else {\n+                            if (callback instanceof AuthorizeCallback) {\n+                                AuthorizeCallback ac = (AuthorizeCallback) callback;\n+                                String authid = ac.getAuthenticationID();\n+                                String authzid = ac.getAuthorizationID();\n+                                if (authid.equals(authzid)) {\n+                                    ac.setAuthorized(true);\n+                                } else {\n+                                    ac.setAuthorized(false);\n+                                }\n+                                if (ac.isAuthorized()) {\n+                                    ac.setAuthorizedID(authzid);\n+                                }\n+                            } else {\n+                                throw new UnsupportedCallbackException(callback, \"Unrecognized SASL ClientCallback\");\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}"},{"sha":"48806ddfc0525a984a8d31d84dadcaf5a440e0c2","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/sasl/SASLClientAuthProvider.java","status":"added","additions":101,"deletions":0,"changes":101,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/667390d1a6305c31608130929ba0d68a0b5a4763/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fsasl%2FSASLClientAuthProvider.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/667390d1a6305c31608130929ba0d68a0b5a4763/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fsasl%2FSASLClientAuthProvider.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fsasl%2FSASLClientAuthProvider.java?ref=667390d1a6305c31608130929ba0d68a0b5a4763","patch":"@@ -0,0 +1,101 @@\n+/**\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.sasl;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import javax.security.auth.Subject;\n+import javax.security.sasl.SaslException;\n+import org.apache.bookkeeper.auth.AuthCallbacks;\n+import org.apache.bookkeeper.auth.AuthToken;\n+import org.apache.bookkeeper.auth.ClientAuthProvider;\n+import org.apache.bookkeeper.client.BKException;\n+import org.apache.bookkeeper.client.ClientConnectionPeer;\n+import org.slf4j.LoggerFactory;\n+\n+public class SASLClientAuthProvider implements ClientAuthProvider {\n+\n+    private static final org.slf4j.Logger LOG = LoggerFactory.getLogger(SASLClientAuthProvider.class);\n+\n+    private SaslClientState client;\n+    private final AuthCallbacks.GenericCallback<Void> completeCb;\n+\n+    SASLClientAuthProvider(ClientConnectionPeer addr, AuthCallbacks.GenericCallback<Void> completeCb,\n+        Subject subject) {\n+        this.completeCb = completeCb;\n+        try {\n+            SocketAddress remoteAddr = addr.getRemoteAddr();\n+            String hostname;\n+            if (remoteAddr instanceof InetSocketAddress) {\n+                InetSocketAddress inetSocketAddress = (InetSocketAddress) remoteAddr;\n+                hostname = inetSocketAddress.getHostName();\n+            } else {\n+                hostname = InetAddress.getLocalHost().getHostName();\n+            }\n+            client = new SaslClientState(hostname, subject);\n+            LOG.debug(\"SASLClientAuthProvider Boot \" + client + \" for \" + hostname);\n+        } catch (IOException error) {\n+            LOG.error(\"Error while booting SASL client\", error);\n+            completeCb.operationComplete(BKException.Code.UnauthorizedAccessException, null);\n+        }\n+    }\n+\n+    @Override\n+    public void init(AuthCallbacks.GenericCallback<AuthToken> cb) {\n+        try {\n+            if (client.hasInitialResponse()) {\n+                byte[] response = client.evaluateChallenge(new byte[0]);\n+                cb.operationComplete(BKException.Code.OK, AuthToken.wrap(response));\n+            } else {\n+                cb.operationComplete(BKException.Code.OK, AuthToken.wrap(new byte[0]));\n+            }\n+        } catch (SaslException err) {\n+            LOG.error(\"Error on SASL client\", err);\n+            completeCb.operationComplete(BKException.Code.UnauthorizedAccessException, null);\n+        }\n+    }\n+\n+    @Override\n+    public void process(AuthToken m, AuthCallbacks.GenericCallback<AuthToken> cb) {\n+        if (client.isComplete()) {\n+            completeCb.operationComplete(BKException.Code.OK, null);\n+            return;\n+        }\n+        try {\n+            byte[] responseToken = m.getData();\n+            byte[] response = client.evaluateChallenge(responseToken);\n+            if (response == null) {\n+                response = new byte[0];\n+            }\n+            cb.operationComplete(BKException.Code.OK, AuthToken.wrap(response));\n+            if (client.isComplete()) {\n+                completeCb.operationComplete(BKException.Code.OK, null);\n+            }\n+        } catch (SaslException err) {\n+            LOG.error(\"Error on SASL client\", err);\n+            completeCb.operationComplete(BKException.Code.UnauthorizedAccessException, null);\n+        }\n+\n+    }\n+\n+}"},{"sha":"5f2079329fa73338653c1923dadd3dd6c5b4fb47","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/sasl/SASLClientProviderFactory.java","status":"added","additions":156,"deletions":0,"changes":156,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/667390d1a6305c31608130929ba0d68a0b5a4763/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fsasl%2FSASLClientProviderFactory.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/667390d1a6305c31608130929ba0d68a0b5a4763/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fsasl%2FSASLClientProviderFactory.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fsasl%2FSASLClientProviderFactory.java?ref=667390d1a6305c31608130929ba0d68a0b5a4763","patch":"@@ -0,0 +1,156 @@\n+/**\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.sasl;\n+\n+import java.io.IOException;\n+import javax.security.auth.Subject;\n+import javax.security.auth.kerberos.KerberosTicket;\n+import javax.security.auth.login.AppConfigurationEntry;\n+import javax.security.auth.login.Configuration;\n+import javax.security.auth.login.LoginContext;\n+import javax.security.auth.login.LoginException;\n+import javax.security.sasl.SaslException;\n+import org.apache.bookkeeper.auth.AuthCallbacks;\n+import org.apache.bookkeeper.auth.ClientAuthProvider;\n+import org.apache.bookkeeper.client.ClientConnectionPeer;\n+import org.apache.bookkeeper.conf.AbstractConfiguration;\n+import org.apache.bookkeeper.conf.ClientConfiguration;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * ClientAuthProvider which uses JDK-bundled SASL\n+ */\n+public class SASLClientProviderFactory implements\n+    org.apache.bookkeeper.auth.ClientAuthProvider.Factory, JAASCredentialsContainer {\n+\n+    private static final org.slf4j.Logger LOG = LoggerFactory.getLogger(SASLClientProviderFactory.class);\n+\n+    private ClientConfiguration clientConfiguration;\n+    private LoginContext login;\n+    private Subject subject;\n+    private String principal;\n+    private boolean isKrbTicket;\n+    private boolean isUsingTicketCache;\n+    private String loginContextName;\n+    private TGTRefreshThread ticketRefreshThread;\n+\n+    @Override\n+    public void init(ClientConfiguration conf) throws IOException {\n+        this.clientConfiguration = conf;\n+        try {\n+\n+            this.login = loginClient();\n+            this.subject = login.getSubject();\n+            this.isKrbTicket = !subject.getPrivateCredentials(KerberosTicket.class).isEmpty();\n+            boolean systemRole = ClientConfiguration.CLIENT_ROLE_SYSTEM.equals(clientConfiguration.getClientRole());\n+            this.loginContextName = systemRole\n+                ? clientConfiguration.getString(SaslConstants.JAAS_AUDITOR_SECTION_NAME, SaslConstants.JAAS_DEFAULT_AUDITOR_SECTION_NAME)\n+                : clientConfiguration.getString(SaslConstants.JAAS_CLIENT_SECTION_NAME, SaslConstants.JAAS_DEFAULT_CLIENT_SECTION_NAME);\n+            if (isKrbTicket) {\n+                this.isUsingTicketCache = SaslConstants.isUsingTicketCache(loginContextName);\n+                this.principal = SaslConstants.getPrincipal(loginContextName);\n+                ticketRefreshThread = new TGTRefreshThread(this);\n+                ticketRefreshThread.start();\n+            }\n+        } catch (SaslException | LoginException error) {\n+            throw new IOException(error);\n+        }\n+    }\n+\n+    @Override\n+    public ClientAuthProvider newProvider(ClientConnectionPeer addr, AuthCallbacks.GenericCallback<Void> completeCb) {\n+        return new SASLClientAuthProvider(addr, completeCb, subject);\n+    }\n+\n+    @Override\n+    public String getPluginName() {\n+        return SaslConstants.PLUGIN_NAME;\n+    }\n+\n+    private LoginContext loginClient() throws SaslException, LoginException {\n+        boolean systemRole = ClientConfiguration.CLIENT_ROLE_SYSTEM.equals(clientConfiguration.getClientRole());\n+        String configurationEntry = systemRole\n+            ? clientConfiguration.getString(SaslConstants.JAAS_AUDITOR_SECTION_NAME, SaslConstants.JAAS_DEFAULT_AUDITOR_SECTION_NAME)\n+            : clientConfiguration.getString(SaslConstants.JAAS_CLIENT_SECTION_NAME, SaslConstants.JAAS_DEFAULT_CLIENT_SECTION_NAME);\n+        AppConfigurationEntry[] entries = Configuration.getConfiguration()\n+            .getAppConfigurationEntry(configurationEntry);\n+        if (entries == null) {\n+            LOG.info(\"No JAAS Configuration found with section BookKeeper\");\n+            return null;\n+        }\n+        try {\n+            LoginContext loginContext = new LoginContext(configurationEntry, new SaslClientState.ClientCallbackHandler(null));\n+            loginContext.login();\n+            return loginContext;\n+        } catch (LoginException error) {\n+            LOG.error(\"Error JAAS Configuration subject\", error);\n+            return null;\n+        }\n+    }\n+\n+    @Override\n+    public void close() {\n+        if (ticketRefreshThread != null) {\n+            ticketRefreshThread.interrupt();\n+            try {\n+                ticketRefreshThread.join(10000);\n+            } catch (InterruptedException exit) {\n+                LOG.debug(\"interrupted while waiting for TGT reresh thread to stop\", exit);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public LoginContext getLogin() {\n+        return login;\n+    }\n+\n+    @Override\n+    public void setLogin(LoginContext login) {\n+        this.login = login;\n+    }\n+\n+    @Override\n+    public Subject getSubject() {\n+        return subject;\n+    }\n+\n+    @Override\n+    public boolean isUsingTicketCache() {\n+        return isUsingTicketCache;\n+    }\n+\n+    @Override\n+    public String getPrincipal() {\n+        return principal;\n+    }\n+\n+    @Override\n+    public AbstractConfiguration getConfiguration() {\n+        return clientConfiguration;\n+    }\n+\n+    @Override\n+    public String getLoginContextName() {\n+        return loginContextName;\n+    }\n+\n+}"},{"sha":"4121f8794c8d129ab06fa4daec6ca97a95df698d","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/sasl/SaslClientState.java","status":"added","additions":180,"deletions":0,"changes":180,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/667390d1a6305c31608130929ba0d68a0b5a4763/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fsasl%2FSaslClientState.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/667390d1a6305c31608130929ba0d68a0b5a4763/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fsasl%2FSaslClientState.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fsasl%2FSaslClientState.java?ref=667390d1a6305c31608130929ba0d68a0b5a4763","patch":"@@ -0,0 +1,180 @@\n+/**\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.sasl;\n+\n+import java.security.Principal;\n+import java.security.PrivilegedActionException;\n+import java.security.PrivilegedExceptionAction;\n+import javax.security.auth.Subject;\n+import javax.security.auth.callback.Callback;\n+import javax.security.auth.callback.CallbackHandler;\n+import javax.security.auth.callback.NameCallback;\n+import javax.security.auth.callback.PasswordCallback;\n+import javax.security.auth.callback.UnsupportedCallbackException;\n+import javax.security.sasl.AuthorizeCallback;\n+import javax.security.sasl.RealmCallback;\n+import javax.security.sasl.Sasl;\n+import javax.security.sasl.SaslClient;\n+import javax.security.sasl.SaslException;\n+import org.apache.zookeeper.server.auth.KerberosName;\n+import org.slf4j.LoggerFactory;\n+\n+public class SaslClientState {\n+\n+    private static final org.slf4j.Logger LOG = LoggerFactory.getLogger(SaslClientState.class);\n+\n+    private final SaslClient saslClient;\n+    private final Subject clientSubject;\n+    private String username;\n+    private String password;\n+\n+    public SaslClientState(String serverHostname, Subject subject) throws SaslException {\n+        String serverPrincipal = SaslConstants.SASL_BOOKKEEPER_PROTOCOL + \"/\" + serverHostname;\n+        this.clientSubject = subject;\n+        if (clientSubject == null) {\n+            throw new SaslException(\"Cannot create JAAS Sujbect for SASL\");\n+        }\n+        if (clientSubject.getPrincipals().isEmpty()) {\n+            LOG.debug(\"Using JAAS/SASL/DIGEST-MD5 auth to connect to {}\", serverPrincipal);\n+            String[] mechs = {\"DIGEST-MD5\"};\n+            username = (String) (clientSubject.getPublicCredentials().toArray()[0]);\n+            password = (String) (clientSubject.getPrivateCredentials().toArray()[0]);\n+            saslClient = Sasl.createSaslClient(mechs, username, SaslConstants.SASL_BOOKKEEPER_PROTOCOL,\n+                SaslConstants.SASL_MD5_DUMMY_HOSTNAME, null, new ClientCallbackHandler(password));\n+        } else { // GSSAPI/Kerberos\n+            final Object[] principals = clientSubject.getPrincipals().toArray();\n+            final Principal clientPrincipal = (Principal) principals[0];\n+            final KerberosName clientKerberosName = new KerberosName(clientPrincipal.getName());\n+            KerberosName serviceKerberosName = new KerberosName(serverPrincipal + \"@\" + clientKerberosName.getRealm());\n+            final String serviceName = serviceKerberosName.getServiceName();\n+            final String serviceHostname = serviceKerberosName.getHostName();\n+            final String clientPrincipalName = clientKerberosName.toString();\n+            LOG.debug(\"Using JAAS/SASL/GSSAPI auth to connect to server Principal {}\", serverPrincipal);\n+            try {\n+                saslClient = Subject.doAs(clientSubject, new PrivilegedExceptionAction<SaslClient>() {\n+                    @Override\n+                    public SaslClient run() throws SaslException {\n+                        String[] mechs = {\"GSSAPI\"};\n+                        return Sasl.createSaslClient(mechs, clientPrincipalName, serviceName, serviceHostname, null,\n+                            new ClientCallbackHandler(null));\n+                    }\n+                });\n+            } catch (PrivilegedActionException err) {\n+                LOG.debug(\"GSSAPI client error\", err.getCause());\n+                throw new SaslException(\"error while booting GSSAPI client\", err.getCause());\n+            }\n+        }\n+        if (saslClient == null) {\n+            throw new SaslException(\"Cannot create JVM SASL Client\");\n+        }\n+\n+    }\n+\n+    public byte[] evaluateChallenge(final byte[] saslToken) throws SaslException {\n+        if (saslToken == null) {\n+            throw new SaslException(\"saslToken is null\");\n+        }\n+        if (clientSubject != null) {\n+            try {\n+                final byte[] retval\n+                    = Subject.doAs(clientSubject, new PrivilegedExceptionAction<byte[]>() {\n+                        @Override\n+                        public byte[] run() throws SaslException {\n+                            return saslClient.evaluateChallenge(saslToken);\n+                        }\n+                    });\n+                return retval;\n+            } catch (PrivilegedActionException e) {\n+                LOG.debug(\"SASL error\", e.getCause());\n+                throw new SaslException(\"SASL/JAAS error\", e.getCause());\n+            }\n+        } else {\n+            return saslClient.evaluateChallenge(saslToken);\n+        }\n+    }\n+\n+    public boolean hasInitialResponse() {\n+        return saslClient.hasInitialResponse();\n+    }\n+\n+    static class ClientCallbackHandler implements CallbackHandler {\n+\n+        private String password = null;\n+\n+        public ClientCallbackHandler(String password) {\n+            this.password = password;\n+        }\n+\n+        @Override\n+        public void handle(Callback[] callbacks) throws\n+            UnsupportedCallbackException {\n+            for (Callback callback : callbacks) {\n+                if (callback instanceof NameCallback) {\n+                    NameCallback nc = (NameCallback) callback;\n+                    nc.setName(nc.getDefaultName());\n+                } else {\n+                    if (callback instanceof PasswordCallback) {\n+                        PasswordCallback pc = (PasswordCallback) callback;\n+                        if (password != null) {\n+                            pc.setPassword(this.password.toCharArray());\n+                        }\n+                    } else {\n+                        if (callback instanceof RealmCallback) {\n+                            RealmCallback rc = (RealmCallback) callback;\n+                            rc.setText(rc.getDefaultText());\n+                        } else {\n+                            if (callback instanceof AuthorizeCallback) {\n+                                AuthorizeCallback ac = (AuthorizeCallback) callback;\n+                                String authid = ac.getAuthenticationID();\n+                                String authzid = ac.getAuthorizationID();\n+                                if (authid.equals(authzid)) {\n+                                    ac.setAuthorized(true);\n+                                } else {\n+                                    ac.setAuthorized(false);\n+                                }\n+                                if (ac.isAuthorized()) {\n+                                    ac.setAuthorizedID(authzid);\n+                                }\n+                            } else {\n+                                throw new UnsupportedCallbackException(callback, \"Unrecognized SASL ClientCallback\");\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    public boolean isComplete() {\n+        return saslClient.isComplete();\n+    }\n+\n+    public byte[] saslResponse(byte[] saslTokenMessage) {\n+        try {\n+            byte[] retval = saslClient.evaluateChallenge(saslTokenMessage);\n+            return retval;\n+        } catch (SaslException e) {\n+            LOG.debug(\"saslResponse: Failed to respond to SASL server's token:\", e);\n+            return null;\n+        }\n+    }\n+\n+}"},{"sha":"9688b70ab981d9b7cc9e89d6c4efbfdb323ce86c","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/sasl/SaslConstants.java","status":"added","additions":88,"deletions":0,"changes":88,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/667390d1a6305c31608130929ba0d68a0b5a4763/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fsasl%2FSaslConstants.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/667390d1a6305c31608130929ba0d68a0b5a4763/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fsasl%2FSaslConstants.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fsasl%2FSaslConstants.java?ref=667390d1a6305c31608130929ba0d68a0b5a4763","patch":"@@ -0,0 +1,88 @@\n+/**\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.sasl;\n+\n+import javax.security.auth.login.AppConfigurationEntry;\n+import javax.security.auth.login.Configuration;\n+\n+public class SaslConstants {\n+\n+    static final String PLUGIN_NAME = \"sasl\";\n+\n+    public static final String JAAS_BOOKIE_SECTION_NAME = \"saslJaasBookieSectionName\";\n+    public static final String JAAS_DEFAULT_BOOKIE_SECTION_NAME = \"Bookie\";\n+\n+    public static final String JAAS_AUDITOR_SECTION_NAME = \"saslJaasAuditorSectionName\";\n+    public static final String JAAS_DEFAULT_AUDITOR_SECTION_NAME = \"Auditor\";\n+\n+    public static final String JAAS_CLIENT_SECTION_NAME = \"saslJaasClientSectionName\";\n+    public static final String JAAS_DEFAULT_CLIENT_SECTION_NAME = \"BookKeeper\";\n+\n+    /**\n+     * This is a regexp which limits the range of possible ids which can connect to the Bookie using SASL\n+     * By default only clients whose id contains the word 'bookkeeper' are allowed to connect\n+     */\n+    public static final String JAAS_CLIENT_ALLOWED_IDS = \"saslJaasClientAllowedIds\";\n+    public static final String JAAS_CLIENT_ALLOWED_IDS_DEFAULT = \".*bookkeeper.*\";\n+\n+    static final String KINIT_COMMAND_DEFAULT = \"/usr/bin/kinit\";\n+\n+    static final String KINIT_COMMAND = \"kerberos.kinit\";\n+\n+    static final String SASL_BOOKKEEPER_PROTOCOL = \"bookkeeper\";\n+    static final String SASL_BOOKKEEPER_REALM = \"bookkeeper\";\n+\n+    static final String SASL_MD5_DUMMY_HOSTNAME = \"bookkeeper\";\n+\n+    static boolean isUsingTicketCache(String configurationEntry) {\n+\n+        AppConfigurationEntry[] entries = Configuration.getConfiguration()\n+            .getAppConfigurationEntry(configurationEntry);\n+        if (entries == null) {\n+            return false;\n+        }\n+        for (AppConfigurationEntry entry : entries) {\n+            // there will only be a single entry, so this for() loop will only be iterated through once.\n+            if (entry.getOptions().get(\"useTicketCache\") != null) {\n+                String val = (String) entry.getOptions().get(\"useTicketCache\");\n+                if (val.equals(\"true\")) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    static String getPrincipal(String configurationEntry) {\n+\n+        AppConfigurationEntry[] entries = Configuration.getConfiguration()\n+            .getAppConfigurationEntry(configurationEntry);\n+        if (entries == null) {\n+            return null;\n+        }\n+        for (AppConfigurationEntry entry : entries) {\n+            if (entry.getOptions().get(\"principal\") != null) {\n+                return (String) entry.getOptions().get(\"principal\");\n+            }\n+        }\n+        return null;\n+    }\n+}"},{"sha":"776bf3ecde128d854e49c60ffac470a498fb4672","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/sasl/SaslServerState.java","status":"added","additions":238,"deletions":0,"changes":238,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/667390d1a6305c31608130929ba0d68a0b5a4763/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fsasl%2FSaslServerState.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/667390d1a6305c31608130929ba0d68a0b5a4763/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fsasl%2FSaslServerState.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fsasl%2FSaslServerState.java?ref=667390d1a6305c31608130929ba0d68a0b5a4763","patch":"@@ -0,0 +1,238 @@\n+/*\n+ Licensed to Diennea S.r.l. under one\n+ or more contributor license agreements. See the NOTICE file\n+ distributed with this work for additional information\n+ regarding copyright ownership. Diennea S.r.l. licenses this file\n+ to you under the Apache License, Version 2.0 (the\n+ \"License\"); you may not use this file except in compliance\n+ with the License.  You may obtain a copy of the License at\n+\n+ http://www.apache.org/licenses/LICENSE-2.0\n+\n+ Unless required by applicable law or agreed to in writing,\n+ software distributed under the License is distributed on an\n+ \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ KIND, either express or implied.  See the License for the\n+ specific language governing permissions and limitations\n+ under the License.\n+\n+ */\n+package org.apache.bookkeeper.sasl;\n+\n+import java.io.IOException;\n+import java.security.Principal;\n+import java.security.PrivilegedActionException;\n+import java.security.PrivilegedExceptionAction;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.regex.Pattern;\n+import javax.security.auth.Subject;\n+import javax.security.auth.callback.Callback;\n+import javax.security.auth.callback.CallbackHandler;\n+import javax.security.auth.callback.NameCallback;\n+import javax.security.auth.callback.PasswordCallback;\n+import javax.security.auth.callback.UnsupportedCallbackException;\n+import javax.security.auth.login.AppConfigurationEntry;\n+import javax.security.auth.login.Configuration;\n+import javax.security.auth.login.LoginException;\n+import javax.security.sasl.AuthorizeCallback;\n+import javax.security.sasl.RealmCallback;\n+import javax.security.sasl.Sasl;\n+import javax.security.sasl.SaslException;\n+import javax.security.sasl.SaslServer;\n+import org.apache.bookkeeper.conf.ServerConfiguration;\n+import org.apache.zookeeper.server.auth.KerberosName;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Server side Sasl implementation\n+ */\n+public class SaslServerState {\n+\n+    private static final org.slf4j.Logger LOG = LoggerFactory.getLogger(SaslServerState.class);\n+\n+    private final SaslServer saslServer;\n+    private final Pattern allowedIdsPattern;\n+\n+    public SaslServerState(\n+        ServerConfiguration serverConfiguration, Subject subject, Pattern allowedIdsPattern)\n+        throws IOException, SaslException, LoginException {\n+        this.allowedIdsPattern = allowedIdsPattern;\n+        saslServer = createSaslServer(subject, serverConfiguration);\n+    }\n+\n+    private SaslServer createSaslServer(final Subject subject, ServerConfiguration serverConfiguration)\n+        throws SaslException, IOException {\n+\n+        SaslServerCallbackHandler callbackHandler = new SaslServerCallbackHandler(Configuration.getConfiguration(),\n+            serverConfiguration);\n+        if (subject.getPrincipals().size() > 0) {\n+            try {\n+                final Object[] principals = subject.getPrincipals().toArray();\n+                final Principal servicePrincipal = (Principal) principals[0];\n+                LOG.debug(\"Authentication will use SASL/JAAS/Kerberos, servicePrincipal is {}\", servicePrincipal);\n+\n+                final String servicePrincipalNameAndHostname = servicePrincipal.getName();\n+                int indexOf = servicePrincipalNameAndHostname.indexOf(\"/\");\n+                final String serviceHostnameAndKerbDomain = servicePrincipalNameAndHostname.substring(indexOf + 1,\n+                    servicePrincipalNameAndHostname.length());\n+                int indexOfAt = serviceHostnameAndKerbDomain.indexOf(\"@\");\n+\n+                final String servicePrincipalName, serviceHostname;\n+                if (indexOf > 0) {\n+                    servicePrincipalName = servicePrincipalNameAndHostname.substring(0, indexOf);\n+                    serviceHostname = serviceHostnameAndKerbDomain.substring(0, indexOfAt);\n+                } else {\n+                    servicePrincipalName = servicePrincipalNameAndHostname.substring(0, indexOfAt);\n+                    serviceHostname = null;\n+                }\n+\n+                try {\n+                    return Subject.doAs(subject, new PrivilegedExceptionAction<SaslServer>() {\n+                        @Override\n+                        public SaslServer run() {\n+                            try {\n+                                SaslServer saslServer;\n+                                saslServer = Sasl.createSaslServer(\"GSSAPI\", servicePrincipalName, serviceHostname, null,\n+                                    callbackHandler);\n+                                return saslServer;\n+                            } catch (SaslException e) {\n+                                throw new RuntimeException(e);\n+                            }\n+                        }\n+                    }\n+                    );\n+                } catch (PrivilegedActionException e) {\n+                    throw new SaslException(\"error on GSSAPI boot\", e.getCause());\n+                }\n+            } catch (IndexOutOfBoundsException e) {\n+                throw new SaslException(\"error on GSSAPI boot\", e);\n+            }\n+        } else {\n+            LOG.debug(\"Authentication will use SASL/JAAS/DIGEST-MD5\");\n+            return Sasl.createSaslServer(\"DIGEST-MD5\", SaslConstants.SASL_BOOKKEEPER_PROTOCOL,\n+                SaslConstants.SASL_MD5_DUMMY_HOSTNAME, null, callbackHandler);\n+        }\n+    }\n+\n+    public boolean isComplete() {\n+        return saslServer.isComplete();\n+    }\n+\n+    public String getUserName() {\n+        return saslServer.getAuthorizationID();\n+    }\n+\n+    public byte[] response(byte[] token) throws SaslException {\n+        try {\n+            byte[] retval = saslServer.evaluateResponse(token);\n+            return retval;\n+        } catch (SaslException e) {\n+            LOG.error(\"response: Failed to evaluate client token\", e);\n+            throw e;\n+        }\n+    }\n+\n+    private class SaslServerCallbackHandler implements CallbackHandler {\n+\n+        private static final String USER_PREFIX = \"user_\";\n+\n+        private String userName;\n+        private final Map<String, String> credentials = new HashMap<>();\n+\n+        public SaslServerCallbackHandler(Configuration configuration, ServerConfiguration serverConfiguration) throws IOException {\n+            String configurationEntry = serverConfiguration.getString(SaslConstants.JAAS_BOOKIE_SECTION_NAME,\n+                SaslConstants.JAAS_DEFAULT_BOOKIE_SECTION_NAME);\n+            AppConfigurationEntry configurationEntries[] = configuration.getAppConfigurationEntry(configurationEntry);\n+\n+            if (configurationEntries == null) {\n+                String errorMessage = \"Could not find a '\" + configurationEntry + \"' entry in this configuration: Server cannot start.\";\n+\n+                throw new IOException(errorMessage);\n+            }\n+            credentials.clear();\n+            for (AppConfigurationEntry entry : configurationEntries) {\n+                Map<String, ?> options = entry.getOptions();\n+                // Populate DIGEST-MD5 user -> password map with JAAS configuration entries from the \"Server\" section.\n+                // Usernames are distinguished from other options by prefixing the username with a \"user_\" prefix.\n+                for (Map.Entry<String, ?> pair : options.entrySet()) {\n+                    String key = pair.getKey();\n+                    if (key.startsWith(USER_PREFIX)) {\n+                        String userName = key.substring(USER_PREFIX.length());\n+                        credentials.put(userName, (String) pair.getValue());\n+                    }\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void handle(Callback[] callbacks) throws UnsupportedCallbackException {\n+            for (Callback callback : callbacks) {\n+                if (callback instanceof NameCallback) {\n+                    handleNameCallback((NameCallback) callback);\n+                } else if (callback instanceof PasswordCallback) {\n+                    handlePasswordCallback((PasswordCallback) callback);\n+                } else if (callback instanceof RealmCallback) {\n+                    handleRealmCallback((RealmCallback) callback);\n+                } else if (callback instanceof AuthorizeCallback) {\n+                    handleAuthorizeCallback((AuthorizeCallback) callback);\n+                }\n+            }\n+        }\n+\n+        private void handleNameCallback(NameCallback nc) {\n+            // check to see if this user is in the user password database.\n+            if (credentials.get(nc.getDefaultName()) == null) {\n+                LOG.error(\"User '\" + nc.getDefaultName() + \"' not found in list of JAAS DIGEST-MD5 users.\");\n+                return;\n+            }\n+            nc.setName(nc.getDefaultName());\n+            userName = nc.getDefaultName();\n+        }\n+\n+        private void handlePasswordCallback(PasswordCallback pc) {\n+            if (credentials.containsKey(userName)) {\n+                pc.setPassword(credentials.get(userName).toCharArray());\n+            } else {\n+                LOG.info(\"No password found for user: \" + userName);\n+            }\n+        }\n+\n+        private void handleRealmCallback(RealmCallback rc) {\n+            LOG.debug(\"client supplied realm: \" + rc.getDefaultText());\n+            rc.setText(rc.getDefaultText());\n+        }\n+\n+        private void handleAuthorizeCallback(AuthorizeCallback ac) {\n+            String authenticationID = ac.getAuthenticationID();\n+            String authorizationID = ac.getAuthorizationID();\n+            if (!authenticationID.equals(authorizationID)) {\n+                ac.setAuthorized(false);\n+                LOG.info(\"Forbidden access to client: authenticationID=\" + authenticationID\n+                    + \" is different from authorizationID=\" + authorizationID + \".\");\n+                return;\n+            }\n+            if (!allowedIdsPattern.matcher(authenticationID).matches()) {\n+                ac.setAuthorized(false);\n+                LOG.info(\"Forbidden access to client: authenticationID=\" + authenticationID\n+                    + \" is not allowed (see \" + SaslConstants.JAAS_CLIENT_ALLOWED_IDS + \" property)\");\n+                return;\n+            }\n+            ac.setAuthorized(true);\n+\n+            LOG.debug(\"Successfully authenticated client: authenticationID=\" + authenticationID\n+                + \";  authorizationID=\" + authorizationID + \".\");\n+\n+            KerberosName kerberosName = new KerberosName(authenticationID);\n+            try {\n+                StringBuilder userNameBuilder = new StringBuilder(kerberosName.getShortName());\n+                userNameBuilder.append(\"/\").append(kerberosName.getHostName());\n+                userNameBuilder.append(\"@\").append(kerberosName.getRealm());\n+                LOG.debug(\"Setting authorizedID: \" + userNameBuilder);\n+                ac.setAuthorizedID(userNameBuilder.toString());\n+            } catch (IOException e) {\n+                LOG.error(\"Failed to set name based on Kerberos authentication rules.\");\n+            }\n+        }\n+    }\n+}"},{"sha":"e8fbaa0150753caad5b62aeca141f73899c3fd6a","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/sasl/TGTRefreshThread.java","status":"added","additions":272,"deletions":0,"changes":272,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/667390d1a6305c31608130929ba0d68a0b5a4763/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fsasl%2FTGTRefreshThread.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/667390d1a6305c31608130929ba0d68a0b5a4763/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fsasl%2FTGTRefreshThread.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fsasl%2FTGTRefreshThread.java?ref=667390d1a6305c31608130929ba0d68a0b5a4763","patch":"@@ -0,0 +1,272 @@\n+/**\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.sasl;\n+\n+import java.util.Date;\n+import java.util.Random;\n+import java.util.Set;\n+import javax.security.auth.kerberos.KerberosPrincipal;\n+import javax.security.auth.kerberos.KerberosTicket;\n+import javax.security.auth.login.LoginContext;\n+import javax.security.auth.login.LoginException;\n+import org.apache.zookeeper.Login;\n+import org.apache.zookeeper.Shell;\n+import org.apache.zookeeper.common.Time;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+// copied from Apache ZooKeeper TGT refresh logic\n+class TGTRefreshThread extends Thread {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(TGTRefreshThread.class);\n+    private static final Random rng = new Random();\n+\n+    private long lastLogin;\n+    private final JAASCredentialsContainer container;\n+\n+    public long getLastLogin() {\n+        return lastLogin;\n+    }\n+\n+    public void setLastLogin(long lastLogin) {\n+        this.lastLogin = lastLogin;\n+    }\n+\n+    public TGTRefreshThread(JAASCredentialsContainer container) {\n+        this.container = container;\n+        // Initialize 'lastLogin' to do a login at first time\n+        this.lastLogin = System.currentTimeMillis() - MIN_TIME_BEFORE_RELOGIN;\n+        setDaemon(true);\n+        setName(\"bookkeeper-tgt-refresh-thread\");\n+    } // Initialize 'lastLogin' to do a login at first time\n+\n+    private synchronized KerberosTicket getTGT() {\n+        Set<KerberosTicket> tickets = container.getSubject().getPrivateCredentials(KerberosTicket.class);\n+        for (KerberosTicket ticket : tickets) {\n+            KerberosPrincipal server = ticket.getServer();\n+            if (server.getName().equals(\"krbtgt/\" + server.getRealm() + \"@\" + server.getRealm())) {\n+                LOG.debug(\"Client principal is \\\"\" + ticket.getClient().getName() + \"\\\".\");\n+                LOG.debug(\"Server principal is \\\"\" + ticket.getServer().getName() + \"\\\".\");\n+                return ticket;\n+            }\n+        }\n+        return null;\n+    }\n+    // LoginThread will sleep until 80% of time from last refresh to\n+    // ticket's expiry has been reached, at which time it will wake\n+    // and try to renew the ticket.\n+    private static final float TICKET_RENEW_WINDOW = 0.80f;\n+    /**\n+     * Percentage of random jitter added to the renewal time\n+     */\n+    private static final float TICKET_RENEW_JITTER = 0.05f;\n+    // Regardless of TICKET_RENEW_WINDOW setting above and the ticket expiry time,\n+    // thread will not sleep between refresh attempts any less than 1 minute (60*1000 milliseconds = 1 minute).\n+    // Change the '1' to e.g. 5, to change this to 5 minutes.\n+    private static final long MIN_TIME_BEFORE_RELOGIN = 1 * 60 * 1000L;\n+\n+    private long getRefreshTime(KerberosTicket tgt) {\n+        long start = tgt.getStartTime().getTime();\n+        long expires = tgt.getEndTime().getTime();\n+        LOG.info(\"TGT valid starting at:        {}\", tgt.getStartTime().toString());\n+        LOG.info(\"TGT expires:                  {}\", tgt.getEndTime().toString());\n+        long proposedRefresh = start\n+            + (long) ((expires - start) * (TICKET_RENEW_WINDOW + (TICKET_RENEW_JITTER * rng.nextDouble())));\n+        if (proposedRefresh > expires) {\n+            // proposedRefresh is too far in the future: it's after ticket expires: simply return now.\n+            return Time.currentWallTime();\n+        } else {\n+            return proposedRefresh;\n+        }\n+    }\n+\n+    @Override\n+    public void run() {\n+        LOG.info(\"TGT refresh thread started.\");\n+        while (true) {\n+            // renewal thread's main loop. if it exits from here, thread will exit.\n+            KerberosTicket tgt = getTGT();\n+            long now = Time.currentWallTime();\n+            long nextRefresh;\n+            Date nextRefreshDate;\n+            if (tgt == null) {\n+                nextRefresh = now + MIN_TIME_BEFORE_RELOGIN;\n+                nextRefreshDate = new Date(nextRefresh);\n+                LOG.warn(\"No TGT found: will try again at {}\", nextRefreshDate);\n+            } else {\n+                nextRefresh = getRefreshTime(tgt);\n+                long expiry = tgt.getEndTime().getTime();\n+                Date expiryDate = new Date(expiry);\n+                if ((container.isUsingTicketCache()) && (tgt.getEndTime().equals(tgt.getRenewTill()))) {\n+                    Object[] logPayload = {expiryDate, container.getPrincipal(), container.getPrincipal()};\n+                    LOG.error(\"The TGT cannot be renewed beyond the next expiry date: {}.\"\n+                        + \"This process will not be able to authenticate new SASL connections after that \"\n+                        + \"time (for example, it will not be authenticate a new connection with a Bookie \"\n+                        + \").  Ask your system administrator to either increase the \"\n+                        + \"'renew until' time by doing : 'modprinc -maxrenewlife {}' within \"\n+                        + \"kadmin, or instead, to generate a keytab for {}. Because the TGT's \"\n+                        + \"expiry cannot be further extended by refreshing, exiting refresh thread now.\", logPayload);\n+                    return;\n+                }\n+                // determine how long to sleep from looking at ticket's expiry.\n+                // We should not allow the ticket to expire, but we should take into consideration\n+                // MIN_TIME_BEFORE_RELOGIN. Will not sleep less than MIN_TIME_BEFORE_RELOGIN, unless doing so\n+                // would cause ticket expiration.\n+                if ((nextRefresh > expiry) || ((now + MIN_TIME_BEFORE_RELOGIN) > expiry)) {\n+                    // expiry is before next scheduled refresh).\n+                    nextRefresh = now;\n+                } else {\n+                    if (nextRefresh < (now + MIN_TIME_BEFORE_RELOGIN)) {\n+                        // next scheduled refresh is sooner than (now + MIN_TIME_BEFORE_LOGIN).\n+                        Date until = new Date(nextRefresh);\n+                        Date newuntil = new Date(now + MIN_TIME_BEFORE_RELOGIN);\n+                        Object[] logPayload = {until, newuntil, MIN_TIME_BEFORE_RELOGIN / 1000};\n+                        LOG.warn(\"TGT refresh thread time adjusted from : {} to : {} since \"\n+                            + \"the former is sooner than the minimum refresh interval (\"\n+                            + \"{} seconds) from now.\", logPayload);\n+                    }\n+                    nextRefresh = Math.max(nextRefresh, now + MIN_TIME_BEFORE_RELOGIN);\n+                }\n+                nextRefreshDate = new Date(nextRefresh);\n+                if (nextRefresh > expiry) {\n+                    Object[] logPayload = {nextRefreshDate, expiryDate};\n+                    LOG.error(\"next refresh: {} is later than expiry {}.\" + \" This may indicate a clock skew problem.\"\n+                        + \"Check that this host and the KDC's \" + \"hosts' clocks are in sync. Exiting refresh thread.\",\n+                        logPayload);\n+                    return;\n+                }\n+            }\n+            if (now == nextRefresh) {\n+                LOG.info(\"refreshing now because expiry is before next scheduled refresh time.\");\n+            } else if (now < nextRefresh) {\n+                Date until = new Date(nextRefresh);\n+                LOG.info(\"TGT refresh sleeping until: {}\", until.toString());\n+                try {\n+                    Thread.sleep(nextRefresh - now);\n+                } catch (InterruptedException ie) {\n+                    LOG.warn(\"TGT renewal thread has been interrupted and will exit.\");\n+                    break;\n+                }\n+            } else {\n+                LOG.error(\"nextRefresh:{} is in the past: exiting refresh thread. Check\"\n+                    + \" clock sync between this host and KDC - (KDC's clock is likely ahead of this host).\"\n+                    + \" Manual intervention will be required for this client to successfully authenticate.\"\n+                    + \" Exiting refresh thread.\", nextRefreshDate);\n+                break;\n+            }\n+            if (container.isUsingTicketCache()) {\n+                String cmd = container.getConfiguration().getString(SaslConstants.KINIT_COMMAND, SaslConstants.KINIT_COMMAND_DEFAULT);\n+                String kinitArgs = \"-R\";\n+                int retry = 1;\n+                while (retry >= 0) {\n+                    try {\n+                        LOG.debug(\"running ticket cache refresh command: {} {}\", cmd, kinitArgs);\n+                        Shell.execCommand(cmd, kinitArgs);\n+                        break;\n+                    } catch (Exception e) {\n+                        if (retry > 0) {\n+                            --retry;\n+                            // sleep for 10 seconds\n+                            try {\n+                                Thread.sleep(10 * 1000);\n+                            } catch (InterruptedException ie) {\n+                                LOG.error(\"Interrupted while renewing TGT, exiting Login thread\");\n+                                return;\n+                            }\n+                        } else {\n+                            Object[] logPayload = {cmd, kinitArgs, e.toString(), e};\n+                            LOG.warn(\"Could not renew TGT due to problem running shell command: '{}\"\n+                                + \" {}'; exception was:{}. Exiting refresh thread.\", logPayload);\n+                            return;\n+                        }\n+                    }\n+                }\n+            }\n+            try {\n+                int retry = 1;\n+                while (retry >= 0) {\n+                    try {\n+                        reLogin();\n+                        break;\n+                    } catch (LoginException le) {\n+                        if (retry > 0) {\n+                            --retry;\n+                            // sleep for 10 seconds.\n+                            try {\n+                                Thread.sleep(10 * 1000);\n+                            } catch (InterruptedException e) {\n+                                LOG.error(\"Interrupted during login retry after LoginException:\", le);\n+                                throw le;\n+                            }\n+                        } else {\n+                            LOG.error(\"Could not refresh TGT for principal: {}.\", container.getPrincipal(), le);\n+                        }\n+                    }\n+                }\n+            } catch (LoginException le) {\n+                LOG.error(\"Failed to refresh TGT: refresh thread exiting now.\", le);\n+                break;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Re-login a principal. This method assumes that {@link #login(String)} has happened already.\n+     *\n+     * @throws javax.security.auth.login.LoginException on a failure\n+     */\n+    // c.f. HADOOP-6559\n+    private synchronized void reLogin() throws LoginException {\n+        LoginContext login = container.getLogin();\n+        if (login == null) {\n+            throw new LoginException(\"login must be done first\");\n+        }\n+        if (!hasSufficientTimeElapsed()) {\n+            return;\n+        }\n+        LOG.info(\"Initiating logout for {}\", container.getPrincipal());\n+        synchronized (Login.class) {\n+            //clear up the kerberos state. But the tokens are not cleared! As per\n+            //the Java kerberos login module code, only the kerberos credentials\n+            //are cleared\n+            login.logout();\n+            //login and also update the subject field of this instance to\n+            //have the new credentials (pass it to the LoginContext constructor)\n+            login = new LoginContext(container.getLoginContextName(), container.getSubject());\n+            LOG.info(\"Initiating re-login for {}\", container.getPrincipal());\n+            login.login();\n+            container.setLogin(login);\n+        }\n+    }\n+\n+    private boolean hasSufficientTimeElapsed() {\n+        long now = System.currentTimeMillis();\n+        if (now - getLastLogin() < MIN_TIME_BEFORE_RELOGIN) {\n+            LOG.warn(\"Not attempting to re-login since the last re-login was \"\n+                + \"attempted less than {} seconds before.\", MIN_TIME_BEFORE_RELOGIN / 1000);\n+            return false;\n+        }\n+        // register most recent relogin attempt\n+        setLastLogin(now);\n+        return true;\n+    }\n+\n+}"},{"sha":"07d31a81ba5a05dba85afd9d44a117726276d2b5","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/sasl/GSSAPIBookKeeperTest.java","status":"added","additions":256,"deletions":0,"changes":256,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/667390d1a6305c31608130929ba0d68a0b5a4763/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fsasl%2FGSSAPIBookKeeperTest.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/667390d1a6305c31608130929ba0d68a0b5a4763/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fsasl%2FGSSAPIBookKeeperTest.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fsasl%2FGSSAPIBookKeeperTest.java?ref=667390d1a6305c31608130929ba0d68a0b5a4763","patch":"@@ -0,0 +1,256 @@\n+package org.apache.bookkeeper.sasl;\n+\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.util.Arrays;\n+import org.apache.bookkeeper.client.*;\n+import java.util.Enumeration;\n+import java.util.Properties;\n+\n+/*\n+*\n+* Licensed to the Apache Software Foundation (ASF) under one\n+* or more contributor license agreements.  See the NOTICE file\n+* distributed with this work for additional information\n+* regarding copyright ownership.  The ASF licenses this file\n+* to you under the Apache License, Version 2.0 (the\n+* \"License\"); you may not use this file except in compliance\n+* with the License.  You may obtain a copy of the License at\n+*\n+*   http://www.apache.org/licenses/LICENSE-2.0\n+*\n+* Unless required by applicable law or agreed to in writing,\n+* software distributed under the License is distributed on an\n+* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+* KIND, either express or implied.  See the License for the\n+* specific language governing permissions and limitations\n+* under the License.\n+*\n+ */\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.security.auth.login.Configuration;\n+import org.apache.bookkeeper.client.BKException.BKUnauthorizedAccessException;\n+\n+import org.apache.bookkeeper.conf.ClientConfiguration;\n+import org.apache.bookkeeper.client.BookKeeper.DigestType;\n+import org.apache.bookkeeper.conf.ServerConfiguration;\n+import org.apache.bookkeeper.proto.BookieServer;\n+import org.apache.bookkeeper.test.BookKeeperClusterTestCase;\n+import org.apache.hadoop.minikdc.MiniKdc;\n+import org.apache.zookeeper.KeeperException;\n+import org.junit.After;\n+import org.junit.AfterClass;\n+\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.junit.Assert.*;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.rules.TemporaryFolder;\n+\n+public class GSSAPIBookKeeperTest extends BookKeeperClusterTestCase {\n+\n+    static final Logger LOG = LoggerFactory.getLogger(GSSAPIBookKeeperTest.class);\n+\n+    private static final byte[] PASSWD = \"testPasswd\".getBytes();\n+    private static final byte[] ENTRY = \"TestEntry\".getBytes();\n+\n+    private MiniKdc kdc;\n+    private Properties conf;\n+\n+    @Rule\n+    public TemporaryFolder kdcDir = new TemporaryFolder();\n+\n+    @Rule\n+    public TemporaryFolder kerberosWorkDir = new TemporaryFolder();\n+\n+    @Before\n+    public void startMiniKdc() throws Exception {\n+\n+        conf = MiniKdc.createConf();\n+        kdc = new MiniKdc(conf, kdcDir.getRoot());\n+        kdc.start();\n+\n+        String localhostName = InetAddress.getLocalHost().getHostName();\n+\n+        String principalServerNoRealm = \"bookkeeper/\" + localhostName;\n+        String principalServer = \"bookkeeper/\" + localhostName + \"@\" + kdc.getRealm();\n+        LOG.info(\"principalServer: \" + principalServer);\n+        String principalClientNoRealm = \"bookkeeperclient/\" + localhostName;\n+        String principalClient = principalClientNoRealm + \"@\" + kdc.getRealm();\n+        LOG.info(\"principalClient: \" + principalClient);\n+\n+        File keytabClient = new File(kerberosWorkDir.getRoot(), \"bookkeeperclient.keytab\");\n+        kdc.createPrincipal(keytabClient, principalClientNoRealm);\n+\n+        File keytabServer = new File(kerberosWorkDir.getRoot(), \"bookkeeperserver.keytab\");\n+        kdc.createPrincipal(keytabServer, principalServerNoRealm);\n+\n+        File jaas_file = new File(kerberosWorkDir.getRoot(), \"jaas.conf\");\n+        try (FileWriter writer = new FileWriter(jaas_file)) {\n+            writer.write(\"\\n\"\n+                + \"Bookie {\\n\"\n+                + \"  com.sun.security.auth.module.Krb5LoginModule required debug=true\\n\"\n+                + \"  useKeyTab=true\\n\"\n+                + \"  keyTab=\\\"\" + keytabServer.getAbsolutePath() + \"\\n\"\n+                + \"  storeKey=true\\n\"\n+                + \"  useTicketCache=false\\n\" // won't test useTicketCache=true on JUnit tests\n+                + \"  principal=\\\"\" + principalServer + \"\\\";\\n\"\n+                + \"};\\n\"\n+                + \"\\n\"\n+                + \"\\n\"\n+                + \"\\n\"\n+                + \"BookKeeper {\\n\"\n+                + \"  com.sun.security.auth.module.Krb5LoginModule required debug=true\\n\"\n+                + \"  useKeyTab=true\\n\"\n+                + \"  keyTab=\\\"\" + keytabClient.getAbsolutePath() + \"\\n\"\n+                + \"  storeKey=true\\n\"\n+                + \"  useTicketCache=false\\n\"\n+                + \"  principal=\\\"\" + principalClient + \"\\\";\\n\"\n+                + \"};\\n\"\n+            );\n+\n+        }\n+\n+        File krb5file = new File(kerberosWorkDir.getRoot(), \"krb5.conf\");\n+        try (FileWriter writer = new FileWriter(krb5file)) {\n+            writer.write(\"[libdefaults]\\n\"\n+                + \" default_realm = \" + kdc.getRealm() + \"\\n\"\n+                + \"\\n\"\n+                + \"\\n\"\n+                + \"[realms]\\n\"\n+                + \" \" + kdc.getRealm() + \"  = {\\n\"\n+                + \"  kdc = \" + kdc.getHost() + \":\" + kdc.getPort() + \"\\n\"\n+                + \" }\"\n+            );\n+\n+        }\n+\n+        System.setProperty(\"java.security.auth.login.config\", jaas_file.getAbsolutePath());\n+        System.setProperty(\"java.security.krb5.conf\", krb5file.getAbsolutePath());\n+        javax.security.auth.login.Configuration.getConfiguration().refresh();\n+\n+    }\n+\n+    @After\n+    public void stopMiniKdc() {\n+        System.clearProperty(\"java.security.auth.login.config\");\n+        System.clearProperty(\"java.security.krb5.conf\");\n+        if (kdc != null) {\n+            kdc.stop();\n+        }\n+    }\n+\n+    public GSSAPIBookKeeperTest() {\n+        super(0); // start them later when auth providers are configured\n+    }\n+\n+    // we pass in ledgerId because the method may throw exceptions\n+    private void connectAndWriteToBookie(ClientConfiguration conf, AtomicLong ledgerWritten)\n+        throws BKException, InterruptedException, IOException, KeeperException {\n+        LOG.info(\"Connecting to bookie\");\n+        try (BookKeeper bkc = new BookKeeper(conf, zkc)) {\n+            LedgerHandle l = bkc.createLedger(1, 1, DigestType.CRC32,\n+                PASSWD);\n+            ledgerWritten.set(l.getId());\n+            l.addEntry(ENTRY);\n+            l.close();\n+        }\n+    }\n+\n+    /**\n+     * check if the entry exists. Restart the bookie to allow access\n+     */\n+    private int entryCount(long ledgerId, ServerConfiguration bookieConf,\n+        ClientConfiguration clientConf) throws Exception {\n+        LOG.info(\"Counting entries in {}\", ledgerId);\n+        for (ServerConfiguration conf : bsConfs) {\n+            bookieConf.setUseHostNameAsBookieID(true);\n+            bookieConf.setBookieAuthProviderFactoryClass(\n+                SASLBookieAuthProviderFactory.class.getName());\n+        }\n+        clientConf.setClientAuthProviderFactoryClass(\n+            SASLClientProviderFactory.class.getName());\n+\n+        restartBookies();\n+\n+        try (BookKeeper bkc = new BookKeeper(clientConf, zkc);\n+            LedgerHandle lh = bkc.openLedger(ledgerId, DigestType.CRC32,\n+                PASSWD);) {\n+            if (lh.getLastAddConfirmed() < 0) {\n+                return 0;\n+            }\n+            Enumeration<LedgerEntry> e = lh.readEntries(0, lh.getLastAddConfirmed());\n+            int count = 0;\n+            while (e.hasMoreElements()) {\n+                count++;\n+                assertTrue(\"Should match what we wrote\",\n+                    Arrays.equals(e.nextElement().getEntry(), ENTRY));\n+            }\n+            return count;\n+        }\n+    }\n+\n+    /**\n+     * Test an connection will authorize with a single message to the server and a single response.\n+     */\n+    @Test(timeout = 30000)\n+    public void testSingleMessageAuth() throws Exception {\n+        ServerConfiguration bookieConf = newServerConfiguration();\n+        bookieConf.setUseHostNameAsBookieID(true);\n+        bookieConf.setBookieAuthProviderFactoryClass(\n+            SASLBookieAuthProviderFactory.class.getName());\n+\n+        ClientConfiguration clientConf = newClientConfiguration();\n+        clientConf.setClientAuthProviderFactoryClass(\n+            SASLClientProviderFactory.class.getName());\n+\n+        startAndStoreBookie(bookieConf);\n+\n+        AtomicLong ledgerId = new AtomicLong(-1);\n+        connectAndWriteToBookie(clientConf, ledgerId); // should succeed\n+\n+        assertFalse(ledgerId.get() == -1);\n+        assertEquals(\"Should have entry\", 1, entryCount(ledgerId.get(), bookieConf, clientConf));\n+    }\n+\n+    @Test(timeout = 30000)\n+    public void testNotAllowedClientId() throws Exception {\n+        ServerConfiguration bookieConf = newServerConfiguration();\n+        bookieConf.setUseHostNameAsBookieID(true);\n+        bookieConf.setBookieAuthProviderFactoryClass(\n+            SASLBookieAuthProviderFactory.class.getName());\n+        bookieConf.setProperty(SaslConstants.JAAS_CLIENT_ALLOWED_IDS, \"nobody\");\n+\n+        ClientConfiguration clientConf = newClientConfiguration();\n+        clientConf.setClientAuthProviderFactoryClass(\n+            SASLClientProviderFactory.class.getName());\n+\n+        startAndStoreBookie(bookieConf);\n+\n+        AtomicLong ledgerId = new AtomicLong(-1);\n+        try {\n+            connectAndWriteToBookie(clientConf, ledgerId);\n+            fail(\"should not be able to access the bookie\");\n+        } catch (BKUnauthorizedAccessException err) {\n+        }\n+\n+    }\n+\n+    BookieServer startAndStoreBookie(ServerConfiguration conf) throws Exception {\n+        bsConfs.add(conf);\n+        BookieServer s = startBookie(conf);\n+        bs.add(s);\n+        return s;\n+    }\n+\n+    @AfterClass\n+    public static void resetJAAS() {\n+        System.clearProperty(\"java.security.auth.login.config\");\n+        Configuration.getConfiguration().refresh();\n+    }\n+}"},{"sha":"185c5cf21fde4a5ac708657f7b68919500142994","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/sasl/MD5DigestBookKeeperTest.java","status":"added","additions":142,"deletions":0,"changes":142,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/667390d1a6305c31608130929ba0d68a0b5a4763/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fsasl%2FMD5DigestBookKeeperTest.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/667390d1a6305c31608130929ba0d68a0b5a4763/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fsasl%2FMD5DigestBookKeeperTest.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fsasl%2FMD5DigestBookKeeperTest.java?ref=667390d1a6305c31608130929ba0d68a0b5a4763","patch":"@@ -0,0 +1,142 @@\n+package org.apache.bookkeeper.sasl;\n+\n+import java.io.File;\n+import java.util.Arrays;\n+import org.apache.bookkeeper.client.*;\n+import java.util.Enumeration;\n+\n+/*\n+*\n+* Licensed to the Apache Software Foundation (ASF) under one\n+* or more contributor license agreements.  See the NOTICE file\n+* distributed with this work for additional information\n+* regarding copyright ownership.  The ASF licenses this file\n+* to you under the Apache License, Version 2.0 (the\n+* \"License\"); you may not use this file except in compliance\n+* with the License.  You may obtain a copy of the License at\n+*\n+*   http://www.apache.org/licenses/LICENSE-2.0\n+*\n+* Unless required by applicable law or agreed to in writing,\n+* software distributed under the License is distributed on an\n+* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+* KIND, either express or implied.  See the License for the\n+* specific language governing permissions and limitations\n+* under the License.\n+*\n+ */\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.security.auth.login.Configuration;\n+\n+import org.apache.bookkeeper.conf.ClientConfiguration;\n+import org.apache.bookkeeper.client.BookKeeper.DigestType;\n+import org.apache.bookkeeper.conf.ServerConfiguration;\n+import org.apache.bookkeeper.proto.BookieServer;\n+import static org.apache.bookkeeper.sasl.SaslConstants.JAAS_CLIENT_ALLOWED_IDS;\n+import org.apache.bookkeeper.test.BookKeeperClusterTestCase;\n+import org.junit.AfterClass;\n+\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.junit.Assert.*;\n+\n+public class MD5DigestBookKeeperTest extends BookKeeperClusterTestCase {\n+\n+    static final Logger LOG = LoggerFactory.getLogger(MD5DigestBookKeeperTest.class);\n+\n+    private static final byte[] PASSWD = \"testPasswd\".getBytes();\n+    private static final byte[] ENTRY = \"TestEntry\".getBytes();\n+\n+    static {\n+        System.setProperty(\"java.security.auth.login.config\", new File(\"src/test/resources/jaas_md5.conf\").getAbsolutePath());\n+    }\n+\n+    public MD5DigestBookKeeperTest() {\n+        super(0); // start them later when auth providers are configured\n+    }\n+\n+    // we pass in ledgerId because the method may throw exceptions\n+    private void connectAndWriteToBookie(ClientConfiguration conf, AtomicLong ledgerWritten)\n+        throws Exception {\n+        LOG.info(\"Connecting to bookie\");\n+        BookKeeper bkc = new BookKeeper(conf, zkc);\n+        LedgerHandle l = bkc.createLedger(1, 1, DigestType.CRC32,\n+            PASSWD);\n+        ledgerWritten.set(l.getId());\n+        l.addEntry(ENTRY);\n+        l.close();\n+        bkc.close();\n+    }\n+\n+    /**\n+     * check if the entry exists. Restart the bookie to allow access\n+     */\n+    private int entryCount(long ledgerId, ServerConfiguration bookieConf,\n+        ClientConfiguration clientConf) throws Exception {\n+        LOG.info(\"Counting entries in {}\", ledgerId);\n+        for (ServerConfiguration conf : bsConfs) {\n+            bookieConf.setBookieAuthProviderFactoryClass(\n+                SASLBookieAuthProviderFactory.class.getName());\n+            bookieConf.setProperty(JAAS_CLIENT_ALLOWED_IDS, \".*hd.*\");\n+        }\n+        clientConf.setClientAuthProviderFactoryClass(\n+            SASLClientProviderFactory.class.getName());\n+\n+        restartBookies();\n+\n+        try (BookKeeper bkc = new BookKeeper(clientConf, zkc);\n+            LedgerHandle lh = bkc.openLedger(ledgerId, DigestType.CRC32,\n+                PASSWD);) {\n+\n+            if (lh.getLastAddConfirmed() < 0) {\n+                return 0;\n+            }\n+            Enumeration<LedgerEntry> e = lh.readEntries(0, lh.getLastAddConfirmed());\n+            int count = 0;\n+            while (e.hasMoreElements()) {\n+                count++;\n+                assertTrue(\"Should match what we wrote\",\n+                    Arrays.equals(e.nextElement().getEntry(), ENTRY));\n+            }\n+            return count;\n+        }\n+    }\n+\n+    /**\n+     * Test an connection will authorize with a single message to the server and a single response.\n+     */\n+    @Test(timeout = 30000)\n+    public void testSingleMessageAuth() throws Exception {\n+        ServerConfiguration bookieConf = newServerConfiguration();\n+        bookieConf.setBookieAuthProviderFactoryClass(\n+            SASLBookieAuthProviderFactory.class.getName());\n+        bookieConf.setProperty(JAAS_CLIENT_ALLOWED_IDS, \".*hd.*\");\n+\n+        ClientConfiguration clientConf = newClientConfiguration();\n+        clientConf.setClientAuthProviderFactoryClass(\n+            SASLClientProviderFactory.class.getName());\n+\n+        startAndStoreBookie(bookieConf);\n+\n+        AtomicLong ledgerId = new AtomicLong(-1);\n+        connectAndWriteToBookie(clientConf, ledgerId); // should succeed\n+\n+        assertFalse(ledgerId.get() == -1);\n+        assertEquals(\"Should have entry\", 1, entryCount(ledgerId.get(), bookieConf, clientConf));\n+    }\n+\n+    BookieServer startAndStoreBookie(ServerConfiguration conf) throws Exception {\n+        bsConfs.add(conf);\n+        BookieServer s = startBookie(conf);\n+        bs.add(s);\n+        return s;\n+    }\n+\n+    @AfterClass\n+    public static void resetJAAS() {\n+        System.clearProperty(\"java.security.auth.login.config\");\n+        Configuration.getConfiguration().refresh();\n+    }\n+}"},{"sha":"060c8255fc918a560d63f5085499f260e4592b14","filename":"bookkeeper-server/src/test/resources/jaas_md5.conf","status":"added","additions":30,"deletions":0,"changes":30,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/667390d1a6305c31608130929ba0d68a0b5a4763/bookkeeper-server%2Fsrc%2Ftest%2Fresources%2Fjaas_md5.conf","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/667390d1a6305c31608130929ba0d68a0b5a4763/bookkeeper-server%2Fsrc%2Ftest%2Fresources%2Fjaas_md5.conf","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fresources%2Fjaas_md5.conf?ref=667390d1a6305c31608130929ba0d68a0b5a4763","patch":"@@ -0,0 +1,30 @@\n+/*\n+* Copyright 2016 The Apache Software Foundation\n+*\n+* Licensed to the Apache Software Foundation (ASF) under one\n+* or more contributor license agreements.  See the NOTICE file\n+* distributed with this work for additional information\n+* regarding copyright ownership.  The ASF licenses this file\n+* to you under the Apache License, Version 2.0 (the\n+* \"License\"); you may not use this file except in compliance\n+* with the License.  You may obtain a copy of the License at\n+*\n+*     http://www.apache.org/licenses/LICENSE-2.0\n+*\n+* Unless required by applicable law or agreed to in writing, software\n+* distributed under the License is distributed on an \"AS IS\" BASIS,\n+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+* See the License for the specific language governing permissions and\n+* limitations under the License.\n+*/\n+\n+Bookie {\n+       org.apache.zookeeper.server.auth.DigestLoginModule required\n+       user_hd=\"testpwd\";\n+};\n+\n+BookKeeper {\n+       org.apache.zookeeper.server.auth.DigestLoginModule required\n+       username=\"hd\"\n+       password=\"testpwd\";\n+};"}]}