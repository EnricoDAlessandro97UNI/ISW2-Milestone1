{"sha":"5fe86525a9c823f79b3e97fd82ea4aa1c75c79eb","node_id":"MDY6Q29tbWl0NDc4NTkyNTI2OjVmZTg2NTI1YTljODIzZjc5YjNlOTdmZDgyZWE0YWExYzc1Yzc5ZWI=","commit":{"author":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2017-06-05T20:13:31Z"},"committer":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2017-06-05T20:13:31Z"},"message":"BOOKKEEPER-1088: Ledger Recovery (part-3) - Add a ReadEntryListener to callback on individual request\n\nTHIS CHANGE IS BASED ON #177  (you can review 868a3c8 for the only change that belongs to BOOKKEEPER-1088).\n\nbookkeeper recovery improvement (part-3): add a ReadEntryListener to callback on individual request.\n\n- add read entry listener which allow doing batch read, but callback on individual entries in sequence. so in recovery op, we could issue batch reads, then on each individual callback do add entry and stop when received NoSuchEntry.\n\nAuthor: Sijie Guo <sijie@apache.org>\nAuthor: Sijie Guo <sijieg@twitter.com>\n\nReviewers: Enrico Olivelli <eolivelli@gmail.com>, Jia Zhai <None>, Venkateswararao Jujjuri (JV) <None>\n\nCloses #178 from sijie/recovery_improvements_part3 and squashes the following commits:\n\ndd24faf [Sijie Guo] Merge branch 'master' into recovery_improvements_part3\n2e1ebb9 [Sijie Guo] Merge branch 'master' into recovery_improvements_part3\n8b8a3c8 [Sijie Guo] bookkeeper recovery improvement (part-3): add a ReadEntryListener to callback on individual request.\ndb3e98b [Sijie Guo] Address conflicts\nf0fb89c [Sijie Guo] bookkeeper recovery improvement (part-2): add a parallel reading request in PendingReadOp\n80ffc6c [Sijie Guo] Address conflicts\n3db0b84 [Sijie Guo] bookkeeper recovery improvement (part-1): refactor PendingReadOp","tree":{"sha":"e577a16bd6819c71479cc142d8ef97c310549d2c","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/trees/e577a16bd6819c71479cc142d8ef97c310549d2c"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/commits/5fe86525a9c823f79b3e97fd82ea4aa1c75c79eb","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/5fe86525a9c823f79b3e97fd82ea4aa1c75c79eb","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/5fe86525a9c823f79b3e97fd82ea4aa1c75c79eb","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/5fe86525a9c823f79b3e97fd82ea4aa1c75c79eb/comments","author":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"committer":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"parents":[{"sha":"b3b958c2b6a7195b23477d181db3fea1e7d1c248","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/b3b958c2b6a7195b23477d181db3fea1e7d1c248","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/b3b958c2b6a7195b23477d181db3fea1e7d1c248"}],"stats":{"total":433,"additions":423,"deletions":10},"files":[{"sha":"69221d0c760a21f72ed8dc160da39f03b262ccaf","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ListenerBasedPendingReadOp.java","status":"added","additions":70,"deletions":0,"changes":70,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/5fe86525a9c823f79b3e97fd82ea4aa1c75c79eb/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FListenerBasedPendingReadOp.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/5fe86525a9c823f79b3e97fd82ea4aa1c75c79eb/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FListenerBasedPendingReadOp.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FListenerBasedPendingReadOp.java?ref=5fe86525a9c823f79b3e97fd82ea4aa1c75c79eb","patch":"@@ -0,0 +1,70 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.client;\n+\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ReadEntryListener;\n+import org.apache.bookkeeper.util.MathUtils;\n+\n+class ListenerBasedPendingReadOp extends PendingReadOp {\n+\n+    final ReadEntryListener listener;\n+\n+    ListenerBasedPendingReadOp(LedgerHandle lh, ScheduledExecutorService scheduler,\n+                               long startEntryId, long endEntryId,\n+                               ReadEntryListener listener, Object ctx) {\n+        super(lh, scheduler, startEntryId, endEntryId, null, ctx);\n+        this.listener = listener;\n+    }\n+\n+    @Override\n+    protected void submitCallback(int code) {\n+        LedgerEntryRequest request;\n+        while ((request = seq.peek()) != null) {\n+            if (!request.isComplete()) {\n+                return;\n+            }\n+            seq.remove();\n+            long latencyNanos = MathUtils.elapsedNanos(requestTimeNanos);\n+            if (BKException.Code.OK == request.getRc()) {\n+                readOpLogger.registerSuccessfulEvent(latencyNanos, TimeUnit.NANOSECONDS);\n+            } else {\n+                readOpLogger.registerFailedEvent(latencyNanos, TimeUnit.NANOSECONDS);\n+            }\n+            // callback with completed entry\n+            listener.onEntryComplete(request.getRc(), lh, request, ctx);\n+        }\n+        // if all entries are already completed.\n+        cancelSpeculativeTask(true);\n+    }\n+\n+    @Override\n+    public boolean hasMoreElements() {\n+        return false;\n+    }\n+\n+    @Override\n+    public LedgerEntry nextElement() throws NoSuchElementException {\n+        throw new NoSuchElementException();\n+    }\n+}"},{"sha":"6f97b9bbc2859786d44bd5a2a128fb455d2488ac","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingReadOp.java","status":"modified","additions":28,"deletions":10,"changes":38,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/5fe86525a9c823f79b3e97fd82ea4aa1c75c79eb/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FPendingReadOp.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/5fe86525a9c823f79b3e97fd82ea4aa1c75c79eb/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FPendingReadOp.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FPendingReadOp.java?ref=5fe86525a9c823f79b3e97fd82ea4aa1c75c79eb","patch":"@@ -78,6 +78,7 @@ abstract class LedgerEntryRequest extends LedgerEntry {\n \n         final AtomicBoolean complete = new AtomicBoolean(false);\n \n+        int rc = BKException.Code.OK;\n         int firstError = BKException.Code.OK;\n         int numMissedEntryReads = 0;\n \n@@ -117,6 +118,7 @@ boolean complete(BookieSocketAddress host, final ByteBuf buffer) {\n             }\n \n             if (!complete.getAndSet(true)) {\n+                rc = BKException.Code.OK;\n                 /*\n                  * The length is a long and it is the last field of the metadata of an entry.\n                  * Consequently, we have to subtract 8 from METADATA_LENGTH to get the length.\n@@ -139,6 +141,7 @@ boolean complete(BookieSocketAddress host, final ByteBuf buffer) {\n          */\n         boolean fail(int rc) {\n             if (complete.compareAndSet(false, true)) {\n+                this.rc = rc;\n                 submitCallback(rc);\n                 return true;\n             } else {\n@@ -203,6 +206,15 @@ boolean isComplete() {\n             return complete.get();\n         }\n \n+        /**\n+         * Get result code of this entry.\n+         *\n+         * @return result code.\n+         */\n+        int getRc() {\n+            return rc;\n+        }\n+\n         @Override\n         public String toString() {\n             return String.format(\"L%d-E%d\", ledgerId, entryId);\n@@ -404,7 +416,7 @@ protected LedgerMetadata getLedgerMetadata() {\n         return lh.metadata;\n     }\n \n-    private void cancelSpeculativeTask(boolean mayInterruptIfRunning) {\n+    protected void cancelSpeculativeTask(boolean mayInterruptIfRunning) {\n         if (speculativeTask != null) {\n             speculativeTask.cancel(mayInterruptIfRunning);\n             speculativeTask = null;\n@@ -470,9 +482,11 @@ public void run() {\n             }\n             seq.add(entry);\n             i++;\n-\n-            entry.read();\n         } while (i <= endEntryId);\n+        // read the entries.\n+        for (LedgerEntryRequest entry : seq) {\n+            entry.read();\n+        }\n     }\n \n     private static class ReadContext {\n@@ -507,19 +521,23 @@ public void readEntryComplete(int rc, long ledgerId, final long entryId, final B\n         heardFromHosts.add(rctx.to);\n \n         if (entry.complete(rctx.to, buffer)) {\n-            numPendingEntries--;\n-            if (numPendingEntries == 0) {\n-                submitCallback(BKException.Code.OK);\n-            }\n+            submitCallback(BKException.Code.OK);\n         }\n \n         if(numPendingEntries < 0)\n             LOG.error(\"Read too many values\");\n     }\n \n-    private void submitCallback(int code) {\n-        if (cb == null) {\n-            // Callback had already been triggered before\n+    protected void submitCallback(int code) {\n+        if (BKException.Code.OK == code) {\n+            numPendingEntries--;\n+            if (numPendingEntries != 0) {\n+                return;\n+            }\n+        }\n+\n+        // ensure callback once\n+        if (!complete.compareAndSet(false, true)) {\n             return;\n         }\n "},{"sha":"ddea8b7056b16d654ad49762806a24a3d6a21e5e","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookkeeperInternalCallbacks.java","status":"modified","additions":21,"deletions":0,"changes":21,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/5fe86525a9c823f79b3e97fd82ea4aa1c75c79eb/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookkeeperInternalCallbacks.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/5fe86525a9c823f79b3e97fd82ea4aa1c75c79eb/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookkeeperInternalCallbacks.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookkeeperInternalCallbacks.java?ref=5fe86525a9c823f79b3e97fd82ea4aa1c75c79eb","patch":"@@ -26,6 +26,8 @@\n import java.util.concurrent.LinkedBlockingQueue;\n import java.util.concurrent.atomic.AtomicInteger;\n \n+import org.apache.bookkeeper.client.LedgerEntry;\n+import org.apache.bookkeeper.client.LedgerHandle;\n import org.apache.bookkeeper.client.LedgerMetadata;\n import org.apache.bookkeeper.client.BookieInfoReader.BookieInfo;\n import org.apache.bookkeeper.net.BookieSocketAddress;\n@@ -94,6 +96,25 @@ public interface GetBookieInfoCallback {\n         void getBookieInfoComplete(int rc, BookieInfo bInfo, Object ctx);\n     }\n \n+    /**\n+     * Listener on entries responded.\n+     */\n+    public interface ReadEntryListener {\n+        /**\n+         * On given <i>entry</i> completed.\n+         *\n+         * @param rc\n+         *          result code of reading this entry.\n+         * @param lh\n+         *          ledger handle.\n+         * @param entry\n+         *          ledger entry.\n+         * @param ctx\n+         *          callback context.\n+         */\n+        void onEntryComplete(int rc, LedgerHandle lh, LedgerEntry entry, Object ctx);\n+    }\n+\n     /**\n      * This is a multi callback object that waits for all of\n      * the multiple async operations to complete. If any fail, then we invoke"},{"sha":"d3ef194d60992e15f4d9514d3eb090a96c35f606","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestReadEntryListener.java","status":"added","additions":304,"deletions":0,"changes":304,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/5fe86525a9c823f79b3e97fd82ea4aa1c75c79eb/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FTestReadEntryListener.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/5fe86525a9c823f79b3e97fd82ea4aa1c75c79eb/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FTestReadEntryListener.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FTestReadEntryListener.java?ref=5fe86525a9c823f79b3e97fd82ea4aa1c75c79eb","patch":"@@ -0,0 +1,304 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.client;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import org.apache.bookkeeper.client.BookKeeper.DigestType;\n+import org.apache.bookkeeper.net.BookieSocketAddress;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ReadEntryListener;\n+import org.apache.bookkeeper.test.BookKeeperClusterTestCase;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.CountDownLatch;\n+\n+/**\n+ * Unit tests for {@link org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ReadEntryListener}.\n+ */\n+public class TestReadEntryListener extends BookKeeperClusterTestCase {\n+\n+    static Logger LOG = LoggerFactory.getLogger(TestReadEntryListener.class);\n+\n+    final DigestType digestType;\n+    final byte[] passwd = \"read-entry-listener\".getBytes();\n+\n+    public TestReadEntryListener() {\n+        super(6);\n+        this.digestType = DigestType.CRC32;\n+    }\n+\n+    long getLedgerToRead(int ensemble, int writeQuorum, int ackQuorum, int numEntries)\n+            throws Exception {\n+        LedgerHandle lh = bkc.createLedger(ensemble, writeQuorum, ackQuorum, digestType, passwd);\n+        for (int i = 0; i < numEntries; i++) {\n+            lh.addEntry((\"\" + i).getBytes());\n+        }\n+        lh.close();\n+        return lh.getId();\n+    }\n+\n+    static class EntryWithRC {\n+        final LedgerEntry entry;\n+        final int rc;\n+\n+        EntryWithRC(int rc, LedgerEntry entry) {\n+            this.rc = rc;\n+            this.entry = entry;\n+        }\n+    }\n+\n+    static class LatchListener implements ReadEntryListener {\n+\n+        final CountDownLatch l;\n+        final Map<Long, EntryWithRC> resultCodes;\n+        boolean inOrder = true;\n+        long nextEntryId;\n+\n+        LatchListener(long startEntryId, int numEntries) {\n+            l = new CountDownLatch(numEntries);\n+            resultCodes = new HashMap<Long, EntryWithRC>();\n+            this.nextEntryId = startEntryId;\n+        }\n+\n+        @Override\n+        public void onEntryComplete(int rc, LedgerHandle lh, LedgerEntry entry, Object ctx) {\n+            if (nextEntryId != entry.getEntryId()) {\n+                inOrder = false;\n+            }\n+            ++nextEntryId;\n+            resultCodes.put(entry.getEntryId(), new EntryWithRC(rc, entry));\n+            l.countDown();\n+        }\n+\n+        void expectComplete() throws Exception {\n+            l.await();\n+        }\n+\n+        boolean isInOrder() {\n+            return inOrder;\n+        }\n+    }\n+\n+    void basicReadTest(boolean parallelRead) throws Exception {\n+        int numEntries = 10;\n+\n+        long id = getLedgerToRead(5, 2, 2, numEntries);\n+        LedgerHandle lh = bkc.openLedger(id, digestType, passwd);\n+\n+        // read single entry\n+        for (int i = 0; i < numEntries; i++) {\n+            LatchListener listener = new LatchListener(i, 1);\n+            ListenerBasedPendingReadOp readOp =\n+                    new ListenerBasedPendingReadOp(lh, lh.bk.scheduler, i, i, listener, null);\n+            readOp.parallelRead(parallelRead).initiate();\n+            listener.expectComplete();\n+            assertEquals(1, listener.resultCodes.size());\n+            EntryWithRC entry = listener.resultCodes.get((long) i);\n+            assertNotNull(entry);\n+            assertEquals(BKException.Code.OK, entry.rc);\n+            assertEquals(i, Integer.parseInt(new String(entry.entry.getEntry())));\n+            assertTrue(listener.isInOrder());\n+        }\n+\n+        // read multiple entries\n+        LatchListener listener = new LatchListener(0L, numEntries);\n+        ListenerBasedPendingReadOp readOp =\n+                new ListenerBasedPendingReadOp(lh, lh.bk.scheduler, 0, numEntries - 1, listener, null);\n+        readOp.parallelRead(parallelRead).initiate();\n+        listener.expectComplete();\n+        assertEquals(numEntries, listener.resultCodes.size());\n+        for (int i = 0; i < numEntries; i++) {\n+            EntryWithRC entry = listener.resultCodes.get((long) i);\n+            assertNotNull(entry);\n+            assertEquals(BKException.Code.OK, entry.rc);\n+            assertEquals(i, Integer.parseInt(new String(entry.entry.getEntry())));\n+        }\n+        assertTrue(listener.isInOrder());\n+\n+        lh.close();\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testBasicEnableParallelRead() throws Exception {\n+        basicReadTest(true);\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testBasicDisableParallelRead() throws Exception {\n+        basicReadTest(false);\n+    }\n+\n+    private void readMissingEntriesTest(boolean parallelRead) throws Exception {\n+        int numEntries = 10;\n+\n+        long id = getLedgerToRead(5, 2, 2, numEntries);\n+        LedgerHandle lh = bkc.openLedger(id, digestType, passwd);\n+\n+        // read single entry\n+        LatchListener listener = new LatchListener(11L, 1);\n+        ListenerBasedPendingReadOp readOp =\n+                new ListenerBasedPendingReadOp(lh, lh.bk.scheduler, 11, 11, listener, null);\n+        readOp.parallelRead(parallelRead).initiate();\n+        listener.expectComplete();\n+        assertEquals(1, listener.resultCodes.size());\n+        EntryWithRC entry = listener.resultCodes.get(11L);\n+        assertNotNull(entry);\n+        assertEquals(BKException.Code.NoSuchEntryException, entry.rc);\n+        assertTrue(listener.isInOrder());\n+\n+        // read multiple missing entries\n+        listener = new LatchListener(11L, 3);\n+        readOp = new ListenerBasedPendingReadOp(lh, lh.bk.scheduler, 11, 13, listener, null);\n+        readOp.parallelRead(parallelRead).initiate();\n+        listener.expectComplete();\n+        assertEquals(3, listener.resultCodes.size());\n+        assertTrue(listener.isInOrder());\n+\n+        for (int i = 11; i <= 13; i++) {\n+            entry = listener.resultCodes.get((long) i);\n+            assertNotNull(entry);\n+            assertEquals(BKException.Code.NoSuchEntryException, entry.rc);\n+        }\n+\n+        // read multiple entries with missing entries\n+        listener = new LatchListener(5L, 10);\n+        readOp = new ListenerBasedPendingReadOp(lh, lh.bk.scheduler, 5L, 14L, listener, null);\n+        readOp.parallelRead(parallelRead).initiate();\n+        listener.expectComplete();\n+        assertEquals(10, listener.resultCodes.size());\n+        assertTrue(listener.isInOrder());\n+\n+        for (long i = 5L; i <= 14L; i++) {\n+            entry = listener.resultCodes.get(i);\n+            assertNotNull(entry);\n+            if (i < 10L) {\n+                assertEquals(BKException.Code.OK, entry.rc);\n+                assertEquals(i, Integer.parseInt(new String(entry.entry.getEntry())));\n+            } else {\n+                assertEquals(BKException.Code.NoSuchEntryException, entry.rc);\n+            }\n+        }\n+\n+        lh.close();\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testReadMissingEntriesEnableParallelRead() throws Exception {\n+        readMissingEntriesTest(true);\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testReadMissingEntriesDisableParallelRead() throws Exception {\n+        readMissingEntriesTest(false);\n+    }\n+\n+    private void readWithFailedBookiesTest(boolean parallelRead) throws Exception {\n+        int numEntries = 10;\n+\n+        long id = getLedgerToRead(5, 3, 3, numEntries);\n+\n+        LedgerHandle lh = bkc.openLedger(id, digestType, passwd);\n+\n+        ArrayList<BookieSocketAddress> ensemble =\n+                lh.getLedgerMetadata().getEnsemble(5);\n+        // kill two bookies\n+        killBookie(ensemble.get(0));\n+        killBookie(ensemble.get(1));\n+\n+        // read multiple entries\n+        LatchListener listener = new LatchListener(0L, numEntries);\n+        ListenerBasedPendingReadOp readOp =\n+                new ListenerBasedPendingReadOp(lh, lh.bk.scheduler, 0, numEntries - 1, listener, null);\n+        readOp.parallelRead(parallelRead).initiate();\n+        listener.expectComplete();\n+        assertEquals(numEntries, listener.resultCodes.size());\n+        for (int i = 0; i < numEntries; i++) {\n+            EntryWithRC entry = listener.resultCodes.get((long) i);\n+            assertNotNull(entry);\n+            assertEquals(BKException.Code.OK, entry.rc);\n+            assertEquals(i, Integer.parseInt(new String(entry.entry.getEntry())));\n+        }\n+\n+        lh.close();\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testReadWithFailedBookiesEnableParallelRead() throws Exception {\n+        readWithFailedBookiesTest(true);\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testReadWithFailedBookiesDisableParallelRead() throws Exception {\n+        readWithFailedBookiesTest(false);\n+    }\n+\n+    private void readFailureWithFailedBookiesTest(boolean parallelRead) throws Exception {\n+        int numEntries = 10;\n+\n+        long id = getLedgerToRead(5, 3, 3, numEntries);\n+\n+        LedgerHandle lh = bkc.openLedger(id, digestType, passwd);\n+\n+        ArrayList<BookieSocketAddress> ensemble =\n+                lh.getLedgerMetadata().getEnsemble(5);\n+        // kill bookies\n+        killBookie(ensemble.get(0));\n+        killBookie(ensemble.get(1));\n+        killBookie(ensemble.get(2));\n+\n+        // read multiple entries\n+        LatchListener listener = new LatchListener(0L, numEntries);\n+        ListenerBasedPendingReadOp readOp =\n+                new ListenerBasedPendingReadOp(lh, lh.bk.scheduler, 0, numEntries - 1, listener, null);\n+        readOp.parallelRead(parallelRead).initiate();\n+        listener.expectComplete();\n+        assertEquals(numEntries, listener.resultCodes.size());\n+        for (int i = 0; i < numEntries; i++) {\n+            EntryWithRC entry = listener.resultCodes.get((long) i);\n+            assertNotNull(entry);\n+            if (i % 5 == 0) {\n+                assertEquals(BKException.Code.BookieHandleNotAvailableException, entry.rc);\n+            } else {\n+                assertEquals(BKException.Code.OK, entry.rc);\n+                assertEquals(i, Integer.parseInt(new String(entry.entry.getEntry())));\n+            }\n+        }\n+\n+        lh.close();\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testReadFailureWithFailedBookiesEnableParallelRead() throws Exception {\n+        readWithFailedBookiesTest(true);\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testReadFailureWithFailedBookiesDisableParallelRead() throws Exception {\n+        readWithFailedBookiesTest(false);\n+    }\n+}"}]}