{"sha":"7e63cff1c110b7b9435a88ab8ab321659057c298","node_id":"MDY6Q29tbWl0NDc4NTkyNTI2OjdlNjNjZmYxYzExMGI3Yjk0MzVhODhhYjhhYjMyMTY1OTA1N2MyOTg=","commit":{"author":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2017-06-21T17:20:15Z"},"committer":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2017-06-21T17:20:15Z"},"message":"DL-124: Use Java8 Future rather than twitter Future\n\nSwitch to use Java8 CompletableFuture, to reduce dependencies introduced by twitter future and make it more friendly to users (users don't think of using which version of scala).\n\nThis change is based on #132 . Gitsha ce0686e is the change to review.\n\nThe changes:\n\n- Change Future to CompletableFuture\n- Map to thenApply\n- flatMap to thenCompose\n- Added a FutureEventListener, and switch addEvenListener to whenComplete (or whenCompleteAsync)\n- setValue to complete\n- setException to completeExceptionally\n- add rescue, ignore, ensure to FutureUtils as util functions.\n\nAuthor: Sijie Guo <sijie@apache.org>\n\nReviewers: Jia Zhai <None>, Leigh Stewart <lstewart@apache.org>\n\nCloses #133 from sijie/change_twitter_future_to_java_future","tree":{"sha":"ed9bac3b34966d1e1c46260725c759204c581443","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/trees/ed9bac3b34966d1e1c46260725c759204c581443"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/commits/7e63cff1c110b7b9435a88ab8ab321659057c298","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/7e63cff1c110b7b9435a88ab8ab321659057c298","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/7e63cff1c110b7b9435a88ab8ab321659057c298","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/7e63cff1c110b7b9435a88ab8ab321659057c298/comments","author":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"committer":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"parents":[],"stats":{"total":3988,"additions":3988,"deletions":0},"files":[{"sha":"cad2bc88828845e47d05120c8b242f6f25b47795","filename":"pom.xml","status":"added","additions":167,"deletions":0,"changes":167,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/7e63cff1c110b7b9435a88ab8ab321659057c298/pom.xml","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/7e63cff1c110b7b9435a88ab8ab321659057c298/pom.xml","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/pom.xml?ref=7e63cff1c110b7b9435a88ab8ab321659057c298","patch":"@@ -0,0 +1,167 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<!--\n+   Licensed to the Apache Software Foundation (ASF) under one or more\n+   contributor license agreements.  See the NOTICE file distributed with\n+   this work for additional information regarding copyright ownership.\n+   The ASF licenses this file to You under the Apache License, Version 2.0\n+   (the \"License\"); you may not use this file except in compliance with\n+   the License.  You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+-->\n+<project xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\" xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n+  <modelVersion>4.0.0</modelVersion>\n+  <parent>\n+    <groupId>org.apache.distributedlog</groupId>\n+    <artifactId>distributedlog</artifactId>\n+    <version>0.5.0-incubating-SNAPSHOT</version>\n+  </parent>\n+  <artifactId>distributedlog-common</artifactId>\n+  <name>Apache DistributedLog :: Common</name>\n+  <dependencies>\n+    <dependency>\n+      <groupId>org.apache.bookkeeper.stats</groupId>\n+      <artifactId>bookkeeper-stats-api</artifactId>\n+      <version>${bookkeeper.version}</version>\n+      <exclusions>\n+        <exclusion>\n+          <groupId>org.slf4j</groupId>\n+          <artifactId>slf4j-log4j12</artifactId>\n+        </exclusion>\n+      </exclusions>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.slf4j</groupId>\n+      <artifactId>slf4j-api</artifactId>\n+      <version>${slf4j.version}</version>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.projectlombok</groupId>\n+      <artifactId>lombok</artifactId>\n+      <version>${lombok.version}</version>\n+      <scope>provided</scope>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.inferred</groupId>\n+      <artifactId>freebuilder</artifactId>\n+      <version>${freebuilder.version}</version>\n+    </dependency>\n+    <dependency>\n+      <groupId>com.google.guava</groupId>\n+      <artifactId>guava</artifactId>\n+      <version>${guava.version}</version>\n+    </dependency>\n+    <dependency>\n+      <groupId>commons-lang</groupId>\n+      <artifactId>commons-lang</artifactId>\n+      <version>${commons-lang.version}</version>\n+    </dependency>\n+    <dependency>\n+      <groupId>commons-codec</groupId>\n+      <artifactId>commons-codec</artifactId>\n+      <version>${commons-codec.version}</version>\n+    </dependency>\n+    <dependency>\n+      <groupId>junit</groupId>\n+      <artifactId>junit</artifactId>\n+      <version>${junit.version}</version>\n+      <scope>test</scope>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.slf4j</groupId>\n+      <artifactId>slf4j-log4j12</artifactId>\n+      <version>${slf4j.version}</version>\n+      <scope>test</scope>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.mockito</groupId>\n+      <artifactId>mockito-core</artifactId>\n+      <version>${mockito.version}</version>\n+      <scope>test</scope>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.jmock</groupId>\n+      <artifactId>jmock</artifactId>\n+      <version>${jmock.version}</version>\n+      <scope>test</scope>\n+    </dependency>\n+  </dependencies>\n+  <build>\n+    <plugins>\n+      <plugin>\n+        <groupId>org.codehaus.mojo</groupId>\n+        <artifactId>findbugs-maven-plugin</artifactId>\n+        <configuration>\n+          <excludeFilterFile>${basedir}/src/main/resources/findbugsExclude.xml</excludeFilterFile>\n+        </configuration>\n+      </plugin>\n+      <plugin>\n+        <artifactId>maven-compiler-plugin</artifactId>\n+        <version>${maven-compiler-plugin.version}</version>\n+      </plugin>\n+      <plugin>\n+        <groupId>org.apache.maven.plugins</groupId>\n+        <artifactId>maven-jar-plugin</artifactId>\n+        <version>${maven-jar-plugin.version}</version>\n+        <executions>\n+          <execution>\n+            <goals>\n+              <goal>test-jar</goal>\n+            </goals>\n+          </execution>\n+        </executions>\n+      </plugin>\n+      <plugin>\n+        <groupId>org.apache.maven.plugins</groupId>\n+        <artifactId>maven-surefire-plugin</artifactId>\n+        <version>${maven-surefire-plugin.version}</version>\n+        <configuration>\n+          <redirectTestOutputToFile>true</redirectTestOutputToFile>\n+          <argLine>-Xmx3G -Djava.net.preferIPv4Stack=true -XX:MaxDirectMemorySize=2G</argLine>\n+          <forkMode>always</forkMode>\n+          <forkedProcessTimeoutInSeconds>1800</forkedProcessTimeoutInSeconds>\n+        </configuration>\n+      </plugin>\n+      <plugin>\n+        <groupId>org.apache.maven.plugins</groupId>\n+        <artifactId>maven-checkstyle-plugin</artifactId>\n+        <version>${maven-checkstyle-plugin.version}</version>\n+        <dependencies>\n+          <dependency>\n+            <groupId>com.puppycrawl.tools</groupId>\n+            <artifactId>checkstyle</artifactId>\n+            <version>${puppycrawl.checkstyle.version}</version>\n+          </dependency>\n+          <dependency>\n+            <groupId>org.apache.distributedlog</groupId>\n+            <artifactId>distributedlog-build-tools</artifactId>\n+            <version>${project.version}</version>\n+          </dependency>\n+        </dependencies>\n+        <configuration>\n+          <configLocation>distributedlog/checkstyle.xml</configLocation>\n+          <suppressionsLocation>distributedlog/suppressions.xml</suppressionsLocation>\n+          <consoleOutput>true</consoleOutput>\n+          <failOnViolation>true</failOnViolation>\n+          <includeResources>false</includeResources>\n+          <includeTestSourceDirectory>true</includeTestSourceDirectory>\n+        </configuration>\n+        <executions>\n+          <execution>\n+            <phase>test-compile</phase>\n+            <goals>\n+              <goal>check</goal>\n+            </goals>\n+          </execution>\n+        </executions>\n+      </plugin>\n+    </plugins>\n+  </build>\n+</project>"},{"sha":"a5144b89f129deb0201646584a18a90027711b97","filename":"src/main/java/org/apache/distributedlog/common/annotations/DistributedLogAnnotations.java","status":"added","additions":35,"deletions":0,"changes":35,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Fannotations%2FDistributedLogAnnotations.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Fannotations%2FDistributedLogAnnotations.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Fannotations%2FDistributedLogAnnotations.java?ref=7e63cff1c110b7b9435a88ab8ab321659057c298","patch":"@@ -0,0 +1,35 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.distributedlog.common.annotations;\n+\n+/**\n+ * Common annotation types.\n+ */\n+public class DistributedLogAnnotations {\n+    /**\n+     * Annotation to identify flaky tests in DistributedLog.\n+     * As and when we find that a test is flaky, we'll add this annotation to it for reference.\n+     */\n+    public @interface FlakyTest {}\n+\n+    /**\n+     * Annotation to specify the occurrence of a compression operation. These are CPU intensive\n+     * and should be avoided in low-latency paths.\n+     */\n+    public @interface Compression {}\n+}"},{"sha":"a39070006f121aa0935368e0aaf793c835194360","filename":"src/main/java/org/apache/distributedlog/common/annotations/package-info.java","status":"added","additions":21,"deletions":0,"changes":21,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Fannotations%2Fpackage-info.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Fannotations%2Fpackage-info.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Fannotations%2Fpackage-info.java?ref=7e63cff1c110b7b9435a88ab8ab321659057c298","patch":"@@ -0,0 +1,21 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+/**\n+ * Defines annotations used across distributedlog project.\n+ */\n+package org.apache.distributedlog.common.annotations;"},{"sha":"d6a9b34a768693363d3e8a55125ba7b19422a2bf","filename":"src/main/java/org/apache/distributedlog/common/concurrent/AsyncSemaphore.java","status":"added","additions":160,"deletions":0,"changes":160,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Fconcurrent%2FAsyncSemaphore.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Fconcurrent%2FAsyncSemaphore.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Fconcurrent%2FAsyncSemaphore.java?ref=7e63cff1c110b7b9435a88ab8ab321659057c298","patch":"@@ -0,0 +1,160 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.distributedlog.common.concurrent;\n+\n+import java.util.LinkedList;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.RejectedExecutionException;\n+import java.util.function.Supplier;\n+import javax.annotation.concurrent.GuardedBy;\n+import org.apache.distributedlog.common.util.Permit;\n+\n+/**\n+ * An AsyncSemaphore is a traditional semaphore but with asynchronous\n+ * execution.\n+ *\n+ * <p>Grabbing a permit returns a `Future[Permit]`.\n+ *\n+ * <p>Basic usage:\n+ * {{{\n+ *   val semaphore = new AsyncSemaphore(n)\n+ *   ...\n+ *   semaphore.acquireAndRun() {\n+ *     somethingThatReturnsFutureT()\n+ *   }\n+ * }}}\n+ *\n+ * <p>Calls to acquire() and acquireAndRun are serialized, and tickets are\n+ * given out fairly (in order of arrival).\n+ */\n+public class AsyncSemaphore {\n+\n+    private final Optional<Integer> maxWaiters;\n+\n+    private final Permit semaphorePermit = new Permit() {\n+        @Override\n+        public void release() {\n+            releasePermit(this);\n+        }\n+    };\n+\n+    @GuardedBy(\"this\")\n+    private Optional<Throwable> closed = Optional.empty();\n+    @GuardedBy(\"this\")\n+    private final LinkedList<CompletableFuture<Permit>> waitq;\n+    @GuardedBy(\"this\")\n+    private int availablePermits;\n+\n+    public AsyncSemaphore(int initialPermits,\n+                          Optional<Integer> maxWaiters) {\n+        this.availablePermits = initialPermits;\n+        this.waitq = new LinkedList<>();\n+        this.maxWaiters = maxWaiters;\n+    }\n+\n+    private synchronized void releasePermit(Permit permit) {\n+        CompletableFuture<Permit> next = waitq.pollFirst();\n+        if (null != next) {\n+            next.complete(permit);\n+        } else {\n+            availablePermits += 1;\n+        }\n+    }\n+\n+    private CompletableFuture<Permit> newFuturePermit() {\n+        return FutureUtils.value(semaphorePermit);\n+    }\n+\n+    /**\n+     * Acquire a [[Permit]], asynchronously.\n+     *\n+     * <p>Be sure to `permit.release()` in a\n+     * - `finally` block of your `onSuccess` callback\n+     * - `ensure` block of your future chain\n+     *\n+     * <p>Interrupting this future is only advisory, and will not release the permit\n+     * if the future has already been satisfied.\n+     *\n+     * @note This method always return the same instance of [[Permit]].\n+     * @return a `Future[Permit]` when the `Future` is satisfied, computation can proceed,\n+     *         or a Future.Exception[RejectedExecutionException]` if the configured maximum\n+     *         number of waiters would be exceeded.\n+     */\n+    public synchronized CompletableFuture<Permit> acquire() {\n+        if (closed.isPresent()) {\n+            return FutureUtils.exception(closed.get());\n+        }\n+\n+        if (availablePermits > 0) {\n+            availablePermits -= 1;\n+            return newFuturePermit();\n+        } else {\n+            if (maxWaiters.isPresent() && waitq.size() >= maxWaiters.get()) {\n+                return FutureUtils.exception(new RejectedExecutionException(\"Max waiters exceeded\"));\n+            } else {\n+                CompletableFuture<Permit> future = FutureUtils.createFuture();\n+                future.whenComplete((value, cause) -> {\n+                    synchronized (AsyncSemaphore.this) {\n+                        waitq.remove(future);\n+                    }\n+                });\n+                waitq.addLast(future);\n+                return future;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Fail the semaphore and stop it from distributing further permits. Subsequent\n+     * attempts to acquire a permit fail with `exc`. This semaphore's queued waiters\n+     * are also failed with `exc`.\n+     */\n+    public synchronized void fail(Throwable exc) {\n+        closed = Optional.of(exc);\n+        for (CompletableFuture<Permit> future : waitq) {\n+            future.cancel(true);\n+        }\n+        waitq.clear();\n+    }\n+\n+    /**\n+     * Execute the function asynchronously when a permit becomes available.\n+     *\n+     * <p>If the function throws a non-fatal exception, the exception is returned as part of the Future.\n+     * For all exceptions, the permit would be released before returning.\n+     *\n+     * @return a Future[T] equivalent to the return value of the input function. If the configured\n+     *         maximum value of waitq is reached, Future.Exception[RejectedExecutionException] is\n+     *         returned.\n+     */\n+    public <T> CompletableFuture<T> acquireAndRun(Supplier<CompletableFuture<T>> func) {\n+        return acquire().thenCompose(permit -> {\n+            CompletableFuture<T> future;\n+            try {\n+                future = func.get();\n+                future.whenComplete((value, cause) -> permit.release());\n+                return future;\n+            } catch (Throwable cause) {\n+                permit.release();\n+                throw cause;\n+            }\n+        });\n+    }\n+\n+}"},{"sha":"ed5b9ac2ef13e6c89e43f0e3488d7171c31776f2","filename":"src/main/java/org/apache/distributedlog/common/concurrent/FutureEventListener.java","status":"added","additions":44,"deletions":0,"changes":44,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Fconcurrent%2FFutureEventListener.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Fconcurrent%2FFutureEventListener.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Fconcurrent%2FFutureEventListener.java?ref=7e63cff1c110b7b9435a88ab8ab321659057c298","patch":"@@ -0,0 +1,44 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.distributedlog.common.concurrent;\n+\n+import java.util.concurrent.CompletionException;\n+import java.util.function.BiConsumer;\n+\n+/**\n+ * Provide similar interface (as twitter future) over java future.\n+ */\n+public interface FutureEventListener<T> extends BiConsumer<T, Throwable> {\n+\n+  void onSuccess(T value);\n+\n+  void onFailure(Throwable cause);\n+\n+  @Override\n+  default void accept(T t, Throwable throwable) {\n+    if (null != throwable) {\n+      if (throwable instanceof CompletionException && null != throwable.getCause()) {\n+        onFailure(throwable.getCause());\n+      } else {\n+        onFailure(throwable);\n+      }\n+      return;\n+    }\n+    onSuccess(t);\n+  }\n+}"},{"sha":"15ecf1d14e192ef683b5905d8ae5f876e68bce1f","filename":"src/main/java/org/apache/distributedlog/common/concurrent/FutureUtils.java","status":"added","additions":376,"deletions":0,"changes":376,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Fconcurrent%2FFutureUtils.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Fconcurrent%2FFutureUtils.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Fconcurrent%2FFutureUtils.java?ref=7e63cff1c110b7b9435a88ab8ab321659057c298","patch":"@@ -0,0 +1,376 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.distributedlog.common.concurrent;\n+\n+import com.google.common.base.Stopwatch;\n+import com.google.common.collect.Lists;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.BiConsumer;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.bookkeeper.stats.OpStatsLogger;\n+import org.apache.distributedlog.common.stats.OpStatsListener;\n+import org.apache.distributedlog.util.OrderedScheduler;\n+\n+/**\n+ * Future related utils.\n+ */\n+@Slf4j\n+public final class FutureUtils {\n+\n+    private FutureUtils() {}\n+\n+    private static final Function<Throwable, Exception> DEFAULT_EXCEPTION_HANDLER = cause -> {\n+        if (cause instanceof Exception) {\n+            return (Exception) cause;\n+        } else {\n+            return new Exception(cause);\n+        }\n+    };\n+\n+    public static CompletableFuture<Void> Void() {\n+        return value(null);\n+    }\n+\n+    public static <T> T result(CompletableFuture<T> future) throws Exception {\n+        return FutureUtils.result(future, DEFAULT_EXCEPTION_HANDLER);\n+    }\n+\n+    public static <T> T result(CompletableFuture<T> future, long timeout, TimeUnit timeUnit) throws Exception {\n+        return FutureUtils.result(future, DEFAULT_EXCEPTION_HANDLER, timeout, timeUnit);\n+    }\n+\n+    @SneakyThrows(InterruptedException.class)\n+    public static <T, ExceptionT extends Throwable> T result(\n+        CompletableFuture<T> future, Function<Throwable, ExceptionT> exceptionHandler) throws ExceptionT {\n+        try {\n+            return future.get();\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+            throw e;\n+        } catch (ExecutionException e) {\n+            ExceptionT cause = exceptionHandler.apply(e.getCause());\n+            if (null == cause) {\n+                return null;\n+            } else {\n+                throw cause;\n+            }\n+        }\n+    }\n+\n+    @SneakyThrows(InterruptedException.class)\n+    public static <T, ExceptionT extends Throwable> T result(\n+        CompletableFuture<T> future,\n+        Function<Throwable, ExceptionT> exceptionHandler,\n+        long timeout,\n+        TimeUnit timeUnit) throws ExceptionT, TimeoutException {\n+        try {\n+            return future.get(timeout, timeUnit);\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+            throw e;\n+        } catch (ExecutionException e) {\n+            ExceptionT cause = exceptionHandler.apply(e.getCause());\n+            if (null == cause) {\n+                return null;\n+            } else {\n+                throw cause;\n+            }\n+        }\n+    }\n+\n+    public static <T> CompletableFuture<T> createFuture() {\n+        return new CompletableFuture<T>();\n+    }\n+\n+    public static <T> CompletableFuture<T> value(T value) {\n+        return CompletableFuture.completedFuture(value);\n+    }\n+\n+    public static <T> CompletableFuture<T> exception(Throwable cause) {\n+        CompletableFuture<T> future = FutureUtils.createFuture();\n+        future.completeExceptionally(cause);\n+        return future;\n+    }\n+\n+    public static <T> void complete(CompletableFuture<T> result,\n+                                    T value) {\n+        if (null == result) {\n+            return;\n+        }\n+        result.complete(value);\n+    }\n+\n+    public static <T> void completeExceptionally(CompletableFuture<T> result,\n+                                                 Throwable cause) {\n+        if (null == result) {\n+            return;\n+        }\n+        result.completeExceptionally(cause);\n+    }\n+\n+    /**\n+     * Completing the {@code future} in the thread in the scheduler identified by\n+     * the {@code scheduleKey}.\n+     *\n+     * @param future      future to complete\n+     * @param action      action to execute when complete\n+     * @param scheduler   scheduler to execute the action.\n+     * @param scheduleKey key to choose the thread to execute the action\n+     * @param <T>\n+     * @return\n+     */\n+    public static <T> CompletableFuture<T> whenCompleteAsync(\n+        CompletableFuture<T> future,\n+        BiConsumer<? super T, ? super Throwable> action,\n+        OrderedScheduler scheduler,\n+        Object scheduleKey) {\n+        return future.whenCompleteAsync(action, scheduler.chooseExecutor(scheduleKey));\n+    }\n+\n+    public static <T> CompletableFuture<List<T>> collect(List<CompletableFuture<T>> futureList) {\n+        CompletableFuture<Void> finalFuture =\n+            CompletableFuture.allOf(futureList.toArray(new CompletableFuture[futureList.size()]));\n+        return finalFuture.thenApply(result ->\n+            futureList\n+                .stream()\n+                .map(CompletableFuture::join)\n+                .collect(Collectors.toList()));\n+    }\n+\n+    public static <T> void proxyTo(CompletableFuture<T> src,\n+                                   CompletableFuture<T> target) {\n+        src.whenComplete((value, cause) -> {\n+            if (null == cause) {\n+                target.complete(value);\n+            } else {\n+                target.completeExceptionally(cause);\n+            }\n+        });\n+    }\n+\n+    //\n+    // Process futures\n+    //\n+\n+    private static class ListFutureProcessor<T, R>\n+        implements FutureEventListener<R>, Runnable {\n+\n+        private volatile boolean done = false;\n+        private final Iterator<T> itemsIter;\n+        private final Function<T, CompletableFuture<R>> processFunc;\n+        private final CompletableFuture<List<R>> promise;\n+        private final List<R> results;\n+        private final ExecutorService callbackExecutor;\n+\n+        ListFutureProcessor(List<T> items,\n+                            Function<T, CompletableFuture<R>> processFunc,\n+                            ExecutorService callbackExecutor) {\n+            this.itemsIter = items.iterator();\n+            this.processFunc = processFunc;\n+            this.promise = new CompletableFuture<>();\n+            this.results = Lists.newArrayListWithExpectedSize(items.size());\n+            this.callbackExecutor = callbackExecutor;\n+        }\n+\n+        @Override\n+        public void onSuccess(R value) {\n+            results.add(value);\n+            if (null == callbackExecutor) {\n+                run();\n+            } else {\n+                callbackExecutor.submit(this);\n+            }\n+        }\n+\n+        @Override\n+        public void onFailure(final Throwable cause) {\n+            done = true;\n+\n+            if (null == callbackExecutor) {\n+                promise.completeExceptionally(cause);\n+            } else {\n+                callbackExecutor.submit(new Runnable() {\n+                    @Override\n+                    public void run() {\n+                        promise.completeExceptionally(cause);\n+                    }\n+                });\n+            }\n+        }\n+\n+        @Override\n+        public void run() {\n+            if (done) {\n+                log.debug(\"ListFutureProcessor is interrupted.\");\n+                return;\n+            }\n+            if (!itemsIter.hasNext()) {\n+                promise.complete(results);\n+                done = true;\n+                return;\n+            }\n+            processFunc.apply(itemsIter.next()).whenComplete(this);\n+        }\n+    }\n+\n+    /**\n+     * Process the list of items one by one using the process function <i>processFunc</i>.\n+     * The process will be stopped immediately if it fails on processing any one.\n+     *\n+     * @param collection       list of items\n+     * @param processFunc      process function\n+     * @param callbackExecutor executor to process the item\n+     * @return future presents the list of processed results\n+     */\n+    public static <T, R> CompletableFuture<List<R>> processList(List<T> collection,\n+                                                                Function<T, CompletableFuture<R>> processFunc,\n+                                                                @Nullable ExecutorService callbackExecutor) {\n+        ListFutureProcessor<T, R> processor =\n+            new ListFutureProcessor<T, R>(collection, processFunc, callbackExecutor);\n+        if (null != callbackExecutor) {\n+            callbackExecutor.submit(processor);\n+        } else {\n+            processor.run();\n+        }\n+        return processor.promise;\n+    }\n+\n+    /**\n+     * Raise an exception to the <i>promise</i> within a given <i>timeout</i> period.\n+     * If the promise has been satisfied before raising, it won't change the state of the promise.\n+     *\n+     * @param promise   promise to raise exception\n+     * @param timeout   timeout period\n+     * @param unit      timeout period unit\n+     * @param cause     cause to raise\n+     * @param scheduler scheduler to execute raising exception\n+     * @param key       the submit key used by the scheduler\n+     * @return the promise applied with the raise logic\n+     */\n+    public static <T> CompletableFuture<T> within(final CompletableFuture<T> promise,\n+                                                  final long timeout,\n+                                                  final TimeUnit unit,\n+                                                  final Throwable cause,\n+                                                  final OrderedScheduler scheduler,\n+                                                  final Object key) {\n+        if (timeout < 0 || promise.isDone()) {\n+            return promise;\n+        }\n+        // schedule a timeout to raise timeout exception\n+        final java.util.concurrent.ScheduledFuture<?> task = scheduler.schedule(key, new Runnable() {\n+            @Override\n+            public void run() {\n+                if (!promise.isDone() && promise.completeExceptionally(cause)) {\n+                    log.info(\"Raise exception\", cause);\n+                }\n+            }\n+        }, timeout, unit);\n+        // when the promise is satisfied, cancel the timeout task\n+        promise.whenComplete((value, throwable) -> {\n+                if (!task.cancel(true)) {\n+                    log.debug(\"Failed to cancel the timeout task\");\n+                }\n+            }\n+        );\n+        return promise;\n+    }\n+\n+    /**\n+     * Ignore exception from the <i>future</i>.\n+     *\n+     * @param future the original future\n+     * @return a transformed future ignores exceptions\n+     */\n+    public static <T> CompletableFuture<Void> ignore(CompletableFuture<T> future) {\n+        return ignore(future, null);\n+    }\n+\n+    /**\n+     * Ignore exception from the <i>future</i> and log <i>errorMsg</i> on exceptions.\n+     *\n+     * @param future   the original future\n+     * @param errorMsg the error message to log on exceptions\n+     * @return a transformed future ignores exceptions\n+     */\n+    public static <T> CompletableFuture<Void> ignore(CompletableFuture<T> future,\n+                                                     final String errorMsg) {\n+        final CompletableFuture<Void> promise = new CompletableFuture<Void>();\n+        future.whenComplete(new FutureEventListener<T>() {\n+            @Override\n+            public void onSuccess(T value) {\n+                promise.complete(null);\n+            }\n+\n+            @Override\n+            public void onFailure(Throwable cause) {\n+                if (null != errorMsg) {\n+                    log.error(errorMsg, cause);\n+                }\n+                promise.complete(null);\n+            }\n+        });\n+        return promise;\n+    }\n+\n+    public static <T> CompletableFuture<T> ensure(CompletableFuture<T> future,\n+                                                  Runnable ensureBlock) {\n+        return future.whenComplete((value, cause) -> {\n+            ensureBlock.run();\n+        });\n+    }\n+\n+    public static <T> CompletableFuture<T> rescue(CompletableFuture<T> future,\n+                                                  Function<Throwable, CompletableFuture<T>> rescueFuc) {\n+        CompletableFuture<T> result = FutureUtils.createFuture();\n+        future.whenComplete((value, cause) -> {\n+            if (null == cause) {\n+                result.complete(value);\n+                return;\n+            }\n+            proxyTo(rescueFuc.apply(cause), result);\n+        });\n+        return result;\n+    }\n+\n+    /**\n+      * Add a event listener over <i>result</i> for collecting the operation stats.\n+      *\n+      * @param result result to listen on\n+      * @param opStatsLogger stats logger to record operations stats\n+      * @param stopwatch stop watch to time operation\n+      * @param <T>\n+      * @return result after registered the event listener\n+      */\n+    public static <T> CompletableFuture<T> stats(CompletableFuture<T> result,\n+                                                 OpStatsLogger opStatsLogger,\n+                                                 Stopwatch stopwatch) {\n+        return result.whenComplete(new OpStatsListener<T>(opStatsLogger, stopwatch));\n+    }\n+\n+}"},{"sha":"dff0aced380306bf0850e0f32a14765d25851676","filename":"src/main/java/org/apache/distributedlog/common/concurrent/package-info.java","status":"added","additions":22,"deletions":0,"changes":22,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Fconcurrent%2Fpackage-info.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Fconcurrent%2Fpackage-info.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Fconcurrent%2Fpackage-info.java?ref=7e63cff1c110b7b9435a88ab8ab321659057c298","patch":"@@ -0,0 +1,22 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+/**\n+ * Utility classes commonly useful in concurrent programming.\n+ */\n+package org.apache.distributedlog.common.concurrent;\n\\ No newline at end of file"},{"sha":"83e8e0e5736fbaddfcceaba101687edbe0c1b2ef","filename":"src/main/java/org/apache/distributedlog/common/config/ConcurrentBaseConfiguration.java","status":"added","additions":71,"deletions":0,"changes":71,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Fconfig%2FConcurrentBaseConfiguration.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Fconfig%2FConcurrentBaseConfiguration.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Fconfig%2FConcurrentBaseConfiguration.java?ref=7e63cff1c110b7b9435a88ab8ab321659057c298","patch":"@@ -0,0 +1,71 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.distributedlog.common.config;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import java.util.Iterator;\n+import java.util.concurrent.ConcurrentHashMap;\n+import org.apache.commons.configuration.AbstractConfiguration;\n+\n+/**\n+ * Configuration view built on concurrent hash map for fast thread-safe access.\n+ * Notes:\n+ * 1. Multi-property list aggregation will not work in this class. I.e. commons config\n+ * normally combines all properties with the same key into one list property automatically.\n+ * This class simply overwrites any existing mapping.\n+ */\n+public class ConcurrentBaseConfiguration extends AbstractConfiguration {\n+\n+    private final ConcurrentHashMap<String, Object> map;\n+\n+    public ConcurrentBaseConfiguration() {\n+        this.map = new ConcurrentHashMap<String, Object>();\n+    }\n+\n+    @Override\n+    protected void addPropertyDirect(String key, Object value) {\n+        checkNotNull(value);\n+        map.put(key, value);\n+    }\n+\n+    @Override\n+    public Object getProperty(String key) {\n+        return map.get(key);\n+    }\n+\n+    @Override\n+    public Iterator getKeys() {\n+        return map.keySet().iterator();\n+    }\n+\n+    @Override\n+    public boolean containsKey(String key) {\n+        return map.containsKey(key);\n+    }\n+\n+    @Override\n+    public boolean isEmpty() {\n+        return map.isEmpty();\n+    }\n+\n+    @Override\n+    protected void clearPropertyDirect(String key) {\n+        map.remove(key);\n+    }\n+}"},{"sha":"1131409e6adf080010acfbf787d46d4c3f7ddde6","filename":"src/main/java/org/apache/distributedlog/common/config/ConcurrentConstConfiguration.java","status":"added","additions":32,"deletions":0,"changes":32,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Fconfig%2FConcurrentConstConfiguration.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Fconfig%2FConcurrentConstConfiguration.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Fconfig%2FConcurrentConstConfiguration.java?ref=7e63cff1c110b7b9435a88ab8ab321659057c298","patch":"@@ -0,0 +1,32 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.distributedlog.common.config;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import org.apache.commons.configuration.Configuration;\n+\n+/**\n+ * Invariant thread-safe view of some configuration.\n+ */\n+public class ConcurrentConstConfiguration extends ConcurrentBaseConfiguration {\n+    public ConcurrentConstConfiguration(Configuration conf) {\n+        checkNotNull(conf);\n+        copy(conf);\n+    }\n+}"},{"sha":"71bb12a7dee01cc522ea875bdac038a9719cd5a1","filename":"src/main/java/org/apache/distributedlog/common/config/ConfigurationListener.java","status":"added","additions":32,"deletions":0,"changes":32,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Fconfig%2FConfigurationListener.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Fconfig%2FConfigurationListener.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Fconfig%2FConfigurationListener.java?ref=7e63cff1c110b7b9435a88ab8ab321659057c298","patch":"@@ -0,0 +1,32 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.distributedlog.common.config;\n+\n+/**\n+ * Configuration listener triggered when reloading configuration settings.\n+ */\n+public interface ConfigurationListener {\n+\n+    /**\n+     * Reload the configuration.\n+     *\n+     * @param conf configuration to reload\n+     */\n+    void onReload(ConcurrentBaseConfiguration conf);\n+\n+}"},{"sha":"72a5657b759cb0ac37d20dff389de1ea4d73e74d","filename":"src/main/java/org/apache/distributedlog/common/config/ConfigurationSubscription.java","status":"added","additions":187,"deletions":0,"changes":187,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Fconfig%2FConfigurationSubscription.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Fconfig%2FConfigurationSubscription.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Fconfig%2FConfigurationSubscription.java?ref=7e63cff1c110b7b9435a88ab8ab321659057c298","patch":"@@ -0,0 +1,187 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.distributedlog.common.config;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Sets;\n+import java.io.FileNotFoundException;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.Iterator;\n+import org.apache.commons.configuration.ConfigurationException;\n+import org.apache.commons.configuration.FileConfiguration;\n+import org.apache.commons.configuration.reloading.FileChangedReloadingStrategy;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * ConfigurationSubscription publishes a reloading, thread-safe view of file configuration. The class\n+ * periodically calls FileConfiguration.reload on the underlying conf, and propagates changes to the\n+ * concurrent config. The configured FileChangedReloadingStrategy ensures that file config will only\n+ * be reloaded if something changed.\n+ * Notes:\n+ * 1. Reload schedule is never terminated. The assumption is a finite number of these are started\n+ * at the calling layer, and terminated only once the executor service is shut down.\n+ * 2. The underlying FileConfiguration is not at all thread-safe, so its important to ensure access\n+ * to this object is always single threaded.\n+ */\n+public class ConfigurationSubscription {\n+    static final Logger LOG = LoggerFactory.getLogger(ConfigurationSubscription.class);\n+\n+    private final ConcurrentBaseConfiguration viewConfig;\n+    private final ScheduledExecutorService executorService;\n+    private final int reloadPeriod;\n+    private final TimeUnit reloadUnit;\n+    private final List<FileConfigurationBuilder> fileConfigBuilders;\n+    private final List<FileConfiguration> fileConfigs;\n+    private final CopyOnWriteArraySet<ConfigurationListener> confListeners;\n+\n+    public ConfigurationSubscription(ConcurrentBaseConfiguration viewConfig,\n+                                     List<FileConfigurationBuilder> fileConfigBuilders,\n+                                     ScheduledExecutorService executorService,\n+                                     int reloadPeriod,\n+                                     TimeUnit reloadUnit)\n+            throws ConfigurationException {\n+        checkNotNull(fileConfigBuilders);\n+        checkArgument(!fileConfigBuilders.isEmpty());\n+        checkNotNull(executorService);\n+        checkNotNull(viewConfig);\n+        this.viewConfig = viewConfig;\n+        this.executorService = executorService;\n+        this.reloadPeriod = reloadPeriod;\n+        this.reloadUnit = reloadUnit;\n+        this.fileConfigBuilders = fileConfigBuilders;\n+        this.fileConfigs = Lists.newArrayListWithExpectedSize(this.fileConfigBuilders.size());\n+        this.confListeners = new CopyOnWriteArraySet<ConfigurationListener>();\n+        reload();\n+        scheduleReload();\n+    }\n+\n+    public void registerListener(ConfigurationListener listener) {\n+        this.confListeners.add(listener);\n+    }\n+\n+    public void unregisterListener(ConfigurationListener listener) {\n+        this.confListeners.remove(listener);\n+    }\n+\n+    private boolean initConfig() {\n+        if (fileConfigs.isEmpty()) {\n+            try {\n+                for (FileConfigurationBuilder fileConfigBuilder : fileConfigBuilders) {\n+                    FileConfiguration fileConfig = fileConfigBuilder.getConfiguration();\n+                    FileChangedReloadingStrategy reloadingStrategy = new FileChangedReloadingStrategy();\n+                    reloadingStrategy.setRefreshDelay(0);\n+                    fileConfig.setReloadingStrategy(reloadingStrategy);\n+                    fileConfigs.add(fileConfig);\n+                }\n+            } catch (ConfigurationException ex) {\n+                if (!fileNotFound(ex)) {\n+                    LOG.error(\"Config init failed {}\", ex);\n+                }\n+            }\n+        }\n+        return !fileConfigs.isEmpty();\n+    }\n+\n+    private void scheduleReload() {\n+        executorService.scheduleAtFixedRate(new Runnable() {\n+            @Override\n+            public void run() {\n+                reload();\n+            }\n+        }, 0, reloadPeriod, reloadUnit);\n+    }\n+\n+    @VisibleForTesting\n+    void reload() {\n+        // No-op if already loaded.\n+        if (!initConfig()) {\n+            return;\n+        }\n+        // Reload if config exists.\n+        Set<String> confKeys = Sets.newHashSet();\n+        for (FileConfiguration fileConfig : fileConfigs) {\n+            LOG.debug(\"Check and reload config, file={}, lastModified={}\", fileConfig.getFile(),\n+                    fileConfig.getFile().lastModified());\n+            fileConfig.reload();\n+            // load keys\n+            Iterator keyIter = fileConfig.getKeys();\n+            while (keyIter.hasNext()) {\n+                String key = (String) keyIter.next();\n+                confKeys.add(key);\n+            }\n+        }\n+        // clear unexisted keys\n+        Iterator viewIter = viewConfig.getKeys();\n+        while (viewIter.hasNext()) {\n+            String key = (String) viewIter.next();\n+            if (!confKeys.contains(key)) {\n+                clearViewProperty(key);\n+            }\n+        }\n+        LOG.info(\"Reload features : {}\", confKeys);\n+        // load keys from files\n+        for (FileConfiguration fileConfig : fileConfigs) {\n+            try {\n+                loadView(fileConfig);\n+            } catch (Exception ex) {\n+                if (!fileNotFound(ex)) {\n+                    LOG.error(\"Config reload failed for file {}\", fileConfig.getFileName(), ex);\n+                }\n+            }\n+        }\n+        for (ConfigurationListener listener : confListeners) {\n+            listener.onReload(viewConfig);\n+        }\n+    }\n+\n+    private boolean fileNotFound(Exception ex) {\n+        return ex instanceof FileNotFoundException\n+            || ex.getCause() != null && ex.getCause() instanceof FileNotFoundException;\n+    }\n+\n+    private void loadView(FileConfiguration fileConfig) {\n+        Iterator fileIter = fileConfig.getKeys();\n+        while (fileIter.hasNext()) {\n+            String key = (String) fileIter.next();\n+            setViewProperty(fileConfig, key, fileConfig.getProperty(key));\n+        }\n+    }\n+\n+    private void clearViewProperty(String key) {\n+        LOG.debug(\"Removing property, key={}\", key);\n+        viewConfig.clearProperty(key);\n+    }\n+\n+    private void setViewProperty(FileConfiguration fileConfig,\n+                                 String key,\n+                                 Object value) {\n+        if (!viewConfig.containsKey(key) || !viewConfig.getProperty(key).equals(value)) {\n+            LOG.debug(\"Setting property, key={} value={}\", key, fileConfig.getProperty(key));\n+            viewConfig.setProperty(key, fileConfig.getProperty(key));\n+        }\n+    }\n+}"},{"sha":"0ff967d0c594d95ab3d893e7d2fb8f9ad2e84b09","filename":"src/main/java/org/apache/distributedlog/common/config/FileConfigurationBuilder.java","status":"added","additions":28,"deletions":0,"changes":28,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Fconfig%2FFileConfigurationBuilder.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Fconfig%2FFileConfigurationBuilder.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Fconfig%2FFileConfigurationBuilder.java?ref=7e63cff1c110b7b9435a88ab8ab321659057c298","patch":"@@ -0,0 +1,28 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.distributedlog.common.config;\n+\n+import org.apache.commons.configuration.ConfigurationException;\n+import org.apache.commons.configuration.FileConfiguration;\n+\n+/**\n+ * Abstract out FileConfiguration subclass construction.\n+ */\n+public interface FileConfigurationBuilder {\n+    FileConfiguration getConfiguration() throws ConfigurationException;\n+}"},{"sha":"2d075355e50013c974a5a8338617f5eab6d5a40a","filename":"src/main/java/org/apache/distributedlog/common/config/PropertiesConfigurationBuilder.java","status":"added","additions":39,"deletions":0,"changes":39,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Fconfig%2FPropertiesConfigurationBuilder.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Fconfig%2FPropertiesConfigurationBuilder.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Fconfig%2FPropertiesConfigurationBuilder.java?ref=7e63cff1c110b7b9435a88ab8ab321659057c298","patch":"@@ -0,0 +1,39 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.distributedlog.common.config;\n+\n+import java.net.URL;\n+import org.apache.commons.configuration.ConfigurationException;\n+import org.apache.commons.configuration.FileConfiguration;\n+import org.apache.commons.configuration.PropertiesConfiguration;\n+\n+/**\n+ * Hide PropertiesConfiguration dependency.\n+ */\n+public class PropertiesConfigurationBuilder implements FileConfigurationBuilder {\n+    private URL url;\n+\n+    public PropertiesConfigurationBuilder(URL url) {\n+        this.url = url;\n+    }\n+\n+    @Override\n+    public FileConfiguration getConfiguration() throws ConfigurationException {\n+        return new PropertiesConfiguration(url);\n+    }\n+}"},{"sha":"88e68f27c7b9170d4449b202dd6f0925315dad20","filename":"src/main/java/org/apache/distributedlog/common/config/package-info.java","status":"added","additions":21,"deletions":0,"changes":21,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Fconfig%2Fpackage-info.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Fconfig%2Fpackage-info.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Fconfig%2Fpackage-info.java?ref=7e63cff1c110b7b9435a88ab8ab321659057c298","patch":"@@ -0,0 +1,21 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+/**\n+ * Configuration Related Utils.\n+ */\n+package org.apache.distributedlog.common.config;"},{"sha":"8d5069edfd1d841a84bf25c09e1004ee7ac85006","filename":"src/main/java/org/apache/distributedlog/common/functions/VoidFunctions.java","status":"added","additions":31,"deletions":0,"changes":31,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Ffunctions%2FVoidFunctions.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Ffunctions%2FVoidFunctions.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Ffunctions%2FVoidFunctions.java?ref=7e63cff1c110b7b9435a88ab8ab321659057c298","patch":"@@ -0,0 +1,31 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.distributedlog.common.functions;\n+\n+import java.util.List;\n+import java.util.function.Function;\n+\n+/**\n+ * Functions for transforming structures related to {@link Void}.\n+ */\n+public class VoidFunctions {\n+\n+    public static final Function<List<Void>, Void> LIST_TO_VOID_FUNC =\n+      list -> null;\n+\n+}"},{"sha":"9e88612fc0f5f6fd099c32f06068561c503e7076","filename":"src/main/java/org/apache/distributedlog/common/functions/package-info.java","status":"added","additions":21,"deletions":0,"changes":21,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Ffunctions%2Fpackage-info.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Ffunctions%2Fpackage-info.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Ffunctions%2Fpackage-info.java?ref=7e63cff1c110b7b9435a88ab8ab321659057c298","patch":"@@ -0,0 +1,21 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+/**\n+ * Common Functions.\n+ */\n+package org.apache.distributedlog.common.functions;"},{"sha":"4c90bd23bf989e0f5a9002bf1020592a9a383241","filename":"src/main/java/org/apache/distributedlog/common/package-info.java","status":"added","additions":22,"deletions":0,"changes":22,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Fpackage-info.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Fpackage-info.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Fpackage-info.java?ref=7e63cff1c110b7b9435a88ab8ab321659057c298","patch":"@@ -0,0 +1,22 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+/**\n+ * Common functions and utils used across the project.\n+ */\n+package org.apache.distributedlog.common;\n\\ No newline at end of file"},{"sha":"f3e8c33904a9cce4f071f8b03a41059fede4ed3d","filename":"src/main/java/org/apache/distributedlog/common/rate/MovingAverageRate.java","status":"added","additions":27,"deletions":0,"changes":27,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Frate%2FMovingAverageRate.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Frate%2FMovingAverageRate.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Frate%2FMovingAverageRate.java?ref=7e63cff1c110b7b9435a88ab8ab321659057c298","patch":"@@ -0,0 +1,27 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.distributedlog.common.rate;\n+\n+/**\n+ * Moving Average Rate.\n+ */\n+public interface MovingAverageRate {\n+    double get();\n+    void add(long amount);\n+    void inc();\n+}"},{"sha":"790ba0372b7ee968e6494fd71969687e595568a9","filename":"src/main/java/org/apache/distributedlog/common/rate/MovingAverageRateFactory.java","status":"added","additions":62,"deletions":0,"changes":62,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Frate%2FMovingAverageRateFactory.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Frate%2FMovingAverageRateFactory.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Frate%2FMovingAverageRateFactory.java?ref=7e63cff1c110b7b9435a88ab8ab321659057c298","patch":"@@ -0,0 +1,62 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.distributedlog.common.rate;\n+\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Factory to create {@link MovingAverageRate} instances.\n+ */\n+public class MovingAverageRateFactory implements Runnable {\n+\n+    private static final int DEFAULT_INTERVAL_SECS = 1;\n+\n+    private final ScheduledExecutorService scheduler;\n+    private final ScheduledFuture<?> scheduledFuture;\n+    private final CopyOnWriteArrayList<SampledMovingAverageRate> avgs;\n+\n+    public MovingAverageRateFactory(ScheduledExecutorService scheduler) {\n+        this.avgs = new CopyOnWriteArrayList<SampledMovingAverageRate>();\n+        this.scheduler = scheduler;\n+        this.scheduledFuture = this.scheduler.scheduleAtFixedRate(\n+            this, DEFAULT_INTERVAL_SECS, DEFAULT_INTERVAL_SECS, TimeUnit.SECONDS);\n+    }\n+\n+    public MovingAverageRate create(int intervalSecs) {\n+        SampledMovingAverageRate avg = new SampledMovingAverageRate(intervalSecs);\n+        avgs.add(avg);\n+        return avg;\n+    }\n+\n+    public void close() {\n+        scheduledFuture.cancel(true);\n+        avgs.clear();\n+    }\n+\n+    @Override\n+    public void run() {\n+        sampleAll();\n+    }\n+\n+    private void sampleAll() {\n+        avgs.forEach(SampledMovingAverageRate::sample);\n+    }\n+}"},{"sha":"2c89d64428e05cb73436d8b3cf048fe19fd089e7","filename":"src/main/java/org/apache/distributedlog/common/rate/SampledMovingAverageRate.java","status":"added","additions":95,"deletions":0,"changes":95,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Frate%2FSampledMovingAverageRate.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Frate%2FSampledMovingAverageRate.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Frate%2FSampledMovingAverageRate.java?ref=7e63cff1c110b7b9435a88ab8ab321659057c298","patch":"@@ -0,0 +1,95 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.distributedlog.common.rate;\n+\n+import com.google.common.base.Ticker;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+/**\n+ * Sampled {@link MovingAverageRate}.\n+ */\n+class SampledMovingAverageRate implements MovingAverageRate {\n+\n+    private static final long NANOS_PER_SEC = TimeUnit.SECONDS.toNanos(1);\n+\n+    private final AtomicLong total;\n+    private final Ticker ticker;\n+    private final double scaleFactor;\n+    private final LinkedBlockingDeque<Pair<Long, Long>> samples;\n+\n+    private double value;\n+\n+    public SampledMovingAverageRate(int intervalSecs) {\n+        this(intervalSecs, 1, Ticker.systemTicker());\n+    }\n+\n+    SampledMovingAverageRate(int intervalSecs,\n+                             double scaleFactor,\n+                             Ticker ticker) {\n+        this.value = 0;\n+        this.total = new AtomicLong(0);\n+        this.scaleFactor = scaleFactor;\n+        this.ticker = ticker;\n+        this.samples = new LinkedBlockingDeque<>(intervalSecs);\n+    }\n+\n+    @Override\n+    public double get() {\n+        return value;\n+    }\n+\n+    @Override\n+    public void add(long amount) {\n+        total.getAndAdd(amount);\n+    }\n+\n+    @Override\n+    public void inc() {\n+        add(1);\n+    }\n+\n+    void sample() {\n+        value = doSample();\n+    }\n+\n+    private double doSample() {\n+        long newSample = total.get();\n+        long newTimestamp = ticker.read();\n+\n+        double rate = 0;\n+        if (!samples.isEmpty()) {\n+            Pair<Long, Long> oldestSample = samples.peekLast();\n+\n+            double dy = newSample - oldestSample.getRight();\n+            double dt = newTimestamp - oldestSample.getLeft();\n+\n+            rate = (dt == 0) ? 0 : (NANOS_PER_SEC * scaleFactor * dy) / dt;\n+        }\n+\n+        if (samples.remainingCapacity() == 0) {\n+            samples.removeLast();\n+        } else {\n+            samples.addFirst(Pair.of(newTimestamp, newSample));\n+        }\n+\n+        return rate;\n+    }\n+}"},{"sha":"3117c6401d24649ac9191b3cd69cff202f08762f","filename":"src/main/java/org/apache/distributedlog/common/rate/package-info.java","status":"added","additions":22,"deletions":0,"changes":22,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Frate%2Fpackage-info.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Frate%2Fpackage-info.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Frate%2Fpackage-info.java?ref=7e63cff1c110b7b9435a88ab8ab321659057c298","patch":"@@ -0,0 +1,22 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+/**\n+ * Rate relate functions.\n+ */\n+package org.apache.distributedlog.common.rate;\n\\ No newline at end of file"},{"sha":"61a20f1900c8d93b37147edb43692023993eb35e","filename":"src/main/java/org/apache/distributedlog/common/stats/BroadCastStatsLogger.java","status":"added","additions":194,"deletions":0,"changes":194,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Fstats%2FBroadCastStatsLogger.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Fstats%2FBroadCastStatsLogger.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Fstats%2FBroadCastStatsLogger.java?ref=7e63cff1c110b7b9435a88ab8ab321659057c298","patch":"@@ -0,0 +1,194 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.distributedlog.common.stats;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import org.apache.bookkeeper.stats.CachingStatsLogger;\n+import org.apache.bookkeeper.stats.Counter;\n+import org.apache.bookkeeper.stats.Gauge;\n+import org.apache.bookkeeper.stats.OpStatsData;\n+import org.apache.bookkeeper.stats.OpStatsLogger;\n+import org.apache.bookkeeper.stats.StatsLogger;\n+\n+/**\n+ * Stats Loggers that broadcast stats to multiple {@link StatsLogger}.\n+ */\n+public class BroadCastStatsLogger {\n+\n+    /**\n+     * Create a broadcast stats logger of two stats loggers `<code>first</code>` and\n+     * `<code>second</code>`. The returned stats logger doesn't allow registering any\n+     * {@link Gauge}.\n+     *\n+     * @param first\n+     *          first stats logger\n+     * @param second\n+     *          second stats logger\n+     * @return broadcast stats logger\n+     */\n+    public static StatsLogger two(StatsLogger first, StatsLogger second) {\n+        return new CachingStatsLogger(new Two(first, second));\n+    }\n+\n+    static class Two implements StatsLogger {\n+        protected final StatsLogger first;\n+        protected final StatsLogger second;\n+\n+        private Two(StatsLogger first, StatsLogger second) {\n+            super();\n+            checkNotNull(first);\n+            checkNotNull(second);\n+            this.first = first;\n+            this.second = second;\n+        }\n+\n+        @Override\n+        public OpStatsLogger getOpStatsLogger(final String statName) {\n+            final OpStatsLogger firstLogger = first.getOpStatsLogger(statName);\n+            final OpStatsLogger secondLogger = second.getOpStatsLogger(statName);\n+            return new OpStatsLogger() {\n+                @Override\n+                public void registerFailedEvent(long l) {\n+                    firstLogger.registerFailedEvent(l);\n+                    secondLogger.registerFailedEvent(l);\n+                }\n+\n+                @Override\n+                public void registerSuccessfulEvent(long l) {\n+                    firstLogger.registerSuccessfulEvent(l);\n+                    secondLogger.registerSuccessfulEvent(l);\n+                }\n+\n+                @Override\n+                public OpStatsData toOpStatsData() {\n+                    // Eventually consistent.\n+                    return firstLogger.toOpStatsData();\n+                }\n+\n+                @Override\n+                public void clear() {\n+                    firstLogger.clear();\n+                    secondLogger.clear();\n+                }\n+            };\n+        }\n+\n+        @Override\n+        public Counter getCounter(final String statName) {\n+            final Counter firstCounter = first.getCounter(statName);\n+            final Counter secondCounter = second.getCounter(statName);\n+            return new Counter() {\n+                @Override\n+                public void clear() {\n+                    firstCounter.clear();\n+                    secondCounter.clear();\n+                }\n+\n+                @Override\n+                public void inc() {\n+                    firstCounter.inc();\n+                    secondCounter.inc();\n+                }\n+\n+                @Override\n+                public void dec() {\n+                    firstCounter.dec();\n+                    secondCounter.dec();\n+                }\n+\n+                @Override\n+                public void add(long l) {\n+                    firstCounter.add(l);\n+                    secondCounter.add(l);\n+                }\n+\n+                @Override\n+                public Long get() {\n+                    // Eventually consistent.\n+                    return firstCounter.get();\n+                }\n+            };\n+        }\n+\n+        @Override\n+        public <T extends Number> void registerGauge(String statName, Gauge<T> gauge) {\n+            // Different underlying stats loggers have different semantics wrt. gauge registration.\n+            throw new RuntimeException(\"Cannot register a gauge on BroadCastStatsLogger.Two\");\n+        }\n+\n+        @Override\n+        public <T extends Number> void unregisterGauge(String statName, Gauge<T> gauge) {\n+            // no-op\n+        }\n+\n+        @Override\n+        public StatsLogger scope(final String scope) {\n+            return new Two(first.scope(scope), second.scope(scope));\n+        }\n+\n+        @Override\n+        public void removeScope(String scope, StatsLogger statsLogger) {\n+            if (!(statsLogger instanceof Two)) {\n+                return;\n+            }\n+\n+            Two another = (Two) statsLogger;\n+\n+            first.removeScope(scope, another.first);\n+            second.removeScope(scope, another.second);\n+        }\n+    }\n+\n+    /**\n+     * Create a broadcast stats logger of two stats loggers <code>master</code> and <code>slave</code>.\n+     * It is similar as {@link #two(StatsLogger, StatsLogger)}, but it allows registering {@link Gauge}s.\n+     * The {@link Gauge} will be registered under master.\n+     *\n+     * @param master\n+     *          master stats logger to receive {@link Counter}, {@link OpStatsLogger} and {@link Gauge}.\n+     * @param slave\n+     *          slave stats logger to receive only {@link Counter} and {@link OpStatsLogger}.\n+     * @return broadcast stats logger\n+     */\n+    public static StatsLogger masterslave(StatsLogger master, StatsLogger slave) {\n+        return new CachingStatsLogger(new MasterSlave(master, slave));\n+    }\n+\n+    static class MasterSlave extends Two {\n+\n+        private MasterSlave(StatsLogger master, StatsLogger slave) {\n+            super(master, slave);\n+        }\n+\n+        @Override\n+        public <T extends Number> void registerGauge(String statName, Gauge<T> gauge) {\n+            first.registerGauge(statName, gauge);\n+        }\n+\n+        @Override\n+        public <T extends Number> void unregisterGauge(String statName, Gauge<T> gauge) {\n+            first.unregisterGauge(statName, gauge);\n+        }\n+\n+        @Override\n+        public StatsLogger scope(String scope) {\n+            return new MasterSlave(first.scope(scope), second.scope(scope));\n+        }\n+    }\n+}"},{"sha":"e71a79929e6e99dd6e1008f862653612bdaf514c","filename":"src/main/java/org/apache/distributedlog/common/stats/OpStatsListener.java","status":"added","additions":54,"deletions":0,"changes":54,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Fstats%2FOpStatsListener.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Fstats%2FOpStatsListener.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Fstats%2FOpStatsListener.java?ref=7e63cff1c110b7b9435a88ab8ab321659057c298","patch":"@@ -0,0 +1,54 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.distributedlog.common.stats;\n+\n+import com.google.common.base.Stopwatch;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.bookkeeper.stats.OpStatsLogger;\n+import org.apache.distributedlog.common.concurrent.FutureEventListener;\n+\n+/**\n+ * A {@link FutureEventListener} monitors the stats for a given operation.\n+ */\n+public class OpStatsListener<T> implements FutureEventListener<T> {\n+    OpStatsLogger opStatsLogger;\n+    Stopwatch stopwatch;\n+\n+    public OpStatsListener(OpStatsLogger opStatsLogger, Stopwatch stopwatch) {\n+        this.opStatsLogger = opStatsLogger;\n+        if (null == stopwatch) {\n+            this.stopwatch = Stopwatch.createStarted();\n+        } else {\n+            this.stopwatch = stopwatch;\n+        }\n+    }\n+\n+    public OpStatsListener(OpStatsLogger opStatsLogger) {\n+        this(opStatsLogger, null);\n+    }\n+\n+    @Override\n+    public void onSuccess(T value) {\n+        opStatsLogger.registerSuccessfulEvent(stopwatch.elapsed(TimeUnit.MICROSECONDS));\n+    }\n+\n+    @Override\n+    public void onFailure(Throwable cause) {\n+        opStatsLogger.registerFailedEvent(stopwatch.elapsed(TimeUnit.MICROSECONDS));\n+    }\n+}"},{"sha":"bf3859dfa38eca493b345c700b5481aec212b472","filename":"src/main/java/org/apache/distributedlog/common/stats/package-info.java","status":"added","additions":21,"deletions":0,"changes":21,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Fstats%2Fpackage-info.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Fstats%2Fpackage-info.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Fstats%2Fpackage-info.java?ref=7e63cff1c110b7b9435a88ab8ab321659057c298","patch":"@@ -0,0 +1,21 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+/**\n+ * Stats Related Utils.\n+ */\n+package org.apache.distributedlog.common.stats;\n\\ No newline at end of file"},{"sha":"53f4ab24f5008062fd3e1a51e60ded0b1b17996a","filename":"src/main/java/org/apache/distributedlog/common/util/BitMaskUtils.java","status":"added","additions":57,"deletions":0,"changes":57,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Futil%2FBitMaskUtils.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Futil%2FBitMaskUtils.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Futil%2FBitMaskUtils.java?ref=7e63cff1c110b7b9435a88ab8ab321659057c298","patch":"@@ -0,0 +1,57 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.distributedlog.common.util;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+\n+/**\n+ * Utils for bit mask operations.\n+ */\n+public class BitMaskUtils {\n+\n+    /**\n+     * 1) Unset all bits where value in mask is set.\n+     * 2) Set these bits to value specified by newValue.\n+     *\n+     * <p>e.g.\n+     * if oldValue = 1010, mask = 0011, newValue = 0001\n+     * 1) 1010 -> 1000\n+     * 2) 1000 -> 1001\n+     *\n+     * @param oldValue expected old value\n+     * @param mask the mask of the value for updates\n+     * @param newValue new value to set\n+     * @return updated value\n+     */\n+    public static long set(long oldValue, long mask, long newValue) {\n+        checkArgument(oldValue >= 0L && mask >= 0L && newValue >= 0L);\n+        return ((oldValue & (~mask)) | (newValue & mask));\n+    }\n+\n+    /**\n+     * Get the bits where mask is 1.\n+     *\n+     * @param value value\n+     * @param mask mask of the value\n+     * @return the bit of the mask\n+     */\n+    public static long get(long value, long mask) {\n+        checkArgument(value >= 0L && mask >= 0L);\n+        return (value & mask);\n+    }\n+}"},{"sha":"38b3ed27f9ce366b0d20dfe7a66fac41e259b51c","filename":"src/main/java/org/apache/distributedlog/common/util/MathUtil.java","status":"added","additions":36,"deletions":0,"changes":36,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Futil%2FMathUtil.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Futil%2FMathUtil.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Futil%2FMathUtil.java?ref=7e63cff1c110b7b9435a88ab8ab321659057c298","patch":"@@ -0,0 +1,36 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.distributedlog.common.util;\n+\n+/**\n+ * Helpers for math related utils.\n+ */\n+public class MathUtil {\n+\n+  public static int signSafeMod(long dividend, int divisor) {\n+    int mod = (int) (dividend % divisor);\n+\n+    if (mod < 0) {\n+      mod += divisor;\n+    }\n+\n+    return mod;\n+  }\n+\n+}"},{"sha":"24cb63dfd58714304e9f33a7d4ae31984f0edac3","filename":"src/main/java/org/apache/distributedlog/common/util/Permit.java","status":"added","additions":28,"deletions":0,"changes":28,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Futil%2FPermit.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Futil%2FPermit.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Futil%2FPermit.java?ref=7e63cff1c110b7b9435a88ab8ab321659057c298","patch":"@@ -0,0 +1,28 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.distributedlog.common.util;\n+\n+/**\n+ * Permit.\n+ */\n+@FunctionalInterface\n+public interface Permit {\n+\n+    void release();\n+\n+}"},{"sha":"8fcbf12732c532f30be0074777b4c87e2091e427","filename":"src/main/java/org/apache/distributedlog/common/util/PermitLimiter.java","status":"added","additions":57,"deletions":0,"changes":57,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Futil%2FPermitLimiter.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Futil%2FPermitLimiter.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Futil%2FPermitLimiter.java?ref=7e63cff1c110b7b9435a88ab8ab321659057c298","patch":"@@ -0,0 +1,57 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.distributedlog.common.util;\n+\n+/**\n+ * A simple limiter interface which tracks acquire/release of permits, for\n+ * example for tracking outstanding writes.\n+ */\n+public interface PermitLimiter {\n+\n+    PermitLimiter NULL_PERMIT_LIMITER = new PermitLimiter() {\n+        @Override\n+        public boolean acquire() {\n+            return true;\n+        }\n+        @Override\n+        public void release(int permits) {\n+        }\n+\n+        @Override\n+        public void close() {\n+\n+        }\n+    };\n+\n+    /**\n+     * Acquire a permit.\n+     *\n+     * @return true if successfully acquire a permit, otherwise false.\n+     */\n+    boolean acquire();\n+\n+    /**\n+     * Release a permit.\n+     */\n+    void release(int permits);\n+\n+    /**\n+     * Close the resources created by the limiter.\n+     */\n+    void close();\n+}"},{"sha":"3b6e3a1e7daf2b8a5621a142c929454f526c7eea","filename":"src/main/java/org/apache/distributedlog/common/util/PermitManager.java","status":"added","additions":94,"deletions":0,"changes":94,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Futil%2FPermitManager.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Futil%2FPermitManager.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Futil%2FPermitManager.java?ref=7e63cff1c110b7b9435a88ab8ab321659057c298","patch":"@@ -0,0 +1,94 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.distributedlog.common.util;\n+\n+/**\n+ * Permit manager for managing permits.\n+ */\n+public interface PermitManager {\n+\n+    /**\n+     * A class present a permit managed by a permit manager.\n+     */\n+    interface Permit {\n+        Permit ALLOWED = () -> true;\n+        boolean isAllowed();\n+    }\n+\n+    PermitManager UNLIMITED_PERMIT_MANAGER = new PermitManager() {\n+        @Override\n+        public Permit acquirePermit() {\n+            return Permit.ALLOWED;\n+        }\n+\n+        @Override\n+        public void releasePermit(Permit permit) {\n+            // nop\n+        }\n+\n+        @Override\n+        public boolean allowObtainPermits() {\n+            return true;\n+        }\n+\n+        @Override\n+        public boolean disallowObtainPermits(Permit permit) {\n+            return false;\n+        }\n+\n+        @Override\n+        public void close() {\n+            // nop\n+        }\n+\n+    };\n+\n+    /**\n+     * Obetain a permit from permit manager.\n+     *\n+     * @return permit.\n+     */\n+    Permit acquirePermit();\n+\n+    /**\n+     * Release a given permit.\n+     *\n+     * @param permit\n+     *          permit to release\n+     */\n+    void releasePermit(Permit permit);\n+\n+    /**\n+     * Allow obtaining permits.\n+     */\n+    boolean allowObtainPermits();\n+\n+    /**\n+     * Disallow obtaining permits. Disallow needs to be performed under the context\n+     * of <i>permit</i>.\n+     *\n+     * @param permit\n+     *          permit context to disallow\n+     */\n+    boolean disallowObtainPermits(Permit permit);\n+\n+    /**\n+     * Release the resources.\n+     */\n+    void close();\n+}"},{"sha":"f6d4f230c56ca2293aa5381ee8d01ab7acb031e1","filename":"src/main/java/org/apache/distributedlog/common/util/SchedulerUtils.java","status":"added","additions":43,"deletions":0,"changes":43,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Futil%2FSchedulerUtils.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Futil%2FSchedulerUtils.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Futil%2FSchedulerUtils.java?ref=7e63cff1c110b7b9435a88ab8ab321659057c298","patch":"@@ -0,0 +1,43 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.distributedlog.common.util;\n+\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Scheduler related utils.\n+ */\n+@Slf4j\n+public class SchedulerUtils {\n+\n+    public static void shutdownScheduler(ExecutorService service, long timeout, TimeUnit timeUnit) {\n+        if (null == service) {\n+            return;\n+        }\n+        service.shutdown();\n+        try {\n+            service.awaitTermination(timeout, timeUnit);\n+        } catch (InterruptedException e) {\n+            log.warn(\"Interrupted when shutting down scheduler : \", e);\n+        }\n+        service.shutdownNow();\n+    }\n+\n+}"},{"sha":"a40b8e25d8deebb281a3a4098c7dc4f84a7eb100","filename":"src/main/java/org/apache/distributedlog/common/util/Sequencer.java","status":"added","additions":31,"deletions":0,"changes":31,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Futil%2FSequencer.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Futil%2FSequencer.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Futil%2FSequencer.java?ref=7e63cff1c110b7b9435a88ab8ab321659057c298","patch":"@@ -0,0 +1,31 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.distributedlog.common.util;\n+\n+/**\n+ * Sequencer generating transaction id.\n+ */\n+public interface Sequencer {\n+\n+    /**\n+     * Return next transaction id generated by the sequencer.\n+     *\n+     * @return next transaction id generated by the sequencer.\n+     */\n+    long nextId();\n+}"},{"sha":"d418e0fdd2a8a04d02b8146741c835da6e44cbb7","filename":"src/main/java/org/apache/distributedlog/common/util/Sizable.java","status":"added","additions":31,"deletions":0,"changes":31,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Futil%2FSizable.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Futil%2FSizable.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Futil%2FSizable.java?ref=7e63cff1c110b7b9435a88ab8ab321659057c298","patch":"@@ -0,0 +1,31 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.distributedlog.common.util;\n+\n+/**\n+ * The {@code Sizable} interface is to provide the capability of calculating size\n+ * of any objects.\n+ */\n+public interface Sizable {\n+    /**\n+     * Calculate the size for this instance.\n+     *\n+     * @return size of the instance.\n+     */\n+    long size();\n+}"},{"sha":"e2bde37643a0025a69cc51b6c35527bf3d969b7a","filename":"src/main/java/org/apache/distributedlog/common/util/package-info.java","status":"added","additions":22,"deletions":0,"changes":22,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Futil%2Fpackage-info.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Futil%2Fpackage-info.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Futil%2Fpackage-info.java?ref=7e63cff1c110b7b9435a88ab8ab321659057c298","patch":"@@ -0,0 +1,22 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+/**\n+ * Common utility functions.\n+ */\n+package org.apache.distributedlog.common.util;\n\\ No newline at end of file"},{"sha":"4edc09dac1adf15c7d20979f82370c3f8f305f72","filename":"src/main/java/org/apache/distributedlog/io/Abortable.java","status":"added","additions":41,"deletions":0,"changes":41,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fio%2FAbortable.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fio%2FAbortable.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fio%2FAbortable.java?ref=7e63cff1c110b7b9435a88ab8ab321659057c298","patch":"@@ -0,0 +1,41 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.distributedlog.io;\n+\n+import java.io.IOException;\n+\n+/**\n+ * An {@code Abortable} is a source or destination of data that can be aborted.\n+ * The abort method is invoked to release resources that the object is holding\n+ * (such as open files). The abort happens when the object is in an error state,\n+ * which it couldn't be closed gracefully.\n+ *\n+ * @see java.io.Closeable\n+ * @since 0.3.32\n+ */\n+public interface Abortable {\n+\n+    /**\n+     * Aborts the object and releases any resources associated with it.\n+     * If the object is already aborted then invoking this method has no\n+     * effect.\n+     *\n+     * @throws IOException if an I/O error occurs.\n+     */\n+    void abort() throws IOException;\n+}"},{"sha":"b6101a825ebecfe8d2e63bebbe483d5eb3303e4a","filename":"src/main/java/org/apache/distributedlog/io/Abortables.java","status":"added","additions":185,"deletions":0,"changes":185,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fio%2FAbortables.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fio%2FAbortables.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fio%2FAbortables.java?ref=7e63cff1c110b7b9435a88ab8ab321659057c298","patch":"@@ -0,0 +1,185 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.distributedlog.io;\n+\n+import com.google.common.collect.Lists;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutorService;\n+import javax.annotation.Nullable;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.distributedlog.common.functions.VoidFunctions;\n+import org.apache.distributedlog.common.concurrent.FutureUtils;\n+\n+/**\n+ * Utility methods for working with {@link Abortable} objects.\n+ *\n+ * @since 0.3.32\n+ */\n+@Slf4j\n+public final class Abortables {\n+\n+    private Abortables() {}\n+\n+    public static CompletableFuture<Void> asyncAbort(@Nullable AsyncAbortable abortable,\n+                                                     boolean swallowIOException) {\n+        if (null == abortable) {\n+            return FutureUtils.Void();\n+        } else if (swallowIOException) {\n+            return FutureUtils.ignore(abortable.asyncAbort());\n+        } else {\n+            return abortable.asyncAbort();\n+        }\n+    }\n+\n+    /**\n+     * Aborts a {@link Abortable}, with control over whether an {@link IOException} may be thrown.\n+     * This is primarily useful in a finally block, where a thrown exception needs to be logged but\n+     * not propagated (otherwise the original exception will be lost).\n+     *\n+     * <p>If {@code swallowIOException} is true then we never throw {@code IOException} but merely log it.\n+     *\n+     * <p>Example: <pre>   {@code\n+     *\n+     *   public void abortStreamNicely() throws IOException {\n+     *      SomeStream stream = new SomeStream(\"foo\");\n+     *      try {\n+     *          // ... code which does something with the stream ...\n+     *      } catch (IOException ioe) {\n+     *          // If an exception occurs, we might abort the stream.\n+     *          Abortables.abort(stream, true);\n+     *      }\n+     *   }}</pre>\n+     *\n+     * @param abortable the {@code Abortable} object to be aborted, or null, in which case this method\n+     *                  does nothing.\n+     * @param swallowIOException if true, don't propagate IO exceptions thrown by the {@code abort} methods\n+     * @throws IOException if {@code swallowIOException} is false and {@code abort} throws an {@code IOException}\n+     */\n+    public static void abort(@Nullable Abortable abortable,\n+                             boolean swallowIOException)\n+        throws IOException {\n+        if (null == abortable) {\n+            return;\n+        }\n+        try {\n+            abortable.abort();\n+        } catch (IOException ioe) {\n+            if (swallowIOException) {\n+                log.warn(\"IOException thrown while aborting Abortable {} : \", abortable, ioe);\n+            } else {\n+                throw ioe;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Abort async <i>abortable</i>.\n+     *\n+     * @param abortable the {@code AsyncAbortable} object to be aborted, or null, in which case this method\n+     *                  does nothing.\n+     * @param swallowIOException if true, don't propagate IO exceptions thrown by the {@code abort} methods\n+     * @throws IOException if {@code swallowIOException} is false and {@code abort} throws an {@code IOException}\n+     * @see #abort(Abortable, boolean)\n+     */\n+    public static void abort(@Nullable AsyncAbortable abortable,\n+                             boolean swallowIOException)\n+            throws IOException {\n+        if (null == abortable) {\n+            return;\n+        }\n+        try {\n+            FutureUtils.result(abortable.asyncAbort());\n+        } catch (Exception e) {\n+            if (swallowIOException) {\n+                log.warn(\"IOException thrown while aborting Abortable {} : \", abortable, e);\n+            } else {\n+                if (e instanceof IOException) {\n+                    throw (IOException) e;\n+                } else {\n+                    throw new IOException(e);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Aborts the given {@code abortable}, logging any {@code IOException} that's thrown rather than\n+     * propagating it.\n+     *\n+     * <p>While it's not safe in the general case to ignore exceptions that are thrown when aborting an\n+     * I/O resource, it should generally be safe in the case of a resource that's being used only for\n+     * reading.\n+     *\n+     * @param abortable the {@code Abortable} to be closed, or {@code null} in which case this method\n+     *                  does nothing.\n+     */\n+    public static void abortQuietly(@Nullable Abortable abortable) {\n+        try {\n+            abort(abortable, true);\n+        } catch (IOException e) {\n+            log.error(\"Unexpected IOException thrown while aborting Abortable {} quietly : \", abortable, e);\n+        }\n+    }\n+\n+    /**\n+     * Aborts the given {@code abortable}, logging any {@code IOException} that's thrown rather than\n+     * propagating it.\n+     *\n+     * <p>While it's not safe in the general case to ignore exceptions that are thrown when aborting an\n+     * I/O resource, it should generally be safe in the case of a resource that's being used only for\n+     * reading.\n+     *\n+     * @param abortable the {@code AsyncAbortable} to be closed, or {@code null} in which case this method\n+     *                  does nothing.\n+     */\n+    public static void abortQuietly(@Nullable AsyncAbortable abortable) {\n+        try {\n+            abort(abortable, true);\n+        } catch (IOException e) {\n+            log.error(\"Unexpected IOException thrown while aborting Abortable {} quietly : \", abortable, e);\n+        }\n+    }\n+\n+    /**\n+     * Abort the abortables in sequence.\n+     *\n+     * @param executorService\n+     *          executor service to execute\n+     * @param abortables\n+     *          abortables to abort\n+     * @return future represents the abort future\n+     */\n+    public static CompletableFuture<Void> abortSequence(ExecutorService executorService,\n+                                             AsyncAbortable... abortables) {\n+        List<AsyncAbortable> abortableList = Lists.newArrayListWithExpectedSize(abortables.length);\n+        for (AsyncAbortable abortable : abortables) {\n+            if (null == abortable) {\n+                abortableList.add(AsyncAbortable.NULL);\n+            } else {\n+                abortableList.add(abortable);\n+            }\n+        }\n+        return FutureUtils.processList(\n+            abortableList,\n+            AsyncAbortable.ABORT_FUNC,\n+            executorService\n+        ).thenApply(VoidFunctions.LIST_TO_VOID_FUNC);\n+    }\n+}"},{"sha":"7636c570613c2bc94f0b60b298adc2493029c376","filename":"src/main/java/org/apache/distributedlog/io/AsyncAbortable.java","status":"added","additions":48,"deletions":0,"changes":48,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fio%2FAsyncAbortable.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fio%2FAsyncAbortable.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fio%2FAsyncAbortable.java?ref=7e63cff1c110b7b9435a88ab8ab321659057c298","patch":"@@ -0,0 +1,48 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.distributedlog.io;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Function;\n+import org.apache.distributedlog.common.concurrent.FutureUtils;\n+\n+/**\n+ * An {@code Abortable} is a source or destination of data that can be aborted.\n+ * The abort method is invoked to release resources that the object is holding\n+ * (such as open files). The abort happens when the object is in an error state,\n+ * which it couldn't be closed gracefully.\n+ *\n+ * @see AsyncCloseable\n+ * @see Abortable\n+ * @since 0.3.43\n+ */\n+public interface AsyncAbortable {\n+\n+    Function<AsyncAbortable, CompletableFuture<Void>> ABORT_FUNC = abortable -> abortable.asyncAbort();\n+\n+    AsyncAbortable NULL = () -> FutureUtils.Void();\n+\n+    /**\n+     * Aborts the object and releases any resources associated with it.\n+     * If the object is already aborted then invoking this method has no\n+     * effect.\n+     *\n+     * @return future represents the abort result\n+     */\n+    CompletableFuture<Void> asyncAbort();\n+}"},{"sha":"851f426e3b1df89b9c71bf792fc39d85aa0329bb","filename":"src/main/java/org/apache/distributedlog/io/AsyncCloseable.java","status":"added","additions":46,"deletions":0,"changes":46,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fio%2FAsyncCloseable.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fio%2FAsyncCloseable.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fio%2FAsyncCloseable.java?ref=7e63cff1c110b7b9435a88ab8ab321659057c298","patch":"@@ -0,0 +1,46 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.distributedlog.io;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Function;\n+import org.apache.distributedlog.common.concurrent.FutureUtils;\n+\n+/**\n+ * A {@code AsyncCloseable} is a source or destination of data that can be closed asynchronously.\n+ * The close method is invoked to release resources that the object is\n+ * holding (such as open files).\n+ */\n+public interface AsyncCloseable {\n+\n+    Function<AsyncCloseable, CompletableFuture<Void>> CLOSE_FUNC = closeable -> closeable.asyncClose();\n+\n+    Function<AsyncCloseable, CompletableFuture<Void>> CLOSE_FUNC_IGNORE_ERRORS =\n+        closeable -> FutureUtils.ignore(closeable.asyncClose());\n+\n+    AsyncCloseable NULL = () -> FutureUtils.Void();\n+\n+    /**\n+     * Closes this source and releases any system resources associated\n+     * with it. If the source is already closed then invoking this\n+     * method has no effect.\n+     *\n+     * @return future representing the close result.\n+     */\n+    CompletableFuture<Void> asyncClose();\n+}"},{"sha":"f7c3e3bf876ba3bf29d245e8e26e0a3319c388d9","filename":"src/main/java/org/apache/distributedlog/io/AsyncDeleteable.java","status":"added","additions":34,"deletions":0,"changes":34,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fio%2FAsyncDeleteable.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fio%2FAsyncDeleteable.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fio%2FAsyncDeleteable.java?ref=7e63cff1c110b7b9435a88ab8ab321659057c298","patch":"@@ -0,0 +1,34 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.distributedlog.io;\n+\n+import java.util.concurrent.CompletableFuture;\n+\n+/**\n+ * A {@code AsyncDeleteable} is a source or destination of data that can be deleted asynchronously.\n+ * This delete method is invoked to delete the source.\n+ */\n+public interface AsyncDeleteable {\n+    /**\n+     * Releases any system resources associated with this and delete the source. If the source is\n+     * already deleted then invoking this method has no effect.\n+     *\n+     * @return future representing the deletion result.\n+     */\n+    CompletableFuture<Void> delete();\n+}"},{"sha":"c8e957f44dccffa26b7ca0d15adbffcb503f1cb9","filename":"src/main/java/org/apache/distributedlog/io/package-info.java","status":"added","additions":21,"deletions":0,"changes":21,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fio%2Fpackage-info.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fio%2Fpackage-info.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fio%2Fpackage-info.java?ref=7e63cff1c110b7b9435a88ab8ab321659057c298","patch":"@@ -0,0 +1,21 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+/**\n+ * IO Utils for distributedlog.\n+ */\n+package org.apache.distributedlog.io;"},{"sha":"89b448e809ddcd82af22c9e3594ba93e6b28034f","filename":"src/main/java/org/apache/distributedlog/util/OrderedScheduler.java","status":"added","additions":353,"deletions":0,"changes":353,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Futil%2FOrderedScheduler.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Futil%2FOrderedScheduler.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Futil%2FOrderedScheduler.java?ref=7e63cff1c110b7b9435a88ab8ab321659057c298","patch":"@@ -0,0 +1,353 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.distributedlog.util;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import org.apache.distributedlog.common.concurrent.FutureUtils;\n+import org.apache.distributedlog.common.util.MathUtil;\n+\n+/**\n+ * Ordered Scheduler. It is thread pool based {@link ScheduledExecutorService}, additionally providing\n+ * the ability to execute/schedule tasks by <code>key</code>. Hence the tasks submitted by same <i>key</i>\n+ * will be executed in order.\n+ *\n+ * <p>The scheduler is comprised of multiple {@link ScheduledExecutorService}s. Each\n+ * {@link ScheduledExecutorService} is a single thread executor. Normal task submissions will\n+ * be submitted to executors in a random manner to guarantee load balancing. Keyed task submissions (e.g\n+ * {@link OrderedScheduler#submit(Object, Runnable)} will be submitted to a dedicated executor based on\n+ * the hash value of submit <i>key</i>.\n+ */\n+public class OrderedScheduler implements ScheduledExecutorService {\n+\n+    /**\n+     * Create a builder to build scheduler.\n+     *\n+     * @return scheduler builder\n+     */\n+    public static Builder newBuilder() {\n+        return new Builder();\n+    }\n+\n+    /**\n+     * Builder for {@link OrderedScheduler}.\n+     */\n+    public static class Builder {\n+\n+        private String name = \"OrderedScheduler\";\n+        private int corePoolSize = -1;\n+        private ThreadFactory threadFactory = null;\n+\n+        /**\n+         * Set the name of this scheduler. It would be used as part of stats scope and thread name.\n+         *\n+         * @param name name of the scheduler.\n+         * @return scheduler builder\n+         */\n+        public Builder name(String name) {\n+            this.name = name;\n+            return this;\n+        }\n+\n+        /**\n+         * Set the number of threads to be used in this scheduler.\n+         *\n+         * @param corePoolSize the number of threads to keep in the pool, even\n+         *                     if they are idle\n+         * @return scheduler builder\n+         */\n+        public Builder corePoolSize(int corePoolSize) {\n+            this.corePoolSize = corePoolSize;\n+            return this;\n+        }\n+\n+        /**\n+         * Set the thread factory that the scheduler uses to create a new thread.\n+         *\n+         * @param threadFactory the factory to use when the executor\n+         *                      creates a new thread\n+         * @return scheduler builder\n+         */\n+        public Builder threadFactory(ThreadFactory threadFactory) {\n+            this.threadFactory = threadFactory;\n+            return this;\n+        }\n+\n+        /**\n+         * Build the ordered scheduler.\n+         *\n+         * @return ordered scheduler\n+         */\n+        public OrderedScheduler build() {\n+            if (corePoolSize <= 0) {\n+                corePoolSize = Runtime.getRuntime().availableProcessors();\n+            }\n+            if (null == threadFactory) {\n+                threadFactory = Executors.defaultThreadFactory();\n+            }\n+\n+            return new OrderedScheduler(\n+                name,\n+                corePoolSize,\n+                threadFactory);\n+        }\n+\n+    }\n+\n+    protected final String name;\n+    protected final int corePoolSize;\n+    protected final ScheduledExecutorService[] executors;\n+    protected final Random random;\n+\n+    private OrderedScheduler(String name,\n+                             int corePoolSize,\n+                             ThreadFactory threadFactory) {\n+        this.name = name;\n+        this.corePoolSize = corePoolSize;\n+        this.executors = new ScheduledExecutorService[corePoolSize];\n+        for (int i = 0; i < corePoolSize; i++) {\n+            ThreadFactory tf = new ThreadFactoryBuilder()\n+                .setNameFormat(name + \"-scheduler-\" + i + \"-%d\")\n+                .setThreadFactory(threadFactory)\n+                .build();\n+            executors[i] = Executors.newSingleThreadScheduledExecutor(tf);\n+        }\n+        this.random = new Random(System.currentTimeMillis());\n+    }\n+\n+    protected ScheduledExecutorService chooseExecutor() {\n+        return corePoolSize == 1 ? executors[0] : executors[random.nextInt(corePoolSize)];\n+    }\n+\n+    public ScheduledExecutorService chooseExecutor(Object key) {\n+        if (null == key) {\n+            return chooseExecutor();\n+        }\n+        return corePoolSize == 1 ? executors[0] :\n+            executors[MathUtil.signSafeMod(Objects.hashCode(key), corePoolSize)];\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit) {\n+        return chooseExecutor().schedule(command, delay, unit);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public <V> ScheduledFuture<V> schedule(Callable<V> callable, long delay, TimeUnit unit) {\n+        return chooseExecutor().schedule(callable, delay, unit);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public ScheduledFuture<?> scheduleAtFixedRate(Runnable command,\n+                                                  long initialDelay, long period, TimeUnit unit) {\n+        return chooseExecutor().scheduleAtFixedRate(command, initialDelay, period, unit);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public ScheduledFuture<?> scheduleWithFixedDelay(Runnable command,\n+                                                     long initialDelay, long delay, TimeUnit unit) {\n+        return chooseExecutor().scheduleWithFixedDelay(command, initialDelay, delay, unit);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void shutdown() {\n+        for (ScheduledExecutorService executor : executors) {\n+            executor.shutdown();\n+        }\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public List<Runnable> shutdownNow() {\n+        List<Runnable> runnables = new ArrayList<Runnable>();\n+        for (ScheduledExecutorService executor : executors) {\n+            runnables.addAll(executor.shutdownNow());\n+        }\n+        return runnables;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public boolean isShutdown() {\n+        for (ScheduledExecutorService executor : executors) {\n+            if (!executor.isShutdown()) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public boolean isTerminated() {\n+        for (ScheduledExecutorService executor : executors) {\n+            if (!executor.isTerminated()) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public boolean awaitTermination(long timeout, TimeUnit unit)\n+        throws InterruptedException {\n+        for (ScheduledExecutorService executor : executors) {\n+            if (!executor.awaitTermination(timeout, unit)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public <T> Future<T> submit(Callable<T> task) {\n+        return chooseExecutor().submit(task);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public <T> Future<T> submit(Runnable task, T result) {\n+        return chooseExecutor().submit(task, result);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public Future<?> submit(Runnable task) {\n+        return chooseExecutor().submit(task);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)\n+        throws InterruptedException {\n+        return chooseExecutor().invokeAll(tasks);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n+        throws InterruptedException {\n+        return chooseExecutor().invokeAll(tasks, timeout, unit);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public <T> T invokeAny(Collection<? extends Callable<T>> tasks)\n+        throws InterruptedException, ExecutionException {\n+        return chooseExecutor().invokeAny(tasks);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n+        throws InterruptedException, ExecutionException, TimeoutException {\n+        return chooseExecutor().invokeAny(tasks, timeout, unit);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void execute(Runnable command) {\n+        chooseExecutor().execute(command);\n+    }\n+\n+    // Ordered Functions\n+\n+    public ScheduledFuture<?> schedule(Object key, Runnable command, long delay, TimeUnit unit) {\n+        return chooseExecutor(key).schedule(command, delay, unit);\n+    }\n+\n+    public ScheduledFuture<?> scheduleAtFixedRate(Object key,\n+                                                  Runnable command,\n+                                                  long initialDelay,\n+                                                  long period,\n+                                                  TimeUnit unit) {\n+        return chooseExecutor(key).scheduleAtFixedRate(command, initialDelay, period, unit);\n+    }\n+\n+    public Future<?> submit(Object key, Runnable command) {\n+        return chooseExecutor(key).submit(command);\n+    }\n+\n+    public <T> CompletableFuture<T> submit(Object key, Callable<T> callable) {\n+        CompletableFuture<T> future = FutureUtils.createFuture();\n+        chooseExecutor(key).submit(() -> {\n+            try {\n+                future.complete(callable.call());\n+            } catch (Exception e) {\n+                future.completeExceptionally(e);\n+            }\n+        });\n+        return future;\n+    }\n+\n+}"},{"sha":"ee17950eda1ddf97ba4c06a135fcfbd27999d07f","filename":"src/main/java/org/apache/distributedlog/util/package-info.java","status":"added","additions":21,"deletions":0,"changes":21,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Futil%2Fpackage-info.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Futil%2Fpackage-info.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Futil%2Fpackage-info.java?ref=7e63cff1c110b7b9435a88ab8ab321659057c298","patch":"@@ -0,0 +1,21 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+/**\n+ * defines the utilities used across the project.\n+ */\n+package org.apache.distributedlog.util;"},{"sha":"ce2c176978157db1bce5e67462bfe9d610c44705","filename":"src/main/resources/findbugsExclude.xml","status":"added","additions":32,"deletions":0,"changes":32,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Fmain%2Fresources%2FfindbugsExclude.xml","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Fmain%2Fresources%2FfindbugsExclude.xml","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fresources%2FfindbugsExclude.xml?ref=7e63cff1c110b7b9435a88ab8ab321659057c298","patch":"@@ -0,0 +1,32 @@\n+<!--\n+    Licensed to the Apache Software Foundation (ASF) under one\n+    or more contributor license agreements.  See the NOTICE file\n+    distributed with this work for additional information\n+    regarding copyright ownership.  The ASF licenses this file\n+    to you under the Apache License, Version 2.0 (the\n+    \"License\"); you may not use this file except in compliance\n+    with the License.  You may obtain a copy of the License at\n+\n+      http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+//-->\n+<FindBugsFilter>\n+  <Match>\n+    <Class name=\"org.apache.distributedlog.common.concurrent.FutureUtils\"/>\n+    <Bug pattern=\"NP_NULL_PARAM_DEREF_NONVIRTUAL\" />\n+  </Match>\n+  <Match>\n+    <Class name=\"org.apache.distributedlog.common.concurrent.FutureUtils$2\"/>\n+    <Bug pattern=\"NP_NONNULL_PARAM_VIOLATION\" />\n+  </Match>\n+  <Match>\n+    <Class name=\"org.apache.distributedlog.common.concurrent.FutureUtils\"/>\n+    <Method name=\"Void\" />\n+    <Bug pattern=\"NM_METHOD_NAMING_CONVENTION\" />\n+  </Match>\n+</FindBugsFilter>"},{"sha":"ddfb7aed80be99c1459ca045e7392a2ca06e51dc","filename":"src/test/java/org/apache/distributedlog/common/concurrent/TestFutureUtils.java","status":"added","additions":384,"deletions":0,"changes":384,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Fconcurrent%2FTestFutureUtils.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Fconcurrent%2FTestFutureUtils.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Fconcurrent%2FTestFutureUtils.java?ref=7e63cff1c110b7b9435a88ab8ab321659057c298","patch":"@@ -0,0 +1,384 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.distributedlog.common.concurrent;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.anyLong;\n+import static org.mockito.Matchers.anyObject;\n+import static org.mockito.Matchers.eq;\n+import static org.mockito.Matchers.isA;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import com.google.common.base.Stopwatch;\n+import com.google.common.collect.Lists;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Function;\n+import java.util.stream.LongStream;\n+import org.apache.bookkeeper.stats.OpStatsLogger;\n+import org.apache.distributedlog.util.OrderedScheduler;\n+import org.junit.Test;\n+\n+/**\n+ * Unit Test for {@link FutureUtils}.\n+ */\n+public class TestFutureUtils {\n+\n+    /**\n+     * Test Exception.\n+     */\n+    static class TestException extends IOException {\n+        private static final long serialVersionUID = -6256482498453846308L;\n+\n+        public TestException() {\n+            super(\"test-exception\");\n+        }\n+    }\n+\n+    @Test\n+    public void testComplete() throws Exception {\n+        CompletableFuture<Long> future = FutureUtils.createFuture();\n+        FutureUtils.complete(future, 1024L);\n+        assertEquals(1024L, FutureUtils.result(future).longValue());\n+    }\n+\n+    @Test(expected = TestException.class)\n+    public void testCompleteExceptionally() throws Exception {\n+        CompletableFuture<Long> future = FutureUtils.createFuture();\n+        FutureUtils.completeExceptionally(future, new TestException());\n+        FutureUtils.result(future);\n+    }\n+\n+    @Test\n+    public void testWhenCompleteAsync() throws Exception {\n+        OrderedScheduler scheduler = OrderedScheduler.newBuilder()\n+            .name(\"test-when-complete-async\")\n+            .corePoolSize(1)\n+            .build();\n+        AtomicLong resultHolder = new AtomicLong(0L);\n+        CountDownLatch latch = new CountDownLatch(1);\n+        CompletableFuture<Long> future = FutureUtils.createFuture();\n+        FutureUtils.whenCompleteAsync(\n+            future,\n+            (result, cause) -> {\n+                resultHolder.set(result);\n+                latch.countDown();\n+            },\n+            scheduler,\n+            new Object());\n+        FutureUtils.complete(future, 1234L);\n+        latch.await();\n+        assertEquals(1234L, resultHolder.get());\n+    }\n+\n+    @Test\n+    public void testProxyToSuccess() throws Exception {\n+        CompletableFuture<Long> src = FutureUtils.createFuture();\n+        CompletableFuture<Long> target = FutureUtils.createFuture();\n+        FutureUtils.proxyTo(src, target);\n+        FutureUtils.complete(src, 10L);\n+        assertEquals(10L, FutureUtils.result(target).longValue());\n+    }\n+\n+    @Test(expected = TestException.class)\n+    public void testProxyToFailure() throws Exception {\n+        CompletableFuture<Long> src = FutureUtils.createFuture();\n+        CompletableFuture<Long> target = FutureUtils.createFuture();\n+        FutureUtils.proxyTo(src, target);\n+        FutureUtils.completeExceptionally(src, new TestException());\n+        FutureUtils.result(target);\n+    }\n+\n+    @Test\n+    public void testVoid() throws Exception {\n+        CompletableFuture<Void> voidFuture = FutureUtils.Void();\n+        assertTrue(voidFuture.isDone());\n+        assertFalse(voidFuture.isCompletedExceptionally());\n+        assertFalse(voidFuture.isCancelled());\n+    }\n+\n+    @Test\n+    public void testCollectEmptyList() throws Exception {\n+        List<CompletableFuture<Integer>> futures = Lists.newArrayList();\n+        List<Integer> result = FutureUtils.result(FutureUtils.collect(futures));\n+        assertTrue(result.isEmpty());\n+    }\n+\n+    @Test\n+    public void testCollectTenItems() throws Exception {\n+        List<CompletableFuture<Integer>> futures = Lists.newArrayList();\n+        List<Integer> expectedResults = Lists.newArrayList();\n+        for (int i = 0; i < 10; i++) {\n+            futures.add(FutureUtils.value(i));\n+            expectedResults.add(i);\n+        }\n+        List<Integer> results = FutureUtils.result(FutureUtils.collect(futures));\n+        assertEquals(expectedResults, results);\n+    }\n+\n+    @Test(expected = TestException.class)\n+    public void testCollectFailures() throws Exception {\n+        List<CompletableFuture<Integer>> futures = Lists.newArrayList();\n+        List<Integer> expectedResults = Lists.newArrayList();\n+        for (int i = 0; i < 10; i++) {\n+            if (i == 9) {\n+                futures.add(FutureUtils.value(i));\n+            } else {\n+                futures.add(FutureUtils.exception(new TestException()));\n+            }\n+            expectedResults.add(i);\n+        }\n+        FutureUtils.result(FutureUtils.collect(futures));\n+    }\n+\n+    @Test\n+    public void testWithinAlreadyDone() throws Exception {\n+        OrderedScheduler scheduler = mock(OrderedScheduler.class);\n+        CompletableFuture<Long> doneFuture = FutureUtils.value(1234L);\n+        CompletableFuture<Long> withinFuture = FutureUtils.within(\n+            doneFuture,\n+            10,\n+            TimeUnit.MILLISECONDS,\n+            new TestException(),\n+            scheduler,\n+            1234L);\n+        TimeUnit.MILLISECONDS.sleep(20);\n+        assertTrue(withinFuture.isDone());\n+        assertFalse(withinFuture.isCancelled());\n+        assertFalse(withinFuture.isCompletedExceptionally());\n+        verify(scheduler, times(0))\n+            .schedule(eq(1234L), isA(Runnable.class), eq(10), eq(TimeUnit.MILLISECONDS));\n+    }\n+\n+    @Test\n+    public void testWithinZeroTimeout() throws Exception {\n+        OrderedScheduler scheduler = mock(OrderedScheduler.class);\n+        CompletableFuture<Long> newFuture = FutureUtils.createFuture();\n+        CompletableFuture<Long> withinFuture = FutureUtils.within(\n+            newFuture,\n+            0,\n+            TimeUnit.MILLISECONDS,\n+            new TestException(),\n+            scheduler,\n+            1234L);\n+        TimeUnit.MILLISECONDS.sleep(20);\n+        assertFalse(withinFuture.isDone());\n+        assertFalse(withinFuture.isCancelled());\n+        assertFalse(withinFuture.isCompletedExceptionally());\n+        verify(scheduler, times(0))\n+            .schedule(eq(1234L), isA(Runnable.class), eq(10), eq(TimeUnit.MILLISECONDS));\n+    }\n+\n+    @Test\n+    public void testWithinCompleteBeforeTimeout() throws Exception {\n+        OrderedScheduler scheduler = mock(OrderedScheduler.class);\n+        ScheduledFuture<?> scheduledFuture = mock(ScheduledFuture.class);\n+        when(scheduler.schedule(anyObject(), any(Runnable.class), anyLong(), any(TimeUnit.class)))\n+            .thenAnswer(invocationOnMock -> scheduledFuture);\n+        CompletableFuture<Long> newFuture = FutureUtils.createFuture();\n+        CompletableFuture<Long> withinFuture = FutureUtils.within(\n+            newFuture,\n+            Long.MAX_VALUE,\n+            TimeUnit.MILLISECONDS,\n+            new TestException(),\n+            scheduler,\n+            1234L);\n+        assertFalse(withinFuture.isDone());\n+        assertFalse(withinFuture.isCancelled());\n+        assertFalse(withinFuture.isCompletedExceptionally());\n+\n+        newFuture.complete(5678L);\n+\n+        assertTrue(withinFuture.isDone());\n+        assertFalse(withinFuture.isCancelled());\n+        assertFalse(withinFuture.isCompletedExceptionally());\n+        assertEquals((Long) 5678L, FutureUtils.result(withinFuture));\n+\n+        verify(scheduledFuture, times(1))\n+            .cancel(eq(true));\n+    }\n+\n+    @Test\n+    public void testIgnoreSuccess() {\n+        CompletableFuture<Long> underlyFuture = FutureUtils.createFuture();\n+        CompletableFuture<Void> ignoredFuture = FutureUtils.ignore(underlyFuture);\n+        underlyFuture.complete(1234L);\n+        assertTrue(ignoredFuture.isDone());\n+        assertFalse(ignoredFuture.isCompletedExceptionally());\n+        assertFalse(ignoredFuture.isCancelled());\n+    }\n+\n+    @Test\n+    public void testIgnoreFailure() {\n+        CompletableFuture<Long> underlyFuture = FutureUtils.createFuture();\n+        CompletableFuture<Void> ignoredFuture = FutureUtils.ignore(underlyFuture);\n+        underlyFuture.completeExceptionally(new TestException());\n+        assertTrue(ignoredFuture.isDone());\n+        assertFalse(ignoredFuture.isCompletedExceptionally());\n+        assertFalse(ignoredFuture.isCancelled());\n+    }\n+\n+    @Test\n+    public void testEnsureSuccess() throws Exception {\n+        CountDownLatch ensureLatch = new CountDownLatch(1);\n+        CompletableFuture<Long> underlyFuture = FutureUtils.createFuture();\n+        CompletableFuture<Long> ensuredFuture = FutureUtils.ensure(underlyFuture, () -> {\n+            ensureLatch.countDown();\n+        });\n+        underlyFuture.complete(1234L);\n+        FutureUtils.result(ensuredFuture);\n+        assertTrue(ensuredFuture.isDone());\n+        assertFalse(ensuredFuture.isCompletedExceptionally());\n+        assertFalse(ensuredFuture.isCancelled());\n+        ensureLatch.await();\n+    }\n+\n+    @Test\n+    public void testEnsureFailure() throws Exception {\n+        CountDownLatch ensureLatch = new CountDownLatch(1);\n+        CompletableFuture<Long> underlyFuture = FutureUtils.createFuture();\n+        CompletableFuture<Long> ensuredFuture = FutureUtils.ensure(underlyFuture, () -> {\n+            ensureLatch.countDown();\n+        });\n+        underlyFuture.completeExceptionally(new TestException());\n+        FutureUtils.result(FutureUtils.ignore(ensuredFuture));\n+        assertTrue(ensuredFuture.isDone());\n+        assertTrue(ensuredFuture.isCompletedExceptionally());\n+        assertFalse(ensuredFuture.isCancelled());\n+        ensureLatch.await();\n+    }\n+\n+    @Test\n+    public void testRescueSuccess() throws Exception {\n+        CompletableFuture<Long> underlyFuture = FutureUtils.createFuture();\n+        Function<Throwable, CompletableFuture<Long>> rescueFuc = mock(Function.class);\n+        CompletableFuture<Long> rescuedFuture = FutureUtils.rescue(underlyFuture, rescueFuc);\n+        underlyFuture.complete(1234L);\n+        FutureUtils.result(rescuedFuture);\n+        assertTrue(rescuedFuture.isDone());\n+        assertFalse(rescuedFuture.isCompletedExceptionally());\n+        assertFalse(rescuedFuture.isCancelled());\n+        verify(rescueFuc, times(0)).apply(any(Throwable.class));\n+    }\n+\n+    @Test\n+    public void testRescueFailure() throws Exception {\n+        CompletableFuture<Long> futureCompletedAtRescue = FutureUtils.value(3456L);\n+        CompletableFuture<Long> underlyFuture = FutureUtils.createFuture();\n+        CompletableFuture<Long> rescuedFuture = FutureUtils.rescue(underlyFuture, (cause) -> futureCompletedAtRescue);\n+        underlyFuture.completeExceptionally(new TestException());\n+        FutureUtils.result(rescuedFuture);\n+        assertTrue(rescuedFuture.isDone());\n+        assertFalse(rescuedFuture.isCompletedExceptionally());\n+        assertFalse(rescuedFuture.isCancelled());\n+        assertEquals((Long) 3456L, FutureUtils.result(rescuedFuture));\n+    }\n+\n+    @Test\n+    public void testStatsSuccess() throws Exception {\n+        OpStatsLogger statsLogger = mock(OpStatsLogger.class);\n+        CompletableFuture<Long> underlyFuture = FutureUtils.createFuture();\n+        CompletableFuture<Long> statsFuture = FutureUtils.stats(\n+            underlyFuture,\n+            statsLogger,\n+            Stopwatch.createStarted());\n+        underlyFuture.complete(1234L);\n+        FutureUtils.result(statsFuture);\n+        verify(statsLogger, times(1)).registerSuccessfulEvent(anyLong());\n+    }\n+\n+    @Test\n+    public void testStatsFailure() throws Exception {\n+        OpStatsLogger statsLogger = mock(OpStatsLogger.class);\n+        CompletableFuture<Long> underlyFuture = FutureUtils.createFuture();\n+        CompletableFuture<Long> statsFuture = FutureUtils.stats(\n+            underlyFuture,\n+            statsLogger,\n+            Stopwatch.createStarted());\n+        underlyFuture.completeExceptionally(new TestException());\n+        FutureUtils.result(FutureUtils.ignore(statsFuture));\n+        verify(statsLogger, times(1)).registerFailedEvent(anyLong());\n+    }\n+\n+    @Test\n+    public void testProcessListSuccess() throws Exception {\n+        List<Long> longList = Lists.newArrayList(LongStream.range(0L, 10L).iterator());\n+        List<Long> expectedList = Lists.transform(\n+            longList,\n+            aLong -> 2 * aLong);\n+        Function<Long, CompletableFuture<Long>> sumFunc = value -> FutureUtils.value(2 * value);\n+        CompletableFuture<List<Long>> totalFuture = FutureUtils.processList(\n+            longList,\n+            sumFunc,\n+            null);\n+        assertEquals(expectedList, FutureUtils.result(totalFuture));\n+    }\n+\n+    @Test\n+    public void testProcessEmptyList() throws Exception {\n+        List<Long> longList = Lists.newArrayList();\n+        List<Long> expectedList = Lists.transform(\n+            longList,\n+            aLong -> 2 * aLong);\n+        Function<Long, CompletableFuture<Long>> sumFunc = value -> FutureUtils.value(2 * value);\n+        CompletableFuture<List<Long>> totalFuture = FutureUtils.processList(\n+            longList,\n+            sumFunc,\n+            null);\n+        assertEquals(expectedList, FutureUtils.result(totalFuture));\n+    }\n+\n+    @Test\n+    public void testProcessListFailures() throws Exception {\n+        List<Long> longList = Lists.newArrayList(LongStream.range(0L, 10L).iterator());\n+        AtomicLong total = new AtomicLong(0L);\n+        Function<Long, CompletableFuture<Long>> sumFunc = value -> {\n+            if (value < 5) {\n+                total.addAndGet(value);\n+                return FutureUtils.value(2 * value);\n+            } else {\n+                return FutureUtils.exception(new TestException());\n+            }\n+        };\n+        CompletableFuture<List<Long>> totalFuture = FutureUtils.processList(\n+            longList,\n+            sumFunc,\n+            null);\n+        try {\n+            FutureUtils.result(totalFuture);\n+            fail(\"Should fail with TestException\");\n+        } catch (TestException te) {\n+            // as expected\n+        }\n+        assertEquals(10L, total.get());\n+    }\n+\n+}"},{"sha":"6b3ca584c292b225f76bf70563bb9f656c7c5774","filename":"src/test/java/org/apache/distributedlog/common/config/PropertiesWriter.java","status":"added","additions":69,"deletions":0,"changes":69,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Fconfig%2FPropertiesWriter.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Fconfig%2FPropertiesWriter.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Fconfig%2FPropertiesWriter.java?ref=7e63cff1c110b7b9435a88ab8ab321659057c298","patch":"@@ -0,0 +1,69 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.distributedlog.common.config;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.util.Properties;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Writer to write properties to files.\n+ */\n+public class PropertiesWriter {\n+    static final Logger LOG = LoggerFactory.getLogger(PropertiesWriter.class);\n+\n+    final FileOutputStream outputStream;\n+    final File configFile;\n+    final Properties properties;\n+\n+    public PropertiesWriter() throws Exception {\n+        this(null);\n+    }\n+\n+    public PropertiesWriter(File configFile) throws Exception {\n+        if (null == configFile) {\n+            this.configFile = File.createTempFile(\"temp\", \".conf\");\n+        } else {\n+            this.configFile = configFile;\n+        }\n+        this.configFile.deleteOnExit();\n+        this.properties = new Properties();\n+        this.outputStream = new FileOutputStream(this.configFile);\n+    }\n+\n+    public void setProperty(String key, String value) {\n+        properties.setProperty(key, value);\n+    }\n+\n+    public void removeProperty(String key) {\n+        properties.remove(key);\n+    }\n+\n+    public void save() throws Exception {\n+        FileOutputStream outputStream = new FileOutputStream(configFile);\n+        properties.store(outputStream, null);\n+        configFile.setLastModified(configFile.lastModified() + 1000);\n+        LOG.debug(\"save modified={}\", configFile.lastModified());\n+    }\n+\n+    public File getFile() {\n+        return configFile;\n+    }\n+}"},{"sha":"a54faa04162bc3454128449309e78a26a4a776c5","filename":"src/test/java/org/apache/distributedlog/common/config/TestConcurrentBaseConfiguration.java","status":"added","additions":47,"deletions":0,"changes":47,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Fconfig%2FTestConcurrentBaseConfiguration.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Fconfig%2FTestConcurrentBaseConfiguration.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Fconfig%2FTestConcurrentBaseConfiguration.java?ref=7e63cff1c110b7b9435a88ab8ab321659057c298","patch":"@@ -0,0 +1,47 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.distributedlog.common.config;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+import org.junit.Test;\n+\n+/**\n+ * Unit test of {@link ConcurrentBaseConfiguration}.\n+ */\n+public class TestConcurrentBaseConfiguration {\n+\n+    @Test(timeout = 20000)\n+    public void testBasicOperations() throws Exception {\n+        ConcurrentBaseConfiguration conf = new ConcurrentBaseConfiguration();\n+        conf.setProperty(\"prop1\", \"1\");\n+        assertEquals(1, conf.getInt(\"prop1\"));\n+        conf.setProperty(\"prop1\", \"2\");\n+        assertEquals(2, conf.getInt(\"prop1\"));\n+        conf.clearProperty(\"prop1\");\n+        assertEquals(null, conf.getInteger(\"prop1\", null));\n+        conf.setProperty(\"prop1\", \"1\");\n+        conf.setProperty(\"prop2\", \"2\");\n+        assertEquals(1, conf.getInt(\"prop1\"));\n+        assertEquals(2, conf.getInt(\"prop2\"));\n+        conf.clearProperty(\"prop1\");\n+        assertEquals(null, conf.getInteger(\"prop1\", null));\n+        assertEquals(2, conf.getInt(\"prop2\"));\n+    }\n+\n+}"},{"sha":"a474f894186fa17a6c63e70e16e09efdb39e9020","filename":"src/test/java/org/apache/distributedlog/common/config/TestConfigurationSubscription.java","status":"added","additions":173,"deletions":0,"changes":173,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Fconfig%2FTestConfigurationSubscription.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Fconfig%2FTestConfigurationSubscription.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Fconfig%2FTestConfigurationSubscription.java?ref=7e63cff1c110b7b9435a88ab8ab321659057c298","patch":"@@ -0,0 +1,173 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.distributedlog.common.config;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import com.google.common.collect.Lists;\n+import java.util.List;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.apache.commons.configuration.CompositeConfiguration;\n+import org.apache.commons.configuration.event.ConfigurationEvent;\n+import org.apache.commons.configuration.event.ConfigurationListener;\n+import org.jmock.lib.concurrent.DeterministicScheduler;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Notes:\n+ * 1. lastModified granularity is platform dependent, generally 1 sec, so we can't wait 1ms for things to\n+ * get picked up.\n+ */\n+public class TestConfigurationSubscription {\n+    static final Logger LOG = LoggerFactory.getLogger(TestConfigurationSubscription.class);\n+\n+    /**\n+     * Give FileChangedReloadingStrategy some time to start reloading.\n+     *\n+     * <p>Make sure now!=lastChecked\n+     * {@link org.apache.commons.configuration.reloading.FileChangedReloadingStrategy#reloadingRequired()}\n+     */\n+    private void ensureConfigReloaded() throws InterruptedException {\n+        // sleep 1 ms so that System.currentTimeMillis() !=\n+        // lastChecked (the time we construct FileChangedReloadingStrategy\n+        Thread.sleep(1);\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testReloadConfiguration() throws Exception {\n+        PropertiesWriter writer = new PropertiesWriter();\n+        FileConfigurationBuilder builder = new PropertiesConfigurationBuilder(writer.getFile().toURI().toURL());\n+        ConcurrentConstConfiguration conf = new ConcurrentConstConfiguration(new CompositeConfiguration());\n+        DeterministicScheduler executorService = new DeterministicScheduler();\n+        List<FileConfigurationBuilder> fileConfigBuilders = Lists.newArrayList(builder);\n+        ConfigurationSubscription confSub =\n+                new ConfigurationSubscription(conf, fileConfigBuilders, executorService, 100, TimeUnit.MILLISECONDS);\n+        final AtomicReference<ConcurrentBaseConfiguration> confHolder = new AtomicReference<>();\n+        confSub.registerListener(new org.apache.distributedlog.common.config.ConfigurationListener() {\n+            @Override\n+            public void onReload(ConcurrentBaseConfiguration conf) {\n+                confHolder.set(conf);\n+            }\n+        });\n+        assertEquals(null, conf.getProperty(\"prop1\"));\n+\n+        // add\n+        writer.setProperty(\"prop1\", \"1\");\n+        writer.save();\n+        // ensure the file change reloading event can be triggered\n+        ensureConfigReloaded();\n+        // reload the config\n+        confSub.reload();\n+        assertNotNull(confHolder.get());\n+        assertTrue(conf == confHolder.get());\n+        assertEquals(\"1\", conf.getProperty(\"prop1\"));\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testAddReloadBasicsConfig() throws Exception {\n+        PropertiesWriter writer = new PropertiesWriter();\n+        DeterministicScheduler mockScheduler = new DeterministicScheduler();\n+        FileConfigurationBuilder builder = new PropertiesConfigurationBuilder(writer.getFile().toURI().toURL());\n+        ConcurrentConstConfiguration conf = new ConcurrentConstConfiguration(new CompositeConfiguration());\n+        List<FileConfigurationBuilder> fileConfigBuilders = Lists.newArrayList(builder);\n+        ConfigurationSubscription confSub =\n+                new ConfigurationSubscription(conf, fileConfigBuilders, mockScheduler, 100, TimeUnit.MILLISECONDS);\n+        assertEquals(null, conf.getProperty(\"prop1\"));\n+\n+        // add\n+        writer.setProperty(\"prop1\", \"1\");\n+        writer.save();\n+        // ensure the file change reloading event can be triggered\n+        ensureConfigReloaded();\n+        mockScheduler.tick(100, TimeUnit.MILLISECONDS);\n+        assertEquals(\"1\", conf.getProperty(\"prop1\"));\n+\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testInitialConfigLoad() throws Exception {\n+        PropertiesWriter writer = new PropertiesWriter();\n+        writer.setProperty(\"prop1\", \"1\");\n+        writer.setProperty(\"prop2\", \"abc\");\n+        writer.setProperty(\"prop3\", \"123.0\");\n+        writer.setProperty(\"prop4\", \"11132\");\n+        writer.setProperty(\"prop5\", \"true\");\n+        writer.save();\n+\n+        ScheduledExecutorService mockScheduler = new DeterministicScheduler();\n+        FileConfigurationBuilder builder = new PropertiesConfigurationBuilder(writer.getFile().toURI().toURL());\n+        ConcurrentConstConfiguration conf = new ConcurrentConstConfiguration(new CompositeConfiguration());\n+        List<FileConfigurationBuilder> fileConfigBuilders = Lists.newArrayList(builder);\n+        ConfigurationSubscription confSub =\n+                new ConfigurationSubscription(conf, fileConfigBuilders, mockScheduler, 100, TimeUnit.MILLISECONDS);\n+        assertEquals(1, conf.getInt(\"prop1\"));\n+        assertEquals(\"abc\", conf.getString(\"prop2\"));\n+        assertEquals(123.0, conf.getFloat(\"prop3\"), 0);\n+        assertEquals(11132, conf.getInt(\"prop4\"));\n+        assertEquals(true, conf.getBoolean(\"prop5\"));\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testExceptionInConfigLoad() throws Exception {\n+        PropertiesWriter writer = new PropertiesWriter();\n+        writer.setProperty(\"prop1\", \"1\");\n+        writer.save();\n+\n+        DeterministicScheduler mockScheduler = new DeterministicScheduler();\n+        FileConfigurationBuilder builder = new PropertiesConfigurationBuilder(writer.getFile().toURI().toURL());\n+        ConcurrentConstConfiguration conf = new ConcurrentConstConfiguration(new CompositeConfiguration());\n+        List<FileConfigurationBuilder> fileConfigBuilders = Lists.newArrayList(builder);\n+        ConfigurationSubscription confSub =\n+                new ConfigurationSubscription(conf, fileConfigBuilders, mockScheduler, 100, TimeUnit.MILLISECONDS);\n+\n+        final AtomicInteger count = new AtomicInteger(1);\n+        conf.addConfigurationListener(new ConfigurationListener() {\n+            @Override\n+            public void configurationChanged(ConfigurationEvent event) {\n+                LOG.info(\"config changed {}\", event);\n+                // Throw after so we actually see the update anyway.\n+                if (!event.isBeforeUpdate()) {\n+                    count.getAndIncrement();\n+                    throw new RuntimeException(\"config listener threw and exception\");\n+                }\n+            }\n+        });\n+\n+        int i = 0;\n+        int initial = 0;\n+        while (count.get() == initial) {\n+            writer.setProperty(\"prop1\", Integer.toString(i++));\n+            writer.save();\n+            mockScheduler.tick(100, TimeUnit.MILLISECONDS);\n+        }\n+\n+        initial = count.get();\n+        while (count.get() == initial) {\n+            writer.setProperty(\"prop1\", Integer.toString(i++));\n+            writer.save();\n+            mockScheduler.tick(100, TimeUnit.MILLISECONDS);\n+        }\n+    }\n+}"},{"sha":"7a981d1741a26aae08e6b9688a0c1bc911e644a8","filename":"src/test/java/org/apache/distributedlog/common/util/TestTimedOutTestsListener.java","status":"added","additions":183,"deletions":0,"changes":183,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Futil%2FTestTimedOutTestsListener.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Futil%2FTestTimedOutTestsListener.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Futil%2FTestTimedOutTestsListener.java?ref=7e63cff1c110b7b9435a88ab8ab321659057c298","patch":"@@ -0,0 +1,183 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.distributedlog.common.util;\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.util.concurrent.CyclicBarrier;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.junit.runner.notification.Failure;\n+\n+/**\n+ * Test Case for {@link TimedOutTestsListener}.\n+ */\n+public class TestTimedOutTestsListener {\n+\n+    private static class Deadlock {\n+        private CyclicBarrier barrier = new CyclicBarrier(6);\n+\n+        public Deadlock() {\n+            DeadlockThread[] dThreads = new DeadlockThread[6];\n+\n+            Monitor a = new Monitor(\"a\");\n+            Monitor b = new Monitor(\"b\");\n+            Monitor c = new Monitor(\"c\");\n+            dThreads[0] = new DeadlockThread(\"MThread-1\", a, b);\n+            dThreads[1] = new DeadlockThread(\"MThread-2\", b, c);\n+            dThreads[2] = new DeadlockThread(\"MThread-3\", c, a);\n+\n+            Lock d = new ReentrantLock();\n+            Lock e = new ReentrantLock();\n+            Lock f = new ReentrantLock();\n+\n+            dThreads[3] = new DeadlockThread(\"SThread-4\", d, e);\n+            dThreads[4] = new DeadlockThread(\"SThread-5\", e, f);\n+            dThreads[5] = new DeadlockThread(\"SThread-6\", f, d);\n+\n+            // make them daemon threads so that the test will exit\n+            for (int i = 0; i < 6; i++) {\n+                dThreads[i].setDaemon(true);\n+                dThreads[i].start();\n+            }\n+        }\n+\n+        class DeadlockThread extends Thread {\n+            private Lock lock1 = null;\n+\n+            private Lock lock2 = null;\n+\n+            private Monitor mon1 = null;\n+\n+            private Monitor mon2 = null;\n+\n+            private boolean useSync;\n+\n+            DeadlockThread(String name, Lock lock1, Lock lock2) {\n+                super(name);\n+                this.lock1 = lock1;\n+                this.lock2 = lock2;\n+                this.useSync = true;\n+            }\n+\n+            DeadlockThread(String name, Monitor mon1, Monitor mon2) {\n+                super(name);\n+                this.mon1 = mon1;\n+                this.mon2 = mon2;\n+                this.useSync = false;\n+            }\n+\n+            public void run() {\n+                if (useSync) {\n+                    syncLock();\n+                } else {\n+                    monitorLock();\n+                }\n+            }\n+\n+            private void syncLock() {\n+                lock1.lock();\n+                try {\n+                    try {\n+                        barrier.await();\n+                    } catch (Exception e) {\n+                    }\n+                    goSyncDeadlock();\n+                } finally {\n+                    lock1.unlock();\n+                }\n+            }\n+\n+            private void goSyncDeadlock() {\n+                try {\n+                    barrier.await();\n+                } catch (Exception e) {\n+                }\n+                lock2.lock();\n+                throw new RuntimeException(\"should not reach here.\");\n+            }\n+\n+            private void monitorLock() {\n+                synchronized (mon1) {\n+                    try {\n+                        barrier.await();\n+                    } catch (Exception e) {\n+                    }\n+                    goMonitorDeadlock();\n+                }\n+            }\n+\n+            private void goMonitorDeadlock() {\n+                try {\n+                    barrier.await();\n+                } catch (Exception e) {\n+                }\n+                synchronized (mon2) {\n+                    throw new RuntimeException(getName() + \" should not reach here.\");\n+                }\n+            }\n+        }\n+\n+        class Monitor {\n+            String name;\n+\n+            Monitor(String name) {\n+                this.name = name;\n+            }\n+        }\n+\n+    }\n+\n+    @Test(timeout = 500)\n+    public void testThreadDumpAndDeadlocks() throws Exception {\n+        new Deadlock();\n+        String s = null;\n+        while (true) {\n+            s = TimedOutTestsListener.buildDeadlockInfo();\n+            if (s != null) {\n+                break;\n+            }\n+            Thread.sleep(100);\n+        }\n+\n+        Assert.assertEquals(3, countStringOccurrences(s, \"BLOCKED\"));\n+\n+        Failure failure = new Failure(null, new Exception(TimedOutTestsListener.TEST_TIMED_OUT_PREFIX));\n+        StringWriter writer = new StringWriter();\n+        new TimedOutTestsListener(new PrintWriter(writer)).testFailure(failure);\n+        String out = writer.toString();\n+\n+        Assert.assertTrue(out.contains(\"THREAD DUMP\"));\n+        Assert.assertTrue(out.contains(\"DEADLOCKS DETECTED\"));\n+\n+        System.out.println(out);\n+    }\n+\n+    private int countStringOccurrences(String s, String substr) {\n+        int n = 0;\n+        int index = 0;\n+        while ((index = s.indexOf(substr, index) + 1) != 0) {\n+            n++;\n+        }\n+        return n;\n+    }\n+\n+}"},{"sha":"c86cf8f5ea1020e26e8fae06146c8de0bc52d9c5","filename":"src/test/java/org/apache/distributedlog/common/util/TimedOutTestsListener.java","status":"added","additions":168,"deletions":0,"changes":168,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Futil%2FTimedOutTestsListener.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/7e63cff1c110b7b9435a88ab8ab321659057c298/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Futil%2FTimedOutTestsListener.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Forg%2Fapache%2Fdistributedlog%2Fcommon%2Futil%2FTimedOutTestsListener.java?ref=7e63cff1c110b7b9435a88ab8ab321659057c298","patch":"@@ -0,0 +1,168 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.distributedlog.common.util;\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.lang.management.LockInfo;\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.MonitorInfo;\n+import java.lang.management.ThreadInfo;\n+import java.lang.management.ThreadMXBean;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Date;\n+import java.util.Map;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.junit.runner.notification.Failure;\n+import org.junit.runner.notification.RunListener;\n+\n+/**\n+ * JUnit run listener which prints full thread dump into System.err in case a test is failed due to\n+ * timeout.\n+ */\n+public class TimedOutTestsListener extends RunListener {\n+\n+    static final String TEST_TIMED_OUT_PREFIX = \"test timed out after\";\n+\n+    private static String indent = \"    \";\n+\n+    private final PrintWriter output;\n+\n+    public TimedOutTestsListener() {\n+        this.output = new PrintWriter(System.err);\n+    }\n+\n+    public TimedOutTestsListener(PrintWriter output) {\n+        this.output = output;\n+    }\n+\n+    @Override\n+    public void testFailure(Failure failure) throws Exception {\n+        if (failure != null && failure.getMessage() != null && failure.getMessage().startsWith(TEST_TIMED_OUT_PREFIX)) {\n+            output.println(\"====> TEST TIMED OUT. PRINTING THREAD DUMP. <====\");\n+            output.println();\n+            output.print(buildThreadDiagnosticString());\n+        }\n+    }\n+\n+    public static String buildThreadDiagnosticString() {\n+        StringWriter sw = new StringWriter();\n+        PrintWriter output = new PrintWriter(sw);\n+\n+        DateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd hh:mm:ss,SSS\");\n+        output.println(String.format(\"Timestamp: %s\", dateFormat.format(new Date())));\n+        output.println();\n+        output.println(buildThreadDump());\n+\n+        String deadlocksInfo = buildDeadlockInfo();\n+        if (deadlocksInfo != null) {\n+            output.println(\"====> DEADLOCKS DETECTED <====\");\n+            output.println();\n+            output.println(deadlocksInfo);\n+        }\n+\n+        return sw.toString();\n+    }\n+\n+    static String buildThreadDump() {\n+        StringBuilder dump = new StringBuilder();\n+        Map<Thread, StackTraceElement[]> stackTraces = Thread.getAllStackTraces();\n+        for (Map.Entry<Thread, StackTraceElement[]> e : stackTraces.entrySet()) {\n+            Thread thread = e.getKey();\n+            dump.append(String.format(\"\\\"%s\\\" %s prio=%d tid=%d %s\\njava.lang.Thread.State: %s\", thread.getName(),\n+                (thread.isDaemon() ? \"daemon\" : \"\"), thread.getPriority(), thread.getId(),\n+                Thread.State.WAITING.equals(thread.getState()) ? \"in Object.wait()\"\n+                        : StringUtils.lowerCase(thread.getState().name()),\n+                Thread.State.WAITING.equals(thread.getState()) ? \"WAITING (on object monitor)\" : thread.getState()));\n+            for (StackTraceElement stackTraceElement : e.getValue()) {\n+                dump.append(\"\\n        at \");\n+                dump.append(stackTraceElement);\n+            }\n+            dump.append(\"\\n\");\n+        }\n+        return dump.toString();\n+    }\n+\n+    static String buildDeadlockInfo() {\n+        ThreadMXBean threadBean = ManagementFactory.getThreadMXBean();\n+        long[] threadIds = threadBean.findMonitorDeadlockedThreads();\n+        if (threadIds != null && threadIds.length > 0) {\n+            StringWriter stringWriter = new StringWriter();\n+            PrintWriter out = new PrintWriter(stringWriter);\n+\n+            ThreadInfo[] infos = threadBean.getThreadInfo(threadIds, true, true);\n+            for (ThreadInfo ti : infos) {\n+                printThreadInfo(ti, out);\n+                printLockInfo(ti.getLockedSynchronizers(), out);\n+                out.println();\n+            }\n+\n+            out.close();\n+            return stringWriter.toString();\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    private static void printThreadInfo(ThreadInfo ti, PrintWriter out) {\n+        // print thread information\n+        printThread(ti, out);\n+\n+        // print stack trace with locks\n+        StackTraceElement[] stacktrace = ti.getStackTrace();\n+        MonitorInfo[] monitors = ti.getLockedMonitors();\n+        for (int i = 0; i < stacktrace.length; i++) {\n+            StackTraceElement ste = stacktrace[i];\n+            out.println(indent + \"at \" + ste.toString());\n+            for (MonitorInfo mi : monitors) {\n+                if (mi.getLockedStackDepth() == i) {\n+                    out.println(indent + \"  - locked \" + mi);\n+                }\n+            }\n+        }\n+        out.println();\n+    }\n+\n+    private static void printThread(ThreadInfo ti, PrintWriter out) {\n+        out.print(\"\\\"\" + ti.getThreadName() + \"\\\"\" + \" Id=\" + ti.getThreadId() + \" in \" + ti.getThreadState());\n+        if (ti.getLockName() != null) {\n+            out.print(\" on lock=\" + ti.getLockName());\n+        }\n+        if (ti.isSuspended()) {\n+            out.print(\" (suspended)\");\n+        }\n+        if (ti.isInNative()) {\n+            out.print(\" (running in native)\");\n+        }\n+        out.println();\n+        if (ti.getLockOwnerName() != null) {\n+            out.println(indent + \" owned by \" + ti.getLockOwnerName() + \" Id=\" + ti.getLockOwnerId());\n+        }\n+    }\n+\n+    private static void printLockInfo(LockInfo[] locks, PrintWriter out) {\n+        out.println(indent + \"Locked synchronizers: count = \" + locks.length);\n+        for (LockInfo li : locks) {\n+            out.println(indent + \"  - \" + li);\n+        }\n+        out.println();\n+    }\n+\n+}"}]}