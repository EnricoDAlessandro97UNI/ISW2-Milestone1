{"sha":"c9e76260dee1d661906c8bf89b032950f92c6d0e","node_id":"MDY6Q29tbWl0NDc4NTkyNTI2OmM5ZTc2MjYwZGVlMWQ2NjE5MDZjOGJmODliMDMyOTUwZjkyYzZkMGU=","commit":{"author":{"name":"Sijie Guo","email":"sijieg@twitter.com","date":"2016-11-22T01:35:40Z"},"committer":{"name":"Sijie Guo","email":"sijieg@twitter.com","date":"2016-12-28T00:49:29Z"},"message":"DL-112: Improve SyncReader to access readahead cache directly\n\nThis changes the implementation of SyncReader to let it access the read ahead cache directly, rather\nthan calling AsyncReader to fetch the entries. It would reduce the function calls that SyncReader spends\non reading individual records.","tree":{"sha":"845509a4756f5d2224c2bc553a1835f6e216ebd6","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/trees/845509a4756f5d2224c2bc553a1835f6e216ebd6"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/commits/c9e76260dee1d661906c8bf89b032950f92c6d0e","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/c9e76260dee1d661906c8bf89b032950f92c6d0e","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/c9e76260dee1d661906c8bf89b032950f92c6d0e","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/c9e76260dee1d661906c8bf89b032950f92c6d0e/comments","author":null,"committer":null,"parents":[{"sha":"ee117235dc1a6fa76093c315c0fed4239831cd63","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/ee117235dc1a6fa76093c315c0fed4239831cd63","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/ee117235dc1a6fa76093c315c0fed4239831cd63"}],"stats":{"total":319,"additions":169,"deletions":150},"files":[{"sha":"cf792e35a3f39f214cfcf406415df14bbc257437","filename":"src/main/java/com/twitter/distributedlog/BKAsyncLogReaderDLSN.java","status":"modified","additions":13,"deletions":8,"changes":21,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/c9e76260dee1d661906c8bf89b032950f92c6d0e/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FBKAsyncLogReaderDLSN.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/c9e76260dee1d661906c8bf89b032950f92c6d0e/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FBKAsyncLogReaderDLSN.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FBKAsyncLogReaderDLSN.java?ref=c9e76260dee1d661906c8bf89b032950f92c6d0e","patch":"@@ -97,7 +97,7 @@ public LogRecordWithDLSN apply(List<LogRecordWithDLSN> records) {\n     private int lastPosition = 0;\n     private final boolean positionGapDetectionEnabled;\n     private final int idleErrorThresholdMillis;\n-    private final ScheduledFuture<?> idleReaderTimeoutTask;\n+    final ScheduledFuture<?> idleReaderTimeoutTask;\n     private ScheduledFuture<?> backgroundScheduleTask = null;\n \n     protected Promise<Void> closeFuture = null;\n@@ -312,6 +312,17 @@ public void run() {\n         return null;\n     }\n \n+    void cancelIdleReaderTask() {\n+        // Do this after we have checked that the reader was not previously closed\n+        try {\n+            if (null != idleReaderTimeoutTask) {\n+                idleReaderTimeoutTask.cancel(true);\n+            }\n+        } catch (Exception exc) {\n+            LOG.info(\"{}: Failed to cancel the background idle reader timeout task\", bkLedgerManager.getFullyQualifiedName());\n+        }\n+    }\n+\n     protected synchronized void setStartDLSN(DLSN fromDLSN) throws UnexpectedException {\n         if (readAheadStarted) {\n             throw new UnexpectedException(\"Could't reset from dlsn after reader already starts reading.\");\n@@ -471,13 +482,7 @@ public Future<Void> asyncClose() {\n         }\n \n         // Do this after we have checked that the reader was not previously closed\n-        try {\n-            if (null != idleReaderTimeoutTask) {\n-                idleReaderTimeoutTask.cancel(true);\n-            }\n-        } catch (Exception exc) {\n-            LOG.info(\"{}: Failed to cancel the background idle reader timeout task\", bkLedgerManager.getFullyQualifiedName());\n-        }\n+        cancelIdleReaderTask();\n \n         synchronized (scheduleLock) {\n             if (null != backgroundScheduleTask) {"},{"sha":"ac37f3afbf2c26c551f4b2d8d208e955a271ff39","filename":"src/main/java/com/twitter/distributedlog/BKDistributedLogManager.java","status":"modified","additions":8,"deletions":14,"changes":22,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/c9e76260dee1d661906c8bf89b032950f92c6d0e/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FBKDistributedLogManager.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/c9e76260dee1d661906c8bf89b032950f92c6d0e/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FBKDistributedLogManager.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FBKDistributedLogManager.java?ref=c9e76260dee1d661906c8bf89b032950f92c6d0e","patch":"@@ -75,7 +75,6 @@\n import org.apache.bookkeeper.feature.FeatureProvider;\n import org.apache.bookkeeper.stats.NullStatsLogger;\n import org.apache.bookkeeper.stats.StatsLogger;\n-import org.apache.bookkeeper.versioning.Versioned;\n import org.apache.zookeeper.KeeperException;\n import org.apache.zookeeper.Watcher;\n import org.apache.zookeeper.ZKUtil;\n@@ -408,7 +407,7 @@ public DLSN apply(LogRecordWithDLSN record) {\n         this.readAheadExceptionsLogger = readAheadExceptionsLogger;\n     }\n \n-    private synchronized OrderedScheduler getLockStateExecutor(boolean createIfNull) {\n+    synchronized OrderedScheduler getLockStateExecutor(boolean createIfNull) {\n         if (createIfNull && null == lockStateExecutor && ownExecutor) {\n             lockStateExecutor = OrderedScheduler.newBuilder()\n                     .corePoolSize(1).name(\"BKDL-LockState\").build();\n@@ -1106,18 +1105,13 @@ LogReader getInputStreamInternal(DLSN fromDLSN, Optional<Long> fromTxnId)\n             throws IOException {\n         LOG.info(\"Create async reader starting from {}\", fromDLSN);\n         checkClosedOrInError(\"getInputStream\");\n-        Optional<String> subscriberId = Optional.absent();\n-        BKAsyncLogReaderDLSN asyncReader = new BKAsyncLogReaderDLSN(\n+        LogReader reader = new BKSyncLogReaderDLSN(\n+                conf,\n                 this,\n-                scheduler,\n-                getLockStateExecutor(true),\n                 fromDLSN,\n-                subscriberId,\n-                true,\n-                dynConf.getDeserializeRecordSetOnReads(),\n+                fromTxnId,\n                 statsLogger);\n-        pendingReaders.add(asyncReader);\n-        return new BKSyncLogReaderDLSN(conf, asyncReader, scheduler, fromTxnId);\n+        return reader;\n     }\n \n     /**\n@@ -1325,17 +1319,17 @@ public void purgeLogsOlderThan(long minTxIdToKeep) throws IOException {\n     static class PendingReaders implements AsyncCloseable {\n \n         final ExecutorService executorService;\n-        final Set<AsyncLogReader> readers = new HashSet<AsyncLogReader>();\n+        final Set<AsyncCloseable> readers = new HashSet<AsyncCloseable>();\n \n         PendingReaders(ExecutorService executorService) {\n             this.executorService = executorService;\n         }\n \n-        public synchronized void remove(AsyncLogReader reader) {\n+        public synchronized void remove(AsyncCloseable reader) {\n             readers.remove(reader);\n         }\n \n-        public synchronized void add(AsyncLogReader reader) {\n+        public synchronized void add(AsyncCloseable reader) {\n             readers.add(reader);\n         }\n "},{"sha":"30a96ffb0f7077dc97e6f2c9124b27d77e4dce55","filename":"src/main/java/com/twitter/distributedlog/BKLogReadHandler.java","status":"modified","additions":4,"deletions":0,"changes":4,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/c9e76260dee1d661906c8bf89b032950f92c6d0e/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FBKLogReadHandler.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/c9e76260dee1d661906c8bf89b032950f92c6d0e/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FBKLogReadHandler.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FBKLogReadHandler.java?ref=c9e76260dee1d661906c8bf89b032950f92c6d0e","patch":"@@ -482,6 +482,10 @@ public Entry.Reader getNextReadAheadEntry() throws IOException {\n         return readAheadCache.getNextReadAheadEntry();\n     }\n \n+    public Entry.Reader getNextReadAheadEntry(long waitTime, TimeUnit waitTimeUnit) throws IOException {\n+        return readAheadCache.getNextReadAheadEntry(waitTime, waitTimeUnit);\n+    }\n+\n     public ReadAheadCache getReadAheadCache() {\n         return readAheadCache;\n     }"},{"sha":"ded318c0b9e4dca8407656b9bf149b960266111b","filename":"src/main/java/com/twitter/distributedlog/BKSyncLogReaderDLSN.java","status":"modified","additions":129,"deletions":123,"changes":252,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/c9e76260dee1d661906c8bf89b032950f92c6d0e/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FBKSyncLogReaderDLSN.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/c9e76260dee1d661906c8bf89b032950f92c6d0e/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FBKSyncLogReaderDLSN.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FBKSyncLogReaderDLSN.java?ref=c9e76260dee1d661906c8bf89b032950f92c6d0e","patch":"@@ -19,171 +19,175 @@\n \n import com.google.common.annotations.VisibleForTesting;\n import com.google.common.base.Optional;\n-import com.twitter.distributedlog.callback.ReadAheadCallback;\n-import com.twitter.distributedlog.exceptions.DLInterruptedException;\n import com.twitter.distributedlog.exceptions.EndOfStreamException;\n+import com.twitter.distributedlog.exceptions.IdleReaderException;\n+import com.twitter.distributedlog.injector.AsyncFailureInjector;\n import com.twitter.distributedlog.util.FutureUtils;\n import com.twitter.util.Future;\n-import com.twitter.util.FutureEventListener;\n import com.twitter.util.Promise;\n+import org.apache.bookkeeper.stats.Counter;\n+import org.apache.bookkeeper.stats.StatsLogger;\n \n import java.io.IOException;\n import java.util.LinkedList;\n import java.util.List;\n-import java.util.concurrent.LinkedBlockingQueue;\n-import java.util.concurrent.ScheduledExecutorService;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicReference;\n \n /**\n  * Synchronous Log Reader based on {@link AsyncLogReader}\n  */\n-class BKSyncLogReaderDLSN implements LogReader, Runnable, FutureEventListener<LogRecordWithDLSN>, ReadAheadCallback {\n+class BKSyncLogReaderDLSN implements LogReader, AsyncNotification {\n \n-    private final BKAsyncLogReaderDLSN reader;\n-    private final ScheduledExecutorService executorService;\n-    private final LinkedBlockingQueue<LogRecordWithDLSN> readAheadRecords;\n+    private final BKLogReadHandler readHandler;\n     private final AtomicReference<IOException> readerException =\n             new AtomicReference<IOException>(null);\n-    private final int maxNumCachedRecords;\n     private final int maxReadAheadWaitTime;\n-    private ReadAheadCallback readAheadCallback = null;\n     private Promise<Void> closeFuture;\n     private final Optional<Long> startTransactionId;\n-    private final DLSN startDLSN;\n-    // lock on variables that would be accessed by both background threads and foreground threads\n-    private final Object sharedLock = new Object();\n+    private boolean positioned = false;\n+    private Entry.Reader currentEntry = null;\n+\n+    // idle reader settings\n+    private final boolean shouldCheckIdleReader;\n+    private final int idleErrorThresholdMillis;\n+\n+    // Stats\n+    private final Counter idleReaderError;\n \n     BKSyncLogReaderDLSN(DistributedLogConfiguration conf,\n-                        BKAsyncLogReaderDLSN reader,\n-                        ScheduledExecutorService executorService,\n-                        Optional<Long> startTransactionId) {\n-        this.maxNumCachedRecords = conf.getReadAheadMaxRecords();\n+                        BKDistributedLogManager bkdlm,\n+                        DLSN startDLSN,\n+                        Optional<Long> startTransactionId,\n+                        StatsLogger statsLogger) {\n+        this.readHandler = bkdlm.createReadHandler(\n+                Optional.<String>absent(),\n+                bkdlm.getLockStateExecutor(true),\n+                this,\n+                conf.getDeserializeRecordSetOnReads(),\n+                true);\n         this.maxReadAheadWaitTime = conf.getReadAheadWaitTime();\n-        this.reader = reader;\n-        this.executorService = executorService;\n-        this.readAheadRecords = new LinkedBlockingQueue<LogRecordWithDLSN>();\n+        this.idleErrorThresholdMillis = conf.getReaderIdleErrorThresholdMillis();\n+        this.shouldCheckIdleReader = idleErrorThresholdMillis > 0 && idleErrorThresholdMillis < Integer.MAX_VALUE;\n         this.startTransactionId = startTransactionId;\n-        this.startDLSN = reader.getStartDLSN();\n-        scheduleReadNext();\n+        readHandler.startReadAhead(\n+                new LedgerReadPosition(startDLSN),\n+                AsyncFailureInjector.NULL);\n+        if (!startTransactionId.isPresent()) {\n+            positioned = true;\n+        }\n+\n+        // Stats\n+        StatsLogger syncReaderStatsLogger = statsLogger.scope(\"sync_reader\");\n+        idleReaderError = syncReaderStatsLogger.getCounter(\"idle_reader_error\");\n     }\n \n     @VisibleForTesting\n-    BKAsyncLogReaderDLSN getAsyncReader() {\n-        return reader;\n+    BKLogReadHandler getReadHandler() {\n+        return readHandler;\n     }\n \n-    private void scheduleReadNext() {\n-        synchronized (sharedLock) {\n-            if (null != closeFuture) {\n-                return;\n-            }\n-        }\n-        this.executorService.submit(this);\n-    }\n+    // reader is still catching up, waiting for next record\n \n-    private void invokeReadAheadCallback() {\n-        synchronized (sharedLock) {\n-            if (null != readAheadCallback) {\n-                readAheadCallback.resumeReadAhead();\n-                readAheadCallback = null;\n+    private Entry.Reader readNextEntry(boolean nonBlocking) throws IOException {\n+        Entry.Reader entry = null;\n+        if (nonBlocking) {\n+            return readHandler.getNextReadAheadEntry();\n+        } else {\n+            while (!readHandler.isReadAheadCaughtUp()\n+                    && null == readerException.get()\n+                    && null == entry) {\n+                entry = readHandler.getNextReadAheadEntry(maxReadAheadWaitTime,\n+                        TimeUnit.MILLISECONDS);\n             }\n-        }\n-    }\n-\n-    private void setReadAheadCallback(ReadAheadCallback callback) {\n-        synchronized (sharedLock) {\n-            this.readAheadCallback = callback;\n-            if (readAheadRecords.size() < maxNumCachedRecords) {\n-                invokeReadAheadCallback();\n+            if (null != entry) {\n+                return entry;\n+            }\n+            // reader is caught up\n+            if (readHandler.isReadAheadCaughtUp()\n+                    && null == entry\n+                    && null == readerException.get()) {\n+                entry = readHandler.getNextReadAheadEntry(maxReadAheadWaitTime,\n+                        TimeUnit.MILLISECONDS);\n             }\n+            return entry;\n         }\n     }\n \n-    // Background Read Future Listener\n-\n-    @Override\n-    public void resumeReadAhead() {\n-        scheduleReadNext();\n+    private void markReaderAsIdle() throws IdleReaderException {\n+        idleReaderError.inc();\n+        IdleReaderException ire = new IdleReaderException(\"Sync reader on stream \"\n+                + readHandler.getFullyQualifiedName()\n+                + \" is idle for more than \" + idleErrorThresholdMillis + \" ms\");\n+        readerException.compareAndSet(null, ire);\n+        throw ire;\n     }\n \n-    @Override\n-    public void onSuccess(LogRecordWithDLSN record) {\n-        if (!startTransactionId.isPresent() || record.getTransactionId() >= startTransactionId.get()) {\n-            readAheadRecords.add(record);\n-        }\n-        if (readAheadRecords.size() >= maxNumCachedRecords) {\n-            setReadAheadCallback(this);\n-        } else {\n-            scheduleReadNext();\n-        }\n-    }\n \n     @Override\n-    public void onFailure(Throwable cause) {\n-        if (cause instanceof IOException) {\n-            readerException.compareAndSet(null, (IOException) cause);\n-        } else {\n-            readerException.compareAndSet(null, new IOException(\"Encountered exception on reading \"\n-                    + reader.getStreamName() + \" : \", cause));\n+    public synchronized LogRecordWithDLSN readNext(boolean nonBlocking)\n+            throws IOException {\n+        if (null != readerException.get()) {\n+            throw readerException.get();\n         }\n-    }\n \n-    // Background Read\n+        LogRecordWithDLSN record = doReadNext(nonBlocking);\n \n-    @Override\n-    public void run() {\n-        this.reader.readNext().addEventListener(this);\n+        // no record is returned, check if the reader becomes idle\n+        if (null == record && shouldCheckIdleReader) {\n+            ReadAheadCache cache = readHandler.getReadAheadCache();\n+            if (cache.getNumCachedEntries() <= 0 &&\n+                    cache.isReadAheadIdle(idleErrorThresholdMillis, TimeUnit.MILLISECONDS)) {\n+                markReaderAsIdle();\n+            }\n+        }\n+\n+        return record;\n     }\n \n-    @Override\n-    public synchronized LogRecordWithDLSN readNext(boolean nonBlocking)\n+    private synchronized LogRecordWithDLSN doReadNext(boolean nonBlocking)\n             throws IOException {\n-        if (null != readerException.get()) {\n-            throw readerException.get();\n-        }\n         LogRecordWithDLSN record = null;\n-        if (nonBlocking) {\n-            record = readAheadRecords.poll();\n-        } else {\n-            try {\n-                // reader is still catching up, waiting for next record\n-                while (!reader.bkLedgerManager.isReadAheadCaughtUp()\n-                        && null == readerException.get()\n-                        && null == record) {\n-                    record = readAheadRecords.poll(maxReadAheadWaitTime,\n-                            TimeUnit.MILLISECONDS);\n-                }\n-                // reader caught up\n-                boolean shallWait = true;\n-                while (shallWait\n-                        && reader.bkLedgerManager.isReadAheadCaughtUp()\n-                        && null == record\n-                        && null == readerException.get()) {\n-                    record = readAheadRecords.poll(maxReadAheadWaitTime,\n-                            TimeUnit.MILLISECONDS);\n-                    if (null != record) {\n-                        break;\n+\n+        do {\n+            // fetch one record until we don't find any entry available in the readahead cache\n+            while (null == record) {\n+                if (null == currentEntry) {\n+                    currentEntry = readNextEntry(nonBlocking);\n+                    if (null == currentEntry) {\n+                        return null;\n                     }\n-                    shallWait = reader.hasMoreRecords();\n                 }\n-            } catch (InterruptedException e) {\n-                throw new DLInterruptedException(\"Interrupted on waiting next available log record for stream \"\n-                        + reader.getStreamName(), e);\n+                record = currentEntry.nextRecord();\n+                if (null == record) {\n+                    currentEntry = null;\n+                }\n             }\n-        }\n-        if (null != readerException.get()) {\n-            throw readerException.get();\n-        }\n-        if (null != record) {\n+\n+            // check if we reached the end of stream\n             if (record.isEndOfStream()) {\n                 EndOfStreamException eos = new EndOfStreamException(\"End of Stream Reached for \"\n-                                        + reader.bkLedgerManager.getFullyQualifiedName());\n+                        + readHandler.getFullyQualifiedName());\n                 readerException.compareAndSet(null, eos);\n                 throw eos;\n             }\n-            invokeReadAheadCallback();\n-        }\n+            // skip control records\n+            if (record.isControl()) {\n+                record = null;\n+                continue;\n+            }\n+            if (!positioned) {\n+                if (record.getTransactionId() < startTransactionId.get()) {\n+                    record = null;\n+                    continue;\n+                } else {\n+                    positioned = true;\n+                    break;\n+                }\n+            } else {\n+                break;\n+            }\n+        } while (true);\n         return record;\n     }\n \n@@ -209,13 +213,13 @@ public synchronized List<LogRecordWithDLSN> readBulk(boolean nonBlocking, int nu\n     @Override\n     public Future<Void> asyncClose() {\n         Promise<Void> closePromise;\n-        synchronized (sharedLock) {\n+        synchronized (this) {\n             if (null != closeFuture) {\n                 return closeFuture;\n             }\n             closeFuture = closePromise = new Promise<Void>();\n         }\n-        reader.asyncClose().proxyTo(closePromise);\n+        readHandler.asyncClose().proxyTo(closePromise);\n         return closePromise;\n     }\n \n@@ -225,18 +229,20 @@ public void close() throws IOException {\n     }\n \n     //\n-    // Test Methods\n+    // Notification From ReadHandler\n     //\n-    @VisibleForTesting\n-    void disableReadAheadLogSegmentsNotification() {\n-        reader.bkLedgerManager.disableReadAheadLogSegmentsNotification();\n-    }\n \n-    @VisibleForTesting\n-    LedgerReadPosition getReadAheadPosition() {\n-        if (null != reader.bkLedgerManager.readAheadWorker) {\n-            return reader.bkLedgerManager.readAheadWorker.getNextReadAheadPosition();\n+    @Override\n+    public void notifyOnError(Throwable cause) {\n+        if (cause instanceof IOException) {\n+            readerException.compareAndSet(null, (IOException) cause);\n+        } else {\n+            readerException.compareAndSet(null, new IOException(cause));\n         }\n-        return null;\n+    }\n+\n+    @Override\n+    public void notifyOnOperationComplete() {\n+        // no-op\n     }\n }"},{"sha":"284b3271319f725c78e72235a46e89cf32294b62","filename":"src/main/java/com/twitter/distributedlog/ReadAheadCache.java","status":"modified","additions":11,"deletions":1,"changes":12,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/c9e76260dee1d661906c8bf89b032950f92c6d0e/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FReadAheadCache.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/c9e76260dee1d661906c8bf89b032950f92c6d0e/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FReadAheadCache.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FReadAheadCache.java?ref=c9e76260dee1d661906c8bf89b032950f92c6d0e","patch":"@@ -25,6 +25,7 @@\n import com.google.common.base.Stopwatch;\n import com.google.common.base.Ticker;\n import com.twitter.distributedlog.callback.ReadAheadCallback;\n+import com.twitter.distributedlog.exceptions.DLInterruptedException;\n import com.twitter.distributedlog.exceptions.InvalidEnvelopedEntryException;\n import com.twitter.distributedlog.exceptions.LogReadException;\n import org.apache.bookkeeper.client.LedgerEntry;\n@@ -107,11 +108,20 @@ private void setLastException(IOException exc) {\n      * @throws IOException\n      */\n     public Entry.Reader getNextReadAheadEntry() throws IOException {\n+        return getNextReadAheadEntry(0L, TimeUnit.MILLISECONDS);\n+    }\n+\n+    public Entry.Reader getNextReadAheadEntry(long waitTime, TimeUnit waitTimeUnit) throws IOException {\n         if (null != lastException.get()) {\n             throw lastException.get();\n         }\n \n-        Entry.Reader entry = readAheadEntries.poll();\n+        Entry.Reader entry = null;\n+        try {\n+            entry = readAheadEntries.poll(waitTime, waitTimeUnit);\n+        } catch (InterruptedException e) {\n+            throw new DLInterruptedException(\"Interrupted on polling readahead entries : \", e);\n+        }\n \n         if (null != entry) {\n             if (!isCacheFull()) {"},{"sha":"c34eb6ef212119bf1d3658a6380b066d204b2d09","filename":"src/test/java/com/twitter/distributedlog/NonBlockingReadsTestUtil.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/c9e76260dee1d661906c8bf89b032950f92c6d0e/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FNonBlockingReadsTestUtil.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/c9e76260dee1d661906c8bf89b032950f92c6d0e/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FNonBlockingReadsTestUtil.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FNonBlockingReadsTestUtil.java?ref=c9e76260dee1d661906c8bf89b032950f92c6d0e","patch":"@@ -65,7 +65,7 @@ static void readNonBlocking(DistributedLogManager dlm,\n         try {\n             LOG.info(\"Created reader reading from {}\", dlm.getStreamName());\n             if (forceStall) {\n-                reader.disableReadAheadLogSegmentsNotification();\n+                reader.getReadHandler().disableReadAheadLogSegmentsNotification();\n             }\n \n             long numTrans = 0;"},{"sha":"c029dca3739a8b4b28088cff64526938202d87c8","filename":"src/test/java/com/twitter/distributedlog/TestBKSyncLogReader.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/c9e76260dee1d661906c8bf89b032950f92c6d0e/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestBKSyncLogReader.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/c9e76260dee1d661906c8bf89b032950f92c6d0e/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestBKSyncLogReader.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestBKSyncLogReader.java?ref=c9e76260dee1d661906c8bf89b032950f92c6d0e","patch":"@@ -162,7 +162,7 @@ public void testReadRecordsAfterReadAheadCaughtUp() throws Exception {\n         BKSyncLogReaderDLSN reader = (BKSyncLogReaderDLSN) dlm.getInputStream(1L);\n \n         // wait until readahead caught up\n-        while (!reader.getAsyncReader().bkLedgerManager.isReadAheadCaughtUp()) {\n+        while (!reader.getReadHandler().isReadAheadCaughtUp()) {\n             TimeUnit.MILLISECONDS.sleep(20);\n         }\n \n@@ -178,7 +178,7 @@ public void testReadRecordsAfterReadAheadCaughtUp() throws Exception {\n         logger.info(\"Write another 10 records\");\n \n         // wait until readahead move on\n-        while (reader.getAsyncReader().bkLedgerManager\n+        while (reader.getReadHandler()\n                 .readAheadWorker.getNextReadAheadPosition().getEntryId() < 21) {\n             TimeUnit.MILLISECONDS.sleep(20);\n         }"},{"sha":"775c99d25f8e907c1bf1d1d01b8b8b1a1478df0d","filename":"src/test/java/com/twitter/distributedlog/TestNonBlockingReadsMultiReader.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/c9e76260dee1d661906c8bf89b032950f92c6d0e/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestNonBlockingReadsMultiReader.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/c9e76260dee1d661906c8bf89b032950f92c6d0e/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestNonBlockingReadsMultiReader.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestNonBlockingReadsMultiReader.java?ref=c9e76260dee1d661906c8bf89b032950f92c6d0e","patch":"@@ -150,7 +150,7 @@ public void run() {\n             while (writeCount.get() > (readerThreads[0].getReadCount())) {\n                 LOG.info(\"Write Count = {}, Read Count = {}, ReadAhead = {}\",\n                         new Object[] { writeCount.get(), readerThreads[0].getReadCount(),\n-                                        reader0.getReadAheadPosition() });\n+                                        reader0.getReadHandler().getReadAheadCache() });\n                 TimeUnit.MILLISECONDS.sleep(100);\n             }\n             assertEquals(writeCount.get(),"}]}