{"sha":"387dc83d6d2db6a1d30bac3216a92f875083d144","node_id":"MDY6Q29tbWl0NDc4NTkyNTI2OjM4N2RjODNkNmQyZGI2YTFkMzBiYWMzMjE2YTkyZjg3NTA4M2QxNDQ=","commit":{"author":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2017-07-17T20:53:38Z"},"committer":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2017-07-17T20:53:38Z"},"message":"ISSUE #228: BookKeeper Server: Index Page Management Memory Growth\n\nDescriptions of the changes in this PR:\n\n** Improvements **\n\n- Never delete a LedgerEntryPage that has been allocated.\n- Track free LedgerEntryPage in a separate list\n- Use pages from the free pages list as though they were being freshly allocated\n- This guarantees that the direct buffer allocation never exceeds the allocated space for index pages\n\nAuthor: Sijie Guo <sijie@apache.org>\n\nReviewers: Enrico Olivelli <eolivelli@gmail.com>\n\nThis closes #229 from sijie/lru_related_changes, closes #228","tree":{"sha":"f3f9873b699757581dfa4a001d1b726109950344","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/trees/f3f9873b699757581dfa4a001d1b726109950344"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/commits/387dc83d6d2db6a1d30bac3216a92f875083d144","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/387dc83d6d2db6a1d30bac3216a92f875083d144","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/387dc83d6d2db6a1d30bac3216a92f875083d144","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/387dc83d6d2db6a1d30bac3216a92f875083d144/comments","author":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"committer":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"parents":[{"sha":"c49621bacaa960d240afbbee83a9703b4cbc3ec2","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/c49621bacaa960d240afbbee83a9703b4cbc3ec2","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/c49621bacaa960d240afbbee83a9703b4cbc3ec2"}],"stats":{"total":237,"additions":180,"deletions":57},"files":[{"sha":"e0690fbbaf24ac843be8e76124e4109ca2724fd2","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BookKeeperServerStats.java","status":"modified","additions":10,"deletions":0,"changes":10,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/387dc83d6d2db6a1d30bac3216a92f875083d144/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FBookKeeperServerStats.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/387dc83d6d2db6a1d30bac3216a92f875083d144/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FBookKeeperServerStats.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FBookKeeperServerStats.java?ref=387dc83d6d2db6a1d30bac3216a92f875083d144","patch":"@@ -86,6 +86,9 @@ public interface BookKeeperServerStats {\n     // Ledger Storage Stats\n     String STORAGE_GET_OFFSET = \"STORAGE_GET_OFFSET\";\n     String STORAGE_GET_ENTRY = \"STORAGE_GET_ENTRY\";\n+    /** Ledger Cache Stats **/\n+    String LEDGER_CACHE_READ_PAGE = \"LEDGER_CACHE_READ_PAGE\";\n+    /** SkipList Stats **/\n     String SKIP_LIST_GET_ENTRY = \"SKIP_LIST_GET_ENTRY\";\n     String SKIP_LIST_PUT_ENTRY = \"SKIP_LIST_PUT_ENTRY\";\n     String SKIP_LIST_SNAPSHOT = \"SKIP_LIST_SNAPSHOT\";\n@@ -95,8 +98,15 @@ public interface BookKeeperServerStats {\n     String JOURNAL_QUEUE_SIZE = \"JOURNAL_QUEUE_SIZE\";\n     String READ_BYTES = \"READ_BYTES\";\n     String WRITE_BYTES = \"WRITE_BYTES\";\n+    /** Ledger Cache Counters **/\n+    String LEDGER_CACHE_HIT = \"LEDGER_CACHE_HIT\";\n+    String LEDGER_CACHE_MISS = \"LEDGER_CACHE_MISS\";\n+    /** Compaction/Garbage Collection Related Counters **/\n     String NUM_MINOR_COMP = \"NUM_MINOR_COMP\";\n     String NUM_MAJOR_COMP = \"NUM_MAJOR_COMP\";\n+    /** Index Related Counters **/\n+    String INDEX_INMEM_ILLEGAL_STATE_RESET = \"INDEX_INMEM_ILLEGAL_STATE_RESET\";\n+    String INDEX_INMEM_ILLEGAL_STATE_DELETE = \"INDEX_INMEM_ILLEGAL_STATE_DELETE\";\n     String JOURNAL_FORCE_WRITE_QUEUE_SIZE = \"JOURNAL_FORCE_WRITE_QUEUE_SIZE\";\n     String JOURNAL_NUM_FORCE_WRITES = \"JOURNAL_NUM_FORCE_WRITES\";\n     String JOURNAL_NUM_FLUSH_EMPTY_QUEUE = \"JOURNAL_NUM_FLUSH_EMPTY_QUEUE\";"},{"sha":"361bc6ee4896b150ca83cb82075d1f2a3b01e7f2","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/IndexInMemPageMgr.java","status":"modified","additions":133,"deletions":53,"changes":186,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/387dc83d6d2db6a1d30bac3216a92f875083d144/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FIndexInMemPageMgr.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/387dc83d6d2db6a1d30bac3216a92f875083d144/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FIndexInMemPageMgr.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FIndexInMemPageMgr.java?ref=387dc83d6d2db6a1d30bac3216a92f875083d144","patch":"@@ -20,8 +20,12 @@\n  */\n package org.apache.bookkeeper.bookie;\n \n+import com.google.common.base.Stopwatch;\n+import java.util.concurrent.TimeUnit;\n import org.apache.bookkeeper.conf.ServerConfiguration;\n+import org.apache.bookkeeper.stats.Counter;\n import org.apache.bookkeeper.stats.Gauge;\n+import org.apache.bookkeeper.stats.OpStatsLogger;\n import org.apache.bookkeeper.stats.StatsLogger;\n import org.apache.bookkeeper.util.DirectMemoryUtils;\n import org.slf4j.Logger;\n@@ -42,6 +46,11 @@\n import java.util.concurrent.ConcurrentSkipListSet;\n import java.util.concurrent.atomic.AtomicInteger;\n \n+import static org.apache.bookkeeper.bookie.BookKeeperServerStats.INDEX_INMEM_ILLEGAL_STATE_DELETE;\n+import static org.apache.bookkeeper.bookie.BookKeeperServerStats.INDEX_INMEM_ILLEGAL_STATE_RESET;\n+import static org.apache.bookkeeper.bookie.BookKeeperServerStats.LEDGER_CACHE_HIT;\n+import static org.apache.bookkeeper.bookie.BookKeeperServerStats.LEDGER_CACHE_MISS;\n+import static org.apache.bookkeeper.bookie.BookKeeperServerStats.LEDGER_CACHE_READ_PAGE;\n import static org.apache.bookkeeper.bookie.BookKeeperServerStats.NUM_INDEX_PAGES;\n \n class IndexInMemPageMgr {\n@@ -51,14 +60,20 @@ class IndexInMemPageMgr {\n \n     private static class InMemPageCollection implements LEPStateChangeCallback {\n \n-        ConcurrentMap<Long, ConcurrentMap<Long,LedgerEntryPage>> pages;\n+        final ConcurrentMap<Long, ConcurrentMap<Long,LedgerEntryPage>> pages;\n+        final Map<EntryKey, LedgerEntryPage> lruCleanPageMap;\n+        final ConcurrentLinkedQueue<LedgerEntryPage> listOfFreePages;\n \n-        Map<EntryKey, LedgerEntryPage> lruCleanPageMap;\n+        // Stats\n+        final Counter illegalStateResetCounter;\n+        final Counter illegalStateDeleteCounter;\n \n-        public InMemPageCollection() {\n+        public InMemPageCollection(StatsLogger statsLogger) {\n             pages = new ConcurrentHashMap<Long, ConcurrentMap<Long,LedgerEntryPage>>();\n-            lruCleanPageMap =\n-                Collections.synchronizedMap(new LinkedHashMap<EntryKey, LedgerEntryPage>(16, 0.75f, true));\n+            lruCleanPageMap = Collections.synchronizedMap(new LinkedHashMap<EntryKey, LedgerEntryPage>(16, 0.75f, true));\n+            listOfFreePages = new ConcurrentLinkedQueue<LedgerEntryPage>();\n+            illegalStateResetCounter = statsLogger.getCounter(INDEX_INMEM_ILLEGAL_STATE_RESET);\n+            illegalStateDeleteCounter = statsLogger.getCounter(INDEX_INMEM_ILLEGAL_STATE_DELETE);\n         }\n \n         /**\n@@ -140,18 +155,28 @@ private long getLastEntryInMem(long ledgerId) {\n          *          Ledger id\n          * @returns number of pages removed\n          */\n-        private int removeEntriesForALedger(long ledgerId) {\n+        private void removeEntriesForALedger(long ledgerId) {\n             // remove pages first to avoid page flushed when deleting file info\n             ConcurrentMap<Long, LedgerEntryPage> lPages = pages.remove(ledgerId);\n             if (null != lPages) {\n-                for (long entryId: lPages.keySet()) {\n+                for (Map.Entry<Long, LedgerEntryPage> pageEntry : lPages.entrySet()) {\n+                    long entryId = pageEntry.getKey();\n                     synchronized(lruCleanPageMap) {\n                         lruCleanPageMap.remove(new EntryKey(ledgerId, entryId));\n                     }\n+\n+                    LedgerEntryPage lep = pageEntry.getValue();\n+                    // Cannot imagine under what circumstances we would have a null entry here\n+                    // Just being safe\n+                    if (null != lep) {\n+                        if (lep.inUse()) {\n+                            illegalStateDeleteCounter.inc();\n+                        }\n+                        listOfFreePages.add(lep);\n+                    }\n                 }\n-                return lPages.size();\n+\n             }\n-            return 0;\n         }\n \n         /**\n@@ -232,7 +257,13 @@ Set<Long> getActiveLedgers() {\n          * @returns LedgerEntryPage if present\n          */\n         LedgerEntryPage grabCleanPage(long ledgerId, long firstEntry) {\n-            LedgerEntryPage lep = null;\n+            LedgerEntryPage lep = listOfFreePages.poll();\n+            if (null != lep) {\n+                lep.resetPage();\n+                lep.setLedgerAndFirstEntry(ledgerId, firstEntry);\n+                lep.usePage();\n+                return lep;\n+            }\n             while (lruCleanPageMap.size() > 0) {\n                 lep = null;\n                 synchronized(lruCleanPageMap) {\n@@ -286,6 +317,15 @@ LedgerEntryPage grabCleanPage(long ledgerId, long firstEntry) {\n             return lep;\n         }\n \n+        public void addToListOfFreePages(LedgerEntryPage lep) {\n+            if ((null == lep) || lep.inUse()) {\n+                illegalStateResetCounter.inc();\n+            }\n+            if (null != lep) {\n+                listOfFreePages.add(lep);\n+            }\n+        }\n+\n         @Override\n         public void onSetInUse(LedgerEntryPage lep) {\n             removeFromCleanPageList(lep);\n@@ -325,6 +365,11 @@ public void onSetDirty(LedgerEntryPage lep) {\n     private final ConcurrentLinkedQueue<Long> ledgersToFlush = new ConcurrentLinkedQueue<Long>();\n     private final ConcurrentSkipListSet<Long> ledgersFlushing = new ConcurrentSkipListSet<Long>();\n \n+    // Stats\n+    private final Counter ledgerCacheHitCounter;\n+    private final Counter ledgerCacheMissCounter;\n+    private final OpStatsLogger ledgerCacheReadPageStats;\n+\n     public IndexInMemPageMgr(int pageSize,\n                              int entriesPerPage,\n                              ServerConfiguration conf,\n@@ -333,7 +378,7 @@ public IndexInMemPageMgr(int pageSize,\n         this.pageSize = pageSize;\n         this.entriesPerPage = entriesPerPage;\n         this.indexPersistenceManager = indexPersistenceManager;\n-        this.pageMapAndList = new InMemPageCollection();\n+        this.pageMapAndList = new InMemPageCollection(statsLogger);\n \n         long maxDirectMemory = DirectMemoryUtils.maxDirectMemory();\n \n@@ -346,17 +391,23 @@ public IndexInMemPageMgr(int pageSize,\n         LOG.info(\"maxDirectMemory = {}, pageSize = {}, pageLimit = {}\",\n                 new Object[] { maxDirectMemory, pageSize, pageLimit });\n         // Expose Stats\n-        statsLogger.registerGauge(NUM_INDEX_PAGES, new Gauge<Number>() {\n-            @Override\n-            public Number getDefaultValue() {\n-                return 0;\n-            }\n-\n-            @Override\n-            public Number getSample() {\n-                return getNumUsedPages();\n-            }\n-        });\n+        this.ledgerCacheHitCounter = statsLogger.getCounter(LEDGER_CACHE_HIT);\n+        this.ledgerCacheMissCounter = statsLogger.getCounter(LEDGER_CACHE_MISS);\n+        this.ledgerCacheReadPageStats = statsLogger.getOpStatsLogger(LEDGER_CACHE_READ_PAGE);\n+        // Export sampled stats for index pages, ledgers.\n+        statsLogger.registerGauge(\n+                NUM_INDEX_PAGES,\n+                new Gauge<Integer>() {\n+                    @Override\n+                    public Integer getDefaultValue() {\n+                        return 0;\n+                    }\n+                    @Override\n+                    public Integer getSample() {\n+                        return getNumUsedPages();\n+                    }\n+                }\n+        );\n     }\n \n     /**\n@@ -387,7 +438,31 @@ public int getNumUsedPages() {\n         return pageCount.get();\n     }\n \n-    LedgerEntryPage getLedgerEntryPage(Long ledger, Long firstEntry, boolean onlyDirty) {\n+        /**\n+     * Get the ledger entry page for a given <i>pageEntry</i>.\n+     *\n+     * @param ledger\n+     *          ledger id\n+     * @param pageEntry\n+     *          first entry id of a given page\n+     * @return ledger entry page\n+     * @throws IOException\n+     */\n+    public LedgerEntryPage getLedgerEntryPage(long ledger,\n+                                              long pageEntry) throws IOException {\n+        LedgerEntryPage lep = getLedgerEntryPageFromCache(ledger, pageEntry, false);\n+        if (lep == null) {\n+            ledgerCacheMissCounter.inc();\n+            lep = grabLedgerEntryPage(ledger, pageEntry);\n+        } else {\n+            ledgerCacheHitCounter.inc();\n+        }\n+        return lep;\n+    }\n+\n+    LedgerEntryPage getLedgerEntryPageFromCache(long ledger,\n+                                                       long firstEntry,\n+                                                       boolean onlyDirty) {\n         LedgerEntryPage lep = pageMapAndList.getPage(ledger, firstEntry);\n         if (onlyDirty && null != lep && lep.isClean()) {\n             return null;\n@@ -415,33 +490,37 @@ private LedgerEntryPage grabLedgerEntryPage(long ledger, long pageEntry) throws\n             // should get the up to date page from the persistence manager\n             // before we put it into table otherwise we would put\n             // an empty page in it\n-            indexPersistenceManager.updatePage(lep);\n-            LedgerEntryPage oldLep;\n-            if (lep != (oldLep = pageMapAndList.putPage(lep))) {\n-                lep.releasePage();\n-                // Decrement the page count because we couldn't put this lep in the page cache.\n-                pageCount.decrementAndGet();\n-                // Increment the use count of the old lep because this is unexpected\n-                oldLep.usePage();\n-                lep = oldLep;\n+            Stopwatch readPageStopwatch = Stopwatch.createStarted();\n+            boolean isNewPage = indexPersistenceManager.updatePage(lep);\n+            if (!isNewPage) {\n+                ledgerCacheReadPageStats.registerSuccessfulEvent(\n+                        readPageStopwatch.elapsed(TimeUnit.MICROSECONDS),\n+                        TimeUnit.MICROSECONDS);\n             }\n         } catch (IOException ie) {\n             // if we grab a clean page, but failed to update the page\n-            // we are exhausting the count of ledger entry pages.\n-            // since this page will be never used, so we need to decrement\n-            // page count of ledger cache.\n-            lep.releasePage();\n-            pageCount.decrementAndGet();\n+            // we should put this page in the free page list so that it\n+            // can be reassigned to the next grabPage request\n+            lep.releasePageNoCallback();\n+            pageMapAndList.addToListOfFreePages(lep);\n             throw ie;\n         }\n+        LedgerEntryPage oldLep;\n+        if (lep != (oldLep = pageMapAndList.putPage(lep))) {\n+            // if we grab a clean page, but failed to put it in the cache\n+            // we should put this page in the free page list so that it\n+            // can be reassigned to the next grabPage request\n+            lep.releasePageNoCallback();\n+            pageMapAndList.addToListOfFreePages(lep);\n+            // Increment the use count of the old lep because this is unexpected\n+            oldLep.usePage();\n+            lep = oldLep;\n+        }\n         return lep;\n     }\n \n     void removePagesForLedger(long ledgerId) {\n-        int removedPageCount = pageMapAndList.removeEntriesForALedger(ledgerId);\n-        if (pageCount.addAndGet(-removedPageCount) < 0) {\n-            throw new RuntimeException(\"Page count of ledger cache has been decremented to be less than zero.\");\n-        }\n+        pageMapAndList.removeEntriesForALedger(ledgerId);\n         ledgersToFlush.remove(ledgerId);\n     }\n \n@@ -524,7 +603,7 @@ private void flushSpecificLedger(long ledger) throws IOException {\n         List<LedgerEntryPage> entries = new ArrayList<LedgerEntryPage>(firstEntryList.size());\n         try {\n             for(Long firstEntry: firstEntryList) {\n-                LedgerEntryPage lep = getLedgerEntryPage(ledger, firstEntry, true);\n+                LedgerEntryPage lep = getLedgerEntryPageFromCache(ledger, firstEntry, true);\n                 if (lep != null) {\n                     entries.add(lep);\n                 }\n@@ -542,26 +621,27 @@ void putEntryOffset(long ledger, long entry, long offset) throws IOException {\n         // find the id of the first entry of the page that has the entry\n         // we are looking for\n         long pageEntry = entry - offsetInPage;\n-        LedgerEntryPage lep = getLedgerEntryPage(ledger, pageEntry, false);\n-        if (lep == null) {\n-            lep = grabLedgerEntryPage(ledger, pageEntry);\n+        LedgerEntryPage lep = null;\n+        try {\n+            lep = getLedgerEntryPage(ledger, pageEntry);\n+            assert lep != null;\n+            lep.setOffset(offset, offsetInPage * LedgerEntryPage.getIndexEntrySize());\n+        } finally {\n+            if (null != lep) {\n+                lep.releasePage();\n+            }\n         }\n-        assert lep != null;\n-        lep.setOffset(offset, offsetInPage * LedgerEntryPage.getIndexEntrySize());\n-        lep.releasePage();\n     }\n \n     long getEntryOffset(long ledger, long entry) throws IOException {\n         int offsetInPage = (int) (entry % entriesPerPage);\n         // find the id of the first entry of the page that has the entry\n         // we are looking for\n         long pageEntry = entry - offsetInPage;\n-        LedgerEntryPage lep = getLedgerEntryPage(ledger, pageEntry, false);\n+        LedgerEntryPage lep = null;\n         try {\n-            if (lep == null) {\n-                lep = grabLedgerEntryPage(ledger, pageEntry);\n-            }\n-            return lep.getOffset(offsetInPage * LedgerEntryPage.getIndexEntrySize());\n+            lep = getLedgerEntryPage(ledger, pageEntry);\n+            return lep.getOffset(offsetInPage  * LedgerEntryPage.getIndexEntrySize());\n         } finally {\n             if (lep != null) {\n                 lep.releasePage();"},{"sha":"6332996abcee9af146cc13a686270a15431cf04d","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/IndexPersistenceMgr.java","status":"modified","additions":11,"deletions":1,"changes":12,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/387dc83d6d2db6a1d30bac3216a92f875083d144/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FIndexPersistenceMgr.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/387dc83d6d2db6a1d30bac3216a92f875083d144/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FIndexPersistenceMgr.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FIndexPersistenceMgr.java?ref=387dc83d6d2db6a1d30bac3216a92f875083d144","patch":"@@ -629,7 +629,15 @@ private void writeBuffers(Long ledger,\n         }\n     }\n \n-    void updatePage(LedgerEntryPage lep) throws IOException {\n+    /**\n+     * Update the ledger entry page\n+     *\n+     * @param lep\n+     *          ledger entry page\n+     * @return true if it is a new page, otherwise false.\n+     * @throws IOException\n+     */\n+    boolean updatePage(LedgerEntryPage lep) throws IOException {\n         if (!lep.isClean()) {\n             throw new IOException(\"Trying to update a dirty page\");\n         }\n@@ -639,8 +647,10 @@ void updatePage(LedgerEntryPage lep) throws IOException {\n             long pos = lep.getFirstEntryPosition();\n             if (pos >= fi.size()) {\n                 lep.zeroPage();\n+                return true;\n             } else {\n                 lep.readPage(fi);\n+                return false;\n             }\n         } finally {\n             if (fi != null) {"},{"sha":"ea96dffa653cbfd5adca693d23e2666bd5b73012","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerEntryPage.java","status":"modified","additions":25,"deletions":2,"changes":27,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/387dc83d6d2db6a1d30bac3216a92f875083d144/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLedgerEntryPage.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/387dc83d6d2db6a1d30bac3216a92f875083d144/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLedgerEntryPage.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLedgerEntryPage.java?ref=387dc83d6d2db6a1d30bac3216a92f875083d144","patch":"@@ -43,7 +43,7 @@ public class LedgerEntryPage {\n     volatile private EntryKey entryKey = new EntryKey(-1, BookieProtocol.INVALID_ENTRY_ID);\n     private final ByteBuffer page;\n     volatile private boolean clean = true;\n-    private final AtomicInteger useCount = new AtomicInteger();\n+    private final AtomicInteger useCount = new AtomicInteger(0);\n     private final AtomicInteger version = new AtomicInteger(0);\n     volatile private int last = -1; // Last update position\n     private final LEPStateChangeCallback callback;\n@@ -66,6 +66,21 @@ public LedgerEntryPage(int pageSize, int entriesPerPage, LEPStateChangeCallback\n         }\n     }\n \n+    // Except for not allocating a new direct byte buffer; this should do everything that\n+    // the constructor does\n+    public void resetPage() {\n+        page.clear();\n+        ZeroBuffer.put(page);\n+        last = -1;\n+        entryKey = new EntryKey(-1, BookieProtocol.INVALID_ENTRY_ID);\n+        clean = true;\n+        useCount.set(0);\n+        if (null != this.callback) {\n+            callback.onResetInUse(this);\n+        }\n+    }\n+\n+\n     @Override\n     public String toString() {\n         StringBuilder sb = new StringBuilder();\n@@ -84,12 +99,20 @@ public void usePage() {\n         }\n     }\n \n+    public void releasePageNoCallback() {\n+        releasePageInternal(false);\n+    }\n+\n     public void releasePage() {\n+        releasePageInternal(true);\n+    }\n+\n+    private void releasePageInternal(boolean shouldCallback) {\n         int newUseCount = useCount.decrementAndGet();\n         if (newUseCount < 0) {\n             throw new IllegalStateException(\"Use count has gone below 0\");\n         }\n-        if ((null != callback) && (newUseCount == 0)) {\n+        if (shouldCallback && (null != callback) && (newUseCount == 0)) {\n             callback.onResetInUse(this);\n         }\n     }"},{"sha":"8f4aacd61b41771f0a4cc54d415412b2439705ae","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/LedgerCacheTest.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/387dc83d6d2db6a1d30bac3216a92f875083d144/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLedgerCacheTest.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/387dc83d6d2db6a1d30bac3216a92f875083d144/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLedgerCacheTest.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLedgerCacheTest.java?ref=387dc83d6d2db6a1d30bac3216a92f875083d144","patch":"@@ -374,7 +374,7 @@ public void testIndexPageEvictionWriteOrder() throws Exception {\n     public void testSyncThreadNPE() throws IOException {\n         newLedgerCache();\n         try {\n-            ((LedgerCacheImpl) ledgerCache).getIndexPageManager().getLedgerEntryPage(0L, 0L, true);\n+            ((LedgerCacheImpl) ledgerCache).getIndexPageManager().getLedgerEntryPageFromCache(0L, 0L, true);\n         } catch (Exception e) {\n             LOG.error(\"Exception when trying to get a ledger entry page\", e);\n             fail(\"Shouldn't have thrown an exception\");"}]}