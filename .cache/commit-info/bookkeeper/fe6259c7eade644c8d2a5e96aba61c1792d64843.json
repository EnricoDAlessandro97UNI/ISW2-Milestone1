{"sha":"fe6259c7eade644c8d2a5e96aba61c1792d64843","node_id":"MDY6Q29tbWl0NDc4NTkyNTI2OmZlNjI1OWM3ZWFkZTY0NGM4ZDJhNWU5NmFiYTYxYzE3OTJkNjQ4NDM=","commit":{"author":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2015-04-21T07:23:48Z"},"committer":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2015-04-21T07:23:48Z"},"message":"BOOKKEEPER-850: Use nanoseconds to calculate poll timeout when doing group commit (Matteo Merli via sijie)","tree":{"sha":"8f2e7e356bd662625eb572b3c0937e92806cd33c","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/trees/8f2e7e356bd662625eb572b3c0937e92806cd33c"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/commits/fe6259c7eade644c8d2a5e96aba61c1792d64843","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/fe6259c7eade644c8d2a5e96aba61c1792d64843","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/fe6259c7eade644c8d2a5e96aba61c1792d64843","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/fe6259c7eade644c8d2a5e96aba61c1792d64843/comments","author":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"committer":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"parents":[{"sha":"6622b46d4979c92cd9c3f450e3832d63513c6a22","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/6622b46d4979c92cd9c3f450e3832d63513c6a22","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/6622b46d4979c92cd9c3f450e3832d63513c6a22"}],"stats":{"total":22,"additions":13,"deletions":9},"files":[{"sha":"c36151debc59d934c14a57fcaff4c55465e0320c","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/fe6259c7eade644c8d2a5e96aba61c1792d64843/CHANGES.txt","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/fe6259c7eade644c8d2a5e96aba61c1792d64843/CHANGES.txt","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/CHANGES.txt?ref=fe6259c7eade644c8d2a5e96aba61c1792d64843","patch":"@@ -69,6 +69,8 @@ Trunk (unreleased changes)\n \n       BOOKKEEPER-849: Collect stats with sub-milliseconds precision (Matteo Merli via sijie)\n \n+      BOOKKEEPER-850: Use nanoseconds to calculate poll timeout when doing group commit (Matteo Merli via sijie)\n+\n       bookkeeper-client:\n \n         BOOKKEEPER-810: Allow to configure TCP connect timeout (Charles Xie via sijie)"},{"sha":"48e5f55d0358071a5e73b164cbf932d86421b9fd","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Journal.java","status":"modified","additions":11,"deletions":9,"changes":20,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/fe6259c7eade644c8d2a5e96aba61c1792d64843/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FJournal.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/fe6259c7eade644c8d2a5e96aba61c1792d64843/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FJournal.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FJournal.java?ref=fe6259c7eade644c8d2a5e96aba61c1792d64843","patch":"@@ -494,7 +494,7 @@ static void writePaddingBytes(JournalChannel jc, ByteBuffer paddingBuffer, int j\n     final ServerConfiguration conf;\n     final ForceWriteThread forceWriteThread;\n     // Time after which we will stop grouping and issue the flush\n-    private final long maxGroupWaitInMSec;\n+    private final long maxGroupWaitInNanos;\n     // Threshold after which we flush any buffered journal entries\n     private final long bufferedEntriesThreshold;\n     // Threshold after which we flush any buffered journal writes\n@@ -546,15 +546,15 @@ public Journal(ServerConfiguration conf, LedgerDirsManager ledgerDirsManager, St\n         this.journalWriteBufferSize = conf.getJournalWriteBufferSizeKB() * KB;\n         this.maxBackupJournals = conf.getMaxBackupJournals();\n         this.forceWriteThread = new ForceWriteThread(this, conf.getJournalAdaptiveGroupWrites());\n-        this.maxGroupWaitInMSec = conf.getJournalMaxGroupWaitMSec();\n+        this.maxGroupWaitInNanos = TimeUnit.MILLISECONDS.toNanos(conf.getJournalMaxGroupWaitMSec());\n         this.bufferedWritesThreshold = conf.getJournalBufferedWritesThreshold();\n         this.bufferedEntriesThreshold = conf.getJournalBufferedEntriesThreshold();\n         this.cbThreadPool = Executors.newFixedThreadPool(conf.getNumJournalCallbackThreads(),\n                                                          new DaemonThreadFactory());\n \n         // Unless there is a cap on the max wait (which requires group force writes)\n         // we cannot skip flushing for queue empty\n-        this.flushWhenQueueEmpty = maxGroupWaitInMSec <= 0 || conf.getJournalFlushWhenQueueEmpty();\n+        this.flushWhenQueueEmpty = maxGroupWaitInNanos <= 0 || conf.getJournalFlushWhenQueueEmpty();\n \n         this.removePagesFromCache = conf.getJournalRemovePagesFromCache();\n         // read last log mark\n@@ -822,17 +822,19 @@ public void run() {\n                     if (toFlush.isEmpty()) {\n                         qe = queue.take();\n                     } else {\n-                        long pollWaitTime = maxGroupWaitInMSec - MathUtils.elapsedMSec(toFlush.getFirst().enqueueTime);\n-                        if (flushWhenQueueEmpty || pollWaitTime < 0) {\n-                            pollWaitTime = 0;\n+                        long pollWaitTimeNanos = maxGroupWaitInNanos - MathUtils.elapsedNanos(toFlush.get(0).enqueueTime);\n+                        if (flushWhenQueueEmpty || pollWaitTimeNanos < 0) {\n+                            pollWaitTimeNanos = 0;\n                         }\n-                        qe = queue.poll(pollWaitTime, TimeUnit.MILLISECONDS);\n+                        qe = queue.poll(pollWaitTimeNanos, TimeUnit.NANOSECONDS);\n                         boolean shouldFlush = false;\n                         // We should issue a forceWrite if any of the three conditions below holds good\n                         // 1. If the oldest pending entry has been pending for longer than the max wait time\n-                        if (maxGroupWaitInMSec > 0 && !groupWhenTimeout && (MathUtils.elapsedMSec(toFlush.getFirst().enqueueTime) > maxGroupWaitInMSec)) {\n+                        if (maxGroupWaitInNanos > 0 && !groupWhenTimeout\n+                                && (MathUtils.elapsedNanos(toFlush.get(0).enqueueTime) > maxGroupWaitInNanos)) {\n                             groupWhenTimeout = true;\n-                        } else if (maxGroupWaitInMSec > 0 && groupWhenTimeout && qe != null && MathUtils.elapsedMSec(qe.enqueueTime) < maxGroupWaitInMSec) {\n+                        } else if (maxGroupWaitInNanos > 0 && groupWhenTimeout && qe != null\n+                                && MathUtils.elapsedNanos(qe.enqueueTime) < maxGroupWaitInNanos) {\n                             // when group timeout, it would be better to look forward, as there might be lots of entries already timeout\n                             // due to a previous slow write (writing to filesystem which impacted by force write).\n                             // Group those entries in the queue"}]}