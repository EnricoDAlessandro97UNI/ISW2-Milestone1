{"sha":"7b5dc6231e89d282fe00b95cb845ddaf15b034e8","node_id":"MDY6Q29tbWl0NDc4NTkyNTI2OjdiNWRjNjIzMWU4OWQyODJmZTAwYjk1Y2I4NDVkZGFmMTViMDM0ZTg=","commit":{"author":{"name":"Jordan Bull","email":"jbull@twitter.com","date":"2016-12-17T05:51:03Z"},"committer":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2016-12-17T05:51:03Z"},"message":"DL-86: Improve handling of lock conflicts in zk session lock\n\nmerge twitter's change from Sijie Guo.\n\nAuthor: Jordan Bull <jbull@twitter.com>\nAuthor: Sijie Guo <sijieg@twitter.com>\n\nReviewers: Leigh Stewart <lstewart@apache.org>\n\nCloses #58 from sijie/merge/DL-86","tree":{"sha":"1cde26be7012b3676735e624f635c2b21bf1e357","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/trees/1cde26be7012b3676735e624f635c2b21bf1e357"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/commits/7b5dc6231e89d282fe00b95cb845ddaf15b034e8","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/7b5dc6231e89d282fe00b95cb845ddaf15b034e8","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/7b5dc6231e89d282fe00b95cb845ddaf15b034e8","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/7b5dc6231e89d282fe00b95cb845ddaf15b034e8/comments","author":{"login":"jordanbull","id":1355932,"node_id":"MDQ6VXNlcjEzNTU5MzI=","avatar_url":"https://avatars.githubusercontent.com/u/1355932?v=4","gravatar_id":"","url":"https://api.github.com/users/jordanbull","html_url":"https://github.com/jordanbull","followers_url":"https://api.github.com/users/jordanbull/followers","following_url":"https://api.github.com/users/jordanbull/following{/other_user}","gists_url":"https://api.github.com/users/jordanbull/gists{/gist_id}","starred_url":"https://api.github.com/users/jordanbull/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jordanbull/subscriptions","organizations_url":"https://api.github.com/users/jordanbull/orgs","repos_url":"https://api.github.com/users/jordanbull/repos","events_url":"https://api.github.com/users/jordanbull/events{/privacy}","received_events_url":"https://api.github.com/users/jordanbull/received_events","type":"User","site_admin":false},"committer":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"parents":[{"sha":"0451d59c89b0df346e39c921acf6f066d949bfe0","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/0451d59c89b0df346e39c921acf6f066d949bfe0","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/0451d59c89b0df346e39c921acf6f066d949bfe0"}],"stats":{"total":84,"additions":80,"deletions":4},"files":[{"sha":"dc57d552d37e8931be7bca3884a01010b49f31ef","filename":"src/main/java/com/twitter/distributedlog/lock/ZKSessionLock.java","status":"modified","additions":31,"deletions":4,"changes":35,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/7b5dc6231e89d282fe00b95cb845ddaf15b034e8/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Flock%2FZKSessionLock.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/7b5dc6231e89d282fe00b95cb845ddaf15b034e8/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Flock%2FZKSessionLock.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Flock%2FZKSessionLock.java?ref=7b5dc6231e89d282fe00b95cb845ddaf15b034e8","patch":"@@ -480,6 +480,31 @@ static int parseMemberID(String nodeName) {\n         return id;\n     }\n \n+    static boolean areLockWaitersInSameSession(String node1, String node2) {\n+        String[] parts1 = node1.split(\"_\");\n+        String[] parts2 = node2.split(\"_\");\n+        if (parts1.length != 4 || parts2.length != 4) {\n+            return node1.equals(node2);\n+        }\n+        if (!parts1[2].startsWith(\"s\") || !parts2[2].startsWith(\"s\")) {\n+            return node1.equals(node2);\n+        }\n+        long sessionOwner1 = Long.parseLong(parts1[2].substring(1));\n+        long sessionOwner2 = Long.parseLong(parts2[2].substring(1));\n+        if (sessionOwner1 != sessionOwner2) {\n+            return false;\n+        }\n+        String clientId1, clientId2;\n+        try {\n+            clientId1 = URLDecoder.decode(parts1[1], UTF_8.name());\n+            clientId2 = URLDecoder.decode(parts2[1], UTF_8.name());\n+            return clientId1.equals(clientId2);\n+        } catch (UnsupportedEncodingException e) {\n+            // if failed to parse client id, we have to get client id by zookeeper#getData.\n+            return node1.equals(node2);\n+        }\n+    }\n+\n     /**\n      * Get client id and its ephemeral owner.\n      *\n@@ -1209,17 +1234,19 @@ private void watchLockOwner(final LockWatcher lockWatcher,\n             @Override\n             public void execute() {\n                 boolean shouldWatch;\n+                final boolean shouldClaimOwnership;\n                 if (lockContext.hasLockId(currentOwner) && siblingNode.equals(ownerNode)) {\n                     // if the current owner is the znode left from previous session\n                     // we should watch it and claim ownership\n                     shouldWatch = true;\n+                    shouldClaimOwnership = true;\n                     LOG.info(\"LockWatcher {} for {} found its previous session {} held lock, watch it to claim ownership.\",\n                             new Object[] { myNode, lockPath, currentOwner });\n-                } else if (lockId.compareTo(currentOwner) == 0 && siblingNode.equals(ownerNode)) {\n+                } else if (lockId.compareTo(currentOwner) == 0 && areLockWaitersInSameSession(siblingNode, ownerNode)) {\n                     // I found that my sibling is the current owner with same lock id (client id & session id)\n                     // It must be left by any race condition from same zookeeper client\n-                    // I would watch owner instead of sibling\n                     shouldWatch = true;\n+                    shouldClaimOwnership = true;\n                     LOG.info(\"LockWatcher {} for {} found itself {} already held lock at sibling node {}, watch it to claim ownership.\",\n                             new Object[]{myNode, lockPath, lockId, siblingNode});\n                 } else {\n@@ -1230,6 +1257,7 @@ public void execute() {\n                                     new Object[]{lockPath, myNode, siblingNode, System.currentTimeMillis()});\n                         }\n                     }\n+                    shouldClaimOwnership = false;\n                 }\n \n                 // watch sibling for lock ownership\n@@ -1247,8 +1275,7 @@ public void execute() {\n                                     }\n \n                                     if (KeeperException.Code.OK.intValue() == rc) {\n-                                        if (siblingNode.equals(ownerNode) &&\n-                                                (lockId.compareTo(currentOwner) == 0 || lockContext.hasLockId(currentOwner))) {\n+                                        if (shouldClaimOwnership) {\n                                             // watch owner successfully\n                                             LOG.info(\"LockWatcher {} claimed ownership for {} after set watcher on {}.\",\n                                                     new Object[]{ myNode, lockPath, ownerNode });"},{"sha":"054d7141c68a0d788ba3aa23f57ab8aeec235f56","filename":"src/test/java/com/twitter/distributedlog/lock/TestZKSessionLock.java","status":"modified","additions":49,"deletions":0,"changes":49,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/7b5dc6231e89d282fe00b95cb845ddaf15b034e8/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Flock%2FTestZKSessionLock.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/7b5dc6231e89d282fe00b95cb845ddaf15b034e8/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Flock%2FTestZKSessionLock.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Flock%2FTestZKSessionLock.java?ref=7b5dc6231e89d282fe00b95cb845ddaf15b034e8","patch":"@@ -179,6 +179,28 @@ public void testParseMemberID() throws Exception {\n         assertEquals(123, parseMemberID(\"member_000123\"));\n     }\n \n+    @Test(timeout = 60000)\n+    public void testAreLockWaitersInSameSession() throws Exception {\n+        ZooKeeper zk = zkc.get();\n+\n+        String lockPath = \"/test-are-lock-waiters-in-same-session\";\n+        String clientId1 = \"test-are-lock-waiters-in-same-session-1\";\n+        String clientId2 = \"test-are-lock-waiters-in-same-session-2\";\n+\n+        createLockPath(zk, lockPath);\n+\n+        String node1 = getLockIdFromPath(createLockNodeV3(zk, lockPath, clientId1));\n+        String node2 = getLockIdFromPath(createLockNodeV3(zk, lockPath, clientId2));\n+        String node3 = getLockIdFromPath(createLockNodeV3(zk, lockPath, clientId1));\n+\n+        assertEquals(node1 + \" and \" + node3 + \" should be in same session.\",\n+                true, areLockWaitersInSameSession(node1, node3));\n+        assertEquals(node1 + \" and \" + node2 + \" should be not in same session.\",\n+                false, areLockWaitersInSameSession(node1, node2));\n+        assertEquals(node3 + \" and \" + node2 + \" should be not in same session.\",\n+                false, areLockWaitersInSameSession(node3, node2));\n+    }\n+\n     @Test(timeout = 60000)\n     public void testExecuteLockAction() throws Exception {\n         String lockPath = \"/test-execute-lock-action\";\n@@ -921,6 +943,33 @@ public void run() {\n         lock1_1.unlock();\n     }\n \n+    @Test(timeout = 60000)\n+    public void testLockWithMultipleSiblingWaiters() throws Exception {\n+        String lockPath = \"/test-lock-with-multiple-sibling-waiters\";\n+        String clientId = \"client-id\";\n+\n+        createLockPath(zkc.get(), lockPath);\n+\n+        final ZKSessionLock lock0 = new ZKSessionLock(zkc, lockPath, clientId, lockStateExecutor);\n+        final ZKSessionLock lock1 = new ZKSessionLock(zkc, lockPath, clientId, lockStateExecutor);\n+        final ZKSessionLock lock2 = new ZKSessionLock(zkc, lockPath, clientId, lockStateExecutor);\n+\n+        lock0.tryLock(Long.MAX_VALUE, TimeUnit.MILLISECONDS);\n+        lock1.tryLock(Long.MAX_VALUE, TimeUnit.MILLISECONDS);\n+        lock2.tryLock(Long.MAX_VALUE, TimeUnit.MILLISECONDS);\n+\n+        List<String> children = awaitWaiters(3, zkc, lockPath);\n+\n+        assertEquals(3, children.size());\n+        assertEquals(State.CLAIMED, lock0.getLockState());\n+        assertEquals(State.CLAIMED, lock1.getLockState());\n+        assertEquals(State.CLAIMED, lock2.getLockState());\n+\n+        lock0.unlock();\n+        lock1.unlock();\n+        lock2.unlock();\n+    }\n+\n     /**\n      * Immediate lock and unlock first lock\n      * @throws Exception"}]}