{"sha":"42e8f1294f206cbe51a6af669cf605833b78bf42","node_id":"MDY6Q29tbWl0NDc4NTkyNTI2OjQyZThmMTI5NGYyMDZjYmU1MWE2YWY2NjljZjYwNTgzM2I3OGJmNDI=","commit":{"author":{"name":"Venkateswara","email":"vjujjuri@salesforce.com","date":"2017-01-31T01:41:54Z"},"committer":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2017-01-31T01:41:54Z"},"message":" BOOKKEEPER-873 and BOOKKEEPER-553\n\n    BOOKKEEPER-873: CreateLedgerAPI to accept ledgerId\n    Add ledgerCreateAdv with ledgerId interface to Bookkeeper\n    and corresponding Junit tests.\n\n    BOOKKEEPER-553: LongHierarchicalLedgerManager\n    - LongHierarchicalLedgerManager to support 63 bits ledgerid (positive long)\n    - LongHierarchicalLedgerManager splits the generated id into 5 parts (3-4-4-4-4)\n\nAuthor: Venkateswara <vjujjuri@salesforce.com>\nAuthor: Charan Reddy Guttapalem <cguttapalem@salesforce.com>\n\nReviewers: Sijie Guo <sijie@apache.org>\n\nCloses #88 from reddycharan/ledgerhandleadvwithledgerid","tree":{"sha":"300d59465ad5d55a09a9160a93fe1a52c841134a","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/trees/300d59465ad5d55a09a9160a93fe1a52c841134a"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/commits/42e8f1294f206cbe51a6af669cf605833b78bf42","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/42e8f1294f206cbe51a6af669cf605833b78bf42","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/42e8f1294f206cbe51a6af669cf605833b78bf42","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/42e8f1294f206cbe51a6af669cf605833b78bf42/comments","author":{"login":"jvrao","id":41390,"node_id":"MDQ6VXNlcjQxMzkw","avatar_url":"https://avatars.githubusercontent.com/u/41390?v=4","gravatar_id":"","url":"https://api.github.com/users/jvrao","html_url":"https://github.com/jvrao","followers_url":"https://api.github.com/users/jvrao/followers","following_url":"https://api.github.com/users/jvrao/following{/other_user}","gists_url":"https://api.github.com/users/jvrao/gists{/gist_id}","starred_url":"https://api.github.com/users/jvrao/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jvrao/subscriptions","organizations_url":"https://api.github.com/users/jvrao/orgs","repos_url":"https://api.github.com/users/jvrao/repos","events_url":"https://api.github.com/users/jvrao/events{/privacy}","received_events_url":"https://api.github.com/users/jvrao/received_events","type":"User","site_admin":false},"committer":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"parents":[{"sha":"13d668f2208bf472e4938cfdfd2de912eaa11275","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/13d668f2208bf472e4938cfdfd2de912eaa11275","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/13d668f2208bf472e4938cfdfd2de912eaa11275"}],"stats":{"total":650,"additions":629,"deletions":21},"files":[{"sha":"2f8a0b8d59a50b0c9304ac33a73f8fc7de541940","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeper.java","status":"modified","additions":108,"deletions":1,"changes":109,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/42e8f1294f206cbe51a6af669cf605833b78bf42/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookKeeper.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/42e8f1294f206cbe51a6af669cf605833b78bf42/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookKeeper.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookKeeper.java?ref=42e8f1294f206cbe51a6af669cf605833b78bf42","patch":"@@ -738,7 +738,114 @@ public void asyncCreateLedgerAdv(final int ensSize, final int writeQuorumSize, f\n                 return;\n             }\n             new LedgerCreateOp(BookKeeper.this, ensSize, writeQuorumSize,\n-                               ackQuorumSize, digestType, passwd, cb, ctx, customMetadata).initiateAdv();\n+                               ackQuorumSize, digestType, passwd, cb, ctx, customMetadata).initiateAdv((long)(-1));\n+        } finally {\n+            closeLock.readLock().unlock();\n+        }\n+    }\n+\n+    /**\n+     * Synchronously creates a new ledger using the interface which accepts a ledgerId as input.\n+     * This method returns {@link LedgerHandleAdv} which can accept entryId.\n+     * Parameters must match those of\n+     * {@link #asyncCreateLedgerAdvWithLedgerId(byte[], long, int, int, int, DigestType, byte[],\n+     *                           AsyncCallback.CreateCallback, Object)}\n+     * @param ledgerId\n+     * @param ensSize\n+     * @param writeQuorumSize\n+     * @param ackQuorumSize\n+     * @param digestType\n+     * @param passwd\n+     * @param customMetadata\n+     * @return a handle to the newly created ledger\n+     * @throws InterruptedException\n+     * @throws BKException\n+     */\n+    public LedgerHandle createLedgerAdv(final long ledgerId,\n+                                        int ensSize,\n+                                        int writeQuorumSize,\n+                                        int ackQuorumSize,\n+                                        DigestType digestType,\n+                                        byte passwd[],\n+                                        final Map<String, byte[]> customMetadata) throws InterruptedException, BKException{\n+        CompletableFuture<LedgerHandle> counter = new CompletableFuture<>();\n+\n+        /*\n+         * Calls asynchronous version\n+         */\n+        asyncCreateLedgerAdv(ledgerId, ensSize, writeQuorumSize, ackQuorumSize, digestType, passwd,\n+                             new SyncCreateCallback(), counter, customMetadata);\n+\n+        LedgerHandle lh = SynchCallbackUtils.waitForResult(counter);\n+        if (lh == null) {\n+            LOG.error(\"Unexpected condition : no ledger handle returned for a success ledger creation\");\n+            throw BKException.create(BKException.Code.UnexpectedConditionException);\n+        } else if (ledgerId != lh.getId()) {\n+            LOG.error(\"Unexpected condition : Expected ledgerId: {} but got: {}\", ledgerId, lh.getId());\n+            throw BKException.create(BKException.Code.UnexpectedConditionException);\n+        }\n+\n+        LOG.info(\"Ensemble: {} for ledger: {}\", lh.getLedgerMetadata().getEnsemble(0L),\n+                lh.getId());\n+\n+        return lh;\n+    }\n+\n+    /**\n+     * Asynchronously creates a new ledger using the interface which accepts a ledgerId as input.\n+     * This method returns {@link LedgerHandleAdv} which can accept entryId.\n+     * Ledgers created with this call have ability to accept\n+     * a separate write quorum and ack quorum size. The write quorum must be larger than\n+     * the ack quorum.\n+     *\n+     * Separating the write and the ack quorum allows the BookKeeper client to continue\n+     * writing when a bookie has failed but the failure has not yet been detected. Detecting\n+     * a bookie has failed can take a number of seconds, as configured by the read timeout\n+     * {@link ClientConfiguration#getReadTimeout()}. Once the bookie failure is detected,\n+     * that bookie will be removed from the ensemble.\n+     *\n+     * The other parameters match those of {@link #asyncCreateLedger(long, int, int, DigestType, byte[],\n+     *                                      AsyncCallback.CreateCallback, Object)}\n+     *\n+     * @param ledgerId\n+     *          ledger Id to use for the newly created ledger\n+     * @param ensSize\n+     *          number of bookies over which to stripe entries\n+     * @param writeQuorumSize\n+     *          number of bookies each entry will be written to\n+     * @param ackQuorumSize\n+     *          number of bookies which must acknowledge an entry before the call is completed\n+     * @param digestType\n+     *          digest type, either MAC or CRC32\n+     * @param passwd\n+     *          password\n+     * @param cb\n+     *          createCallback implementation\n+     * @param ctx\n+     *          optional control object\n+     * @param customMetadata\n+     *          optional customMetadata that holds user specified metadata\n+     */\n+    public void asyncCreateLedgerAdv(final long ledgerId,\n+                                     final int ensSize,\n+                                     final int writeQuorumSize,\n+                                     final int ackQuorumSize,\n+                                     final DigestType digestType,\n+                                     final byte[] passwd,\n+                                     final CreateCallback cb,\n+                                     final Object ctx,\n+                                     final Map<String, byte[]> customMetadata) {\n+        if (writeQuorumSize < ackQuorumSize) {\n+            throw new IllegalArgumentException(\"Write quorum must be larger than ack quorum\");\n+        }\n+        closeLock.readLock().lock();\n+        try {\n+            if (closed) {\n+                cb.createComplete(BKException.Code.ClientClosedException, null, ctx);\n+                return;\n+            }\n+            new LedgerCreateOp(BookKeeper.this, ensSize, writeQuorumSize,\n+                               ackQuorumSize, digestType, passwd, cb, ctx, customMetadata).initiateAdv(ledgerId);\n         } finally {\n             closeLock.readLock().unlock();\n         }"},{"sha":"376d716bb4d028185459b0c32c8f8f7afa014840","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerCreateOp.java","status":"modified","additions":17,"deletions":9,"changes":26,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/42e8f1294f206cbe51a6af669cf605833b78bf42/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FLedgerCreateOp.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/42e8f1294f206cbe51a6af669cf605833b78bf42/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FLedgerCreateOp.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FLedgerCreateOp.java?ref=42e8f1294f206cbe51a6af669cf605833b78bf42","patch":"@@ -48,14 +48,15 @@ class LedgerCreateOp implements GenericCallback<Void> {\n     CreateCallback cb;\n     LedgerMetadata metadata;\n     LedgerHandle lh;\n-    Long ledgerId;\n+    Long ledgerId = -1L;\n     Object ctx;\n     byte[] passwd;\n     BookKeeper bk;\n     DigestType digestType;\n     long startTime;\n     OpStatsLogger createOpLogger;\n     boolean adv = false;\n+    boolean generateLedgerId = true;\n \n     /**\n      * Constructor\n@@ -119,12 +120,16 @@ public void initiate() {\n          * Add ensemble to the configuration\n          */\n         metadata.addEnsemble(0L, ensemble);\n-\n-        createLedger();\n+        if (this.generateLedgerId) {\n+            generateLedgerIdAndCreateLedger();\n+        } else {\n+            // Create ledger with supplied ledgerId\n+            bk.getLedgerManager().createLedgerMetadata(ledgerId, metadata, LedgerCreateOp.this);\n+        }\n     }\n \n-    void createLedger() {\n-        // generate a ledger id and then create the ledger with metadata\n+    void generateLedgerIdAndCreateLedger() {\n+        // generate a ledgerId\n         final LedgerIdGenerator ledgerIdGenerator = bk.getLedgerIdGenerator();\n         ledgerIdGenerator.generateLedgerId(new GenericCallback<Long>() {\n             @Override\n@@ -133,7 +138,6 @@ public void operationComplete(int rc, Long ledgerId) {\n                     createComplete(rc, null);\n                     return;\n                 }\n-\n                 LedgerCreateOp.this.ledgerId = ledgerId;\n                 // create a ledger with metadata\n                 bk.getLedgerManager().createLedgerMetadata(ledgerId, metadata, LedgerCreateOp.this);\n@@ -144,8 +148,12 @@ public void operationComplete(int rc, Long ledgerId) {\n     /**\n      * Initiates the operation to return LedgerHandleAdv.\n      */\n-    public void initiateAdv() {\n+    public void initiateAdv(final long ledgerId) {\n         this.adv = true;\n+        this.ledgerId = ledgerId;\n+        if (this.ledgerId != -1L) {\n+            this.generateLedgerId = false;\n+        }\n         initiate();\n     }\n \n@@ -154,9 +162,9 @@ public void initiateAdv() {\n      */\n     @Override\n     public void operationComplete(int rc, Void result) {\n-        if (BKException.Code.LedgerExistException == rc) {\n+        if (this.generateLedgerId && (BKException.Code.LedgerExistException == rc)) {\n             // retry to generate a new ledger id\n-            createLedger();\n+            generateLedgerIdAndCreateLedger();\n             return;\n         } else if (BKException.Code.OK != rc) {\n             createComplete(rc, null);"},{"sha":"bed16271fa1d2f5999aca4c8505cba46c97691ef","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/HierarchicalLedgerManager.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/42e8f1294f206cbe51a6af669cf605833b78bf42/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FHierarchicalLedgerManager.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/42e8f1294f206cbe51a6af669cf605833b78bf42/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FHierarchicalLedgerManager.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FHierarchicalLedgerManager.java?ref=42e8f1294f206cbe51a6af669cf605833b78bf42","patch":"@@ -84,7 +84,7 @@ public long getLedgerId(String pathName) throws IOException {\n     }\n \n     // get ledger from all level nodes\n-    private long getLedgerId(String...levelNodes) throws IOException {\n+    long getLedgerId(String...levelNodes) throws IOException {\n         return StringUtils.stringToHierarchicalLedgerId(levelNodes);\n     }\n \n@@ -151,7 +151,7 @@ public void process(String l2Node, AsyncCallback.VoidCallback cb2) {\n     /**\n      * Process hash nodes in a given path\n      */\n-    private void asyncProcessLevelNodes(\n+    void asyncProcessLevelNodes(\n         final String path, final Processor<String> processor,\n         final AsyncCallback.VoidCallback finalCb, final Object context,\n         final int successRc, final int failureRc) {"},{"sha":"990297ff7ea582f7bc15853ff71c0fcd46b25efe","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/LongHierarchicalLedgerManager.java","status":"added","additions":334,"deletions":0,"changes":334,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/42e8f1294f206cbe51a6af669cf605833b78bf42/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FLongHierarchicalLedgerManager.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/42e8f1294f206cbe51a6af669cf605833b78bf42/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FLongHierarchicalLedgerManager.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FLongHierarchicalLedgerManager.java?ref=42e8f1294f206cbe51a6af669cf605833b78bf42","patch":"@@ -0,0 +1,334 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.bookkeeper.meta;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NavigableSet;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.bookkeeper.conf.AbstractConfiguration;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.Processor;\n+import org.apache.bookkeeper.util.StringUtils;\n+import org.apache.bookkeeper.util.ZkUtils;\n+import org.apache.zookeeper.AsyncCallback;\n+import org.apache.zookeeper.AsyncCallback.VoidCallback;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.ZooKeeper;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * LongHierarchical Ledger Manager which manages ledger meta in zookeeper using 4-level hierarchical znodes.\n+ *\n+ * <p>\n+ * LongHierarchicalLedgerManager splits the generated id into 5 parts (3-4-4-4-4):\n+ *\n+ * <pre>\n+ * &lt;level1 (3 digits)&gt;&lt;level2 (4 digits)&gt;&lt;level3 (4 digits)&gt;&lt;level4 (4 digits)&gt;\n+ * &lt;level5 (4 digits)&gt;\n+ * </pre>\n+ *\n+ * These 5 parts are used to form the actual ledger node path used to store ledger metadata:\n+ *\n+ * <pre>\n+ * (ledgersRootPath) / level1 / level2 / level3 / level4 / L(level5)\n+ * </pre>\n+ *\n+ * E.g Ledger 0000000000000000001 is split into 5 parts <i>000</i>, <i>0000</i>, <i>0000</i>, <i>0000</i>, <i>0001</i>,\n+ * which is stored in <i>(ledgersRootPath)/000/0000/0000/0000/L0001</i>. So each znode could have at most 10000 ledgers,\n+ * which avoids errors during garbage collection due to lists of children that are too long.\n+ */\n+class LongHierarchicalLedgerManager extends HierarchicalLedgerManager {\n+\n+    static final Logger LOG = LoggerFactory.getLogger(LongHierarchicalLedgerManager.class);\n+\n+    private static final String MAX_ID_SUFFIX = \"9999\";\n+    private static final String MIN_ID_SUFFIX = \"0000\";\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param conf\n+     *            Configuration object\n+     * @param zk\n+     *            ZooKeeper Client Handle\n+     */\n+    public LongHierarchicalLedgerManager(AbstractConfiguration conf, ZooKeeper zk) {\n+        super(conf, zk);\n+    }\n+\n+    @Override\n+    public String getLedgerPath(long ledgerId) {\n+        return ledgerRootPath + StringUtils.getLongHierarchicalLedgerPath(ledgerId);\n+    }\n+\n+    @Override\n+    public long getLedgerId(String pathName) throws IOException {\n+        if (!pathName.startsWith(ledgerRootPath)) {\n+            throw new IOException(\"it is not a valid hashed path name : \" + pathName);\n+        }\n+        String hierarchicalPath = pathName.substring(ledgerRootPath.length() + 1);\n+        return StringUtils.stringToLongHierarchicalLedgerId(hierarchicalPath);\n+    }\n+\n+    //\n+    // Active Ledger Manager\n+    //\n+\n+    /**\n+     * Get the smallest cache id in a specified node /level1/level2/level3/level4\n+     *\n+     * @param level1\n+     *            1st level node name\n+     * @param level2\n+     *            2nd level node name\n+     * @param level3\n+     *            3rd level node name\n+     * @param level4\n+     *            4th level node name\n+     * @return the smallest ledger id\n+     */\n+    private long getStartLedgerIdByLevel(String level1, String level2, String level3, String level4)\n+            throws IOException {\n+        return getLedgerId(level1, level2, level3, level4, MIN_ID_SUFFIX);\n+    }\n+\n+    /**\n+     * Get the largest cache id in a specified node /level1/level2/level3/level4\n+     *\n+     * @param level1\n+     *            1st level node name\n+     * @param level2\n+     *            2nd level node name\n+     * @param level3\n+     *            3rd level node name\n+     * @param level4\n+     *            4th level node name\n+     * @return the largest ledger id\n+     */\n+    private long getEndLedgerIdByLevel(String level1, String level2, String level3, String level4) throws IOException {\n+        return getLedgerId(level1, level2, level3, level4, MAX_ID_SUFFIX);\n+    }\n+\n+    @Override\n+    public void asyncProcessLedgers(final Processor<Long> processor, final AsyncCallback.VoidCallback finalCb,\n+            final Object context, final int successRc, final int failureRc) {\n+        asyncProcessLevelNodes(ledgerRootPath,\n+                new RecursiveProcessor(0, ledgerRootPath, processor, context, successRc, failureRc), finalCb, context,\n+                successRc, failureRc);\n+    }\n+\n+    private class RecursiveProcessor implements Processor<String> {\n+        private final int level;\n+        private final String path;\n+        private final Processor<Long> processor;\n+        private final Object context;\n+        private final int successRc;\n+        private final int failureRc;\n+\n+        private RecursiveProcessor(int level, String path, Processor<Long> processor, Object context, int successRc,\n+                int failureRc) {\n+            this.level = level;\n+            this.path = path;\n+            this.processor = processor;\n+            this.context = context;\n+            this.successRc = successRc;\n+            this.failureRc = failureRc;\n+        }\n+\n+        @Override\n+        public void process(String lNode, VoidCallback cb) {\n+            String nodePath = path + \"/\" + lNode;\n+            if ((level == 0) && isSpecialZnode(lNode)) {\n+                cb.processResult(successRc, null, context);\n+                return;\n+            } else if (level < 3) {\n+                asyncProcessLevelNodes(nodePath,\n+                        new RecursiveProcessor(level + 1, nodePath, processor, context, successRc, failureRc), cb,\n+                        context, successRc, failureRc);\n+            } else {\n+                // process each ledger after all ledger are processed, cb will be call to continue processing next\n+                // level5 node\n+                asyncProcessLedgersInSingleNode(nodePath, processor, cb, context, successRc, failureRc);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public LedgerRangeIterator getLedgerRanges() {\n+        return new LongHierarchicalLedgerRangeIterator();\n+    }\n+\n+    /**\n+     * Iterator through each metadata bucket with hierarchical mode\n+     */\n+    private class LongHierarchicalLedgerRangeIterator implements LedgerRangeIterator {\n+        private List<Iterator<String>> levelNodesIter;\n+        private List<String> curLevelNodes;\n+\n+        private boolean initialized = false;\n+        private boolean iteratorDone = false;\n+        private LedgerRange nextRange = null;\n+\n+        private LongHierarchicalLedgerRangeIterator() {\n+            levelNodesIter = new ArrayList<Iterator<String>>(Collections.nCopies(4, (Iterator<String>) null));\n+            curLevelNodes = new ArrayList<String>(Collections.nCopies(4, (String) null));\n+        }\n+\n+        private void initialize(String path, int level) throws KeeperException, InterruptedException, IOException {\n+            List<String> levelNodes = zk.getChildren(path, null);\n+            Collections.sort(levelNodes);\n+            if (level == 0) {\n+                Iterator<String> l0NodesIter = levelNodes.iterator();\n+                levelNodesIter.set(0, l0NodesIter);\n+                while (l0NodesIter.hasNext()) {\n+                    String curL0Node = l0NodesIter.next();\n+                    if (!isSpecialZnode(curL0Node)) {\n+                        curLevelNodes.set(0, curL0Node);\n+                        break;\n+                    }\n+                }\n+            } else {\n+                Iterator<String> lNodesIter = levelNodes.iterator();\n+                levelNodesIter.set(level, lNodesIter);\n+                if (lNodesIter.hasNext()) {\n+                    String curLNode = lNodesIter.next();\n+                    curLevelNodes.set(level, curLNode);\n+                }\n+            }\n+            String curLNode = curLevelNodes.get(level);\n+            if (curLNode != null) {\n+                if (level != 3) {\n+                    String nextLevelPath = path + \"/\" + curLNode;\n+                    initialize(nextLevelPath, level + 1);\n+                } else {\n+                    nextRange = getLedgerRangeByLevel(curLevelNodes);\n+                    initialized = true;\n+                }\n+            } else {\n+                iteratorDone = true;\n+            }\n+        }\n+\n+        private boolean moveToNext(int level) throws KeeperException, InterruptedException {\n+            Iterator<String> curLevelNodesIter = levelNodesIter.get(level);\n+            boolean movedToNextNode = false;\n+            if (level == 0) {\n+                while (curLevelNodesIter.hasNext()) {\n+                    String nextNode = curLevelNodesIter.next();\n+                    if (isSpecialZnode(nextNode)) {\n+                        continue;\n+                    } else {\n+                        curLevelNodes.set(level, nextNode);\n+                        movedToNextNode = true;\n+                        break;\n+                    }\n+                }\n+            } else {\n+                if (curLevelNodesIter.hasNext()) {\n+                    String nextNode = curLevelNodesIter.next();\n+                    curLevelNodes.set(level, nextNode);\n+                    movedToNextNode = true;\n+                } else {\n+                    movedToNextNode = moveToNext(level - 1);\n+                    if (movedToNextNode) {\n+                        StringBuilder path = new StringBuilder(ledgerRootPath);\n+                        for (int i = 0; i < level; i++) {\n+                            path = path.append(\"/\").append(curLevelNodes.get(i));\n+                        }\n+                        List<String> newCurLevelNodesList = zk.getChildren(path.toString(), null);\n+                        Collections.sort(newCurLevelNodesList);\n+                        Iterator<String> newCurLevelNodesIter = newCurLevelNodesList.iterator();\n+                        levelNodesIter.set(level, newCurLevelNodesIter);\n+                        if (newCurLevelNodesIter.hasNext()) {\n+                            curLevelNodes.set(level, newCurLevelNodesIter.next());\n+                            movedToNextNode = true;\n+                        }\n+                    }\n+                }\n+            }\n+            return movedToNextNode;\n+        }\n+\n+        synchronized private void preload() throws IOException, KeeperException, InterruptedException {\n+            if (!iteratorDone && !initialized) {\n+                initialize(ledgerRootPath, 0);\n+            }\n+            while (((nextRange == null) || (nextRange.size() == 0)) && !iteratorDone) {\n+                boolean movedToNextNode = moveToNext(3);\n+                if (movedToNextNode) {\n+                    nextRange = getLedgerRangeByLevel(curLevelNodes);\n+                } else {\n+                    iteratorDone = true;\n+                }\n+            }\n+        }\n+\n+        @Override\n+        synchronized public boolean hasNext() throws IOException {\n+            try {\n+                preload();\n+            } catch (KeeperException ke) {\n+                throw new IOException(\"Error preloading next range\", ke);\n+            } catch (InterruptedException ie) {\n+                Thread.currentThread().interrupt();\n+                throw new IOException(\"Interrupted while preloading\", ie);\n+            }\n+            return nextRange != null && !iteratorDone;\n+        }\n+\n+        @Override\n+        synchronized public LedgerRange next() throws IOException {\n+            if (!hasNext()) {\n+                throw new NoSuchElementException();\n+            }\n+            LedgerRange r = nextRange;\n+            nextRange = null;\n+            return r;\n+        }\n+\n+        LedgerRange getLedgerRangeByLevel(List<String> curLevelNodes) throws IOException {\n+            String level1 = curLevelNodes.get(0);\n+            String level2 = curLevelNodes.get(1);\n+            String level3 = curLevelNodes.get(2);\n+            String level4 = curLevelNodes.get(3);\n+\n+            StringBuilder nodeBuilder = new StringBuilder();\n+            nodeBuilder.append(ledgerRootPath).append(\"/\").append(level1).append(\"/\").append(level2).append(\"/\")\n+                    .append(level3).append(\"/\").append(level4);\n+            String nodePath = nodeBuilder.toString();\n+            List<String> ledgerNodes = null;\n+            try {\n+                ledgerNodes = ZkUtils.getChildrenInSingleNode(zk, nodePath);\n+            } catch (InterruptedException e) {\n+                throw new IOException(\"Error when get child nodes from zk\", e);\n+            }\n+            NavigableSet<Long> zkActiveLedgers = ledgerListToSet(ledgerNodes, nodePath);\n+            if (LOG.isDebugEnabled()) {\n+                LOG.debug(\"All active ledgers from ZK for hash node \" + level1 + \"/\" + level2 + \"/\" + level3 + \"/\"\n+                        + level4 + \" : \" + zkActiveLedgers);\n+            }\n+            return new LedgerRange(zkActiveLedgers.subSet(getStartLedgerIdByLevel(level1, level2, level3, level4), true,\n+                    getEndLedgerIdByLevel(level1, level2, level3, level4), true));\n+        }\n+    }\n+}"},{"sha":"020bde82271faf152d3ebc94776fdb6320ecc0ee","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/LongHierarchicalLedgerManagerFactory.java","status":"added","additions":12,"deletions":0,"changes":12,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/42e8f1294f206cbe51a6af669cf605833b78bf42/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FLongHierarchicalLedgerManagerFactory.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/42e8f1294f206cbe51a6af669cf605833b78bf42/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FLongHierarchicalLedgerManagerFactory.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FLongHierarchicalLedgerManagerFactory.java?ref=42e8f1294f206cbe51a6af669cf605833b78bf42","patch":"@@ -0,0 +1,12 @@\n+package org.apache.bookkeeper.meta;\n+\n+public class LongHierarchicalLedgerManagerFactory extends HierarchicalLedgerManagerFactory {\n+\n+    public static final String NAME = \"longhierarchical\";\n+\n+    @Override\n+    public LedgerManager newLedgerManager() {\n+        return new LongHierarchicalLedgerManager(conf, zk);\n+    }\n+\n+}"},{"sha":"c2f658b8f02d88558ebb3f314c5e40abfec386ab","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/util/StringUtils.java","status":"modified","additions":49,"deletions":0,"changes":49,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/42e8f1294f206cbe51a6af669cf605833b78bf42/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2FStringUtils.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/42e8f1294f206cbe51a6af669cf605833b78bf42/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2FStringUtils.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2FStringUtils.java?ref=42e8f1294f206cbe51a6af669cf605833b78bf42","patch":"@@ -40,6 +40,16 @@ public static String getZKStringId(long id) {\n         return String.format(\"%010d\", id);\n     }\n \n+    /**\n+     * Formats ledger ID according to ZooKeeper rules\n+     *\n+     * @param id\n+     *            znode id\n+     */\n+    public static String getZKStringIdForLongHierarchical(long id) {\n+        return String.format(\"%019d\", id);\n+    }\n+    \n     /**\n      * Get the hierarchical ledger path according to the ledger id\n      *\n@@ -59,6 +69,27 @@ public static String getHierarchicalLedgerPath(long ledgerId) {\n         return sb.toString();\n     }\n \n+    /**\n+     * Get the long hierarchical ledger path according to the ledger id\n+     *\n+     * @param ledgerId\n+     *          ledger id\n+     * @return the long hierarchical path\n+     */\n+    public static String getLongHierarchicalLedgerPath(long ledgerId) {\n+        String ledgerIdStr = getZKStringIdForLongHierarchical(ledgerId);\n+        // do 3-4-4-4-4 split\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(\"/\")\n+          .append(ledgerIdStr.substring(0, 3)).append(\"/\")\n+          .append(ledgerIdStr.substring(3, 7)).append(\"/\")\n+          .append(ledgerIdStr.substring(7, 11)).append(\"/\")\n+          .append(ledgerIdStr.substring(11, 15)).append(\"/\")\n+          .append(LEDGER_NODE_PREFIX)\n+          .append(ledgerIdStr.substring(15, 19));\n+        return sb.toString();\n+    }\n+    \n     /**\n      * Parse the hierarchical ledger path to its ledger id\n      *\n@@ -77,6 +108,24 @@ public static long stringToHierarchicalLedgerId(String hierarchicalLedgerPath)\n         return stringToHierarchicalLedgerId(hierarchicalParts);\n     }\n \n+    /**\n+     * Parse the long hierarchical ledger path to its ledger id\n+     *\n+     * @param longHierarchicalLedgerPaths\n+     * @return the ledger id\n+     * @throws IOException\n+     */\n+    public static long stringToLongHierarchicalLedgerId(String longHierarchicalLedgerPath)\n+            throws IOException {\n+        String[] longHierarchicalParts = longHierarchicalLedgerPath.split(\"/\");\n+        if (longHierarchicalParts.length != 5) {\n+            throw new IOException(\"it is not a valid hierarchical path name : \" + longHierarchicalLedgerPath);\n+        }\n+        longHierarchicalParts[4] =\n+                longHierarchicalParts[4].substring(LEDGER_NODE_PREFIX.length());\n+        return stringToHierarchicalLedgerId(longHierarchicalParts);\n+    }\n+    \n     /**\n      * Get ledger id\n      *"},{"sha":"69ac921b2b4a9fb518b20df7a686cdc55b015a8e","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookieWriteLedgerTest.java","status":"modified","additions":99,"deletions":4,"changes":103,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/42e8f1294f206cbe51a6af669cf605833b78bf42/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookieWriteLedgerTest.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/42e8f1294f206cbe51a6af669cf605833b78bf42/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookieWriteLedgerTest.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookieWriteLedgerTest.java?ref=42e8f1294f206cbe51a6af669cf605833b78bf42","patch":"@@ -20,26 +20,28 @@\n  */\n package org.apache.bookkeeper.client;\n \n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n import java.nio.ByteBuffer;\n import java.util.ArrayList;\n import java.util.Enumeration;\n+import java.util.List;\n import java.util.Random;\n import java.util.Map;\n import java.util.UUID;\n import java.util.HashMap;\n \n import org.apache.bookkeeper.client.AsyncCallback.AddCallback;\n import org.apache.bookkeeper.client.BookKeeper.DigestType;\n+import org.apache.bookkeeper.meta.LongHierarchicalLedgerManagerFactory;\n import org.apache.bookkeeper.net.BookieSocketAddress;\n import org.apache.bookkeeper.test.MultiLedgerManagerMultiDigestTestCase;\n import org.junit.Before;\n import org.junit.Test;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import static org.junit.Assert.*;\n-\n-\n /**\n  * Testing ledger write entry cases\n  */\n@@ -176,6 +178,50 @@ public void testLedgerCreateAdv() throws Exception {\n         lh.close();\n     }\n \n+    /**\n+     * Verify the functionality of Advanced Ledger which accepts ledgerId as input and returns\n+     * LedgerHandleAdv. LedgerHandleAdv takes entryId for addEntry, and let\n+     * user manage entryId allocation.\n+     *\n+     * @throws Exception\n+     */\n+    @Test(timeout = 60000)\n+    public void testLedgerCreateAdvWithLedgerId() throws Exception {\n+        // Create a ledger\n+        long ledgerId = 0xABCDEF;\n+        lh = bkc.createLedgerAdv(ledgerId, 5, 3, 2, digestType, ledgerPassword, null);\n+        for (int i = 0; i < numEntriesToWrite; i++) {\n+            ByteBuffer entry = ByteBuffer.allocate(4);\n+            entry.putInt(rng.nextInt(maxInt));\n+            entry.position(0);\n+\n+            entries1.add(entry.array());\n+            lh.addEntry(i, entry.array());\n+        }\n+        // Start one more bookies\n+        startNewBookie();\n+\n+        // Shutdown one bookie in the last ensemble and continue writing\n+        ArrayList<BookieSocketAddress> ensemble = lh.getLedgerMetadata().getEnsembles().entrySet().iterator().next()\n+                .getValue();\n+        killBookie(ensemble.get(0));\n+\n+        int i = numEntriesToWrite;\n+        numEntriesToWrite = numEntriesToWrite + 50;\n+        for (; i < numEntriesToWrite; i++) {\n+            ByteBuffer entry = ByteBuffer.allocate(4);\n+            entry.putInt(rng.nextInt(maxInt));\n+            entry.position(0);\n+\n+            entries1.add(entry.array());\n+            lh.addEntry(i, entry.array());\n+        }\n+\n+        readEntries(lh, entries1);\n+        lh.close();\n+        bkc.deleteLedger(ledgerId);\n+    }\n+\n     /**\n      * Verify the functionality of Ledger create which accepts customMetadata as input.\n      * Also verifies that the data written is read back properly.\n@@ -222,6 +268,55 @@ public void testLedgerCreateWithCustomMetadata() throws Exception {\n         }\n     }\n \n+    /*\n+     * In a loop create/write/delete the ledger with same ledgerId through\n+     * the functionality of Advanced Ledger which accepts ledgerId as input.\n+     *\n+     * @throws Exception\n+     */\n+    @Test(timeout = 180000)\n+    public void testLedgerCreateAdvWithLedgerIdInLoop() throws Exception {\n+        long ledgerId;\n+        int ledgerCount = 40;\n+\n+        List<List<byte[]>> entryList = new ArrayList<List<byte[]>>();\n+        LedgerHandle[] lhArray = new LedgerHandle[ledgerCount];\n+\n+        List<byte[]> tmpEntry;\n+        for (int lc = 0; lc < ledgerCount; lc++) {\n+            tmpEntry = new ArrayList<byte[]>();\n+\n+            ledgerId = rng.nextLong();\n+            ledgerId &= Long.MAX_VALUE;\n+            if (!baseConf.getLedgerManagerFactoryClass().equals(LongHierarchicalLedgerManagerFactory.class)) {\n+                // since LongHierarchicalLedgerManager supports ledgerIds of decimal length upto 19 digits but other\n+                // LedgerManagers only upto 10 decimals\n+                ledgerId %= 9999999999L;\n+            }\n+\n+            LOG.info(\"Iteration: {}  LedgerId: {}\", lc, ledgerId);\n+            lh = bkc.createLedgerAdv(ledgerId, 5, 3, 2, digestType, ledgerPassword, null);\n+            lhArray[lc] = lh;\n+\n+            for (int i = 0; i < numEntriesToWrite; i++) {\n+                ByteBuffer entry = ByteBuffer.allocate(4);\n+                entry.putInt(rng.nextInt(maxInt));\n+                entry.position(0);\n+                tmpEntry.add(entry.array());\n+                lh.addEntry(i, entry.array());\n+            }\n+            entryList.add(tmpEntry);\n+        }\n+        for (int lc = 0; lc < ledgerCount; lc++) {\n+            // Read and verify\n+            long lid = lhArray[lc].getId();\n+            LOG.info(\"readEntries for lc: {} ledgerId: {} \", lc, lhArray[lc].getId());\n+            readEntries(lhArray[lc], entryList.get(lc));\n+            lhArray[lc].close();\n+            bkc.deleteLedger(lid);\n+        }\n+    }\n+\n     /**\n      * Verify asynchronous writing when few bookie failures in last ensemble.\n      */\n@@ -615,7 +710,7 @@ public void testLedgerCreateAdvSyncAsyncAddDuplicateEntryIds() throws Exception\n         lh.close();\n     }\n \n-    private void readEntries(LedgerHandle lh, ArrayList<byte[]> entries) throws InterruptedException, BKException {\n+    private void readEntries(LedgerHandle lh, List<byte[]> entries) throws InterruptedException, BKException {\n         ls = lh.readEntries(0, numEntriesToWrite - 1);\n         int index = 0;\n         while (ls.hasMoreElements()) {"},{"sha":"97e3c9f4b8d8bd132c3010b1544fa9dcfede96a2","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestWatchEnsembleChange.java","status":"modified","additions":3,"deletions":1,"changes":4,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/42e8f1294f206cbe51a6af669cf605833b78bf42/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FTestWatchEnsembleChange.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/42e8f1294f206cbe51a6af669cf605833b78bf42/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FTestWatchEnsembleChange.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FTestWatchEnsembleChange.java?ref=42e8f1294f206cbe51a6af669cf605833b78bf42","patch":"@@ -26,6 +26,7 @@\n import org.apache.bookkeeper.meta.LedgerIdGenerator;\n import org.apache.bookkeeper.meta.LedgerManager;\n import org.apache.bookkeeper.meta.LedgerManagerFactory;\n+import org.apache.bookkeeper.meta.LongHierarchicalLedgerManagerFactory;\n import org.apache.bookkeeper.meta.MSLedgerManagerFactory;\n import org.apache.bookkeeper.net.BookieSocketAddress;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks;\n@@ -72,7 +73,8 @@ public static Collection<Object[]> configs() {\n         return Arrays.asList(new Object[][] {\n                 { FlatLedgerManagerFactory.class },\n                 { HierarchicalLedgerManagerFactory.class },\n-                { MSLedgerManagerFactory.class }\n+                { LongHierarchicalLedgerManagerFactory.class },\n+                { MSLedgerManagerFactory.class },\n         });\n     }\n "},{"sha":"c1e8bdec3a6eabaa5288ab0fa297333187713505","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/GcLedgersTest.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/42e8f1294f206cbe51a6af669cf605833b78bf42/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FGcLedgersTest.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/42e8f1294f206cbe51a6af669cf605833b78bf42/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FGcLedgersTest.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FGcLedgersTest.java?ref=42e8f1294f206cbe51a6af669cf605833b78bf42","patch":"@@ -263,7 +263,7 @@ public void clean(long ledgerId) {\n         assertEquals(\"Should have cleaned first ledger\" + first, (long)first, (long)cleaned.poll());\n     }\n \n-    @Test(timeout=60000)\n+    @Test(timeout=120000)\n     public void testGcLedgersNotLast() throws Exception {\n         final SortedSet<Long> createdLedgers = Collections.synchronizedSortedSet(new TreeSet<Long>());\n         final List<Long> cleaned = new ArrayList<Long>();"},{"sha":"53874248cfc6feec3e7697a724e427d89e28c83b","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/LedgerManagerTestCase.java","status":"modified","additions":2,"deletions":1,"changes":3,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/42e8f1294f206cbe51a6af669cf605833b78bf42/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FLedgerManagerTestCase.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/42e8f1294f206cbe51a6af669cf605833b78bf42/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FLedgerManagerTestCase.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FLedgerManagerTestCase.java?ref=42e8f1294f206cbe51a6af669cf605833b78bf42","patch":"@@ -89,7 +89,8 @@ public static Collection<Object[]> configs() {\n         return Arrays.asList(new Object[][] {\n             { FlatLedgerManagerFactory.class },\n             { HierarchicalLedgerManagerFactory.class },\n-            { MSLedgerManagerFactory.class }\n+            { LongHierarchicalLedgerManagerFactory.class },\n+            { MSLedgerManagerFactory.class },\n         });\n     }\n "},{"sha":"2c9a1f488d6e91dd616c7940710372f2e6f318ff","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/MultiLedgerManagerMultiDigestTestCase.java","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/42e8f1294f206cbe51a6af669cf605833b78bf42/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Ftest%2FMultiLedgerManagerMultiDigestTestCase.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/42e8f1294f206cbe51a6af669cf605833b78bf42/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Ftest%2FMultiLedgerManagerMultiDigestTestCase.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Ftest%2FMultiLedgerManagerMultiDigestTestCase.java?ref=42e8f1294f206cbe51a6af669cf605833b78bf42","patch":"@@ -49,6 +49,7 @@ public static Collection<Object[]> configs() {\n         String[] ledgerManagers = {\n             \"org.apache.bookkeeper.meta.FlatLedgerManagerFactory\",\n             \"org.apache.bookkeeper.meta.HierarchicalLedgerManagerFactory\",\n+            \"org.apache.bookkeeper.meta.LongHierarchicalLedgerManagerFactory\",\n             \"org.apache.bookkeeper.meta.MSLedgerManagerFactory\",\n         };\n         ArrayList<Object[]> cfgs = new ArrayList<Object[]>(ledgerManagers.length);"},{"sha":"34a22af8ddb4947cba4a388fa51af74f4aa094fc","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/MultiLedgerManagerTestCase.java","status":"modified","additions":1,"deletions":2,"changes":3,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/42e8f1294f206cbe51a6af669cf605833b78bf42/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Ftest%2FMultiLedgerManagerTestCase.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/42e8f1294f206cbe51a6af669cf605833b78bf42/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Ftest%2FMultiLedgerManagerTestCase.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Ftest%2FMultiLedgerManagerTestCase.java?ref=42e8f1294f206cbe51a6af669cf605833b78bf42","patch":"@@ -28,8 +28,6 @@\n  *\n  */\n \n-import org.apache.bookkeeper.meta.LedgerManagerFactory;\n-\n /**\n  * Test Case run over different ledger manager.\n  */\n@@ -45,6 +43,7 @@ public static Collection<Object[]> configs() {\n         String[] ledgerManagers = new String[] {\n             \"org.apache.bookkeeper.meta.FlatLedgerManagerFactory\",\n             \"org.apache.bookkeeper.meta.HierarchicalLedgerManagerFactory\",\n+            \"org.apache.bookkeeper.meta.LongHierarchicalLedgerManagerFactory\",\n             \"org.apache.bookkeeper.meta.MSLedgerManagerFactory\",\n         };\n         ArrayList<Object[]> cfgs = new ArrayList<Object[]>(ledgerManagers.length);"}]}