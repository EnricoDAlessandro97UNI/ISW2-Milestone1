{"sha":"057af8dbce6c08794eb8b46ca52ca13f222d9bbb","node_id":"MDY6Q29tbWl0NDc4NTkyNTI2OjA1N2FmOGRiY2U2YzA4Nzk0ZWI4YjQ2Y2E1MmNhMTNmMjIyZDliYmI=","commit":{"author":{"name":"Kyle Nusbaum","email":"knusbaum@yahoo-inc.com","date":"2017-05-02T21:04:57Z"},"committer":{"name":"Matteo Merli","email":"mmerli@apache.org","date":"2017-05-02T21:04:57Z"},"message":"BOOKKEEPER-552: 64 Bits Ledger ID Generation\n\nThis PR supersedes #112\n\nInstead of moving LongHierarchicalLedgerManager to HierarchicalLedgerManager, LongHierarchicalLedgerManager is still a stand-alone manager. HierarchicalLedgerManager has been moved to LegacyHierarchicalLedgerManager, and a new HierarchicalLedgerManager class has been put in its place, which is backwards-compatible with the original (now legacy) HierarchicalLedgerManager.\n\nThis new HierarchicalLedgerManager leverages the new LongZkLedgerIdGenerator to generate Ids, and uses the LongHierarchicalLedgerManager to manage metadata for ledger IDs > 31 bits long. For shorter ledger ids, the LegacyHierarchicalLedgerManager is used, to keep backwards-compatibility.\n\nAuthor: Kyle Nusbaum <knusbaum@yahoo-inc.com>\n\nReviewers: Enrico Olivelli <eolivelli@gmail.com>, Matteo Merli <mmerli@apache.org>, Venkateswararao Jujjuri (JV) <None>\n\nCloses #114 from knusbaum/BOOKKEEPER-552","tree":{"sha":"d7abc89a7c5cca24ef394c6906142a083b2da8da","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/trees/d7abc89a7c5cca24ef394c6906142a083b2da8da"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/commits/057af8dbce6c08794eb8b46ca52ca13f222d9bbb","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/057af8dbce6c08794eb8b46ca52ca13f222d9bbb","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/057af8dbce6c08794eb8b46ca52ca13f222d9bbb","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/057af8dbce6c08794eb8b46ca52ca13f222d9bbb/comments","author":null,"committer":{"login":"merlimat","id":62500,"node_id":"MDQ6VXNlcjYyNTAw","avatar_url":"https://avatars.githubusercontent.com/u/62500?v=4","gravatar_id":"","url":"https://api.github.com/users/merlimat","html_url":"https://github.com/merlimat","followers_url":"https://api.github.com/users/merlimat/followers","following_url":"https://api.github.com/users/merlimat/following{/other_user}","gists_url":"https://api.github.com/users/merlimat/gists{/gist_id}","starred_url":"https://api.github.com/users/merlimat/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/merlimat/subscriptions","organizations_url":"https://api.github.com/users/merlimat/orgs","repos_url":"https://api.github.com/users/merlimat/repos","events_url":"https://api.github.com/users/merlimat/events{/privacy}","received_events_url":"https://api.github.com/users/merlimat/received_events","type":"User","site_admin":false},"parents":[{"sha":"9c79e078b8cfefc24251aefcb727760fb99229ed","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/9c79e078b8cfefc24251aefcb727760fb99229ed","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/9c79e078b8cfefc24251aefcb727760fb99229ed"}],"stats":{"total":1756,"additions":1310,"deletions":446},"files":[{"sha":"aa3ec080204baca5203e41a2076bc50dee79218d","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BKException.java","status":"modified","additions":12,"deletions":0,"changes":12,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/057af8dbce6c08794eb8b46ca52ca13f222d9bbb/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBKException.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/057af8dbce6c08794eb8b46ca52ca13f222d9bbb/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBKException.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBKException.java?ref=057af8dbce6c08794eb8b46ca52ca13f222d9bbb","patch":"@@ -102,6 +102,8 @@ public static BKException create(int code) {\n             return new BKDuplicateEntryIdException();\n         case Code.TimeoutException:\n             return new BKTimeoutException();\n+        case Code.LedgerIdOverflowException:\n+            return new BKLedgerIdOverflowException();\n         default:\n             return new BKUnexpectedConditionException();\n         }\n@@ -142,6 +144,8 @@ public interface Code {\n         int UnauthorizedAccessException = -102;\n         int UnclosedFragmentException = -103;\n         int WriteOnReadOnlyBookieException = -104;\n+        //-105 reserved for TooManyRequestsException\n+        int LedgerIdOverflowException = -106;\n \n         // generic exception code used to propagate in replication pipeline\n         int ReplicationException = -200;\n@@ -210,6 +214,8 @@ public static String getMessage(int code) {\n             return \"Attempting to use an unclosed fragment; This is not safe\";\n         case Code.WriteOnReadOnlyBookieException:\n             return \"Attempting to write on ReadOnly bookie\";\n+        case Code.LedgerIdOverflowException:\n+            return \"Next ledgerID is too large.\";\n         case Code.ReplicationException:\n             return \"Errors in replication pipeline\";\n         case Code.ClientClosedException:\n@@ -404,4 +410,10 @@ public BKTimeoutException() {\n             super(Code.TimeoutException);\n         }\n     }\n+\n+    public static class BKLedgerIdOverflowException extends BKException {\n+        public BKLedgerIdOverflowException() {\n+            super(Code.LedgerIdOverflowException);\n+        }\n+    }\n }"},{"sha":"c7c50cdaa72a9339a41ee7981a94e4bd398389db","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/AbstractConfiguration.java","status":"modified","additions":3,"deletions":0,"changes":3,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/057af8dbce6c08794eb8b46ca52ca13f222d9bbb/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fconf%2FAbstractConfiguration.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/057af8dbce6c08794eb8b46ca52ca13f222d9bbb/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fconf%2FAbstractConfiguration.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fconf%2FAbstractConfiguration.java?ref=057af8dbce6c08794eb8b46ca52ca13f222d9bbb","patch":"@@ -76,6 +76,9 @@ public abstract class AbstractConfiguration extends CompositeConfiguration {\n     // Zookeeper ACL settings\n     protected final static String ZK_ENABLE_SECURITY = \"zkEnableSecurity\";\n \n+    // Kluge for compatibility testing. Never set this outside tests.\n+    public final static String LEDGER_MANAGER_FACTORY_DISABLE_CLASS_CHECK = \"ledgerManagerFactoryDisableClassCheck\";\n+\n     protected AbstractConfiguration() {\n         super();\n         if (READ_SYSTEM_PROPERTIES) {"},{"sha":"02359e00eb26540bb68cd4c04a3111872223696c","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/AbstractHierarchicalLedgerManager.java","status":"added","additions":213,"deletions":0,"changes":213,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/057af8dbce6c08794eb8b46ca52ca13f222d9bbb/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FAbstractHierarchicalLedgerManager.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/057af8dbce6c08794eb8b46ca52ca13f222d9bbb/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FAbstractHierarchicalLedgerManager.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FAbstractHierarchicalLedgerManager.java?ref=057af8dbce6c08794eb8b46ca52ca13f222d9bbb","patch":"@@ -0,0 +1,213 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.bookkeeper.meta;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.NavigableSet;\n+import java.util.TreeSet;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.apache.bookkeeper.conf.AbstractConfiguration;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.Processor;\n+import org.apache.bookkeeper.util.StringUtils;\n+import org.apache.zookeeper.AsyncCallback;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.ZooKeeper;\n+import org.apache.zookeeper.AsyncCallback.VoidCallback;\n+import org.apache.zookeeper.KeeperException.Code;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public abstract class AbstractHierarchicalLedgerManager extends AbstractZkLedgerManager {\n+    \n+    private static final Logger LOG = LoggerFactory.getLogger(AbstractHierarchicalLedgerManager.class);\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param conf\n+     *          Configuration object\n+     * @param zk\n+     *          ZooKeeper Client Handle\n+     */\n+    public AbstractHierarchicalLedgerManager(AbstractConfiguration conf, ZooKeeper zk) {\n+        super(conf, zk);\n+    }\n+    \n+    /**\n+     * Process hash nodes in a given path\n+     */\n+    void asyncProcessLevelNodes(\n+        final String path, final Processor<String> processor,\n+        final AsyncCallback.VoidCallback finalCb, final Object context,\n+        final int successRc, final int failureRc) {\n+        zk.sync(path, new AsyncCallback.VoidCallback() {\n+            @Override\n+            public void processResult(int rc, String path, Object ctx) {\n+                if (rc != Code.OK.intValue()) {\n+                    LOG.error(\"Error syncing path \" + path + \" when getting its chidren: \",\n+                              KeeperException.create(KeeperException.Code.get(rc), path));\n+                    finalCb.processResult(failureRc, null, context);\n+                    return;\n+                }\n+\n+                zk.getChildren(path, false, new AsyncCallback.ChildrenCallback() {\n+                    @Override\n+                    public void processResult(int rc, String path, Object ctx,\n+                                              List<String> levelNodes) {\n+                        if (rc != Code.OK.intValue()) {\n+                            LOG.error(\"Error polling hash nodes of \" + path,\n+                                      KeeperException.create(KeeperException.Code.get(rc), path));\n+                            finalCb.processResult(failureRc, null, context);\n+                            return;\n+                        }\n+                        AsyncListProcessor<String> listProcessor =\n+                                new AsyncListProcessor<String>(scheduler);\n+                        // process its children\n+                        listProcessor.process(levelNodes, processor, finalCb,\n+                                              context, successRc, failureRc);\n+                    }\n+                }, null);\n+            }\n+        }, null);\n+    }\n+    \n+    /**\n+     * Process list one by one in asynchronize way. Process will be stopped immediately\n+     * when error occurred.\n+     */\n+    private static class AsyncListProcessor<T> {\n+        // use this to prevent long stack chains from building up in callbacks\n+        ScheduledExecutorService scheduler;\n+\n+        /**\n+         * Constructor\n+         *\n+         * @param scheduler\n+         *          Executor used to prevent long stack chains\n+         */\n+        public AsyncListProcessor(ScheduledExecutorService scheduler) {\n+            this.scheduler = scheduler;\n+        }\n+\n+        /**\n+         * Process list of items\n+         *\n+         * @param data\n+         *          List of data to process\n+         * @param processor\n+         *          Callback to process element of list when success\n+         * @param finalCb\n+         *          Final callback to be called after all elements in the list are processed\n+         * @param context\n+         *          Context of final callback\n+         * @param successRc\n+         *          RC passed to final callback on success\n+         * @param failureRc\n+         *          RC passed to final callback on failure\n+         */\n+        public void process(final List<T> data, final Processor<T> processor,\n+                            final AsyncCallback.VoidCallback finalCb, final Object context,\n+                            final int successRc, final int failureRc) {\n+            if (data == null || data.size() == 0) {\n+                finalCb.processResult(successRc, null, context);\n+                return;\n+            }\n+            final int size = data.size();\n+            final AtomicInteger current = new AtomicInteger(0);\n+            AsyncCallback.VoidCallback stubCallback = new AsyncCallback.VoidCallback() {\n+                @Override\n+                public void processResult(int rc, String path, Object ctx) {\n+                    if (rc != successRc) {\n+                        // terminal immediately\n+                        finalCb.processResult(failureRc, null, context);\n+                        return;\n+                    }\n+                    // process next element\n+                    int next = current.incrementAndGet();\n+                    if (next >= size) { // reach the end of list\n+                        finalCb.processResult(successRc, null, context);\n+                        return;\n+                    }\n+                    final T dataToProcess = data.get(next);\n+                    final AsyncCallback.VoidCallback stub = this;\n+                    scheduler.submit(new Runnable() {\n+                        @Override\n+                        public final void run() {\n+                            processor.process(dataToProcess, stub);\n+                        }\n+                    });\n+                }\n+            };\n+            T firstElement = data.get(0);\n+            processor.process(firstElement, stubCallback);\n+        }\n+    }\n+    \n+    // get ledger from all level nodes\n+    long getLedgerId(String...levelNodes) throws IOException {\n+        return StringUtils.stringToHierarchicalLedgerId(levelNodes);\n+    }\n+    \n+    /**\n+     * Get all ledger ids in the given zk path.\n+     *\n+     * @param ledgerNodes\n+     *          List of ledgers in the given path\n+     *          example:- {L1652, L1653, L1650}\n+     * @param path\n+     *          The zookeeper path of the ledger ids. The path should start with {@ledgerRootPath}\n+     *          example (with ledgerRootPath = /ledgers):- /ledgers/00/0053\n+     */\n+    @Override\n+    protected NavigableSet<Long> ledgerListToSet(List<String> ledgerNodes, String path) {\n+        NavigableSet<Long> zkActiveLedgers = new TreeSet<Long>();\n+\n+        if (!path.startsWith(ledgerRootPath)) {\n+            LOG.warn(\"Ledger path [{}] is not a valid path name, it should start wth {}\", path, ledgerRootPath);\n+            return zkActiveLedgers;\n+        }\n+\n+        long ledgerIdPrefix = 0;\n+        char ch;\n+        for (int i = ledgerRootPath.length() + 1; i < path.length(); i++) {\n+            ch = path.charAt(i);\n+            if (ch < '0' || ch > '9')\n+                continue;\n+            ledgerIdPrefix = ledgerIdPrefix * 10 + (ch - '0');\n+        }\n+\n+        for (String ledgerNode : ledgerNodes) {\n+            if (isSpecialZnode(ledgerNode)) {\n+                continue;\n+            }\n+            long ledgerId = ledgerIdPrefix;\n+            for (int i = 0; i < ledgerNode.length(); i++) {\n+                ch = ledgerNode.charAt(i);\n+                if (ch < '0' || ch > '9')\n+                    continue;\n+                ledgerId = ledgerId * 10 + (ch - '0');\n+            }\n+            zkActiveLedgers.add(ledgerId);\n+        }\n+        return zkActiveLedgers;\n+    }\n+\n+}"},{"sha":"f5a60f61672d7fc28bd349f767ea476abf1229c0","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/AbstractZkLedgerManager.java","status":"modified","additions":2,"deletions":1,"changes":3,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/057af8dbce6c08794eb8b46ca52ca13f222d9bbb/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FAbstractZkLedgerManager.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/057af8dbce6c08794eb8b46ca52ca13f222d9bbb/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FAbstractZkLedgerManager.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FAbstractZkLedgerManager.java?ref=057af8dbce6c08794eb8b46ca52ca13f222d9bbb","patch":"@@ -38,6 +38,7 @@\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.MultiCallback;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.Processor;\n import org.apache.bookkeeper.util.BookKeeperConstants;\n+import org.apache.bookkeeper.util.StringUtils;\n import org.apache.bookkeeper.util.ZkUtils;\n import org.apache.bookkeeper.versioning.Version;\n import org.apache.zookeeper.AsyncCallback;\n@@ -468,7 +469,7 @@ public void operationComplete(int rc, List<String> ledgerNodes) {\n      *          Znode Name\n      * @return true  if the znode is a special znode otherwise false\n      */\n-    protected boolean isSpecialZnode(String znode) {\n+     protected static boolean isSpecialZnode(String znode) {\n         if (BookKeeperConstants.AVAILABLE_NODE.equals(znode)\n                 || BookKeeperConstants.COOKIE_NODE.equals(znode)\n                 || BookKeeperConstants.LAYOUT_ZNODE.equals(znode)"},{"sha":"36db62a35031f3354e9c26397a6eec0b844adffa","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/FlatLedgerManager.java","status":"modified","additions":3,"deletions":3,"changes":6,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/057af8dbce6c08794eb8b46ca52ca13f222d9bbb/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FFlatLedgerManager.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/057af8dbce6c08794eb8b46ca52ca13f222d9bbb/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FFlatLedgerManager.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FFlatLedgerManager.java?ref=057af8dbce6c08794eb8b46ca52ca13f222d9bbb","patch":"@@ -87,9 +87,9 @@ public void asyncProcessLedgers(final Processor<Long> processor,\n         asyncProcessLedgersInSingleNode(ledgerRootPath, processor, finalCb, ctx, successRc, failureRc);\n     }\n \n-    @Override\n-    protected boolean isSpecialZnode(String znode) {\n-        return znode.startsWith(ZkLedgerIdGenerator.LEDGER_ID_GEN_PREFIX) || super.isSpecialZnode(znode);\n+    \n+    protected static boolean isSpecialZnode(String znode) {\n+        return znode.startsWith(ZkLedgerIdGenerator.LEDGER_ID_GEN_PREFIX) || AbstractZkLedgerManager.isSpecialZnode(znode);\n     }\n \n     @Override"},{"sha":"309762befae8d490a861b31a90cc73ea90610254","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/HierarchicalLedgerManager.java","status":"modified","additions":55,"deletions":320,"changes":375,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/057af8dbce6c08794eb8b46ca52ca13f222d9bbb/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FHierarchicalLedgerManager.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/057af8dbce6c08794eb8b46ca52ca13f222d9bbb/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FHierarchicalLedgerManager.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FHierarchicalLedgerManager.java?ref=057af8dbce6c08794eb8b46ca52ca13f222d9bbb","patch":"@@ -18,370 +18,105 @@\n package org.apache.bookkeeper.meta;\n \n import java.io.IOException;\n-import java.util.Collections;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.NavigableSet;\n-import java.util.NoSuchElementException;\n-import java.util.concurrent.ScheduledExecutorService;\n-import java.util.concurrent.atomic.AtomicInteger;\n \n import org.apache.bookkeeper.conf.AbstractConfiguration;\n+import org.apache.bookkeeper.meta.LedgerManager.LedgerRangeIterator;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.Processor;\n import org.apache.bookkeeper.util.StringUtils;\n-import org.apache.bookkeeper.util.ZkUtils;\n-import org.apache.zookeeper.AsyncCallback;\n-import org.apache.zookeeper.KeeperException;\n-import org.apache.zookeeper.KeeperException.Code;\n-import org.apache.zookeeper.ZooKeeper;\n+import org.apache.zookeeper.AsyncCallback.VoidCallback;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n+import org.apache.zookeeper.ZooKeeper;\n \n /**\n- * Hierarchical Ledger Manager which manages ledger meta in zookeeper using 2-level hierarchical znodes.\n+ * HierarchicalLedgerManager makes use of both LongHierarchicalLedgerManager and LegacyHierarchicalLedgerManager\n+ * to extend the 31-bit ledger id range of the LegacyHierarchicalLedgerManager to that of the LongHierarchicalLedgerManager\n+ * while remaining backwards-compatible with the legacy manager.\n+ * \n+ * In order to achieve backwards-compatibility, the HierarchicalLedgerManager forwards requests relating to ledger IDs which \n+ * are < Integer.MAX_INT to the LegacyHierarchicalLedgerManager. The new 5-part directory structure will not appear until a \n+ * ledger with an ID >= Integer.MAX_INT is created.\n  *\n- * <p>\n- * HierarchicalLedgerManager splits the generated id into 3 parts (2-4-4):\n- * <pre>&lt;level1 (2 digits)&gt;&lt;level2 (4 digits)&gt;&lt;level3 (4 digits)&gt;</pre>\n- * These 3 parts are used to form the actual ledger node path used to store ledger metadata:\n- * <pre>(ledgersRootPath)/level1/level2/L(level3)</pre>\n- * E.g Ledger 0000000001 is split into 3 parts <i>00</i>, <i>0000</i>, <i>0001</i>, which is stored in\n- * <i>(ledgersRootPath)/00/0000/L0001</i>. So each znode could have at most 10000 ledgers, which avoids\n- * errors during garbage collection due to lists of children that are too long.\n+ * @see LongHierarchicalLedgerManager\n+ * @see LegacyHierarchicalLedgerManager\n  */\n-class HierarchicalLedgerManager extends AbstractZkLedgerManager {\n-\n+class HierarchicalLedgerManager extends AbstractHierarchicalLedgerManager {\n     static final Logger LOG = LoggerFactory.getLogger(HierarchicalLedgerManager.class);\n \n-    static final String IDGEN_ZNODE = \"idgen\";\n-    private static final String MAX_ID_SUFFIX = \"9999\";\n-    private static final String MIN_ID_SUFFIX = \"0000\";\n+    LegacyHierarchicalLedgerManager legacyLM;\n+    LongHierarchicalLedgerManager longLM;\n \n-    /**\n-     * Constructor\n-     *\n-     * @param conf\n-     *          Configuration object\n-     * @param zk\n-     *          ZooKeeper Client Handle\n-     */\n     public HierarchicalLedgerManager(AbstractConfiguration conf, ZooKeeper zk) {\n         super(conf, zk);\n+        legacyLM = new LegacyHierarchicalLedgerManager(conf, zk);\n+        longLM = new LongHierarchicalLedgerManager (conf, zk);\n     }\n \n     @Override\n-    public String getLedgerPath(long ledgerId) {\n-        return ledgerRootPath + StringUtils.getHierarchicalLedgerPath(ledgerId);\n-    }\n-\n-    @Override\n-    public long getLedgerId(String pathName) throws IOException {\n-        if (!pathName.startsWith(ledgerRootPath)) {\n-            throw new IOException(\"it is not a valid hashed path name : \" + pathName);\n-        }\n-        String hierarchicalPath = pathName.substring(ledgerRootPath.length() + 1);\n-        return StringUtils.stringToHierarchicalLedgerId(hierarchicalPath);\n-    }\n-\n-    // get ledger from all level nodes\n-    long getLedgerId(String...levelNodes) throws IOException {\n-        return StringUtils.stringToHierarchicalLedgerId(levelNodes);\n-    }\n-\n-    //\n-    // Active Ledger Manager\n-    //\n-\n-    /**\n-     * Get the smallest cache id in a specified node /level1/level2\n-     *\n-     * @param level1\n-     *          1st level node name\n-     * @param level2\n-     *          2nd level node name\n-     * @return the smallest ledger id\n-     */\n-    private long getStartLedgerIdByLevel(String level1, String level2) throws IOException {\n-        return getLedgerId(level1, level2, MIN_ID_SUFFIX);\n-    }\n-\n-    /**\n-     * Get the largest cache id in a specified node /level1/level2\n-     *\n-     * @param level1\n-     *          1st level node name\n-     * @param level2\n-     *          2nd level node name\n-     * @return the largest ledger id\n-     */\n-    private long getEndLedgerIdByLevel(String level1, String level2) throws IOException {\n-        return getLedgerId(level1, level2, MAX_ID_SUFFIX);\n-    }\n-\n-    @Override\n-    public void asyncProcessLedgers(final Processor<Long> processor,\n-                                    final AsyncCallback.VoidCallback finalCb, final Object context,\n-                                    final int successRc, final int failureRc) {\n-        // process 1st level nodes\n-        asyncProcessLevelNodes(ledgerRootPath, new Processor<String>() {\n-            @Override\n-            public void process(final String l1Node, final AsyncCallback.VoidCallback cb1) {\n-                if (isSpecialZnode(l1Node)) {\n-                    cb1.processResult(successRc, null, context);\n-                    return;\n-                }\n-                final String l1NodePath = ledgerRootPath + \"/\" + l1Node;\n-                // process level1 path, after all children of level1 process\n-                // it callback to continue processing next level1 node\n-                asyncProcessLevelNodes(l1NodePath, new Processor<String>() {\n-                    @Override\n-                    public void process(String l2Node, AsyncCallback.VoidCallback cb2) {\n-                        // process level1/level2 path\n-                        String l2NodePath = ledgerRootPath + \"/\" + l1Node + \"/\" + l2Node;\n-                        // process each ledger\n-                        // after all ledger are processed, cb2 will be call to continue processing next level2 node\n-                        asyncProcessLedgersInSingleNode(l2NodePath, processor, cb2,\n-                                                        context, successRc, failureRc);\n-                    }\n-                }, cb1, context, successRc, failureRc);\n-            }\n-        }, finalCb, context, successRc, failureRc);\n-    }\n+    public void asyncProcessLedgers(Processor<Long> processor, VoidCallback finalCb, Object context, int successRc,\n+            int failureRc) {\n+        // Process the old 31-bit id ledgers first.\n+        legacyLM.asyncProcessLedgers(processor, new VoidCallback(){\n \n-    /**\n-     * Process hash nodes in a given path\n-     */\n-    void asyncProcessLevelNodes(\n-        final String path, final Processor<String> processor,\n-        final AsyncCallback.VoidCallback finalCb, final Object context,\n-        final int successRc, final int failureRc) {\n-        zk.sync(path, new AsyncCallback.VoidCallback() {\n             @Override\n             public void processResult(int rc, String path, Object ctx) {\n-                if (rc != Code.OK.intValue()) {\n-                    LOG.error(\"Error syncing path \" + path + \" when getting its chidren: \",\n-                              KeeperException.create(KeeperException.Code.get(rc), path));\n-                    finalCb.processResult(failureRc, null, context);\n-                    return;\n+                if(rc == failureRc) {\n+                    // If it fails, return the failure code to the callback\n+                    finalCb.processResult(rc, path, ctx);\n+                }\n+                else {\n+                    // If it succeeds, proceed with our own recursive ledger processing for the 63-bit id ledgers\n+                    longLM.asyncProcessLedgers(processor, finalCb, context, successRc, failureRc);\n                 }\n-\n-                zk.getChildren(path, false, new AsyncCallback.ChildrenCallback() {\n-                    @Override\n-                    public void processResult(int rc, String path, Object ctx,\n-                                              List<String> levelNodes) {\n-                        if (rc != Code.OK.intValue()) {\n-                            LOG.error(\"Error polling hash nodes of \" + path,\n-                                      KeeperException.create(KeeperException.Code.get(rc), path));\n-                            finalCb.processResult(failureRc, null, context);\n-                            return;\n-                        }\n-                        AsyncListProcessor<String> listProcessor =\n-                                new AsyncListProcessor<String>(scheduler);\n-                        // process its children\n-                        listProcessor.process(levelNodes, processor, finalCb,\n-                                              context, successRc, failureRc);\n-                    }\n-                }, null);\n             }\n-        }, null);\n-    }\n-\n-    /**\n-     * Process list one by one in asynchronize way. Process will be stopped immediately\n-     * when error occurred.\n-     */\n-    private static class AsyncListProcessor<T> {\n-        // use this to prevent long stack chains from building up in callbacks\n-        ScheduledExecutorService scheduler;\n \n-        /**\n-         * Constructor\n-         *\n-         * @param scheduler\n-         *          Executor used to prevent long stack chains\n-         */\n-        public AsyncListProcessor(ScheduledExecutorService scheduler) {\n-            this.scheduler = scheduler;\n-        }\n+        }, context, successRc, failureRc);\n+    }\n \n-        /**\n-         * Process list of items\n-         *\n-         * @param data\n-         *          List of data to process\n-         * @param processor\n-         *          Callback to process element of list when success\n-         * @param finalCb\n-         *          Final callback to be called after all elements in the list are processed\n-         * @param context\n-         *          Context of final callback\n-         * @param successRc\n-         *          RC passed to final callback on success\n-         * @param failureRc\n-         *          RC passed to final callback on failure\n-         */\n-        public void process(final List<T> data, final Processor<T> processor,\n-                            final AsyncCallback.VoidCallback finalCb, final Object context,\n-                            final int successRc, final int failureRc) {\n-            if (data == null || data.size() == 0) {\n-                finalCb.processResult(successRc, null, context);\n-                return;\n-            }\n-            final int size = data.size();\n-            final AtomicInteger current = new AtomicInteger(0);\n-            AsyncCallback.VoidCallback stubCallback = new AsyncCallback.VoidCallback() {\n-                @Override\n-                public void processResult(int rc, String path, Object ctx) {\n-                    if (rc != successRc) {\n-                        // terminal immediately\n-                        finalCb.processResult(failureRc, null, context);\n-                        return;\n-                    }\n-                    // process next element\n-                    int next = current.incrementAndGet();\n-                    if (next >= size) { // reach the end of list\n-                        finalCb.processResult(successRc, null, context);\n-                        return;\n-                    }\n-                    final T dataToProcess = data.get(next);\n-                    final AsyncCallback.VoidCallback stub = this;\n-                    scheduler.submit(new Runnable() {\n-                        @Override\n-                        public final void run() {\n-                            processor.process(dataToProcess, stub);\n-                        }\n-                    });\n-                }\n-            };\n-            T firstElement = data.get(0);\n-            processor.process(firstElement, stubCallback);\n-        }\n+    @Override\n+    protected String getLedgerPath(long ledgerId) {\n+        return ledgerRootPath + StringUtils.getHybridHierarchicalLedgerPath(ledgerId);\n     }\n \n     @Override\n-    protected boolean isSpecialZnode(String znode) {\n-        return IDGEN_ZNODE.equals(znode) || super.isSpecialZnode(znode);\n+    protected long getLedgerId(String ledgerPath) throws IOException {\n+        // TODO Auto-generated method stub\n+        if (!ledgerPath.startsWith(ledgerRootPath)) {\n+            throw new IOException(\"it is not a valid hashed path name : \" + ledgerPath);\n+        }\n+        String hierarchicalPath = ledgerPath.substring(ledgerRootPath.length() + 1);\n+        return StringUtils.stringToLongHierarchicalLedgerId(hierarchicalPath);\n     }\n \n     @Override\n     public LedgerRangeIterator getLedgerRanges() {\n-        return new HierarchicalLedgerRangeIterator();\n+        LedgerRangeIterator legacyLedgerRangeIterator = legacyLM.getLedgerRanges();\n+        LedgerRangeIterator longLedgerRangeIterator = longLM.getLedgerRanges();\n+        return new HierarchicalLedgerRangeIterator(legacyLedgerRangeIterator, longLedgerRangeIterator);\n     }\n \n-    /**\n-     * Iterator through each metadata bucket with hierarchical mode\n-     */\n-    private class HierarchicalLedgerRangeIterator implements LedgerRangeIterator {\n-        private Iterator<String> l1NodesIter = null;\n-        private Iterator<String> l2NodesIter = null;\n-        private String curL1Nodes = \"\";\n-        private boolean iteratorDone = false;\n-        private LedgerRange nextRange = null;\n+    private static class HierarchicalLedgerRangeIterator implements LedgerRangeIterator {\n \n-        /**\n-         * iterate next level1 znode\n-         *\n-         * @return false if have visited all level1 nodes\n-         * @throws InterruptedException/KeeperException if error occurs reading zookeeper children\n-         */\n-        private boolean nextL1Node() throws KeeperException, InterruptedException {\n-            l2NodesIter = null;\n-            while (l2NodesIter == null) {\n-                if (l1NodesIter.hasNext()) {\n-                    curL1Nodes = l1NodesIter.next();\n-                } else {\n-                    return false;\n-                }\n-                if (isSpecialZnode(curL1Nodes)) {\n-                    continue;\n-                }\n-                List<String> l2Nodes = zk.getChildren(ledgerRootPath + \"/\" + curL1Nodes, null);\n-                Collections.sort(l2Nodes);\n-                l2NodesIter = l2Nodes.iterator();\n-                if (!l2NodesIter.hasNext()) {\n-                    l2NodesIter = null;\n-                    continue;\n-                }\n-            }\n-            return true;\n-        }\n+        LedgerRangeIterator legacyLedgerRangeIterator;\n+        LedgerRangeIterator longLedgerRangeIterator;\n \n-        synchronized private void preload() throws IOException {\n-            while (nextRange == null && !iteratorDone) {\n-                boolean hasMoreElements = false;\n-                try {\n-                    if (l1NodesIter == null) {\n-                        List<String> l1Nodes = zk.getChildren(ledgerRootPath, null);\n-                        Collections.sort(l1Nodes);\n-                        l1NodesIter = l1Nodes.iterator();\n-                        hasMoreElements = nextL1Node();\n-                    } else if (l2NodesIter == null || !l2NodesIter.hasNext()) {\n-                        hasMoreElements = nextL1Node();\n-                    } else {\n-                        hasMoreElements = true;\n-                    }\n-                } catch (KeeperException ke) {\n-                    throw new IOException(\"Error preloading next range\", ke);\n-                } catch (InterruptedException ie) {\n-                    Thread.currentThread().interrupt();\n-                    throw new IOException(\"Interrupted while preloading\", ie);\n-                }\n-                if (hasMoreElements) {\n-                    nextRange = getLedgerRangeByLevel(curL1Nodes, l2NodesIter.next());\n-                    if (nextRange.size() == 0) {\n-                        nextRange = null;\n-                    }\n-                } else {\n-                    iteratorDone = true;\n-                }\n-            }\n+        HierarchicalLedgerRangeIterator(LedgerRangeIterator legacyLedgerRangeIterator, LedgerRangeIterator longLedgerRangeIterator) {\n+            this.legacyLedgerRangeIterator = legacyLedgerRangeIterator;\n+            this.longLedgerRangeIterator = longLedgerRangeIterator;\n         }\n \n         @Override\n-        synchronized public boolean hasNext() throws IOException {\n-            preload();\n-            return nextRange != null && !iteratorDone;\n+        public boolean hasNext() throws IOException {\n+            return legacyLedgerRangeIterator.hasNext() || longLedgerRangeIterator.hasNext();\n         }\n \n         @Override\n-        synchronized public LedgerRange next() throws IOException {\n-            if (!hasNext()) {\n-                throw new NoSuchElementException();\n+        public LedgerRange next() throws IOException {\n+            if(legacyLedgerRangeIterator.hasNext()) {\n+                return legacyLedgerRangeIterator.next();\n             }\n-            LedgerRange r = nextRange;\n-            nextRange = null;\n-            return r;\n+            return longLedgerRangeIterator.next();\n         }\n \n-        /**\n-         * Get a single node level1/level2\n-         *\n-         * @param level1\n-         *          1st level node name\n-         * @param level2\n-         *          2nd level node name\n-         * @throws IOException\n-         */\n-        LedgerRange getLedgerRangeByLevel(final String level1, final String level2)\n-                throws IOException {\n-            StringBuilder nodeBuilder = new StringBuilder();\n-            nodeBuilder.append(ledgerRootPath).append(\"/\")\n-                       .append(level1).append(\"/\").append(level2);\n-            String nodePath = nodeBuilder.toString();\n-            List<String> ledgerNodes = null;\n-            try {\n-                ledgerNodes = ZkUtils.getChildrenInSingleNode(zk, nodePath);\n-            } catch (InterruptedException e) {\n-                throw new IOException(\"Error when get child nodes from zk\", e);\n-            }\n-            NavigableSet<Long> zkActiveLedgers = ledgerListToSet(ledgerNodes, nodePath);\n-            if (LOG.isDebugEnabled()) {\n-                LOG.debug(\"All active ledgers from ZK for hash node \"\n-                          + level1 + \"/\" + level2 + \" : \" + zkActiveLedgers);\n-            }\n-\n-            return new LedgerRange(zkActiveLedgers.subSet(getStartLedgerIdByLevel(level1, level2), true,\n-                                                          getEndLedgerIdByLevel(level1, level2), true));\n-        }\n     }\n }"},{"sha":"a74a6336445a50450bca033b3294974edc7e0381","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/HierarchicalLedgerManagerFactory.java","status":"modified","additions":7,"deletions":73,"changes":80,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/057af8dbce6c08794eb8b46ca52ca13f222d9bbb/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FHierarchicalLedgerManagerFactory.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/057af8dbce6c08794eb8b46ca52ca13f222d9bbb/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FHierarchicalLedgerManagerFactory.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FHierarchicalLedgerManagerFactory.java?ref=057af8dbce6c08794eb8b46ca52ca13f222d9bbb","patch":"@@ -1,5 +1,3 @@\n-package org.apache.bookkeeper.meta;\n-\n /**\n  * Licensed to the Apache Software Foundation (ASF) under one\n  * or more contributor license agreements.  See the NOTICE file\n@@ -17,89 +15,25 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n+package org.apache.bookkeeper.meta;\n \n-import java.io.IOException;\n import java.util.List;\n \n-import org.apache.zookeeper.KeeperException;\n-import org.apache.zookeeper.ZKUtil;\n-import org.apache.bookkeeper.replication.ReplicationException;\n-import org.apache.bookkeeper.conf.AbstractConfiguration;\n import org.apache.bookkeeper.util.ZkUtils;\n-import org.apache.zookeeper.ZooKeeper;\n import org.apache.zookeeper.data.ACL;\n \n /**\n- * Hierarchical Ledger Manager Factory\n+ * Legacy Hierarchical Ledger Manager Factory\n  */\n-public class HierarchicalLedgerManagerFactory extends LedgerManagerFactory {\n+public class HierarchicalLedgerManagerFactory extends LegacyHierarchicalLedgerManagerFactory {\n \n     public static final String NAME = \"hierarchical\";\n-    public static final int CUR_VERSION = 1;\n-\n-    AbstractConfiguration conf;\n-    ZooKeeper zk;\n-\n-    @Override\n-    public int getCurrentVersion() {\n-        return CUR_VERSION;\n-    }\n-\n-    @Override\n-    public LedgerManagerFactory initialize(final AbstractConfiguration conf,\n-                                           final ZooKeeper zk,\n-                                           final int factoryVersion)\n-    throws IOException {\n-        if (CUR_VERSION != factoryVersion) {\n-            throw new IOException(\"Incompatible layout version found : \"\n-                                + factoryVersion);\n-        }\n-        this.conf = conf;\n-        this.zk = zk;\n-        return this;\n-    }\n-\n-    @Override\n-    public void uninitialize() throws IOException {\n-        // since zookeeper instance is passed from outside\n-        // we don't need to close it here\n-    }\n-\n+    \n     @Override\n     public LedgerIdGenerator newLedgerIdGenerator() {\n         List<ACL> zkAcls = ZkUtils.getACLs(conf);\n-        return new ZkLedgerIdGenerator(zk, conf.getZkLedgersRootPath(), HierarchicalLedgerManager.IDGEN_ZNODE, zkAcls);\n-    }\n-\n-    @Override\n-    public LedgerManager newLedgerManager() {\n-        return new HierarchicalLedgerManager(conf, zk);\n-    }\n-\n-    @Override\n-    public LedgerUnderreplicationManager newLedgerUnderreplicationManager()\n-            throws KeeperException, InterruptedException, ReplicationException.CompatibilityException{\n-        return new ZkLedgerUnderreplicationManager(conf, zk);\n-    }\n-\n-    @Override\n-    public void format(AbstractConfiguration conf, ZooKeeper zk)\n-            throws InterruptedException, KeeperException, IOException {\n-        HierarchicalLedgerManager ledgerManager = (HierarchicalLedgerManager) newLedgerManager();\n-        try {\n-            String ledgersRootPath = conf.getZkLedgersRootPath();\n-            List<String> children = zk.getChildren(ledgersRootPath, false);\n-            for (String child : children) {\n-                if (ledgerManager.isSpecialZnode(child)) {\n-                    continue;\n-                }\n-                ZKUtil.deleteRecursive(zk, ledgersRootPath + \"/\" + child);\n-            }\n-        } finally {\n-            ledgerManager.close();\n-        }\n-        // Delete and recreate the LAYOUT information.\n-        super.format(conf, zk);\n+        ZkLedgerIdGenerator subIdGenerator = new ZkLedgerIdGenerator(zk, conf.getZkLedgersRootPath(), LegacyHierarchicalLedgerManager.IDGEN_ZNODE, zkAcls);\n+        return new LongZkLedgerIdGenerator(zk, conf.getZkLedgersRootPath(), LongHierarchicalLedgerManager.IDGEN_ZNODE, subIdGenerator, zkAcls);\n     }\n-\n+    \n }"},{"sha":"e7cfc4cf4e5fe013b15bfb7507372eb3033e34b4","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/LedgerManagerFactory.java","status":"modified","additions":4,"deletions":1,"changes":5,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/057af8dbce6c08794eb8b46ca52ca13f222d9bbb/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FLedgerManagerFactory.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/057af8dbce6c08794eb8b46ca52ca13f222d9bbb/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FLedgerManagerFactory.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FLedgerManagerFactory.java?ref=057af8dbce6c08794eb8b46ca52ca13f222d9bbb","patch":"@@ -164,7 +164,8 @@ public static LedgerManagerFactory newLedgerManagerFactory(\n \n         // handle V2 layout case\n         if (factoryClass != null &&\n-            !layout.getManagerFactoryClass().equals(factoryClass.getName())) {\n+            !layout.getManagerFactoryClass().equals(factoryClass.getName()) &&\n+            conf.getProperty(AbstractConfiguration.LEDGER_MANAGER_FACTORY_DISABLE_CLASS_CHECK) == null) { // Disable should ONLY happen during compatibility testing.\n \n             throw new IOException(\"Configured layout \" + factoryClass.getName()\n                                 + \" does not match existing layout \"  + layout.getManagerFactoryClass());\n@@ -210,6 +211,8 @@ private static LedgerManagerFactory createNewLMFactory(\n                     factoryClass = FlatLedgerManagerFactory.class;\n                 } else if (HierarchicalLedgerManagerFactory.NAME.equals(lmType)) {\n                     factoryClass = HierarchicalLedgerManagerFactory.class;\n+                } else if (LongHierarchicalLedgerManagerFactory.NAME.equals(lmType)) {\n+                    factoryClass = LongHierarchicalLedgerManagerFactory.class;\n                 } else {\n                     throw new IOException(\"Unknown ledger manager type: \"\n                             + lmType);"},{"sha":"8be23b2851bc7f529f463d90da4a48b83b208c87","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/LegacyHierarchicalLedgerManager.java","status":"added","additions":281,"deletions":0,"changes":281,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/057af8dbce6c08794eb8b46ca52ca13f222d9bbb/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FLegacyHierarchicalLedgerManager.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/057af8dbce6c08794eb8b46ca52ca13f222d9bbb/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FLegacyHierarchicalLedgerManager.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FLegacyHierarchicalLedgerManager.java?ref=057af8dbce6c08794eb8b46ca52ca13f222d9bbb","patch":"@@ -0,0 +1,281 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.bookkeeper.meta;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NavigableSet;\n+import java.util.NoSuchElementException;\n+import java.util.TreeSet;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.apache.bookkeeper.conf.AbstractConfiguration;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.Processor;\n+import org.apache.bookkeeper.util.StringUtils;\n+import org.apache.bookkeeper.util.ZkUtils;\n+import org.apache.zookeeper.AsyncCallback;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.KeeperException.Code;\n+import org.apache.zookeeper.ZooKeeper;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Hierarchical Ledger Manager which manages ledger meta in zookeeper using 2-level hierarchical znodes.\n+ *\n+ * <p>\n+ * LegacyHierarchicalLedgerManager splits the generated id into 3 parts (2-4-4):\n+ * <pre>&lt;level1 (2 digits)&gt;&lt;level2 (4 digits)&gt;&lt;level3 (4 digits)&gt;</pre>\n+ * These 3 parts are used to form the actual ledger node path used to store ledger metadata:\n+ * <pre>(ledgersRootPath)/level1/level2/L(level3)</pre>\n+ * E.g Ledger 0000000001 is split into 3 parts <i>00</i>, <i>0000</i>, <i>0001</i>, which is stored in\n+ * <i>(ledgersRootPath)/00/0000/L0001</i>. So each znode could have at most 10000 ledgers, which avoids\n+ * errors during garbage collection due to lists of children that are too long.\n+ */\n+class LegacyHierarchicalLedgerManager extends AbstractHierarchicalLedgerManager {\n+\n+    static final Logger LOG = LoggerFactory.getLogger(LegacyHierarchicalLedgerManager.class);\n+\n+    static final String IDGEN_ZNODE = \"idgen\";\n+    private static final String MAX_ID_SUFFIX = \"9999\";\n+    private static final String MIN_ID_SUFFIX = \"0000\";\n+\n+    private static final ThreadLocal<StringBuilder> threadLocalNodeBuilder = new ThreadLocal<StringBuilder>() {\n+        @Override\n+        protected StringBuilder initialValue() {\n+            return new StringBuilder();\n+        }\n+    };\n+    \n+    /**\n+     * Constructor\n+     *\n+     * @param conf\n+     *          Configuration object\n+     * @param zk\n+     *          ZooKeeper Client Handle\n+     */\n+    public LegacyHierarchicalLedgerManager(AbstractConfiguration conf, ZooKeeper zk) {\n+        super(conf, zk);\n+    }\n+\n+    @Override\n+    public String getLedgerPath(long ledgerId) {\n+        return ledgerRootPath + StringUtils.getShortHierarchicalLedgerPath(ledgerId);\n+    }\n+\n+    @Override\n+    public long getLedgerId(String pathName) throws IOException {\n+        if (!pathName.startsWith(ledgerRootPath)) {\n+            throw new IOException(\"it is not a valid hashed path name : \" + pathName);\n+        }\n+        String hierarchicalPath = pathName.substring(ledgerRootPath.length() + 1);\n+        return StringUtils.stringToHierarchicalLedgerId(hierarchicalPath);\n+    }\n+\n+    //\n+    // Active Ledger Manager\n+    //\n+\n+    /**\n+     * Get the smallest cache id in a specified node /level1/level2\n+     *\n+     * @param level1\n+     *          1st level node name\n+     * @param level2\n+     *          2nd level node name\n+     * @return the smallest ledger id\n+     */\n+    private long getStartLedgerIdByLevel(String level1, String level2) throws IOException {\n+        return getLedgerId(level1, level2, MIN_ID_SUFFIX);\n+    }\n+\n+    /**\n+     * Get the largest cache id in a specified node /level1/level2\n+     *\n+     * @param level1\n+     *          1st level node name\n+     * @param level2\n+     *          2nd level node name\n+     * @return the largest ledger id\n+     */\n+    private long getEndLedgerIdByLevel(String level1, String level2) throws IOException {\n+        return getLedgerId(level1, level2, MAX_ID_SUFFIX);\n+    }\n+\n+    @Override\n+    public void asyncProcessLedgers(final Processor<Long> processor,\n+                                    final AsyncCallback.VoidCallback finalCb, final Object context,\n+                                    final int successRc, final int failureRc) {\n+        // process 1st level nodes\n+        asyncProcessLevelNodes(ledgerRootPath, new Processor<String>() {\n+            @Override\n+            public void process(final String l1Node, final AsyncCallback.VoidCallback cb1) {\n+                if (isSpecialZnode(l1Node)) {\n+                    cb1.processResult(successRc, null, context);\n+                    return;\n+                }\n+                final String l1NodePath = ledgerRootPath + \"/\" + l1Node;\n+                // process level1 path, after all children of level1 process\n+                // it callback to continue processing next level1 node\n+                asyncProcessLevelNodes(l1NodePath, new Processor<String>() {\n+                    @Override\n+                    public void process(String l2Node, AsyncCallback.VoidCallback cb2) {\n+                        // process level1/level2 path\n+                        String l2NodePath = ledgerRootPath + \"/\" + l1Node + \"/\" + l2Node;\n+                        // process each ledger\n+                        // after all ledger are processed, cb2 will be call to continue processing next level2 node\n+                        asyncProcessLedgersInSingleNode(l2NodePath, processor, cb2,\n+                                                        context, successRc, failureRc);\n+                    }\n+                }, cb1, context, successRc, failureRc);\n+            }\n+        }, finalCb, context, successRc, failureRc);\n+    }\n+\n+    protected static boolean isSpecialZnode(String znode) {\n+        return IDGEN_ZNODE.equals(znode) || LongHierarchicalLedgerManager.IDGEN_ZNODE.equals(znode) || AbstractHierarchicalLedgerManager.isSpecialZnode(znode);\n+    }\n+\n+    @Override\n+    public LedgerRangeIterator getLedgerRanges() {\n+        return new HierarchicalLedgerRangeIterator();\n+    }\n+\n+    /**\n+     * Iterator through each metadata bucket with hierarchical mode\n+     */\n+    private class HierarchicalLedgerRangeIterator implements LedgerRangeIterator {\n+        private Iterator<String> l1NodesIter = null;\n+        private Iterator<String> l2NodesIter = null;\n+        private String curL1Nodes = \"\";\n+        private boolean iteratorDone = false;\n+        private LedgerRange nextRange = null;\n+\n+        /**\n+         * iterate next level1 znode\n+         *\n+         * @return false if have visited all level1 nodes\n+         * @throws InterruptedException/KeeperException if error occurs reading zookeeper children\n+         */\n+        private boolean nextL1Node() throws KeeperException, InterruptedException {\n+            l2NodesIter = null;\n+            while (l2NodesIter == null) {\n+                if (l1NodesIter.hasNext()) {\n+                    curL1Nodes = l1NodesIter.next();\n+                } else {\n+                    return false;\n+                }\n+                // Top level nodes are always exactly 2 digits long. (Don't pick up long hierarchical top level nodes)\n+                if (isSpecialZnode(curL1Nodes) || curL1Nodes.length() > 2) {\n+                    continue;\n+                }\n+                List<String> l2Nodes = zk.getChildren(ledgerRootPath + \"/\" + curL1Nodes, null);\n+                Collections.sort(l2Nodes);\n+                l2NodesIter = l2Nodes.iterator();\n+                if (!l2NodesIter.hasNext()) {\n+                    l2NodesIter = null;\n+                    continue;\n+                }\n+            }\n+            return true;\n+        }\n+\n+        synchronized private void preload() throws IOException {\n+            while (nextRange == null && !iteratorDone) {\n+                boolean hasMoreElements = false;\n+                try {\n+                    if (l1NodesIter == null) {\n+                        List<String> l1Nodes = zk.getChildren(ledgerRootPath, null);\n+                        Collections.sort(l1Nodes);\n+                        l1NodesIter = l1Nodes.iterator();\n+                        hasMoreElements = nextL1Node();\n+                    } else if (l2NodesIter == null || !l2NodesIter.hasNext()) {\n+                        hasMoreElements = nextL1Node();\n+                    } else {\n+                        hasMoreElements = true;\n+                    }\n+                } catch (KeeperException ke) {\n+                    throw new IOException(\"Error preloading next range\", ke);\n+                } catch (InterruptedException ie) {\n+                    Thread.currentThread().interrupt();\n+                    throw new IOException(\"Interrupted while preloading\", ie);\n+                }\n+                if (hasMoreElements) {\n+                    nextRange = getLedgerRangeByLevel(curL1Nodes, l2NodesIter.next());\n+                    if (nextRange.size() == 0) {\n+                        nextRange = null;\n+                    }\n+                } else {\n+                    iteratorDone = true;\n+                }\n+            }\n+        }\n+\n+        @Override\n+        synchronized public boolean hasNext() throws IOException {\n+            preload();\n+            return nextRange != null && !iteratorDone;\n+        }\n+\n+        @Override\n+        synchronized public LedgerRange next() throws IOException {\n+            if (!hasNext()) {\n+                throw new NoSuchElementException();\n+            }\n+            LedgerRange r = nextRange;\n+            nextRange = null;\n+            return r;\n+        }\n+\n+        /**\n+         * Get a single node level1/level2\n+         *\n+         * @param level1\n+         *          1st level node name\n+         * @param level2\n+         *          2nd level node name\n+         * @throws IOException\n+         */\n+        LedgerRange getLedgerRangeByLevel(final String level1, final String level2)\n+                throws IOException {\n+            StringBuilder nodeBuilder = threadLocalNodeBuilder.get();\n+            nodeBuilder.setLength(0);\n+            nodeBuilder.append(ledgerRootPath).append(\"/\")\n+                       .append(level1).append(\"/\").append(level2);\n+            String nodePath = nodeBuilder.toString();\n+            List<String> ledgerNodes = null;\n+            try {\n+                ledgerNodes = ZkUtils.getChildrenInSingleNode(zk, nodePath);\n+            } catch (InterruptedException e) {\n+                throw new IOException(\"Error when get child nodes from zk\", e);\n+            }\n+            NavigableSet<Long> zkActiveLedgers = ledgerListToSet(ledgerNodes, nodePath);\n+            if (LOG.isDebugEnabled()) {\n+                LOG.debug(\"All active ledgers from ZK for hash node \"\n+                          + level1 + \"/\" + level2 + \" : \" + zkActiveLedgers);\n+            }\n+\n+            return new LedgerRange(zkActiveLedgers.subSet(getStartLedgerIdByLevel(level1, level2), true,\n+                                                          getEndLedgerIdByLevel(level1, level2), true));\n+        }\n+    }\n+}"},{"sha":"1ac403823f0efe652e83f1e16c29b4197b9957e9","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/LegacyHierarchicalLedgerManagerFactory.java","status":"added","additions":100,"deletions":0,"changes":100,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/057af8dbce6c08794eb8b46ca52ca13f222d9bbb/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FLegacyHierarchicalLedgerManagerFactory.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/057af8dbce6c08794eb8b46ca52ca13f222d9bbb/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FLegacyHierarchicalLedgerManagerFactory.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FLegacyHierarchicalLedgerManagerFactory.java?ref=057af8dbce6c08794eb8b46ca52ca13f222d9bbb","patch":"@@ -0,0 +1,100 @@\n+package org.apache.bookkeeper.meta;\n+\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.util.List;\n+\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.ZKUtil;\n+import org.apache.bookkeeper.replication.ReplicationException;\n+import org.apache.bookkeeper.util.ZkUtils;\n+import org.apache.bookkeeper.conf.AbstractConfiguration;\n+import org.apache.zookeeper.ZooKeeper;\n+import org.apache.zookeeper.data.ACL;\n+\n+/**\n+ * Hierarchical Ledger Manager Factory\n+ */\n+public class LegacyHierarchicalLedgerManagerFactory extends LedgerManagerFactory {\n+\n+    public static final String NAME = \"legacyhierarchical\";\n+    public static final int CUR_VERSION = 1;\n+\n+    AbstractConfiguration conf;\n+    ZooKeeper zk;\n+\n+    @Override\n+    public int getCurrentVersion() {\n+        return CUR_VERSION;\n+    }\n+\n+    @Override\n+    public LedgerManagerFactory initialize(final AbstractConfiguration conf,\n+                                           final ZooKeeper zk,\n+                                           final int factoryVersion)\n+    throws IOException {\n+        if (CUR_VERSION != factoryVersion) {\n+            throw new IOException(\"Incompatible layout version found : \"\n+                                + factoryVersion);\n+        }\n+        this.conf = conf;\n+        this.zk = zk;\n+        return this;\n+    }\n+\n+    @Override\n+    public void uninitialize() throws IOException {\n+        // since zookeeper instance is passed from outside\n+        // we don't need to close it here\n+    }\n+\n+    @Override\n+    public LedgerIdGenerator newLedgerIdGenerator() {\n+        List<ACL> zkAcls = ZkUtils.getACLs(conf);\n+        return new ZkLedgerIdGenerator(zk, conf.getZkLedgersRootPath(), LegacyHierarchicalLedgerManager.IDGEN_ZNODE, zkAcls);\n+    }\n+\n+    @Override\n+    public LedgerManager newLedgerManager() {\n+        return new HierarchicalLedgerManager(conf, zk);\n+    }\n+\n+    @Override\n+    public LedgerUnderreplicationManager newLedgerUnderreplicationManager()\n+            throws KeeperException, InterruptedException, ReplicationException.CompatibilityException{\n+        return new ZkLedgerUnderreplicationManager(conf, zk);\n+    }\n+\n+    @Override\n+    public void format(AbstractConfiguration conf, ZooKeeper zk)\n+            throws InterruptedException, KeeperException, IOException {\n+        String ledgersRootPath = conf.getZkLedgersRootPath();\n+        List<String> children = zk.getChildren(ledgersRootPath, false);\n+        for (String child : children) {\n+            if (HierarchicalLedgerManager.isSpecialZnode(child)) {\n+                continue;\n+            }\n+            ZKUtil.deleteRecursive(zk, ledgersRootPath + \"/\" + child);\n+        }\n+        // Delete and recreate the LAYOUT information.\n+        super.format(conf, zk);\n+    }\n+\n+}"},{"sha":"f8f7546c85f543b1c3a8f2a95e5ffb76c0d872c0","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/LongHierarchicalLedgerManager.java","status":"modified","additions":63,"deletions":38,"changes":101,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/057af8dbce6c08794eb8b46ca52ca13f222d9bbb/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FLongHierarchicalLedgerManager.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/057af8dbce6c08794eb8b46ca52ca13f222d9bbb/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FLongHierarchicalLedgerManager.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FLongHierarchicalLedgerManager.java?ref=057af8dbce6c08794eb8b46ca52ca13f222d9bbb","patch":"@@ -24,6 +24,7 @@\n import java.util.List;\n import java.util.NavigableSet;\n import java.util.NoSuchElementException;\n+import java.util.TreeSet;\n \n import org.apache.bookkeeper.conf.AbstractConfiguration;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.Processor;\n@@ -37,33 +38,36 @@\n import org.slf4j.LoggerFactory;\n \n /**\n- * LongHierarchical Ledger Manager which manages ledger meta in zookeeper using 4-level hierarchical znodes.\n+ * LongHierarchical Ledger Manager which manages ledger meta in zookeeper using 5-level hierarchical znodes.\n  *\n  * <p>\n  * LongHierarchicalLedgerManager splits the generated id into 5 parts (3-4-4-4-4):\n  *\n  * <pre>\n- * &lt;level1 (3 digits)&gt;&lt;level2 (4 digits)&gt;&lt;level3 (4 digits)&gt;&lt;level4 (4 digits)&gt;\n- * &lt;level5 (4 digits)&gt;\n+ * &lt;level0 (3 digits)&gt;&lt;level1 (4 digits)&gt;&lt;level2 (4 digits)&gt;&lt;level3 (4 digits)&gt;\n+ * &lt;level4 (4 digits)&gt;\n  * </pre>\n  *\n  * These 5 parts are used to form the actual ledger node path used to store ledger metadata:\n  *\n  * <pre>\n- * (ledgersRootPath) / level1 / level2 / level3 / level4 / L(level5)\n+ * (ledgersRootPath) / level0 / level1 / level2 / level3 / L(level4)\n  * </pre>\n  *\n  * E.g Ledger 0000000000000000001 is split into 5 parts <i>000</i>, <i>0000</i>, <i>0000</i>, <i>0000</i>, <i>0001</i>,\n  * which is stored in <i>(ledgersRootPath)/000/0000/0000/0000/L0001</i>. So each znode could have at most 10000 ledgers,\n  * which avoids errors during garbage collection due to lists of children that are too long.\n+ *\n  */\n-class LongHierarchicalLedgerManager extends HierarchicalLedgerManager {\n+class LongHierarchicalLedgerManager extends AbstractHierarchicalLedgerManager {\n \n     static final Logger LOG = LoggerFactory.getLogger(LongHierarchicalLedgerManager.class);\n \n+    static final String IDGEN_ZNODE = \"idgen-long\";\n     private static final String MAX_ID_SUFFIX = \"9999\";\n     private static final String MIN_ID_SUFFIX = \"0000\";\n \n+\n     /**\n      * Constructor\n      *\n@@ -76,11 +80,6 @@ public LongHierarchicalLedgerManager(AbstractConfiguration conf, ZooKeeper zk) {\n         super(conf, zk);\n     }\n \n-    @Override\n-    public String getLedgerPath(long ledgerId) {\n-        return ledgerRootPath + StringUtils.getLongHierarchicalLedgerPath(ledgerId);\n-    }\n-\n     @Override\n     public long getLedgerId(String pathName) throws IOException {\n         if (!pathName.startsWith(ledgerRootPath)) {\n@@ -89,54 +88,68 @@ public long getLedgerId(String pathName) throws IOException {\n         String hierarchicalPath = pathName.substring(ledgerRootPath.length() + 1);\n         return StringUtils.stringToLongHierarchicalLedgerId(hierarchicalPath);\n     }\n+    \n+    @Override\n+    public String getLedgerPath(long ledgerId) {\n+        return ledgerRootPath + StringUtils.getLongHierarchicalLedgerPath(ledgerId);\n+    }\n \n     //\n     // Active Ledger Manager\n     //\n \n     /**\n-     * Get the smallest cache id in a specified node /level1/level2/level3/level4\n+     * Get the smallest cache id in a specified node /level0/level1/level2/level3\n      *\n-     * @param level1\n+     * @param level0\n      *            1st level node name\n-     * @param level2\n+     * @param level1\n      *            2nd level node name\n-     * @param level3\n+     * @param level2\n      *            3rd level node name\n-     * @param level4\n+     * @param level3\n      *            4th level node name\n      * @return the smallest ledger id\n      */\n-    private long getStartLedgerIdByLevel(String level1, String level2, String level3, String level4)\n+    private long getStartLedgerIdByLevel(String level0, String level1, String level2, String level3)\n             throws IOException {\n-        return getLedgerId(level1, level2, level3, level4, MIN_ID_SUFFIX);\n+        return getLedgerId(level0, level1, level2, level3, MIN_ID_SUFFIX);\n     }\n \n     /**\n-     * Get the largest cache id in a specified node /level1/level2/level3/level4\n+     * Get the largest cache id in a specified node /level0/level1/level2/level3\n      *\n-     * @param level1\n+     * @param level0\n      *            1st level node name\n-     * @param level2\n+     * @param level1\n      *            2nd level node name\n-     * @param level3\n+     * @param level2\n      *            3rd level node name\n-     * @param level4\n+     * @param level3\n      *            4th level node name\n      * @return the largest ledger id\n      */\n-    private long getEndLedgerIdByLevel(String level1, String level2, String level3, String level4) throws IOException {\n-        return getLedgerId(level1, level2, level3, level4, MAX_ID_SUFFIX);\n+    private long getEndLedgerIdByLevel(String level0, String level1, String level2, String level3) throws IOException {\n+        return getLedgerId(level0, level1, level2, level3, MAX_ID_SUFFIX);\n     }\n \n     @Override\n     public void asyncProcessLedgers(final Processor<Long> processor, final AsyncCallback.VoidCallback finalCb,\n             final Object context, final int successRc, final int failureRc) {\n+\n+        // If it succeeds, proceed with our own recursive ledger processing for the 63-bit id ledgers\n         asyncProcessLevelNodes(ledgerRootPath,\n                 new RecursiveProcessor(0, ledgerRootPath, processor, context, successRc, failureRc), finalCb, context,\n                 successRc, failureRc);\n     }\n \n+    protected static boolean isSpecialZnode(String znode) {\n+        // Check nextnode length. All paths in long hierarchical format (3-4-4-4-4)\n+        // are at least 3 characters long. This prevents picking up any old-style\n+        // hierarchical paths (2-4-4)\n+        return LegacyHierarchicalLedgerManager.isSpecialZnode(znode) || znode.length() < 3;\n+    }\n+    \n     private class RecursiveProcessor implements Processor<String> {\n         private final int level;\n         private final String path;\n@@ -167,7 +180,7 @@ public void process(String lNode, VoidCallback cb) {\n                         context, successRc, failureRc);\n             } else {\n                 // process each ledger after all ledger are processed, cb will be call to continue processing next\n-                // level5 node\n+                // level4 node\n                 asyncProcessLedgersInSingleNode(nodePath, processor, cb, context, successRc, failureRc);\n             }\n         }\n@@ -194,7 +207,7 @@ private LongHierarchicalLedgerRangeIterator() {\n             curLevelNodes = new ArrayList<String>(Collections.nCopies(4, (String) null));\n         }\n \n-        private void initialize(String path, int level) throws KeeperException, InterruptedException, IOException {\n+        synchronized private void initialize(String path, int level) throws KeeperException, InterruptedException, IOException {\n             List<String> levelNodes = zk.getChildren(path, null);\n             Collections.sort(levelNodes);\n             if (level == 0) {\n@@ -217,6 +230,9 @@ private void initialize(String path, int level) throws KeeperException, Interrup\n             }\n             String curLNode = curLevelNodes.get(level);\n             if (curLNode != null) {\n+                // Traverse down through levels 0-3\n+                // The nextRange becomes a listing of the children\n+                // in the level4 directory.\n                 if (level != 3) {\n                     String nextLevelPath = path + \"/\" + curLNode;\n                     initialize(nextLevelPath, level + 1);\n@@ -229,7 +245,13 @@ private void initialize(String path, int level) throws KeeperException, Interrup\n             }\n         }\n \n-        private boolean moveToNext(int level) throws KeeperException, InterruptedException {\n+        private void clearHigherLevels(int level) {\n+            for(int i = level+1; i < 4; i++) {\n+                curLevelNodes.set(i, null);\n+            }\n+        }\n+\n+        synchronized private boolean moveToNext(int level) throws KeeperException, InterruptedException {\n             Iterator<String> curLevelNodesIter = levelNodesIter.get(level);\n             boolean movedToNextNode = false;\n             if (level == 0) {\n@@ -239,6 +261,7 @@ private boolean moveToNext(int level) throws KeeperException, InterruptedExcepti\n                         continue;\n                     } else {\n                         curLevelNodes.set(level, nextNode);\n+                        clearHigherLevels(level);\n                         movedToNextNode = true;\n                         break;\n                     }\n@@ -247,6 +270,7 @@ private boolean moveToNext(int level) throws KeeperException, InterruptedExcepti\n                 if (curLevelNodesIter.hasNext()) {\n                     String nextNode = curLevelNodesIter.next();\n                     curLevelNodes.set(level, nextNode);\n+                    clearHigherLevels(level);\n                     movedToNextNode = true;\n                 } else {\n                     movedToNextNode = moveToNext(level - 1);\n@@ -261,6 +285,7 @@ private boolean moveToNext(int level) throws KeeperException, InterruptedExcepti\n                         levelNodesIter.set(level, newCurLevelNodesIter);\n                         if (newCurLevelNodesIter.hasNext()) {\n                             curLevelNodes.set(level, newCurLevelNodesIter.next());\n+                            clearHigherLevels(level);\n                             movedToNextNode = true;\n                         }\n                     }\n@@ -306,15 +331,15 @@ synchronized public LedgerRange next() throws IOException {\n             return r;\n         }\n \n-        LedgerRange getLedgerRangeByLevel(List<String> curLevelNodes) throws IOException {\n-            String level1 = curLevelNodes.get(0);\n-            String level2 = curLevelNodes.get(1);\n-            String level3 = curLevelNodes.get(2);\n-            String level4 = curLevelNodes.get(3);\n+        private LedgerRange getLedgerRangeByLevel(List<String> curLevelNodes) throws IOException {\n+            String level0 = curLevelNodes.get(0);\n+            String level1 = curLevelNodes.get(1);\n+            String level2 = curLevelNodes.get(2);\n+            String level3 = curLevelNodes.get(3);\n \n             StringBuilder nodeBuilder = new StringBuilder();\n-            nodeBuilder.append(ledgerRootPath).append(\"/\").append(level1).append(\"/\").append(level2).append(\"/\")\n-                    .append(level3).append(\"/\").append(level4);\n+            nodeBuilder.append(ledgerRootPath).append(\"/\").append(level0).append(\"/\").append(level1).append(\"/\")\n+                    .append(level2).append(\"/\").append(level3);\n             String nodePath = nodeBuilder.toString();\n             List<String> ledgerNodes = null;\n             try {\n@@ -324,11 +349,11 @@ LedgerRange getLedgerRangeByLevel(List<String> curLevelNodes) throws IOException\n             }\n             NavigableSet<Long> zkActiveLedgers = ledgerListToSet(ledgerNodes, nodePath);\n             if (LOG.isDebugEnabled()) {\n-                LOG.debug(\"All active ledgers from ZK for hash node \" + level1 + \"/\" + level2 + \"/\" + level3 + \"/\"\n-                        + level4 + \" : \" + zkActiveLedgers);\n+                LOG.debug(\"All active ledgers from ZK for hash node \" + level0 + \"/\" + level1 + \"/\" + level2 + \"/\"\n+                        + level3 + \" : \" + zkActiveLedgers);\n             }\n-            return new LedgerRange(zkActiveLedgers.subSet(getStartLedgerIdByLevel(level1, level2, level3, level4), true,\n-                    getEndLedgerIdByLevel(level1, level2, level3, level4), true));\n+            return new LedgerRange(zkActiveLedgers.subSet(getStartLedgerIdByLevel(level0, level1, level2, level3), true,\n+                    getEndLedgerIdByLevel(level0, level1, level2, level3), true));\n         }\n     }\n }"},{"sha":"393f9b1855ddb1cbfb98e0c833ef3ae123e9932d","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/LongZkLedgerIdGenerator.java","status":"added","additions":333,"deletions":0,"changes":333,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/057af8dbce6c08794eb8b46ca52ca13f222d9bbb/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FLongZkLedgerIdGenerator.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/057af8dbce6c08794eb8b46ca52ca13f222d9bbb/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FLongZkLedgerIdGenerator.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FLongZkLedgerIdGenerator.java?ref=057af8dbce6c08794eb8b46ca52ca13f222d9bbb","patch":"@@ -0,0 +1,333 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.bookkeeper.meta;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Formatter;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Optional;\n+\n+import org.apache.bookkeeper.client.BKException;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n+import org.apache.bookkeeper.util.ZkUtils;\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.ZooKeeper;\n+import org.apache.zookeeper.AsyncCallback.StringCallback;\n+import org.apache.zookeeper.ZooDefs.Ids;\n+import org.apache.zookeeper.data.ACL;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * ZooKeeper based ledger id generator class, which using EPHEMERAL_SEQUENTIAL\n+ * with <i>(ledgerIdGenPath)/HOB-[high-32-bits]/ID-</i> prefix to generate ledger id. Note\n+ * zookeeper sequential counter has a format of %10d -- that is 10 digits with 0\n+ * (zero) padding, i.e. \"&lt;path&gt;0000000001\", so ledger id space would be\n+ * fundamentally limited to 9 billion. In practice, the id generated by zookeeper\n+ * is only 31 bits (signed 32-bit integer), so the limit is much lower than 9 billion.\n+ *\n+ * In order to support the full range of the long ledgerId, once ledgerIds reach Integer.MAX_INT,\n+ * a new system is employed. The 32 most significant bits of the ledger ID are taken and turned into\n+ * a directory prefixed with <i>HOB-</i> under <i>(ledgerIdGenPath)</i>\n+ *\n+ * Under this <i>HOB-</i> directory, zookeeper is used to continue generating EPHEMERAL_SEQUENTIAL ids\n+ * which constitute the lower 32-bits of the ledgerId (sign bit is always 0). Once the <i>HOB-</i> directory runs out of available\n+ * ids, the process is repeated. The higher bits are incremented, a new <i>HOB-</i> directory is created, and\n+ * zookeeper generates sequential ids underneath it.\n+ *\n+ * The reason for treating ids which are less than Integer.MAX_INT differently is to maintain backwards\n+ * compatibility. This is a drop-in replacement for ZkLedgerIdGenerator.\n+ */\n+public class LongZkLedgerIdGenerator implements LedgerIdGenerator {\n+    private static final Logger LOG = LoggerFactory.getLogger(LongZkLedgerIdGenerator.class);\n+    private ZooKeeper zk;\n+    private String ledgerIdGenPath;\n+    private ZkLedgerIdGenerator shortIdGen;\n+    private List<String> highOrderDirectories;\n+    private HighOrderLedgerIdGenPathStatus ledgerIdGenPathStatus;\n+    private final List<ACL> zkAcls;\n+\n+    private enum HighOrderLedgerIdGenPathStatus {\n+        UNKNOWN,\n+        PRESENT,\n+        NOT_PRESENT\n+    };\n+\n+    public LongZkLedgerIdGenerator(ZooKeeper zk, String ledgersPath, String idGenZnodeName, ZkLedgerIdGenerator shortIdGen, List<ACL> zkAcls) {\n+        this.zk = zk;\n+        if (StringUtils.isBlank(idGenZnodeName)) {\n+            this.ledgerIdGenPath = ledgersPath;\n+        } else {\n+            this.ledgerIdGenPath = ledgersPath + \"/\" + idGenZnodeName;\n+        }\n+        this.shortIdGen = shortIdGen;\n+        highOrderDirectories = new ArrayList<String>();\n+        ledgerIdGenPathStatus = HighOrderLedgerIdGenPathStatus.UNKNOWN;\n+        this.zkAcls = zkAcls; \n+    }\n+\n+    private void generateLongLedgerIdLowBits(final String ledgerPrefix, long highBits, final GenericCallback<Long> cb) throws KeeperException, InterruptedException, IOException {\n+        String highPath = ledgerPrefix + formatHalfId((int)highBits);\n+        ZkLedgerIdGenerator.generateLedgerIdImpl(new GenericCallback<Long>(){\n+            @Override\n+            public void operationComplete(int rc, Long result) {\n+                if(rc == BKException.Code.OK) {\n+                    assert((highBits & 0xFFFFFFFF00000000l) == 0);\n+                    assert((result & 0xFFFFFFFF00000000l) == 0);\n+                    cb.operationComplete(rc, (highBits << 32) | result);\n+                }\n+                else if(rc == BKException.Code.LedgerIdOverflowException) {\n+                    // Lower bits are full. Need to expand and create another HOB node.\n+                    try {\n+                        Long newHighBits = highBits + 1;\n+                        createHOBPathAndGenerateId(ledgerPrefix, newHighBits.intValue(), cb);\n+                    }\n+                    catch (KeeperException e) {\n+                        LOG.error(\"Failed to create long ledger ID path\", e);\n+                        cb.operationComplete(BKException.Code.ZKException, null);\n+                    }\n+                    catch (InterruptedException e) {\n+                        LOG.error(\"Failed to create long ledger ID path\", e);\n+                        cb.operationComplete(BKException.Code.InterruptedException, null);\n+                    } catch (IOException e) {\n+                        LOG.error(\"Failed to create long ledger ID path\", e);\n+                        cb.operationComplete(BKException.Code.IllegalOpException, null);\n+                    }\n+\n+                }\n+            }\n+\n+        }, zk, ZkLedgerIdGenerator.createLedgerPrefix(highPath, null), zkAcls);\n+    }\n+\n+    /**\n+     * Formats half an ID as 10-character 0-padded string\n+     * @param i - 32 bits of the ID to format\n+     * @return a 10-character 0-padded string.\n+     */\n+    private String formatHalfId(int i) {\n+        return String.format(\"%010d\", i);\n+    }\n+\n+    private void createHOBPathAndGenerateId(String ledgerPrefix, int hob, final GenericCallback<Long> cb) throws KeeperException, InterruptedException, IOException {\n+        try {\n+            LOG.debug(\"Creating HOB path: {}\", ledgerPrefix + formatHalfId(hob));\n+            zk.create(ledgerPrefix + formatHalfId(hob), new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n+        }\n+        catch(KeeperException.NodeExistsException e) {\n+            // It's fine if we lost a race to create the node (NodeExistsException).\n+            // All other exceptions should continue unwinding.\n+            LOG.debug(\"Tried to create High-order-bits node, but it already existed!\", e);\n+        }\n+        // We just created a new HOB directory. Invalidate the directory cache\n+        invalidateDirectoryCache();\n+        generateLongLedgerId(cb); // Try again.\n+    }\n+\n+    private void invalidateDirectoryCache() {\n+        highOrderDirectories = null;\n+    }\n+\n+    private void generateLongLedgerId(final GenericCallback<Long> cb) throws KeeperException, InterruptedException, IOException {\n+        final String hobPrefix = \"HOB-\";\n+        final String ledgerPrefix = this.ledgerIdGenPath + \"/\" + hobPrefix;\n+\n+        // Only pull the directories from zk if we don't have any cached.\n+        boolean refreshedDirectories = false;\n+        if(highOrderDirectories == null) {\n+            refreshedDirectories = true;\n+            highOrderDirectories = zk.getChildren(ledgerIdGenPath, false);\n+        }\n+\n+        Optional<Long> largest = highOrderDirectories.stream()\n+            .map((t) -> {\n+                    try {\n+                        return Long.parseLong(t.replace(hobPrefix, \"\"));\n+                    }\n+                    catch(NumberFormatException e) {\n+                        return null;\n+                    }\n+                })\n+            .filter((t) -> t != null)\n+            .reduce(Math::max);\n+\n+        // If we didn't get any valid IDs from the directory...\n+        if(!largest.isPresent()) {\n+            if(!refreshedDirectories) {\n+                // Our cache might be bad. Invalidate it and retry.\n+                invalidateDirectoryCache();\n+                generateLongLedgerId(cb); // Try again\n+            }\n+            else {\n+                // else, Start at HOB-0000000001;\n+                createHOBPathAndGenerateId(ledgerPrefix, 1, cb);\n+            }\n+            return;\n+        }\n+\n+        // Found the largest.\n+        // Get the low-order bits.\n+        final Long highBits = largest.get();\n+        generateLongLedgerIdLowBits(ledgerPrefix, highBits, cb);\n+\n+        // Perform garbage collection on HOB- directories.\n+        // Keeping 3 should be plenty to prevent races\n+        if(highOrderDirectories.size() > 3) {\n+            Object[] highOrderDirs = highOrderDirectories.stream()\n+                    .map((t) -> {\n+                            try {\n+                                return Long.parseLong(t.replace(hobPrefix, \"\"));\n+                            }\n+                            catch(NumberFormatException e) {\n+                                return null;\n+                            }\n+                        })\n+                    .filter((t) -> t != null)\n+                    .sorted()\n+                    .toArray();\n+\n+            // Go ahead and invalidate. We want to reload cache even if we fail.\n+            invalidateDirectoryCache();\n+\n+            for(int i = 0; i < highOrderDirs.length - 3; i++) {\n+                String path = ledgerPrefix + formatHalfId(((Long)highOrderDirs[i]).intValue());\n+                LOG.debug(\"DELETING HIGH ORDER DIR: {}\", path);\n+                try {\n+                    zk.delete(path, 0);\n+                }\n+                catch (KeeperException e) {\n+                    // We don't care if we fail. Just warn about it.\n+                    LOG.debug(\"Failed to delete {}\", path);\n+                }\n+            }\n+        }\n+    }\n+\n+    private void createLongLedgerIdPathAndGenerateLongLedgerId(final GenericCallback<Long> cb, String createPath) {\n+        ZkUtils.asyncCreateFullPathOptimistic(zk, ledgerIdGenPath, new byte[0], Ids.OPEN_ACL_UNSAFE,\n+                                              CreateMode.PERSISTENT, new StringCallback() {\n+                                                      @Override\n+                                                      public void processResult(int rc, String path, Object ctx, String name) {\n+                                                          try {\n+                                                              setLedgerIdGenPathStatus(HighOrderLedgerIdGenPathStatus.PRESENT);\n+                                                              generateLongLedgerId(cb);\n+                                                          } catch (KeeperException e) {\n+                                                              LOG.error(\"Failed to create long ledger ID path\", e);\n+                                                              setLedgerIdGenPathStatus(HighOrderLedgerIdGenPathStatus.UNKNOWN);\n+                                                              cb.operationComplete(BKException.Code.ZKException, null);\n+                                                          } catch (InterruptedException e) {\n+                                                              LOG.error(\"Failed to create long ledger ID path\", e);\n+                                                              setLedgerIdGenPathStatus(HighOrderLedgerIdGenPathStatus.UNKNOWN);\n+                                                              cb.operationComplete(BKException.Code.InterruptedException, null);\n+                                                          } catch (IOException e) {\n+                                                              LOG.error(\"Failed to create long ledger ID path\", e);\n+                                                              setLedgerIdGenPathStatus(HighOrderLedgerIdGenPathStatus.UNKNOWN);\n+                                                              cb.operationComplete(BKException.Code.IllegalOpException, null);\n+                                                          }\n+                                                      }\n+                                                  }, null);\n+    }\n+\n+    public void invalidateLedgerIdGenPathStatus() {\n+        setLedgerIdGenPathStatus(HighOrderLedgerIdGenPathStatus.UNKNOWN);\n+    }\n+\n+    synchronized private void setLedgerIdGenPathStatus(HighOrderLedgerIdGenPathStatus status) {\n+        ledgerIdGenPathStatus = status;\n+    }\n+\n+    /**\n+     * Checks the existence of the long ledger id gen path. Existence indicates we have switched from the legacy\n+     * algorithm to the new method of generating 63-bit ids. If the existence is UNKNOWN, it looks in zk to\n+     * find out. If it previously checked in zk, it returns that value. This value changes when we run out\n+     * of ids < Integer.MAX_VALUE, and try to create the long ledger id gen path.\n+     * @see createLongLedgerIdPathAndGenerateLongLedgerId\n+     * @param zk\n+     * @return Does the long ledger id gen path exist?\n+     * @throws KeeperException\n+     * @throws InterruptedException\n+     */\n+    synchronized public boolean ledgerIdGenPathPresent(ZooKeeper zk) throws KeeperException, InterruptedException {\n+        switch(ledgerIdGenPathStatus) {\n+        case UNKNOWN:\n+            if(zk.exists(ledgerIdGenPath, false) != null) {\n+                ledgerIdGenPathStatus = HighOrderLedgerIdGenPathStatus.PRESENT;\n+                return true;\n+            }\n+            else {\n+                ledgerIdGenPathStatus = HighOrderLedgerIdGenPathStatus.NOT_PRESENT;\n+                return false;\n+            }\n+        case PRESENT:\n+            return true;\n+        case NOT_PRESENT:\n+            return false;\n+        default:\n+            return false;\n+        }\n+    }\n+\n+    @Override\n+    public void generateLedgerId(final GenericCallback<Long> cb) {\n+        try {\n+            if(!ledgerIdGenPathPresent(zk)) {\n+                // We've not moved onto 63-bit ledgers yet.\n+                shortIdGen.generateLedgerId(new GenericCallback<Long>(){\n+                        @Override\n+                        public void operationComplete(int rc, Long result) {\n+                            if(rc == BKException.Code.LedgerIdOverflowException) {\n+                                // 31-bit IDs overflowed. Start using 63-bit ids.\n+                                createLongLedgerIdPathAndGenerateLongLedgerId(cb, ledgerIdGenPath);\n+                            }\n+                            else {\n+                                // 31-bit Generation worked OK, or had some other\n+                                // error that we will pass on.\n+                                cb.operationComplete(rc, result);\n+                            }\n+                        }\n+                    });\n+            }\n+            else {\n+                // We've already started generating 63-bit ledger IDs.\n+                // Keep doing that.\n+                generateLongLedgerId(cb);\n+            }\n+        } catch (KeeperException e) {\n+            LOG.error(\"Failed to create long ledger ID path\", e);\n+            cb.operationComplete(BKException.Code.ZKException, null);\n+        }\n+        catch (InterruptedException e) {\n+            LOG.error(\"Failed to create long ledger ID path\", e);\n+            cb.operationComplete(BKException.Code.InterruptedException, null);\n+        }\n+        catch (IOException e) {\n+            LOG.error(\"Failed to create long ledger ID path\", e);\n+            cb.operationComplete(BKException.Code.IllegalOpException, null);\n+        }\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        shortIdGen.close();\n+    }\n+\n+}"},{"sha":"1373f348c5854a46a9fa5c8431928b1242b7347a","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/ZkLedgerIdGenerator.java","status":"modified","additions":20,"deletions":7,"changes":27,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/057af8dbce6c08794eb8b46ca52ca13f222d9bbb/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FZkLedgerIdGenerator.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/057af8dbce6c08794eb8b46ca52ca13f222d9bbb/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FZkLedgerIdGenerator.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FZkLedgerIdGenerator.java?ref=057af8dbce6c08794eb8b46ca52ca13f222d9bbb","patch":"@@ -47,7 +47,6 @@ public class ZkLedgerIdGenerator implements LedgerIdGenerator {\n     static final String LEDGER_ID_GEN_PREFIX = \"ID-\";\n \n     final ZooKeeper zk;\n-    final String ledgerIdGenPath;\n     final String ledgerPrefix;\n     final List<ACL> zkAcls;\n \n@@ -56,17 +55,26 @@ public ZkLedgerIdGenerator(ZooKeeper zk,\n                                String idGenZnodeName,\n                                List<ACL> zkAcls) {\n         this.zk = zk;\n+        ledgerPrefix = createLedgerPrefix(ledgersPath, idGenZnodeName);\n         this.zkAcls = zkAcls;\n+    }\n+\n+    public static String createLedgerPrefix(String ledgersPath, String idGenZnodeName) {\n+        String ledgerIdGenPath = null;\n         if (StringUtils.isBlank(idGenZnodeName)) {\n-            this.ledgerIdGenPath = ledgersPath;\n+            ledgerIdGenPath = ledgersPath;\n         } else {\n-            this.ledgerIdGenPath = ledgersPath + \"/\" + idGenZnodeName;\n+            ledgerIdGenPath = ledgersPath + \"/\" + idGenZnodeName;\n         }\n-        this.ledgerPrefix = this.ledgerIdGenPath + \"/\" + LEDGER_ID_GEN_PREFIX;\n+        return ledgerIdGenPath + \"/\" + LEDGER_ID_GEN_PREFIX;\n     }\n \n     @Override\n     public void generateLedgerId(final GenericCallback<Long> cb) {\n+        generateLedgerIdImpl(cb, zk, ledgerPrefix, zkAcls);\n+    }\n+\n+    public static void generateLedgerIdImpl(final GenericCallback<Long> cb, ZooKeeper zk, String ledgerPrefix, List<ACL> zkAcls) {\n         ZkUtils.asyncCreateFullPathOptimistic(zk, ledgerPrefix, new byte[0], zkAcls,\n                 CreateMode.EPHEMERAL_SEQUENTIAL,\n                 new StringCallback() {\n@@ -84,8 +92,13 @@ public void processResult(int rc, String path, Object ctx, final String idPathNa\n                          */\n                         long ledgerId;\n                         try {\n-                            ledgerId = getLedgerIdFromGenPath(idPathName);\n-                            cb.operationComplete(BKException.Code.OK, ledgerId);\n+                            ledgerId = getLedgerIdFromGenPath(idPathName, ledgerPrefix);\n+                            if(ledgerId < 0 || ledgerId >= Integer.MAX_VALUE) {\n+                                cb.operationComplete(BKException.Code.LedgerIdOverflowException, null);\n+                            }\n+                            else {\n+                                cb.operationComplete(BKException.Code.OK, ledgerId);\n+                            }\n                         } catch (IOException e) {\n                             LOG.error(\"Could not extract ledger-id from id gen path:\" + path, e);\n                             cb.operationComplete(BKException.Code.ZKException, null);\n@@ -109,7 +122,7 @@ public void processResult(int rc, String path, Object ctx) {\n     }\n \n     // get ledger id from generation path\n-    private long getLedgerIdFromGenPath(String nodeName) throws IOException {\n+    private static long getLedgerIdFromGenPath(String nodeName, String ledgerPrefix) throws IOException {\n         long ledgerId;\n         try {\n             String parts[] = nodeName.split(ledgerPrefix);"},{"sha":"c0c110df0bbb8dda164b7810689dd9bbb72c0349","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/util/StringUtils.java","status":"modified","additions":9,"deletions":2,"changes":11,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/057af8dbce6c08794eb8b46ca52ca13f222d9bbb/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2FStringUtils.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/057af8dbce6c08794eb8b46ca52ca13f222d9bbb/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2FStringUtils.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2FStringUtils.java?ref=057af8dbce6c08794eb8b46ca52ca13f222d9bbb","patch":"@@ -57,7 +57,7 @@ public static String getZKStringIdForLongHierarchical(long id) {\n      *          ledger id\n      * @return the hierarchical path\n      */\n-    public static String getHierarchicalLedgerPath(long ledgerId) {\n+    public static String getShortHierarchicalLedgerPath(long ledgerId) {\n         String ledgerIdStr = getZKStringId(ledgerId);\n         // do 2-4-4 split\n         StringBuilder sb = new StringBuilder();\n@@ -90,6 +90,13 @@ public static String getLongHierarchicalLedgerPath(long ledgerId) {\n         return sb.toString();\n     }\n     \n+    public static String getHybridHierarchicalLedgerPath(long ledgerId) {\n+        if(ledgerId < Integer.MAX_VALUE) {\n+            return getShortHierarchicalLedgerPath(ledgerId);\n+        }\n+        return getLongHierarchicalLedgerPath(ledgerId);\n+    }\n+    \n     /**\n      * Parse the hierarchical ledger path to its ledger id\n      *\n@@ -119,7 +126,7 @@ public static long stringToLongHierarchicalLedgerId(String longHierarchicalLedge\n             throws IOException {\n         String[] longHierarchicalParts = longHierarchicalLedgerPath.split(\"/\");\n         if (longHierarchicalParts.length != 5) {\n-            throw new IOException(\"it is not a valid hierarchical path name : \" + longHierarchicalLedgerPath);\n+            return stringToHierarchicalLedgerId(longHierarchicalLedgerPath);\n         }\n         longHierarchicalParts[4] =\n                 longHierarchicalParts[4].substring(LEDGER_NODE_PREFIX.length());"},{"sha":"d25bd703b494843787b04ab729a769eecd74db01","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookieRecoveryTest.java","status":"modified","additions":5,"deletions":1,"changes":6,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/057af8dbce6c08794eb8b46ca52ca13f222d9bbb/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookieRecoveryTest.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/057af8dbce6c08794eb8b46ca52ca13f222d9bbb/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookieRecoveryTest.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookieRecoveryTest.java?ref=057af8dbce6c08794eb8b46ca52ca13f222d9bbb","patch":"@@ -24,6 +24,7 @@\n import org.apache.bookkeeper.client.BookKeeper.DigestType;\n import org.apache.bookkeeper.conf.ClientConfiguration;\n import org.apache.bookkeeper.conf.ServerConfiguration;\n+import org.apache.bookkeeper.meta.LongHierarchicalLedgerManagerFactory;\n import org.apache.bookkeeper.meta.MSLedgerManagerFactory;\n import org.apache.bookkeeper.net.BookieSocketAddress;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n@@ -882,10 +883,13 @@ public void recoverWithoutPasswordInConf() throws Exception {\n     public void ensurePasswordUsedForOldLedgers() throws Exception {\n         // This test bases on creating old ledgers in version 4.1.0, which only\n         // supports ZooKeeper based flat and hierarchical LedgerManagerFactory.\n-        // So we ignore it for MSLedgerManagerFactory.\n+        // So we ignore it for MSLedgerManagerFactory and LongHierarchicalLedgerManagerFactory.\n         if (MSLedgerManagerFactory.class.getName().equals(ledgerManagerFactory)) {\n             return;\n         }\n+        if (LongHierarchicalLedgerManagerFactory.class.getName().equals(ledgerManagerFactory)) {\n+            return;\n+        }\n \n         // stop all bookies\n         // and wipe the ledger layout so we can use an old client"},{"sha":"75422a4b93b36a599886ce0e9374073a9cb8c759","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/TestLongZkLedgerIdGenerator.java","status":"added","additions":145,"deletions":0,"changes":145,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/057af8dbce6c08794eb8b46ca52ca13f222d9bbb/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FTestLongZkLedgerIdGenerator.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/057af8dbce6c08794eb8b46ca52ca13f222d9bbb/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FTestLongZkLedgerIdGenerator.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FTestLongZkLedgerIdGenerator.java?ref=057af8dbce6c08794eb8b46ca52ca13f222d9bbb","patch":"@@ -0,0 +1,145 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.bookkeeper.meta;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n+import org.apache.bookkeeper.test.ZooKeeperUtil;\n+import org.apache.bookkeeper.util.ZkUtils;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.ZooDefs;\n+import org.apache.zookeeper.ZooKeeper;\n+import org.apache.zookeeper.KeeperException.Code;\n+import org.apache.zookeeper.ZooDefs.Ids;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import junit.framework.TestCase;\n+\n+public class TestLongZkLedgerIdGenerator extends TestCase {\n+    private static final Logger LOG = LoggerFactory.getLogger(TestZkLedgerIdGenerator.class);\n+\n+    ZooKeeperUtil zkutil;\n+    ZooKeeper zk;\n+\n+    LongZkLedgerIdGenerator ledgerIdGenerator;\n+\n+    @Override\n+    @Before\n+    public void setUp() throws Exception {\n+        LOG.info(\"Setting up test\");\n+        super.setUp();\n+\n+        zkutil = new ZooKeeperUtil();\n+        zkutil.startServer();\n+        zk = zkutil.getZooKeeperClient();\n+\n+        ZkLedgerIdGenerator shortLedgerIdGenerator = new ZkLedgerIdGenerator(zk,\n+                \"/test-zk-ledger-id-generator\", \"idgen\", ZooDefs.Ids.OPEN_ACL_UNSAFE);\n+        ledgerIdGenerator = new LongZkLedgerIdGenerator(zk, \n+                \"/test-zk-ledger-id-generator\", \"idgen-long\", shortLedgerIdGenerator, ZooDefs.Ids.OPEN_ACL_UNSAFE);\n+    }\n+\n+    @Override\n+    @After\n+    public void tearDown() throws Exception {\n+        LOG.info(\"Tearing down test\");\n+        ledgerIdGenerator.close();\n+        zk.close();\n+        zkutil.killServer();\n+\n+        super.tearDown();\n+    }\n+\n+    @Test(timeout=60000)\n+    public void testGenerateLedgerId() throws Exception {\n+        // Create *nThread* threads each generate *nLedgers* ledger id,\n+        // and then check there is no identical ledger id.\n+        final int nThread = 2;\n+        final int nLedgers = 2000;\n+        // Multiply by two. We're going to do half in the old legacy space and half in the new.\n+        final CountDownLatch countDownLatch = new CountDownLatch(nThread*nLedgers*2); \n+\n+        final AtomicInteger errCount = new AtomicInteger(0);\n+        final ConcurrentLinkedQueue<Long> ledgerIds = new ConcurrentLinkedQueue<Long>();\n+        final GenericCallback<Long> cb = new GenericCallback<Long>() {\n+            @Override\n+            public void operationComplete(int rc, Long result) {\n+                if (Code.OK.intValue() == rc) {\n+                    ledgerIds.add(result);\n+                } else {\n+                    errCount.incrementAndGet();\n+                }\n+                countDownLatch.countDown();\n+            }\n+        };\n+\n+        long start = System.currentTimeMillis();\n+\n+        for (int i = 0; i < nThread; i++) {\n+            new Thread() {\n+                @Override\n+                public void run() {\n+                    for (int j = 0; j < nLedgers; j++) {\n+                        ledgerIdGenerator.generateLedgerId(cb);\n+                    }\n+                }\n+            }.start();\n+        }\n+        \n+        // Go and create the long-id directory in zookeeper. This should cause the id generator to generate ids with the\n+        // new algo once we clear it's stored status.\n+        ZkUtils.createFullPathOptimistic(zk, \"/test-zk-ledger-id-generator/idgen-long\", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n+        ledgerIdGenerator.invalidateLedgerIdGenPathStatus();\n+        \n+        for (int i = 0; i < nThread; i++) {\n+            new Thread() {\n+                @Override\n+                public void run() {\n+                    for (int j = 0; j < nLedgers; j++) {\n+                        ledgerIdGenerator.generateLedgerId(cb);\n+                    }\n+                }\n+            }.start();\n+        }\n+\n+        assertTrue(\"Wait ledger id generation threads to stop timeout : \",\n+                countDownLatch.await(30, TimeUnit.SECONDS));\n+        LOG.info(\"Number of generated ledger id: {}, time used: {}\", ledgerIds.size(),\n+                System.currentTimeMillis() - start);\n+        assertEquals(\"Error occur during ledger id generation : \", 0, errCount.get());\n+\n+        Set<Long> ledgers = new HashSet<Long>();\n+        while (!ledgerIds.isEmpty()) {\n+            Long ledger = ledgerIds.poll();\n+            assertNotNull(\"Generated ledger id is null : \", ledger);\n+            assertFalse(\"Ledger id [\" + ledger + \"] conflict : \", ledgers.contains(ledger));\n+            ledgers.add(ledger);\n+        }\n+    }\n+\n+}"},{"sha":"357bd34420f931700ee4b2eb75348725a59d420f","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/MultiLedgerManagerMultiDigestTestCase.java","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/057af8dbce6c08794eb8b46ca52ca13f222d9bbb/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Ftest%2FMultiLedgerManagerMultiDigestTestCase.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/057af8dbce6c08794eb8b46ca52ca13f222d9bbb/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Ftest%2FMultiLedgerManagerMultiDigestTestCase.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Ftest%2FMultiLedgerManagerMultiDigestTestCase.java?ref=057af8dbce6c08794eb8b46ca52ca13f222d9bbb","patch":"@@ -48,6 +48,7 @@ public MultiLedgerManagerMultiDigestTestCase(int numBookies) {\n     public static Collection<Object[]> configs() {\n         String[] ledgerManagers = {\n             \"org.apache.bookkeeper.meta.FlatLedgerManagerFactory\",\n+            \"org.apache.bookkeeper.meta.LegacyHierarchicalLedgerManagerFactory\",\n             \"org.apache.bookkeeper.meta.HierarchicalLedgerManagerFactory\",\n             \"org.apache.bookkeeper.meta.LongHierarchicalLedgerManagerFactory\",\n             \"org.apache.bookkeeper.meta.MSLedgerManagerFactory\","},{"sha":"cb640b1e3ffae07cad4a977edf0b8e20f6734839","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/MultiLedgerManagerTestCase.java","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/057af8dbce6c08794eb8b46ca52ca13f222d9bbb/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Ftest%2FMultiLedgerManagerTestCase.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/057af8dbce6c08794eb8b46ca52ca13f222d9bbb/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Ftest%2FMultiLedgerManagerTestCase.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Ftest%2FMultiLedgerManagerTestCase.java?ref=057af8dbce6c08794eb8b46ca52ca13f222d9bbb","patch":"@@ -42,6 +42,7 @@ public MultiLedgerManagerTestCase(int numBookies) {\n     public static Collection<Object[]> configs() {\n         String[] ledgerManagers = new String[] {\n             \"org.apache.bookkeeper.meta.FlatLedgerManagerFactory\",\n+            \"org.apache.bookkeeper.meta.LegacyHierarchicalLedgerManagerFactory\",\n             \"org.apache.bookkeeper.meta.HierarchicalLedgerManagerFactory\",\n             \"org.apache.bookkeeper.meta.LongHierarchicalLedgerManagerFactory\",\n             \"org.apache.bookkeeper.meta.MSLedgerManagerFactory\","},{"sha":"18504e33cb88f58d36f5a1bb42bb07170e4fa697","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/TestBackwardCompat.java","status":"modified","additions":53,"deletions":0,"changes":53,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/057af8dbce6c08794eb8b46ca52ca13f222d9bbb/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Ftest%2FTestBackwardCompat.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/057af8dbce6c08794eb8b46ca52ca13f222d9bbb/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Ftest%2FTestBackwardCompat.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Ftest%2FTestBackwardCompat.java?ref=057af8dbce6c08794eb8b46ca52ca13f222d9bbb","patch":"@@ -37,6 +37,7 @@\n import org.apache.bookkeeper.bookie.BookieException;\n import org.apache.bookkeeper.bookie.FileSystemUpgrade;\n import org.apache.bookkeeper.client.BookKeeperAdmin;\n+import org.apache.bookkeeper.conf.AbstractConfiguration;\n import org.apache.bookkeeper.conf.ClientConfiguration;\n import org.apache.bookkeeper.conf.TestBKConfiguration;\n import org.apache.bookkeeper.util.IOUtils;\n@@ -437,6 +438,17 @@ static LedgerCurrent openLedger(long id) throws Exception {\n             return new LedgerCurrent(newbk, newlh);\n         }\n \n+        static LedgerCurrent openLedger(long id, ClientConfiguration conf) throws Exception {\n+            conf.setZkServers(zkUtil.getZooKeeperConnectString());\n+            org.apache.bookkeeper.client.BookKeeper newbk\n+                = new org.apache.bookkeeper.client.BookKeeper(conf);\n+            org.apache.bookkeeper.client.LedgerHandle newlh\n+                = newbk.openLedger(id,\n+                                   org.apache.bookkeeper.client.BookKeeper.DigestType.CRC32,\n+                                \"foobar\".getBytes());\n+            return new LedgerCurrent(newbk, newlh);\n+        }\n+\n         long getId() {\n             return lh.getId();\n         }\n@@ -827,4 +839,45 @@ public void testCompatWrites() throws Exception {\n         oldledger.close();\n         scur.stop();\n     }\n+\n+    /**\n+     * Test compatability between version old version and the current version\n+     * with respect to the HierarchicalLedgerManagers.\n+     * - 4.2.0 server starts with HierarchicalLedgerManager.\n+     * - Write ledgers with old and new clients\n+     * - Read ledgers written by old clients.\n+     */\n+    @Test(timeout = 60000)\n+    public void testCompatHierarchicalLedgerManager() throws Exception {\n+        File journalDir = createTempDir(\"bookie\", \"journal\");\n+        File ledgerDir = createTempDir(\"bookie\", \"ledger\");\n+\n+        int port = PortManager.nextFreePort();\n+        // start server, upgrade\n+        Server420 s420 = new Server420(journalDir, ledgerDir, port);\n+        s420.getConf().setLedgerManagerFactoryClassName(\"org.apache.bk_v4_2_0.bookkeeper.meta.HierarchicalLedgerManagerFactory\");\n+        s420.start();\n+\n+        Ledger420 l420 = Ledger420.newLedger();\n+        l420.write100();\n+        long oldLedgerId = l420.getId();\n+        l420.close();\n+        s420.stop();\n+\n+        // Start the current server\n+        ServerCurrent scur = new ServerCurrent(journalDir, ledgerDir, port, true);\n+        scur.getConf().setLedgerManagerFactoryClassName(\"org.apache.bookkeeper.meta.HierarchicalLedgerManagerFactory\");\n+        scur.getConf().setProperty(AbstractConfiguration.LEDGER_MANAGER_FACTORY_DISABLE_CLASS_CHECK, true);\n+        scur.start();\n+\n+        // Munge the conf so we can test.\n+        ClientConfiguration conf = new ClientConfiguration();\n+        conf.setLedgerManagerFactoryClassName(\"org.apache.bookkeeper.meta.HierarchicalLedgerManagerFactory\");\n+        conf.setProperty(AbstractConfiguration.LEDGER_MANAGER_FACTORY_DISABLE_CLASS_CHECK, true);\n+\n+        // check that new client can read old ledgers on new server\n+        LedgerCurrent oldledger = LedgerCurrent.openLedger(oldLedgerId, conf);\n+        assertEquals(\"Failed to read entries!\", 100, oldledger.readAll());\n+        oldledger.close();\n+    }\n }"}]}