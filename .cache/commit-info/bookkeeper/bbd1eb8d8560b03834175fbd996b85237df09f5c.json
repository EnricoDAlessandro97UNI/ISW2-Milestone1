{"sha":"bbd1eb8d8560b03834175fbd996b85237df09f5c","node_id":"MDY6Q29tbWl0NDc4NTkyNTI2OmJiZDFlYjhkODU2MGIwMzgzNDE3NWZiZDk5NmI4NTIzN2RmMDlmNWM=","commit":{"author":{"name":"Robin Dhamankar","email":"robin.dhamankar@gmail.com","date":"2016-10-13T05:50:42Z"},"committer":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2016-10-13T05:50:42Z"},"message":"BOOKKEEPER-612: Region aware placement\n\n- Introduce the concept of a two level Network Topology with region as the first level and rack as the second level\n- NodeBase, Node and NetworkTopology manage this two level hierarchy and position of individual nodes in this hierarchy\n- An implementation of RegionawareEnsemblePlacementPolicy that distributes nodes across regions and within regions uses rack aware placement to place nodes\n\nThis is a stacked diff (opening to start a review), we would still merge the dependent pull request first.\n\nAuthor: Robin Dhamankar <robindh@Robins-MacBook-Air.local>\n\nReviewers: Sijie Guo <sijie@apache.org>\n\nCloses #56 from robindh/RegionAwarePlacement","tree":{"sha":"67e24ecb59a109277593b9109574114e7615f55d","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/trees/67e24ecb59a109277593b9109574114e7615f55d"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/commits/bbd1eb8d8560b03834175fbd996b85237df09f5c","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/bbd1eb8d8560b03834175fbd996b85237df09f5c","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/bbd1eb8d8560b03834175fbd996b85237df09f5c","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/bbd1eb8d8560b03834175fbd996b85237df09f5c/comments","author":{"login":"robindh","id":2607057,"node_id":"MDQ6VXNlcjI2MDcwNTc=","avatar_url":"https://avatars.githubusercontent.com/u/2607057?v=4","gravatar_id":"","url":"https://api.github.com/users/robindh","html_url":"https://github.com/robindh","followers_url":"https://api.github.com/users/robindh/followers","following_url":"https://api.github.com/users/robindh/following{/other_user}","gists_url":"https://api.github.com/users/robindh/gists{/gist_id}","starred_url":"https://api.github.com/users/robindh/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/robindh/subscriptions","organizations_url":"https://api.github.com/users/robindh/orgs","repos_url":"https://api.github.com/users/robindh/repos","events_url":"https://api.github.com/users/robindh/events{/privacy}","received_events_url":"https://api.github.com/users/robindh/received_events","type":"User","site_admin":false},"committer":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"parents":[{"sha":"9dc05fc080ddf01e69eb89ce1b0865c552d3de53","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/9dc05fc080ddf01e69eb89ce1b0865c552d3de53","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/9dc05fc080ddf01e69eb89ce1b0865c552d3de53"}],"stats":{"total":6309,"additions":4837,"deletions":1472},"files":[{"sha":"bd143f1018133314e91e9fadbcab82676080ded4","filename":"bookkeeper-server/pom.xml","status":"modified","additions":5,"deletions":0,"changes":5,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/bbd1eb8d8560b03834175fbd996b85237df09f5c/bookkeeper-server%2Fpom.xml","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/bbd1eb8d8560b03834175fbd996b85237df09f5c/bookkeeper-server%2Fpom.xml","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fpom.xml?ref=bbd1eb8d8560b03834175fbd996b85237df09f5c","patch":"@@ -83,6 +83,11 @@\n       <version>${netty.version}</version>\n       <scope>compile</scope>\n     </dependency>\n+    <dependency>\n+      <groupId>org.apache.commons</groupId>\n+      <artifactId>commons-lang3</artifactId>\n+      <version>3.3.2</version>\n+    </dependency>\n     <dependency>\n       <groupId>commons-configuration</groupId>\n       <artifactId>commons-configuration</artifactId>"},{"sha":"508511ba6375454c0013d5ca77cc93dcd41d1d48","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LocalBookieEnsemblePlacementPolicy.java","status":"modified","additions":25,"deletions":12,"changes":37,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/bbd1eb8d8560b03834175fbd996b85237df09f5c/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLocalBookieEnsemblePlacementPolicy.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/bbd1eb8d8560b03834175fbd996b85237df09f5c/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLocalBookieEnsemblePlacementPolicy.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLocalBookieEnsemblePlacementPolicy.java?ref=bbd1eb8d8560b03834175fbd996b85237df09f5c","patch":"@@ -17,16 +17,21 @@\n  */\n package org.apache.bookkeeper.bookie;\n \n+import com.google.common.base.Optional;\n+\n import java.net.UnknownHostException;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.Set;\n+import java.util.*;\n \n import org.apache.bookkeeper.client.BKException;\n import org.apache.bookkeeper.client.EnsemblePlacementPolicy;\n import org.apache.bookkeeper.client.BKException.BKNotEnoughBookiesException;\n+import org.apache.bookkeeper.conf.ClientConfiguration;\n import org.apache.bookkeeper.conf.ServerConfiguration;\n+import org.apache.bookkeeper.feature.FeatureProvider;\n import org.apache.bookkeeper.net.BookieSocketAddress;\n+import org.apache.bookkeeper.stats.StatsLogger;\n+import org.apache.bookkeeper.net.DNSToSwitchMapping;\n+import org.jboss.netty.util.HashedWheelTimer;\n import org.apache.commons.configuration.Configuration;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -43,8 +48,7 @@ public class LocalBookieEnsemblePlacementPolicy implements EnsemblePlacementPoli\n     private BookieSocketAddress bookieAddress;\n \n     @Override\n-    public EnsemblePlacementPolicy initialize(Configuration conf) {\n-\n+    public EnsemblePlacementPolicy initialize(ClientConfiguration conf, Optional<DNSToSwitchMapping> optionalDnsResolver, HashedWheelTimer hashedWheelTimer, FeatureProvider featureProvider, StatsLogger statsLogger) {\n         // Configuration will have already the bookie configuration inserted\n         ServerConfiguration serverConf = new ServerConfiguration();\n         serverConf.addConfiguration(conf);\n@@ -70,7 +74,22 @@ public Set<BookieSocketAddress> onClusterChanged(Set<BookieSocketAddress> writab\n     }\n \n     @Override\n-    public ArrayList<BookieSocketAddress> newEnsemble(int ensembleSize, int writeQuorumSize,\n+    public BookieSocketAddress replaceBookie(int ensembleSize, int writeQuorumSize, int ackQuorumSize, Collection<BookieSocketAddress> currentEnsemble, BookieSocketAddress bookieToReplace, Set<BookieSocketAddress> excludeBookies) throws BKNotEnoughBookiesException {\n+        throw new BKNotEnoughBookiesException();\n+    }\n+\n+    @Override\n+    public List<Integer> reorderReadSequence(ArrayList<BookieSocketAddress> ensemble, List<Integer> writeSet, Map<BookieSocketAddress, Long> bookieFailureHistory) {\n+        return null;\n+    }\n+\n+    @Override\n+    public List<Integer> reorderReadLACSequence(ArrayList<BookieSocketAddress> ensemble, List<Integer> writeSet, Map<BookieSocketAddress, Long> bookieFailureHistory) {\n+        return null;\n+    }\n+\n+    @Override\n+    public ArrayList<BookieSocketAddress> newEnsemble(int ensembleSize, int writeQuorumSize, int ackQuorumSize,\n             Set<BookieSocketAddress> excludeBookies) throws BKNotEnoughBookiesException {\n         if (ensembleSize > 1) {\n             throw new IllegalArgumentException(\"Local ensemble policy can only return 1 bookie\");\n@@ -79,10 +98,4 @@ public ArrayList<BookieSocketAddress> newEnsemble(int ensembleSize, int writeQuo\n         return Lists.newArrayList(bookieAddress);\n     }\n \n-    @Override\n-    public BookieSocketAddress replaceBookie(BookieSocketAddress bookieToReplace,\n-            Set<BookieSocketAddress> excludeBookies) throws BKNotEnoughBookiesException {\n-        throw new BKNotEnoughBookiesException();\n-    }\n-\n }"},{"sha":"b683ca48c6a2d992a40cad72dec79587fe55ab1a","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeper.java","status":"modified","additions":65,"deletions":7,"changes":72,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/bbd1eb8d8560b03834175fbd996b85237df09f5c/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookKeeper.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/bbd1eb8d8560b03834175fbd996b85237df09f5c/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookKeeper.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookKeeper.java?ref=bbd1eb8d8560b03834175fbd996b85237df09f5c","patch":"@@ -29,18 +29,22 @@\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.locks.ReentrantReadWriteLock;\n \n+import com.google.common.base.Optional;\n import com.google.common.base.Preconditions;\n \n import org.apache.bookkeeper.client.AsyncCallback.CreateCallback;\n import org.apache.bookkeeper.client.AsyncCallback.DeleteCallback;\n import org.apache.bookkeeper.client.AsyncCallback.OpenCallback;\n import org.apache.bookkeeper.client.AsyncCallback.IsClosedCallback;\n import org.apache.bookkeeper.conf.ClientConfiguration;\n+import org.apache.bookkeeper.feature.FeatureProvider;\n+import org.apache.bookkeeper.feature.SettableFeatureProvider;\n import org.apache.bookkeeper.meta.CleanupLedgerManager;\n import org.apache.bookkeeper.meta.LedgerIdGenerator;\n import org.apache.bookkeeper.meta.LedgerManager;\n import org.apache.bookkeeper.meta.LedgerManagerFactory;\n import org.apache.bookkeeper.net.BookieSocketAddress;\n+import org.apache.bookkeeper.net.DNSToSwitchMapping;\n import org.apache.bookkeeper.proto.BookieClient;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n import org.apache.bookkeeper.stats.NullStatsLogger;\n@@ -56,6 +60,7 @@\n import org.apache.zookeeper.ZooKeeper;\n import org.jboss.netty.channel.socket.ClientSocketChannelFactory;\n import org.jboss.netty.channel.socket.nio.NioClientSocketChannelFactory;\n+import org.jboss.netty.util.HashedWheelTimer;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -101,6 +106,9 @@ public class BookKeeper implements AutoCloseable {\n \n     final OrderedSafeExecutor mainWorkerPool;\n     final ScheduledExecutorService scheduler;\n+    final HashedWheelTimer requestTimer;\n+    final boolean ownTimer;\n+    final FeatureProvider featureProvider;\n \n     // Ledger manager responsible for how to store ledger meta data\n     final LedgerManagerFactory ledgerManagerFactory;\n@@ -122,6 +130,9 @@ public static class Builder {\n         ZooKeeper zk = null;\n         ClientSocketChannelFactory channelFactory = null;\n         StatsLogger statsLogger = NullStatsLogger.INSTANCE;\n+        DNSToSwitchMapping dnsResolver = null;\n+        HashedWheelTimer requestTimer = null;\n+        FeatureProvider featureProvider = null;\n \n         Builder(ClientConfiguration conf) {\n             this.conf = conf;\n@@ -142,9 +153,25 @@ public Builder setStatsLogger(StatsLogger statsLogger) {\n             return this;\n         }\n \n+\n+        public Builder dnsResolver(DNSToSwitchMapping dnsResolver) {\n+            this.dnsResolver = dnsResolver;\n+            return this;\n+        }\n+\n+        public Builder requestTimer(HashedWheelTimer requestTimer) {\n+            this.requestTimer = requestTimer;\n+            return this;\n+        }\n+\n+        public Builder featureProvider(FeatureProvider featureProvider) {\n+            this.featureProvider = featureProvider;\n+            return this;\n+        }\n+\n         public BookKeeper build() throws IOException, InterruptedException, KeeperException {\n             Preconditions.checkNotNull(statsLogger, \"No stats logger provided\");\n-            return new BookKeeper(conf, zk, channelFactory, statsLogger);\n+            return new BookKeeper(conf, zk, channelFactory, statsLogger, dnsResolver, requestTimer, featureProvider);\n         }\n     }\n \n@@ -183,7 +210,8 @@ public BookKeeper(String servers) throws IOException, InterruptedException,\n      */\n     public BookKeeper(final ClientConfiguration conf)\n             throws IOException, InterruptedException, KeeperException {\n-        this(conf, null, null, NullStatsLogger.INSTANCE);\n+        this(conf, null, null, NullStatsLogger.INSTANCE,\n+                null, null, null);\n     }\n \n     private static ZooKeeper validateZooKeeper(ZooKeeper zk) throws NullPointerException {\n@@ -240,7 +268,8 @@ public BookKeeper(ClientConfiguration conf, ZooKeeper zk)\n      */\n     public BookKeeper(ClientConfiguration conf, ZooKeeper zk, ClientSocketChannelFactory channelFactory)\n             throws IOException, InterruptedException, KeeperException {\n-        this(conf, validateZooKeeper(zk), validateChannelFactory(channelFactory), NullStatsLogger.INSTANCE);\n+        this(conf, validateZooKeeper(zk), validateChannelFactory(channelFactory), NullStatsLogger.INSTANCE,\n+                null, null, null);\n     }\n \n     /**\n@@ -249,7 +278,10 @@ public BookKeeper(ClientConfiguration conf, ZooKeeper zk, ClientSocketChannelFac\n     private BookKeeper(ClientConfiguration conf,\n                        ZooKeeper zkc,\n                        ClientSocketChannelFactory channelFactory,\n-                       StatsLogger statsLogger)\n+                       StatsLogger statsLogger,\n+                       DNSToSwitchMapping dnsResolver,\n+                       HashedWheelTimer requestTimer,\n+                       FeatureProvider featureProvider)\n             throws IOException, InterruptedException, KeeperException {\n         this.conf = conf;\n \n@@ -286,6 +318,23 @@ private BookKeeper(ClientConfiguration conf,\n             this.ownChannelFactory = false;\n         }\n \n+        if (null == requestTimer) {\n+            this.requestTimer = new HashedWheelTimer(\n+                    new ThreadFactoryBuilder().setNameFormat(\"BookieClientTimer-%d\").build(),\n+                    conf.getTimeoutTimerTickDurationMs(), TimeUnit.MILLISECONDS,\n+                    conf.getTimeoutTimerNumTicks());\n+            this.ownTimer = true;\n+        } else {\n+            this.requestTimer = requestTimer;\n+            this.ownTimer = false;\n+        }\n+\n+        if (null == featureProvider) {\n+            this.featureProvider = SettableFeatureProvider.DISABLE_ALL;\n+        } else {\n+            this.featureProvider = featureProvider;\n+        }\n+\n         // initialize scheduler\n         ThreadFactoryBuilder tfb = new ThreadFactoryBuilder().setNameFormat(\n                 \"BookKeeperClientScheduler-%d\");\n@@ -297,7 +346,8 @@ private BookKeeper(ClientConfiguration conf,\n         initOpLoggers(this.statsLogger);\n \n         // initialize the ensemble placement\n-        this.placementPolicy = initializeEnsemblePlacementPolicy(conf);\n+        this.placementPolicy = initializeEnsemblePlacementPolicy(conf,\n+                dnsResolver, this.requestTimer, this.featureProvider, this.statsLogger);\n \n         // initialize main worker pool\n         this.mainWorkerPool = OrderedSafeExecutor.newBuilder()\n@@ -321,11 +371,16 @@ private BookKeeper(ClientConfiguration conf,\n         scheduleBookieHealthCheckIfEnabled();\n     }\n \n-    private EnsemblePlacementPolicy initializeEnsemblePlacementPolicy(ClientConfiguration conf)\n+    private EnsemblePlacementPolicy initializeEnsemblePlacementPolicy(ClientConfiguration conf,\n+                                                                      DNSToSwitchMapping dnsResolver,\n+                                                                      HashedWheelTimer timer,\n+                                                                      FeatureProvider featureProvider,\n+                                                                      StatsLogger statsLogger)\n         throws IOException {\n         try {\n             Class<? extends EnsemblePlacementPolicy> policyCls = conf.getEnsemblePlacementPolicy();\n-            return ReflectionUtils.newInstance(policyCls).initialize(conf);\n+            return ReflectionUtils.newInstance(policyCls).initialize(conf, Optional.fromNullable(dnsResolver),\n+                    timer, featureProvider, statsLogger);\n         } catch (ConfigurationException e) {\n             throw new IOException(\"Failed to initialize ensemble placement policy : \", e);\n         }\n@@ -1001,6 +1056,9 @@ public void close() throws InterruptedException, BKException {\n             LOG.warn(\"The mainWorkerPool did not shutdown cleanly\");\n         }\n \n+        if (ownTimer) {\n+            requestTimer.stop();\n+        }\n         if (ownChannelFactory) {\n             channelFactory.releaseExternalResources();\n         }"},{"sha":"b8d89519ca8ebb0e67e8a22cb68a7020e2bcb385","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookieWatcher.java","status":"modified","additions":11,"deletions":6,"changes":17,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/bbd1eb8d8560b03834175fbd996b85237df09f5c/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookieWatcher.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/bbd1eb8d8560b03834175fbd996b85237df09f5c/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookieWatcher.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookieWatcher.java?ref=bbd1eb8d8560b03834175fbd996b85237df09f5c","patch":"@@ -255,17 +255,18 @@ public void processResult(int rc, String path, Object ctx, List<String> children\n      * @return list of bookies for new ensemble.\n      * @throws BKNotEnoughBookiesException\n      */\n-    public ArrayList<BookieSocketAddress> newEnsemble(int ensembleSize, int writeQuorumSize)\n+    public ArrayList<BookieSocketAddress> newEnsemble(int ensembleSize, int writeQuorumSize, int ackQuorumSize)\n             throws BKNotEnoughBookiesException {\n         try {\n             // we try to only get from the healthy bookies first\n-            return placementPolicy.newEnsemble(ensembleSize, writeQuorumSize, new HashSet<BookieSocketAddress>(\n+            return placementPolicy.newEnsemble(ensembleSize,\n+                    writeQuorumSize, ackQuorumSize, new HashSet<BookieSocketAddress>(\n                     quarantinedBookies.asMap().keySet()));\n         } catch (BKNotEnoughBookiesException e) {\n             if (logger.isDebugEnabled()) {\n                 logger.debug(\"Not enough healthy bookies available, using quarantined bookies\");\n             }\n-            return placementPolicy.newEnsemble(ensembleSize, writeQuorumSize, EMPTY_SET);\n+            return placementPolicy.newEnsemble(ensembleSize, writeQuorumSize, ackQuorumSize, EMPTY_SET);\n         }\n     }\n \n@@ -278,19 +279,23 @@ public ArrayList<BookieSocketAddress> newEnsemble(int ensembleSize, int writeQuo\n      * @return the bookie to replace.\n      * @throws BKNotEnoughBookiesException\n      */\n-    public BookieSocketAddress replaceBookie(List<BookieSocketAddress> existingBookies, int bookieIdx)\n+    public BookieSocketAddress replaceBookie(int ensembleSize, int writeQuorumSize, int ackQuorumSize,\n+                                             List<BookieSocketAddress> existingBookies, int bookieIdx,\n+                                             Set<BookieSocketAddress> excludeBookies)\n             throws BKNotEnoughBookiesException {\n         BookieSocketAddress addr = existingBookies.get(bookieIdx);\n         try {\n             // we exclude the quarantined bookies also first\n             Set<BookieSocketAddress> existingAndQuarantinedBookies = new HashSet<BookieSocketAddress>(existingBookies);\n             existingAndQuarantinedBookies.addAll(quarantinedBookies.asMap().keySet());\n-            return placementPolicy.replaceBookie(addr, existingAndQuarantinedBookies);\n+            return placementPolicy.replaceBookie(ensembleSize, writeQuorumSize, ackQuorumSize,\n+                    existingAndQuarantinedBookies, addr, excludeBookies);\n         } catch (BKNotEnoughBookiesException e) {\n             if (logger.isDebugEnabled()) {\n                 logger.debug(\"Not enough healthy bookies available, using quarantined bookies\");\n             }\n-            return placementPolicy.replaceBookie(addr, new HashSet<BookieSocketAddress>(existingBookies));\n+            return placementPolicy.replaceBookie(ensembleSize, writeQuorumSize, ackQuorumSize,\n+                    new HashSet<BookieSocketAddress>(existingBookies), addr, excludeBookies);\n         }\n     }\n "},{"sha":"640bdb7c906ace514df4473f0f55846420dbaa70","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/DefaultEnsemblePlacementPolicy.java","status":"modified","additions":38,"deletions":7,"changes":45,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/bbd1eb8d8560b03834175fbd996b85237df09f5c/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FDefaultEnsemblePlacementPolicy.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/bbd1eb8d8560b03834175fbd996b85237df09f5c/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FDefaultEnsemblePlacementPolicy.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FDefaultEnsemblePlacementPolicy.java?ref=bbd1eb8d8560b03834175fbd996b85237df09f5c","patch":"@@ -18,14 +18,22 @@\n package org.apache.bookkeeper.client;\n \n import java.util.ArrayList;\n+import java.util.Collection;\n import java.util.Collections;\n import java.util.HashSet;\n import java.util.List;\n+import java.util.Map;\n import java.util.Set;\n \n+import com.google.common.base.Optional;\n+\n import org.apache.bookkeeper.client.BKException.BKNotEnoughBookiesException;\n+import org.apache.bookkeeper.conf.ClientConfiguration;\n+import org.apache.bookkeeper.feature.FeatureProvider;\n import org.apache.bookkeeper.net.BookieSocketAddress;\n-import org.apache.commons.configuration.Configuration;\n+import org.apache.bookkeeper.net.DNSToSwitchMapping;\n+import org.apache.bookkeeper.stats.StatsLogger;\n+import org.jboss.netty.util.HashedWheelTimer;\n \n /**\n  * Default Ensemble Placement Policy, which picks bookies randomly\n@@ -37,7 +45,7 @@ public class DefaultEnsemblePlacementPolicy implements EnsemblePlacementPolicy {\n     private Set<BookieSocketAddress> knownBookies = new HashSet<BookieSocketAddress>();\n \n     @Override\n-    public ArrayList<BookieSocketAddress> newEnsemble(int ensembleSize, int quorumSize,\n+    public ArrayList<BookieSocketAddress> newEnsemble(int ensembleSize, int quorumSize, int ackQuorumSize,\n             Set<BookieSocketAddress> excludeBookies) throws BKNotEnoughBookiesException {\n         ArrayList<BookieSocketAddress> newBookies = new ArrayList<BookieSocketAddress>(ensembleSize);\n         if (ensembleSize <= 0) {\n@@ -62,9 +70,11 @@ public ArrayList<BookieSocketAddress> newEnsemble(int ensembleSize, int quorumSi\n     }\n \n     @Override\n-    public BookieSocketAddress replaceBookie(BookieSocketAddress bookieToReplace,\n-            Set<BookieSocketAddress> excludeBookies) throws BKNotEnoughBookiesException {\n-        ArrayList<BookieSocketAddress> addresses = newEnsemble(1, 1, excludeBookies);\n+    public BookieSocketAddress replaceBookie(int ensembleSize, int writeQuorumSize, int ackQuorumSize, Collection<BookieSocketAddress> currentEnsemble,\n+                                           BookieSocketAddress bookieToReplace,\n+                                           Set<BookieSocketAddress> excludeBookies) throws BKNotEnoughBookiesException {\n+        excludeBookies.addAll(currentEnsemble);\n+        ArrayList<BookieSocketAddress> addresses = newEnsemble(1, 1, 1, excludeBookies);\n         return addresses.get(0);\n     }\n \n@@ -81,13 +91,34 @@ public synchronized Set<BookieSocketAddress> onClusterChanged(Set<BookieSocketAd\n     }\n \n     @Override\n-    public EnsemblePlacementPolicy initialize(Configuration conf) {\n+    public List<Integer> reorderReadSequence(ArrayList<BookieSocketAddress> ensemble, List<Integer> writeSet, Map<BookieSocketAddress, Long> bookieFailureHistory) {\n+        return writeSet;\n+    }\n+\n+    @Override\n+    public List<Integer> reorderReadLACSequence(ArrayList<BookieSocketAddress> ensemble, List<Integer> writeSet, Map<BookieSocketAddress, Long> bookieFailureHistory) {\n+        List<Integer> retList = new ArrayList<Integer>(writeSet);\n+        if (retList.size() < ensemble.size()) {\n+            for (int i = 0; i < ensemble.size(); i++) {\n+                if (!retList.contains(i)) {\n+                    retList.add(i);\n+                }\n+            }\n+        }\n+        return retList;\n+    }\n+\n+    @Override\n+    public EnsemblePlacementPolicy initialize(ClientConfiguration conf,\n+                                              Optional<DNSToSwitchMapping> optionalDnsResolver,\n+                                              HashedWheelTimer timer,\n+                                              FeatureProvider featureProvider,\n+                                              StatsLogger statsLogger) {\n         return this;\n     }\n \n     @Override\n     public void uninitalize() {\n         // do nothing\n     }\n-\n }"},{"sha":"2af81081d597ae4c66e07772704cf3d1114c1872","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/EnsemblePlacementPolicy.java","status":"modified","additions":55,"deletions":10,"changes":65,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/bbd1eb8d8560b03834175fbd996b85237df09f5c/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FEnsemblePlacementPolicy.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/bbd1eb8d8560b03834175fbd996b85237df09f5c/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FEnsemblePlacementPolicy.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FEnsemblePlacementPolicy.java?ref=bbd1eb8d8560b03834175fbd996b85237df09f5c","patch":"@@ -18,11 +18,20 @@\n package org.apache.bookkeeper.client;\n \n import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n import java.util.Set;\n \n+import com.google.common.base.Optional;\n+\n import org.apache.bookkeeper.client.BKException.BKNotEnoughBookiesException;\n+import org.apache.bookkeeper.conf.ClientConfiguration;\n+import org.apache.bookkeeper.feature.FeatureProvider;\n import org.apache.bookkeeper.net.BookieSocketAddress;\n-import org.apache.commons.configuration.Configuration;\n+import org.apache.bookkeeper.net.DNSToSwitchMapping;\n+import org.apache.bookkeeper.stats.StatsLogger;\n+import org.jboss.netty.util.HashedWheelTimer;\n \n /**\n  * Encapsulation of the algorithm that selects a number of bookies from the cluster as an ensemble for storing\n@@ -33,11 +42,17 @@ public interface EnsemblePlacementPolicy {\n     /**\n      * Initialize the policy.\n      *\n-     * @param conf\n-     *          client configuration.\n-     * @return initialized ensemble placement policy\n+     * @param conf client configuration\n+     * @param optionalDnsResolver dns resolver\n+     * @param hashedWheelTimer timer\n+     * @param featureProvider feature provider\n+     * @param statsLogger stats logger\n      */\n-    public EnsemblePlacementPolicy initialize(Configuration conf);\n+    public EnsemblePlacementPolicy initialize(ClientConfiguration conf,\n+                                              Optional<DNSToSwitchMapping> optionalDnsResolver,\n+                                              HashedWheelTimer hashedWheelTimer,\n+                                              FeatureProvider featureProvider,\n+                                              StatsLogger statsLogger);\n \n     /**\n      * Uninitialize the policy\n@@ -55,7 +70,7 @@ public interface EnsemblePlacementPolicy {\n      * @return the dead bookies during this cluster change.\n      */\n     public Set<BookieSocketAddress> onClusterChanged(Set<BookieSocketAddress> writableBookies,\n-            Set<BookieSocketAddress> readOnlyBookies);\n+                                                     Set<BookieSocketAddress> readOnlyBookies);\n \n     /**\n      * Choose <i>numBookies</i> bookies for ensemble. If the count is more than the number of available\n@@ -70,8 +85,8 @@ public Set<BookieSocketAddress> onClusterChanged(Set<BookieSocketAddress> writab\n      * @return list of bookies chosen as targets.\n      * @throws BKNotEnoughBookiesException if not enough bookies available.\n      */\n-    public ArrayList<BookieSocketAddress> newEnsemble(int ensembleSize, int writeQuorumSize,\n-            Set<BookieSocketAddress> excludeBookies) throws BKNotEnoughBookiesException;\n+    public ArrayList<BookieSocketAddress> newEnsemble(int ensembleSize, int writeQuorumSize, int ackQuorumSize,\n+                                                      Set<BookieSocketAddress> excludeBookies) throws BKNotEnoughBookiesException;\n \n     /**\n      * Choose a new bookie to replace <i>bookieToReplace</i>. If no bookie available in the cluster,\n@@ -84,6 +99,36 @@ public ArrayList<BookieSocketAddress> newEnsemble(int ensembleSize, int writeQuo\n      * @return the bookie chosen as target.\n      * @throws BKNotEnoughBookiesException\n      */\n-    public BookieSocketAddress replaceBookie(BookieSocketAddress bookieToReplace,\n-            Set<BookieSocketAddress> excludeBookies) throws BKNotEnoughBookiesException;\n+    public BookieSocketAddress replaceBookie(int ensembleSize, int writeQuorumSize, int ackQuorumSize,\n+                                             Collection<BookieSocketAddress> currentEnsemble, BookieSocketAddress bookieToReplace,\n+                                             Set<BookieSocketAddress> excludeBookies) throws BKNotEnoughBookiesException;\n+\n+    /**\n+     * Reorder the read sequence of a given write quorum <i>writeSet</i>.\n+     *\n+     * @param ensemble\n+     *          Ensemble to read entries.\n+     * @param writeSet\n+     *          Write quorum to read entries.\n+     * @param bookieFailureHistory\n+     *          Observed failures on the bookies\n+     * @return read sequence of bookies\n+     */\n+    public List<Integer> reorderReadSequence(ArrayList<BookieSocketAddress> ensemble,\n+                                             List<Integer> writeSet, Map<BookieSocketAddress, Long> bookieFailureHistory);\n+\n+\n+    /**\n+     * Reorder the read last add confirmed sequence of a given write quorum <i>writeSet</i>.\n+     *\n+     * @param ensemble\n+     *          Ensemble to read entries.\n+     * @param writeSet\n+     *          Write quorum to read entries.\n+     * @param bookieFailureHistory\n+     *          Observed failures on the bookies\n+     * @return read sequence of bookies\n+     */\n+    public List<Integer> reorderReadLACSequence(ArrayList<BookieSocketAddress> ensemble,\n+                                                List<Integer> writeSet, Map<BookieSocketAddress, Long> bookieFailureHistory);\n }"},{"sha":"535fffe99c033417948a9d462fee382c602e97fd","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ITopologyAwareEnsemblePlacementPolicy.java","status":"added","additions":127,"deletions":0,"changes":127,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/bbd1eb8d8560b03834175fbd996b85237df09f5c/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FITopologyAwareEnsemblePlacementPolicy.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/bbd1eb8d8560b03834175fbd996b85237df09f5c/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FITopologyAwareEnsemblePlacementPolicy.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FITopologyAwareEnsemblePlacementPolicy.java?ref=bbd1eb8d8560b03834175fbd996b85237df09f5c","patch":"@@ -0,0 +1,127 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.bookkeeper.client;\n+\n+import org.apache.bookkeeper.net.BookieSocketAddress;\n+import org.apache.bookkeeper.net.Node;\n+\n+import java.util.ArrayList;\n+import java.util.Set;\n+\n+/**\n+ * Interface for topology aware ensemble placement policy.\n+ */\n+public interface ITopologyAwareEnsemblePlacementPolicy<T extends Node> extends EnsemblePlacementPolicy {\n+    /**\n+     * Predicate used when choosing an ensemble.\n+     */\n+    public static interface Predicate<T extends Node> {\n+        boolean apply(T candidate, Ensemble<T> chosenBookies);\n+    }\n+\n+    /**\n+     * Ensemble used to hold the result of an ensemble selected for placement.\n+     */\n+    public static interface Ensemble<T extends Node> {\n+\n+        /**\n+         * Append the new bookie node to the ensemble only if the ensemble doesnt\n+         * already contain the same bookie\n+         *\n+         * @param node\n+         *          new candidate bookie node.\n+         * @return\n+         *          true if the node was added\n+         */\n+        public boolean addNode(T node);\n+\n+        /**\n+         * @return list of addresses representing the ensemble\n+         */\n+        public ArrayList<BookieSocketAddress> toList();\n+\n+        /**\n+         * Validates if an ensemble is valid\n+         *\n+         * @return true if the ensemble is valid; false otherwise\n+         */\n+        public boolean validate();\n+\n+    }\n+\n+    /**\n+     * Create an ensemble with parent ensemble.\n+     *\n+     * @param ensembleSize\n+     *          ensemble size\n+     * @param writeQuorumSize\n+     *          write quorum size\n+     * @param ackQuorumSize\n+     *          ack quorum size\n+     * @param excludeBookies\n+     *          exclude bookies\n+     * @param parentEnsemble\n+     *          parent ensemble\n+     * @return list of bookies forming the ensemble\n+     * @throws BKException.BKNotEnoughBookiesException\n+     */\n+    ArrayList<BookieSocketAddress> newEnsemble(\n+            int ensembleSize,\n+            int writeQuorumSize,\n+            int ackQuorumSize,\n+            Set<BookieSocketAddress> excludeBookies,\n+            Ensemble<T> parentEnsemble,\n+            Predicate<T> parentPredicate)\n+            throws BKException.BKNotEnoughBookiesException;\n+\n+    /**\n+     * Select a node from a given network location.\n+     *\n+     * @param networkLoc\n+     *          network location\n+     * @param excludeBookies\n+     *          exclude bookies set\n+     * @param predicate\n+     *          predicate to apply\n+     * @param ensemble\n+     *          ensemble\n+     * @return the selected bookie.\n+     * @throws BKException.BKNotEnoughBookiesException\n+     */\n+    T selectFromNetworkLocation(String networkLoc,\n+                                Set<Node> excludeBookies,\n+                                Predicate<T> predicate,\n+                                Ensemble<T> ensemble)\n+            throws BKException.BKNotEnoughBookiesException;\n+\n+    /**\n+     * Handle bookies that left.\n+     *\n+     * @param leftBookies\n+     *          bookies that left\n+     */\n+    void handleBookiesThatLeft(Set<BookieSocketAddress> leftBookies);\n+\n+    /**\n+     * Handle bookies that joined\n+     *\n+     * @param joinedBookies\n+     *          bookies that joined.\n+     */\n+    void handleBookiesThatJoined(Set<BookieSocketAddress> joinedBookies);\n+}"},{"sha":"e88df3194d38a732a9a73170c23fba668f2e07b4","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerCreateOp.java","status":"modified","additions":3,"deletions":1,"changes":4,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/bbd1eb8d8560b03834175fbd996b85237df09f5c/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FLedgerCreateOp.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/bbd1eb8d8560b03834175fbd996b85237df09f5c/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FLedgerCreateOp.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FLedgerCreateOp.java?ref=bbd1eb8d8560b03834175fbd996b85237df09f5c","patch":"@@ -105,7 +105,9 @@ public void initiate() {\n         ArrayList<BookieSocketAddress> ensemble;\n         try {\n             ensemble = bk.bookieWatcher\n-                    .newEnsemble(metadata.getEnsembleSize(), metadata.getWriteQuorumSize());\n+                    .newEnsemble(metadata.getEnsembleSize(),\n+                            metadata.getWriteQuorumSize(),\n+                            metadata.getAckQuorumSize());\n         } catch (BKNotEnoughBookiesException e) {\n             LOG.error(\"Not enough bookies to create ledger\");\n             createComplete(e.getCode(), null);"},{"sha":"06f84eb9d3ca3e2e94d2f941b0709574c8e19063","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","status":"modified","additions":7,"deletions":2,"changes":9,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/bbd1eb8d8560b03834175fbd996b85237df09f5c/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FLedgerHandle.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/bbd1eb8d8560b03834175fbd996b85237df09f5c/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FLedgerHandle.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FLedgerHandle.java?ref=bbd1eb8d8560b03834175fbd996b85237df09f5c","patch":"@@ -26,6 +26,7 @@\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Enumeration;\n+import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Queue;\n@@ -1005,9 +1006,13 @@ ArrayList<BookieSocketAddress> replaceBookieInMetadata(final BookieSocketAddress\n \n         // avoid parallel ensemble changes to same ensemble.\n         synchronized (metadata) {\n-            newBookie = bk.bookieWatcher.replaceBookie(metadata.currentEnsemble, bookieIndex);\n-\n             newEnsemble.addAll(metadata.currentEnsemble);\n+            newBookie = bk.bookieWatcher.replaceBookie(metadata.getEnsembleSize(),\n+                    metadata.getWriteQuorumSize(),\n+                    metadata.getAckQuorumSize(), newEnsemble,\n+                    bookieIndex, new HashSet<>(Arrays.asList(addr)));\n+\n+\n             newEnsemble.set(bookieIndex, newBookie);\n \n             if (LOG.isDebugEnabled()) {"},{"sha":"f42e42a747b5e7579d5e9dd7e1c85b2db19352e9","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/RackawareEnsemblePlacementPolicy.java","status":"modified","additions":115,"deletions":494,"changes":609,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/bbd1eb8d8560b03834175fbd996b85237df09f5c/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FRackawareEnsemblePlacementPolicy.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/bbd1eb8d8560b03834175fbd996b85237df09f5c/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FRackawareEnsemblePlacementPolicy.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FRackawareEnsemblePlacementPolicy.java?ref=bbd1eb8d8560b03834175fbd996b85237df09f5c","patch":"@@ -17,556 +17,177 @@\n  */\n package org.apache.bookkeeper.client;\n \n-import java.net.InetAddress;\n-import java.net.UnknownHostException;\n import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.HashSet;\n+import java.util.Collection;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n-import java.util.concurrent.locks.ReentrantReadWriteLock;\n \n import org.apache.bookkeeper.client.BKException.BKNotEnoughBookiesException;\n-import org.apache.bookkeeper.conf.Configurable;\n import org.apache.bookkeeper.net.BookieSocketAddress;\n-import org.apache.bookkeeper.net.CachedDNSToSwitchMapping;\n import org.apache.bookkeeper.net.DNSToSwitchMapping;\n-import org.apache.bookkeeper.net.NetworkTopology;\n import org.apache.bookkeeper.net.Node;\n-import org.apache.bookkeeper.net.NodeBase;\n-import org.apache.bookkeeper.net.ScriptBasedMapping;\n-import org.apache.bookkeeper.util.ReflectionUtils;\n-import org.apache.commons.configuration.Configuration;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n+import org.apache.bookkeeper.stats.StatsLogger;\n+import org.jboss.netty.util.HashedWheelTimer;\n \n-import com.google.common.collect.ImmutableSet;\n-import com.google.common.collect.Sets;\n+public class RackawareEnsemblePlacementPolicy extends RackawareEnsemblePlacementPolicyImpl\n+        implements ITopologyAwareEnsemblePlacementPolicy<TopologyAwareEnsemblePlacementPolicy.BookieNode> {\n \n-/**\n- * Simple rackware ensemble placement policy.\n- *\n- * Make most of the class and methods as protected, so it could be extended to implement other algorithms.\n- */\n-public class RackawareEnsemblePlacementPolicy implements EnsemblePlacementPolicy {\n-\n-    static final Logger LOG = LoggerFactory.getLogger(RackawareEnsemblePlacementPolicy.class);\n-\n-    public static final String REPP_DNS_RESOLVER_CLASS = \"reppDnsResolverClass\";\n-\n-    /**\n-     * Predicate used when choosing an ensemble.\n-     */\n-    protected static interface Predicate {\n-        boolean apply(BookieNode candidate, Ensemble chosenBookies);\n-    }\n-\n-    /**\n-     * Ensemble used to hold the result of an ensemble selected for placement.\n-     */\n-    protected static interface Ensemble {\n-\n-        /**\n-         * Append the new bookie node to the ensemble.\n-         *\n-         * @param node\n-         *          new candidate bookie node.\n-         */\n-        public void addBookie(BookieNode node);\n+    RackawareEnsemblePlacementPolicyImpl slave = null;\n \n-        /**\n-         * @return list of addresses representing the ensemble\n-         */\n-        public ArrayList<BookieSocketAddress> toList();\n+    RackawareEnsemblePlacementPolicy() {\n+        super();\n     }\n \n-    protected static class TruePredicate implements Predicate {\n-\n-        public static final TruePredicate instance = new TruePredicate();\n-\n-        @Override\n-        public boolean apply(BookieNode candidate, Ensemble chosenNodes) {\n-            return true;\n-        }\n-\n+    RackawareEnsemblePlacementPolicy(boolean enforceDurability) {\n+        super(enforceDurability);\n     }\n \n-    protected static class EnsembleForReplacement implements Ensemble {\n-\n-        public static final EnsembleForReplacement instance = new EnsembleForReplacement();\n-        static final ArrayList<BookieSocketAddress> EMPTY_LIST = new ArrayList<BookieSocketAddress>(0);\n-\n-        @Override\n-        public void addBookie(BookieNode node) {\n-            // do nothing\n-        }\n-\n-        @Override\n-        public ArrayList<BookieSocketAddress> toList() {\n-            return EMPTY_LIST;\n+    @Override\n+    protected RackawareEnsemblePlacementPolicy initialize(DNSToSwitchMapping dnsResolver,\n+                                                          HashedWheelTimer timer,\n+                                                          boolean reorderReadsRandom,\n+                                                          int stabilizePeriodSeconds,\n+                                                          StatsLogger statsLogger) {\n+        if (stabilizePeriodSeconds > 0) {\n+            super.initialize(dnsResolver, timer, reorderReadsRandom, 0, statsLogger);\n+            slave = new RackawareEnsemblePlacementPolicyImpl(enforceDurability);\n+            slave.initialize(dnsResolver, timer, reorderReadsRandom, stabilizePeriodSeconds, statsLogger);\n+        } else {\n+            super.initialize(dnsResolver, timer, reorderReadsRandom, stabilizePeriodSeconds, statsLogger);\n+            slave = null;\n         }\n-\n+        return this;\n     }\n \n-    /**\n-     * A predicate checking the rack coverage for write quorum in {@link RoundRobinDistributionSchedule},\n-     * which ensures that a write quorum should be covered by at least two racks.\n-     */\n-    protected static class RRRackCoverageEnsemble implements Predicate, Ensemble {\n-\n-        class QuorumCoverageSet {\n-            Set<String> racks = new HashSet<String>();\n-            int seenBookies = 0;\n-\n-            boolean apply(BookieNode candidate) {\n-                if (seenBookies + 1 == writeQuorumSize) {\n-                    return racks.size() > (racks.contains(candidate.getNetworkLocation()) ? 1 : 0);\n-                }\n-                return true;\n-            }\n-\n-            void addBookie(BookieNode candidate) {\n-                ++seenBookies;\n-                racks.add(candidate.getNetworkLocation());\n-            }\n-        }\n-\n-        final int ensembleSize;\n-        final int writeQuorumSize;\n-        final ArrayList<BookieNode> chosenNodes;\n-        private final QuorumCoverageSet[] quorums;\n-\n-        protected RRRackCoverageEnsemble(int ensembleSize, int writeQuorumSize) {\n-            this.ensembleSize = ensembleSize;\n-            this.writeQuorumSize = writeQuorumSize;\n-            this.chosenNodes = new ArrayList<BookieNode>(ensembleSize);\n-            this.quorums = new QuorumCoverageSet[ensembleSize];\n-        }\n-\n-        @Override\n-        public boolean apply(BookieNode candidate, Ensemble ensemble) {\n-            if (ensemble != this) {\n-                return false;\n-            }\n-            // candidate position\n-            int candidatePos = chosenNodes.size();\n-            int startPos = candidatePos - writeQuorumSize + 1;\n-            for (int i = startPos; i <= candidatePos; i++) {\n-                int idx = (i + ensembleSize) % ensembleSize;\n-                if (null == quorums[idx]) {\n-                    quorums[idx] = new QuorumCoverageSet();\n-                }\n-                if (!quorums[idx].apply(candidate)) {\n-                    return false;\n-                }\n-            }\n-            return true;\n-        }\n-\n-        @Override\n-        public void addBookie(BookieNode node) {\n-            int candidatePos = chosenNodes.size();\n-            int startPos = candidatePos - writeQuorumSize + 1;\n-            for (int i = startPos; i <= candidatePos; i++) {\n-                int idx = (i + ensembleSize) % ensembleSize;\n-                if (null == quorums[idx]) {\n-                    quorums[idx] = new QuorumCoverageSet();\n-                }\n-                quorums[idx].addBookie(node);\n-            }\n-            chosenNodes.add(node);\n-        }\n-\n-        @Override\n-        public ArrayList<BookieSocketAddress> toList() {\n-            ArrayList<BookieSocketAddress> addresses = new ArrayList<BookieSocketAddress>(ensembleSize);\n-            for (BookieNode bn : chosenNodes) {\n-                addresses.add(bn.getAddr());\n-            }\n-            return addresses;\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return chosenNodes.toString();\n+    @Override\n+    public void uninitalize() {\n+        super.uninitalize();\n+        if (null != slave) {\n+            slave.uninitalize();\n         }\n-\n     }\n \n-    protected static class BookieNode implements Node {\n-\n-        private final BookieSocketAddress addr; // identifier of a bookie node.\n-\n-        private int level; // the level in topology tree\n-        private Node parent; // its parent in topology tree\n-        private String location = NetworkTopology.DEFAULT_RACK; // its network location\n-        private final String name;\n-\n-        BookieNode(BookieSocketAddress addr, String networkLoc) {\n-            this.addr = addr;\n-            this.name = addr.toString();\n-            setNetworkLocation(networkLoc);\n-        }\n-\n-        public BookieSocketAddress getAddr() {\n-            return addr;\n-        }\n-\n-        @Override\n-        public int getLevel() {\n-            return level;\n-        }\n-\n-        @Override\n-        public void setLevel(int level) {\n-            this.level = level;\n-        }\n-\n-        @Override\n-        public Node getParent() {\n-            return parent;\n-        }\n-\n-        @Override\n-        public void setParent(Node parent) {\n-            this.parent = parent;\n-        }\n-\n-        @Override\n-        public String getName() {\n-            return name;\n-        }\n-\n-        @Override\n-        public String getNetworkLocation() {\n-            return location;\n-        }\n-\n-        @Override\n-        public void setNetworkLocation(String location) {\n-            this.location = location;\n-        }\n-\n-        @Override\n-        public int hashCode() {\n-            return name.hashCode();\n-        }\n-\n-        @Override\n-        public boolean equals(Object obj) {\n-            if (!(obj instanceof BookieNode)) {\n-                return false;\n-            }\n-            BookieNode other = (BookieNode) obj;\n-            return getName().equals(other.getName());\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return String.format(\"<Bookie:%s>\", name);\n+    @Override\n+    public Set<BookieSocketAddress> onClusterChanged(Set<BookieSocketAddress> writableBookies, Set<BookieSocketAddress> readOnlyBookies) {\n+        Set<BookieSocketAddress> deadBookies = super.onClusterChanged(writableBookies, readOnlyBookies);\n+        if (null != slave) {\n+            deadBookies = slave.onClusterChanged(writableBookies, readOnlyBookies);\n         }\n-\n+        return deadBookies;\n     }\n \n-    static class DefaultResolver implements DNSToSwitchMapping {\n-\n-        @Override\n-        public List<String> resolve(List<String> names) {\n-            List<String> rNames = new ArrayList<String>(names.size());\n-            for (@SuppressWarnings(\"unused\") String name : names) {\n-                rNames.add(NetworkTopology.DEFAULT_RACK);\n+    @Override\n+    public ArrayList<BookieSocketAddress> newEnsemble(\n+            int ensembleSize,\n+            int writeQuorumSize,\n+            int ackQuorumSize,\n+            Set<BookieSocketAddress> excludeBookies)\n+            throws BKException.BKNotEnoughBookiesException {\n+        try {\n+            return super.newEnsemble(ensembleSize, writeQuorumSize, ackQuorumSize, excludeBookies);\n+        } catch (BKException.BKNotEnoughBookiesException bnebe) {\n+            if (slave == null) {\n+                throw bnebe;\n+            } else {\n+                return slave.newEnsemble(ensembleSize, writeQuorumSize, ackQuorumSize, excludeBookies);\n             }\n-            return rNames;\n         }\n-\n-        @Override\n-        public void reloadCachedMappings() {\n-            // nop\n-        }\n-\n-    };\n-\n-    // for now, we just maintain the writable bookies' topology\n-    private final NetworkTopology topology;\n-    private DNSToSwitchMapping dnsResolver;\n-    private final Map<BookieSocketAddress, BookieNode> knownBookies;\n-    private BookieNode localNode;\n-    private final ReentrantReadWriteLock rwLock;\n-\n-    public RackawareEnsemblePlacementPolicy() {\n-        topology = new NetworkTopology();\n-        knownBookies = new HashMap<BookieSocketAddress, BookieNode>();\n-\n-        rwLock = new ReentrantReadWriteLock();\n-    }\n-\n-    private BookieNode createBookieNode(BookieSocketAddress addr) {\n-        return new BookieNode(addr, resolveNetworkLocation(addr));\n     }\n \n     @Override\n-    public EnsemblePlacementPolicy initialize(Configuration conf) {\n-        String dnsResolverName = conf.getString(REPP_DNS_RESOLVER_CLASS, ScriptBasedMapping.class.getName());\n+    public BookieSocketAddress replaceBookie(\n+            int ensembleSize,\n+            int writeQuorumSize,\n+            int ackQuorumSize,\n+            Collection<BookieSocketAddress> currentEnsemble,\n+            BookieSocketAddress bookieToReplace,\n+            Set<BookieSocketAddress> excludeBookies)\n+            throws BKException.BKNotEnoughBookiesException {\n         try {\n-            dnsResolver = ReflectionUtils.newInstance(dnsResolverName, DNSToSwitchMapping.class);\n-            if (dnsResolver instanceof Configurable) {\n-                ((Configurable) dnsResolver).setConf(conf);\n+            return super.replaceBookie(ensembleSize, writeQuorumSize, ackQuorumSize,\n+                    currentEnsemble, bookieToReplace, excludeBookies);\n+        } catch (BKException.BKNotEnoughBookiesException bnebe) {\n+            if (slave == null) {\n+                throw bnebe;\n+            } else {\n+                return slave.replaceBookie(ensembleSize, writeQuorumSize, ackQuorumSize,\n+                        currentEnsemble, bookieToReplace, excludeBookies);\n             }\n-        } catch (RuntimeException re) {\n-            LOG.info(\"Failed to initialize DNS Resolver {}, used default subnet resolver.\", dnsResolverName, re);\n-            dnsResolver = new DefaultResolver();\n         }\n-\n-        BookieNode bn;\n-        try {\n-            bn = createBookieNode(new BookieSocketAddress(InetAddress.getLocalHost().getHostAddress(), 0));\n-        } catch (UnknownHostException e) {\n-            LOG.error(\"Failed to get local host address : \", e);\n-            bn = null;\n-        }\n-        localNode = bn;\n-        LOG.info(\"Initialize rackaware ensemble placement policy @ {} : {}.\", localNode,\n-                dnsResolver.getClass().getName());\n-        return this;\n     }\n \n     @Override\n-    public void uninitalize() {\n-        // do nothing\n-    }\n-\n-    private String resolveNetworkLocation(BookieSocketAddress addr) {\n-        List<String> names = new ArrayList<String>(1);\n-        if (dnsResolver instanceof CachedDNSToSwitchMapping) {\n-            names.add(addr.getSocketAddress().getAddress().getHostAddress());\n-        } else {\n-            names.add(addr.getSocketAddress().getHostName());\n-        }\n-        // resolve network addresses\n-        List<String> rNames = dnsResolver.resolve(names);\n-        String netLoc;\n-        if (null == rNames) {\n-            LOG.warn(\"Failed to resolve network location for {}, using default rack for them : {}.\", names,\n-                    NetworkTopology.DEFAULT_RACK);\n-            netLoc = NetworkTopology.DEFAULT_RACK;\n-        } else {\n-            netLoc = rNames.get(0);\n-        }\n-        return netLoc;\n+    public List<Integer> reorderReadSequence(ArrayList<BookieSocketAddress> ensemble,\n+                                             List<Integer> writeSet,\n+                                             Map<BookieSocketAddress, Long> bookieFailureHistory) {\n+        return super.reorderReadSequence(ensemble, writeSet, bookieFailureHistory);\n     }\n \n     @Override\n-    public Set<BookieSocketAddress> onClusterChanged(Set<BookieSocketAddress> writableBookies,\n-            Set<BookieSocketAddress> readOnlyBookies) {\n-        rwLock.writeLock().lock();\n-        try {\n-            ImmutableSet<BookieSocketAddress> joinedBookies, leftBookies, deadBookies;\n-            Set<BookieSocketAddress> oldBookieSet = knownBookies.keySet();\n-            // left bookies : bookies in known bookies, but not in new writable bookie cluster.\n-            leftBookies = Sets.difference(oldBookieSet, writableBookies).immutableCopy();\n-            // joined bookies : bookies in new writable bookie cluster, but not in known bookies\n-            joinedBookies = Sets.difference(writableBookies, oldBookieSet).immutableCopy();\n-            // dead bookies.\n-            deadBookies = Sets.difference(leftBookies, readOnlyBookies).immutableCopy();\n-            if (LOG.isDebugEnabled()) {\n-                LOG.debug(\n-                        \"Cluster changed : left bookies are {}, joined bookies are {}, while dead bookies are {}.\",\n-                        new Object[] { leftBookies, joinedBookies, deadBookies });\n-            }\n-\n-            // node left\n-            for (BookieSocketAddress addr : leftBookies) {\n-                BookieNode node = knownBookies.remove(addr);\n-                topology.remove(node);\n-                if (LOG.isDebugEnabled()) {\n-                    LOG.debug(\"Cluster changed : bookie {} left from cluster.\", addr);\n-                }\n-            }\n-\n-            // node joined\n-            for (BookieSocketAddress addr : joinedBookies) {\n-                BookieNode node = createBookieNode(addr);\n-                topology.add(node);\n-                knownBookies.put(addr, node);\n-                if (LOG.isDebugEnabled()) {\n-                    LOG.debug(\"Cluster changed : bookie {} joined the cluster.\", addr);\n-                }\n-            }\n-\n-            return deadBookies;\n-        } finally {\n-            rwLock.writeLock().unlock();\n-        }\n-    }\n-\n-    private Set<Node> convertBookiesToNodes(Set<BookieSocketAddress> excludeBookies) {\n-        Set<Node> nodes = new HashSet<Node>();\n-        for (BookieSocketAddress addr : excludeBookies) {\n-            BookieNode bn = knownBookies.get(addr);\n-            if (null == bn) {\n-                bn = createBookieNode(addr);\n-            }\n-            nodes.add(bn);\n-        }\n-        return nodes;\n+    public List<Integer> reorderReadLACSequence(ArrayList<BookieSocketAddress> ensemble,\n+                                                List<Integer> writeSet,\n+                                                Map<BookieSocketAddress, Long> bookieFailureHistory) {\n+        return super.reorderReadLACSequence(ensemble, writeSet, bookieFailureHistory);\n     }\n \n     @Override\n-    public ArrayList<BookieSocketAddress> newEnsemble(int ensembleSize, int writeQuorumSize,\n-            Set<BookieSocketAddress> excludeBookies) throws BKNotEnoughBookiesException {\n-        rwLock.readLock().lock();\n+    public ArrayList<BookieSocketAddress> newEnsemble(int ensembleSize,\n+                                                    int writeQuorumSize,\n+                                                    int ackQuorumSize,\n+                                                    Set<BookieSocketAddress> excludeBookies,\n+                                                    Ensemble<BookieNode> parentEnsemble,\n+                                                    Predicate<BookieNode> parentPredicate)\n+            throws BKException.BKNotEnoughBookiesException {\n         try {\n-            Set<Node> excludeNodes = convertBookiesToNodes(excludeBookies);\n-            RRRackCoverageEnsemble ensemble = new RRRackCoverageEnsemble(ensembleSize, writeQuorumSize);\n-            BookieNode prevNode = null;\n-            int numRacks = topology.getNumOfRacks();\n-            // only one rack, use the random algorithm.\n-            if (numRacks < 2) {\n-                List<BookieNode> bns = selectRandom(ensembleSize, excludeNodes,\n-                        EnsembleForReplacement.instance);\n-                ArrayList<BookieSocketAddress> addrs = new ArrayList<BookieSocketAddress>(ensembleSize);\n-                for (BookieNode bn : bns) {\n-                    addrs.add(bn.addr);\n-                }\n-                return addrs;\n+            return super.newEnsemble(\n+                    ensembleSize,\n+                    writeQuorumSize,\n+                    ackQuorumSize,\n+                    excludeBookies,\n+                    parentEnsemble,\n+                    parentPredicate);\n+        } catch (BKException.BKNotEnoughBookiesException bnebe) {\n+            if (slave == null) {\n+                throw bnebe;\n+            } else {\n+                return slave.newEnsemble(ensembleSize, writeQuorumSize, ackQuorumSize,\n+                        excludeBookies, parentEnsemble, parentPredicate);\n             }\n-            // pick nodes by racks, to ensure there is at least two racks per write quorum.\n-            for (int i = 0; i < ensembleSize; i++) {\n-                String curRack;\n-                if (null == prevNode) {\n-                    if (null == localNode) {\n-                        curRack = NodeBase.ROOT;\n-                    } else {\n-                        curRack = localNode.getNetworkLocation();\n-                    }\n-                } else {\n-                    curRack = \"~\" + prevNode.getNetworkLocation();\n-                }\n-                prevNode = selectFromRack(curRack, excludeNodes, ensemble, ensemble);\n-            }\n-            return ensemble.toList();\n-        } finally {\n-            rwLock.readLock().unlock();\n         }\n     }\n \n     @Override\n-    public BookieSocketAddress replaceBookie(BookieSocketAddress bookieToReplace,\n-            Set<BookieSocketAddress> excludeBookies) throws BKNotEnoughBookiesException {\n-        rwLock.readLock().lock();\n+    public BookieNode selectFromNetworkLocation(\n+            String networkLoc,\n+            Set<Node> excludeBookies,\n+            Predicate<BookieNode> predicate,\n+            Ensemble<BookieNode> ensemble)\n+            throws BKException.BKNotEnoughBookiesException {\n         try {\n-            BookieNode bn = knownBookies.get(bookieToReplace);\n-            if (null == bn) {\n-                bn = createBookieNode(bookieToReplace);\n-            }\n-\n-            Set<Node> excludeNodes = convertBookiesToNodes(excludeBookies);\n-            // add the bookie to replace in exclude set\n-            excludeNodes.add(bn);\n-            if (LOG.isDebugEnabled()) {\n-                LOG.debug(\"Try to choose a new bookie to replace {}, excluding {}.\", bookieToReplace,\n-                        excludeNodes);\n+            return super.selectFromNetworkLocation(networkLoc, excludeBookies, predicate, ensemble);\n+        } catch (BKException.BKNotEnoughBookiesException bnebe) {\n+            if (slave == null) {\n+                throw bnebe;\n+            } else {\n+                return slave.selectFromNetworkLocation(networkLoc, excludeBookies, predicate, ensemble);\n             }\n-            // pick a candidate from same rack to replace\n-            BookieNode candidate = selectFromRack(bn.getNetworkLocation(), excludeNodes,\n-                    TruePredicate.instance, EnsembleForReplacement.instance);\n-            if (LOG.isDebugEnabled()) {\n-                LOG.debug(\"Bookie {} is chosen to replace bookie {}.\", candidate, bn);\n-            }\n-            return candidate.addr;\n-        } finally {\n-            rwLock.readLock().unlock();\n-        }\n-    }\n-\n-    protected BookieNode selectFromRack(String networkLoc, Set<Node> excludeBookies, Predicate predicate,\n-            Ensemble ensemble) throws BKNotEnoughBookiesException {\n-        // select one from local rack\n-        try {\n-            return selectRandomFromRack(networkLoc, excludeBookies, predicate, ensemble);\n-        } catch (BKNotEnoughBookiesException e) {\n-            LOG.warn(\"Failed to choose a bookie from {} : \"\n-                     + \"excluded {}, fallback to choose bookie randomly from the cluster.\",\n-                     networkLoc, excludeBookies);\n-            // randomly choose one from whole cluster, ignore the provided predicate.\n-            return selectRandom(1, excludeBookies, ensemble).get(0);\n         }\n     }\n \n-    protected String getRemoteRack(BookieNode node) {\n-        return \"~\" + node.getNetworkLocation();\n-    }\n-\n-    /**\n-     * Choose random node under a given network path.\n-     *\n-     * @param netPath\n-     *          network path\n-     * @param excludeBookies\n-     *          exclude bookies\n-     * @param predicate\n-     *          predicate to check whether the target is a good target.\n-     * @param ensemble\n-     *          ensemble structure\n-     * @return chosen bookie.\n-     */\n-    protected BookieNode selectRandomFromRack(String netPath, Set<Node> excludeBookies, Predicate predicate,\n-            Ensemble ensemble) throws BKNotEnoughBookiesException {\n-        List<Node> leaves = new ArrayList<Node>(topology.getLeaves(netPath));\n-        Collections.shuffle(leaves);\n-        for (Node n : leaves) {\n-            if (excludeBookies.contains(n)) {\n-                continue;\n-            }\n-            if (!(n instanceof BookieNode) || !predicate.apply((BookieNode) n, ensemble)) {\n-                continue;\n-            }\n-            BookieNode bn = (BookieNode) n;\n-            // got a good candidate\n-            ensemble.addBookie(bn);\n-            // add the candidate to exclude set\n-            excludeBookies.add(bn);\n-            return bn;\n+    @Override\n+    public void handleBookiesThatLeft(Set<BookieSocketAddress> leftBookies) {\n+        super.handleBookiesThatLeft(leftBookies);\n+        if (null != slave) {\n+            slave.handleBookiesThatLeft(leftBookies);\n         }\n-        throw new BKNotEnoughBookiesException();\n     }\n \n-    /**\n-     * Choose a random node from whole cluster.\n-     *\n-     * @param numBookies\n-     *          number bookies to choose\n-     * @param excludeBookies\n-     *          bookies set to exclude.\n-     * @param ensemble\n-     *          ensemble to hold the bookie chosen.\n-     * @return the bookie node chosen.\n-     * @throws BKNotEnoughBookiesException\n-     */\n-    protected List<BookieNode> selectRandom(int numBookies, Set<Node> excludeBookies, Ensemble ensemble)\n-            throws BKNotEnoughBookiesException {\n-        List<BookieNode> allBookies = new ArrayList<BookieNode>(knownBookies.values());\n-        Collections.shuffle(allBookies);\n-        List<BookieNode> newBookies = new ArrayList<BookieNode>(numBookies);\n-        for (BookieNode bookie : allBookies) {\n-            if (excludeBookies.contains(bookie)) {\n-                continue;\n-            }\n-            ensemble.addBookie(bookie);\n-            excludeBookies.add(bookie);\n-            newBookies.add(bookie);\n-            --numBookies;\n-            if (numBookies == 0) {\n-                return newBookies;\n-            }\n-        }\n-        if (LOG.isDebugEnabled()) {\n-            LOG.debug(\"Failed to find {} bookies : excludeBookies {}, allBookies {}.\", new Object[] {\n-                    numBookies, excludeBookies, allBookies });\n+    @Override\n+    public void handleBookiesThatJoined(Set<BookieSocketAddress> joinedBookies) {\n+        super.handleBookiesThatJoined(joinedBookies);\n+        if (null != slave) {\n+            slave.handleBookiesThatJoined(joinedBookies);\n         }\n-        throw new BKNotEnoughBookiesException();\n     }\n-\n }"},{"sha":"3c41a7c7a9d42227153cc23ed41e3e8f0b996af4","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/RackawareEnsemblePlacementPolicyImpl.java","status":"added","additions":554,"deletions":0,"changes":554,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/bbd1eb8d8560b03834175fbd996b85237df09f5c/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FRackawareEnsemblePlacementPolicyImpl.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/bbd1eb8d8560b03834175fbd996b85237df09f5c/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FRackawareEnsemblePlacementPolicyImpl.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FRackawareEnsemblePlacementPolicyImpl.java?ref=bbd1eb8d8560b03834175fbd996b85237df09f5c","patch":"@@ -0,0 +1,554 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.bookkeeper.client;\n+\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import org.apache.bookkeeper.client.BKException.BKNotEnoughBookiesException;\n+import org.apache.bookkeeper.conf.ClientConfiguration;\n+import org.apache.bookkeeper.conf.Configurable;\n+import org.apache.bookkeeper.feature.FeatureProvider;\n+import org.apache.bookkeeper.net.BookieSocketAddress;\n+import org.apache.bookkeeper.net.DNSToSwitchMapping;\n+import org.apache.bookkeeper.net.NetUtils;\n+import org.apache.bookkeeper.net.NetworkTopology;\n+import org.apache.bookkeeper.net.NetworkTopologyImpl;\n+import org.apache.bookkeeper.net.Node;\n+import org.apache.bookkeeper.net.NodeBase;\n+import org.apache.bookkeeper.net.ScriptBasedMapping;\n+import org.apache.bookkeeper.net.StabilizeNetworkTopology;\n+import org.apache.bookkeeper.stats.StatsLogger;\n+import org.apache.bookkeeper.util.ReflectionUtils;\n+import org.jboss.netty.util.HashedWheelTimer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.base.Optional;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Sets;\n+\n+/**\n+ * Simple rackware ensemble placement policy.\n+ *\n+ * Make most of the class and methods as protected, so it could be extended to implement other algorithms.\n+ */\n+class RackawareEnsemblePlacementPolicyImpl extends TopologyAwareEnsemblePlacementPolicy {\n+\n+    static final Logger LOG = LoggerFactory.getLogger(RackawareEnsemblePlacementPolicyImpl.class);\n+\n+    public static final String REPP_DNS_RESOLVER_CLASS = \"reppDnsResolverClass\";\n+    public static final String REPP_RANDOM_READ_REORDERING = \"ensembleRandomReadReordering\";\n+\n+    static final int RACKNAME_DISTANCE_FROM_LEAVES = 1;\n+\n+    static class DefaultResolver implements DNSToSwitchMapping {\n+\n+        @Override\n+        public List<String> resolve(List<String> names) {\n+            List<String> rNames = new ArrayList<String>(names.size());\n+            for (@SuppressWarnings(\"unused\") String name : names) {\n+                rNames.add(NetworkTopology.DEFAULT_RACK);\n+            }\n+            return rNames;\n+        }\n+\n+        @Override\n+        public void reloadCachedMappings() {\n+            // nop\n+        }\n+\n+    }\n+\n+    // for now, we just maintain the writable bookies' topology\n+    protected NetworkTopology topology;\n+    protected DNSToSwitchMapping dnsResolver;\n+    protected HashedWheelTimer timer;\n+    protected final Map<BookieSocketAddress, BookieNode> knownBookies;\n+    protected BookieNode localNode;\n+    protected final ReentrantReadWriteLock rwLock;\n+    protected ImmutableSet<BookieSocketAddress> readOnlyBookies = null;\n+    protected boolean reorderReadsRandom = false;\n+    protected boolean enforceDurability = false;\n+    protected int stabilizePeriodSeconds = 0;\n+    protected StatsLogger statsLogger = null;\n+\n+    RackawareEnsemblePlacementPolicyImpl() {\n+        this(false);\n+    }\n+\n+    RackawareEnsemblePlacementPolicyImpl(boolean enforceDurability) {\n+        this.enforceDurability = enforceDurability;\n+        topology = new NetworkTopologyImpl();\n+        knownBookies = new HashMap<BookieSocketAddress, BookieNode>();\n+\n+        rwLock = new ReentrantReadWriteLock();\n+    }\n+\n+    protected BookieNode createBookieNode(BookieSocketAddress addr) {\n+        return new BookieNode(addr, resolveNetworkLocation(addr));\n+    }\n+\n+    /**\n+     * Initialize the policy.\n+     *\n+     * @param dnsResolver the object used to resolve addresses to their network address\n+     * @return initialized ensemble placement policy\n+     */\n+    protected RackawareEnsemblePlacementPolicyImpl initialize(DNSToSwitchMapping dnsResolver,\n+                                                              HashedWheelTimer timer,\n+                                                              boolean reorderReadsRandom,\n+                                                              int stabilizePeriodSeconds,\n+                                                              StatsLogger statsLogger) {\n+        this.statsLogger = statsLogger;\n+        this.reorderReadsRandom = reorderReadsRandom;\n+        this.stabilizePeriodSeconds = stabilizePeriodSeconds;\n+        this.dnsResolver = dnsResolver;\n+        this.timer = timer;\n+\n+        // create the network topology\n+        if (stabilizePeriodSeconds > 0) {\n+            this.topology = new StabilizeNetworkTopology(timer, stabilizePeriodSeconds);\n+        } else {\n+            this.topology = new NetworkTopologyImpl();\n+        }\n+\n+        BookieNode bn;\n+        try {\n+            bn = createBookieNode(new BookieSocketAddress(InetAddress.getLocalHost().getHostAddress(), 0));\n+        } catch (UnknownHostException e) {\n+            LOG.error(\"Failed to get local host address : \", e);\n+            bn = null;\n+        }\n+        localNode = bn;\n+        LOG.info(\"Initialize rackaware ensemble placement policy @ {} @ {} : {}.\",\n+            new Object[] { localNode, null == localNode ? \"Unknown\" : localNode.getNetworkLocation(),\n+                dnsResolver.getClass().getName() });\n+        return this;\n+    }\n+\n+    @Override\n+    public RackawareEnsemblePlacementPolicyImpl initialize(ClientConfiguration conf,\n+                                                           Optional<DNSToSwitchMapping> optionalDnsResolver,\n+                                                           HashedWheelTimer timer,\n+                                                           FeatureProvider featureProvider,\n+                                                           StatsLogger statsLogger) {\n+        DNSToSwitchMapping dnsResolver;\n+        if (optionalDnsResolver.isPresent()) {\n+            dnsResolver = optionalDnsResolver.get();\n+        } else {\n+            String dnsResolverName = conf.getString(REPP_DNS_RESOLVER_CLASS, ScriptBasedMapping.class.getName());\n+            try {\n+                dnsResolver = ReflectionUtils.newInstance(dnsResolverName, DNSToSwitchMapping.class);\n+                if (dnsResolver instanceof Configurable) {\n+                    ((Configurable) dnsResolver).setConf(conf);\n+                }\n+            } catch (RuntimeException re) {\n+                LOG.info(\"Failed to initialize DNS Resolver {}, used default subnet resolver.\", dnsResolverName, re);\n+                dnsResolver = new DefaultResolver();\n+            }\n+        }\n+        return initialize(\n+                dnsResolver,\n+                timer,\n+                conf.getBoolean(REPP_RANDOM_READ_REORDERING, false),\n+                conf.getNetworkTopologyStabilizePeriodSeconds(),\n+                statsLogger);\n+    }\n+\n+    @Override\n+    public void uninitalize() {\n+        // do nothing\n+    }\n+\n+    protected String resolveNetworkLocation(BookieSocketAddress addr) {\n+        return NetUtils.resolveNetworkLocation(dnsResolver, addr.getSocketAddress());\n+    }\n+\n+    @Override\n+    public Set<BookieSocketAddress> onClusterChanged(Set<BookieSocketAddress> writableBookies,\n+            Set<BookieSocketAddress> readOnlyBookies) {\n+        rwLock.writeLock().lock();\n+        try {\n+            ImmutableSet<BookieSocketAddress> joinedBookies, leftBookies, deadBookies;\n+            Set<BookieSocketAddress> oldBookieSet = knownBookies.keySet();\n+            // left bookies : bookies in known bookies, but not in new writable bookie cluster.\n+            leftBookies = Sets.difference(oldBookieSet, writableBookies).immutableCopy();\n+            // joined bookies : bookies in new writable bookie cluster, but not in known bookies\n+            joinedBookies = Sets.difference(writableBookies, oldBookieSet).immutableCopy();\n+            // dead bookies.\n+            deadBookies = Sets.difference(leftBookies, readOnlyBookies).immutableCopy();\n+            if (LOG.isDebugEnabled()) {\n+                LOG.debug(\n+                        \"Cluster changed : left bookies are {}, joined bookies are {}, while dead bookies are {}.\",\n+                        new Object[] { leftBookies, joinedBookies, deadBookies });\n+            }\n+            handleBookiesThatLeft(leftBookies);\n+            handleBookiesThatJoined(joinedBookies);\n+\n+            if (!readOnlyBookies.isEmpty()) {\n+                this.readOnlyBookies = ImmutableSet.copyOf(readOnlyBookies);\n+            }\n+\n+            return deadBookies;\n+        } finally {\n+            rwLock.writeLock().unlock();\n+        }\n+    }\n+\n+    @Override\n+    public void handleBookiesThatLeft(Set<BookieSocketAddress> leftBookies) {\n+        for (BookieSocketAddress addr : leftBookies) {\n+            BookieNode node = knownBookies.remove(addr);\n+            if(null != node) {\n+                topology.remove(node);\n+                if (LOG.isDebugEnabled()) {\n+                    LOG.debug(\"Cluster changed : bookie {} left from cluster.\", addr);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void handleBookiesThatJoined(Set<BookieSocketAddress> joinedBookies) {\n+        // node joined\n+        for (BookieSocketAddress addr : joinedBookies) {\n+            BookieNode node = createBookieNode(addr);\n+            topology.add(node);\n+            knownBookies.put(addr, node);\n+            if (LOG.isDebugEnabled()) {\n+                LOG.debug(\"Cluster changed : bookie {} joined the cluster.\", addr);\n+            }\n+        }\n+    }\n+\n+    protected Set<Node> convertBookiesToNodes(Set<BookieSocketAddress> excludeBookies) {\n+        Set<Node> nodes = new HashSet<Node>();\n+        for (BookieSocketAddress addr : excludeBookies) {\n+            BookieNode bn = knownBookies.get(addr);\n+            if (null == bn) {\n+                bn = createBookieNode(addr);\n+            }\n+            nodes.add(bn);\n+        }\n+        return nodes;\n+    }\n+\n+    @Override\n+    public ArrayList<BookieSocketAddress> newEnsemble(int ensembleSize, int writeQuorumSize, int ackQuorumSize,\n+                                                      Set<BookieSocketAddress> excludeBookies)\n+            throws BKNotEnoughBookiesException {\n+        return newEnsembleInternal(ensembleSize, writeQuorumSize, excludeBookies, null, null);\n+    }\n+\n+    protected ArrayList<BookieSocketAddress> newEnsembleInternal(int ensembleSize,\n+                                                               int writeQuorumSize,\n+                                                               Set<BookieSocketAddress> excludeBookies,\n+                                                               Ensemble<BookieNode> parentEnsemble,\n+                                                               Predicate<BookieNode> parentPredicate)\n+            throws BKNotEnoughBookiesException {\n+        return newEnsembleInternal(\n+                ensembleSize,\n+                writeQuorumSize,\n+                writeQuorumSize,\n+                excludeBookies,\n+                parentEnsemble,\n+                parentPredicate);\n+    }\n+\n+    @Override\n+    public ArrayList<BookieSocketAddress> newEnsemble(int ensembleSize,\n+                                                    int writeQuorumSize,\n+                                                    int ackQuorumSize,\n+                                                    Set<BookieSocketAddress> excludeBookies,\n+                                                    Ensemble<BookieNode> parentEnsemble,\n+                                                    Predicate<BookieNode> parentPredicate)\n+            throws BKNotEnoughBookiesException {\n+        return newEnsembleInternal(\n+                ensembleSize,\n+                writeQuorumSize,\n+                ackQuorumSize,\n+                excludeBookies,\n+                parentEnsemble,\n+                parentPredicate);\n+    }\n+\n+    protected ArrayList<BookieSocketAddress> newEnsembleInternal(\n+            int ensembleSize,\n+            int writeQuorumSize,\n+            int ackQuorumSize,\n+            Set<BookieSocketAddress> excludeBookies,\n+            Ensemble<BookieNode> parentEnsemble,\n+            Predicate<BookieNode> parentPredicate) throws BKNotEnoughBookiesException {\n+        rwLock.readLock().lock();\n+        try {\n+            Set<Node> excludeNodes = convertBookiesToNodes(excludeBookies);\n+            RRTopologyAwareCoverageEnsemble ensemble =\n+                    new RRTopologyAwareCoverageEnsemble(\n+                            ensembleSize,\n+                            writeQuorumSize,\n+                            ackQuorumSize,\n+                            RACKNAME_DISTANCE_FROM_LEAVES,\n+                            parentEnsemble,\n+                            parentPredicate);\n+            BookieNode prevNode = null;\n+            int numRacks = topology.getNumOfRacks();\n+            // only one rack, use the random algorithm.\n+            if (numRacks < 2) {\n+                List<BookieNode> bns = selectRandom(ensembleSize, excludeNodes, TruePredicate.instance,\n+                        ensemble);\n+                ArrayList<BookieSocketAddress> addrs = new ArrayList<BookieSocketAddress>(ensembleSize);\n+                for (BookieNode bn : bns) {\n+                    addrs.add(bn.getAddr());\n+                }\n+                return addrs;\n+            }\n+            // pick nodes by racks, to ensure there is at least two racks per write quorum.\n+            for (int i = 0; i < ensembleSize; i++) {\n+                String curRack;\n+                if (null == prevNode) {\n+                    if ((null == localNode) ||\n+                            localNode.getNetworkLocation().equals(NetworkTopology.DEFAULT_RACK)) {\n+                        curRack = NodeBase.ROOT;\n+                    } else {\n+                        curRack = localNode.getNetworkLocation();\n+                    }\n+                } else {\n+                    curRack = \"~\" + prevNode.getNetworkLocation();\n+                }\n+                prevNode = selectFromNetworkLocation(curRack, excludeNodes, ensemble, ensemble);\n+            }\n+            ArrayList<BookieSocketAddress> bookieList = ensemble.toList();\n+            if (ensembleSize != bookieList.size()) {\n+                LOG.error(\"Not enough {} bookies are available to form an ensemble : {}.\",\n+                          ensembleSize, bookieList);\n+                throw new BKNotEnoughBookiesException();\n+            }\n+            return bookieList;\n+        } finally {\n+            rwLock.readLock().unlock();\n+        }\n+    }\n+\n+    @Override\n+    public BookieSocketAddress replaceBookie(int ensembleSize, int writeQuorumSize, int ackQuorumSize,\n+                                             Collection<BookieSocketAddress> currentEnsemble,\n+                                             BookieSocketAddress bookieToReplace,\n+                                             Set<BookieSocketAddress> excludeBookies)\n+            throws BKNotEnoughBookiesException {\n+        rwLock.readLock().lock();\n+        try {\n+            excludeBookies.addAll(currentEnsemble);\n+            BookieNode bn = knownBookies.get(bookieToReplace);\n+            if (null == bn) {\n+                bn = createBookieNode(bookieToReplace);\n+            }\n+\n+            Set<Node> excludeNodes = convertBookiesToNodes(excludeBookies);\n+            // add the bookie to replace in exclude set\n+            excludeNodes.add(bn);\n+            if (LOG.isDebugEnabled()) {\n+                LOG.debug(\"Try to choose a new bookie to replace {}, excluding {}.\", bookieToReplace,\n+                        excludeNodes);\n+            }\n+            // pick a candidate from same rack to replace\n+            BookieNode candidate = selectFromNetworkLocation(\n+                    bn.getNetworkLocation(),\n+                    excludeNodes,\n+                    TruePredicate.instance,\n+                    EnsembleForReplacementWithNoConstraints.instance);\n+            if (LOG.isDebugEnabled()) {\n+                LOG.debug(\"Bookie {} is chosen to replace bookie {}.\", candidate, bn);\n+            }\n+            return candidate.getAddr();\n+        } finally {\n+            rwLock.readLock().unlock();\n+        }\n+    }\n+\n+    @Override\n+    public BookieNode selectFromNetworkLocation(\n+            String networkLoc,\n+            Set<Node> excludeBookies,\n+            Predicate<BookieNode> predicate,\n+            Ensemble<BookieNode> ensemble)\n+            throws BKNotEnoughBookiesException {\n+        // select one from local rack\n+        try {\n+            return selectRandomFromRack(networkLoc, excludeBookies, predicate, ensemble);\n+        } catch (BKNotEnoughBookiesException e) {\n+            LOG.warn(\"Failed to choose a bookie from {} : \"\n+                     + \"excluded {}, fallback to choose bookie randomly from the cluster.\",\n+                     networkLoc, excludeBookies);\n+            // randomly choose one from whole cluster, ignore the provided predicate.\n+            return selectRandom(1, excludeBookies, predicate, ensemble).get(0);\n+        }\n+    }\n+\n+    protected String getRemoteRack(BookieNode node) {\n+        return \"~\" + node.getNetworkLocation();\n+    }\n+\n+    /**\n+     * Choose random node under a given network path.\n+     *\n+     * @param netPath\n+     *          network path\n+     * @param excludeBookies\n+     *          exclude bookies\n+     * @param predicate\n+     *          predicate to check whether the target is a good target.\n+     * @param ensemble\n+     *          ensemble structure\n+     * @return chosen bookie.\n+     */\n+    protected BookieNode selectRandomFromRack(String netPath, Set<Node> excludeBookies, Predicate<BookieNode> predicate,\n+            Ensemble<BookieNode> ensemble) throws BKNotEnoughBookiesException {\n+        List<Node> leaves = new ArrayList<Node>(topology.getLeaves(netPath));\n+        Collections.shuffle(leaves);\n+        for (Node n : leaves) {\n+            if (excludeBookies.contains(n)) {\n+                continue;\n+            }\n+            if (!(n instanceof BookieNode) || !predicate.apply((BookieNode) n, ensemble)) {\n+                continue;\n+            }\n+            BookieNode bn = (BookieNode) n;\n+            // got a good candidate\n+            if (ensemble.addNode(bn)) {\n+                // add the candidate to exclude set\n+                excludeBookies.add(bn);\n+            }\n+            return bn;\n+        }\n+        throw new BKNotEnoughBookiesException();\n+    }\n+\n+    /**\n+     * Choose a random node from whole cluster.\n+     *\n+     * @param numBookies\n+     *          number bookies to choose\n+     * @param excludeBookies\n+     *          bookies set to exclude.\n+     * @param ensemble\n+     *          ensemble to hold the bookie chosen.\n+     * @return the bookie node chosen.\n+     * @throws BKNotEnoughBookiesException\n+     */\n+    protected List<BookieNode> selectRandom(int numBookies,\n+                                            Set<Node> excludeBookies,\n+                                            Predicate<BookieNode> predicate,\n+                                            Ensemble<BookieNode> ensemble)\n+            throws BKNotEnoughBookiesException {\n+        return selectRandomInternal(new ArrayList<BookieNode>(knownBookies.values()),  numBookies, excludeBookies, predicate, ensemble);\n+    }\n+\n+    protected List<BookieNode> selectRandomInternal(List<BookieNode> bookiesToSelectFrom,\n+                                                    int numBookies,\n+                                                    Set<Node> excludeBookies,\n+                                                    Predicate<BookieNode> predicate,\n+                                                    Ensemble<BookieNode> ensemble)\n+        throws BKNotEnoughBookiesException {\n+        Collections.shuffle(bookiesToSelectFrom);\n+        List<BookieNode> newBookies = new ArrayList<BookieNode>(numBookies);\n+        for (BookieNode bookie : bookiesToSelectFrom) {\n+            if (excludeBookies.contains(bookie)) {\n+                continue;\n+            }\n+\n+            // When durability is being enforced; we must not violate the\n+            // predicate even when selecting a random bookie; as durability\n+            // guarantee is not best effort; correctness is implied by it\n+            if (enforceDurability && !predicate.apply(bookie, ensemble)) {\n+                continue;\n+            }\n+\n+            if (ensemble.addNode(bookie)) {\n+                excludeBookies.add(bookie);\n+                newBookies.add(bookie);\n+                --numBookies;\n+            }\n+\n+            if (numBookies == 0) {\n+                return newBookies;\n+            }\n+        }\n+        if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"Failed to find {} bookies : excludeBookies {}, allBookies {}.\", new Object[] {\n+                numBookies, excludeBookies, bookiesToSelectFrom });\n+        }\n+        throw new BKNotEnoughBookiesException();\n+    }\n+\n+\n+\n+    @Override\n+    public List<Integer> reorderReadSequence(ArrayList<BookieSocketAddress> ensemble, List<Integer> writeSet, Map<BookieSocketAddress, Long> bookieFailureHistory) {\n+        int ensembleSize = ensemble.size();\n+        List<Integer> finalList = new ArrayList<Integer>(writeSet.size());\n+        List<Long> observedFailuresList = new ArrayList<Long>(writeSet.size());\n+        List<Integer> readOnlyList = new ArrayList<Integer>(writeSet.size());\n+        List<Integer> unAvailableList = new ArrayList<Integer>(writeSet.size());\n+        for (Integer idx : writeSet) {\n+            BookieSocketAddress address = ensemble.get(idx);\n+            Long lastFailedEntryOnBookie = bookieFailureHistory.get(address);\n+            if (null == knownBookies.get(address)) {\n+                // there isn't too much differences between readonly bookies from unavailable bookies. since there\n+                // is no write requests to them, so we shouldn't try reading from readonly bookie in prior to writable\n+                // bookies.\n+                if ((null == readOnlyBookies) || !readOnlyBookies.contains(address)) {\n+                    unAvailableList.add(idx);\n+                } else {\n+                    readOnlyList.add(idx);\n+                }\n+            } else {\n+                if ((lastFailedEntryOnBookie == null) || (lastFailedEntryOnBookie < 0)) {\n+                    finalList.add(idx);\n+                } else {\n+                    observedFailuresList.add(lastFailedEntryOnBookie * ensembleSize + idx);\n+                }\n+            }\n+        }\n+\n+        if (reorderReadsRandom) {\n+            Collections.shuffle(finalList);\n+            Collections.shuffle(readOnlyList);\n+            Collections.shuffle(unAvailableList);\n+        }\n+\n+        Collections.sort(observedFailuresList);\n+\n+        for(long value: observedFailuresList) {\n+            finalList.add((int)(value % ensembleSize));\n+        }\n+\n+        finalList.addAll(readOnlyList);\n+        finalList.addAll(unAvailableList);\n+        return finalList;\n+    }\n+}"},{"sha":"abdcb6117cd7794427932addd523c4f04bcca61a","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/RegionAwareEnsemblePlacementPolicy.java","status":"added","additions":602,"deletions":0,"changes":602,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/bbd1eb8d8560b03834175fbd996b85237df09f5c/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FRegionAwareEnsemblePlacementPolicy.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/bbd1eb8d8560b03834175fbd996b85237df09f5c/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FRegionAwareEnsemblePlacementPolicy.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FRegionAwareEnsemblePlacementPolicy.java?ref=bbd1eb8d8560b03834175fbd996b85237df09f5c","patch":"@@ -0,0 +1,602 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.bookkeeper.client;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import com.google.common.base.Optional;\n+\n+\n+import org.apache.bookkeeper.conf.ClientConfiguration;\n+import org.apache.bookkeeper.feature.Feature;\n+import org.apache.bookkeeper.feature.FeatureProvider;\n+import org.apache.bookkeeper.net.BookieSocketAddress;\n+import org.apache.bookkeeper.net.DNSToSwitchMapping;\n+import org.apache.bookkeeper.net.NetworkTopology;\n+import org.apache.bookkeeper.net.Node;\n+import org.apache.bookkeeper.net.NodeBase;\n+import org.apache.bookkeeper.stats.StatsLogger;\n+import org.apache.bookkeeper.util.BookKeeperConstants;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.jboss.netty.util.HashedWheelTimer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class RegionAwareEnsemblePlacementPolicy extends RackawareEnsemblePlacementPolicy {\n+    static final Logger LOG = LoggerFactory.getLogger(RegionAwareEnsemblePlacementPolicy.class);\n+\n+    public static final String REPP_REGIONS_TO_WRITE = \"reppRegionsToWrite\";\n+    public static final String REPP_MINIMUM_REGIONS_FOR_DURABILITY = \"reppMinimumRegionsForDurability\";\n+    public static final String REPP_ENABLE_DURABILITY_ENFORCEMENT_IN_REPLACE = \"reppEnableDurabilityEnforcementInReplace\";\n+    public static final String REPP_DISABLE_DURABILITY_FEATURE_NAME = \"reppDisableDurabilityFeatureName\";\n+    public static final String REPP_DISALLOW_BOOKIE_PLACEMENT_IN_REGION_FEATURE_NAME = \"reppDisallowBookiePlacementInRegionFeatureName\";\n+    public static final String REPP_DISABLE_DURABILITY_ENFORCEMENT_FEATURE = \"reppDisableDurabilityEnforcementFeature\";\n+    public static final String REPP_ENABLE_VALIDATION = \"reppEnableValidation\";\n+    public static final String REGION_AWARE_ANOMALOUS_ENSEMBLE = \"region_aware_anomalous_ensemble\";\n+    static final int MINIMUM_REGIONS_FOR_DURABILITY_DEFAULT = 2;\n+    static final int REGIONID_DISTANCE_FROM_LEAVES = 2;\n+    static final String UNKNOWN_REGION = \"UnknownRegion\";\n+    static final int REMOTE_NODE_IN_REORDER_SEQUENCE = 2;\n+\n+    protected final Map<String, TopologyAwareEnsemblePlacementPolicy> perRegionPlacement;\n+    protected final ConcurrentMap<BookieSocketAddress, String> address2Region;\n+    protected FeatureProvider featureProvider;\n+    protected String disallowBookiePlacementInRegionFeatureName;\n+    protected String myRegion = null;\n+    protected int minRegionsForDurability = 0;\n+    protected boolean enableValidation = true;\n+    protected boolean enforceDurabilityInReplace = false;\n+    protected Feature disableDurabilityFeature;\n+\n+    RegionAwareEnsemblePlacementPolicy() {\n+        super();\n+        perRegionPlacement = new HashMap<String, TopologyAwareEnsemblePlacementPolicy>();\n+        address2Region = new ConcurrentHashMap<BookieSocketAddress, String>();\n+    }\n+\n+    protected String getRegion(BookieSocketAddress addr) {\n+        String region = address2Region.get(addr);\n+        if (null == region) {\n+            String networkLocation = resolveNetworkLocation(addr);\n+            if (NetworkTopology.DEFAULT_RACK.equals(networkLocation)) {\n+                region = UNKNOWN_REGION;\n+            } else {\n+                String[] parts = networkLocation.split(NodeBase.PATH_SEPARATOR_STR);\n+                if (parts.length <= 1) {\n+                    region = UNKNOWN_REGION;\n+                } else {\n+                    region = parts[1];\n+                }\n+            }\n+            address2Region.putIfAbsent(addr, region);\n+        }\n+        return region;\n+    }\n+\n+    protected String getLocalRegion(BookieNode node) {\n+        if (null == node || null == node.getAddr()) {\n+            return UNKNOWN_REGION;\n+        }\n+        return getRegion(node.getAddr());\n+    }\n+\n+    @Override\n+    public void handleBookiesThatLeft(Set<BookieSocketAddress> leftBookies) {\n+        super.handleBookiesThatLeft(leftBookies);\n+\n+        for(TopologyAwareEnsemblePlacementPolicy policy: perRegionPlacement.values()) {\n+            policy.handleBookiesThatLeft(leftBookies);\n+        }\n+    }\n+\n+    @Override\n+    public void handleBookiesThatJoined(Set<BookieSocketAddress> joinedBookies) {\n+        Map<String, Set<BookieSocketAddress>> perRegionClusterChange = new HashMap<String, Set<BookieSocketAddress>>();\n+\n+        // node joined\n+        for (BookieSocketAddress addr : joinedBookies) {\n+            BookieNode node = createBookieNode(addr);\n+            topology.add(node);\n+            knownBookies.put(addr, node);\n+            String region = getLocalRegion(node);\n+            if (null == perRegionPlacement.get(region)) {\n+                perRegionPlacement.put(region, new RackawareEnsemblePlacementPolicy()\n+                        .initialize(dnsResolver, timer, this.reorderReadsRandom, this.stabilizePeriodSeconds, statsLogger));\n+            }\n+\n+            Set<BookieSocketAddress> regionSet = perRegionClusterChange.get(region);\n+            if (null == regionSet) {\n+                regionSet = new HashSet<BookieSocketAddress>();\n+                regionSet.add(addr);\n+                perRegionClusterChange.put(region, regionSet);\n+            } else {\n+                regionSet.add(addr);\n+            }\n+\n+            if (LOG.isDebugEnabled()) {\n+                LOG.debug(\"Cluster changed : bookie {} joined the cluster.\", addr);\n+            }\n+        }\n+\n+        for(String region: perRegionPlacement.keySet()) {\n+            Set<BookieSocketAddress> regionSet = perRegionClusterChange.get(region);\n+            if (null == regionSet) {\n+                regionSet = new HashSet<BookieSocketAddress>();\n+            }\n+            perRegionPlacement.get(region).handleBookiesThatJoined(regionSet);\n+        }\n+    }\n+\n+    @Override\n+    public RegionAwareEnsemblePlacementPolicy initialize(ClientConfiguration conf,\n+                                                         Optional<DNSToSwitchMapping> optionalDnsResolver,\n+                                                         HashedWheelTimer timer,\n+                                                         FeatureProvider featureProvider,\n+                                                         StatsLogger statsLogger) {\n+        super.initialize(conf, optionalDnsResolver, timer, featureProvider, statsLogger);\n+        myRegion = getLocalRegion(localNode);\n+        enableValidation = conf.getBoolean(REPP_ENABLE_VALIDATION, true);\n+\n+        // We have to statically provide regions we want the writes to go through and how many regions\n+        // are required for durability. This decision cannot be driven by the active bookies as the\n+        // current topology will not be indicative of constraints that must be enforced for durability\n+        String regionsString = conf.getString(REPP_REGIONS_TO_WRITE, null);\n+        if (null != regionsString) {\n+            // Regions are specified as\n+            // R1;R2;...\n+            String[] regions = regionsString.split(\";\");\n+            for (String region: regions) {\n+                perRegionPlacement.put(region, new RackawareEnsemblePlacementPolicy(true)\n+                        .initialize(dnsResolver, timer, this.reorderReadsRandom, this.stabilizePeriodSeconds, statsLogger));\n+            }\n+            minRegionsForDurability = conf.getInt(REPP_MINIMUM_REGIONS_FOR_DURABILITY, MINIMUM_REGIONS_FOR_DURABILITY_DEFAULT);\n+            if (minRegionsForDurability > 0) {\n+                enforceDurability = true;\n+                enforceDurabilityInReplace = conf.getBoolean(REPP_ENABLE_DURABILITY_ENFORCEMENT_IN_REPLACE, true);\n+            }\n+            if (regions.length < minRegionsForDurability) {\n+                throw new IllegalArgumentException(\"Regions provided are insufficient to meet the durability constraints\");\n+            }\n+        }\n+        this.featureProvider = featureProvider;\n+        this.disallowBookiePlacementInRegionFeatureName = conf.getString(REPP_DISALLOW_BOOKIE_PLACEMENT_IN_REGION_FEATURE_NAME);\n+        this.disableDurabilityFeature = conf.getFeature(REPP_DISABLE_DURABILITY_ENFORCEMENT_FEATURE, null);\n+        if (null == disableDurabilityFeature) {\n+            this.disableDurabilityFeature =\n+                    featureProvider.getFeature(\n+                        conf.getString(REPP_DISABLE_DURABILITY_FEATURE_NAME,\n+                                BookKeeperConstants.FEATURE_REPP_DISABLE_DURABILITY_ENFORCEMENT));\n+        }\n+        return this;\n+    }\n+\n+    protected List<BookieNode> selectRandomFromRegions(Set<String> availableRegions,\n+                                            int numBookies,\n+                                            Set<Node> excludeBookies,\n+                                            Predicate<BookieNode> predicate,\n+                                            Ensemble<BookieNode> ensemble)\n+        throws BKException.BKNotEnoughBookiesException {\n+        List<BookieNode> availableBookies = new ArrayList<BookieNode>();\n+        for(BookieNode bookieNode: knownBookies.values()) {\n+            if (availableRegions.contains(getLocalRegion(bookieNode))) {\n+                availableBookies.add(bookieNode);\n+            }\n+        }\n+\n+        return selectRandomInternal(availableBookies,  numBookies, excludeBookies, predicate, ensemble);\n+    }\n+\n+\n+    @Override\n+    public ArrayList<BookieSocketAddress> newEnsemble(int ensembleSize, int writeQuorumSize, int ackQuorumSize,\n+                                                    Set<BookieSocketAddress> excludeBookies) throws BKException.BKNotEnoughBookiesException {\n+\n+        int effectiveMinRegionsForDurability = disableDurabilityFeature.isAvailable() ? 1 : minRegionsForDurability;\n+\n+        // All of these conditions indicate bad configuration\n+        if (ackQuorumSize < effectiveMinRegionsForDurability) {\n+            throw new IllegalArgumentException(\"Ack Quorum size provided are insufficient to meet the durability constraints\");\n+        } else if (ensembleSize < writeQuorumSize) {\n+            throw new IllegalArgumentException(\"write quorum (\" + writeQuorumSize + \") cannot exceed ensemble size (\" + ensembleSize + \")\");\n+        } else if (writeQuorumSize < ackQuorumSize) {\n+            throw new IllegalArgumentException(\"ack quorum (\" + ackQuorumSize + \") cannot exceed write quorum size (\" + writeQuorumSize + \")\");\n+        } else if (effectiveMinRegionsForDurability > 0) {\n+            // We must survive the failure of numRegions - effectiveMinRegionsForDurability. When these\n+            // regions have failed we would spread the replicas over the remaining\n+            // effectiveMinRegionsForDurability regions; we have to make sure that the ack quorum is large\n+            // enough such that there is a configuration for spreading the replicas across\n+            // effectiveMinRegionsForDurability - 1 regions\n+            if (ackQuorumSize <= (writeQuorumSize - (writeQuorumSize / effectiveMinRegionsForDurability))) {\n+                throw new IllegalArgumentException(\"ack quorum (\" + ackQuorumSize + \") \" +\n+                    \"violates the requirement to satisfy durability constraints when running in degraded mode\");\n+            }\n+        }\n+\n+        rwLock.readLock().lock();\n+        try {\n+            Set<Node> excludeNodes = convertBookiesToNodes(excludeBookies);\n+            Set<String> availableRegions = new HashSet<String>();\n+            for (String region: perRegionPlacement.keySet()) {\n+                if ((null == disallowBookiePlacementInRegionFeatureName) ||\n+                    !featureProvider.scope(region).getFeature(disallowBookiePlacementInRegionFeatureName).isAvailable()) {\n+                    availableRegions.add(region);\n+                }\n+            }\n+            int numRegionsAvailable = availableRegions.size();\n+\n+            // If we were unable to get region information or all regions are disallowed which is\n+            // an invalid configuration; default to random selection from the set of nodes\n+            if (numRegionsAvailable < 1) {\n+                // We cant disallow all regions; if we did, raise an alert to draw attention\n+                if (perRegionPlacement.keySet().size() >= 1) {\n+                    LOG.error(\"No regions available, invalid configuration\");\n+                }\n+                List<BookieNode> bns = selectRandom(ensembleSize, excludeNodes, TruePredicate.instance,\n+                    EnsembleForReplacementWithNoConstraints.instance);\n+                ArrayList<BookieSocketAddress> addrs = new ArrayList<BookieSocketAddress>(ensembleSize);\n+                for (BookieNode bn : bns) {\n+                    addrs.add(bn.getAddr());\n+                }\n+                return addrs;\n+            }\n+\n+            // Single region, fall back to RackAwareEnsemblePlacement\n+            if (numRegionsAvailable < 2) {\n+                RRTopologyAwareCoverageEnsemble ensemble = new RRTopologyAwareCoverageEnsemble(ensembleSize,\n+                                                                    writeQuorumSize,\n+                                                                    ackQuorumSize,\n+                                                                    REGIONID_DISTANCE_FROM_LEAVES,\n+                                                                    effectiveMinRegionsForDurability > 0 ? new HashSet<String>(perRegionPlacement.keySet()) : null,\n+                                                                    effectiveMinRegionsForDurability);\n+                TopologyAwareEnsemblePlacementPolicy nextPolicy = perRegionPlacement.get(availableRegions.iterator().next());\n+                return nextPolicy.newEnsemble(ensembleSize, writeQuorumSize, writeQuorumSize, excludeBookies, ensemble, ensemble);\n+            }\n+\n+            int remainingEnsemble = ensembleSize;\n+            int remainingWriteQuorum = writeQuorumSize;\n+\n+            // Equally distribute the nodes across all regions to whatever extent possible\n+            // with the hierarchy in mind\n+            // Try and place as many nodes in a region as possible, the ones that cannot be\n+            // accommodated are placed on other regions\n+            // Within each region try and follow rack aware placement\n+            Map<String, Pair<Integer,Integer>> regionsWiseAllocation = new HashMap<String, Pair<Integer,Integer>>();\n+            for (String region: availableRegions) {\n+                regionsWiseAllocation.put(region, Pair.of(0,0));\n+            }\n+            int remainingEnsembleBeforeIteration;\n+            Set<String> regionsReachedMaxAllocation = new HashSet<String>();\n+            RRTopologyAwareCoverageEnsemble ensemble;\n+            int iteration = 0;\n+            do {\n+                LOG.info(\"RegionAwareEnsemblePlacementPolicy#newEnsemble Iteration {}\", iteration++);\n+                int numRemainingRegions = numRegionsAvailable - regionsReachedMaxAllocation.size();\n+                ensemble = new RRTopologyAwareCoverageEnsemble(ensembleSize,\n+                                    writeQuorumSize,\n+                                    ackQuorumSize,\n+                                    REGIONID_DISTANCE_FROM_LEAVES,\n+                                    // We pass all regions we know off to the coverage ensemble as\n+                                    // regardless of regions that are available; constraints are\n+                                    // always applied based on all possible regions\n+                                    effectiveMinRegionsForDurability > 0 ? new HashSet<String>(perRegionPlacement.keySet()) : null,\n+                                    effectiveMinRegionsForDurability);\n+                remainingEnsembleBeforeIteration = remainingEnsemble;\n+                for (Map.Entry<String, Pair<Integer, Integer>> regionEntry: regionsWiseAllocation.entrySet()) {\n+                    String region = regionEntry.getKey();\n+                    final Pair<Integer, Integer> currentAllocation = regionEntry.getValue();\n+                    TopologyAwareEnsemblePlacementPolicy policyWithinRegion = perRegionPlacement.get(region);\n+                    if (!regionsReachedMaxAllocation.contains(region)) {\n+                        if (numRemainingRegions <= 0) {\n+                            LOG.error(\"Inconsistent State: This should never happen\");\n+                            throw new BKException.BKNotEnoughBookiesException();\n+                        }\n+\n+                        int addToEnsembleSize = Math.min(remainingEnsemble, (remainingEnsembleBeforeIteration + numRemainingRegions - 1) / numRemainingRegions);\n+                        boolean success = false;\n+                        while(addToEnsembleSize > 0) {\n+                            int addToWriteQuorum = Math.max(1, Math.min(remainingWriteQuorum, Math.round(1.0f * writeQuorumSize * addToEnsembleSize / ensembleSize)));\n+\n+                            // Temp ensemble will be merged back into the ensemble only if we are able to successfully allocate\n+                            // the target number of bookies in this region; if we fail because we dont have enough bookies; then we\n+                            // retry the process with a smaller target\n+                            RRTopologyAwareCoverageEnsemble tempEnsemble = new RRTopologyAwareCoverageEnsemble(ensemble);\n+                            int newEnsembleSize = currentAllocation.getLeft() + addToEnsembleSize;\n+                            int newWriteQuorumSize = currentAllocation.getRight() + addToWriteQuorum;\n+                            try {\n+                                policyWithinRegion.newEnsemble(newEnsembleSize, newWriteQuorumSize, newWriteQuorumSize, excludeBookies, tempEnsemble, tempEnsemble);\n+                                ensemble = tempEnsemble;\n+                                remainingEnsemble -= addToEnsembleSize;\n+                                remainingWriteQuorum -= writeQuorumSize;\n+                                regionsWiseAllocation.put(region, Pair.of(newEnsembleSize, newWriteQuorumSize));\n+                                success = true;\n+                                LOG.info(\"Allocated {} bookies in region {} : {}\",\n+                                        new Object[]{newEnsembleSize, region, ensemble});\n+                                break;\n+                            } catch (BKException.BKNotEnoughBookiesException exc) {\n+                                LOG.warn(\"Could not allocate {} bookies in region {}, try allocating {} bookies\",\n+                                         new Object[] {newEnsembleSize, region, (newEnsembleSize - 1) });\n+                                addToEnsembleSize--;\n+                            }\n+                        }\n+\n+                        // we couldn't allocate additional bookies from the region,\n+                        // it should have reached its max allocation.\n+                        if (!success) {\n+                            regionsReachedMaxAllocation.add(region);\n+                        }\n+                    }\n+\n+                    if (regionsReachedMaxAllocation.contains(region)) {\n+                        if (currentAllocation.getLeft() > 0) {\n+                            LOG.info(\"Allocating {} bookies in region {} : ensemble {} exclude {}\",\n+                                new Object[]{currentAllocation.getLeft(), region, excludeBookies, ensemble});\n+                            policyWithinRegion.newEnsemble(\n+                                    currentAllocation.getLeft(),\n+                                    currentAllocation.getRight(),\n+                                    currentAllocation.getRight(),\n+                                    excludeBookies,\n+                                    ensemble,\n+                                    ensemble);\n+                            LOG.info(\"Allocated {} bookies in region {} : {}\",\n+                                new Object[]{currentAllocation.getLeft(), region, ensemble});\n+                        }\n+                    }\n+                }\n+\n+                if (regionsReachedMaxAllocation.containsAll(regionsWiseAllocation.keySet())) {\n+                    break;\n+                }\n+            } while ((remainingEnsemble > 0) && (remainingEnsemble < remainingEnsembleBeforeIteration));\n+\n+            ArrayList<BookieSocketAddress> bookieList = ensemble.toList();\n+            if (ensembleSize != bookieList.size()) {\n+                LOG.error(\"Not enough {} bookies are available to form an ensemble : {}.\",\n+                          ensembleSize, bookieList);\n+                throw new BKException.BKNotEnoughBookiesException();\n+            }\n+\n+            if(enableValidation && !ensemble.validate()) {\n+                LOG.error(\"Not enough {} bookies are available to form a valid ensemble : {}.\",\n+                    ensembleSize, bookieList);\n+                throw new BKException.BKNotEnoughBookiesException();\n+            }\n+\n+            return ensemble.toList();\n+        } finally {\n+            rwLock.readLock().unlock();\n+        }\n+    }\n+\n+    @Override\n+    public BookieSocketAddress replaceBookie(int ensembleSize, int writeQuorumSize, int ackQuorumSize, Collection<BookieSocketAddress> currentEnsemble, BookieSocketAddress bookieToReplace,\n+                                           Set<BookieSocketAddress> excludeBookies) throws BKException.BKNotEnoughBookiesException {\n+        rwLock.readLock().lock();\n+        try {\n+            boolean enforceDurability = enforceDurabilityInReplace && !disableDurabilityFeature.isAvailable();\n+            int effectiveMinRegionsForDurability = enforceDurability ? minRegionsForDurability : 1;\n+            Set<Node> excludeNodes = convertBookiesToNodes(excludeBookies);\n+            RRTopologyAwareCoverageEnsemble ensemble = new RRTopologyAwareCoverageEnsemble(ensembleSize,\n+                writeQuorumSize,\n+                ackQuorumSize,\n+                REGIONID_DISTANCE_FROM_LEAVES,\n+                effectiveMinRegionsForDurability > 0 ? new HashSet<String>(perRegionPlacement.keySet()) : null,\n+                effectiveMinRegionsForDurability);\n+\n+            BookieNode bookieNodeToReplace = knownBookies.get(bookieToReplace);\n+            if (null == bookieNodeToReplace) {\n+                bookieNodeToReplace = createBookieNode(bookieToReplace);\n+            }\n+            excludeNodes.add(bookieNodeToReplace);\n+\n+            for(BookieSocketAddress bookieAddress: currentEnsemble) {\n+                if (bookieAddress.equals(bookieToReplace)) {\n+                    continue;\n+                }\n+\n+                BookieNode bn = knownBookies.get(bookieAddress);\n+                if (null == bn) {\n+                    bn = createBookieNode(bookieAddress);\n+                }\n+\n+                excludeNodes.add(bn);\n+\n+                if (!ensemble.apply(bn, ensemble)) {\n+                    LOG.warn(\"Anomalous ensemble detected\");\n+                    if (null != statsLogger) {\n+                        statsLogger.getCounter(REGION_AWARE_ANOMALOUS_ENSEMBLE).inc();\n+                    }\n+                    enforceDurability = false;\n+                }\n+\n+                ensemble.addNode(bn);\n+            }\n+\n+            if (LOG.isDebugEnabled()) {\n+                LOG.debug(\"Try to choose a new bookie to replace {}, excluding {}.\", bookieToReplace,\n+                    excludeNodes);\n+            }\n+            // pick a candidate from same rack to replace\n+            BookieNode candidate = replaceFromRack(bookieNodeToReplace, excludeNodes,\n+                ensemble, ensemble, enforceDurability);\n+            if (LOG.isDebugEnabled()) {\n+                LOG.debug(\"Bookie {} is chosen to replace bookie {}.\", candidate, bookieNodeToReplace);\n+            }\n+            return candidate.getAddr();\n+        } finally {\n+            rwLock.readLock().unlock();\n+        }\n+    }\n+\n+    protected BookieNode replaceFromRack(BookieNode bookieNodeToReplace,\n+                                         Set<Node> excludeBookies,\n+                                         Predicate<BookieNode> predicate,\n+                                         Ensemble<BookieNode> ensemble,\n+                                         boolean enforceDurability)\n+        throws BKException.BKNotEnoughBookiesException {\n+        Set<String> availableRegions = new HashSet<String>();\n+        for (String region: perRegionPlacement.keySet()) {\n+            if ((null == disallowBookiePlacementInRegionFeatureName) ||\n+                !featureProvider.scope(region).getFeature(disallowBookiePlacementInRegionFeatureName).isAvailable()) {\n+                availableRegions.add(region);\n+            }\n+        }\n+        String regionForBookieToReplace = getLocalRegion(bookieNodeToReplace);\n+        if (availableRegions.contains(regionForBookieToReplace)) {\n+            TopologyAwareEnsemblePlacementPolicy regionPolicy = perRegionPlacement.get(regionForBookieToReplace);\n+            if (null != regionPolicy) {\n+                try {\n+                    // select one from local rack => it falls back to selecting a node from the region\n+                    // if the rack does not have an available node, selecting from the same region\n+                    // should not violate durability constraints so we can simply not have to check\n+                    // for that.\n+                    return regionPolicy.selectFromNetworkLocation(\n+                        bookieNodeToReplace.getNetworkLocation(),\n+                        excludeBookies,\n+                        TruePredicate.instance,\n+                        EnsembleForReplacementWithNoConstraints.instance);\n+                } catch (BKException.BKNotEnoughBookiesException e) {\n+                    LOG.warn(\"Failed to choose a bookie from {} : \"\n+                            + \"excluded {}, fallback to choose bookie randomly from the cluster.\",\n+                        bookieNodeToReplace.getNetworkLocation(), excludeBookies);\n+                }\n+            }\n+        }\n+\n+        // randomly choose one from all the regions that are available, ignore the provided predicate if we are not\n+        // enforcing durability.\n+        return selectRandomFromRegions(availableRegions, 1,\n+            excludeBookies,\n+            enforceDurability ? predicate : TruePredicate.instance,\n+            enforceDurability ? ensemble : EnsembleForReplacementWithNoConstraints.instance).get(0);\n+    }\n+\n+    @Override\n+    public final List<Integer> reorderReadSequence(ArrayList<BookieSocketAddress> ensemble, List<Integer> writeSet, Map<BookieSocketAddress, Long> bookieFailureHistory) {\n+        if (UNKNOWN_REGION.equals(myRegion)) {\n+            return super.reorderReadSequence(ensemble, writeSet, bookieFailureHistory);\n+        } else {\n+            int ensembleSize = ensemble.size();\n+            List<Integer> finalList = new ArrayList<Integer>(writeSet.size());\n+            List<Integer> localList = new ArrayList<Integer>(writeSet.size());\n+            List<Long> localFailures = new ArrayList<Long>(writeSet.size());\n+            List<Integer> remoteList = new ArrayList<Integer>(writeSet.size());\n+            List<Long> remoteFailures = new ArrayList<Long>(writeSet.size());\n+            List<Integer> readOnlyList = new ArrayList<Integer>(writeSet.size());\n+            List<Integer> unAvailableList = new ArrayList<Integer>(writeSet.size());\n+            for (Integer idx : writeSet) {\n+                BookieSocketAddress address = ensemble.get(idx);\n+                String region = getRegion(address);\n+                Long lastFailedEntryOnBookie = bookieFailureHistory.get(address);\n+                if (null == knownBookies.get(address)) {\n+                    // there isn't too much differences between readonly bookies from unavailable bookies. since there\n+                    // is no write requests to them, so we shouldn't try reading from readonly bookie in prior to writable\n+                    // bookies.\n+                    if ((null == readOnlyBookies) || !readOnlyBookies.contains(address)) {\n+                        unAvailableList.add(idx);\n+                    } else {\n+                        readOnlyList.add(idx);\n+                    }\n+                } else if (region.equals(myRegion)) {\n+                    if ((lastFailedEntryOnBookie == null) || (lastFailedEntryOnBookie < 0)) {\n+                        localList.add(idx);\n+                    } else {\n+                         localFailures.add(lastFailedEntryOnBookie * ensembleSize + idx);\n+                    }\n+                } else {\n+                    if ((lastFailedEntryOnBookie == null) || (lastFailedEntryOnBookie < 0)) {\n+                        remoteList.add(idx);\n+                    } else {\n+                        remoteFailures.add(lastFailedEntryOnBookie * ensembleSize + idx);\n+                    }\n+                }\n+            }\n+\n+            // Given that idx is less than ensemble size the order of the elements in these two lists\n+            // is determined by the lastFailedEntryOnBookie\n+            Collections.sort(localFailures);\n+            Collections.sort(remoteFailures);\n+\n+            if (reorderReadsRandom) {\n+                Collections.shuffle(localList);\n+                Collections.shuffle(remoteList);\n+                Collections.shuffle(readOnlyList);\n+                Collections.shuffle(unAvailableList);\n+            }\n+\n+            // nodes within a region are ordered as follows\n+            // (Random?) list of nodes that have no history of failure\n+            // Nodes with Failure history are ordered in the reverse\n+            // order of the most recent entry that generated an error\n+            for(long value: localFailures) {\n+                localList.add((int)(value % ensembleSize));\n+            }\n+\n+            for(long value: remoteFailures) {\n+                remoteList.add((int)(value % ensembleSize));\n+            }\n+\n+            // Insert a node from the remote region at the specified location so we\n+            // try more than one region within the max allowed latency\n+            for (int i = 0; i < REMOTE_NODE_IN_REORDER_SEQUENCE; i++) {\n+                if (localList.size() > 0) {\n+                    finalList.add(localList.remove(0));\n+                } else {\n+                    break;\n+                }\n+            }\n+\n+            if (remoteList.size() > 0) {\n+                finalList.add(remoteList.remove(0));\n+            }\n+\n+            // Add all the local nodes\n+            finalList.addAll(localList);\n+            finalList.addAll(remoteList);\n+            finalList.addAll(readOnlyList);\n+            finalList.addAll(unAvailableList);\n+            return finalList;\n+        }\n+    }\n+\n+    @Override\n+    public final List<Integer> reorderReadLACSequence(ArrayList<BookieSocketAddress> ensemble, List<Integer> writeSet, Map<BookieSocketAddress, Long> bookieFailureHistory) {\n+        if (UNKNOWN_REGION.equals(myRegion)) {\n+            return super.reorderReadLACSequence(ensemble, writeSet, bookieFailureHistory);\n+        }\n+        List<Integer> finalList = reorderReadSequence(ensemble, writeSet, bookieFailureHistory);\n+\n+        if (finalList.size() < ensemble.size()) {\n+            for (int i = 0; i < ensemble.size(); i++) {\n+                if (!finalList.contains(i)) {\n+                    finalList.add(i);\n+                }\n+            }\n+        }\n+        return finalList;\n+\n+    }\n+}"},{"sha":"c2228271d968310618a1ee266593a028f3ae9fa2","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/TopologyAwareEnsemblePlacementPolicy.java","status":"added","additions":467,"deletions":0,"changes":467,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/bbd1eb8d8560b03834175fbd996b85237df09f5c/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FTopologyAwareEnsemblePlacementPolicy.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/bbd1eb8d8560b03834175fbd996b85237df09f5c/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FTopologyAwareEnsemblePlacementPolicy.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FTopologyAwareEnsemblePlacementPolicy.java?ref=bbd1eb8d8560b03834175fbd996b85237df09f5c","patch":"@@ -0,0 +1,467 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.bookkeeper.client;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+import org.apache.bookkeeper.net.BookieSocketAddress;\n+import org.apache.bookkeeper.net.NetworkTopology;\n+import org.apache.bookkeeper.net.NodeBase;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+abstract class TopologyAwareEnsemblePlacementPolicy implements ITopologyAwareEnsemblePlacementPolicy<TopologyAwareEnsemblePlacementPolicy.BookieNode> {\n+    static final Logger LOG = LoggerFactory.getLogger(TopologyAwareEnsemblePlacementPolicy.class);\n+\n+    protected static class TruePredicate implements Predicate<BookieNode> {\n+\n+        public static final TruePredicate instance = new TruePredicate();\n+\n+        @Override\n+        public boolean apply(BookieNode candidate, Ensemble chosenNodes) {\n+            return true;\n+        }\n+\n+    }\n+\n+    protected static class EnsembleForReplacementWithNoConstraints implements Ensemble<BookieNode> {\n+\n+        public static final EnsembleForReplacementWithNoConstraints instance = new EnsembleForReplacementWithNoConstraints();\n+        static final ArrayList<BookieSocketAddress> EMPTY_LIST = new ArrayList<BookieSocketAddress>(0);\n+\n+        @Override\n+        public boolean addNode(BookieNode node) {\n+            // do nothing\n+            return true;\n+        }\n+\n+        @Override\n+        public ArrayList<BookieSocketAddress> toList() {\n+            return EMPTY_LIST;\n+        }\n+\n+        /**\n+         * Validates if an ensemble is valid\n+         *\n+         * @return true if the ensemble is valid; false otherwise\n+         */\n+        @Override\n+        public boolean validate() {\n+            return true;\n+        }\n+\n+    }\n+\n+    protected static class BookieNode extends NodeBase {\n+\n+        private final BookieSocketAddress addr; // identifier of a bookie node.\n+\n+        BookieNode(BookieSocketAddress addr, String networkLoc) {\n+            super(addr.toString(), networkLoc);\n+            this.addr = addr;\n+        }\n+\n+        public BookieSocketAddress getAddr() {\n+            return addr;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return name.hashCode();\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (!(obj instanceof BookieNode)) {\n+                return false;\n+            }\n+            BookieNode other = (BookieNode) obj;\n+            return getName().equals(other.getName());\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"<Bookie:%s>\", name);\n+        }\n+\n+    }\n+\n+    /**\n+     * A predicate checking the rack coverage for write quorum in {@link RoundRobinDistributionSchedule},\n+     * which ensures that a write quorum should be covered by at least two racks.\n+     */\n+    protected static class RRTopologyAwareCoverageEnsemble implements Predicate<BookieNode>, Ensemble<BookieNode> {\n+\n+        protected interface CoverageSet {\n+            boolean apply(BookieNode candidate);\n+            void addBookie(BookieNode candidate);\n+            public CoverageSet duplicate();\n+        }\n+\n+        protected class RackQuorumCoverageSet implements CoverageSet {\n+            HashSet<String> racksOrRegionsInQuorum = new HashSet<String>();\n+            int seenBookies = 0;\n+\n+            @Override\n+            public boolean apply(BookieNode candidate) {\n+                // If we don't have sufficient members in the write quorum; then we cant enforce\n+                // rack/region diversity\n+                if (writeQuorumSize < 2) {\n+                    return true;\n+                }\n+\n+                if (seenBookies + 1 == writeQuorumSize) {\n+                    return racksOrRegionsInQuorum.size() > (racksOrRegionsInQuorum.contains(candidate.getNetworkLocation(distanceFromLeaves)) ? 1 : 0);\n+                }\n+                return true;\n+            }\n+\n+            @Override\n+            public void addBookie(BookieNode candidate) {\n+                ++seenBookies;\n+                racksOrRegionsInQuorum.add(candidate.getNetworkLocation(distanceFromLeaves));\n+            }\n+\n+            @Override\n+            public RackQuorumCoverageSet duplicate() {\n+                RackQuorumCoverageSet ret = new RackQuorumCoverageSet();\n+                ret.racksOrRegionsInQuorum = Sets.newHashSet(this.racksOrRegionsInQuorum);\n+                ret.seenBookies = this.seenBookies;\n+                return ret;\n+            }\n+        }\n+\n+        protected class RackOrRegionDurabilityCoverageSet implements CoverageSet {\n+            HashMap<String, Integer> allocationToRacksOrRegions = new HashMap<String, Integer>();\n+\n+            RackOrRegionDurabilityCoverageSet() {\n+                for (String rackOrRegion: racksOrRegions) {\n+                    allocationToRacksOrRegions.put(rackOrRegion, 0);\n+                }\n+            }\n+\n+            @Override\n+            public RackOrRegionDurabilityCoverageSet duplicate() {\n+                RackOrRegionDurabilityCoverageSet ret = new RackOrRegionDurabilityCoverageSet();\n+                ret.allocationToRacksOrRegions = Maps.newHashMap(this.allocationToRacksOrRegions);\n+                return ret;\n+            }\n+\n+            private boolean checkSumOfSubsetWithinLimit(final Set<String> includedRacksOrRegions,\n+                            final Set<String> remainingRacksOrRegions,\n+                            int subsetSize,\n+                            int maxAllowedSum) {\n+                if (remainingRacksOrRegions.isEmpty() || (subsetSize <= 0)) {\n+                    if (maxAllowedSum < 0) {\n+                        LOG.trace(\"CHECK FAILED: RacksOrRegions Included {} Remaining {}, subsetSize {}, maxAllowedSum {}\", new Object[]{\n+                            includedRacksOrRegions, remainingRacksOrRegions, subsetSize, maxAllowedSum\n+                        });\n+                    }\n+                    return (maxAllowedSum >= 0);\n+                }\n+\n+                for(String rackOrRegion: remainingRacksOrRegions) {\n+                    Integer currentAllocation = allocationToRacksOrRegions.get(rackOrRegion);\n+                    if (currentAllocation == null) {\n+                        allocationToRacksOrRegions.put(rackOrRegion, 0);\n+                        currentAllocation = 0;\n+                    }\n+\n+                    if (currentAllocation > maxAllowedSum) {\n+                        LOG.trace(\"CHECK FAILED: RacksOrRegions Included {} Candidate {}, subsetSize {}, maxAllowedSum {}\", new Object[]{\n+                            includedRacksOrRegions, rackOrRegion, subsetSize, maxAllowedSum\n+                        });\n+                        return false;\n+                    } else {\n+                        Set<String> remainingElements = new HashSet<String>(remainingRacksOrRegions);\n+                        Set<String> includedElements = new HashSet<String>(includedRacksOrRegions);\n+                        includedElements.add(rackOrRegion);\n+                        remainingElements.remove(rackOrRegion);\n+                        if (!checkSumOfSubsetWithinLimit(includedElements,\n+                            remainingElements,\n+                            subsetSize - 1,\n+                            maxAllowedSum - currentAllocation)) {\n+                            return false;\n+                        }\n+                    }\n+                }\n+\n+                return true;\n+            }\n+\n+            @Override\n+            public boolean apply(BookieNode candidate) {\n+                if (minRacksOrRegionsForDurability <= 1) {\n+                    return true;\n+                }\n+\n+                String candidateRackOrRegion = candidate.getNetworkLocation(distanceFromLeaves);\n+                candidateRackOrRegion = candidateRackOrRegion.startsWith(NodeBase.PATH_SEPARATOR_STR) ? candidateRackOrRegion.substring(1) : candidateRackOrRegion;\n+                final Set<String> remainingRacksOrRegions = new HashSet<String>(racksOrRegions);\n+                remainingRacksOrRegions.remove(candidateRackOrRegion);\n+                final Set<String> includedRacksOrRegions = new HashSet<String>();\n+                includedRacksOrRegions.add(candidateRackOrRegion);\n+\n+                // If minRacksOrRegionsForDurability are required for durability; we must ensure that\n+                // no subset of (minRacksOrRegionsForDurability - 1) regions have ackQuorumSize\n+                // We are only modifying candidateRackOrRegion if we accept this bookie, so lets only\n+                // find sets that contain this candidateRackOrRegion\n+                Integer currentAllocation = allocationToRacksOrRegions.get(candidateRackOrRegion);\n+                if (currentAllocation == null) {\n+                    LOG.info(\"Detected a region that was not initialized {}\", candidateRackOrRegion);\n+                    if (candidateRackOrRegion.equals(NetworkTopology.DEFAULT_REGION)) {\n+                        LOG.error(\"Failed to resolve network location {}\", candidate);\n+                    } else if (!racksOrRegions.contains(candidateRackOrRegion)) {\n+                        LOG.error(\"Unknown region detected {}\", candidateRackOrRegion);\n+                    }\n+                    allocationToRacksOrRegions.put(candidateRackOrRegion, 0);\n+                    currentAllocation = 0;\n+                }\n+\n+                int inclusiveLimit = (ackQuorumSize - 1) - (currentAllocation + 1);\n+                return checkSumOfSubsetWithinLimit(includedRacksOrRegions,\n+                        remainingRacksOrRegions, minRacksOrRegionsForDurability - 2, inclusiveLimit);\n+            }\n+\n+            @Override\n+            public void addBookie(BookieNode candidate) {\n+                String candidateRackOrRegion = candidate.getNetworkLocation(distanceFromLeaves);\n+                candidateRackOrRegion = candidateRackOrRegion.startsWith(NodeBase.PATH_SEPARATOR_STR) ? candidateRackOrRegion.substring(1) : candidateRackOrRegion;\n+                int oldCount = 0;\n+                if (null != allocationToRacksOrRegions.get(candidateRackOrRegion)) {\n+                    oldCount = allocationToRacksOrRegions.get(candidateRackOrRegion);\n+                }\n+                allocationToRacksOrRegions.put(candidateRackOrRegion, oldCount + 1);\n+            }\n+        }\n+\n+\n+\n+        final int distanceFromLeaves;\n+        final int ensembleSize;\n+        final int writeQuorumSize;\n+        final int ackQuorumSize;\n+        final int minRacksOrRegionsForDurability;\n+        final ArrayList<BookieNode> chosenNodes;\n+        final Set<String> racksOrRegions;\n+        private final CoverageSet[] quorums;\n+        final Predicate<BookieNode> parentPredicate;\n+        final Ensemble<BookieNode> parentEnsemble;\n+\n+        protected RRTopologyAwareCoverageEnsemble(RRTopologyAwareCoverageEnsemble that) {\n+            this.distanceFromLeaves = that.distanceFromLeaves;\n+            this.ensembleSize = that.ensembleSize;\n+            this.writeQuorumSize = that.writeQuorumSize;\n+            this.ackQuorumSize = that.ackQuorumSize;\n+            this.chosenNodes = Lists.newArrayList(that.chosenNodes);\n+            this.quorums = new CoverageSet[that.quorums.length];\n+            for (int i = 0; i < that.quorums.length; i++) {\n+                if (null != that.quorums[i]) {\n+                    this.quorums[i] = that.quorums[i].duplicate();\n+                } else {\n+                    this.quorums[i] = null;\n+                }\n+            }\n+            this.parentPredicate = that.parentPredicate;\n+            this.parentEnsemble = that.parentEnsemble;\n+            if (null != that.racksOrRegions) {\n+                this.racksOrRegions = new HashSet<String>(that.racksOrRegions);\n+            } else {\n+                this.racksOrRegions = null;\n+            }\n+            this.minRacksOrRegionsForDurability = that.minRacksOrRegionsForDurability;\n+        }\n+\n+        protected RRTopologyAwareCoverageEnsemble(int ensembleSize,\n+                                                  int writeQuorumSize,\n+                                                  int ackQuorumSize,\n+                                                  int distanceFromLeaves,\n+                                                  Set<String> racksOrRegions,\n+                                                  int minRacksOrRegionsForDurability) {\n+            this(ensembleSize, writeQuorumSize, ackQuorumSize, distanceFromLeaves, null, null,\n+                 racksOrRegions, minRacksOrRegionsForDurability);\n+        }\n+\n+        protected RRTopologyAwareCoverageEnsemble(int ensembleSize,\n+                                                  int writeQuorumSize,\n+                                                  int ackQuorumSize,\n+                                                  int distanceFromLeaves,\n+                                                  Ensemble<BookieNode> parentEnsemble,\n+                                                  Predicate<BookieNode> parentPredicate) {\n+            this(ensembleSize, writeQuorumSize, ackQuorumSize, distanceFromLeaves, parentEnsemble, parentPredicate,\n+                 null, 0);\n+        }\n+\n+        protected RRTopologyAwareCoverageEnsemble(int ensembleSize,\n+                                                  int writeQuorumSize,\n+                                                  int ackQuorumSize,\n+                                                  int distanceFromLeaves,\n+                                                  Ensemble<BookieNode> parentEnsemble,\n+                                                  Predicate<BookieNode> parentPredicate,\n+                                                  Set<String> racksOrRegions,\n+                                                  int minRacksOrRegionsForDurability) {\n+            this.ensembleSize = ensembleSize;\n+            this.writeQuorumSize = writeQuorumSize;\n+            this.ackQuorumSize = ackQuorumSize;\n+            this.distanceFromLeaves = distanceFromLeaves;\n+            this.chosenNodes = new ArrayList<BookieNode>(ensembleSize);\n+            if (minRacksOrRegionsForDurability > 0) {\n+                this.quorums = new RackOrRegionDurabilityCoverageSet[ensembleSize];\n+            } else {\n+                this.quorums = new RackQuorumCoverageSet[ensembleSize];\n+            }\n+            this.parentEnsemble = parentEnsemble;\n+            this.parentPredicate = parentPredicate;\n+            this.racksOrRegions = racksOrRegions;\n+            this.minRacksOrRegionsForDurability = minRacksOrRegionsForDurability;\n+        }\n+\n+        @Override\n+        public boolean apply(BookieNode candidate, Ensemble<BookieNode> ensemble) {\n+            if (ensemble != this) {\n+                return false;\n+            }\n+\n+            // An ensemble cannot contain the same node twice\n+            if (chosenNodes.contains(candidate)) {\n+                return false;\n+            }\n+\n+            // candidate position\n+            if ((ensembleSize == writeQuorumSize) && (minRacksOrRegionsForDurability > 0)) {\n+                if (null == quorums[0]) {\n+                    quorums[0] = new RackOrRegionDurabilityCoverageSet();\n+                }\n+                if (!quorums[0].apply(candidate)) {\n+                    return false;\n+                }\n+            } else {\n+                int candidatePos = chosenNodes.size();\n+                int startPos = candidatePos - writeQuorumSize + 1;\n+                for (int i = startPos; i <= candidatePos; i++) {\n+                    int idx = (i + ensembleSize) % ensembleSize;\n+                    if (null == quorums[idx]) {\n+                        if (minRacksOrRegionsForDurability > 0) {\n+                            quorums[idx] = new RackOrRegionDurabilityCoverageSet();\n+                        } else {\n+                            quorums[idx] = new RackQuorumCoverageSet();\n+                        }\n+                    }\n+                    if (!quorums[idx].apply(candidate)) {\n+                        return false;\n+                    }\n+                }\n+            }\n+\n+            return ((null == parentPredicate) || parentPredicate.apply(candidate, parentEnsemble));\n+        }\n+\n+        @Override\n+        public boolean addNode(BookieNode node) {\n+            // An ensemble cannot contain the same node twice\n+            if (chosenNodes.contains(node)) {\n+                return false;\n+            }\n+\n+            if ((ensembleSize == writeQuorumSize) && (minRacksOrRegionsForDurability > 0)) {\n+                if (null == quorums[0]) {\n+                    quorums[0] = new RackOrRegionDurabilityCoverageSet();\n+                }\n+                quorums[0].addBookie(node);\n+            } else {\n+                int candidatePos = chosenNodes.size();\n+                int startPos = candidatePos - writeQuorumSize + 1;\n+                for (int i = startPos; i <= candidatePos; i++) {\n+                    int idx = (i + ensembleSize) % ensembleSize;\n+                    if (null == quorums[idx]) {\n+                        if (minRacksOrRegionsForDurability > 0) {\n+                            quorums[idx] = new RackOrRegionDurabilityCoverageSet();\n+                        } else {\n+                            quorums[idx] = new RackQuorumCoverageSet();\n+                        }\n+                    }\n+                    quorums[idx].addBookie(node);\n+                }\n+            }\n+            chosenNodes.add(node);\n+\n+            return ((null == parentEnsemble) || parentEnsemble.addNode(node));\n+        }\n+\n+        @Override\n+        public ArrayList<BookieSocketAddress> toList() {\n+            ArrayList<BookieSocketAddress> addresses = new ArrayList<BookieSocketAddress>(ensembleSize);\n+            for (BookieNode bn : chosenNodes) {\n+                addresses.add(bn.getAddr());\n+            }\n+            return addresses;\n+        }\n+\n+        /**\n+         * Validates if an ensemble is valid\n+         *\n+         * @return true if the ensemble is valid; false otherwise\n+         */\n+        @Override\n+        public boolean validate() {\n+            HashSet<BookieSocketAddress> addresses = new HashSet<BookieSocketAddress>(ensembleSize);\n+            HashSet<String> racksOrRegions = new HashSet<String>();\n+            for (BookieNode bn : chosenNodes) {\n+                if (addresses.contains(bn.getAddr())) {\n+                    return false;\n+                }\n+                addresses.add(bn.getAddr());\n+                racksOrRegions.add(bn.getNetworkLocation(distanceFromLeaves));\n+            }\n+\n+            return ((minRacksOrRegionsForDurability == 0) ||\n+                    (racksOrRegions.size() >= minRacksOrRegionsForDurability));\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return chosenNodes.toString();\n+        }\n+    }\n+\n+    @Override\n+    public List<Integer> reorderReadSequence(ArrayList<BookieSocketAddress> ensemble, List<Integer> writeSet, Map<BookieSocketAddress, Long> bookieFailureHistory) {\n+        return writeSet;\n+    }\n+\n+    @Override\n+    public List<Integer> reorderReadLACSequence(ArrayList<BookieSocketAddress> ensemble, List<Integer> writeSet, Map<BookieSocketAddress, Long> bookieFailureHistory) {\n+        List<Integer> retList = new ArrayList<Integer>(reorderReadSequence(ensemble, writeSet, bookieFailureHistory));\n+        if (retList.size() < ensemble.size()) {\n+            for (int i = 0; i < ensemble.size(); i++) {\n+                if (!retList.contains(i)) {\n+                    retList.add(i);\n+                }\n+            }\n+        }\n+        return retList;\n+    }\n+}"},{"sha":"8e76bb7cb6158923eb8e19885065fadb87ce3f31","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ClientConfiguration.java","status":"modified","additions":69,"deletions":3,"changes":72,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/bbd1eb8d8560b03834175fbd996b85237df09f5c/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fconf%2FClientConfiguration.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/bbd1eb8d8560b03834175fbd996b85237df09f5c/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fconf%2FClientConfiguration.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fconf%2FClientConfiguration.java?ref=bbd1eb8d8560b03834175fbd996b85237df09f5c","patch":"@@ -66,6 +66,8 @@ public class ClientConfiguration extends AbstractConfiguration {\n     protected final static String TIMEOUT_TASK_INTERVAL_MILLIS = \"timeoutTaskIntervalMillis\";\n     protected final static String PCBC_TIMEOUT_TIMER_TICK_DURATION_MS = \"pcbcTimeoutTimerTickDurationMs\";\n     protected final static String PCBC_TIMEOUT_TIMER_NUM_TICKS = \"pcbcTimeoutTimerNumTicks\";\n+    protected final static String TIMEOUT_TIMER_TICK_DURATION_MS = \"timeoutTimerTickDurationMs\";\n+    protected final static String TIMEOUT_TIMER_NUM_TICKS = \"timeoutTimerNumTicks\";\n \n     // Bookie health check settings\n     protected final static String BOOKIE_HEALTH_CHECK_ENABLED = \"bookieHealthCheckEnabled\";\n@@ -78,6 +80,7 @@ public class ClientConfiguration extends AbstractConfiguration {\n \n     // Ensemble Placement Policy\n     protected final static String ENSEMBLE_PLACEMENT_POLICY = \"ensemblePlacementPolicy\";\n+    protected final static String NETWORK_TOPOLOGY_STABILIZE_PERIOD_SECONDS = \"networkTopologyStabilizePeriodSeconds\";\n \n     // Stats\n     protected final static String ENABLE_TASK_EXECUTION_STATS = \"enableTaskExecutionStats\";\n@@ -328,6 +331,48 @@ public ClientConfiguration setClientWriteBufferHighWaterMark(int waterMark) {\n         return this;\n     }\n \n+    /**\n+     * Get the tick duration in milliseconds that used for timeout timer.\n+     *\n+     * @return tick duration in milliseconds\n+     */\n+    public long getTimeoutTimerTickDurationMs() {\n+        return getLong(TIMEOUT_TIMER_TICK_DURATION_MS, 100);\n+    }\n+\n+    /**\n+     * Set the tick duration in milliseconds that used for timeout timer.\n+     *\n+     * @param tickDuration\n+     *          tick duration in milliseconds.\n+     * @return client configuration.\n+     */\n+    public ClientConfiguration setTimeoutTimerTickDurationMs(long tickDuration) {\n+        setProperty(TIMEOUT_TIMER_TICK_DURATION_MS, tickDuration);\n+        return this;\n+    }\n+\n+    /**\n+     * Get number of ticks that used for timeout timer.\n+     *\n+     * @return number of ticks that used for timeout timer.\n+     */\n+    public int getTimeoutTimerNumTicks() {\n+        return getInt(TIMEOUT_TIMER_NUM_TICKS, 1024);\n+    }\n+\n+    /**\n+     * Set number of ticks that used for timeout timer.\n+     *\n+     * @param numTicks\n+     *          number of ticks that used for timeout timer.\n+     * @return client configuration.\n+     */\n+    public ClientConfiguration setTimeoutTimerNumTicks(int numTicks) {\n+        setProperty(TIMEOUT_TIMER_NUM_TICKS, numTicks);\n+        return this;\n+    }\n+\n     /**\n      * Get client netty connect timeout in millis.\n      *\n@@ -666,10 +711,10 @@ public ClientConfiguration setSpeculativeReadTimeout(int timeout) {\n      * @return ensemble placement policy class.\n      */\n     public Class<? extends EnsemblePlacementPolicy> getEnsemblePlacementPolicy()\n-        throws ConfigurationException {\n+            throws ConfigurationException {\n         return ReflectionUtils.getClass(this, ENSEMBLE_PLACEMENT_POLICY,\n-                                        RackawareEnsemblePlacementPolicy.class,\n-                                        EnsemblePlacementPolicy.class,\n+                RackawareEnsemblePlacementPolicy.class,\n+                EnsemblePlacementPolicy.class,\n                                         defaultLoader);\n     }\n \n@@ -684,6 +729,27 @@ public ClientConfiguration setEnsemblePlacementPolicy(Class<? extends EnsemblePl\n         return this;\n     }\n \n+    /**\n+     * Get the network topology stabilize period in seconds. if it is zero, this feature is turned off.\n+     *\n+     * @return network topology stabilize period in seconds.\n+     */\n+    public int getNetworkTopologyStabilizePeriodSeconds() {\n+        return getInt(NETWORK_TOPOLOGY_STABILIZE_PERIOD_SECONDS, 0);\n+    }\n+\n+    /**\n+     * Set the network topology stabilize period in seconds.\n+     *\n+     * @see #getNetworkTopologyStabilizePeriodSeconds()\n+     * @param seconds stabilize period in seconds\n+     * @return client configuration.\n+     */\n+    public ClientConfiguration setNetworkTopologyStabilizePeriodSeconds(int seconds) {\n+        setProperty(NETWORK_TOPOLOGY_STABILIZE_PERIOD_SECONDS, seconds);\n+        return this;\n+    }\n+\n     /**\n      * Whether to enable recording task execution stats.\n      *"},{"sha":"99ed03894bf7ade35b2d67b0cbaceeadb7c5994c","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/net/AbstractDNSToSwitchMapping.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/bbd1eb8d8560b03834175fbd996b85237df09f5c/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fnet%2FAbstractDNSToSwitchMapping.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/bbd1eb8d8560b03834175fbd996b85237df09f5c/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fnet%2FAbstractDNSToSwitchMapping.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fnet%2FAbstractDNSToSwitchMapping.java?ref=bbd1eb8d8560b03834175fbd996b85237df09f5c","patch":"@@ -15,7 +15,7 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-// This code has been copied from hadoop-common 0.23.1\n+\n package org.apache.bookkeeper.net;\n \n import java.util.HashSet;"},{"sha":"8947abf32beb0763949f561905cd37cbf1566837","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/net/BookieSocketAddress.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/bbd1eb8d8560b03834175fbd996b85237df09f5c/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fnet%2FBookieSocketAddress.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/bbd1eb8d8560b03834175fbd996b85237df09f5c/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fnet%2FBookieSocketAddress.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fnet%2FBookieSocketAddress.java?ref=bbd1eb8d8560b03834175fbd996b85237df09f5c","patch":"@@ -63,7 +63,7 @@ public BookieSocketAddress(String addr) throws UnknownHostException {\n     }\n \n     // Public getters\n-    public String getHostname() {\n+    public String getHostName() {\n         return hostname;\n     }\n "},{"sha":"d7ff251ca51afcbed8acf86f2ffeff9935f0e361","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/net/CachedDNSToSwitchMapping.java","status":"modified","additions":0,"deletions":1,"changes":1,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/bbd1eb8d8560b03834175fbd996b85237df09f5c/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fnet%2FCachedDNSToSwitchMapping.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/bbd1eb8d8560b03834175fbd996b85237df09f5c/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fnet%2FCachedDNSToSwitchMapping.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fnet%2FCachedDNSToSwitchMapping.java?ref=bbd1eb8d8560b03834175fbd996b85237df09f5c","patch":"@@ -15,7 +15,6 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-// This code has been copied from hadoop-common 0.23.1\n package org.apache.bookkeeper.net;\n \n import java.util.ArrayList;"},{"sha":"d09e422d7b6b322145ea61eb15af0ea445bb2b34","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/net/DNS.java","status":"modified","additions":4,"deletions":0,"changes":4,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/bbd1eb8d8560b03834175fbd996b85237df09f5c/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fnet%2FDNS.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/bbd1eb8d8560b03834175fbd996b85237df09f5c/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fnet%2FDNS.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fnet%2FDNS.java?ref=bbd1eb8d8560b03834175fbd996b85237df09f5c","patch":"@@ -69,6 +69,10 @@ public static String reverseDns(InetAddress hostIp, String ns)\n         // This is formed by reversing the IP numbers and appending in-addr.arpa\n         //\n         String[] parts = hostIp.getHostAddress().split(\"\\\\.\");\n+        if(parts.length !=4) {\n+            //Not proper address. May be IPv6\n+            throw new NamingException(\"IPV6\");\n+        }\n         String reverseIP = parts[3] + \".\" + parts[2] + \".\" + parts[1] + \".\"\n                 + parts[0] + \".in-addr.arpa\";\n "},{"sha":"615699358c7a677d4592cf5b05acb666b26b67bd","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/net/DNSToSwitchMapping.java","status":"modified","additions":0,"deletions":1,"changes":1,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/bbd1eb8d8560b03834175fbd996b85237df09f5c/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fnet%2FDNSToSwitchMapping.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/bbd1eb8d8560b03834175fbd996b85237df09f5c/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fnet%2FDNSToSwitchMapping.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fnet%2FDNSToSwitchMapping.java?ref=bbd1eb8d8560b03834175fbd996b85237df09f5c","patch":"@@ -15,7 +15,6 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-// This code has been copied from hadoop-common 0.23.1\n package org.apache.bookkeeper.net;\n \n import java.util.List;"},{"sha":"d954d0432cae112a5d0389d414955344fb2514aa","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/net/NetUtils.java","status":"modified","additions":25,"deletions":1,"changes":26,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/bbd1eb8d8560b03834175fbd996b85237df09f5c/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fnet%2FNetUtils.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/bbd1eb8d8560b03834175fbd996b85237df09f5c/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fnet%2FNetUtils.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fnet%2FNetUtils.java?ref=bbd1eb8d8560b03834175fbd996b85237df09f5c","patch":"@@ -15,16 +15,20 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-// This code has been copied from hadoop-common 0.23.1\n package org.apache.bookkeeper.net;\n \n import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n import java.net.UnknownHostException;\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.List;\n \n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n public class NetUtils {\n+    private static final Logger logger = LoggerFactory.getLogger(NetUtils.class);\n \n     /**\n      * Given a string representation of a host, return its ip address\n@@ -58,4 +62,24 @@ public static List<String> normalizeHostNames(Collection<String> names) {\n         return hostNames;\n     }\n \n+    public static String resolveNetworkLocation(DNSToSwitchMapping dnsResolver, InetSocketAddress addr) {\n+        List<String> names = new ArrayList<String>(1);\n+        if (dnsResolver instanceof CachedDNSToSwitchMapping) {\n+            names.add(addr.getAddress().getHostAddress());\n+        } else {\n+            names.add(addr.getHostName());\n+        }\n+        // resolve network addresses\n+        List<String> rNames = dnsResolver.resolve(names);\n+        String netLoc;\n+        if (null == rNames) {\n+            logger.warn(\"Failed to resolve network location for {}, using default rack for them : {}.\", names,\n+                NetworkTopology.DEFAULT_RACK);\n+            netLoc = NetworkTopology.DEFAULT_RACK;\n+        } else {\n+            netLoc = rNames.get(0);\n+        }\n+        return netLoc;\n+    }\n+\n }"},{"sha":"18f3ec9df3edfc9b3afc568e238d79231722ccef","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/net/NetworkTopology.java","status":"modified","additions":31,"deletions":830,"changes":861,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/bbd1eb8d8560b03834175fbd996b85237df09f5c/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fnet%2FNetworkTopology.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/bbd1eb8d8560b03834175fbd996b85237df09f5c/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fnet%2FNetworkTopology.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fnet%2FNetworkTopology.java?ref=bbd1eb8d8560b03834175fbd996b85237df09f5c","patch":"@@ -1,4 +1,4 @@\n-/**\n+/*\n  * Licensed to the Apache Software Foundation (ASF) under one\n  * or more contributor license agreements.  See the NOTICE file\n  * distributed with this work for additional information\n@@ -15,863 +15,64 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-// This code has been copied from hadoop-common 0.23.1\n package org.apache.bookkeeper.net;\n \n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Random;\n import java.util.Set;\n-import java.util.concurrent.locks.ReadWriteLock;\n-import java.util.concurrent.locks.ReentrantReadWriteLock;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n \n /**\n- * The class represents a cluster of computer with a tree hierarchical\n- * network topology.\n- * For example, a cluster may be consists of many data centers filled\n- * with racks of computers.\n- * In a network topology, leaves represent data nodes (computers) and inner\n- * nodes represent switches/routers that manage traffic in/out of data centers\n- * or racks.\n- *\n+ * Network Topology Interface\n  */\n-public class NetworkTopology {\n-\n-    public final static String DEFAULT_RACK = \"/default-rack\";\n-    public final static int DEFAULT_HOST_LEVEL = 2;\n-    public static final Logger LOG = LoggerFactory.getLogger(NetworkTopology.class);\n-\n-    public static class InvalidTopologyException extends RuntimeException {\n-        private static final long serialVersionUID = 1L;\n-\n-        public InvalidTopologyException(String msg) {\n-            super(msg);\n-        }\n-    }\n-\n-    /** InnerNode represents a switch/router of a data center or rack.\n-     * Different from a leaf node, it has non-null children.\n-     */\n-    static class InnerNode extends NodeBase {\n-        protected List<Node> children = new ArrayList<Node>();\n-        private int numOfLeaves;\n-\n-        /** Construct an InnerNode from a path-like string */\n-        InnerNode(String path) {\n-            super(path);\n-        }\n-\n-        /** Construct an InnerNode from its name and its network location */\n-        InnerNode(String name, String location) {\n-            super(name, location);\n-        }\n-\n-        /** Construct an InnerNode\n-         * from its name, its network location, its parent, and its level */\n-        InnerNode(String name, String location, InnerNode parent, int level) {\n-            super(name, location, parent, level);\n-        }\n-\n-        /** @return its children */\n-        List<Node> getChildren() {\n-            return children;\n-        }\n-\n-        /** @return the number of children this node has */\n-        int getNumOfChildren() {\n-            return children.size();\n-        }\n-\n-        /** Judge if this node represents a rack\n-         * @return true if it has no child or its children are not InnerNodes\n-         */\n-        boolean isRack() {\n-            if (children.isEmpty()) {\n-                return true;\n-            }\n-\n-            Node firstChild = children.get(0);\n-            if (firstChild instanceof InnerNode) {\n-                return false;\n-            }\n-\n-            return true;\n-        }\n-\n-        /** Judge if this node is an ancestor of node <i>n</i>\n-         *\n-         * @param n a node\n-         * @return true if this node is an ancestor of <i>n</i>\n-         */\n-        boolean isAncestor(Node n) {\n-            return getPath(this).equals(NodeBase.PATH_SEPARATOR_STR)\n-                    || (n.getNetworkLocation() + NodeBase.PATH_SEPARATOR_STR).startsWith(getPath(this)\n-                            + NodeBase.PATH_SEPARATOR_STR);\n-        }\n-\n-        /** Judge if this node is the parent of node <i>n</i>\n-         *\n-         * @param n a node\n-         * @return true if this node is the parent of <i>n</i>\n-         */\n-        boolean isParent(Node n) {\n-            return n.getNetworkLocation().equals(getPath(this));\n-        }\n-\n-        /* Return a child name of this node who is an ancestor of node <i>n</i> */\n-        private String getNextAncestorName(Node n) {\n-            if (!isAncestor(n)) {\n-                throw new IllegalArgumentException(this + \"is not an ancestor of \" + n);\n-            }\n-            String name = n.getNetworkLocation().substring(getPath(this).length());\n-            if (name.charAt(0) == PATH_SEPARATOR) {\n-                name = name.substring(1);\n-            }\n-            int index = name.indexOf(PATH_SEPARATOR);\n-            if (index != -1)\n-                name = name.substring(0, index);\n-            return name;\n-        }\n-\n-        /** Add node <i>n</i> to the subtree of this node\n-         * @param n node to be added\n-         * @return true if the node is added; false otherwise\n-         */\n-        boolean add(Node n) {\n-            if (!isAncestor(n))\n-                throw new IllegalArgumentException(n.getName() + \", which is located at \" + n.getNetworkLocation()\n-                        + \", is not a decendent of \" + getPath(this));\n-            if (isParent(n)) {\n-                // this node is the parent of n; add n directly\n-                n.setParent(this);\n-                n.setLevel(this.level + 1);\n-                for (int i = 0; i < children.size(); i++) {\n-                    if (children.get(i).getName().equals(n.getName())) {\n-                        children.set(i, n);\n-                        return false;\n-                    }\n-                }\n-                children.add(n);\n-                numOfLeaves++;\n-                return true;\n-            } else {\n-                // find the next ancestor node\n-                String parentName = getNextAncestorName(n);\n-                InnerNode parentNode = null;\n-                for (int i = 0; i < children.size(); i++) {\n-                    if (children.get(i).getName().equals(parentName)) {\n-                        parentNode = (InnerNode) children.get(i);\n-                        break;\n-                    }\n-                }\n-                if (parentNode == null) {\n-                    // create a new InnerNode\n-                    parentNode = createParentNode(parentName);\n-                    children.add(parentNode);\n-                }\n-                // add n to the subtree of the next ancestor node\n-                if (parentNode.add(n)) {\n-                    numOfLeaves++;\n-                    return true;\n-                } else {\n-                    return false;\n-                }\n-            }\n-        }\n-\n-        /**\n-         * Creates a parent node to be added to the list of children.\n-         * Creates a node using the InnerNode four argument constructor specifying\n-         * the name, location, parent, and level of this node.\n-         *\n-         * <p>To be overridden in subclasses for specific InnerNode implementations,\n-         * as alternative to overriding the full {@link #add(Node)} method.\n-         *\n-         * @param parentName The name of the parent node\n-         * @return A new inner node\n-         * @see InnerNode#InnerNode(String, String, InnerNode, int)\n-         */\n-        protected InnerNode createParentNode(String parentName) {\n-            return new InnerNode(parentName, getPath(this), this, this.getLevel() + 1);\n-        }\n+public interface NetworkTopology {\n \n-        /** Remove node <i>n</i> from the subtree of this node\n-         * @param n node to be deleted\n-         * @return true if the node is deleted; false otherwise\n-         */\n-        boolean remove(Node n) {\n-            String parent = n.getNetworkLocation();\n-            String currentPath = getPath(this);\n-            if (!isAncestor(n))\n-                throw new IllegalArgumentException(n.getName() + \", which is located at \" + parent\n-                        + \", is not a descendent of \" + currentPath);\n-            if (isParent(n)) {\n-                // this node is the parent of n; remove n directly\n-                for (int i = 0; i < children.size(); i++) {\n-                    if (children.get(i).getName().equals(n.getName())) {\n-                        children.remove(i);\n-                        numOfLeaves--;\n-                        n.setParent(null);\n-                        return true;\n-                    }\n-                }\n-                return false;\n-            } else {\n-                // find the next ancestor node: the parent node\n-                String parentName = getNextAncestorName(n);\n-                InnerNode parentNode = null;\n-                int i;\n-                for (i = 0; i < children.size(); i++) {\n-                    if (children.get(i).getName().equals(parentName)) {\n-                        parentNode = (InnerNode) children.get(i);\n-                        break;\n-                    }\n-                }\n-                if (parentNode == null) {\n-                    return false;\n-                }\n-                // remove n from the parent node\n-                boolean isRemoved = parentNode.remove(n);\n-                // if the parent node has no children, remove the parent node too\n-                if (isRemoved) {\n-                    if (parentNode.getNumOfChildren() == 0) {\n-                        children.remove(i);\n-                    }\n-                    numOfLeaves--;\n-                }\n-                return isRemoved;\n-            }\n-        } // end of remove\n-\n-        /** Given a node's string representation, return a reference to the node\n-         * @param loc string location of the form /rack/node\n-         * @return null if the node is not found or the childnode is there but\n-         * not an instance of {@link InnerNode}\n-         */\n-        private Node getLoc(String loc) {\n-            if (loc == null || loc.length() == 0)\n-                return this;\n-\n-            String[] path = loc.split(PATH_SEPARATOR_STR, 2);\n-            Node childnode = null;\n-            for (int i = 0; i < children.size(); i++) {\n-                if (children.get(i).getName().equals(path[0])) {\n-                    childnode = children.get(i);\n-                }\n-            }\n-            if (childnode == null)\n-                return null; // non-existing node\n-            if (path.length == 1)\n-                return childnode;\n-            if (childnode instanceof InnerNode) {\n-                return ((InnerNode) childnode).getLoc(path[1]);\n-            } else {\n-                return null;\n-            }\n-        }\n-\n-        /** get <i>leafIndex</i> leaf of this subtree\n-         * if it is not in the <i>excludedNode</i>\n-         *\n-         * @param leafIndex an indexed leaf of the node\n-         * @param excludedNode an excluded node (can be null)\n-         * @return\n-         */\n-        Node getLeaf(int leafIndex, Node excludedNode) {\n-            int count = 0;\n-            // check if the excluded node a leaf\n-            boolean isLeaf = excludedNode == null || !(excludedNode instanceof InnerNode);\n-            // calculate the total number of excluded leaf nodes\n-            int numOfExcludedLeaves = isLeaf ? 1 : ((InnerNode) excludedNode).getNumOfLeaves();\n-            if (isLeafParent()) { // children are leaves\n-                if (isLeaf) { // excluded node is a leaf node\n-                    int excludedIndex = children.indexOf(excludedNode);\n-                    if (excludedIndex != -1 && leafIndex >= 0) {\n-                        // excluded node is one of the children so adjust the leaf index\n-                        leafIndex = leafIndex >= excludedIndex ? leafIndex + 1 : leafIndex;\n-                    }\n-                }\n-                // range check\n-                if (leafIndex < 0 || leafIndex >= this.getNumOfChildren()) {\n-                    return null;\n-                }\n-                return children.get(leafIndex);\n-            } else {\n-                for (int i = 0; i < children.size(); i++) {\n-                    InnerNode child = (InnerNode) children.get(i);\n-                    if (excludedNode == null || excludedNode != child) {\n-                        // not the excludedNode\n-                        int numOfLeaves = child.getNumOfLeaves();\n-                        if (excludedNode != null && child.isAncestor(excludedNode)) {\n-                            numOfLeaves -= numOfExcludedLeaves;\n-                        }\n-                        if (count + numOfLeaves > leafIndex) {\n-                            // the leaf is in the child subtree\n-                            return child.getLeaf(leafIndex - count, excludedNode);\n-                        } else {\n-                            // go to the next child\n-                            count = count + numOfLeaves;\n-                        }\n-                    } else { // it is the excluededNode\n-                        // skip it and set the excludedNode to be null\n-                        excludedNode = null;\n-                    }\n-                }\n-                return null;\n-            }\n-        }\n-\n-        protected boolean isLeafParent() {\n-            return isRack();\n-        }\n-\n-        /**\n-          * Determine if children a leaves, default implementation calls {@link #isRack()}\n-          * <p>To be overridden in subclasses for specific InnerNode implementations,\n-          * as alternative to overriding the full {@link #getLeaf(int, Node)} method.\n-          *\n-          * @return true if children are leaves, false otherwise\n-          */\n-        protected boolean areChildrenLeaves() {\n-            return isRack();\n-        }\n-\n-        /**\n-         * Get number of leaves.\n-         */\n-        int getNumOfLeaves() {\n-            return numOfLeaves;\n-        }\n-    } // end of InnerNode\n-\n-    /**\n-     * the root cluster map\n-     */\n-    InnerNode clusterMap;\n-    /** Depth of all leaf nodes */\n-    private int depthOfAllLeaves = -1;\n-    /** rack counter */\n-    protected int numOfRacks = 0;\n-    /** the lock used to manage access */\n-    protected ReadWriteLock netlock = new ReentrantReadWriteLock();\n-\n-    public NetworkTopology() {\n-        clusterMap = new InnerNode(InnerNode.ROOT);\n-    }\n-\n-    /** Add a leaf node\n-     * Update node counter & rack counter if necessary\n-     * @param node node to be added; can be null\n-     * @exception IllegalArgumentException if add a node to a leave\n-                                           or node to be added is not a leaf\n-     */\n-    public void add(Node node) {\n-        if (node == null)\n-            return;\n-        String oldTopoStr = this.toString();\n-        if (node instanceof InnerNode) {\n-            throw new IllegalArgumentException(\"Not allow to add an inner node: \" + NodeBase.getPath(node));\n-        }\n-        int newDepth = NodeBase.locationToDepth(node.getNetworkLocation()) + 1;\n-        netlock.writeLock().lock();\n-        try {\n-            if ((depthOfAllLeaves != -1) && (depthOfAllLeaves != newDepth)) {\n-                LOG.error(\"Error: can't add leaf node at depth \" + newDepth + \" to topology:\\n\" + oldTopoStr);\n-                throw new InvalidTopologyException(\"Invalid network topology. \"\n-                        + \"You cannot have a rack and a non-rack node at the same level of the network topology.\");\n-            }\n-            Node rack = getNodeForNetworkLocation(node);\n-            if (rack != null && !(rack instanceof InnerNode)) {\n-                throw new IllegalArgumentException(\"Unexpected data node \" + node.toString()\n-                        + \" at an illegal network location\");\n-            }\n-            if (clusterMap.add(node)) {\n-                LOG.info(\"Adding a new node: \" + NodeBase.getPath(node));\n-                if (rack == null) {\n-                    numOfRacks++;\n-                }\n-                if (!(node instanceof InnerNode)) {\n-                    if (depthOfAllLeaves == -1) {\n-                        depthOfAllLeaves = node.getLevel();\n-                    }\n-                }\n-            }\n-            if (LOG.isDebugEnabled()) {\n-                LOG.debug(\"NetworkTopology became:\\n\" + this.toString());\n-            }\n-        } finally {\n-            netlock.writeLock().unlock();\n-        }\n-    }\n+    public final static String DEFAULT_REGION = \"/default-region\";\n+    public final static String DEFAULT_RACK = \"/default-region/default-rack\";\n \n     /**\n-     * Return a reference to the node given its string representation.\n-     * Default implementation delegates to {@link #getNode(String)}.\n-     *\n-     * <p>To be overridden in subclasses for specific NetworkTopology\n-     * implementations, as alternative to overriding the full {@link #add(Node)}\n-     *  method.\n+     * Add a node to the network topology\n      *\n-     * @param node The string representation of this node's network location is\n-     * used to retrieve a Node object.\n-     * @return a reference to the node; null if the node is not in the tree\n-     *\n-     * @see #add(Node)\n-     * @see #getNode(String)\n+     * @param node\n+     *          add the node to network topology\n      */\n-    protected Node getNodeForNetworkLocation(Node node) {\n-        return getNode(node.getNetworkLocation());\n-    }\n+    void add(Node node);\n \n     /**\n-     * Given a string representation of a rack, return its children\n-     * @param loc a path-like string representation of a rack\n-     * @return a newly allocated list with all the node's children\n-     */\n-    public List<Node> getDatanodesInRack(String loc) {\n-        netlock.readLock().lock();\n-        try {\n-            loc = NodeBase.normalize(loc);\n-            if (!NodeBase.ROOT.equals(loc)) {\n-                loc = loc.substring(1);\n-            }\n-            InnerNode rack = (InnerNode) clusterMap.getLoc(loc);\n-            if (rack == null) {\n-                return null;\n-            }\n-            return new ArrayList<Node>(rack.getChildren());\n-        } finally {\n-            netlock.readLock().unlock();\n-        }\n-    }\n-\n-    /** Remove a node\n-     * Update node counter and rack counter if necessary\n-     * @param node node to be removed; can be null\n-     */\n-    public void remove(Node node) {\n-        if (node == null)\n-            return;\n-        if (node instanceof InnerNode) {\n-            throw new IllegalArgumentException(\"Not allow to remove an inner node: \" + NodeBase.getPath(node));\n-        }\n-        LOG.info(\"Removing a node: \" + NodeBase.getPath(node));\n-        netlock.writeLock().lock();\n-        try {\n-            if (clusterMap.remove(node)) {\n-                InnerNode rack = (InnerNode) getNode(node.getNetworkLocation());\n-                if (rack == null) {\n-                    numOfRacks--;\n-                }\n-            }\n-            if (LOG.isDebugEnabled()) {\n-                LOG.debug(\"NetworkTopology became:\\n\" + this.toString());\n-            }\n-        } finally {\n-            netlock.writeLock().unlock();\n-        }\n-    }\n-\n-    /** Check if the tree contains node <i>node</i>\n+     * Remove a node from nework topology\n      *\n-     * @param node a node\n-     * @return true if <i>node</i> is already in the tree; false otherwise\n+     * @param node\n+     *          remove the node from network topology\n      */\n-    public boolean contains(Node node) {\n-        if (node == null)\n-            return false;\n-        netlock.readLock().lock();\n-        try {\n-            Node parent = node.getParent();\n-            for (int level = node.getLevel(); parent != null && level > 0; parent = parent.getParent(), level--) {\n-                if (parent == clusterMap) {\n-                    return true;\n-                }\n-            }\n-        } finally {\n-            netlock.readLock().unlock();\n-        }\n-        return false;\n-    }\n-\n-    /** Given a string representation of a node, return its reference\n-     *\n-     * @param loc\n-     *          a path-like string representation of a node\n-     * @return a reference to the node; null if the node is not in the tree\n-     */\n-    public Node getNode(String loc) {\n-        netlock.readLock().lock();\n-        try {\n-            loc = NodeBase.normalize(loc);\n-            if (!NodeBase.ROOT.equals(loc))\n-                loc = loc.substring(1);\n-            return clusterMap.getLoc(loc);\n-        } finally {\n-            netlock.readLock().unlock();\n-        }\n-    }\n-\n-    /** Given a string representation of a rack for a specific network\n-     *  location\n-     *\n-     * To be overridden in subclasses for specific NetworkTopology\n-     * implementations, as alternative to overriding the full\n-     * {@link #getRack(String)} method.\n-     * @param loc\n-     *          a path-like string representation of a network location\n-     * @return a rack string\n-     */\n-    public String getRack(String loc) {\n-        return loc;\n-    }\n-\n-    /** @return the total number of racks */\n-    public int getNumOfRacks() {\n-        netlock.readLock().lock();\n-        try {\n-            return numOfRacks;\n-        } finally {\n-            netlock.readLock().unlock();\n-        }\n-    }\n-\n-    /** @return the total number of leaf nodes */\n-    public int getNumOfLeaves() {\n-        netlock.readLock().lock();\n-        try {\n-            return clusterMap.getNumOfLeaves();\n-        } finally {\n-            netlock.readLock().unlock();\n-        }\n-    }\n-\n-    /** Return the distance between two nodes\n-     * It is assumed that the distance from one node to its parent is 1\n-     * The distance between two nodes is calculated by summing up their distances\n-     * to their closest common ancestor.\n-     * @param node1 one node\n-     * @param node2 another node\n-     * @return the distance between node1 and node2 which is zero if they are the same\n-     *  or {@link Integer#MAX_VALUE} if node1 or node2 do not belong to the cluster\n-     */\n-    public int getDistance(Node node1, Node node2) {\n-        if (node1 == node2) {\n-            return 0;\n-        }\n-        Node n1 = node1, n2 = node2;\n-        int dis = 0;\n-        netlock.readLock().lock();\n-        try {\n-            int level1 = node1.getLevel(), level2 = node2.getLevel();\n-            while (n1 != null && level1 > level2) {\n-                n1 = n1.getParent();\n-                level1--;\n-                dis++;\n-            }\n-            while (n2 != null && level2 > level1) {\n-                n2 = n2.getParent();\n-                level2--;\n-                dis++;\n-            }\n-            while (n1 != null && n2 != null && n1.getParent() != n2.getParent()) {\n-                n1 = n1.getParent();\n-                n2 = n2.getParent();\n-                dis += 2;\n-            }\n-        } finally {\n-            netlock.readLock().unlock();\n-        }\n-        if (n1 == null) {\n-            LOG.warn(\"The cluster does not contain node: \" + NodeBase.getPath(node1));\n-            return Integer.MAX_VALUE;\n-        }\n-        if (n2 == null) {\n-            LOG.warn(\"The cluster does not contain node: \" + NodeBase.getPath(node2));\n-            return Integer.MAX_VALUE;\n-        }\n-        return dis + 2;\n-    }\n-\n-    /** Check if two nodes are on the same rack\n-     * @param node1 one node (can be null)\n-     * @param node2 another node (can be null)\n-     * @return true if node1 and node2 are on the same rack; false otherwise\n-     * @exception IllegalArgumentException when either node1 or node2 is null, or\n-     * node1 or node2 do not belong to the cluster\n-     */\n-    public boolean isOnSameRack(Node node1, Node node2) {\n-        if (node1 == null || node2 == null) {\n-            return false;\n-        }\n-\n-        netlock.readLock().lock();\n-        try {\n-            return isSameParents(node1, node2);\n-        } finally {\n-            netlock.readLock().unlock();\n-        }\n-    }\n-\n-    /**\n-     * Check if network topology is aware of NodeGroup\n-     */\n-    public boolean isNodeGroupAware() {\n-        return false;\n-    }\n+    void remove(Node node);\n \n     /**\n-     * Return false directly as not aware of NodeGroup, to be override in sub-class\n-     */\n-    public boolean isOnSameNodeGroup(Node node1, Node node2) {\n-        return false;\n-    }\n-\n-    /**\n-     * Compare the parents of each node for equality\n-     *\n-     * <p>To be overridden in subclasses for specific NetworkTopology\n-     * implementations, as alternative to overriding the full\n-     * {@link #isOnSameRack(Node, Node)} method.\n+     * Check if the tree contains node <i>node</i>.\n      *\n-     * @param node1 the first node to compare\n-     * @param node2 the second node to compare\n-     * @return true if their parents are equal, false otherwise\n-     *\n-     * @see #isOnSameRack(Node, Node)\n-     */\n-    protected boolean isSameParents(Node node1, Node node2) {\n-        return node1.getParent() == node2.getParent();\n-    }\n-\n-    final protected static Random r = new Random();\n-\n-    /** randomly choose one node from <i>scope</i>\n-     * if scope starts with ~, choose one from the all nodes except for the\n-     * ones in <i>scope</i>; otherwise, choose one from <i>scope</i>\n-     * @param scope range of nodes from which a node will be chosen\n-     * @return the chosen node\n-     */\n-    public Node chooseRandom(String scope) {\n-        netlock.readLock().lock();\n-        try {\n-            if (scope.startsWith(\"~\")) {\n-                return chooseRandom(NodeBase.ROOT, scope.substring(1));\n-            } else {\n-                return chooseRandom(scope, null);\n-            }\n-        } finally {\n-            netlock.readLock().unlock();\n-        }\n-    }\n-\n-    private Node chooseRandom(String scope, String excludedScope) {\n-        if (excludedScope != null) {\n-            if (scope.startsWith(excludedScope)) {\n-                return null;\n-            }\n-            if (!excludedScope.startsWith(scope)) {\n-                excludedScope = null;\n-            }\n-        }\n-        Node node = getNode(scope);\n-        if (!(node instanceof InnerNode)) {\n-            return node;\n-        }\n-        InnerNode innerNode = (InnerNode) node;\n-        int numOfDatanodes = innerNode.getNumOfLeaves();\n-        if (excludedScope == null) {\n-            node = null;\n-        } else {\n-            node = getNode(excludedScope);\n-            if (!(node instanceof InnerNode)) {\n-                numOfDatanodes -= 1;\n-            } else {\n-                numOfDatanodes -= ((InnerNode) node).getNumOfLeaves();\n-            }\n-        }\n-        int leaveIndex = r.nextInt(numOfDatanodes);\n-        return innerNode.getLeaf(leaveIndex, node);\n-    }\n-\n-    /** return leaves in <i>scope</i>\n-     * @param scope a path string\n-     * @return leaves nodes under specific scope\n-     */\n-    private Set<Node> doGetLeaves(String scope) {\n-        Node node = getNode(scope);\n-        Set<Node> leafNodes = new HashSet<Node>();\n-        if (!(node instanceof InnerNode)) {\n-            leafNodes.add(node);\n-        } else {\n-            InnerNode innerNode = (InnerNode) node;\n-            for (int i = 0; i < innerNode.getNumOfLeaves(); i++) {\n-                leafNodes.add(innerNode.getLeaf(i, null));\n-            }\n-        }\n-        return leafNodes;\n-    }\n-\n-    public Set<Node> getLeaves(String scope) {\n-        netlock.readLock().lock();\n-        try {\n-            if (scope.startsWith(\"~\")) {\n-                Set<Node> allNodes = doGetLeaves(NodeBase.ROOT);\n-                Set<Node> excludeNodes = doGetLeaves(scope.substring(1));\n-                allNodes.removeAll(excludeNodes);\n-                return allNodes;\n-            } else {\n-                return doGetLeaves(scope);\n-            }\n-        } finally {\n-            netlock.readLock().unlock();\n-        }\n-    }\n-\n-    /** return the number of leaves in <i>scope</i> but not in <i>excludedNodes</i>\n-     * if scope starts with ~, return the number of nodes that are not\n-     * in <i>scope</i> and <i>excludedNodes</i>;\n-     * @param scope a path string that may start with ~\n-     * @param excludedNodes a list of nodes\n-     * @return number of available nodes\n+     * @param node\n+     *          node to check\n+     * @return true if <i>node</i> is already in the network topology, otherwise false.\n      */\n-    public int countNumOfAvailableNodes(String scope, Collection<Node> excludedNodes) {\n-        boolean isExcluded = false;\n-        if (scope.startsWith(\"~\")) {\n-            isExcluded = true;\n-            scope = scope.substring(1);\n-        }\n-        scope = NodeBase.normalize(scope);\n-        int count = 0; // the number of nodes in both scope & excludedNodes\n-        netlock.readLock().lock();\n-        try {\n-            for (Node node : excludedNodes) {\n-                if ((NodeBase.getPath(node) + NodeBase.PATH_SEPARATOR_STR).startsWith(scope\n-                        + NodeBase.PATH_SEPARATOR_STR)) {\n-                    count++;\n-                }\n-            }\n-            Node n = getNode(scope);\n-            int scopeNodeCount = 1;\n-            if (n instanceof InnerNode) {\n-                scopeNodeCount = ((InnerNode) n).getNumOfLeaves();\n-            }\n-            if (isExcluded) {\n-                return clusterMap.getNumOfLeaves() - scopeNodeCount - excludedNodes.size() + count;\n-            } else {\n-                return scopeNodeCount - count;\n-            }\n-        } finally {\n-            netlock.readLock().unlock();\n-        }\n-    }\n-\n-    /** convert a network tree to a string */\n-    @Override\n-    public String toString() {\n-        // print the number of racks\n-        StringBuilder tree = new StringBuilder();\n-        tree.append(\"Number of racks: \");\n-        tree.append(numOfRacks);\n-        tree.append(\"\\n\");\n-        // print the number of leaves\n-        int numOfLeaves = getNumOfLeaves();\n-        tree.append(\"Expected number of leaves:\");\n-        tree.append(numOfLeaves);\n-        tree.append(\"\\n\");\n-        // print nodes\n-        for (int i = 0; i < numOfLeaves; i++) {\n-            tree.append(NodeBase.getPath(clusterMap.getLeaf(i, null)));\n-            tree.append(\"\\n\");\n-        }\n-        return tree.toString();\n-    }\n+    boolean contains(Node node);\n \n     /**\n-     * Divide networklocation string into two parts by last separator, and get\n-     * the first part here.\n-     *\n-     * @param networkLocation\n+     * Retrieve a node from the network topology\n+     * @param loc\n      * @return\n      */\n-    public static String getFirstHalf(String networkLocation) {\n-        int index = networkLocation.lastIndexOf(NodeBase.PATH_SEPARATOR_STR);\n-        return networkLocation.substring(0, index);\n-    }\n+    Node getNode(String loc);\n \n     /**\n-     * Divide networklocation string into two parts by last separator, and get\n-     * the second part here.\n+     * Returns number of racks in the network topology.\n      *\n-     * @param networkLocation\n-     * @return\n+     * @return number of racks in the network topology.\n      */\n-    public static String getLastHalf(String networkLocation) {\n-        int index = networkLocation.lastIndexOf(NodeBase.PATH_SEPARATOR_STR);\n-        return networkLocation.substring(index);\n-    }\n-\n-    /** swap two array items */\n-    static protected void swap(Node[] nodes, int i, int j) {\n-        Node tempNode;\n-        tempNode = nodes[j];\n-        nodes[j] = nodes[i];\n-        nodes[i] = tempNode;\n-    }\n+    int getNumOfRacks();\n \n-    /** Sort nodes array by their distances to <i>reader</i>\n-     * It linearly scans the array, if a local node is found, swap it with\n-     * the first element of the array.\n-     * If a local rack node is found, swap it with the first element following\n-     * the local node.\n-     * If neither local node or local rack node is found, put a random replica\n-     * location at position 0.\n-     * It leaves the rest nodes untouched.\n-     * @param reader the node that wishes to read a block from one of the nodes\n-     * @param nodes the list of nodes containing data for the reader\n+    /**\n+     * Returns the nodes under a location.\n+     *\n+     * @param loc\n+     *      network location\n+     * @return nodes under a location\n      */\n-    public void pseudoSortByDistance(Node reader, Node[] nodes) {\n-        int tempIndex = 0;\n-        int localRackNode = -1;\n-        if (reader != null) {\n-            //scan the array to find the local node & local rack node\n-            for (int i = 0; i < nodes.length; i++) {\n-                if (tempIndex == 0 && reader == nodes[i]) { //local node\n-                    //swap the local node and the node at position 0\n-                    if (i != 0) {\n-                        swap(nodes, tempIndex, i);\n-                    }\n-                    tempIndex = 1;\n-                    if (localRackNode != -1) {\n-                        if (localRackNode == 0) {\n-                            localRackNode = i;\n-                        }\n-                        break;\n-                    }\n-                } else if (localRackNode == -1 && isOnSameRack(reader, nodes[i])) {\n-                    //local rack\n-                    localRackNode = i;\n-                    if (tempIndex != 0)\n-                        break;\n-                }\n-            }\n-\n-            // swap the local rack node and the node at position tempIndex\n-            if (localRackNode != -1 && localRackNode != tempIndex) {\n-                swap(nodes, tempIndex, localRackNode);\n-                tempIndex++;\n-            }\n-        }\n-\n-        // put a random node at position 0 if it is not a local/local-rack node\n-        if (tempIndex == 0 && localRackNode == -1 && nodes.length != 0) {\n-            swap(nodes, 0, r.nextInt(nodes.length));\n-        }\n-    }\n+    Set<Node> getLeaves(String loc);\n \n }"},{"sha":"78c4fe481928449620f166404df67f850da3213c","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/net/NetworkTopologyImpl.java","status":"added","additions":880,"deletions":0,"changes":880,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/bbd1eb8d8560b03834175fbd996b85237df09f5c/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fnet%2FNetworkTopologyImpl.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/bbd1eb8d8560b03834175fbd996b85237df09f5c/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fnet%2FNetworkTopologyImpl.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fnet%2FNetworkTopologyImpl.java?ref=bbd1eb8d8560b03834175fbd996b85237df09f5c","patch":"@@ -0,0 +1,880 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.bookkeeper.net;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The class represents a cluster of computer with a tree hierarchical\n+ * network topology.\n+ * For example, a cluster may be consists of many data centers filled\n+ * with racks of computers.\n+ * In a network topology, leaves represent data nodes (computers) and inner\n+ * nodes represent switches/routers that manage traffic in/out of data centers\n+ * or racks.\n+ *\n+ */\n+public class NetworkTopologyImpl implements NetworkTopology {\n+\n+    public final static int DEFAULT_HOST_LEVEL = 2;\n+    public static final Logger LOG = LoggerFactory.getLogger(NetworkTopologyImpl.class);\n+\n+    public static class InvalidTopologyException extends RuntimeException {\n+        private static final long serialVersionUID = 1L;\n+\n+        public InvalidTopologyException(String msg) {\n+            super(msg);\n+        }\n+    }\n+\n+    /** InnerNode represents a switch/router of a data center or rack.\n+     * Different from a leaf node, it has non-null children.\n+     */\n+    static class InnerNode extends NodeBase {\n+        protected List<Node> children = new ArrayList<Node>();\n+        private int numOfLeaves;\n+\n+        /** Construct an InnerNode from a path-like string */\n+        InnerNode(String path) {\n+            super(path);\n+        }\n+\n+        /** Construct an InnerNode from its name and its network location */\n+        InnerNode(String name, String location) {\n+            super(name, location);\n+        }\n+\n+        /** Construct an InnerNode\n+         * from its name, its network location, its parent, and its level */\n+        InnerNode(String name, String location, InnerNode parent, int level) {\n+            super(name, location, parent, level);\n+        }\n+\n+        /** @return its children */\n+        List<Node> getChildren() {\n+            return children;\n+        }\n+\n+        /** @return the number of children this node has */\n+        int getNumOfChildren() {\n+            return children.size();\n+        }\n+\n+        /** Judge if this node represents a rack\n+         * @return true if it has no child or its children are not InnerNodes\n+         */\n+        boolean isRack() {\n+            if (children.isEmpty()) {\n+                return true;\n+            }\n+\n+            Node firstChild = children.get(0);\n+            if (firstChild instanceof InnerNode) {\n+                return false;\n+            }\n+\n+            return true;\n+        }\n+\n+        /** Judge if this node is an ancestor of node <i>n</i>\n+         *\n+         * @param n a node\n+         * @return true if this node is an ancestor of <i>n</i>\n+         */\n+        boolean isAncestor(Node n) {\n+            return getPath(this).equals(NodeBase.PATH_SEPARATOR_STR)\n+                    || (n.getNetworkLocation() + NodeBase.PATH_SEPARATOR_STR).startsWith(getPath(this)\n+                            + NodeBase.PATH_SEPARATOR_STR);\n+        }\n+\n+        /** Judge if this node is the parent of node <i>n</i>\n+         *\n+         * @param n a node\n+         * @return true if this node is the parent of <i>n</i>\n+         */\n+        boolean isParent(Node n) {\n+            return n.getNetworkLocation().equals(getPath(this));\n+        }\n+\n+        /* Return a child name of this node who is an ancestor of node <i>n</i> */\n+        private String getNextAncestorName(Node n) {\n+            if (!isAncestor(n)) {\n+                throw new IllegalArgumentException(this + \"is not an ancestor of \" + n);\n+            }\n+            String name = n.getNetworkLocation().substring(getPath(this).length());\n+            if (name.charAt(0) == PATH_SEPARATOR) {\n+                name = name.substring(1);\n+            }\n+            int index = name.indexOf(PATH_SEPARATOR);\n+            if (index != -1)\n+                name = name.substring(0, index);\n+            return name;\n+        }\n+\n+        /** Add node <i>n</i> to the subtree of this node\n+         * @param n node to be added\n+         * @return true if the node is added; false otherwise\n+         */\n+        boolean add(Node n) {\n+            if (!isAncestor(n))\n+                throw new IllegalArgumentException(n.getName() + \", which is located at \" + n.getNetworkLocation()\n+                        + \", is not a decendent of \" + getPath(this));\n+            if (isParent(n)) {\n+                // this node is the parent of n; add n directly\n+                n.setParent(this);\n+                n.setLevel(this.level + 1);\n+                for (int i = 0; i < children.size(); i++) {\n+                    if (children.get(i).getName().equals(n.getName())) {\n+                        children.set(i, n);\n+                        return false;\n+                    }\n+                }\n+                children.add(n);\n+                numOfLeaves++;\n+                return true;\n+            } else {\n+                // find the next ancestor node\n+                String parentName = getNextAncestorName(n);\n+                InnerNode parentNode = null;\n+                for (int i = 0; i < children.size(); i++) {\n+                    if (children.get(i).getName().equals(parentName)) {\n+                        parentNode = (InnerNode) children.get(i);\n+                        break;\n+                    }\n+                }\n+                if (parentNode == null) {\n+                    // create a new InnerNode\n+                    parentNode = createParentNode(parentName);\n+                    children.add(parentNode);\n+                }\n+                // add n to the subtree of the next ancestor node\n+                if (parentNode.add(n)) {\n+                    numOfLeaves++;\n+                    return true;\n+                } else {\n+                    return false;\n+                }\n+            }\n+        }\n+\n+        /**\n+         * Creates a parent node to be added to the list of children.\n+         * Creates a node using the InnerNode four argument constructor specifying\n+         * the name, location, parent, and level of this node.\n+         *\n+         * <p>To be overridden in subclasses for specific InnerNode implementations,\n+         * as alternative to overriding the full {@link #add(Node)} method.\n+         *\n+         * @param parentName The name of the parent node\n+         * @return A new inner node\n+         * @see InnerNode#InnerNode(String, String, InnerNode, int)\n+         */\n+        protected InnerNode createParentNode(String parentName) {\n+            return new InnerNode(parentName, getPath(this), this, this.getLevel() + 1);\n+        }\n+\n+        /** Remove node <i>n</i> from the subtree of this node\n+         * @param n node to be deleted\n+         * @return true if the node is deleted; false otherwise\n+         */\n+        boolean remove(Node n) {\n+            String parent = n.getNetworkLocation();\n+            String currentPath = getPath(this);\n+            if (!isAncestor(n))\n+                throw new IllegalArgumentException(n.getName() + \", which is located at \" + parent\n+                        + \", is not a descendent of \" + currentPath);\n+            if (isParent(n)) {\n+                // this node is the parent of n; remove n directly\n+                for (int i = 0; i < children.size(); i++) {\n+                    if (children.get(i).getName().equals(n.getName())) {\n+                        children.remove(i);\n+                        numOfLeaves--;\n+                        n.setParent(null);\n+                        return true;\n+                    }\n+                }\n+                return false;\n+            } else {\n+                // find the next ancestor node: the parent node\n+                String parentName = getNextAncestorName(n);\n+                InnerNode parentNode = null;\n+                int i;\n+                for (i = 0; i < children.size(); i++) {\n+                    if (children.get(i).getName().equals(parentName)) {\n+                        parentNode = (InnerNode) children.get(i);\n+                        break;\n+                    }\n+                }\n+                if (parentNode == null) {\n+                    return false;\n+                }\n+                // remove n from the parent node\n+                boolean isRemoved = parentNode.remove(n);\n+                // if the parent node has no children, remove the parent node too\n+                if (isRemoved) {\n+                    if (parentNode.getNumOfChildren() == 0) {\n+                        children.remove(i);\n+                    }\n+                    numOfLeaves--;\n+                }\n+                return isRemoved;\n+            }\n+        } // end of remove\n+\n+        /** Given a node's string representation, return a reference to the node\n+         * @param loc string location of the form /rack/node\n+         * @return null if the node is not found or the childnode is there but\n+         * not an instance of {@link InnerNode}\n+         */\n+        private Node getLoc(String loc) {\n+            if (loc == null || loc.length() == 0)\n+                return this;\n+\n+            String[] path = loc.split(PATH_SEPARATOR_STR, 2);\n+            Node childnode = null;\n+            for (int i = 0; i < children.size(); i++) {\n+                if (children.get(i).getName().equals(path[0])) {\n+                    childnode = children.get(i);\n+                }\n+            }\n+            if (childnode == null)\n+                return null; // non-existing node\n+            if (path.length == 1)\n+                return childnode;\n+            if (childnode instanceof InnerNode) {\n+                return ((InnerNode) childnode).getLoc(path[1]);\n+            } else {\n+                return null;\n+            }\n+        }\n+\n+        /** get <i>leafIndex</i> leaf of this subtree\n+         * if it is not in the <i>excludedNode</i>\n+         *\n+         * @param leafIndex an indexed leaf of the node\n+         * @param excludedNode an excluded node (can be null)\n+         * @return\n+         */\n+        Node getLeaf(int leafIndex, Node excludedNode) {\n+            int count = 0;\n+            // check if the excluded node a leaf\n+            boolean isLeaf = excludedNode == null || !(excludedNode instanceof InnerNode);\n+            // calculate the total number of excluded leaf nodes\n+            int numOfExcludedLeaves = isLeaf ? 1 : ((InnerNode) excludedNode).getNumOfLeaves();\n+            if (isLeafParent()) { // children are leaves\n+                if (isLeaf) { // excluded node is a leaf node\n+                    int excludedIndex = children.indexOf(excludedNode);\n+                    if (excludedIndex != -1 && leafIndex >= 0) {\n+                        // excluded node is one of the children so adjust the leaf index\n+                        leafIndex = leafIndex >= excludedIndex ? leafIndex + 1 : leafIndex;\n+                    }\n+                }\n+                // range check\n+                if (leafIndex < 0 || leafIndex >= this.getNumOfChildren()) {\n+                    return null;\n+                }\n+                return children.get(leafIndex);\n+            } else {\n+                for (int i = 0; i < children.size(); i++) {\n+                    InnerNode child = (InnerNode) children.get(i);\n+                    if (excludedNode == null || excludedNode != child) {\n+                        // not the excludedNode\n+                        int numOfLeaves = child.getNumOfLeaves();\n+                        if (excludedNode != null && child.isAncestor(excludedNode)) {\n+                            numOfLeaves -= numOfExcludedLeaves;\n+                        }\n+                        if (count + numOfLeaves > leafIndex) {\n+                            // the leaf is in the child subtree\n+                            return child.getLeaf(leafIndex - count, excludedNode);\n+                        } else {\n+                            // go to the next child\n+                            count = count + numOfLeaves;\n+                        }\n+                    } else { // it is the excluededNode\n+                        // skip it and set the excludedNode to be null\n+                        excludedNode = null;\n+                    }\n+                }\n+                return null;\n+            }\n+        }\n+\n+        protected boolean isLeafParent() {\n+            return isRack();\n+        }\n+\n+        /**\n+          * Determine if children a leaves, default implementation calls {@link #isRack()}\n+          * <p>To be overridden in subclasses for specific InnerNode implementations,\n+          * as alternative to overriding the full {@link #getLeaf(int, Node)} method.\n+          *\n+          * @return true if children are leaves, false otherwise\n+          */\n+        protected boolean areChildrenLeaves() {\n+            return isRack();\n+        }\n+\n+        /**\n+         * Get number of leaves.\n+         */\n+        int getNumOfLeaves() {\n+            return numOfLeaves;\n+        }\n+    } // end of InnerNode\n+\n+    /**\n+     * the root cluster map\n+     */\n+    InnerNode clusterMap;\n+    /** Depth of all leaf nodes */\n+    private int depthOfAllLeaves = -1;\n+    /** rack counter */\n+    protected int numOfRacks = 0;\n+    /** the lock used to manage access */\n+    protected ReadWriteLock netlock = new ReentrantReadWriteLock();\n+\n+    public NetworkTopologyImpl() {\n+        clusterMap = new InnerNode(InnerNode.ROOT);\n+    }\n+\n+    /** Add a leaf node\n+     * Update node counter & rack counter if necessary\n+     * @param node node to be added; can be null\n+     * @exception IllegalArgumentException if add a node to a leave\n+                                           or node to be added is not a leaf\n+     */\n+    public void add(Node node) {\n+        if (node == null)\n+            return;\n+        String oldTopoStr = this.toString();\n+        if (node instanceof InnerNode) {\n+            throw new IllegalArgumentException(\"Not allow to add an inner node: \" + NodeBase.getPath(node));\n+        }\n+        int newDepth = NodeBase.locationToDepth(node.getNetworkLocation()) + 1;\n+        netlock.writeLock().lock();\n+        try {\n+            if ((depthOfAllLeaves != -1) && (depthOfAllLeaves != newDepth)) {\n+                LOG.error(\"Error: can't add leaf node at depth \" + newDepth + \" to topology:\\n\" + oldTopoStr);\n+                throw new InvalidTopologyException(\"Invalid network topology. \"\n+                        + \"You cannot have a rack and a non-rack node at the same level of the network topology.\");\n+            }\n+            Node rack = getNodeForNetworkLocation(node);\n+            if (rack != null && !(rack instanceof InnerNode)) {\n+                throw new IllegalArgumentException(\"Unexpected data node \" + node.toString()\n+                        + \" at an illegal network location\");\n+            }\n+            if (clusterMap.add(node)) {\n+                LOG.info(\"Adding a new node: \" + NodeBase.getPath(node));\n+                if (rack == null) {\n+                    numOfRacks++;\n+                }\n+                if (!(node instanceof InnerNode)) {\n+                    if (depthOfAllLeaves == -1) {\n+                        depthOfAllLeaves = node.getLevel();\n+                    }\n+                }\n+            }\n+            if (LOG.isDebugEnabled()) {\n+                LOG.debug(\"NetworkTopology became:\\n\" + this.toString());\n+            }\n+        } finally {\n+            netlock.writeLock().unlock();\n+        }\n+    }\n+\n+    /**\n+     * Return a reference to the node given its string representation.\n+     * Default implementation delegates to {@link #getNode(String)}.\n+     *\n+     * <p>To be overridden in subclasses for specific NetworkTopology\n+     * implementations, as alternative to overriding the full {@link #add(Node)}\n+     *  method.\n+     *\n+     * @param node The string representation of this node's network location is\n+     * used to retrieve a Node object.\n+     * @return a reference to the node; null if the node is not in the tree\n+     *\n+     * @see #add(Node)\n+     * @see #getNode(String)\n+     */\n+    protected Node getNodeForNetworkLocation(Node node) {\n+        return getNode(node.getNetworkLocation());\n+    }\n+\n+    /**\n+     * Given a string representation of a rack, return its children\n+     * @param loc a path-like string representation of a rack\n+     * @return a newly allocated list with all the node's children\n+     */\n+    public List<Node> getDatanodesInRack(String loc) {\n+        netlock.readLock().lock();\n+        try {\n+            loc = NodeBase.normalize(loc);\n+            if (!NodeBase.ROOT.equals(loc)) {\n+                loc = loc.substring(1);\n+            }\n+            InnerNode rack = (InnerNode) clusterMap.getLoc(loc);\n+            if (rack == null) {\n+                return null;\n+            }\n+            return new ArrayList<Node>(rack.getChildren());\n+        } finally {\n+            netlock.readLock().unlock();\n+        }\n+    }\n+\n+    /** Remove a node\n+     * Update node counter and rack counter if necessary\n+     * @param node node to be removed; can be null\n+     */\n+    @Override\n+    public void remove(Node node) {\n+        if (node == null)\n+            return;\n+        if (node instanceof InnerNode) {\n+            throw new IllegalArgumentException(\"Not allow to remove an inner node: \" + NodeBase.getPath(node));\n+        }\n+        LOG.info(\"Removing a node: \" + NodeBase.getPath(node));\n+        netlock.writeLock().lock();\n+        try {\n+            if (clusterMap.remove(node)) {\n+                InnerNode rack = (InnerNode) getNode(node.getNetworkLocation());\n+                if (rack == null) {\n+                    numOfRacks--;\n+                }\n+            }\n+            if (LOG.isDebugEnabled()) {\n+                LOG.debug(\"NetworkTopology became:\\n\" + this.toString());\n+            }\n+        } finally {\n+            netlock.writeLock().unlock();\n+        }\n+    }\n+\n+    /** Check if the tree contains node <i>node</i>\n+     *\n+     * @param node a node\n+     * @return true if <i>node</i> is already in the tree; false otherwise\n+     */\n+    @Override\n+    public boolean contains(Node node) {\n+        if (node == null)\n+            return false;\n+        netlock.readLock().lock();\n+        try {\n+            Node parent = node.getParent();\n+            for (int level = node.getLevel(); parent != null && level > 0; parent = parent.getParent(), level--) {\n+                if (parent == clusterMap) {\n+                    return true;\n+                }\n+            }\n+        } finally {\n+            netlock.readLock().unlock();\n+        }\n+        return false;\n+    }\n+\n+    /** Given a string representation of a node, return its reference\n+     *\n+     * @param loc\n+     *          a path-like string representation of a node\n+     * @return a reference to the node; null if the node is not in the tree\n+     */\n+    @Override\n+    public Node getNode(String loc) {\n+        netlock.readLock().lock();\n+        try {\n+            loc = NodeBase.normalize(loc);\n+            if (!NodeBase.ROOT.equals(loc))\n+                loc = loc.substring(1);\n+            return clusterMap.getLoc(loc);\n+        } finally {\n+            netlock.readLock().unlock();\n+        }\n+    }\n+\n+    /** Given a string representation of a rack for a specific network\n+     *  location\n+     *\n+     * To be overridden in subclasses for specific NetworkTopology\n+     * implementations, as alternative to overriding the full\n+     * {@link #getRack(String)} method.\n+     * @param loc\n+     *          a path-like string representation of a network location\n+     * @return a rack string\n+     */\n+    public String getRack(String loc) {\n+        return loc;\n+    }\n+\n+    /** @return the total number of racks */\n+    @Override\n+    public int getNumOfRacks() {\n+        netlock.readLock().lock();\n+        try {\n+            return numOfRacks;\n+        } finally {\n+            netlock.readLock().unlock();\n+        }\n+    }\n+\n+    /** @return the total number of leaf nodes */\n+    public int getNumOfLeaves() {\n+        netlock.readLock().lock();\n+        try {\n+            return clusterMap.getNumOfLeaves();\n+        } finally {\n+            netlock.readLock().unlock();\n+        }\n+    }\n+\n+    /** Return the distance between two nodes\n+     * It is assumed that the distance from one node to its parent is 1\n+     * The distance between two nodes is calculated by summing up their distances\n+     * to their closest common ancestor.\n+     * @param node1 one node\n+     * @param node2 another node\n+     * @return the distance between node1 and node2 which is zero if they are the same\n+     *  or {@link Integer#MAX_VALUE} if node1 or node2 do not belong to the cluster\n+     */\n+    public int getDistance(Node node1, Node node2) {\n+        if (node1 == node2) {\n+            return 0;\n+        }\n+        Node n1 = node1, n2 = node2;\n+        int dis = 0;\n+        netlock.readLock().lock();\n+        try {\n+            int level1 = node1.getLevel(), level2 = node2.getLevel();\n+            while (n1 != null && level1 > level2) {\n+                n1 = n1.getParent();\n+                level1--;\n+                dis++;\n+            }\n+            while (n2 != null && level2 > level1) {\n+                n2 = n2.getParent();\n+                level2--;\n+                dis++;\n+            }\n+            while (n1 != null && n2 != null && n1.getParent() != n2.getParent()) {\n+                n1 = n1.getParent();\n+                n2 = n2.getParent();\n+                dis += 2;\n+            }\n+        } finally {\n+            netlock.readLock().unlock();\n+        }\n+        if (n1 == null) {\n+            LOG.warn(\"The cluster does not contain node: {}\", NodeBase.getPath(node1));\n+            return Integer.MAX_VALUE;\n+        }\n+        if (n2 == null) {\n+            LOG.warn(\"The cluster does not contain node: {}\", NodeBase.getPath(node2));\n+            return Integer.MAX_VALUE;\n+        }\n+        return dis + 2;\n+    }\n+\n+    /** Check if two nodes are on the same rack\n+     * @param node1 one node (can be null)\n+     * @param node2 another node (can be null)\n+     * @return true if node1 and node2 are on the same rack; false otherwise\n+     * @exception IllegalArgumentException when either node1 or node2 is null, or\n+     * node1 or node2 do not belong to the cluster\n+     */\n+    public boolean isOnSameRack(Node node1, Node node2) {\n+        if (node1 == null || node2 == null) {\n+            return false;\n+        }\n+\n+        netlock.readLock().lock();\n+        try {\n+            return isSameParents(node1, node2);\n+        } finally {\n+            netlock.readLock().unlock();\n+        }\n+    }\n+\n+    /**\n+     * Check if network topology is aware of NodeGroup\n+     */\n+    public boolean isNodeGroupAware() {\n+        return false;\n+    }\n+\n+    /**\n+     * Return false directly as not aware of NodeGroup, to be override in sub-class\n+     */\n+    public boolean isOnSameNodeGroup(Node node1, Node node2) {\n+        return false;\n+    }\n+\n+    /**\n+     * Compare the parents of each node for equality\n+     *\n+     * <p>To be overridden in subclasses for specific NetworkTopology\n+     * implementations, as alternative to overriding the full\n+     * {@link #isOnSameRack(Node, Node)} method.\n+     *\n+     * @param node1 the first node to compare\n+     * @param node2 the second node to compare\n+     * @return true if their parents are equal, false otherwise\n+     *\n+     * @see #isOnSameRack(Node, Node)\n+     */\n+    protected boolean isSameParents(Node node1, Node node2) {\n+        return node1.getParent() == node2.getParent();\n+    }\n+\n+    final protected static Random r = new Random();\n+\n+    /** randomly choose one node from <i>scope</i>\n+     * if scope starts with ~, choose one from the all nodes except for the\n+     * ones in <i>scope</i>; otherwise, choose one from <i>scope</i>\n+     * @param scope range of nodes from which a node will be chosen\n+     * @return the chosen node\n+     */\n+    public Node chooseRandom(String scope) {\n+        netlock.readLock().lock();\n+        try {\n+            if (scope.startsWith(\"~\")) {\n+                return chooseRandom(NodeBase.ROOT, scope.substring(1));\n+            } else {\n+                return chooseRandom(scope, null);\n+            }\n+        } finally {\n+            netlock.readLock().unlock();\n+        }\n+    }\n+\n+    private Node chooseRandom(String scope, String excludedScope) {\n+        if (excludedScope != null) {\n+            if (scope.startsWith(excludedScope)) {\n+                return null;\n+            }\n+            if (!excludedScope.startsWith(scope)) {\n+                excludedScope = null;\n+            }\n+        }\n+        Node node = getNode(scope);\n+        if (!(node instanceof InnerNode)) {\n+            return node;\n+        }\n+        InnerNode innerNode = (InnerNode) node;\n+        int numOfDatanodes = innerNode.getNumOfLeaves();\n+        if (excludedScope == null) {\n+            node = null;\n+        } else {\n+            node = getNode(excludedScope);\n+            if (!(node instanceof InnerNode)) {\n+                numOfDatanodes -= 1;\n+            } else {\n+                numOfDatanodes -= ((InnerNode) node).getNumOfLeaves();\n+            }\n+        }\n+        int leaveIndex = r.nextInt(numOfDatanodes);\n+        return innerNode.getLeaf(leaveIndex, node);\n+    }\n+\n+    /** return leaves in <i>scope</i>\n+     * @param scope a path string\n+     * @return leaves nodes under specific scope\n+     */\n+    private Set<Node> doGetLeaves(String scope) {\n+        Node node = getNode(scope);\n+        Set<Node> leafNodes = new HashSet<Node>();\n+        if (!(node instanceof InnerNode)) {\n+            leafNodes.add(node);\n+        } else {\n+            InnerNode innerNode = (InnerNode) node;\n+            for (int i = 0; i < innerNode.getNumOfLeaves(); i++) {\n+                leafNodes.add(innerNode.getLeaf(i, null));\n+            }\n+        }\n+        return leafNodes;\n+    }\n+\n+    @Override\n+    public Set<Node> getLeaves(String scope) {\n+        netlock.readLock().lock();\n+        try {\n+            if (scope.startsWith(\"~\")) {\n+                Set<Node> allNodes = doGetLeaves(NodeBase.ROOT);\n+                Set<Node> excludeNodes = doGetLeaves(scope.substring(1));\n+                allNodes.removeAll(excludeNodes);\n+                return allNodes;\n+            } else {\n+                return doGetLeaves(scope);\n+            }\n+        } finally {\n+            netlock.readLock().unlock();\n+        }\n+    }\n+\n+    /** return the number of leaves in <i>scope</i> but not in <i>excludedNodes</i>\n+     * if scope starts with ~, return the number of nodes that are not\n+     * in <i>scope</i> and <i>excludedNodes</i>;\n+     * @param scope a path string that may start with ~\n+     * @param excludedNodes a list of nodes\n+     * @return number of available nodes\n+     */\n+    public int countNumOfAvailableNodes(String scope, Collection<Node> excludedNodes) {\n+        boolean isExcluded = false;\n+        if (scope.startsWith(\"~\")) {\n+            isExcluded = true;\n+            scope = scope.substring(1);\n+        }\n+        scope = NodeBase.normalize(scope);\n+        int count = 0; // the number of nodes in both scope & excludedNodes\n+        netlock.readLock().lock();\n+        try {\n+            for (Node node : excludedNodes) {\n+                if ((NodeBase.getPath(node) + NodeBase.PATH_SEPARATOR_STR).startsWith(scope\n+                        + NodeBase.PATH_SEPARATOR_STR)) {\n+                    count++;\n+                }\n+            }\n+            Node n = getNode(scope);\n+            int scopeNodeCount = 1;\n+            if (n instanceof InnerNode) {\n+                scopeNodeCount = ((InnerNode) n).getNumOfLeaves();\n+            }\n+            if (isExcluded) {\n+                return clusterMap.getNumOfLeaves() - scopeNodeCount - excludedNodes.size() + count;\n+            } else {\n+                return scopeNodeCount - count;\n+            }\n+        } finally {\n+            netlock.readLock().unlock();\n+        }\n+    }\n+\n+    /** convert a network tree to a string */\n+    @Override\n+    public String toString() {\n+        // print the number of racks\n+        StringBuilder tree = new StringBuilder();\n+        tree.append(\"Number of racks: \");\n+        tree.append(numOfRacks);\n+        tree.append(\"\\n\");\n+        // print the number of leaves\n+        int numOfLeaves = getNumOfLeaves();\n+        tree.append(\"Expected number of leaves:\");\n+        tree.append(numOfLeaves);\n+        tree.append(\"\\n\");\n+        // print nodes\n+        for (int i = 0; i < numOfLeaves; i++) {\n+            tree.append(NodeBase.getPath(clusterMap.getLeaf(i, null)));\n+            tree.append(\"\\n\");\n+        }\n+        return tree.toString();\n+    }\n+\n+    /**\n+     * Divide networklocation string into two parts by last separator, and get\n+     * the first part here.\n+     *\n+     * @param networkLocation\n+     * @return\n+     */\n+    public static String getFirstHalf(String networkLocation) {\n+        int index = networkLocation.lastIndexOf(NodeBase.PATH_SEPARATOR_STR);\n+        return networkLocation.substring(0, index);\n+    }\n+\n+    /**\n+     * Divide networklocation string into two parts by last separator, and get\n+     * the second part here.\n+     *\n+     * @param networkLocation\n+     * @return\n+     */\n+    public static String getLastHalf(String networkLocation) {\n+        int index = networkLocation.lastIndexOf(NodeBase.PATH_SEPARATOR_STR);\n+        return networkLocation.substring(index);\n+    }\n+\n+    /** swap two array items */\n+    static protected void swap(Node[] nodes, int i, int j) {\n+        Node tempNode;\n+        tempNode = nodes[j];\n+        nodes[j] = nodes[i];\n+        nodes[i] = tempNode;\n+    }\n+\n+    /** Sort nodes array by their distances to <i>reader</i>\n+     * It linearly scans the array, if a local node is found, swap it with\n+     * the first element of the array.\n+     * If a local rack node is found, swap it with the first element following\n+     * the local node.\n+     * If neither local node or local rack node is found, put a random replica\n+     * location at position 0.\n+     * It leaves the rest nodes untouched.\n+     * @param reader the node that wishes to read a block from one of the nodes\n+     * @param nodes the list of nodes containing data for the reader\n+     */\n+    public void pseudoSortByDistance(Node reader, Node[] nodes) {\n+        int tempIndex = 0;\n+        int localRackNode = -1;\n+        if (reader != null) {\n+            //scan the array to find the local node & local rack node\n+            for (int i = 0; i < nodes.length; i++) {\n+                if (tempIndex == 0 && reader == nodes[i]) { //local node\n+                    //swap the local node and the node at position 0\n+                    if (i != 0) {\n+                        swap(nodes, tempIndex, i);\n+                    }\n+                    tempIndex = 1;\n+                    if (localRackNode != -1) {\n+                        if (localRackNode == 0) {\n+                            localRackNode = i;\n+                        }\n+                        break;\n+                    }\n+                } else if (localRackNode == -1 && isOnSameRack(reader, nodes[i])) {\n+                    //local rack\n+                    localRackNode = i;\n+                    if (tempIndex != 0)\n+                        break;\n+                }\n+            }\n+\n+            // swap the local rack node and the node at position tempIndex\n+            if (localRackNode != -1 && localRackNode != tempIndex) {\n+                swap(nodes, tempIndex, localRackNode);\n+                tempIndex++;\n+            }\n+        }\n+\n+        // put a random node at position 0 if it is not a local/local-rack node\n+        if (tempIndex == 0 && localRackNode == -1 && nodes.length != 0) {\n+            swap(nodes, 0, r.nextInt(nodes.length));\n+        }\n+    }\n+\n+}"},{"sha":"62ec6c0ca97b7589c3e6ce4b7ddbbf513e9b7a8d","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/net/Node.java","status":"modified","additions":3,"deletions":1,"changes":4,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/bbd1eb8d8560b03834175fbd996b85237df09f5c/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fnet%2FNode.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/bbd1eb8d8560b03834175fbd996b85237df09f5c/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fnet%2FNode.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fnet%2FNode.java?ref=bbd1eb8d8560b03834175fbd996b85237df09f5c","patch":"@@ -15,7 +15,6 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-// This code has been copied from hadoop-common 0.23.1\n package org.apache.bookkeeper.net;\n \n import com.google.common.annotations.Beta;\n@@ -31,6 +30,9 @@\n  */\n @Beta\n public interface Node {\n+    /** @return the string representation of this node's network location at the specified level in the hierarchy*/\n+    public String getNetworkLocation(int level);\n+\n     /** @return the string representation of this node's network location */\n     public String getNetworkLocation();\n "},{"sha":"13ddfce4c7d1ec6a158e3e68ff9878403aa5b0ef","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/net/NodeBase.java","status":"modified","additions":14,"deletions":1,"changes":15,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/bbd1eb8d8560b03834175fbd996b85237df09f5c/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fnet%2FNodeBase.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/bbd1eb8d8560b03834175fbd996b85237df09f5c/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fnet%2FNodeBase.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fnet%2FNodeBase.java?ref=bbd1eb8d8560b03834175fbd996b85237df09f5c","patch":"@@ -15,7 +15,6 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-// This code has been copied from hadoop-common 0.23.1\n package org.apache.bookkeeper.net;\n \n /** A base class that implements interface Node\n@@ -183,4 +182,18 @@ public static int locationToDepth(String location) {\n         }\n         return depth;\n     }\n+\n+    @Override\n+    public String getNetworkLocation(int distanceFromLeaves) {\n+        Node node = this;\n+        while (distanceFromLeaves > 1) {\n+            Node parent = node.getParent();\n+            if (null == parent) {\n+                break;\n+            }\n+            node = parent;\n+            distanceFromLeaves--;\n+        }\n+        return node.getNetworkLocation();\n+    }\n }"},{"sha":"dd8563cc058ca7e118005ddc5baaf9c6d825ffe9","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/net/ScriptBasedMapping.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/bbd1eb8d8560b03834175fbd996b85237df09f5c/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fnet%2FScriptBasedMapping.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/bbd1eb8d8560b03834175fbd996b85237df09f5c/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fnet%2FScriptBasedMapping.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fnet%2FScriptBasedMapping.java?ref=bbd1eb8d8560b03834175fbd996b85237df09f5c","patch":"@@ -15,7 +15,7 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-// This code has been copied from hadoop-common 0.23.1\n+\n package org.apache.bookkeeper.net;\n \n import java.io.File;"},{"sha":"5dce90673b983ac51de0e261c88085fd26d51f4f","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/net/StabilizeNetworkTopology.java","status":"added","additions":154,"deletions":0,"changes":154,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/bbd1eb8d8560b03834175fbd996b85237df09f5c/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fnet%2FStabilizeNetworkTopology.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/bbd1eb8d8560b03834175fbd996b85237df09f5c/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fnet%2FStabilizeNetworkTopology.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fnet%2FStabilizeNetworkTopology.java?ref=bbd1eb8d8560b03834175fbd996b85237df09f5c","patch":"@@ -0,0 +1,154 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.bookkeeper.net;\n+\n+import org.apache.bookkeeper.util.MathUtils;\n+import org.jboss.netty.util.HashedWheelTimer;\n+import org.jboss.netty.util.Timeout;\n+import org.jboss.netty.util.TimerTask;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * This is going to provide a stabilize network topology regarding to flapping zookeeper registration.\n+ */\n+public class StabilizeNetworkTopology implements NetworkTopology {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(StabilizeNetworkTopology.class);\n+\n+    static class NodeStatus {\n+        long lastPresentTime;\n+        boolean tentativeToRemove;\n+\n+        NodeStatus() {\n+            this.lastPresentTime = MathUtils.now();\n+        }\n+\n+        synchronized boolean isTentativeToRemove() {\n+            return tentativeToRemove;\n+        }\n+\n+        synchronized NodeStatus updateStatus(boolean tentativeToRemove) {\n+            this.tentativeToRemove = tentativeToRemove;\n+            if (!this.tentativeToRemove) {\n+                this.lastPresentTime = MathUtils.now();\n+            }\n+            return this;\n+        }\n+\n+        synchronized long getLastPresentTime() {\n+            return this.lastPresentTime;\n+        }\n+    }\n+\n+    protected final NetworkTopologyImpl impl;\n+    // timer\n+    protected final HashedWheelTimer timer;\n+    // statuses\n+    protected final ConcurrentMap<Node, NodeStatus> nodeStatuses;\n+    // stabilize period seconds\n+    protected final long stabilizePeriodMillis;\n+\n+    private class RemoveNodeTask implements TimerTask {\n+\n+        private final Node node;\n+\n+        RemoveNodeTask(Node node) {\n+            this.node = node;\n+        }\n+\n+        @Override\n+        public void run(Timeout timeout) throws Exception {\n+            if (timeout.isCancelled()) {\n+                return;\n+            }\n+            NodeStatus status = nodeStatuses.get(node);\n+            if (null == status) {\n+                // no status of this node, remove this node from topology\n+                impl.remove(node);\n+            } else if (status.isTentativeToRemove()) {\n+                long millisSinceLastSeen = MathUtils.now() - status.getLastPresentTime();\n+                if (millisSinceLastSeen >= stabilizePeriodMillis) {\n+                    logger.info(\"Node {} (seen @ {}) becomes stale for {} ms, remove it from the topology.\",\n+                            new Object[] { node, status.getLastPresentTime(), millisSinceLastSeen });\n+                    impl.remove(node);\n+                    nodeStatuses.remove(node, status);\n+                }\n+            }\n+        }\n+    }\n+\n+    public StabilizeNetworkTopology(HashedWheelTimer timer,\n+                                    int stabilizePeriodSeconds) {\n+        this.impl = new NetworkTopologyImpl();\n+        this.timer = timer;\n+        this.nodeStatuses = new ConcurrentHashMap<Node, NodeStatus>();\n+        this.stabilizePeriodMillis = TimeUnit.SECONDS.toMillis(stabilizePeriodSeconds);\n+    }\n+\n+    void updateNode(Node node, boolean tentativeToRemove) {\n+        NodeStatus ns = nodeStatuses.get(node);\n+        if (null == ns) {\n+            NodeStatus newStatus = new NodeStatus();\n+            NodeStatus oldStatus = nodeStatuses.putIfAbsent(node, newStatus);\n+            if (null == oldStatus) {\n+                ns = newStatus;\n+            } else {\n+                ns = oldStatus;\n+            }\n+        }\n+        ns.updateStatus(tentativeToRemove);\n+    }\n+\n+    @Override\n+    public void add(Node node) {\n+        updateNode(node, false);\n+        this.impl.add(node);\n+    }\n+\n+    @Override\n+    public void remove(Node node) {\n+        updateNode(node, true);\n+        timer.newTimeout(new RemoveNodeTask(node), stabilizePeriodMillis, TimeUnit.MILLISECONDS);\n+    }\n+\n+    @Override\n+    public boolean contains(Node node) {\n+        return impl.contains(node);\n+    }\n+\n+    @Override\n+    public Node getNode(String loc) {\n+        return impl.getNode(loc);\n+    }\n+\n+    @Override\n+    public int getNumOfRacks() {\n+        return impl.getNumOfRacks();\n+    }\n+\n+    @Override\n+    public Set<Node> getLeaves(String loc) {\n+        return impl.getLeaves(loc);\n+    }\n+}"},{"sha":"274fd36658cb0e79c5b31fe941365eda3be2f569","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/bbd1eb8d8560b03834175fbd996b85237df09f5c/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FPerChannelBookieClient.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/bbd1eb8d8560b03834175fbd996b85237df09f5c/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FPerChannelBookieClient.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FPerChannelBookieClient.java?ref=bbd1eb8d8560b03834175fbd996b85237df09f5c","patch":"@@ -180,7 +180,7 @@ public PerChannelBookieClient(ClientConfiguration conf, OrderedSafeExecutor exec\n         this.extRegistry = extRegistry;\n \n         StringBuilder nameBuilder = new StringBuilder();\n-        nameBuilder.append(addr.getHostname().replace('.', '_').replace('-', '_'))\n+        nameBuilder.append(addr.getHostName().replace('.', '_').replace('-', '_'))\n             .append(\"_\").append(addr.getPort());\n \n         this.statsLogger = parentStatsLogger.scope(BookKeeperClientStats.CHANNEL_SCOPE)"},{"sha":"8dc7e2d0d0b2440b8571e78b53f21667b3b85074","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/util/BookKeeperConstants.java","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/bbd1eb8d8560b03834175fbd996b85237df09f5c/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2FBookKeeperConstants.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/bbd1eb8d8560b03834175fbd996b85237df09f5c/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2FBookKeeperConstants.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2FBookKeeperConstants.java?ref=bbd1eb8d8560b03834175fbd996b85237df09f5c","patch":"@@ -50,4 +50,6 @@ public class BookKeeperConstants {\n      * memtable (for performance consideration)\r\n      */\r\n     public static final long MAX_LOG_SIZE_LIMIT = 1 * 1024 * 1024 * 1024;\r\n+\r\n+    public static final String FEATURE_REPP_DISABLE_DURABILITY_ENFORCEMENT = \"repp_disable_durability_enforcement\";\r\n }\r"},{"sha":"4f3690204ff228d1c9f83b5a50260601a12c53cf","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestRackawareEnsemblePlacementPolicy.java","status":"modified","additions":301,"deletions":87,"changes":388,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/bbd1eb8d8560b03834175fbd996b85237df09f5c/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FTestRackawareEnsemblePlacementPolicy.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/bbd1eb8d8560b03834175fbd996b85237df09f5c/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FTestRackawareEnsemblePlacementPolicy.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FTestRackawareEnsemblePlacementPolicy.java?ref=bbd1eb8d8560b03834175fbd996b85237df09f5c","patch":"@@ -18,62 +18,220 @@\n package org.apache.bookkeeper.client;\n \n import static org.apache.bookkeeper.client.RackawareEnsemblePlacementPolicy.REPP_DNS_RESOLVER_CLASS;\n+import static org.apache.bookkeeper.feature.SettableFeatureProvider.DISABLE_ALL;\n \n import java.net.InetAddress;\n import java.util.ArrayList;\n+import java.util.HashMap;\n import java.util.HashSet;\n+import java.util.List;\n import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n \n+import com.google.common.base.Optional;\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+\n+import junit.framework.TestCase;\n import org.apache.bookkeeper.client.BKException.BKNotEnoughBookiesException;\n+import org.apache.bookkeeper.conf.ClientConfiguration;\n import org.apache.bookkeeper.net.BookieSocketAddress;\n+import org.apache.bookkeeper.net.DNSToSwitchMapping;\n import org.apache.bookkeeper.net.NetworkTopology;\n import org.apache.bookkeeper.util.StaticDNSResolver;\n-import org.apache.commons.configuration.CompositeConfiguration;\n-import org.apache.commons.configuration.Configuration;\n-import org.junit.After;\n-import org.junit.Before;\n+import org.jboss.netty.util.HashedWheelTimer;\n import org.junit.Test;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import static org.junit.Assert.*;\n-\n-public class TestRackawareEnsemblePlacementPolicy {\n+public class TestRackawareEnsemblePlacementPolicy extends TestCase {\n \n     static final Logger LOG = LoggerFactory.getLogger(TestRackawareEnsemblePlacementPolicy.class);\n \n     RackawareEnsemblePlacementPolicy repp;\n-    Configuration conf = new CompositeConfiguration();\n+    final ArrayList<BookieSocketAddress> ensemble = new ArrayList<BookieSocketAddress>();\n+    final List<Integer> writeSet = new ArrayList<Integer>();\n+    ClientConfiguration conf = new ClientConfiguration();\n+    BookieSocketAddress addr1, addr2, addr3, addr4;\n+    HashedWheelTimer timer;\n \n-    @Before\n-    public void setUp() throws Exception {\n+    @Override\n+    protected void setUp() throws Exception {\n+        super.setUp();\n         StaticDNSResolver.reset();\n         StaticDNSResolver.addNodeToRack(InetAddress.getLocalHost().getHostAddress(), NetworkTopology.DEFAULT_RACK);\n         StaticDNSResolver.addNodeToRack(\"127.0.0.1\", NetworkTopology.DEFAULT_RACK);\n         StaticDNSResolver.addNodeToRack(\"localhost\", NetworkTopology.DEFAULT_RACK);\n         LOG.info(\"Set up static DNS Resolver.\");\n         conf.setProperty(REPP_DNS_RESOLVER_CLASS, StaticDNSResolver.class.getName());\n+        addr1 = new BookieSocketAddress(\"127.0.0.2\", 3181);\n+        addr2 = new BookieSocketAddress(\"127.0.0.3\", 3181);\n+        addr3 = new BookieSocketAddress(\"127.0.0.4\", 3181);\n+        addr4 = new BookieSocketAddress(\"127.0.0.5\", 3181);\n+        // update dns mapping\n+        StaticDNSResolver.addNodeToRack(addr1.getHostName(), NetworkTopology.DEFAULT_REGION + \"/rack1\");\n+        StaticDNSResolver.addNodeToRack(addr2.getHostName(), NetworkTopology.DEFAULT_RACK);\n+        StaticDNSResolver.addNodeToRack(addr3.getHostName(), NetworkTopology.DEFAULT_RACK);\n+        StaticDNSResolver.addNodeToRack(addr4.getHostName(), NetworkTopology.DEFAULT_REGION + \"/rack2\");\n+        ensemble.add(addr1);\n+        ensemble.add(addr2);\n+        ensemble.add(addr3);\n+        ensemble.add(addr4);\n+        for (int i = 0; i < 4; i++) {\n+            writeSet.add(i);\n+        }\n+\n+        timer = new HashedWheelTimer(\n+                new ThreadFactoryBuilder().setNameFormat(\"TestTimer-%d\").build(),\n+                conf.getTimeoutTimerTickDurationMs(), TimeUnit.MILLISECONDS,\n+                conf.getTimeoutTimerNumTicks());\n+\n         repp = new RackawareEnsemblePlacementPolicy();\n-        repp.initialize(conf);\n+        repp.initialize(conf, Optional.<DNSToSwitchMapping>absent(), timer, DISABLE_ALL, null);\n     }\n \n-    @After\n-    public void tearDown() throws Exception {\n+    @Override\n+    protected void tearDown() throws Exception {\n         repp.uninitalize();\n+        super.tearDown();\n+    }\n+\n+    static void updateMyRack(String rack) throws Exception {\n+        StaticDNSResolver.addNodeToRack(InetAddress.getLocalHost().getHostAddress(), rack);\n+        StaticDNSResolver.addNodeToRack(InetAddress.getLocalHost().getHostName(), rack);\n+        StaticDNSResolver.addNodeToRack(\"127.0.0.1\", rack);\n+        StaticDNSResolver.addNodeToRack(\"localhost\", rack);\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testNodeDown() throws Exception {\n+        repp.uninitalize();\n+        updateMyRack(NetworkTopology.DEFAULT_RACK);\n+\n+        repp = new RackawareEnsemblePlacementPolicy();\n+        repp.initialize(conf, Optional.<DNSToSwitchMapping>absent(), timer, DISABLE_ALL, null);\n+\n+        Set<BookieSocketAddress> addrs = new HashSet<BookieSocketAddress>();\n+        addrs.add(addr1);\n+        addrs.add(addr2);\n+        addrs.add(addr3);\n+        addrs.add(addr4);\n+        repp.onClusterChanged(addrs, new HashSet<BookieSocketAddress>());\n+        addrs.remove(addr1);\n+        repp.onClusterChanged(addrs, new HashSet<BookieSocketAddress>());\n+\n+        List<Integer> reoderSet = repp.reorderReadSequence(ensemble, writeSet, new HashMap<BookieSocketAddress, Long>());\n+        List<Integer> expectedSet = new ArrayList<Integer>();\n+        expectedSet.add(1);\n+        expectedSet.add(2);\n+        expectedSet.add(3);\n+        expectedSet.add(0);\n+        LOG.info(\"reorder set : {}\", reoderSet);\n+        assertFalse(reoderSet == writeSet);\n+        assertEquals(expectedSet, reoderSet);\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testNodeReadOnly() throws Exception {\n+        repp.uninitalize();\n+        updateMyRack(\"/r1/rack1\");\n+\n+        repp = new RackawareEnsemblePlacementPolicy();\n+        repp.initialize(conf, Optional.<DNSToSwitchMapping>absent(), timer, DISABLE_ALL, null);\n+\n+        // Update cluster\n+        Set<BookieSocketAddress> addrs = new HashSet<BookieSocketAddress>();\n+        addrs.add(addr1);\n+        addrs.add(addr2);\n+        addrs.add(addr3);\n+        addrs.add(addr4);\n+        repp.onClusterChanged(addrs, new HashSet<BookieSocketAddress>());\n+        addrs.remove(addr1);\n+        Set<BookieSocketAddress> ro = new HashSet<BookieSocketAddress>();\n+        ro.add(addr1);\n+        repp.onClusterChanged(addrs, ro);\n+\n+        List<Integer> reoderSet = repp.reorderReadSequence(ensemble, writeSet, new HashMap<BookieSocketAddress, Long>());\n+        List<Integer> expectedSet = new ArrayList<Integer>();\n+        expectedSet.add(1);\n+        expectedSet.add(2);\n+        expectedSet.add(3);\n+        expectedSet.add(0);\n+        LOG.info(\"reorder set : {}\", reoderSet);\n+        assertFalse(reoderSet == writeSet);\n+        assertEquals(expectedSet, reoderSet);\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testTwoNodesDown() throws Exception {\n+        repp.uninitalize();\n+        updateMyRack(\"/r1/rack1\");\n+\n+        repp = new RackawareEnsemblePlacementPolicy();\n+        repp.initialize(conf, Optional.<DNSToSwitchMapping>absent(), timer, DISABLE_ALL, null);\n+\n+        // Update cluster\n+        Set<BookieSocketAddress> addrs = new HashSet<BookieSocketAddress>();\n+        addrs.add(addr1);\n+        addrs.add(addr2);\n+        addrs.add(addr3);\n+        addrs.add(addr4);\n+        repp.onClusterChanged(addrs, new HashSet<BookieSocketAddress>());\n+        addrs.remove(addr1);\n+        addrs.remove(addr2);\n+        repp.onClusterChanged(addrs, new HashSet<BookieSocketAddress>());\n+\n+        List<Integer> reoderSet = repp.reorderReadSequence(ensemble, writeSet, new HashMap<BookieSocketAddress, Long>());\n+        List<Integer> expectedSet = new ArrayList<Integer>();\n+        expectedSet.add(2);\n+        expectedSet.add(3);\n+        expectedSet.add(0);\n+        expectedSet.add(1);\n+        LOG.info(\"reorder set : {}\", reoderSet);\n+        assertFalse(reoderSet == writeSet);\n+        assertEquals(expectedSet, reoderSet);\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testNodeDownAndReadOnly() throws Exception {\n+        repp.uninitalize();\n+        updateMyRack(\"/r1/rack1\");\n+\n+        repp = new RackawareEnsemblePlacementPolicy();\n+        repp.initialize(conf, Optional.<DNSToSwitchMapping>absent(), timer, DISABLE_ALL, null);\n+\n+        // Update cluster\n+        Set<BookieSocketAddress> addrs = new HashSet<BookieSocketAddress>();\n+        addrs.add(addr1);\n+        addrs.add(addr2);\n+        addrs.add(addr3);\n+        addrs.add(addr4);\n+        repp.onClusterChanged(addrs, new HashSet<BookieSocketAddress>());\n+        addrs.remove(addr1);\n+        addrs.remove(addr2);\n+        Set<BookieSocketAddress> roAddrs = new HashSet<BookieSocketAddress>();\n+        roAddrs.add(addr2);\n+        repp.onClusterChanged(addrs, roAddrs);\n+        List<Integer> reoderSet = repp.reorderReadSequence(ensemble, writeSet, new HashMap<BookieSocketAddress, Long>());\n+        List<Integer> expectedSet = new ArrayList<Integer>();\n+        expectedSet.add(2);\n+        expectedSet.add(3);\n+        expectedSet.add(1);\n+        expectedSet.add(0);\n+        assertFalse(reoderSet == writeSet);\n+        assertEquals(expectedSet, reoderSet);\n     }\n \n     @Test(timeout = 60000)\n     public void testReplaceBookieWithEnoughBookiesInSameRack() throws Exception {\n-        BookieSocketAddress addr1 = new BookieSocketAddress(\"127.0.0.1\", 3181);\n-        BookieSocketAddress addr2 = new BookieSocketAddress(\"127.0.0.2\", 3181);\n-        BookieSocketAddress addr3 = new BookieSocketAddress(\"127.0.0.3\", 3181);\n-        BookieSocketAddress addr4 = new BookieSocketAddress(\"127.0.0.4\", 3181);\n+        BookieSocketAddress addr1 = new BookieSocketAddress(\"127.0.0.2\", 3181);\n+        BookieSocketAddress addr2 = new BookieSocketAddress(\"127.0.0.3\", 3181);\n+        BookieSocketAddress addr3 = new BookieSocketAddress(\"127.0.0.4\", 3181);\n+        BookieSocketAddress addr4 = new BookieSocketAddress(\"127.0.0.5\", 3181);\n         // update dns mapping\n-        StaticDNSResolver.addNodeToRack(addr1.getSocketAddress().getAddress().getHostAddress(),\n-                NetworkTopology.DEFAULT_RACK);\n-        StaticDNSResolver.addNodeToRack(addr2.getSocketAddress().getAddress().getHostAddress(), \"/r2\");\n-        StaticDNSResolver.addNodeToRack(addr3.getSocketAddress().getAddress().getHostAddress(), \"/r2\");\n-        StaticDNSResolver.addNodeToRack(addr4.getSocketAddress().getAddress().getHostAddress(), \"/r3\");\n+        StaticDNSResolver.addNodeToRack(addr1.getHostName(), NetworkTopology.DEFAULT_RACK);\n+        StaticDNSResolver.addNodeToRack(addr2.getHostName(), \"/default-region/r2\");\n+        StaticDNSResolver.addNodeToRack(addr3.getHostName(), \"/default-region/r2\");\n+        StaticDNSResolver.addNodeToRack(addr4.getHostName(), \"/default-region/r3\");\n         // Update cluster\n         Set<BookieSocketAddress> addrs = new HashSet<BookieSocketAddress>();\n         addrs.add(addr1);\n@@ -82,22 +240,21 @@ public void testReplaceBookieWithEnoughBookiesInSameRack() throws Exception {\n         addrs.add(addr4);\n         repp.onClusterChanged(addrs, new HashSet<BookieSocketAddress>());\n         // replace node under r2\n-        BookieSocketAddress replacedBookie = repp.replaceBookie(addr2, new HashSet<BookieSocketAddress>());\n+        BookieSocketAddress replacedBookie = repp.replaceBookie(1, 1, 1, new HashSet<BookieSocketAddress>(), addr2, new HashSet<BookieSocketAddress>());\n         assertEquals(addr3, replacedBookie);\n     }\n \n     @Test(timeout = 60000)\n     public void testReplaceBookieWithEnoughBookiesInDifferentRack() throws Exception {\n-        BookieSocketAddress addr1 = new BookieSocketAddress(\"127.0.0.1\", 3181);\n-        BookieSocketAddress addr2 = new BookieSocketAddress(\"127.0.0.2\", 3181);\n-        BookieSocketAddress addr3 = new BookieSocketAddress(\"127.0.0.3\", 3181);\n-        BookieSocketAddress addr4 = new BookieSocketAddress(\"127.0.0.4\", 3181);\n+        BookieSocketAddress addr1 = new BookieSocketAddress(\"127.0.0.2\", 3181);\n+        BookieSocketAddress addr2 = new BookieSocketAddress(\"127.0.0.3\", 3181);\n+        BookieSocketAddress addr3 = new BookieSocketAddress(\"127.0.0.4\", 3181);\n+        BookieSocketAddress addr4 = new BookieSocketAddress(\"127.0.0.5\", 3181);\n         // update dns mapping\n-        StaticDNSResolver.addNodeToRack(addr1.getSocketAddress().getAddress().getHostAddress(),\n-                NetworkTopology.DEFAULT_RACK);\n-        StaticDNSResolver.addNodeToRack(addr2.getSocketAddress().getAddress().getHostAddress(), \"/r2\");\n-        StaticDNSResolver.addNodeToRack(addr3.getSocketAddress().getAddress().getHostAddress(), \"/r3\");\n-        StaticDNSResolver.addNodeToRack(addr4.getSocketAddress().getAddress().getHostAddress(), \"/r4\");\n+        StaticDNSResolver.addNodeToRack(addr1.getHostName(), NetworkTopology.DEFAULT_RACK);\n+        StaticDNSResolver.addNodeToRack(addr2.getHostName(), \"/default-region/r2\");\n+        StaticDNSResolver.addNodeToRack(addr3.getHostName(), \"/default-region/r3\");\n+        StaticDNSResolver.addNodeToRack(addr4.getHostName(), \"/default-region/r4\");\n         // Update cluster\n         Set<BookieSocketAddress> addrs = new HashSet<BookieSocketAddress>();\n         addrs.add(addr1);\n@@ -108,24 +265,23 @@ public void testReplaceBookieWithEnoughBookiesInDifferentRack() throws Exception\n         // replace node under r2\n         Set<BookieSocketAddress> excludedAddrs = new HashSet<BookieSocketAddress>();\n         excludedAddrs.add(addr1);\n-        BookieSocketAddress replacedBookie = repp.replaceBookie(addr2, excludedAddrs);\n+        BookieSocketAddress replacedBookie = repp.replaceBookie(1, 1, 1, new HashSet<BookieSocketAddress>(), addr2, excludedAddrs);\n \n         assertFalse(addr1.equals(replacedBookie));\n         assertTrue(addr3.equals(replacedBookie) || addr4.equals(replacedBookie));\n     }\n \n     @Test(timeout = 60000)\n     public void testReplaceBookieWithNotEnoughBookies() throws Exception {\n-        BookieSocketAddress addr1 = new BookieSocketAddress(\"127.0.0.1\", 3181);\n-        BookieSocketAddress addr2 = new BookieSocketAddress(\"127.0.0.2\", 3181);\n-        BookieSocketAddress addr3 = new BookieSocketAddress(\"127.0.0.3\", 3181);\n-        BookieSocketAddress addr4 = new BookieSocketAddress(\"127.0.0.4\", 3181);\n+        BookieSocketAddress addr1 = new BookieSocketAddress(\"127.0.0.2\", 3181);\n+        BookieSocketAddress addr2 = new BookieSocketAddress(\"127.0.0.3\", 3181);\n+        BookieSocketAddress addr3 = new BookieSocketAddress(\"127.0.0.4\", 3181);\n+        BookieSocketAddress addr4 = new BookieSocketAddress(\"127.0.0.5\", 3181);\n         // update dns mapping\n-        StaticDNSResolver.addNodeToRack(addr1.getSocketAddress().getAddress().getHostAddress(),\n-                NetworkTopology.DEFAULT_RACK);\n-        StaticDNSResolver.addNodeToRack(addr2.getSocketAddress().getAddress().getHostAddress(), \"/r2\");\n-        StaticDNSResolver.addNodeToRack(addr3.getSocketAddress().getAddress().getHostAddress(), \"/r3\");\n-        StaticDNSResolver.addNodeToRack(addr4.getSocketAddress().getAddress().getHostAddress(), \"/r4\");\n+        StaticDNSResolver.addNodeToRack(addr1.getHostName(), NetworkTopology.DEFAULT_RACK);\n+        StaticDNSResolver.addNodeToRack(addr2.getHostName(), \"/default-region/r2\");\n+        StaticDNSResolver.addNodeToRack(addr3.getHostName(), \"/default-region/r3\");\n+        StaticDNSResolver.addNodeToRack(addr4.getHostName(), \"/default-region/r4\");\n         // Update cluster\n         Set<BookieSocketAddress> addrs = new HashSet<BookieSocketAddress>();\n         addrs.add(addr1);\n@@ -139,7 +295,7 @@ public void testReplaceBookieWithNotEnoughBookies() throws Exception {\n         excludedAddrs.add(addr3);\n         excludedAddrs.add(addr4);\n         try {\n-            repp.replaceBookie(addr2, excludedAddrs);\n+            repp.replaceBookie(1, 1, 1, new HashSet<BookieSocketAddress>(), addr2, excludedAddrs);\n             fail(\"Should throw BKNotEnoughBookiesException when there is not enough bookies\");\n         } catch (BKNotEnoughBookiesException bnebe) {\n             // should throw not enou\n@@ -148,10 +304,10 @@ public void testReplaceBookieWithNotEnoughBookies() throws Exception {\n \n     @Test(timeout = 60000)\n     public void testNewEnsembleWithSingleRack() throws Exception {\n-        BookieSocketAddress addr1 = new BookieSocketAddress(\"127.0.0.1\", 3181);\n-        BookieSocketAddress addr2 = new BookieSocketAddress(\"127.0.0.2\", 3181);\n-        BookieSocketAddress addr3 = new BookieSocketAddress(\"127.0.0.3\", 3181);\n-        BookieSocketAddress addr4 = new BookieSocketAddress(\"127.0.0.4\", 3181);\n+        BookieSocketAddress addr1 = new BookieSocketAddress(\"127.0.0.6\", 3181);\n+        BookieSocketAddress addr2 = new BookieSocketAddress(\"127.0.0.7\", 3181);\n+        BookieSocketAddress addr3 = new BookieSocketAddress(\"127.0.0.8\", 3181);\n+        BookieSocketAddress addr4 = new BookieSocketAddress(\"127.0.0.9\", 3181);\n         // Update cluster\n         Set<BookieSocketAddress> addrs = new HashSet<BookieSocketAddress>();\n         addrs.add(addr1);\n@@ -160,9 +316,9 @@ public void testNewEnsembleWithSingleRack() throws Exception {\n         addrs.add(addr4);\n         repp.onClusterChanged(addrs, new HashSet<BookieSocketAddress>());\n         try {\n-            ArrayList<BookieSocketAddress> ensemble = repp.newEnsemble(3, 2, new HashSet<BookieSocketAddress>());\n+            ArrayList<BookieSocketAddress> ensemble = repp.newEnsemble(3, 2, 2, new HashSet<BookieSocketAddress>());\n             assertEquals(0, getNumCoveredWriteQuorums(ensemble, 2));\n-            ArrayList<BookieSocketAddress> ensemble2 = repp.newEnsemble(4, 2, new HashSet<BookieSocketAddress>());\n+            ArrayList<BookieSocketAddress> ensemble2 = repp.newEnsemble(4, 2, 2, new HashSet<BookieSocketAddress>());\n             assertEquals(0, getNumCoveredWriteQuorums(ensemble2, 2));\n         } catch (BKNotEnoughBookiesException bnebe) {\n             fail(\"Should not get not enough bookies exception even there is only one rack.\");\n@@ -176,11 +332,10 @@ public void testNewEnsembleWithMultipleRacks() throws Exception {\n         BookieSocketAddress addr3 = new BookieSocketAddress(\"127.0.0.3\", 3181);\n         BookieSocketAddress addr4 = new BookieSocketAddress(\"127.0.0.4\", 3181);\n         // update dns mapping\n-        StaticDNSResolver.addNodeToRack(addr1.getSocketAddress().getAddress().getHostAddress(),\n-                NetworkTopology.DEFAULT_RACK);\n-        StaticDNSResolver.addNodeToRack(addr2.getSocketAddress().getAddress().getHostAddress(), \"/r2\");\n-        StaticDNSResolver.addNodeToRack(addr3.getSocketAddress().getAddress().getHostAddress(), \"/r2\");\n-        StaticDNSResolver.addNodeToRack(addr4.getSocketAddress().getAddress().getHostAddress(), \"/r2\");\n+        StaticDNSResolver.addNodeToRack(addr1.getHostName(), NetworkTopology.DEFAULT_RACK);\n+        StaticDNSResolver.addNodeToRack(addr2.getHostName(), \"/default-region/r2\");\n+        StaticDNSResolver.addNodeToRack(addr3.getHostName(), \"/default-region/r2\");\n+        StaticDNSResolver.addNodeToRack(addr4.getHostName(), \"/default-region/r2\");\n         // Update cluster\n         Set<BookieSocketAddress> addrs = new HashSet<BookieSocketAddress>();\n         addrs.add(addr1);\n@@ -189,38 +344,36 @@ public void testNewEnsembleWithMultipleRacks() throws Exception {\n         addrs.add(addr4);\n         repp.onClusterChanged(addrs, new HashSet<BookieSocketAddress>());\n         try {\n-            ArrayList<BookieSocketAddress> ensemble = repp.newEnsemble(3, 2, new HashSet<BookieSocketAddress>());\n+            ArrayList<BookieSocketAddress> ensemble = repp.newEnsemble(3, 2, 2, new HashSet<BookieSocketAddress>());\n             int numCovered = getNumCoveredWriteQuorums(ensemble, 2);\n             assertTrue(numCovered >= 1 && numCovered < 3);\n-            ArrayList<BookieSocketAddress> ensemble2 = repp.newEnsemble(4, 2, new HashSet<BookieSocketAddress>());\n+            ArrayList<BookieSocketAddress> ensemble2 = repp.newEnsemble(4, 2, 2, new HashSet<BookieSocketAddress>());\n             numCovered = getNumCoveredWriteQuorums(ensemble2, 2);\n             assertTrue(numCovered >= 1 && numCovered < 3);\n         } catch (BKNotEnoughBookiesException bnebe) {\n             fail(\"Should not get not enough bookies exception even there is only one rack.\");\n         }\n     }\n \n-    @Test(timeout = 90000)\n+    @Test(timeout = 60000)\n     public void testNewEnsembleWithEnoughRacks() throws Exception {\n-        BookieSocketAddress addr1 = new BookieSocketAddress(\"127.0.0.1\", 3181);\n-        BookieSocketAddress addr2 = new BookieSocketAddress(\"127.0.0.2\", 3181);\n-        BookieSocketAddress addr3 = new BookieSocketAddress(\"127.0.0.3\", 3181);\n-        BookieSocketAddress addr4 = new BookieSocketAddress(\"127.0.0.4\", 3181);\n-        BookieSocketAddress addr5 = new BookieSocketAddress(\"127.0.0.5\", 3181);\n-        BookieSocketAddress addr6 = new BookieSocketAddress(\"127.0.0.6\", 3181);\n-        BookieSocketAddress addr7 = new BookieSocketAddress(\"127.0.0.7\", 3181);\n-        BookieSocketAddress addr8 = new BookieSocketAddress(\"127.0.0.8\", 3181);\n+        BookieSocketAddress addr1 = new BookieSocketAddress(\"127.0.0.2\", 3181);\n+        BookieSocketAddress addr2 = new BookieSocketAddress(\"127.0.0.3\", 3181);\n+        BookieSocketAddress addr3 = new BookieSocketAddress(\"127.0.0.4\", 3181);\n+        BookieSocketAddress addr4 = new BookieSocketAddress(\"127.0.0.5\", 3181);\n+        BookieSocketAddress addr5 = new BookieSocketAddress(\"127.0.0.6\", 3181);\n+        BookieSocketAddress addr6 = new BookieSocketAddress(\"127.0.0.7\", 3181);\n+        BookieSocketAddress addr7 = new BookieSocketAddress(\"127.0.0.8\", 3181);\n+        BookieSocketAddress addr8 = new BookieSocketAddress(\"127.0.0.9\", 3181);\n         // update dns mapping\n-        StaticDNSResolver.addNodeToRack(addr1.getSocketAddress().getAddress().getHostAddress(),\n-                NetworkTopology.DEFAULT_RACK);\n-        StaticDNSResolver.addNodeToRack(addr2.getSocketAddress().getAddress().getHostAddress(), \"/r2\");\n-        StaticDNSResolver.addNodeToRack(addr3.getSocketAddress().getAddress().getHostAddress(), \"/r3\");\n-        StaticDNSResolver.addNodeToRack(addr4.getSocketAddress().getAddress().getHostAddress(), \"/r4\");\n-        StaticDNSResolver.addNodeToRack(addr5.getSocketAddress().getAddress().getHostAddress(),\n-                NetworkTopology.DEFAULT_RACK);\n-        StaticDNSResolver.addNodeToRack(addr6.getSocketAddress().getAddress().getHostAddress(), \"/r2\");\n-        StaticDNSResolver.addNodeToRack(addr7.getSocketAddress().getAddress().getHostAddress(), \"/r3\");\n-        StaticDNSResolver.addNodeToRack(addr8.getSocketAddress().getAddress().getHostAddress(), \"/r4\");\n+        StaticDNSResolver.addNodeToRack(addr1.getHostName(), NetworkTopology.DEFAULT_RACK);\n+        StaticDNSResolver.addNodeToRack(addr2.getHostName(), \"/default-region/r2\");\n+        StaticDNSResolver.addNodeToRack(addr3.getHostName(), \"/default-region/r3\");\n+        StaticDNSResolver.addNodeToRack(addr4.getHostName(), \"/default-region/r4\");\n+        StaticDNSResolver.addNodeToRack(addr5.getHostName(), NetworkTopology.DEFAULT_RACK);\n+        StaticDNSResolver.addNodeToRack(addr6.getHostName(), \"/default-region/r2\");\n+        StaticDNSResolver.addNodeToRack(addr7.getHostName(), \"/default-region/r3\");\n+        StaticDNSResolver.addNodeToRack(addr8.getHostName(), \"/default-region/r4\");\n         // Update cluster\n         Set<BookieSocketAddress> addrs = new HashSet<BookieSocketAddress>();\n         addrs.add(addr1);\n@@ -233,9 +386,9 @@ public void testNewEnsembleWithEnoughRacks() throws Exception {\n         addrs.add(addr8);\n         repp.onClusterChanged(addrs, new HashSet<BookieSocketAddress>());\n         try {\n-            ArrayList<BookieSocketAddress> ensemble1 = repp.newEnsemble(3, 2, new HashSet<BookieSocketAddress>());\n+            ArrayList<BookieSocketAddress> ensemble1 = repp.newEnsemble(3, 2, 2, new HashSet<BookieSocketAddress>());\n             assertEquals(3, getNumCoveredWriteQuorums(ensemble1, 2));\n-            ArrayList<BookieSocketAddress> ensemble2 = repp.newEnsemble(4, 2, new HashSet<BookieSocketAddress>());\n+            ArrayList<BookieSocketAddress> ensemble2 = repp.newEnsemble(4, 2, 2, new HashSet<BookieSocketAddress>());\n             assertEquals(4, getNumCoveredWriteQuorums(ensemble2, 2));\n         } catch (BKNotEnoughBookiesException bnebe) {\n             fail(\"Should not get not enough bookies exception even there is only one rack.\");\n@@ -247,16 +400,15 @@ public void testNewEnsembleWithEnoughRacks() throws Exception {\n      */\n     @Test(timeout = 60000)\n     public void testRemoveBookieFromCluster() {\n-        BookieSocketAddress addr1 = new BookieSocketAddress(\"127.0.0.1\", 3181);\n-        BookieSocketAddress addr2 = new BookieSocketAddress(\"127.0.0.2\", 3181);\n-        BookieSocketAddress addr3 = new BookieSocketAddress(\"127.0.0.3\", 3181);\n-        BookieSocketAddress addr4 = new BookieSocketAddress(\"127.0.0.4\", 3181);\n+        BookieSocketAddress addr1 = new BookieSocketAddress(\"127.0.0.2\", 3181);\n+        BookieSocketAddress addr2 = new BookieSocketAddress(\"127.0.0.3\", 3181);\n+        BookieSocketAddress addr3 = new BookieSocketAddress(\"127.0.0.4\", 3181);\n+        BookieSocketAddress addr4 = new BookieSocketAddress(\"127.0.0.5\", 3181);\n         // update dns mapping\n-        StaticDNSResolver.addNodeToRack(addr1.getSocketAddress().getAddress().getHostAddress(),\n-                NetworkTopology.DEFAULT_RACK);\n-        StaticDNSResolver.addNodeToRack(addr2.getSocketAddress().getAddress().getHostAddress(), \"/r2\");\n-        StaticDNSResolver.addNodeToRack(addr3.getSocketAddress().getAddress().getHostAddress(), \"/r2\");\n-        StaticDNSResolver.addNodeToRack(addr4.getSocketAddress().getAddress().getHostAddress(), \"/r3\");\n+        StaticDNSResolver.addNodeToRack(addr1.getHostName(), NetworkTopology.DEFAULT_RACK);\n+        StaticDNSResolver.addNodeToRack(addr2.getHostName(), \"/default-region/r2\");\n+        StaticDNSResolver.addNodeToRack(addr3.getHostName(), \"/default-region/r2\");\n+        StaticDNSResolver.addNodeToRack(addr4.getHostName(), \"/default-region/r3\");\n         // Update cluster\n         Set<BookieSocketAddress> addrs = new HashSet<BookieSocketAddress>();\n         addrs.add(addr1);\n@@ -277,10 +429,72 @@ private int getNumCoveredWriteQuorums(ArrayList<BookieSocketAddress> ensemble, i\n             for (int j = 0; j < writeQuorumSize; j++) {\n                 int bookieIdx = (i + j) % ensembleSize;\n                 BookieSocketAddress addr = ensemble.get(bookieIdx);\n-                racks.add(StaticDNSResolver.getRack(addr.getSocketAddress().getAddress().getHostAddress()));\n+                racks.add(StaticDNSResolver.getRack(addr.getHostName()));\n             }\n             numCoveredWriteQuorums += (racks.size() > 1 ? 1 : 0);\n         }\n         return numCoveredWriteQuorums;\n     }\n+\n+    @Test(timeout = 60000)\n+    public void testNodeWithFailures() throws Exception {\n+        repp.uninitalize();\n+        updateMyRack(NetworkTopology.DEFAULT_RACK);\n+\n+        repp = new RackawareEnsemblePlacementPolicy();\n+        repp.initialize(conf, Optional.<DNSToSwitchMapping>absent(), timer, DISABLE_ALL, null);\n+\n+        Set<BookieSocketAddress> addrs = new HashSet<BookieSocketAddress>();\n+        addrs.add(addr1);\n+        addrs.add(addr2);\n+        addrs.add(addr3);\n+        addrs.add(addr4);\n+        repp.onClusterChanged(addrs, new HashSet<BookieSocketAddress>());\n+\n+        HashMap<BookieSocketAddress, Long> bookieFailures = new HashMap<BookieSocketAddress, Long>();\n+\n+        bookieFailures.put(addr1, 20L);\n+        bookieFailures.put(addr2, 22L);\n+\n+        List<Integer> reoderSet = repp.reorderReadSequence(ensemble, writeSet, bookieFailures);\n+        LOG.info(\"reorder set : {}\", reoderSet);\n+        assertEquals(ensemble.get(reoderSet.get(2)), addr1);\n+        assertEquals(ensemble.get(reoderSet.get(3)), addr2);\n+        assertEquals(ensemble.get(reoderSet.get(0)), addr3);\n+        assertEquals(ensemble.get(reoderSet.get(1)), addr4);\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testPlacementOnStabilizeNetworkTopology() throws Exception {\n+        repp.uninitalize();\n+        updateMyRack(NetworkTopology.DEFAULT_RACK);\n+\n+        repp = new RackawareEnsemblePlacementPolicy();\n+        ClientConfiguration confLocal = new ClientConfiguration();\n+        confLocal.addConfiguration(conf);\n+        confLocal.setNetworkTopologyStabilizePeriodSeconds(99999);\n+        repp.initialize(confLocal, Optional.<DNSToSwitchMapping>absent(), timer, DISABLE_ALL, null);\n+\n+        Set<BookieSocketAddress> addrs = new HashSet<BookieSocketAddress>();\n+        addrs.add(addr1);\n+        addrs.add(addr2);\n+        addrs.add(addr3);\n+        addrs.add(addr4);\n+        repp.onClusterChanged(addrs, new HashSet<BookieSocketAddress>());\n+        // addr4 left\n+        addrs.remove(addr4);\n+        Set<BookieSocketAddress> deadBookies = repp.onClusterChanged(addrs, new HashSet<BookieSocketAddress>());\n+        assertTrue(deadBookies.isEmpty());\n+\n+        // we will never use addr4 even it is in the stabilized network topology\n+        for (int i = 0 ; i < 5; i++) {\n+            ArrayList<BookieSocketAddress> ensemble =\n+                    repp.newEnsemble(3, 3, 3, new HashSet<BookieSocketAddress>());\n+            assertFalse(ensemble.contains(addr4));\n+        }\n+\n+        // we could still use addr4 for urgent allocation if it is just bookie flapping\n+        ArrayList<BookieSocketAddress> ensemble = repp.newEnsemble(4, 4, 4, new HashSet<BookieSocketAddress>());\n+        assertTrue(ensemble.contains(addr4));\n+    }\n }"},{"sha":"9a32986eb2b4f7a11fab26846567417803dd6a59","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestRegionAwareEnsemblePlacementPolicy.java","status":"added","additions":1262,"deletions":0,"changes":1262,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/bbd1eb8d8560b03834175fbd996b85237df09f5c/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FTestRegionAwareEnsemblePlacementPolicy.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/bbd1eb8d8560b03834175fbd996b85237df09f5c/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FTestRegionAwareEnsemblePlacementPolicy.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FTestRegionAwareEnsemblePlacementPolicy.java?ref=bbd1eb8d8560b03834175fbd996b85237df09f5c","patch":"@@ -0,0 +1,1262 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.bookkeeper.client;\n+\n+import java.net.InetAddress;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+\n+import com.google.common.base.Optional;\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+import org.apache.bookkeeper.client.BKException.BKNotEnoughBookiesException;\n+import org.apache.bookkeeper.conf.ClientConfiguration;\n+import org.apache.bookkeeper.feature.Feature;\n+import org.apache.bookkeeper.feature.FeatureProvider;\n+import org.apache.bookkeeper.feature.SettableFeature;\n+import org.apache.bookkeeper.feature.SettableFeatureProvider;\n+import org.apache.bookkeeper.net.BookieSocketAddress;\n+import org.apache.bookkeeper.net.DNSToSwitchMapping;\n+import org.apache.bookkeeper.net.NetworkTopology;\n+import org.apache.bookkeeper.util.BookKeeperConstants;\n+import org.apache.bookkeeper.util.StaticDNSResolver;\n+import org.jboss.netty.util.HashedWheelTimer;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import junit.framework.TestCase;\n+\n+import static org.apache.bookkeeper.client.RackawareEnsemblePlacementPolicy.REPP_DNS_RESOLVER_CLASS;\n+import static org.apache.bookkeeper.client.RegionAwareEnsemblePlacementPolicy.*;\n+import static org.apache.bookkeeper.feature.SettableFeatureProvider.DISABLE_ALL;\n+\n+public class TestRegionAwareEnsemblePlacementPolicy extends TestCase {\n+\n+    static final Logger LOG = LoggerFactory.getLogger(TestRegionAwareEnsemblePlacementPolicy.class);\n+\n+    RegionAwareEnsemblePlacementPolicy repp;\n+    final ClientConfiguration conf = new ClientConfiguration();\n+    final ArrayList<BookieSocketAddress> ensemble = new ArrayList<BookieSocketAddress>();\n+    final List<Integer> writeSet = new ArrayList<Integer>();\n+    BookieSocketAddress addr1, addr2, addr3, addr4;\n+    HashedWheelTimer timer;\n+\n+    static void updateMyRack(String rack) throws Exception {\n+        StaticDNSResolver.addNodeToRack(InetAddress.getLocalHost().getHostAddress(), rack);\n+        StaticDNSResolver.addNodeToRack(InetAddress.getLocalHost().getHostName(), rack);\n+        StaticDNSResolver.addNodeToRack(\"127.0.0.1\", rack);\n+        StaticDNSResolver.addNodeToRack(\"localhost\", rack);\n+    }\n+\n+    @Override\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+        StaticDNSResolver.reset();\n+        updateMyRack(NetworkTopology.DEFAULT_RACK);\n+        LOG.info(\"Set up static DNS Resolver.\");\n+        conf.setProperty(REPP_DNS_RESOLVER_CLASS, StaticDNSResolver.class.getName());\n+\n+        addr1 = new BookieSocketAddress(\"127.0.0.2\", 3181);\n+        addr2 = new BookieSocketAddress(\"127.0.0.3\", 3181);\n+        addr3 = new BookieSocketAddress(\"127.0.0.4\", 3181);\n+        addr4 = new BookieSocketAddress(\"127.0.0.5\", 3181);\n+        // update dns mapping\n+        StaticDNSResolver.addNodeToRack(addr1.getHostName(), \"/r1/rack1\");\n+        StaticDNSResolver.addNodeToRack(addr2.getHostName(), NetworkTopology.DEFAULT_RACK);\n+        StaticDNSResolver.addNodeToRack(addr3.getHostName(), NetworkTopology.DEFAULT_RACK);\n+        StaticDNSResolver.addNodeToRack(addr4.getHostName(), \"/r1/rack2\");\n+        ensemble.add(addr1);\n+        ensemble.add(addr2);\n+        ensemble.add(addr3);\n+        ensemble.add(addr4);\n+        for (int i = 0; i < 4; i++) {\n+            writeSet.add(i);\n+        }\n+\n+        timer = new HashedWheelTimer(\n+                new ThreadFactoryBuilder().setNameFormat(\"TestTimer-%d\").build(),\n+                conf.getTimeoutTimerTickDurationMs(), TimeUnit.MILLISECONDS,\n+                conf.getTimeoutTimerNumTicks());\n+\n+        repp = new RegionAwareEnsemblePlacementPolicy();\n+        repp.initialize(conf, Optional.<DNSToSwitchMapping>absent(), timer, DISABLE_ALL, null);\n+    }\n+\n+    @Override\n+    protected void tearDown() throws Exception {\n+        repp.uninitalize();\n+        super.tearDown();\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testNotReorderReadIfInDefaultRack() throws Exception {\n+        repp.uninitalize();\n+        updateMyRack(NetworkTopology.DEFAULT_RACK);\n+\n+        repp = new RegionAwareEnsemblePlacementPolicy();\n+        repp.initialize(conf, Optional.<DNSToSwitchMapping>absent(), timer, DISABLE_ALL, null);\n+\n+        List<Integer> reorderSet = repp.reorderReadSequence(ensemble, writeSet, new HashMap<BookieSocketAddress, Long>());\n+        assertFalse(reorderSet == writeSet);\n+        assertEquals(writeSet, reorderSet);\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testNodeInSameRegion() throws Exception {\n+        repp.uninitalize();\n+        updateMyRack(\"/r1/rack3\");\n+\n+        repp = new RegionAwareEnsemblePlacementPolicy();\n+        repp.initialize(conf, Optional.<DNSToSwitchMapping>absent(), timer, DISABLE_ALL, null);\n+\n+        Set<BookieSocketAddress> addrs = new HashSet<BookieSocketAddress>();\n+        addrs.add(addr1);\n+        addrs.add(addr2);\n+        addrs.add(addr3);\n+        addrs.add(addr4);\n+        repp.onClusterChanged(addrs, new HashSet<BookieSocketAddress>());\n+\n+        List<Integer> reoderSet = repp.reorderReadSequence(ensemble, writeSet, new HashMap<BookieSocketAddress, Long>());\n+        List<Integer> expectedSet = new ArrayList<Integer>();\n+        expectedSet.add(0);\n+        expectedSet.add(3);\n+        expectedSet.add(1);\n+        expectedSet.add(2);\n+        LOG.info(\"reorder set : {}\", reoderSet);\n+        assertFalse(reoderSet == writeSet);\n+        assertEquals(expectedSet, reoderSet);\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testNodeNotInSameRegions() throws Exception {\n+        repp.uninitalize();\n+        updateMyRack(\"/r2/rack1\");\n+\n+        repp = new RegionAwareEnsemblePlacementPolicy();\n+        repp.initialize(conf, Optional.<DNSToSwitchMapping>absent(), timer, DISABLE_ALL, null);\n+\n+        List<Integer> reoderSet = repp.reorderReadSequence(ensemble, writeSet, new HashMap<BookieSocketAddress, Long>());\n+        LOG.info(\"reorder set : {}\", reoderSet);\n+        assertFalse(reoderSet == writeSet);\n+        assertEquals(writeSet, reoderSet);\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testNodeDown() throws Exception {\n+        repp.uninitalize();\n+        updateMyRack(\"/r1/rack1\");\n+\n+        repp = new RegionAwareEnsemblePlacementPolicy();\n+        repp.initialize(conf, Optional.<DNSToSwitchMapping>absent(), timer, DISABLE_ALL, null);\n+\n+        // Update cluster\n+        Set<BookieSocketAddress> addrs = new HashSet<BookieSocketAddress>();\n+        addrs.add(addr1);\n+        addrs.add(addr2);\n+        addrs.add(addr3);\n+        addrs.add(addr4);\n+        repp.onClusterChanged(addrs, new HashSet<BookieSocketAddress>());\n+        addrs.remove(addr1);\n+        repp.onClusterChanged(addrs, new HashSet<BookieSocketAddress>());\n+\n+        List<Integer> reoderSet = repp.reorderReadSequence(ensemble, writeSet, new HashMap<BookieSocketAddress, Long>());\n+        List<Integer> expectedSet = new ArrayList<Integer>();\n+        expectedSet.add(3);\n+        expectedSet.add(1);\n+        expectedSet.add(2);\n+        expectedSet.add(0);\n+        LOG.info(\"reorder set : {}\", reoderSet);\n+        assertFalse(reoderSet == writeSet);\n+        assertEquals(expectedSet, reoderSet);\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testNodeReadOnly() throws Exception {\n+        repp.uninitalize();\n+        updateMyRack(\"/r1/rack1\");\n+\n+        repp = new RegionAwareEnsemblePlacementPolicy();\n+        repp.initialize(conf, Optional.<DNSToSwitchMapping>absent(), timer, DISABLE_ALL, null);\n+\n+        // Update cluster\n+        Set<BookieSocketAddress> addrs = new HashSet<BookieSocketAddress>();\n+        addrs.add(addr1);\n+        addrs.add(addr2);\n+        addrs.add(addr3);\n+        addrs.add(addr4);\n+        repp.onClusterChanged(addrs, new HashSet<BookieSocketAddress>());\n+        addrs.remove(addr1);\n+        Set<BookieSocketAddress> ro = new HashSet<BookieSocketAddress>();\n+        ro.add(addr1);\n+        repp.onClusterChanged(addrs, ro);\n+\n+        List<Integer> reoderSet = repp.reorderReadSequence(ensemble, writeSet, new HashMap<BookieSocketAddress, Long>());\n+        List<Integer> expectedSet = new ArrayList<Integer>();\n+        expectedSet.add(3);\n+        expectedSet.add(1);\n+        expectedSet.add(2);\n+        expectedSet.add(0);\n+        LOG.info(\"reorder set : {}\", reoderSet);\n+        assertFalse(reoderSet == writeSet);\n+        assertEquals(expectedSet, reoderSet);\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testTwoNodesDown() throws Exception {\n+        repp.uninitalize();\n+        updateMyRack(\"/r1/rack1\");\n+\n+        repp = new RegionAwareEnsemblePlacementPolicy();\n+        repp.initialize(conf, Optional.<DNSToSwitchMapping>absent(), timer, DISABLE_ALL, null);\n+\n+        // Update cluster\n+        Set<BookieSocketAddress> addrs = new HashSet<BookieSocketAddress>();\n+        addrs.add(addr1);\n+        addrs.add(addr2);\n+        addrs.add(addr3);\n+        addrs.add(addr4);\n+        repp.onClusterChanged(addrs, new HashSet<BookieSocketAddress>());\n+        addrs.remove(addr1);\n+        addrs.remove(addr2);\n+        repp.onClusterChanged(addrs, new HashSet<BookieSocketAddress>());\n+\n+        List<Integer> reoderSet = repp.reorderReadSequence(ensemble, writeSet, new HashMap<BookieSocketAddress, Long>());\n+        List<Integer> expectedSet = new ArrayList<Integer>();\n+        expectedSet.add(3);\n+        expectedSet.add(2);\n+        expectedSet.add(0);\n+        expectedSet.add(1);\n+        LOG.info(\"reorder set : {}\", reoderSet);\n+        assertFalse(reoderSet == writeSet);\n+        assertEquals(expectedSet, reoderSet);\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testReplaceBookieWithEnoughBookiesInSameRegion() throws Exception {\n+        BookieSocketAddress addr1 = new BookieSocketAddress(\"127.0.0.2\", 3181);\n+        BookieSocketAddress addr2 = new BookieSocketAddress(\"127.0.0.3\", 3181);\n+        BookieSocketAddress addr3 = new BookieSocketAddress(\"127.0.0.4\", 3181);\n+        BookieSocketAddress addr4 = new BookieSocketAddress(\"127.0.0.5\", 3181);\n+        // update dns mapping\n+        StaticDNSResolver.addNodeToRack(addr1.getHostName(), NetworkTopology.DEFAULT_RACK);\n+        StaticDNSResolver.addNodeToRack(addr2.getHostName(), \"/region1/r1\");\n+        StaticDNSResolver.addNodeToRack(addr3.getHostName(), \"/region1/r2\");\n+        StaticDNSResolver.addNodeToRack(addr4.getHostName(), \"/default-region/r3\");\n+        // Update cluster\n+        Set<BookieSocketAddress> addrs = new HashSet<BookieSocketAddress>();\n+        addrs.add(addr1);\n+        addrs.add(addr2);\n+        addrs.add(addr3);\n+        addrs.add(addr4);\n+        repp.onClusterChanged(addrs, new HashSet<BookieSocketAddress>());\n+        // replace node under r2\n+        BookieSocketAddress replacedBookie = repp.replaceBookie(1, 1, 1, new HashSet<BookieSocketAddress>(), addr2, new HashSet<BookieSocketAddress>());\n+        assertEquals(addr3, replacedBookie);\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testReplaceBookieWithEnoughBookiesInDifferentRegion() throws Exception {\n+        BookieSocketAddress addr1 = new BookieSocketAddress(\"127.0.0.2\", 3181);\n+        BookieSocketAddress addr2 = new BookieSocketAddress(\"127.0.0.3\", 3181);\n+        BookieSocketAddress addr3 = new BookieSocketAddress(\"127.0.0.4\", 3181);\n+        BookieSocketAddress addr4 = new BookieSocketAddress(\"127.0.0.5\", 3181);\n+        // update dns mapping\n+        StaticDNSResolver.addNodeToRack(addr1.getHostName(), NetworkTopology.DEFAULT_RACK);\n+        StaticDNSResolver.addNodeToRack(addr2.getHostName(), \"/region1/r2\");\n+        StaticDNSResolver.addNodeToRack(addr3.getHostName(), \"/region2/r3\");\n+        StaticDNSResolver.addNodeToRack(addr4.getHostName(), \"/region3/r4\");\n+        // Update cluster\n+        Set<BookieSocketAddress> addrs = new HashSet<BookieSocketAddress>();\n+        addrs.add(addr1);\n+        addrs.add(addr2);\n+        addrs.add(addr3);\n+        addrs.add(addr4);\n+        repp.onClusterChanged(addrs, new HashSet<BookieSocketAddress>());\n+        // replace node under r2\n+        Set<BookieSocketAddress> excludedAddrs = new HashSet<BookieSocketAddress>();\n+        excludedAddrs.add(addr1);\n+        BookieSocketAddress replacedBookie = repp.replaceBookie(1, 1, 1, new HashSet<BookieSocketAddress>(), addr2, excludedAddrs);\n+\n+        assertFalse(addr1.equals(replacedBookie));\n+        assertTrue(addr3.equals(replacedBookie) || addr4.equals(replacedBookie));\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testNewEnsembleBookieWithNotEnoughBookies() throws Exception {\n+        BookieSocketAddress addr1 = new BookieSocketAddress(\"127.0.0.2\", 3181);\n+        BookieSocketAddress addr2 = new BookieSocketAddress(\"127.0.0.3\", 3181);\n+        BookieSocketAddress addr3 = new BookieSocketAddress(\"127.0.0.4\", 3181);\n+        BookieSocketAddress addr4 = new BookieSocketAddress(\"127.0.0.5\", 3181);\n+        // update dns mapping\n+        StaticDNSResolver.addNodeToRack(addr1.getHostName(), NetworkTopology.DEFAULT_RACK);\n+        StaticDNSResolver.addNodeToRack(addr2.getHostName(), \"/region2/r2\");\n+        StaticDNSResolver.addNodeToRack(addr3.getHostName(), \"/region3/r3\");\n+        StaticDNSResolver.addNodeToRack(addr4.getHostName(), \"/region4/r4\");\n+        // Update cluster\n+        Set<BookieSocketAddress> addrs = new HashSet<BookieSocketAddress>();\n+        addrs.add(addr1);\n+        addrs.add(addr2);\n+        addrs.add(addr3);\n+        addrs.add(addr4);\n+        repp.onClusterChanged(addrs, new HashSet<BookieSocketAddress>());\n+        try {\n+            ArrayList<BookieSocketAddress> list = repp.newEnsemble(5, 5, 3, new HashSet<BookieSocketAddress>());\n+            LOG.info(\"Ensemble : {}\", list);\n+            fail(\"Should throw BKNotEnoughBookiesException when there is not enough bookies\");\n+        } catch (BKNotEnoughBookiesException bnebe) {\n+            // should throw not enou\n+        }\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testReplaceBookieWithNotEnoughBookies() throws Exception {\n+        BookieSocketAddress addr1 = new BookieSocketAddress(\"127.0.0.2\", 3181);\n+        BookieSocketAddress addr2 = new BookieSocketAddress(\"127.0.0.3\", 3181);\n+        BookieSocketAddress addr3 = new BookieSocketAddress(\"127.0.0.4\", 3181);\n+        BookieSocketAddress addr4 = new BookieSocketAddress(\"127.0.0.5\", 3181);\n+        // update dns mapping\n+        StaticDNSResolver.addNodeToRack(addr1.getHostName(), NetworkTopology.DEFAULT_RACK);\n+        StaticDNSResolver.addNodeToRack(addr2.getHostName(), \"/region2/r2\");\n+        StaticDNSResolver.addNodeToRack(addr3.getHostName(), \"/region3/r3\");\n+        StaticDNSResolver.addNodeToRack(addr4.getHostName(), \"/region4/r4\");\n+        // Update cluster\n+        Set<BookieSocketAddress> addrs = new HashSet<BookieSocketAddress>();\n+        addrs.add(addr1);\n+        addrs.add(addr2);\n+        addrs.add(addr3);\n+        addrs.add(addr4);\n+        repp.onClusterChanged(addrs, new HashSet<BookieSocketAddress>());\n+        // replace node under r2\n+        Set<BookieSocketAddress> excludedAddrs = new HashSet<BookieSocketAddress>();\n+        excludedAddrs.add(addr1);\n+        excludedAddrs.add(addr3);\n+        excludedAddrs.add(addr4);\n+        try {\n+            repp.replaceBookie(1, 1, 1, new HashSet<BookieSocketAddress>(), addr2, excludedAddrs);\n+            fail(\"Should throw BKNotEnoughBookiesException when there is not enough bookies\");\n+        } catch (BKNotEnoughBookiesException bnebe) {\n+            // should throw not enou\n+        }\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testNewEnsembleWithSingleRegion() throws Exception {\n+        repp.uninitalize();\n+        repp = new RegionAwareEnsemblePlacementPolicy();\n+        repp.initialize(conf, Optional.<DNSToSwitchMapping>absent(), timer, DISABLE_ALL, null);\n+        BookieSocketAddress addr1 = new BookieSocketAddress(\"127.0.0.2\", 3181);\n+        BookieSocketAddress addr2 = new BookieSocketAddress(\"127.0.0.3\", 3181);\n+        BookieSocketAddress addr3 = new BookieSocketAddress(\"127.0.0.4\", 3181);\n+        BookieSocketAddress addr4 = new BookieSocketAddress(\"127.0.0.5\", 3181);\n+        // update dns mapping\n+        StaticDNSResolver.addNodeToRack(addr1.getHostName(), \"/region1/r2\");\n+        StaticDNSResolver.addNodeToRack(addr2.getHostName(), \"/region1/r2\");\n+        StaticDNSResolver.addNodeToRack(addr3.getHostName(), \"/region1/r2\");\n+        StaticDNSResolver.addNodeToRack(addr4.getHostName(), \"/region1/r2\");\n+        // Update cluster\n+        Set<BookieSocketAddress> addrs = new HashSet<BookieSocketAddress>();\n+        addrs.add(addr1);\n+        addrs.add(addr2);\n+        addrs.add(addr3);\n+        addrs.add(addr4);\n+        repp.onClusterChanged(addrs, new HashSet<BookieSocketAddress>());\n+        try {\n+            ArrayList<BookieSocketAddress> ensemble = repp.newEnsemble(3, 2, 2, new HashSet<BookieSocketAddress>());\n+            assertEquals(0, getNumCoveredRegionsInWriteQuorum(ensemble, 2));\n+            ArrayList<BookieSocketAddress> ensemble2 = repp.newEnsemble(4, 2, 2, new HashSet<BookieSocketAddress>());\n+            assertEquals(0, getNumCoveredRegionsInWriteQuorum(ensemble2, 2));\n+        } catch (BKNotEnoughBookiesException bnebe) {\n+            fail(\"Should not get not enough bookies exception even there is only one rack.\");\n+        }\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testNewEnsembleWithMultipleRegions() throws Exception {\n+        repp.uninitalize();\n+        repp = new RegionAwareEnsemblePlacementPolicy();\n+        repp.initialize(conf, Optional.<DNSToSwitchMapping>absent(), timer, DISABLE_ALL, null);\n+        BookieSocketAddress addr1 = new BookieSocketAddress(\"127.0.0.2\", 3181);\n+        BookieSocketAddress addr2 = new BookieSocketAddress(\"127.0.0.3\", 3181);\n+        BookieSocketAddress addr3 = new BookieSocketAddress(\"127.0.0.4\", 3181);\n+        BookieSocketAddress addr4 = new BookieSocketAddress(\"127.0.0.5\", 3181);\n+        // update dns mapping\n+        StaticDNSResolver.addNodeToRack(addr1.getHostName(), NetworkTopology.DEFAULT_RACK);\n+        StaticDNSResolver.addNodeToRack(addr2.getHostName(), \"/region1/r2\");\n+        StaticDNSResolver.addNodeToRack(addr3.getHostName(), \"/region1/r2\");\n+        StaticDNSResolver.addNodeToRack(addr4.getHostName(), \"/region1/r2\");\n+        // Update cluster\n+        Set<BookieSocketAddress> addrs = new HashSet<BookieSocketAddress>();\n+        addrs.add(addr1);\n+        addrs.add(addr2);\n+        addrs.add(addr3);\n+        addrs.add(addr4);\n+        repp.onClusterChanged(addrs, new HashSet<BookieSocketAddress>());\n+        try {\n+            ArrayList<BookieSocketAddress> ensemble = repp.newEnsemble(3, 2, 2, new HashSet<BookieSocketAddress>());\n+            int numCovered = getNumCoveredRegionsInWriteQuorum(ensemble, 2);\n+            assertTrue(numCovered >= 1);\n+            assertTrue(numCovered < 3);\n+        } catch (BKNotEnoughBookiesException bnebe) {\n+            fail(\"Should not get not enough bookies exception even there is only one rack.\");\n+        }\n+        try {\n+            ArrayList<BookieSocketAddress> ensemble2 = repp.newEnsemble(4, 2, 2, new HashSet<BookieSocketAddress>());\n+            int numCovered = getNumCoveredRegionsInWriteQuorum(ensemble2, 2);\n+            assertTrue(numCovered >= 1 && numCovered < 3);\n+        } catch (BKNotEnoughBookiesException bnebe) {\n+            fail(\"Should not get not enough bookies exception even there is only one rack.\");\n+        }\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testNewEnsembleWithEnoughRegions() throws Exception {\n+        BookieSocketAddress addr1 = new BookieSocketAddress(\"127.0.0.2\", 3181);\n+        BookieSocketAddress addr2 = new BookieSocketAddress(\"127.0.0.3\", 3181);\n+        BookieSocketAddress addr3 = new BookieSocketAddress(\"127.0.0.4\", 3181);\n+        BookieSocketAddress addr4 = new BookieSocketAddress(\"127.0.0.5\", 3181);\n+        BookieSocketAddress addr5 = new BookieSocketAddress(\"127.0.0.6\", 3181);\n+        BookieSocketAddress addr6 = new BookieSocketAddress(\"127.0.0.7\", 3181);\n+        BookieSocketAddress addr7 = new BookieSocketAddress(\"127.0.0.8\", 3181);\n+        BookieSocketAddress addr8 = new BookieSocketAddress(\"127.0.0.9\", 3181);\n+        // update dns mapping\n+        StaticDNSResolver.addNodeToRack(addr1.getHostName(), \"/default-region/default-rack1\");\n+        StaticDNSResolver.addNodeToRack(addr2.getHostName(), \"/region1/r2\");\n+        StaticDNSResolver.addNodeToRack(addr3.getHostName(), \"/region2/r3\");\n+        StaticDNSResolver.addNodeToRack(addr4.getHostName(), \"/region3/r4\");\n+        StaticDNSResolver.addNodeToRack(addr5.getHostName(), \"/default-region/default-rack2\");\n+        StaticDNSResolver.addNodeToRack(addr6.getHostName(), \"/region1/r12\");\n+        StaticDNSResolver.addNodeToRack(addr7.getHostName(), \"/region2/r13\");\n+        StaticDNSResolver.addNodeToRack(addr8.getHostName(), \"/region3/r14\");\n+        // Update cluster\n+        Set<BookieSocketAddress> addrs = new HashSet<BookieSocketAddress>();\n+        addrs.add(addr1);\n+        addrs.add(addr2);\n+        addrs.add(addr3);\n+        addrs.add(addr4);\n+        addrs.add(addr5);\n+        addrs.add(addr6);\n+        addrs.add(addr7);\n+        addrs.add(addr8);\n+        repp.onClusterChanged(addrs, new HashSet<BookieSocketAddress>());\n+        try {\n+            ArrayList<BookieSocketAddress> ensemble1 = repp.newEnsemble(3, 2, 2, new HashSet<BookieSocketAddress>());\n+            assertEquals(3, getNumCoveredRegionsInWriteQuorum(ensemble1, 2));\n+            ArrayList<BookieSocketAddress> ensemble2 = repp.newEnsemble(4, 2, 2, new HashSet<BookieSocketAddress>());\n+            assertEquals(4, getNumCoveredRegionsInWriteQuorum(ensemble2, 2));\n+        } catch (BKNotEnoughBookiesException bnebe) {\n+            fail(\"Should not get not enough bookies exception even there is only one rack.\");\n+        }\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testNewEnsembleWithThreeRegions() throws Exception {\n+        repp.uninitalize();\n+        repp = new RegionAwareEnsemblePlacementPolicy();\n+        repp.initialize(conf, Optional.<DNSToSwitchMapping>absent(), timer, DISABLE_ALL, null);\n+        BookieSocketAddress addr1 = new BookieSocketAddress(\"127.0.0.2\", 3181);\n+        BookieSocketAddress addr2 = new BookieSocketAddress(\"127.0.0.3\", 3181);\n+        BookieSocketAddress addr3 = new BookieSocketAddress(\"127.0.0.4\", 3181);\n+        BookieSocketAddress addr4 = new BookieSocketAddress(\"127.0.0.5\", 3181);\n+        BookieSocketAddress addr5 = new BookieSocketAddress(\"127.0.0.6\", 3181);\n+        BookieSocketAddress addr6 = new BookieSocketAddress(\"127.0.0.7\", 3181);\n+        BookieSocketAddress addr7 = new BookieSocketAddress(\"127.0.0.8\", 3181);\n+        BookieSocketAddress addr8 = new BookieSocketAddress(\"127.0.0.9\", 3181);\n+        BookieSocketAddress addr9 = new BookieSocketAddress(\"127.0.0.10\", 3181);\n+        BookieSocketAddress addr10 = new BookieSocketAddress(\"127.0.0.11\", 3181);\n+        // update dns mapping\n+        StaticDNSResolver.addNodeToRack(addr1.getHostName(), \"/region2/r1\");\n+        StaticDNSResolver.addNodeToRack(addr2.getHostName(), \"/region1/r2\");\n+        StaticDNSResolver.addNodeToRack(addr3.getHostName(), \"/region2/r3\");\n+        StaticDNSResolver.addNodeToRack(addr4.getHostName(), \"/region3/r4\");\n+        StaticDNSResolver.addNodeToRack(addr5.getHostName(), \"/region1/r11\");\n+        StaticDNSResolver.addNodeToRack(addr6.getHostName(), \"/region1/r12\");\n+        StaticDNSResolver.addNodeToRack(addr7.getHostName(), \"/region2/r13\");\n+        StaticDNSResolver.addNodeToRack(addr8.getHostName(), \"/region3/r14\");\n+        StaticDNSResolver.addNodeToRack(addr9.getHostName(), \"/region2/r23\");\n+        StaticDNSResolver.addNodeToRack(addr10.getHostName(), \"/region1/r24\");\n+        // Update cluster\n+        Set<BookieSocketAddress> addrs = new HashSet<BookieSocketAddress>();\n+        addrs.add(addr1);\n+        addrs.add(addr2);\n+        addrs.add(addr3);\n+        addrs.add(addr4);\n+        addrs.add(addr5);\n+        addrs.add(addr6);\n+        addrs.add(addr7);\n+        addrs.add(addr8);\n+        addrs.add(addr9);\n+        addrs.add(addr10);\n+        repp.onClusterChanged(addrs, new HashSet<BookieSocketAddress>());\n+        try {\n+            ArrayList<BookieSocketAddress> ensemble = repp.newEnsemble(6, 6, 4, new HashSet<BookieSocketAddress>());\n+            assert(ensemble.contains(addr4));\n+            assert(ensemble.contains(addr8));\n+            assert(ensemble.size() == 6);\n+            assertEquals(3, getNumRegionsInEnsemble(ensemble));\n+            ensemble = repp.newEnsemble(7, 7, 4, new HashSet<BookieSocketAddress>());\n+            assert(ensemble.contains(addr4));\n+            assert(ensemble.contains(addr8));\n+            assert(ensemble.size() == 7);\n+            assertEquals(3, getNumRegionsInEnsemble(ensemble));\n+            ensemble = repp.newEnsemble(8, 8, 5, new HashSet<BookieSocketAddress>());\n+            assert(ensemble.contains(addr4));\n+            assert(ensemble.contains(addr8));\n+            assert(ensemble.size() == 8);\n+            assertEquals(3, getNumRegionsInEnsemble(ensemble));\n+            ensemble = repp.newEnsemble(9, 9, 5, new HashSet<BookieSocketAddress>());\n+            assert(ensemble.contains(addr4));\n+            assert(ensemble.contains(addr8));\n+            assert(ensemble.size() == 9);\n+            assertEquals(3, getNumRegionsInEnsemble(ensemble));\n+        } catch (BKNotEnoughBookiesException bnebe) {\n+            fail(\"Should not get not enough bookies exception even there is only one rack.\");\n+        }\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testNewEnsembleWithThreeRegionsWithDisable() throws Exception {\n+        FeatureProvider featureProvider = new SettableFeatureProvider(\"\", 0);\n+        repp.uninitalize();\n+        repp = new RegionAwareEnsemblePlacementPolicy();\n+        conf.setProperty(REPP_DISALLOW_BOOKIE_PLACEMENT_IN_REGION_FEATURE_NAME, \"disallowBookies\");\n+        repp.initialize(conf, Optional.<DNSToSwitchMapping>absent(), timer, featureProvider, null);\n+        BookieSocketAddress addr1 = new BookieSocketAddress(\"127.0.0.2\", 3181);\n+        BookieSocketAddress addr2 = new BookieSocketAddress(\"127.0.0.3\", 3181);\n+        BookieSocketAddress addr3 = new BookieSocketAddress(\"127.0.0.4\", 3181);\n+        BookieSocketAddress addr4 = new BookieSocketAddress(\"127.0.0.5\", 3181);\n+        BookieSocketAddress addr5 = new BookieSocketAddress(\"127.0.0.6\", 3181);\n+        BookieSocketAddress addr6 = new BookieSocketAddress(\"127.0.0.7\", 3181);\n+        BookieSocketAddress addr7 = new BookieSocketAddress(\"127.0.0.8\", 3181);\n+        BookieSocketAddress addr8 = new BookieSocketAddress(\"127.0.0.9\", 3181);\n+        BookieSocketAddress addr9 = new BookieSocketAddress(\"127.0.0.10\", 3181);\n+        BookieSocketAddress addr10 = new BookieSocketAddress(\"127.0.0.11\", 3181);\n+        // update dns mapping\n+        StaticDNSResolver.addNodeToRack(addr1.getHostName(), \"/region2/r1\");\n+        StaticDNSResolver.addNodeToRack(addr2.getHostName(), \"/region1/r2\");\n+        StaticDNSResolver.addNodeToRack(addr3.getHostName(), \"/region2/r3\");\n+        StaticDNSResolver.addNodeToRack(addr4.getHostName(), \"/region3/r4\");\n+        StaticDNSResolver.addNodeToRack(addr5.getHostName(), \"/region1/r11\");\n+        StaticDNSResolver.addNodeToRack(addr6.getHostName(), \"/region1/r12\");\n+        StaticDNSResolver.addNodeToRack(addr7.getHostName(), \"/region2/r13\");\n+        StaticDNSResolver.addNodeToRack(addr8.getHostName(), \"/region3/r14\");\n+        StaticDNSResolver.addNodeToRack(addr9.getHostName(), \"/region2/r23\");\n+        StaticDNSResolver.addNodeToRack(addr10.getHostName(), \"/region1/r24\");\n+        // Update cluster\n+        Set<BookieSocketAddress> addrs = new HashSet<BookieSocketAddress>();\n+        addrs.add(addr1);\n+        addrs.add(addr2);\n+        addrs.add(addr3);\n+        addrs.add(addr4);\n+        addrs.add(addr5);\n+        addrs.add(addr6);\n+        addrs.add(addr7);\n+        addrs.add(addr8);\n+        addrs.add(addr9);\n+        addrs.add(addr10);\n+        repp.onClusterChanged(addrs, new HashSet<BookieSocketAddress>());\n+        try {\n+            ((SettableFeature) featureProvider.scope(\"region1\").getFeature(\"disallowBookies\")).set(true);\n+            ArrayList<BookieSocketAddress> ensemble = repp.newEnsemble(6, 6, 4, new HashSet<BookieSocketAddress>());\n+            assertEquals(2, getNumRegionsInEnsemble(ensemble));\n+            assert(ensemble.contains(addr1));\n+            assert(ensemble.contains(addr3));\n+            assert(ensemble.contains(addr4));\n+            assert(ensemble.contains(addr7));\n+            assert(ensemble.contains(addr8));\n+            assert(ensemble.contains(addr9));\n+            assert(ensemble.size() == 6);\n+        } catch (BKNotEnoughBookiesException bnebe) {\n+            fail(\"Should not get not enough bookies exception even there is only one rack.\");\n+        }\n+        try {\n+            ((SettableFeature) featureProvider.scope(\"region2\").getFeature(\"disallowBookies\")).set(true);\n+            ArrayList<BookieSocketAddress> ensemble = repp.newEnsemble(6, 6, 4, new HashSet<BookieSocketAddress>());\n+            fail(\"Should get not enough bookies exception even there is only one region with insufficient bookies.\");\n+        } catch (BKNotEnoughBookiesException bnebe) {\n+            // Expected\n+        }\n+        try {\n+            ((SettableFeature) featureProvider.scope(\"region2\").getFeature(\"disallowBookies\")).set(false);\n+            ArrayList<BookieSocketAddress> ensemble = repp.newEnsemble(6, 6, 4, new HashSet<BookieSocketAddress>());\n+            assert(ensemble.contains(addr1));\n+            assert(ensemble.contains(addr3));\n+            assert(ensemble.contains(addr4));\n+            assert(ensemble.contains(addr7));\n+            assert(ensemble.contains(addr8));\n+            assert(ensemble.contains(addr9));\n+            assert(ensemble.size() == 6);\n+            assertEquals(2, getNumRegionsInEnsemble(ensemble));\n+        } catch (BKNotEnoughBookiesException bnebe) {\n+            fail(\"Should not get not enough bookies exception even there is only one rack.\");\n+        }\n+    }\n+\n+\n+    @Test(timeout = 60000)\n+    public void testNewEnsembleWithFiveRegions() throws Exception {\n+        repp.uninitalize();\n+        repp = new RegionAwareEnsemblePlacementPolicy();\n+        conf.setProperty(REPP_REGIONS_TO_WRITE, \"region1;region2;region3;region4;region5\");\n+        conf.setProperty(REPP_MINIMUM_REGIONS_FOR_DURABILITY, 5);\n+        repp.initialize(conf, Optional.<DNSToSwitchMapping>absent(), timer, DISABLE_ALL, null);\n+        BookieSocketAddress addr1 = new BookieSocketAddress(\"127.1.0.2\", 3181);\n+        BookieSocketAddress addr2 = new BookieSocketAddress(\"127.1.0.3\", 3181);\n+        BookieSocketAddress addr3 = new BookieSocketAddress(\"127.1.0.4\", 3181);\n+        BookieSocketAddress addr4 = new BookieSocketAddress(\"127.1.0.5\", 3181);\n+        BookieSocketAddress addr5 = new BookieSocketAddress(\"127.1.0.6\", 3181);\n+        BookieSocketAddress addr6 = new BookieSocketAddress(\"127.1.0.7\", 3181);\n+        BookieSocketAddress addr7 = new BookieSocketAddress(\"127.1.0.8\", 3181);\n+        BookieSocketAddress addr8 = new BookieSocketAddress(\"127.1.0.9\", 3181);\n+        BookieSocketAddress addr9 = new BookieSocketAddress(\"127.1.0.10\", 3181);\n+        BookieSocketAddress addr10 = new BookieSocketAddress(\"127.1.0.11\", 3181);\n+        BookieSocketAddress addr11 = new BookieSocketAddress(\"127.1.0.12\", 3181);\n+        BookieSocketAddress addr12 = new BookieSocketAddress(\"127.1.0.13\", 3181);\n+        BookieSocketAddress addr13 = new BookieSocketAddress(\"127.1.0.14\", 3181);\n+        BookieSocketAddress addr14 = new BookieSocketAddress(\"127.1.0.15\", 3181);\n+        BookieSocketAddress addr15 = new BookieSocketAddress(\"127.1.0.16\", 3181);\n+        // update dns mapping\n+        StaticDNSResolver.addNodeToRack(addr1.getHostName(), \"/region1/r1\");\n+        StaticDNSResolver.addNodeToRack(addr2.getHostName(), \"/region1/r2\");\n+        StaticDNSResolver.addNodeToRack(addr3.getHostName(), \"/region1/r3\");\n+        StaticDNSResolver.addNodeToRack(addr4.getHostName(), \"/region2/r4\");\n+        StaticDNSResolver.addNodeToRack(addr5.getHostName(), \"/region2/r11\");\n+        StaticDNSResolver.addNodeToRack(addr6.getHostName(), \"/region2/r12\");\n+        StaticDNSResolver.addNodeToRack(addr7.getHostName(), \"/region3/r13\");\n+        StaticDNSResolver.addNodeToRack(addr8.getHostName(), \"/region3/r14\");\n+        StaticDNSResolver.addNodeToRack(addr9.getHostName(), \"/region3/r23\");\n+        StaticDNSResolver.addNodeToRack(addr10.getHostName(), \"/region4/r24\");\n+        StaticDNSResolver.addNodeToRack(addr11.getHostName(), \"/region4/r31\");\n+        StaticDNSResolver.addNodeToRack(addr12.getHostName(), \"/region4/r32\");\n+        StaticDNSResolver.addNodeToRack(addr13.getHostName(), \"/region5/r33\");\n+        StaticDNSResolver.addNodeToRack(addr14.getHostName(), \"/region5/r34\");\n+        StaticDNSResolver.addNodeToRack(addr15.getHostName(), \"/region5/r35\");\n+        // Update cluster\n+        Set<BookieSocketAddress> addrs = new HashSet<BookieSocketAddress>();\n+        addrs.add(addr1);\n+        addrs.add(addr2);\n+        addrs.add(addr3);\n+        addrs.add(addr4);\n+        addrs.add(addr5);\n+        addrs.add(addr6);\n+        addrs.add(addr7);\n+        addrs.add(addr8);\n+        addrs.add(addr9);\n+        addrs.add(addr10);\n+        addrs.add(addr11);\n+        addrs.add(addr12);\n+        addrs.add(addr13);\n+        addrs.add(addr14);\n+        addrs.add(addr15);\n+        repp.onClusterChanged(addrs, new HashSet<BookieSocketAddress>());\n+\n+        try {\n+            ArrayList<BookieSocketAddress> ensemble = repp.newEnsemble(10, 10, 10, new HashSet<BookieSocketAddress>());\n+            assert(ensemble.size() == 10);\n+            assertEquals(5, getNumRegionsInEnsemble(ensemble));\n+        } catch (BKNotEnoughBookiesException bnebe) {\n+            LOG.error(\"BKNotEnoughBookiesException\", bnebe);\n+            fail(\"Should not get not enough bookies exception even there is only one rack.\");\n+        }\n+\n+        try{\n+            Set<BookieSocketAddress> excludedAddrs = new HashSet<BookieSocketAddress>();\n+            excludedAddrs.add(addr10);\n+            ArrayList<BookieSocketAddress> ensemble = repp.newEnsemble(10, 10, 10, excludedAddrs);\n+            assert(ensemble.contains(addr11) && ensemble.contains(addr12));\n+            assert(ensemble.size() == 10);\n+            assertEquals(5, getNumRegionsInEnsemble(ensemble));\n+        } catch (BKNotEnoughBookiesException bnebe) {\n+            fail(\"Should not get not enough bookies exception even there is only one rack.\");\n+        }\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testEnsembleWithThreeRegionsReplace() throws Exception {\n+        testEnsembleWithThreeRegionsReplaceInternal(3, false, false);\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testEnsembleWithThreeRegionsReplaceDisableOneRegion() throws Exception {\n+        testEnsembleWithThreeRegionsReplaceInternal(2, false, true);\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testEnsembleWithThreeRegionsReplaceMinDurabilityOne() throws Exception {\n+        testEnsembleWithThreeRegionsReplaceInternal(1, false, false);\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testEnsembleWithThreeRegionsReplaceDisableDurability() throws Exception {\n+        testEnsembleWithThreeRegionsReplaceInternal(1, true, false);\n+    }\n+\n+    public void testEnsembleWithThreeRegionsReplaceInternal(int minDurability, boolean disableDurability, boolean disableOneRegion) throws Exception {\n+        repp.uninitalize();\n+        repp = new RegionAwareEnsemblePlacementPolicy();\n+        conf.setProperty(REPP_REGIONS_TO_WRITE, \"region1;region2;region3\");\n+        conf.setProperty(REPP_MINIMUM_REGIONS_FOR_DURABILITY, minDurability);\n+        FeatureProvider featureProvider = new SettableFeatureProvider(\"\", 0);\n+        if (minDurability <= 1) {\n+            conf.setProperty(REPP_ENABLE_DURABILITY_ENFORCEMENT_IN_REPLACE, false);\n+        } else {\n+            conf.setProperty(REPP_ENABLE_DURABILITY_ENFORCEMENT_IN_REPLACE, true);\n+        }\n+        conf.setProperty(REPP_DISALLOW_BOOKIE_PLACEMENT_IN_REGION_FEATURE_NAME, \"disallowBookies\");\n+\n+        repp.initialize(conf, Optional.<DNSToSwitchMapping>absent(), timer, featureProvider, null);\n+        BookieSocketAddress addr1 = new BookieSocketAddress(\"127.1.0.2\", 3181);\n+        BookieSocketAddress addr2 = new BookieSocketAddress(\"127.1.0.3\", 3181);\n+        BookieSocketAddress addr3 = new BookieSocketAddress(\"127.1.0.4\", 3181);\n+        BookieSocketAddress addr4 = new BookieSocketAddress(\"127.1.0.5\", 3181);\n+        BookieSocketAddress addr5 = new BookieSocketAddress(\"127.1.0.6\", 3181);\n+        BookieSocketAddress addr6 = new BookieSocketAddress(\"127.1.0.7\", 3181);\n+        BookieSocketAddress addr7 = new BookieSocketAddress(\"127.1.0.8\", 3181);\n+        BookieSocketAddress addr8 = new BookieSocketAddress(\"127.1.0.9\", 3181);\n+        BookieSocketAddress addr9 = new BookieSocketAddress(\"127.1.0.10\", 3181);\n+        // update dns mapping\n+        StaticDNSResolver.addNodeToRack(addr1.getHostName(), \"/region1/r1\");\n+        StaticDNSResolver.addNodeToRack(addr2.getHostName(), \"/region1/r2\");\n+        StaticDNSResolver.addNodeToRack(addr3.getHostName(), \"/region1/r3\");\n+        StaticDNSResolver.addNodeToRack(addr4.getHostName(), \"/region2/r4\");\n+        StaticDNSResolver.addNodeToRack(addr5.getHostName(), \"/region2/r11\");\n+        StaticDNSResolver.addNodeToRack(addr6.getHostName(), \"/region2/r12\");\n+        StaticDNSResolver.addNodeToRack(addr7.getHostName(), \"/region3/r13\");\n+        StaticDNSResolver.addNodeToRack(addr8.getHostName(), \"/region3/r14\");\n+        StaticDNSResolver.addNodeToRack(addr9.getHostName(), \"/region3/r23\");\n+\n+        // Update cluster\n+        Set<BookieSocketAddress> addrs = new HashSet<BookieSocketAddress>();\n+        addrs.add(addr1);\n+        addrs.add(addr2);\n+        addrs.add(addr3);\n+        addrs.add(addr4);\n+        addrs.add(addr5);\n+        addrs.add(addr6);\n+        addrs.add(addr7);\n+        addrs.add(addr8);\n+        addrs.add(addr9);\n+        repp.onClusterChanged(addrs, new HashSet<BookieSocketAddress>());\n+\n+        SettableFeature disableDurabilityFeature =\n+                (SettableFeature) featureProvider.getFeature(\n+                        BookKeeperConstants.FEATURE_REPP_DISABLE_DURABILITY_ENFORCEMENT);\n+\n+        if (disableDurability) {\n+            disableDurabilityFeature.set(true);\n+        }\n+\n+        int ackQuorum = 4;\n+        if (minDurability > 2) {\n+            ackQuorum = 5;\n+        }\n+\n+        ArrayList<BookieSocketAddress> ensemble;\n+        try {\n+            ensemble = repp.newEnsemble(6, 6, ackQuorum, new HashSet<BookieSocketAddress>());\n+            assert(ensemble.size() == 6);\n+            assertEquals(3, getNumRegionsInEnsemble(ensemble));\n+        } catch (BKNotEnoughBookiesException bnebe) {\n+            LOG.error(\"BKNotEnoughBookiesException\", bnebe);\n+            fail(\"Should not get not enough bookies exception even there is only one rack.\");\n+            throw bnebe;\n+        }\n+\n+        if (disableOneRegion) {\n+            ((SettableFeature) featureProvider.scope(\"region2\").getFeature(\"disallowBookies\")).set(true);\n+            Set<BookieSocketAddress> region2Bookies = new HashSet<BookieSocketAddress>();\n+            region2Bookies.add(addr4);\n+            region2Bookies.add(addr5);\n+            region2Bookies.add(addr6);\n+            Set<BookieSocketAddress> region1And3Bookies = new HashSet<BookieSocketAddress>(addrs);\n+            region1And3Bookies.removeAll(region2Bookies);\n+\n+            Set<BookieSocketAddress> excludedAddrs = new HashSet<BookieSocketAddress>();\n+            for(BookieSocketAddress addr: region2Bookies) {\n+                if (ensemble.contains(addr)) {\n+                    BookieSocketAddress replacedBookie = repp.replaceBookie(6, 6, ackQuorum, ensemble, addr, excludedAddrs);\n+                    ensemble.remove(addr);\n+                    ensemble.add(replacedBookie);\n+                }\n+            }\n+            assertEquals(2, getNumRegionsInEnsemble(ensemble));\n+            assertTrue(ensemble.containsAll(region1And3Bookies));\n+        } else {\n+            BookieSocketAddress bookieToReplace;\n+            BookieSocketAddress replacedBookieExpected;\n+            if (ensemble.contains(addr4)) {\n+                bookieToReplace = addr4;\n+                if (ensemble.contains(addr5)) {\n+                    replacedBookieExpected = addr6;\n+                } else {\n+                    replacedBookieExpected = addr5;\n+                }\n+            } else {\n+                replacedBookieExpected = addr4;\n+                bookieToReplace = addr5;\n+            }\n+            Set<BookieSocketAddress> excludedAddrs = new HashSet<BookieSocketAddress>();\n+\n+            try {\n+                BookieSocketAddress replacedBookie = repp.replaceBookie(6, 6, ackQuorum, ensemble, bookieToReplace, excludedAddrs);\n+                assert (replacedBookie.equals(replacedBookieExpected));\n+                assertEquals(3, getNumRegionsInEnsemble(ensemble));\n+            } catch (BKNotEnoughBookiesException bnebe) {\n+                fail(\"Should not get not enough bookies exception even there is only one rack.\");\n+            }\n+\n+            excludedAddrs.add(replacedBookieExpected);\n+            try {\n+                BookieSocketAddress replacedBookie = repp.replaceBookie(6, 6, ackQuorum, ensemble, bookieToReplace, excludedAddrs);\n+                if (minDurability > 1 && !disableDurabilityFeature.isAvailable()) {\n+                    fail(\"Should throw BKNotEnoughBookiesException when there is not enough bookies\");\n+                }\n+            } catch (BKNotEnoughBookiesException bnebe) {\n+                if (minDurability <= 1 || disableDurabilityFeature.isAvailable()) {\n+                    fail(\"Should not throw BKNotEnoughBookiesException when there is not enough bookies\");\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testEnsembleMinDurabilityOne() throws Exception {\n+        testEnsembleDurabilityDisabledInternal(1, false);\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testEnsembleDisableDurability() throws Exception {\n+        testEnsembleDurabilityDisabledInternal(2, true);\n+    }\n+\n+    public void testEnsembleDurabilityDisabledInternal(int minDurability, boolean disableDurability) throws Exception {\n+        repp.uninitalize();\n+        repp = new RegionAwareEnsemblePlacementPolicy();\n+        conf.setProperty(REPP_REGIONS_TO_WRITE, \"region1;region2;region3\");\n+        conf.setProperty(REPP_MINIMUM_REGIONS_FOR_DURABILITY, minDurability);\n+        FeatureProvider featureProvider = new SettableFeatureProvider(\"\", 0);\n+        if (minDurability <= 1) {\n+            conf.setProperty(REPP_ENABLE_DURABILITY_ENFORCEMENT_IN_REPLACE, false);\n+        } else {\n+            conf.setProperty(REPP_ENABLE_DURABILITY_ENFORCEMENT_IN_REPLACE, true);\n+        }\n+\n+        repp.initialize(conf, Optional.<DNSToSwitchMapping>absent(), timer, featureProvider, null);\n+        BookieSocketAddress addr1 = new BookieSocketAddress(\"127.1.0.2\", 3181);\n+        BookieSocketAddress addr2 = new BookieSocketAddress(\"127.1.0.3\", 3181);\n+        BookieSocketAddress addr3 = new BookieSocketAddress(\"127.1.0.4\", 3181);\n+        BookieSocketAddress addr4 = new BookieSocketAddress(\"127.1.0.5\", 3181);\n+        BookieSocketAddress addr5 = new BookieSocketAddress(\"127.1.0.6\", 3181);\n+        BookieSocketAddress addr6 = new BookieSocketAddress(\"127.1.0.7\", 3181);\n+        BookieSocketAddress addr7 = new BookieSocketAddress(\"127.1.0.8\", 3181);\n+        BookieSocketAddress addr8 = new BookieSocketAddress(\"127.1.0.9\", 3181);\n+        BookieSocketAddress addr9 = new BookieSocketAddress(\"127.1.0.10\", 3181);\n+        // update dns mapping\n+        StaticDNSResolver.addNodeToRack(addr1.getHostName(), \"/region1/r1\");\n+        StaticDNSResolver.addNodeToRack(addr2.getHostName(), \"/region1/r2\");\n+        StaticDNSResolver.addNodeToRack(addr3.getHostName(), \"/region1/r3\");\n+        StaticDNSResolver.addNodeToRack(addr4.getHostName(), \"/region1/r4\");\n+        StaticDNSResolver.addNodeToRack(addr5.getHostName(), \"/region1/r11\");\n+        StaticDNSResolver.addNodeToRack(addr6.getHostName(), \"/region1/r12\");\n+        StaticDNSResolver.addNodeToRack(addr7.getHostName(), \"/region1/r13\");\n+        StaticDNSResolver.addNodeToRack(addr8.getHostName(), \"/region1/r14\");\n+        StaticDNSResolver.addNodeToRack(addr9.getHostName(), \"/region1/r23\");\n+\n+        // Update cluster\n+        Set<BookieSocketAddress> addrs = new HashSet<BookieSocketAddress>();\n+        addrs.add(addr1);\n+        addrs.add(addr2);\n+        addrs.add(addr3);\n+        addrs.add(addr4);\n+        addrs.add(addr5);\n+        addrs.add(addr6);\n+        addrs.add(addr7);\n+        addrs.add(addr8);\n+        addrs.add(addr9);\n+        repp.onClusterChanged(addrs, new HashSet<BookieSocketAddress>());\n+\n+        if (disableDurability) {\n+            ((SettableFeature) featureProvider.getFeature(BookKeeperConstants.FEATURE_REPP_DISABLE_DURABILITY_ENFORCEMENT))\n+                    .set(true);\n+        }\n+\n+        ArrayList<BookieSocketAddress> ensemble;\n+        try {\n+            ensemble = repp.newEnsemble(6, 6, 4, new HashSet<BookieSocketAddress>());\n+            assert(ensemble.size() == 6);\n+        } catch (BKNotEnoughBookiesException bnebe) {\n+            LOG.error(\"BKNotEnoughBookiesException\", bnebe);\n+            fail(\"Should not get not enough bookies exception even there is only one rack.\");\n+            throw bnebe;\n+        }\n+\n+        Set<BookieSocketAddress> excludedAddrs = new HashSet<BookieSocketAddress>();\n+\n+        try{\n+            repp.replaceBookie(6, 6, 4, ensemble, addr4, excludedAddrs);\n+        } catch (BKNotEnoughBookiesException bnebe) {\n+            fail(\"Should not get not enough bookies exception even there is only one rack.\");\n+        }\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testNewEnsembleFailWithFiveRegions() throws Exception {\n+        repp.uninitalize();\n+        repp = new RegionAwareEnsemblePlacementPolicy();\n+        conf.setProperty(REPP_REGIONS_TO_WRITE, \"region1;region2;region3;region4;region5\");\n+        conf.setProperty(REPP_MINIMUM_REGIONS_FOR_DURABILITY, 5);\n+        conf.setProperty(REPP_ENABLE_VALIDATION, false);\n+        repp.initialize(conf, Optional.<DNSToSwitchMapping>absent(), timer, DISABLE_ALL, null);\n+        BookieSocketAddress addr1 = new BookieSocketAddress(\"127.0.0.2\", 3181);\n+        BookieSocketAddress addr2 = new BookieSocketAddress(\"127.0.0.3\", 3181);\n+        BookieSocketAddress addr3 = new BookieSocketAddress(\"127.0.0.4\", 3181);\n+        BookieSocketAddress addr4 = new BookieSocketAddress(\"127.0.0.5\", 3181);\n+        BookieSocketAddress addr5 = new BookieSocketAddress(\"127.0.0.6\", 3181);\n+        BookieSocketAddress addr6 = new BookieSocketAddress(\"127.0.0.7\", 3181);\n+        BookieSocketAddress addr7 = new BookieSocketAddress(\"127.0.0.8\", 3181);\n+        BookieSocketAddress addr8 = new BookieSocketAddress(\"127.0.0.9\", 3181);\n+        BookieSocketAddress addr9 = new BookieSocketAddress(\"127.0.0.10\", 3181);\n+        BookieSocketAddress addr10 = new BookieSocketAddress(\"127.0.0.11\", 3181);\n+        // update dns mapping\n+        StaticDNSResolver.addNodeToRack(addr1.getHostName(), \"/region1/r1\");\n+        StaticDNSResolver.addNodeToRack(addr2.getHostName(), \"/region1/r2\");\n+        StaticDNSResolver.addNodeToRack(addr3.getHostName(), \"/region2/r3\");\n+        StaticDNSResolver.addNodeToRack(addr4.getHostName(), \"/region2/r4\");\n+        StaticDNSResolver.addNodeToRack(addr5.getHostName(), \"/region3/r11\");\n+        StaticDNSResolver.addNodeToRack(addr6.getHostName(), \"/region3/r12\");\n+        StaticDNSResolver.addNodeToRack(addr7.getHostName(), \"/region4/r13\");\n+        StaticDNSResolver.addNodeToRack(addr8.getHostName(), \"/region4/r14\");\n+        StaticDNSResolver.addNodeToRack(addr9.getHostName(), \"/region5/r23\");\n+        StaticDNSResolver.addNodeToRack(addr10.getHostName(), \"/region5/r24\");\n+        // Update cluster\n+        Set<BookieSocketAddress> addrs = new HashSet<BookieSocketAddress>();\n+        addrs.add(addr1);\n+        addrs.add(addr2);\n+        addrs.add(addr3);\n+        addrs.add(addr4);\n+        addrs.add(addr5);\n+        addrs.add(addr6);\n+        addrs.add(addr7);\n+        addrs.add(addr8);\n+        addrs.add(addr9);\n+        addrs.add(addr10);\n+        repp.onClusterChanged(addrs, new HashSet<BookieSocketAddress>());\n+\n+        Set<BookieSocketAddress> excludedAddrs = new HashSet<BookieSocketAddress>();\n+        excludedAddrs.add(addr10);\n+        excludedAddrs.add(addr9);\n+        try {\n+            ArrayList<BookieSocketAddress> list = repp.newEnsemble(5, 5, 5, excludedAddrs);\n+            LOG.info(\"Ensemble : {}\", list);\n+            fail(\"Should throw BKNotEnoughBookiesException when there is not enough bookies\");\n+        } catch (BKNotEnoughBookiesException bnebe) {\n+            // should throw not enou\n+        }\n+    }\n+\n+    private void prepareNetworkTopologyForReorderTests(String myRegion) throws Exception {\n+        repp.uninitalize();\n+        updateMyRack(\"/\" + myRegion);\n+\n+        repp = new RegionAwareEnsemblePlacementPolicy();\n+        repp.initialize(conf, Optional.<DNSToSwitchMapping>absent(), timer, DISABLE_ALL, null);\n+\n+        BookieSocketAddress addr1 = new BookieSocketAddress(\"127.0.0.2\", 3181);\n+        BookieSocketAddress addr2 = new BookieSocketAddress(\"127.0.0.3\", 3181);\n+        BookieSocketAddress addr3 = new BookieSocketAddress(\"127.0.0.4\", 3181);\n+        BookieSocketAddress addr4 = new BookieSocketAddress(\"127.0.0.5\", 3181);\n+        BookieSocketAddress addr5 = new BookieSocketAddress(\"127.0.0.6\", 3181);\n+        BookieSocketAddress addr6 = new BookieSocketAddress(\"127.0.0.7\", 3181);\n+        BookieSocketAddress addr7 = new BookieSocketAddress(\"127.0.0.8\", 3181);\n+        BookieSocketAddress addr8 = new BookieSocketAddress(\"127.0.0.9\", 3181);\n+        BookieSocketAddress addr9 = new BookieSocketAddress(\"127.0.0.10\", 3181);\n+        // update dns mapping\n+        StaticDNSResolver.addNodeToRack(addr1.getHostName(), \"/region1/r1\");\n+        StaticDNSResolver.addNodeToRack(addr2.getHostName(), \"/region1/r2\");\n+        StaticDNSResolver.addNodeToRack(addr3.getHostName(), \"/region1/r3\");\n+        StaticDNSResolver.addNodeToRack(addr4.getHostName(), \"/region2/r1\");\n+        StaticDNSResolver.addNodeToRack(addr5.getHostName(), \"/region2/r2\");\n+        StaticDNSResolver.addNodeToRack(addr6.getHostName(), \"/region2/r3\");\n+        StaticDNSResolver.addNodeToRack(addr7.getHostName(), \"/region3/r1\");\n+        StaticDNSResolver.addNodeToRack(addr8.getHostName(), \"/region3/r2\");\n+        StaticDNSResolver.addNodeToRack(addr9.getHostName(), \"/region3/r3\");\n+        // Update cluster\n+        Set<BookieSocketAddress> addrs = new HashSet<BookieSocketAddress>();\n+        addrs.add(addr1);\n+        addrs.add(addr2);\n+        addrs.add(addr3);\n+        addrs.add(addr4);\n+        addrs.add(addr5);\n+        addrs.add(addr6);\n+        addrs.add(addr7);\n+        addrs.add(addr8);\n+        addrs.add(addr9);\n+        repp.onClusterChanged(addrs, new HashSet<BookieSocketAddress>());\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testBasicReorderReadSequenceWithLocalRegion() throws Exception {\n+        basicReorderReadSequenceWithLocalRegionTest(\"region2\", false);\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testBasicReorderReadLACSequenceWithLocalRegion() throws Exception {\n+        basicReorderReadSequenceWithLocalRegionTest(\"region2\", true);\n+    }\n+\n+    private void basicReorderReadSequenceWithLocalRegionTest(String myRegion, boolean isReadLAC) throws Exception {\n+        prepareNetworkTopologyForReorderTests(myRegion);\n+\n+        ArrayList<BookieSocketAddress> ensemble = repp.newEnsemble(9, 9, 5, new HashSet<BookieSocketAddress>());\n+        assertEquals(9, getNumCoveredRegionsInWriteQuorum(ensemble, 9));\n+\n+        DistributionSchedule ds = new RoundRobinDistributionSchedule(9, 9, 9);\n+\n+        LOG.info(\"My region is {}, ensemble : {}\", repp.myRegion, ensemble);\n+\n+        int ensembleSize = ensemble.size();\n+        for (int i = 0; i < ensembleSize; i++) {\n+            List<Integer> writeSet = ds.getWriteSet(i);\n+            List<Integer> readSet;\n+            if (isReadLAC) {\n+                readSet = repp.reorderReadLACSequence(ensemble, writeSet, new HashMap<BookieSocketAddress, Long>());\n+            } else {\n+                readSet = repp.reorderReadSequence(ensemble, writeSet, new HashMap<BookieSocketAddress, Long>());\n+            }\n+\n+            LOG.info(\"Reorder {} => {}.\", writeSet, readSet);\n+\n+            // first few nodes less than REMOTE_NODE_IN_REORDER_SEQUENCE should be local region\n+            int k = 0;\n+            for (; k < RegionAwareEnsemblePlacementPolicy.REMOTE_NODE_IN_REORDER_SEQUENCE; k++) {\n+                BookieSocketAddress address = ensemble.get(readSet.get(k));\n+                assertEquals(myRegion, StaticDNSResolver.getRegion(address.getHostName()));\n+            }\n+            BookieSocketAddress remoteAddress = ensemble.get(readSet.get(k));\n+            assertFalse(myRegion.equals(StaticDNSResolver.getRegion(remoteAddress.getHostName())));\n+            k++;\n+            BookieSocketAddress localAddress = ensemble.get(readSet.get(k));\n+            assertEquals(myRegion, StaticDNSResolver.getRegion(localAddress.getHostName()));\n+            k++;\n+            for (; k < ensembleSize; k++) {\n+                BookieSocketAddress address = ensemble.get(readSet.get(k));\n+                assertFalse(myRegion.equals(StaticDNSResolver.getRegion(address.getHostName())));\n+            }\n+        }\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testBasicReorderReadSequenceWithRemoteRegion() throws Exception {\n+        basicReorderReadSequenceWithRemoteRegionTest(\"region4\", false);\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testBasicReorderReadLACSequenceWithRemoteRegion() throws Exception {\n+        basicReorderReadSequenceWithRemoteRegionTest(\"region4\", true);\n+    }\n+\n+    private void basicReorderReadSequenceWithRemoteRegionTest(String myRegion, boolean isReadLAC) throws Exception {\n+        prepareNetworkTopologyForReorderTests(myRegion);\n+\n+        ArrayList<BookieSocketAddress> ensemble = repp.newEnsemble(9, 9, 5, new HashSet<BookieSocketAddress>());\n+        assertEquals(9, getNumCoveredRegionsInWriteQuorum(ensemble, 9));\n+\n+        DistributionSchedule ds = new RoundRobinDistributionSchedule(9, 9, 9);\n+\n+        LOG.info(\"My region is {}, ensemble : {}\", repp.myRegion, ensemble);\n+\n+        int ensembleSize = ensemble.size();\n+        for (int i = 0; i < ensembleSize; i++) {\n+            List<Integer> writeSet = ds.getWriteSet(i);\n+            List<Integer> readSet;\n+\n+            if (isReadLAC) {\n+                readSet = repp.reorderReadLACSequence(ensemble, writeSet, new HashMap<BookieSocketAddress, Long>());\n+            } else {\n+                readSet = repp.reorderReadSequence(ensemble, writeSet, new HashMap<BookieSocketAddress, Long>());\n+            }\n+\n+            assertEquals(writeSet, readSet);\n+        }\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testReorderReadSequenceWithUnavailableOrReadOnlyBookies() throws Exception {\n+        reorderReadSequenceWithUnavailableOrReadOnlyBookiesTest(false);\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testReorderReadLACSequenceWithUnavailableOrReadOnlyBookies() throws Exception {\n+        reorderReadSequenceWithUnavailableOrReadOnlyBookiesTest(true);\n+    }\n+\n+    static Set<BookieSocketAddress> getBookiesForRegion(ArrayList<BookieSocketAddress> ensemble, String region) {\n+        Set<BookieSocketAddress> regionBookies = new HashSet<BookieSocketAddress>();\n+        for (BookieSocketAddress address : ensemble) {\n+            String r = StaticDNSResolver.getRegion(address.getHostName());\n+            if (r.equals(region)) {\n+                regionBookies.add(address);\n+            }\n+        }\n+        return regionBookies;\n+    }\n+\n+    static void appendBookieIndexByRegion(ArrayList<BookieSocketAddress> ensemble,\n+                                          List<Integer> writeSet,\n+                                          String region,\n+                                          List<Integer> finalSet) {\n+        for (int bi : writeSet) {\n+            String r = StaticDNSResolver.getRegion(ensemble.get(bi).getHostName());\n+            if (r.equals(region)) {\n+                finalSet.add(bi);\n+            }\n+        }\n+    }\n+\n+    private void reorderReadSequenceWithUnavailableOrReadOnlyBookiesTest(boolean isReadLAC) throws Exception {\n+        String myRegion = \"region4\";\n+        String unavailableRegion = \"region1\";\n+        String writeRegion = \"region2\";\n+        String readOnlyRegion = \"region3\";\n+\n+        prepareNetworkTopologyForReorderTests(myRegion);\n+\n+        ArrayList<BookieSocketAddress> ensemble = repp.newEnsemble(9, 9, 5, new HashSet<BookieSocketAddress>());\n+        assertEquals(9, getNumCoveredRegionsInWriteQuorum(ensemble, 9));\n+\n+        DistributionSchedule ds = new RoundRobinDistributionSchedule(9, 9, 9);\n+\n+        LOG.info(\"My region is {}, ensemble : {}\", repp.myRegion, ensemble);\n+\n+        Set<BookieSocketAddress> readOnlyBookies = getBookiesForRegion(ensemble, readOnlyRegion);\n+        Set<BookieSocketAddress> writeBookies = getBookiesForRegion(ensemble, writeRegion);\n+\n+        repp.onClusterChanged(writeBookies, readOnlyBookies);\n+\n+        LOG.info(\"Writable Bookies {}, ReadOnly Bookies {}.\", repp.knownBookies.keySet(), repp.readOnlyBookies);\n+\n+        int ensembleSize = ensemble.size();\n+        for (int i = 0; i < ensembleSize; i++) {\n+            List<Integer> writeSet = ds.getWriteSet(i);\n+            List<Integer> readSet;\n+            if (isReadLAC) {\n+                readSet = repp.reorderReadLACSequence(ensemble, writeSet, new HashMap<BookieSocketAddress, Long>());\n+            } else {\n+                readSet = repp.reorderReadSequence(ensemble, writeSet, new HashMap<BookieSocketAddress, Long>());\n+            }\n+\n+            LOG.info(\"Reorder {} => {}.\", writeSet, readSet);\n+\n+            List<Integer> expectedReadSet = new ArrayList<Integer>();\n+            // writable bookies\n+            appendBookieIndexByRegion(ensemble, writeSet, writeRegion, expectedReadSet);\n+            // readonly bookies\n+            appendBookieIndexByRegion(ensemble, writeSet, readOnlyRegion, expectedReadSet);\n+            // unavailable bookies\n+            appendBookieIndexByRegion(ensemble, writeSet, unavailableRegion, expectedReadSet);\n+\n+            assertEquals(expectedReadSet, readSet);\n+        }\n+    }\n+\n+    private int getNumRegionsInEnsemble(ArrayList<BookieSocketAddress> ensemble) {\n+        Set<String> regions = new HashSet<String>();\n+        for(BookieSocketAddress addr: ensemble) {\n+            regions.add(StaticDNSResolver.getRegion(addr.getHostName()));\n+        }\n+        return regions.size();\n+    }\n+\n+    private int getNumCoveredRegionsInWriteQuorum(ArrayList<BookieSocketAddress> ensemble, int writeQuorumSize)\n+            throws Exception {\n+        int ensembleSize = ensemble.size();\n+        int numCoveredWriteQuorums = 0;\n+        for (int i = 0; i < ensembleSize; i++) {\n+            Set<String> regions = new HashSet<String>();\n+            for (int j = 0; j < writeQuorumSize; j++) {\n+                int bookieIdx = (i + j) % ensembleSize;\n+                BookieSocketAddress addr = ensemble.get(bookieIdx);\n+                regions.add(StaticDNSResolver.getRegion(addr.getHostName()));\n+            }\n+            numCoveredWriteQuorums += (regions.size() > 1 ? 1 : 0);\n+        }\n+        return numCoveredWriteQuorums;\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testNodeWithFailures() throws Exception {\n+        repp.uninitalize();\n+        updateMyRack(\"/r2/rack1\");\n+\n+        repp = new RegionAwareEnsemblePlacementPolicy();\n+        repp.initialize(conf, Optional.<DNSToSwitchMapping>absent(), timer, DISABLE_ALL, null);\n+\n+        BookieSocketAddress addr5 = new BookieSocketAddress(\"127.0.0.6\", 3181);\n+        BookieSocketAddress addr6 = new BookieSocketAddress(\"127.0.0.7\", 3181);\n+        BookieSocketAddress addr7 = new BookieSocketAddress(\"127.0.0.8\", 3181);\n+        BookieSocketAddress addr8 = new BookieSocketAddress(\"127.0.0.9\", 3181);\n+        // update dns mapping\n+        StaticDNSResolver.addNodeToRack(addr2.getHostName(), \"/r2/rack1\");\n+        StaticDNSResolver.addNodeToRack(addr3.getHostName(), \"/r2/rack2\");\n+        StaticDNSResolver.addNodeToRack(addr5.getHostName(), \"/r1/rack3\");\n+        StaticDNSResolver.addNodeToRack(addr6.getHostName(), \"/r2/rack3\");\n+        StaticDNSResolver.addNodeToRack(addr7.getHostName(), \"/r2/rack4\");\n+        StaticDNSResolver.addNodeToRack(addr8.getHostName(), \"/r1/rack4\");\n+        ensemble.add(addr5);\n+        ensemble.add(addr6);\n+        ensemble.add(addr7);\n+        ensemble.add(addr8);\n+\n+        for (int i = 4; i < 8; i++) {\n+            writeSet.add(i);\n+        }\n+\n+        Set<BookieSocketAddress> addrs = new HashSet<BookieSocketAddress>();\n+        addrs.add(addr1);\n+        addrs.add(addr2);\n+        addrs.add(addr3);\n+        addrs.add(addr4);\n+        addrs.add(addr5);\n+        addrs.add(addr6);\n+        addrs.add(addr7);\n+        addrs.add(addr8);\n+        repp.onClusterChanged(addrs, new HashSet<BookieSocketAddress>());\n+\n+        HashMap<BookieSocketAddress, Long> bookieFailures = new HashMap<BookieSocketAddress, Long>();\n+\n+        bookieFailures.put(addr1, 20L);\n+        bookieFailures.put(addr2, 22L);\n+        bookieFailures.put(addr3, 24L);\n+        bookieFailures.put(addr4, 25L);\n+\n+        List<Integer> reoderSet = repp.reorderReadSequence(ensemble, writeSet, bookieFailures);\n+        LOG.info(\"reorder set : {}\", reoderSet);\n+        assertEquals(ensemble.get(reoderSet.get(0)), addr6);\n+        assertEquals(ensemble.get(reoderSet.get(1)), addr7);\n+        assertEquals(ensemble.get(reoderSet.get(2)), addr5);\n+        assertEquals(ensemble.get(reoderSet.get(3)), addr2);\n+        assertEquals(ensemble.get(reoderSet.get(4)), addr3);\n+        assertEquals(ensemble.get(reoderSet.get(5)), addr8);\n+        assertEquals(ensemble.get(reoderSet.get(6)), addr1);\n+        assertEquals(ensemble.get(reoderSet.get(7)), addr4);\n+    }\n+\n+}"},{"sha":"b04ff64c6016f4ef522301dc63d377ab7f2e56d3","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/UpdateLedgerCmdTest.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/bbd1eb8d8560b03834175fbd996b85237df09f5c/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FUpdateLedgerCmdTest.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/bbd1eb8d8560b03834175fbd996b85237df09f5c/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FUpdateLedgerCmdTest.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FUpdateLedgerCmdTest.java?ref=bbd1eb8d8560b03834175fbd996b85237df09f5c","patch":"@@ -72,7 +72,7 @@ public void testUpdateLedgersToHostname() throws Exception {\n         final ServerConfiguration conf = bsConfs.get(0);\n         conf.setUseHostNameAsBookieID(true);\n         BookieSocketAddress toBookieId = Bookie.getBookieAddress(conf);\n-        BookieSocketAddress toBookieAddr = new BookieSocketAddress(toBookieId.getHostname() + \":\"\n+        BookieSocketAddress toBookieAddr = new BookieSocketAddress(toBookieId.getHostName() + \":\"\n                 + conf.getBookiePort());\n \n         updateLedgerCmd(argv, 0, conf);"},{"sha":"ebcf8faff96dfeb70213456555e79ea1a7b4ffdc","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/UpdateLedgerOpTest.java","status":"modified","additions":3,"deletions":3,"changes":6,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/bbd1eb8d8560b03834175fbd996b85237df09f5c/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FUpdateLedgerOpTest.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/bbd1eb8d8560b03834175fbd996b85237df09f5c/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FUpdateLedgerOpTest.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FUpdateLedgerOpTest.java?ref=bbd1eb8d8560b03834175fbd996b85237df09f5c","patch":"@@ -85,7 +85,7 @@ public void testManyLedgers() throws Exception {\n         BookieSocketAddress curBookieAddr = ensemble.get(0);\n         baseConf.setUseHostNameAsBookieID(true);\n         BookieSocketAddress curBookieId = Bookie.getBookieAddress(baseConf);\n-        BookieSocketAddress toBookieAddr = new BookieSocketAddress(curBookieId.getHostname() + \":\"\n+        BookieSocketAddress toBookieAddr = new BookieSocketAddress(curBookieId.getHostName() + \":\"\n                 + curBookieAddr.getPort());\n         UpdateLedgerOp updateLedgerOp = new UpdateLedgerOp(bk, bkadmin);\n         updateLedgerOp.updateBookieIdInLedgers(curBookieAddr, toBookieAddr, 5, Integer.MIN_VALUE, progressable);\n@@ -125,7 +125,7 @@ public void testLimitLessThanTotalLedgers() throws Exception {\n         BookieSocketAddress curBookieAddr = ensemble.get(0);\n         baseConf.setUseHostNameAsBookieID(true);\n         BookieSocketAddress toBookieId = Bookie.getBookieAddress(baseConf);\n-        BookieSocketAddress toBookieAddr = new BookieSocketAddress(toBookieId.getHostname() + \":\"\n+        BookieSocketAddress toBookieAddr = new BookieSocketAddress(toBookieId.getHostName() + \":\"\n                 + curBookieAddr.getPort());\n         UpdateLedgerOp updateLedgerOp = new UpdateLedgerOp(bk, bkadmin);\n         updateLedgerOp.updateBookieIdInLedgers(curBookieAddr, toBookieAddr, 7, 4, progressable);\n@@ -172,7 +172,7 @@ public void testChangeEnsembleAfterRenaming() throws Exception {\n         Assert.assertNotNull(\"Couldn't find the bookie in ledger metadata!\", curBookieAddr);\n         baseConf.setUseHostNameAsBookieID(true);\n         BookieSocketAddress toBookieId = Bookie.getBookieAddress(baseConf);\n-        BookieSocketAddress toBookieAddr = new BookieSocketAddress(toBookieId.getHostname() + \":\"\n+        BookieSocketAddress toBookieAddr = new BookieSocketAddress(toBookieId.getHostName() + \":\"\n                 + curBookieAddr.getPort());\n         UpdateLedgerOp updateLedgerOp = new UpdateLedgerOp(bk, bkadmin);\n         updateLedgerOp.updateBookieIdInLedgers(curBookieAddr, toBookieAddr, 5, 100, progressable);"},{"sha":"b02fdce5514d21a06ec4da2f3eb6289cc4c6b286","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/util/StaticDNSResolver.java","status":"modified","additions":10,"deletions":0,"changes":10,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/bbd1eb8d8560b03834175fbd996b85237df09f5c/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2FStaticDNSResolver.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/bbd1eb8d8560b03834175fbd996b85237df09f5c/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2FStaticDNSResolver.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2FStaticDNSResolver.java?ref=bbd1eb8d8560b03834175fbd996b85237df09f5c","patch":"@@ -25,6 +25,7 @@\n import org.apache.bookkeeper.net.AbstractDNSToSwitchMapping;\n import org.apache.bookkeeper.net.DNSToSwitchMapping;\n import org.apache.bookkeeper.net.NetworkTopology;\n+import org.apache.bookkeeper.net.NodeBase;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -52,6 +53,15 @@ public static String getRack(String name) {\n         return rack;\n     }\n \n+    public static String getRegion(String name) {\n+        String[] parts = getRack(name).split(NodeBase.PATH_SEPARATOR_STR);\n+        if (parts.length <= 1) {\n+            return NetworkTopology.DEFAULT_REGION;\n+        } else {\n+            return parts[1];\n+        }\n+    }\n+\n     public static void reset() {\n         name2Racks.clear();\n     }"}]}