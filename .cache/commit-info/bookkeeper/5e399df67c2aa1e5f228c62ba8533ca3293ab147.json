{"sha":"5e399df67c2aa1e5f228c62ba8533ca3293ab147","node_id":"MDY6Q29tbWl0NDc4NTkyNTI2OjVlMzk5ZGY2N2MyYWExZTVmMjI4YzYyYmE4NTMzY2EzMjkzYWIxNDc=","commit":{"author":{"name":"Sijie Guo","email":"sijieg@twitter.com","date":"2017-06-29T22:12:40Z"},"committer":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2017-06-29T22:12:40Z"},"message":"BOOKKEEPER-759: Delay Ensemble Change & Disable Ensemble Change\n\nDescriptions of the changes in this PR:\n\nThis pull request contains the changes around ensemble change.\n\n- Delay Ensemble Change: Provide a flag to allow delay ensemble change. if that is set to change, will not do ensemble change until it breaks ack quorum requirements.\n- Disable Ensemble Change: Provide a runtime feature flag to allow disabling ensemble change. The ensemble change behavior can be disabled on-the-fly via the FeatureProvider.\n\n---\nBe sure to do all of the following to help us incorporate your contribution\nquickly and easily:\n\n- [x] Make sure the PR title is formatted like:\n    `<Issue #>: Description of pull request`\n    `e.g. Issue 123: Description ...`\n- [x] Make sure tests pass via `mvn clean apache-rat:check install findbugs:check`.\n- [x] Replace `<Issue #>` in the title with the actual Issue number, if there is one.\n\n---\n\nAuthor: Sijie Guo <sijieg@twitter.com>\nAuthor: Sijie Guo <sijie@apache.org>\n\nReviewers: Enrico Olivelli <eolivelli@gmail.com>, Matteo Merli <mmerli@apache.org>\n\nThis closes #202 from sijie/client_changes/delay_ensemble_changes","tree":{"sha":"9a59988e18f787c00228f160da7a4983f8d2cd2c","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/trees/9a59988e18f787c00228f160da7a4983f8d2cd2c"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/commits/5e399df67c2aa1e5f228c62ba8533ca3293ab147","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/5e399df67c2aa1e5f228c62ba8533ca3293ab147","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/5e399df67c2aa1e5f228c62ba8533ca3293ab147","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/5e399df67c2aa1e5f228c62ba8533ca3293ab147/comments","author":null,"committer":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"parents":[{"sha":"95ebc45fa2d0c4028c31c66b790743f4a7909800","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/95ebc45fa2d0c4028c31c66b790743f4a7909800","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/95ebc45fa2d0c4028c31c66b790743f4a7909800"}],"stats":{"total":1431,"additions":1238,"deletions":193},"files":[{"sha":"e17d8b9284b41945fdf3e6da1ad2d9d5678f3c64","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BKException.java","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/5e399df67c2aa1e5f228c62ba8533ca3293ab147/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBKException.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/5e399df67c2aa1e5f228c62ba8533ca3293ab147/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBKException.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBKException.java?ref=5e399df67c2aa1e5f228c62ba8533ca3293ab147","patch":"@@ -114,6 +114,7 @@ public static BKException create(int code) {\n      *\n      */\n     public interface Code {\n+        int UNINITIALIZED = 1;\n         int OK = 0;\n         int ReadException = -1;\n         int QuorumException = -2;"},{"sha":"383fe3fc4f58f20f6deccd7939993695b7f037cb","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeper.java","status":"modified","additions":11,"deletions":1,"changes":12,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/5e399df67c2aa1e5f228c62ba8533ca3293ab147/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookKeeper.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/5e399df67c2aa1e5f228c62ba8533ca3293ab147/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookKeeper.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookKeeper.java?ref=5e399df67c2aa1e5f228c62ba8533ca3293ab147","patch":"@@ -46,6 +46,7 @@\n import org.apache.bookkeeper.client.AsyncCallback.IsClosedCallback;\n import org.apache.bookkeeper.client.BookieInfoReader.BookieInfo;\n import org.apache.bookkeeper.conf.ClientConfiguration;\n+import org.apache.bookkeeper.feature.Feature;\n import org.apache.bookkeeper.feature.FeatureProvider;\n import org.apache.bookkeeper.feature.SettableFeatureProvider;\n import org.apache.bookkeeper.meta.CleanupLedgerManager;\n@@ -119,7 +120,10 @@ public class BookKeeper implements AutoCloseable {\n     final HashedWheelTimer requestTimer;\n     final boolean ownTimer;\n     final FeatureProvider featureProvider;\n-    ScheduledExecutorService bookieInfoScheduler;\n+    final ScheduledExecutorService bookieInfoScheduler;\n+\n+    // Features\n+    final Feature disableEnsembleChangeFeature;\n \n     // Ledger manager responsible for how to store ledger meta data\n     final LedgerManagerFactory ledgerManagerFactory;\n@@ -132,6 +136,7 @@ public class BookKeeper implements AutoCloseable {\n \n     final ClientConfiguration conf;\n     final int explicitLacInterval;\n+    final boolean delayEnsembleChange;\n \n     final Optional<SpeculativeRequestExecutionPolicy> readSpeculativeRequestPolicy;\n \n@@ -295,6 +300,7 @@ private BookKeeper(ClientConfiguration conf,\n                        FeatureProvider featureProvider)\n             throws IOException, InterruptedException, KeeperException {\n         this.conf = conf;\n+        this.delayEnsembleChange = conf.getDelayEnsembleChange();\n \n         // initialize zookeeper client\n         if (zkc == null) {\n@@ -340,6 +346,9 @@ private BookKeeper(ClientConfiguration conf,\n         } else {\n             this.featureProvider = featureProvider;\n         }\n+        \n+        // get features\n+        this.disableEnsembleChangeFeature = this.featureProvider.getFeature(conf.getDisableEnsembleChangeFeatureName());\n \n         // initialize scheduler\n         ThreadFactoryBuilder tfb = new ThreadFactoryBuilder().setNameFormat(\n@@ -387,6 +396,7 @@ private BookKeeper(ClientConfiguration conf,\n             this.bookieInfoReader.start();\n         } else {\n             LOG.info(\"Weighted ledger placement is not enabled\");\n+            this.bookieInfoScheduler = null;\n             this.bookieInfoReader = new BookieInfoReader(this, conf, null);\n             this.bookieWatcher.readBookiesBlocking();\n         }"},{"sha":"c0d78e9ccc5b7f59a4b7836b7cfb6e96d9080eb7","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/DistributionSchedule.java","status":"modified","additions":36,"deletions":7,"changes":43,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/5e399df67c2aa1e5f228c62ba8533ca3293ab147/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FDistributionSchedule.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/5e399df67c2aa1e5f228c62ba8533ca3293ab147/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FDistributionSchedule.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FDistributionSchedule.java?ref=5e399df67c2aa1e5f228c62ba8533ca3293ab147","patch":"@@ -17,7 +17,11 @@\n  */\n package org.apache.bookkeeper.client;\n \n+import org.apache.bookkeeper.net.BookieSocketAddress;\n+\n import java.util.List;\n+import java.util.Map;\n+\n /**\n  * This interface determins how entries are distributed among bookies.\n  *\n@@ -45,13 +49,32 @@ public interface AckSet {\n          * Add a bookie response and check if quorum has been met\n          * @return true if quorum has been met, false otherwise\n          */\n-        public boolean addBookieAndCheck(int bookieIndexHeardFrom);\n+        public boolean completeBookieAndCheck(int bookieIndexHeardFrom);\n+\n+        /**\n+         * Received failure response from a bookie and check if ack quorum\n+         * will be broken.\n+         *\n+         * @param bookieIndexHeardFrom\n+         *          bookie index that failed.\n+         * @param address\n+         *          bookie address\n+         * @return true if ack quorum is broken, false otherwise.\n+         */\n+        public boolean failBookieAndCheck(int bookieIndexHeardFrom, BookieSocketAddress address);\n+\n+        /**\n+         * Return the list of bookies that already failed.\n+         *\n+         * @return the list of bookies that already failed.\n+         */\n+        public Map<Integer, BookieSocketAddress> getFailedBookies();\n \n         /**\n          * Invalidate a previous bookie response.\n          * Used for reissuing write requests.\n          */\n-        public void removeBookie(int bookie);\n+        public boolean removeBookieAndCheck(int bookie);\n     }\n \n     /**\n@@ -66,19 +89,25 @@ public interface AckSet {\n      */\n     public interface QuorumCoverageSet {\n         /**\n-         * Add a bookie to the set, and check if all quorum in the set\n-         * have had the action performed for it.\n+         * Add a bookie to the result set\n+         *\n          * @param bookieIndexHeardFrom Bookie we've just heard from\n+         */\n+        void addBookie(int bookieIndexHeardFrom, int rc);\n+\n+        /**\n+         * check if all quorum in the set have had the action performed for it.\n+         *\n          * @return whether all quorums have been covered\n          */\n-        public boolean addBookieAndCheckCovered(int bookieIndexHeardFrom);\n+        boolean checkCovered();\n     }\n \n     public QuorumCoverageSet getCoverageSet();\n-    \n+\n     /**\n      * Whether entry presents on given bookie index\n-     * \n+     *\n      * @param entryId\n      *            - entryId to check the presence on given bookie index\n      * @param bookieIndex"},{"sha":"9a96078412211824340ab3225c22aeba660cd9d6","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","status":"modified","additions":195,"deletions":97,"changes":292,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/5e399df67c2aa1e5f228c62ba8533ca3293ab147/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FLedgerHandle.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/5e399df67c2aa1e5f228c62ba8533ca3293ab147/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FLedgerHandle.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FLedgerHandle.java?ref=5e399df67c2aa1e5f228c62ba8533ca3293ab147","patch":"@@ -20,9 +20,8 @@\n  */\n package org.apache.bookkeeper.client;\n \n-import static com.google.common.base.Charsets.UTF_8;\n-\n import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Objects;\n import com.google.common.collect.Sets;\n import com.google.common.util.concurrent.RateLimiter;\n import io.netty.buffer.ByteBuf;\n@@ -89,6 +88,7 @@ public class LedgerHandle implements AutoCloseable {\n     final static public long INVALID_ENTRY_ID = BookieProtocol.INVALID_ENTRY_ID;\n \n     final AtomicInteger blockAddCompletions = new AtomicInteger(0);\n+    final AtomicInteger numEnsembleChanges = new AtomicInteger(0);\n     Queue<PendingAddOp> pendingAddOps;\n     ExplicitLacFlushPolicy explicitLacFlushPolicy;\n \n@@ -183,10 +183,14 @@ public long getId() {\n      *\n      * @return the last confirmed entry id or {@link #INVALID_ENTRY_ID INVALID_ENTRY_ID} if no entry has been confirmed\n      */\n-    public long getLastAddConfirmed() {\n+    public synchronized long getLastAddConfirmed() {\n         return lastAddConfirmed;\n     }\n \n+    synchronized void setLastAddConfirmed(long lac) {\n+        this.lastAddConfirmed = lac;\n+    }\n+\n     /**\n      * Get the entry id of the last entry that has been enqueued for addition (but\n      * may not have possibly been persited to the ledger)\n@@ -425,8 +429,8 @@ public void safeOperationComplete(final int rc, Void result) {\n                                 @Override\n                                 public void safeOperationComplete(int newrc, LedgerMetadata newMeta) {\n                                     if (newrc != BKException.Code.OK) {\n-                                        LOG.error(\"Error reading new metadata from ledger \" + ledgerId\n-                                                  + \" when closing, code=\" + newrc);\n+                                        LOG.error(\"Error reading new metadata from ledger {} when closing, code={}\",\n+                                                ledgerId, newrc);\n                                         cb.closeComplete(rc, LedgerHandle.this, ctx);\n                                     } else {\n                                         metadata.setState(prevState);\n@@ -442,13 +446,13 @@ public void safeOperationComplete(int newrc, LedgerMetadata newMeta) {\n                                             metadata.setEnsembles(newMeta.getEnsembles());\n                                             metadata.setVersion(newMeta.version);\n                                             metadata.setLength(length);\n-                                            metadata.close(lastAddConfirmed);\n+                                            metadata.close(getLastAddConfirmed());\n                                             writeLedgerConfig(new CloseCb());\n                                             return;\n                                         } else {\n                                             metadata.setLength(length);\n-                                            metadata.close(lastAddConfirmed);\n-                                            LOG.warn(\"Conditional update ledger metadata for ledger \" + ledgerId + \" failed.\");\n+                                            metadata.close(getLastAddConfirmed());\n+                                            LOG.warn(\"Conditional update ledger metadata for ledger {} failed.\", ledgerId);\n                                             cb.closeComplete(rc, LedgerHandle.this, ctx);\n                                         }\n                                     }\n@@ -460,7 +464,7 @@ public String toString() {\n                                 }\n                             });\n                         } else if (rc != BKException.Code.OK) {\n-                            LOG.error(\"Error update ledger metadata for ledger \" + ledgerId + \" : \" + rc);\n+                            LOG.error(\"Error update ledger metadata for ledger {} : {}\", ledgerId, rc);\n                             cb.closeComplete(rc, LedgerHandle.this, ctx);\n                         } else {\n                             cb.closeComplete(BKException.Code.OK, LedgerHandle.this, ctx);\n@@ -1184,87 +1188,116 @@ void sendAddSuccessCallbacks() {\n \n     }\n \n-    ArrayList<BookieSocketAddress> replaceBookieInMetadata(final BookieSocketAddress addr, final int bookieIndex)\n+    EnsembleInfo replaceBookieInMetadata(final Map<Integer, BookieSocketAddress> failedBookies,\n+                                         int ensembleChangeIdx)\n             throws BKException.BKNotEnoughBookiesException {\n-        BookieSocketAddress newBookie;\n-        LOG.info(\"Handling failure of bookie: {} index: {}\", addr, bookieIndex);\n         final ArrayList<BookieSocketAddress> newEnsemble = new ArrayList<BookieSocketAddress>();\n-        final long newEnsembleStartEntry = lastAddConfirmed + 1;\n-\n-        // avoid parallel ensemble changes to same ensemble.\n+        final long newEnsembleStartEntry = getLastAddConfirmed() + 1;\n+        final HashSet<Integer> replacedBookies = new HashSet<Integer>();\n         synchronized (metadata) {\n             newEnsemble.addAll(metadata.currentEnsemble);\n-            newBookie = bk.bookieWatcher.replaceBookie(metadata.getEnsembleSize(),\n-                    metadata.getWriteQuorumSize(),\n-                    metadata.getAckQuorumSize(),\n-                    metadata.getCustomMetadata(),\n-                    newEnsemble,\n-                    bookieIndex, new HashSet<>(Arrays.asList(addr)));\n-\n-\n-            newEnsemble.set(bookieIndex, newBookie);\n-\n+            for (Map.Entry<Integer, BookieSocketAddress> entry : failedBookies.entrySet()) {\n+                int idx = entry.getKey();\n+                BookieSocketAddress addr = entry.getValue();\n+                if (LOG.isDebugEnabled()) {\n+                    LOG.debug(\"[EnsembleChange-L{}-{}] : replacing bookie: {} index: {}\",\n+                        new Object[]{getId(), ensembleChangeIdx, addr, idx});\n+                }\n+                if (!newEnsemble.get(idx).equals(addr)) {\n+                    // ensemble has already changed, failure of this addr is immaterial\n+                    if (LOG.isDebugEnabled()) {\n+                        LOG.debug(\"Write did not succeed to {}, bookieIndex {}, but we have already fixed it.\",\n+                                  addr, idx);\n+                    }\n+                    continue;\n+                }\n+                try {\n+                    BookieSocketAddress newBookie = bk.bookieWatcher.replaceBookie(\n+                        metadata.getEnsembleSize(),\n+                        metadata.getWriteQuorumSize(),\n+                        metadata.getAckQuorumSize(),\n+                        metadata.getCustomMetadata(),\n+                        newEnsemble,\n+                        idx,\n+                        new HashSet<BookieSocketAddress>(failedBookies.values()));\n+                    newEnsemble.set(idx, newBookie);\n+                    replacedBookies.add(idx);\n+                } catch (BKException.BKNotEnoughBookiesException e) {\n+                    // if there is no bookie replaced, we throw not enough bookie exception\n+                    if (replacedBookies.size() <= 0) {\n+                        throw e;\n+                    } else {\n+                        break;\n+                    }\n+                }\n+            }\n             if (LOG.isDebugEnabled()) {\n-                LOG.debug(\"Changing ensemble from: \" + metadata.currentEnsemble\n-                        + \" to: \" + newEnsemble + \" for ledger: \" + ledgerId\n-                        + \" starting at entry: \" + (lastAddConfirmed + 1));\n+                LOG.debug(\"[EnsembleChange-L{}-{}] : changing ensemble from: {} to: {} starting at entry: {},\" +\n+                    \" failed bookies: {}, replaced bookies: {}\",\n+                      new Object[] { ledgerId, ensembleChangeIdx, metadata.currentEnsemble, newEnsemble,\n+                              (getLastAddConfirmed() + 1), failedBookies, replacedBookies });\n             }\n-\n             metadata.addEnsemble(newEnsembleStartEntry, newEnsemble);\n         }\n-        return newEnsemble;\n+        return new EnsembleInfo(newEnsemble, failedBookies, replacedBookies);\n     }\n \n-    void handleBookieFailure(final BookieSocketAddress addr, final int bookieIndex) {\n-        // If this is the first failure,\n-        // try to submit completed pendingAddOps before this failure.\n-        if (0 == blockAddCompletions.get()) {\n-            sendAddSuccessCallbacks();\n+    void handleBookieFailure(final Map<Integer, BookieSocketAddress> failedBookies) {\n+        int curBlockAddCompletions = blockAddCompletions.incrementAndGet();\n+\n+        if (bk.disableEnsembleChangeFeature.isAvailable()) {\n+            blockAddCompletions.decrementAndGet();\n+            if (LOG.isDebugEnabled()) {\n+                LOG.debug(\"Ensemble change is disabled. Retry sending to failed bookies {} for ledger {}.\",\n+                    failedBookies, ledgerId);\n+            }\n+            unsetSuccessAndSendWriteRequest(failedBookies.keySet());\n+            return;\n         }\n \n-        blockAddCompletions.incrementAndGet();\n+        int curNumEnsembleChanges = numEnsembleChanges.incrementAndGet();\n \n         synchronized (metadata) {\n-            if (!metadata.currentEnsemble.get(bookieIndex).equals(addr)) {\n-                // ensemble has already changed, failure of this addr is immaterial\n-                LOG.warn(\"Write did not succeed to {}, bookieIndex {}, but we have already fixed it.\",\n-                         addr, bookieIndex);\n-                blockAddCompletions.decrementAndGet();\n-\n-                // Try to submit completed pendingAddOps, pending by this fix.\n-                if (0 == blockAddCompletions.get()) {\n-                    sendAddSuccessCallbacks();\n-                }\n-\n-                return;\n-            }\n-\n             try {\n-                ArrayList<BookieSocketAddress> newEnsemble = replaceBookieInMetadata(addr, bookieIndex);\n-\n-                EnsembleInfo ensembleInfo = new EnsembleInfo(newEnsemble, bookieIndex,\n-                                                             addr);\n-                writeLedgerConfig(new ChangeEnsembleCb(ensembleInfo));\n+                EnsembleInfo ensembleInfo = replaceBookieInMetadata(failedBookies, curNumEnsembleChanges);\n+                if (ensembleInfo.replacedBookies.isEmpty()) {\n+                    blockAddCompletions.decrementAndGet();\n+                    return;\n+                }\n+                if (LOG.isDebugEnabled()) {\n+                    LOG.debug(\"[EnsembleChange-L{}-{}] : writing new ensemble info = {}, block add completions = {}\",\n+                        new Object[]{getId(), curNumEnsembleChanges, ensembleInfo, curBlockAddCompletions});\n+                }\n+                writeLedgerConfig(new ChangeEnsembleCb(ensembleInfo, curBlockAddCompletions, curNumEnsembleChanges));\n             } catch (BKException.BKNotEnoughBookiesException e) {\n-                LOG.error(\"Could not get additional bookie to \"\n-                          + \"remake ensemble, closing ledger: \" + ledgerId);\n+                LOG.error(\"Could not get additional bookie to remake ensemble, closing ledger: {}\", ledgerId);\n                 handleUnrecoverableErrorDuringAdd(e.getCode());\n                 return;\n             }\n         }\n     }\n \n     // Contains newly reformed ensemble, bookieIndex, failedBookieAddress\n-    private static final class EnsembleInfo {\n+    static final class EnsembleInfo {\n         private final ArrayList<BookieSocketAddress> newEnsemble;\n-        private final int bookieIndex;\n-        private final BookieSocketAddress addr;\n+        private final Map<Integer, BookieSocketAddress> failedBookies;\n+        final Set<Integer> replacedBookies;\n \n-        public EnsembleInfo(ArrayList<BookieSocketAddress> newEnsemble, int bookieIndex,\n-                            BookieSocketAddress addr) {\n+        public EnsembleInfo(ArrayList<BookieSocketAddress> newEnsemble,\n+                            Map<Integer, BookieSocketAddress> failedBookies,\n+                            Set<Integer> replacedBookies) {\n             this.newEnsemble = newEnsemble;\n-            this.bookieIndex = bookieIndex;\n-            this.addr = addr;\n+            this.failedBookies = failedBookies;\n+            this.replacedBookies = replacedBookies;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            StringBuilder sb = new StringBuilder();\n+            sb.append(\"Ensemble Info : failed bookies = \").append(failedBookies)\n+                    .append(\", replaced bookies = \").append(replacedBookies)\n+                    .append(\", new ensemble = \").append(newEnsemble);\n+            return sb.toString();\n         }\n     }\n \n@@ -1275,10 +1308,16 @@ public EnsembleInfo(ArrayList<BookieSocketAddress> newEnsemble, int bookieIndex,\n      */\n     private final class ChangeEnsembleCb extends OrderedSafeGenericCallback<Void> {\n         private final EnsembleInfo ensembleInfo;\n+        private final int curBlockAddCompletions;\n+        private final int ensembleChangeIdx;\n \n-        ChangeEnsembleCb(EnsembleInfo ensembleInfo) {\n+        ChangeEnsembleCb(EnsembleInfo ensembleInfo,\n+                         int curBlockAddCompletions,\n+                         int ensembleChangeIdx) {\n             super(bk.mainWorkerPool, ledgerId);\n             this.ensembleInfo = ensembleInfo;\n+            this.curBlockAddCompletions = curBlockAddCompletions;\n+            this.ensembleChangeIdx = ensembleChangeIdx;\n         }\n \n         @Override\n@@ -1287,30 +1326,39 @@ public void safeOperationComplete(final int rc, Void result) {\n                 // We changed the ensemble, but got a version exception. We\n                 // should still consider this as an ensemble change\n                 ensembleChangeCounter.inc();\n+\n+                if (LOG.isDebugEnabled()) {\n+                    LOG.info(\"[EnsembleChange-L{}-{}] : encountered version conflicts, re-read ledger metadata.\",\n+                        getId(), ensembleChangeIdx);\n+                }\n+\n                 rereadMetadata(new ReReadLedgerMetadataCb(rc,\n-                                       ensembleInfo));\n+                                       ensembleInfo, curBlockAddCompletions, ensembleChangeIdx));\n                 return;\n             } else if (rc != BKException.Code.OK) {\n-                LOG.error(\"Could not persist ledger metadata while \"\n-                          + \"changing ensemble to: \"\n-                          + ensembleInfo.newEnsemble\n-                          + \" , closing ledger\");\n+                LOG.error(\"[EnsembleChange-L{}-{}] : could not persist ledger metadata : info = {}, closing ledger : {}.\",\n+                        new Object[] { getId(), ensembleChangeIdx, ensembleInfo, rc });\n                 handleUnrecoverableErrorDuringAdd(rc);\n                 return;\n             }\n-            blockAddCompletions.decrementAndGet();\n+            int newBlockAddCompletions = blockAddCompletions.decrementAndGet();\n+\n+            if (LOG.isDebugEnabled()) {\n+                LOG.info(\"[EnsembleChange-L{}-{}] : completed ensemble change, block add completion {} => {}\",\n+                    new Object[]{getId(), ensembleChangeIdx, curBlockAddCompletions, newBlockAddCompletions});\n+            }\n \n             // We've successfully changed an ensemble\n             ensembleChangeCounter.inc();\n             // the failed bookie has been replaced\n-            unsetSuccessAndSendWriteRequest(ensembleInfo.bookieIndex);\n+            unsetSuccessAndSendWriteRequest(ensembleInfo.replacedBookies);\n         }\n \n         @Override\n         public String toString() {\n             return String.format(\"ChangeEnsemble(%d)\", ledgerId);\n         }\n-    };\n+    }\n \n     /**\n      * Callback which is reading the ledgerMetadata present in zk. This will try\n@@ -1319,29 +1367,32 @@ public String toString() {\n     private final class ReReadLedgerMetadataCb extends OrderedSafeGenericCallback<LedgerMetadata> {\n         private final int rc;\n         private final EnsembleInfo ensembleInfo;\n+        private final int curBlockAddCompletions;\n+        private final int ensembleChangeIdx;\n \n-        ReReadLedgerMetadataCb(int rc, EnsembleInfo ensembleInfo) {\n+        ReReadLedgerMetadataCb(int rc,\n+                               EnsembleInfo ensembleInfo,\n+                               int curBlockAddCompletions,\n+                               int ensembleChangeIdx) {\n             super(bk.mainWorkerPool, ledgerId);\n             this.rc = rc;\n             this.ensembleInfo = ensembleInfo;\n+            this.curBlockAddCompletions = curBlockAddCompletions;\n+            this.ensembleChangeIdx = ensembleChangeIdx;\n         }\n \n         @Override\n         public void safeOperationComplete(int newrc, LedgerMetadata newMeta) {\n             if (newrc != BKException.Code.OK) {\n-                LOG.error(\"Error reading new metadata from ledger \"\n-                        + \"after changing ensemble, code=\" + newrc);\n+                LOG.error(\"[EnsembleChange-L{}-{}] : error re-reading metadata to address ensemble change conflicts,\" +\n+                        \" code=\", new Object[] { ledgerId, ensembleChangeIdx, newrc });\n                 handleUnrecoverableErrorDuringAdd(rc);\n             } else {\n                 if (!resolveConflict(newMeta)) {\n-                    LOG.error(\"Could not resolve ledger metadata conflict \"\n-                            + \"while changing ensemble to: \"\n-                            + ensembleInfo.newEnsemble\n-                            + \", old meta data is \\n\"\n-                            + new String(metadata.serialize(), UTF_8)\n-                            + \"\\n, new meta data is \\n\"\n-                            + new String(newMeta.serialize(), UTF_8)\n-                            + \"\\n ,closing ledger\");\n+                    LOG.error(\"[EnsembleChange-L{}-{}] : could not resolve ledger metadata conflict\" +\n+                            \" while changing ensemble to: {}, local meta data is \\n {} \\n,\" +\n+                            \" zk meta data is \\n {} \\n, closing ledger\",\n+                            new Object[] { ledgerId, ensembleChangeIdx, ensembleInfo.newEnsemble, metadata, newMeta });\n                     handleUnrecoverableErrorDuringAdd(rc);\n                 }\n             }\n@@ -1362,8 +1413,17 @@ public void safeOperationComplete(int newrc, LedgerMetadata newMeta) {\n          * </p>\n          */\n         private boolean resolveConflict(LedgerMetadata newMeta) {\n+            if (LOG.isDebugEnabled()) {\n+                LOG.debug(\"[EnsembleChange-L{}-{}] : resolving conflicts - local metadata = \\n {} \\n,\" +\n+                    \" zk metadata = \\n {} \\n\", new Object[]{ledgerId, ensembleChangeIdx, metadata, newMeta});\n+            }\n             // make sure the ledger isn't closed by other ones.\n             if (metadata.getState() != newMeta.getState()) {\n+                if (LOG.isDebugEnabled()) {\n+                    LOG.info(\"[EnsembleChange-L{}-{}] : resolving conflicts but state changed,\" +\n+                            \" local metadata = \\n {} \\n, zk metadata = \\n {} \\n\",\n+                        new Object[]{ledgerId, ensembleChangeIdx, metadata, newMeta});\n+                }\n                 return false;\n             }\n \n@@ -1375,6 +1435,11 @@ private boolean resolveConflict(LedgerMetadata newMeta) {\n             //           than the metadata changed by recovery.\n             int diff = newMeta.getEnsembles().size() - metadata.getEnsembles().size();\n             if (0 != diff) {\n+                if (LOG.isDebugEnabled()) {\n+                    LOG.debug(\"[EnsembleChange-L{}-{}] : resolving conflicts but ensembles have {} differences,\" +\n+                            \" local metadata = \\n {} \\n, zk metadata = \\n {} \\n\",\n+                        new Object[]{ledgerId, ensembleChangeIdx, diff, metadata, newMeta});\n+                }\n                 if (-1 == diff) {\n                     // Case 1: metadata is changed by other ones (e.g. Recovery)\n                     return updateMetadataIfPossible(newMeta);\n@@ -1389,57 +1454,90 @@ private boolean resolveConflict(LedgerMetadata newMeta) {\n             // the ensemble change of the failed bookie is failed due to metadata conflicts. so try to\n             // update the ensemble change metadata again. Otherwise, it means that the ensemble change\n             // is already succeed, unset the success and re-adding entries.\n-            if (newMeta.currentEnsemble.get(ensembleInfo.bookieIndex).equals(\n-                    ensembleInfo.addr)) {\n+            if (!areFailedBookiesReplaced(newMeta, ensembleInfo)) {\n                 // If the in-memory data doesn't contains the failed bookie, it means the ensemble change\n                 // didn't finish, so try to resolve conflicts with the metadata read from zookeeper and\n                 // update ensemble changed metadata again.\n-                if (!metadata.currentEnsemble.get(ensembleInfo.bookieIndex)\n-                        .equals(ensembleInfo.addr)) {\n+                if (areFailedBookiesReplaced(metadata, ensembleInfo)) {\n                     return updateMetadataIfPossible(newMeta);\n                 }\n             } else {\n                 ensembleChangeCounter.inc();\n                 // We've successfully changed an ensemble\n                 // the failed bookie has been replaced\n-                blockAddCompletions.decrementAndGet();\n-                unsetSuccessAndSendWriteRequest(ensembleInfo.bookieIndex);\n+                int newBlockAddCompletions = blockAddCompletions.decrementAndGet();\n+                unsetSuccessAndSendWriteRequest(ensembleInfo.replacedBookies);\n+                if (LOG.isDebugEnabled()) {\n+                    LOG.info(\"[EnsembleChange-L{}-{}] : resolved conflicts, block add complectiosn {} => {}.\",\n+                        new Object[]{ledgerId, ensembleChangeIdx, curBlockAddCompletions, newBlockAddCompletions});\n+                }\n             }\n             return true;\n         }\n \n+        /**\n+         * Check whether all the failed bookies are replaced.\n+         *\n+         * @param newMeta\n+         *          new ledger metadata\n+         * @param ensembleInfo\n+         *          ensemble info used for ensemble change.\n+         * @return true if all failed bookies are replaced, false otherwise\n+         */\n+        private boolean areFailedBookiesReplaced(LedgerMetadata newMeta, EnsembleInfo ensembleInfo) {\n+            boolean replaced = true;\n+            for (Integer replacedBookieIdx : ensembleInfo.replacedBookies) {\n+                BookieSocketAddress failedBookieAddr = ensembleInfo.failedBookies.get(replacedBookieIdx);\n+                BookieSocketAddress replacedBookieAddr = newMeta.currentEnsemble.get(replacedBookieIdx);\n+                replaced &= !Objects.equal(replacedBookieAddr, failedBookieAddr);\n+            }\n+            return replaced;\n+        }\n+\n         private boolean updateMetadataIfPossible(LedgerMetadata newMeta) {\n             // if the local metadata is newer than zookeeper metadata, it means that metadata is updated\n             // again when it was trying re-reading the metatada, re-kick the reread again\n             if (metadata.isNewerThan(newMeta)) {\n+                if (LOG.isDebugEnabled()) {\n+                    LOG.debug(\"[EnsembleChange-L{}-{}] : reread metadata because local metadata is newer.\",\n+                        new Object[]{ledgerId, ensembleChangeIdx});\n+                }\n                 rereadMetadata(this);\n                 return true;\n             }\n             // make sure the metadata doesn't changed by other ones.\n             if (metadata.isConflictWith(newMeta)) {\n+                if (LOG.isDebugEnabled()) {\n+                    LOG.debug(\"[EnsembleChange-L{}-{}] : metadata is conflicted, local metadata = \\n {} \\n,\" +\n+                        \" zk metadata = \\n {} \\n\", new Object[]{ledgerId, ensembleChangeIdx, metadata, newMeta});\n+                }\n                 return false;\n             }\n-            LOG.info(\"Resolve ledger metadata conflict while changing ensemble to: {},\"\n-                    + \" old meta data is \\n {} \\n, new meta data is \\n {}.\", new Object[] {\n-                    ensembleInfo.newEnsemble, metadata, newMeta });\n+            if (LOG.isDebugEnabled()) {\n+                LOG.info(\"[EnsembleChange-L{}-{}] : resolved ledger metadata conflict and writing to zookeeper,\"\n+                        + \" local meta data is \\n {} \\n, zk meta data is \\n {}.\",\n+                    new Object[]{ledgerId, ensembleChangeIdx, metadata, newMeta});\n+            }\n             // update znode version\n             metadata.setVersion(newMeta.getVersion());\n             // merge ensemble infos from new meta except last ensemble\n             // since they might be modified by recovery tool.\n             metadata.mergeEnsembles(newMeta.getEnsembles());\n-            writeLedgerConfig(new ChangeEnsembleCb(ensembleInfo));\n+            writeLedgerConfig(new ChangeEnsembleCb(ensembleInfo, curBlockAddCompletions, ensembleChangeIdx));\n             return true;\n         }\n \n         @Override\n         public String toString() {\n             return String.format(\"ReReadLedgerMetadata(%d)\", ledgerId);\n         }\n-    };\n+    }\n \n-    void unsetSuccessAndSendWriteRequest(final int bookieIndex) {\n+    void unsetSuccessAndSendWriteRequest(final Set<Integer> bookies) {\n         for (PendingAddOp pendingAddOp : pendingAddOps) {\n-            pendingAddOp.unsetSuccessAndSendWriteRequest(bookieIndex);\n+            for (Integer bookieIndex: bookies) {\n+                pendingAddOp.unsetSuccessAndSendWriteRequest(bookieIndex);\n+            }\n         }\n     }\n "},{"sha":"130e1e2573493450b775aa54f3812e91ff330b01","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingAddOp.java","status":"modified","additions":60,"deletions":18,"changes":78,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/5e399df67c2aa1e5f228c62ba8533ca3293ab147/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FPendingAddOp.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/5e399df67c2aa1e5f228c62ba8533ca3293ab147/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FPendingAddOp.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FPendingAddOp.java?ref=5e399df67c2aa1e5f228c62ba8533ca3293ab147","patch":"@@ -23,9 +23,11 @@\n import io.netty.util.TimerTask;\n \n import java.util.HashSet;\n+import java.util.Map;\n import java.util.Set;\n import java.util.concurrent.TimeUnit;\n \n+import com.google.common.collect.ImmutableMap;\n import org.apache.bookkeeper.client.AsyncCallback.AddCallback;\n import org.apache.bookkeeper.net.BookieSocketAddress;\n import org.apache.bookkeeper.proto.BookieProtocol;\n@@ -36,7 +38,6 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import java.util.concurrent.RejectedExecutionException;\n-import java.util.concurrent.TimeUnit;\n \n /**\n  * This represents a pending add operation. When it has got success from all\n@@ -168,8 +169,10 @@ void unsetSuccessAndSendWriteRequest(int bookieIndex) {\n         // if we had already heard a success from this array index, need to\n         // increment our number of responses that are pending, since we are\n         // going to unset this success\n-        ackSet.removeBookie(bookieIndex);\n-        completed = false;\n+        if (!ackSet.removeBookieAndCheck(bookieIndex)) {\n+            // unset completed if this results in loss of ack quorum\n+            completed = false;\n+        }\n \n         sendWriteRequest(bookieIndex);\n     }\n@@ -198,7 +201,36 @@ void initiate(ByteBuf toSend, int entryLength) {\n     public void writeComplete(int rc, long ledgerId, long entryId, BookieSocketAddress addr, Object ctx) {\n         int bookieIndex = (Integer) ctx;\n \n+        if (!lh.metadata.currentEnsemble.get(bookieIndex).equals(addr)) {\n+            // ensemble has already changed, failure of this addr is immaterial\n+            if (LOG.isDebugEnabled()) {\n+                LOG.debug(\"Write did not succeed: \" + ledgerId + \", \" + entryId + \". But we have already fixed it.\");\n+            }\n+            return;\n+        }\n+\n+        // must record all acks, even if complete (completion can be undone by an ensemble change)\n+        boolean ackQuorum = false;\n+        if (BKException.Code.OK == rc) {\n+            ackQuorum = ackSet.completeBookieAndCheck(bookieIndex);\n+        }\n+\n         if (completed) {\n+            // even the add operation is completed, but because we don't reset completed flag back to false when\n+            // #unsetSuccessAndSendWriteRequest doesn't break ack quorum constraint. we still have current pending\n+            // add op is completed but never callback. so do a check here to complete again.\n+            //\n+            // E.g. entry x is going to complete.\n+            //\n+            // 1) entry x + k hits a failure. lh.handleBookieFailure increases blockAddCompletions to 1, for ensemble change\n+            // 2) entry x receives all responses, sets completed to true but fails to send success callback because\n+            //    blockAddCompletions is 1\n+            // 3) ensemble change completed. lh unset success starting from x to x+k, but since the unset doesn't break ackSet\n+            //    constraint. #removeBookieAndCheck doesn't set completed back to false.\n+            // 4) so when the retry request on new bookie completes, it finds the pending op is already completed.\n+            //    we have to trigger #sendAddSuccessCallbacks\n+            //\n+            sendAddSuccessCallbacks();\n             // I am already finished, ignore incoming responses.\n             // otherwise, we might hit the following error handling logic, which might cause bad things.\n             return;\n@@ -223,29 +255,39 @@ public void writeComplete(int rc, long ledgerId, long entryId, BookieSocketAddre\n             lh.handleUnrecoverableErrorDuringAdd(rc);\n             return;\n         default:\n-            LOG.warn(\"Write did not succeed: L{} E{} on {}, rc = {}\",\n-                     new Object[] { ledgerId, entryId, addr, rc });\n-            lh.handleBookieFailure(addr, bookieIndex);\n-            return;\n-        }\n-\n-        if (!writeSet.contains(bookieIndex)) {\n-            LOG.warn(\"Received a response for (lid:{}, eid:{}) from {}@{}, but it doesn't belong to {}.\",\n-                     new Object[] { ledgerId, entryId, addr, bookieIndex, writeSet });\n+            if (lh.bk.delayEnsembleChange) {\n+                if (ackSet.failBookieAndCheck(bookieIndex, addr) || rc == BKException.Code.WriteOnReadOnlyBookieException) {\n+                    Map<Integer, BookieSocketAddress> failedBookies = ackSet.getFailedBookies();\n+                    LOG.warn(\"Failed to write entry ({}, {}) to bookies {}, handling failures.\",\n+                             new Object[] { ledgerId, entryId, failedBookies });\n+                    // we can't meet ack quorum requirement, trigger ensemble change.\n+                    lh.handleBookieFailure(failedBookies);\n+                } else {\n+                    if (LOG.isDebugEnabled()) {\n+                        LOG.debug(\"Failed to write entry ({}, {}) to bookie ({}, {}),\" +\n+                                  \" but it didn't break ack quorum, delaying ensemble change : {}\",\n+                                  new Object[] { ledgerId, entryId, bookieIndex, addr, BKException.getMessage(rc) });\n+                    }\n+                }\n+            } else {\n+                LOG.warn(\"Failed to write entry ({}, {}): {}\",\n+                         new Object[] { ledgerId, entryId, BKException.getMessage(rc) });\n+                lh.handleBookieFailure(ImmutableMap.of(bookieIndex, addr));\n+            }\n             return;\n         }\n \n-        if (ackSet.addBookieAndCheck(bookieIndex) && !completed) {\n+        if (ackQuorum && !completed) {\n             completed = true;\n \n-            if (LOG.isDebugEnabled()) {\n-                LOG.debug(\"Complete (lid:{}, eid:{}).\", ledgerId, entryId);\n-            }\n-            // when completed an entry, try to send success add callbacks in order\n-            lh.sendAddSuccessCallbacks();\n+            sendAddSuccessCallbacks();\n         }\n     }\n \n+    void sendAddSuccessCallbacks() {\n+        lh.sendAddSuccessCallbacks();\n+    }\n+\n     void submitCallback(final int rc) {\n         if (null != timeout) {\n             timeout.cancel();"},{"sha":"94923e097e9fa217fda6d5c3179639ea15a8069d","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingReadLacOp.java","status":"modified","additions":5,"deletions":1,"changes":6,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/5e399df67c2aa1e5f228c62ba8533ca3293ab147/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FPendingReadLacOp.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/5e399df67c2aa1e5f228c62ba8533ca3293ab147/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FPendingReadLacOp.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FPendingReadLacOp.java?ref=5e399df67c2aa1e5f228c62ba8533ca3293ab147","patch":"@@ -75,6 +75,10 @@ public void initiate() {\n     public void readLacComplete(int rc, long ledgerId, final ByteBuf lacBuffer, final ByteBuf lastEntryBuffer,\n             Object ctx) {\n         int bookieIndex = (Integer) ctx;\n+\n+        // add the response to coverage set\n+        coverageSet.addBookie(bookieIndex, rc);\n+\n         numResponsesPending--;\n         boolean heardValidResponse = false;\n \n@@ -127,7 +131,7 @@ public void readLacComplete(int rc, long ledgerId, final ByteBuf lacBuffer, fina\n \n         // We don't consider a success until we have coverage set responses.\n         if (heardValidResponse\n-                && coverageSet.addBookieAndCheckCovered(bookieIndex)\n+                && coverageSet.checkCovered()\n                 && !completed) {\n             completed = true;\n             if (LOG.isDebugEnabled()) {"},{"sha":"ea9ee3b75c1da3b17eb7acffc0caee8eb25079e6","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingWriteLacOp.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/5e399df67c2aa1e5f228c62ba8533ca3293ab147/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FPendingWriteLacOp.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/5e399df67c2aa1e5f228c62ba8533ca3293ab147/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FPendingWriteLacOp.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FPendingWriteLacOp.java?ref=5e399df67c2aa1e5f228c62ba8533ca3293ab147","patch":"@@ -98,7 +98,7 @@ public void writeLacComplete(int rc, long ledgerId, BookieSocketAddress addr, Ob\n         receivedResponseSet.remove(bookieIndex);\n \n         if (rc == BKException.Code.OK) {\n-            if (ackSet.addBookieAndCheck(bookieIndex) && !completed) {\n+            if (ackSet.completeBookieAndCheck(bookieIndex) && !completed) {\n                 completed = true;\n                 cb.addLacComplete(rc, lh, ctx);\n                 return;"},{"sha":"75264c6aaafb98b52c6a8b37b4f1d6d3d2dcf9e0","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ReadLastConfirmedOp.java","status":"modified","additions":4,"deletions":1,"changes":5,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/5e399df67c2aa1e5f228c62ba8533ca3293ab147/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FReadLastConfirmedOp.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/5e399df67c2aa1e5f228c62ba8533ca3293ab147/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FReadLastConfirmedOp.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FReadLastConfirmedOp.java?ref=5e399df67c2aa1e5f228c62ba8533ca3293ab147","patch":"@@ -80,6 +80,9 @@ public synchronized void readEntryComplete(final int rc, final long ledgerId, fi\n             final ByteBuf buffer, final Object ctx) {\n         int bookieIndex = (Integer) ctx;\n \n+        // add the response to coverage set\n+        coverageSet.addBookie(bookieIndex, rc);\n+\n         numResponsesPending--;\n         boolean heardValidResponse = false;\n         if (rc == BKException.Code.OK) {\n@@ -116,7 +119,7 @@ public synchronized void readEntryComplete(final int rc, final long ledgerId, fi\n \n         // other return codes dont count as valid responses\n         if (heardValidResponse\n-            && coverageSet.addBookieAndCheckCovered(bookieIndex)\n+            && coverageSet.checkCovered()\n             && !completed) {\n             completed = true;\n             if (LOG.isDebugEnabled()) {"},{"sha":"297ea32a9e897bf85ad499cff6a9f21ad4175848","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ReadOnlyLedgerHandle.java","status":"modified","additions":7,"deletions":13,"changes":20,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/5e399df67c2aa1e5f228c62ba8533ca3293ab147/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FReadOnlyLedgerHandle.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/5e399df67c2aa1e5f228c62ba8533ca3293ab147/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FReadOnlyLedgerHandle.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FReadOnlyLedgerHandle.java?ref=5e399df67c2aa1e5f228c62ba8533ca3293ab147","patch":"@@ -21,6 +21,8 @@\n package org.apache.bookkeeper.client;\n \n import java.security.GeneralSecurityException;\n+import java.util.Map;\n+import java.util.concurrent.RejectedExecutionException;\n \n import org.apache.bookkeeper.client.AsyncCallback.AddCallback;\n import org.apache.bookkeeper.client.AsyncCallback.CloseCallback;\n@@ -30,8 +32,6 @@\n import org.apache.bookkeeper.util.SafeRunnable;\n import org.apache.bookkeeper.versioning.Version;\n \n-import java.util.concurrent.RejectedExecutionException;\n-\n /**\n  * Read only ledger handle. This ledger handle allows you to\n  * read from a ledger but not to write to it. It overrides all\n@@ -118,25 +118,19 @@ public void asyncAddEntry(final byte[] data, final int offset, final int length,\n     }\n \n     @Override\n-    void handleBookieFailure(final BookieSocketAddress addr, final int bookieIndex) {\n+    void handleBookieFailure(final Map<Integer, BookieSocketAddress> failedBookies) {\n         blockAddCompletions.incrementAndGet();\n         synchronized (metadata) {\n             try {\n-                if (!metadata.currentEnsemble.get(bookieIndex).equals(addr)) {\n-                    // ensemble has already changed, failure of this addr is immaterial\n-                    if (LOG.isDebugEnabled()) {\n-                        LOG.debug(\"Write did not succeed to {}, bookieIndex {},\"\n-                                +\" but we have already fixed it.\", addr, bookieIndex);\n-                    }\n+                EnsembleInfo ensembleInfo = replaceBookieInMetadata(failedBookies,\n+                        numEnsembleChanges.incrementAndGet());\n+                if (ensembleInfo.replacedBookies.isEmpty()) {\n                     blockAddCompletions.decrementAndGet();\n                     return;\n                 }\n-\n-                replaceBookieInMetadata(addr, bookieIndex);\n-\n                 blockAddCompletions.decrementAndGet();\n                 // the failed bookie has been replaced\n-                unsetSuccessAndSendWriteRequest(bookieIndex);\n+                unsetSuccessAndSendWriteRequest(ensembleInfo.replacedBookies);\n             } catch (BKException.BKNotEnoughBookiesException e) {\n                 LOG.error(\"Could not get additional bookie to \"\n                           + \"remake ensemble, closing ledger: \" + ledgerId);"},{"sha":"4eaf37ba73a3b2e3614417ae1a322beffc340376","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/RoundRobinDistributionSchedule.java","status":"modified","additions":44,"deletions":10,"changes":54,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/5e399df67c2aa1e5f228c62ba8533ca3293ab147/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FRoundRobinDistributionSchedule.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/5e399df67c2aa1e5f228c62ba8533ca3293ab147/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FRoundRobinDistributionSchedule.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FRoundRobinDistributionSchedule.java?ref=5e399df67c2aa1e5f228c62ba8533ca3293ab147","patch":"@@ -17,11 +17,14 @@\n  */\n package org.apache.bookkeeper.client;\n \n-import org.apache.bookkeeper.util.MathUtils;\n+import com.google.common.collect.ImmutableMap;\n+import org.apache.bookkeeper.net.BookieSocketAddress;\n \n+import java.util.HashMap;\n import java.util.List;\n import java.util.ArrayList;\n import java.util.HashSet;\n+import java.util.Map;\n \n /**\n  * A specific {@link DistributionSchedule} that places entries in round-robin\n@@ -54,40 +57,71 @@ public List<Integer> getWriteSet(long entryId) {\n     @Override\n     public AckSet getAckSet() {\n         final HashSet<Integer> ackSet = new HashSet<Integer>();\n+        final HashMap<Integer, BookieSocketAddress> failureMap =\n+                new HashMap<Integer, BookieSocketAddress>();\n         return new AckSet() {\n-            public boolean addBookieAndCheck(int bookieIndexHeardFrom) {\n+            public boolean completeBookieAndCheck(int bookieIndexHeardFrom) {\n+                failureMap.remove(bookieIndexHeardFrom);\n                 ackSet.add(bookieIndexHeardFrom);\n                 return ackSet.size() >= ackQuorumSize;\n             }\n \n-            public void removeBookie(int bookie) {\n+            @Override\n+            public boolean failBookieAndCheck(int bookieIndexHeardFrom, BookieSocketAddress address) {\n+                ackSet.remove(bookieIndexHeardFrom);\n+                failureMap.put(bookieIndexHeardFrom, address);\n+                return failureMap.size() > (writeQuorumSize - ackQuorumSize);\n+            }\n+\n+            @Override\n+            public Map<Integer, BookieSocketAddress> getFailedBookies() {\n+                return ImmutableMap.copyOf(failureMap);\n+            }\n+\n+            public boolean removeBookieAndCheck(int bookie) {\n                 ackSet.remove(bookie);\n+                failureMap.remove(bookie);\n+                return ackSet.size() >= ackQuorumSize;\n             }\n         };\n     }\n \n     private class RRQuorumCoverageSet implements QuorumCoverageSet {\n-        private final boolean[] covered = new boolean[ensembleSize];\n+        private final int[] covered = new int[ensembleSize];\n \n         private RRQuorumCoverageSet() {\n             for (int i = 0; i < covered.length; i++) {\n-                covered[i] = false;\n+                covered[i] = BKException.Code.UNINITIALIZED;\n             }\n         }\n \n-        public synchronized boolean addBookieAndCheckCovered(int bookieIndexHeardFrom) {\n-            covered[bookieIndexHeardFrom] = true;\n+        @Override\n+        public synchronized void addBookie(int bookieIndexHeardFrom, int rc) {\n+            covered[bookieIndexHeardFrom] = rc;\n+        }\n \n+        @Override\n+        public synchronized boolean checkCovered() {\n             // now check if there are any write quorums, with |ackQuorum| nodes available\n             for (int i = 0; i < ensembleSize; i++) {\n                 int nodesNotCovered = 0;\n+                int nodesOkay = 0;\n+                int nodesUninitialized = 0;\n                 for (int j = 0; j < writeQuorumSize; j++) {\n                     int nodeIndex = (i + j) % ensembleSize;\n-                    if (!covered[nodeIndex]) {\n+                    if (covered[nodeIndex] == BKException.Code.OK) {\n+                        nodesOkay++;\n+                    } else if (covered[nodeIndex] != BKException.Code.NoSuchEntryException &&\n+                            covered[nodeIndex] != BKException.Code.NoSuchLedgerExistsException) {\n                         nodesNotCovered++;\n+                    } else if (covered[nodeIndex] == BKException.Code.UNINITIALIZED) {\n+                        nodesUninitialized++;\n                     }\n                 }\n-                if (nodesNotCovered >= ackQuorumSize) {\n+                // if we haven't seen any OK responses and there are still nodes not heard from,\n+                // let's wait until\n+                if (nodesNotCovered >= ackQuorumSize ||\n+                        (nodesOkay == 0 && nodesUninitialized > 0)) {\n                     return false;\n                 }\n             }\n@@ -99,7 +133,7 @@ public synchronized boolean addBookieAndCheckCovered(int bookieIndexHeardFrom) {\n     public QuorumCoverageSet getCoverageSet() {\n         return new RRQuorumCoverageSet();\n     }\n-    \n+\n     @Override\n     public boolean hasEntry(long entryId, int bookieIndex) {\n         return getWriteSet(entryId).contains(bookieIndex);"},{"sha":"038437a9a6b81a488804d505a724207e2254c5e3","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ClientConfiguration.java","status":"modified","additions":52,"deletions":0,"changes":52,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/5e399df67c2aa1e5f228c62ba8533ca3293ab147/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fconf%2FClientConfiguration.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/5e399df67c2aa1e5f228c62ba8533ca3293ab147/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fconf%2FClientConfiguration.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fconf%2FClientConfiguration.java?ref=5e399df67c2aa1e5f228c62ba8533ca3293ab147","patch":"@@ -18,6 +18,7 @@\n package org.apache.bookkeeper.conf;\n \n import static com.google.common.base.Charsets.UTF_8;\n+import static org.apache.bookkeeper.util.BookKeeperConstants.FEATURE_DISABLE_ENSEMBLE_CHANGE;\n \n import java.util.List;\n import java.util.concurrent.TimeUnit;\n@@ -67,6 +68,8 @@ public class ClientConfiguration extends AbstractConfiguration {\n     protected final static String SPECULATIVE_READ_TIMEOUT_BACKOFF_MULTIPLIER = \"speculativeReadTimeoutBackoffMultiplier\";\n     protected final static String ENABLE_PARALLEL_RECOVERY_READ = \"enableParallelRecoveryRead\";\n     protected final static String RECOVERY_READ_BATCH_SIZE = \"recoveryReadBatchSize\";\n+    // Add Parameters\n+    protected final static String DELAY_ENSEMBLE_CHANGE = \"delayEnsembleChange\";\n     // Timeout Setting\n     protected final static String ADD_ENTRY_TIMEOUT_SEC = \"addEntryTimeoutSec\";\n     protected final static String ADD_ENTRY_QUORUM_TIMEOUT_SEC = \"addEntryQuorumTimeoutSec\";\n@@ -100,6 +103,9 @@ public class ClientConfiguration extends AbstractConfiguration {\n     // Stats\n     protected final static String ENABLE_TASK_EXECUTION_STATS = \"enableTaskExecutionStats\";\n     protected final static String TASK_EXECUTION_WARN_TIME_MICROS = \"taskExecutionWarnTimeMicros\";\n+    \n+    // Names of dynamic features\n+    protected final static String DISABLE_ENSEMBLE_CHANGE_FEATURE_NAME = \"disableEnsembleChangeFeatureName\";\n \n     // Role of the client\n     protected final static String CLIENT_ROLE = \"clientRole\";\n@@ -1207,4 +1213,50 @@ public String getClientRole() {\n         return getString(CLIENT_ROLE, CLIENT_ROLE_STANDARD);\n     }\n \n+    /**\n+     * Whether to delay ensemble change or not?\n+     *\n+     * @return true if to delay ensemble change, otherwise false.\n+     */\n+    public boolean getDelayEnsembleChange() {\n+        return getBoolean(DELAY_ENSEMBLE_CHANGE, false);\n+    }\n+\n+    /**\n+     * Enable/Disable delaying ensemble change.\n+     * <p>\n+     * If set to true, ensemble change only happens when it can't meet\n+     * ack quorum requirement. If set to false, ensemble change happens\n+     * immediately when it received a failed write.\n+     * </p>\n+     *\n+     * @param enabled\n+     *          flag to enable/disable delaying ensemble change.\n+     * @return client configuration.\n+     */\n+    public ClientConfiguration setDelayEnsembleChange(boolean enabled) {\n+        setProperty(DELAY_ENSEMBLE_CHANGE, enabled);\n+        return this;\n+    }\n+\n+    /**\n+     * Get the name of the dynamic feature that disables ensemble change\n+     *\n+     * @return name of the dynamic feature that disables ensemble change\n+     */\n+    public String getDisableEnsembleChangeFeatureName() {\n+        return getString(DISABLE_ENSEMBLE_CHANGE_FEATURE_NAME, FEATURE_DISABLE_ENSEMBLE_CHANGE);\n+    }\n+\n+    /**\n+     * Set the name of the dynamic feature that disables ensemble change\n+     *\n+     * @param disableEnsembleChangeFeatureName\n+     *          name of the dynamic feature that disables ensemble change\n+     * @return client configuration.\n+     */\n+    public ClientConfiguration setDisableEnsembleChangeFeatureName(String disableEnsembleChangeFeatureName) {\n+        setProperty(DISABLE_ENSEMBLE_CHANGE_FEATURE_NAME, disableEnsembleChangeFeatureName);\n+        return this;\n+    }\n }"},{"sha":"b25a3b869c822a04aada97d7adac3855624168d0","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieClient.java","status":"modified","additions":55,"deletions":30,"changes":85,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/5e399df67c2aa1e5f228c62ba8533ca3293ab147/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookieClient.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/5e399df67c2aa1e5f228c62ba8533ca3293ab147/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookieClient.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookieClient.java?ref=5e399df67c2aa1e5f228c62ba8533ca3293ab147","patch":"@@ -25,7 +25,6 @@\n import java.io.IOException;\n import java.util.List;\n import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.Executors;\n import java.util.concurrent.RejectedExecutionException;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicLong;\n@@ -52,7 +51,6 @@\n import org.slf4j.LoggerFactory;\n \n import com.google.common.collect.Lists;\n-import com.google.common.util.concurrent.ThreadFactoryBuilder;\n import com.google.protobuf.ExtensionRegistry;\n \n import io.netty.buffer.ByteBuf;\n@@ -210,14 +208,42 @@ public void safeRun() {\n         }\n     }\n \n-    public void addEntry(final BookieSocketAddress addr, final long ledgerId, final byte[] masterKey,\n-            final long entryId, final ByteBuf toSend, final WriteCallback cb, final Object ctx, final int options) {\n+    private void completeAdd(final int rc,\n+                             final long ledgerId,\n+                             final long entryId,\n+                             final BookieSocketAddress addr,\n+                             final WriteCallback cb,\n+                             final Object ctx) {\n+        try {\n+            executor.submitOrdered(ledgerId, new SafeRunnable() {\n+                @Override\n+                public void safeRun() {\n+                    cb.writeComplete(rc, ledgerId, entryId, addr, ctx);\n+                }\n+                @Override\n+                public String toString() {\n+                    return String.format(\"CompleteWrite(ledgerId=%d, entryId=%d, addr=%s)\", ledgerId, entryId, addr);\n+                }\n+            });\n+        } catch (RejectedExecutionException ree) {\n+            cb.writeComplete(getRc(BKException.Code.InterruptedException), ledgerId, entryId, addr, ctx);\n+        }\n+    }\n+\n+    public void addEntry(final BookieSocketAddress addr,\n+                         final long ledgerId,\n+                         final byte[] masterKey,\n+                         final long entryId,\n+                         final ByteBuf toSend,\n+                         final WriteCallback cb,\n+                         final Object ctx,\n+                         final int options) {\n         closeLock.readLock().lock();\n         try {\n             final PerChannelBookieClientPool client = lookupClient(addr, entryId);\n             if (client == null) {\n-                cb.writeComplete(getRc(BKException.Code.BookieHandleNotAvailableException),\n-                                 ledgerId, entryId, addr, ctx);\n+                completeAdd(getRc(BKException.Code.BookieHandleNotAvailableException),\n+                            ledgerId, entryId, addr, cb, ctx);\n                 return;\n             }\n \n@@ -229,17 +255,7 @@ public void addEntry(final BookieSocketAddress addr, final long ledgerId, final\n                 @Override\n                 public void operationComplete(final int rc, PerChannelBookieClient pcbc) {\n                     if (rc != BKException.Code.OK) {\n-                        try {\n-                            executor.submitOrdered(ledgerId, new SafeRunnable() {\n-                                @Override\n-                                public void safeRun() {\n-                                    cb.writeComplete(rc, ledgerId, entryId, addr, ctx);\n-                                }\n-                            });\n-                        } catch (RejectedExecutionException re) {\n-                            cb.writeComplete(getRc(BKException.Code.InterruptedException),\n-                                    ledgerId, entryId, addr, ctx);\n-                        }\n+                        completeAdd(rc, ledgerId, entryId, addr, cb, ctx);\n                     } else {\n                         pcbc.addEntry(ledgerId, masterKey, entryId, toSend, cb, ctx, options);\n                     }\n@@ -250,6 +266,25 @@ public void safeRun() {\n             closeLock.readLock().unlock();\n         }\n     }\n+    \n+    private void completeRead(final int rc,\n+                              final long ledgerId,\n+                              final long entryId,\n+                              final ByteBuf entry,\n+                              final ReadEntryCallback cb,\n+                              final Object ctx) {\n+        try {\n+            executor.submitOrdered(ledgerId, new SafeRunnable() {\n+                @Override\n+                public void safeRun() {\n+                    cb.readEntryComplete(rc, ledgerId, entryId, entry, ctx);\n+                }\n+            });\n+        } catch (RejectedExecutionException ree) {\n+            cb.readEntryComplete(getRc(BKException.Code.InterruptedException),\n+                                 ledgerId, entryId, entry, ctx);\n+        }\n+    }\n \n     public void readEntryAndFenceLedger(final BookieSocketAddress addr,\n                                         final long ledgerId,\n@@ -261,26 +296,16 @@ public void readEntryAndFenceLedger(final BookieSocketAddress addr,\n         try {\n             final PerChannelBookieClientPool client = lookupClient(addr, entryId);\n             if (client == null) {\n-                cb.readEntryComplete(getRc(BKException.Code.BookieHandleNotAvailableException),\n-                                     ledgerId, entryId, null, ctx);\n+                completeRead(getRc(BKException.Code.BookieHandleNotAvailableException),\n+                             ledgerId, entryId, null, cb, ctx);\n                 return;\n             }\n \n             client.obtain(new GenericCallback<PerChannelBookieClient>() {\n                 @Override\n                 public void operationComplete(final int rc, PerChannelBookieClient pcbc) {\n                     if (rc != BKException.Code.OK) {\n-                        try {\n-                            executor.submitOrdered(ledgerId, new SafeRunnable() {\n-                                @Override\n-                                public void safeRun() {\n-                                    cb.readEntryComplete(rc, ledgerId, entryId, null, ctx);\n-                                }\n-                            });\n-                        } catch (RejectedExecutionException re) {\n-                            cb.readEntryComplete(getRc(BKException.Code.InterruptedException),\n-                                    ledgerId, entryId, null, ctx);\n-                        }\n+                        completeRead(rc, ledgerId, entryId, null, cb, ctx);\n                         return;\n                     }\n                     pcbc.readEntryAndFenceLedger(ledgerId, masterKey, entryId, cb, ctx);"},{"sha":"3905083d46cbabd1484141bc0c6b54e20c7da3cc","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java","status":"modified","additions":3,"deletions":0,"changes":3,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/5e399df67c2aa1e5f228c62ba8533ca3293ab147/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FPerChannelBookieClient.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/5e399df67c2aa1e5f228c62ba8533ca3293ab147/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FPerChannelBookieClient.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FPerChannelBookieClient.java?ref=5e399df67c2aa1e5f228c62ba8533ca3293ab147","patch":"@@ -1775,6 +1775,9 @@ private Integer statusCodeToExceptionCode(StatusCode status) {\n             case EFENCED:\n                 rcToRet = BKException.Code.LedgerFencedException;\n                 break;\n+            case EREADONLY:\n+                rcToRet = BKException.Code.WriteOnReadOnlyBookieException;\n+                break;\n             default:\n                 break;\n         }"},{"sha":"bae7715cfe24994f320cf2c0ed01976c2f0bde0e","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/util/BookKeeperConstants.java","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/5e399df67c2aa1e5f228c62ba8533ca3293ab147/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2FBookKeeperConstants.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/5e399df67c2aa1e5f228c62ba8533ca3293ab147/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2FBookKeeperConstants.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2FBookKeeperConstants.java?ref=5e399df67c2aa1e5f228c62ba8533ca3293ab147","patch":"@@ -52,4 +52,5 @@ public class BookKeeperConstants {\n     public static final long MAX_LOG_SIZE_LIMIT = 1 * 1024 * 1024 * 1024;\r\n \r\n     public static final String FEATURE_REPP_DISABLE_DURABILITY_ENFORCEMENT = \"repp_disable_durability_enforcement\";\r\n+    public static final String FEATURE_DISABLE_ENSEMBLE_CHANGE = \"disable_ensemble_change\";\r\n }\r"},{"sha":"3b307e1222af2fc6b58fa016551162b9cb37a98b","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookieRecoveryTest.java","status":"modified","additions":24,"deletions":5,"changes":29,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/5e399df67c2aa1e5f228c62ba8533ca3293ab147/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookieRecoveryTest.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/5e399df67c2aa1e5f228c62ba8533ca3293ab147/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookieRecoveryTest.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookieRecoveryTest.java?ref=5e399df67c2aa1e5f228c62ba8533ca3293ab147","patch":"@@ -29,7 +29,7 @@\n import org.apache.bookkeeper.net.BookieSocketAddress;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ReadEntryCallback;\n-import org.apache.bookkeeper.test.MultiLedgerManagerMultiDigestTestCase;\n+import org.apache.bookkeeper.test.BookKeeperClusterTestCase;\n import org.junit.After;\n import org.junit.Before;\n import org.junit.Test;\n@@ -57,7 +57,8 @@\n /**\n  * This class tests the bookie recovery admin functionality.\n  */\n-public class BookieRecoveryTest extends MultiLedgerManagerMultiDigestTestCase {\n+public class BookieRecoveryTest extends BookKeeperClusterTestCase {\n+\n     private final static Logger LOG = LoggerFactory.getLogger(BookieRecoveryTest.class);\n \n     // Object used for synchronizing async method calls\n@@ -93,10 +94,11 @@ public void recoverComplete(int rc, Object ctx) {\n     BookKeeperAdmin bkAdmin;\n \n     // Constructor\n-    public BookieRecoveryTest(String ledgerManagerFactory, DigestType digestType) {\n+    public BookieRecoveryTest() {\n         super(3);\n-        this.digestType = digestType;\n-        this.ledgerManagerFactory = ledgerManagerFactory;\n+\n+        this.digestType = DigestType.CRC32;\n+        this.ledgerManagerFactory = \"org.apache.bookkeeper.meta.HierarchicalLedgerManagerFactory\";\n         LOG.info(\"Using ledger manager \" + ledgerManagerFactory);\n         // set ledger manager\n         baseConf.setLedgerManagerFactoryClassName(ledgerManagerFactory);\n@@ -241,6 +243,23 @@ private void verifyRecoveredLedgers(List<LedgerHandle> oldLhs, long startEntryId\n      */\n     @Test(timeout = 60000)\n     public void testMetadataConflictWithRecovery() throws Exception {\n+        metadataConflictWithRecovery(bkc);\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testMetadataConflictWhenDelayingEnsembleChange() throws Exception {\n+        ClientConfiguration newConf = new ClientConfiguration(baseClientConf);\n+        newConf.setZkServers(zkUtil.getZooKeeperConnectString());\n+        newConf.setDelayEnsembleChange(true);\n+        BookKeeper newBkc = new BookKeeper(newConf);\n+        try {\n+            metadataConflictWithRecovery(newBkc);\n+        } finally {\n+            newBkc.close();\n+        }\n+    }\n+\n+    void metadataConflictWithRecovery(BookKeeper bkc) throws Exception {\n         int numEntries = 10;\n         byte[] data = \"testMetadataConflictWithRecovery\".getBytes();\n "},{"sha":"327b642f631e27897ac0ea46767897f3937c7a0f","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/RoundRobinDistributionScheduleTest.java","status":"modified","additions":6,"deletions":6,"changes":12,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/5e399df67c2aa1e5f228c62ba8533ca3293ab147/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FRoundRobinDistributionScheduleTest.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/5e399df67c2aa1e5f228c62ba8533ca3293ab147/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FRoundRobinDistributionScheduleTest.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FRoundRobinDistributionScheduleTest.java?ref=5e399df67c2aa1e5f228c62ba8533ca3293ab147","patch":"@@ -43,10 +43,10 @@ public void testDistributionSchedule() throws Exception {\n         assertEquals(\"Write set is wrong size\", wSet.size(), 3);\n \n         DistributionSchedule.AckSet ackSet = schedule.getAckSet();\n-        assertFalse(\"Shouldn't ack yet\", ackSet.addBookieAndCheck(wSet.get(0)));\n-        assertFalse(\"Shouldn't ack yet\", ackSet.addBookieAndCheck(wSet.get(0)));\n-        assertTrue(\"Should ack after 2 unique\", ackSet.addBookieAndCheck(wSet.get(2)));\n-        assertTrue(\"Should still be acking\", ackSet.addBookieAndCheck(wSet.get(1)));\n+        assertFalse(\"Shouldn't ack yet\", ackSet.completeBookieAndCheck(wSet.get(0)));\n+        assertFalse(\"Shouldn't ack yet\", ackSet.completeBookieAndCheck(wSet.get(0)));\n+        assertTrue(\"Should ack after 2 unique\", ackSet.completeBookieAndCheck(wSet.get(2)));\n+        assertTrue(\"Should still be acking\", ackSet.completeBookieAndCheck(wSet.get(1)));\n     }\n \n     /**\n@@ -113,10 +113,10 @@ private int testCoverageForConfiguration(int ensemble, int writeQuorum, int ackQ\n         int errors = 0;\n         for (Set<Integer> subset : subsets) {\n             DistributionSchedule.QuorumCoverageSet covSet = schedule.getCoverageSet();\n-            boolean covSetSays = false;\n             for (Integer i : subset) {\n-                covSetSays = covSet.addBookieAndCheckCovered(i);\n+                covSet.addBookie(i, BKException.Code.OK);\n             }\n+            boolean covSetSays = covSet.checkCovered();\n \n             boolean[] nodesAvailable = buildAvailable(ensemble, subset);\n             boolean canGetAck = canGetAckQuorum(ensemble, writeQuorum, ackQuorum, nodesAvailable);"},{"sha":"8c8e60b2b94d12bd4860ab8cccbf153f8efece8e","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestDelayEnsembleChange.java","status":"added","additions":417,"deletions":0,"changes":417,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/5e399df67c2aa1e5f228c62ba8533ca3293ab147/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FTestDelayEnsembleChange.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/5e399df67c2aa1e5f228c62ba8533ca3293ab147/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FTestDelayEnsembleChange.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FTestDelayEnsembleChange.java?ref=5e399df67c2aa1e5f228c62ba8533ca3293ab147","patch":"@@ -0,0 +1,417 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.client;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+\n+import io.netty.buffer.ByteBuf;\n+import org.apache.bookkeeper.client.BookKeeper.DigestType;\n+import org.apache.bookkeeper.conf.ServerConfiguration;\n+import org.apache.bookkeeper.net.BookieSocketAddress;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ReadEntryCallback;\n+import org.apache.bookkeeper.test.BookKeeperClusterTestCase;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+public class TestDelayEnsembleChange extends BookKeeperClusterTestCase {\n+\n+    final static Logger logger = LoggerFactory.getLogger(TestDelayEnsembleChange.class);\n+\n+    final DigestType digestType;\n+    final byte[] testPasswd = \"\".getBytes();\n+\n+    public TestDelayEnsembleChange() {\n+        super(5);\n+        this.digestType = DigestType.CRC32;\n+    }\n+\n+    @Before\n+    @Override\n+    public void setUp() throws Exception {\n+        baseClientConf.setDelayEnsembleChange(true);\n+        super.setUp();\n+    }\n+\n+    private static class VerificationCallback implements ReadEntryCallback {\n+        final CountDownLatch latch;\n+        final AtomicLong numSuccess;\n+        final AtomicLong numMissing;\n+        final AtomicLong numFailure;\n+\n+        VerificationCallback(int numRequests) {\n+            latch = new CountDownLatch(numRequests);\n+            numSuccess = new AtomicLong(0L);\n+            numMissing = new AtomicLong(0L);\n+            numFailure = new AtomicLong(0L);\n+        }\n+\n+        @Override\n+        public void readEntryComplete(int rc, long ledgerId, long entryId, ByteBuf buffer, Object ctx) {\n+            if (rc == BKException.Code.OK) {\n+                numSuccess.incrementAndGet();\n+            } else if (rc == BKException.Code.NoSuchEntryException || rc == BKException.Code.NoSuchLedgerExistsException) {\n+                logger.error(\"Missed entry({}, {}) from host {}.\", new Object[] { ledgerId, entryId, ctx });\n+                numMissing.incrementAndGet();\n+            } else {\n+                logger.error(\"Failed to get entry({}, {}) from host {} : {}\",\n+                             new Object[] { ledgerId, entryId, ctx, rc });\n+                numFailure.incrementAndGet();\n+            }\n+            latch.countDown();\n+        }\n+    }\n+\n+    private void verifyEntries(LedgerHandle lh, long startEntry, long untilEntry,\n+                               long expectedSuccess, long expectedMissing) throws Exception {\n+        LedgerMetadata md = lh.getLedgerMetadata();\n+\n+        for (long eid = startEntry; eid < untilEntry; eid++) {\n+            ArrayList<BookieSocketAddress> addresses = md.getEnsemble(eid);\n+            VerificationCallback callback = new VerificationCallback(addresses.size());\n+            for (BookieSocketAddress addr : addresses) {\n+                bkc.bookieClient.readEntry(addr, lh.getId(), eid, callback, addr);\n+            }\n+            callback.latch.await();\n+            assertEquals(expectedSuccess, callback.numSuccess.get());\n+            assertEquals(expectedMissing, callback.numMissing.get());\n+            assertEquals(0, callback.numFailure.get());\n+        }\n+    }\n+\n+    private void verifyEntriesRange(LedgerHandle lh, long startEntry, long untilEntry,\n+                                    long expectedSuccess, long expectedMissing) throws Exception {\n+        LedgerMetadata md = lh.getLedgerMetadata();\n+\n+        for (long eid = startEntry; eid < untilEntry; eid++) {\n+            ArrayList<BookieSocketAddress> addresses = md.getEnsemble(eid);\n+            VerificationCallback callback = new VerificationCallback(addresses.size());\n+            for (BookieSocketAddress addr : addresses) {\n+                bkc.bookieClient.readEntry(addr, lh.getId(), eid, callback, addr);\n+            }\n+            callback.latch.await();\n+            assertTrue(expectedSuccess >= callback.numSuccess.get());\n+            assertTrue(expectedMissing <= callback.numMissing.get());\n+            assertEquals(0, callback.numFailure.get());\n+        }\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testNotChangeEnsembleIfNotBrokenAckQuorum() throws Exception {\n+        LedgerHandle lh = bkc.createLedger(5, 5, 3, digestType, testPasswd);\n+\n+        byte[] data = \"foobar\".getBytes();\n+\n+        int numEntries = 10;\n+        for (int i = 0; i < numEntries; i++) {\n+            lh.addEntry(data);\n+        }\n+\n+        // kill two bookies, but we still have 3 bookies for the ack quorum.\n+        ServerConfiguration conf0 = killBookie(lh.getLedgerMetadata().currentEnsemble.get(0));\n+        ServerConfiguration conf1 = killBookie(lh.getLedgerMetadata().currentEnsemble.get(1));\n+\n+        for (int i = numEntries; i < 2 * numEntries; i++) {\n+            lh.addEntry(data);\n+        }\n+\n+        // ensure there is no ensemble changed\n+        assertEquals(\"There should be no ensemble change if delaying ensemble change is enabled.\",\n+                     1, lh.getLedgerMetadata().getEnsembles().size());\n+\n+        bsConfs.add(conf0);\n+        bs.add(startBookie(conf0));\n+        bsConfs.add(conf1);\n+        bs.add(startBookie(conf1));\n+\n+        for (int i = 2 * numEntries; i < 3 * numEntries; i++) {\n+            lh.addEntry(data);\n+        }\n+\n+        // ensure there is no ensemble changed\n+        assertEquals(\"There should be no ensemble change if delaying ensemble change is enabled.\",\n+                     1, lh.getLedgerMetadata().getEnsembles().size());\n+\n+        // check entries\n+        verifyEntries(lh, 0, numEntries, 5, 0);\n+        verifyEntries(lh, numEntries, 2 * numEntries, 3, 2);\n+        verifyEntries(lh, 2 * numEntries, 3 * numEntries, 5, 0);\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testChangeEnsembleIfBrokenAckQuorum() throws Exception {\n+        startNewBookie();\n+        startNewBookie();\n+        startNewBookie();\n+\n+        LedgerHandle lh = bkc.createLedger(5, 5, 3, digestType, testPasswd);\n+\n+        byte[] data = \"foobar\".getBytes();\n+\n+        int numEntries = 5;\n+        for (int i = 0; i < numEntries; i++) {\n+            lh.addEntry(data);\n+        }\n+\n+        logger.info(\"Kill bookie 0 and write {} entries.\", numEntries);\n+\n+        // kill two bookies, but we still have 3 bookies for the ack quorum.\n+        ServerConfiguration conf0 = killBookie(lh.getLedgerMetadata().currentEnsemble.get(0));\n+\n+        for (int i = numEntries; i < 2 * numEntries; i++) {\n+            lh.addEntry(data);\n+        }\n+\n+        // ensure there is no ensemble changed\n+        assertEquals(\"There should be no ensemble change if delaying ensemble change is enabled.\",\n+                     1, lh.getLedgerMetadata().getEnsembles().size());\n+\n+        logger.info(\"Kill bookie 1 and write another {} entries.\", numEntries);\n+\n+        ServerConfiguration conf1 = killBookie(lh.getLedgerMetadata().currentEnsemble.get(1));\n+\n+        for (int i = 2 * numEntries; i < 3 * numEntries; i++) {\n+            lh.addEntry(data);\n+        }\n+\n+        // ensure there is no ensemble changed\n+        assertEquals(\"There should be no ensemble change if delaying ensemble change is enabled.\",\n+                     1, lh.getLedgerMetadata().getEnsembles().size());\n+\n+        logger.info(\"Kill bookie 2 and write another {} entries.\", numEntries);\n+\n+        ServerConfiguration conf2 = killBookie(lh.getLedgerMetadata().currentEnsemble.get(2));\n+\n+        for (int i = 3 * numEntries; i < 4 * numEntries; i++) {\n+            lh.addEntry(data);\n+        }\n+\n+        // ensemble change should kill in\n+        assertEquals(\"There should be ensemble change if ack quorum couldn't be formed.\",\n+                     2, lh.getLedgerMetadata().getEnsembles().size());\n+\n+        ArrayList<BookieSocketAddress> firstFragment = lh.getLedgerMetadata().getEnsemble(0);\n+        ArrayList<BookieSocketAddress> secondFragment = lh.getLedgerMetadata().getEnsemble(3 * numEntries);\n+        assertFalse(firstFragment.get(0).equals(secondFragment.get(0)));\n+        assertFalse(firstFragment.get(1).equals(secondFragment.get(1)));\n+        assertFalse(firstFragment.get(2).equals(secondFragment.get(2)));\n+        assertEquals(firstFragment.get(3), secondFragment.get(3));\n+        assertEquals(firstFragment.get(4), secondFragment.get(4));\n+\n+        bsConfs.add(conf0);\n+        bs.add(startBookie(conf0));\n+        bsConfs.add(conf1);\n+        bs.add(startBookie(conf1));\n+        bsConfs.add(conf2);\n+        bs.add(startBookie(conf2));\n+\n+        for (int i = 4 * numEntries; i < 5 * numEntries; i++) {\n+            lh.addEntry(data);\n+        }\n+\n+        // ensure there is no ensemble changed\n+        assertEquals(\"There should be no ensemble change if delaying ensemble change is enabled.\",\n+                     2, lh.getLedgerMetadata().getEnsembles().size());\n+\n+        // check entries\n+        verifyEntries(lh, 0, numEntries, 5, 0);\n+        verifyEntries(lh, numEntries, 2 * numEntries, 4, 1);\n+        verifyEntries(lh, 2 * numEntries, 3 * numEntries, 3, 2);\n+        verifyEntries(lh, 3 * numEntries, 4 * numEntries, 5, 0);\n+        verifyEntries(lh, 4 * numEntries, 5 * numEntries, 5, 0);\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testEnsembleChangeWithNotEnoughBookies() throws Exception {\n+        startNewBookie();\n+\n+        LedgerHandle lh = bkc.createLedger(5, 5, 3, digestType, testPasswd);\n+\n+        byte[] data = \"foobar\".getBytes();\n+\n+        int numEntries = 10;\n+        for (int i = 0; i < numEntries; i++) {\n+            lh.addEntry(data);\n+        }\n+\n+        logger.info(\"Killed 3 bookies and add {} more entries : {}\", numEntries, lh.getLedgerMetadata());\n+\n+        // kill three bookies, but we only have 2 new bookies for ensemble change.\n+        ServerConfiguration conf0 = killBookie(lh.getLedgerMetadata().currentEnsemble.get(0));\n+        ServerConfiguration conf1 = killBookie(lh.getLedgerMetadata().currentEnsemble.get(1));\n+        ServerConfiguration conf2 = killBookie(lh.getLedgerMetadata().currentEnsemble.get(2));\n+\n+        for (int i = numEntries; i < 2 * numEntries; i++) {\n+            lh.addEntry(data);\n+        }\n+\n+        logger.info(\"Ledger metadata after killed bookies : {}\", lh.getLedgerMetadata());\n+\n+        // ensure there is ensemble changed\n+        assertEquals(\"There should be ensemble change if ack quorum is broken.\",\n+                     2, lh.getLedgerMetadata().getEnsembles().size());\n+\n+        bsConfs.add(conf0);\n+        bs.add(startBookie(conf0));\n+        bsConfs.add(conf1);\n+        bs.add(startBookie(conf1));\n+        bsConfs.add(conf2);\n+        bs.add(startBookie(conf2));\n+\n+        for (int i = 2 * numEntries; i < 3 * numEntries; i++) {\n+            lh.addEntry(data);\n+        }\n+\n+        // ensure there is no ensemble changed\n+        assertEquals(\"There should be no ensemble change after adding failed bookies back.\",\n+                     2, lh.getLedgerMetadata().getEnsembles().size());\n+\n+        // check entries\n+        verifyEntries(lh, 0, numEntries, 5, 0);\n+        verifyEntries(lh, numEntries, 2 * numEntries, 3, 2);\n+        verifyEntries(lh, 2 * numEntries, 3 * numEntries, 5, 0);\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testEnsembleChangeWithMoreBookieFailures() throws Exception {\n+        for (int i = 0; i < 5; i++) {\n+            startNewBookie();\n+        }\n+\n+        LedgerHandle lh = bkc.createLedger(5, 5, 3, digestType, testPasswd);\n+\n+        byte[] data = \"foobar\".getBytes();\n+\n+        int numEntries = 10;\n+        for (int i = 0; i < numEntries; i++) {\n+            logger.info(\"Add entry {}\", i);\n+            lh.addEntry(data);\n+        }\n+\n+        logger.info(\"Killed 5 bookies and add {} more entries : {}\", numEntries, lh.getLedgerMetadata());\n+\n+        // kill 5 bookies to introduce more bookie failure\n+        List<ServerConfiguration> confs = new ArrayList<ServerConfiguration>(5);\n+        for (int i = 0; i < 5; i++) {\n+            confs.add(killBookie(lh.getLedgerMetadata().currentEnsemble.get(i)));\n+        }\n+\n+        for (int i = numEntries; i < 2 * numEntries; i++) {\n+            logger.info(\"Add entry {}\", i);\n+            lh.addEntry(data);\n+        }\n+\n+        logger.info(\"Ledger metadata after killed bookies : {}\", lh.getLedgerMetadata());\n+\n+        // ensure there is no ensemble changed\n+        assertEquals(\"There should be ensemble change if breaking ack quorum.\",\n+                     2, lh.getLedgerMetadata().getEnsembles().size());\n+\n+        for (ServerConfiguration conf : confs) {\n+            bsConfs.add(conf);\n+            bs.add(startBookie(conf));\n+        }\n+\n+        for (int i = 2 * numEntries; i < 3 * numEntries; i++) {\n+            logger.info(\"Add entry {}\", i);\n+            lh.addEntry(data);\n+        }\n+\n+        // ensure there is no ensemble changed\n+        assertEquals(\"There should not be ensemble changed if delaying ensemble change is enabled.\",\n+                     2, lh.getLedgerMetadata().getEnsembles().size());\n+\n+        // check entries\n+        verifyEntries(lh, 0, numEntries, 5, 0);\n+        verifyEntriesRange(lh, numEntries, 2 * numEntries, 5, 0);\n+        verifyEntries(lh, 2 * numEntries, 3 * numEntries, 5, 0);\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testChangeEnsembleIfBookieReadOnly() throws Exception {\n+        LedgerHandle lh = bkc.createLedger(3, 3, 2, digestType, testPasswd);\n+\n+        byte[] data = \"foobar\".getBytes();\n+\n+        int numEntries = 10;\n+        for (int i = 0; i < numEntries; i++) {\n+            lh.addEntry(data);\n+        }\n+\n+        // kill two bookies, but we still have 3 bookies for the ack quorum.\n+        setBookieToReadOnly(lh.getLedgerMetadata().currentEnsemble.get(0));\n+\n+        for (int i = numEntries; i < 2 * numEntries; i++) {\n+            lh.addEntry(data);\n+        }\n+\n+        // ensure there is no ensemble changed\n+        assertEquals(\"The ensemble should change when a bookie is readonly even if we delay ensemble change.\",\n+            2, lh.getLedgerMetadata().getEnsembles().size());\n+\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testChangeEnsembleSecondBookieReadOnly() throws Exception {\n+        LedgerHandle lh = bkc.createLedger(3, 3, 2, digestType, testPasswd);\n+\n+        byte[] data = \"foobar\".getBytes();\n+\n+        int numEntries = 10;\n+        for (int i = 0; i < numEntries; i++) {\n+            lh.addEntry(data);\n+        }\n+\n+        BookieSocketAddress failedBookie = lh.getLedgerMetadata().currentEnsemble.get(0);\n+        BookieSocketAddress readOnlyBookie = lh.getLedgerMetadata().currentEnsemble.get(1);\n+        ServerConfiguration conf0 = killBookie(failedBookie);\n+\n+        for (int i = 0; i < numEntries; i++) {\n+            lh.addEntry(data);\n+        }\n+\n+        assertEquals(\"There should be ensemble change if delaying ensemble change is enabled.\",\n+            1, lh.getLedgerMetadata().getEnsembles().size());\n+\n+        // kill two bookies, but we still have 3 bookies for the ack quorum.\n+        setBookieToReadOnly(readOnlyBookie);\n+\n+        for (int i = 0; i < numEntries; i++) {\n+            lh.addEntry(data);\n+        }\n+\n+        // ensure there is no ensemble changed\n+        assertEquals(\"The ensemble should change when a bookie is readonly even if we delay ensemble change.\",\n+            2, lh.getLedgerMetadata().getEnsembles().size());\n+        assertEquals(3, lh.getLedgerMetadata().currentEnsemble.size());\n+        assertFalse(lh.getLedgerMetadata().currentEnsemble.contains(failedBookie));\n+        assertFalse(lh.getLedgerMetadata().currentEnsemble.contains(readOnlyBookie));\n+    }\n+\n+}"},{"sha":"b45d434db07ef0fad53dfc15b3f82af928b1f05a","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestDisableEnsembleChange.java","status":"added","additions":277,"deletions":0,"changes":277,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/5e399df67c2aa1e5f228c62ba8533ca3293ab147/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FTestDisableEnsembleChange.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/5e399df67c2aa1e5f228c62ba8533ca3293ab147/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FTestDisableEnsembleChange.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FTestDisableEnsembleChange.java?ref=5e399df67c2aa1e5f228c62ba8533ca3293ab147","patch":"@@ -0,0 +1,277 @@\n+/**\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.client;\n+\n+import com.google.common.util.concurrent.RateLimiter;\n+import org.apache.bookkeeper.conf.ClientConfiguration;\n+import org.apache.bookkeeper.conf.ServerConfiguration;\n+import org.apache.bookkeeper.feature.SettableFeature;\n+import org.apache.bookkeeper.feature.SettableFeatureProvider;\n+import org.apache.bookkeeper.net.BookieSocketAddress;\n+import org.apache.bookkeeper.test.BookKeeperClusterTestCase;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static com.google.common.base.Charsets.UTF_8;\n+import static org.apache.bookkeeper.util.BookKeeperConstants.*;\n+import static org.junit.Assert.*;\n+\n+/**\n+ * Test Case on Disabling Ensemble Change Feature\n+ */\n+public class TestDisableEnsembleChange extends BookKeeperClusterTestCase {\n+\n+    static final Logger logger = LoggerFactory.getLogger(TestDisableEnsembleChange.class);\n+\n+    public TestDisableEnsembleChange() {\n+        super(4);\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testDisableEnsembleChange() throws Exception {\n+        disableEnsembleChangeTest(true);\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testDisableEnsembleChangeNotEnoughBookies() throws Exception {\n+        disableEnsembleChangeTest(false);\n+    }\n+\n+    void disableEnsembleChangeTest(boolean startNewBookie) throws Exception {\n+        ClientConfiguration conf = new ClientConfiguration();\n+        conf.setZkServers(zkUtil.getZooKeeperConnectString())\n+            .setDelayEnsembleChange(false)\n+            .setDisableEnsembleChangeFeatureName(FEATURE_DISABLE_ENSEMBLE_CHANGE);\n+\n+        SettableFeatureProvider featureProvider = new SettableFeatureProvider(\"test\", 0);\n+        BookKeeper bkc = BookKeeper.forConfig(conf)\n+                .featureProvider(featureProvider)\n+                .build();\n+\n+        SettableFeature disableEnsembleChangeFeature = featureProvider.getFeature(FEATURE_DISABLE_ENSEMBLE_CHANGE);\n+        disableEnsembleChangeFeature.set(true);\n+\n+        final byte[] password = new byte[0];\n+        final LedgerHandle lh = bkc.createLedger(4, 3, 2, BookKeeper.DigestType.CRC32, password);\n+        final AtomicBoolean finished = new AtomicBoolean(false);\n+        final AtomicBoolean failTest = new AtomicBoolean(false);\n+        final byte[] entry = \"test-disable-ensemble-change\".getBytes(UTF_8);\n+\n+        assertEquals(1, lh.getLedgerMetadata().getEnsembles().size());\n+        ArrayList<BookieSocketAddress> ensembleBeforeFailure =\n+                new ArrayList<BookieSocketAddress>(lh.getLedgerMetadata().getEnsembles().entrySet().iterator().next().getValue());\n+\n+        final RateLimiter rateLimiter = RateLimiter.create(10);\n+\n+        Thread addThread = new Thread() {\n+            @Override\n+            public void run() {\n+                try {\n+                    while (!finished.get()) {\n+                        rateLimiter.acquire();\n+                        lh.addEntry(entry);\n+                    }\n+                } catch (Exception e) {\n+                    logger.error(\"Exception on adding entry : \", e);\n+                    failTest.set(true);\n+                }\n+            }\n+        };\n+        addThread.start();\n+        Thread.sleep(2000);\n+        killBookie(0);\n+        Thread.sleep(2000);\n+        finished.set(true);\n+        addThread.join();\n+\n+        assertFalse(\"Should not fail adding entries facing one bookie failure when disable ensemble change\",\n+                failTest.get());\n+\n+        // check the ensemble after failure\n+        assertEquals(\"No new ensemble should be added when disable ensemble change.\",\n+                1, lh.getLedgerMetadata().getEnsembles().size());\n+        ArrayList<BookieSocketAddress> ensembleAfterFailure =\n+                new ArrayList<BookieSocketAddress>(lh.getLedgerMetadata().getEnsembles().entrySet().iterator().next().getValue());\n+        assertArrayEquals(ensembleBeforeFailure.toArray(new BookieSocketAddress[ensembleBeforeFailure.size()]),\n+                ensembleAfterFailure.toArray(new BookieSocketAddress[ensembleAfterFailure.size()]));\n+\n+        // enable ensemble change\n+        disableEnsembleChangeFeature.set(false);\n+        if (startNewBookie) {\n+            startNewBookie();\n+        }\n+\n+        // reset add thread\n+        finished.set(false);\n+        final CountDownLatch failLatch = new CountDownLatch(1);\n+\n+        addThread = new Thread() {\n+            @Override\n+            public void run() {\n+                try {\n+                    while (!finished.get()) {\n+                        lh.addEntry(entry);\n+                    }\n+                } catch (Exception e) {\n+                    logger.error(\"Exception on adding entry : \", e);\n+                    failLatch.countDown();\n+                    failTest.set(true);\n+                }\n+            }\n+        };\n+        addThread.start();\n+        failLatch.await(4000, TimeUnit.MILLISECONDS);\n+        finished.set(true);\n+        addThread.join();\n+\n+        if (startNewBookie) {\n+            assertFalse(\"Should not fail adding entries when enable ensemble change again.\",\n+                    failTest.get());\n+            assertFalse(\"Ledger should be closed when enable ensemble change again.\",\n+                    lh.getLedgerMetadata().isClosed());\n+            assertEquals(\"New ensemble should be added when enable ensemble change again.\",\n+                    2, lh.getLedgerMetadata().getEnsembles().size());\n+        } else {\n+            assertTrue(\"Should fail adding entries when enable ensemble change again.\",\n+                    failTest.get());\n+            assertTrue(\"Ledger should be closed when enable ensemble change again.\",\n+                    lh.getLedgerMetadata().isClosed());\n+        }\n+    }\n+\n+    @Test(timeout=20000)\n+    public void testRetryFailureBookie() throws Exception {\n+        ClientConfiguration conf = new ClientConfiguration();\n+        conf.setZkServers(zkUtil.getZooKeeperConnectString())\n+            .setDelayEnsembleChange(false)\n+            .setDisableEnsembleChangeFeatureName(FEATURE_DISABLE_ENSEMBLE_CHANGE);\n+\n+        SettableFeatureProvider featureProvider = new SettableFeatureProvider(\"test\", 0);\n+        BookKeeper bkc = BookKeeper.forConfig(conf)\n+                .featureProvider(featureProvider)\n+                .build();\n+\n+        SettableFeature disableEnsembleChangeFeature = featureProvider.getFeature(FEATURE_DISABLE_ENSEMBLE_CHANGE);\n+        disableEnsembleChangeFeature.set(true);\n+\n+        LedgerHandle lh = bkc.createLedger(4, 4, 4, BookKeeper.DigestType.CRC32, new byte[] {});\n+        byte[] entry = \"testRetryFailureBookie\".getBytes();\n+        for (int i=0; i<10; i++) {\n+            lh.addEntry(entry);\n+        }\n+        // kill a bookie\n+        ServerConfiguration killedConf = killBookie(0);\n+\n+        final AtomicInteger res = new AtomicInteger(0xdeadbeef);\n+        final CountDownLatch addLatch = new CountDownLatch(1);\n+        AsyncCallback.AddCallback cb = new AsyncCallback.AddCallback() {\n+            @Override\n+                public void addComplete(int rc, LedgerHandle lh, long entryId, Object ctx) {\n+                    logger.info(\"Add entry {} completed : rc {}.\", entryId, rc);\n+                    res.set(rc);\n+                    addLatch.countDown();\n+                }\n+        };\n+        lh.asyncAddEntry(entry, cb, null);\n+        assertFalse(\"Add entry operation should not complete.\",\n+                addLatch.await(1000, TimeUnit.MILLISECONDS));\n+        assertEquals(res.get(), 0xdeadbeef);\n+        // start the original bookie\n+        bsConfs.add(killedConf);\n+        bs.add(startBookie(killedConf));\n+        assertTrue(\"Add entry operation should complete at this point.\",\n+                addLatch.await(1000, TimeUnit.MILLISECONDS));\n+        assertEquals(res.get(), BKException.Code.OK);\n+    }\n+\n+    @Test(timeout=20000)\n+    public void testRetrySlowBookie() throws Exception {\n+        final int readTimeout = 2;\n+\n+        ClientConfiguration conf = new ClientConfiguration();\n+        conf.setZkServers(zkUtil.getZooKeeperConnectString())\n+            .setReadEntryTimeout(readTimeout)\n+            .setAddEntryTimeout(readTimeout)\n+            .setDelayEnsembleChange(false)\n+            .setDisableEnsembleChangeFeatureName(FEATURE_DISABLE_ENSEMBLE_CHANGE);\n+\n+\n+        SettableFeatureProvider featureProvider = new SettableFeatureProvider(\"test\", 0);\n+        BookKeeper bkc = BookKeeper.forConfig(conf)\n+                .featureProvider(featureProvider)\n+                .build();\n+\n+        SettableFeature disableEnsembleChangeFeature = featureProvider.getFeature(FEATURE_DISABLE_ENSEMBLE_CHANGE);\n+        disableEnsembleChangeFeature.set(true);\n+\n+        LedgerHandle lh = bkc.createLedger(4, 4, 4, BookKeeper.DigestType.CRC32, new byte[] {});\n+        byte[] entry = \"testRetryFailureBookie\".getBytes();\n+        for (int i=0; i<10; i++) {\n+            lh.addEntry(entry);\n+        }\n+\n+        List<BookieSocketAddress> curEns = lh.getLedgerMetadata().currentEnsemble;\n+\n+        final CountDownLatch wakeupLatch = new CountDownLatch(1);\n+        final CountDownLatch suspendLatch = new CountDownLatch(1);\n+        sleepBookie(curEns.get(2), wakeupLatch, suspendLatch);\n+\n+        suspendLatch.await();\n+\n+        final AtomicInteger res = new AtomicInteger(0xdeadbeef);\n+        final CountDownLatch addLatch = new CountDownLatch(1);\n+        AsyncCallback.AddCallback cb = new AsyncCallback.AddCallback() {\n+            @Override\n+                public void addComplete(int rc, LedgerHandle lh, long entryId, Object ctx) {\n+                    logger.info(\"Add entry {} completed : rc {}.\", entryId, rc);\n+                    res.set(rc);\n+                    addLatch.countDown();\n+                }\n+        };\n+        lh.asyncAddEntry(entry, cb, null);\n+        assertFalse(\"Add entry operation should not complete.\",\n+                addLatch.await(1000, TimeUnit.MILLISECONDS));\n+        assertEquals(res.get(), 0xdeadbeef);\n+        // wait until read timeout\n+        assertFalse(\"Add entry operation should not complete even timeout.\",\n+                addLatch.await(readTimeout, TimeUnit.SECONDS));\n+        assertEquals(res.get(), 0xdeadbeef);\n+        // wait one more read timeout, to ensure we resend multiple retries\n+        // to ensure it works correctly\n+        assertFalse(\"Add entry operation should not complete even timeout.\",\n+                addLatch.await(readTimeout, TimeUnit.SECONDS));\n+        assertEquals(res.get(), 0xdeadbeef);\n+        // wakeup the sleep bookie\n+        wakeupLatch.countDown();\n+        assertTrue(\"Add entry operation should complete at this point.\",\n+                addLatch.await(1000, TimeUnit.MILLISECONDS));\n+        assertEquals(res.get(), BKException.Code.OK);\n+    }\n+\n+}"},{"sha":"437c79456c3736b90a5b7962cd1d3fef72722e4d","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookKeeperClusterTestCase.java","status":"modified","additions":33,"deletions":2,"changes":35,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/5e399df67c2aa1e5f228c62ba8533ca3293ab147/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Ftest%2FBookKeeperClusterTestCase.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/5e399df67c2aa1e5f228c62ba8533ca3293ab147/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Ftest%2FBookKeeperClusterTestCase.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Ftest%2FBookKeeperClusterTestCase.java?ref=5e399df67c2aa1e5f228c62ba8533ca3293ab147","patch":"@@ -24,6 +24,7 @@\n import java.io.File;\n import java.io.IOException;\n import java.net.InetAddress;\n+import java.net.UnknownHostException;\n import java.util.HashMap;\n import java.util.LinkedList;\n import java.util.List;\n@@ -203,6 +204,7 @@ protected ServerConfiguration newServerConfiguration(int port, String zkServers,\n         ServerConfiguration conf = new ServerConfiguration(baseConf);\n         conf.setBookiePort(port);\n         conf.setZkServers(zkServers);\n+        conf.setAllowLoopback(true);\n         conf.setJournalDirName(journalDir.getPath());\n         String[] ledgerDirNames = new String[ledgerDirs.length];\n         for (int i=0; i<ledgerDirs.length; i++) {\n@@ -268,6 +270,23 @@ public ServerConfiguration killBookie(BookieSocketAddress addr) throws Exception\n         return null;\n     }\n \n+    /**\n+     * Set the bookie identified by its socket address to readonly\n+     *\n+     * @param addr\n+     *          Socket Address\n+     * @return the configuration of killed bookie\n+     * @throws InterruptedException\n+     */\n+    public void setBookieToReadOnly(BookieSocketAddress addr) throws InterruptedException, UnknownHostException {\n+        for (BookieServer server : bs) {\n+            if (server.getLocalAddress().equals(addr)) {\n+                server.getBookie().doTransitionToReadOnlyMode();\n+                break;\n+            }\n+        }\n+    }\n+\n     /**\n      * Kill a bookie by index. Also, stops the respective auto recovery process\n      * for this bookie, if isAutoRecoveryEnabled is true.\n@@ -338,13 +357,25 @@ public void run() {\n      * @throws IOException\n      */\n     public void sleepBookie(BookieSocketAddress addr, final CountDownLatch l)\n-            throws Exception {\n+            throws InterruptedException, IOException {\n+        final CountDownLatch suspendLatch = new CountDownLatch(1);\n+        sleepBookie(addr, l, suspendLatch);\n+        suspendLatch.await();\n+    }\n+\n+    public void sleepBookie(BookieSocketAddress addr, final CountDownLatch l, final CountDownLatch suspendLatch)\n+            throws InterruptedException, IOException {\n         for (final BookieServer bookie : bs) {\n             if (bookie.getLocalAddress().equals(addr)) {\n-                bookie.suspendProcessing();\n+                LOG.info(\"Sleep bookie {}.\", addr);\n                 Thread sleeper = new Thread() {\n+                    @Override\n                     public void run() {\n                         try {\n+                            bookie.suspendProcessing();\n+                            if (null != suspendLatch) {\n+                                suspendLatch.countDown();\n+                            }\n                             l.await();\n                             bookie.resumeProcessing();\n                         } catch (Exception e) {"},{"sha":"25c5250562888aa416e05f7398bced8045d00655","filename":"bookkeeper-server/src/test/resources/log4j.properties","status":"modified","additions":6,"deletions":1,"changes":7,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/5e399df67c2aa1e5f228c62ba8533ca3293ab147/bookkeeper-server%2Fsrc%2Ftest%2Fresources%2Flog4j.properties","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/5e399df67c2aa1e5f228c62ba8533ca3293ab147/bookkeeper-server%2Fsrc%2Ftest%2Fresources%2Flog4j.properties","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fresources%2Flog4j.properties?ref=5e399df67c2aa1e5f228c62ba8533ca3293ab147","patch":"@@ -42,12 +42,17 @@ log4j.appender.CONSOLE.Threshold=INFO\n log4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayout\n log4j.appender.CONSOLE.layout.ConversionPattern=%d{ISO8601} - %-5p - [%t:%C{1}@%L] - %m%n\n \n+#disable zookeeper logging\n+log4j.logger.org.apache.zookeeper=OFF\n+log4j.logger.org.apache.bookkeeper.bookie=INFO\n+log4j.logger.org.apache.bookkeeper.meta=INFO\n+\n #\n # Add ROLLINGFILE to rootLogger to get log file output\n #    Log DEBUG level and above messages to a log file\n log4j.appender.ROLLINGFILE=org.apache.log4j.DailyRollingFileAppender\n log4j.appender.ROLLINGFILE.Threshold=DEBUG\n-log4j.appender.ROLLINGFILE.File=bookkeeper-server.log\n+log4j.appender.ROLLINGFILE.File=target/bookkeeper-server.log\n log4j.appender.ROLLINGFILE.layout=org.apache.log4j.PatternLayout\n log4j.appender.ROLLINGFILE.layout.ConversionPattern=%d{ISO8601} - %-5p - [%t:%C{1}@%L] - %m%n\n "}]}