{"sha":"5130d3596f7fb862e38910bf0a0a1dae3ed892e8","node_id":"MDY6Q29tbWl0NDc4NTkyNTI2OjUxMzBkMzU5NmY3ZmI4NjJlMzg5MTBiZjBhMGExZGFlM2VkODkyZTg=","commit":{"author":{"name":"Matteo Merli","email":"mmerli@yahoo-inc.com","date":"2017-05-12T14:39:04Z"},"committer":{"name":"eolivelli","email":"eolivelli@apache.org","date":"2017-05-12T14:39:04Z"},"message":"BOOKKEEPER-1063: Use executor.execute() instead of submit()\n\nâ€¦ creation of unused FutureTask\n\nWhen submitting tasks to an executor, if the `FutureTask` object is not being used we should use `execute()` instead of `submit()` in order to avoid the task object allocation.\n\nAuthor: Matteo Merli <mmerli@yahoo-inc.com>\n\nReviewers: Enrico Olivelli <eolivelli@apache.org>\n\nCloses #150 from merlimat/executor-execute","tree":{"sha":"f4b093df6a7a317df49807ad01b8a63d177f1ec3","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/trees/f4b093df6a7a317df49807ad01b8a63d177f1ec3"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/commits/5130d3596f7fb862e38910bf0a0a1dae3ed892e8","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/5130d3596f7fb862e38910bf0a0a1dae3ed892e8","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/5130d3596f7fb862e38910bf0a0a1dae3ed892e8","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/5130d3596f7fb862e38910bf0a0a1dae3ed892e8/comments","author":{"login":"merlimat","id":62500,"node_id":"MDQ6VXNlcjYyNTAw","avatar_url":"https://avatars.githubusercontent.com/u/62500?v=4","gravatar_id":"","url":"https://api.github.com/users/merlimat","html_url":"https://github.com/merlimat","followers_url":"https://api.github.com/users/merlimat/followers","following_url":"https://api.github.com/users/merlimat/following{/other_user}","gists_url":"https://api.github.com/users/merlimat/gists{/gist_id}","starred_url":"https://api.github.com/users/merlimat/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/merlimat/subscriptions","organizations_url":"https://api.github.com/users/merlimat/orgs","repos_url":"https://api.github.com/users/merlimat/repos","events_url":"https://api.github.com/users/merlimat/events{/privacy}","received_events_url":"https://api.github.com/users/merlimat/received_events","type":"User","site_admin":false},"committer":{"login":"eolivelli","id":9469110,"node_id":"MDQ6VXNlcjk0NjkxMTA=","avatar_url":"https://avatars.githubusercontent.com/u/9469110?v=4","gravatar_id":"","url":"https://api.github.com/users/eolivelli","html_url":"https://github.com/eolivelli","followers_url":"https://api.github.com/users/eolivelli/followers","following_url":"https://api.github.com/users/eolivelli/following{/other_user}","gists_url":"https://api.github.com/users/eolivelli/gists{/gist_id}","starred_url":"https://api.github.com/users/eolivelli/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/eolivelli/subscriptions","organizations_url":"https://api.github.com/users/eolivelli/orgs","repos_url":"https://api.github.com/users/eolivelli/repos","events_url":"https://api.github.com/users/eolivelli/events{/privacy}","received_events_url":"https://api.github.com/users/eolivelli/received_events","type":"User","site_admin":false},"parents":[{"sha":"d7f7b922f3ea0471452115c6271fd18ab63d3505","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/d7f7b922f3ea0471452115c6271fd18ab63d3505","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/d7f7b922f3ea0471452115c6271fd18ab63d3505"}],"stats":{"total":65,"additions":30,"deletions":35},"files":[{"sha":"a39c3fad1045a0d731a1c31272d49dc012342081","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Journal.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/5130d3596f7fb862e38910bf0a0a1dae3ed892e8/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FJournal.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/5130d3596f7fb862e38910bf0a0a1dae3ed892e8/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FJournal.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FJournal.java?ref=5130d3596f7fb862e38910bf0a0a1dae3ed892e8","patch":"@@ -338,7 +338,7 @@ public int process(boolean shouldForceWrite) throws IOException {\n \n                 // Notify the waiters that the force write succeeded\n                 for (QueueEntry e : this.forceWriteWaiters) {\n-                    cbThreadPool.submit(e);\n+                    cbThreadPool.execute(e);\n                 }\n \n                 return this.forceWriteWaiters.size();"},{"sha":"698dbd30668823ee4e91363056cffe784709b6a2","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/SortedLedgerStorage.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/5130d3596f7fb862e38910bf0a0a1dae3ed892e8/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FSortedLedgerStorage.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/5130d3596f7fb862e38910bf0a0a1dae3ed892e8/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FSortedLedgerStorage.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FSortedLedgerStorage.java?ref=5130d3596f7fb862e38910bf0a0a1dae3ed892e8","patch":"@@ -175,7 +175,7 @@ public void onSizeLimitReached() throws IOException {\n         //\n         // The only exception for the size limitation is if a file grows to be more than hard limit 2GB,\n         // we have to force rolling log, which it might cause slight performance effects\n-        scheduler.submit(new Runnable() {\n+        scheduler.execute(new Runnable() {\n             @Override\n             public void run() {\n                 try {"},{"sha":"8fd3701e9b65753b63a946c2674bd156ddca5b55","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/HierarchicalLedgerManager.java","status":"modified","additions":3,"deletions":3,"changes":6,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/5130d3596f7fb862e38910bf0a0a1dae3ed892e8/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FHierarchicalLedgerManager.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/5130d3596f7fb862e38910bf0a0a1dae3ed892e8/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FHierarchicalLedgerManager.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FHierarchicalLedgerManager.java?ref=5130d3596f7fb862e38910bf0a0a1dae3ed892e8","patch":"@@ -32,9 +32,9 @@\n  * HierarchicalLedgerManager makes use of both LongHierarchicalLedgerManager and LegacyHierarchicalLedgerManager\n  * to extend the 31-bit ledger id range of the LegacyHierarchicalLedgerManager to that of the LongHierarchicalLedgerManager\n  * while remaining backwards-compatible with the legacy manager.\n- * \n- * In order to achieve backwards-compatibility, the HierarchicalLedgerManager forwards requests relating to ledger IDs which \n- * are < Integer.MAX_INT to the LegacyHierarchicalLedgerManager. The new 5-part directory structure will not appear until a \n+ *\n+ * In order to achieve backwards-compatibility, the HierarchicalLedgerManager forwards requests relating to ledger IDs which\n+ * are < Integer.MAX_INT to the LegacyHierarchicalLedgerManager. The new 5-part directory structure will not appear until a\n  * ledger with an ID >= Integer.MAX_INT is created.\n  *\n  * @see LongHierarchicalLedgerManager"},{"sha":"118001cc55ddb614078d53d07d1846d46ede353b","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/util/OrderedSafeExecutor.java","status":"modified","additions":25,"deletions":30,"changes":55,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/5130d3596f7fb862e38910bf0a0a1dae3ed892e8/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2FOrderedSafeExecutor.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/5130d3596f7fb862e38910bf0a0a1dae3ed892e8/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2FOrderedSafeExecutor.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2FOrderedSafeExecutor.java?ref=5130d3596f7fb862e38910bf0a0a1dae3ed892e8","patch":"@@ -20,18 +20,14 @@\n import com.google.common.base.Preconditions;\n import com.google.common.util.concurrent.ThreadFactoryBuilder;\n import java.util.Random;\n-import java.util.concurrent.BlockingQueue;\n-import java.util.concurrent.Callable;\n import java.util.concurrent.ExecutionException;\n import java.util.concurrent.ExecutorService;\n import java.util.concurrent.Executors;\n-import java.util.concurrent.LinkedBlockingQueue;\n import java.util.concurrent.RejectedExecutionException;\n import java.util.concurrent.ScheduledExecutorService;\n import java.util.concurrent.ScheduledFuture;\n import java.util.concurrent.ScheduledThreadPoolExecutor;\n import java.util.concurrent.ThreadFactory;\n-import java.util.concurrent.ThreadPoolExecutor;\n import java.util.concurrent.TimeUnit;\n \n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n@@ -166,7 +162,6 @@ public OrderedSafeExecutor(int numThreads, String threadName) {\n      * @param warnTimeMicroSec\n      *            - log long task exec warning after this interval\n      */\n-    @SuppressWarnings(\"unchecked\")\n     private OrderedSafeExecutor(String baseName, int numThreads, ThreadFactory threadFactory,\n                                 StatsLogger statsLogger, boolean traceTaskExecution,\n                                 long warnTimeMicroSec) {\n@@ -281,7 +276,7 @@ private SafeRunnable timedRunnable(SafeRunnable r) {\n      * schedules a one time action to execute\n      */\n     public void submit(SafeRunnable r) {\n-        chooseThread().submit(timedRunnable(r));\n+        chooseThread().execute(timedRunnable(r));\n     }\n \n     /**\n@@ -290,12 +285,12 @@ public void submit(SafeRunnable r) {\n      * @param r\n      */\n     public void submitOrdered(Object orderingKey, SafeRunnable r) {\n-        chooseThread(orderingKey).submit(timedRunnable(r));\n+        chooseThread(orderingKey).execute(timedRunnable(r));\n     }\n \n     /**\n      * Creates and executes a one-shot action that becomes enabled after the given delay.\n-     * \n+     *\n      * @param command - the SafeRunnable to execute\n      * @param delay - the time from now to delay execution\n      * @param unit - the time unit of the delay parameter\n@@ -307,8 +302,8 @@ public ScheduledFuture<?> schedule(SafeRunnable command, long delay, TimeUnit un\n \n     /**\n      * Creates and executes a one-shot action that becomes enabled after the given delay.\n-     * \n-     * @param orderingKey - the key used for ordering \n+     *\n+     * @param orderingKey - the key used for ordering\n      * @param command - the SafeRunnable to execute\n      * @param delay - the time from now to delay execution\n      * @param unit - the time unit of the delay parameter\n@@ -318,35 +313,35 @@ public ScheduledFuture<?> scheduleOrdered(Object orderingKey, SafeRunnable comma\n         return chooseThread(orderingKey).schedule(command, delay, unit);\n     }\n \n-    /** \n+    /**\n      * Creates and executes a periodic action that becomes enabled first after\n-     * the given initial delay, and subsequently with the given period; \n-     * \n+     * the given initial delay, and subsequently with the given period;\n+     *\n      * For more details check scheduleAtFixedRate in interface ScheduledExecutorService\n-     * \n+     *\n      * @param command - the SafeRunnable to execute\n      * @param initialDelay - the time to delay first execution\n      * @param period - the period between successive executions\n      * @param unit - the time unit of the initialDelay and period parameters\n-     * @return a ScheduledFuture representing pending completion of the task, and whose get() \n+     * @return a ScheduledFuture representing pending completion of the task, and whose get()\n      * method will throw an exception upon cancellation\n      */\n     public ScheduledFuture<?> scheduleAtFixedRate(SafeRunnable command, long initialDelay, long period, TimeUnit unit) {\n         return chooseThread().scheduleAtFixedRate(command, initialDelay, period, unit);\n     }\n \n-    /** \n+    /**\n      * Creates and executes a periodic action that becomes enabled first after\n-     * the given initial delay, and subsequently with the given period; \n-     * \n+     * the given initial delay, and subsequently with the given period;\n+     *\n      * For more details check scheduleAtFixedRate in interface ScheduledExecutorService\n-     * \n+     *\n      * @param orderingKey - the key used for ordering\n      * @param command - the SafeRunnable to execute\n      * @param initialDelay - the time to delay first execution\n      * @param period - the period between successive executions\n      * @param unit - the time unit of the initialDelay and period parameters\n-     * @return a ScheduledFuture representing pending completion of the task, and whose get() method \n+     * @return a ScheduledFuture representing pending completion of the task, and whose get() method\n      * will throw an exception upon cancellation\n      */\n     public ScheduledFuture<?> scheduleAtFixedRateOrdered(Object orderingKey, SafeRunnable command, long initialDelay,\n@@ -355,16 +350,16 @@ public ScheduledFuture<?> scheduleAtFixedRateOrdered(Object orderingKey, SafeRun\n     }\n \n     /**\n-     * Creates and executes a periodic action that becomes enabled first after the given initial delay, and subsequently \n+     * Creates and executes a periodic action that becomes enabled first after the given initial delay, and subsequently\n      * with the given delay between the termination of one execution and the commencement of the next.\n-     * \n+     *\n      * For more details check scheduleWithFixedDelay in interface ScheduledExecutorService\n-     * \n+     *\n      * @param command - the SafeRunnable to execute\n      * @param initialDelay - the time to delay first execution\n      * @param delay - the delay between the termination of one execution and the commencement of the next\n      * @param unit - the time unit of the initialDelay and delay parameters\n-     * @return a ScheduledFuture representing pending completion of the task, and whose get() method \n+     * @return a ScheduledFuture representing pending completion of the task, and whose get() method\n      * will throw an exception upon cancellation\n      */\n     public ScheduledFuture<?> scheduleWithFixedDelay(SafeRunnable command, long initialDelay, long delay,\n@@ -373,17 +368,17 @@ public ScheduledFuture<?> scheduleWithFixedDelay(SafeRunnable command, long init\n     }\n \n     /**\n-     * Creates and executes a periodic action that becomes enabled first after the given initial delay, and subsequently \n+     * Creates and executes a periodic action that becomes enabled first after the given initial delay, and subsequently\n      * with the given delay between the termination of one execution and the commencement of the next.\n-     * \n+     *\n      * For more details check scheduleWithFixedDelay in interface ScheduledExecutorService\n-     * \n+     *\n      * @param orderingKey - the key used for ordering\n      * @param command - the SafeRunnable to execute\n      * @param initialDelay - the time to delay first execution\n      * @param delay - the delay between the termination of one execution and the commencement of the next\n      * @param unit - the time unit of the initialDelay and delay parameters\n-     * @return a ScheduledFuture representing pending completion of the task, and whose get() method \n+     * @return a ScheduledFuture representing pending completion of the task, and whose get() method\n      * will throw an exception upon cancellation\n      */\n     public ScheduledFuture<?> scheduleWithFixedDelayOrdered(Object orderingKey, SafeRunnable command, long initialDelay,\n@@ -397,7 +392,7 @@ public ScheduledFuture<?> scheduleWithFixedDelayOrdered(Object orderingKey, Safe\n      * @param r\n      */\n     public void submitOrdered(long orderingKey, SafeRunnable r) {\n-        chooseThread(orderingKey).submit(r);\n+        chooseThread(orderingKey).execute(r);\n     }\n \n     /**\n@@ -406,7 +401,7 @@ public void submitOrdered(long orderingKey, SafeRunnable r) {\n      * @param r\n      */\n     public void submitOrdered(int orderingKey, SafeRunnable r) {\n-        chooseThread(orderingKey).submit(r);\n+        chooseThread(orderingKey).execute(r);\n     }\n \n     private long getThreadID(long orderingKey) {"}]}