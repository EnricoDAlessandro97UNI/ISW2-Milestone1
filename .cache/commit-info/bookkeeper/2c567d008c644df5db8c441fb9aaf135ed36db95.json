{"sha":"2c567d008c644df5db8c441fb9aaf135ed36db95","node_id":"MDY6Q29tbWl0NDc4NTkyNTI2OjJjNTY3ZDAwOGM2NDRkZjVkYjhjNDQxZmI5YWFmMTM1ZWQzNmRiOTU=","commit":{"author":{"name":"Matteo Merli","email":"mmerli@apache.org","date":"2016-02-23T23:44:31Z"},"committer":{"name":"Matteo Merli","email":"mmerli@apache.org","date":"2016-02-23T23:44:31Z"},"message":"BOOKKEEPER-841: Bookie should calculate ledgers map writing a new entry log file\n\nsijie I've addressed all comments from https://reviews.apache.org/r/33061\n\nAuthor: Matteo Merli <mmerli@apache.org>\n\nReviewers: Sijie Guo <sijie@apache.org>\n\nCloses #5 from merlimat/bk-841","tree":{"sha":"e50681bda13143d397362d69cba867571f7dff07","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/trees/e50681bda13143d397362d69cba867571f7dff07"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/commits/2c567d008c644df5db8c441fb9aaf135ed36db95","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/2c567d008c644df5db8c441fb9aaf135ed36db95","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/2c567d008c644df5db8c441fb9aaf135ed36db95","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/2c567d008c644df5db8c441fb9aaf135ed36db95/comments","author":{"login":"merlimat","id":62500,"node_id":"MDQ6VXNlcjYyNTAw","avatar_url":"https://avatars.githubusercontent.com/u/62500?v=4","gravatar_id":"","url":"https://api.github.com/users/merlimat","html_url":"https://github.com/merlimat","followers_url":"https://api.github.com/users/merlimat/followers","following_url":"https://api.github.com/users/merlimat/following{/other_user}","gists_url":"https://api.github.com/users/merlimat/gists{/gist_id}","starred_url":"https://api.github.com/users/merlimat/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/merlimat/subscriptions","organizations_url":"https://api.github.com/users/merlimat/orgs","repos_url":"https://api.github.com/users/merlimat/repos","events_url":"https://api.github.com/users/merlimat/events{/privacy}","received_events_url":"https://api.github.com/users/merlimat/received_events","type":"User","site_admin":false},"committer":{"login":"merlimat","id":62500,"node_id":"MDQ6VXNlcjYyNTAw","avatar_url":"https://avatars.githubusercontent.com/u/62500?v=4","gravatar_id":"","url":"https://api.github.com/users/merlimat","html_url":"https://github.com/merlimat","followers_url":"https://api.github.com/users/merlimat/followers","following_url":"https://api.github.com/users/merlimat/following{/other_user}","gists_url":"https://api.github.com/users/merlimat/gists{/gist_id}","starred_url":"https://api.github.com/users/merlimat/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/merlimat/subscriptions","organizations_url":"https://api.github.com/users/merlimat/orgs","repos_url":"https://api.github.com/users/merlimat/repos","events_url":"https://api.github.com/users/merlimat/events{/privacy}","received_events_url":"https://api.github.com/users/merlimat/received_events","type":"User","site_admin":false},"parents":[{"sha":"9bd9e061bc225f36d8c9d516d4265aa209e4e90e","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/9bd9e061bc225f36d8c9d516d4265aa209e4e90e","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/9bd9e061bc225f36d8c9d516d4265aa209e4e90e"}],"stats":{"total":567,"additions":456,"deletions":111},"files":[{"sha":"461736c69189bce6b51fd4bfbbeab498f84f26ac","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/EntryLogMetadata.java","status":"added","additions":101,"deletions":0,"changes":101,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/2c567d008c644df5db8c441fb9aaf135ed36db95/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FEntryLogMetadata.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/2c567d008c644df5db8c441fb9aaf135ed36db95/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FEntryLogMetadata.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FEntryLogMetadata.java?ref=2c567d008c644df5db8c441fb9aaf135ed36db95","patch":"@@ -0,0 +1,101 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+\n+package org.apache.bookkeeper.bookie;\n+\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+/**\n+ * Records the total size, remaining size and the set of ledgers that comprise a entry log.\n+ */\n+public class EntryLogMetadata {\n+    private final long entryLogId;\n+    private long totalSize;\n+    private long remainingSize;\n+    private ConcurrentHashMap<Long, Long> ledgersMap;\n+\n+    public EntryLogMetadata(long logId) {\n+        this.entryLogId = logId;\n+\n+        totalSize = remainingSize = 0;\n+        ledgersMap = new ConcurrentHashMap<Long, Long>();\n+    }\n+\n+    public void addLedgerSize(long ledgerId, long size) {\n+        totalSize += size;\n+        remainingSize += size;\n+        Long ledgerSize = ledgersMap.get(ledgerId);\n+        if (null == ledgerSize) {\n+            ledgerSize = 0L;\n+        }\n+        ledgerSize += size;\n+        ledgersMap.put(ledgerId, ledgerSize);\n+    }\n+\n+    public void removeLedger(long ledgerId) {\n+        Long size = ledgersMap.remove(ledgerId);\n+        if (null == size) {\n+            return;\n+        }\n+        remainingSize -= size;\n+    }\n+\n+    public boolean containsLedger(long ledgerId) {\n+        return ledgersMap.containsKey(ledgerId);\n+    }\n+\n+    public double getUsage() {\n+        if (totalSize == 0L) {\n+            return 0.0f;\n+        }\n+        return (double) remainingSize / totalSize;\n+    }\n+\n+    public boolean isEmpty() {\n+        return ledgersMap.isEmpty();\n+    }\n+\n+    public long getEntryLogId() {\n+        return entryLogId;\n+    }\n+\n+    public long getTotalSize() {\n+        return totalSize;\n+    }\n+\n+    public long getRemainingSize() {\n+        return remainingSize;\n+    }\n+\n+    Map<Long, Long> getLedgersMap() {\n+        return ledgersMap;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(\"{ totalSize = \").append(totalSize).append(\", remainingSize = \").append(remainingSize)\n+                .append(\", ledgersMap = \").append(ledgersMap).append(\" }\");\n+        return sb.toString();\n+    }\n+\n+}"},{"sha":"a970a969f095ad8041883ede68a9f9b7b9dd4f24","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/EntryLogger.java","status":"modified","additions":254,"deletions":2,"changes":256,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/2c567d008c644df5db8c441fb9aaf135ed36db95/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FEntryLogger.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/2c567d008c644df5db8c441fb9aaf135ed36db95/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FEntryLogger.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FEntryLogger.java?ref=2c567d008c644df5db8c441fb9aaf135ed36db95","patch":"@@ -39,9 +39,11 @@\n import java.nio.channels.FileChannel;\n import java.util.ArrayList;\n import java.util.Collections;\n+import java.util.Iterator;\n import java.util.LinkedList;\n import java.util.List;\n import java.util.Map;\n+import java.util.Map.Entry;\n import java.util.concurrent.Callable;\n import java.util.concurrent.CancellationException;\n import java.util.concurrent.ConcurrentHashMap;\n@@ -74,14 +76,25 @@ public class EntryLogger {\n \n     private static class BufferedLogChannel extends BufferedChannel {\n         final private long logId;\n+        private final EntryLogMetadata entryLogMetada;\n+\n         public BufferedLogChannel(FileChannel fc, int writeCapacity,\n                                   int readCapacity, long logId) throws IOException {\n             super(fc, writeCapacity, readCapacity);\n             this.logId = logId;\n+            this.entryLogMetada = new EntryLogMetadata(logId);\n         }\n         public long getLogId() {\n             return logId;\n         }\n+\n+        public void registerWrittenEntry(long ledgerId, long entrySize) {\n+            entryLogMetada.addLedgerSize(ledgerId, entrySize);\n+        }\n+\n+        public Map<Long, Long> getLedgersMap() {\n+            return entryLogMetada.getLedgersMap();\n+        }\n     }\n \n     volatile File currentDir;\n@@ -101,14 +114,60 @@ public long getLogId() {\n     private final CopyOnWriteArrayList<EntryLogListener> listeners\n         = new CopyOnWriteArrayList<EntryLogListener>();\n \n+    private static final int HEADER_V0 = 0; // Old log file format (no ledgers map index)\n+    private static final int HEADER_V1 = 1; // Introduced ledger map index\n+    private static final int HEADER_CURRENT_VERSION = HEADER_V1;\n+\n+    private static class Header {\n+        final int version;\n+        final long ledgersMapOffset;\n+        final int ledgersCount;\n+\n+        Header(int version, long ledgersMapOffset, int ledgersCount) {\n+            this.version = version;\n+            this.ledgersMapOffset = ledgersMapOffset;\n+            this.ledgersCount = ledgersCount;\n+        }\n+    }\n+\n     /**\n      * The 1K block at the head of the entry logger file\n-     * that contains the fingerprint and (future) meta-data\n+     * that contains the fingerprint and meta-data.\n+     *\n+     * Header is composed of:\n+     * Fingerprint: 4 bytes \"BKLO\"\n+     * Log file HeaderVersion enum: 4 bytes\n+     * Ledger map offset: 8 bytes\n+     * Ledgers Count: 4 bytes\n      */\n     final static int LOGFILE_HEADER_SIZE = 1024;\n     final ByteBuffer LOGFILE_HEADER = ByteBuffer.allocate(LOGFILE_HEADER_SIZE);\n+\n+    final static int HEADER_VERSION_POSITION = 4;\n+    final static int LEDGERS_MAP_OFFSET_POSITION = HEADER_VERSION_POSITION + 4;\n+\n+    /**\n+     * Ledgers map is composed of multiple parts that can be split into separated entries. Each of them is composed of:\n+     *\n+     * <pre>\n+     * length: (4 bytes) [0-3]\n+     * ledger id (-1): (8 bytes) [4 - 11]\n+     * entry id: (8 bytes) [12-19]\n+     * num ledgers stored in current metadata entry: (4 bytes) [20 - 23]\n+     * ledger entries: sequence of (ledgerid, size) (8 + 8 bytes each) [24..]\n+     * </pre>\n+     */\n+    final static int LEDGERS_MAP_HEADER_SIZE = 4 + 8 + 8 + 4;\n+    final static int LEDGERS_MAP_ENTRY_SIZE = 8 + 8;\n+\n+    // Break the ledgers map into multiple batches, each of which can contain up to 10K ledgers\n+    final static int LEDGERS_MAP_MAX_BATCH_SIZE = 10000;\n+\n     final static long INVALID_LID = -1L;\n \n+    // EntryId used to mark an entry (belonging to INVALID_ID) as a component of the serialized ledgers map\n+    final static long LEDGERS_MAP_ENTRY_ID = -2L;\n+\n     final static int MIN_SANE_ENTRY_SIZE = 8 + 8;\n     final static long MB = 1024 * 1024;\n \n@@ -177,6 +236,7 @@ public EntryLogger(ServerConfiguration conf,\n         // so there can be race conditions when entry logs are rolled over and\n         // this header buffer is cleared before writing it into the new logChannel.\n         LOGFILE_HEADER.put(\"BKLO\".getBytes(UTF_8));\n+        LOGFILE_HEADER.putInt(HEADER_CURRENT_VERSION);\n \n         // Find the largest logId\n         long logId = INVALID_LID;\n@@ -370,9 +430,14 @@ void createNewLog() throws IOException {\n             if (null == logChannelsToFlush) {\n                 logChannelsToFlush = new LinkedList<BufferedLogChannel>();\n             }\n+\n             // flush the internal buffer back to filesystem but not sync disk\n             // so the readers could access the data from filesystem.\n             logChannel.flush(false);\n+\n+            // Append ledgers map at the end of entry log\n+            appendLedgersMap(logChannel);\n+\n             BufferedLogChannel newLogChannel = entryLoggerAllocator.createNewLog();\n             logChannelsToFlush.add(logChannel);\n             LOG.info(\"Flushing entry logger {} back to filesystem, pending for syncing entry loggers : {}.\",\n@@ -386,6 +451,55 @@ void createNewLog() throws IOException {\n         }\n     }\n \n+    /**\n+     * Append the ledger map at the end of the entry log.\n+     * Updates the entry log file header with the offset and size of the map.\n+     */\n+    private void appendLedgersMap(BufferedLogChannel entryLogChannel) throws IOException {\n+        long ledgerMapOffset = entryLogChannel.position();\n+\n+        Map<Long, Long> ledgersMap = entryLogChannel.getLedgersMap();\n+\n+        Iterator<Entry<Long, Long>> iterator = ledgersMap.entrySet().iterator();\n+        int numberOfLedgers = ledgersMap.size();\n+        int remainingLedgers = numberOfLedgers;\n+\n+        // Write the ledgers map into several batches\n+        while (iterator.hasNext()) {\n+            // Start new batch\n+            int batchSize = Math.min(remainingLedgers, LEDGERS_MAP_MAX_BATCH_SIZE);\n+            int ledgerMapSize = LEDGERS_MAP_HEADER_SIZE + LEDGERS_MAP_ENTRY_SIZE * batchSize;\n+            ByteBuffer serializedMap = ByteBuffer.allocate(ledgerMapSize);\n+\n+            serializedMap.putInt(ledgerMapSize - 4);\n+            serializedMap.putLong(INVALID_LID);\n+            serializedMap.putLong(LEDGERS_MAP_ENTRY_ID);\n+            serializedMap.putInt(batchSize);\n+\n+            // Dump all ledgers for this batch\n+            for (int i = 0; i < batchSize; i++) {\n+                Entry<Long, Long> entry = iterator.next();\n+                long ledgerId = entry.getKey();\n+                long size = entry.getValue();\n+\n+                serializedMap.putLong(ledgerId);\n+                serializedMap.putLong(size);\n+                --remainingLedgers;\n+            }\n+\n+            // Close current batch\n+            serializedMap.flip();\n+            entryLogChannel.fileChannel.write(serializedMap);\n+        }\n+\n+        // Update the headers with the map offset and count of ledgers\n+        ByteBuffer mapInfo = ByteBuffer.allocate(8 + 4);\n+        mapInfo.putLong(ledgerMapOffset);\n+        mapInfo.putInt(numberOfLedgers);\n+        mapInfo.flip();\n+        entryLogChannel.fileChannel.write(mapInfo, LEDGERS_MAP_OFFSET_POSITION);\n+    }\n+\n     /**\n      * An allocator pre-allocates entry log files.\n      */\n@@ -642,12 +756,14 @@ synchronized long addEntry(long ledger, ByteBuffer entry, boolean rollLog) throw\n                 shouldCreateNewEntryLog.set(false);\n             }\n         }\n+\n         ByteBuffer buff = ByteBuffer.allocate(4);\n         buff.putInt(entry.remaining());\n         buff.flip();\n         logChannel.write(buff);\n         long pos = logChannel.position();\n         logChannel.write(entry);\n+        logChannel.registerWrittenEntry(ledger, entrySize);\n \n         return (logChannel.getLogId() << 32L) | pos;\n     }\n@@ -721,6 +837,30 @@ byte[] readEntry(long ledgerId, long entryId, long location) throws IOException,\n         return data;\n     }\n \n+    /**\n+     * Read the header of an entry log\n+     */\n+    private Header getHeaderForLogId(long entryLogId) throws IOException {\n+        BufferedReadChannel bc = getChannelForLogId(entryLogId);\n+\n+        // Allocate buffer to read (version, ledgersMapOffset, ledgerCount)\n+        ByteBuffer headers = ByteBuffer.allocate(LOGFILE_HEADER_SIZE);\n+        bc.read(headers, 0);\n+        headers.flip();\n+\n+        // Skip marker string \"BKLO\"\n+        headers.getInt();\n+\n+        int headerVersion = headers.getInt();\n+        if (headerVersion < HEADER_V0 || headerVersion > HEADER_CURRENT_VERSION) {\n+            LOG.info(\"Unknown entry log header version for log {}: {}\", entryLogId, headerVersion);\n+        }\n+\n+        long ledgersMapOffset = headers.getLong();\n+        int ledgersCount = headers.getInt();\n+        return new Header(headerVersion, ledgersMapOffset, ledgersCount);\n+    }\n+\n     private BufferedReadChannel getChannelForLogId(long entryLogId) throws IOException {\n         BufferedReadChannel fc = getFromChannels(entryLogId);\n         if (fc != null) {\n@@ -788,6 +928,7 @@ protected void scanEntryLog(long entryLogId, EntryLogScanner scanner) throws IOE\n         // Start the read position in the current entry log file to be after\n         // the header where all of the ledger entries are.\n         long pos = LOGFILE_HEADER_SIZE;\n+\n         // Read through the entry log file and extract the ledger ID's.\n         while (true) {\n             // Check if we've finished reading the entry log file.\n@@ -812,7 +953,7 @@ protected void scanEntryLog(long entryLogId, EntryLogScanner scanner) throws IOE\n             lidBuff.flip();\n             long lid = lidBuff.getLong();\n             lidBuff.clear();\n-            if (!scanner.accept(lid)) {\n+            if (lid == INVALID_LID || !scanner.accept(lid)) {\n                 // skip this entry\n                 pos += entrySize;\n                 continue;\n@@ -834,6 +975,117 @@ protected void scanEntryLog(long entryLogId, EntryLogScanner scanner) throws IOE\n         }\n     }\n \n+    public EntryLogMetadata getEntryLogMetadata(long entryLogId) throws IOException {\n+        // First try to extract the EntryLogMetada from the index, if there's no index then fallback to scanning the\n+        // entry log\n+        try {\n+            return extractEntryLogMetadataFromIndex(entryLogId);\n+        } catch (Exception e) {\n+            LOG.info(\"Failed to get ledgers map index from: {}.log : {}\", entryLogId, e.getMessage());\n+\n+            // Fall-back to scanning\n+            return extractEntryLogMetadataByScanning(entryLogId);\n+        }\n+    }\n+\n+    EntryLogMetadata extractEntryLogMetadataFromIndex(long entryLogId) throws IOException {\n+        Header header = getHeaderForLogId(entryLogId);\n+\n+        if (header.version < HEADER_V1) {\n+            throw new IOException(\"Old log file header without ledgers map on entryLogId \" + entryLogId);\n+        }\n+\n+        if (header.ledgersMapOffset == 0L) {\n+            // The index was not stored in the log file (possibly because the bookie crashed before flushing it)\n+            throw new IOException(\"No ledgers map index found on entryLogId\" + entryLogId);\n+        }\n+\n+        if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"Recovering ledgers maps for log {} at offset: {}\", entryLogId, header.ledgersMapOffset);\n+        }\n+\n+        BufferedReadChannel bc = getChannelForLogId(entryLogId);\n+\n+        // There can be multiple entries containing the various components of the serialized ledgers map\n+        long offset = header.ledgersMapOffset;\n+        EntryLogMetadata meta = new EntryLogMetadata(entryLogId);\n+\n+        while (offset < bc.size()) {\n+            // Read ledgers map size\n+            ByteBuffer sizeBuf = ByteBuffer.allocate(4);\n+            bc.read(sizeBuf, offset);\n+            sizeBuf.flip();\n+\n+            int ledgersMapSize = sizeBuf.getInt();\n+\n+            // Read the index into a buffer\n+            ByteBuffer ledgersMapBuffer = ByteBuffer.allocate(ledgersMapSize);\n+            bc.read(ledgersMapBuffer, offset + 4);\n+            ledgersMapBuffer.flip();\n+\n+            // Discard ledgerId and entryId\n+            long lid = ledgersMapBuffer.getLong();\n+            if (lid != INVALID_LID) {\n+                throw new IOException(\"Cannot deserialize ledgers map from ledger \" + lid + \" -- entryLogId: \" + entryLogId);\n+            }\n+\n+            long entryId = ledgersMapBuffer.getLong();\n+            if (entryId != LEDGERS_MAP_ENTRY_ID) {\n+                throw new IOException(\"Cannot deserialize ledgers map from ledger \" + lid + \":\" + entryId + \" -- entryLogId: \" + entryLogId);\n+            }\n+\n+            // Read the number of ledgers in the current entry batch\n+            int ledgersCount = ledgersMapBuffer.getInt();\n+\n+            // Extract all (ledger,size) tuples from buffer\n+            for (int i = 0; i < ledgersCount; i++) {\n+                long ledgerId = ledgersMapBuffer.getLong();\n+                long size = ledgersMapBuffer.getLong();\n+\n+                if (LOG.isDebugEnabled()) {\n+                    LOG.debug(\"Recovering ledgers maps for log {} -- Found ledger: {} with size: {}\",\n+                            new Object[] { entryLogId, ledgerId, size });\n+                }\n+                meta.addLedgerSize(ledgerId, size);\n+            }\n+\n+            if (ledgersMapBuffer.hasRemaining()) {\n+                throw new IOException(\"Invalid entry size when reading ledgers map on entryLogId: \" + entryLogId);\n+            }\n+\n+            // Move to next entry, if any\n+            offset += ledgersMapSize + 4;\n+        }\n+\n+        if (meta.getLedgersMap().size() != header.ledgersCount) {\n+            throw new IOException(\"Not all ledgers were found in ledgers map index. expected: \" + header.ledgersCount\n+                    + \" -- found: \" + meta.getLedgersMap().size() + \" -- entryLogId: \" + entryLogId);\n+        }\n+\n+        return meta;\n+    }\n+\n+    private EntryLogMetadata extractEntryLogMetadataByScanning(long entryLogId) throws IOException {\n+        final EntryLogMetadata meta = new EntryLogMetadata(entryLogId);\n+\n+        // Read through the entry log file and extract the entry log meta\n+        scanEntryLog(entryLogId, new EntryLogScanner() {\n+            @Override\n+            public void process(long ledgerId, long offset, ByteBuffer entry) throws IOException {\n+                // add new entry size of a ledger to entry log meta\n+                meta.addLedgerSize(ledgerId, entry.limit() + 4);\n+            }\n+\n+            @Override\n+            public boolean accept(long ledgerId) {\n+                return true;\n+            }\n+        });\n+\n+        LOG.debug(\"Retrieved entry log meta data entryLogId: {}, meta: {}\", entryLogId, meta);\n+        return meta;\n+    }\n+\n     /**\n      * Shutdown method to gracefully stop entry logger.\n      */"},{"sha":"1c9c7e730a46e425e8c1f9180cdb9cb89b06fed2","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/GarbageCollectorThread.java","status":"modified","additions":11,"deletions":99,"changes":110,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/2c567d008c644df5db8c441fb9aaf135ed36db95/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FGarbageCollectorThread.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/2c567d008c644df5db8c441fb9aaf135ed36db95/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FGarbageCollectorThread.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FGarbageCollectorThread.java?ref=2c567d008c644df5db8c441fb9aaf135ed36db95","patch":"@@ -426,7 +426,7 @@ private void doGcEntryLogs() {\n         // Loop through all of the entry logs and remove the non-active ledgers.\n         for (Long entryLogId : entryLogMetaMap.keySet()) {\n             EntryLogMetadata meta = entryLogMetaMap.get(entryLogId);\n-            for (Long entryLogLedger : meta.ledgersMap.keySet()) {\n+            for (Long entryLogLedger : meta.getLedgersMap().keySet()) {\n                 // Remove the entry log ledger from the set if it isn't active.\n                 if (!activeLedgers.containsKey(entryLogLedger)) {\n                     meta.removeLedger(entryLogLedger);\n@@ -457,8 +457,8 @@ void doCompactEntryLogs(double threshold) {\n         Comparator<EntryLogMetadata> sizeComparator = new Comparator<EntryLogMetadata>() {\n             @Override\n             public int compare(EntryLogMetadata m1, EntryLogMetadata m2) {\n-                long unusedSize1 = m1.totalSize - m1.remainingSize;\n-                long unusedSize2 = m2.totalSize - m2.remainingSize;\n+                long unusedSize1 = m1.getTotalSize() - m1.getRemainingSize();\n+                long unusedSize2 = m2.getTotalSize() - m2.getRemainingSize();\n                 if (unusedSize1 > unusedSize2) {\n                     return -1;\n                 } else if (unusedSize1 < unusedSize2) {\n@@ -477,10 +477,13 @@ public int compare(EntryLogMetadata m1, EntryLogMetadata m2) {\n             if (meta.getUsage() >= threshold) {\n                 break;\n             }\n-            LOG.debug(\"Compacting entry log {} below threshold {}.\", meta.entryLogId, threshold);\n+\n+            if (LOG.isDebugEnabled()) {\n+                LOG.debug(\"Compacting entry log {} below threshold {}.\", meta.getEntryLogId(), threshold);\n+            }\n             try {\n                 compactEntryLog(scannerFactory, meta);\n-                toRemove.add(meta.entryLogId);\n+                toRemove.add(meta.getEntryLogId());\n             } catch (LedgerDirsManager.NoWritableLedgerDirException nwlde) {\n                 LOG.warn(\"No writable ledger directory available, aborting compaction\", nwlde);\n                 break;\n@@ -557,97 +560,17 @@ protected void compactEntryLog(CompactionScannerFactory scannerFactory,\n             return;\n         }\n \n-        LOG.info(\"Compacting entry log : {}\", entryLogMeta.entryLogId);\n+        LOG.info(\"Compacting entry log : {}\", entryLogMeta.getEntryLogId());\n \n         try {\n-            entryLogger.scanEntryLog(entryLogMeta.entryLogId,\n+            entryLogger.scanEntryLog(entryLogMeta.getEntryLogId(),\n                                      scannerFactory.newScanner(entryLogMeta));\n         } finally {\n             // clear compacting flag\n             compacting.set(false);\n         }\n     }\n \n-    /**\n-     * Records the total size, remaining size and the set of ledgers that comprise a entry log.\n-     */\n-    static class EntryLogMetadata {\n-        long entryLogId;\n-        long totalSize;\n-        long remainingSize;\n-        ConcurrentHashMap<Long, Long> ledgersMap;\n-\n-        public EntryLogMetadata(long logId) {\n-            this.entryLogId = logId;\n-\n-            totalSize = remainingSize = 0;\n-            ledgersMap = new ConcurrentHashMap<Long, Long>();\n-        }\n-\n-        public void addLedgerSize(long ledgerId, long size) {\n-            totalSize += size;\n-            remainingSize += size;\n-            Long ledgerSize = ledgersMap.get(ledgerId);\n-            if (null == ledgerSize) {\n-                ledgerSize = 0L;\n-            }\n-            ledgerSize += size;\n-            ledgersMap.put(ledgerId, ledgerSize);\n-        }\n-\n-        public void removeLedger(long ledgerId) {\n-            Long size = ledgersMap.remove(ledgerId);\n-            if (null == size) {\n-                return;\n-            }\n-            remainingSize -= size;\n-        }\n-\n-        public boolean containsLedger(long ledgerId) {\n-            return ledgersMap.containsKey(ledgerId);\n-        }\n-\n-        public double getUsage() {\n-            if (totalSize == 0L) {\n-                return 0.0f;\n-            }\n-            return (double)remainingSize / totalSize;\n-        }\n-\n-        public boolean isEmpty() {\n-            return ledgersMap.isEmpty();\n-        }\n-\n-        @Override\n-        public String toString() {\n-            StringBuilder sb = new StringBuilder();\n-            sb.append(\"{ totalSize = \").append(totalSize).append(\", remainingSize = \")\n-              .append(remainingSize).append(\", ledgersMap = \").append(ledgersMap).append(\" }\");\n-            return sb.toString();\n-        }\n-    }\n-\n-    /**\n-     * A scanner used to extract entry log meta from entry log files.\n-     */\n-    static class ExtractionScanner implements EntryLogScanner {\n-        EntryLogMetadata meta;\n-\n-        public ExtractionScanner(EntryLogMetadata meta) {\n-            this.meta = meta;\n-        }\n-\n-        @Override\n-        public boolean accept(long ledgerId) {\n-            return true;\n-        }\n-        @Override\n-        public void process(long ledgerId, long offset, ByteBuffer entry) {\n-            // add new entry size of a ledger to entry log meta\n-            meta.addLedgerSize(ledgerId, entry.limit() + 4);\n-        }\n-    }\n-\n     /**\n      * Method to read in all of the entry logs (those that we haven't done so yet),\n      * and find the set of ledger ID's that make up each entry log file.\n@@ -678,7 +601,7 @@ protected Map<Long, EntryLogMetadata> extractMetaFromEntryLogs(Map<Long, EntryLo\n \n             try {\n                 // Read through the entry log file and extract the entry log meta\n-                EntryLogMetadata entryLogMeta = extractMetaFromEntryLog(entryLogger, entryLogId);\n+                EntryLogMetadata entryLogMeta = entryLogger.getEntryLogMetadata(entryLogId);\n                 entryLogMetaMap.put(entryLogId, entryLogMeta);\n             } catch (IOException e) {\n                 hasExceptionWhenScan = true;\n@@ -695,15 +618,4 @@ protected Map<Long, EntryLogMetadata> extractMetaFromEntryLogs(Map<Long, EntryLo\n         }\n         return entryLogMetaMap;\n     }\n-\n-    static EntryLogMetadata extractMetaFromEntryLog(EntryLogger entryLogger, long entryLogId)\n-            throws IOException {\n-        EntryLogMetadata entryLogMeta = new EntryLogMetadata(entryLogId);\n-        ExtractionScanner scanner = new ExtractionScanner(entryLogMeta);\n-        // Read through the entry log file and extract the entry log meta\n-        entryLogger.scanEntryLog(entryLogId, scanner);\n-        LOG.debug(\"Retrieved entry log meta data entryLogId: {}, meta: {}\",\n-                  entryLogId, entryLogMeta);\n-        return entryLogMeta;\n-    }\n }"},{"sha":"4e1004c9b11944cb1ef2a5b45b579ba882648a87","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/EntryLogTest.java","status":"modified","additions":90,"deletions":10,"changes":100,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/2c567d008c644df5db8c441fb9aaf135ed36db95/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FEntryLogTest.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/2c567d008c644df5db8c441fb9aaf135ed36db95/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FEntryLogTest.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FEntryLogTest.java?ref=2c567d008c644df5db8c441fb9aaf135ed36db95","patch":"@@ -28,8 +28,6 @@\n import java.util.ArrayList;\n import java.util.List;\n \n-import org.apache.bookkeeper.bookie.GarbageCollectorThread.EntryLogMetadata;\n-import org.apache.bookkeeper.bookie.GarbageCollectorThread.ExtractionScanner;\n import org.apache.bookkeeper.conf.ServerConfiguration;\n import org.apache.bookkeeper.conf.TestBKConfiguration;\n import org.apache.bookkeeper.util.IOUtils;\n@@ -86,15 +84,11 @@ public void testCorruptEntryLog() throws Exception {\n         // now see which ledgers are in the log\n         logger = new EntryLogger(conf, bookie.getLedgerDirsManager());\n \n-        EntryLogMetadata meta = new EntryLogMetadata(0L);\n-        ExtractionScanner scanner = new ExtractionScanner(meta);\n-\n-        logger.scanEntryLog(0L, scanner);\n-\n+        EntryLogMetadata meta = logger.getEntryLogMetadata(0L);\n         LOG.info(\"Extracted Meta From Entry Log {}\", meta);\n-        assertNotNull(meta.ledgersMap.get(1L));\n-        assertNull(meta.ledgersMap.get(2L));\n-        assertNotNull(meta.ledgersMap.get(3L));\n+        assertNotNull(meta.getLedgersMap().get(1L));\n+        assertNull(meta.getLedgersMap().get(2L));\n+        assertNotNull(meta.getLedgersMap().get(3L));\n     }\n \n     private ByteBuffer generateEntry(long ledger, long entry) {\n@@ -220,4 +214,90 @@ public void testAddEntryFailureOnDiskFull() throws Exception {\n         Assert.assertTrue(0 == generateEntry(3, 1).compareTo(ledgerStorage.getEntry(3, 1)));\n     }\n \n+    /**\n+     * Explicitely try to recover using the ledgers map index at the end of the entry log\n+     */\n+    @Test(timeout=60000)\n+    public void testRecoverFromLedgersMap() throws Exception {\n+        File tmpDir = createTempDir(\"bkTest\", \".dir\");\n+        File curDir = Bookie.getCurrentDirectory(tmpDir);\n+        Bookie.checkDirectoryStructure(curDir);\n+\n+        int gcWaitTime = 1000;\n+        ServerConfiguration conf = TestBKConfiguration.newServerConfiguration();\n+        conf.setGcWaitTime(gcWaitTime);\n+        conf.setLedgerDirNames(new String[] {tmpDir.toString()});\n+        Bookie bookie = new Bookie(conf);\n+\n+        // create some entries\n+        EntryLogger logger = ((InterleavedLedgerStorage)bookie.ledgerStorage).entryLogger;\n+        logger.addEntry(1, generateEntry(1, 1));\n+        logger.addEntry(3, generateEntry(3, 1));\n+        logger.addEntry(2, generateEntry(2, 1));\n+        logger.addEntry(1, generateEntry(1, 2));\n+        logger.rollLog();\n+        logger.flushRotatedLogs();\n+\n+        EntryLogMetadata meta = logger.extractEntryLogMetadataFromIndex(0L);\n+        LOG.info(\"Extracted Meta From Entry Log {}\", meta);\n+        assertEquals(60, meta.getLedgersMap().get(1L).longValue());\n+        assertEquals(30, meta.getLedgersMap().get(2L).longValue());\n+        assertEquals(30, meta.getLedgersMap().get(3L).longValue());\n+        assertNull(meta.getLedgersMap().get(4L));\n+        assertEquals(120, meta.getTotalSize());\n+        assertEquals(120, meta.getRemainingSize());\n+    }\n+\n+    /**\n+     * Explicitely try to recover using the ledgers map index at the end of the entry log\n+     */\n+    @Test(timeout = 60000)\n+    public void testRecoverFromLedgersMapOnV0EntryLog() throws Exception {\n+        File tmpDir = createTempDir(\"bkTest\", \".dir\");\n+        File curDir = Bookie.getCurrentDirectory(tmpDir);\n+        Bookie.checkDirectoryStructure(curDir);\n+\n+        int gcWaitTime = 1000;\n+        ServerConfiguration conf = TestBKConfiguration.newServerConfiguration();\n+        conf.setGcWaitTime(gcWaitTime);\n+        conf.setLedgerDirNames(new String[] { tmpDir.toString() });\n+        Bookie bookie = new Bookie(conf);\n+\n+        // create some entries\n+        EntryLogger logger = ((InterleavedLedgerStorage) bookie.ledgerStorage).entryLogger;\n+        logger.addEntry(1, generateEntry(1, 1));\n+        logger.addEntry(3, generateEntry(3, 1));\n+        logger.addEntry(2, generateEntry(2, 1));\n+        logger.addEntry(1, generateEntry(1, 2));\n+        logger.rollLog();\n+\n+        // Rewrite the entry log header to be on V0 format\n+        File f = new File(curDir, \"0.log\");\n+        RandomAccessFile raf = new RandomAccessFile(f, \"rw\");\n+        raf.seek(EntryLogger.HEADER_VERSION_POSITION);\n+        // Write zeros to indicate V0 + no ledgers map info\n+        raf.write(new byte[4 + 8]);\n+        raf.close();\n+\n+        // now see which ledgers are in the log\n+        logger = new EntryLogger(conf, bookie.getLedgerDirsManager());\n+\n+        try {\n+            logger.extractEntryLogMetadataFromIndex(0L);\n+            fail(\"Should not be possible to recover from ledgers map index\");\n+        } catch (IOException e) {\n+            // Ok\n+        }\n+\n+        // Public method should succeed by falling back to scanning the file\n+        EntryLogMetadata meta = logger.getEntryLogMetadata(0L);\n+        LOG.info(\"Extracted Meta From Entry Log {}\", meta);\n+        assertEquals(60, meta.getLedgersMap().get(1L).longValue());\n+        assertEquals(30, meta.getLedgersMap().get(2L).longValue());\n+        assertEquals(30, meta.getLedgersMap().get(3L).longValue());\n+        assertNull(meta.getLedgersMap().get(4L));\n+        assertEquals(120, meta.getTotalSize());\n+        assertEquals(120, meta.getRemainingSize());\n+    }\n+\n }"}]}