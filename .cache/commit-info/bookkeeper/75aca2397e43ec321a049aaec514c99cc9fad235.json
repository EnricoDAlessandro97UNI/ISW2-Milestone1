{"sha":"75aca2397e43ec321a049aaec514c99cc9fad235","node_id":"MDY6Q29tbWl0NDc4NTkyNTI2Ojc1YWNhMjM5N2U0M2VjMzIxYTA0OWFhZWM1MTRjOTljYzlmYWQyMzU=","commit":{"author":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2017-06-29T21:57:16Z"},"committer":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2017-06-29T21:57:16Z"},"message":"ISSUE #207: change the HashSet to BitSet to handle duplicated bookies on reading entries\n\nDescriptions of the changes in this PR:\n\nProblem:\n\nIf there happens to have duplicated bookies in same ledger (it happened before when ensemble change still has problem), the read doesn't work as expected. It hang forever.\n\nSolution:\n\nChange the HashSet to BitSet to use bookieIndex rather than InetSocketAddress to track the heardfrom bookies set.\n\n---\nBe sure to do all of the following to help us incorporate your contribution\nquickly and easily:\n\n- [x] Make sure the PR title is formatted like:\n    `<Issue #>: Description of pull request`\n    `e.g. Issue 123: Description ...`\n- [x] Make sure tests pass via `mvn clean apache-rat:check install findbugs:check`.\n- [x] Replace `<Issue #>` in the title with the actual Issue number, if there is one.\n\n---\n\nAuthor: Sijie Guo <sijie@apache.org>\nAuthor: Sijie Guo <sijieg@twitter.com>\n\nReviewers: Enrico Olivelli <eolivelli@gmail.com>, Jia Zhai <None>, Matteo Merli <mmerli@apache.org>\n\nThis closes #199 from sijie/client_changes/bitset, closes #207","tree":{"sha":"fb90aa85f5feddd2e5e0a1f05e7e00d3ad9f7e30","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/trees/fb90aa85f5feddd2e5e0a1f05e7e00d3ad9f7e30"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/commits/75aca2397e43ec321a049aaec514c99cc9fad235","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/75aca2397e43ec321a049aaec514c99cc9fad235","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/75aca2397e43ec321a049aaec514c99cc9fad235","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/75aca2397e43ec321a049aaec514c99cc9fad235/comments","author":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"committer":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"parents":[{"sha":"b9648998802ce4bf256e33ffd6296b4c973a4824","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/b9648998802ce4bf256e33ffd6296b4c973a4824","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/b9648998802ce4bf256e33ffd6296b4c973a4824"}],"stats":{"total":197,"additions":146,"deletions":51},"files":[{"sha":"0dd1f674cd8ceb116fc545d6e31e556ce5b8fb52","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingReadOp.java","status":"modified","additions":41,"deletions":42,"changes":83,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/75aca2397e43ec321a049aaec514c99cc9fad235/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FPendingReadOp.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/75aca2397e43ec321a049aaec514c99cc9fad235/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FPendingReadOp.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FPendingReadOp.java?ref=75aca2397e43ec321a049aaec514c99cc9fad235","patch":"@@ -62,6 +62,7 @@ class PendingReadOp implements Enumeration<LedgerEntry>, ReadEntryCallback {\n     private ScheduledFuture<?> speculativeTask = null;\n     Queue<LedgerEntryRequest> seq;\n     Set<BookieSocketAddress> heardFromHosts;\n+    BitSet heardFromHostsBitSet;\n     ReadCallback cb;\n     Object ctx;\n     LedgerHandle lh;\n@@ -101,19 +102,21 @@ abstract class LedgerEntryRequest extends LedgerEntry {\n         /**\n          * Complete the read request from <i>host</i>.\n          *\n+         * @param bookieIndex\n+         *          bookie index\n          * @param host\n          *          host that respond the read\n          * @param buffer\n          *          the data buffer\n          * @return return true if we managed to complete the entry;\n          *         otherwise return false if the read entry is not complete or it is already completed before\n          */\n-        boolean complete(BookieSocketAddress host, final ByteBuf buffer) {\n+        boolean complete(int bookieIndex, BookieSocketAddress host, final ByteBuf buffer) {\n             ByteBuf content;\n             try {\n                 content = lh.macManager.verifyDigestAndReturnData(entryId, buffer);\n             } catch (BKDigestMatchException e) {\n-                logErrorAndReattemptRead(host, \"Mac mismatch\", BKException.Code.DigestMatchException);\n+                logErrorAndReattemptRead(bookieIndex, host, \"Mac mismatch\", BKException.Code.DigestMatchException);\n                 buffer.release();\n                 return false;\n             }\n@@ -153,14 +156,16 @@ boolean fail(int rc) {\n         /**\n          * Log error <i>errMsg</i> and reattempt read from <i>host</i>.\n          *\n+         * @param bookieIndex\n+         *          bookie index\n          * @param host\n          *          host that just respond\n          * @param errMsg\n          *          error msg to log\n          * @param rc\n          *          read result code\n          */\n-        synchronized void logErrorAndReattemptRead(BookieSocketAddress host, String errMsg, int rc) {\n+        synchronized void logErrorAndReattemptRead(int bookieIndex, BookieSocketAddress host, String errMsg, int rc) {\n             if (BKException.Code.OK == firstError ||\n                 BKException.Code.NoSuchEntryException == firstError ||\n                 BKException.Code.NoSuchLedgerExistsException == firstError) {\n@@ -192,11 +197,11 @@ synchronized void logErrorAndReattemptRead(BookieSocketAddress host, String errM\n          * Send to next replica speculatively, if required and possible.\n          * This returns the host we may have sent to for unit testing.\n          *\n-         * @param heardFromHosts\n+         * @param heardFromHostsBitSet\n          *      the set of hosts that we already received responses.\n          * @return host we sent to if we sent. null otherwise.\n          */\n-        abstract BookieSocketAddress maybeSendSpeculativeRead(Set<BookieSocketAddress> heardFromHosts);\n+        abstract BookieSocketAddress maybeSendSpeculativeRead(BitSet heardFromHostsBitSet);\n \n         /**\n          * Whether the read request completed.\n@@ -220,6 +225,7 @@ int getRc() {\n         public String toString() {\n             return String.format(\"L%d-E%d\", ledgerId, entryId);\n         }\n+\n     }\n \n     class ParallelReadRequest extends LedgerEntryRequest {\n@@ -236,7 +242,7 @@ void read() {\n             for (int bookieIndex : writeSet) {\n                 BookieSocketAddress to = ensemble.get(bookieIndex);\n                 try {\n-                    sendReadTo(to, this);\n+                    sendReadTo(bookieIndex, to, this);\n                 } catch (InterruptedException ie) {\n                     LOG.error(\"Interrupted reading entry {} : \", this, ie);\n                     Thread.currentThread().interrupt();\n@@ -247,8 +253,8 @@ void read() {\n         }\n \n         @Override\n-        synchronized void logErrorAndReattemptRead(BookieSocketAddress host, String errMsg, int rc) {\n-            super.logErrorAndReattemptRead(host, errMsg, rc);\n+        synchronized void logErrorAndReattemptRead(int bookieIndex, BookieSocketAddress host, String errMsg, int rc) {\n+            super.logErrorAndReattemptRead(bookieIndex, host, errMsg, rc);\n             --numPendings;\n             // if received all responses or this entry doesn't meet quorum write, complete the request.\n             if (numMissedEntryReads > maxMissedReadsAllowed || numPendings == 0) {\n@@ -262,7 +268,7 @@ synchronized void logErrorAndReattemptRead(BookieSocketAddress host, String errM\n         }\n \n         @Override\n-        BookieSocketAddress maybeSendSpeculativeRead(Set<BookieSocketAddress> heardFromHosts) {\n+        BookieSocketAddress maybeSendSpeculativeRead(BitSet heardFromHostsBitSet) {\n             // no speculative read\n             return null;\n         }\n@@ -282,11 +288,11 @@ class SequenceReadRequest extends LedgerEntryRequest {\n             this.erroredReplicas = new BitSet(lh.getLedgerMetadata().getWriteQuorumSize());\n         }\n \n-        private int getReplicaIndex(BookieSocketAddress host) {\n-            int bookieIndex = ensemble.indexOf(host);\n-            if (bookieIndex == -1) {\n-                return NOT_FOUND;\n-            }\n+        private synchronized int getNextReplicaIndexToReadFrom() {\n+            return nextReplicaIndexToReadFrom;\n+        }\n+\n+        private int getReplicaIndex(int bookieIndex) {\n             return writeSet.indexOf(bookieIndex);\n         }\n \n@@ -301,17 +307,6 @@ private BitSet getSentToBitSet() {\n             return b;\n         }\n \n-        private BitSet getHeardFromBitSet(Set<BookieSocketAddress> heardFromHosts) {\n-            BitSet b = new BitSet(ensemble.size());\n-            for (BookieSocketAddress i : heardFromHosts) {\n-                int index = ensemble.indexOf(i);\n-                if (index != -1) {\n-                    b.set(index);\n-                }\n-            }\n-            return b;\n-        }\n-\n         private boolean readsOutstanding() {\n             return (sentReplicas.cardinality() - erroredReplicas.cardinality()) > 0;\n         }\n@@ -322,13 +317,12 @@ private boolean readsOutstanding() {\n          * @return host we sent to if we sent. null otherwise.\n          */\n         @Override\n-        synchronized BookieSocketAddress maybeSendSpeculativeRead(Set<BookieSocketAddress> heardFromHosts) {\n+        synchronized BookieSocketAddress maybeSendSpeculativeRead(BitSet heardFrom) {\n             if (nextReplicaIndexToReadFrom >= getLedgerMetadata().getWriteQuorumSize()) {\n                 return null;\n             }\n \n             BitSet sentTo = getSentToBitSet();\n-            BitSet heardFrom = getHeardFromBitSet(heardFromHosts);\n             sentTo.and(heardFrom);\n \n             // only send another read, if we have had no response at all (even for other entries)\n@@ -367,7 +361,7 @@ synchronized BookieSocketAddress sendNextRead() {\n \n             try {\n                 BookieSocketAddress to = ensemble.get(bookieIndex);\n-                sendReadTo(to, this);\n+                sendReadTo(bookieIndex, to, this);\n                 sentReplicas.set(replica);\n                 return to;\n             } catch (InterruptedException ie) {\n@@ -379,10 +373,10 @@ synchronized BookieSocketAddress sendNextRead() {\n         }\n \n         @Override\n-        synchronized void logErrorAndReattemptRead(BookieSocketAddress host, String errMsg, int rc) {\n-            super.logErrorAndReattemptRead(host, errMsg, rc);\n+        synchronized void logErrorAndReattemptRead(int bookieIndex, BookieSocketAddress host, String errMsg, int rc) {\n+            super.logErrorAndReattemptRead(bookieIndex, host, errMsg, rc);\n \n-            int replica = getReplicaIndex(host);\n+            int replica = getReplicaIndex(bookieIndex);\n             if (replica == NOT_FOUND) {\n                 LOG.error(\"Received error from a host which is not in the ensemble {} {}.\", host, ensemble);\n                 return;\n@@ -393,6 +387,7 @@ synchronized void logErrorAndReattemptRead(BookieSocketAddress host, String errM\n                 sendNextRead();\n             }\n         }\n+\n     }\n \n     PendingReadOp(LedgerHandle lh, ScheduledExecutorService scheduler,\n@@ -408,7 +403,8 @@ synchronized void logErrorAndReattemptRead(BookieSocketAddress host, String errM\n         maxMissedReadsAllowed = getLedgerMetadata().getWriteQuorumSize()\n                 - getLedgerMetadata().getAckQuorumSize();\n         speculativeReadTimeout = lh.bk.getConf().getSpeculativeReadTimeout();\n-        heardFromHosts = new HashSet<BookieSocketAddress>();\n+        heardFromHosts = new HashSet<>();\n+        heardFromHostsBitSet = new BitSet(getLedgerMetadata().getEnsembleSize());\n \n         readOpLogger = lh.bk.getReadOpLogger();\n     }\n@@ -440,12 +436,12 @@ public void run() {\n                     int x = 0;\n                     for (LedgerEntryRequest r : seq) {\n                         if (!r.isComplete()) {\n-                            if (null == r.maybeSendSpeculativeRead(heardFromHosts)) {\n+                            if (null == r.maybeSendSpeculativeRead(heardFromHostsBitSet)) {\n                                 // Subsequent speculative read will not materialize anyway\n                                 cancelSpeculativeTask(false);\n                             } else {\n                                 if (LOG.isDebugEnabled()) {\n-                                    LOG.debug(\"Send speculative read for {}. Hosts heard are {}.\", r, heardFromHosts);\n+                                    LOG.debug(\"Send speculative read for {}. Hosts heard are {}.\", r, heardFromHostsBitSet);\n                                 }\n                                 ++x;\n                             }\n@@ -454,7 +450,7 @@ public void run() {\n                     if (x > 0) {\n                         if (LOG.isDebugEnabled()) {\n                             LOG.debug(\"Send {} speculative reads for ledger {} ({}, {}). Hosts heard are {}.\",\n-                                    new Object[] { x, lh.getId(), startEntryId, endEntryId, heardFromHosts });\n+                                    new Object[] { x, lh.getId(), startEntryId, endEntryId, heardFromHostsBitSet });\n                         }\n                     }\n                 }\n@@ -491,11 +487,13 @@ public void run() {\n     }\n \n     private static class ReadContext implements ReadEntryCallbackCtx {\n+        final int bookieIndex;\n         final BookieSocketAddress to;\n         final LedgerEntryRequest entry;\n         long lac = LedgerHandle.INVALID_ENTRY_ID;\n \n-        ReadContext(BookieSocketAddress to, LedgerEntryRequest entry) {\n+        ReadContext(int bookieIndex, BookieSocketAddress to, LedgerEntryRequest entry) {\n+            this.bookieIndex = bookieIndex;\n             this.to = to;\n             this.entry = entry;\n         }\n@@ -511,13 +509,13 @@ public long getLastAddConfirmed() {\n         }\n     }\n \n-    void sendReadTo(BookieSocketAddress to, LedgerEntryRequest entry) throws InterruptedException {\n+    void sendReadTo(int bookieIndex, BookieSocketAddress to, LedgerEntryRequest entry) throws InterruptedException {\n         if (lh.throttler != null) {\n             lh.throttler.acquire();\n         }\n \n         lh.bk.bookieClient.readEntry(to, lh.ledgerId, entry.entryId,\n-                                     this, new ReadContext(to, entry));\n+                                     this, new ReadContext(bookieIndex, to, entry));\n     }\n \n     @Override\n@@ -526,13 +524,14 @@ public void readEntryComplete(int rc, long ledgerId, final long entryId, final B\n         final LedgerEntryRequest entry = rctx.entry;\n \n         if (rc != BKException.Code.OK) {\n-            entry.logErrorAndReattemptRead(rctx.to, \"Error: \" + BKException.getMessage(rc), rc);\n+            entry.logErrorAndReattemptRead(rctx.bookieIndex, rctx.to, \"Error: \" + BKException.getMessage(rc), rc);\n             return;\n         }\n \n         heardFromHosts.add(rctx.to);\n+        heardFromHostsBitSet.set(rctx.bookieIndex, true);\n \n-        if (entry.complete(rctx.to, buffer)) {\n+        if (entry.complete(rctx.bookieIndex, rctx.to, buffer)) {\n             lh.updateLastConfirmed(rctx.getLastAddConfirmed(), 0L);\n             submitCallback(BKException.Code.OK);\n         }\n@@ -564,8 +563,8 @@ protected void submitCallback(int code) {\n                     break;\n                 }\n             }\n-            LOG.error(\"Read of ledger entry failed: L{} E{}-E{}, Heard from {}. First unread entry is {}\",\n-                    new Object[] { lh.getId(), startEntryId, endEntryId, heardFromHosts, firstUnread });\n+            LOG.error(\"Read of ledger entry failed: L{} E{}-E{}, Heard from {} : bitset = {}. First unread entry is {}\",\n+                    new Object[] { lh.getId(), startEntryId, endEntryId, heardFromHosts, heardFromHostsBitSet, firstUnread });\n             readOpLogger.registerFailedEvent(latencyNanos, TimeUnit.NANOSECONDS);\n         } else {\n             readOpLogger.registerSuccessfulEvent(latencyNanos, TimeUnit.NANOSECONDS);"},{"sha":"5b035b7697e0527d4ca55dfbc152a660a6ad2e80","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestSequenceRead.java","status":"added","additions":94,"deletions":0,"changes":94,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/75aca2397e43ec321a049aaec514c99cc9fad235/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FTestSequenceRead.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/75aca2397e43ec321a049aaec514c99cc9fad235/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FTestSequenceRead.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FTestSequenceRead.java?ref=75aca2397e43ec321a049aaec514c99cc9fad235","patch":"@@ -0,0 +1,94 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.client;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+import java.util.ArrayList;\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+import org.apache.bookkeeper.client.BookKeeper.DigestType;\n+import org.apache.bookkeeper.net.BookieSocketAddress;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks;\n+import org.apache.bookkeeper.test.BookKeeperClusterTestCase;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Map;\n+import java.util.concurrent.CountDownLatch;\n+\n+/**\n+ * Test reading an entry from replicas in sequence way.\n+ */\n+public class TestSequenceRead extends BookKeeperClusterTestCase {\n+\n+    static final Logger logger = LoggerFactory.getLogger(TestSequenceRead.class);\n+\n+    final DigestType digestType;\n+    final byte[] passwd = \"sequence-read\".getBytes();\n+\n+    public TestSequenceRead() {\n+        super(5);\n+        this.digestType = DigestType.CRC32;\n+    }\n+\n+    private LedgerHandle createLedgerWithDuplicatedBookies() throws Exception {\n+        final LedgerHandle lh = bkc.createLedger(3, 3, 3, digestType, passwd);\n+        // introduce duplicated bookies in an ensemble.\n+        SortedMap<Long, ArrayList<BookieSocketAddress>> ensembles = lh.getLedgerMetadata().getEnsembles();\n+        SortedMap<Long, ArrayList<BookieSocketAddress>> newEnsembles = new TreeMap<Long, ArrayList<BookieSocketAddress>>();\n+        for (Map.Entry<Long, ArrayList<BookieSocketAddress>> entry : ensembles.entrySet()) {\n+            ArrayList<BookieSocketAddress> newList = new ArrayList<BookieSocketAddress>(entry.getValue().size());\n+            BookieSocketAddress firstBookie = entry.getValue().get(0);\n+            for (BookieSocketAddress ignored : entry.getValue()) {\n+                newList.add(firstBookie);\n+            }\n+            newEnsembles.put(entry.getKey(), newList);\n+        }\n+        lh.getLedgerMetadata().setEnsembles(newEnsembles);\n+        // update the ledger metadata with duplicated bookies\n+        final CountDownLatch latch = new CountDownLatch(1);\n+        bkc.getLedgerManager().writeLedgerMetadata(lh.getId(), lh.getLedgerMetadata(), new BookkeeperInternalCallbacks.GenericCallback<Void>() {\n+            @Override\n+            public void operationComplete(int rc, Void result) {\n+                if (BKException.Code.OK == rc) {\n+                    latch.countDown();\n+                } else {\n+                    logger.error(\"Error on writing ledger metadata for ledger {} : \", lh.getId(), BKException.getMessage(rc));\n+                }\n+            }\n+        });\n+        latch.await();\n+        logger.info(\"Update ledger metadata with duplicated bookies for ledger {}.\", lh.getId());\n+        return lh;\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testSequenceReadOnDuplicatedBookies() throws Exception {\n+        final LedgerHandle lh = createLedgerWithDuplicatedBookies();\n+\n+        // should be able to open the ledger even it has duplicated bookies\n+        final LedgerHandle readLh = bkc.openLedger(lh.getId(), digestType, passwd);\n+        assertEquals(LedgerHandle.INVALID_ENTRY_ID, readLh.getLastAddConfirmed());\n+    }\n+\n+}"},{"sha":"c0b8e498909167cf657ee2d9241a2a9e003d7ed5","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestSpeculativeRead.java","status":"modified","additions":11,"deletions":9,"changes":20,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/75aca2397e43ec321a049aaec514c99cc9fad235/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FTestSpeculativeRead.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/75aca2397e43ec321a049aaec514c99cc9fad235/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FTestSpeculativeRead.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FTestSpeculativeRead.java?ref=75aca2397e43ec321a049aaec514c99cc9fad235","patch":"@@ -1,5 +1,3 @@\n-package org.apache.bookkeeper.client;\n-\n /*\n  *\n  * Licensed to the Apache Software Foundation (ASF) under one\n@@ -20,19 +18,20 @@\n  * under the License.\n  *\n  */\n+package org.apache.bookkeeper.client;\n \n import java.util.ArrayList;\n+import java.util.BitSet;\n import java.util.Enumeration;\n-import java.util.HashSet;\n-import java.util.Set;\n import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.TimeUnit;\n \n+import org.apache.bookkeeper.conf.ClientConfiguration;\n import org.apache.bookkeeper.client.AsyncCallback.ReadCallback;\n import org.apache.bookkeeper.client.BookKeeper.DigestType;\n-import org.apache.bookkeeper.conf.ClientConfiguration;\n import org.apache.bookkeeper.net.BookieSocketAddress;\n import org.apache.bookkeeper.test.BaseTestCase;\n+\n import org.junit.Test;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -286,10 +285,13 @@ public void testSpeculativeReadScheduling() throws Exception {\n         LedgerHandle l = bkspec.openLedger(id, digestType, passwd);\n \n         ArrayList<BookieSocketAddress> ensemble = l.getLedgerMetadata().getEnsembles().get(0L);\n-        Set<BookieSocketAddress> allHosts = new HashSet<BookieSocketAddress>(ensemble);\n-        Set<BookieSocketAddress> noHost = new HashSet<BookieSocketAddress>();\n-        Set<BookieSocketAddress> secondHostOnly = new HashSet<BookieSocketAddress>();\n-        secondHostOnly.add(ensemble.get(1));\n+        BitSet allHosts = new BitSet(ensemble.size());\n+        for (int i = 0; i < ensemble.size(); i++) {\n+            allHosts.set(i, true);\n+        }\n+        BitSet noHost = new BitSet(ensemble.size());\n+        BitSet secondHostOnly = new BitSet(ensemble.size());\n+        secondHostOnly.set(1, true);\n         PendingReadOp.LedgerEntryRequest req0 = null, req2 = null, req4 = null;\n         try {\n             LatchCallback latch0 = new LatchCallback();"}]}