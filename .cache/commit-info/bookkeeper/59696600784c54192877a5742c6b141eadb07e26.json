{"sha":"59696600784c54192877a5742c6b141eadb07e26","node_id":"MDY6Q29tbWl0NDc4NTkyNTI2OjU5Njk2NjAwNzg0YzU0MTkyODc3YTU3NDJjNmIxNDFlYWRiMDdlMjY=","commit":{"author":{"name":"Charan Reddy Guttapalem","email":"cguttapalem@salesforce.com","date":"2017-06-21T19:07:39Z"},"committer":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2017-06-21T19:07:39Z"},"message":"BOOKKEEPER-1097: GC test when no WritableDirs\n\n- Functional test validating that Compaction takes place even if there\nare no writableledgerdir but there are ledgerdirs according to\nLedgerDirsManager.getWritableLedgerDirsForNewLog\n\n- end-to-end testcase of Bookie recovery, incase of Bookie ledgerdir reaching\nthe threshold, and recovering by forcing the gc/compaction\n\nAuthor: Charan Reddy Guttapalem <cguttapalem@salesforce.com>\n\nReviewers: Enrico Olivelli <eolivelli@gmail.com>, Jia Zhai <None>, Sijie Guo <sijie@apache.org>\n\nThis closes #188 from reddycharan/gctestnowritabledirs","tree":{"sha":"753eadebb59cadf66b45def09b9da9c21bf5221e","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/trees/753eadebb59cadf66b45def09b9da9c21bf5221e"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/commits/59696600784c54192877a5742c6b141eadb07e26","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/59696600784c54192877a5742c6b141eadb07e26","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/59696600784c54192877a5742c6b141eadb07e26","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/59696600784c54192877a5742c6b141eadb07e26/comments","author":{"login":"reddycharan","id":13989266,"node_id":"MDQ6VXNlcjEzOTg5MjY2","avatar_url":"https://avatars.githubusercontent.com/u/13989266?v=4","gravatar_id":"","url":"https://api.github.com/users/reddycharan","html_url":"https://github.com/reddycharan","followers_url":"https://api.github.com/users/reddycharan/followers","following_url":"https://api.github.com/users/reddycharan/following{/other_user}","gists_url":"https://api.github.com/users/reddycharan/gists{/gist_id}","starred_url":"https://api.github.com/users/reddycharan/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/reddycharan/subscriptions","organizations_url":"https://api.github.com/users/reddycharan/orgs","repos_url":"https://api.github.com/users/reddycharan/repos","events_url":"https://api.github.com/users/reddycharan/events{/privacy}","received_events_url":"https://api.github.com/users/reddycharan/received_events","type":"User","site_admin":false},"committer":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"parents":[{"sha":"256e7587331eddd51b7c05f27717c9d4dc848500","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/256e7587331eddd51b7c05f27717c9d4dc848500","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/256e7587331eddd51b7c05f27717c9d4dc848500"}],"stats":{"total":369,"additions":367,"deletions":2},"files":[{"sha":"c63333f43b65225b3dbcf95853f65f6687d2616d","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/59696600784c54192877a5742c6b141eadb07e26/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FBookie.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/59696600784c54192877a5742c6b141eadb07e26/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FBookie.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FBookie.java?ref=59696600784c54192877a5742c6b141eadb07e26","patch":"@@ -128,8 +128,8 @@ public class Bookie extends BookieCriticalThread {\n     private final LedgerDirsManager ledgerDirsManager;\n     private LedgerDirsManager indexDirsManager;\n     \n-    private final LedgerDirsMonitor ledgerMonitor;\n-    private final LedgerDirsMonitor idxMonitor;\n+    LedgerDirsMonitor ledgerMonitor;\n+    LedgerDirsMonitor idxMonitor;\n \n     // ZooKeeper client instance for the Bookie\n     ZooKeeper zk;"},{"sha":"e9dd6ab2357517f215eaf72662155933f242b16c","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/BookieStorageThresholdTest.java","status":"added","additions":255,"deletions":0,"changes":255,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/59696600784c54192877a5742c6b141eadb07e26/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FBookieStorageThresholdTest.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/59696600784c54192877a5742c6b141eadb07e26/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FBookieStorageThresholdTest.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FBookieStorageThresholdTest.java?ref=59696600784c54192877a5742c6b141eadb07e26","patch":"@@ -0,0 +1,255 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+\n+package org.apache.bookkeeper.bookie;\n+\n+import static org.junit.Assert.*;\n+\n+import java.io.File;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.apache.bookkeeper.bookie.LedgerDirsManager.LedgerDirsListener;\n+import org.apache.bookkeeper.bookie.LedgerDirsManager.NoWritableLedgerDirException;\n+import org.apache.bookkeeper.client.BookKeeper.DigestType;\n+import org.apache.bookkeeper.client.LedgerHandle;\n+import org.apache.bookkeeper.test.BookKeeperClusterTestCase;\n+import org.apache.bookkeeper.util.DiskChecker;\n+import org.apache.bookkeeper.util.TestUtils;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class BookieStorageThresholdTest extends BookKeeperClusterTestCase {\n+\n+    static int NUM_BOOKIES = 1;\n+    static int NUM_ENTRIES = 100;\n+    static int ENTRY_SIZE = 1024;\n+\n+    final String msg;\n+    DigestType digestType = DigestType.CRC32;\n+\n+    public BookieStorageThresholdTest() {\n+        super(NUM_BOOKIES);\n+        // a dummy message\n+        StringBuilder msgSB = new StringBuilder();\n+        for (int i = 0; i < ENTRY_SIZE; i++) {\n+            msgSB.append(\"a\");\n+        }\n+        msg = msgSB.toString();\n+    }\n+\n+    @Before\n+    @Override\n+    public void setUp() throws Exception {\n+        // Set up the configuration properties needed.\n+        baseConf.setEntryLogSizeLimit(NUM_ENTRIES * ENTRY_SIZE);\n+        baseConf.setFlushInterval(500);\n+        // setting very high intervals for GC intervals, so GC/compaction is not invoked by regular scheduler\n+        baseConf.setGcWaitTime(60000);\n+        baseConf.setMinorCompactionInterval(600000);\n+        baseConf.setMajorCompactionInterval(700000);\n+        baseConf.setEntryLogFilePreAllocationEnabled(false);\n+        baseConf.setLedgerStorageClass(InterleavedLedgerStorage.class.getName());\n+        // set isForceGCAllowWhenNoSpace to true, which will forceGC when a disk is full (or when all disks are full)\n+        baseConf.setIsForceGCAllowWhenNoSpace(true);\n+        // keep some lower value for DiskCheckInterval, so DiskChecker checks quite often\n+        baseConf.setDiskCheckInterval(3000);\n+\n+        super.setUp();\n+    }\n+\n+    LedgerHandle[] prepareData(int numEntryLogs) throws Exception {\n+        // since an entry log file can hold at most 100 entries\n+        // first ledger write 2 entries, which is less than low water mark\n+        int num1 = 2;\n+        // third ledger write more than high water mark entries\n+        int num3 = (int) (NUM_ENTRIES * 0.7f);\n+        // second ledger write remaining entries, which is higher than low water\n+        // mark and less than high water mark\n+        int num2 = NUM_ENTRIES - num3 - num1;\n+\n+        LedgerHandle[] lhs = new LedgerHandle[3];\n+        for (int i = 0; i < 3; ++i) {\n+            lhs[i] = bkc.createLedger(NUM_BOOKIES, NUM_BOOKIES, digestType, \"\".getBytes());\n+        }\n+\n+        for (int n = 0; n < numEntryLogs; n++) {\n+            for (int k = 0; k < num1; k++) {\n+                lhs[0].addEntry(msg.getBytes());\n+            }\n+            for (int k = 0; k < num2; k++) {\n+                lhs[1].addEntry(msg.getBytes());\n+            }\n+            for (int k = 0; k < num3; k++) {\n+                lhs[2].addEntry(msg.getBytes());\n+            }\n+        }\n+\n+        return lhs;\n+    }\n+\n+    public class ThresholdTestDiskChecker extends DiskChecker {\n+\n+        final AtomicBoolean injectDiskOutOfSpaceException;\n+\n+        public ThresholdTestDiskChecker(float threshold, float warnThreshold) {\n+            super(threshold, warnThreshold);\n+            injectDiskOutOfSpaceException = new AtomicBoolean();\n+        }\n+\n+        public void setInjectDiskOutOfSpaceException(boolean setValue) {\n+            injectDiskOutOfSpaceException.set(setValue);\n+        }\n+\n+        @Override\n+        public float checkDir(File dir) throws DiskErrorException, DiskOutOfSpaceException, DiskWarnThresholdException {\n+            if (injectDiskOutOfSpaceException.get()) {\n+                throw new DiskOutOfSpaceException(\"Injected DiskOutOfSpaceException\",\n+                        baseConf.getDiskUsageThreshold() + 2);\n+            }\n+            return super.checkDir(dir);\n+        }\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testStorageThresholdCompaction() throws Exception {\n+\n+        // We are having BKCluster with just one bookie (NUM_BOOKIES = 1).\n+        Bookie bookie = bs.get(0).getBookie();\n+        // since we are going to set dependency injected ledgermonitor, so we need to shutdown\n+        // the ledgermonitor which was created as part of the initialization of Bookie\n+        bookie.ledgerMonitor.shutdown();\n+\n+        LedgerDirsManager ledgerDirsManager = bookie.getLedgerDirsManager();\n+\n+        // flag latches\n+        final CountDownLatch diskWritable = new CountDownLatch(1);\n+        final CountDownLatch diskFull = new CountDownLatch(1);\n+        ledgerDirsManager.addLedgerDirsListener(new LedgerDirsListener() {\n+            @Override\n+            public void fatalError() {\n+            }\n+\n+            @Override\n+            public void diskWritable(File disk) {\n+                diskWritable.countDown();\n+            }\n+\n+            @Override\n+            public void diskJustWritable(File disk) {\n+            }\n+\n+            @Override\n+            public void diskFull(File disk) {\n+                diskFull.countDown();\n+            }\n+\n+            @Override\n+            public void diskFailed(File disk) {\n+            }\n+\n+            @Override\n+            public void diskAlmostFull(File disk) {\n+            }\n+\n+            @Override\n+            public void allDisksFull() {\n+            }\n+        });\n+\n+        // Dependency Injected class\n+        ThresholdTestDiskChecker thresholdTestDiskChecker = new ThresholdTestDiskChecker(\n+                baseConf.getDiskUsageThreshold(), baseConf.getDiskUsageWarnThreshold());\n+        LedgerDirsMonitor ledgerDirsMonitor = new LedgerDirsMonitor(baseConf, thresholdTestDiskChecker,\n+                ledgerDirsManager);\n+        // set the ledgermonitor and idxmonitor and initiate/start it\n+        bookie.ledgerMonitor = ledgerDirsMonitor;\n+        bookie.idxMonitor = ledgerDirsMonitor;\n+        bookie.ledgerMonitor.init();\n+        bookie.ledgerMonitor.start();\n+\n+        // create ledgers and add fragments\n+        LedgerHandle[] lhs = prepareData(3);\n+        for (LedgerHandle lh : lhs) {\n+            lh.close();\n+        }\n+\n+        // delete ledger2 and ledger3\n+        bkc.deleteLedger(lhs[1].getId());\n+        bkc.deleteLedger(lhs[2].getId());\n+\n+        // since compaction intervals are too long, there is no possibility for compaction to get kicked in\n+        // so all the entrylogs (0,1,2) should be available in the ledgerdirectory\n+        assertTrue(\"All the entry log files ([0,1,2].log are not available, which is not expected\"\n+                + tmpDirs.get(0).getAbsolutePath(), TestUtils.hasLogFiles(tmpDirs.get(0), false, 0, 1, 2));\n+        // validating that LedgerDirsListener are not triggered yet\n+        assertTrue(\"Disk Full shouldn't have been triggered yet\", diskFull.getCount() == 1);\n+        assertTrue(\"Disk writable shouldn't have been triggered yet\", diskWritable.getCount() == 1);\n+\n+        // set exception injection to true, so that next time when checkDir of DiskChecker (ThresholdTestDiskChecker) is\n+        // called it will throw DiskOutOfSpaceException\n+        thresholdTestDiskChecker.setInjectDiskOutOfSpaceException(true);\n+\n+        // now we are waiting for diskFull latch count to get to 0.\n+        // we are waiting for diskCheckInterval period, so that next time when LedgerDirsMonitor monitors diskusage of\n+        // its directories, it would get DiskOutOfSpaceException and hence diskFull of all LedgerDirsListener would be\n+        // called.\n+        diskFull.await(baseConf.getDiskCheckInterval() + 500, TimeUnit.MILLISECONDS);\n+        // verifying that diskFull of all LedgerDirsListener are invoked, so countdown of diskFull should come down to 0\n+        assertTrue(\"Disk Full should have been triggered\", diskFull.getCount() == 0);\n+        // making sure diskWritable of LedgerDirsListener are not invoked yet\n+        assertTrue(\"Disk writable shouldn't have been triggered yet\", diskWritable.getCount() == 1);\n+        // waiting momentarily, because transition to Readonly mode happens asynchronously when there are no more\n+        // writableLedgerDirs\n+        Thread.sleep(500);\n+        assertTrue(\"Bookie should be transitioned to ReadOnly\", bookie.isReadOnly());\n+        // since we set isForceGCAllowWhenNoSpace to true, when the disk is full (or when all disks are full) it does\n+        // force GC.\n+        // Because of getWritableLedgerDirsForNewLog, compaction would be able to create newlog and compact even though\n+        // there are no writableLedgerDirs\n+        assertFalse(\n+                \"Found entry log file ([0,1,2].log. They should have been compacted\" + tmpDirs.get(0).getAbsolutePath(),\n+                TestUtils.hasLogFiles(tmpDirs.get(0), true, 0, 1, 2));\n+\n+        try {\n+            ledgerDirsManager.getWritableLedgerDirs();\n+            fail(\"It is expected that there wont be any Writable LedgerDirs and getWritableLedgerDirs is supposed to throw NoWritableLedgerDirException\");\n+        } catch (NoWritableLedgerDirException nowritableDirsException) {\n+        }\n+\n+        // disable exception injection\n+        thresholdTestDiskChecker.setInjectDiskOutOfSpaceException(false);\n+\n+        // now we are waiting for diskWritable latch count to get to 0.\n+        // we are waiting for diskCheckInterval period, so that next time when LedgerDirsMonitor monitors diskusage of\n+        // its directories, it would find writableledgerdirectory and hence diskWritable of all LedgerDirsListener would\n+        // be called.\n+        diskWritable.await(baseConf.getDiskCheckInterval() + 500, TimeUnit.MILLISECONDS);\n+        // verifying that diskWritable of all LedgerDirsListener are invoked, so countdown of diskWritable should come\n+        // down to 0\n+        assertTrue(\"Disk writable should have been triggered\", diskWritable.getCount() == 0);\n+        // waiting momentarily, because transition to ReadWrite mode happens asynchronously when there is new\n+        // writableLedgerDirectory\n+        Thread.sleep(500);\n+        assertFalse(\"Bookie should be transitioned to ReadWrite\", bookie.isReadOnly());\n+    }\n+}"},{"sha":"f6253cf9972c4d1f906068759499c2ae1527b3a8","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/CompactionTest.java","status":"modified","additions":110,"deletions":0,"changes":110,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/59696600784c54192877a5742c6b141eadb07e26/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FCompactionTest.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/59696600784c54192877a5742c6b141eadb07e26/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FCompactionTest.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FCompactionTest.java?ref=59696600784c54192877a5742c6b141eadb07e26","patch":"@@ -31,12 +31,15 @@\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.Collections;\n import java.util.Enumeration;\n+import java.util.List;\n import java.util.Arrays;\n import java.util.Collection;\n \n import org.apache.bookkeeper.client.BookKeeper.DigestType;\n import org.apache.bookkeeper.bookie.EntryLogger.EntryLogScanner;\n import org.apache.bookkeeper.bookie.GarbageCollectorThread.CompactionScannerFactory;\n+import org.apache.bookkeeper.bookie.LedgerDirsManager.NoWritableLedgerDirException;\n+import org.apache.bookkeeper.client.BKException;\n import org.apache.bookkeeper.client.LedgerEntry;\n import org.apache.bookkeeper.client.LedgerHandle;\n import org.apache.bookkeeper.client.LedgerMetadata;\n@@ -45,6 +48,7 @@\n import org.apache.bookkeeper.meta.LedgerManager;\n import org.apache.bookkeeper.meta.LedgerManagerFactory;\n import org.apache.bookkeeper.stats.NullStatsLogger;\n+import org.apache.bookkeeper.proto.BookieServer;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.LedgerMetadataListener;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.Processor;\n@@ -127,6 +131,7 @@ public void setUp() throws Exception {\n         baseConf.setEntryLogFilePreAllocationEnabled(false);\n         baseConf.setLedgerStorageClass(InterleavedLedgerStorage.class.getName());\n         baseConf.setIsThrottleByBytes(this.isThrottleByBytes);\n+        baseConf.setIsForceGCAllowWhenNoSpace(false);\n \n         super.setUp();\n     }\n@@ -280,6 +285,111 @@ public void testMinorCompaction() throws Exception {\n         verifyLedger(lhs[0].getId(), 0, lhs[0].getLastAddConfirmed());\n     }\n \n+    @Test(timeout = 60000)\n+    public void testMinorCompactionWithNoWritableLedgerDirs() throws Exception {\n+        // prepare data\n+        LedgerHandle[] lhs = prepareData(3, false);\n+\n+        for (LedgerHandle lh : lhs) {\n+            lh.close();\n+        }\n+\n+        // disable major compaction\n+        baseConf.setMajorCompactionThreshold(0.0f);\n+\n+        // restart bookies\n+        restartBookies(baseConf);\n+\n+        for (BookieServer bookieServer : bs) {\n+            Bookie bookie = bookieServer.getBookie();\n+            LedgerDirsManager ledgerDirsManager = bookie.getLedgerDirsManager();\n+            List<File> ledgerDirs = ledgerDirsManager.getAllLedgerDirs();\n+            // if all the discs are full then Major and Minor compaction would be disabled since\n+            // 'isForceGCAllowWhenNoSpace' is not enabled. Check LedgerDirsListener of interleavedLedgerStorage.\n+            for (File ledgerDir : ledgerDirs) {\n+                ledgerDirsManager.addToFilledDirs(ledgerDir);\n+            }\n+        }\n+\n+        // remove ledger2 and ledger3\n+        bkc.deleteLedger(lhs[1].getId());\n+        bkc.deleteLedger(lhs[2].getId());\n+\n+        LOG.info(\"Finished deleting the ledgers contains most entries.\");\n+        Thread.sleep(baseConf.getMinorCompactionInterval() * 1000 + baseConf.getGcWaitTime());\n+\n+        // entry logs ([0,1,2].log) should still remain, because both major and Minor compaction are disabled.\n+        for (File ledgerDirectory : tmpDirs) {\n+            assertTrue(\n+                    \"All the entry log files ([0,1,2].log are not available, which is not expected\" + ledgerDirectory,\n+                    TestUtils.hasLogFiles(ledgerDirectory, false, 0, 1, 2));\n+        }\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testMinorCompactionWithNoWritableLedgerDirsButIsForceGCAllowWhenNoSpaceIsSet() throws Exception {\n+        // prepare data\n+        LedgerHandle[] lhs = prepareData(3, false);\n+\n+        for (LedgerHandle lh : lhs) {\n+            lh.close();\n+        }\n+\n+        // disable major compaction\n+        baseConf.setMajorCompactionThreshold(0.0f);\n+\n+        // here we are setting isForceGCAllowWhenNoSpace to true, so Major and Minor compaction wont be disabled in case\n+        // when discs are full\n+        baseConf.setIsForceGCAllowWhenNoSpace(true);\n+\n+        // restart bookies\n+        restartBookies(baseConf);\n+\n+        for (BookieServer bookieServer : bs) {\n+            Bookie bookie = bookieServer.getBookie();\n+            LedgerDirsManager ledgerDirsManager = bookie.getLedgerDirsManager();\n+            List<File> ledgerDirs = ledgerDirsManager.getAllLedgerDirs();\n+            // Major and Minor compaction are not disabled even though discs are full. Check LedgerDirsListener of\n+            // interleavedLedgerStorage.\n+            for (File ledgerDir : ledgerDirs) {\n+                ledgerDirsManager.addToFilledDirs(ledgerDir);\n+            }\n+        }\n+\n+        // remove ledger2 and ledger3\n+        bkc.deleteLedger(lhs[1].getId());\n+        bkc.deleteLedger(lhs[2].getId());\n+\n+        LOG.info(\"Finished deleting the ledgers contains most entries.\");\n+        Thread.sleep(baseConf.getMinorCompactionInterval() * 1000 + baseConf.getGcWaitTime() + 500);\n+\n+        // though all discs are added to filled dirs list, compaction would succeed, because in EntryLogger for\n+        // allocating newlog\n+        // we get getWritableLedgerDirsForNewLog() of ledgerDirsManager instead of getWritableLedgerDirs()\n+        // entry logs ([0,1,2].log) should be compacted.\n+        for (File ledgerDirectory : tmpDirs) {\n+            assertFalse(\"Found entry log file ([0,1,2].log that should have not been compacted in ledgerDirectory: \"\n+                    + ledgerDirectory, TestUtils.hasLogFiles(ledgerDirectory, true, 0, 1, 2));\n+        }\n+\n+        // even entry log files are removed, we still can access entries for ledger1\n+        // since those entries has been compacted to new entry log\n+        verifyLedger(lhs[0].getId(), 0, lhs[0].getLastAddConfirmed());\n+\n+        // for the sake of validity of test lets make sure that there is no writableLedgerDir in the bookies\n+        for (BookieServer bookieServer : bs) {\n+            Bookie bookie = bookieServer.getBookie();\n+            LedgerDirsManager ledgerDirsManager = bookie.getLedgerDirsManager();\n+            try {\n+                List<File> ledgerDirs = ledgerDirsManager.getWritableLedgerDirs();\n+                // it is expected not to have any writableLedgerDirs since we added all of them to FilledDirs\n+                fail(\"It is expected not to have any writableLedgerDirs\");\n+            } catch (NoWritableLedgerDirException nwe) {\n+\n+            }\n+        }\n+    }\n+    \n     @Test(timeout=60000)\n     public void testMajorCompaction() throws Exception {\n "}]}