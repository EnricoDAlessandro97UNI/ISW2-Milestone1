{"sha":"355ddbc7c13e39c49a58371d467e87aa80f696d7","node_id":"MDY6Q29tbWl0NDc4NTkyNTI2OjM1NWRkYmM3YzEzZTM5YzQ5YTU4MzcxZDQ2N2U4N2FhODBmNjk2ZDc=","commit":{"author":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2015-10-22T07:22:36Z"},"committer":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2015-10-22T07:22:36Z"},"message":"BOOKKEEPER-867: New Client API to allow applications pass-in EntryId. (Venkateswararao Jujjuri via sijie)","tree":{"sha":"d757a091d5304a09db789e3ad47ce0b1370fce06","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/trees/d757a091d5304a09db789e3ad47ce0b1370fce06"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/commits/355ddbc7c13e39c49a58371d467e87aa80f696d7","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/355ddbc7c13e39c49a58371d467e87aa80f696d7","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/355ddbc7c13e39c49a58371d467e87aa80f696d7","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/355ddbc7c13e39c49a58371d467e87aa80f696d7/comments","author":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"committer":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"parents":[{"sha":"8a3922e00d5fc3f82cb28ca032595b02db1a516e","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/8a3922e00d5fc3f82cb28ca032595b02db1a516e","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/8a3922e00d5fc3f82cb28ca032595b02db1a516e"}],"stats":{"total":826,"additions":815,"deletions":11},"files":[{"sha":"b2355cd26c0d1945b1065639570d3aa7adf7be40","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BKException.java","status":"modified","additions":11,"deletions":0,"changes":11,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/355ddbc7c13e39c49a58371d467e87aa80f696d7/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBKException.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/355ddbc7c13e39c49a58371d467e87aa80f696d7/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBKException.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBKException.java?ref=355ddbc7c13e39c49a58371d467e87aa80f696d7","patch":"@@ -96,6 +96,8 @@ public static BKException create(int code) {\n             return new BKIllegalOpException();\n         case Code.AddEntryQuorumTimeoutException:\n             return new BKAddEntryQuorumTimeoutException();\n+        case Code.DuplicateEntryIdException:\n+            return new BKDuplicateEntryIdException();\n         default:\n             return new BKUnexpectedConditionException();\n         }\n@@ -128,6 +130,7 @@ public interface Code {\n         int ClientClosedException = -19;\n         int LedgerExistException = -20;\n         int AddEntryQuorumTimeoutException = -21;\n+        int DuplicateEntryIdException = -22;\n \n         int IllegalOpException = -100;\n         int LedgerFencedException = -101;\n@@ -192,6 +195,8 @@ public static String getMessage(int code) {\n             return \"Bookie protocol version on server is incompatible with client\";\n         case Code.MetadataVersionException:\n             return \"Bad ledger metadata version\";\n+        case Code.DuplicateEntryIdException:\n+            return \"Attempted to add Duplicate entryId\";\n         case Code.LedgerFencedException:\n             return \"Ledger has been fenced off. Some other client must have opened it to read\";\n         case Code.UnauthorizedAccessException:\n@@ -261,6 +266,12 @@ public BKAddEntryQuorumTimeoutException() {\n         }\n     }\n \n+    public static class BKDuplicateEntryIdException extends BKException {\n+        public BKDuplicateEntryIdException() {\n+            super(Code.DuplicateEntryIdException);\n+        }\n+    }\n+\n     public static class BKUnexpectedConditionException extends BKException {\n         public BKUnexpectedConditionException() {\n             super(Code.UnexpectedConditionException);"},{"sha":"ed744b067a907df1ac57c5dfadf2f6ce93e68902","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeper.java","status":"modified","additions":93,"deletions":0,"changes":93,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/355ddbc7c13e39c49a58371d467e87aa80f696d7/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookKeeper.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/355ddbc7c13e39c49a58371d467e87aa80f696d7/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookKeeper.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookKeeper.java?ref=355ddbc7c13e39c49a58371d467e87aa80f696d7","patch":"@@ -536,6 +536,99 @@ public LedgerHandle createLedger(int ensSize, int writeQuorumSize, int ackQuorum\n         return counter.getLh();\n     }\n \n+    /**\n+     * Synchronous call to create ledger.\n+     * Creates a new ledger asynchronously and returns {@link LedgerHandleAdv} which can accept entryId.\n+     * Parameters must match those of\n+     * {@link #asyncCreateLedgerAdv(int, int, int, DigestType, byte[],\n+     *                           AsyncCallback.CreateCallback, Object)}\n+     *\n+     * @param ensSize\n+     * @param writeQuorumSize\n+     * @param ackQuorumSize\n+     * @param digestType\n+     * @param passwd\n+     * @return a handle to the newly created ledger\n+     * @throws InterruptedException\n+     * @throws BKException\n+     */\n+    public LedgerHandle createLedgerAdv(int ensSize, int writeQuorumSize, int ackQuorumSize,\n+                                        DigestType digestType, byte passwd[])\n+            throws InterruptedException, BKException {\n+        SyncCounter counter = new SyncCounter();\n+        counter.inc();\n+        /*\n+         * Calls asynchronous version\n+         */\n+        asyncCreateLedgerAdv(ensSize, writeQuorumSize, ackQuorumSize, digestType, passwd,\n+                             new SyncCreateCallback(), counter);\n+\n+        /*\n+         * Wait\n+         */\n+        counter.block(0);\n+        if (counter.getrc() != BKException.Code.OK) {\n+            LOG.error(\"Error while creating ledger : {}\", counter.getrc());\n+            throw BKException.create(counter.getrc());\n+        } else if (counter.getLh() == null) {\n+            LOG.error(\"Unexpected condition : no ledger handle returned for a success ledger creation\");\n+            throw BKException.create(BKException.Code.UnexpectedConditionException);\n+        }\n+\n+        return counter.getLh();\n+    }\n+\n+    /**\n+     * Creates a new ledger asynchronously and returns {@link LedgerHandleAdv}\n+     * which can accept entryId.  Ledgers created with this call have ability to accept\n+     * a separate write quorum and ack quorum size. The write quorum must be larger than\n+     * the ack quorum.\n+     *\n+     * Separating the write and the ack quorum allows the BookKeeper client to continue\n+     * writing when a bookie has failed but the failure has not yet been detected. Detecting\n+     * a bookie has failed can take a number of seconds, as configured by the read timeout\n+     * {@link ClientConfiguration#getReadTimeout()}. Once the bookie failure is detected,\n+     * that bookie will be removed from the ensemble.\n+     *\n+     * The other parameters match those of {@link #asyncCreateLedger(int, int, DigestType, byte[],\n+     *                                      AsyncCallback.CreateCallback, Object)}\n+     *\n+     * @param ensSize\n+     *          number of bookies over which to stripe entries\n+     * @param writeQuorumSize\n+     *          number of bookies each entry will be written to\n+     * @param ackQuorumSize\n+     *          number of bookies which must acknowledge an entry before the call is completed\n+     * @param digestType\n+     *          digest type, either MAC or CRC32\n+     * @param passwd\n+     *          password\n+     * @param cb\n+     *          createCallback implementation\n+     * @param ctx\n+     *          optional control object\n+     */\n+    public void asyncCreateLedgerAdv(final int ensSize,\n+                                     final int writeQuorumSize,\n+                                     final int ackQuorumSize,\n+                                     final DigestType digestType,\n+                                     final byte[] passwd, final CreateCallback cb, final Object ctx) {\n+        if (writeQuorumSize < ackQuorumSize) {\n+            throw new IllegalArgumentException(\"Write quorum must be larger than ack quorum\");\n+        }\n+        closeLock.readLock().lock();\n+        try {\n+            if (closed) {\n+                cb.createComplete(BKException.Code.ClientClosedException, null, ctx);\n+                return;\n+            }\n+            new LedgerCreateOp(BookKeeper.this, ensSize, writeQuorumSize,\n+                               ackQuorumSize, digestType, passwd, cb, ctx).initiateAdv();\n+        } finally {\n+            closeLock.readLock().unlock();\n+        }\n+    }\n+\n     /**\n      * Open existing ledger asynchronously for reading.\n      *"},{"sha":"6f794d057f52e94b42f58040bb2dc9b6c226171a","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerCreateOp.java","status":"modified","additions":14,"deletions":1,"changes":15,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/355ddbc7c13e39c49a58371d467e87aa80f696d7/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FLedgerCreateOp.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/355ddbc7c13e39c49a58371d467e87aa80f696d7/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FLedgerCreateOp.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FLedgerCreateOp.java?ref=355ddbc7c13e39c49a58371d467e87aa80f696d7","patch":"@@ -54,6 +54,7 @@ class LedgerCreateOp implements GenericCallback<Void> {\n     DigestType digestType;\n     long startTime;\n     OpStatsLogger createOpLogger;\n+    boolean adv = false;\n \n     /**\n      * Constructor\n@@ -136,6 +137,14 @@ public void operationComplete(int rc, Long ledgerId) {\n         });\n     }\n \n+    /**\n+     * Initiates the operation to return LedgerHandleAdv.\n+     */\n+    public void initiateAdv() {\n+        this.adv = true;\n+        initiate();\n+    }\n+\n     /**\n      * Callback when created ledger.\n      */\n@@ -151,7 +160,11 @@ public void operationComplete(int rc, Void result) {\n         }\n \n         try {\n-            lh = new LedgerHandle(bk, ledgerId, metadata, digestType, passwd);\n+            if (adv) {\n+                lh = new LedgerHandleAdv(bk, ledgerId, metadata, digestType, passwd);\n+            } else {\n+                lh = new LedgerHandle(bk, ledgerId, metadata, digestType, passwd);\n+            }\n         } catch (GeneralSecurityException e) {\n             LOG.error(\"Security exception while creating ledger: \" + ledgerId, e);\n             createComplete(BKException.Code.DigestNotInitializedException, null);"},{"sha":"61cc603b4442759d81c880ba6885806e2cf6726d","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","status":"modified","additions":103,"deletions":8,"changes":111,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/355ddbc7c13e39c49a58371d467e87aa80f696d7/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FLedgerHandle.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/355ddbc7c13e39c49a58371d467e87aa80f696d7/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FLedgerHandle.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FLedgerHandle.java?ref=355ddbc7c13e39c49a58371d467e87aa80f696d7","patch":"@@ -78,7 +78,7 @@ public class LedgerHandle {\n     final static public long INVALID_ENTRY_ID = BookieProtocol.INVALID_ENTRY_ID;\n \n     final AtomicInteger blockAddCompletions = new AtomicInteger(0);\n-    final Queue<PendingAddOp> pendingAddOps = new ConcurrentLinkedQueue<PendingAddOp>();\n+    Queue<PendingAddOp> pendingAddOps;\n \n     final Counter ensembleChangeCounter;\n     final Counter lacUpdateHitsCounter;\n@@ -89,6 +89,7 @@ public class LedgerHandle {\n             throws GeneralSecurityException, NumberFormatException {\n         this.bk = bk;\n         this.metadata = metadata;\n+        this.pendingAddOps = new ConcurrentLinkedQueue<PendingAddOp>();\n \n         if (metadata.isClosed()) {\n             lastAddConfirmed = lastAddPushed = metadata.getLastEntryId();\n@@ -472,6 +473,23 @@ public long addEntry(byte[] data) throws InterruptedException, BKException {\n         return addEntry(data, 0, data.length);\n     }\n \n+    /**\n+     * Add entry synchronously to an open ledger. This can be used only with\n+     * {@link LedgerHandleAdv} returned through ledgers created with {@link\n+     * BookKeeper#createLedgerAdv(int, int, int, DigestType, byte[])}.\n+     *\n+     *\n+     * @param entryId\n+     *            entryId to be added\n+     * @param data\n+     *            array of bytes to be written to the ledger\n+     * @return the entryId of the new inserted entry\n+     */\n+    public long addEntry(final long entryId, byte[] data) throws InterruptedException, BKException {\n+        LOG.error(\"To use this feature Ledger must be created with createLedgerAdv interface.\");\n+        throw BKException.create(BKException.Code.IllegalOpException);\n+    }\n+\n     /**\n      * Add entry synchronously to an open ledger.\n      *\n@@ -501,6 +519,27 @@ public long addEntry(byte[] data, int offset, int length)\n         return callback.entryId;\n     }\n \n+    /**\n+     * Add entry synchronously to an open ledger. This can be used only with\n+     * {@link LedgerHandleAdv} returned through ledgers created with {@link\n+     * BookKeeper#createLedgerAdv(int, int, int, DigestType, byte[])}.\n+     *\n+     * @param entryId\n+     *            entryId to be added.\n+     * @param data\n+     *            array of bytes to be written to the ledger\n+     * @param offset\n+     *            offset from which to take bytes from data\n+     * @param length\n+     *            number of bytes to take from data\n+     * @return entryId\n+     */\n+    public long addEntry(final long entryId, byte[] data, int offset, int length) throws InterruptedException,\n+            BKException {\n+        LOG.error(\"To use this feature Ledger must be created with createLedgerAdv() interface.\");\n+        throw BKException.create(BKException.Code.IllegalOpException);\n+    }\n+\n     /**\n      * Add entry asynchronously to an open ledger.\n      *\n@@ -516,6 +555,26 @@ public void asyncAddEntry(final byte[] data, final AddCallback cb,\n         asyncAddEntry(data, 0, data.length, cb, ctx);\n     }\n \n+    /**\n+     * Add entry asynchronously to an open ledger. This can be used only with\n+     * {@link LedgerHandleAdv} returned through ledgers created with {@link\n+     * BookKeeper#createLedgerAdv(int, int, int, DigestType, byte[])}.\n+     *\n+     * @param entryId\n+     *            entryId to be added\n+     * @param data\n+     *            array of bytes to be written\n+     * @param cb\n+     *            object implementing callbackinterface\n+     * @param ctx\n+     *            some control object\n+     */\n+    public void asyncAddEntry(final long entryId, final byte[] data, final AddCallback cb, final Object ctx)\n+            throws BKException {\n+        LOG.error(\"To use this feature Ledger must be created with createLedgerAdv() interface.\");\n+        cb.addComplete(BKException.Code.IllegalOpException, LedgerHandle.this, entryId, ctx);\n+    }\n+\n     /**\n      * Add entry asynchronously to an open ledger, using an offset and range.\n      *\n@@ -539,8 +598,35 @@ public void asyncAddEntry(final byte[] data, final int offset, final int length,\n     }\n \n     /**\n-     * Make a recovery add entry request. Recovery adds can add to a ledger even if\n-     * it has been fenced.\n+     * Add entry asynchronously to an open ledger, using an offset and range.\n+     * This can be used only with {@link LedgerHandleAdv} returned through\n+     * ledgers created with {@link BookKeeper#createLedgerAdv(int, int, int, DigestType, byte[])}.\n+     *\n+     * @param entryId\n+     *            entryId of the entry to add.\n+     * @param data\n+     *            array of bytes to be written\n+     * @param offset\n+     *            offset from which to take bytes from data\n+     * @param length\n+     *            number of bytes to take from data\n+     * @param cb\n+     *            object implementing callbackinterface\n+     * @param ctx\n+     *            some control object\n+     * @throws ArrayIndexOutOfBoundsException\n+     *             if offset or length is negative or offset and length sum to a\n+     *             value higher than the length of data.\n+     */\n+    public void asyncAddEntry(final long entryId, final byte[] data, final int offset, final int length,\n+            final AddCallback cb, final Object ctx) throws BKException {\n+        LOG.error(\"To use this feature Ledger must be created with createLedgerAdv() interface.\");\n+        cb.addComplete(BKException.Code.IllegalOpException, LedgerHandle.this, entryId, ctx);\n+    }\n+\n+    /**\n+     * Make a recovery add entry request. Recovery adds can add to a ledger even\n+     * if it has been fenced.\n      *\n      * This is only valid for bookie and ledger recovery, which may need to replicate\n      * entries to a quorum of bookies to ensure data safety.\n@@ -553,13 +639,14 @@ void asyncRecoveryAddEntry(final byte[] data, final int offset, final int length\n         doAsyncAddEntry(op, data, offset, length, cb, ctx);\n     }\n \n-    private void doAsyncAddEntry(final PendingAddOp op, final byte[] data, final int offset, final int length,\n-                                 final AddCallback cb, final Object ctx) {\n+    void doAsyncAddEntry(final PendingAddOp op, final byte[] data, final int offset, final int length,\n+                         final AddCallback cb, final Object ctx) {\n+\n         if (offset < 0 || length < 0\n                 || (offset + length) > data.length) {\n             throw new ArrayIndexOutOfBoundsException(\n-                \"Invalid values for offset(\"+offset\n-                +\") or length(\"+length+\")\");\n+                    \"Invalid values for offset(\" +offset\n+                    +\") or length(\"+length+\")\");\n         }\n         throttler.acquire();\n \n@@ -592,6 +679,7 @@ public void safeRun() {\n                         cb.addComplete(BKException.Code.LedgerClosedException,\n                                 LedgerHandle.this, INVALID_ENTRY_ID, ctx);\n                     }\n+\n                     @Override\n                     public String toString() {\n                         return String.format(\"AsyncAddEntryToClosedLedger(lid=%d)\", ledgerId);\n@@ -701,6 +789,7 @@ public void asyncTryReadLastConfirmed(final ReadLastConfirmedCallback cb, final\n         }\n         ReadLastConfirmedOp.LastConfirmedDataCallback innercb = new ReadLastConfirmedOp.LastConfirmedDataCallback() {\n             AtomicBoolean completed = new AtomicBoolean(false);\n+\n             @Override\n             public void readLastConfirmedDataComplete(int rc, DigestManager.RecoveryData data) {\n                 if (rc == BKException.Code.OK) {\n@@ -842,11 +931,17 @@ void sendAddSuccessCallbacks() {\n         // Start from the head of the queue and proceed while there are\n         // entries that have had all their responses come back\n         PendingAddOp pendingAddOp;\n+\n         while ((pendingAddOp = pendingAddOps.peek()) != null\n                && blockAddCompletions.get() == 0) {\n             if (!pendingAddOp.completed) {\n                 return;\n             }\n+            // Check if it is the next entry in the sequence.\n+            if (pendingAddOp.entryId != 0 && pendingAddOp.entryId != lastAddConfirmed + 1) {\n+                LOG.debug(\"Head of the queue entryId: {} is not lac: {} + 1\", pendingAddOp.entryId, lastAddConfirmed);\n+                return;\n+            }\n             pendingAddOps.remove();\n             lastAddConfirmed = pendingAddOp.entryId;\n             pendingAddOp.submitCallback(BKException.Code.OK);\n@@ -1219,7 +1314,7 @@ public void readComplete(int rc, LedgerHandle lh,\n         }\n     }\n \n-    private static class SyncAddCallback implements AddCallback {\n+    static class SyncAddCallback implements AddCallback {\n         long entryId = -1;\n \n         /**"},{"sha":"00fcfa7ce43c4b871e66a026d94a4c41d40ea962","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandleAdv.java","status":"added","additions":214,"deletions":0,"changes":214,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/355ddbc7c13e39c49a58371d467e87aa80f696d7/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FLedgerHandleAdv.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/355ddbc7c13e39c49a58371d467e87aa80f696d7/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FLedgerHandleAdv.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FLedgerHandleAdv.java?ref=355ddbc7c13e39c49a58371d467e87aa80f696d7","patch":"@@ -0,0 +1,214 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+\n+package org.apache.bookkeeper.client;\n+\n+import java.io.Serializable;\n+import java.security.GeneralSecurityException;\n+import java.util.Comparator;\n+import java.util.concurrent.PriorityBlockingQueue;\n+import java.util.concurrent.RejectedExecutionException;\n+\n+import org.apache.bookkeeper.client.AsyncCallback.AddCallback;\n+import org.apache.bookkeeper.client.BookKeeper.DigestType;\n+import org.apache.bookkeeper.util.SafeRunnable;\n+import org.jboss.netty.buffer.ChannelBuffer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Ledger Advanced handle extends {@link LedgerHandle} to provide API to add entries with\n+ * user supplied entryIds. Through this interface Ledger Length may not be accurate wile the\n+ * ledger being written.\n+ */\n+public class LedgerHandleAdv extends LedgerHandle {\n+    final static Logger LOG = LoggerFactory.getLogger(LedgerHandleAdv.class);\n+\n+    static class PendingOpsComparator implements Comparator<PendingAddOp>, Serializable {\n+        public int compare(PendingAddOp o1, PendingAddOp o2) {\n+            return Long.compare(o1.entryId, o2.entryId);\n+        }\n+    }\n+\n+    LedgerHandleAdv(BookKeeper bk, long ledgerId, LedgerMetadata metadata, DigestType digestType, byte[] password)\n+            throws GeneralSecurityException, NumberFormatException {\n+        super(bk, ledgerId, metadata, digestType, password);\n+        pendingAddOps = new PriorityBlockingQueue<PendingAddOp>(10, new PendingOpsComparator());\n+    }\n+\n+\n+    /**\n+     * Add entry synchronously to an open ledger.\n+     *\n+     * @param entryId\n+     *            entryId of the entry to add\n+     * @param data\n+     *            array of bytes to be written to the ledger\n+     * @return\n+     *            entryId that is just created.\n+     */\n+    @Override\n+    public long addEntry(final long entryId, byte[] data) throws InterruptedException, BKException {\n+\n+        return addEntry(entryId, data, 0, data.length);\n+\n+    }\n+\n+    /**\n+     * Add entry synchronously to an open ledger.\n+     *\n+     * @param entryId\n+     *            entryId of the entry to add\n+     * @param data\n+     *            array of bytes to be written to the ledger\n+     * @param offset\n+     *            offset from which to take bytes from data\n+     * @param length\n+     *            number of bytes to take from data\n+     * @return The entryId of newly inserted entry.\n+     */\n+    @Override\n+    public long addEntry(final long entryId, byte[] data, int offset, int length) throws InterruptedException,\n+            BKException {\n+        LOG.debug(\"Adding entry {}\", data);\n+\n+        SyncCounter counter = new SyncCounter();\n+        counter.inc();\n+\n+        SyncAddCallback callback = new SyncAddCallback();\n+        asyncAddEntry(entryId, data, offset, length, callback, counter);\n+\n+        counter.block(0);\n+\n+        if (counter.getrc() != BKException.Code.OK) {\n+            throw BKException.create(counter.getrc());\n+        }\n+        return callback.entryId;\n+    }\n+\n+    /**\n+     * Add entry asynchronously to an open ledger.\n+     *\n+     * @param entryId\n+     *            entryId of the entry to add\n+     * @param data\n+     *            array of bytes to be written\n+     * @param cb\n+     *            object implementing callbackinterface\n+     * @param ctx\n+     *            some control object\n+     */\n+    @Override\n+    public void asyncAddEntry(long entryId, byte[] data, AddCallback cb, Object ctx) throws BKException {\n+        asyncAddEntry(entryId, data, 0, data.length, cb, ctx);\n+    }\n+\n+    /**\n+     * Add entry asynchronously to an open ledger, using an offset and range.\n+     *\n+     * @param entryId\n+     *            entryId of the entry to add\n+     * @param data\n+     *            array of bytes to be written\n+     * @param offset\n+     *            offset from which to take bytes from data\n+     * @param length\n+     *            number of bytes to take from data\n+     * @param cb\n+     *            object implementing callbackinterface\n+     * @param ctx\n+     *            some control object\n+     * @throws ArrayIndexOutOfBoundsException\n+     *             if offset or length is negative or offset and length sum to a\n+     *             value higher than the length of data.\n+     */\n+\n+    public void asyncAddEntry(final long entryId, final byte[] data, final int offset, final int length,\n+            final AddCallback cb, final Object ctx) {\n+        PendingAddOp op = new PendingAddOp(this, cb, ctx);\n+        op.setEntryId(entryId);\n+        if ((entryId <= this.lastAddConfirmed) || pendingAddOps.contains(op)) {\n+            LOG.error(\"Trying to re-add duplicate entryid:{}\", entryId);\n+            cb.addComplete(BKException.Code.DuplicateEntryIdException,\n+                    LedgerHandleAdv.this, entryId, ctx);\n+            return;\n+        }\n+        pendingAddOps.add(op);\n+\n+        doAsyncAddEntry(op, data, offset, length, cb, ctx);\n+    }\n+\n+    /**\n+     * Overriding part is mostly around setting entryId.\n+     * Though there may be some code duplication, Choose to have the override routine so the control flow is\n+     * unaltered in the base class.\n+     */\n+    @Override\n+    void doAsyncAddEntry(final PendingAddOp op, final byte[] data, final int offset, final int length,\n+            final AddCallback cb, final Object ctx) {\n+        if (offset < 0 || length < 0\n+                || (offset + length) > data.length) {\n+            throw new ArrayIndexOutOfBoundsException(\n+                \"Invalid values for offset(\"+offset\n+                +\") or length(\"+length+\")\");\n+        }\n+        throttler.acquire();\n+\n+        if (metadata.isClosed()) {\n+            // make sure the callback is triggered in main worker pool\n+            try {\n+                bk.mainWorkerPool.submit(new SafeRunnable() {\n+                    @Override\n+                    public void safeRun() {\n+                        LOG.warn(\"Attempt to add to closed ledger: {}\", ledgerId);\n+                        cb.addComplete(BKException.Code.LedgerClosedException,\n+                                LedgerHandleAdv.this, op.getEntryId(), ctx);\n+                    }\n+                    @Override\n+                    public String toString() {\n+                        return String.format(\"AsyncAddEntryToClosedLedger(lid=%d)\", ledgerId);\n+                    }\n+                });\n+            } catch (RejectedExecutionException e) {\n+                cb.addComplete(bk.getReturnRc(BKException.Code.InterruptedException),\n+                        LedgerHandleAdv.this, op.getEntryId(), ctx);\n+            }\n+            return;\n+        }\n+\n+        try {\n+            final long currentLength = addToLength(length);\n+\n+            bk.mainWorkerPool.submit(new SafeRunnable() {\n+                @Override\n+                public void safeRun() {\n+                    ChannelBuffer toSend = macManager.computeDigestAndPackageForSending(\n+                                               op.getEntryId(), lastAddConfirmed, currentLength, data, offset, length);\n+                    op.initiate(toSend, length);\n+                }\n+            });\n+        } catch (RejectedExecutionException e) {\n+            cb.addComplete(bk.getReturnRc(BKException.Code.InterruptedException),\n+                    LedgerHandleAdv.this, op.getEntryId(), ctx);\n+        }\n+    }\n+\n+}"},{"sha":"bc487f6820d64e21294b24113da72b1d8f0cfb6e","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingAddOp.java","status":"modified","additions":17,"deletions":0,"changes":17,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/355ddbc7c13e39c49a58371d467e87aa80f696d7/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FPendingAddOp.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/355ddbc7c13e39c49a58371d467e87aa80f696d7/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FPendingAddOp.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FPendingAddOp.java?ref=355ddbc7c13e39c49a58371d467e87aa80f696d7","patch":"@@ -91,6 +91,10 @@ void setEntryId(long entryId) {\n         writeSet = new HashSet<Integer>(lh.distributionSchedule.getWriteSet(entryId));\n     }\n \n+    long getEntryId() {\n+        return this.entryId;\n+    }\n+\n     void sendWriteRequest(int bookieIndex) {\n         int flags = isRecoveryAdd ? BookieProtocol.FLAG_RECOVERY_ADD : BookieProtocol.FLAG_NONE;\n \n@@ -249,4 +253,17 @@ public String toString() {\n         return sb.toString();\n     }\n \n+    @Override\n+    public int hashCode() {\n+        return (int) entryId;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+       if (o instanceof PendingAddOp) {\n+           return (this.entryId == ((PendingAddOp)o).entryId);\n+       }\n+       return (this == o);\n+    }\n+\n }"},{"sha":"692c48082e2f2e6c9946ab862c64bcd60ec3a34b","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookieWriteLedgerTest.java","status":"modified","additions":363,"deletions":2,"changes":365,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/355ddbc7c13e39c49a58371d467e87aa80f696d7/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookieWriteLedgerTest.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/355ddbc7c13e39c49a58371d467e87aa80f696d7/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookieWriteLedgerTest.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookieWriteLedgerTest.java?ref=355ddbc7c13e39c49a58371d467e87aa80f696d7","patch":"@@ -130,6 +130,48 @@ public void testWithMultipleBookieFailuresInLastEnsemble() throws Exception {\n         lh.close();\n     }\n \n+    /**\n+     * Verify the functionality of Advanced Ledger which returns\n+     * LedgerHandleAdv. LedgerHandleAdv takes entryId for addEntry, and let\n+     * user manage entryId allocation.\n+     *\n+     * @throws Exception\n+     */\n+    @Test(timeout = 60000)\n+    public void testLedgerCreateAdv() throws Exception {\n+        // Create a ledger\n+        lh = bkc.createLedgerAdv(5, 3, 2, digestType, ledgerPassword);\n+        for (int i = 0; i < numEntriesToWrite; i++) {\n+            ByteBuffer entry = ByteBuffer.allocate(4);\n+            entry.putInt(rng.nextInt(maxInt));\n+            entry.position(0);\n+\n+            entries1.add(entry.array());\n+            lh.addEntry(i, entry.array());\n+        }\n+        // Start one more bookies\n+        startNewBookie();\n+\n+        // Shutdown one bookie in the last ensemble and continue writing\n+        ArrayList<BookieSocketAddress> ensemble = lh.getLedgerMetadata().getEnsembles().entrySet().iterator().next()\n+                .getValue();\n+        killBookie(ensemble.get(0));\n+\n+        int i = numEntriesToWrite;\n+        numEntriesToWrite = numEntriesToWrite + 50;\n+        for (; i < numEntriesToWrite; i++) {\n+            ByteBuffer entry = ByteBuffer.allocate(4);\n+            entry.putInt(rng.nextInt(maxInt));\n+            entry.position(0);\n+\n+            entries1.add(entry.array());\n+            lh.addEntry(i, entry.array());\n+        }\n+\n+        readEntries(lh, entries1);\n+        lh.close();\n+    }\n+\n     /**\n      * Verify asynchronous writing when few bookie failures in last ensemble.\n      */\n@@ -203,8 +245,327 @@ public void testAsyncWritesWithMultipleFailuresInLastEnsemble()\n         lh2.close();\n     }\n \n-    private void readEntries(LedgerHandle lh, ArrayList<byte[]> entries)\n-            throws InterruptedException, BKException {\n+    /**\n+     * Verify Advanced asynchronous writing with entryIds in reverse order\n+     */\n+    @Test(timeout = 60000)\n+    public void testLedgerCreateAdvWithAsyncWritesWithBookieFailures() throws Exception {\n+        // Create ledgers\n+        lh = bkc.createLedgerAdv(5, 3, 2, digestType, ledgerPassword);\n+        lh2 = bkc.createLedgerAdv(5, 3, 2, digestType, ledgerPassword);\n+\n+        LOG.info(\"Ledger ID-1: \" + lh.getId());\n+        LOG.info(\"Ledger ID-2: \" + lh2.getId());\n+        SyncObj syncObj1 = new SyncObj();\n+        SyncObj syncObj2 = new SyncObj();\n+        for (int i = numEntriesToWrite - 1; i >= 0; i--) {\n+            ByteBuffer entry = ByteBuffer.allocate(4);\n+            entry.putInt(rng.nextInt(maxInt));\n+            entry.position(0);\n+            try {\n+                entries1.add(0, entry.array());\n+                entries2.add(0, entry.array());\n+            } catch (Exception e) {\n+                e.printStackTrace();\n+            }\n+            lh.asyncAddEntry(i, entry.array(), 0, entry.capacity(), this, syncObj1);\n+            lh2.asyncAddEntry(i, entry.array(), 0, entry.capacity(), this, syncObj2);\n+        }\n+        // Start One more bookie and shutdown one from last ensemble before reading\n+        startNewBookie();\n+        ArrayList<BookieSocketAddress> ensemble = lh.getLedgerMetadata().getEnsembles().entrySet().iterator().next()\n+                .getValue();\n+        killBookie(ensemble.get(0));\n+\n+        // Wait for all entries to be acknowledged for the first ledger\n+        synchronized (syncObj1) {\n+            while (syncObj1.counter < numEntriesToWrite) {\n+                syncObj1.wait();\n+            }\n+            assertEquals(BKException.Code.OK, syncObj1.rc);\n+        }\n+        // Wait for all entries to be acknowledged for the second ledger\n+        synchronized (syncObj2) {\n+            while (syncObj2.counter < numEntriesToWrite) {\n+                syncObj2.wait();\n+            }\n+            assertEquals(BKException.Code.OK, syncObj2.rc);\n+        }\n+\n+        // Reading ledger till the last entry\n+        readEntries(lh, entries1);\n+        readEntries(lh2, entries2);\n+        lh.close();\n+        lh2.close();\n+    }\n+\n+    /**\n+     * Verify Advanced asynchronous writing with entryIds in pseudo random order with bookie failures between writes\n+     */\n+    @Test(timeout = 60000)\n+    public void testLedgerCreateAdvWithRandomAsyncWritesWithBookieFailuresBetweenWrites() throws Exception {\n+        // Create ledgers\n+        lh = bkc.createLedgerAdv(5, 3, 2, digestType, ledgerPassword);\n+        lh2 = bkc.createLedgerAdv(5, 3, 2, digestType, ledgerPassword);\n+\n+        LOG.info(\"Ledger ID-1: \" + lh.getId());\n+        LOG.info(\"Ledger ID-2: \" + lh2.getId());\n+        SyncObj syncObj1 = new SyncObj();\n+        SyncObj syncObj2 = new SyncObj();\n+        int batchSize = 5;\n+        int i, j;\n+\n+        // Fill the result buffers first\n+        for (i = 0; i < numEntriesToWrite; i++) {\n+            ByteBuffer entry = ByteBuffer.allocate(4);\n+\n+            entry.putInt(rng.nextInt(maxInt));\n+            entry.position(0);\n+            try {\n+                entries1.add(0, entry.array());\n+                entries2.add(0, entry.array());\n+            } catch (Exception e) {\n+                e.printStackTrace();\n+            }\n+        }\n+\n+        for (i = 0; i < batchSize; i++) {\n+            for (j = i; j < numEntriesToWrite; j = j + batchSize) {\n+                byte[] entry1 = entries1.get(j);\n+                byte[] entry2 = entries2.get(j);\n+                lh.asyncAddEntry(j, entry1, 0, entry1.length, this, syncObj1);\n+                lh2.asyncAddEntry(j, entry2, 0, entry2.length, this, syncObj2);\n+                if (j == numEntriesToWrite/2) {\n+                    // Start One more bookie and shutdown one from last ensemble at half-way\n+                    startNewBookie();\n+                    ArrayList<BookieSocketAddress> ensemble = lh.getLedgerMetadata().getEnsembles().entrySet()\n+                            .iterator().next().getValue();\n+                    killBookie(ensemble.get(0));\n+                }\n+            }\n+        }\n+\n+        // Wait for all entries to be acknowledged for the first ledger\n+        synchronized (syncObj1) {\n+            while (syncObj1.counter < numEntriesToWrite) {\n+                syncObj1.wait();\n+            }\n+            assertEquals(BKException.Code.OK, syncObj1.rc);\n+        }\n+        // Wait for all entries to be acknowledged for the second ledger\n+        synchronized (syncObj2) {\n+            while (syncObj2.counter < numEntriesToWrite) {\n+                syncObj2.wait();\n+            }\n+            assertEquals(BKException.Code.OK, syncObj2.rc);\n+        }\n+\n+        // Reading ledger till the last entry\n+        readEntries(lh, entries1);\n+        readEntries(lh2, entries2);\n+        lh.close();\n+        lh2.close();\n+    }\n+\n+    /**\n+     * Verify Advanced asynchronous writing with entryIds in pseudo random order\n+     */\n+    @Test(timeout = 60000)\n+    public void testLedgerCreateAdvWithRandomAsyncWritesWithBookieFailures() throws Exception {\n+        // Create ledgers\n+        lh = bkc.createLedgerAdv(5, 3, 2, digestType, ledgerPassword);\n+        lh2 = bkc.createLedgerAdv(5, 3, 2, digestType, ledgerPassword);\n+\n+        LOG.info(\"Ledger ID-1: \" + lh.getId());\n+        LOG.info(\"Ledger ID-2: \" + lh2.getId());\n+        SyncObj syncObj1 = new SyncObj();\n+        SyncObj syncObj2 = new SyncObj();\n+        int batchSize = 5;\n+        int i, j;\n+\n+        // Fill the result buffers first\n+        for (i = 0; i < numEntriesToWrite; i++) {\n+            ByteBuffer entry = ByteBuffer.allocate(4);\n+\n+            entry.putInt(rng.nextInt(maxInt));\n+            entry.position(0);\n+            try {\n+                entries1.add(0, entry.array());\n+                entries2.add(0, entry.array());\n+            } catch (Exception e) {\n+                e.printStackTrace();\n+            }\n+        }\n+\n+        for (i = 0; i < batchSize; i++) {\n+            for (j = i; j < numEntriesToWrite; j = j + batchSize) {\n+                byte[] entry1 = entries1.get(j);\n+                byte[] entry2 = entries2.get(j);\n+                lh.asyncAddEntry(j, entry1, 0, entry1.length, this, syncObj1);\n+                lh2.asyncAddEntry(j, entry2, 0, entry2.length, this, syncObj2);\n+            }\n+        }\n+        // Start One more bookie and shutdown one from last ensemble before reading\n+        startNewBookie();\n+        ArrayList<BookieSocketAddress> ensemble = lh.getLedgerMetadata().getEnsembles().entrySet().iterator().next()\n+                .getValue();\n+        killBookie(ensemble.get(0));\n+\n+        // Wait for all entries to be acknowledged for the first ledger\n+        synchronized (syncObj1) {\n+            while (syncObj1.counter < numEntriesToWrite) {\n+                syncObj1.wait();\n+            }\n+            assertEquals(BKException.Code.OK, syncObj1.rc);\n+        }\n+        // Wait for all entries to be acknowledged for the second ledger\n+        synchronized (syncObj2) {\n+            while (syncObj2.counter < numEntriesToWrite) {\n+                syncObj2.wait();\n+            }\n+            assertEquals(BKException.Code.OK, syncObj2.rc);\n+        }\n+\n+        // Reading ledger till the last entry\n+        readEntries(lh, entries1);\n+        readEntries(lh2, entries2);\n+        lh.close();\n+        lh2.close();\n+    }\n+\n+    /**\n+     * Skips few entries before closing the ledger and assert that the\n+     * lastAddConfirmed is right before our skipEntryId.\n+     *\n+     * @throws Exception\n+     */\n+    @Test(timeout = 60000)\n+    public void testLedgerCreateAdvWithSkipEntries() throws Exception {\n+        long ledgerId;\n+        SyncObj syncObj1 = new SyncObj();\n+\n+        // Create a ledger\n+        lh = bkc.createLedgerAdv(5, 3, 2, digestType, ledgerPassword);\n+        // Save ledgerId to reopen the ledger\n+        ledgerId = lh.getId();\n+        LOG.info(\"Ledger ID: \" + ledgerId);\n+        int skipEntryId = rng.nextInt(numEntriesToWrite - 1);\n+        for (int i = numEntriesToWrite - 1; i >= 0; i--) {\n+            ByteBuffer entry = ByteBuffer.allocate(4);\n+            entry.putInt(rng.nextInt(maxInt));\n+            entry.position(0);\n+            try {\n+                entries1.add(0, entry.array());\n+            } catch (Exception e) {\n+                e.printStackTrace();\n+            }\n+            if (i == skipEntryId) {\n+                LOG.info(\"Skipping entry:{}\", skipEntryId);\n+                continue;\n+            }\n+            lh.asyncAddEntry(i, entry.array(), 0, entry.capacity(), this, syncObj1);\n+        }\n+        // wait for all entries to be acknowledged for the first ledger\n+        synchronized (syncObj1) {\n+            while (syncObj1.counter < skipEntryId) {\n+                syncObj1.wait();\n+            }\n+            assertEquals(BKException.Code.OK, syncObj1.rc);\n+        }\n+        // Close the ledger\n+        lh.close();\n+        // Open the ledger\n+        lh = bkc.openLedger(ledgerId, digestType, ledgerPassword);\n+        assertEquals(lh.lastAddConfirmed, skipEntryId - 1);\n+        lh.close();\n+    }\n+\n+    /**\n+     * Verify the functionality LedgerHandleAdv addEntry with duplicate entryIds\n+     *\n+     * @throws Exception\n+     */\n+    @Test(timeout = 60000)\n+    public void testLedgerCreateAdvSyncAddDuplicateEntryIds() throws Exception {\n+        // Create a ledger\n+        lh = bkc.createLedgerAdv(5, 3, 2, digestType, ledgerPassword);\n+        LOG.info(\"Ledger ID: \" + lh.getId());\n+        for (int i = 0; i < numEntriesToWrite; i++) {\n+            ByteBuffer entry = ByteBuffer.allocate(4);\n+            entry.putInt(rng.nextInt(maxInt));\n+            entry.position(0);\n+\n+            entries1.add(entry.array());\n+            lh.addEntry(i, entry.array());\n+            entry.position(0);\n+        }\n+        readEntries(lh, entries1);\n+\n+        int dupEntryId = rng.nextInt(numEntriesToWrite - 1);\n+\n+        try {\n+            ByteBuffer entry = ByteBuffer.allocate(4);\n+            entry.putInt(rng.nextInt(maxInt));\n+            entry.position(0);\n+            lh.addEntry(dupEntryId, entry.array());\n+            fail(\"Expected exception not thrown\");\n+        } catch (BKException e) {\n+            // This test expects DuplicateEntryIdException\n+            assertEquals(e.getCode(), BKException.Code.DuplicateEntryIdException);\n+        }\n+        lh.close();\n+    }\n+\n+    /**\n+     * Verify the functionality LedgerHandleAdv asyncAddEntry with duplicate\n+     * entryIds\n+     *\n+     * @throws Exception\n+     */\n+    @Test(timeout = 60000)\n+    public void testLedgerCreateAdvSyncAsyncAddDuplicateEntryIds() throws Exception {\n+        long ledgerId;\n+        SyncObj syncObj1 = new SyncObj();\n+        SyncObj syncObj2 = new SyncObj();\n+\n+        // Create a ledger\n+        lh = bkc.createLedgerAdv(5, 3, 2, digestType, ledgerPassword);\n+        // Save ledgerId to reopen the ledger\n+        ledgerId = lh.getId();\n+        LOG.info(\"Ledger ID: \" + ledgerId);\n+        for (int i = numEntriesToWrite - 1; i >= 0; i--) {\n+            ByteBuffer entry = ByteBuffer.allocate(4);\n+            entry.putInt(rng.nextInt(maxInt));\n+            entry.position(0);\n+            try {\n+                entries1.add(0, entry.array());\n+            } catch (Exception e) {\n+                e.printStackTrace();\n+            }\n+            lh.asyncAddEntry(i, entry.array(), 0, entry.capacity(), this, syncObj1);\n+            if (rng.nextBoolean()) {\n+                // Attempt to write the same entry\n+                lh.asyncAddEntry(i, entry.array(), 0, entry.capacity(), this, syncObj2);\n+                synchronized (syncObj2) {\n+                    while (syncObj2.counter < 1) {\n+                        syncObj2.wait();\n+                    }\n+                    assertEquals(BKException.Code.DuplicateEntryIdException, syncObj2.rc);\n+                }\n+            }\n+        }\n+        // Wait for all entries to be acknowledged for the first ledger\n+        synchronized (syncObj1) {\n+            while (syncObj1.counter < numEntriesToWrite) {\n+                syncObj1.wait();\n+            }\n+            assertEquals(BKException.Code.OK, syncObj1.rc);\n+        }\n+        // Close the ledger\n+        lh.close();\n+    }\n+\n+    private void readEntries(LedgerHandle lh, ArrayList<byte[]> entries) throws InterruptedException, BKException {\n         ls = lh.readEntries(0, numEntriesToWrite - 1);\n         int index = 0;\n         while (ls.hasMoreElements()) {"}]}