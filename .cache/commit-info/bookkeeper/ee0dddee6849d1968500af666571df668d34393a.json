{"sha":"ee0dddee6849d1968500af666571df668d34393a","node_id":"MDY6Q29tbWl0NDc4NTkyNTI2OmVlMGRkZGVlNjg0OWQxOTY4NTAwYWY2NjY1NzFkZjY2OGQzNDM5M2E=","commit":{"author":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2017-07-04T04:27:21Z"},"committer":{"name":"jiazhai","email":"zhaijia@live.com","date":"2017-07-04T04:27:21Z"},"message":"BOOKKEEPER-772: Reorder Read Sequence\n\nDescriptions of the changes in this PR:\n\n    - for rackware placement policy, the bookie in the same rack will be preferred.\n    - for region-aware placement policy, the bookie in the same region will be preferred.\n    - for any readonly or unavailable (high score in bookie failure history) bookies, they will be at the last position in the sequence.\n\nThis change is based on #220 . Please review gitsha 1f7dccd for the reorder change.\n\nAuthor: Sijie Guo <sijie@apache.org>\n\nReviewers: Enrico Olivelli <None>, Matteo Merli <None>\n\nThis closes #224 from sijie/reorder_reads","tree":{"sha":"ba9401aaa89e1c51e917fb22f613a3d50192da87","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/trees/ba9401aaa89e1c51e917fb22f613a3d50192da87"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/commits/ee0dddee6849d1968500af666571df668d34393a","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/ee0dddee6849d1968500af666571df668d34393a","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/ee0dddee6849d1968500af666571df668d34393a","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/ee0dddee6849d1968500af666571df668d34393a/comments","author":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"committer":null,"parents":[{"sha":"21366fee0e43e69591a03d7b517cf66dff2861d9","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/21366fee0e43e69591a03d7b517cf66dff2861d9","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/21366fee0e43e69591a03d7b517cf66dff2861d9"}],"stats":{"total":2221,"additions":2115,"deletions":106},"files":[{"sha":"d607b53321a54220724112a93c6cf0a0969276aa","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java","status":"modified","additions":7,"deletions":0,"changes":7,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/ee0dddee6849d1968500af666571df668d34393a/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FBookie.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/ee0dddee6849d1968500af666571df668d34393a/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FBookie.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FBookie.java?ref=ee0dddee6849d1968500af666571df668d34393a","patch":"@@ -45,6 +45,8 @@\n import java.util.Collections;\n import java.util.HashSet;\n import java.util.List;\n+import java.util.Observable;\n+import java.util.Observer;\n import java.util.Set;\n import java.util.concurrent.Callable;\n import java.util.concurrent.CountDownLatch;\n@@ -1491,6 +1493,11 @@ public long readLastAddConfirmed(long ledgerId) throws IOException {\n         LedgerDescriptor handle = handles.getReadOnlyHandle(ledgerId);\n         return handle.getLastAddConfirmed();\n     }\n+    \n+    public Observable waitForLastAddConfirmedUpdate(long ledgerId, long previoisLAC, Observer observer) throws IOException {\n+        LedgerDescriptor handle = handles.getReadOnlyHandle(ledgerId);\n+        return handle.waitForLastAddConfirmedUpdate(previoisLAC, observer);\n+    }\n \n     // The rest of the code is test stuff\n     static class CounterCallback implements WriteCallback {"},{"sha":"597fcd34da5a8f972ec723a69e38fa8747bef13c","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/FileInfo.java","status":"modified","additions":109,"deletions":46,"changes":155,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/ee0dddee6849d1968500af666571df668d34393a/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FFileInfo.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/ee0dddee6849d1968500af666571df668d34393a/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FFileInfo.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FFileInfo.java?ref=ee0dddee6849d1968500af666571df668d34393a","patch":"@@ -23,22 +23,21 @@\n \n import static com.google.common.base.Charsets.UTF_8;\n \n+import com.google.common.annotations.VisibleForTesting;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n import java.io.File;\n import java.io.IOException;\n import java.io.RandomAccessFile;\n import java.nio.BufferUnderflowException;\n import java.nio.ByteBuffer;\n import java.nio.channels.FileChannel;\n+import java.util.Observable;\n+import java.util.Observer;\n import java.util.concurrent.atomic.AtomicInteger;\n-\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import com.google.common.annotations.VisibleForTesting;\n-\n-import io.netty.buffer.ByteBuf;\n-import io.netty.buffer.Unpooled;\n-\n /**\n  * This is the file handle for a ledger's index file that maps entry ids to location.\n  * It is used by LedgerCache.\n@@ -57,7 +56,7 @@\n  * <b>Index page</b> is a fixed-length page, which contains serveral entries which point to the offsets of data stored in entry loggers.\n  * </p>\n  */\n-class FileInfo {\n+class FileInfo extends Observable {\n     private final static Logger LOG = LoggerFactory.getLogger(FileInfo.class);\n \n     static final int NO_MASTER_KEY = -1;\n@@ -102,14 +101,34 @@ synchronized Long getLastAddConfirmed() {\n         return lac;\n     }\n \n-    synchronized long setLastAddConfirmed(long lac) {\n-        if (null == this.lac || this.lac < lac) {\n-            this.lac = lac;\n+    long setLastAddConfirmed(long lac) {\n+        long lacToReturn;\n+        synchronized (this) {\n+            if (null == this.lac || this.lac < lac) {\n+                this.lac = lac;\n+                setChanged();\n+            }\n+            lacToReturn = this.lac;\n+        }\n+        LOG.trace(\"Updating LAC {} , {}\", lacToReturn, lac);\n+\n+\n+        notifyObservers(new LastAddConfirmedUpdateNotification(lacToReturn));\n+        return lacToReturn;\n+    }\n+\n+    synchronized Observable waitForLastAddConfirmedUpdate(long previousLAC, Observer observe) {\n+        if ((null != lac && lac > previousLAC)\n+                || isClosed || ((stateBits & STATE_FENCED_BIT) == STATE_FENCED_BIT)) {\n+            LOG.trace(\"Wait For LAC {} , {}\", this.lac, previousLAC);\n+            return null;\n         }\n-        return this.lac;\n+\n+        addObserver(observe);\n+        return this;\n     }\n \n-    public File getLf() {\n+    public synchronized File getLf() {\n         return lf;\n     }\n \n@@ -170,15 +189,15 @@ synchronized public void readHeader() throws IOException {\n             }\n             bb.flip();\n             if (bb.getInt() != signature) {\n-                throw new IOException(\"Missing ledger signature\");\n+                throw new IOException(\"Missing ledger signature while reading header for \" + lf);\n             }\n             int version = bb.getInt();\n             if (version != headerVersion) {\n-                throw new IOException(\"Incompatible ledger version \" + version);\n+                throw new IOException(\"Incompatible ledger version \" + version + \" while reading header for \" + lf);\n             }\n             int length = bb.getInt();\n             if (length < 0) {\n-                throw new IOException(\"Length \" + length + \" is invalid\");\n+                throw new IOException(\"Length \" + length + \" is invalid while reading header for \" + lf);\n             } else if (length > bb.remaining()) {\n                 throw new BufferUnderflowException();\n             }\n@@ -187,11 +206,17 @@ synchronized public void readHeader() throws IOException {\n             stateBits = bb.getInt();\n             needFlushHeader = false;\n         } else {\n-            throw new IOException(\"Ledger index file does not exist\");\n+            throw new IOException(\"Ledger index file \" + lf +\" does not exist\");\n         }\n     }\n \n-    synchronized void checkOpen(boolean create) throws IOException {\n+    @VisibleForTesting\n+    void checkOpen(boolean create) throws IOException {\n+        checkOpen(create, false);\n+    }\n+\n+    private synchronized void checkOpen(boolean create, boolean openBeforeClose)\n+            throws IOException {\n         if (fc != null) {\n             return;\n         }\n@@ -211,6 +236,10 @@ synchronized void checkOpen(boolean create) throws IOException {\n                 }\n             }\n         } else {\n+            if (openBeforeClose) {\n+                // if it is checking for close, skip reading header\n+                return;\n+            }\n             try {\n                 readHeader();\n             } catch (BufferUnderflowException buf) {\n@@ -246,19 +275,25 @@ synchronized public boolean isFenced() throws IOException {\n      * @return true if set fence succeed, otherwise false when\n      * it already fenced or failed to set fenced.\n      */\n-    synchronized public boolean setFenced() throws IOException {\n-        checkOpen(false);\n-        if (LOG.isDebugEnabled()) {\n-            LOG.debug(\"Try to set fenced state in file info {} : state bits {}.\", lf, stateBits);\n-        }\n-        if ((stateBits & STATE_FENCED_BIT) != STATE_FENCED_BIT) {\n-            // not fenced yet\n-            stateBits |= STATE_FENCED_BIT;\n-            needFlushHeader = true;\n-            return true;\n-        } else {\n-            return false;\n+    public boolean setFenced() throws IOException {\n+        boolean returnVal = false;\n+        synchronized (this) {\n+            checkOpen(false);\n+            if (LOG.isDebugEnabled()) {\n+                LOG.debug(\"Try to set fenced state in file info {} : state bits {}.\", lf, stateBits);\n+            }\n+            if ((stateBits & STATE_FENCED_BIT) != STATE_FENCED_BIT) {\n+                // not fenced yet\n+                stateBits |= STATE_FENCED_BIT;\n+                needFlushHeader = true;\n+                synchronized (this) {\n+                    setChanged();\n+                }\n+                returnVal = true;\n+            }\n         }\n+        notifyObservers(new LastAddConfirmedUpdateNotification(Long.MAX_VALUE));\n+        return returnVal;\n     }\n \n     // flush the header when header is changed\n@@ -279,11 +314,28 @@ synchronized public long size() throws IOException {\n         return rc;\n     }\n \n-    public int read(ByteBuffer bb, long position) throws IOException {\n-        return readAbsolute(bb, position + START_OF_DATA);\n+    public int read(ByteBuffer bb, long position, boolean bestEffort)\n+            throws IOException {\n+        return readAbsolute(bb, position + START_OF_DATA, bestEffort);\n     }\n \n-    private int readAbsolute(ByteBuffer bb, long start) throws IOException {\n+    /**\n+     * Read data from position <i>start</i> to fill the byte buffer <i>bb</i>.\n+     * If <i>bestEffort </i> is provided, it would return when it reaches EOF.\n+     * Otherwise, it would throw {@link org.apache.bookkeeper.bookie.ShortReadException}\n+     * if it reaches EOF.\n+     *\n+     * @param bb\n+     *          byte buffer of data\n+     * @param start\n+     *          start position to read data\n+     * @param bestEffort\n+     *          flag indicates if it is a best-effort read\n+     * @return number of bytes read\n+     * @throws IOException\n+     */\n+    private int readAbsolute(ByteBuffer bb, long start, boolean bestEffort)\n+            throws IOException {\n         checkOpen(false);\n         synchronized (this) {\n             if (fc == null) {\n@@ -297,7 +349,11 @@ private int readAbsolute(ByteBuffer bb, long start) throws IOException {\n                 rc = fc.read(bb, start);\n             }\n             if (rc <= 0) {\n-                throw new IOException(\"Short read\");\n+                if (bestEffort) {\n+                    return total;\n+                } else {\n+                    throw new ShortReadException(\"Short read at \" + getLf().getPath() + \"@\" + start);\n+                }\n             }\n             total += rc;\n             // should move read position\n@@ -307,23 +363,30 @@ private int readAbsolute(ByteBuffer bb, long start) throws IOException {\n     }\n \n     /**\n-     * Close a file info\n+     * Close a file info. Generally, force should be set to true. If set to false metadata will not be flushed and\n+     * accessing metadata before restart and recovery will be unsafe (since reloading from the index file will\n+     * cause metadata to be lost). Setting force=false helps avoid expensive file create during shutdown with many\n+     * dirty ledgers, and is safe because ledger metadata will be recovered before being accessed again.\n      *\n      * @param force\n      *          if set to true, the index is forced to create before closed,\n      *          if set to false, the index is not forced to create.\n      */\n-    synchronized public void close(boolean force) throws IOException {\n-        isClosed = true;\n-        checkOpen(force);\n-        // Any time when we force close a file, we should try to flush header. otherwise, we might lose fence bit.\n-        if (force) {\n-            flushHeader();\n-        }\n-        if (useCount.get() == 0 && fc != null) {\n-            fc.close();\n-            fc = null;\n+    public void close(boolean force) throws IOException {\n+        synchronized (this) {\n+            isClosed = true;\n+            checkOpen(force, true);\n+            // Any time when we force close a file, we should try to flush header. otherwise, we might lose fence bit.\n+            if (force) {\n+                flushHeader();\n+            }\n+            setChanged();\n+            if (useCount.get() == 0 && fc != null) {\n+                fc.close();\n+                fc = null;\n+            }\n         }\n+        notifyObservers(new LastAddConfirmedUpdateNotification(Long.MAX_VALUE));\n     }\n \n     synchronized public long write(ByteBuffer[] buffs, long position) throws IOException {\n@@ -429,7 +492,7 @@ synchronized public void release() {\n         }\n     }\n \n-    public boolean delete() {\n+    public synchronized boolean delete() {\n         return lf.delete();\n     }\n \n@@ -443,7 +506,7 @@ static final private void checkParents(File f) throws IOException {\n         }\n     }\n \n-    public boolean isSameFile(File f) {\n+    public synchronized boolean isSameFile(File f) {\n         return this.lf.equals(f);\n     }\n }"},{"sha":"323ad62b9b5606e83e6778b6c82d130d4edae742","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/IndexPersistenceMgr.java","status":"modified","additions":24,"deletions":6,"changes":30,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/ee0dddee6849d1968500af666571df668d34393a/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FIndexPersistenceMgr.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/ee0dddee6849d1968500af666571df668d34393a/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FIndexPersistenceMgr.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FIndexPersistenceMgr.java?ref=ee0dddee6849d1968500af666571df668d34393a","patch":"@@ -20,6 +20,8 @@\n  */\n package org.apache.bookkeeper.bookie;\n \n+import com.google.common.annotations.VisibleForTesting;\n+import io.netty.buffer.ByteBuf;\n import java.io.File;\n import java.io.IOException;\n import java.nio.ByteBuffer;\n@@ -28,9 +30,10 @@\n import java.util.LinkedList;\n import java.util.List;\n import java.util.Map.Entry;\n+import java.util.Observable;\n+import java.util.Observer;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.ConcurrentMap;\n-\n import org.apache.bookkeeper.bookie.LedgerDirsManager.LedgerDirsListener;\n import org.apache.bookkeeper.bookie.LedgerDirsManager.NoWritableLedgerDirException;\n import org.apache.bookkeeper.conf.ServerConfiguration;\n@@ -41,10 +44,6 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import com.google.common.annotations.VisibleForTesting;\n-\n-import io.netty.buffer.ByteBuf;\n-\n import static org.apache.bookkeeper.bookie.BookKeeperServerStats.LEDGER_CACHE_NUM_EVICTED_LEDGERS;\n import static org.apache.bookkeeper.bookie.BookKeeperServerStats.NUM_OPEN_LEDGERS;\n \n@@ -333,6 +332,18 @@ Long getLastAddConfirmed(long ledgerId) throws IOException {\n             }\n         }\n     }\n+    \n+    Observable waitForLastAddConfirmedUpdate(long ledgerId, long previoisLAC, Observer observer) throws IOException {\n+        FileInfo fi = null;\n+        try {\n+            fi = getFileInfo(ledgerId, null);\n+            return fi.waitForLastAddConfirmedUpdate(previoisLAC, observer);\n+        } finally {\n+            if (null != fi) {\n+                fi.release();\n+            }\n+        }\n+    }\n \n     long updateLastAddConfirmed(long ledgerId, long lac) throws IOException {\n         FileInfo fi = null;\n@@ -626,7 +637,14 @@ long getPersistEntryBeyondInMem(long ledgerId, long lastEntryInMem) throws IOExc\n                 if (position < 0) {\n                     position = 0;\n                 }\n-                fi.read(bb, position);\n+                // we read the last page from file size minus page size, so it should not encounter short read\n+                // exception. if it does, it is an unexpected situation, then throw the exception and fail it immediately.\n+                try {\n+                    fi.read(bb, position, false);\n+                } catch (ShortReadException sre) {\n+                    // throw a more meaningful exception with ledger id\n+                    throw new ShortReadException(\"Short read on ledger \" + ledgerId + \" : \", sre);\n+                }\n                 bb.flip();\n                 long startingEntryId = position / LedgerEntryPage.getIndexEntrySize();\n                 for (int i = entriesPerPage - 1; i >= 0; i--) {"},{"sha":"3d8487774bdd48601431ce0b5271cce63b0714d3","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/InterleavedLedgerStorage.java","status":"modified","additions":14,"deletions":11,"changes":25,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/ee0dddee6849d1968500af666571df668d34393a/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FInterleavedLedgerStorage.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/ee0dddee6849d1968500af666571df668d34393a/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FInterleavedLedgerStorage.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FInterleavedLedgerStorage.java?ref=ee0dddee6849d1968500af666571df668d34393a","patch":"@@ -21,24 +21,23 @@\n \n package org.apache.bookkeeper.bookie;\n \n+import com.google.common.collect.Lists;\n+\n import io.netty.buffer.ByteBuf;\n import io.netty.buffer.Unpooled;\n-\n import java.io.File;\n import java.io.IOException;\n import java.nio.ByteBuffer;\n-\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Observable;\n+import java.util.Observer;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.TimeUnit;\n import org.apache.bookkeeper.bookie.Bookie.NoLedgerException;\n import org.apache.bookkeeper.bookie.CheckpointSource.Checkpoint;\n import org.apache.bookkeeper.bookie.EntryLogger.EntryLogListener;\n import org.apache.bookkeeper.bookie.LedgerDirsManager.LedgerDirsListener;\n-\n-import java.util.concurrent.CopyOnWriteArrayList;\n-import java.util.concurrent.TimeUnit;\n-\n-import java.util.Map;\n-import java.util.NavigableMap;\n-\n import org.apache.bookkeeper.conf.ServerConfiguration;\n import org.apache.bookkeeper.meta.LedgerManager;\n import org.apache.bookkeeper.proto.BookieProtocol;\n@@ -49,8 +48,6 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import com.google.common.collect.Lists;\n-\n import static org.apache.bookkeeper.bookie.BookKeeperServerStats.STORAGE_GET_ENTRY;\n import static org.apache.bookkeeper.bookie.BookKeeperServerStats.STORAGE_GET_OFFSET;\n \n@@ -263,6 +260,12 @@ public long getLastAddConfirmed(long ledgerId) throws IOException {\n         return lac;\n     }\n \n+    @Override\n+    public Observable waitForLastAddConfirmedUpdate(long ledgerId, long previoisLAC, Observer observer) throws IOException {\n+        return ledgerCache.waitForLastAddConfirmedUpdate(ledgerId, previoisLAC, observer);\n+    }\n+\n+\n     @Override\n     synchronized public long addEntry(ByteBuf entry) throws IOException {\n         long ledgerId = entry.getLong(entry.readerIndex() + 0);"},{"sha":"81cd8425051bf0d39d80ee6d5f8d4fcc58684a03","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LastAddConfirmedUpdateNotification.java","status":"added","additions":31,"deletions":0,"changes":31,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/ee0dddee6849d1968500af666571df668d34393a/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLastAddConfirmedUpdateNotification.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/ee0dddee6849d1968500af666571df668d34393a/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLastAddConfirmedUpdateNotification.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLastAddConfirmedUpdateNotification.java?ref=ee0dddee6849d1968500af666571df668d34393a","patch":"@@ -0,0 +1,31 @@\n+/**\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.bookie;\n+\n+public class LastAddConfirmedUpdateNotification {\n+    public long lastAddConfirmed;\n+    public long timestamp;\n+\n+    public LastAddConfirmedUpdateNotification(long lastAddConfirmed) {\n+        this.lastAddConfirmed = lastAddConfirmed;\n+        this.timestamp = System.currentTimeMillis();\n+    }\n+}"},{"sha":"26d5245a156128d9fea59c23543814d65ae81569","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCache.java","status":"modified","additions":4,"deletions":2,"changes":6,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/ee0dddee6849d1968500af666571df668d34393a/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLedgerCache.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/ee0dddee6849d1968500af666571df668d34393a/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLedgerCache.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLedgerCache.java?ref=ee0dddee6849d1968500af666571df668d34393a","patch":"@@ -21,10 +21,11 @@\n \n package org.apache.bookkeeper.bookie;\n \n+import io.netty.buffer.ByteBuf;\n import java.io.Closeable;\n import java.io.IOException;\n-\n-import io.netty.buffer.ByteBuf;\n+import java.util.Observable;\n+import java.util.Observer;\n \n /**\n  * This class maps a ledger entry number into a location (entrylogid, offset) in\n@@ -48,6 +49,7 @@ interface LedgerCache extends Closeable {\n \n     Long getLastAddConfirmed(long ledgerId) throws IOException;\n     long updateLastAddConfirmed(long ledgerId, long lac) throws IOException;\n+    Observable waitForLastAddConfirmedUpdate(long ledgerId, long previoisLAC, Observer observer) throws IOException;\n \n     void deleteLedger(long ledgerId) throws IOException;\n "},{"sha":"5709ce6fb4f86e8c0b9070a626430f626e07c635","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerCacheImpl.java","status":"modified","additions":8,"deletions":0,"changes":8,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/ee0dddee6849d1968500af666571df668d34393a/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLedgerCacheImpl.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/ee0dddee6849d1968500af666571df668d34393a/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLedgerCacheImpl.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLedgerCacheImpl.java?ref=ee0dddee6849d1968500af666571df668d34393a","patch":"@@ -23,6 +23,8 @@\n \n import java.io.IOException;\n \n+import java.util.Observable;\n+import java.util.Observer;\n import org.apache.bookkeeper.conf.ServerConfiguration;\n import org.apache.bookkeeper.stats.NullStatsLogger;\n import org.apache.bookkeeper.stats.StatsLogger;\n@@ -84,6 +86,12 @@ public long updateLastAddConfirmed(long ledgerId, long lac) throws IOException {\n         return indexPersistenceManager.updateLastAddConfirmed(ledgerId, lac);\n     }\n \n+    @Override\n+    public Observable waitForLastAddConfirmedUpdate(long ledgerId, long previoisLAC, Observer observer) throws IOException {\n+        return indexPersistenceManager.waitForLastAddConfirmedUpdate(ledgerId, previoisLAC, observer);\n+    }\n+\n+\n     @Override\n     public void putEntryOffset(long ledger, long entry, long offset) throws IOException {\n         indexPageManager.putEntryOffset(ledger, entry, offset);"},{"sha":"032dfe2f423e721f40d8c91c69bcb110e3f691ed","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDescriptor.java","status":"modified","additions":3,"deletions":0,"changes":3,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/ee0dddee6849d1968500af666571df668d34393a/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLedgerDescriptor.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/ee0dddee6849d1968500af666571df668d34393a/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLedgerDescriptor.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLedgerDescriptor.java?ref=ee0dddee6849d1968500af666571df668d34393a","patch":"@@ -24,6 +24,8 @@\n import io.netty.buffer.ByteBuf;\n \n import java.io.IOException;\n+import java.util.Observable;\n+import java.util.Observer;\n \n /**\n  * Implements a ledger inside a bookie. In particular, it implements operations\n@@ -58,6 +60,7 @@ static LedgerDescriptor createReadOnly(long ledgerId,\n     abstract ByteBuf readEntry(long entryId) throws IOException;\n \n     abstract long getLastAddConfirmed() throws IOException;\n+    abstract Observable waitForLastAddConfirmedUpdate(long previoisLAC, Observer observer) throws IOException;\n \n     abstract void setExplicitLac(ByteBuf entry) throws IOException;\n "},{"sha":"c2246bf883316a1bc9ba6f6e7a19e191d16a8864","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDescriptorImpl.java","status":"modified","additions":7,"deletions":2,"changes":9,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/ee0dddee6849d1968500af666571df668d34393a/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLedgerDescriptorImpl.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/ee0dddee6849d1968500af666571df668d34393a/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLedgerDescriptorImpl.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLedgerDescriptorImpl.java?ref=ee0dddee6849d1968500af666571df668d34393a","patch":"@@ -22,10 +22,10 @@\n package org.apache.bookkeeper.bookie;\n \n import io.netty.buffer.ByteBuf;\n-\n import java.io.IOException;\n import java.util.Arrays;\n-\n+import java.util.Observable;\n+import java.util.Observer;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -101,4 +101,9 @@ ByteBuf readEntry(long entryId) throws IOException {\n     long getLastAddConfirmed() throws IOException {\n         return ledgerStorage.getLastAddConfirmed(ledgerId);\n     }\n+\n+    @Override\n+    Observable waitForLastAddConfirmedUpdate(long previoisLAC, Observer observer) throws IOException {\n+        return ledgerStorage.waitForLastAddConfirmedUpdate(ledgerId, previoisLAC, observer);\n+    }\n }"},{"sha":"5aee2fe413d7d8cfb5873be5921373fe585e96b4","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerEntryPage.java","status":"modified","additions":25,"deletions":8,"changes":33,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/ee0dddee6849d1968500af666571df668d34393a/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLedgerEntryPage.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/ee0dddee6849d1968500af666571df668d34393a/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLedgerEntryPage.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLedgerEntryPage.java?ref=ee0dddee6849d1968500af666571df668d34393a","patch":"@@ -21,18 +21,22 @@\n \n package org.apache.bookkeeper.bookie;\n \n-import org.apache.bookkeeper.proto.BookieProtocol;\n-import org.apache.bookkeeper.util.ZeroBuffer;\n-\n import java.io.IOException;\n import java.nio.ByteBuffer;\n import java.util.concurrent.atomic.AtomicInteger;\n+import org.apache.bookkeeper.proto.BookieProtocol;\n+import org.apache.bookkeeper.util.ZeroBuffer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n /**\n  * This is a page in the LedgerCache. It holds the locations\n  * (entrylogfile, offset) for entry ids.\n  */\n public class LedgerEntryPage {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(LedgerEntryPage.class);\n+\n     private final static int indexEntrySize = 8;\n     private final int pageSize;\n     private final int entriesPerPage;\n@@ -153,11 +157,24 @@ public void zeroPage() {\n     public void readPage(FileInfo fi) throws IOException {\n         checkPage();\n         page.clear();\n-        while(page.remaining() != 0) {\n-            if (fi.read(page, getFirstEntryPosition()) <= 0) {\n-                throw new IOException(\"Short page read of ledger \" + getLedger()\n-                                + \" tried to get \" + page.capacity() + \" from position \" + getFirstEntryPosition()\n-                                + \" still need \" + page.remaining());\n+        try {\n+            fi.read(page, getFirstEntryPosition(), true);\n+        } catch (ShortReadException sre) {\n+            throw new ShortReadException(\"Short page read of ledger \" + getLedger()\n+                    + \" tried to get \" + page.capacity() + \" from position \"\n+                    + getFirstEntryPosition() + \" still need \" + page.remaining(), sre);\n+        } catch (IllegalArgumentException iae) {\n+            LOG.error(\"IllegalArgumentException when trying to read ledger {} from position {}\"\n+                , new Object[]{getLedger(), getFirstEntryPosition(), iae});\n+            throw iae;\n+        }\n+        // make sure we don't include partial index entry\n+        if (page.remaining() != 0) {\n+            LOG.info(\"Short page read of ledger {} : tried to read {} bytes from position {}, but only {} bytes read.\",\n+                     new Object[] { getLedger(), page.capacity(), getFirstEntryPosition(), page.position() });\n+            if (page.position() % indexEntrySize != 0) {\n+                int partialIndexEntryStart = page.position() - page.position() % indexEntrySize;\n+                page.putLong(partialIndexEntryStart, 0L);\n             }\n         }\n         last = getLastEntryIndex();"},{"sha":"9fc93905589bc17aa2cb57fb3909c859aa6e19f5","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerStorage.java","status":"modified","additions":12,"deletions":2,"changes":14,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/ee0dddee6849d1968500af666571df668d34393a/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLedgerStorage.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/ee0dddee6849d1968500af666571df668d34393a/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLedgerStorage.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLedgerStorage.java?ref=ee0dddee6849d1968500af666571df668d34393a","patch":"@@ -22,9 +22,9 @@\n package org.apache.bookkeeper.bookie;\n \n import io.netty.buffer.ByteBuf;\n-\n import java.io.IOException;\n-\n+import java.util.Observable;\n+import java.util.Observer;\n import org.apache.bookkeeper.bookie.CheckpointSource.Checkpoint;\n import org.apache.bookkeeper.conf.ServerConfiguration;\n import org.apache.bookkeeper.stats.StatsLogger;\n@@ -117,6 +117,16 @@ public void initialize(ServerConfiguration conf, LedgerManager ledgerManager,\n      */\n     long getLastAddConfirmed(long ledgerId) throws IOException;\n \n+    /**\n+     * Wait for last add confirmed update.\n+     *\n+     * @param previoisLAC - The threshold beyond which we would wait for the update\n+     * @param observer  - Observer to notify on update\n+     * @return\n+     * @throws IOException\n+     */\n+    Observable waitForLastAddConfirmedUpdate(long ledgerId, long previoisLAC, Observer observer) throws IOException;\n+\n     /**\n      * Flushes all data in the storage. Once this is called,\n      * add data written to the LedgerStorage up until this point"},{"sha":"302cc46227fd88911487600a3f617651d4d1dcba","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/ShortReadException.java","status":"added","additions":37,"deletions":0,"changes":37,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/ee0dddee6849d1968500af666571df668d34393a/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FShortReadException.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/ee0dddee6849d1968500af666571df668d34393a/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FShortReadException.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FShortReadException.java?ref=ee0dddee6849d1968500af666571df668d34393a","patch":"@@ -0,0 +1,37 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.bookkeeper.bookie;\n+\n+import java.io.IOException;\n+\n+/**\n+ * Short Read Exception. Used to distinguish short read exception with other {@link java.io.IOException}s.\n+ */\n+public class ShortReadException extends IOException {\n+\n+    private static final long serialVersionUID = -4201771547564923223L;\n+\n+    public ShortReadException(String msg) {\n+        super(msg);\n+    }\n+\n+    public ShortReadException(String msg, Throwable t) {\n+        super(msg, t);\n+    }\n+\n+}"},{"sha":"8f5bdeae37c176e8db2e35f06421fd8037d52d8c","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/AsyncCallback.java","status":"modified","additions":16,"deletions":0,"changes":16,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/ee0dddee6849d1968500af666571df668d34393a/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FAsyncCallback.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/ee0dddee6849d1968500af666571df668d34393a/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FAsyncCallback.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FAsyncCallback.java?ref=ee0dddee6849d1968500af666571df668d34393a","patch":"@@ -139,6 +139,22 @@ public interface ReadLastConfirmedCallback {\n         void readLastConfirmedComplete(int rc, long lastConfirmed, Object ctx);\n     }\n \n+    public interface ReadLastConfirmedAndEntryCallback {\n+        /**\n+         * Callback definition for bookie operation that allows reading the last add confirmed\n+         * along with an entry within the last add confirmed range\n+         *\n+         * @param rc Return code\n+         * @param lastConfirmed The entry id of the last confirmed write or\n+         *                      {@link LedgerHandle#INVALID_ENTRY_ID INVALID_ENTRY_ID}\n+         *                      if no entry has been confirmed\n+         * @param entry The entry since the lastAddConfirmed entry that was specified when the request\n+         *              was initiated\n+         * @param ctx context object\n+         */\n+        void readLastConfirmedAndEntryComplete(int rc, long lastConfirmed, LedgerEntry entry, Object ctx);\n+    }\n+\n     public interface RecoverCallback {\n         /**\n          * Callback definition for bookie recover operations"},{"sha":"7895af2399e18ba44556382ad725697942a12edb","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeper.java","status":"modified","additions":22,"deletions":0,"changes":22,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/ee0dddee6849d1968500af666571df668d34393a/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookKeeper.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/ee0dddee6849d1968500af666571df668d34393a/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookKeeper.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookKeeper.java?ref=ee0dddee6849d1968500af666571df668d34393a","patch":"@@ -99,6 +99,8 @@ public class BookKeeper implements AutoCloseable {\n     private OpStatsLogger deleteOpLogger;\n     private OpStatsLogger recoverOpLogger;\n     private OpStatsLogger readOpLogger;\n+    private OpStatsLogger readLacAndEntryOpLogger;\n+    private OpStatsLogger readLacAndEntryRespLogger;\n     private OpStatsLogger addOpLogger;\n     private OpStatsLogger writeLacOpLogger;\n     private OpStatsLogger readLacOpLogger;\n@@ -137,8 +139,10 @@ public class BookKeeper implements AutoCloseable {\n     final ClientConfiguration conf;\n     final int explicitLacInterval;\n     final boolean delayEnsembleChange;\n+    final boolean reorderReadSequence;\n \n     final Optional<SpeculativeRequestExecutionPolicy> readSpeculativeRequestPolicy;\n+    final Optional<SpeculativeRequestExecutionPolicy> readLACSpeculativeRequestPolicy;\n \n     // Close State\n     boolean closed = false;\n@@ -301,6 +305,7 @@ private BookKeeper(ClientConfiguration conf,\n             throws IOException, InterruptedException, KeeperException {\n         this.conf = conf;\n         this.delayEnsembleChange = conf.getDelayEnsembleChange();\n+        this.reorderReadSequence = conf.isReorderReadSequenceEnabled();\n \n         // initialize zookeeper client\n         if (zkc == null) {\n@@ -374,6 +379,15 @@ private BookKeeper(ClientConfiguration conf,\n             this.readSpeculativeRequestPolicy = Optional.<SpeculativeRequestExecutionPolicy>absent();\n         }\n \n+        if (conf.getFirstSpeculativeReadLACTimeout() > 0) {\n+            this.readLACSpeculativeRequestPolicy =\n+                    Optional.of((SpeculativeRequestExecutionPolicy)(new DefaultSpeculativeRequestExecutionPolicy(\n+                        conf.getFirstSpeculativeReadLACTimeout(),\n+                        conf.getMaxSpeculativeReadLACTimeout(),\n+                        conf.getSpeculativeReadLACTimeoutBackoffMultiplier())));\n+        } else {\n+            this.readLACSpeculativeRequestPolicy = Optional.<SpeculativeRequestExecutionPolicy>absent();\n+        }\n         // initialize main worker pool\n         this.mainWorkerPool = OrderedSafeExecutor.newBuilder()\n                 .name(\"BookKeeperClientWorker\")\n@@ -504,6 +518,10 @@ public Optional<SpeculativeRequestExecutionPolicy> getReadSpeculativeRequestPoli\n         return readSpeculativeRequestPolicy;\n     }\n \n+    public Optional<SpeculativeRequestExecutionPolicy> getReadLACSpeculativeRequestPolicy() {\n+        return readLACSpeculativeRequestPolicy;\n+    }\n+\n     /**\n      * Get the BookieClient, currently used for doing bookie recovery.\n      *\n@@ -1275,6 +1293,8 @@ private final void initOpLoggers(StatsLogger stats) {\n         openOpLogger = stats.getOpStatsLogger(BookKeeperClientStats.OPEN_OP);\n         recoverOpLogger = stats.getOpStatsLogger(BookKeeperClientStats.RECOVER_OP);\n         readOpLogger = stats.getOpStatsLogger(BookKeeperClientStats.READ_OP);\n+        readLacAndEntryOpLogger = stats.getOpStatsLogger(BookKeeperClientStats.READ_LAST_CONFIRMED_AND_ENTRY);\n+        readLacAndEntryRespLogger = stats.getOpStatsLogger(BookKeeperClientStats.READ_LAST_CONFIRMED_AND_ENTRY_RESPONSE);\n         addOpLogger = stats.getOpStatsLogger(BookKeeperClientStats.ADD_OP);\n         writeLacOpLogger = stats.getOpStatsLogger(BookKeeperClientStats.WRITE_LAC_OP);\n         readLacOpLogger = stats.getOpStatsLogger(BookKeeperClientStats.READ_LAC_OP);\n@@ -1287,6 +1307,8 @@ private final void initOpLoggers(StatsLogger stats) {\n     OpStatsLogger getDeleteOpLogger() { return deleteOpLogger; }\n     OpStatsLogger getRecoverOpLogger() { return recoverOpLogger; }\n     OpStatsLogger getReadOpLogger() { return readOpLogger; }\n+    OpStatsLogger getReadLacAndEntryOpLogger() { return readLacAndEntryOpLogger; }\n+    OpStatsLogger getReadLacAndEntryRespLogger() { return readLacAndEntryRespLogger; }\n     OpStatsLogger getAddOpLogger() { return addOpLogger; }\n     OpStatsLogger getWriteLacOpLogger() { return writeLacOpLogger; }\n     OpStatsLogger getReadLacOpLogger() { return readLacOpLogger; }"},{"sha":"15c62485972c3dfbbecf6fe4a012a48a5b812761","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeperClientStats.java","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/ee0dddee6849d1968500af666571df668d34393a/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookKeeperClientStats.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/ee0dddee6849d1968500af666571df668d34393a/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookKeeperClientStats.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookKeeperClientStats.java?ref=ee0dddee6849d1968500af666571df668d34393a","patch":"@@ -39,6 +39,8 @@ public interface BookKeeperClientStats {\n     public final static String READ_OP = \"READ_ENTRY\";\n     public final static String WRITE_LAC_OP = \"WRITE_LAC\";\n     public final static String READ_LAC_OP = \"READ_LAC\";\n+    public final static String READ_LAST_CONFIRMED_AND_ENTRY = \"READ_LAST_CONFIRMED_AND_ENTRY\";\n+    public final static String READ_LAST_CONFIRMED_AND_ENTRY_RESPONSE = \"READ_LAST_CONFIRMED_AND_ENTRY_RESPONSE\";\n     public final static String PENDING_ADDS = \"NUM_PENDING_ADD\";\n     public final static String ENSEMBLE_CHANGES = \"NUM_ENSEMBLE_CHANGE\";\n     public final static String LAC_UPDATE_HITS = \"LAC_UPDATE_HITS\";"},{"sha":"a0560432df727ec0e77a8d473a110f40a4fdfc2a","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","status":"modified","additions":94,"deletions":0,"changes":94,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/ee0dddee6849d1968500af666571df668d34393a/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FLedgerHandle.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/ee0dddee6849d1968500af666571df668d34393a/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FLedgerHandle.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FLedgerHandle.java?ref=ee0dddee6849d1968500af666571df668d34393a","patch":"@@ -22,6 +22,9 @@\n \n import com.google.common.annotations.VisibleForTesting;\n import com.google.common.base.Objects;\n+import com.google.common.cache.CacheBuilder;\n+import com.google.common.cache.CacheLoader;\n+import com.google.common.cache.LoadingCache;\n import com.google.common.collect.Sets;\n import com.google.common.util.concurrent.RateLimiter;\n import io.netty.buffer.ByteBuf;\n@@ -39,6 +42,7 @@\n import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.RejectedExecutionException;\n+import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicInteger;\n import org.apache.bookkeeper.client.AsyncCallback.AddCallback;\n@@ -78,6 +82,7 @@ public class LedgerHandle implements AutoCloseable {\n     final DigestManager macManager;\n     final DistributionSchedule distributionSchedule;\n     final RateLimiter throttler;\n+    final LoadingCache<BookieSocketAddress, Long> bookieFailureHistory;\n     final boolean enableParallelRecoveryRead;\n     final int recoveryReadBatchSize;\n \n@@ -138,6 +143,13 @@ public class LedgerHandle implements AutoCloseable {\n         this.ledgerKey = password.length > 0 ? MacDigestManager.genDigest(\"ledger\", password) : emptyLedgerKey;\n         distributionSchedule = new RoundRobinDistributionSchedule(\n                 metadata.getWriteQuorumSize(), metadata.getAckQuorumSize(), metadata.getEnsembleSize());\n+        this.bookieFailureHistory = CacheBuilder.newBuilder()\n+            .expireAfterWrite(bk.getConf().getBookieFailureHistoryExpirationMSec(), TimeUnit.MILLISECONDS)\n+            .build(new CacheLoader<BookieSocketAddress, Long>() {\n+            public Long load(BookieSocketAddress key) {\n+                return -1L;\n+            }\n+        });\n \n         ensembleChangeCounter = bk.getStatsLogger().getCounter(BookKeeperClientStats.ENSEMBLE_CHANGES);\n         lacUpdateHitsCounter = bk.getStatsLogger().getCounter(BookKeeperClientStats.LAC_UPDATE_HITS);\n@@ -957,6 +969,81 @@ public void readLastConfirmedDataComplete(int rc, DigestManager.RecoveryData dat\n         new TryReadLastConfirmedOp(this, innercb, getLastAddConfirmed()).initiate();\n     }\n \n+\n+    /**\n+     * Asynchronous read next entry and the latest last add confirmed.\n+     * If the next entryId is less than known last add confirmed, the call will read next entry directly.\n+     * If the next entryId is ahead of known last add confirmed, the call will issue a long poll read\n+     * to wait for the next entry <i>entryId</i>.\n+     *\n+     * The callback will return the latest last add confirmed and next entry if it is available within timeout period <i>timeOutInMillis</i>.\n+     *\n+     * @param entryId\n+     *          next entry id to read\n+     * @param timeOutInMillis\n+     *          timeout period to wait for the entry id to be available (for long poll only)\n+     * @param parallel\n+     *          whether to issue the long poll reads in parallel\n+     * @param cb\n+     *          callback to return the result\n+     * @param ctx\n+     *          callback context\n+     */\n+    public void asyncReadLastConfirmedAndEntry(final long entryId,\n+                                               final long timeOutInMillis,\n+                                               final boolean parallel,\n+                                               final AsyncCallback.ReadLastConfirmedAndEntryCallback cb,\n+                                               final Object ctx) {\n+        boolean isClosed;\n+        long lac;\n+        synchronized (this) {\n+            isClosed = metadata.isClosed();\n+            lac = metadata.getLastEntryId();\n+        }\n+        if (isClosed) {\n+            if (entryId > lac) {\n+                cb.readLastConfirmedAndEntryComplete(BKException.Code.OK, lac, null, ctx);\n+                return;\n+            }\n+        } else {\n+            lac = getLastAddConfirmed();\n+        }\n+        if (entryId <= lac) {\n+            asyncReadEntries(entryId, entryId, new ReadCallback() {\n+                @Override\n+                public void readComplete(int rc, LedgerHandle lh, Enumeration<LedgerEntry> seq, Object ctx) {\n+                    if (BKException.Code.OK == rc) {\n+                        if (seq.hasMoreElements()) {\n+                            cb.readLastConfirmedAndEntryComplete(rc, getLastAddConfirmed(), seq.nextElement(), ctx);\n+                        } else {\n+                            cb.readLastConfirmedAndEntryComplete(rc, getLastAddConfirmed(), null, ctx);\n+                        }\n+                    } else {\n+                        cb.readLastConfirmedAndEntryComplete(rc, INVALID_ENTRY_ID, null, ctx);\n+                    }\n+                }\n+            }, ctx);\n+            return;\n+        }\n+        // wait for entry <i>entryId</i>\n+        ReadLastConfirmedAndEntryOp.LastConfirmedAndEntryCallback innercb = new ReadLastConfirmedAndEntryOp.LastConfirmedAndEntryCallback() {\n+            AtomicBoolean completed = new AtomicBoolean(false);\n+            @Override\n+            public void readLastConfirmedAndEntryComplete(int rc, long lastAddConfirmed, LedgerEntry entry) {\n+                if (rc == BKException.Code.OK) {\n+                    if (completed.compareAndSet(false, true)) {\n+                        cb.readLastConfirmedAndEntryComplete(rc, lastAddConfirmed, entry, ctx);\n+                    }\n+                } else {\n+                    if (completed.compareAndSet(false, true)) {\n+                        cb.readLastConfirmedAndEntryComplete(rc, INVALID_ENTRY_ID, null, ctx);\n+                    }\n+                }\n+            }\n+        };\n+        new ReadLastConfirmedAndEntryOp(this, innercb, entryId - 1, timeOutInMillis, bk.scheduler).parallelRead(parallel).initiate();\n+    }\n+\n     /**\n      * Context objects for synchronous call to read last confirmed.\n      */\n@@ -1545,6 +1632,13 @@ void rereadMetadata(final GenericCallback<LedgerMetadata> cb) {\n         bk.getLedgerManager().readLedgerMetadata(ledgerId, cb);\n     }\n \n+    void registerOperationFailureOnBookie(BookieSocketAddress bookie, long entryId) {\n+        if (bk.getConf().getEnableBookieFailureTracking()) {\n+            bookieFailureHistory.put(bookie, entryId);\n+        }\n+    }\n+\n+\n     void recover(GenericCallback<Void> finalCb) {\n         recover(finalCb, null, false);\n     }"},{"sha":"c820122da494928bdf6054b5fd64d804ef95212b","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingReadOp.java","status":"modified","additions":7,"deletions":1,"changes":8,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/ee0dddee6849d1968500af666571df668d34393a/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FPendingReadOp.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/ee0dddee6849d1968500af666571df668d34393a/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FPendingReadOp.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FPendingReadOp.java?ref=ee0dddee6849d1968500af666571df668d34393a","patch":"@@ -92,7 +92,13 @@ abstract class LedgerEntryRequest extends LedgerEntry implements SpeculativeRequ\n             super(lId, eId);\n \n             this.ensemble = ensemble;\n-            this.writeSet = lh.distributionSchedule.getWriteSet(entryId);\n+\n+            if (lh.bk.reorderReadSequence) {\n+                this.writeSet = lh.bk.placementPolicy.reorderReadSequence(ensemble,\n+                    lh.distributionSchedule.getWriteSet(entryId), lh.bookieFailureHistory.asMap());\n+            } else {\n+                this.writeSet = lh.distributionSchedule.getWriteSet(entryId);\n+            }\n         }\n \n         /**"},{"sha":"2fab6948aab8ca25eb3aac073be55977cfd2daff","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/ReadLastConfirmedAndEntryOp.java","status":"added","additions":620,"deletions":0,"changes":620,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/ee0dddee6849d1968500af666571df668d34393a/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FReadLastConfirmedAndEntryOp.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/ee0dddee6849d1968500af666571df668d34393a/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FReadLastConfirmedAndEntryOp.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FReadLastConfirmedAndEntryOp.java?ref=ee0dddee6849d1968500af666571df668d34393a","patch":"@@ -0,0 +1,620 @@\n+/**\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.client;\n+\n+import io.netty.buffer.ByteBuf;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import com.google.common.base.Optional;\n+import com.google.common.util.concurrent.ListenableFuture;\n+\n+import org.apache.bookkeeper.net.BookieSocketAddress;\n+import org.apache.bookkeeper.proto.BookieProtocol;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks;\n+import org.apache.bookkeeper.util.MathUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class ReadLastConfirmedAndEntryOp implements BookkeeperInternalCallbacks.ReadEntryCallback, SpeculativeRequestExectuor {\n+    static final Logger LOG = LoggerFactory.getLogger(ReadLastConfirmedAndEntryOp.class);\n+\n+    final private ScheduledExecutorService scheduler;\n+    ReadLACAndEntryRequest request;\n+    final BitSet heardFromHostsBitSet;\n+    final BitSet emptyResponsesFromHostsBitSet;\n+    final int maxMissedReadsAllowed;\n+    boolean parallelRead = false;\n+    final AtomicBoolean requestComplete = new AtomicBoolean(false);\n+\n+    final long requestTimeNano;\n+    private final LedgerHandle lh;\n+    private final LastConfirmedAndEntryCallback cb;\n+\n+    private int numResponsesPending;\n+    private final int numEmptyResponsesAllowed;\n+    private volatile boolean hasValidResponse = false;\n+    private final long prevEntryId;\n+    private long lastAddConfirmed;\n+    private long timeOutInMillis;\n+\n+    abstract class ReadLACAndEntryRequest extends LedgerEntry {\n+\n+        final AtomicBoolean complete = new AtomicBoolean(false);\n+\n+        int rc = BKException.Code.OK;\n+        int firstError = BKException.Code.OK;\n+        int numMissedEntryReads = 0;\n+\n+        final ArrayList<BookieSocketAddress> ensemble;\n+        final List<Integer> writeSet;\n+        final List<Integer> orderedEnsemble;\n+\n+        ReadLACAndEntryRequest(ArrayList<BookieSocketAddress> ensemble, long lId, long eId) {\n+            super(lId, eId);\n+\n+            this.ensemble = ensemble;\n+            this.writeSet = lh.distributionSchedule.getWriteSet(entryId);\n+            if (lh.bk.reorderReadSequence) {\n+                this.orderedEnsemble = lh.bk.placementPolicy.reorderReadLACSequence(ensemble,\n+                    writeSet, lh.bookieFailureHistory.asMap());\n+            } else {\n+                this.orderedEnsemble = writeSet;\n+            }\n+        }\n+\n+        synchronized int getFirstError() {\n+            return firstError;\n+        }\n+\n+        /**\n+         * Execute the read request.\n+         */\n+        abstract void read();\n+\n+        /**\n+         * Complete the read request from <i>host</i>.\n+         *\n+         * @param bookieIndex\n+         *          bookie index\n+         * @param host\n+         *          host that respond the read\n+         * @param buffer\n+         *          the data buffer\n+         * @return return true if we managed to complete the entry;\n+         *         otherwise return false if the read entry is not complete or it is already completed before\n+         */\n+        boolean complete(int bookieIndex, BookieSocketAddress host, final ByteBuf buffer, long entryId) {\n+            ByteBuf content;\n+            try {\n+                content = lh.macManager.verifyDigestAndReturnData(entryId, buffer);\n+            } catch (BKException.BKDigestMatchException e) {\n+                logErrorAndReattemptRead(bookieIndex, host, \"Mac mismatch\", BKException.Code.DigestMatchException);\n+                buffer.release();\n+                return false;\n+            }\n+\n+            if (!complete.getAndSet(true)) {\n+                rc = BKException.Code.OK;\n+                this.entryId = entryId;\n+                /*\n+                 * The length is a long and it is the last field of the metadata of an entry.\n+                 * Consequently, we have to subtract 8 from METADATA_LENGTH to get the length.\n+                 */\n+                length = buffer.getLong(DigestManager.METADATA_LENGTH - 8);\n+                data = content;\n+                return true;\n+            } else {\n+                return false;\n+            }\n+        }\n+\n+        /**\n+         * Fail the request with given result code <i>rc</i>.\n+         *\n+         * @param rc\n+         *          result code to fail the request.\n+         * @return true if we managed to fail the entry; otherwise return false if it already failed or completed.\n+         */\n+        boolean fail(int rc) {\n+            if (complete.compareAndSet(false, true)) {\n+                this.rc = rc;\n+                translateAndSetFirstError(rc);\n+                completeRequest();\n+                return true;\n+            } else {\n+                return false;\n+            }\n+        }\n+\n+        synchronized private void translateAndSetFirstError(int rc) {\n+            if (BKException.Code.OK == firstError ||\n+                BKException.Code.NoSuchEntryException == firstError ||\n+                BKException.Code.NoSuchLedgerExistsException == firstError) {\n+                firstError = rc;\n+            } else if (BKException.Code.BookieHandleNotAvailableException == firstError &&\n+                BKException.Code.NoSuchEntryException != rc &&\n+                BKException.Code.NoSuchLedgerExistsException != rc) {\n+                // if other exception rather than NoSuchEntryException is returned\n+                // we need to update firstError to indicate that it might be a valid read but just failed.\n+                firstError = rc;\n+            }\n+        }\n+\n+        /**\n+         * Log error <i>errMsg</i> and reattempt read from <i>host</i>.\n+         *\n+         * @param bookieIndex\n+         *          bookie index\n+         * @param host\n+         *          host that just respond\n+         * @param errMsg\n+         *          error msg to log\n+         * @param rc\n+         *          read result code\n+         */\n+        synchronized void logErrorAndReattemptRead(int bookieIndex, BookieSocketAddress host, String errMsg, int rc) {\n+            translateAndSetFirstError(rc);\n+\n+            if (BKException.Code.NoSuchEntryException == rc ||\n+                BKException.Code.NoSuchLedgerExistsException == rc) {\n+                // Since we send all long poll requests to every available node, we should only\n+                // treat these errors as failures if the node from which we received this is part of\n+                // the writeSet\n+                if (this.writeSet.contains(bookieIndex)) {\n+                    lh.registerOperationFailureOnBookie(host, entryId);\n+                }\n+                ++numMissedEntryReads;\n+            }\n+\n+            if (LOG.isDebugEnabled()) {\n+                LOG.debug(errMsg + \" while reading entry: \" + entryId + \" ledgerId: \" + lh.ledgerId + \" from bookie: \"\n+                    + host);\n+            }\n+        }\n+\n+        /**\n+         * Send to next replica speculatively, if required and possible.\n+         * This returns the host we may have sent to for unit testing.\n+         *\n+         * @param heardFromHostsBitSet\n+         *      the set of hosts that we already received responses.\n+         * @return host we sent to if we sent. null otherwise.\n+         */\n+        abstract BookieSocketAddress maybeSendSpeculativeRead(BitSet heardFromHostsBitSet);\n+\n+        /**\n+         * Whether the read request completed.\n+         *\n+         * @return true if the read request is completed.\n+         */\n+        boolean isComplete() {\n+            return complete.get();\n+        }\n+\n+        /**\n+         * Get result code of this entry.\n+         *\n+         * @return result code.\n+         */\n+        int getRc() {\n+            return rc;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"L%d-E%d\", ledgerId, entryId);\n+        }\n+    }\n+\n+    class ParallelReadRequest extends ReadLACAndEntryRequest {\n+\n+        int numPendings;\n+\n+        ParallelReadRequest(ArrayList<BookieSocketAddress> ensemble, long lId, long eId) {\n+            super(ensemble, lId, eId);\n+            numPendings = orderedEnsemble.size();\n+        }\n+\n+        @Override\n+        void read() {\n+            for (int bookieIndex : orderedEnsemble) {\n+                BookieSocketAddress to = ensemble.get(bookieIndex);\n+                try {\n+                    sendReadTo(bookieIndex, to, this);\n+                } catch (InterruptedException ie) {\n+                    LOG.error(\"Interrupted reading entry {} : \", this, ie);\n+                    Thread.currentThread().interrupt();\n+                    fail(BKException.Code.InterruptedException);\n+                    return;\n+                }\n+            }\n+        }\n+\n+        @Override\n+        synchronized void logErrorAndReattemptRead(int bookieIndex, BookieSocketAddress host, String errMsg, int rc) {\n+            super.logErrorAndReattemptRead(bookieIndex, host, errMsg, rc);\n+            --numPendings;\n+            // if received all responses or this entry doesn't meet quorum write, complete the request.\n+            if (numMissedEntryReads > maxMissedReadsAllowed || numPendings == 0) {\n+                if (BKException.Code.BookieHandleNotAvailableException == firstError &&\n+                    numMissedEntryReads > maxMissedReadsAllowed) {\n+                    firstError = BKException.Code.NoSuchEntryException;\n+                }\n+\n+                fail(firstError);\n+            }\n+        }\n+\n+        @Override\n+        BookieSocketAddress maybeSendSpeculativeRead(BitSet heardFromHostsBitSet) {\n+            // no speculative read\n+            return null;\n+        }\n+    }\n+\n+    class SequenceReadRequest extends ReadLACAndEntryRequest {\n+        final static int NOT_FOUND = -1;\n+        int nextReplicaIndexToReadFrom = 0;\n+\n+        final BitSet sentReplicas;\n+        final BitSet erroredReplicas;\n+        final BitSet emptyResponseReplicas;\n+\n+        SequenceReadRequest(ArrayList<BookieSocketAddress> ensemble, long lId, long eId) {\n+            super(ensemble, lId, eId);\n+\n+            this.sentReplicas = new BitSet(orderedEnsemble.size());\n+            this.erroredReplicas = new BitSet(orderedEnsemble.size());\n+            this.emptyResponseReplicas = new BitSet(orderedEnsemble.size());\n+        }\n+\n+        private synchronized int getNextReplicaIndexToReadFrom() {\n+            return nextReplicaIndexToReadFrom;\n+        }\n+\n+        private int getReplicaIndex(int bookieIndex) {\n+            return orderedEnsemble.indexOf(bookieIndex);\n+        }\n+\n+        private BitSet getSentToBitSet() {\n+            BitSet b = new BitSet(ensemble.size());\n+\n+            for (int i = 0; i < sentReplicas.length(); i++) {\n+                if (sentReplicas.get(i)) {\n+                    b.set(orderedEnsemble.get(i));\n+                }\n+            }\n+            return b;\n+        }\n+\n+        private boolean readsOutstanding() {\n+            return (sentReplicas.cardinality() - erroredReplicas.cardinality() - emptyResponseReplicas.cardinality()) > 0;\n+        }\n+\n+        /**\n+         * Send to next replica speculatively, if required and possible.\n+         * This returns the host we may have sent to for unit testing.\n+         * @return host we sent to if we sent. null otherwise.\n+         */\n+        @Override\n+        synchronized BookieSocketAddress maybeSendSpeculativeRead(BitSet heardFrom) {\n+            if (nextReplicaIndexToReadFrom >= getLedgerMetadata().getEnsembleSize()) {\n+                return null;\n+            }\n+\n+            BitSet sentTo = getSentToBitSet();\n+            sentTo.and(heardFrom);\n+\n+            // only send another read, if we have had no response at all (even for other entries)\n+            // from any of the other bookies we have sent the request to\n+            if (sentTo.cardinality() == 0) {\n+                return sendNextRead();\n+            } else {\n+                return null;\n+            }\n+        }\n+\n+        @Override\n+        void read() {\n+            sendNextRead();\n+        }\n+\n+        synchronized BookieSocketAddress sendNextRead() {\n+            if (nextReplicaIndexToReadFrom >= getLedgerMetadata().getEnsembleSize()) {\n+                // we are done, the read has failed from all replicas, just fail the\n+                // read\n+\n+                // Do it a bit pessimistically, only when finished trying all replicas\n+                // to check whether we received more missed reads than maxMissedReadsAllowed\n+                if (BKException.Code.BookieHandleNotAvailableException == firstError &&\n+                    numMissedEntryReads > maxMissedReadsAllowed) {\n+                    firstError = BKException.Code.NoSuchEntryException;\n+                }\n+\n+                fail(firstError);\n+                return null;\n+            }\n+\n+            int replica = nextReplicaIndexToReadFrom;\n+            int bookieIndex = orderedEnsemble.get(nextReplicaIndexToReadFrom);\n+            nextReplicaIndexToReadFrom++;\n+\n+            try {\n+                BookieSocketAddress to = ensemble.get(bookieIndex);\n+                sendReadTo(bookieIndex, to, this);\n+                sentReplicas.set(replica);\n+                return to;\n+            } catch (InterruptedException ie) {\n+                LOG.error(\"Interrupted reading entry \" + this, ie);\n+                Thread.currentThread().interrupt();\n+                fail(BKException.Code.InterruptedException);\n+                return null;\n+            }\n+        }\n+\n+        @Override\n+        synchronized void logErrorAndReattemptRead(int bookieIndex, BookieSocketAddress host, String errMsg, int rc) {\n+            super.logErrorAndReattemptRead(bookieIndex, host, errMsg, rc);\n+\n+            int replica = getReplicaIndex(bookieIndex);\n+            if (replica == NOT_FOUND) {\n+                LOG.error(\"Received error from a host which is not in the ensemble {} {}.\", host, ensemble);\n+                return;\n+            }\n+\n+            if (BKException.Code.OK == rc) {\n+                emptyResponseReplicas.set(replica);\n+            } else {\n+                erroredReplicas.set(replica);\n+            }\n+\n+            if (!readsOutstanding()) {\n+                sendNextRead();\n+            }\n+        }\n+\n+    }\n+\n+    ReadLastConfirmedAndEntryOp(LedgerHandle lh,\n+                                LastConfirmedAndEntryCallback cb,\n+                                long prevEntryId,\n+                                long timeOutInMillis,\n+                                ScheduledExecutorService scheduler) {\n+        this.lh = lh;\n+        this.cb = cb;\n+        this.prevEntryId = prevEntryId;\n+        this.lastAddConfirmed = lh.getLastAddConfirmed();\n+        this.timeOutInMillis = timeOutInMillis;\n+        this.numResponsesPending = 0;\n+        this.numEmptyResponsesAllowed = getLedgerMetadata().getWriteQuorumSize()\n+                - getLedgerMetadata().getAckQuorumSize() + 1;\n+        this.requestTimeNano = MathUtils.nowInNano();\n+        this.scheduler = scheduler;\n+        maxMissedReadsAllowed = getLedgerMetadata().getEnsembleSize()\n+            - getLedgerMetadata().getAckQuorumSize();\n+        heardFromHostsBitSet = new BitSet(getLedgerMetadata().getEnsembleSize());\n+        emptyResponsesFromHostsBitSet = new BitSet(getLedgerMetadata().getEnsembleSize());\n+    }\n+\n+    protected LedgerMetadata getLedgerMetadata() {\n+        return lh.metadata;\n+    }\n+\n+    ReadLastConfirmedAndEntryOp parallelRead(boolean enabled) {\n+        this.parallelRead = enabled;\n+        return this;\n+    }\n+\n+    /**\n+     * Speculative Read Logic\n+     */\n+    @Override\n+    public ListenableFuture<Boolean> issueSpeculativeRequest() {\n+        return lh.bk.mainWorkerPool.submitOrdered(lh.getId(), new Callable<Boolean>() {\n+            @Override\n+            public Boolean call() throws Exception {\n+                if (!requestComplete.get() && !request.isComplete() &&\n+                    (null != request.maybeSendSpeculativeRead(heardFromHostsBitSet))) {\n+                    if (LOG.isDebugEnabled()) {\n+                        LOG.debug(\"Send speculative ReadLAC {} for ledger {} (previousLAC: {}). Hosts heard are {}.\",\n+                            new Object[] {request, lh.getId(), lastAddConfirmed, heardFromHostsBitSet });\n+                    }\n+                    return true;\n+                }\n+                return false;\n+            }\n+        });\n+    }\n+\n+    public void initiate() {\n+        if (parallelRead) {\n+            request = new ParallelReadRequest(lh.metadata.currentEnsemble, lh.ledgerId, prevEntryId + 1);\n+        } else {\n+            request = new SequenceReadRequest(lh.metadata.currentEnsemble, lh.ledgerId, prevEntryId + 1);\n+        }\n+        request.read();\n+\n+        if (!parallelRead && lh.bk.getReadLACSpeculativeRequestPolicy().isPresent()) {\n+            lh.bk.getReadLACSpeculativeRequestPolicy().get().initiateSpeculativeRequest(scheduler, this);\n+        }\n+    }\n+\n+    void sendReadTo(int bookieIndex, BookieSocketAddress to, ReadLACAndEntryRequest entry) throws InterruptedException {\n+        if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"Calling Read LAC and Entry with {} and long polling interval {} on Bookie {} - Parallel {}\",\n+                    new Object[] { prevEntryId, timeOutInMillis, to, parallelRead });\n+        }\n+        lh.bk.bookieClient.readEntryWaitForLACUpdate(to,\n+            lh.ledgerId,\n+            BookieProtocol.LAST_ADD_CONFIRMED,\n+            prevEntryId,\n+            timeOutInMillis,\n+            true,\n+            this, new ReadLastConfirmedAndEntryContext(bookieIndex, to));\n+        this.numResponsesPending++;\n+    }\n+\n+    /**\n+     * Wrapper to get all recovered data from the request\n+     */\n+    interface LastConfirmedAndEntryCallback {\n+        public void readLastConfirmedAndEntryComplete(int rc, long lastAddConfirmed, LedgerEntry entry);\n+    }\n+\n+    public static class ReadLastConfirmedAndEntryContext implements BookkeeperInternalCallbacks.ReadEntryCallbackCtx {\n+        final int bookieIndex;\n+        final BookieSocketAddress bookie;\n+        long lac = LedgerHandle.INVALID_ENTRY_ID;\n+        Optional<Long> lacUpdateTimestamp = Optional.absent();\n+\n+        ReadLastConfirmedAndEntryContext(int bookieIndex, BookieSocketAddress bookie) {\n+            this.bookieIndex = bookieIndex;\n+            this.bookie = bookie;\n+        }\n+\n+        @Override\n+        public void setLastAddConfirmed(long lac) {\n+            this.lac = lac;\n+        }\n+\n+        @Override\n+        public long getLastAddConfirmed() {\n+            return lac;\n+        }\n+\n+        public Optional<Long> getLacUpdateTimestamp() {\n+            return lacUpdateTimestamp;\n+        }\n+\n+        public void setLacUpdateTimestamp(long lacUpdateTimestamp) {\n+            this.lacUpdateTimestamp = Optional.of(lacUpdateTimestamp);\n+        }\n+\n+\n+    }\n+\n+    private void submitCallback(int rc, long lastAddConfirmed, LedgerEntry entry) {\n+        long latencyMicros = MathUtils.elapsedMicroSec(requestTimeNano);\n+        if (BKException.Code.OK != rc) {\n+            lh.bk.getReadLacAndEntryOpLogger()\n+                .registerFailedEvent(latencyMicros, TimeUnit.MICROSECONDS);\n+        } else {\n+            lh.bk.getReadLacAndEntryOpLogger()\n+                .registerSuccessfulEvent(latencyMicros, TimeUnit.MICROSECONDS);\n+        }\n+        cb.readLastConfirmedAndEntryComplete(rc, lastAddConfirmed, entry);\n+    }\n+\n+    @Override\n+    public void readEntryComplete(int rc, long ledgerId, long entryId, ByteBuf buffer, Object ctx) {\n+        if (LOG.isTraceEnabled()) {\n+            LOG.trace(\"{} received response for (lid={}, eid={}) : {}\",\n+                new Object[] { getClass().getName(), ledgerId, entryId, rc });\n+        }\n+        ReadLastConfirmedAndEntryContext rCtx = (ReadLastConfirmedAndEntryContext) ctx;\n+        BookieSocketAddress bookie = rCtx.bookie;\n+        numResponsesPending--;\n+        if (BKException.Code.OK == rc) {\n+            if (LOG.isTraceEnabled()) {\n+                LOG.trace(\"Received lastAddConfirmed (lac={}) from bookie({}) for (lid={}).\",\n+                    new Object[] { rCtx.getLastAddConfirmed(), bookie, ledgerId });\n+            }\n+\n+            if (rCtx.getLastAddConfirmed() > lastAddConfirmed) {\n+                lastAddConfirmed = rCtx.getLastAddConfirmed();\n+                lh.updateLastConfirmed(rCtx.getLastAddConfirmed(), 0L);\n+            }\n+\n+            hasValidResponse = true;\n+\n+            if (entryId != BookieProtocol.LAST_ADD_CONFIRMED) {\n+                if (request.complete(rCtx.bookieIndex, bookie, buffer, entryId)) {\n+                    // callback immediately\n+                    if (rCtx.getLacUpdateTimestamp().isPresent()) {\n+                        long elapsedMicros = TimeUnit.MILLISECONDS.toMicros(System.currentTimeMillis() - rCtx.getLacUpdateTimestamp().get());\n+                        elapsedMicros = Math.max(elapsedMicros, 0);\n+                        lh.bk.getReadLacAndEntryRespLogger()\n+                            .registerSuccessfulEvent(elapsedMicros, TimeUnit.MICROSECONDS);\n+                    }\n+\n+                    submitCallback(BKException.Code.OK, lastAddConfirmed, request);\n+                    requestComplete.set(true);\n+                    heardFromHostsBitSet.set(rCtx.bookieIndex, true);\n+                }\n+            } else {\n+                emptyResponsesFromHostsBitSet.set(rCtx.bookieIndex, true);\n+                if (lastAddConfirmed > prevEntryId) {\n+                    // received advanced lac\n+                    completeRequest();\n+                } else if(emptyResponsesFromHostsBitSet.cardinality() >= numEmptyResponsesAllowed) {\n+                    if (LOG.isDebugEnabled()) {\n+                        LOG.debug(\"Completed readLACAndEntry(lid = {}, previousEntryId = {}) after received {} empty responses ('{}').\",\n+                                new Object[]{ledgerId, prevEntryId, emptyResponsesFromHostsBitSet.cardinality(), emptyResponsesFromHostsBitSet});\n+                    }\n+                    completeRequest();\n+                } else {\n+                    if (LOG.isDebugEnabled()) {\n+                        LOG.debug(\"Received empty response for readLACAndEntry(lid = {}, previousEntryId = {}) from\" +\n+                                        \" bookie {} @ {}, reattempting reading next bookie : lac = {}\",\n+                                new Object[]{ledgerId, prevEntryId, rCtx.bookieIndex,\n+                                        rCtx.bookie, lastAddConfirmed});\n+                    }\n+                    request.logErrorAndReattemptRead(rCtx.bookieIndex, bookie, \"Empty Response\", rc);\n+                }\n+                return;\n+            }\n+        } else if (BKException.Code.UnauthorizedAccessException == rc && !requestComplete.get()) {\n+            submitCallback(rc, lastAddConfirmed, null);\n+            requestComplete.set(true);\n+        } else {\n+            request.logErrorAndReattemptRead(rCtx.bookieIndex, bookie, \"Error: \" + BKException.getMessage(rc), rc);\n+            return;\n+        }\n+\n+        if (numResponsesPending <= 0) {\n+            completeRequest();\n+        }\n+    }\n+\n+    private void completeRequest() {\n+        if (requestComplete.compareAndSet(false, true)) {\n+            if (!hasValidResponse) {\n+                // no success called\n+                submitCallback(request.getFirstError(), lastAddConfirmed, null);\n+            } else {\n+                // callback\n+                submitCallback(BKException.Code.OK, lastAddConfirmed, null);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"ReadLastConfirmedAndEntryOp(lid=%d, prevEntryId=%d])\", lh.ledgerId, prevEntryId);\n+    }\n+\n+}"},{"sha":"157c6b5f022032a0cc45fc66cb08761d0f8d3af4","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ClientConfiguration.java","status":"modified","additions":162,"deletions":1,"changes":163,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/ee0dddee6849d1968500af666571df668d34393a/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fconf%2FClientConfiguration.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/ee0dddee6849d1968500af666571df668d34393a/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fconf%2FClientConfiguration.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fconf%2FClientConfiguration.java?ref=ee0dddee6849d1968500af666571df668d34393a","patch":"@@ -20,7 +20,9 @@\n import static com.google.common.base.Charsets.UTF_8;\n import static org.apache.bookkeeper.util.BookKeeperConstants.FEATURE_DISABLE_ENSEMBLE_CHANGE;\n \n+import java.util.ArrayList;\n import java.util.List;\n+import java.util.Map;\n import java.util.concurrent.TimeUnit;\n \n import org.apache.bookkeeper.client.BookKeeper.DigestType;\n@@ -66,8 +68,12 @@ public class ClientConfiguration extends AbstractConfiguration {\n     protected final static String FIRST_SPECULATIVE_READ_TIMEOUT = \"firstSpeculativeReadTimeout\";\n     protected final static String MAX_SPECULATIVE_READ_TIMEOUT = \"maxSpeculativeReadTimeout\";\n     protected final static String SPECULATIVE_READ_TIMEOUT_BACKOFF_MULTIPLIER = \"speculativeReadTimeoutBackoffMultiplier\";\n+    protected final static String FIRST_SPECULATIVE_READ_LAC_TIMEOUT = \"firstSpeculativeReadLACTimeout\";\n+    protected final static String MAX_SPECULATIVE_READ_LAC_TIMEOUT = \"maxSpeculativeReadLACTimeout\";\n+    protected final static String SPECULATIVE_READ_LAC_TIMEOUT_BACKOFF_MULTIPLIER = \"speculativeReadLACTimeoutBackoffMultiplier\";\n     protected final static String ENABLE_PARALLEL_RECOVERY_READ = \"enableParallelRecoveryRead\";\n     protected final static String RECOVERY_READ_BATCH_SIZE = \"recoveryReadBatchSize\";\n+    protected final static String REORDER_READ_SEQUENCE_ENABLED = \"reorderReadSequenceEnabled\";\n     // Add Parameters\n     protected final static String DELAY_ENSEMBLE_CHANGE = \"delayEnsembleChange\";\n     // Timeout Setting\n@@ -103,7 +109,11 @@ public class ClientConfiguration extends AbstractConfiguration {\n     // Stats\n     protected final static String ENABLE_TASK_EXECUTION_STATS = \"enableTaskExecutionStats\";\n     protected final static String TASK_EXECUTION_WARN_TIME_MICROS = \"taskExecutionWarnTimeMicros\";\n-    \n+\n+    // Failure History Settings\n+    protected final static String ENABLE_BOOKIE_FAILURE_TRACKING = \"enableBookieFailureTracking\";\n+    protected final static String BOOKIE_FAILURE_HISTORY_EXPIRATION_MS = \"bookieFailureHistoryExpirationMSec\";\n+\n     // Names of dynamic features\n     protected final static String DISABLE_ENSEMBLE_CHANGE_FEATURE_NAME = \"disableEnsembleChangeFeatureName\";\n \n@@ -845,6 +855,27 @@ public ClientConfiguration setSpeculativeReadTimeoutBackoffMultiplier(float spec\n         return this;\n     }\n \n+    /**\n+     * Multipler to use when determining time between successive speculative read LAC requests\n+     *\n+     * @return speculative read LAC timeout backoff multiplier.\n+     */\n+    public float getSpeculativeReadLACTimeoutBackoffMultiplier() {\n+        return getFloat(SPECULATIVE_READ_LAC_TIMEOUT_BACKOFF_MULTIPLIER, 2.0f);\n+    }\n+\n+    /**\n+     * Set the multipler to use when determining time between successive speculative read LAC requests\n+     *\n+     * @param speculativeReadLACTimeoutBackoffMultiplier\n+     *          multipler to use when determining time between successive speculative read LAC requests.\n+     * @return client configuration.\n+     */\n+    public ClientConfiguration setSpeculativeReadLACTimeoutBackoffMultiplier(float speculativeReadLACTimeoutBackoffMultiplier) {\n+        setProperty(SPECULATIVE_READ_LAC_TIMEOUT_BACKOFF_MULTIPLIER, speculativeReadLACTimeoutBackoffMultiplier);\n+        return this;\n+    }\n+\n     /**\n      * Get the max speculative read timeout.\n      *\n@@ -866,6 +897,66 @@ public ClientConfiguration setMaxSpeculativeReadTimeout(int timeout) {\n         return this;\n     }\n \n+    /**\n+     * Get the period of time after which the first speculative read last add confirmed and entry\n+     * should be triggered.\n+     * A speculative entry request is sent to the next replica bookie before\n+     * an error or response has been received for the previous entry read request.\n+     *\n+     * A speculative entry read is only sent if we have not heard from the current\n+     * replica bookie during the entire read operation which may comprise of many entries.\n+     *\n+     * Speculative requests allow the client to avoid having to wait for the connect timeout\n+     * in the case that a bookie has failed. It induces higher load on the network and on\n+     * bookies. This should be taken into account before changing this configuration value.\n+     *\n+     * @return the speculative request timeout in milliseconds. Default 1500.\n+     */\n+    public int getFirstSpeculativeReadLACTimeout() {\n+        return getInt(FIRST_SPECULATIVE_READ_LAC_TIMEOUT, 1500);\n+    }\n+\n+\n+    /**\n+     * Get the maximum interval between successive speculative read last add confirmed and entry\n+     * requests.\n+     *\n+     * @return the max speculative request timeout in milliseconds. Default 5000.\n+     */\n+    public int getMaxSpeculativeReadLACTimeout() {\n+        return getInt(MAX_SPECULATIVE_READ_LAC_TIMEOUT, 5000);\n+    }\n+\n+    /**\n+     * Set the period of time after which the first speculative read last add confirmed and entry\n+     * should be triggered.\n+     * A lower timeout will reduce read latency in the case of a failed bookie,\n+     * while increasing the load on bookies and the network.\n+     *\n+     * The default is 1500 milliseconds. A value of 0 will disable speculative reads\n+     * completely.\n+     *\n+     * @see #getSpeculativeReadTimeout()\n+     * @param timeout the timeout value, in milliseconds\n+     * @return client configuration\n+     */\n+    public ClientConfiguration setFirstSpeculativeReadLACTimeout(int timeout) {\n+        setProperty(FIRST_SPECULATIVE_READ_LAC_TIMEOUT, timeout);\n+        return this;\n+    }\n+\n+    /**\n+     * Set the maximum interval between successive speculative read last add confirmed and entry\n+     * requests.\n+     *\n+     * @param timeout the timeout value, in milliseconds\n+     * @return client configuration\n+     */\n+    public ClientConfiguration setMaxSpeculativeReadLACTimeout(int timeout) {\n+        setProperty(MAX_SPECULATIVE_READ_LAC_TIMEOUT, timeout);\n+        return this;\n+    }\n+\n     /**\n      * Whether to enable parallel reading in recovery read.\n      *\n@@ -908,6 +999,34 @@ public ClientConfiguration setRecoveryReadBatchSize(int batchSize) {\n         return this;\n     }\n \n+    /**\n+     * If reorder read sequence enabled or not.\n+     *\n+     * @return true if reorder read sequence is enabled, otherwise false.\n+     */\n+    public boolean isReorderReadSequenceEnabled() {\n+        return getBoolean(REORDER_READ_SEQUENCE_ENABLED, false);\n+    }\n+\n+    /**\n+     * Enable/disable reordering read sequence on reading entries.\n+     *\n+     * <p>If this flag is enabled, the client will use\n+     * {@link EnsemblePlacementPolicy#reorderReadSequence(ArrayList, List, Map)}\n+     * to figure out a better read sequence to attempt reads from replicas and use\n+     * {@link EnsemblePlacementPolicy#reorderReadLACSequence(ArrayList, List, Map)}\n+     * to figure out a better read sequence to attempt long poll reads from replicas.\n+     *\n+     * <p>The order of read sequence is determined by the placement policy implementations.\n+     *\n+     * @param enabled the flag to enable/disable reorder read sequence.\n+     * @return client configuration instance.\n+     */\n+    public ClientConfiguration setReorderReadSequenceEnabled(boolean enabled) {\n+        setProperty(REORDER_READ_SEQUENCE_ENABLED, enabled);\n+        return this;\n+    }\n+\n     /**\n      * Get Ensemble Placement Policy Class.\n      *\n@@ -1239,6 +1358,48 @@ public ClientConfiguration setDelayEnsembleChange(boolean enabled) {\n         return this;\n     }\n \n+    /**\n+     * Whether to enable bookie failure tracking\n+     *\n+     * @return flag to enable/disable bookie failure tracking\n+     */\n+    public boolean getEnableBookieFailureTracking() {\n+        return getBoolean(ENABLE_BOOKIE_FAILURE_TRACKING, true);\n+    }\n+\n+    /**\n+     * Enable/Disable bookie failure tracking.\n+     *\n+     * @param enabled\n+     *          flag to enable/disable bookie failure tracking\n+     * @return client configuration.\n+     */\n+    public ClientConfiguration setEnableBookieFailureTracking(boolean enabled) {\n+        setProperty(ENABLE_BOOKIE_FAILURE_TRACKING, enabled);\n+        return this;\n+    }\n+\n+    /**\n+     * Get the bookie failure tracking expiration timeout.\n+     *\n+     * @return bookie failure tracking expiration timeout.\n+     */\n+    public int getBookieFailureHistoryExpirationMSec() {\n+        return getInt(BOOKIE_FAILURE_HISTORY_EXPIRATION_MS, 60000);\n+    }\n+\n+    /**\n+     * Set the bookie failure tracking expiration timeout.\n+     *\n+     * @param timeout\n+     *          bookie failure tracking expiration timeout.\n+     * @return client configuration.\n+     */\n+    public ClientConfiguration setBookieFailureHistoryExpirationMSec(int expirationMSec) {\n+        setProperty(BOOKIE_FAILURE_HISTORY_EXPIRATION_MS, expirationMSec);\n+        return this;\n+    }\n+\n     /**\n      * Get the name of the dynamic feature that disables ensemble change\n      *"},{"sha":"e5c96e8fd5c96534ac729db6c783701e65b3a970","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ServerConfiguration.java","status":"modified","additions":65,"deletions":0,"changes":65,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/ee0dddee6849d1968500af666571df668d34393a/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fconf%2FServerConfiguration.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/ee0dddee6849d1968500af666571df668d34393a/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fconf%2FServerConfiguration.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fconf%2FServerConfiguration.java?ref=ee0dddee6849d1968500af666571df668d34393a","patch":"@@ -115,6 +115,11 @@ public class ServerConfiguration extends AbstractConfiguration {\n     // Worker Thread parameters.\n     protected final static String NUM_ADD_WORKER_THREADS = \"numAddWorkerThreads\";\n     protected final static String NUM_READ_WORKER_THREADS = \"numReadWorkerThreads\";\n+    protected final static String NUM_LONG_POLL_WORKER_THREADS = \"numLongPollWorkerThreads\";\n+\n+    // Long poll parameters\n+    protected final static String REQUEST_TIMER_TICK_DURATION_MILLISEC = \"requestTimerTickDurationMs\";\n+    protected final static String REQUEST_TIMER_NO_OF_TICKS = \"requestTimerNumTicks\";\n \n     protected final static String READ_BUFFER_SIZE = \"readBufferSizeBytes\";\n     protected final static String WRITE_BUFFER_SIZE = \"writeBufferSizeBytes\";\n@@ -1130,6 +1135,26 @@ public int getNumAddWorkerThreads() {\n         return getInt(NUM_ADD_WORKER_THREADS, 1);\n     }\n \n+    /**\n+     * Set the number of threads that should handle long poll requests\n+     *\n+     * @param numThreads\n+     *          number of threads to handle long poll requests.\n+     * @return server configuration\n+     */\n+    public ServerConfiguration setNumLongPollWorkerThreads(int numThreads) {\n+        setProperty(NUM_LONG_POLL_WORKER_THREADS, numThreads);\n+        return this;\n+    }\n+\n+    /**\n+     * Get the number of threads that should handle long poll requests.\n+     * @return\n+     */\n+    public int getNumLongPollWorkerThreads() {\n+        return getInt(NUM_LONG_POLL_WORKER_THREADS, 10);\n+    }\n+\n     /**\n      * Set the number of threads that would handle read requests.\n      *\n@@ -1148,6 +1173,46 @@ public ServerConfiguration setNumReadWorkerThreads(int numThreads) {\n     public int getNumReadWorkerThreads() {\n         return getInt(NUM_READ_WORKER_THREADS, 8);\n     }\n+    \n+    /**\n+     * Set the tick duration in milliseconds\n+     *\n+     * @param tickDuration\n+     *          tick duration in milliseconds.\n+     * @return server configuration\n+     */\n+    public ServerConfiguration setRequestTimerTickDurationMs(int tickDuration) {\n+        setProperty(REQUEST_TIMER_TICK_DURATION_MILLISEC, tickDuration);\n+        return this;\n+    }\n+\n+    /**\n+     * Get the tick duration in milliseconds.\n+     * @return\n+     */\n+    public int getRequestTimerTickDurationMs() {\n+        return getInt(REQUEST_TIMER_TICK_DURATION_MILLISEC, 10);\n+    }\n+\n+    /**\n+     * Set the number of ticks per wheel for the request timer.\n+     *\n+     * @param tickCount\n+     *          number of ticks per wheel for the request timer.\n+     * @return server configuration\n+     */\n+    public ServerConfiguration setRequestTimerNumTicks(int tickCount) {\n+        setProperty(REQUEST_TIMER_NO_OF_TICKS, tickCount);\n+        return this;\n+    }\n+\n+    /**\n+     * Get the number of ticks per wheel for the request timer.\n+     * @return\n+     */\n+    public int getRequestTimerNumTicks() {\n+        return getInt(REQUEST_TIMER_NO_OF_TICKS, 1024);\n+    }\n \n     /**\n      * Get the number of bytes used as capacity for the write buffer. Default is"},{"sha":"4cbd8149860f68acaf92228dd570d95b1c676fce","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieClient.java","status":"modified","additions":35,"deletions":11,"changes":46,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/ee0dddee6849d1968500af666571df668d34393a/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookieClient.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/ee0dddee6849d1968500af666571df668d34393a/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookieClient.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookieClient.java?ref=ee0dddee6849d1968500af666571df668d34393a","patch":"@@ -364,17 +364,7 @@ public void readEntry(final BookieSocketAddress addr, final long ledgerId, final\n                 @Override\n                 public void operationComplete(final int rc, PerChannelBookieClient pcbc) {\n                     if (rc != BKException.Code.OK) {\n-                        try {\n-                            executor.submitOrdered(ledgerId, new SafeRunnable() {\n-                                @Override\n-                                public void safeRun() {\n-                                    cb.readEntryComplete(rc, ledgerId, entryId, null, ctx);\n-                                }\n-                            });\n-                        } catch (RejectedExecutionException re) {\n-                            cb.readEntryComplete(getRc(BKException.Code.InterruptedException),\n-                                    ledgerId, entryId, null, ctx);\n-                        }\n+                        completeRead(rc, ledgerId, entryId, null, cb, ctx);\n                         return;\n                     }\n                     pcbc.readEntry(ledgerId, entryId, cb, ctx);\n@@ -384,6 +374,40 @@ public void safeRun() {\n             closeLock.readLock().unlock();\n         }\n     }\n+    \n+    \n+    public void readEntryWaitForLACUpdate(final BookieSocketAddress addr,\n+                                          final long ledgerId,\n+                                          final long entryId,\n+                                          final long previousLAC,\n+                                          final long timeOutInMillis,\n+                                          final boolean piggyBackEntry,\n+                                          final ReadEntryCallback cb,\n+                                          final Object ctx) {\n+        closeLock.readLock().lock();\n+        try {\n+            final PerChannelBookieClientPool client = lookupClient(addr, entryId);\n+            if (client == null) {\n+                completeRead(BKException.Code.BookieHandleNotAvailableException,\n+                        ledgerId, entryId, null, cb, ctx);\n+                return;\n+            }\n+\n+            client.obtain(new GenericCallback<PerChannelBookieClient>() {\n+                @Override\n+                public void operationComplete(final int rc, PerChannelBookieClient pcbc) {\n+\n+                    if (rc != BKException.Code.OK) {\n+                        completeRead(rc, ledgerId, entryId, null, cb, ctx);\n+                        return;\n+                    }\n+                    pcbc.readEntryWaitForLACUpdate(ledgerId, entryId, previousLAC, timeOutInMillis, piggyBackEntry, cb, ctx);\n+                }\n+            }, ledgerId);\n+        } finally {\n+            closeLock.readLock().unlock();\n+        }\n+    }\n \n     public void getBookieInfo(final BookieSocketAddress addr, final long requested, final GetBookieInfoCallback cb, final Object ctx) {\n         closeLock.readLock().lock();"},{"sha":"1f2042521dc13b00e26bf2896d55e3cb26768423","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieRequestProcessor.java","status":"modified","additions":49,"deletions":4,"changes":53,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/ee0dddee6849d1968500af666571df668d34393a/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookieRequestProcessor.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/ee0dddee6849d1968500af666571df668d34393a/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookieRequestProcessor.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookieRequestProcessor.java?ref=ee0dddee6849d1968500af666571df668d34393a","patch":"@@ -20,14 +20,18 @@\n  */\n package org.apache.bookkeeper.proto;\n \n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n import com.google.protobuf.ByteString;\n import io.netty.channel.Channel;\n+import io.netty.util.HashedWheelTimer;\n import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeUnit;\n import org.apache.bookkeeper.auth.AuthProviderFactoryFactory;\n import org.apache.bookkeeper.auth.AuthToken;\n import org.apache.bookkeeper.bookie.Bookie;\n import org.apache.bookkeeper.conf.ServerConfiguration;\n import org.apache.bookkeeper.processor.RequestProcessor;\n+import org.apache.bookkeeper.stats.Counter;\n import org.apache.bookkeeper.stats.OpStatsLogger;\n import org.apache.bookkeeper.stats.StatsLogger;\n import org.apache.bookkeeper.util.OrderedSafeExecutor;\n@@ -49,6 +53,7 @@\n import static org.apache.bookkeeper.bookie.BookKeeperServerStats.READ_ENTRY_REQUEST;\n import static org.apache.bookkeeper.bookie.BookKeeperServerStats.READ_ENTRY_SCHEDULING_DELAY;\n import static org.apache.bookkeeper.bookie.BookKeeperServerStats.READ_LAC_REQUEST;\n+import static org.apache.bookkeeper.bookie.BookKeeperServerStats.READ_LAST_ENTRY_NOENTRY_ERROR;\n import static org.apache.bookkeeper.bookie.BookKeeperServerStats.WRITE_LAC;\n import static org.apache.bookkeeper.bookie.BookKeeperServerStats.READ_LAC;\n import static org.apache.bookkeeper.bookie.BookKeeperServerStats.GET_BOOKIE_INFO;\n@@ -79,6 +84,17 @@ public class BookieRequestProcessor implements RequestProcessor {\n      */\n     private final OrderedSafeExecutor writeThreadPool;\n \n+    /**\n+     * The threadpool used to execute all long poll requests issued to this server\n+     * after they are done waiting\n+     */\n+    private final OrderedSafeExecutor longPollThreadPool;\n+\n+    /**\n+     * The Timer used to time out requests for long polling\n+     */\n+    private final HashedWheelTimer requestTimer;\n+\n     // Expose Stats\n     private final BKStats bkStats = BKStats.getInstance();\n     private final boolean statsEnabled;\n@@ -94,6 +110,7 @@ public class BookieRequestProcessor implements RequestProcessor {\n     final OpStatsLogger longPollWaitStats;\n     final OpStatsLogger longPollReadStats;\n     final OpStatsLogger longPollReadRequestStats;\n+    final Counter readLastEntryNoEntryErrorCounter;\n     final OpStatsLogger writeLacRequestStats;\n     final OpStatsLogger writeLacStats;\n     final OpStatsLogger readLacRequestStats;\n@@ -108,6 +125,15 @@ public BookieRequestProcessor(ServerConfiguration serverCfg, Bookie bookie,\n         this.bookie = bookie;\n         this.readThreadPool = createExecutor(this.serverCfg.getNumReadWorkerThreads(), \"BookieReadThread-\" + serverCfg.getBookiePort());\n         this.writeThreadPool = createExecutor(this.serverCfg.getNumAddWorkerThreads(), \"BookieWriteThread-\" + serverCfg.getBookiePort());\n+        this.longPollThreadPool =\n+            createExecutor(\n+                this.serverCfg.getNumLongPollWorkerThreads(),\n+                \"BookieLongPollThread-\" + serverCfg.getBookiePort());\n+        this.requestTimer = new HashedWheelTimer(\n+            new ThreadFactoryBuilder().setNameFormat(\"BookieRequestTimer-%d\").build(),\n+            this.serverCfg.getRequestTimerTickDurationMs(),\n+            TimeUnit.MILLISECONDS, this.serverCfg.getRequestTimerNumTicks());\n+\n         // Expose Stats\n         this.statsEnabled = serverCfg.isStatisticsEnabled();\n         this.addEntryStats = statsLogger.getOpStatsLogger(ADD_ENTRY);\n@@ -122,6 +148,7 @@ public BookieRequestProcessor(ServerConfiguration serverCfg, Bookie bookie,\n         this.longPollWaitStats = statsLogger.getOpStatsLogger(READ_ENTRY_LONG_POLL_WAIT);\n         this.longPollReadStats = statsLogger.getOpStatsLogger(READ_ENTRY_LONG_POLL_READ);\n         this.longPollReadRequestStats = statsLogger.getOpStatsLogger(READ_ENTRY_LONG_POLL_REQUEST);\n+        this.readLastEntryNoEntryErrorCounter = statsLogger.getCounter(READ_LAST_ENTRY_NOENTRY_ERROR);\n         this.writeLacStats = statsLogger.getOpStatsLogger(WRITE_LAC);\n         this.writeLacRequestStats = statsLogger.getOpStatsLogger(WRITE_LAC_REQUEST);\n         this.readLacStats = statsLogger.getOpStatsLogger(READ_LAC);\n@@ -231,11 +258,29 @@ private void processAddRequestV3(final BookkeeperProtocol.Request r, final Chann\n     private void processReadRequestV3(final BookkeeperProtocol.Request r, final Channel c) {\n         ExecutorService fenceThreadPool =\n           null == readThreadPool ? null : readThreadPool.chooseThread(c);\n-        ReadEntryProcessorV3 read = new ReadEntryProcessorV3(r, c, this, fenceThreadPool);\n-        if (null == readThreadPool) {\n-            read.run();\n+        ExecutorService lpThreadPool =\n+          null == longPollThreadPool ? null : longPollThreadPool.chooseThread(c);\n+        ReadEntryProcessorV3 read;\n+        if (RequestUtils.isLongPollReadRequest(r.getReadRequest())) {\n+            read = new LongPollReadEntryProcessorV3(\n+                r,\n+                c,\n+                this,\n+                fenceThreadPool,\n+                lpThreadPool,\n+                requestTimer);\n+            if (null == longPollThreadPool) {\n+                read.run();\n+            } else {\n+                longPollThreadPool.submitOrdered(r.getReadRequest().getLedgerId(), read);\n+            }\n         } else {\n-            readThreadPool.submitOrdered(r.getReadRequest().getLedgerId(), read);\n+            read = new ReadEntryProcessorV3(r, c, this, fenceThreadPool);\n+            if (null == readThreadPool) {\n+                read.run();\n+            } else {\n+                readThreadPool.submitOrdered(r.getReadRequest().getLedgerId(), read);\n+            }\n         }\n     }\n "},{"sha":"342e788cfe8bf94fa67b9d7106e12f643ee68401","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/LongPollReadEntryProcessorV3.java","status":"added","additions":226,"deletions":0,"changes":226,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/ee0dddee6849d1968500af666571df668d34393a/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FLongPollReadEntryProcessorV3.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/ee0dddee6849d1968500af666571df668d34393a/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FLongPollReadEntryProcessorV3.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FLongPollReadEntryProcessorV3.java?ref=ee0dddee6849d1968500af666571df668d34393a","patch":"@@ -0,0 +1,226 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.bookkeeper.proto;\n+\n+import com.google.common.base.Optional;\n+import com.google.common.base.Stopwatch;\n+import io.netty.channel.Channel;\n+import io.netty.util.HashedWheelTimer;\n+import io.netty.util.Timeout;\n+import io.netty.util.TimerTask;\n+import java.io.IOException;\n+import java.util.Observable;\n+import java.util.Observer;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.RejectedExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.bookkeeper.bookie.Bookie;\n+import org.apache.bookkeeper.bookie.LastAddConfirmedUpdateNotification;\n+import org.apache.bookkeeper.proto.BookkeeperProtocol.Request;\n+import org.apache.bookkeeper.proto.BookkeeperProtocol.ReadResponse;\n+import org.apache.bookkeeper.proto.BookkeeperProtocol.StatusCode;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Processor handling long poll read entry request.\n+ */\n+class LongPollReadEntryProcessorV3 extends ReadEntryProcessorV3 implements Observer {\n+\n+    private final static Logger logger = LoggerFactory.getLogger(LongPollReadEntryProcessorV3.class);\n+\n+    private final Long previousLAC;\n+    private Optional<Long> lastAddConfirmedUpdateTime = Optional.absent();\n+\n+    // long poll execution state\n+    private final ExecutorService longPollThreadPool;\n+    private final HashedWheelTimer requestTimer;\n+    private Timeout expirationTimerTask = null;\n+    private Future<?> deferredTask = null;\n+    private boolean shouldReadEntry = false;\n+\n+    LongPollReadEntryProcessorV3(Request request,\n+                                 Channel channel,\n+                                 BookieRequestProcessor requestProcessor,\n+                                 ExecutorService fenceThreadPool,\n+                                 ExecutorService longPollThreadPool,\n+                                 HashedWheelTimer requestTimer) {\n+        super(request, channel, requestProcessor, fenceThreadPool);\n+        this.previousLAC = readRequest.getPreviousLAC();\n+        this.longPollThreadPool = longPollThreadPool;\n+        this.requestTimer = requestTimer;\n+\n+    }\n+\n+    @Override\n+    protected Long getPreviousLAC() {\n+        return previousLAC;\n+    }\n+\n+    private synchronized boolean shouldReadEntry() {\n+        return shouldReadEntry;\n+    }\n+\n+    @Override\n+    protected ReadResponse readEntry(ReadResponse.Builder readResponseBuilder,\n+                                     long entryId,\n+                                     Stopwatch startTimeSw)\n+            throws IOException {\n+        if (RequestUtils.shouldPiggybackEntry(readRequest)) {\n+            if(!readRequest.hasPreviousLAC() || (BookieProtocol.LAST_ADD_CONFIRMED != entryId)) {\n+                // This is not a valid request - client bug?\n+                logger.error(\"Incorrect read request, entry piggyback requested incorrectly for ledgerId {} entryId {}\",\n+                        ledgerId, entryId);\n+                return buildResponse(readResponseBuilder, StatusCode.EBADREQ, startTimeSw);\n+            } else {\n+                long knownLAC = requestProcessor.bookie.readLastAddConfirmed(ledgerId);\n+                readResponseBuilder.setMaxLAC(knownLAC);\n+                if (knownLAC > previousLAC) {\n+                    entryId = previousLAC + 1;\n+                    readResponseBuilder.setMaxLAC(knownLAC);\n+                    if (lastAddConfirmedUpdateTime.isPresent()) {\n+                        readResponseBuilder.setLacUpdateTimestamp(lastAddConfirmedUpdateTime.get());\n+                    }\n+                    if (logger.isDebugEnabled()) {\n+                        logger.debug(\"ReadLAC Piggy Back reading entry:{} from ledger: {}\", entryId, ledgerId);\n+                    }\n+                    try {\n+                        return super.readEntry(readResponseBuilder, entryId, true, startTimeSw);\n+                    } catch (Bookie.NoEntryException e) {\n+                        requestProcessor.readLastEntryNoEntryErrorCounter.inc();\n+                        logger.info(\"No entry found while piggyback reading entry {} from ledger {} : previous lac = {}\",\n+                                new Object[] { entryId, ledgerId, previousLAC });\n+                        // piggy back is best effort and this request can fail genuinely because of striping\n+                        // entries across the ensemble\n+                        return buildResponse(readResponseBuilder, StatusCode.EOK, startTimeSw);\n+                    }\n+                } else {\n+                    if (knownLAC < previousLAC) {\n+                        if (logger.isDebugEnabled()) {\n+                            logger.debug(\"Found smaller lac when piggy back reading lac and entry from ledger {} :\" +\n+                                    \" previous lac = {}, known lac = {}\",\n+                                    new Object[]{ ledgerId, previousLAC, knownLAC });\n+                        }\n+                    }\n+                    return buildResponse(readResponseBuilder, StatusCode.EOK, startTimeSw);\n+                }\n+            }\n+        } else {\n+            return super.readEntry(readResponseBuilder, entryId, false, startTimeSw);\n+        }\n+    }\n+\n+    private ReadResponse buildErrorResponse(StatusCode statusCode, Stopwatch sw) {\n+        ReadResponse.Builder builder = ReadResponse.newBuilder()\n+                .setLedgerId(ledgerId)\n+                .setEntryId(entryId);\n+        return buildResponse(builder, statusCode, sw);\n+    }\n+\n+    private ReadResponse getLongPollReadResponse() {\n+        if (!shouldReadEntry() && readRequest.hasTimeOut()) {\n+            if (logger.isTraceEnabled()) {\n+                logger.trace(\"Waiting For LAC Update {}\", previousLAC);\n+            }\n+\n+            final Stopwatch startTimeSw = Stopwatch.createStarted();\n+\n+            final Observable observable;\n+            try {\n+                observable = requestProcessor.bookie.waitForLastAddConfirmedUpdate(ledgerId, previousLAC, this);\n+            } catch (Bookie.NoLedgerException e) {\n+                logger.info(\"No ledger found while longpoll reading ledger {}, previous lac = {}.\",\n+                        ledgerId, previousLAC);\n+                return buildErrorResponse(StatusCode.ENOLEDGER, startTimeSw);\n+            } catch (IOException ioe) {\n+                logger.error(\"IOException while longpoll reading ledger {}, previous lac = {} : \",\n+                        new Object[] { ledgerId, previousLAC, ioe });\n+                return buildErrorResponse(StatusCode.EIO, startTimeSw);\n+            }\n+\n+            registerSuccessfulEvent(requestProcessor.longPollPreWaitStats, startTimeSw);\n+            lastPhaseStartTime.reset().start();\n+\n+            if (null != observable) {\n+                // successfully registered observable to lac updates\n+                if (logger.isTraceEnabled()) {\n+                    logger.trace(\"Waiting For LAC Update {}: Timeout {}\", previousLAC, readRequest.getTimeOut());\n+                }\n+                synchronized (this) {\n+                    expirationTimerTask = requestTimer.newTimeout(new TimerTask() {\n+                        @Override\n+                        public void run(Timeout timeout) throws Exception {\n+                            // When the timeout expires just get whatever is the current\n+                            // readLastConfirmed\n+                            LongPollReadEntryProcessorV3.this.scheduleDeferredRead(observable, true);\n+                        }\n+                    }, readRequest.getTimeOut(), TimeUnit.MILLISECONDS);\n+                }\n+                return null;\n+            }\n+        }\n+        // request doesn't have timeout or fail to wait, proceed to read entry\n+        return getReadResponse();\n+    }\n+\n+    @Override\n+    protected void executeOp() {\n+        ReadResponse readResponse = getLongPollReadResponse();\n+        if (null != readResponse) {\n+            sendResponse(readResponse);\n+        }\n+    }\n+\n+    @Override\n+    public void update(Observable observable, Object o) {\n+        LastAddConfirmedUpdateNotification newLACNotification = (LastAddConfirmedUpdateNotification)o;\n+        if (newLACNotification.lastAddConfirmed > previousLAC) {\n+            if (newLACNotification.lastAddConfirmed != Long.MAX_VALUE &&\n+                    !lastAddConfirmedUpdateTime.isPresent()) {\n+                lastAddConfirmedUpdateTime = Optional.of(newLACNotification.timestamp);\n+            }\n+            if (logger.isTraceEnabled()) {\n+                logger.trace(\"Last Add Confirmed Advanced to {} for request {}\",\n+                        newLACNotification.lastAddConfirmed, request);\n+            }\n+            scheduleDeferredRead(observable, false);\n+        }\n+    }\n+\n+    private synchronized void scheduleDeferredRead(Observable observable, boolean timeout) {\n+        if (null == deferredTask) {\n+            if (logger.isTraceEnabled()) {\n+                logger.trace(\"Deferred Task, expired: {}, request: {}\", timeout, request);\n+            }\n+            observable.deleteObserver(this);\n+            try {\n+                shouldReadEntry = true;\n+                deferredTask = longPollThreadPool.submit(this);\n+            } catch (RejectedExecutionException exc) {\n+                // If the threadPool has been shutdown, simply drop the task\n+            }\n+            if (null != expirationTimerTask) {\n+                expirationTimerTask.cancel();\n+            }\n+\n+            registerEvent(timeout, requestProcessor.longPollWaitStats, lastPhaseStartTime);\n+            lastPhaseStartTime.reset().start();\n+        }\n+    }\n+}"},{"sha":"7ecb0b488f3d294504091b2aae654e23fb430775","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java","status":"modified","additions":65,"deletions":3,"changes":68,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/ee0dddee6849d1968500af666571df668d34393a/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FPerChannelBookieClient.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/ee0dddee6849d1968500af666571df668d34393a/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FPerChannelBookieClient.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FPerChannelBookieClient.java?ref=ee0dddee6849d1968500af666571df668d34393a","patch":"@@ -66,6 +66,7 @@\n import org.apache.bookkeeper.client.BKException;\n import org.apache.bookkeeper.client.BookKeeperClientStats;\n import org.apache.bookkeeper.client.BookieInfoReader.BookieInfo;\n+import org.apache.bookkeeper.client.ReadLastConfirmedAndEntryOp;\n import org.apache.bookkeeper.conf.ClientConfiguration;\n import org.apache.bookkeeper.net.BookieSocketAddress;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n@@ -728,7 +729,36 @@ public void operationComplete(ChannelFuture future) throws Exception {\n         }\n     }\n \n-    public void readEntry(final long ledgerId, final long entryId, ReadEntryCallback cb, Object ctx) {\n+    /**\n+     * Long Poll Reads\n+     */\n+    public void readEntryWaitForLACUpdate(final long ledgerId,\n+                                          final long entryId,\n+                                          final long previousLAC,\n+                                          final long timeOutInMillis,\n+                                          final boolean piggyBackEntry,\n+                                          ReadEntryCallback cb,\n+                                          Object ctx) {\n+        readEntryInternal(ledgerId, entryId, previousLAC, timeOutInMillis, piggyBackEntry, cb, ctx);\n+    }\n+\n+    /**\n+     * Normal Reads.\n+     */\n+    public void readEntry(final long ledgerId,\n+                          final long entryId,\n+                          ReadEntryCallback cb,\n+                          Object ctx) {\n+        readEntryInternal(ledgerId, entryId, null, null, false, cb, ctx);\n+    }\n+\n+    private void readEntryInternal(final long ledgerId,\n+                                   final long entryId,\n+                                   final Long previousLAC,\n+                                   final Long timeOutInMillis,\n+                                   final boolean piggyBackEntry,\n+                                   final ReadEntryCallback cb,\n+                                   final Object ctx) {\n         Object request = null;\n         CompletionKey completion = null;\n         if (useV2WireProtocol) {\n@@ -749,6 +779,30 @@ public void readEntry(final long ledgerId, final long entryId, ReadEntryCallback\n                     .setLedgerId(ledgerId)\n                     .setEntryId(entryId);\n \n+            if (null != previousLAC) {\n+                readBuilder = readBuilder.setPreviousLAC(previousLAC);\n+            }\n+\n+            if (null != timeOutInMillis) {\n+                // Long poll requires previousLAC\n+                if (null == previousLAC) {\n+                    cb.readEntryComplete(BKException.Code.IncorrectParameterException,\n+                        ledgerId, entryId, null, ctx);\n+                    return;\n+                }\n+                readBuilder = readBuilder.setTimeOut(timeOutInMillis);\n+            }\n+\n+            if (piggyBackEntry) {\n+                // Long poll requires previousLAC\n+                if (null == previousLAC) {\n+                    cb.readEntryComplete(BKException.Code.IncorrectParameterException,\n+                        ledgerId, entryId, null, ctx);\n+                    return;\n+                }\n+                readBuilder = readBuilder.setFlag(ReadRequest.Flag.ENTRY_PIGGYBACK);\n+            }\n+\n             request = Request.newBuilder()\n                     .setHeader(headerBuilder)\n                     .setReadRequest(readBuilder)\n@@ -1210,7 +1264,7 @@ public void safeRun() {\n                             if (readResponse.hasData()) {\n                               data = readResponse.getData();\n                             }\n-                            handleReadResponse(ledgerId, entryId, status, data, INVALID_ENTRY_ID, completionValue);\n+                            handleReadResponse(ledgerId, entryId, status, data, INVALID_ENTRY_ID, -1L, completionValue);\n                             break;\n                         }\n                         default:\n@@ -1302,7 +1356,11 @@ public void safeRun() {\n                             if (readResponse.hasMaxLAC()) {\n                                 maxLAC = readResponse.getMaxLAC();\n                             }\n-                            handleReadResponse(readResponse.getLedgerId(), readResponse.getEntryId(), status, buffer, maxLAC, completionValue);\n+                            long lacUpdateTimestamp = -1L;\n+                            if (readResponse.hasLacUpdateTimestamp()) {\n+                                lacUpdateTimestamp = readResponse.getLacUpdateTimestamp();\n+                            }\n+                            handleReadResponse(readResponse.getLedgerId(), readResponse.getEntryId(), status, buffer, maxLAC, lacUpdateTimestamp, completionValue);\n                             break;\n                         }\n                         case WRITE_LAC: {\n@@ -1416,6 +1474,7 @@ void handleReadResponse(long ledgerId,\n                             StatusCode status,\n                             ByteBuf buffer,\n                             long maxLAC, // max known lac piggy-back from bookies\n+                            long lacUpdateTimestamp, // the timestamp when the lac is updated.\n                             CompletionValue completionValue) {\n         // The completion value should always be an instance of a ReadCompletion object when we reach here.\n         ReadCompletion rc = (ReadCompletion)completionValue;\n@@ -1440,6 +1499,9 @@ void handleReadResponse(long ledgerId,\n         if (maxLAC > INVALID_ENTRY_ID && (rc.ctx instanceof ReadEntryCallbackCtx)) {\n             ((ReadEntryCallbackCtx) rc.ctx).setLastAddConfirmed(maxLAC);\n         }\n+        if (lacUpdateTimestamp > -1L && (rc.ctx instanceof ReadLastConfirmedAndEntryOp.ReadLastConfirmedAndEntryContext)) {\n+            ((ReadLastConfirmedAndEntryOp.ReadLastConfirmedAndEntryContext) rc.ctx).setLacUpdateTimestamp(lacUpdateTimestamp);\n+        }\n         rc.cb.readEntryComplete(rcToRet, ledgerId, entryId, buffer, rc.ctx);\n     }\n "},{"sha":"0febdc7197dd9afe5f9d40c4b45ed5272bb743e5","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/TestSyncThread.java","status":"modified","additions":7,"deletions":0,"changes":7,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/ee0dddee6849d1968500af666571df668d34393a/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FTestSyncThread.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/ee0dddee6849d1968500af666571df668d34393a/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FTestSyncThread.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FTestSyncThread.java?ref=ee0dddee6849d1968500af666571df668d34393a","patch":"@@ -24,6 +24,8 @@\n \n import java.io.File;\n import java.io.IOException;\n+import java.util.Observable;\n+import java.util.Observer;\n import java.util.concurrent.ExecutorService;\n import java.util.concurrent.Executors;\n import java.util.concurrent.Callable;\n@@ -338,6 +340,11 @@ public ByteBuf getExplicitLac(long ledgerId) {\n             return null;\n         }\n \n+        @Override\n+        public Observable waitForLastAddConfirmedUpdate(long ledgerId, long previoisLAC, Observer observer) throws IOException {\n+            return null;\n+        }\n+\n         @Override\n         public Checkpoint checkpoint(Checkpoint checkpoint)\n                 throws IOException {"},{"sha":"96c5c08157f6ac89043e35a22d94af049fd95e11","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestReadLastConfirmedAndEntry.java","status":"added","additions":267,"deletions":0,"changes":267,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/ee0dddee6849d1968500af666571df668d34393a/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FTestReadLastConfirmedAndEntry.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/ee0dddee6849d1968500af666571df668d34393a/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FTestReadLastConfirmedAndEntry.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FTestReadLastConfirmedAndEntry.java?ref=ee0dddee6849d1968500af666571df668d34393a","patch":"@@ -0,0 +1,267 @@\n+/**\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.client;\n+\n+import io.netty.buffer.ByteBuf;\n+import org.apache.bookkeeper.bookie.Bookie;\n+import org.apache.bookkeeper.bookie.BookieException;\n+import org.apache.bookkeeper.conf.ClientConfiguration;\n+import org.apache.bookkeeper.conf.ServerConfiguration;\n+import org.apache.bookkeeper.test.BookKeeperClusterTestCase;\n+import org.apache.zookeeper.KeeperException;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.Enumeration;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import static com.google.common.base.Charsets.UTF_8;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+\n+public class TestReadLastConfirmedAndEntry extends BookKeeperClusterTestCase {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(TestReadLastConfirmedAndEntry.class);\n+\n+    final BookKeeper.DigestType digestType;\n+\n+    public TestReadLastConfirmedAndEntry() {\n+        super(3);\n+        this.digestType = BookKeeper.DigestType.CRC32;\n+    }\n+\n+    static class FakeBookie extends Bookie {\n+\n+        final long expectedEntryToFail;\n+        final boolean stallOrRespondNull;\n+\n+        public FakeBookie(ServerConfiguration conf, long expectedEntryToFail, boolean stallOrRespondNull)\n+                throws InterruptedException, BookieException, KeeperException, IOException {\n+            super(conf);\n+            this.expectedEntryToFail = expectedEntryToFail;\n+            this.stallOrRespondNull = stallOrRespondNull;\n+        }\n+\n+        @Override\n+        public ByteBuf readEntry(long ledgerId, long entryId)\n+                throws IOException, NoLedgerException {\n+            if (entryId == expectedEntryToFail) {\n+                if (stallOrRespondNull) {\n+                    try {\n+                        Thread.sleep(600000);\n+                    } catch (InterruptedException e) {\n+                        // ignore\n+                    }\n+                } else {\n+                    throw new NoEntryException(ledgerId, entryId);\n+                }\n+            }\n+            return super.readEntry(ledgerId, entryId);\n+        }\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testAdvancedLacWithEmptyResponse() throws Exception {\n+        byte[] passwd = \"advanced-lac-with-empty-response\".getBytes(UTF_8);\n+\n+        ClientConfiguration newConf = new ClientConfiguration();\n+        newConf.addConfiguration(baseClientConf);\n+        newConf.setAddEntryTimeout(9999999);\n+        newConf.setReadEntryTimeout(9999999);\n+\n+        // stop existing bookies\n+        stopAllBookies();\n+        // add fake bookies\n+        long expectedEntryIdToFail = 2;\n+        for (int i = 0; i < numBookies; i++) {\n+            ServerConfiguration conf = newServerConfiguration();\n+            Bookie b = new FakeBookie(conf, expectedEntryIdToFail, i != 0);\n+            bs.add(startBookie(conf, b));\n+            bsConfs.add(conf);\n+        }\n+\n+        // create bookkeeper\n+        BookKeeper newBk = new BookKeeper(newConf);\n+        // create ledger to write some data\n+        LedgerHandle lh = newBk.createLedger(3, 3, 2, digestType, passwd);\n+        for (int i = 0; i <= expectedEntryIdToFail; i++) {\n+            lh.addEntry(\"test\".getBytes(UTF_8));\n+        }\n+\n+        // open ledger to tail reading\n+        LedgerHandle newLh = newBk.openLedgerNoRecovery(lh.getId(), digestType, passwd);\n+        long lac = newLh.readLastConfirmed();\n+        assertEquals(expectedEntryIdToFail - 1, lac);\n+        Enumeration<LedgerEntry> entries = newLh.readEntries(0, lac);\n+\n+        int numReads = 0;\n+        long expectedEntryId = 0L;\n+        while (entries.hasMoreElements()) {\n+            LedgerEntry entry = entries.nextElement();\n+            assertEquals(expectedEntryId++, entry.getEntryId());\n+            ++numReads;\n+        }\n+        assertEquals(lac + 1, numReads);\n+\n+        final AtomicInteger rcHolder = new AtomicInteger(-12345);\n+        final AtomicLong lacHolder = new AtomicLong(lac);\n+        final AtomicReference<LedgerEntry> entryHolder = new AtomicReference<LedgerEntry>(null);\n+        final CountDownLatch latch = new CountDownLatch(1);\n+\n+        newLh.asyncReadLastConfirmedAndEntry(newLh.getLastAddConfirmed() + 1, 99999, false,\n+                new AsyncCallback.ReadLastConfirmedAndEntryCallback() {\n+            @Override\n+            public void readLastConfirmedAndEntryComplete(int rc, long lastConfirmed, LedgerEntry entry, Object ctx) {\n+                rcHolder.set(rc);\n+                lacHolder.set(lastConfirmed);\n+                entryHolder.set(entry);\n+                latch.countDown();\n+            }\n+        }, null);\n+\n+        lh.addEntry(\"another test\".getBytes(UTF_8));\n+\n+        latch.await();\n+        assertEquals(expectedEntryIdToFail, lacHolder.get());\n+        assertNull(entryHolder.get());\n+        assertEquals(BKException.Code.OK, rcHolder.get());\n+    }\n+\n+    static class SlowReadLacBookie extends Bookie {\n+\n+        private final long lacToSlowRead;\n+        private final CountDownLatch readLatch;\n+\n+        public SlowReadLacBookie(ServerConfiguration conf,\n+                                 long lacToSlowRead, CountDownLatch readLatch)\n+                throws IOException, KeeperException, InterruptedException, BookieException {\n+            super(conf);\n+            this.lacToSlowRead = lacToSlowRead;\n+            this.readLatch = readLatch;\n+        }\n+\n+        @Override\n+        public long readLastAddConfirmed(long ledgerId) throws IOException {\n+            long lac = super.readLastAddConfirmed(ledgerId);\n+            logger.info(\"Last Add Confirmed for ledger {} is {}\", ledgerId, lac);\n+            if (lacToSlowRead == lac) {\n+                logger.info(\"Suspend returning lac {} for ledger {}\", lac, ledgerId);\n+                try {\n+                    readLatch.await();\n+                } catch (InterruptedException e) {\n+                    // no-op\n+                }\n+            }\n+            return super.readLastAddConfirmed(ledgerId);\n+        }\n+    }\n+\n+    static class ReadLastConfirmedAndEntryResult implements AsyncCallback.ReadLastConfirmedAndEntryCallback {\n+\n+        int rc = -1234;\n+        long lac = -1234L;\n+        LedgerEntry entry = null;\n+        final CountDownLatch doneLatch = new CountDownLatch(1);\n+\n+        @Override\n+        public void readLastConfirmedAndEntryComplete(int rc, long lastConfirmed, LedgerEntry entry, Object ctx) {\n+            this.rc = rc;\n+            this.lac = lastConfirmed;\n+            this.entry = entry;\n+            doneLatch.countDown();\n+        }\n+\n+        void await() throws InterruptedException {\n+            doneLatch.await();\n+        }\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testRaceOnLastAddConfirmed() throws Exception {\n+        byte[] passwd = \"race-on-last-add-confirmed\".getBytes(UTF_8);\n+\n+        ClientConfiguration newConf = new ClientConfiguration();\n+        newConf.addConfiguration(baseClientConf);\n+        newConf.setAddEntryTimeout(9999999);\n+        newConf.setReadEntryTimeout(9999999);\n+\n+        final long lacToSlowRead = 0L;\n+        final CountDownLatch readLatch = new CountDownLatch(1);\n+\n+        // stop first bookie\n+        ServerConfiguration bsConf = killBookie(0);\n+        // start it with a slow bookie\n+        Bookie b = new SlowReadLacBookie(bsConf, lacToSlowRead, readLatch);\n+        bs.add(startBookie(bsConf, b));\n+        bsConfs.add(bsConf);\n+\n+        // create bookkeeper\n+        BookKeeper newBk = new BookKeeper(newConf);\n+        // create ledger\n+        LedgerHandle lh = newBk.createLedger(3, 3, 3, digestType, passwd);\n+        // 0) write entry 0\n+        lh.addEntry(\"entry-0\".getBytes(UTF_8));\n+\n+        // open ledger to read\n+        LedgerHandle readLh = newBk.openLedgerNoRecovery(lh.getId(), digestType, passwd);\n+\n+        // 1) wait entry 0 to be committed\n+        ReadLastConfirmedAndEntryResult readResult = new ReadLastConfirmedAndEntryResult();\n+        readLh.asyncReadLastConfirmedAndEntry(0L, 9999999, true, readResult, null);\n+\n+        // 2) write entry 1 to commit entry 0 => lac = 0\n+        lh.addEntry(\"entry-1\".getBytes(UTF_8));\n+        readResult.await();\n+        assertEquals(BKException.Code.OK, readResult.rc);\n+        assertEquals(0L, readResult.lac);\n+        assertEquals(0L, readResult.entry.getEntryId());\n+        assertEquals(\"entry-0\", new String(readResult.entry.getEntry(), UTF_8));\n+\n+        // 3) write entry 2 to commit entry 1 => lac = 1\n+        lh.addEntry(\"entry-2\".getBytes(UTF_8));\n+        // 4) count down read latch to trigger previous readLacAndEntry request\n+        readLatch.countDown();\n+        // 5) due to piggyback, the lac is updated to lac = 1\n+        while (readLh.getLastAddConfirmed() < 1L) {\n+            Thread.sleep(100);\n+        }\n+        // 6) write entry 3 to commit entry 2 => lac = 2\n+        lh.addEntry(\"entry-3\".getBytes(UTF_8));\n+        // 7) readLastConfirmedAndEntry for next entry (we are expecting to read entry 1)\n+        readResult = new ReadLastConfirmedAndEntryResult();\n+        readLh.asyncReadLastConfirmedAndEntry(1L, 9999999, true, readResult, null);\n+        readResult.await();\n+        assertEquals(BKException.Code.OK, readResult.rc);\n+        assertEquals(2L, readResult.lac);\n+        assertEquals(1L, readResult.entry.getEntryId());\n+        assertEquals(\"entry-1\", new String(readResult.entry.getEntry(), UTF_8));\n+\n+        lh.close();\n+        readLh.close();\n+\n+        newBk.close();\n+    }\n+}"},{"sha":"094fe88f6ae244e79e6c777ae84d8c267db5f06a","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestReadLastConfirmedLongPoll.java","status":"added","additions":169,"deletions":0,"changes":169,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/ee0dddee6849d1968500af666571df668d34393a/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FTestReadLastConfirmedLongPoll.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/ee0dddee6849d1968500af666571df668d34393a/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FTestReadLastConfirmedLongPoll.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FTestReadLastConfirmedLongPoll.java?ref=ee0dddee6849d1968500af666571df668d34393a","patch":"@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.bookkeeper.client;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+import org.apache.bookkeeper.client.BookKeeper.DigestType;\n+import org.apache.bookkeeper.conf.ServerConfiguration;\n+import org.apache.bookkeeper.test.BookKeeperClusterTestCase;\n+import org.junit.Test;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+public class TestReadLastConfirmedLongPoll extends BookKeeperClusterTestCase {\n+    final DigestType digestType;\n+\n+    public TestReadLastConfirmedLongPoll() {\n+        super(6);\n+        this.digestType = DigestType.CRC32;\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testReadLACLongPollWhenAllBookiesUp() throws Exception {\n+        final int numEntries = 3;\n+\n+        final LedgerHandle lh = bkc.createLedger(3, 3, 1, digestType, \"\".getBytes());\n+        LedgerHandle readLh = bkc.openLedgerNoRecovery(lh.getId(), digestType, \"\".getBytes());\n+        assertEquals(LedgerHandle.INVALID_ENTRY_ID, readLh.getLastAddConfirmed());\n+        // add entries\n+        for (int i = 0; i < (numEntries - 1); i++) {\n+            lh.addEntry((\"data\" + i).getBytes());\n+        }\n+        final AtomicBoolean success = new AtomicBoolean(false);\n+        final AtomicInteger numCallbacks = new AtomicInteger(0);\n+        final CountDownLatch firstReadComplete = new CountDownLatch(1);\n+        readLh.asyncTryReadLastConfirmed(new AsyncCallback.ReadLastConfirmedCallback() {\n+            @Override\n+            public void readLastConfirmedComplete(int rc, long lastConfirmed, Object ctx) {\n+                numCallbacks.incrementAndGet();\n+                if (BKException.Code.OK == rc) {\n+                    success.set(true);\n+                } else {\n+                    success.set(false);\n+                }\n+                firstReadComplete.countDown();\n+            }\n+        }, null);\n+        firstReadComplete.await();\n+        assertTrue(success.get());\n+        assertTrue(numCallbacks.get() == 1);\n+        assertEquals(numEntries - 3, readLh.getLastAddConfirmed());\n+        // try read last confirmed again\n+        success.set(false);\n+        numCallbacks.set(0);\n+        long entryId = readLh.getLastAddConfirmed()+1;\n+        final CountDownLatch secondReadComplete = new CountDownLatch(1);\n+        readLh.asyncReadLastConfirmedAndEntry(entryId++, 1000, true, new AsyncCallback.ReadLastConfirmedAndEntryCallback() {\n+            @Override\n+            public void readLastConfirmedAndEntryComplete(int rc, long lastConfirmed, LedgerEntry entry, Object ctx) {\n+                numCallbacks.incrementAndGet();\n+                if (BKException.Code.OK == rc && lastConfirmed == (numEntries - 2)) {\n+                    success.set(true);\n+                } else {\n+                    success.set(false);\n+                }\n+                secondReadComplete.countDown();\n+            }\n+        }, null);\n+        lh.addEntry((\"data\" + (numEntries - 1)).getBytes());\n+        secondReadComplete.await();\n+        assertTrue(success.get());\n+        assertTrue(numCallbacks.get() == 1);\n+        assertEquals(numEntries - 2, readLh.getLastAddConfirmed());\n+\n+        success.set(false);\n+        numCallbacks.set(0);\n+        final CountDownLatch thirdReadComplete = new CountDownLatch(1);\n+        readLh.asyncReadLastConfirmedAndEntry(entryId++, 1000, false, new AsyncCallback.ReadLastConfirmedAndEntryCallback() {\n+            @Override\n+            public void readLastConfirmedAndEntryComplete(int rc, long lastConfirmed, LedgerEntry entry, Object ctx) {\n+                numCallbacks.incrementAndGet();\n+                if (BKException.Code.OK == rc && lastConfirmed == (numEntries - 1)) {\n+                    success.set(true);\n+                } else {\n+                    success.set(false);\n+                }\n+                thirdReadComplete.countDown();\n+            }\n+        }, null);\n+        lh.addEntry((\"data\" + numEntries).getBytes());\n+        thirdReadComplete.await();\n+        assertTrue(success.get());\n+        assertTrue(numCallbacks.get() == 1);\n+        assertEquals(numEntries - 1, readLh.getLastAddConfirmed());\n+        lh.close();\n+        readLh.close();\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testReadLACLongPollWhenSomeBookiesDown() throws Exception {\n+        final int numEntries = 3;\n+        final LedgerHandle lh = bkc.createLedger(3, 1, 1, digestType, \"\".getBytes());\n+        LedgerHandle readLh = bkc.openLedgerNoRecovery(lh.getId(), digestType, \"\".getBytes());\n+        assertEquals(LedgerHandle.INVALID_ENTRY_ID, readLh.getLastAddConfirmed());\n+        // add entries\n+        for (int i = 0; i < numEntries; i++) {\n+            lh.addEntry((\"data\" + i).getBytes());\n+        }\n+        for (int i = 0; i < numEntries; i++) {\n+            ServerConfiguration[] confs = new ServerConfiguration[numEntries - 1];\n+            for (int j = 0; j < numEntries - 1; j++) {\n+                int idx = (i + 1 + j) % numEntries;\n+                confs[j] = killBookie(lh.getLedgerMetadata().currentEnsemble.get(idx));\n+            }\n+\n+            final AtomicBoolean entryAsExpected = new AtomicBoolean(false);\n+            final AtomicBoolean success = new AtomicBoolean(false);\n+            final AtomicInteger numCallbacks = new AtomicInteger(0);\n+            final CountDownLatch readComplete = new CountDownLatch(1);\n+            final int entryId = i;\n+            readLh.asyncTryReadLastConfirmed(new AsyncCallback.ReadLastConfirmedCallback() {\n+                @Override\n+                public void readLastConfirmedComplete(int rc, long lastConfirmed, Object ctx) {\n+                    numCallbacks.incrementAndGet();\n+                    if (BKException.Code.OK == rc) {\n+                        success.set(true);\n+                        entryAsExpected.set(lastConfirmed == (entryId - 1));\n+                    } else {\n+                        System.out.println(\"Return value\" + rc);\n+                        success.set(false);\n+                        entryAsExpected.set(false);\n+                    }\n+                    readComplete.countDown();\n+                }\n+            }, null);\n+            readComplete.await();\n+            assertTrue(success.get());\n+            assertTrue(entryAsExpected.get());\n+            assertTrue(numCallbacks.get() == 1);\n+\n+            lh.close();\n+            readLh.close();\n+\n+            // start the bookies\n+            for (ServerConfiguration conf : confs) {\n+                bs.add(startBookie(conf));\n+                bsConfs.add(conf);\n+            }\n+        }\n+    }\n+}"},{"sha":"95a0506d26b2e52ccdb76148790bf5dc5672d74d","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/GcLedgersTest.java","status":"modified","additions":7,"deletions":0,"changes":7,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/ee0dddee6849d1968500af666571df668d34393a/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FGcLedgersTest.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/ee0dddee6849d1968500af666571df668d34393a/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FGcLedgersTest.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FGcLedgersTest.java?ref=ee0dddee6849d1968500af666571df668d34393a","patch":"@@ -38,6 +38,8 @@\n import java.util.List;\n import java.util.Map;\n import java.util.NavigableMap;\n+import java.util.Observable;\n+import java.util.Observer;\n import java.util.Queue;\n import java.util.Random;\n import java.util.Set;\n@@ -418,5 +420,10 @@ public void registerLedgerDeletionListener(LedgerDeletionListener listener) {\n         @Override\n         public void flushEntriesLocationsIndex() throws IOException {\n         }\n+\n+        @Override\n+        public Observable waitForLastAddConfirmedUpdate(long ledgerId, long previoisLAC, Observer observer) throws IOException {\n+            return null;\n+        }\n     }\n }"},{"sha":"c6f2a36c246f2dc7856aa9a4455195bcb9e7d31a","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/LedgerManagerTestCase.java","status":"modified","additions":8,"deletions":9,"changes":17,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/ee0dddee6849d1968500af666571df668d34393a/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FLedgerManagerTestCase.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/ee0dddee6849d1968500af666571df668d34393a/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FLedgerManagerTestCase.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FLedgerManagerTestCase.java?ref=ee0dddee6849d1968500af666571df668d34393a","patch":"@@ -21,12 +21,14 @@\n \n package org.apache.bookkeeper.meta;\n \n+import io.netty.buffer.ByteBuf;\n import java.io.IOException;\n import java.util.Arrays;\n import java.util.Collection;\n import java.util.Map;\n import java.util.NavigableMap;\n-\n+import java.util.Observable;\n+import java.util.Observer;\n import org.apache.bookkeeper.bookie.BookieException;\n import org.apache.bookkeeper.bookie.CheckpointSource;\n import org.apache.bookkeeper.bookie.CheckpointSource.Checkpoint;\n@@ -43,17 +45,12 @@\n import org.junit.runner.RunWith;\n import org.junit.runners.Parameterized;\n import org.junit.runners.Parameterized.Parameters;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import io.netty.buffer.ByteBuf;\n \n /**\n  * Test case to run over serveral ledger managers\n  */\n @RunWith(Parameterized.class)\n public abstract class LedgerManagerTestCase extends BookKeeperClusterTestCase {\n-    static final Logger LOG = LoggerFactory.getLogger(LedgerManagerTestCase.class);\n \n     protected LedgerManagerFactory ledgerManagerFactory;\n     protected LedgerManager ledgerManager = null;\n@@ -208,14 +205,16 @@ public void flushEntriesLocationsIndex() throws IOException {\n         }\n \n         @Override\n-        public void setExplicitlac(long ledgerId, ByteBuf lac) throws IOException {\n-            // TODO Auto-generated method stub\n+        public Observable waitForLastAddConfirmedUpdate(long ledgerId, long previoisLAC, Observer observer) throws IOException {\n+            return null;\n+        }\n \n+        @Override\n+        public void setExplicitlac(long ledgerId, ByteBuf lac) throws IOException {\n         }\n \n         @Override\n         public ByteBuf getExplicitLac(long ledgerId) {\n-            // TODO Auto-generated method stub\n             return null;\n         }\n     }"},{"sha":"a2f66bbd5c774ff757ca06fd59602c2456dad7f6","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookKeeperClusterTestCase.java","status":"modified","additions":13,"deletions":0,"changes":13,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/ee0dddee6849d1968500af666571df668d34393a/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Ftest%2FBookKeeperClusterTestCase.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/ee0dddee6849d1968500af666571df668d34393a/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Ftest%2FBookKeeperClusterTestCase.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Ftest%2FBookKeeperClusterTestCase.java?ref=ee0dddee6849d1968500af666571df668d34393a","patch":"@@ -214,6 +214,19 @@ protected ServerConfiguration newServerConfiguration(int port, String zkServers,\n         return conf;\n     }\n \n+    protected void stopAllBookies() throws Exception {\n+        for (BookieServer server : bs) {\n+            server.shutdown();\n+        }\n+        bs.clear();\n+    }\n+\n+    protected void startAllBookies() throws Exception {\n+        for (ServerConfiguration conf : bsConfs) {\n+            bs.add(startBookie(conf));\n+        }\n+    }\n+\n     /**\n      * Get bookie address for bookie at index\n      */"}]}