{"sha":"32c2859f0bec9ab74965d954bce038480e4dc2ba","node_id":"MDY6Q29tbWl0NDc4NTkyNTI2OjMyYzI4NTlmMGJlYzlhYjc0OTY1ZDk1NGJjZTAzODQ4MGU0ZGMyYmE=","commit":{"author":{"name":"Samuel Just","email":"sjust@salesforce.com","date":"2017-06-28T21:28:38Z"},"committer":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2017-06-28T21:28:38Z"},"message":"BOOKKEEPER-1086: ZkUnderreplicationManager cache watcher\n\nPreviously, getLedgerToReplicate left watches each time it traversed the\ntree until it found a suitable replication target.  Since we don't have\na way of canceling watches, these watches tended to get abandoned,\nparticularly on interior nodes, which aren't changed much.  Thus,\nover time, some nodes would build up a very large number of watch.\n\nInstead, introduce a caching mechanism to remember outstanding watches\nand avoid ever creating two watches on the same node.\n\nAuthor: Samuel Just <sjustsalesforce.com>\n\nAuthor: Samuel Just <sjust@salesforce.com>\n\nReviewers: Enrico Olivelli <eolivelli@gmail.com>, Jia Zhai <None>, Sijie Guo <sijie@apache.org>\n\nThis closes #193 from athanatos/forupstream/BOOKKEEPER-1098","tree":{"sha":"592639cb9c2a0fe7d7aedca8c27cb64bcbba1c87","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/trees/592639cb9c2a0fe7d7aedca8c27cb64bcbba1c87"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/commits/32c2859f0bec9ab74965d954bce038480e4dc2ba","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/32c2859f0bec9ab74965d954bce038480e4dc2ba","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/32c2859f0bec9ab74965d954bce038480e4dc2ba","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/32c2859f0bec9ab74965d954bce038480e4dc2ba/comments","author":null,"committer":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"parents":[{"sha":"9ddd9e6f9e48b03a57a2c78ec2630303abd49782","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/9ddd9e6f9e48b03a57a2c78ec2630303abd49782","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/9ddd9e6f9e48b03a57a2c78ec2630303abd49782"}],"stats":{"total":554,"additions":523,"deletions":31},"files":[{"sha":"e9863175d9b78dc47546da421a5ec1a56a79949a","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/ZkLedgerUnderreplicationManager.java","status":"modified","additions":36,"deletions":31,"changes":67,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/32c2859f0bec9ab74965d954bce038480e4dc2ba/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FZkLedgerUnderreplicationManager.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/32c2859f0bec9ab74965d954bce038480e4dc2ba/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FZkLedgerUnderreplicationManager.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FZkLedgerUnderreplicationManager.java?ref=32c2859f0bec9ab74965d954bce038480e4dc2ba","patch":"@@ -43,6 +43,7 @@\n import org.apache.bookkeeper.replication.ReplicationException;\n import org.apache.bookkeeper.replication.ReplicationException.UnavailableException;\n import org.apache.bookkeeper.util.BookKeeperConstants;\n+import org.apache.bookkeeper.util.SubTreeCache;\n import org.apache.bookkeeper.util.ZkUtils;\n import org.apache.zookeeper.CreateMode;\n import org.apache.zookeeper.KeeperException;\n@@ -102,6 +103,7 @@ private static class Lock {\n     private final String layoutZNode;\n     private final AbstractConfiguration conf;\n     private final ZooKeeper zkc;\n+    private final SubTreeCache subTreeCache;\n \n     public ZkLedgerUnderreplicationManager(AbstractConfiguration conf, ZooKeeper zkc)\n             throws KeeperException, InterruptedException, ReplicationException.CompatibilityException {\n@@ -114,6 +116,12 @@ public ZkLedgerUnderreplicationManager(AbstractConfiguration conf, ZooKeeper zkc\n \n         idExtractionPattern = Pattern.compile(\"urL(\\\\d+)$\");\n         this.zkc = zkc;\n+        this.subTreeCache = new SubTreeCache(new SubTreeCache.TreeProvider() {\n+            @Override\n+            public List<String> getChildren(String path, Watcher watcher) throws InterruptedException, KeeperException {\n+                return zkc.getChildren(path, watcher);\n+            }\n+        });\n \n         checkLayout();\n     }\n@@ -384,12 +392,12 @@ public Long next() {\n         };\n     }\n \n-    private long getLedgerToRereplicateFromHierarchy(String parent, long depth, Watcher w)\n+    private long getLedgerToRereplicateFromHierarchy(String parent, long depth)\n             throws KeeperException, InterruptedException {\n         if (depth == 4) {\n             List<String> children;\n             try {\n-                children = zkc.getChildren(parent, w);\n+                children = subTreeCache.getChildren(parent);\n             } catch (KeeperException.NoNodeException nne) {\n                 // can occur if another underreplicated ledger's\n                 // hierarchy is being cleaned up\n@@ -401,8 +409,8 @@ private long getLedgerToRereplicateFromHierarchy(String parent, long depth, Watc\n             while (children.size() > 0) {\n                 String tryChild = children.get(0);\n                 try {\n-                    String lockPath = urLockPath + \"/\" + tryChild;\n-                    if (zkc.exists(lockPath, w) != null) {\n+                    List<String> locks = subTreeCache.getChildren(urLockPath);\n+                    if (locks.contains(tryChild)) {\n                         children.remove(tryChild);\n                         continue;\n                     }\n@@ -416,6 +424,7 @@ private long getLedgerToRereplicateFromHierarchy(String parent, long depth, Watc\n                         continue;\n                     }\n \n+                    String lockPath = urLockPath + \"/\" + tryChild;\n                     long ledgerId = getLedgerId(tryChild);\n                     zkc.create(lockPath, LOCK_DATA, zkAcls, CreateMode.EPHEMERAL);\n                     heldLocks.put(ledgerId, new Lock(lockPath, stat.getVersion()));\n@@ -431,7 +440,7 @@ private long getLedgerToRereplicateFromHierarchy(String parent, long depth, Watc\n \n         List<String> children;\n         try {\n-            children = zkc.getChildren(parent, w);\n+            children = subTreeCache.getChildren(parent);\n         } catch (KeeperException.NoNodeException nne) {\n             // can occur if another underreplicated ledger's\n             // hierarchy is being cleaned up\n@@ -443,7 +452,7 @@ private long getLedgerToRereplicateFromHierarchy(String parent, long depth, Watc\n         while (children.size() > 0) {\n             String tryChild = children.get(0);\n             String tryPath = parent + \"/\" + tryChild;\n-            long ledger = getLedgerToRereplicateFromHierarchy(tryPath, depth + 1, w);\n+            long ledger = getLedgerToRereplicateFromHierarchy(tryPath, depth + 1);\n             if (ledger != -1) {\n                 return ledger;\n             }\n@@ -459,11 +468,7 @@ public long pollLedgerToRereplicate() throws ReplicationException.UnavailableExc\n             LOG.debug(\"pollLedgerToRereplicate()\");\n         }\n         try {\n-            Watcher w = new Watcher() {\n-                    public void process(WatchedEvent e) { // do nothing\n-                    }\n-                };\n-            return getLedgerToRereplicateFromHierarchy(urLedgerPath, 0, w);\n+            return getLedgerToRereplicateFromHierarchy(urLedgerPath, 0);\n         } catch (KeeperException ke) {\n             throw new ReplicationException.UnavailableException(\"Error contacting zookeeper\", ke);\n         } catch (InterruptedException ie) {\n@@ -477,33 +482,33 @@ public long getLedgerToRereplicate() throws ReplicationException.UnavailableExce\n         if (LOG.isDebugEnabled()) {\n             LOG.debug(\"getLedgerToRereplicate()\");\n         }\n-        try {\n-            while (true) {\n+        while (true) {\n+            final CountDownLatch changedLatch = new CountDownLatch(1);\n+            Watcher w = new Watcher() {\n+                public void process(WatchedEvent e) {\n+                    if (e.getType() == Watcher.Event.EventType.NodeChildrenChanged\n+                            || e.getType() == Watcher.Event.EventType.NodeDeleted\n+                            || e.getType() == Watcher.Event.EventType.NodeCreated\n+                            || e.getState() == Watcher.Event.KeeperState.Expired\n+                            || e.getState() == Watcher.Event.KeeperState.Disconnected) {\n+                        changedLatch.countDown();\n+                    }\n+                }\n+            };\n+            try (SubTreeCache.WatchGuard wg = subTreeCache.registerWatcherWithGuard(w)) {\n                 waitIfLedgerReplicationDisabled();\n-                final CountDownLatch changedLatch = new CountDownLatch(1);\n-                Watcher w = new Watcher() {\n-                        public void process(WatchedEvent e) {\n-                            if (e.getType() == Watcher.Event.EventType.NodeChildrenChanged\n-                                || e.getType() == Watcher.Event.EventType.NodeDeleted\n-                                || e.getType() == Watcher.Event.EventType.NodeCreated\n-                                || e.getState() == Watcher.Event.KeeperState.Expired\n-                                || e.getState() == Watcher.Event.KeeperState.Disconnected) {\n-                                changedLatch.countDown();\n-                            }\n-                        }\n-                    };\n-                long ledger = getLedgerToRereplicateFromHierarchy(urLedgerPath, 0, w);\n+                long ledger = getLedgerToRereplicateFromHierarchy(urLedgerPath, 0);\n                 if (ledger != -1) {\n                     return ledger;\n                 }\n                 // nothing found, wait for a watcher to trigger\n                 changedLatch.await();\n+            } catch (KeeperException ke) {\n+                throw new ReplicationException.UnavailableException(\"Error contacting zookeeper\", ke);\n+            } catch (InterruptedException ie) {\n+                Thread.currentThread().interrupt();\n+                throw new ReplicationException.UnavailableException(\"Interrupted while connecting zookeeper\", ie);\n             }\n-        } catch (KeeperException ke) {\n-            throw new ReplicationException.UnavailableException(\"Error contacting zookeeper\", ke);\n-        } catch (InterruptedException ie) {\n-            Thread.currentThread().interrupt();\n-            throw new ReplicationException.UnavailableException(\"Interrupted while connecting zookeeper\", ie);\n         }\n     }\n "},{"sha":"418c4583882b847490fce5e4c87e54d10714c363","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/util/SubTreeCache.java","status":"added","additions":166,"deletions":0,"changes":166,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/32c2859f0bec9ab74965d954bce038480e4dc2ba/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2FSubTreeCache.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/32c2859f0bec9ab74965d954bce038480e4dc2ba/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2FSubTreeCache.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2FSubTreeCache.java?ref=32c2859f0bec9ab74965d954bce038480e4dc2ba","patch":"@@ -0,0 +1,166 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+\n+package org.apache.bookkeeper.util;\n+\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.WatchedEvent;\n+import org.apache.zookeeper.Watcher;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Caching layer for traversing and monitoring changes on a znode subtree\n+ *\n+ * ZooKeeper does not provide a way to perform a recursive watch on a subtree.\n+ * In order to detect changes to a subtree, we need to maintain a\n+ * cache of nodes which have been listed and have not changed since.  This would\n+ * mirror the set of nodes with live watches in ZooKeeper (since we can't\n+ * cancel them at the moment).\n+ *\n+ * In order to avoid having to pre-read the whole subtree up front, we'll weaken\n+ * the guarantee to only require firing the watcher for updates on nodes read since\n+ * the watcher was registered which happened after the read.  We'll also permit\n+ * spurious events elsewhere in the tree to avoid having to distinguish between\n+ * nodes which were read before and after a watch was established.\n+ *\n+ * Finally, we'll allow (require, even) the user to cancel a registered watcher\n+ * once no longer interested.\n+ */\n+public class SubTreeCache {\n+    private static final Logger LOG = LoggerFactory.getLogger(SubTreeCache.class);\n+\n+    public interface TreeProvider {\n+        List<String> getChildren(\n+                String path, Watcher watcher) throws InterruptedException, KeeperException;\n+    }\n+\n+    private class SubTreeNode implements Watcher {\n+        String path;\n+        private List<String> children;\n+\n+        SubTreeNode(String path) {\n+            this.path = path;\n+        }\n+\n+        private void setChildren(List<String> children) {\n+            this.children = children;\n+        }\n+\n+        @Override\n+        public void process(WatchedEvent event) {\n+            synchronized (SubTreeCache.this) {\n+                handleEvent(event);\n+                cachedNodes.remove(path);\n+            }\n+        }\n+\n+        private List<String> getChildren() {\n+            return new ArrayList<String>(children);\n+        }\n+    }\n+\n+    TreeProvider provider;\n+    Set<Watcher> pendingWatchers = new HashSet<>();\n+    Map<String, SubTreeNode> cachedNodes = new HashMap<>();\n+\n+    public SubTreeCache(TreeProvider provider) {\n+        this.provider = provider;\n+    }\n+\n+    synchronized private void handleEvent(WatchedEvent event) {\n+        Set<Watcher> toReturn = pendingWatchers;\n+        for (Watcher watcher: pendingWatchers) {\n+            watcher.process(event);\n+        }\n+        pendingWatchers.clear();\n+    }\n+\n+\n+    /**\n+     * Returns children of node\n+     *\n+     * @param path Path of which to get children\n+     * @return Children of path\n+     */\n+    public synchronized List<String> getChildren(String path) throws KeeperException, InterruptedException {\n+        SubTreeNode node = cachedNodes.get(path);\n+        if (null == node) {\n+            node = new SubTreeNode(path);\n+            node.setChildren(provider.getChildren(path, node));\n+            cachedNodes.put(path, node);\n+        }\n+        return node.getChildren();\n+    }\n+\n+    /**\n+     * Register a watcher\n+     * <p>\n+     * See class header for semantics.\n+     *\n+     * @param watcher watcher to register\n+     */\n+    public synchronized void registerWatcher(Watcher watcher) {\n+        pendingWatchers.add(watcher);\n+    }\n+\n+    /**\n+     * Cancel a watcher (noop if not registered or already fired)\n+     *\n+     * @param watcher Watcher object to cancel\n+     */\n+    public synchronized void cancelWatcher(Watcher watcher) {\n+        pendingWatchers.remove(watcher);\n+    }\n+\n+    public class WatchGuard implements AutoCloseable {\n+        final Watcher w;\n+\n+        WatchGuard(Watcher w) {\n+            this.w = w;\n+        }\n+\n+        @Override\n+        public void close() {\n+            cancelWatcher(w);\n+        }\n+    }\n+\n+    /**\n+     * Register watcher and get interest guard object which can be used with try-with-resources\n+     * <p>\n+     * It's important not to leak watchers into this structure.  The returned WatchGuard\n+     * can be used to ensure that the watch is unregistered upon exiting a scope.\n+     *\n+     * @param watcher Watcher to register\n+     */\n+    public synchronized WatchGuard registerWatcherWithGuard(Watcher watcher) {\n+        registerWatcher(watcher);\n+        return new WatchGuard(watcher);\n+    }\n+}"},{"sha":"fde101b740a5c77afb2db1c991a259ea9f435f80","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/util/SubTreeCacheTest.java","status":"added","additions":321,"deletions":0,"changes":321,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/32c2859f0bec9ab74965d954bce038480e4dc2ba/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2FSubTreeCacheTest.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/32c2859f0bec9ab74965d954bce038480e4dc2ba/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2FSubTreeCacheTest.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2FSubTreeCacheTest.java?ref=32c2859f0bec9ab74965d954bce038480e4dc2ba","patch":"@@ -0,0 +1,321 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+\n+package org.apache.bookkeeper.util;\n+\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.WatchedEvent;\n+import org.apache.zookeeper.Watcher;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+\n+public class SubTreeCacheTest {\n+    class TestTreeProvider implements SubTreeCache.TreeProvider {\n+        class Node {\n+            Watcher watcher = null;\n+            public Map<String, Node> children = new HashMap<>();\n+        }\n+\n+        final Node root = new Node();\n+\n+        Node getNode(String path) throws KeeperException {\n+            String[] pathSegments = path.split(\"/\");\n+            Node cur = root;\n+            for (String segment : pathSegments) {\n+                if (segment.length() == 0)\n+                    continue; // ignore leading empty one for leading /\n+                if (cur.children.containsKey(segment)) {\n+                    cur = cur.children.get(segment);\n+                } else {\n+                    throw KeeperException.create(KeeperException.Code.NONODE);\n+                }\n+            }\n+            return cur;\n+        }\n+\n+        @Override\n+        public List<String> getChildren(\n+                String path, Watcher watcher) throws InterruptedException, KeeperException {\n+            Node node = getNode(path);\n+\n+            /* Enforce only one live watch per node */\n+            Assert.assertTrue(null == node.watcher);\n+\n+            node.watcher = watcher;\n+            return new ArrayList<String>(node.children.keySet());\n+        }\n+\n+        public void createNode(String path) throws KeeperException {\n+            String[] segments = path.split(\"/\");\n+            if (segments.length == 0) {\n+                throw KeeperException.create(KeeperException.Code.NONODE);\n+            }\n+            String child = segments[segments.length - 1];\n+            String[] parentSegments = Arrays.copyOfRange(segments, 0, segments.length - 1);\n+            Node parent = getNode(String.join(\"/\", parentSegments));\n+            if (parent.children.containsKey(child)) {\n+                throw KeeperException.create(KeeperException.Code.NODEEXISTS);\n+            } else {\n+                parent.children.put(child, new Node());\n+                if (null != parent.watcher) {\n+                    parent.watcher.process(\n+                            new WatchedEvent(\n+                                    Watcher.Event.EventType.NodeCreated,\n+                                    Watcher.Event.KeeperState.SyncConnected,\n+                                    path));\n+                    parent.watcher = null;\n+                }\n+            }\n+        }\n+\n+        public void removeNode(String path) throws KeeperException {\n+            String[] segments = path.split(\"/\");\n+            if (segments.length == 0) {\n+                throw KeeperException.create(KeeperException.Code.NONODE);\n+            }\n+            String child = segments[segments.length - 1];\n+            String[] parentSegments = Arrays.copyOfRange(segments, 0, segments.length - 1);\n+            String parentPath = String.join(\"/\", parentSegments);\n+            Node parent = getNode(parentPath);\n+            if (!parent.children.containsKey(child)) {\n+                throw KeeperException.create(KeeperException.Code.NONODE);\n+            } else {\n+                Node cNode = parent.children.get(child);\n+                if (!cNode.children.isEmpty()) {\n+                    throw KeeperException.create(KeeperException.Code.NOTEMPTY);\n+                } else {\n+                    if (null != cNode.watcher) {\n+                        cNode.watcher.process(\n+                                new WatchedEvent(\n+                                        Watcher.Event.EventType.NodeChildrenChanged,\n+                                        Watcher.Event.KeeperState.SyncConnected,\n+                                        path));\n+                        cNode.watcher = null;\n+                    }\n+                    if (null != parent.watcher) {\n+                        parent.watcher.process(\n+                                new WatchedEvent(\n+                                        Watcher.Event.EventType.NodeDeleted,\n+                                        Watcher.Event.KeeperState.SyncConnected,\n+                                        parentPath));\n+                        parent.watcher = null;\n+                    }\n+                    parent.children.remove(child);\n+                }\n+            }\n+        }\n+    }\n+\n+    TestTreeProvider tree = new TestTreeProvider();\n+    SubTreeCache cache = new SubTreeCache(tree);\n+\n+    class TestWatch implements Watcher {\n+        boolean fired = false;\n+\n+        @Override\n+        public void process(WatchedEvent event) {\n+            fired = true;\n+        }\n+\n+        public boolean getFired() {\n+            return fired;\n+        }\n+    }\n+\n+    TestWatch setWatch() {\n+        TestWatch watch = new TestWatch();\n+        cache.registerWatcher(watch);\n+        return watch;\n+    }\n+\n+    void assertFired(TestWatch watch) {\n+        Assert.assertTrue(watch.getFired());\n+    }\n+\n+    void assertNotFired(TestWatch watch) {\n+        Assert.assertFalse(watch.getFired());\n+    }\n+\n+    class TestWatchGuard extends TestWatch implements AutoCloseable {\n+        SubTreeCache.WatchGuard guard;\n+\n+        void setGuard(SubTreeCache.WatchGuard guard) {\n+            this.guard = guard;\n+        }\n+\n+        @Override\n+        public void close() throws Exception {\n+            guard.close();\n+        }\n+    }\n+\n+    TestWatchGuard setWatchWithGuard() {\n+        TestWatchGuard watch = new TestWatchGuard();\n+        watch.setGuard(cache.registerWatcherWithGuard(watch));\n+        return watch;\n+    }\n+\n+    void readAssertChildren(String path, String[] children) throws KeeperException, InterruptedException {\n+        SortedSet<String> shouldBe = new TreeSet<String>(Arrays.asList(children));\n+        List<String> returned = cache.getChildren(path);\n+        SortedSet<String> is = new TreeSet<String>(returned);\n+        returned.clear(); // trip up implementations which return an internal reference\n+        Assert.assertEquals(shouldBe, is);\n+    }\n+\n+    @Before\n+    public void setUp() throws Exception {\n+        String[] preCreate =\n+                {\"/a\"\n+                        , \"/a/a\"\n+                        , \"/a/a/a\"\n+                        , \"/a/a/b\"\n+                        , \"/a/b\"\n+                        , \"/a/c\"\n+                        , \"/b\"\n+                        , \"/b/a\"\n+                };\n+        for (String path : preCreate) {\n+            tree.createNode(path);\n+        }\n+    }\n+\n+    @Test(timeout=5000)\n+    public void testNoUpdate() throws Exception {\n+        TestWatch watch = setWatch();\n+        readAssertChildren(\"/a/a\", new String[]{\"a\", \"b\"});\n+        assertNotFired(watch);\n+    }\n+\n+    @Test(timeout=5000)\n+    public void testSingleCreate() throws Exception {\n+        TestWatch watch = setWatch();\n+        readAssertChildren(\"/a/a\", new String[]{\"a\", \"b\"});\n+        tree.createNode(\"/a/a/c\");\n+        assertFired(watch);\n+    }\n+\n+    @Test(timeout=5000)\n+    public void testSingleRemoval() throws Exception {\n+        TestWatch watch = setWatch();\n+        readAssertChildren(\"/a/a\", new String[]{\"a\", \"b\"});\n+        tree.removeNode(\"/a/a/b\");\n+        assertFired(watch);\n+    }\n+\n+    @Test(timeout=5000)\n+    public void testCancelation() throws Exception {\n+        TestWatch watch = setWatch();\n+        readAssertChildren(\"/a/a\", new String[]{\"a\", \"b\"});\n+        cache.cancelWatcher(watch);\n+        tree.createNode(\"/a/a/c\");\n+        assertNotFired(watch);\n+    }\n+\n+    @Test(timeout=5000)\n+    public void testGuardCancelation() throws Exception {\n+        TestWatch watch;\n+        try (TestWatchGuard guard = setWatchWithGuard()) {\n+            readAssertChildren(\"/a/a\", new String[]{\"a\", \"b\"});\n+            watch = guard;\n+        }\n+        tree.createNode(\"/a/a/c\");\n+        assertNotFired(watch);\n+    }\n+\n+    @Test(timeout=5000)\n+    public void testGuardCancelationExceptional() throws Exception {\n+        TestWatch watch = null;\n+        try (TestWatchGuard guard = setWatchWithGuard()) {\n+            watch = guard;\n+            readAssertChildren(\"/z/a\", new String[]{});\n+        } catch (Exception e) {\n+        }\n+        tree.createNode(\"/a/a/c\");\n+        assertNotFired(watch);\n+    }\n+\n+    @Test(timeout=5000)\n+    public void testDuplicateWatch() throws Exception {\n+        try (TestWatchGuard watch = setWatchWithGuard()) {\n+            readAssertChildren(\"/a/a\", new String[]{\"a\", \"b\"});\n+        }\n+        try (TestWatchGuard watch = setWatchWithGuard()) {\n+            readAssertChildren(\"/a/a\", new String[]{\"a\", \"b\"});\n+            assertNotFired(watch);\n+            tree.createNode(\"/a/a/e\");\n+            assertFired(watch);\n+        }\n+    }\n+\n+    @Test(timeout=5000, expected = KeeperException.class)\n+    public void testNoNode() throws Exception {\n+        try (TestWatchGuard watch = setWatchWithGuard()) {\n+            readAssertChildren(\"/z/a\", new String[]{});\n+        }\n+    }\n+\n+    @Test(timeout=5000)\n+    public void testRemoveEmptyNode() throws Exception {\n+        try (TestWatchGuard watch = setWatchWithGuard()) {\n+            readAssertChildren(\"/a/a/a\", new String[]{});\n+            tree.removeNode(\"/a/a/a\");\n+            assertFired(watch);\n+        }\n+    }\n+\n+    @Test(timeout=5000)\n+    public void doubleWatch() throws Exception {\n+        try (TestWatchGuard watch1 = setWatchWithGuard()) {\n+            readAssertChildren(\"/a/a\", new String[]{\"a\", \"b\"});\n+            try (TestWatchGuard watch2 = setWatchWithGuard()) {\n+                tree.createNode(\"/a/a/e\");\n+                assertFired(watch1);\n+                readAssertChildren(\"/a/b\", new String[]{});\n+                tree.createNode(\"/a/b/e\");\n+                assertFired(watch2);\n+            }\n+        }\n+    }\n+\n+    @Test(timeout=5000)\n+    public void sequentialWatch() throws Exception {\n+        try (TestWatchGuard watch = setWatchWithGuard()) {\n+            readAssertChildren(\"/a/a\", new String[]{\"a\", \"b\"});\n+            tree.removeNode(\"/a/a/a\");\n+            assertFired(watch);\n+        }\n+        try (TestWatchGuard watch = setWatchWithGuard()) {\n+            readAssertChildren(\"/a/a\", new String[]{\"b\"});\n+            tree.removeNode(\"/a/a/b\");\n+            assertFired(watch);\n+        }\n+    }\n+}"}]}