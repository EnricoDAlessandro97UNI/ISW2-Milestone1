{"sha":"e33ec10aa400f32c2e0278c15ea80a0f624e5919","node_id":"MDY6Q29tbWl0NDc4NTkyNTI2OmUzM2VjMTBhYTQwMGYzMmMyZTAyNzhjMTVlYTgwYTBmNjI0ZTU5MTk=","commit":{"author":{"name":"Robin Dhamankar","email":"rdhamankar@twitter.com","date":"2017-06-01T10:30:54Z"},"committer":{"name":"Enrico Olivelli","email":"eolivelli@apache.org","date":"2017-06-01T10:30:54Z"},"message":"BOOKKEEPER-1083: Improvements on OrderedSafeExecutor\n\n    - use listeningscheduledexecutorservice for the threads\n    - as a general util class, expose chooseThread to allow applications use specific thread\n    - add a method to force shutdown executor\n\nAuthor: Robin Dhamankar <rdhamankar@twitter.com>\nAuthor: Sijie Guo <sijie@apache.org>\n\nReviewers: Enrico Olivelli\n\nCloses #171 from sijie/add_monitored_thread_pool","tree":{"sha":"3cfc5c70d6f78fdd0d89c3e10ed1fc91b619a34f","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/trees/3cfc5c70d6f78fdd0d89c3e10ed1fc91b619a34f"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/commits/e33ec10aa400f32c2e0278c15ea80a0f624e5919","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/e33ec10aa400f32c2e0278c15ea80a0f624e5919","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/e33ec10aa400f32c2e0278c15ea80a0f624e5919","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/e33ec10aa400f32c2e0278c15ea80a0f624e5919/comments","author":{"login":"dhamanka","id":84472204,"node_id":"MDQ6VXNlcjg0NDcyMjA0","avatar_url":"https://avatars.githubusercontent.com/u/84472204?v=4","gravatar_id":"","url":"https://api.github.com/users/dhamanka","html_url":"https://github.com/dhamanka","followers_url":"https://api.github.com/users/dhamanka/followers","following_url":"https://api.github.com/users/dhamanka/following{/other_user}","gists_url":"https://api.github.com/users/dhamanka/gists{/gist_id}","starred_url":"https://api.github.com/users/dhamanka/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dhamanka/subscriptions","organizations_url":"https://api.github.com/users/dhamanka/orgs","repos_url":"https://api.github.com/users/dhamanka/repos","events_url":"https://api.github.com/users/dhamanka/events{/privacy}","received_events_url":"https://api.github.com/users/dhamanka/received_events","type":"User","site_admin":false},"committer":{"login":"eolivelli","id":9469110,"node_id":"MDQ6VXNlcjk0NjkxMTA=","avatar_url":"https://avatars.githubusercontent.com/u/9469110?v=4","gravatar_id":"","url":"https://api.github.com/users/eolivelli","html_url":"https://github.com/eolivelli","followers_url":"https://api.github.com/users/eolivelli/followers","following_url":"https://api.github.com/users/eolivelli/following{/other_user}","gists_url":"https://api.github.com/users/eolivelli/gists{/gist_id}","starred_url":"https://api.github.com/users/eolivelli/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/eolivelli/subscriptions","organizations_url":"https://api.github.com/users/eolivelli/orgs","repos_url":"https://api.github.com/users/eolivelli/repos","events_url":"https://api.github.com/users/eolivelli/events{/privacy}","received_events_url":"https://api.github.com/users/eolivelli/received_events","type":"User","site_admin":false},"parents":[{"sha":"77a01dc7e6431092f82a7efb02789beb165b75e2","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/77a01dc7e6431092f82a7efb02789beb165b75e2","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/77a01dc7e6431092f82a7efb02789beb165b75e2"}],"stats":{"total":108,"additions":70,"deletions":38},"files":[{"sha":"c3554b482a0445036470924260f5613a713126f5","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/util/OrderedSafeExecutor.java","status":"modified","additions":70,"deletions":38,"changes":108,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/e33ec10aa400f32c2e0278c15ea80a0f624e5919/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2FOrderedSafeExecutor.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/e33ec10aa400f32c2e0278c15ea80a0f624e5919/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2FOrderedSafeExecutor.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2FOrderedSafeExecutor.java?ref=e33ec10aa400f32c2e0278c15ea80a0f624e5919","patch":"@@ -18,18 +18,19 @@\n package org.apache.bookkeeper.util;\n \n import com.google.common.base.Preconditions;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import com.google.common.util.concurrent.ListeningScheduledExecutorService;\n+import com.google.common.util.concurrent.MoreExecutors;\n import com.google.common.util.concurrent.ThreadFactoryBuilder;\n import java.util.Random;\n import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.ExecutorService;\n import java.util.concurrent.Executors;\n import java.util.concurrent.RejectedExecutionException;\n import java.util.concurrent.ScheduledExecutorService;\n import java.util.concurrent.ScheduledFuture;\n import java.util.concurrent.ScheduledThreadPoolExecutor;\n import java.util.concurrent.ThreadFactory;\n import java.util.concurrent.TimeUnit;\n-\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n import org.apache.bookkeeper.stats.Gauge;\n import org.apache.bookkeeper.stats.NullStatsLogger;\n@@ -57,7 +58,7 @@\n public class OrderedSafeExecutor {\n     final static long WARN_TIME_MICRO_SEC_DEFAULT = TimeUnit.SECONDS.toMicros(1);\n     final String name;\n-    final ScheduledThreadPoolExecutor threads[];\n+    final ListeningScheduledExecutorService threads[];\n     final long threadIds[];\n     final Random rand = new Random();\n     final OpStatsLogger taskExecutionStats;\n@@ -170,16 +171,15 @@ private OrderedSafeExecutor(String baseName, int numThreads, ThreadFactory threa\n \n         this.warnTimeMicroSec = warnTimeMicroSec;\n         name = baseName;\n-        threads = new ScheduledThreadPoolExecutor[numThreads];\n+        threads = new ListeningScheduledExecutorService[numThreads];\n         threadIds = new long[numThreads];\n         for (int i = 0; i < numThreads; i++) {\n-            threads[i] =  new ScheduledThreadPoolExecutor(1,\n+            final ScheduledThreadPoolExecutor thread =  new ScheduledThreadPoolExecutor(1,\n                     new ThreadFactoryBuilder()\n                         .setNameFormat(name + \"-orderedsafeexecutor-\" + i + \"-%d\")\n                         .setThreadFactory(threadFactory)\n                         .build());\n-\n-            // Save thread ids\n+            threads[i] = MoreExecutors.listeningDecorator(thread);\n             final int idx = i;\n             try {\n                 threads[idx].submit(new SafeRunnable() {\n@@ -203,7 +203,7 @@ public Number getDefaultValue() {\n \n                 @Override\n                 public Number getSample() {\n-                    return threads[idx].getQueue().size();\n+                    return thread.getQueue().size();\n                 }\n             });\n             statsLogger.registerGauge(String.format(\"%s-completed-tasks-%d\", name, idx), new Gauge<Number>() {\n@@ -214,7 +214,7 @@ public Number getDefaultValue() {\n \n                 @Override\n                 public Number getSample() {\n-                    return threads[idx].getCompletedTaskCount();\n+                    return thread.getCompletedTaskCount();\n                 }\n             });\n             statsLogger.registerGauge(String.format(\"%s-total-tasks-%d\", name, idx), new Gauge<Number>() {\n@@ -225,7 +225,7 @@ public Number getDefaultValue() {\n \n                 @Override\n                 public Number getSample() {\n-                    return threads[idx].getTaskCount();\n+                    return thread.getTaskCount();\n                 }\n             });\n         }\n@@ -236,27 +236,30 @@ public Number getSample() {\n         this.traceTaskExecution = traceTaskExecution;\n     }\n \n-    ScheduledExecutorService chooseThread() {\n+    public ListeningScheduledExecutorService chooseThread() {\n         // skip random # generation in this special case\n         if (threads.length == 1) {\n             return threads[0];\n         }\n \n         return threads[rand.nextInt(threads.length)];\n-\n     }\n \n-    ScheduledExecutorService chooseThread(Object orderingKey) {\n-        // skip hashcode generation in this special case\n+    public ListeningScheduledExecutorService chooseThread(Object orderingKey) {\n         if (threads.length == 1) {\n             return threads[0];\n         }\n \n         return threads[MathUtils.signSafeMod(orderingKey.hashCode(), threads.length)];\n     }\n \n-    ExecutorService chooseThread(long orderingKey) {\n-        // skip hashcode generation in this special case\n+    /**\n+     * skip hashcode generation in this special case\n+     *\n+     * @param orderingKey long ordering key\n+     * @return the thread for executing this order key\n+     */\n+    public ListeningScheduledExecutorService chooseThread(long orderingKey) {\n         if (threads.length == 1) {\n             return threads[0];\n         }\n@@ -276,16 +279,45 @@ private SafeRunnable timedRunnable(SafeRunnable r) {\n      * schedules a one time action to execute\n      */\n     public void submit(SafeRunnable r) {\n-        chooseThread().execute(timedRunnable(r));\n+        chooseThread().submit(timedRunnable(r));\n+    }\n+\n+    /**\n+     * schedules a one time action to execute with an ordering guarantee on the key\n+     * @param orderingKey\n+     * @param r\n+     */\n+    public ListenableFuture<?> submitOrdered(Object orderingKey, SafeRunnable r) {\n+        return chooseThread(orderingKey).submit(timedRunnable(r));\n     }\n \n     /**\n      * schedules a one time action to execute with an ordering guarantee on the key\n      * @param orderingKey\n      * @param r\n      */\n-    public void submitOrdered(Object orderingKey, SafeRunnable r) {\n-        chooseThread(orderingKey).execute(timedRunnable(r));\n+    public void submitOrdered(long orderingKey, SafeRunnable r) {\n+        chooseThread(orderingKey).execute(r);\n+    }\n+\n+    /**\n+     * schedules a one time action to execute with an ordering guarantee on the key\n+     * @param orderingKey\n+     * @param r\n+     */\n+    public void submitOrdered(int orderingKey, SafeRunnable r) {\n+        chooseThread(orderingKey).execute(r);\n+    }\n+\n+    /**\n+     * schedules a one time action to execute with an ordering guarantee on the key.\n+     *\n+     * @param orderingKey\n+     * @param callable\n+     */\n+    public <T> ListenableFuture<T> submitOrdered(Object orderingKey,\n+                                                 java.util.concurrent.Callable<T> callable) {\n+        return chooseThread(orderingKey).submit(callable);\n     }\n \n     /**\n@@ -386,24 +418,6 @@ public ScheduledFuture<?> scheduleWithFixedDelayOrdered(Object orderingKey, Safe\n         return chooseThread(orderingKey).scheduleWithFixedDelay(command, initialDelay, delay, unit);\n     }\n \n-    /**\n-     * schedules a one time action to execute with an ordering guarantee on the key\n-     * @param orderingKey\n-     * @param r\n-     */\n-    public void submitOrdered(long orderingKey, SafeRunnable r) {\n-        chooseThread(orderingKey).execute(r);\n-    }\n-\n-    /**\n-     * schedules a one time action to execute with an ordering guarantee on the key\n-     * @param orderingKey\n-     * @param r\n-     */\n-    public void submitOrdered(int orderingKey, SafeRunnable r) {\n-        chooseThread(orderingKey).execute(r);\n-    }\n-\n     private long getThreadID(long orderingKey) {\n         // skip hashcode generation in this special case\n         if (threadIds.length == 1) {\n@@ -427,13 +441,31 @@ public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedE\n         return ret;\n     }\n \n+    /**\n+     * Force threads shutdown (cancel active requests) after specified delay,\n+     * to be used after shutdown() rejects new requests.\n+     */\n+    public void forceShutdown(long timeout, TimeUnit unit) {\n+        for (int i = 0; i < threads.length; i++) {\n+            try {\n+                if (!threads[i].awaitTermination(timeout, unit)) {\n+                    threads[i].shutdownNow();\n+                }\n+            }\n+            catch (InterruptedException exception) {\n+                threads[i].shutdownNow();\n+                Thread.currentThread().interrupt();\n+            }\n+        }\n+    }\n+\n     /**\n      * Generic callback implementation which will run the\n      * callback in the thread which matches the ordering key\n      */\n     public static abstract class OrderedSafeGenericCallback<T>\n             implements GenericCallback<T> {\n-        private final Logger LOG = LoggerFactory.getLogger(OrderedSafeGenericCallback.class);\n+        private static final Logger LOG = LoggerFactory.getLogger(OrderedSafeGenericCallback.class);\n \n         private final OrderedSafeExecutor executor;\n         private final long orderingKey;"}]}