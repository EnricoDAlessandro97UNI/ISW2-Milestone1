{"sha":"dd575a16decbeaab1f230db271bc400d7e434216","node_id":"MDY6Q29tbWl0NDc4NTkyNTI2OmRkNTc1YTE2ZGVjYmVhYWIxZjIzMGRiMjcxYmM0MDBkN2U0MzQyMTY=","commit":{"author":{"name":"Siddharth Boobna","email":"sboobna@yahoo-inc.com","date":"2016-04-27T07:55:19Z"},"committer":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2016-04-27T07:55:19Z"},"message":"BOOKKEEPER-895: GC ledgers that are no longer a part of the ensemble\n\nAuthor: Siddharth Boobna <sboobna@yahoo-inc.com>\n\nReviewers: Matteo Merli <mmerli@apache.org>, Guo Sijie <sijie@apache.org>\n\nCloses #25 from sboobna/BOOKKEEPER-895","tree":{"sha":"c65a825214d648e8802e869e612609b3eaf25bf3","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/trees/c65a825214d648e8802e869e612609b3eaf25bf3"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/commits/dd575a16decbeaab1f230db271bc400d7e434216","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/dd575a16decbeaab1f230db271bc400d7e434216","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/dd575a16decbeaab1f230db271bc400d7e434216","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/dd575a16decbeaab1f230db271bc400d7e434216/comments","author":null,"committer":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"parents":[{"sha":"40af841a366323d19fde2ae73d198824c16af688","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/40af841a366323d19fde2ae73d198824c16af688","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/40af841a366323d19fde2ae73d198824c16af688"}],"stats":{"total":781,"additions":619,"deletions":162},"files":[{"sha":"b3f1637b82dd08edc8a7138d6042142a47737e66","filename":"bookkeeper-server/conf/bk_server.conf","status":"modified","additions":5,"deletions":0,"changes":5,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/dd575a16decbeaab1f230db271bc400d7e434216/bookkeeper-server%2Fconf%2Fbk_server.conf","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/dd575a16decbeaab1f230db271bc400d7e434216/bookkeeper-server%2Fconf%2Fbk_server.conf","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fconf%2Fbk_server.conf?ref=dd575a16decbeaab1f230db271bc400d7e434216","patch":"@@ -162,6 +162,11 @@ ledgerDirectories=/tmp/bk-data\n # interval if there is enough disk capacity.\n # gcWaitTime=1000\n \n+# How long the interval to trigger next garbage collection of overreplicated\n+# ledgers, in milliseconds [Default: 1 day]. This should not be run very frequently since we read\n+# the metadata for all the ledgers on the bookie from zk\n+# gcOverreplicatedLedgerWaitTime=86400000\n+\n # How long the interval to flush ledger index pages to disk, in milliseconds\n # Flushing index files will introduce much random disk I/O.\n # If separating journal dir and ledger dirs each on different devices,"},{"sha":"2821ec889b2cd9a0204a6a93c517a9894583ff1a","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/GarbageCollectorThread.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/dd575a16decbeaab1f230db271bc400d7e434216/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FGarbageCollectorThread.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/dd575a16decbeaab1f230db271bc400d7e434216/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FGarbageCollectorThread.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FGarbageCollectorThread.java?ref=dd575a16decbeaab1f230db271bc400d7e434216","patch":"@@ -244,7 +244,7 @@ public void clean(long ledgerId) {\n             }\n         };\n \n-        this.garbageCollector = new ScanAndCompareGarbageCollector(ledgerManager, ledgerStorage);\n+        this.garbageCollector = new ScanAndCompareGarbageCollector(ledgerManager, ledgerStorage, conf);\n \n         // compaction parameters\n         minorCompactionThreshold = conf.getMinorCompactionThreshold();"},{"sha":"05cd958f93a590acf33100956ddc4c4094013835","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/ScanAndCompareGarbageCollector.java","status":"modified","additions":125,"deletions":3,"changes":128,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/dd575a16decbeaab1f230db271bc400d7e434216/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FScanAndCompareGarbageCollector.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/dd575a16decbeaab1f230db271bc400d7e434216/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FScanAndCompareGarbageCollector.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FScanAndCompareGarbageCollector.java?ref=dd575a16decbeaab1f230db271bc400d7e434216","patch":"@@ -21,12 +21,27 @@\n \n package org.apache.bookkeeper.bookie;\n \n+import java.io.IOException;\n+import java.util.ArrayList;\n import java.util.NavigableSet;\n import java.util.Set;\n+import java.util.SortedMap;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Semaphore;\n \n+import org.apache.bookkeeper.client.BKException;\n+import org.apache.bookkeeper.client.LedgerMetadata;\n+import org.apache.bookkeeper.conf.ServerConfiguration;\n import org.apache.bookkeeper.meta.LedgerManager;\n import org.apache.bookkeeper.meta.LedgerManager.LedgerRange;\n import org.apache.bookkeeper.meta.LedgerManager.LedgerRangeIterator;\n+import org.apache.bookkeeper.meta.ZkLedgerUnderreplicationManager;\n+import org.apache.bookkeeper.net.BookieSocketAddress;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n+import org.apache.bookkeeper.util.MathUtils;\n+import org.apache.bookkeeper.zookeeper.ZooKeeperClient;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.ZooKeeper;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -49,12 +64,32 @@\n public class ScanAndCompareGarbageCollector implements GarbageCollector{\n \n     static final Logger LOG = LoggerFactory.getLogger(ScanAndCompareGarbageCollector.class);\n+    static final int MAX_CONCURRENT_ZK_REQUESTS = 1000;\n+\n     private final LedgerManager ledgerManager;\n     private final CompactableLedgerStorage ledgerStorage;\n-\n-    public ScanAndCompareGarbageCollector(LedgerManager ledgerManager, CompactableLedgerStorage ledgerStorage) {\n+    private final ServerConfiguration conf;\n+    private final BookieSocketAddress selfBookieAddress;\n+    private ZooKeeper zk = null;\n+    private boolean enableGcOverReplicatedLedger;\n+    private final long gcOverReplicatedLedgerIntervalMillis;\n+    private long lastOverReplicatedLedgerGcTimeMillis;\n+    private final String zkLedgersRootPath;\n+\n+    public ScanAndCompareGarbageCollector(LedgerManager ledgerManager, CompactableLedgerStorage ledgerStorage,\n+            ServerConfiguration conf) throws IOException {\n         this.ledgerManager = ledgerManager;\n         this.ledgerStorage = ledgerStorage;\n+        this.conf = conf;\n+        this.selfBookieAddress = Bookie.getBookieAddress(conf);\n+        this.gcOverReplicatedLedgerIntervalMillis = conf.getGcOverreplicatedLedgerWaitTimeMillis();\n+        this.lastOverReplicatedLedgerGcTimeMillis = MathUtils.now();\n+        if (gcOverReplicatedLedgerIntervalMillis > 0) {\n+            this.enableGcOverReplicatedLedger = true;\n+        }\n+        this.zkLedgersRootPath = conf.getZkLedgersRootPath();\n+        LOG.info(\"Over Replicated Ledger Deletion : enabled=\" + enableGcOverReplicatedLedger + \", interval=\"\n+                + gcOverReplicatedLedgerIntervalMillis);\n     }\n \n     @Override\n@@ -75,6 +110,22 @@ public void gc(GarbageCleaner garbageCleaner) {\n \n             long lastEnd = -1;\n \n+            long curTime = MathUtils.now();\n+            boolean checkOverreplicatedLedgers = (enableGcOverReplicatedLedger && curTime\n+                    - lastOverReplicatedLedgerGcTimeMillis > gcOverReplicatedLedgerIntervalMillis);\n+            if (checkOverreplicatedLedgers) {\n+                zk = ZooKeeperClient.newBuilder().connectString(conf.getZkServers())\n+                        .sessionTimeoutMs(conf.getZkTimeout()).build();\n+                // remove all the overreplicated ledgers from the local bookie\n+                Set<Long> overReplicatedLedgers = removeOverReplicatedledgers(bkActiveLedgers, garbageCleaner);\n+                if (overReplicatedLedgers.isEmpty()) {\n+                    LOG.info(\"No over-replicated ledgers found.\");\n+                } else {\n+                    LOG.info(\"Removed over-replicated ledgers: {}\", overReplicatedLedgers);\n+                }\n+                lastOverReplicatedLedgerGcTimeMillis = MathUtils.now();\n+            }\n+\n             while(ledgerRangeIterator.hasNext()) {\n                 LedgerRange lRange = ledgerRangeIterator.next();\n \n@@ -100,8 +151,79 @@ public void gc(GarbageCleaner garbageCleaner) {\n         } catch (Exception e) {\n             // ignore exception, collecting garbage next time\n             LOG.warn(\"Exception when iterating over the metadata {}\", e);\n+        } finally {\n+            if (zk != null) {\n+                try {\n+                    zk.close();\n+                } catch (InterruptedException e) {\n+                    LOG.error(\"Error closing zk session\", e);\n+                }\n+                zk = null;\n+            }\n         }\n     }\n-}\n \n+    private Set<Long> removeOverReplicatedledgers(Set<Long> bkActiveledgers, final GarbageCleaner garbageCleaner)\n+            throws InterruptedException, KeeperException {\n+        final Set<Long> overReplicatedLedgers = Sets.newHashSet();\n+        final Semaphore semaphore = new Semaphore(MAX_CONCURRENT_ZK_REQUESTS);\n+        final CountDownLatch latch = new CountDownLatch(bkActiveledgers.size());\n+        for (final Long ledgerId : bkActiveledgers) {\n+            try {\n+                // check if the ledger is being replicated already by the replication worker\n+                if (ZkLedgerUnderreplicationManager.isLedgerBeingReplicated(zk, zkLedgersRootPath, ledgerId)) {\n+                    latch.countDown();\n+                    continue;\n+                }\n+                // we try to acquire the underreplicated ledger lock to not let the bookie replicate the ledger that is\n+                // already being checked for deletion, since that might change the ledger ensemble to include the\n+                // current bookie again and, in that case, we cannot remove the ledger from local storage\n+                ZkLedgerUnderreplicationManager.acquireUnderreplicatedLedgerLock(zk, zkLedgersRootPath, ledgerId);\n+                semaphore.acquire();\n+                ledgerManager.readLedgerMetadata(ledgerId, new GenericCallback<LedgerMetadata>() {\n+\n+                    @Override\n+                    public void operationComplete(int rc, LedgerMetadata ledgerMetadata) {\n+                        if (rc == BKException.Code.OK) {\n+                            // do not delete a ledger that is not closed, since the ensemble might change again and\n+                            // include the current bookie while we are deleting it\n+                            if (!ledgerMetadata.isClosed()) {\n+                                release();\n+                                return;\n+                            }\n+                            SortedMap<Long, ArrayList<BookieSocketAddress>> ensembles = ledgerMetadata.getEnsembles();\n+                            for (ArrayList<BookieSocketAddress> ensemble : ensembles.values()) {\n+                                // check if this bookie is supposed to have this ledger\n+                                if (ensemble.contains(selfBookieAddress)) {\n+                                    release();\n+                                    return;\n+                                }\n+                            }\n+                            // this bookie is not supposed to have this ledger, thus we can delete this ledger now\n+                            overReplicatedLedgers.add(ledgerId);\n+                            garbageCleaner.clean(ledgerId);\n+                        }\n+                        release();\n+                    }\n \n+                    private void release() {\n+                        semaphore.release();\n+                        latch.countDown();\n+                        try {\n+                            ZkLedgerUnderreplicationManager.releaseUnderreplicatedLedgerLock(zk, zkLedgersRootPath,\n+                                    ledgerId);\n+                        } catch (Exception e) {\n+                            LOG.error(\"Error removing underreplicated lock for ledger {}\", ledgerId, e);\n+                        }\n+                    }\n+                });\n+            } catch (Exception e) {\n+                LOG.error(\"Exception when iterating through the ledgers to check for over-replication\", e);\n+                latch.countDown();\n+            }\n+        }\n+        latch.await();\n+        bkActiveledgers.removeAll(overReplicatedLedgers);\n+        return overReplicatedLedgers;\n+    }\n+}"},{"sha":"7d9b697cc15c300efea9b1e7ffcfeaa92817ca2e","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ServerConfiguration.java","status":"modified","additions":31,"deletions":1,"changes":32,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/dd575a16decbeaab1f230db271bc400d7e434216/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fconf%2FServerConfiguration.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/dd575a16decbeaab1f230db271bc400d7e434216/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fconf%2FServerConfiguration.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fconf%2FServerConfiguration.java?ref=dd575a16decbeaab1f230db271bc400d7e434216","patch":"@@ -19,8 +19,10 @@\n \n import java.io.File;\n import java.util.List;\n+import java.util.concurrent.TimeUnit;\n \n import com.google.common.annotations.Beta;\n+\n import org.apache.bookkeeper.stats.NullStatsProvider;\n import org.apache.bookkeeper.stats.StatsProvider;\n import org.apache.bookkeeper.util.BookKeeperConstants;\n@@ -51,6 +53,7 @@ public class ServerConfiguration extends AbstractConfiguration {\n     // Gc Parameters\n     protected final static String GC_WAIT_TIME = \"gcWaitTime\";\n     protected final static String IS_FORCE_GC_ALLOW_WHEN_NO_SPACE = \"isForceGCAllowWhenNoSpace\";\n+    protected final static String GC_OVERREPLICATED_LEDGER_WAIT_TIME = \"gcOverreplicatedLedgerWaitTime\";\n     // Sync Parameters\n     protected final static String FLUSH_INTERVAL = \"flushInterval\";\n     // Bookie death watch interval\n@@ -209,11 +212,38 @@ public ServerConfiguration setGcWaitTime(long gcWaitTime) {\n         return this;\n     }\n \n+    /**\n+     * Get wait time in millis for garbage collection of overreplicated ledgers\n+     * \n+     * @return gc wait time\n+     */\n+    public long getGcOverreplicatedLedgerWaitTimeMillis() {\n+        return this.getLong(GC_OVERREPLICATED_LEDGER_WAIT_TIME, TimeUnit.DAYS.toMillis(1));\n+    }\n+\n+    /**\n+     * Set wait time for garbage collection of overreplicated ledgers. Default: 1 day\n+     * \n+     * A ledger can be overreplicated under the following circumstances:\n+     * 1. The ledger with few entries has bk1 and bk2 as its ensemble.\n+     * 2. bk1 crashes.\n+     * 3. bk3 replicates the ledger from bk2 and updates the ensemble to bk2 and bk3.\n+     * 4. bk1 comes back up.\n+     * 5. Now there are 3 copies of the ledger.\n+     *  \n+     * @param gcWaitTime\n+     * @return server configuration\n+     */\n+    public ServerConfiguration setGcOverreplicatedLedgerWaitTime(long gcWaitTime, TimeUnit unit) {\n+        this.setProperty(GC_OVERREPLICATED_LEDGER_WAIT_TIME, Long.toString(unit.toMillis(gcWaitTime)));\n+        return this;\n+    }\n+\n     /**\n      * Get flush interval. Default value is 10 second. It isn't useful to decrease\n      * this value, since ledger storage only checkpoints when an entry logger file\n      * is rolled.\n-     *\n+     * \n      * @return flush interval\n      */\n     public int getFlushInterval() {"},{"sha":"c49c5a20a75cd27a69ed38f03851d6716501b8c2","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/ZkLedgerUnderreplicationManager.java","status":"modified","additions":77,"deletions":42,"changes":119,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/dd575a16decbeaab1f230db271bc400d7e434216/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FZkLedgerUnderreplicationManager.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/dd575a16decbeaab1f230db271bc400d7e434216/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FZkLedgerUnderreplicationManager.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FZkLedgerUnderreplicationManager.java?ref=dd575a16decbeaab1f230db271bc400d7e434216","patch":"@@ -18,51 +18,45 @@\n \n package org.apache.bookkeeper.meta;\n \n+import static com.google.common.base.Charsets.UTF_8;\n+\n+import java.net.UnknownHostException;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.bookkeeper.conf.AbstractConfiguration;\n import org.apache.bookkeeper.net.DNS;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n+import org.apache.bookkeeper.proto.DataFormats.LedgerRereplicationLayoutFormat;\n+import org.apache.bookkeeper.proto.DataFormats.LockDataFormat;\n+import org.apache.bookkeeper.proto.DataFormats.UnderreplicatedLedgerFormat;\n import org.apache.bookkeeper.replication.ReplicationEnableCb;\n import org.apache.bookkeeper.replication.ReplicationException;\n import org.apache.bookkeeper.replication.ReplicationException.UnavailableException;\n import org.apache.bookkeeper.util.BookKeeperConstants;\n import org.apache.bookkeeper.util.ZkUtils;\n-\n-import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n-import org.apache.bookkeeper.proto.DataFormats.LedgerRereplicationLayoutFormat;\n-import org.apache.bookkeeper.proto.DataFormats.UnderreplicatedLedgerFormat;\n-import org.apache.bookkeeper.proto.DataFormats.LockDataFormat;\n-import org.apache.bookkeeper.conf.AbstractConfiguration;\n-import org.apache.zookeeper.ZooKeeper;\n-import org.apache.zookeeper.WatchedEvent;\n-import org.apache.zookeeper.Watcher;\n import org.apache.zookeeper.CreateMode;\n import org.apache.zookeeper.KeeperException;\n-import org.apache.zookeeper.data.Stat;\n+import org.apache.zookeeper.WatchedEvent;\n+import org.apache.zookeeper.Watcher;\n import org.apache.zookeeper.ZooDefs.Ids;\n+import org.apache.zookeeper.ZooKeeper;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n import com.google.common.annotations.VisibleForTesting;\n-import com.google.protobuf.TextFormat;\n import com.google.common.base.Joiner;\n-import static com.google.common.base.Charsets.UTF_8;\n-\n-import java.net.UnknownHostException;\n-\n-import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.Map;\n-import java.util.List;\n-import java.util.Collections;\n-import java.util.Arrays;\n-import java.util.Deque;\n-import java.util.ArrayDeque;\n-import java.util.Iterator;\n-import java.util.LinkedList;\n-import java.util.Queue;\n-import java.util.ArrayList;\n-\n-import java.util.regex.Pattern;\n-import java.util.regex.Matcher;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n+import com.google.protobuf.TextFormat;\n \n /**\n  * ZooKeeper implementation of underreplication manager.\n@@ -84,6 +78,8 @@ public class ZkLedgerUnderreplicationManager implements LedgerUnderreplicationMa\n     static final String LAYOUT=\"BASIC\";\n     static final int LAYOUT_VERSION=1;\n \n+    public static final byte[] LOCK_DATA = getLockData();\n+\n     private static class Lock {\n         private final String lockZNode;\n         private final int ledgerZNodeVersion;\n@@ -103,32 +99,40 @@ private static class Lock {\n     private final String urLedgerPath;\n     private final String urLockPath;\n     private final String layoutZNode;\n-    private final LockDataFormat lockData;\n \n     private final ZooKeeper zkc;\n \n     public ZkLedgerUnderreplicationManager(AbstractConfiguration conf, ZooKeeper zkc)\n             throws KeeperException, InterruptedException, ReplicationException.CompatibilityException {\n-        basePath = conf.getZkLedgersRootPath() + '/'\n-                + BookKeeperConstants.UNDER_REPLICATION_NODE;\n+        basePath = getBasePath(conf.getZkLedgersRootPath());\n         layoutZNode = basePath + '/' + BookKeeperConstants.LAYOUT_ZNODE;\n         urLedgerPath = basePath\n                 + BookKeeperConstants.DEFAULT_ZK_LEDGERS_ROOT_PATH;\n-        urLockPath = basePath + \"/locks\";\n+        urLockPath = basePath + '/' + BookKeeperConstants.UNDER_REPLICATION_LOCK;\n \n         idExtractionPattern = Pattern.compile(\"urL(\\\\d+)$\");\n         this.zkc = zkc;\n \n+        checkLayout();\n+    }\n+\n+    public static String getBasePath(String rootPath) {\n+        return String.format(\"%s/%s\", rootPath, BookKeeperConstants.UNDER_REPLICATION_NODE);\n+    }\n+\n+    public static String getUrLockPath(String rootPath) {\n+        return String.format(\"%s/%s\", getBasePath(rootPath), BookKeeperConstants.UNDER_REPLICATION_LOCK);\n+    }\n+\n+    public static byte[] getLockData() {\n         LockDataFormat.Builder lockDataBuilder = LockDataFormat.newBuilder();\n         try {\n             lockDataBuilder.setBookieId(DNS.getDefaultHost(\"default\"));\n         } catch (UnknownHostException uhe) {\n             // if we cant get the address, ignore. it's optional\n             // in the data structure in any case\n         }\n-        lockData = lockDataBuilder.build();\n-\n-        checkLayout();\n+        return TextFormat.printToString(lockDataBuilder.build()).getBytes(UTF_8);\n     }\n \n     private void checkLayout()\n@@ -212,6 +216,10 @@ public static String getUrLedgerZnode(String base, long ledgerId) {\n         return String.format(\"%s/urL%010d\", getParentZnodePath(base, ledgerId), ledgerId);\n     }\n \n+    public static String getUrLedgerLockZnode(String base, long ledgerId) {\n+        return String.format(\"%s/urL%010d\", base, ledgerId);\n+    }\n+\n     private String getUrLedgerZnode(long ledgerId) {\n         return getUrLedgerZnode(urLedgerPath, ledgerId);\n     }\n@@ -399,8 +407,7 @@ private long getLedgerToRereplicateFromHierarchy(String parent, long depth, Watc\n                     }\n \n                     long ledgerId = getLedgerId(tryChild);\n-                    zkc.create(lockPath, TextFormat.printToString(lockData).getBytes(UTF_8),\n-                               Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);\n+                    zkc.create(lockPath, LOCK_DATA, Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);\n                     heldLocks.put(ledgerId, new Lock(lockPath, stat.getVersion()));\n                     return ledgerId;\n                 } catch (KeeperException.NodeExistsException nee) {\n@@ -627,4 +634,32 @@ public void process(WatchedEvent e) {\n                     \"Interrupted while contacting zookeeper\", ie);\n         }\n     }\n+\n+    /**\n+     * Check whether the ledger is being replicated by any bookie\n+     */\n+    public static boolean isLedgerBeingReplicated(ZooKeeper zkc, String zkLedgersRootPath, long ledgerId)\n+            throws KeeperException,\n+            InterruptedException {\n+        return zkc.exists(getUrLedgerLockZnode(getUrLockPath(zkLedgersRootPath), ledgerId), false) != null;\n+    }\n+\n+    /**\n+     * Acquire the underreplicated ledger lock\n+     */\n+    public static void acquireUnderreplicatedLedgerLock(ZooKeeper zkc, String zkLedgersRootPath, long ledgerId)\n+            throws KeeperException, InterruptedException {\n+        ZkUtils.createFullPathOptimistic(zkc, getUrLedgerLockZnode(getUrLockPath(zkLedgersRootPath), ledgerId),\n+                LOCK_DATA, Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);\n+    }\n+\n+    /**\n+     * Release the underreplicated ledger lock if it exists\n+     */\n+    public static void releaseUnderreplicatedLedgerLock(ZooKeeper zkc, String zkLedgersRootPath, long ledgerId)\n+            throws InterruptedException, KeeperException {\n+        if (isLedgerBeingReplicated(zkc, zkLedgersRootPath, ledgerId)) {\n+            zkc.delete(getUrLedgerLockZnode(getUrLockPath(zkLedgersRootPath), ledgerId), -1);\n+        }\n+    }\n }"},{"sha":"987de7a6ec6b6d77b6e4e8fb836fc70aadb45c13","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/util/BookKeeperConstants.java","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/dd575a16decbeaab1f230db271bc400d7e434216/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2FBookKeeperConstants.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/dd575a16decbeaab1f230db271bc400d7e434216/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2FBookKeeperConstants.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2FBookKeeperConstants.java?ref=dd575a16decbeaab1f230db271bc400d7e434216","patch":"@@ -38,6 +38,7 @@ public class BookKeeperConstants {\n     public static final String AVAILABLE_NODE = \"available\";\r\n     public static final String COOKIE_NODE = \"cookies\";\r\n     public static final String UNDER_REPLICATION_NODE = \"underreplication\";\r\n+    public static final String UNDER_REPLICATION_LOCK = \"locks\";\r\n     public static final String DISABLE_NODE = \"disable\";\r\n     public static final String DEFAULT_ZK_LEDGERS_ROOT_PATH = \"/ledgers\";\r\n     public static final String LAYOUT_ZNODE = \"LAYOUT\";\r"},{"sha":"5004817cd71f08cf6e9ad315d039caa5fe6f8169","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/TestGcOverreplicatedLedger.java","status":"added","additions":240,"deletions":0,"changes":240,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/dd575a16decbeaab1f230db271bc400d7e434216/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FTestGcOverreplicatedLedger.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/dd575a16decbeaab1f230db271bc400d7e434216/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FTestGcOverreplicatedLedger.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FTestGcOverreplicatedLedger.java?ref=dd575a16decbeaab1f230db271bc400d7e434216","patch":"@@ -0,0 +1,240 @@\n+/**\n+  *\n+  * Licensed to the Apache Software Foundation (ASF) under one\n+  * or more contributor license agreements.  See the NOTICE file\n+  * distributed with this work for additional information\n+  * regarding copyright ownership.  The ASF licenses this file\n+  * to you under the Apache License, Version 2.0 (the\n+  * \"License\"); you may not use this file except in compliance\n+  * with the License.  You may obtain a copy of the License at\n+  *\n+  *   http://www.apache.org/licenses/LICENSE-2.0\n+  *\n+  * Unless required by applicable law or agreed to in writing,\n+  * software distributed under the License is distributed on an\n+  * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+  * KIND, either express or implied.  See the License for the\n+  * specific language governing permissions and limitations\n+  * under the License.\n+  *\n+  */\n+\n+package org.apache.bookkeeper.bookie;\n+\n+import java.io.IOException;\n+import java.net.UnknownHostException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.SortedMap;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import org.apache.bookkeeper.bookie.GarbageCollector.GarbageCleaner;\n+import org.apache.bookkeeper.client.BKException;\n+import org.apache.bookkeeper.client.BookKeeper.DigestType;\n+import org.apache.bookkeeper.client.LedgerHandle;\n+import org.apache.bookkeeper.client.LedgerMetadata;\n+import org.apache.bookkeeper.conf.ServerConfiguration;\n+import org.apache.bookkeeper.meta.FlatLedgerManagerFactory;\n+import org.apache.bookkeeper.meta.LedgerManagerFactory;\n+import org.apache.bookkeeper.meta.LedgerManagerTestCase;\n+import org.apache.bookkeeper.meta.ZkLedgerUnderreplicationManager;\n+import org.apache.bookkeeper.net.BookieSocketAddress;\n+import org.apache.bookkeeper.proto.BookieServer;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n+import org.apache.bookkeeper.util.SnapshotMap;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+import com.google.common.collect.Lists;\n+\n+@RunWith(Parameterized.class)\n+public class TestGcOverreplicatedLedger extends LedgerManagerTestCase {\n+\n+    @Before\n+    @Override\n+    public void setUp() throws Exception {\n+        super.setUp();\n+        ledgerManager = ledgerManagerFactory.newLedgerManager();\n+        activeLedgers = new SnapshotMap<Long, Boolean>();\n+    }\n+\n+    public TestGcOverreplicatedLedger(Class<? extends LedgerManagerFactory> lmFactoryCls) {\n+        super(lmFactoryCls, 3);\n+    }\n+\n+    @Parameters\n+    public static Collection<Object[]> configs() {\n+        return Arrays.asList(new Object[][] { { FlatLedgerManagerFactory.class } });\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testGcOverreplicatedLedger() throws Exception {\n+        LedgerHandle lh = bkc.createLedger(2, 2, DigestType.MAC, \"\".getBytes());\n+        activeLedgers.put(lh.getId(), true);\n+\n+        final AtomicReference<LedgerMetadata> newLedgerMetadata = new AtomicReference<>(null);\n+        final CountDownLatch latch = new CountDownLatch(1);\n+        ledgerManager.readLedgerMetadata(lh.getId(), new GenericCallback<LedgerMetadata>() {\n+\n+            @Override\n+            public void operationComplete(int rc, LedgerMetadata result) {\n+                if (rc == BKException.Code.OK) {\n+                    newLedgerMetadata.set(result);\n+                }\n+                latch.countDown();\n+            }\n+        });\n+        latch.await();\n+        if (newLedgerMetadata.get() == null) {\n+            Assert.fail(\"No ledger metadata found\");\n+        }\n+        BookieSocketAddress bookieNotInEnsemble = getBookieNotInEnsemble(newLedgerMetadata.get());\n+        ServerConfiguration bkConf = getBkConf(bookieNotInEnsemble);\n+        bkConf.setGcOverreplicatedLedgerWaitTime(10, TimeUnit.MILLISECONDS);\n+\n+        lh.close();\n+\n+        final CompactableLedgerStorage mockLedgerStorage = new MockLedgerStorage();\n+        final GarbageCollector garbageCollector = new ScanAndCompareGarbageCollector(ledgerManager, mockLedgerStorage,\n+                bkConf);\n+        Thread.sleep(bkConf.getGcOverreplicatedLedgerWaitTimeMillis() + 1);\n+        garbageCollector.gc(new GarbageCleaner() {\n+\n+            @Override\n+            public void clean(long ledgerId) {\n+                try {\n+                    mockLedgerStorage.deleteLedger(ledgerId);\n+                } catch (IOException e) {\n+                    e.printStackTrace();\n+                    return;\n+                }\n+            }\n+        });\n+\n+        Assert.assertFalse(activeLedgers.containsKey(lh.getId()));\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testNoGcOfLedger() throws Exception {\n+        LedgerHandle lh = bkc.createLedger(2, 2, DigestType.MAC, \"\".getBytes());\n+        activeLedgers.put(lh.getId(), true);\n+\n+        final AtomicReference<LedgerMetadata> newLedgerMetadata = new AtomicReference<>(null);\n+        final CountDownLatch latch = new CountDownLatch(1);\n+        ledgerManager.readLedgerMetadata(lh.getId(), new GenericCallback<LedgerMetadata>() {\n+\n+            @Override\n+            public void operationComplete(int rc, LedgerMetadata result) {\n+                if (rc == BKException.Code.OK) {\n+                    newLedgerMetadata.set(result);\n+                }\n+                latch.countDown();\n+            }\n+        });\n+        latch.await();\n+        if (newLedgerMetadata.get() == null) {\n+            Assert.fail(\"No ledger metadata found\");\n+        }\n+        BookieSocketAddress address = null;\n+        SortedMap<Long, ArrayList<BookieSocketAddress>> ensembleMap = newLedgerMetadata.get().getEnsembles();\n+        for (ArrayList<BookieSocketAddress> ensemble : ensembleMap.values()) {\n+            address = ensemble.get(0);\n+        }\n+        ServerConfiguration bkConf = getBkConf(address);\n+        bkConf.setGcOverreplicatedLedgerWaitTime(10, TimeUnit.MILLISECONDS);\n+\n+        lh.close();\n+\n+        final CompactableLedgerStorage mockLedgerStorage = new MockLedgerStorage();\n+        final GarbageCollector garbageCollector = new ScanAndCompareGarbageCollector(ledgerManager, mockLedgerStorage,\n+                bkConf);\n+        Thread.sleep(bkConf.getGcOverreplicatedLedgerWaitTimeMillis() + 1);\n+        garbageCollector.gc(new GarbageCleaner() {\n+\n+            @Override\n+            public void clean(long ledgerId) {\n+                try {\n+                    mockLedgerStorage.deleteLedger(ledgerId);\n+                } catch (IOException e) {\n+                    e.printStackTrace();\n+                    return;\n+                }\n+            }\n+        });\n+\n+        Assert.assertTrue(activeLedgers.containsKey(lh.getId()));\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testNoGcIfLedgerBeingReplicated() throws Exception {\n+        LedgerHandle lh = bkc.createLedger(2, 2, DigestType.MAC, \"\".getBytes());\n+        activeLedgers.put(lh.getId(), true);\n+\n+        final AtomicReference<LedgerMetadata> newLedgerMetadata = new AtomicReference<>(null);\n+        final CountDownLatch latch = new CountDownLatch(1);\n+        ledgerManager.readLedgerMetadata(lh.getId(), new GenericCallback<LedgerMetadata>() {\n+\n+            @Override\n+            public void operationComplete(int rc, LedgerMetadata result) {\n+                if (rc == BKException.Code.OK) {\n+                    newLedgerMetadata.set(result);\n+                }\n+                latch.countDown();\n+            }\n+        });\n+        latch.await();\n+        if (newLedgerMetadata.get() == null) {\n+            Assert.fail(\"No ledger metadata found\");\n+        }\n+        BookieSocketAddress bookieNotInEnsemble = getBookieNotInEnsemble(newLedgerMetadata.get());\n+        ServerConfiguration bkConf = getBkConf(bookieNotInEnsemble);\n+        bkConf.setGcOverreplicatedLedgerWaitTime(10, TimeUnit.MILLISECONDS);\n+\n+        lh.close();\n+\n+        ZkLedgerUnderreplicationManager.acquireUnderreplicatedLedgerLock(zkc, baseConf.getZkLedgersRootPath(),\n+                lh.getId());\n+\n+        final CompactableLedgerStorage mockLedgerStorage = new MockLedgerStorage();\n+        final GarbageCollector garbageCollector = new ScanAndCompareGarbageCollector(ledgerManager, mockLedgerStorage,\n+                bkConf);\n+        Thread.sleep(bkConf.getGcOverreplicatedLedgerWaitTimeMillis() + 1);\n+        garbageCollector.gc(new GarbageCleaner() {\n+\n+            @Override\n+            public void clean(long ledgerId) {\n+                try {\n+                    mockLedgerStorage.deleteLedger(ledgerId);\n+                } catch (IOException e) {\n+                    e.printStackTrace();\n+                    return;\n+                }\n+            }\n+        });\n+\n+        Assert.assertTrue(activeLedgers.containsKey(lh.getId()));\n+    }\n+\n+    private BookieSocketAddress getBookieNotInEnsemble(LedgerMetadata ledgerMetadata) throws UnknownHostException {\n+        List<BookieSocketAddress> allAddresses = Lists.newArrayList();\n+        for (BookieServer bk : bs) {\n+            allAddresses.add(bk.getLocalAddress());\n+        }\n+        SortedMap<Long, ArrayList<BookieSocketAddress>> ensembles = ledgerMetadata.getEnsembles();\n+        for (ArrayList<BookieSocketAddress> fragmentEnsembles : ensembles.values()) {\n+            for (BookieSocketAddress ensemble : fragmentEnsembles) {\n+                allAddresses.remove(ensemble);\n+            }\n+        }\n+        Assert.assertEquals(allAddresses.size(), 1);\n+        return allAddresses.get(0);\n+    }\n+}"},{"sha":"d5866a5020c425db74a6a6c3d6c3d6c7d956826d","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/GcLedgersTest.java","status":"modified","additions":9,"deletions":110,"changes":119,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/dd575a16decbeaab1f230db271bc400d7e434216/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FGcLedgersTest.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/dd575a16decbeaab1f230db271bc400d7e434216/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FGcLedgersTest.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FGcLedgersTest.java?ref=dd575a16decbeaab1f230db271bc400d7e434216","patch":"@@ -21,15 +21,18 @@\n \n package org.apache.bookkeeper.meta;\n \n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+\n import java.io.IOException;\n-import java.nio.ByteBuffer;\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.HashSet;\n import java.util.LinkedList;\n import java.util.List;\n-import java.util.Map;\n-import java.util.NavigableMap;\n import java.util.Queue;\n import java.util.Random;\n import java.util.Set;\n@@ -39,21 +42,12 @@\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicInteger;\n \n-import org.apache.bookkeeper.bookie.CheckpointSource.Checkpoint;\n import org.apache.bookkeeper.bookie.CompactableLedgerStorage;\n-import org.apache.bookkeeper.bookie.EntryLocation;\n-import org.apache.bookkeeper.bookie.CheckpointSource;\n-import org.apache.bookkeeper.bookie.BookieException;\n-import org.apache.bookkeeper.bookie.EntryLogger;\n import org.apache.bookkeeper.bookie.GarbageCollector;\n-import org.apache.bookkeeper.bookie.LedgerDirsManager;\n import org.apache.bookkeeper.bookie.ScanAndCompareGarbageCollector;\n-import org.apache.bookkeeper.stats.StatsLogger;\n import org.apache.bookkeeper.client.BKException;\n import org.apache.bookkeeper.client.BookKeeper.DigestType;\n import org.apache.bookkeeper.client.LedgerMetadata;\n-import org.apache.bookkeeper.conf.ServerConfiguration;\n-import org.apache.bookkeeper.jmx.BKMBeanInfo;\n import org.apache.bookkeeper.meta.LedgerManager.LedgerRange;\n import org.apache.bookkeeper.meta.LedgerManager.LedgerRangeIterator;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n@@ -62,8 +56,6 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import static org.junit.Assert.*;\n-\n /**\n  * Test garbage collection ledgers in ledger manager\n  */\n@@ -175,7 +167,7 @@ public void operationComplete(int rc, Void result) {\n         final CountDownLatch endLatch = new CountDownLatch(2);\n         final CompactableLedgerStorage mockLedgerStorage = new MockLedgerStorage();\n         final GarbageCollector garbageCollector = new ScanAndCompareGarbageCollector(getLedgerManager(),\n-                mockLedgerStorage);\n+                mockLedgerStorage, baseConf);\n         Thread gcThread = new Thread() {\n             @Override\n             public void run() {\n@@ -246,7 +238,7 @@ public void testGcLedgersOutsideRange() throws Exception {\n         createLedgers(numLedgers, createdLedgers);\n \n         final GarbageCollector garbageCollector = new ScanAndCompareGarbageCollector(getLedgerManager(),\n-                new MockLedgerStorage());\n+                new MockLedgerStorage(), baseConf);\n         GarbageCollector.GarbageCleaner cleaner = new GarbageCollector.GarbageCleaner() {\n                 @Override\n                 public void clean(long ledgerId) {\n@@ -282,7 +274,7 @@ public void testGcLedgersNotLast() throws Exception {\n         createLedgers(numLedgers, createdLedgers);\n \n         final GarbageCollector garbageCollector = new ScanAndCompareGarbageCollector(getLedgerManager(),\n-                new MockLedgerStorage());\n+                new MockLedgerStorage(), baseConf);\n         GarbageCollector.GarbageCleaner cleaner = new GarbageCollector.GarbageCleaner() {\n                 @Override\n                 public void clean(long ledgerId) {\n@@ -309,97 +301,4 @@ public void clean(long ledgerId) {\n         assertEquals(\"Should have cleaned something\", 1, cleaned.size());\n         assertEquals(\"Should have cleaned first ledger\" + first, (long)first, (long)cleaned.get(0));\n     }\n-\n-    class MockLedgerStorage implements CompactableLedgerStorage {\n-\n-        @Override\n-        public void initialize(ServerConfiguration conf, LedgerManager ledgerManager,\n-                               LedgerDirsManager ledgerDirsManager,\n-                               LedgerDirsManager indexDirsManager,\n-                               CheckpointSource checkpointSource, StatsLogger statsLogger)\n-                throws IOException {}\n-\n-        @Override\n-        public void start() {\n-        }\n-\n-        @Override\n-        public void shutdown() throws InterruptedException {\n-        }\n-\n-        @Override\n-        public boolean ledgerExists(long ledgerId) throws IOException {\n-            return false;\n-        }\n-\n-        @Override\n-        public boolean setFenced(long ledgerId) throws IOException {\n-            return false;\n-        }\n-\n-        @Override\n-        public boolean isFenced(long ledgerId) throws IOException {\n-            return false;\n-        }\n-\n-        @Override\n-        public void setMasterKey(long ledgerId, byte[] masterKey) throws IOException {\n-        }\n-\n-        @Override\n-        public byte[] readMasterKey(long ledgerId) throws IOException, BookieException {\n-            return null;\n-        }\n-\n-        @Override\n-        public long addEntry(ByteBuffer entry) throws IOException {\n-            return 0;\n-        }\n-\n-        @Override\n-        public ByteBuffer getEntry(long ledgerId, long entryId) throws IOException {\n-            return null;\n-        }\n-\n-        @Override\n-        public void flush() throws IOException {\n-        }\n-\n-        @Override\n-        public Checkpoint checkpoint(Checkpoint checkpoint) throws IOException {\n-            return null;\n-        }\n-\n-        @Override\n-        public void deleteLedger(long ledgerId) throws IOException {\n-            activeLedgers.remove(ledgerId);\n-        }\n-\n-        @Override\n-        public Iterable<Long> getActiveLedgersInRange(long firstLedgerId, long lastLedgerId) {\n-            NavigableMap<Long, Boolean> bkActiveLedgersSnapshot = activeLedgers.snapshot();\n-            Map<Long, Boolean> subBkActiveLedgers = bkActiveLedgersSnapshot\n-                    .subMap(firstLedgerId, true, lastLedgerId, false);\n-\n-            return subBkActiveLedgers.keySet();\n-        }\n-\n-        @Override\n-        public BKMBeanInfo getJMXBean() {\n-            return null;\n-        }\n-\n-        @Override\n-        public EntryLogger getEntryLogger() {\n-            return null;\n-        }\n-\n-        @Override\n-        public void updateEntriesLocations(Iterable<EntryLocation> locations) throws IOException {\n-        }\n-\n-        @Override\n-        public void flushEntriesLocationsIndex() throws IOException {\n-        }\n-    }\n }"},{"sha":"1e7c9a619b447d6dc8572732e46b079c8237fb38","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/meta/LedgerManagerTestCase.java","status":"modified","additions":113,"deletions":5,"changes":118,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/dd575a16decbeaab1f230db271bc400d7e434216/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FLedgerManagerTestCase.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/dd575a16decbeaab1f230db271bc400d7e434216/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FLedgerManagerTestCase.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FLedgerManagerTestCase.java?ref=dd575a16decbeaab1f230db271bc400d7e434216","patch":"@@ -22,9 +22,22 @@\n package org.apache.bookkeeper.meta;\n \n import java.io.IOException;\n+import java.nio.ByteBuffer;\n import java.util.Arrays;\n import java.util.Collection;\n+import java.util.Map;\n+import java.util.NavigableMap;\n \n+import org.apache.bookkeeper.bookie.BookieException;\n+import org.apache.bookkeeper.bookie.CheckpointSource;\n+import org.apache.bookkeeper.bookie.CheckpointSource.Checkpoint;\n+import org.apache.bookkeeper.bookie.CompactableLedgerStorage;\n+import org.apache.bookkeeper.bookie.EntryLocation;\n+import org.apache.bookkeeper.bookie.EntryLogger;\n+import org.apache.bookkeeper.bookie.LedgerDirsManager;\n+import org.apache.bookkeeper.conf.ServerConfiguration;\n+import org.apache.bookkeeper.jmx.BKMBeanInfo;\n+import org.apache.bookkeeper.stats.StatsLogger;\n import org.apache.bookkeeper.test.BookKeeperClusterTestCase;\n import org.apache.bookkeeper.util.SnapshotMap;\n import org.junit.After;\n@@ -42,13 +55,17 @@\n public abstract class LedgerManagerTestCase extends BookKeeperClusterTestCase {\n     static final Logger LOG = LoggerFactory.getLogger(LedgerManagerTestCase.class);\n \n-    LedgerManagerFactory ledgerManagerFactory;\n-    LedgerManager ledgerManager = null;\n-    LedgerIdGenerator ledgerIdGenerator = null;\n-    SnapshotMap<Long, Boolean> activeLedgers = null;\n+    protected LedgerManagerFactory ledgerManagerFactory;\n+    protected LedgerManager ledgerManager = null;\n+    protected LedgerIdGenerator ledgerIdGenerator = null;\n+    protected SnapshotMap<Long, Boolean> activeLedgers = null;\n \n     public LedgerManagerTestCase(Class<? extends LedgerManagerFactory> lmFactoryCls) {\n-        super(0);\n+        this(lmFactoryCls, 0);\n+    }\n+\n+    public LedgerManagerTestCase(Class<? extends LedgerManagerFactory> lmFactoryCls, int numBookies) {\n+        super(numBookies);\n         activeLedgers = new SnapshotMap<Long, Boolean>();\n         baseConf.setLedgerManagerFactoryClass(lmFactoryCls);\n     }\n@@ -93,4 +110,95 @@ public void tearDown() throws Exception {\n         super.tearDown();\n     }\n \n+    public class MockLedgerStorage implements CompactableLedgerStorage {\n+\n+        @Override\n+        public void initialize(ServerConfiguration conf, LedgerManager ledgerManager,\n+                LedgerDirsManager ledgerDirsManager, LedgerDirsManager indexDirsManager,\n+                CheckpointSource checkpointSource, StatsLogger statsLogger) throws IOException {\n+        }\n+\n+        @Override\n+        public void start() {\n+        }\n+\n+        @Override\n+        public void shutdown() throws InterruptedException {\n+        }\n+\n+        @Override\n+        public boolean ledgerExists(long ledgerId) throws IOException {\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean setFenced(long ledgerId) throws IOException {\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean isFenced(long ledgerId) throws IOException {\n+            return false;\n+        }\n+\n+        @Override\n+        public void setMasterKey(long ledgerId, byte[] masterKey) throws IOException {\n+        }\n+\n+        @Override\n+        public byte[] readMasterKey(long ledgerId) throws IOException, BookieException {\n+            return null;\n+        }\n+\n+        @Override\n+        public long addEntry(ByteBuffer entry) throws IOException {\n+            return 0;\n+        }\n+\n+        @Override\n+        public ByteBuffer getEntry(long ledgerId, long entryId) throws IOException {\n+            return null;\n+        }\n+\n+        @Override\n+        public void flush() throws IOException {\n+        }\n+\n+        @Override\n+        public Checkpoint checkpoint(Checkpoint checkpoint) throws IOException {\n+            return null;\n+        }\n+\n+        @Override\n+        public void deleteLedger(long ledgerId) throws IOException {\n+            activeLedgers.remove(ledgerId);\n+        }\n+\n+        @Override\n+        public Iterable<Long> getActiveLedgersInRange(long firstLedgerId, long lastLedgerId) {\n+            NavigableMap<Long, Boolean> bkActiveLedgersSnapshot = activeLedgers.snapshot();\n+            Map<Long, Boolean> subBkActiveLedgers = bkActiveLedgersSnapshot\n+                    .subMap(firstLedgerId, true, lastLedgerId, false);\n+\n+            return subBkActiveLedgers.keySet();\n+        }\n+\n+        @Override\n+        public BKMBeanInfo getJMXBean() {\n+            return null;\n+        }\n+\n+        @Override\n+        public EntryLogger getEntryLogger() {\n+            return null;\n+        }\n+\n+        @Override\n+        public void updateEntriesLocations(Iterable<EntryLocation> locations) throws IOException {\n+        }\n+\n+        @Override\n+        public void flushEntriesLocationsIndex() throws IOException {\n+        }\n+    }\n }"},{"sha":"efb8375a428fd656b2a04f61a5dfbb2ccb685f83","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookKeeperClusterTestCase.java","status":"modified","additions":17,"deletions":0,"changes":17,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/dd575a16decbeaab1f230db271bc400d7e434216/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Ftest%2FBookKeeperClusterTestCase.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/dd575a16decbeaab1f230db271bc400d7e434216/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Ftest%2FBookKeeperClusterTestCase.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Ftest%2FBookKeeperClusterTestCase.java?ref=dd575a16decbeaab1f230db271bc400d7e434216","patch":"@@ -223,6 +223,23 @@ public BookieSocketAddress getBookie(int index) throws Exception {\n         return bs.get(index).getLocalAddress();\n     }\n \n+    /**\n+     * Get bookie configuration for bookie\n+     */\n+    public ServerConfiguration getBkConf(BookieSocketAddress addr) throws Exception {\n+        int bkIndex = 0;\n+        for (BookieServer server : bs) {\n+            if (server.getLocalAddress().equals(addr)) {\n+                break;\n+            }\n+            ++bkIndex;\n+        }\n+        if (bkIndex < bs.size()) {\n+            return bsConfs.get(bkIndex);\n+        }\n+        return null;\n+    }\n+\n     /**\n      * Kill a bookie by its socket address. Also, stops the autorecovery process\n      * for the corresponding bookie server, if isAutoRecoveryEnabled is true."}]}