{"sha":"8e0bd2c3d81b522e97434d8646915f36422a104b","node_id":"MDY6Q29tbWl0NDc4NTkyNTI2OjhlMGJkMmMzZDgxYjUyMmU5NzQzNGQ4NjQ2OTE1ZjM2NDIyYTEwNGI=","commit":{"author":{"name":"kishorekasi","email":"kkasiud1@gmail.com","date":"2017-08-01T22:49:46Z"},"committer":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2017-08-01T22:49:46Z"},"message":"BOOKKEEPER-588: SSL Support for Bookkeeper\n\n+ Merged changes from eoliville\n+ Mutual Authentication\n\nAuthor: kishorekasi <kkasiud1@gmail.com>\nAuthor: Kishore Kasi Udayashankar <kudayashankar@salesforce.com>\nAuthor: Kishore Udayashankar <kudayashankar@salesforce.com>\n\nReviewers: Sijie Guo <sijie@apache.org>\n\nThis patch had conflicts when merged, resolved by\nCommitter: Sijie Guo <sijie@apache.org>\n\nThis closes #183 from kishorekasi/BOOKKEEPER-588-kishore","tree":{"sha":"4bcf68828a8046cd18e6babd1a3082f78e34170f","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/trees/4bcf68828a8046cd18e6babd1a3082f78e34170f"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/commits/8e0bd2c3d81b522e97434d8646915f36422a104b","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/8e0bd2c3d81b522e97434d8646915f36422a104b","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/8e0bd2c3d81b522e97434d8646915f36422a104b","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/8e0bd2c3d81b522e97434d8646915f36422a104b/comments","author":{"login":"kishorekasi","id":3315960,"node_id":"MDQ6VXNlcjMzMTU5NjA=","avatar_url":"https://avatars.githubusercontent.com/u/3315960?v=4","gravatar_id":"","url":"https://api.github.com/users/kishorekasi","html_url":"https://github.com/kishorekasi","followers_url":"https://api.github.com/users/kishorekasi/followers","following_url":"https://api.github.com/users/kishorekasi/following{/other_user}","gists_url":"https://api.github.com/users/kishorekasi/gists{/gist_id}","starred_url":"https://api.github.com/users/kishorekasi/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/kishorekasi/subscriptions","organizations_url":"https://api.github.com/users/kishorekasi/orgs","repos_url":"https://api.github.com/users/kishorekasi/repos","events_url":"https://api.github.com/users/kishorekasi/events{/privacy}","received_events_url":"https://api.github.com/users/kishorekasi/received_events","type":"User","site_admin":false},"committer":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"parents":[{"sha":"45e7f08f6a88de2fbb2f23df4c15a88625edff5d","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/45e7f08f6a88de2fbb2f23df4c15a88625edff5d","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/45e7f08f6a88de2fbb2f23df4c15a88625edff5d"}],"stats":{"total":10726,"additions":6784,"deletions":3942},"files":[{"sha":"11d7244617ca1785f0b4c5b0eb466ff83492064f","filename":"bookkeeper-server/conf/bk_server.conf","status":"modified","additions":27,"deletions":0,"changes":27,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/8e0bd2c3d81b522e97434d8646915f36422a104b/bookkeeper-server%2Fconf%2Fbk_server.conf","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/8e0bd2c3d81b522e97434d8646915f36422a104b/bookkeeper-server%2Fconf%2Fbk_server.conf","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fconf%2Fbk_server.conf?ref=8e0bd2c3d81b522e97434d8646915f36422a104b","patch":"@@ -332,6 +332,33 @@ zkEnableSecurity=false\n # Stats Provider Class (if statistics are enabled)\n #statsProviderClass=org.apache.bookkeeper.stats.CodahaleMetricsProvider\n \n+# SSL Provider (JDK or OpenSSL)\n+# sslProvider=OpenSSL\n+\n+# The path to class that provides security.\n+#sslProviderFactoryClass=org.apache.bookkeeper.security.SSLContextFactory\n+\n+# Type of security used by server\n+#sslClientAuthentication=true\n+\n+# Bookie Keystore type\n+#sslKeyStoreType=JKS\n+\n+# Bookie Keystore location (path)\n+#sslKeyStore=\n+\n+# Bookie Keystore password path, if the keystore is protected by a password\n+#sslKeyStorePasswordPath=\n+\n+# Bookie Truststore type\n+#sslTrustStoreType=\n+\n+# Bookie Truststore location (path)\n+#sslTrustStore=\n+\n+# Bookie Truststore password path, if the truststore is protected by a password\n+#sslTrustStorePasswordPath=\n+\n # Minimum safe Usable size to be available in index directory for Bookie to create Index File while replaying \n # journal at the time of Bookie Start in Readonly Mode (in bytes)\n # minUsableSizeForIndexFileCreation=1073741824"},{"sha":"d1e74b5441e3e1a6a7228620c814cd82dfcde889","filename":"bookkeeper-server/pom.xml","status":"modified","additions":11,"deletions":0,"changes":11,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/8e0bd2c3d81b522e97434d8646915f36422a104b/bookkeeper-server%2Fpom.xml","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/8e0bd2c3d81b522e97434d8646915f36422a104b/bookkeeper-server%2Fpom.xml","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fpom.xml?ref=8e0bd2c3d81b522e97434d8646915f36422a104b","patch":"@@ -221,6 +221,11 @@\n         <version>2.7.3</version>\n         <scope>test</scope>\n     </dependency>          \n+    <dependency>\n+      <groupId>io.netty</groupId>\n+      <artifactId>netty-tcnative-boringssl-static</artifactId>\n+      <version>${netty-boringssl.version}</version>\n+    </dependency>\n   </dependencies>\n   <build>\n     <plugins>\n@@ -334,6 +339,12 @@\n             <exclude>**/.gitignore</exclude>\n             <exclude>**/.project</exclude>\n             <exclude>**/.settings/*</exclude>\n+            <exclude>certs/keyStoreClientPassword.txt</exclude>\n+            <exclude>certs/keyStoreServerPassword.txt</exclude>\n+            <exclude>certs/trustStorePassword.txt</exclude>\n+            <exclude>src/test/resources/keyStoreClientPassword.txt</exclude>\n+            <exclude>src/test/resources/keyStoreServerPassword.txt</exclude>\n+            <exclude>src/test/resources/trustStorePassword.txt</exclude>\n           </excludes>\n         </configuration>\n       </plugin>"},{"sha":"c5906fe1fc694e2dc70192eacb75d10df8786a8c","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/auth/AuthProviderFactoryFactory.java","status":"modified","additions":0,"deletions":1,"changes":1,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/8e0bd2c3d81b522e97434d8646915f36422a104b/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fauth%2FAuthProviderFactoryFactory.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/8e0bd2c3d81b522e97434d8646915f36422a104b/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fauth%2FAuthProviderFactoryFactory.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fauth%2FAuthProviderFactoryFactory.java?ref=8e0bd2c3d81b522e97434d8646915f36422a104b","patch":"@@ -106,5 +106,4 @@ public void process(AuthToken m, AuthCallbacks.GenericCallback<AuthToken> cb) {}\n             };\n         }\n     }\n-\n }"},{"sha":"4570d103d963de93e503d329aff58031b912291a","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/auth/BookieAuthProvider.java","status":"modified","additions":7,"deletions":0,"changes":7,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/8e0bd2c3d81b522e97434d8646915f36422a104b/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fauth%2FBookieAuthProvider.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/8e0bd2c3d81b522e97434d8646915f36422a104b/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fauth%2FBookieAuthProvider.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fauth%2FBookieAuthProvider.java?ref=8e0bd2c3d81b522e97434d8646915f36422a104b","patch":"@@ -77,6 +77,13 @@ BookieAuthProvider newProvider(BookieConnectionPeer connection,\n         default void close() {}\n     }\n \n+    /**\n+     * Callback to let the provider know that the underlying protocol is changed.\n+     * For instance this will happen when a START_TLS operation succeeds\n+     */\n+    default void onProtocolUpgrade() {\n+    }\n+\n     /**\n      * Process a request from the client. cb will receive the next\n      * message to be sent to the client. If there are no more messages"},{"sha":"8737d606284524c61f256bb091d57b2b4549546b","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/auth/ClientAuthProvider.java","status":"modified","additions":7,"deletions":0,"changes":7,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/8e0bd2c3d81b522e97434d8646915f36422a104b/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fauth%2FClientAuthProvider.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/8e0bd2c3d81b522e97434d8646915f36422a104b/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fauth%2FClientAuthProvider.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fauth%2FClientAuthProvider.java?ref=8e0bd2c3d81b522e97434d8646915f36422a104b","patch":"@@ -81,6 +81,13 @@ default void close() {}\n      */\n     void init(AuthCallbacks.GenericCallback<AuthToken> cb);\n \n+    /**\n+     * Callback to let the provider know that the underlying protocol is changed.\n+     * For instance this will happen when a START_TLS operation succeeds\n+     */\n+    default void onProtocolUpgrade() {\n+    }\n+\n     /**\n      * Process a response from the server. cb will receive the next\n      * message to be sent to the server. If there are no more messages"},{"sha":"c05d25daaa47423937094f0400f5d5ab3b479b7d","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java","status":"modified","additions":6,"deletions":1,"changes":7,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/8e0bd2c3d81b522e97434d8646915f36422a104b/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FBookie.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/8e0bd2c3d81b522e97434d8646915f36422a104b/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FBookie.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FBookie.java?ref=8e0bd2c3d81b522e97434d8646915f36422a104b","patch":"@@ -576,7 +576,12 @@ public static BookieSocketAddress getBookieAddress(ServerConfiguration conf)\n         if (iface == null) {\n             iface = \"default\";\n         }\n-        InetSocketAddress inetAddr = new InetSocketAddress(DNS.getDefaultHost(iface), conf.getBookiePort());\n+        String hostName = DNS.getDefaultHost(iface);\n+        InetSocketAddress inetAddr = new InetSocketAddress(hostName, conf.getBookiePort());\n+        if (inetAddr.isUnresolved()) {\n+            throw new UnknownHostException(\"Unable to resolve default hostname: \"\n+                    + hostName + \" for interface: \" + iface);\n+        }\n         String hostAddress = inetAddr.getAddress().getHostAddress();\n         if (conf.getUseHostNameAsBookieID()) {\n             hostAddress = inetAddr.getAddress().getCanonicalHostName();"},{"sha":"406d552726f21d7366a8978ff0cde985564362a2","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BKException.java","status":"modified","additions":10,"deletions":0,"changes":10,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/8e0bd2c3d81b522e97434d8646915f36422a104b/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBKException.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/8e0bd2c3d81b522e97434d8646915f36422a104b/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBKException.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBKException.java?ref=8e0bd2c3d81b522e97434d8646915f36422a104b","patch":"@@ -103,6 +103,8 @@ public static BKException create(int code) {\n             return new BKTimeoutException();\n         case Code.LedgerIdOverflowException:\n             return new BKLedgerIdOverflowException();\n+        case Code.SecurityException:\n+            return new BKSecurityException();\n         default:\n             return new BKUnexpectedConditionException();\n         }\n@@ -174,6 +176,7 @@ public interface Code {\n          * @since 4.5\n          */\n         int TimeoutException = -23;\n+        int SecurityException = -24;\n \n         /**\n          * Operation is illegal.\n@@ -286,11 +289,18 @@ public static String getMessage(int code) {\n             return \"Add entry quorum wait timed out\";\n         case Code.TimeoutException:\n             return \"Bookie operation timeout\";\n+        case Code.SecurityException:\n+            return \"Failed to establish a secure connection\";\n         default:\n             return \"Unexpected condition\";\n         }\n     }\n \n+    public static class BKSecurityException extends BKException {\n+        public BKSecurityException() {\n+            super(Code.SecurityException);\n+        }\n+    }\n     public static class BKReadException extends BKException {\n         public BKReadException() {\n             super(Code.ReadException);"},{"sha":"a0389c158dbaf4ad6631517f79f5fe7430efba7e","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeperClientStats.java","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/8e0bd2c3d81b522e97434d8646915f36422a104b/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookKeeperClientStats.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/8e0bd2c3d81b522e97434d8646915f36422a104b/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookKeeperClientStats.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookKeeperClientStats.java?ref=8e0bd2c3d81b522e97434d8646915f36422a104b","patch":"@@ -62,4 +62,5 @@ public interface BookKeeperClientStats {\n     public final static String CHANNEL_READ_LAC_OP = \"READ_LAC\";\n     public final static String CHANNEL_TIMEOUT_READ_LAC = \"TIMEOUT_READ_LAC\";\n     public final static String TIMEOUT_GET_BOOKIE_INFO = \"TIMEOUT_GET_BOOKIE_INFO\";\n+    public final static String CHANNEL_START_TLS_OP = \"START_TLS\";\n }"},{"sha":"5ab2435365b8832c758dcca13484d784458bb727","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingAddOp.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/8e0bd2c3d81b522e97434d8646915f36422a104b/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FPendingAddOp.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/8e0bd2c3d81b522e97434d8646915f36422a104b/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FPendingAddOp.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FPendingAddOp.java?ref=8e0bd2c3d81b522e97434d8646915f36422a104b","patch":"@@ -297,7 +297,7 @@ void submitCallback(final int rc) {\n         ReferenceCountUtil.release(toSend);\n \n         if (LOG.isDebugEnabled()) {\n-            LOG.debug(\"Submit callback (lid:{}, eid: {}). rc:{}\", new Object[] { lh.getId(), entryId, rc });\n+            LOG.debug(\"Submit callback (lid:{}, eid: {}). rc:{}\", lh.getId(), entryId, rc);\n         }\n \n         long latencyNanos = MathUtils.elapsedNanos(requestTimeNanos);"},{"sha":"5a081cea65f127638bf3a2ed1bc0cdbe44019e75","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/AbstractConfiguration.java","status":"modified","additions":143,"deletions":8,"changes":151,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/8e0bd2c3d81b522e97434d8646915f36422a104b/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fconf%2FAbstractConfiguration.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/8e0bd2c3d81b522e97434d8646915f36422a104b/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fconf%2FAbstractConfiguration.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fconf%2FAbstractConfiguration.java?ref=8e0bd2c3d81b522e97434d8646915f36422a104b","patch":"@@ -18,17 +18,19 @@\n package org.apache.bookkeeper.conf;\n \n import java.net.URL;\n+import javax.net.ssl.SSLEngine;\n+\n+import org.apache.bookkeeper.feature.Feature;\n+import org.apache.bookkeeper.meta.LedgerManagerFactory;\n+import org.apache.bookkeeper.util.ReflectionUtils;\n+import static org.apache.bookkeeper.conf.ClientConfiguration.CLIENT_AUTH_PROVIDER_FACTORY_CLASS;\n \n import org.apache.commons.configuration.CompositeConfiguration;\n import org.apache.commons.configuration.Configuration;\n import org.apache.commons.configuration.ConfigurationException;\n import org.apache.commons.configuration.PropertiesConfiguration;\n import org.apache.commons.configuration.SystemConfiguration;\n \n-import org.apache.bookkeeper.feature.Feature;\n-import org.apache.bookkeeper.meta.LedgerManagerFactory;\n-import org.apache.bookkeeper.util.ReflectionUtils;\n-\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -67,8 +69,27 @@ public abstract class AbstractConfiguration extends CompositeConfiguration {\n     protected final static String METASTORE_IMPL_CLASS = \"metastoreImplClass\";\n     protected final static String METASTORE_MAX_ENTRIES_PER_SCAN = \"metastoreMaxEntriesPerScan\";\n \n-    // Client auth provider factory class name. It must be configured on Bookies to for the Auditor\n-    protected final static String CLIENT_AUTH_PROVIDER_FACTORY_CLASS = \"clientAuthProviderFactoryClass\";\n+    // Common TLS configuration\n+    // TLS Provider (JDK or OpenSSL)\n+    protected final static String TLS_PROVIDER = \"tlsProvider\";\n+\n+    // TLS provider factory class name\n+    protected final static String TLS_PROVIDER_FACTORY_CLASS = \"tlsProviderFactoryClass\";\n+\n+    // Enable authentication of the other connection end point (mutual authentication)\n+    protected final static String TLS_CLIENT_AUTHENTICATION = \"tlsClientAuthentication\";\n+\n+    /**\n+     * This list will be passed to {@link SSLEngine#setEnabledCipherSuites(java.lang.String[]) }.\n+     * Please refer to official JDK JavaDocs\n+    */\n+    protected final static String TLS_ENABLED_CIPHER_SUITES = \"tlsEnabledCipherSuites\";\n+\n+    /**\n+     * This list will be passed to {@link SSLEngine#setEnabledProtocols(java.lang.String[]) }.\n+     * Please refer to official JDK JavaDocs\n+    */\n+    protected final static String TLS_ENABLED_PROTOCOLS = \"tlsEnabledProtocols\";\n \n     //Netty configuration\n     protected final static String NETTY_MAX_FRAME_SIZE = \"nettyMaxFrameSizeBytes\";\n@@ -323,8 +344,8 @@ public AbstractConfiguration setClientAuthProviderFactoryClass(\n     }\n \n     /**\n-     * Get the client authentication provider factory class name. If this returns null, no authentication will take\n-     * place.\n+     * Get the client authentication provider factory class name.\n+     * If this returns null, no authentication will take place.\n      *\n      * @return the client authentication provider factory class name or null.\n      */\n@@ -354,4 +375,118 @@ public AbstractConfiguration setNettyMaxFrameSizeBytes(int maxSize) {\n         setProperty(NETTY_MAX_FRAME_SIZE, String.valueOf(maxSize));\n         return this;\n     }\n+\n+    /**\n+     * Get the security provider factory class name. If this returns null, no security will be enforced on the channel.\n+     *\n+     * @return the security provider factory class name or null.\n+     */\n+    public String getTLSProviderFactoryClass() {\n+        return getString(TLS_PROVIDER_FACTORY_CLASS, null);\n+    }\n+\n+    /**\n+     * Set the client security provider factory class name. If this is not set, no security will be used on the channel.\n+     *\n+     * @param factoryClass\n+     *            the client security provider factory class name\n+     * @return client configuration\n+     */\n+    public AbstractConfiguration setTLSProviderFactoryClass(String factoryClass) {\n+        setProperty(TLS_PROVIDER_FACTORY_CLASS, factoryClass);\n+        return this;\n+    }\n+\n+    /**\n+     * Get TLS Provider (JDK or OpenSSL)\n+     * \n+     * @return the TLS provider to use in creating TLS Context\n+     */\n+    public String getTLSProvider() {\n+        return getString(TLS_PROVIDER, \"OpenSSL\");\n+    }\n+\n+    /**\n+     * Set TLS Provider (JDK or OpenSSL)\n+     * \n+     * @param provider\n+     *            TLS Provider type\n+     * @return Client Configuration\n+     */\n+    public AbstractConfiguration setTLSProvider(String provider) {\n+        setProperty(TLS_PROVIDER, provider);\n+        return this;\n+    }\n+\n+    /**\n+     * Whether the client will send an TLS certificate on TLS-handshake\n+     * \n+     * @see #setTLSAuthentication(boolean)\n+     * @return whether TLS is enabled on the bookie or not.\n+     */\n+    public boolean getTLSClientAuthentication() {\n+        return getBoolean(TLS_CLIENT_AUTHENTICATION, false);\n+    }\n+\n+    /**\n+     * Specify whether the client will send an TLS certificate on TLS-handshake\n+     * \n+     * @param enabled\n+     *            Whether to send a certificate or not\n+     * @return client configuration\n+     */\n+    public AbstractConfiguration setTLSClientAuthentication(boolean enabled) {\n+        setProperty(TLS_CLIENT_AUTHENTICATION, enabled);\n+        return this;\n+    }\n+\n+    /**\n+     * Set the list of enabled TLS cipher suites. Leave null not to override default JDK list. This list will be passed\n+     * to {@link SSLEngine#setEnabledCipherSuites(java.lang.String[]) }. Please refer to official JDK JavaDocs\n+     *\n+     * @param list\n+     *            comma separated list of enabled TLS cipher suites\n+     * @return current configuration\n+     */\n+    public AbstractConfiguration setTLSEnabledCipherSuites(\n+            String list) {\n+        setProperty(TLS_ENABLED_CIPHER_SUITES, list);\n+        return this;\n+    }\n+\n+    /**\n+     * Get the list of enabled TLS cipher suites\n+     *\n+     * @return this list of enabled TLS cipher suites\n+     *\n+     * @see #setTLSEnabledCipherSuites(java.lang.String)\n+     */\n+    public String getTLSEnabledCipherSuites() {\n+        return getString(TLS_ENABLED_CIPHER_SUITES, null);\n+    }\n+\n+    /**\n+     * Set the list of enabled TLS protocols. Leave null not to override default JDK list. This list will be passed to\n+     * {@link SSLEngine#setEnabledProtocols(java.lang.String[]) }. Please refer to official JDK JavaDocs\n+     *\n+     * @param list\n+     *            comma separated list of enabled TLS cipher suites\n+     * @return current configuration\n+     */\n+    public AbstractConfiguration setTLSEnabledProtocols(\n+            String list) {\n+        setProperty(TLS_ENABLED_PROTOCOLS, list);\n+        return this;\n+    }\n+\n+    /**\n+     * Get the list of enabled TLS protocols\n+     *\n+     * @return the list of enabled TLS protocols.\n+     *\n+     * @see #setTLSEnabledProtocols(java.lang.String)\n+     */\n+    public String getTLSEnabledProtocols() {\n+        return getString(TLS_ENABLED_PROTOCOLS, null);\n+    }\n }"},{"sha":"6e11f94f3943bc9e2e4163bd7ca2491d4fb5f348","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ClientConfiguration.java","status":"modified","additions":147,"deletions":0,"changes":147,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/8e0bd2c3d81b522e97434d8646915f36422a104b/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fconf%2FClientConfiguration.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/8e0bd2c3d81b522e97434d8646915f36422a104b/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fconf%2FClientConfiguration.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fconf%2FClientConfiguration.java?ref=8e0bd2c3d81b522e97434d8646915f36422a104b","patch":"@@ -35,6 +35,7 @@\n import org.apache.commons.configuration.ConfigurationException;\n import org.apache.commons.lang.StringUtils;\n \n+\n /**\n  * Configuration settings for client side\n  */\n@@ -103,6 +104,7 @@ public class ClientConfiguration extends AbstractConfiguration {\n     protected final static String GET_BOOKIE_INFO_RETRY_INTERVAL_SECONDS = \"getBookieInfoRetryIntervalSeconds\";\n     protected final static String BOOKIE_MAX_MULTIPLE_FOR_WEIGHTED_PLACEMENT = \"bookieMaxMultipleForWeightBasedPlacement\";\n     protected final static String GET_BOOKIE_INFO_TIMEOUT_SECS = \"getBookieInfoTimeoutSecs\";\n+    protected final static String START_TLS_TIMEOUT_SECS = \"startTLSTimeoutSecs\";\n \n     // Number Woker Threads\n     protected final static String NUM_WORKER_THREADS = \"numWorkerThreads\";\n@@ -135,6 +137,17 @@ public class ClientConfiguration extends AbstractConfiguration {\n      */\n     public final static String CLIENT_ROLE_SYSTEM = \"system\";\n \n+    // Client auth provider factory class name. It must be configured on Bookies to for the Auditor\n+    protected final static String CLIENT_AUTH_PROVIDER_FACTORY_CLASS = \"clientAuthProviderFactoryClass\";\n+\n+    // Client TLS\n+    protected final static String TLS_KEYSTORE_TYPE = \"clientKeyStoreType\";\n+    protected final static String TLS_KEYSTORE = \"clientKeyStore\";\n+    protected final static String TLS_KEYSTORE_PASSWORD_PATH = \"clientKeyStorePasswordPath\";\n+    protected final static String TLS_TRUSTSTORE_TYPE = \"clientTrustStoreType\";\n+    protected final static String TLS_TRUSTSTORE = \"clientTrustStore\";\n+    protected final static String TLS_TRUSTSTORE_PASSWORD_PATH = \"clientTrustStorePasswordPath\";\n+\n     /**\n      * Construct a default client-side configuration\n      */\n@@ -1274,6 +1287,14 @@ public int getBookieInfoTimeout() {\n         return getInteger(GET_BOOKIE_INFO_TIMEOUT_SECS, 5);\n     }\n \n+    /**\n+     * Return the timeout value for startTLS request\n+     * @return\n+     */\n+    public int getStartTLSTimeout() {\n+        return getInteger(START_TLS_TIMEOUT_SECS, 10);\n+    }\n+\n     /**\n      * Set whether or not disk weight based placement is enabled.\n      *\n@@ -1330,6 +1351,16 @@ public ClientConfiguration setGetBookieInfoTimeout(int timeoutSecs) {\n         return this;\n     }\n \n+    /**\n+     * Set the timeout value in secs for the START_TLS request\n+     * @param timeout\n+     * @return client configuration\n+     */\n+    public ClientConfiguration setStartTLSTimeout(int timeoutSecs) {\n+        setProperty(START_TLS_TIMEOUT_SECS, timeoutSecs);\n+        return this;\n+    }\n+\n     /**\n      * Set the client role\n      *\n@@ -1360,6 +1391,122 @@ public String getClientRole() {\n         return getString(CLIENT_ROLE, CLIENT_ROLE_STANDARD);\n     }\n \n+    /**\n+     * Get the keystore type for client. Default is JKS.\n+     * \n+     * @return\n+     */\n+    public String getTLSKeyStoreType() {\n+        return getString(TLS_KEYSTORE_TYPE, \"JKS\");\n+    }\n+\n+\n+    /**\n+     * Set the keystore type for client.\n+     * \n+     * @return\n+     */\n+    public ClientConfiguration setTLSKeyStoreType(String arg) {\n+        setProperty(TLS_KEYSTORE_TYPE, arg);\n+        return this;\n+    }\n+\n+    /**\n+     * Get the keystore path for the client.\n+     * \n+     * @return\n+     */\n+    public String getTLSKeyStore() {\n+        return getString(TLS_KEYSTORE, null);\n+    }\n+\n+    /**\n+     * Set the keystore path for the client.\n+     * \n+     * @return\n+     */\n+    public ClientConfiguration setTLSKeyStore(String arg) {\n+        setProperty(TLS_KEYSTORE, arg);\n+        return this;\n+    }\n+\n+    /**\n+     * Get the path to file containing keystore password, if the client keystore is password protected. Default is null.\n+     * \n+     * @return\n+     */\n+    public String getTLSKeyStorePasswordPath() {\n+        return getString(TLS_KEYSTORE_PASSWORD_PATH, null);\n+    }\n+\n+    /**\n+     * Set the path to file containing keystore password, if the client keystore is password protected.\n+     * \n+     * @return\n+     */\n+    public ClientConfiguration setTLSKeyStorePasswordPath(String arg) {\n+        setProperty(TLS_KEYSTORE_PASSWORD_PATH, arg);\n+        return this;\n+    }\n+\n+    /**\n+     * Get the truststore type for client. Default is JKS.\n+     * \n+     * @return\n+     */\n+    public String getTLSTrustStoreType() {\n+        return getString(TLS_TRUSTSTORE_TYPE, \"JKS\");\n+    }\n+\n+    /**\n+     * Set the truststore type for client.\n+     * \n+     * @return\n+     */\n+    public ClientConfiguration setTLSTrustStoreType(String arg) {\n+        setProperty(TLS_TRUSTSTORE_TYPE, arg);\n+        return this;\n+    }\n+\n+    /**\n+     * Get the truststore path for the client.\n+     * \n+     * @return\n+     */\n+    public String getTLSTrustStore() {\n+        return getString(TLS_TRUSTSTORE, null);\n+    }\n+\n+    /**\n+     * Set the truststore path for the client.\n+     * \n+     * @return\n+     */\n+    public ClientConfiguration setTLSTrustStore(String arg) {\n+        setProperty(TLS_TRUSTSTORE, arg);\n+        return this;\n+    }\n+\n+    /**\n+     * Get the path to file containing truststore password, if the client truststore is password protected. Default is\n+     * null.\n+     * \n+     * @return\n+     */\n+    public String getTLSTrustStorePasswordPath() {\n+        return getString(TLS_TRUSTSTORE_PASSWORD_PATH, null);\n+    }\n+\n+    /**\n+     * Set the path to file containing truststore password, if the client truststore is password protected.\n+     * \n+     * @return\n+     */\n+    public ClientConfiguration setTLSTrustStorePasswordPath(String arg) {\n+        setProperty(TLS_TRUSTSTORE_PASSWORD_PATH, arg);\n+        return this;\n+    }\n+\n     /**\n      * Whether to delay ensemble change or not?\n      *"},{"sha":"177c9660f9f1a41a642f007cb3f31ec205bf1057","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ServerConfiguration.java","status":"modified","additions":123,"deletions":0,"changes":123,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/8e0bd2c3d81b522e97434d8646915f36422a104b/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fconf%2FServerConfiguration.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/8e0bd2c3d81b522e97434d8646915f36422a104b/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fconf%2FServerConfiguration.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fconf%2FServerConfiguration.java?ref=8e0bd2c3d81b522e97434d8646915f36422a104b","patch":"@@ -154,6 +154,14 @@ public class ServerConfiguration extends AbstractConfiguration {\n \n     protected final static String ALLOW_MULTIPLEDIRS_UNDER_SAME_DISKPARTITION = \"allowMultipleDirsUnderSameDiskPartition\";\n \n+    protected final static String TLS_CLIENT_AUTHENTICATION = \"tlsClientAuthentication\";\n+    protected final static String TLS_KEYSTORE_TYPE = \"tlsKeyStoreType\";\n+    protected final static String TLS_KEYSTORE = \"tlsKeyStore\";\n+    protected final static String TLS_KEYSTORE_PASSWORD_PATH = \"tlsKeyStorePasswordPath\";\n+    protected final static String TLS_TRUSTSTORE_TYPE = \"tlsTrustStoreType\";\n+    protected final static String TLS_TRUSTSTORE = \"tlsTrustStore\";\n+    protected final static String TLS_TRUSTSTORE_PASSWORD_PATH = \"tlsTrustStorePasswordPath\";\n+\n     /**\n      * Construct a default configuration object\n      */\n@@ -2051,6 +2059,121 @@ public ServerConfiguration setNettyMaxFrameSizeBytes(int maxSize) {\n         return this;\n     }\n \n+    /**\n+     * Get the truststore type for client. Default is JKS.\n+     * \n+     * @return\n+     */\n+    public String getTLSTrustStoreType() {\n+        return getString(TLS_TRUSTSTORE_TYPE, \"JKS\");\n+    }\n+\n+    /**\n+     * Set the keystore type for client.\n+     * \n+     * @return\n+     */\n+    public ServerConfiguration setTLSKeyStoreType(String arg) {\n+        setProperty(TLS_KEYSTORE_TYPE, arg);\n+        return this;\n+    }\n+\n+    /**\n+     * Get the keystore path for the client.\n+     * \n+     * @return\n+     */\n+    public String getTLSKeyStore() {\n+        return getString(TLS_KEYSTORE, null);\n+    }\n+\n+    /**\n+     * Set the keystore path for the client.\n+     * \n+     * @return\n+     */\n+    public ServerConfiguration setTLSKeyStore(String arg) {\n+        setProperty(TLS_KEYSTORE, arg);\n+        return this;\n+    }\n+\n+    /**\n+     * Get the path to file containing keystore password if the client keystore is password protected. Default is null.\n+     * \n+     * @return\n+     */\n+    public String getTLSKeyStorePasswordPath() {\n+        return getString(TLS_KEYSTORE_PASSWORD_PATH, null);\n+    }\n+\n+    /**\n+     * Set the path to file containing keystore password, if the client keystore is password protected.\n+     * \n+     * @return\n+     */\n+    public ServerConfiguration setTLSKeyStorePasswordPath(String arg) {\n+        setProperty(TLS_KEYSTORE_PASSWORD_PATH, arg);\n+        return this;\n+    }\n+\n+    /**\n+     * Get the keystore type for client. Default is JKS.\n+     * \n+     * @return\n+     */\n+    public String getTLSKeyStoreType() {\n+        return getString(TLS_KEYSTORE_TYPE, \"JKS\");\n+    }\n+\n+    /**\n+     * Set the truststore type for client.\n+     * \n+     * @return\n+     */\n+    public ServerConfiguration setTLSTrustStoreType(String arg) {\n+        setProperty(TLS_TRUSTSTORE_TYPE, arg);\n+        return this;\n+    }\n+\n+    /**\n+     * Get the truststore path for the client.\n+     * \n+     * @return\n+     */\n+    public String getTLSTrustStore() {\n+        return getString(TLS_TRUSTSTORE, null);\n+    }\n+\n+    /**\n+     * Set the truststore path for the client.\n+     * \n+     * @return\n+     */\n+    public ServerConfiguration setTLSTrustStore(String arg) {\n+        setProperty(TLS_TRUSTSTORE, arg);\n+        return this;\n+    }\n+\n+    /**\n+     * Get the path to file containing truststore password if the client truststore is password protected. Default is\n+     * null.\n+     * \n+     * @return\n+     */\n+    public String getTLSTrustStorePasswordPath() {\n+        return getString(TLS_TRUSTSTORE_PASSWORD_PATH, null);\n+    }\n+\n+    /**\n+     * Set the path to file containing truststore password, if the client truststore is password protected.\n+     * \n+     * @return\n+     */\n+    public ServerConfiguration setTLSTrustStorePasswordPath(String arg) {\n+        setProperty(TLS_TRUSTSTORE_PASSWORD_PATH, arg);\n+        return this;\n+    }\n+\n     /**\n      * Gets the minimum safe Usable size to be available in index directory for Bookie to create Index File while replaying \n      * journal at the time of Bookie Start in Readonly Mode (in bytes)"},{"sha":"409fe4b4a6b5aebe8e218d083368b097dd2a302e","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/AuthHandler.java","status":"modified","additions":72,"deletions":70,"changes":142,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/8e0bd2c3d81b522e97434d8646915f36422a104b/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FAuthHandler.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/8e0bd2c3d81b522e97434d8646915f36422a104b/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FAuthHandler.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FAuthHandler.java?ref=8e0bd2c3d81b522e97434d8646915f36422a104b","patch":"@@ -124,7 +124,10 @@ && checkAuthPlugin(req.getAuthRequest(), ctx.channel())) {\n                         .getPayload()\n                         .toByteArray();\n                     authProvider.process(AuthToken.wrap(payload),\n-                                         new AuthResponseCallback(req, ctx.channel(), authProviderFactory.getPluginName()));\n+                            new AuthResponseCallback(req, ctx.channel(), authProviderFactory.getPluginName()));\n+                } else if (req.getHeader().getOperation() == BookkeeperProtocol.OperationType.START_TLS\n+                        && req.hasStartTLSRequest()) {\n+                    super.channelRead(ctx, msg);\n                 } else {\n                     BookkeeperProtocol.Response.Builder builder\n                         = BookkeeperProtocol.Response.newBuilder()\n@@ -140,11 +143,9 @@ && checkAuthPlugin(req.getAuthRequest(), ctx.channel())) {\n         }\n \n         private boolean checkAuthPlugin(AuthMessage am, final Channel src) {\n-            if (!am.hasAuthPluginName()\n-                || !am.getAuthPluginName().equals(authProviderFactory.getPluginName())) {\n-                LOG.error(\"Received message from incompatible auth plugin. Local = {},\"\n-                          + \" Remote = {}, Channel = {}\",\n-                          authProviderFactory.getPluginName(), am.getAuthPluginName());\n+            if (!am.hasAuthPluginName() || !am.getAuthPluginName().equals(authProviderFactory.getPluginName())) {\n+                LOG.error(\"Received message from incompatible auth plugin. Local = {},\" + \" Remote = {}, Channel = {}\",\n+                        authProviderFactory.getPluginName(), am.getAuthPluginName());\n                 return false;\n             }\n             return true;\n@@ -165,14 +166,9 @@ public void operationComplete(int rc, AuthToken newam) {\n                     channel.close();\n                     return;\n                 }\n-                AuthMessage message =\n-                    AuthMessage\n-                        .newBuilder()\n-                        .setAuthPluginName(req.authMessage.getAuthPluginName())\n-                        .setPayload(ByteString.copyFrom(newam.getData()))\n-                        .build();\n-                channel.writeAndFlush(new BookieProtocol.AuthResponse(req.getProtocolVersion(),\n-                                                              message));\n+                AuthMessage message = AuthMessage.newBuilder().setAuthPluginName(req.authMessage.getAuthPluginName())\n+                        .setPayload(ByteString.copyFrom(newam.getData())).build();\n+                channel.writeAndFlush(new BookieProtocol.AuthResponse(req.getProtocolVersion(), message));\n             }\n         }\n \n@@ -188,9 +184,8 @@ static class AuthResponseCallback implements AuthCallbacks.GenericCallback<AuthT\n             }\n \n             public void operationComplete(int rc, AuthToken newam) {\n-                BookkeeperProtocol.Response.Builder builder\n-                    = BookkeeperProtocol.Response.newBuilder()\n-                    .setHeader(req.getHeader());\n+                BookkeeperProtocol.Response.Builder builder = BookkeeperProtocol.Response.newBuilder()\n+                        .setHeader(req.getHeader());\n \n                 if (rc != BKException.Code.OK) {\n                     LOG.error(\"Error processing auth message, closing connection\");\n@@ -200,14 +195,9 @@ public void operationComplete(int rc, AuthToken newam) {\n                     channel.close();\n                     return;\n                 } else {\n-                    AuthMessage message =\n-                        AuthMessage\n-                            .newBuilder()\n-                            .setAuthPluginName(pluginName)\n-                            .setPayload(ByteString.copyFrom(newam.getData()))\n-                            .build();\n-                    builder.setStatus(BookkeeperProtocol.StatusCode.EOK)\n-                        .setAuthResponse(message);\n+                    AuthMessage message = AuthMessage.newBuilder().setAuthPluginName(pluginName)\n+                            .setPayload(ByteString.copyFrom(newam.getData())).build();\n+                    builder.setStatus(BookkeeperProtocol.StatusCode.EOK).setAuthResponse(message);\n                     channel.writeAndFlush(builder.build());\n                 }\n             }\n@@ -236,9 +226,12 @@ static class ClientSideHandler extends ChannelDuplexHandler {\n         final Queue<Object> waitingForAuth = new ConcurrentLinkedQueue<>();\n         final ClientConnectionPeer connectionPeer;\n \n-        ClientSideHandler(ClientAuthProvider.Factory authProviderFactory,\n-                          AtomicLong transactionIdGenerator,\n-                          ClientConnectionPeer connectionPeer) {\n+        public ClientAuthProvider getAuthProvider() {\n+            return authProvider;\n+        }\n+\n+        ClientSideHandler(ClientAuthProvider.Factory authProviderFactory, AtomicLong transactionIdGenerator,\n+                ClientConnectionPeer connectionPeer) {\n             this.authProviderFactory = authProviderFactory;\n             this.transactionIdGenerator = transactionIdGenerator;\n             this.connectionPeer = connectionPeer;\n@@ -247,8 +240,7 @@ static class ClientSideHandler extends ChannelDuplexHandler {\n \n         @Override\n         public void channelActive(ChannelHandlerContext ctx) throws Exception {\n-            authProvider = authProviderFactory.newProvider(connectionPeer,\n-                        new AuthHandshakeCompleteCallback(ctx));\n+            authProvider = authProviderFactory.newProvider(connectionPeer, new AuthHandshakeCompleteCallback(ctx));\n             authProvider.init(new AuthRequestCallback(ctx, authProviderFactory.getPluginName()));\n \n             super.channelActive(ctx);\n@@ -270,28 +262,40 @@ public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception\n                 super.channelRead(ctx, msg);\n             } else if (msg instanceof BookkeeperProtocol.Response) {\n                 BookkeeperProtocol.Response resp = (BookkeeperProtocol.Response) msg;\n-                if (resp.getHeader().getOperation() == BookkeeperProtocol.OperationType.AUTH) {\n-                    if (resp.getStatus() != BookkeeperProtocol.StatusCode.EOK) {\n-                        authenticationError(ctx, resp.getStatus().getNumber());\n-                    } else {\n-                        assert (resp.hasAuthResponse());\n-                        BookkeeperProtocol.AuthMessage am = resp.getAuthResponse();\n-                        if (AuthProviderFactoryFactory.AUTHENTICATION_DISABLED_PLUGIN_NAME.equals(am.getAuthPluginName())){\n-                            SocketAddress remote  = ctx.channel().remoteAddress();\n-                            LOG.info(\"Authentication is not enabled.\"\n-                                + \"Considering this client {0} authenticated\", remote);\n-                            AuthHandshakeCompleteCallback authHandshakeCompleteCallback\n-                                = new AuthHandshakeCompleteCallback(ctx);\n-                            authHandshakeCompleteCallback.operationComplete(BKException.Code.OK, null);\n-                            return;\n+                if (null == resp.getHeader().getOperation()) {\n+                    LOG.info(\"dropping received malformed message {} from bookie {}\", msg, ctx.channel());\n+                    // drop the message without header\n+                } else {\n+                    switch (resp.getHeader().getOperation()) {\n+                    case START_TLS:\n+                        super.channelRead(ctx, msg);\n+                        break;\n+                    case AUTH:\n+                        if (resp.getStatus() != BookkeeperProtocol.StatusCode.EOK) {\n+                            authenticationError(ctx, resp.getStatus().getNumber());\n+                        } else {\n+                            assert (resp.hasAuthResponse());\n+                            BookkeeperProtocol.AuthMessage am = resp.getAuthResponse();\n+                            if (AuthProviderFactoryFactory.AUTHENTICATION_DISABLED_PLUGIN_NAME.equals(am.getAuthPluginName())){\n+                                SocketAddress remote = ctx.channel().remoteAddress();\n+                                LOG.info(\"Authentication is not enabled.\"\n+                                    + \"Considering this client {0} authenticated\", remote);\n+                                AuthHandshakeCompleteCallback authHandshakeCompleteCallback\n+                                    = new AuthHandshakeCompleteCallback(ctx);\n+                                authHandshakeCompleteCallback.operationComplete(BKException.Code.OK, null);\n+                                return;\n+                            }\n+                            byte[] payload = am.getPayload().toByteArray();\n+                            authProvider.process(AuthToken.wrap(payload), new AuthRequestCallback(ctx,\n+                                authProviderFactory.getPluginName()));\n                         }\n-                        byte[] payload = am.getPayload().toByteArray();\n-                        authProvider.process(AuthToken.wrap(payload), new AuthRequestCallback(ctx,\n-                            authProviderFactory.getPluginName()));\n+                        break;\n+                    default:\n+                        LOG.warn(\"dropping received message {} from bookie {}\", msg, ctx.channel());\n+                        // else just drop the message,\n+                        // we're not authenticated so nothing should be coming through\n+                        break;\n                     }\n-                } else {\n-                    // else just drop the message,\n-                    // we're not authenticated so nothing should be coming through\n                 }\n             }\n         }\n@@ -301,12 +305,15 @@ public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)\n             synchronized (this) {\n                 if (authenticated) {\n                     super.write(ctx, msg, promise);\n+                    super.flush(ctx);\n                 } else if (msg instanceof BookkeeperProtocol.Request) {\n                     // let auth messages through, queue the rest\n                     BookkeeperProtocol.Request req = (BookkeeperProtocol.Request) msg;\n                     if (req.getHeader().getOperation()\n-                            == BookkeeperProtocol.OperationType.AUTH) {\n+                            == BookkeeperProtocol.OperationType.AUTH\n+                        || req.getHeader().getOperation() == BookkeeperProtocol.OperationType.START_TLS) {\n                         super.write(ctx, msg, promise);\n+                        super.flush(ctx);\n                     } else {\n                         waitingForAuth.add(msg);\n                     }\n@@ -315,10 +322,13 @@ public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)\n                     BookieProtocol.Request req = (BookieProtocol.Request)msg;\n                     if (BookkeeperProtocol.OperationType.AUTH.getNumber() == req.getOpCode()) {\n                         super.write(ctx, msg, promise);\n+                        super.flush(ctx);\n                     } else {\n                         waitingForAuth.add(msg);\n                     }\n-                } // else just drop\n+                } else {\n+                    LOG.info(\"dropping write of message {}\", msg);\n+                }\n             }\n         }\n \n@@ -347,28 +357,22 @@ public void operationComplete(int rc, AuthToken newam) {\n                     authenticationError(ctx, rc);\n                     return;\n                 }\n-                AuthMessage message = AuthMessage\n-                    .newBuilder()\n-                    .setAuthPluginName(pluginName)\n-                    .setPayload(ByteString.copyFrom(newam.getData()))\n-                    .build();\n-\n-                BookkeeperProtocol.BKPacketHeader header\n-                    = BookkeeperProtocol.BKPacketHeader.newBuilder()\n-                    .setVersion(BookkeeperProtocol.ProtocolVersion.VERSION_THREE)\n-                    .setOperation(BookkeeperProtocol.OperationType.AUTH)\n-                    .setTxnId(newTxnId()).build();\n-                BookkeeperProtocol.Request.Builder builder\n-                    = BookkeeperProtocol.Request.newBuilder()\n-                    .setHeader(header)\n-                    .setAuthRequest(message);\n+                AuthMessage message = AuthMessage.newBuilder().setAuthPluginName(pluginName)\n+                        .setPayload(ByteString.copyFrom(newam.getData())).build();\n+\n+                BookkeeperProtocol.BKPacketHeader header = BookkeeperProtocol.BKPacketHeader.newBuilder()\n+                        .setVersion(BookkeeperProtocol.ProtocolVersion.VERSION_THREE)\n+                        .setOperation(BookkeeperProtocol.OperationType.AUTH).setTxnId(newTxnId()).build();\n+                BookkeeperProtocol.Request.Builder builder = BookkeeperProtocol.Request.newBuilder().setHeader(header)\n+                        .setAuthRequest(message);\n \n                 channel.writeAndFlush(builder.build());\n             }\n         }\n \n         class AuthHandshakeCompleteCallback implements AuthCallbacks.GenericCallback<Void> {\n             ChannelHandlerContext ctx;\n+\n             AuthHandshakeCompleteCallback(ChannelHandlerContext ctx) {\n                 this.ctx = ctx;\n             }\n@@ -385,10 +389,8 @@ public void operationComplete(int rc, Void v) {\n                         }\n                     }\n                 } else {\n+                    LOG.warn(\"Client authentication failed\");\n                     authenticationError(ctx, rc);\n-                    if (LOG.isDebugEnabled()) {\n-                        LOG.debug(\"Authentication failed on server side\");\n-                    }\n                 }\n             }\n         }"},{"sha":"d763f576832e3a9d01d53223ecd56333b15388c6","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieClient.java","status":"modified","additions":10,"deletions":4,"changes":14,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/8e0bd2c3d81b522e97434d8646915f36422a104b/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookieClient.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/8e0bd2c3d81b522e97434d8646915f36422a104b/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookieClient.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookieClient.java?ref=8e0bd2c3d81b522e97434d8646915f36422a104b","patch":"@@ -41,9 +41,11 @@\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ReadEntryCallback;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ReadLacCallback;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteLacCallback;\n-import org.apache.bookkeeper.stats.NullStatsLogger;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteCallback;\n+import org.apache.bookkeeper.stats.NullStatsLogger;\n import org.apache.bookkeeper.stats.StatsLogger;\n+import org.apache.bookkeeper.tls.SecurityException;\n+import org.apache.bookkeeper.tls.SecurityHandlerFactory;\n import org.apache.bookkeeper.util.OrderedSafeExecutor;\n import org.apache.bookkeeper.util.SafeRunnable;\n import org.slf4j.Logger;\n@@ -139,9 +141,10 @@ public List<BookieSocketAddress> getFaultyBookies() {\n     }\n \n     @Override\n-    public PerChannelBookieClient create(BookieSocketAddress address, PerChannelBookieClientPool pcbcPool) {\n+    public PerChannelBookieClient create(BookieSocketAddress address, PerChannelBookieClientPool pcbcPool,\n+            SecurityHandlerFactory shFactory) throws SecurityException {\n         return new PerChannelBookieClient(conf, executor, eventLoopGroup, address, requestTimer, statsLogger,\n-                authProviderFactory, registry, pcbcPool);\n+                authProviderFactory, registry, pcbcPool, shFactory);\n     }\n \n     private PerChannelBookieClientPool lookupClient(BookieSocketAddress addr, Object key) {\n@@ -153,7 +156,7 @@ private PerChannelBookieClientPool lookupClient(BookieSocketAddress addr, Object\n                     return null;\n                 }\n                 PerChannelBookieClientPool newClientPool =\n-                    new DefaultPerChannelBookieClientPool(this, addr, numConnectionsPerBookie);\n+                    new DefaultPerChannelBookieClientPool(conf, this, addr, numConnectionsPerBookie);\n                 PerChannelBookieClientPool oldClientPool = channels.putIfAbsent(addr, newClientPool);\n                 if (null == oldClientPool) {\n                     clientPool = newClientPool;\n@@ -163,6 +166,9 @@ private PerChannelBookieClientPool lookupClient(BookieSocketAddress addr, Object\n                     clientPool = oldClientPool;\n                     newClientPool.close(false);\n                 }\n+            } catch (SecurityException e) {\n+                LOG.error(\"Security Exception in creating new default PCBC pool: \", e);\n+                return null;\n             } finally {\n                 closeLock.readLock().unlock();\n             }"},{"sha":"17fbbcb484d1b566ea8c8aab27b39c77a109b225","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieNettyServer.java","status":"modified","additions":96,"deletions":62,"changes":158,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/8e0bd2c3d81b522e97434d8646915f36422a104b/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookieNettyServer.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/8e0bd2c3d81b522e97434d8646915f36422a104b/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookieNettyServer.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookieNettyServer.java?ref=8e0bd2c3d81b522e97434d8646915f36422a104b","patch":"@@ -62,11 +62,17 @@\n import io.netty.channel.socket.nio.NioServerSocketChannel;\n import io.netty.handler.codec.LengthFieldBasedFrameDecoder;\n import io.netty.handler.codec.LengthFieldPrepender;\n+import io.netty.handler.ssl.SslHandler;\n \n import com.google.common.annotations.VisibleForTesting;\n import java.net.SocketAddress;\n import java.util.Collection;\n import java.util.Collections;\n+import java.security.cert.Certificate;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import javax.net.ssl.SSLPeerUnverifiedException;\n import org.apache.bookkeeper.auth.BookKeeperPrincipal;\n import com.google.common.util.concurrent.ThreadFactoryBuilder;\n import org.apache.bookkeeper.net.BookieSocketAddress;\n@@ -89,6 +95,7 @@ class BookieNettyServer {\n     volatile boolean suspended = false;\n     ChannelGroup allChannels;\n     final BookieSocketAddress bookieAddress;\n+    final InetSocketAddress bindAddress;\n \n     final BookieAuthProvider.Factory authProviderFactory;\n     final ExtensionRegistry registry = ExtensionRegistry.newInstance();\n@@ -130,13 +137,11 @@ class BookieNettyServer {\n         }\n \n         bookieAddress = Bookie.getBookieAddress(conf);\n-        InetSocketAddress bindAddress;\n         if (conf.getListeningInterface() == null) {\n             bindAddress = new InetSocketAddress(conf.getBookiePort());\n         } else {\n             bindAddress = bookieAddress.getSocketAddress();\n         }\n-        listenOn(bindAddress, bookieAddress);\n     }\n \n     public BookieNettyServer setRequestProcessor(RequestProcessor processor) {\n@@ -179,8 +184,92 @@ void resumeProcessing() {\n         }\n     }\n \n-    private void listenOn(InetSocketAddress address, BookieSocketAddress bookieAddress)\n-            throws InterruptedException {\n+    class BookieSideConnectionPeerContextHandler extends ChannelInboundHandlerAdapter {\n+\n+        final BookieConnectionPeer connectionPeer;\n+        volatile Channel channel;\n+        volatile BookKeeperPrincipal authorizedId = BookKeeperPrincipal.ANONYMOUS;\n+\n+        public BookieSideConnectionPeerContextHandler() {\n+            this.connectionPeer = new BookieConnectionPeer() {\n+                @Override\n+                public SocketAddress getRemoteAddr() {\n+                    Channel c = channel;\n+                    if (c != null) {\n+                        return c.remoteAddress();\n+                    } else {\n+                        return null;\n+                    }\n+                }\n+\n+                @Override\n+                public Collection<Object> getProtocolPrincipals() {\n+                    Channel c = channel;\n+                    if (c == null) {\n+                        return Collections.emptyList();\n+                    } else {\n+                        SslHandler ssl = c.pipeline().get(SslHandler.class);\n+                        if (ssl == null) {\n+                            return Collections.emptyList();\n+                        }\n+                        try {\n+                            Certificate[] certificates = ssl.engine().getSession().getPeerCertificates();\n+                            if (certificates == null) {\n+                                return Collections.emptyList();\n+                            }\n+                            List<Object> result = new ArrayList<>();\n+                            result.addAll(Arrays.asList(certificates));\n+                            return result;\n+                        } catch (SSLPeerUnverifiedException err) {\n+                            return Collections.emptyList();\n+                        }\n+\n+                    }\n+                }\n+\n+                @Override\n+                public void disconnect() {\n+                    Channel c = channel;\n+                    if (c != null) {\n+                        c.close();\n+                    }\n+                    LOG.info(\"authplugin disconnected channel {}\", channel);\n+                }\n+\n+                @Override\n+                public BookKeeperPrincipal getAuthorizedId() {\n+                    return authorizedId;\n+                }\n+\n+                @Override\n+                public void setAuthorizedId(BookKeeperPrincipal principal) {\n+                    LOG.info(\"connection {} authenticated as {}\", channel, principal);\n+                    authorizedId = principal;\n+                }\n+\n+                @Override\n+                public boolean isSecure() {\n+                    Channel c = channel;\n+                    if (c == null) {\n+                        return false;\n+                    } else {\n+                        return c.pipeline().get(\"tls\") != null;\n+                    }\n+                }\n+            };\n+        }\n+\n+        public BookieConnectionPeer getConnectionPeer() {\n+            return connectionPeer;\n+        }\n+\n+        @Override\n+        public void channelActive(ChannelHandlerContext ctx) throws Exception {\n+            channel = ctx.channel();\n+        }\n+    }\n+\n+    private void listenOn(InetSocketAddress address, BookieSocketAddress bookieAddress) throws InterruptedException {\n         if (!conf.isDisableServerSocketBind()) {\n             ServerBootstrap bootstrap = new ServerBootstrap();\n             bootstrap.childOption(ChannelOption.ALLOCATOR, new PooledByteBufAllocator(true));\n@@ -220,6 +309,7 @@ protected void initChannel(SocketChannel ch) throws Exception {\n                             ? new BookieRequestHandler(conf, requestProcessor, allChannels) : new RejectRequestHandler();\n                     pipeline.addLast(\"bookieRequestHandler\", requestHandler);\n \n+                    pipeline.addLast(\"contextHandler\", contextHandler);\n                 }\n             });\n \n@@ -283,7 +373,8 @@ protected void initChannel(LocalChannel ch) throws Exception {\n         }\n     }\n \n-    void start() {\n+    void start() throws InterruptedException {\n+        listenOn(bindAddress, bookieAddress);\n         isRunning.set(true);\n     }\n \n@@ -313,63 +404,6 @@ void shutdown() {\n         authProviderFactory.close();\n     }\n \n-    class BookieSideConnectionPeerContextHandler extends ChannelInboundHandlerAdapter {\n-\n-        final BookieConnectionPeer connectionPeer;\n-        volatile Channel channel;\n-        volatile BookKeeperPrincipal authorizedId = BookKeeperPrincipal.ANONYMOUS;\n-\n-        public BookieSideConnectionPeerContextHandler() {\n-            this.connectionPeer = new BookieConnectionPeer() {\n-                @Override\n-                public SocketAddress getRemoteAddr() {\n-                    Channel c = channel;\n-                    if (c != null) {\n-                        return c.remoteAddress();\n-                    } else {\n-                        return null;\n-                    }\n-                }\n-\n-                @Override\n-                public Collection<Object> getProtocolPrincipals() {\n-                    return Collections.emptyList();\n-                }\n-\n-                @Override\n-                public void disconnect() {\n-                    Channel c = channel;\n-                    if (c != null) {\n-                        c.close();\n-                    }\n-                    LOG.info(\"authplugin disconnected channel {}\", channel);\n-                }\n-\n-                @Override\n-                public BookKeeperPrincipal getAuthorizedId() {\n-                    return authorizedId;\n-                }\n-\n-                @Override\n-                public void setAuthorizedId(BookKeeperPrincipal principal) {\n-                    LOG.info(\"connection {} authenticated as {}\", channel, principal);\n-                    authorizedId = principal;\n-                }\n-\n-            };\n-        }\n-\n-        public BookieConnectionPeer getConnectionPeer() {\n-            return connectionPeer;\n-        }\n-\n-        @Override\n-        public void channelActive(ChannelHandlerContext ctx) throws Exception {\n-            channel = ctx.channel();\n-        }\n-\n-    }\n-\n     private static class RejectRequestHandler extends ChannelInboundHandlerAdapter {\n         @Override\n         public void channelActive(ChannelHandlerContext ctx) throws Exception {"},{"sha":"1315dc9ed1c569b1efe047f2c53111ed8e93b0b2","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieRequestHandler.java","status":"modified","additions":2,"deletions":1,"changes":3,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/8e0bd2c3d81b522e97434d8646915f36422a104b/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookieRequestHandler.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/8e0bd2c3d81b522e97434d8646915f36422a104b/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookieRequestHandler.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookieRequestHandler.java?ref=8e0bd2c3d81b522e97434d8646915f36422a104b","patch":"@@ -48,7 +48,8 @@ class BookieRequestHandler extends ChannelInboundHandlerAdapter {\n \n     @Override\n     public void channelActive(ChannelHandlerContext ctx) throws Exception {\n-        LOG.info(\"Channel connected: {}\", ctx.channel());\n+        LOG.info(\"Channel connected  {}\", ctx.channel());\n+        super.channelActive(ctx);\n     }\n \n     @Override"},{"sha":"8d719e6d0dd7070b43faa09c466774e13454ec4c","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieRequestProcessor.java","status":"modified","additions":76,"deletions":14,"changes":90,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/8e0bd2c3d81b522e97434d8646915f36422a104b/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookieRequestProcessor.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/8e0bd2c3d81b522e97434d8646915f36422a104b/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookieRequestProcessor.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookieRequestProcessor.java?ref=8e0bd2c3d81b522e97434d8646915f36422a104b","patch":"@@ -23,6 +23,9 @@\n import com.google.common.util.concurrent.ThreadFactoryBuilder;\n import com.google.protobuf.ByteString;\n import io.netty.channel.Channel;\n+import io.netty.handler.ssl.SslHandler;\n+import io.netty.util.concurrent.Future;\n+import io.netty.util.concurrent.GenericFutureListener;\n import io.netty.util.HashedWheelTimer;\n import java.util.concurrent.ExecutorService;\n import java.util.concurrent.TimeUnit;\n@@ -34,6 +37,9 @@\n import org.apache.bookkeeper.stats.Counter;\n import org.apache.bookkeeper.stats.OpStatsLogger;\n import org.apache.bookkeeper.stats.StatsLogger;\n+import org.apache.bookkeeper.tls.SecurityException;\n+import org.apache.bookkeeper.tls.SecurityHandlerFactory;\n+import org.apache.bookkeeper.tls.SecurityHandlerFactory.NodeType;\n import org.apache.bookkeeper.util.OrderedSafeExecutor;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -56,6 +62,7 @@\n import static org.apache.bookkeeper.bookie.BookKeeperServerStats.READ_LAST_ENTRY_NOENTRY_ERROR;\n import static org.apache.bookkeeper.bookie.BookKeeperServerStats.WRITE_LAC;\n import static org.apache.bookkeeper.bookie.BookKeeperServerStats.READ_LAC;\n+import static org.apache.bookkeeper.bookie.BookKeeperServerStats.WRITE_LAC;\n import static org.apache.bookkeeper.bookie.BookKeeperServerStats.GET_BOOKIE_INFO;\n import static org.apache.bookkeeper.bookie.BookKeeperServerStats.WRITE_LAC_REQUEST;\n \n@@ -84,6 +91,11 @@ public class BookieRequestProcessor implements RequestProcessor {\n      */\n     private final OrderedSafeExecutor writeThreadPool;\n \n+    /**\n+     * TLS management\n+     */\n+    private final SecurityHandlerFactory shFactory;\n+\n     /**\n      * The threadpool used to execute all long poll requests issued to this server\n      * after they are done waiting\n@@ -120,7 +132,7 @@ public class BookieRequestProcessor implements RequestProcessor {\n     final OpStatsLogger channelWriteStats;\n \n     public BookieRequestProcessor(ServerConfiguration serverCfg, Bookie bookie,\n-                                  StatsLogger statsLogger) {\n+            StatsLogger statsLogger, SecurityHandlerFactory shFactory) throws SecurityException {\n         this.serverCfg = serverCfg;\n         this.bookie = bookie;\n         this.readThreadPool = createExecutor(this.serverCfg.getNumReadWorkerThreads(), \"BookieReadThread-\" + serverCfg.getBookiePort());\n@@ -133,6 +145,10 @@ public BookieRequestProcessor(ServerConfiguration serverCfg, Bookie bookie,\n             new ThreadFactoryBuilder().setNameFormat(\"BookieRequestTimer-%d\").build(),\n             this.serverCfg.getRequestTimerTickDurationMs(),\n             TimeUnit.MILLISECONDS, this.serverCfg.getRequestTimerNumTicks());\n+        this.shFactory = shFactory;\n+        if (shFactory != null) {\n+            shFactory.init(NodeType.Server, serverCfg);\n+        }\n \n         // Expose Stats\n         this.statsEnabled = serverCfg.isStatisticsEnabled();\n@@ -214,6 +230,9 @@ public void processRequest(Object msg, Channel c) {\n                 case GET_BOOKIE_INFO:\n                     processGetBookieInfoRequestV3(r,c);\n                     break;\n+                case START_TLS:\n+                    processStartTLSRequestV3(r, c);\n+                    break;\n                 default:\n                     LOG.info(\"Unknown operation type {}\", header.getOperation());\n                     BookkeeperProtocol.Response.Builder response =\n@@ -246,6 +265,24 @@ public void processRequest(Object msg, Channel c) {\n         }\n     }\n \n+     private void processWriteLacRequestV3(final BookkeeperProtocol.Request r, final Channel c) {\n+        WriteLacProcessorV3 writeLac = new WriteLacProcessorV3(r, c, this);\n+        if (null == writeThreadPool) {\n+            writeLac.run();\n+        } else {\n+            writeThreadPool.submitOrdered(r.getAddRequest().getLedgerId(), writeLac);\n+        }\n+    }\n+\n+    private void processReadLacRequestV3(final BookkeeperProtocol.Request r, final Channel c) {\n+        ReadLacProcessorV3 readLac = new ReadLacProcessorV3(r, c, this);\n+        if (null == readThreadPool) {\n+            readLac.run();\n+        } else {\n+            readThreadPool.submitOrdered(r.getAddRequest().getLedgerId(), readLac);\n+        }\n+    }\n+\n     private void processAddRequestV3(final BookkeeperProtocol.Request r, final Channel c) {\n         WriteEntryProcessorV3 write = new WriteEntryProcessorV3(r, c, this);\n         if (null == writeThreadPool) {\n@@ -284,21 +321,46 @@ private void processReadRequestV3(final BookkeeperProtocol.Request r, final Chan\n         }\n     }\n \n-    private void processWriteLacRequestV3(final BookkeeperProtocol.Request r, final Channel c) {\n-        WriteLacProcessorV3 writeLac = new WriteLacProcessorV3(r, c, this);\n-        if (null == writeThreadPool) {\n-            writeLac.run();\n+    private void processStartTLSRequestV3(final BookkeeperProtocol.Request r, final Channel c) {\n+        BookkeeperProtocol.Response.Builder response = BookkeeperProtocol.Response.newBuilder();\n+        BookkeeperProtocol.BKPacketHeader.Builder header = BookkeeperProtocol.BKPacketHeader.newBuilder();\n+        header.setVersion(BookkeeperProtocol.ProtocolVersion.VERSION_THREE);\n+        header.setOperation(r.getHeader().getOperation());\n+        header.setTxnId(r.getHeader().getTxnId());\n+        response.setHeader(header.build());\n+        if (shFactory == null) {\n+            LOG.error(\"Got StartTLS request but TLS not configured\");\n+            response.setStatus(BookkeeperProtocol.StatusCode.EBADREQ);\n+            c.writeAndFlush(response.build());\n         } else {\n-            writeThreadPool.submit(writeLac);\n-        }\n-    }\n+            // there is no need to execute in a different thread as this operation is light\n+            SslHandler sslHandler = shFactory.newTLSHandler();\n+            c.pipeline().addFirst(\"tls\", sslHandler);\n \n-    private void processReadLacRequestV3(final BookkeeperProtocol.Request r, final Channel c) {\n-        ReadLacProcessorV3 readLac = new ReadLacProcessorV3(r, c, this);\n-        if (null == readThreadPool) {\n-            readLac.run();\n-        } else {\n-            readThreadPool.submit(readLac);\n+            response.setStatus(BookkeeperProtocol.StatusCode.EOK);\n+            BookkeeperProtocol.StartTLSResponse.Builder builder = BookkeeperProtocol.StartTLSResponse.newBuilder();\n+            response.setStartTLSResponse(builder.build());\n+            sslHandler.handshakeFuture().addListener(new GenericFutureListener<Future<Channel>>() {\n+                @Override\n+                public void operationComplete(Future<Channel> future) throws Exception {\n+                    // notify the AuthPlugin the completion of the handshake, even in case of failure\n+                    AuthHandler.ServerSideHandler authHandler = c.pipeline()\n+                            .get(AuthHandler.ServerSideHandler.class);\n+                    authHandler.authProvider.onProtocolUpgrade();\n+                    if (future.isSuccess()) {\n+                        LOG.info(\"Session is protected by: {}\", sslHandler.engine().getSession().getCipherSuite());\n+                    } else {\n+                        LOG.error(\"TLS Handshake failure: {}\", future.cause());\n+                        BookkeeperProtocol.Response.Builder errResponse = BookkeeperProtocol.Response.newBuilder()\n+                                .setHeader(r.getHeader()).setStatus(BookkeeperProtocol.StatusCode.EIO);\n+                        c.writeAndFlush(errResponse.build());\n+                        if (statsEnabled) {\n+                            bkStats.getOpStats(BKStats.STATS_UNKNOWN).incrementFailedOps();\n+                        }\n+                    }\n+                }\n+            });\n+            c.writeAndFlush(response.build());\n         }\n     }\n "},{"sha":"bda022cd750267907b095a9e54e7022c74e356ea","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieServer.java","status":"modified","additions":12,"deletions":4,"changes":16,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/8e0bd2c3d81b522e97434d8646915f36422a104b/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookieServer.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/8e0bd2c3d81b522e97434d8646915f36422a104b/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookieServer.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookieServer.java?ref=8e0bd2c3d81b522e97434d8646915f36422a104b","patch":"@@ -41,6 +41,9 @@\n import org.apache.bookkeeper.stats.NullStatsLogger;\n import org.apache.bookkeeper.stats.StatsLogger;\n import org.apache.bookkeeper.stats.StatsProvider;\n+import org.apache.bookkeeper.tls.SecurityException;\n+import org.apache.bookkeeper.tls.SecurityHandlerFactory;\n+import org.apache.bookkeeper.tls.SecurityProviderFactoryFactory;\n import org.apache.bookkeeper.util.ReflectionUtils;\n import org.apache.commons.cli.BasicParser;\n import org.apache.commons.cli.CommandLine;\n@@ -83,13 +86,13 @@ public class BookieServer {\n \n     public BookieServer(ServerConfiguration conf) throws IOException,\n             KeeperException, InterruptedException, BookieException,\n-            UnavailableException, CompatibilityException {\n+            UnavailableException, CompatibilityException, SecurityException {\n         this(conf, NullStatsLogger.INSTANCE);\n     }\n \n     public BookieServer(ServerConfiguration conf, StatsLogger statsLogger)\n             throws IOException, KeeperException, InterruptedException,\n-            BookieException, UnavailableException, CompatibilityException {\n+            BookieException, UnavailableException, CompatibilityException, SecurityException {\n         this.conf = conf;\n         this.statsLogger = statsLogger;\n         this.nettyServer = new BookieNettyServer(this.conf, null);\n@@ -100,9 +103,14 @@ public BookieServer(ServerConfiguration conf, StatsLogger statsLogger)\n             this.nettyServer.shutdown();\n             throw e;\n         }\n+        final SecurityHandlerFactory shFactory;\n+\n+        shFactory = SecurityProviderFactoryFactory\n+                .getSecurityProviderFactory(conf.getTLSProviderFactoryClass());\n         this.requestProcessor = new BookieRequestProcessor(conf, bookie,\n-                statsLogger.scope(SERVER_SCOPE));\n+                statsLogger.scope(SERVER_SCOPE), shFactory);\n         this.nettyServer.setRequestProcessor(this.requestProcessor);\n+\n         isAutoRecoveryDaemonEnabled = conf.isAutoRecoveryDaemonEnabled();\n         if (isAutoRecoveryDaemonEnabled) {\n             this.autoRecoveryMain = new AutoRecoveryMain(conf, statsLogger.scope(REPLICATION_SCOPE));\n@@ -116,7 +124,7 @@ protected Bookie newBookie(ServerConfiguration conf)\n                 new Bookie(conf, statsLogger.scope(BOOKIE_SCOPE));\n     }\n \n-    public void start() throws IOException, UnavailableException {\n+    public void start() throws IOException, UnavailableException, InterruptedException {\n         this.bookie.start();\n         // fail fast, when bookie startup is not successful\n         if (!this.bookie.isRunning()) {"},{"sha":"ab160ce81948f4293e804488504ca163ad6d061f","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookkeeperInternalCallbacks.java","status":"modified","additions":4,"deletions":0,"changes":4,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/8e0bd2c3d81b522e97434d8646915f36422a104b/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookkeeperInternalCallbacks.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/8e0bd2c3d81b522e97434d8646915f36422a104b/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookkeeperInternalCallbacks.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookkeeperInternalCallbacks.java?ref=8e0bd2c3d81b522e97434d8646915f36422a104b","patch":"@@ -79,6 +79,10 @@ public interface WriteLacCallback {\n         void writeLacComplete(int rc, long ledgerId, BookieSocketAddress addr, Object ctx);\n     }\n \n+    public interface StartTLSCallback {\n+        void startTLSComplete(int rc, Object ctx);\n+    }\n+\n     public interface GenericCallback<T> {\n         void operationComplete(int rc, T result);\n     }"},{"sha":"4f054c0f7858a7a8504abba9d65c5f28fae063e8","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookkeeperProtocol.java","status":"modified","additions":4732,"deletions":3694,"changes":8426,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/8e0bd2c3d81b522e97434d8646915f36422a104b/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookkeeperProtocol.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/8e0bd2c3d81b522e97434d8646915f36422a104b/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookkeeperProtocol.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookkeeperProtocol.java?ref=8e0bd2c3d81b522e97434d8646915f36422a104b"},{"sha":"b5a1837732eaae8d0d8ba40bd7153903e1a3eb81","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/ConnectionPeer.java","status":"modified","additions":6,"deletions":0,"changes":6,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/8e0bd2c3d81b522e97434d8646915f36422a104b/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FConnectionPeer.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/8e0bd2c3d81b522e97434d8646915f36422a104b/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FConnectionPeer.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FConnectionPeer.java?ref=8e0bd2c3d81b522e97434d8646915f36422a104b","patch":"@@ -60,4 +60,10 @@ public interface ConnectionPeer {\n      * @see #getAuthorizedId()\n      */\n     public void setAuthorizedId(BookKeeperPrincipal principal);\n+\n+    /**\n+     * This flag returns true if a 'secure' channel in use, like TLS\n+     * @return true if the channel is 'secure'\n+     */\n+    public boolean isSecure();\n }"},{"sha":"ba1b444e58386c897ba0224f8d737998768e7d95","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/DefaultPerChannelBookieClientPool.java","status":"modified","additions":18,"deletions":4,"changes":22,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/8e0bd2c3d81b522e97434d8646915f36422a104b/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FDefaultPerChannelBookieClientPool.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/8e0bd2c3d81b522e97434d8646915f36422a104b/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FDefaultPerChannelBookieClientPool.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FDefaultPerChannelBookieClientPool.java?ref=8e0bd2c3d81b522e97434d8646915f36422a104b","patch":"@@ -22,8 +22,12 @@\n \n import java.util.concurrent.atomic.AtomicLong;\n \n+import org.apache.bookkeeper.conf.ClientConfiguration;\n import org.apache.bookkeeper.net.BookieSocketAddress;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n+import org.apache.bookkeeper.tls.SecurityException;\n+import org.apache.bookkeeper.tls.SecurityHandlerFactory;\n+import org.apache.bookkeeper.tls.SecurityProviderFactoryFactory;\n import org.apache.bookkeeper.util.MathUtils;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -39,23 +43,33 @@\n class DefaultPerChannelBookieClientPool implements PerChannelBookieClientPool,\n         GenericCallback<PerChannelBookieClient> {\n \n-    static final Logger logger = LoggerFactory.getLogger(DefaultPerChannelBookieClientPool.class);\n+    static final Logger LOG = LoggerFactory.getLogger(DefaultPerChannelBookieClientPool.class);\n \n     final PerChannelBookieClientFactory factory;\n     final BookieSocketAddress address;\n+\n     final PerChannelBookieClient[] clients;\n+\n+    final ClientConfiguration conf;\n+    SecurityHandlerFactory shFactory;\n+\n     final AtomicInteger counter = new AtomicInteger(0);\n     final AtomicLong errorCounter = new AtomicLong(0);\n \n-    DefaultPerChannelBookieClientPool(PerChannelBookieClientFactory factory,\n+    DefaultPerChannelBookieClientPool(ClientConfiguration conf, PerChannelBookieClientFactory factory,\n                                       BookieSocketAddress address,\n-                                      int coreSize) {\n+                                      int coreSize) throws SecurityException {\n         Preconditions.checkArgument(coreSize > 0);\n         this.factory = factory;\n         this.address = address;\n+        this.conf = conf;\n+\n+        this.shFactory = SecurityProviderFactoryFactory\n+                .getSecurityProviderFactory(conf.getTLSProviderFactoryClass());\n+\n         this.clients = new PerChannelBookieClient[coreSize];\n         for (int i = 0; i < coreSize; i++) {\n-            this.clients[i] = factory.create(address, this);\n+            this.clients[i] = factory.create(address, this, shFactory);\n         }\n     }\n "},{"sha":"20f601ce98b0c11c368a13e5fcbc9ba8f63a267c","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java","status":"modified","additions":335,"deletions":66,"changes":401,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/8e0bd2c3d81b522e97434d8646915f36422a104b/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FPerChannelBookieClient.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/8e0bd2c3d81b522e97434d8646915f36422a104b/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FPerChannelBookieClient.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FPerChannelBookieClient.java?ref=8e0bd2c3d81b522e97434d8646915f36422a104b","patch":"@@ -48,9 +48,13 @@\n import io.netty.handler.codec.LengthFieldBasedFrameDecoder;\n import io.netty.handler.codec.LengthFieldPrepender;\n import io.netty.handler.codec.TooLongFrameException;\n+import io.netty.handler.ssl.SslHandler;\n import io.netty.util.HashedWheelTimer;\n import io.netty.util.Timeout;\n import io.netty.util.TimerTask;\n+import io.netty.util.concurrent.Future;\n+import io.netty.util.concurrent.GenericFutureListener;\n+\n import java.io.IOException;\n import java.net.SocketAddress;\n import java.nio.channels.ClosedChannelException;\n@@ -78,6 +82,7 @@\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteCallback;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteLacCallback;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ReadLacCallback;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.StartTLSCallback;\n import org.apache.bookkeeper.proto.BookkeeperProtocol.AddRequest;\n import org.apache.bookkeeper.proto.BookkeeperProtocol.AddResponse;\n import org.apache.bookkeeper.proto.BookkeeperProtocol.BKPacketHeader;\n@@ -97,12 +102,29 @@\n import org.apache.bookkeeper.stats.NullStatsLogger;\n import org.apache.bookkeeper.stats.OpStatsLogger;\n import org.apache.bookkeeper.stats.StatsLogger;\n+import org.apache.bookkeeper.tls.SecurityException;\n+import org.apache.bookkeeper.tls.SecurityHandlerFactory;\n+import org.apache.bookkeeper.tls.SecurityHandlerFactory.NodeType;\n import org.apache.bookkeeper.util.MathUtils;\n import org.apache.bookkeeper.util.OrderedSafeExecutor;\n import org.apache.bookkeeper.util.SafeRunnable;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import com.google.common.collect.Sets;\n+import com.google.protobuf.ExtensionRegistry;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.buffer.UnpooledByteBufAllocator;\n+import java.net.SocketAddress;\n+\n+import java.net.SocketAddress;\n+import java.security.cert.Certificate;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import javax.net.ssl.SSLPeerUnverifiedException;\n+import org.apache.bookkeeper.auth.BookKeeperPrincipal;\n+\n /**\n  * This class manages all details of connection to a particular bookie. It also\n  * has reconnect logic if a connection to a bookie fails.\n@@ -132,6 +154,7 @@ public class PerChannelBookieClient extends ChannelInboundHandlerAdapter {\n     final int readEntryTimeout;\n     final int maxFrameSize;\n     final int getBookieInfoTimeout;\n+    final int startTLSTimeout;\n \n     private final ConcurrentHashMap<CompletionKey, CompletionValue> completionObjects = new ConcurrentHashMap<CompletionKey, CompletionValue>();\n \n@@ -146,6 +169,7 @@ public class PerChannelBookieClient extends ChannelInboundHandlerAdapter {\n     private final OpStatsLogger readLacTimeoutOpLogger;\n     private final OpStatsLogger getBookieInfoOpLogger;\n     private final OpStatsLogger getBookieInfoTimeoutOpLogger;\n+    private final OpStatsLogger startTLSOpLogger;\n \n     private final boolean useV2WireProtocol;\n \n@@ -160,7 +184,7 @@ public class PerChannelBookieClient extends ChannelInboundHandlerAdapter {\n     private volatile BookKeeperPrincipal authorizedId = BookKeeperPrincipal.ANONYMOUS;\n \n     enum ConnectionState {\n-        DISCONNECTED, CONNECTING, CONNECTED, CLOSED\n+        DISCONNECTED, CONNECTING, CONNECTED, CLOSED, START_TLS\n     }\n \n     volatile ConnectionState state;\n@@ -170,27 +194,39 @@ enum ConnectionState {\n     private final PerChannelBookieClientPool pcbcPool;\n     private final ClientAuthProvider.Factory authProviderFactory;\n     private final ExtensionRegistry extRegistry;\n+    private final SecurityHandlerFactory shFactory;\n \n     public PerChannelBookieClient(OrderedSafeExecutor executor, EventLoopGroup eventLoopGroup,\n-                                  BookieSocketAddress addr) {\n+                                  BookieSocketAddress addr) throws SecurityException {\n         this(new ClientConfiguration(), executor, eventLoopGroup, addr, null, NullStatsLogger.INSTANCE, null, null,\n                 null);\n     }\n \n     public PerChannelBookieClient(OrderedSafeExecutor executor, EventLoopGroup eventLoopGroup,\n                                   BookieSocketAddress addr,\n                                   ClientAuthProvider.Factory authProviderFactory,\n-                                  ExtensionRegistry extRegistry) {\n+                                  ExtensionRegistry extRegistry) throws SecurityException {\n         this(new ClientConfiguration(), executor, eventLoopGroup, addr, null, NullStatsLogger.INSTANCE,\n                 authProviderFactory, extRegistry, null);\n     }\n \n     public PerChannelBookieClient(ClientConfiguration conf, OrderedSafeExecutor executor,\n-            EventLoopGroup eventLoopGroup, BookieSocketAddress addr,\n+                                  EventLoopGroup eventLoopGroup, BookieSocketAddress addr,\n+                                  HashedWheelTimer requestTimer, StatsLogger parentStatsLogger,\n+                                  ClientAuthProvider.Factory authProviderFactory,\n+                                  ExtensionRegistry extRegistry,\n+                                  PerChannelBookieClientPool pcbcPool) throws SecurityException {\n+       this(conf, executor, eventLoopGroup, addr, null, NullStatsLogger.INSTANCE,\n+                authProviderFactory, extRegistry, pcbcPool, null);\n+    }\n+\n+    public PerChannelBookieClient(ClientConfiguration conf, OrderedSafeExecutor executor,\n+                                  EventLoopGroup eventLoopGroup, BookieSocketAddress addr,\n                                   HashedWheelTimer requestTimer, StatsLogger parentStatsLogger,\n                                   ClientAuthProvider.Factory authProviderFactory,\n                                   ExtensionRegistry extRegistry,\n-                                  PerChannelBookieClientPool pcbcPool) {\n+                                  PerChannelBookieClientPool pcbcPool,\n+                                  SecurityHandlerFactory shFactory) throws SecurityException {\n         this.maxFrameSize = conf.getNettyMaxFrameSizeBytes();\n         this.conf = conf;\n         this.addr = addr;\n@@ -205,10 +241,15 @@ public PerChannelBookieClient(ClientConfiguration conf, OrderedSafeExecutor exec\n         this.addEntryTimeout = conf.getAddEntryTimeout();\n         this.readEntryTimeout = conf.getReadEntryTimeout();\n         this.getBookieInfoTimeout = conf.getBookieInfoTimeout();\n+        this.startTLSTimeout = conf.getStartTLSTimeout();\n         this.useV2WireProtocol = conf.getUseV2WireProtocol();\n \n         this.authProviderFactory = authProviderFactory;\n         this.extRegistry = extRegistry;\n+        this.shFactory = shFactory;\n+        if (shFactory != null) {\n+            shFactory.init(NodeType.Client, conf);\n+        }\n \n         StringBuilder nameBuilder = new StringBuilder();\n         nameBuilder.append(addr.getHostName().replace('.', '_').replace('-', '_'))\n@@ -227,6 +268,7 @@ public PerChannelBookieClient(ClientConfiguration conf, OrderedSafeExecutor exec\n         writeLacTimeoutOpLogger = statsLogger.getOpStatsLogger(BookKeeperClientStats.CHANNEL_TIMEOUT_WRITE_LAC);\n         readLacTimeoutOpLogger = statsLogger.getOpStatsLogger(BookKeeperClientStats.CHANNEL_TIMEOUT_READ_LAC);\n         getBookieInfoTimeoutOpLogger = statsLogger.getOpStatsLogger(BookKeeperClientStats.TIMEOUT_GET_BOOKIE_INFO);\n+        startTLSOpLogger = statsLogger.getOpStatsLogger(BookKeeperClientStats.CHANNEL_START_TLS_OP);\n \n         this.pcbcPool = pcbcPool;\n \n@@ -244,7 +286,25 @@ public SocketAddress getRemoteAddr() {\n \n             @Override\n             public Collection<Object> getProtocolPrincipals() {\n-                return Collections.emptyList();\n+                Channel c = channel;\n+                if (c == null) {\n+                    return Collections.emptyList();\n+                }\n+                SslHandler ssl = c.pipeline().get(SslHandler.class);\n+                if (ssl == null) {\n+                    return Collections.emptyList();\n+                }\n+                try {\n+                    Certificate[] certificates = ssl.engine().getSession().getPeerCertificates();\n+                    if (certificates == null) {\n+                        return Collections.emptyList();\n+                    }\n+                    List<Object> result = new ArrayList<>();\n+                    result.addAll(Arrays.asList(certificates));\n+                    return result;\n+                } catch (SSLPeerUnverifiedException err) {\n+                     return Collections.emptyList();\n+                }\n             }\n \n             @Override\n@@ -267,6 +327,16 @@ public BookKeeperPrincipal getAuthorizedId() {\n                 return authorizedId;\n             }\n \n+            @Override\n+            public boolean isSecure() {\n+               Channel c = channel;\n+               if (c == null) {\n+                    return false;\n+               } else {\n+                    return c.pipeline().get(SslHandler.class) != null;\n+               }\n+            }\n+\n         };\n     }\n \n@@ -351,63 +421,15 @@ protected void initChannel(Channel ch) throws Exception {\n         }\n \n         ChannelFuture future = bootstrap.connect(bookieAddr);\n-        future.addListener(new ChannelFutureListener() {\n-            @Override\n-            public void operationComplete(ChannelFuture future) throws Exception {\n-                if (LOG.isDebugEnabled()) {\n-                    LOG.debug(\"Channel connected ({}) {}\", future.isSuccess(), future.channel());\n-                }\n-                int rc;\n-                Queue<GenericCallback<PerChannelBookieClient>> oldPendingOps;\n-\n-                synchronized (PerChannelBookieClient.this) {\n-                    if (future.isSuccess() && state == ConnectionState.CONNECTING) {\n-                        LOG.info(\"Successfully connected to bookie: {}\", future.channel());\n-                        rc = BKException.Code.OK;\n-                        channel = future.channel();\n-                        state = ConnectionState.CONNECTED;\n-                    } else if (future.isSuccess() && (state == ConnectionState.CLOSED\n-                                                      || state == ConnectionState.DISCONNECTED)) {\n-                        LOG.warn(\"Closed before connection completed, clean up: {}, current state {}\",\n-                                future.channel(), state);\n-                        closeChannel(future.channel());\n-                        rc = BKException.Code.BookieHandleNotAvailableException;\n-                        channel = null;\n-                    } else if (future.isSuccess() && state == ConnectionState.CONNECTED) {\n-                        if (LOG.isDebugEnabled()) {\n-                            LOG.debug(\"Already connected with another channel({}), so close the new channel({})\",\n-                                    channel, future.channel());\n-                        }\n-                        closeChannel(future.channel());\n-                        return; // pendingOps should have been completed when other channel connected\n-                    } else {\n-                        LOG.error(\"Could not connect to bookie: {}/{}, current state {} : \",\n-                                new Object[] { future.channel(), addr, state, future.cause() });\n-                        rc = BKException.Code.BookieHandleNotAvailableException;\n-                        closeChannel(future.channel());\n-                        channel = null;\n-                        if (state != ConnectionState.CLOSED) {\n-                            state = ConnectionState.DISCONNECTED;\n-                        }\n-                    }\n-\n-                    // trick to not do operations under the lock, take the list\n-                    // of pending ops and assign it to a new variable, while\n-                    // emptying the pending ops by just assigning it to a new\n-                    // list\n-                    oldPendingOps = pendingOps;\n-                    pendingOps = new ArrayDeque<GenericCallback<PerChannelBookieClient>>();\n-                }\n-\n-                for (GenericCallback<PerChannelBookieClient> pendingOp : oldPendingOps) {\n-                    completeOperation(pendingOp, rc);\n-                }\n-            }\n-        });\n-\n+        future.addListener(new ConnectionFutureListener());\n         return future;\n     }\n \n+    void cleanDisconnectAndClose() {\n+        disconnect();\n+        close();\n+    }\n+\n     void connectIfNeededAndDoOp(GenericCallback<PerChannelBookieClient> op) {\n         boolean completeOpNow = false;\n         int opRc = BKException.Code.OK;\n@@ -431,9 +453,9 @@ void connectIfNeededAndDoOp(GenericCallback<PerChannelBookieClient> op) {\n                     // connection attempt either fails or succeeds\n                     pendingOps.add(op);\n \n-                    if (state == ConnectionState.CONNECTING) {\n-                        // just return as connection request has already send\n-                        // and waiting for the response.\n+                    if (state == ConnectionState.CONNECTING\n+                        || state == ConnectionState.START_TLS) {\n+                        // the connection request has already been sent and it is waiting for the response.\n                         return;\n                     }\n                     // switch state to connecting and do connection attempt\n@@ -958,6 +980,10 @@ private ChannelFuture closeChannel(Channel c) {\n         return c.close();\n     }\n \n+    void errorStartTLS(int rc) {\n+        failTLS(rc);\n+    }\n+\n     void errorOutReadKey(final CompletionKey key) {\n         errorOutReadKey(key, BKException.Code.BookieHandleNotAvailableException);\n     }\n@@ -1139,6 +1165,9 @@ void errorOutOutstandingEntries(int rc) {\n                 case GET_BOOKIE_INFO:\n                     errorOutGetBookieInfoKey(key, rc);\n                     break;\n+                case START_TLS:\n+                    errorStartTLS(rc);\n+                    break;\n                 default:\n                     break;\n             }\n@@ -1333,8 +1362,8 @@ private void readV3Response(final Response response) {\n         if (null == completionValue) {\n             // Unexpected response, so log it. The txnId should have been present.\n             if (LOG.isDebugEnabled()) {\n-                LOG.debug(\"Unexpected response received from bookie : \" + addr + \" for type : \" + header.             getOperation() +\n-                        \" and txnId : \" + header.getTxnId());\n+                LOG.debug(\"Unexpected response received from bookie : \" + addr + \" for type : \"\n+                        + header.getOperation() + \" and txnId : \" + header.getTxnId());\n             }\n         } else {\n             long orderingKey = completionValue.ledgerId;\n@@ -1396,6 +1425,11 @@ public void safeRun() {\n                             handleGetBookieInfoResponse(getBookieInfoResponse.getFreeDiskSpace(), getBookieInfoResponse.getTotalDiskCapacity(), status, completionValue);\n                             break;\n                         }\n+                        case START_TLS: {\n+                            StatusCode status = response.getStatus();\n+                            handleStartTLSResponse(status, completionValue);\n+                            break;\n+                        }\n                         default:\n                             LOG.error(\"Unexpected response, type:{} received from bookie:{}, ignoring\",\n                                       type, addr);\n@@ -1413,6 +1447,98 @@ public String toString() {\n         }\n     }\n \n+    void handleStartTLSResponse(StatusCode status, CompletionValue completionValue) {\n+        StartTLSCompletion tlsCompletion = (StartTLSCompletion) completionValue;\n+\n+        // convert to BKException code because thats what the upper\n+        // layers expect. This is UGLY, there should just be one set of\n+        // error codes.\n+        Integer rcToRet = statusCodeToExceptionCode(status);\n+        if (null == rcToRet) {\n+            LOG.error(\"START_TLS failed on bookie:{}\", addr);\n+            rcToRet = BKException.Code.SecurityException;\n+        } else {\n+            if (LOG.isDebugEnabled()) {\n+                LOG.debug(\"Received START_TLS response from {} rc: {}\", addr, rcToRet);\n+            }\n+        }\n+\n+        // Cancel START_TLS request timeout\n+        tlsCompletion.cb.startTLSComplete(rcToRet, tlsCompletion.ctx);\n+\n+        if (state != ConnectionState.START_TLS) {\n+            LOG.error(\"Connection state changed before TLS response received\");\n+            failTLS(BKException.Code.BookieHandleNotAvailableException);\n+        } else if (status != StatusCode.EOK) {\n+            LOG.error(\"Client received error {} during TLS negotiation\", status);\n+            failTLS(BKException.Code.SecurityException);\n+        } else {\n+            // create TLS handler\n+            PerChannelBookieClient parentObj = PerChannelBookieClient.this;\n+            SslHandler handler = parentObj.shFactory.newTLSHandler();\n+            channel.pipeline().addFirst(parentObj.shFactory.getHandlerName(), handler);\n+            handler.handshakeFuture().addListener(new GenericFutureListener<Future<Channel>>() {\n+                @Override\n+                public void operationComplete(Future<Channel> future) throws Exception {\n+                    int rc;\n+                    Queue<GenericCallback<PerChannelBookieClient>> oldPendingOps;\n+\n+                    synchronized (PerChannelBookieClient.this) {\n+                        if (future.isSuccess() && state == ConnectionState.CONNECTING) {\n+                            LOG.error(\"Connection state changed before TLS handshake completed {}/{}\", addr, state);\n+                            rc = BKException.Code.BookieHandleNotAvailableException;\n+                            closeChannel(future.get());\n+                            channel = null;\n+                            if (state != ConnectionState.CLOSED) {\n+                                state = ConnectionState.DISCONNECTED;\n+                            }\n+                        } else if (future.isSuccess() && state == ConnectionState.START_TLS) {\n+                            rc = BKException.Code.OK;\n+                            LOG.info(\"Successfully connected to bookie using TLS: \" + addr);\n+\n+                            state = ConnectionState.CONNECTED;\n+                            AuthHandler.ClientSideHandler authHandler = future.get().pipeline()\n+                                    .get(AuthHandler.ClientSideHandler.class);\n+                            authHandler.authProvider.onProtocolUpgrade();\n+                        } else if (future.isSuccess()\n+                                && (state == ConnectionState.CLOSED || state == ConnectionState.DISCONNECTED)) {\n+                            LOG.warn(\"Closed before TLS handshake completed, clean up: {}, current state {}\",\n+                                    future.get(), state);\n+                            closeChannel(future.get());\n+                            rc = BKException.Code.BookieHandleNotAvailableException;\n+                            channel = null;\n+                        } else if (future.isSuccess() && state == ConnectionState.CONNECTED) {\n+                            LOG.debug(\"Already connected with another channel({}), so close the new channel({})\",\n+                                    channel, future.get());\n+                            closeChannel(future.get());\n+                            return; // pendingOps should have been completed when other channel connected\n+                        } else {\n+                            LOG.error(\"TLS handshake failed with bookie: {}/{}, current state {} : \",\n+                                    new Object[] { future.get(), addr, state, future.cause() });\n+                            rc = BKException.Code.SecurityException;\n+                            closeChannel(future.get());\n+                            channel = null;\n+                            if (state != ConnectionState.CLOSED) {\n+                                state = ConnectionState.DISCONNECTED;\n+                            }\n+                        }\n+\n+                        // trick to not do operations under the lock, take the list\n+                        // of pending ops and assign it to a new variable, while\n+                        // emptying the pending ops by just assigning it to a new\n+                        // list\n+                        oldPendingOps = pendingOps;\n+                        pendingOps = new ArrayDeque<>();\n+                    }\n+\n+                    for (GenericCallback<PerChannelBookieClient> pendingOp : oldPendingOps) {\n+                        pendingOp.operationComplete(rc, PerChannelBookieClient.this);\n+                    }\n+                }\n+            });\n+        }\n+    }\n+\n     void handleWriteLacResponse(long ledgerId, StatusCode status, CompletionValue completionValue) {\n         // The completion value should always be an instance of an WriteLacCompletion object when we reach here.\n         WriteLacCompletion plc = (WriteLacCompletion)completionValue;\n@@ -1657,6 +1783,42 @@ public void readEntryComplete(int rc, long ledgerId, long entryId, ByteBuf buffe\n         }\n     }\n \n+    static class StartTLSCompletion extends CompletionValue {\n+        final StartTLSCallback cb;\n+\n+        public StartTLSCompletion(final PerChannelBookieClient pcbc, StartTLSCallback cb, Object ctx) {\n+            this(pcbc, null, cb, ctx, null);\n+        }\n+\n+        public StartTLSCompletion(final PerChannelBookieClient pcbc, final OpStatsLogger startTLSOpLogger,\n+                                  final StartTLSCallback originalCallback, final Object originalCtx, final Timeout timeout) {\n+            super(originalCtx, -1, -1, timeout);\n+            final long startTime = MathUtils.nowInNano();\n+            this.cb = new StartTLSCallback() {\n+                @Override\n+                public void startTLSComplete(int rc, Object ctx) {\n+                    cancelTimeout();\n+                    if (startTLSOpLogger != null) {\n+                        long latency = MathUtils.elapsedNanos(startTime);\n+                        if (rc != BKException.Code.OK) {\n+                            startTLSOpLogger.registerFailedEvent(latency, TimeUnit.NANOSECONDS);\n+                        } else {\n+                            startTLSOpLogger.registerSuccessfulEvent(latency, TimeUnit.NANOSECONDS);\n+                        }\n+                    }\n+\n+                    if (rc != BKException.Code.OK && !expectedBkOperationErrors.contains(rc)) {\n+                        pcbc.recordError();\n+                    }\n+\n+                    if (originalCallback != null) {\n+                        originalCallback.startTLSComplete(rc, originalCtx);\n+                    }\n+                }\n+            };\n+        }\n+    }\n+\n     // visible for testing\n     static class GetBookieInfoCompletion extends CompletionValue {\n         final GetBookieInfoCallback cb;\n@@ -1803,11 +1965,16 @@ public void run(Timeout timeout) throws Exception {\n             } else if (OperationType.READ_LAC == operationType) {\n                 errorOutReadLacKey(this, BKException.Code.TimeoutException);\n                 readLacTimeoutOpLogger.registerSuccessfulEvent(elapsedTime(), TimeUnit.NANOSECONDS);\n+            } else if (OperationType.GET_BOOKIE_INFO == operationType) {\n+                errorOutGetBookieInfoKey(this, BKException.Code.TimeoutException);\n+                getBookieInfoTimeoutOpLogger.registerSuccessfulEvent(elapsedTime(), TimeUnit.NANOSECONDS);\n+            } else if (OperationType.START_TLS == operationType) {\n+                errorStartTLS(BKException.Code.TimeoutException);\n             } else {\n                 errorOutGetBookieInfoKey(this, BKException.Code.TimeoutException);\n                 getBookieInfoTimeoutOpLogger.registerSuccessfulEvent(elapsedTime(), TimeUnit.NANOSECONDS);\n             }\n-\t}\n+        }\n     }\n \n \n@@ -1884,4 +2051,106 @@ public String toString() {\n             return String.format(\"%d:%d %s\", ledgerId, entryId, operationType);\n         }\n     }\n+    \n+    public class ConnectionFutureListener implements ChannelFutureListener {\n+        @Override\n+        public void operationComplete(ChannelFuture future) throws Exception {\n+            LOG.debug(\"Channel connected ({}) {}\", future.isSuccess(), future.channel());\n+            int rc;\n+            Queue<GenericCallback<PerChannelBookieClient>> oldPendingOps;\n+\n+            synchronized (PerChannelBookieClient.this) {\n+                if (future.isSuccess() && state == ConnectionState.CONNECTING) {\n+                    LOG.info(\"Successfully connected to bookie: {}\", future.channel());\n+                    rc = BKException.Code.OK;\n+                    channel = future.channel();\n+                    if (shFactory != null) {\n+                        initiateTLS();\n+                        return;\n+                    } else {\n+                        LOG.info(\"Successfully connected to bookie: \" + addr);\n+                        state = ConnectionState.CONNECTED;\n+                    }\n+                } else if (future.isSuccess() && state == ConnectionState.START_TLS) {\n+                    rc = BKException.Code.OK;\n+                    LOG.info(\"Successfully connected to bookie using TLS: \" + addr);\n+\n+                    state = ConnectionState.CONNECTED;\n+                    AuthHandler.ClientSideHandler authHandler = future.channel().pipeline()\n+                            .get(AuthHandler.ClientSideHandler.class);\n+                    authHandler.authProvider.onProtocolUpgrade();\n+                } else if (future.isSuccess() && (state == ConnectionState.CLOSED\n+                    || state == ConnectionState.DISCONNECTED)) {\n+                    LOG.warn(\"Closed before connection completed, clean up: {}, current state {}\",\n+                            future.channel(), state);\n+                    closeChannel(future.channel());\n+                    rc = BKException.Code.BookieHandleNotAvailableException;\n+                    channel = null;\n+                } else if (future.isSuccess() && state == ConnectionState.CONNECTED) {\n+                    LOG.debug(\"Already connected with another channel({}), so close the new channel({})\",\n+                            channel, future.channel());\n+                    closeChannel(future.channel());\n+                    return; // pendingOps should have been completed when other channel connected\n+                } else {\n+                    LOG.error(\"Could not connect to bookie: {}/{}, current state {} : \",\n+                            new Object[] { future.channel(), addr, state, future.cause() });\n+                    rc = BKException.Code.BookieHandleNotAvailableException;\n+                    closeChannel(future.channel());\n+                    channel = null;\n+                    if (state != ConnectionState.CLOSED) {\n+                        state = ConnectionState.DISCONNECTED;\n+                    }\n+                }\n+\n+                // trick to not do operations under the lock, take the list\n+                // of pending ops and assign it to a new variable, while\n+                // emptying the pending ops by just assigning it to a new\n+                // list\n+                oldPendingOps = pendingOps;\n+                pendingOps = new ArrayDeque<>();\n+            }\n+\n+            for (GenericCallback<PerChannelBookieClient> pendingOp : oldPendingOps) {\n+                pendingOp.operationComplete(rc, PerChannelBookieClient.this);\n+            }\n+        }\n+    }\n+\n+    private void initiateTLS() {\n+        LOG.info(\"Initializing TLS to {}\",channel);\n+        assert state == ConnectionState.CONNECTING;\n+        final long txnId = getTxnId();\n+        final CompletionKey completionKey = new V3CompletionKey(txnId, OperationType.START_TLS);\n+        completionObjects.put(completionKey, new StartTLSCompletion(this, startTLSOpLogger, null, null,\n+                scheduleTimeout(completionKey, startTLSTimeout)));\n+        BookkeeperProtocol.Request.Builder h = BookkeeperProtocol.Request.newBuilder();\n+        BKPacketHeader.Builder headerBuilder = BKPacketHeader.newBuilder()\n+                .setVersion(ProtocolVersion.VERSION_THREE)\n+                .setOperation(OperationType.START_TLS)\n+                .setTxnId(txnId);\n+        h.setHeader(headerBuilder.build());\n+        h.setStartTLSRequest(BookkeeperProtocol.StartTLSRequest.newBuilder().build());\n+        state = ConnectionState.START_TLS;\n+        channel.writeAndFlush(h.build()).addListener(new ChannelFutureListener() {\n+            @Override\n+            public void operationComplete(ChannelFuture future) throws Exception {\n+                if (!future.isSuccess()) {\n+                    LOG.error(\"Failed to send START_TLS request\");\n+                    failTLS(BKException.Code.SecurityException);\n+                }\n+            }\n+        });\n+    }\n+    private void failTLS(int rc) {\n+        LOG.error(\"TLS failure on: {}, rc: {}\", channel, rc);\n+        Queue<GenericCallback<PerChannelBookieClient>> oldPendingOps;\n+        synchronized(this) {\n+            disconnect();\n+            oldPendingOps = pendingOps;\n+            pendingOps = new ArrayDeque<>();\n+        }\n+        for (GenericCallback<PerChannelBookieClient> pendingOp : oldPendingOps) {\n+            pendingOp.operationComplete(rc, null);\n+        }\n+    }\n }"},{"sha":"17abb5658270171be4addb19054918112cd95a80","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClientFactory.java","status":"modified","additions":5,"deletions":1,"changes":6,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/8e0bd2c3d81b522e97434d8646915f36422a104b/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FPerChannelBookieClientFactory.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/8e0bd2c3d81b522e97434d8646915f36422a104b/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FPerChannelBookieClientFactory.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FPerChannelBookieClientFactory.java?ref=8e0bd2c3d81b522e97434d8646915f36422a104b","patch":"@@ -21,6 +21,8 @@\n package org.apache.bookkeeper.proto;\n \n import org.apache.bookkeeper.net.BookieSocketAddress;\n+import org.apache.bookkeeper.tls.SecurityException;\n+import org.apache.bookkeeper.tls.SecurityHandlerFactory;\n \n /**\n  * Factory to create {@link org.apache.bookkeeper.proto.PerChannelBookieClient}.\n@@ -32,6 +34,8 @@ interface PerChannelBookieClientFactory {\n      * <i>address</i>.\n      *\n      * @return the client connected to address.\n+     * @throws SecurityException\n      */\n-    PerChannelBookieClient create(BookieSocketAddress address, PerChannelBookieClientPool pcbcPool);\n+    PerChannelBookieClient create(BookieSocketAddress address,\n+            PerChannelBookieClientPool pcbcPool, SecurityHandlerFactory shFactory) throws SecurityException;\n }"},{"sha":"166513e6450255f8de8f55b6ccda6eedf4e4cce1","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/tls/SecurityException.java","status":"added","additions":34,"deletions":0,"changes":34,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/8e0bd2c3d81b522e97434d8646915f36422a104b/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Ftls%2FSecurityException.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/8e0bd2c3d81b522e97434d8646915f36422a104b/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Ftls%2FSecurityException.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Ftls%2FSecurityException.java?ref=8e0bd2c3d81b522e97434d8646915f36422a104b","patch":"@@ -0,0 +1,34 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.bookkeeper.tls;\n+\n+public class SecurityException extends Exception {\n+    public SecurityException() {}\n+\n+    public SecurityException(String message) {\n+        super(message);\n+    }\n+\n+    public SecurityException(Throwable cause) {\n+        super(cause);\n+    }\n+\n+    public SecurityException(String message, Throwable cause) {\n+        super(message, cause);\n+    }\n+}"},{"sha":"84a3a5ea7119d868863444d40656fe94717ca2a6","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/tls/SecurityHandlerFactory.java","status":"added","additions":35,"deletions":0,"changes":35,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/8e0bd2c3d81b522e97434d8646915f36422a104b/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Ftls%2FSecurityHandlerFactory.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/8e0bd2c3d81b522e97434d8646915f36422a104b/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Ftls%2FSecurityHandlerFactory.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Ftls%2FSecurityHandlerFactory.java?ref=8e0bd2c3d81b522e97434d8646915f36422a104b","patch":"@@ -0,0 +1,35 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.bookkeeper.tls;\n+\n+import org.apache.bookkeeper.conf.AbstractConfiguration;\n+\n+import io.netty.handler.ssl.SslHandler;\n+\n+public interface SecurityHandlerFactory {\n+    public enum NodeType {\n+        Unknown,\n+        Client,\n+        Server,\n+    }\n+\n+    public abstract String getHandlerName();\n+\n+    public abstract void init(NodeType type, AbstractConfiguration conf) throws SecurityException;\n+    public SslHandler newTLSHandler();\n+}"},{"sha":"38376d8a9f238646f00ae6be4b1b7df56fb09e4d","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/tls/SecurityProviderFactoryFactory.java","status":"added","additions":45,"deletions":0,"changes":45,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/8e0bd2c3d81b522e97434d8646915f36422a104b/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Ftls%2FSecurityProviderFactoryFactory.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/8e0bd2c3d81b522e97434d8646915f36422a104b/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Ftls%2FSecurityProviderFactoryFactory.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Ftls%2FSecurityProviderFactoryFactory.java?ref=8e0bd2c3d81b522e97434d8646915f36422a104b","patch":"@@ -0,0 +1,45 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.bookkeeper.tls;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public abstract class SecurityProviderFactoryFactory {\n+    private final static Logger LOG = LoggerFactory.getLogger(SecurityProviderFactoryFactory.class);\n+\n+    public static SecurityHandlerFactory getSecurityProviderFactory(String securityHandler)\n+            throws SecurityException {\n+        if ((securityHandler == null) || (securityHandler.equals(\"\"))) {\n+            return null;\n+        }\n+\n+        ClassLoader classLoader = SecurityProviderFactoryFactory.class.getClassLoader();\n+        SecurityHandlerFactory shFactory = null;\n+        try {\n+            Class<?> shFactoryClass = classLoader.loadClass(securityHandler);\n+            shFactory = (SecurityHandlerFactory) shFactoryClass.newInstance();\n+            LOG.info(\"Loaded security handler for {}\", securityHandler);\n+        } catch (Exception e) {\n+            LOG.error(\"Unable to load security handler for {}: \", securityHandler, e);\n+            throw new SecurityException(e);\n+        }\n+        return shFactory;\n+    }\n+\n+}"},{"sha":"eda5aec98f1d7c6ab93fd2ba7abad9ca541adf23","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/tls/TLSContextFactory.java","status":"added","additions":293,"deletions":0,"changes":293,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/8e0bd2c3d81b522e97434d8646915f36422a104b/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Ftls%2FTLSContextFactory.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/8e0bd2c3d81b522e97434d8646915f36422a104b/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Ftls%2FTLSContextFactory.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Ftls%2FTLSContextFactory.java?ref=8e0bd2c3d81b522e97434d8646915f36422a104b","patch":"@@ -0,0 +1,293 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.bookkeeper.tls;\n+\n+import org.apache.bookkeeper.conf.AbstractConfiguration;\n+import org.apache.bookkeeper.conf.ClientConfiguration;\n+import org.apache.bookkeeper.conf.ServerConfiguration;\n+import org.apache.commons.io.FileUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.base.Strings;\n+\n+import io.netty.buffer.PooledByteBufAllocator;\n+import io.netty.handler.ssl.ClientAuth;\n+import io.netty.handler.ssl.OpenSsl;\n+import io.netty.handler.ssl.SslContext;\n+import io.netty.handler.ssl.SslContextBuilder;\n+import io.netty.handler.ssl.SslHandler;\n+import io.netty.handler.ssl.SslProvider;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.UnrecoverableKeyException;\n+import java.security.cert.CertificateException;\n+\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.TrustManagerFactory;\n+\n+public class TLSContextFactory implements SecurityHandlerFactory {\n+    private final static Logger LOG = LoggerFactory.getLogger(TLSContextFactory.class);\n+    private final static String TLSCONTEXT_HANDLER_NAME = \"tls\";\n+    private String[] protocols;\n+    private String[] ciphers;\n+    private SslContext sslContext;\n+\n+    private String getPasswordFromFile(String path) throws IOException {\n+        FileInputStream pwdin = new FileInputStream(path);\n+        byte[] pwd;\n+        try {\n+            File passwdFile = new File(path);\n+            if (passwdFile.length() == 0) {\n+                return \"\";\n+            }\n+            pwd = FileUtils.readFileToByteArray(passwdFile);\n+        } finally {\n+            pwdin.close();\n+        }\n+        return new String(pwd, \"UTF-8\");\n+    }\n+\n+    private KeyStore loadKeyStore(String keyStoreType, String keyStoreLocation, String keyStorePassword)\n+            throws KeyStoreException, NoSuchAlgorithmException, CertificateException, IOException {\n+        KeyStore ks = KeyStore.getInstance(keyStoreType);\n+        FileInputStream ksin = new FileInputStream(keyStoreLocation);\n+        try {\n+            ks.load(ksin, keyStorePassword.trim().toCharArray());\n+        } finally {\n+            ksin.close();\n+        }\n+        return ks;\n+    }\n+\n+    public String getHandlerName() {\n+        return TLSCONTEXT_HANDLER_NAME;\n+    }\n+\n+    private KeyManagerFactory initKeyManagerFactory(String keyStoreType, String keyStoreLocation,\n+            String keyStorePasswordPath) throws SecurityException, KeyStoreException, NoSuchAlgorithmException,\n+            CertificateException, IOException, UnrecoverableKeyException {\n+        KeyManagerFactory kmf = null;\n+\n+        if (Strings.isNullOrEmpty(keyStoreLocation)) {\n+            LOG.error(\"Key store location cannot be empty when Mutual Authentication is enabled!\");\n+            throw new SecurityException(\"Key store location cannot be empty when Mutual Authentication is enabled!\");\n+        }\n+\n+        String keyStorePassword = \"\";\n+        if (!Strings.isNullOrEmpty(keyStorePasswordPath)) {\n+            keyStorePassword = getPasswordFromFile(keyStorePasswordPath);\n+        }\n+\n+        // Initialize key store\n+        KeyStore ks = loadKeyStore(keyStoreType, keyStoreLocation, keyStorePassword);\n+        kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n+        kmf.init(ks, keyStorePassword.trim().toCharArray());\n+\n+        return kmf;\n+    }\n+\n+    private TrustManagerFactory initTrustManagerFactory(String trustStoreType, String trustStoreLocation,\n+            String trustStorePasswordPath)\n+            throws KeyStoreException, NoSuchAlgorithmException, CertificateException, IOException, SecurityException {\n+        TrustManagerFactory tmf;\n+\n+        if (Strings.isNullOrEmpty(trustStoreLocation)) {\n+            LOG.error(\"Trust Store location cannot be empty!\");\n+            throw new SecurityException(\"Trust Store location cannot be empty!\");\n+        }\n+\n+        String trustStorePassword = \"\";\n+        if (!Strings.isNullOrEmpty(trustStorePasswordPath)) {\n+            trustStorePassword = getPasswordFromFile(trustStorePasswordPath);\n+        }\n+\n+        // Initialize trust store\n+        KeyStore ts = loadKeyStore(trustStoreType, trustStoreLocation, trustStorePassword);\n+        tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n+        tmf.init(ts);\n+\n+        return tmf;\n+    }\n+\n+    private SslProvider getTLSProvider(String sslProvider) {\n+        if (sslProvider.trim().equalsIgnoreCase(\"OpenSSL\")) {\n+            if (OpenSsl.isAvailable()) {\n+                LOG.info(\"Security provider - OpenSSL\");\n+                return SslProvider.OPENSSL;\n+            }\n+\n+            Throwable causeUnavailable = OpenSsl.unavailabilityCause();\n+            LOG.warn(\"OpenSSL Unavailable: \", causeUnavailable);\n+\n+            LOG.info(\"Security provider - JDK\");\n+            return SslProvider.JDK;\n+        }\n+\n+        LOG.info(\"Security provider - JDK\");\n+        return SslProvider.JDK;\n+    }\n+\n+    private void createClientContext(AbstractConfiguration conf) throws SecurityException, KeyStoreException, NoSuchAlgorithmException,\n+            CertificateException, IOException, UnrecoverableKeyException {\n+        final SslContextBuilder sslContextBuilder;\n+        final ClientConfiguration clientConf;\n+        final SslProvider provider;\n+        final boolean Authentication;\n+\n+        KeyManagerFactory kmf = null;\n+        TrustManagerFactory tmf = null;\n+\n+        // get key-store and trust-store locations and passwords\n+        if (!(conf instanceof ClientConfiguration)) {\n+            throw new SecurityException(\"Client configruation not provided\");\n+        }\n+\n+        clientConf = (ClientConfiguration) conf;\n+        provider = getTLSProvider(clientConf.getTLSProvider());\n+        Authentication = clientConf.getTLSClientAuthentication();\n+\n+        tmf = initTrustManagerFactory(clientConf.getTLSTrustStoreType(), clientConf.getTLSTrustStore(),\n+                clientConf.getTLSTrustStorePasswordPath());\n+\n+        if (Authentication) {\n+            kmf = initKeyManagerFactory(clientConf.getTLSKeyStoreType(), clientConf.getTLSKeyStore(),\n+                    clientConf.getTLSKeyStorePasswordPath());\n+        }\n+\n+        // Build Ssl context\n+        sslContextBuilder = SslContextBuilder.forClient()\n+                                            .trustManager(tmf)\n+                                            .ciphers(null)\n+                                            .sessionCacheSize(0)\n+                                            .sessionTimeout(0)\n+                                            .sslProvider(provider)\n+                                            .clientAuth(ClientAuth.REQUIRE);\n+\n+        /* if mutual authentication is enabled */\n+        if (Authentication) {\n+            sslContextBuilder.keyManager(kmf);\n+        }\n+\n+        sslContext = sslContextBuilder.build();\n+    }\n+\n+    private void createServerContext(AbstractConfiguration conf) throws SecurityException, KeyStoreException, NoSuchAlgorithmException,\n+            CertificateException, IOException, UnrecoverableKeyException {\n+        final SslContextBuilder sslContextBuilder;\n+        final ServerConfiguration serverConf;\n+        final SslProvider provider;\n+        final boolean Authentication;\n+\n+        KeyManagerFactory kmf = null;\n+        TrustManagerFactory tmf = null;\n+\n+        // get key-store and trust-store locations and passwords\n+        if (!(conf instanceof ServerConfiguration)) {\n+            throw new SecurityException(\"Server configruation not provided\");\n+        }\n+\n+        serverConf = (ServerConfiguration) conf;\n+        provider = getTLSProvider(serverConf.getTLSProvider());\n+        Authentication = serverConf.getTLSClientAuthentication();\n+\n+        kmf = initKeyManagerFactory(serverConf.getTLSKeyStoreType(), serverConf.getTLSKeyStore(),\n+                serverConf.getTLSKeyStorePasswordPath());\n+\n+        if (Authentication) {\n+            tmf = initTrustManagerFactory(serverConf.getTLSTrustStoreType(), serverConf.getTLSTrustStore(),\n+                    serverConf.getTLSTrustStorePasswordPath());\n+        }\n+\n+        // Build Ssl context\n+        sslContextBuilder = SslContextBuilder.forServer(kmf)\n+                                            .ciphers(null)\n+                                            .sessionCacheSize(0)\n+                                            .sessionTimeout(0)\n+                                            .sslProvider(provider)\n+                                            .startTls(true);\n+\n+        /* if mutual authentication is enabled */\n+        if (Authentication) {\n+            sslContextBuilder.trustManager(tmf)\n+                            .clientAuth(ClientAuth.REQUIRE);\n+        }\n+\n+        sslContext = sslContextBuilder.build();\n+    }\n+\n+    @Override\n+    public synchronized void init(NodeType type, AbstractConfiguration conf) throws SecurityException {\n+        final String enabledProtocols;\n+        final String enabledCiphers;\n+\n+        enabledCiphers = conf.getTLSEnabledCipherSuites();\n+        enabledProtocols = conf.getTLSEnabledProtocols();\n+\n+        try {\n+            switch (type) {\n+            case Client:\n+                createClientContext(conf);\n+                break;\n+            case Server:\n+                createServerContext(conf);\n+                break;\n+            default:\n+                throw new SecurityException(new IllegalArgumentException(\"Invalid NodeType\"));\n+            }\n+\n+            if (enabledProtocols != null && !enabledProtocols.isEmpty()) {\n+                protocols = enabledProtocols.split(\",\");\n+            }\n+\n+            if (enabledCiphers != null && !enabledCiphers.isEmpty()) {\n+                ciphers = enabledCiphers.split(\",\");\n+            }\n+        } catch (KeyStoreException e) {\n+            throw new RuntimeException(\"Standard keystore type missing\", e);\n+        } catch (NoSuchAlgorithmException e) {\n+            throw new RuntimeException(\"Standard algorithm missing\", e);\n+        } catch (CertificateException e) {\n+            throw new SecurityException(\"Unable to load keystore\", e);\n+        } catch (IOException e) {\n+            throw new SecurityException(\"Error initializing TLSContext\", e);\n+        } catch (UnrecoverableKeyException e) {\n+            throw new SecurityException(\"Unable to load key manager, possibly wrong password given\", e);\n+        }\n+    }\n+\n+    @Override\n+    public SslHandler newTLSHandler() {\n+        SslHandler sslHandler = sslContext.newHandler(PooledByteBufAllocator.DEFAULT);\n+\n+        if (protocols != null && protocols.length != 0) {\n+            sslHandler.engine().setEnabledProtocols(protocols);\n+        }\n+\n+        if (ciphers != null && ciphers.length != 0) {\n+            sslHandler.engine().setEnabledCipherSuites(ciphers);\n+        }\n+\n+        return sslHandler;\n+    }\n+}"},{"sha":"77ce25f6d3c99e024ed9abac37bdfc07227f72a6","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/util/LocalBookKeeper.java","status":"modified","additions":7,"deletions":4,"changes":11,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/8e0bd2c3d81b522e97434d8646915f36422a104b/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2FLocalBookKeeper.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/8e0bd2c3d81b522e97434d8646915f36422a104b/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2FLocalBookKeeper.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2FLocalBookKeeper.java?ref=8e0bd2c3d81b522e97434d8646915f36422a104b","patch":"@@ -36,6 +36,9 @@\n import org.apache.bookkeeper.proto.BookieServer;\n import org.apache.bookkeeper.replication.ReplicationException.CompatibilityException;\n import org.apache.bookkeeper.replication.ReplicationException.UnavailableException;\n+import org.apache.bookkeeper.stats.StatsLogger;\n+import org.apache.bookkeeper.stats.StatsProvider;\n+import org.apache.bookkeeper.tls.SecurityException;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.apache.zookeeper.CreateMode;\n@@ -129,7 +132,7 @@ private static void cleanupDirectories(List<File> dirs) throws IOException {\n \n     private List<File> runBookies(ServerConfiguration baseConf, String dirSuffix)\n             throws IOException, KeeperException, InterruptedException, BookieException,\n-            UnavailableException, CompatibilityException {\n+            UnavailableException, CompatibilityException, SecurityException {\n         List<File> tempDirs = new ArrayList<File>();\n         try {\n             runBookies(baseConf, tempDirs, dirSuffix);\n@@ -157,8 +160,8 @@ private List<File> runBookies(ServerConfiguration baseConf, String dirSuffix)\n \n     @SuppressWarnings(\"deprecation\")\n     private void runBookies(ServerConfiguration baseConf, List<File> tempDirs, String dirSuffix)\n-            throws IOException, KeeperException, InterruptedException, BookieException,\n-            UnavailableException, CompatibilityException {\n+            throws IOException, KeeperException, InterruptedException, BookieException, UnavailableException,\n+            CompatibilityException, SecurityException {\n         LOG.info(\"Starting Bookie(s)\");\n         // Create Bookie Servers (B1, B2, B3)\n \n@@ -311,7 +314,7 @@ static void startLocalBookiesInternal(ServerConfiguration conf,\n         }\n     }\n \n-    public static void main(String[] args) throws Exception {\n+    public static void main(String[] args) throws Exception, SecurityException {\n         if(args.length < 1) {\n             usage();\n             System.exit(-1);"},{"sha":"309987c357fc2b94bae6c34d4bf19d20cfe47d12","filename":"bookkeeper-server/src/main/proto/BookkeeperProtocol.proto","status":"modified","additions":9,"deletions":0,"changes":9,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/8e0bd2c3d81b522e97434d8646915f36422a104b/bookkeeper-server%2Fsrc%2Fmain%2Fproto%2FBookkeeperProtocol.proto","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/8e0bd2c3d81b522e97434d8646915f36422a104b/bookkeeper-server%2Fsrc%2Fmain%2Fproto%2FBookkeeperProtocol.proto","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fproto%2FBookkeeperProtocol.proto?ref=8e0bd2c3d81b522e97434d8646915f36422a104b","patch":"@@ -60,6 +60,7 @@ enum OperationType {\n     WRITE_LAC = 6;\n     READ_LAC = 7;\n     GET_BOOKIE_INFO = 8;\n+    START_TLS = 9;\n }\n \n /**\n@@ -80,6 +81,7 @@ message Request {\n     optional WriteLacRequest writeLacRequest = 103;\n     optional ReadLacRequest readLacRequest = 104;\n     optional GetBookieInfoRequest getBookieInfoRequest = 105;\n+    optional StartTLSRequest startTLSRequest = 106;\n }\n \n message ReadRequest {\n@@ -110,6 +112,9 @@ message AddRequest {\n     required bytes body = 4;\n }\n \n+message StartTLSRequest {\n+}\n+\n message WriteLacRequest {\n     required int64 ledgerId = 1;\n     required int64 lac = 2;\n@@ -143,6 +148,7 @@ message Response {\n     optional WriteLacResponse writeLacResponse = 103;\n     optional ReadLacResponse readLacResponse = 104;\n     optional GetBookieInfoResponse getBookieInfoResponse = 105;\n+    optional StartTLSResponse startTLSResponse = 106;\n }\n \n message ReadResponse {\n@@ -183,3 +189,6 @@ message GetBookieInfoResponse {\n     optional int64 totalDiskCapacity = 2;\n     optional int64 freeDiskSpace = 3;\n }\n+\n+message StartTLSResponse {\n+}"},{"sha":"2d112c6945426805b82d72ee6e882acc98fa60fe","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/auth/TestAuth.java","status":"modified","additions":0,"deletions":2,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/8e0bd2c3d81b522e97434d8646915f36422a104b/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fauth%2FTestAuth.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/8e0bd2c3d81b522e97434d8646915f36422a104b/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fauth%2FTestAuth.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fauth%2FTestAuth.java?ref=8e0bd2c3d81b522e97434d8646915f36422a104b","patch":"@@ -488,15 +488,13 @@ public void close() {\n         @Override\n         public BookieAuthProvider newProvider(BookieConnectionPeer connection, AuthCallbacks.GenericCallback<Void> completeCb) {\n             return new BookieAuthProvider() {\n-\n                 {\n                     completeCb.operationComplete(BKException.Code.OK, null);\n                     initCountersOnConnections.incrementAndGet();\n                 }\n \n                 @Override\n                 public void process(AuthToken m, AuthCallbacks.GenericCallback<AuthToken> cb) {\n-\n                 }\n \n                 @Override"},{"sha":"455c9081dd436f001d0ae81f99ed6ceeb0ee482e","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/BookieInitializationTest.java","status":"modified","additions":2,"deletions":1,"changes":3,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/8e0bd2c3d81b522e97434d8646915f36422a104b/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FBookieInitializationTest.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/8e0bd2c3d81b522e97434d8646915f36422a104b/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FBookieInitializationTest.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FBookieInitializationTest.java?ref=8e0bd2c3d81b522e97434d8646915f36422a104b","patch":"@@ -45,6 +45,7 @@\n import org.apache.bookkeeper.stats.StatsLogger;\n import org.apache.bookkeeper.test.BookKeeperClusterTestCase;\n import org.apache.bookkeeper.test.PortManager;\n+import org.apache.bookkeeper.tls.SecurityException;\n import org.apache.bookkeeper.util.DiskChecker;\n import org.apache.bookkeeper.zookeeper.ZooKeeperClient;\n import org.apache.zookeeper.KeeperException;\n@@ -456,7 +457,7 @@ class MockBookieServer extends BookieServer {\n         ServerConfiguration conf;\n \n         public MockBookieServer(ServerConfiguration conf) throws IOException, KeeperException, InterruptedException,\n-                BookieException, UnavailableException, CompatibilityException {\n+                BookieException, UnavailableException, CompatibilityException, SecurityException {\n             super(conf);\n             this.conf = conf;\n         }"},{"sha":"654a0aa4d9291fb81441c91e5042cb2ad37e6c65","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuthAutoRecoveryTest.java","status":"modified","additions":1,"deletions":2,"changes":3,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/8e0bd2c3d81b522e97434d8646915f36422a104b/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Freplication%2FAuthAutoRecoveryTest.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/8e0bd2c3d81b522e97434d8646915f36422a104b/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Freplication%2FAuthAutoRecoveryTest.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Freplication%2FAuthAutoRecoveryTest.java?ref=8e0bd2c3d81b522e97434d8646915f36422a104b","patch":"@@ -66,10 +66,9 @@ public ClientAuthProvider newProvider(ClientConnectionPeer addr,\n             final AuthCallbacks.GenericCallback<Void> completeCb) {\n             return new ClientAuthProvider() {\n                 public void init(AuthCallbacks.GenericCallback<AuthToken> cb) {\n-\n                     completeCb.operationComplete(BKException.Code.OK, null);\n                 }\n-\n+                \n                 public void process(AuthToken m, AuthCallbacks.GenericCallback<AuthToken> cb) {\n                 }\n             };"},{"sha":"61e78b5475bab4cddb1d371fd89e83a3afe25d49","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/tls/TestTLS.java","status":"added","additions":501,"deletions":0,"changes":501,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/8e0bd2c3d81b522e97434d8646915f36422a104b/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Ftls%2FTestTLS.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/8e0bd2c3d81b522e97434d8646915f36422a104b/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Ftls%2FTestTLS.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Ftls%2FTestTLS.java?ref=8e0bd2c3d81b522e97434d8646915f36422a104b","patch":"@@ -0,0 +1,501 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.bookkeeper.tls;\n+\n+import org.junit.*;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.Enumeration;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+\n+import org.apache.bookkeeper.conf.ClientConfiguration;\n+import org.apache.bookkeeper.conf.ServerConfiguration;\n+import org.apache.bookkeeper.net.BookieSocketAddress;\n+import org.apache.bookkeeper.test.BookKeeperClusterTestCase;\n+import org.apache.bookkeeper.tls.SecurityException;\n+import org.apache.bookkeeper.tls.TLSContextFactory;\n+import org.apache.bookkeeper.client.LedgerHandle;\n+import org.apache.bookkeeper.client.LedgerEntry;\n+import org.apache.bookkeeper.client.BookKeeper;\n+import org.apache.bookkeeper.client.BKException;\n+import org.apache.bookkeeper.client.BookKeeper.DigestType;\n+\n+import java.io.IOException;\n+import java.security.cert.Certificate;\n+import java.security.cert.X509Certificate;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.apache.bookkeeper.auth.AuthCallbacks;\n+import org.apache.bookkeeper.auth.AuthToken;\n+import org.apache.bookkeeper.auth.BookieAuthProvider;\n+import org.apache.bookkeeper.auth.ClientAuthProvider;\n+import org.apache.bookkeeper.client.BookKeeperAdmin;\n+import org.apache.bookkeeper.client.LedgerMetadata;\n+import org.apache.bookkeeper.proto.BookieConnectionPeer;\n+import org.apache.bookkeeper.proto.ClientConnectionPeer;\n+import org.apache.bookkeeper.proto.TestPerChannelBookieClient;\n+\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Tests with TLS enabled.\n+ */\n+public class TestTLS extends BookKeeperClusterTestCase {\n+\n+    static Logger LOG = LoggerFactory.getLogger(TestPerChannelBookieClient.class);\n+\n+    private static boolean secureClientSideChannel = false;\n+    private static Collection<Object> secureClientSideChannelPrincipals = null;\n+\n+    private static boolean secureBookieSideChannel = false;\n+    private static Collection<Object> secureBookieSideChannelPrincipals = null;\n+\n+\n+    public TestTLS() {\n+        super(3);\n+    }\n+\n+    @Before\n+    @Override\n+    public void setUp() throws Exception {\n+        /* client configuration */\n+        baseClientConf.setTLSProviderFactoryClass(TLSContextFactory.class.getName());\n+        baseClientConf.setTLSClientAuthentication(true);\n+        baseClientConf.setTLSKeyStoreType(\"JKS\");\n+        baseClientConf.setTLSKeyStore(this.getClass().getClassLoader().getResource(\"client.jks\").getPath());\n+        baseClientConf.setTLSKeyStorePasswordPath(\n+                this.getClass().getClassLoader().getResource(\"keyStoreClientPassword.txt\").getPath());\n+        baseClientConf.setTLSTrustStoreType(\"JKS\");\n+        baseClientConf.setTLSTrustStore(this.getClass().getClassLoader().getResource(\"cacerts\").getPath());\n+        baseClientConf.setTLSTrustStorePasswordPath(\n+                this.getClass().getClassLoader().getResource(\"trustStorePassword.txt\").getPath());\n+\n+        /* server configuration */\n+        baseConf.setTLSProviderFactoryClass(TLSContextFactory.class.getName());\n+        baseConf.setTLSClientAuthentication(true);\n+        baseConf.setTLSKeyStoreType(\"JKS\");\n+        baseConf.setTLSKeyStore(this.getClass().getClassLoader().getResource(\"server.jks\").getPath());\n+        baseConf.setTLSKeyStorePasswordPath(\n+                this.getClass().getClassLoader().getResource(\"keyStoreServerPassword.txt\").getPath());\n+        baseConf.setTLSTrustStoreType(\"JKS\");\n+        baseConf.setTLSTrustStore(this.getClass().getClassLoader().getResource(\"cacerts\").getPath());\n+        baseConf.setTLSTrustStorePasswordPath(\n+                this.getClass().getClassLoader().getResource(\"trustStorePassword.txt\").getPath());\n+\n+        super.setUp();\n+    }\n+\n+    @After\n+    @Override\n+    public void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+\n+    /**\n+     * Verify that a server will not start if tls is enabled but no cert is specified\n+     */\n+    @Test(timeout = 60000)\n+    public void testStartTLSServerNoKeyStore() throws Exception {\n+        ServerConfiguration bookieConf = newServerConfiguration().setTLSKeyStore(null);\n+\n+        try {\n+            bs.add(startBookie(bookieConf));\n+            fail(\"Shouldn't have been able to start\");\n+        } catch (SecurityException se) {\n+            assertTrue(true);\n+        }\n+    }\n+\n+    /**\n+     * Verify that a server will not start if tls is enabled but the cert password is incorrect\n+     */\n+    @Test(timeout = 60000)\n+    public void testStartTLSServerBadPassword() throws Exception {\n+        ServerConfiguration bookieConf = newServerConfiguration().setTLSKeyStorePasswordPath(\"badpassword\");\n+        try {\n+            bs.add(startBookie(bookieConf));\n+            fail(\"Shouldn't have been able to start\");\n+        } catch (SecurityException se) {\n+            assertTrue(true);\n+        }\n+    }\n+\n+    private LedgerMetadata testClient(ClientConfiguration conf, int clusterSize) throws Exception {\n+        try (BookKeeper client = new BookKeeper(conf);) {\n+            byte[] passwd = \"testPassword\".getBytes();\n+            int numEntries = 100;\n+            long lid;\n+            byte[] testEntry = \"testEntry\".getBytes();\n+            try (LedgerHandle lh = client.createLedger(clusterSize, clusterSize, DigestType.CRC32, passwd);) {\n+                for (int i = 0; i <= numEntries; i++) {\n+                    lh.addEntry(testEntry);\n+                }\n+                lid = lh.getId();\n+            }\n+            try (LedgerHandle lh = client.openLedger(lid, DigestType.CRC32, passwd);) {\n+                Enumeration<LedgerEntry> entries = lh.readEntries(0, numEntries);\n+                while (entries.hasMoreElements()) {\n+                    LedgerEntry e = entries.nextElement();\n+                    assertTrue(\"Entry contents incorrect\", Arrays.equals(e.getEntry(), testEntry));\n+                }\n+                BookKeeperAdmin admin = new BookKeeperAdmin(client);\n+                return admin.getLedgerMetadata(lh);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Verify the basic use of TLS. TLS client, TLS servers\n+     */\n+    @Test(timeout = 60000)\n+    public void testConnectToTLSClusterTLSClient() throws Exception {\n+        ClientConfiguration clientConf = new ClientConfiguration(baseClientConf);\n+        testClient(clientConf, numBookies);\n+    }\n+\n+\n+    /**\n+     * Multiple clients, some with TLS, and some without TLS\n+     */\n+    @Test(timeout = 60000)\n+    public void testConnectToTLSClusterMixedClient() throws Exception {\n+        ClientConfiguration confWithTLS = new ClientConfiguration(baseClientConf);\n+        testClient(confWithTLS, numBookies);\n+\n+        ClientConfiguration confNoTLS = new ClientConfiguration(baseClientConf);\n+        confNoTLS.setTLSProviderFactoryClass(null);\n+        testClient(confNoTLS, numBookies);\n+    }\n+\n+    /**\n+     * Verify the basic use of TLS. TLS client, TLS servers. No Mutual Authentication.\n+     */\n+    @Test(timeout = 60000)\n+    public void testConnectToTLSClusterTLSClientWithTLSNoAuthentication() throws Exception {\n+        ServerConfiguration serverConf = new ServerConfiguration(baseConf);\n+        serverConf.setTLSClientAuthentication(false);\n+        restartBookies(serverConf);\n+\n+        ClientConfiguration conf = new ClientConfiguration(baseClientConf);\n+        testClient(conf, numBookies);\n+    }\n+\n+    /**\n+     * Verify the basic use of TLS. TLS client, TLS servers with mutual Auth.\n+     */\n+    @Test(timeout = 60000)\n+    public void testConnectToTLSClusterTLSClientWithAuthentication() throws Exception {\n+        ClientConfiguration conf = new ClientConfiguration(baseClientConf);\n+        try {\n+            testClient(conf, numBookies);\n+        } catch (BKException.BKNotEnoughBookiesException nnbe) {\n+            fail(\"Client should be able to connect to bookie\");\n+        }\n+    }\n+\n+    /**\n+     * Verify that a client without tls enabled can connect to a cluster with TLS\n+     */\n+    @Test(timeout = 60000)\n+    public void testConnectToTLSClusterNonTLSClient() throws Exception {\n+        ClientConfiguration conf = new ClientConfiguration(baseClientConf);\n+        conf.setTLSProviderFactoryClass(null);\n+        try {\n+            testClient(conf, numBookies);\n+        } catch (BKException.BKNotEnoughBookiesException nnbe) {\n+            fail(\"non tls client should be able to connect to tls enabled bookies\");\n+        }\n+    }\n+\n+    /**\n+     * Verify that a client will fail to connect to a server if it has asked for TLS, but it is not available.\n+     */\n+    @Test(timeout = 60000)\n+    public void testClientWantsTLSNoServersHaveIt() throws Exception {\n+        ServerConfiguration serverConf = new ServerConfiguration(baseConf);\n+        serverConf.setTLSProviderFactoryClass(null);\n+        restartBookies(serverConf);\n+\n+        ClientConfiguration clientConf = new ClientConfiguration(baseClientConf);\n+        try {\n+            testClient(clientConf, numBookies);\n+            fail(\"Shouldn't be able to connect\");\n+        } catch (BKException.BKNotEnoughBookiesException nnbe) {\n+            // correct response\n+        }\n+    }\n+\n+    /**\n+     * Verify that a client will be able to connect to a bookie cluster if it has asked for TLS, and there are enough\n+     * bookies with TLS enabled in the cluster, although few bookies do not have TLS enabled.\n+     */\n+    @Test(timeout = 60000)\n+    public void testTLSClientButOnlyFewTLSServers() throws Exception {\n+        // disable TLS on initial set of bookies\n+        ServerConfiguration serverConf = new ServerConfiguration(baseConf);\n+        serverConf.setTLSProviderFactoryClass(null);\n+        restartBookies(serverConf);\n+\n+        // add two bookies which support TLS\n+        baseConf.setTLSProviderFactoryClass(TLSContextFactory.class.getName());\n+\n+        Set<Integer> tlsBookiePorts = new HashSet<>();\n+        tlsBookiePorts.add(startNewBookie());\n+        tlsBookiePorts.add(startNewBookie());\n+\n+        ClientConfiguration clientConf = new ClientConfiguration(baseClientConf);\n+        LedgerMetadata metadata = testClient(clientConf, 2);\n+        assertTrue(metadata.getEnsembles().size() > 0);\n+        Collection<ArrayList<BookieSocketAddress>> ensembles = metadata.getEnsembles().values();\n+        for (ArrayList<BookieSocketAddress> bookies : ensembles) {\n+            for (BookieSocketAddress bookieAddress : bookies) {\n+                int port = bookieAddress.getPort();\n+                assertTrue(tlsBookiePorts.contains(port));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Verify that a client-side Auth plugin can access server certificates\n+     */\n+    @Test(timeout = 60000)\n+    public void testClientAuthPlugin() throws Exception {\n+        secureClientSideChannel = false;\n+        secureClientSideChannelPrincipals = null;\n+        ClientConfiguration clientConf = new ClientConfiguration(baseClientConf);\n+\n+        clientConf.setClientAuthProviderFactoryClass(AllowOnlyBookiesWithX509Certificates.class.getName());\n+\n+        testClient(clientConf, numBookies);\n+        assertTrue(secureClientSideChannel);\n+        assertNotNull(secureClientSideChannelPrincipals);\n+        assertTrue(!secureClientSideChannelPrincipals.isEmpty());\n+        assertTrue(secureClientSideChannelPrincipals.iterator().next() instanceof Certificate);\n+        Certificate cert = (Certificate) secureClientSideChannelPrincipals.iterator().next();\n+        assertTrue(cert instanceof X509Certificate);\n+    }\n+\n+    /**\n+     * Verify that a bookie-side Auth plugin can access server certificates\n+     */\n+    @Test(timeout = 60000)\n+    public void testBookieAuthPluginRequireClientTLSAuthentication() throws Exception {\n+        ServerConfiguration serverConf = new ServerConfiguration(baseConf);\n+        serverConf.setBookieAuthProviderFactoryClass(AllowOnlyClientsWithX509Certificates.class.getName());\n+        restartBookies(serverConf);\n+\n+        secureBookieSideChannel = false;\n+        secureBookieSideChannelPrincipals = null;\n+        ClientConfiguration clientConf = new ClientConfiguration(baseClientConf);\n+\n+        testClient(clientConf, numBookies);\n+        assertTrue(secureBookieSideChannel);\n+        assertNotNull(secureBookieSideChannelPrincipals);\n+        assertTrue(!secureBookieSideChannelPrincipals.isEmpty());\n+        assertTrue(secureBookieSideChannelPrincipals.iterator().next() instanceof Certificate);\n+        Certificate cert = (Certificate) secureBookieSideChannelPrincipals.iterator().next();\n+        assertTrue(cert instanceof X509Certificate);\n+    }\n+\n+    /**\n+     * Verify that a bookie-side Auth plugin can access server certificates\n+     */\n+    @Test(timeout = 60000)\n+    public void testBookieAuthPluginDenyAccesstoClientWithoutTLSAuthentication() throws Exception {\n+        ServerConfiguration serverConf = new ServerConfiguration(baseConf);\n+        serverConf.setTLSClientAuthentication(false);\n+        serverConf.setBookieAuthProviderFactoryClass(AllowOnlyClientsWithX509Certificates.class.getName());\n+        restartBookies(serverConf);\n+\n+        secureBookieSideChannel = false;\n+        secureBookieSideChannelPrincipals = null;\n+        ClientConfiguration clientConf = new ClientConfiguration(baseClientConf);\n+        clientConf.setTLSClientAuthentication(false);\n+\n+        try {\n+            testClient(clientConf, numBookies);\n+            fail(\"Shouldn't be able to connect\");\n+        } catch (BKException.BKUnauthorizedAccessException authFailed) {\n+        }\n+\n+        assertTrue(secureBookieSideChannel);\n+        assertNotNull(secureBookieSideChannelPrincipals);\n+        assertTrue(secureBookieSideChannelPrincipals.isEmpty());\n+    }\n+\n+    /**\n+     * Verify that a bookie-side Auth plugin can access server certificates\n+     */\n+    @Test(timeout = 60000)\n+    public void testBookieAuthPluginDenyAccessToClientWithoutTLS() throws Exception {\n+        ServerConfiguration serverConf = new ServerConfiguration(baseConf);\n+        serverConf.setBookieAuthProviderFactoryClass(AllowOnlyClientsWithX509Certificates.class.getName());\n+        restartBookies(serverConf);\n+\n+        secureBookieSideChannel = false;\n+        secureBookieSideChannelPrincipals = null;\n+        ClientConfiguration clientConf = new ClientConfiguration(baseClientConf);\n+        clientConf.setTLSProviderFactoryClass(\"\");\n+\n+        try {\n+            testClient(clientConf, numBookies);\n+            fail(\"Shouldn't be able to connect\");\n+        } catch (BKException.BKUnauthorizedAccessException authFailed) {\n+        }\n+\n+        assertFalse(secureBookieSideChannel);\n+        assertNull(secureBookieSideChannelPrincipals);\n+    }\n+\n+    private static class AllowOnlyBookiesWithX509Certificates implements ClientAuthProvider.Factory {\n+\n+        @Override\n+        public String getPluginName() {\n+            return \"tls\";\n+        }\n+\n+        @Override\n+        public void init(ClientConfiguration conf) {\n+        }\n+\n+        @Override\n+        public ClientAuthProvider newProvider(ClientConnectionPeer addr,\n+                final AuthCallbacks.GenericCallback<Void> completeCb) {\n+            return new ClientAuthProvider() {\n+\n+                AuthCallbacks.GenericCallback<AuthToken> completeCallback;\n+\n+                @Override\n+                public void init(AuthCallbacks.GenericCallback<AuthToken> cb) {\n+                    this.completeCallback = cb;\n+                }\n+\n+                @Override\n+                public void onProtocolUpgrade() {\n+                    secureClientSideChannel = addr.isSecure();\n+                    secureClientSideChannelPrincipals = addr.getProtocolPrincipals();\n+                    Collection<Object> certificates = addr.getProtocolPrincipals();\n+                    if (addr.isSecure() && !certificates.isEmpty()) {\n+                        assertTrue(certificates.iterator().next() instanceof X509Certificate);\n+                        completeCallback.operationComplete(BKException.Code.OK, AuthToken.NULL);\n+                    } else {\n+                        completeCallback.operationComplete(BKException.Code.UnauthorizedAccessException,\n+                                AuthToken.NULL);\n+                    }\n+                }\n+\n+                @Override\n+                public void process(AuthToken m, AuthCallbacks.GenericCallback<AuthToken> cb) {\n+                }\n+            };\n+        }\n+    }\n+\n+    private static class AllowOnlyClientsWithX509Certificates implements BookieAuthProvider.Factory {\n+\n+        @Override\n+        public String getPluginName() {\n+            return \"tls\";\n+        }\n+\n+        @Override\n+        public void init(ServerConfiguration conf) throws IOException {\n+        }\n+\n+        @Override\n+        public BookieAuthProvider newProvider(BookieConnectionPeer addr,\n+                final AuthCallbacks.GenericCallback<Void> completeCb) {\n+            return new BookieAuthProvider() {\n+\n+                AuthCallbacks.GenericCallback<Void> completeCallback = completeCb;\n+\n+                @Override\n+                public void onProtocolUpgrade() {\n+                    secureBookieSideChannel = addr.isSecure();\n+                    secureBookieSideChannelPrincipals = addr.getProtocolPrincipals();\n+                    Collection<Object> certificates = addr.getProtocolPrincipals();\n+                    if (addr.isSecure() && !certificates.isEmpty()) {\n+                        assertTrue(certificates.iterator().next() instanceof X509Certificate);\n+                        completeCallback.operationComplete(BKException.Code.OK, null);\n+                    } else {\n+                        completeCallback.operationComplete(BKException.Code.UnauthorizedAccessException, null);\n+                    }\n+                }\n+\n+                @Override\n+                public void process(AuthToken m, AuthCallbacks.GenericCallback<AuthToken> cb) {\n+                }\n+            };\n+        }\n+    }\n+\n+    /**\n+     * Verify that a client will fail to connect to a server if it has asked for TLS, but it is not available. Verify\n+     * that if there are enough TLS servers to fill the ensemble, it will eventually use those rather than the non-TLS\n+     */\n+    @Test(timeout = 60000)\n+    public void testMixedCluster() throws Exception {\n+        ClientConfiguration clientConf = new ClientConfiguration(baseClientConf);\n+        int origNumBookies = numBookies;\n+\n+        ServerConfiguration bookieConf = newServerConfiguration();\n+        /*\n+        bookieConf.setTLSProviderFactoryClass(null);\n+        bs.add(startBookie(bookieConf));\n+        try {\n+            testClient(clientConf, origNumBookies + 1);\n+            fail(\"Shouldn't be able to connect\");\n+        } catch (BKException.BKNotEnoughBookiesException nnbe) {\n+            // correct response\n+        }\n+\n+        bookieConf = newServerConfiguration();\n+        */\n+        bookieConf.setTLSProviderFactoryClass(TLSContextFactory.class.getName());\n+        bs.add(startBookie(bookieConf));\n+        testClient(clientConf, origNumBookies + 1);\n+    }\n+\n+    /**\n+     * Verify that if the server hangs while an TLS client is trying to connect, the client can continue.\n+     */\n+    @Test(timeout = 60000)\n+    public void testHungServer() throws Exception {\n+        ClientConfiguration clientConf = new ClientConfiguration(baseClientConf);\n+        CountDownLatch latch = new CountDownLatch(1);\n+        sleepBookie(getBookie(0), latch);\n+        try {\n+            testClient(clientConf, numBookies);\n+            fail(\"Shouldn't be able to connect\");\n+        } catch (BKException.BKNotEnoughBookiesException nnbe) {\n+            // correct response\n+        }\n+        LOG.info(\"latch countdown\");\n+        latch.countDown();\n+    }\n+}"},{"sha":"5016b0c746ebf2fccde4a38e17fb4ccf9fef2604","filename":"bookkeeper-server/src/test/resources/cacerts","status":"added","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/8e0bd2c3d81b522e97434d8646915f36422a104b/bookkeeper-server%2Fsrc%2Ftest%2Fresources%2Fcacerts","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/8e0bd2c3d81b522e97434d8646915f36422a104b/bookkeeper-server%2Fsrc%2Ftest%2Fresources%2Fcacerts","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fresources%2Fcacerts?ref=8e0bd2c3d81b522e97434d8646915f36422a104b"},{"sha":"a959a9b82ad2f833819c2a7f473e203ac90fb425","filename":"bookkeeper-server/src/test/resources/client.jks","status":"added","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/8e0bd2c3d81b522e97434d8646915f36422a104b/bookkeeper-server%2Fsrc%2Ftest%2Fresources%2Fclient.jks","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/8e0bd2c3d81b522e97434d8646915f36422a104b/bookkeeper-server%2Fsrc%2Ftest%2Fresources%2Fclient.jks","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fresources%2Fclient.jks?ref=8e0bd2c3d81b522e97434d8646915f36422a104b"},{"sha":"b051c6c57fa8b6cc588a3ebad860005ec6fcf7cc","filename":"bookkeeper-server/src/test/resources/keyStoreClientPassword.txt","status":"added","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/8e0bd2c3d81b522e97434d8646915f36422a104b/bookkeeper-server%2Fsrc%2Ftest%2Fresources%2FkeyStoreClientPassword.txt","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/8e0bd2c3d81b522e97434d8646915f36422a104b/bookkeeper-server%2Fsrc%2Ftest%2Fresources%2FkeyStoreClientPassword.txt","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fresources%2FkeyStoreClientPassword.txt?ref=8e0bd2c3d81b522e97434d8646915f36422a104b","patch":"@@ -0,0 +1 @@\n+client"},{"sha":"254defddb53c57a8d2fb91f4d2c52b52bcd254a6","filename":"bookkeeper-server/src/test/resources/keyStoreServerPassword.txt","status":"added","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/8e0bd2c3d81b522e97434d8646915f36422a104b/bookkeeper-server%2Fsrc%2Ftest%2Fresources%2FkeyStoreServerPassword.txt","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/8e0bd2c3d81b522e97434d8646915f36422a104b/bookkeeper-server%2Fsrc%2Ftest%2Fresources%2FkeyStoreServerPassword.txt","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fresources%2FkeyStoreServerPassword.txt?ref=8e0bd2c3d81b522e97434d8646915f36422a104b","patch":"@@ -0,0 +1 @@\n+server"},{"sha":"aa582e6dd3f7f3addcc25ddb3c36a6dc689e0e13","filename":"bookkeeper-server/src/test/resources/server.jks","status":"added","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/8e0bd2c3d81b522e97434d8646915f36422a104b/bookkeeper-server%2Fsrc%2Ftest%2Fresources%2Fserver.jks","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/8e0bd2c3d81b522e97434d8646915f36422a104b/bookkeeper-server%2Fsrc%2Ftest%2Fresources%2Fserver.jks","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fresources%2Fserver.jks?ref=8e0bd2c3d81b522e97434d8646915f36422a104b"},{"sha":"1d40192aebffacab75d17e2c3f632d521910ad7d","filename":"bookkeeper-server/src/test/resources/trustStorePassword.txt","status":"added","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/8e0bd2c3d81b522e97434d8646915f36422a104b/bookkeeper-server%2Fsrc%2Ftest%2Fresources%2FtrustStorePassword.txt","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/8e0bd2c3d81b522e97434d8646915f36422a104b/bookkeeper-server%2Fsrc%2Ftest%2Fresources%2FtrustStorePassword.txt","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fresources%2FtrustStorePassword.txt?ref=8e0bd2c3d81b522e97434d8646915f36422a104b","patch":"@@ -0,0 +1 @@\n+changeit"},{"sha":"613c4cfc4af960dd260e9b4774f78d81fb9b5584","filename":"pom.xml","status":"modified","additions":3,"deletions":2,"changes":5,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/8e0bd2c3d81b522e97434d8646915f36422a104b/pom.xml","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/8e0bd2c3d81b522e97434d8646915f36422a104b/pom.xml","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/pom.xml?ref=8e0bd2c3d81b522e97434d8646915f36422a104b","patch":"@@ -96,8 +96,9 @@\n     <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n     <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n     <guava.version>20.0</guava.version>\n-    <netty.version>4.1.10.Final</netty.version>\n     <protobuf.version>2.6.1</protobuf.version>\n+    <netty.version>4.1.12.Final</netty.version>\n+    <netty-boringssl.version>2.0.3.Final</netty-boringssl.version>\n     <slf4j.version>1.7.25</slf4j.version>\n     <zookeeper.version>3.5.3-beta</zookeeper.version>\n     <!-- plugin dependencies -->\n@@ -303,7 +304,7 @@\n             <groupId>org.apache.maven.plugins</groupId>\n             <artifactId>maven-surefire-plugin</artifactId>\n             <configuration>\n-\t      <redirectTestOutputToFile>false</redirectTestOutputToFile>\n+\t      <redirectTestOutputToFile>true</redirectTestOutputToFile>\n             </configuration>\n \t  </plugin>\n \t</plugins>"}]}