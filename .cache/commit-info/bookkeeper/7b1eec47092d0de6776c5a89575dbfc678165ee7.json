{"sha":"7b1eec47092d0de6776c5a89575dbfc678165ee7","node_id":"MDY6Q29tbWl0NDc4NTkyNTI2OjdiMWVlYzQ3MDkyZDBkZTY3NzZjNWE4OTU3NWRiZmM2NzgxNjVlZTc=","commit":{"author":{"name":"Matteo Merli","email":"mmerli@yahoo-inc.com","date":"2017-05-25T12:23:03Z"},"committer":{"name":"eolivelli","email":"eolivelli@apache.org","date":"2017-05-25T12:23:03Z"},"message":"BOOKKEEPER-1068: Expose ByteBuf in LedgerEntry to avoid data copy\n\nTo avoid copying the entries payloads when writing/reading on a ledger and having to allocate a lot of `byte[]` on the JVM heap, we need to accept Netty ByteBuf buffer.\n\nBy passing a ByteBuf, an application can use a pooled buffer, pointing to direct memory, to the `LedgerHandle.addEntry()` and have the same buffer forwarded on the connection sockets to the bookies.\n\nThe same thing on the read side, `LedgerEntry` exposes an additional `getEntryBuffer()` method that can be used to get the underlying buffer and possibly forward that to some other connection, with zero-copy behavior (excluding getting data in-out of the kernel).\n\nAuthor: Matteo Merli <mmerli@yahoo-inc.com>\n\nReviewers: Jia Zhai, Sijie Guo, Enrico Olivelli\n\nCloses #155 from merlimat/byte-buf-ledger-entry","tree":{"sha":"135bfe763d01eba9dc3e2130ec6bbb470ce6b86e","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/trees/135bfe763d01eba9dc3e2130ec6bbb470ce6b86e"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/commits/7b1eec47092d0de6776c5a89575dbfc678165ee7","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/7b1eec47092d0de6776c5a89575dbfc678165ee7","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/7b1eec47092d0de6776c5a89575dbfc678165ee7","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/7b1eec47092d0de6776c5a89575dbfc678165ee7/comments","author":{"login":"merlimat","id":62500,"node_id":"MDQ6VXNlcjYyNTAw","avatar_url":"https://avatars.githubusercontent.com/u/62500?v=4","gravatar_id":"","url":"https://api.github.com/users/merlimat","html_url":"https://github.com/merlimat","followers_url":"https://api.github.com/users/merlimat/followers","following_url":"https://api.github.com/users/merlimat/following{/other_user}","gists_url":"https://api.github.com/users/merlimat/gists{/gist_id}","starred_url":"https://api.github.com/users/merlimat/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/merlimat/subscriptions","organizations_url":"https://api.github.com/users/merlimat/orgs","repos_url":"https://api.github.com/users/merlimat/repos","events_url":"https://api.github.com/users/merlimat/events{/privacy}","received_events_url":"https://api.github.com/users/merlimat/received_events","type":"User","site_admin":false},"committer":{"login":"eolivelli","id":9469110,"node_id":"MDQ6VXNlcjk0NjkxMTA=","avatar_url":"https://avatars.githubusercontent.com/u/9469110?v=4","gravatar_id":"","url":"https://api.github.com/users/eolivelli","html_url":"https://github.com/eolivelli","followers_url":"https://api.github.com/users/eolivelli/followers","following_url":"https://api.github.com/users/eolivelli/following{/other_user}","gists_url":"https://api.github.com/users/eolivelli/gists{/gist_id}","starred_url":"https://api.github.com/users/eolivelli/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/eolivelli/subscriptions","organizations_url":"https://api.github.com/users/eolivelli/orgs","repos_url":"https://api.github.com/users/eolivelli/repos","events_url":"https://api.github.com/users/eolivelli/events{/privacy}","received_events_url":"https://api.github.com/users/eolivelli/received_events","type":"User","site_admin":false},"parents":[{"sha":"8ba8ab9403dbc464c68caf6e7cd3fc490670731e","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/8ba8ab9403dbc464c68caf6e7cd3fc490670731e","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/8ba8ab9403dbc464c68caf6e7cd3fc490670731e"}],"stats":{"total":130,"additions":62,"deletions":68},"files":[{"sha":"ac28a153be9a6bea2246d422a16c9d5bad6f2255","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/DigestManager.java","status":"modified","additions":5,"deletions":10,"changes":15,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/7b1eec47092d0de6776c5a89575dbfc678165ee7/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FDigestManager.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/7b1eec47092d0de6776c5a89575dbfc678165ee7/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FDigestManager.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FDigestManager.java?ref=7b1eec47092d0de6776c5a89575dbfc678165ee7","patch":"@@ -19,7 +19,6 @@\n  */\n \n import io.netty.buffer.ByteBuf;\n-import io.netty.buffer.ByteBufInputStream;\n import io.netty.buffer.PooledByteBufAllocator;\n import io.netty.buffer.Unpooled;\n \n@@ -83,22 +82,18 @@ static DigestManager instantiate(long ledgerId, byte[] passwd, DigestType digest\n      * @param data\n      * @return\n      */\n-\n-    public ByteBuf computeDigestAndPackageForSending(long entryId, long lastAddConfirmed, long length, byte[] data,\n-            int doffset, int dlength) {\n+    public ByteBuf computeDigestAndPackageForSending(long entryId, long lastAddConfirmed, long length, ByteBuf data) {\n         ByteBuf headersBuffer = PooledByteBufAllocator.DEFAULT.buffer(METADATA_LENGTH + macCodeLength);\n         headersBuffer.writeLong(ledgerId);\n         headersBuffer.writeLong(entryId);\n         headersBuffer.writeLong(lastAddConfirmed);\n         headersBuffer.writeLong(length);\n \n-        ByteBuf dataBuffer = Unpooled.wrappedBuffer(data, doffset, dlength);\n-\n         update(headersBuffer);\n-        update(dataBuffer);\n+        update(data);\n         populateValueAndReset(headersBuffer);\n \n-        return DoubleByteBuf.get(headersBuffer, dataBuffer);\n+        return DoubleByteBuf.get(headersBuffer, data);\n     }\n \n     /**\n@@ -212,11 +207,11 @@ long verifyDigestAndReturnLac(ByteBuf dataReceived) throws BKDigestMatchExceptio\n      * @return\n      * @throws BKDigestMatchException\n      */\n-    ByteBufInputStream verifyDigestAndReturnData(long entryId, ByteBuf dataReceived)\n+    ByteBuf verifyDigestAndReturnData(long entryId, ByteBuf dataReceived)\n             throws BKDigestMatchException {\n         verifyDigest(entryId, dataReceived);\n         dataReceived.readerIndex(METADATA_LENGTH + macCodeLength);\n-        return new ByteBufInputStream(dataReceived);\n+        return dataReceived;\n     }\n \n     static class RecoveryData {"},{"sha":"c01ec543b0cb2b393a8189b11aa026299fce2337","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerEntry.java","status":"modified","additions":17,"deletions":22,"changes":39,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/7b1eec47092d0de6776c5a89575dbfc678165ee7/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FLedgerEntry.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/7b1eec47092d0de6776c5a89575dbfc678165ee7/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FLedgerEntry.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FLedgerEntry.java?ref=7b1eec47092d0de6776c5a89575dbfc678165ee7","patch":"@@ -21,27 +21,22 @@\n  *\n  */\n \n+import io.netty.buffer.ByteBuf;\n import io.netty.buffer.ByteBufInputStream;\n \n-import java.io.IOException;\n import java.io.InputStream;\n \n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n /**\n  * Ledger entry. Its a simple tuple containing the ledger id, the entry-id, and\n  * the entry content.\n  *\n  */\n \n public class LedgerEntry {\n-    private final static Logger LOG = LoggerFactory.getLogger(LedgerEntry.class);\n-\n     long ledgerId;\n     long entryId;\n     long length;\n-    ByteBufInputStream entryDataStream;\n+    ByteBuf data;\n \n     LedgerEntry(long lId, long eId) {\n         this.ledgerId = lId;\n@@ -61,23 +56,23 @@ public long getLength() {\n     }\n \n     public byte[] getEntry() {\n-        try {\n-            // In general, you can't rely on the available() method of an input\n-            // stream, but ChannelBufferInputStream is backed by a byte[] so it\n-            // accurately knows the # bytes available\n-            byte[] ret = new byte[entryDataStream.available()];\n-            entryDataStream.readFully(ret);\n-            return ret;\n-        } catch (IOException e) {\n-            // The channelbufferinput stream doesnt really throw the\n-            // ioexceptions, it just has to be in the signature because\n-            // InputStream says so. Hence this code, should never be reached.\n-            LOG.error(\"Unexpected IOException while reading from channel buffer\", e);\n-            return new byte[0];\n-        }\n+        byte[] entry = new byte[data.readableBytes()];\n+        data.readBytes(entry);\n+        data.release();\n+        return entry;\n     }\n \n     public InputStream getEntryInputStream() {\n-        return entryDataStream;\n+        return new ByteBufInputStream(data);\n+    }\n+\n+    /**\n+     * Return the internal buffer that contains the entry payload.\n+     * <p>\n+     *\n+     * Note: It is responsibility of the caller to ensure to release the buffer after usage.\n+     */\n+    public ByteBuf getEntryBuffer() {\n+        return data;\n     }\n }"},{"sha":"fe1104a17691429ca6e2b26d5829f3387d95df91","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerFragmentReplicator.java","status":"modified","additions":2,"deletions":1,"changes":3,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/7b1eec47092d0de6776c5a89575dbfc678165ee7/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FLedgerFragmentReplicator.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/7b1eec47092d0de6776c5a89575dbfc678165ee7/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FLedgerFragmentReplicator.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FLedgerFragmentReplicator.java?ref=7b1eec47092d0de6776c5a89575dbfc678165ee7","patch":"@@ -20,6 +20,7 @@\n package org.apache.bookkeeper.client;\n \n import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n \n import java.util.ArrayList;\n import java.util.Enumeration;\n@@ -284,7 +285,7 @@ public void readComplete(int rc, LedgerHandle lh,\n                 ByteBuf toSend = lh.getDigestManager()\n                         .computeDigestAndPackageForSending(entryId,\n                                 lh.getLastAddConfirmed(), entry.getLength(),\n-                                data, 0, data.length);\n+                                Unpooled.wrappedBuffer(data, 0, data.length));\n                 bkc.getBookieClient().addEntry(newBookie, lh.getId(),\n                         lh.getLedgerKey(), entryId, toSend,\n                         new WriteCallback() {"},{"sha":"f875923df024001f5aae9c828eea45b438909333","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","status":"modified","additions":20,"deletions":15,"changes":35,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/7b1eec47092d0de6776c5a89575dbfc678165ee7/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FLedgerHandle.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/7b1eec47092d0de6776c5a89575dbfc678165ee7/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FLedgerHandle.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FLedgerHandle.java?ref=7b1eec47092d0de6776c5a89575dbfc678165ee7","patch":"@@ -22,6 +22,7 @@\n \n import static com.google.common.base.Charsets.UTF_8;\n import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n \n import java.security.GeneralSecurityException;\n import java.security.NoSuchAlgorithmException;\n@@ -722,8 +723,21 @@ public void asyncAddEntry(final long entryId, final byte[] data, final AddCallba\n      */\n     public void asyncAddEntry(final byte[] data, final int offset, final int length,\n                               final AddCallback cb, final Object ctx) {\n+        if (offset < 0 || length < 0\n+                || (offset + length) > data.length) {\n+            throw new ArrayIndexOutOfBoundsException(\n+                    \"Invalid values for offset(\"+offset\n+                    +\") or length(\"+length+\")\");\n+        }\n+\n+        PendingAddOp op = new PendingAddOp(LedgerHandle.this, cb, ctx);\n+        doAsyncAddEntry(op, Unpooled.wrappedBuffer(data, offset, length), cb, ctx);\n+    }\n+\n+    public void asyncAddEntry(ByteBuf data, final AddCallback cb, final Object ctx) {\n+        data.retain();\n         PendingAddOp op = new PendingAddOp(LedgerHandle.this, cb, ctx);\n-        doAsyncAddEntry(op, data, offset, length, cb, ctx);\n+        doAsyncAddEntry(op, data, cb, ctx);\n     }\n \n     /**\n@@ -765,19 +779,10 @@ public void asyncAddEntry(final long entryId, final byte[] data, final int offse\n     void asyncRecoveryAddEntry(final byte[] data, final int offset, final int length,\n                                final AddCallback cb, final Object ctx) {\n         PendingAddOp op = new PendingAddOp(LedgerHandle.this, cb, ctx).enableRecoveryAdd();\n-        doAsyncAddEntry(op, data, offset, length, cb, ctx);\n+        doAsyncAddEntry(op, Unpooled.wrappedBuffer(data, offset, length), cb, ctx);\n     }\n \n-    void doAsyncAddEntry(final PendingAddOp op, final byte[] data, final int offset, final int length,\n-                         final AddCallback cb, final Object ctx) {\n-\n-        if (offset < 0 || length < 0\n-                || (offset + length) > data.length) {\n-            throw new ArrayIndexOutOfBoundsException(\n-                    \"Invalid values for offset(\" +offset\n-                    +\") or length(\"+length+\")\");\n-        }\n-\n+    protected void doAsyncAddEntry(final PendingAddOp op, final ByteBuf data, final AddCallback cb, final Object ctx) {\n         if (throttler != null) {\n             throttler.acquire();\n         }\n@@ -795,7 +800,7 @@ void doAsyncAddEntry(final PendingAddOp op, final byte[] data, final int offset,\n                 currentLength = 0;\n             } else {\n                 entryId = ++lastAddPushed;\n-                currentLength = addToLength(length);\n+                currentLength = addToLength(data.readableBytes());\n                 op.setEntryId(entryId);\n                 pendingAddOps.add(op);\n             }\n@@ -829,9 +834,9 @@ public String toString() {\n                 @Override\n                 public void safeRun() {\n                     ByteBuf toSend = macManager.computeDigestAndPackageForSending(entryId, lastAddConfirmed,\n-                            currentLength, data, offset, length);\n+                            currentLength, data);\n                     try {\n-                        op.initiate(toSend, length);\n+                        op.initiate(toSend, data.readableBytes());\n                     } finally {\n                         toSend.release();\n                     }"},{"sha":"f971b75802fd49b3079f0c302fe40da30cf8c214","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandleAdv.java","status":"modified","additions":11,"deletions":14,"changes":25,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/7b1eec47092d0de6776c5a89575dbfc678165ee7/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FLedgerHandleAdv.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/7b1eec47092d0de6776c5a89575dbfc678165ee7/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FLedgerHandleAdv.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FLedgerHandleAdv.java?ref=7b1eec47092d0de6776c5a89575dbfc678165ee7","patch":"@@ -36,6 +36,7 @@\n import org.slf4j.LoggerFactory;\n \n import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n \n /**\n  * Ledger Advanced handle extends {@link LedgerHandle} to provide API to add entries with\n@@ -151,8 +152,8 @@ public void asyncAddEntry(final long entryId, final byte[] data, final int offse\n             cb.addComplete(BKException.Code.DuplicateEntryIdException,\n                     LedgerHandleAdv.this, entryId, ctx);\n             return;\n-        }       \n-        doAsyncAddEntry(op, data, offset, length, cb, ctx);\n+        }\n+        doAsyncAddEntry(op, Unpooled.wrappedBuffer(data, offset, length), cb, ctx);\n     }\n \n     /**\n@@ -161,14 +162,7 @@ public void asyncAddEntry(final long entryId, final byte[] data, final int offse\n      * unaltered in the base class.\n      */\n     @Override\n-    void doAsyncAddEntry(final PendingAddOp op, final byte[] data, final int offset, final int length,\n-            final AddCallback cb, final Object ctx) {\n-        if (offset < 0 || length < 0\n-                || (offset + length) > data.length) {\n-            throw new ArrayIndexOutOfBoundsException(\n-                \"Invalid values for offset(\"+offset\n-                +\") or length(\"+length+\")\");\n-        }\n+    protected void doAsyncAddEntry(final PendingAddOp op, final ByteBuf data, final AddCallback cb, final Object ctx) {\n         if (throttler != null) {\n             throttler.acquire();\n         }\n@@ -214,10 +208,13 @@ public String toString() {\n             bk.mainWorkerPool.submit(new SafeRunnable() {\n                 @Override\n                 public void safeRun() {\n-                    ByteBuf toSend = macManager.computeDigestAndPackageForSending(\n-                                               op.getEntryId(), lastAddConfirmed, currentLength, data, offset, length);\n-                    op.initiate(toSend, length);\n-                    toSend.release();\n+                    ByteBuf toSend = macManager.computeDigestAndPackageForSending(op.getEntryId(), lastAddConfirmed,\n+                            currentLength, data);\n+                    try {\n+                        op.initiate(toSend, toSend.readableBytes());\n+                    } finally {\n+                        toSend.release();\n+                    }\n                 }\n             });\n         } catch (RejectedExecutionException e) {"},{"sha":"da15aab11d236a8a9a3a28b0b01809fd8b035ff7","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingReadOp.java","status":"modified","additions":5,"deletions":5,"changes":10,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/7b1eec47092d0de6776c5a89575dbfc678165ee7/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FPendingReadOp.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/7b1eec47092d0de6776c5a89575dbfc678165ee7/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FPendingReadOp.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FPendingReadOp.java?ref=7b1eec47092d0de6776c5a89575dbfc678165ee7","patch":"@@ -21,7 +21,6 @@\n package org.apache.bookkeeper.client;\n \n import io.netty.buffer.ByteBuf;\n-import io.netty.buffer.ByteBufInputStream;\n \n import java.util.ArrayList;\n import java.util.BitSet;\n@@ -223,24 +222,25 @@ synchronized void logErrorAndReattemptRead(BookieSocketAddress host, String errM\n         // return true if we managed to complete the entry\n         // return false if the read entry is not complete or it is already completed before\n         boolean complete(BookieSocketAddress host, final ByteBuf buffer) {\n-            ByteBufInputStream is;\n+            ByteBuf content;\n             try {\n-                is = lh.macManager.verifyDigestAndReturnData(entryId, buffer);\n+                content = lh.macManager.verifyDigestAndReturnData(entryId, buffer);\n             } catch (BKDigestMatchException e) {\n                 logErrorAndReattemptRead(host, \"Mac mismatch\", BKException.Code.DigestMatchException);\n+                buffer.release();\n                 return false;\n             }\n \n             if (!complete.getAndSet(true)) {\n-                entryDataStream = is;\n-\n                 /*\n                  * The length is a long and it is the last field of the metadata of an entry.\n                  * Consequently, we have to subtract 8 from METADATA_LENGTH to get the length.\n                  */\n                 length = buffer.getLong(DigestManager.METADATA_LENGTH - 8);\n+                data = content;\n                 return true;\n             } else {\n+                buffer.release();\n                 return false;\n             }\n         }"},{"sha":"d1ebef25f48f60ef7edadd059debcdcb9795763e","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/ClientUtil.java","status":"modified","additions":2,"deletions":1,"changes":3,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/7b1eec47092d0de6776c5a89575dbfc678165ee7/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FClientUtil.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/7b1eec47092d0de6776c5a89575dbfc678165ee7/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FClientUtil.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FClientUtil.java?ref=7b1eec47092d0de6776c5a89575dbfc678165ee7","patch":"@@ -18,6 +18,7 @@\n package org.apache.bookkeeper.client;\n \n import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n \n public class ClientUtil {\n     public static ByteBuf generatePacket(long ledgerId, long entryId, long lastAddConfirmed,\n@@ -29,7 +30,7 @@ public static ByteBuf generatePacket(long ledgerId, long entryId, long lastAddCo\n                                                long length, byte[] data, int offset, int len) {\n         CRC32DigestManager dm = new CRC32DigestManager(ledgerId);\n         return dm.computeDigestAndPackageForSending(entryId, lastAddConfirmed, length,\n-                                                    data, offset, len);\n+                                                    Unpooled.wrappedBuffer(data, offset, len));\n     }\n \n     /** Returns that whether ledger is in open state */"}]}