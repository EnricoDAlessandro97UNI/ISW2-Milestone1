{"sha":"b59d63e8be237e80872f73d92a31b4213d9a649b","node_id":"MDY6Q29tbWl0NDc4NTkyNTI2OmI1OWQ2M2U4YmUyMzdlODA4NzJmNzNkOTJhMzFiNDIxM2Q5YTY0OWI=","commit":{"author":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2017-07-04T06:24:28Z"},"committer":{"name":"Enrico Olivelli","email":"eolivelli@apache.org","date":"2017-07-04T06:24:28Z"},"message":"Add missed tests for SortedLedgerStorage\n\nAdded two missed tests for SortedLedgerStorage. It was missed when we (twitter) merged the SortedLedgerStorage back.\n\nAuthor: Sijie Guo <sijie@apache.org>\n\nReviewers: Enrico Olivelli, Jia Zhai\n\nThis closes #227 from sijie/more_memory_table_related_tests","tree":{"sha":"23bba80d94ac2e93e09f5281d43fd29d5d4b0fbd","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/trees/23bba80d94ac2e93e09f5281d43fd29d5d4b0fbd"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/commits/b59d63e8be237e80872f73d92a31b4213d9a649b","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/b59d63e8be237e80872f73d92a31b4213d9a649b","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/b59d63e8be237e80872f73d92a31b4213d9a649b","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/b59d63e8be237e80872f73d92a31b4213d9a649b/comments","author":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"committer":{"login":"eolivelli","id":9469110,"node_id":"MDQ6VXNlcjk0NjkxMTA=","avatar_url":"https://avatars.githubusercontent.com/u/9469110?v=4","gravatar_id":"","url":"https://api.github.com/users/eolivelli","html_url":"https://github.com/eolivelli","followers_url":"https://api.github.com/users/eolivelli/followers","following_url":"https://api.github.com/users/eolivelli/following{/other_user}","gists_url":"https://api.github.com/users/eolivelli/gists{/gist_id}","starred_url":"https://api.github.com/users/eolivelli/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/eolivelli/subscriptions","organizations_url":"https://api.github.com/users/eolivelli/orgs","repos_url":"https://api.github.com/users/eolivelli/repos","events_url":"https://api.github.com/users/eolivelli/events{/privacy}","received_events_url":"https://api.github.com/users/eolivelli/received_events","type":"User","site_admin":false},"parents":[{"sha":"ee0dddee6849d1968500af666571df668d34393a","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/ee0dddee6849d1968500af666571df668d34393a","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/ee0dddee6849d1968500af666571df668d34393a"}],"stats":{"total":467,"additions":467,"deletions":0},"files":[{"sha":"7aa2850fbe67ff9bc472fe317e41fa00742b84e2","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LogMark.java","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b59d63e8be237e80872f73d92a31b4213d9a649b/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLogMark.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b59d63e8be237e80872f73d92a31b4213d9a649b/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLogMark.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLogMark.java?ref=b59d63e8be237e80872f73d92a31b4213d9a649b","patch":"@@ -28,6 +28,8 @@ class LogMark {\n     long logFileId;\n     long logFileOffset;\n \n+    public static final LogMark MAX_VALUE = new LogMark(Long.MAX_VALUE, Long.MAX_VALUE);\n+\n     public LogMark() {\n         setLogMark(0, 0);\n     }"},{"sha":"0ca108e1e55ad054d3c5c90205648fb9b29a8156","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/TestEntryMemTable.java","status":"added","additions":263,"deletions":0,"changes":263,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b59d63e8be237e80872f73d92a31b4213d9a649b/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FTestEntryMemTable.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b59d63e8be237e80872f73d92a31b4213d9a649b/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FTestEntryMemTable.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FTestEntryMemTable.java?ref=b59d63e8be237e80872f73d92a31b4213d9a649b","patch":"@@ -0,0 +1,263 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.bookkeeper.bookie;\n+\n+import static org.junit.Assert.*;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.HashSet;\n+\n+import org.apache.bookkeeper.bookie.Bookie.NoLedgerException;\n+import org.apache.bookkeeper.conf.TestBKConfiguration;\n+import org.apache.bookkeeper.stats.NullStatsLogger;\n+import org.junit.Test;\n+import org.junit.Before;\n+import java.nio.ByteBuffer;\n+import java.util.Random;\n+\n+public class TestEntryMemTable implements CacheCallback, SkipListFlusher, CheckpointSource {\n+\n+    private EntryMemTable memTable;\n+    private final Random random = new Random();\n+    private TestCheckPoint curCheckpoint = new TestCheckPoint(0, 0);\n+\n+    @Override\n+    public Checkpoint newCheckpoint() {\n+        return curCheckpoint;\n+    }\n+\n+    @Override\n+    public void checkpointComplete(Checkpoint checkpoint, boolean compact)\n+            throws IOException {\n+    }\n+\n+    @Before\n+    public void setUp() throws Exception {\n+        this.memTable = new EntryMemTable(TestBKConfiguration.newServerConfiguration(),\n+                this, NullStatsLogger.INSTANCE);\n+    }\n+\n+    @Test\n+    public void testLogMark() throws IOException {\n+        LogMark mark = new LogMark();\n+        assertTrue(mark.compare(new LogMark()) == 0);\n+        assertTrue(mark.compare(LogMark.MAX_VALUE) < 0);\n+        mark.setLogMark(3, 11);\n+        byte[] data = new byte[16];\n+        ByteBuffer buf = ByteBuffer.wrap(data);\n+        mark.writeLogMark(buf);\n+        buf.flip();\n+        LogMark mark1 = new LogMark(9, 13);\n+        assertTrue(mark1.compare(mark) > 0);\n+        mark1.readLogMark(buf);\n+        assertTrue(mark1.compare(mark) == 0);\n+    }\n+\n+    /**\n+     * Basic put/get\n+     * @throws IOException\n+     * */\n+    @Test\n+    public void testBasicOps() throws IOException {\n+        long ledgerId = 1;\n+        long entryId = 1;\n+        byte[] data = new byte[10];\n+        random.nextBytes(data);\n+        ByteBuffer buf = ByteBuffer.wrap(data);\n+        memTable.addEntry(ledgerId, entryId, buf, this);\n+        buf.rewind();\n+        EntryKeyValue kv = memTable.getEntry(ledgerId, entryId);\n+        assertTrue(kv.getLedgerId() == ledgerId);\n+        assertTrue(kv.getEntryId() == entryId);\n+        assertTrue(kv.getValueAsByteBuffer().nioBuffer().equals(buf));\n+        memTable.flush(this);\n+    }\n+\n+    @Override\n+    public void onSizeLimitReached() throws IOException {\n+        // No-op\n+    }\n+\n+    public void process(long ledgerId, long entryId, ByteBuffer entry)\n+            throws IOException {\n+        // No-op\n+    }\n+\n+    /**\n+     * Test read/write across snapshot\n+     * @throws IOException\n+     */\n+    @Test\n+    public void testScanAcrossSnapshot() throws IOException {\n+        byte[] data = new byte[10];\n+        List<EntryKeyValue> keyValues = new ArrayList<EntryKeyValue>();\n+        for (long entryId = 1; entryId < 100; entryId++) {\n+            for (long ledgerId = 1; ledgerId < 3; ledgerId++) {\n+                random.nextBytes(data);\n+                memTable.addEntry(ledgerId, entryId, ByteBuffer.wrap(data), this);\n+                keyValues.add(memTable.getEntry(ledgerId, entryId));\n+                if (random.nextInt(16) == 0) {\n+                    memTable.snapshot();\n+                }\n+            }\n+        }\n+\n+        for (EntryKeyValue kv : keyValues) {\n+            assertTrue(memTable.getEntry(kv.getLedgerId(), kv.getEntryId()).equals(kv));\n+        }\n+        memTable.flush(this, Checkpoint.MAX);\n+    }\n+\n+    private class KVFLusher implements SkipListFlusher {\n+        final HashSet<EntryKeyValue> keyValues;\n+\n+        KVFLusher(final HashSet<EntryKeyValue> keyValues) {\n+            this.keyValues = keyValues;\n+        }\n+\n+        @Override\n+        public void process(long ledgerId, long entryId, ByteBuffer entry) throws IOException {\n+            assertTrue(ledgerId + \":\" + entryId + \" is duplicate in store!\",\n+                    keyValues.add(new EntryKeyValue(ledgerId, entryId, entry.array())));\n+        }\n+    }\n+\n+    private class NoLedgerFLusher implements SkipListFlusher {\n+        @Override\n+        public void process(long ledgerId, long entryId, ByteBuffer entry) throws IOException {\n+            throw new NoLedgerException(ledgerId);\n+        }\n+    }\n+\n+    /**\n+     * Test flush w/ logMark parameter\n+     * @throws IOException\n+     */\n+    @Test\n+    public void testFlushLogMark() throws IOException {\n+        HashSet<EntryKeyValue> flushedKVs = new HashSet<EntryKeyValue>();\n+        KVFLusher flusher = new KVFLusher(flushedKVs);\n+\n+        curCheckpoint.setCheckPoint(2, 2);\n+\n+        byte[] data = new byte[10];\n+        long ledgerId = 100;\n+        for (long entryId = 1; entryId < 100; entryId++) {\n+            random.nextBytes(data);\n+            memTable.addEntry(ledgerId, entryId, ByteBuffer.wrap(data), this);\n+        }\n+\n+        assertNull(memTable.snapshot(new TestCheckPoint(1, 1)));\n+        assertNotNull(memTable.snapshot(new TestCheckPoint(3, 3)));\n+\n+        assertTrue(0 < memTable.flush(flusher));\n+        assertTrue(0 == memTable.flush(flusher));\n+\n+        curCheckpoint.setCheckPoint(4, 4);\n+\n+        random.nextBytes(data);\n+        memTable.addEntry(ledgerId, 101, ByteBuffer.wrap(data), this);\n+        assertTrue(0 == memTable.flush(flusher));\n+\n+        assertTrue(0 == memTable.flush(flusher, new TestCheckPoint(3, 3)));\n+        assertTrue(0 < memTable.flush(flusher, new TestCheckPoint(4, 5)));\n+    }\n+\n+    /**\n+     * Test snapshot/flush interaction\n+     * @throws IOException\n+     */\n+    @Test\n+    public void testFlushSnapshot() throws IOException {\n+        HashSet<EntryKeyValue> keyValues = new HashSet<EntryKeyValue>();\n+        HashSet<EntryKeyValue> flushedKVs = new HashSet<EntryKeyValue>();\n+        KVFLusher flusher = new KVFLusher(flushedKVs);\n+\n+        byte[] data = new byte[10];\n+        for (long entryId = 1; entryId < 100; entryId++) {\n+            for (long ledgerId = 1; ledgerId < 100; ledgerId++) {\n+                random.nextBytes(data);\n+                assertTrue(ledgerId + \":\" + entryId + \" is duplicate in mem-table!\",\n+                        memTable.addEntry(ledgerId, entryId, ByteBuffer.wrap(data), this) != 0);\n+                assertTrue(ledgerId + \":\" + entryId + \" is duplicate in hash-set!\",\n+                        keyValues.add(memTable.getEntry(ledgerId, entryId)));\n+                if (random.nextInt(16) == 0) {\n+                    if (null != memTable.snapshot()) {\n+                        if (random.nextInt(2) == 0) {\n+                            memTable.flush(flusher);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        memTable.flush(flusher, Checkpoint.MAX);\n+        for (EntryKeyValue kv : keyValues) {\n+            assertTrue(\"kv \" + kv.toString() + \" was not flushed!\", flushedKVs.contains(kv));\n+        }\n+    }\n+\n+    /**\n+     * Test NoLedger exception/flush interaction\n+     * @throws IOException\n+     */\n+    @Test\n+    public void testNoLedgerException() throws IOException {\n+        NoLedgerFLusher flusher = new NoLedgerFLusher();\n+\n+        byte[] data = new byte[10];\n+        for (long entryId = 1; entryId < 100; entryId++) {\n+            for (long ledgerId = 1; ledgerId < 100; ledgerId++) {\n+                random.nextBytes(data);\n+                if (random.nextInt(16) == 0) {\n+                    if (null != memTable.snapshot()) {\n+                        memTable.flush(flusher);\n+                    }\n+                }\n+            }\n+        }\n+\n+        memTable.flush(flusher, Checkpoint.MAX);\n+    }\n+\n+    private static class TestCheckPoint implements Checkpoint {\n+\n+        LogMark mark;\n+\n+        public TestCheckPoint(long fid, long fpos) {\n+            mark = new LogMark(fid, fpos);\n+        }\n+\n+        private void setCheckPoint(long fid, long fpos) {\n+            mark.setLogMark(fid, fpos);\n+        }\n+\n+        @Override\n+        public int compareTo(Checkpoint o) {\n+            if (Checkpoint.MAX == o) {\n+                return -1;\n+            }\n+            return mark.compare(((TestCheckPoint)o).mark);\n+        }\n+\n+    }\n+}\n+"},{"sha":"e42eacc98339cab1f11d0657f82e4d2dd2808df7","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/bookie/TestSkipListArena.java","status":"added","additions":202,"deletions":0,"changes":202,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b59d63e8be237e80872f73d92a31b4213d9a649b/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FTestSkipListArena.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b59d63e8be237e80872f73d92a31b4213d9a649b/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FTestSkipListArena.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FTestSkipListArena.java?ref=b59d63e8be237e80872f73d92a31b4213d9a649b","patch":"@@ -0,0 +1,202 @@\n+/**\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.bookkeeper.bookie;\n+\n+import static org.junit.Assert.*;\n+\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.CountDownLatch;\n+\n+import org.apache.bookkeeper.conf.ServerConfiguration;\n+import org.apache.bookkeeper.bookie.SkipListArena.MemorySlice;\n+import org.junit.Test;\n+\n+import java.util.Set;\n+import java.util.HashSet;\n+import java.util.HashMap;\n+import java.util.TreeMap;\n+import com.google.common.primitives.Ints;\n+\n+public class TestSkipListArena {\n+\n+    class CustomConfiguration extends ServerConfiguration {\n+        @Override\n+        public int getSkipListArenaChunkSize() {\n+            return 4096;\n+        }\n+        @Override\n+        public int getSkipListArenaMaxAllocSize() {\n+            return 1024;\n+        }\n+        @Override\n+        public boolean getJournalFlushWhenQueueEmpty() {\n+            return true;\n+        }\n+\n+    }\n+\n+    final CustomConfiguration cfg = new CustomConfiguration();\n+\n+    /**\n+    * Test random allocations\n+    */\n+    @Test\n+    public void testRandomAllocation() {\n+        Random rand = new Random();\n+        SkipListArena arena = new SkipListArena(cfg);\n+        int expectedOff = 0;\n+        byte[] lastBuffer = null;\n+\n+        // 10K iterations by 0-512 alloc -> 2560kB expected\n+        // should be reasonable for unit test and also cover wraparound\n+        // behavior\n+        for (int i = 0; i < 10000; i++) {\n+            int size = rand.nextInt(512);\n+            MemorySlice alloc = arena.allocateBytes(size);\n+\n+            if (alloc.getData() != lastBuffer) {\n+                expectedOff = 0;\n+                lastBuffer = alloc.getData();\n+            }\n+            assertTrue(expectedOff == alloc.getOffset());\n+            assertTrue(\"Allocation \" + alloc + \" overruns buffer\",\n+              alloc.getOffset() + size <= alloc.getData().length);\n+            expectedOff += size;\n+        }\n+    }\n+\n+    @Test\n+    public void testLargeAllocation() {\n+        SkipListArena arena = new SkipListArena(cfg);\n+        MemorySlice alloc = arena.allocateBytes(1024 + 1024);\n+        assertNull(\"2KB allocation shouldn't be satisfied by LAB.\", alloc);\n+    }\n+\n+    private class ByteArray {\n+        final byte[] bytes;\n+        ByteArray(final byte[] bytes) {\n+            this.bytes = bytes;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return bytes.hashCode();\n+        }\n+\n+        @Override\n+        public boolean equals(Object object) {\n+            if (object instanceof ByteArray) {\n+                ByteArray other = (ByteArray)object;\n+                return this.bytes.equals(other.bytes);\n+            }\n+            return false;\n+        }\n+    }\n+\n+    private static class AllocBuffer implements Comparable<AllocBuffer>{\n+        private final MemorySlice alloc;\n+        private final int size;\n+        public AllocBuffer(MemorySlice alloc, int size) {\n+            super();\n+            this.alloc = alloc;\n+            this.size = size;\n+        }\n+\n+        @Override\n+        public int compareTo(AllocBuffer e) {\n+            assertTrue(alloc.getData() == e.alloc.getData());\n+            return Ints.compare(alloc.getOffset(), e.alloc.getOffset());\n+        }\n+\n+        @Override\n+        public String toString() {\n+          return alloc + \":\" + size;\n+        }\n+    }\n+\n+    private Thread getAllocThread(final ConcurrentLinkedQueue<AllocBuffer> queue,\n+                                  final CountDownLatch latch,\n+                                  final SkipListArena arena) {\n+        return new Thread(new Runnable() {\n+            @Override\n+            public void run() {\n+                Random rand = new Random();\n+                for (int j = 0; j < 1000; j++) {\n+                    int size = rand.nextInt(512);\n+                    MemorySlice alloc = arena.allocateBytes(size);\n+                    queue.add(new AllocBuffer(alloc, size));\n+                }\n+                latch.countDown();\n+            }\n+        });\n+    }\n+\n+    /**\n+    * Test concurrent allocation, check the results don't overlap\n+    */\n+    @Test\n+    public void testConcurrency() throws Exception {\n+        final SkipListArena arena = new SkipListArena(cfg);\n+        final CountDownLatch latch = new CountDownLatch(10);\n+        final ConcurrentLinkedQueue<AllocBuffer> queue = new ConcurrentLinkedQueue<AllocBuffer>();\n+\n+        Set<Thread> testThreads = new HashSet<Thread>();\n+        for (int i = 0; i < 10; i++) {\n+            testThreads.add(getAllocThread(queue, latch, arena));\n+        }\n+\n+        for (Thread thread : testThreads) {\n+            thread.start();\n+        }\n+        latch.await();\n+\n+        // Partition the allocations by the actual byte[] they share,\n+        // make sure offsets are unique and non-overlap for each buffer.\n+        Map<ByteArray, Map<Integer, AllocBuffer>> mapsByArray = new HashMap<ByteArray, Map<Integer, AllocBuffer>>();\n+        boolean overlapped = false;\n+\n+        final AllocBuffer[] buffers = queue.toArray(new AllocBuffer[0]);\n+        for (AllocBuffer buf : buffers) {\n+            if (buf.size != 0) {\n+                ByteArray ptr = new ByteArray(buf.alloc.getData());\n+                Map<Integer, AllocBuffer> tree_map = mapsByArray.get(ptr);\n+                if (tree_map == null) {\n+                    tree_map = new TreeMap<Integer, AllocBuffer>();\n+                    mapsByArray.put(ptr, tree_map);\n+                }\n+                AllocBuffer other = tree_map.put(new Integer(buf.alloc.getOffset()), buf);\n+                if (other != null) {\n+                    fail(\"Buffer \" + other.toString() + \" overlapped with \" + buf.toString());\n+                }\n+            }\n+        }\n+\n+        // Now check each byte array to make sure allocations don't overlap\n+        for (Map<Integer, AllocBuffer> tree_map : mapsByArray.values()) {\n+            int expectedOff = 0;\n+            for (AllocBuffer buf : tree_map.values()) {\n+                assertEquals(expectedOff, buf.alloc.getOffset());\n+                expectedOff += buf.size;\n+            }\n+        }\n+    }\n+}\n+"}]}