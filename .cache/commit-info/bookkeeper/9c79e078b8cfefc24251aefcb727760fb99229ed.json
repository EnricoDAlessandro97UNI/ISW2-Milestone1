{"sha":"9c79e078b8cfefc24251aefcb727760fb99229ed","node_id":"MDY6Q29tbWl0NDc4NTkyNTI2OjljNzllMDc4YjhjZmVmYzI0MjUxYWVmY2I3Mjc3NjBmYjk5MjI5ZWQ=","commit":{"author":{"name":"eolivelli","email":"eolivelli@apache.org","date":"2017-05-02T20:07:24Z"},"committer":{"name":"Enrico Olivelli","email":"eolivelli@apache.org","date":"2017-05-02T20:07:24Z"},"message":"BOOKKEEPER-1019: Support for reading entries after LAC\n\nThis patch introduces a new client-side configuration option to allow reads outside the boundary of the local LastAddConfirmed value.\n\nAuthor: eolivelli <eolivelli@apache.org>\n\nReviewers: Sijie Guo <sijie@apache.org>, Matteo Merli <mmerli@apache.org>\n\nCloses #121 from eolivelli/BOOKKEEPER-1019-read-after-lac","tree":{"sha":"f769b28fd31a7218b7003d428b5653e2f0bec00d","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/trees/f769b28fd31a7218b7003d428b5653e2f0bec00d"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/commits/9c79e078b8cfefc24251aefcb727760fb99229ed","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/9c79e078b8cfefc24251aefcb727760fb99229ed","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/9c79e078b8cfefc24251aefcb727760fb99229ed","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/9c79e078b8cfefc24251aefcb727760fb99229ed/comments","author":{"login":"eolivelli","id":9469110,"node_id":"MDQ6VXNlcjk0NjkxMTA=","avatar_url":"https://avatars.githubusercontent.com/u/9469110?v=4","gravatar_id":"","url":"https://api.github.com/users/eolivelli","html_url":"https://github.com/eolivelli","followers_url":"https://api.github.com/users/eolivelli/followers","following_url":"https://api.github.com/users/eolivelli/following{/other_user}","gists_url":"https://api.github.com/users/eolivelli/gists{/gist_id}","starred_url":"https://api.github.com/users/eolivelli/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/eolivelli/subscriptions","organizations_url":"https://api.github.com/users/eolivelli/orgs","repos_url":"https://api.github.com/users/eolivelli/repos","events_url":"https://api.github.com/users/eolivelli/events{/privacy}","received_events_url":"https://api.github.com/users/eolivelli/received_events","type":"User","site_admin":false},"committer":{"login":"eolivelli","id":9469110,"node_id":"MDQ6VXNlcjk0NjkxMTA=","avatar_url":"https://avatars.githubusercontent.com/u/9469110?v=4","gravatar_id":"","url":"https://api.github.com/users/eolivelli","html_url":"https://github.com/eolivelli","followers_url":"https://api.github.com/users/eolivelli/followers","following_url":"https://api.github.com/users/eolivelli/following{/other_user}","gists_url":"https://api.github.com/users/eolivelli/gists{/gist_id}","starred_url":"https://api.github.com/users/eolivelli/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/eolivelli/subscriptions","organizations_url":"https://api.github.com/users/eolivelli/orgs","repos_url":"https://api.github.com/users/eolivelli/repos","events_url":"https://api.github.com/users/eolivelli/events{/privacy}","received_events_url":"https://api.github.com/users/eolivelli/received_events","type":"User","site_admin":false},"parents":[{"sha":"c72ff5efbfaa21cbc95c21f89692190aa52a5a29","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/c72ff5efbfaa21cbc95c21f89692190aa52a5a29","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/c72ff5efbfaa21cbc95c21f89692190aa52a5a29"}],"stats":{"total":284,"additions":283,"deletions":1},"files":[{"sha":"d1e5540bf9c6522f0c78514112c6598e292a0fcc","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","status":"modified","additions":63,"deletions":0,"changes":63,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/9c79e078b8cfefc24251aefcb727760fb99229ed/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FLedgerHandle.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/9c79e078b8cfefc24251aefcb727760fb99229ed/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FLedgerHandle.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FLedgerHandle.java?ref=9c79e078b8cfefc24251aefcb727760fb99229ed","patch":"@@ -470,6 +470,7 @@ public String toString() {\n      * @param lastEntry\n      *          id of last entry of sequence (included)\n      *\n+     * @see #asyncReadEntries(long, long, org.apache.bookkeeper.client.AsyncCallback.ReadCallback, java.lang.Object)\n      */\n     public Enumeration<LedgerEntry> readEntries(long firstEntry, long lastEntry)\n             throws InterruptedException, BKException {\n@@ -480,6 +481,29 @@ public Enumeration<LedgerEntry> readEntries(long firstEntry, long lastEntry)\n         return SynchCallbackUtils.waitForResult(counter);\n     }\n \n+    /**\n+     * Read a sequence of entries synchronously, allowing to read after the LastAddConfirmed range.<br>\n+     * This is the same of\n+     * {@link #asyncReadUnconfirmedEntries(long, long, org.apache.bookkeeper.client.AsyncCallback.ReadCallback, java.lang.Object) }\n+     *\n+     * @param firstEntry\n+     *          id of first entry of sequence (included)\n+     * @param lastEntry\n+     *          id of last entry of sequence (included)\n+     *\n+     * @see #readEntries(long, long)\n+     * @see #asyncReadUnconfirmedEntries(long, long, org.apache.bookkeeper.client.AsyncCallback.ReadCallback, java.lang.Object)\n+     * @see #asyncReadLastConfirmed(org.apache.bookkeeper.client.AsyncCallback.ReadLastConfirmedCallback, java.lang.Object)\n+     */\n+    public Enumeration<LedgerEntry> readUnconfirmedEntries(long firstEntry, long lastEntry)\n+            throws InterruptedException, BKException {\n+        CompletableFuture<Enumeration<LedgerEntry>> counter = new CompletableFuture<>();\n+\n+        asyncReadUnconfirmedEntries(firstEntry, lastEntry, new SyncReadCallback(), counter);\n+\n+        return SynchCallbackUtils.waitForResult(counter);\n+    }\n+\n     /**\n      * Read a sequence of entries asynchronously.\n      *\n@@ -511,6 +535,45 @@ public void asyncReadEntries(long firstEntry, long lastEntry, ReadCallback cb, O\n         asyncReadEntriesInternal(firstEntry, lastEntry, cb, ctx);\n     }\n \n+    /**\n+     * Read a sequence of entries asynchronously, allowing to read after the LastAddConfirmed range.\n+     * <br>This is the same of\n+     * {@link #asyncReadEntries(long, long, org.apache.bookkeeper.client.AsyncCallback.ReadCallback, java.lang.Object) }\n+     * but it lets the client read without checking the local value of LastAddConfirmed, so that it is possibile to\n+     * read entries for which the writer has not received the acknowledge yet. <br>\n+     * For entries which are within the range 0..LastAddConfirmed BookKeeper guarantees that the writer has successfully\n+     * received the acknowledge.<br>\n+     * For entries outside that range it is possible that the writer never received the acknoledge\n+     * and so there is the risk that the reader is seeing entries before the writer and this could result in a consistency\n+     * issue in some cases.<br>\n+     * With this method you can even read entries before the LastAddConfirmed and entries after it with one call,\n+     * the expected consistency will be as described above for each subrange of ids.\n+     *\n+     * @param firstEntry\n+     *          id of first entry of sequence\n+     * @param lastEntry\n+     *          id of last entry of sequence\n+     * @param cb\n+     *          object implementing read callback interface\n+     * @param ctx\n+     *          control object\n+     *\n+     * @see #asyncReadEntries(long, long, org.apache.bookkeeper.client.AsyncCallback.ReadCallback, java.lang.Object)\n+     * @see #asyncReadLastConfirmed(org.apache.bookkeeper.client.AsyncCallback.ReadLastConfirmedCallback, java.lang.Object)\n+     * @see #readUnconfirmedEntries(long, long)\n+     */\n+    public void asyncReadUnconfirmedEntries(long firstEntry, long lastEntry, ReadCallback cb, Object ctx) {\n+        // Little sanity check\n+        if (firstEntry < 0 || firstEntry > lastEntry) {\n+            LOG.error(\"IncorrectParameterException on ledgerId:{} firstEntry:{} lastEntry:{}\",\n+                    new Object[] { ledgerId, firstEntry, lastEntry });\n+            cb.readComplete(BKException.Code.IncorrectParameterException, this, null, ctx);\n+            return;\n+        }\n+\n+        asyncReadEntriesInternal(firstEntry, lastEntry, cb, ctx);\n+    }\n+\n     void asyncReadEntriesInternal(long firstEntry, long lastEntry, ReadCallback cb, Object ctx) {\n         try {\n             new PendingReadOp(this, bk.scheduler,"},{"sha":"6b913d427441c7cc9dfc198efb0d788dd509db70","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ClientConfiguration.java","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/9c79e078b8cfefc24251aefcb727760fb99229ed/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fconf%2FClientConfiguration.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/9c79e078b8cfefc24251aefcb727760fb99229ed/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fconf%2FClientConfiguration.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fconf%2FClientConfiguration.java?ref=9c79e078b8cfefc24251aefcb727760fb99229ed","patch":"@@ -1072,4 +1072,5 @@ public ClientConfiguration setClientRole(String role) {\n     public String getClientRole() {\n         return getString(CLIENT_ROLE, CLIENT_ROLE_STANDARD);\n     }\n+\n }"},{"sha":"17d63b33c59185446f98118a6f7f4ab104f24114","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookKeeperTest.java","status":"modified","additions":219,"deletions":1,"changes":220,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/9c79e078b8cfefc24251aefcb727760fb99229ed/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookKeeperTest.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/9c79e078b8cfefc24251aefcb727760fb99229ed/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookKeeperTest.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookKeeperTest.java?ref=9c79e078b8cfefc24251aefcb727760fb99229ed","patch":"@@ -1,5 +1,6 @@\n package org.apache.bookkeeper.client;\n \n+import java.util.Collections;\n import java.util.Enumeration;\n \n /*\n@@ -432,5 +433,222 @@ public void testReadHandleWithExplicitLAC() throws Exception {\n         rlh.close();\n         wlh.close();\n         bkcWithExplicitLAC.close();\n-    }\t\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testReadAfterLastAddConfirmed() throws Exception {\n+\n+        ClientConfiguration clientConfiguration = new ClientConfiguration()\n+            .setZkServers(zkUtil.getZooKeeperConnectString());\n+\n+        try (BookKeeper bkWriter = new BookKeeper(clientConfiguration);) {\n+            LedgerHandle writeLh = bkWriter.createLedger(digestType, \"testPasswd\".getBytes());\n+            long ledgerId = writeLh.getId();\n+            int numOfEntries = 5;\n+            for (int i = 0; i < numOfEntries; i++) {\n+                writeLh.addEntry((\"foobar\" + i).getBytes());\n+            }\n+\n+            try (BookKeeper bkReader = new BookKeeper(clientConfiguration);\n+                LedgerHandle rlh = bkReader.openLedgerNoRecovery(ledgerId, digestType, \"testPasswd\".getBytes());) {\n+                Assert.assertTrue(\n+                    \"Expected LAC of rlh: \" + (numOfEntries - 2) + \" actual LAC of rlh: \" + rlh.getLastAddConfirmed(),\n+                    (rlh.getLastAddConfirmed() == (numOfEntries - 2)));\n+\n+                Assert.assertFalse(writeLh.isClosed());\n+\n+                // with readUnconfirmedEntries we are able to read all of the entries\n+                Enumeration<LedgerEntry> entries = rlh.readUnconfirmedEntries(0, numOfEntries - 1);\n+                int entryId = 0;\n+                while (entries.hasMoreElements()) {\n+                    LedgerEntry entry = entries.nextElement();\n+                    String entryString = new String(entry.getEntry());\n+                    Assert.assertTrue(\"Expected entry String: \" + (\"foobar\" + entryId)\n+                        + \" actual entry String: \" + entryString,\n+                        entryString.equals(\"foobar\" + entryId));\n+                    entryId++;\n+                }\n+            }\n+\n+            try (BookKeeper bkReader = new BookKeeper(clientConfiguration);\n+                LedgerHandle rlh = bkReader.openLedgerNoRecovery(ledgerId, digestType, \"testPasswd\".getBytes());) {\n+                Assert.assertTrue(\n+                    \"Expected LAC of rlh: \" + (numOfEntries - 2) + \" actual LAC of rlh: \" + rlh.getLastAddConfirmed(),\n+                    (rlh.getLastAddConfirmed() == (numOfEntries - 2)));\n+\n+                Assert.assertFalse(writeLh.isClosed());\n+\n+                // without readUnconfirmedEntries we are not able to read all of the entries\n+                try {\n+                    rlh.readEntries(0, numOfEntries - 1);\n+                    fail(\"shoud not be able to read up to \"+ (numOfEntries - 1) + \" with readEntries\");\n+                } catch (BKException.BKReadException expected) {\n+                }\n+\n+                // read all entries within the 0..LastAddConfirmed range with readEntries\n+                assertEquals(rlh.getLastAddConfirmed() + 1,\n+                    Collections.list(rlh.readEntries(0, rlh.getLastAddConfirmed())).size());\n+\n+                // assert local LAC does not change after reads\n+                Assert.assertTrue(\n+                    \"Expected LAC of rlh: \" + (numOfEntries - 2) + \" actual LAC of rlh: \" + rlh.getLastAddConfirmed(),\n+                    (rlh.getLastAddConfirmed() == (numOfEntries - 2)));\n+\n+                // read all entries within the 0..LastAddConfirmed range with readUnconfirmedEntries\n+                assertEquals(rlh.getLastAddConfirmed() + 1,\n+                    Collections.list(rlh.readUnconfirmedEntries(0, rlh.getLastAddConfirmed())).size());\n+\n+                // assert local LAC does not change after reads\n+                Assert.assertTrue(\n+                    \"Expected LAC of rlh: \" + (numOfEntries - 2) + \" actual LAC of rlh: \" + rlh.getLastAddConfirmed(),\n+                    (rlh.getLastAddConfirmed() == (numOfEntries - 2)));\n+\n+                // read all entries within the LastAddConfirmed..numOfEntries - 1 range with readUnconfirmedEntries\n+                assertEquals(numOfEntries - rlh.getLastAddConfirmed(),\n+                    Collections.list(rlh.readUnconfirmedEntries(rlh.getLastAddConfirmed(), numOfEntries - 1)).size());\n+\n+                // assert local LAC does not change after reads\n+                Assert.assertTrue(\n+                    \"Expected LAC of rlh: \" + (numOfEntries - 2) + \" actual LAC of rlh: \" + rlh.getLastAddConfirmed(),\n+                    (rlh.getLastAddConfirmed() == (numOfEntries - 2)));\n+\n+                try {\n+                    // read all entries within the LastAddConfirmed..numOfEntries range  with readUnconfirmedEntries\n+                    // this is an error, we are going outside the range of existing entries\n+                    rlh.readUnconfirmedEntries(rlh.getLastAddConfirmed(), numOfEntries);\n+                    fail(\"the read tried to access data for unexisting entry id \"+numOfEntries);\n+                } catch (BKException.BKNoSuchEntryException expected) {\n+                    // expecting a BKNoSuchEntryException, as the entry does not exist on bookies\n+                }\n+\n+                try {\n+                    // read all entries within the LastAddConfirmed..numOfEntries range with readEntries\n+                    // this is an error, we are going outside the range of existing entries\n+                    rlh.readEntries(rlh.getLastAddConfirmed(), numOfEntries);\n+                    fail(\"the read tries to access data for unexisting entry id \"+numOfEntries);\n+                } catch (BKException.BKReadException expected) {\n+                    // expecting a BKReadException, as the client rejected the request to access entries\n+                    // after local LastAddConfirmed\n+                }\n+\n+            }\n+\n+            // ensure that after restarting every bookie entries are not lost\n+            // even entries after the LastAddConfirmed\n+            restartBookies();\n+\n+            try (BookKeeper bkReader = new BookKeeper(clientConfiguration);\n+                LedgerHandle rlh = bkReader.openLedgerNoRecovery(ledgerId, digestType, \"testPasswd\".getBytes());) {\n+                Assert.assertTrue(\n+                    \"Expected LAC of rlh: \" + (numOfEntries - 2) + \" actual LAC of rlh: \" + rlh.getLastAddConfirmed(),\n+                    (rlh.getLastAddConfirmed() == (numOfEntries - 2)));\n+\n+                Assert.assertFalse(writeLh.isClosed());\n+\n+                // with readUnconfirmedEntries we are able to read all of the entries\n+                Enumeration<LedgerEntry> entries = rlh.readUnconfirmedEntries(0, numOfEntries - 1);\n+                int entryId = 0;\n+                while (entries.hasMoreElements()) {\n+                    LedgerEntry entry = entries.nextElement();\n+                    String entryString = new String(entry.getEntry());\n+                    Assert.assertTrue(\"Expected entry String: \" + (\"foobar\" + entryId)\n+                        + \" actual entry String: \" + entryString,\n+                        entryString.equals(\"foobar\" + entryId));\n+                    entryId++;\n+                }\n+            }\n+\n+            try (BookKeeper bkReader = new BookKeeper(clientConfiguration);\n+                LedgerHandle rlh = bkReader.openLedgerNoRecovery(ledgerId, digestType, \"testPasswd\".getBytes());) {\n+                Assert.assertTrue(\n+                    \"Expected LAC of rlh: \" + (numOfEntries - 2) + \" actual LAC of rlh: \" + rlh.getLastAddConfirmed(),\n+                    (rlh.getLastAddConfirmed() == (numOfEntries - 2)));\n+\n+                Assert.assertFalse(writeLh.isClosed());\n+\n+                // without readUnconfirmedEntries we are not able to read all of the entries\n+                try {\n+                    rlh.readEntries(0, numOfEntries - 1);\n+                    fail(\"shoud not be able to read up to \"+ (numOfEntries - 1) + \" with readEntries\");\n+                } catch (BKException.BKReadException expected) {\n+                }\n+\n+                // read all entries within the 0..LastAddConfirmed range with readEntries\n+                assertEquals(rlh.getLastAddConfirmed() + 1,\n+                    Collections.list(rlh.readEntries(0, rlh.getLastAddConfirmed())).size());\n+\n+                // assert local LAC does not change after reads\n+                Assert.assertTrue(\n+                    \"Expected LAC of rlh: \" + (numOfEntries - 2) + \" actual LAC of rlh: \" + rlh.getLastAddConfirmed(),\n+                    (rlh.getLastAddConfirmed() == (numOfEntries - 2)));\n+\n+                // read all entries within the 0..LastAddConfirmed range with readUnconfirmedEntries\n+                assertEquals(rlh.getLastAddConfirmed() + 1,\n+                    Collections.list(rlh.readUnconfirmedEntries(0, rlh.getLastAddConfirmed())).size());\n+\n+                // assert local LAC does not change after reads\n+                Assert.assertTrue(\n+                    \"Expected LAC of rlh: \" + (numOfEntries - 2) + \" actual LAC of rlh: \" + rlh.getLastAddConfirmed(),\n+                    (rlh.getLastAddConfirmed() == (numOfEntries - 2)));\n+\n+                // read all entries within the LastAddConfirmed..numOfEntries - 1 range with readUnconfirmedEntries\n+                assertEquals(numOfEntries - rlh.getLastAddConfirmed(),\n+                    Collections.list(rlh.readUnconfirmedEntries(rlh.getLastAddConfirmed(), numOfEntries - 1)).size());\n+\n+                // assert local LAC does not change after reads\n+                Assert.assertTrue(\n+                    \"Expected LAC of rlh: \" + (numOfEntries - 2) + \" actual LAC of rlh: \" + rlh.getLastAddConfirmed(),\n+                    (rlh.getLastAddConfirmed() == (numOfEntries - 2)));\n+\n+                try {\n+                    // read all entries within the LastAddConfirmed..numOfEntries range  with readUnconfirmedEntries\n+                    // this is an error, we are going outside the range of existing entries\n+                    rlh.readUnconfirmedEntries(rlh.getLastAddConfirmed(), numOfEntries);\n+                    fail(\"the read tried to access data for unexisting entry id \"+numOfEntries);\n+                } catch (BKException.BKNoSuchEntryException expected) {\n+                    // expecting a BKNoSuchEntryException, as the entry does not exist on bookies\n+                }\n+\n+                try {\n+                    // read all entries within the LastAddConfirmed..numOfEntries range with readEntries\n+                    // this is an error, we are going outside the range of existing entries\n+                    rlh.readEntries(rlh.getLastAddConfirmed(), numOfEntries);\n+                    fail(\"the read tries to access data for unexisting entry id \"+numOfEntries);\n+                } catch (BKException.BKReadException expected) {\n+                    // expecting a BKReadException, as the client rejected the request to access entries\n+                    // after local LastAddConfirmed\n+                }\n+\n+            }\n+\n+            // open ledger with fencing, this will repair the ledger and make the last entry readable\n+            try (BookKeeper bkReader = new BookKeeper(clientConfiguration);\n+                LedgerHandle rlh = bkReader.openLedger(ledgerId, digestType, \"testPasswd\".getBytes());) {\n+                Assert.assertTrue(\n+                    \"Expected LAC of rlh: \" + (numOfEntries - 1) + \" actual LAC of rlh: \" + rlh.getLastAddConfirmed(),\n+                    (rlh.getLastAddConfirmed() == (numOfEntries - 1)));\n+\n+                Assert.assertFalse(writeLh.isClosed());\n+\n+                // without readUnconfirmedEntries we are not able to read all of the entries\n+                Enumeration<LedgerEntry> entries = rlh.readEntries(0, numOfEntries - 1);\n+                int entryId = 0;\n+                while (entries.hasMoreElements()) {\n+                    LedgerEntry entry = entries.nextElement();\n+                    String entryString = new String(entry.getEntry());\n+                    Assert.assertTrue(\"Expected entry String: \" + (\"foobar\" + entryId)\n+                        + \" actual entry String: \" + entryString,\n+                        entryString.equals(\"foobar\" + entryId));\n+                    entryId++;\n+                }\n+            }\n+\n+            try {\n+                writeLh.close();\n+                fail(\"should not be able to close the first LedgerHandler as a recovery has been performed\");\n+            } catch (BKException.BKMetadataVersionException expected) {\n+            }\n+\n+        }\n+    }\n }"}]}