{"sha":"256e7587331eddd51b7c05f27717c9d4dc848500","node_id":"MDY6Q29tbWl0NDc4NTkyNTI2OjI1NmU3NTg3MzMxZWRkZDUxYjdjMDVmMjc3MTdjOWQ0ZGM4NDg1MDA=","commit":{"author":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2017-06-21T19:00:15Z"},"committer":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2017-06-21T19:00:15Z"},"message":"BOOKKEEPER-1092: Ledger Recovery (Part 5) - Add Test Case for Parallel Ledger Recovery\n\nThis change is based on #180 (ebf7020 is the change for review)\n\n- Add test case for parallel ledger recovery\n- More stats for ledger recovery\n\nAuthor: Sijie Guo <sijie@apache.org>\nAuthor: Sijie Guo <sijieg@twitter.com>\n\nReviewers: Enrico Olivelli <eolivelli@gmail.com>, Jia Zhai <None>, Matteo Merli <mmerli@apache.org>\n\nThis closes #182 from sijie/recovery_improvements_part5","tree":{"sha":"8b0eaea557c38f76bffbb3c8884337f1c30cc7a7","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/trees/8b0eaea557c38f76bffbb3c8884337f1c30cc7a7"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/commits/256e7587331eddd51b7c05f27717c9d4dc848500","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/256e7587331eddd51b7c05f27717c9d4dc848500","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/256e7587331eddd51b7c05f27717c9d4dc848500","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/256e7587331eddd51b7c05f27717c9d4dc848500/comments","author":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"committer":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"parents":[{"sha":"90e4e46bccdd1a788e10056f4a3818aa2aead452","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/90e4e46bccdd1a788e10056f4a3818aa2aead452","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/90e4e46bccdd1a788e10056f4a3818aa2aead452"}],"stats":{"total":709,"additions":691,"deletions":18},"files":[{"sha":"9a090847dadf27d953b9b4e459a145ce009684bc","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeper.java","status":"modified","additions":9,"deletions":0,"changes":9,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/256e7587331eddd51b7c05f27717c9d4dc848500/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookKeeper.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/256e7587331eddd51b7c05f27717c9d4dc848500/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookKeeper.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookKeeper.java?ref=256e7587331eddd51b7c05f27717c9d4dc848500","patch":"@@ -20,6 +20,7 @@\n  */\n package org.apache.bookkeeper.client;\n \n+import com.google.common.annotations.VisibleForTesting;\n import io.netty.channel.EventLoopGroup;\n import io.netty.channel.epoll.EpollEventLoopGroup;\n import io.netty.channel.nio.NioEventLoopGroup;\n@@ -98,6 +99,7 @@ public class BookKeeper implements AutoCloseable {\n     private OpStatsLogger createOpLogger;\n     private OpStatsLogger openOpLogger;\n     private OpStatsLogger deleteOpLogger;\n+    private OpStatsLogger recoverOpLogger;\n     private OpStatsLogger readOpLogger;\n     private OpStatsLogger addOpLogger;\n     private OpStatsLogger writeLacOpLogger;\n@@ -447,6 +449,11 @@ LedgerManager getLedgerManager() {\n         return ledgerManager;\n     }\n \n+    @VisibleForTesting\n+    LedgerManager getUnderlyingLedgerManager() {\n+        return ((CleanupLedgerManager) ledgerManager).getUnderlying();\n+    }\n+    \n     LedgerIdGenerator getLedgerIdGenerator() {\n         return ledgerIdGenerator;\n     }\n@@ -1243,6 +1250,7 @@ private final void initOpLoggers(StatsLogger stats) {\n         createOpLogger = stats.getOpStatsLogger(BookKeeperClientStats.CREATE_OP);\n         deleteOpLogger = stats.getOpStatsLogger(BookKeeperClientStats.DELETE_OP);\n         openOpLogger = stats.getOpStatsLogger(BookKeeperClientStats.OPEN_OP);\n+        recoverOpLogger = stats.getOpStatsLogger(BookKeeperClientStats.RECOVER_OP);\n         readOpLogger = stats.getOpStatsLogger(BookKeeperClientStats.READ_OP);\n         addOpLogger = stats.getOpStatsLogger(BookKeeperClientStats.ADD_OP);\n         writeLacOpLogger = stats.getOpStatsLogger(BookKeeperClientStats.WRITE_LAC_OP);\n@@ -1254,6 +1262,7 @@ private final void initOpLoggers(StatsLogger stats) {\n     OpStatsLogger getCreateOpLogger() { return createOpLogger; }\n     OpStatsLogger getOpenOpLogger() { return openOpLogger; }\n     OpStatsLogger getDeleteOpLogger() { return deleteOpLogger; }\n+    OpStatsLogger getRecoverOpLogger() { return recoverOpLogger; }\n     OpStatsLogger getReadOpLogger() { return readOpLogger; }\n     OpStatsLogger getAddOpLogger() { return addOpLogger; }\n     OpStatsLogger getWriteLacOpLogger() { return writeLacOpLogger; }"},{"sha":"e98b2d6d2e7c782f69977f243bcc61815eb349c5","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeperClientStats.java","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/256e7587331eddd51b7c05f27717c9d4dc848500/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookKeeperClientStats.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/256e7587331eddd51b7c05f27717c9d4dc848500/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookKeeperClientStats.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookKeeperClientStats.java?ref=256e7587331eddd51b7c05f27717c9d4dc848500","patch":"@@ -29,6 +29,7 @@ public interface BookKeeperClientStats {\n     public final static String CREATE_OP = \"LEDGER_CREATE\";\n     public final static String DELETE_OP = \"LEDGER_DELETE\";\n     public final static String OPEN_OP = \"LEDGER_OPEN\";\n+    public final static String RECOVER_OP = \"LEDGER_RECOVER\";\n     public final static String LEDGER_RECOVER_READ_ENTRIES = \"LEDGER_RECOVER_READ_ENTRIES\";\n     public final static String LEDGER_RECOVER_ADD_ENTRIES = \"LEDGER_RECOVER_ADD_ENTRIES\";\n "},{"sha":"91700b6da8d36a07fbe3a84b6599e71a0072f128","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","status":"modified","additions":50,"deletions":13,"changes":63,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/256e7587331eddd51b7c05f27717c9d4dc848500/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FLedgerHandle.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/256e7587331eddd51b7c05f27717c9d4dc848500/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FLedgerHandle.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FLedgerHandle.java?ref=256e7587331eddd51b7c05f27717c9d4dc848500","patch":"@@ -22,6 +22,7 @@\n \n import static com.google.common.base.Charsets.UTF_8;\n \n+import com.google.common.annotations.VisibleForTesting;\n import com.google.common.collect.Sets;\n import com.google.common.util.concurrent.RateLimiter;\n import io.netty.buffer.ByteBuf;\n@@ -49,7 +50,9 @@\n import org.apache.bookkeeper.client.BookKeeper.DigestType;\n import org.apache.bookkeeper.net.BookieSocketAddress;\n import org.apache.bookkeeper.proto.BookieProtocol;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.TimedGenericCallback;\n import org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.State;\n import org.apache.bookkeeper.stats.Counter;\n import org.apache.bookkeeper.stats.Gauge;\n@@ -75,8 +78,9 @@ public class LedgerHandle implements AutoCloseable {\n     long length;\n     final DigestManager macManager;\n     final DistributionSchedule distributionSchedule;\n-\n     final RateLimiter throttler;\n+    final boolean enableParallelRecoveryRead;\n+    final int recoveryReadBatchSize;\n \n     /**\n      * Invalid entry id. This value is returned from methods which\n@@ -108,7 +112,8 @@ public class LedgerHandle implements AutoCloseable {\n         this.bk = bk;\n         this.metadata = metadata;\n         this.pendingAddOps = new ConcurrentLinkedQueue<PendingAddOp>();\n-\n+        this.enableParallelRecoveryRead = bk.getConf().getEnableParallelRecoveryRead();\n+        this.recoveryReadBatchSize = bk.getConf().getRecoveryReadBatchSize();\n \n         if (metadata.isClosed()) {\n             lastAddConfirmed = lastAddPushed = metadata.getLastEntryId();\n@@ -1442,15 +1447,42 @@ void rereadMetadata(final GenericCallback<LedgerMetadata> cb) {\n         bk.getLedgerManager().readLedgerMetadata(ledgerId, cb);\n     }\n \n-    void recover(final GenericCallback<Void> cb) {\n+    void recover(GenericCallback<Void> finalCb) {\n+        recover(finalCb, null, false);\n+    }\n+\n+    /**\n+     * Recover the ledger.\n+     *\n+     * @param finalCb\n+     *          callback after recovery is done.\n+     * @param listener\n+     *          read entry listener on recovery reads.\n+     * @param forceRecovery\n+     *          force the recovery procedure even the ledger metadata shows the ledger is closed.\n+     */\n+    void recover(GenericCallback<Void> finalCb,\n+                 final @VisibleForTesting BookkeeperInternalCallbacks.ReadEntryListener listener,\n+                 final boolean forceRecovery) {\n+        final GenericCallback<Void> cb = new TimedGenericCallback<Void>(\n+            finalCb,\n+            BKException.Code.OK,\n+            bk.getRecoverOpLogger());\n         boolean wasClosed = false;\n         boolean wasInRecovery = false;\n \n         synchronized (this) {\n             if (metadata.isClosed()) {\n-                lastAddConfirmed = lastAddPushed = metadata.getLastEntryId();\n-                length = metadata.getLength();\n-                wasClosed = true;\n+                if (forceRecovery) {\n+                    wasClosed = false;\n+                    // mark the ledger back to in recovery state, so it would proceed ledger recovery again.\n+                    wasInRecovery = false;\n+                    metadata.markLedgerInRecovery();\n+                } else {\n+                    lastAddConfirmed = lastAddPushed = metadata.getLastEntryId();\n+                    length = metadata.getLength();\n+                    wasClosed = true;\n+                }\n             } else {\n                 wasClosed = false;\n                 if (metadata.isInRecovery()) {\n@@ -1472,8 +1504,9 @@ void recover(final GenericCallback<Void> cb) {\n             // if metadata is already in recover, dont try to write again,\n             // just do the recovery from the starting point\n             new LedgerRecoveryOp(LedgerHandle.this, cb)\n-                    .parallelRead(bk.getConf().getEnableParallelRecoveryRead())\n-                    .readBatchSize(bk.getConf().getRecoveryReadBatchSize())\n+                    .parallelRead(enableParallelRecoveryRead)\n+                    .readBatchSize(recoveryReadBatchSize)\n+                    .setEntryListener(listener)\n                     .initiate();\n             return;\n         }\n@@ -1490,7 +1523,7 @@ public void safeOperationComplete(int rc, LedgerMetadata newMeta) {\n                                 cb.operationComplete(rc, null);\n                             } else {\n                                 metadata = newMeta;\n-                                recover(cb);\n+                                recover(cb, listener, forceRecovery);\n                             }\n                         }\n \n@@ -1500,12 +1533,16 @@ public String toString() {\n                         }\n                     });\n                 } else if (rc == BKException.Code.OK) {\n+                    // we only could issue recovery operation after we successfully update the ledger state to in recovery\n+                    // otherwise, it couldn't prevent us advancing last confirmed while the other writer is closing the ledger,\n+                    // which will cause inconsistent last add confirmed on bookies & zookeeper metadata.\n                     new LedgerRecoveryOp(LedgerHandle.this, cb)\n-                            .parallelRead(bk.getConf().getEnableParallelRecoveryRead())\n-                            .readBatchSize(bk.getConf().getRecoveryReadBatchSize())\n-                            .initiate();\n+                        .parallelRead(enableParallelRecoveryRead)\n+                        .readBatchSize(recoveryReadBatchSize)\n+                        .setEntryListener(listener)\n+                        .initiate();\n                 } else {\n-                    LOG.error(\"Error writing ledger config \" + rc + \" of ledger \" + ledgerId);\n+                    LOG.error(\"Error writing ledger config {} of ledger {}\", rc, ledgerId);\n                     cb.operationComplete(rc, null);\n                 }\n             }"},{"sha":"5ea8935bd78ad64e6f70a8fd40f2457e9e98955d","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerRecoveryOp.java","status":"modified","additions":5,"deletions":3,"changes":8,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/256e7587331eddd51b7c05f27717c9d4dc848500/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FLedgerRecoveryOp.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/256e7587331eddd51b7c05f27717c9d4dc848500/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FLedgerRecoveryOp.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FLedgerRecoveryOp.java?ref=256e7587331eddd51b7c05f27717c9d4dc848500","patch":"@@ -110,9 +110,11 @@ public void initiate() {\n                 new ReadLastConfirmedOp.LastConfirmedDataCallback() {\n                     public void readLastConfirmedDataComplete(int rc, RecoveryData data) {\n                         if (rc == BKException.Code.OK) {\n-                            lh.lastAddPushed = lh.lastAddConfirmed = data.lastAddConfirmed;\n-                            lh.length = data.length;\n-                            startEntryToRead = endEntryToRead = lh.lastAddConfirmed;\n+                            synchronized (lh) {\n+                                lh.lastAddPushed = lh.lastAddConfirmed = data.lastAddConfirmed;\n+                                lh.length = data.length;\n+                                startEntryToRead = endEntryToRead = lh.lastAddConfirmed;\n+                            }\n                             // keep a copy of ledger metadata before proceeding\n                             // ledger recovery\n                             metadataForRecovery = new LedgerMetadata(lh.getLedgerMetadata());"},{"sha":"50117feed1b46eb20defaf1ebfef434b4fc95b39","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/CleanupLedgerManager.java","status":"modified","additions":6,"deletions":0,"changes":6,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/256e7587331eddd51b7c05f27717c9d4dc848500/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FCleanupLedgerManager.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/256e7587331eddd51b7c05f27717c9d4dc848500/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FCleanupLedgerManager.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FCleanupLedgerManager.java?ref=256e7587331eddd51b7c05f27717c9d4dc848500","patch":"@@ -17,6 +17,7 @@\n  */\n package org.apache.bookkeeper.meta;\n \n+import com.google.common.annotations.VisibleForTesting;\n import org.apache.bookkeeper.client.BKException;\n import org.apache.bookkeeper.client.LedgerMetadata;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n@@ -79,6 +80,11 @@ public CleanupLedgerManager(LedgerManager lm) {\n         this.underlying = lm;\n     }\n \n+    @VisibleForTesting\n+    public LedgerManager getUnderlying() {\n+        return underlying;\n+    }\n+\n     private void addCallback(GenericCallback callback) {\n         callbacks.put(callback, callback);\n     }"},{"sha":"79790c405e3a4879a58566c8ad1b84b2edc8dc14","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookkeeperInternalCallbacks.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/256e7587331eddd51b7c05f27717c9d4dc848500/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookkeeperInternalCallbacks.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/256e7587331eddd51b7c05f27717c9d4dc848500/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookkeeperInternalCallbacks.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookkeeperInternalCallbacks.java?ref=256e7587331eddd51b7c05f27717c9d4dc848500","patch":"@@ -83,7 +83,7 @@ public interface WriteLacCallback {\n         void operationComplete(int rc, T result);\n     }\n     \n-        public static class TimedGenericCallback<T> implements GenericCallback<T> {\n+    public static class TimedGenericCallback<T> implements GenericCallback<T> {\n \n         final GenericCallback<T> cb;\n         final int successRc;\n@@ -107,7 +107,7 @@ public void operationComplete(int rc, T result) {\n             cb.operationComplete(rc, result);\n         }\n     }\n-    \n+\n     public interface ReadEntryCallbackCtx {\n         void setLastAddConfirmed(long lac);\n         long getLastAddConfirmed();"},{"sha":"850a790dc8a8a38def83a3dc999427c4d6cf5a57","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/ParallelLedgerRecoveryTest.java","status":"added","additions":618,"deletions":0,"changes":618,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/256e7587331eddd51b7c05f27717c9d4dc848500/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FParallelLedgerRecoveryTest.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/256e7587331eddd51b7c05f27717c9d4dc848500/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FParallelLedgerRecoveryTest.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FParallelLedgerRecoveryTest.java?ref=256e7587331eddd51b7c05f27717c9d4dc848500","patch":"@@ -0,0 +1,618 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.client;\n+\n+import static com.google.common.base.Charsets.UTF_8;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.atomic.AtomicLong;\n+import org.apache.bookkeeper.bookie.Bookie;\n+import org.apache.bookkeeper.bookie.BookieException;\n+import org.apache.bookkeeper.bookie.InterleavedLedgerStorage;\n+import org.apache.bookkeeper.client.BookKeeper.DigestType;\n+import org.apache.bookkeeper.conf.ClientConfiguration;\n+import org.apache.bookkeeper.conf.ServerConfiguration;\n+import org.apache.bookkeeper.net.BookieSocketAddress;\n+import org.apache.bookkeeper.proto.BookieProtocol;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.LedgerMetadataListener;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.Processor;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteCallback;\n+import org.apache.bookkeeper.meta.HierarchicalLedgerManagerFactory;\n+import org.apache.bookkeeper.meta.LedgerManager;\n+import org.apache.bookkeeper.test.BookKeeperClusterTestCase;\n+import org.apache.bookkeeper.versioning.Version;\n+import org.apache.zookeeper.AsyncCallback.VoidCallback;\n+import org.apache.zookeeper.KeeperException;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.Enumeration;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+public class ParallelLedgerRecoveryTest extends BookKeeperClusterTestCase {\n+\n+    static final Logger LOG = LoggerFactory.getLogger(ParallelLedgerRecoveryTest.class);\n+\n+    static class TestLedgerManager implements LedgerManager {\n+\n+        final LedgerManager lm;\n+        volatile CountDownLatch waitLatch = null;\n+        final ExecutorService executorService;\n+\n+        TestLedgerManager(LedgerManager lm) {\n+            this.lm = lm;\n+            this.executorService = Executors.newSingleThreadExecutor();\n+        }\n+\n+        void setLatch(CountDownLatch waitLatch) {\n+            this.waitLatch = waitLatch;\n+        }\n+\n+        @Override\n+        public void createLedgerMetadata(long ledgerId, LedgerMetadata metadata, GenericCallback<Void> cb) {\n+            lm.createLedgerMetadata(ledgerId, metadata, cb);\n+        }\n+\n+        @Override\n+        public void removeLedgerMetadata(long ledgerId, Version version, GenericCallback<Void> cb) {\n+            lm.removeLedgerMetadata(ledgerId, version, cb);\n+        }\n+\n+        @Override\n+        public void readLedgerMetadata(long ledgerId, GenericCallback<LedgerMetadata> readCb) {\n+            lm.readLedgerMetadata(ledgerId, readCb);\n+        }\n+\n+        @Override\n+        public LedgerRangeIterator getLedgerRanges() {\n+            return lm.getLedgerRanges();\n+        }\n+\n+        @Override\n+        public void writeLedgerMetadata(final long ledgerId, final LedgerMetadata metadata,\n+                                        final GenericCallback<Void> cb) {\n+            final CountDownLatch cdl = waitLatch;\n+            if (null != cdl) {\n+                executorService.submit(new Runnable() {\n+                    @Override\n+                    public void run() {\n+                        try {\n+                            cdl.await();\n+                        } catch (InterruptedException e) {\n+                            LOG.error(\"Interrupted on waiting latch : \", e);\n+                        }\n+                        lm.writeLedgerMetadata(ledgerId, metadata, cb);\n+                    }\n+                });\n+            } else {\n+                lm.writeLedgerMetadata(ledgerId, metadata, cb);\n+            }\n+        }\n+\n+        @Override\n+        public void registerLedgerMetadataListener(long ledgerId, LedgerMetadataListener listener) {\n+            lm.registerLedgerMetadataListener(ledgerId, listener);\n+        }\n+\n+        @Override\n+        public void unregisterLedgerMetadataListener(long ledgerId, LedgerMetadataListener listener) {\n+            lm.unregisterLedgerMetadataListener(ledgerId, listener);\n+        }\n+\n+        @Override\n+        public void asyncProcessLedgers(Processor<Long> processor, VoidCallback finalCb, Object context,\n+                                        int successRc, int failureRc) {\n+            lm.asyncProcessLedgers(processor, finalCb, context, successRc, failureRc);\n+        }\n+\n+        @Override\n+        public void close() throws IOException {\n+            lm.close();\n+            executorService.shutdown();\n+        }\n+    }\n+\n+    static class TestLedgerManagerFactory extends HierarchicalLedgerManagerFactory {\n+        @Override\n+        public LedgerManager newLedgerManager() {\n+            return new TestLedgerManager(super.newLedgerManager());\n+        }\n+    }\n+\n+    final DigestType digestType;\n+\n+    public ParallelLedgerRecoveryTest() {\n+        super(3);\n+        baseConf.setLedgerManagerFactoryClass(TestLedgerManagerFactory.class);\n+        baseClientConf.setLedgerManagerFactoryClass(TestLedgerManagerFactory.class);\n+        baseClientConf.setReadEntryTimeout(60000);\n+        baseClientConf.setAddEntryTimeout(60000);\n+        this.digestType = DigestType.CRC32;\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testRecoverBeforeWriteMetadata1() throws Exception {\n+        rereadDuringRecovery(true, 1, false, false);\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testRecoverBeforeWriteMetadata2() throws Exception {\n+        rereadDuringRecovery(true, 3, false, false);\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testRecoverBeforeWriteMetadata3() throws Exception {\n+        rereadDuringRecovery(false, 1, false, false);\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testRecoverBeforeWriteMetadata4() throws Exception {\n+        rereadDuringRecovery(false, 3, false, false);\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testRereadDuringRecovery1() throws Exception {\n+        rereadDuringRecovery(true, 1, true, false);\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testRereadDuringRecovery2() throws Exception {\n+        rereadDuringRecovery(true, 3, true, false);\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testRereadDuringRecovery3() throws Exception {\n+        rereadDuringRecovery(false, 1, true, false);\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testRereadDuringRecovery4() throws Exception {\n+        rereadDuringRecovery(false, 3, true, false);\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testConcurrentRecovery1() throws Exception {\n+        rereadDuringRecovery(true, 1, true, false);\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testConcurrentRecovery2() throws Exception {\n+        rereadDuringRecovery(true, 3, true, false);\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testConcurrentRecovery3() throws Exception {\n+        rereadDuringRecovery(false, 1, true, false);\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testConcurrentRecovery4() throws Exception {\n+        rereadDuringRecovery(false, 3, true, false);\n+    }\n+\n+    private void rereadDuringRecovery(boolean parallelRead, int batchSize,\n+                                      boolean updateMetadata, boolean close) throws Exception {\n+        ClientConfiguration newConf = new ClientConfiguration();\n+        newConf.addConfiguration(baseClientConf);\n+        newConf.setEnableParallelRecoveryRead(parallelRead);\n+        newConf.setRecoveryReadBatchSize(batchSize);\n+        BookKeeper newBk = new BookKeeper(newConf);\n+\n+        TestLedgerManager tlm = (TestLedgerManager) newBk.getUnderlyingLedgerManager();\n+\n+        final LedgerHandle lh = newBk.createLedger(numBookies, 2, 2, digestType, \"\".getBytes());\n+        CountDownLatch latch1 = new CountDownLatch(1);\n+        CountDownLatch latch2 = new CountDownLatch(1);\n+        sleepBookie(lh.getLedgerMetadata().currentEnsemble.get(0), latch1);\n+        sleepBookie(lh.getLedgerMetadata().currentEnsemble.get(1), latch2);\n+\n+        int numEntries = (numBookies * 3) + 1;\n+        final AtomicInteger numPendingAdds = new AtomicInteger(numEntries);\n+        final CountDownLatch addDone = new CountDownLatch(1);\n+        for (int i = 0; i < numEntries; i++) {\n+            lh.asyncAddEntry((\"\" + i).getBytes(), new org.apache.bookkeeper.client.AsyncCallback.AddCallback() {\n+                @Override\n+                public void addComplete(int rc, LedgerHandle lh, long entryId, Object ctx) {\n+                    if (BKException.Code.OK != rc) {\n+                        addDone.countDown();\n+                        return;\n+                    }\n+                    if (numPendingAdds.decrementAndGet() == 0) {\n+                        addDone.countDown();\n+                    }\n+                }\n+            }, null);\n+        }\n+        latch1.countDown();\n+        latch2.countDown();\n+        addDone.await(10, TimeUnit.SECONDS);\n+        assertEquals(0, numPendingAdds.get());\n+\n+        LOG.info(\"Added {} entries to ledger {}.\", numEntries, lh.getId());\n+\n+        long ledgerLenth = lh.getLength();\n+\n+        LedgerHandle recoverLh = newBk.openLedgerNoRecovery(lh.getId(), digestType, \"\".getBytes());\n+        assertEquals(BookieProtocol.INVALID_ENTRY_ID, recoverLh.getLastAddPushed());\n+        assertEquals(BookieProtocol.INVALID_ENTRY_ID, recoverLh.getLastAddConfirmed());\n+        assertEquals(0, recoverLh.getLength());\n+\n+        LOG.info(\"OpenLedgerNoRecovery {}.\", lh.getId());\n+\n+        final CountDownLatch metadataLatch = new CountDownLatch(1);\n+\n+        tlm.setLatch(metadataLatch);\n+\n+        final CountDownLatch recoverLatch = new CountDownLatch(1);\n+        final AtomicBoolean success = new AtomicBoolean(false);\n+        recoverLh.recover(new GenericCallback<Void>() {\n+            @Override\n+            public void operationComplete(int rc, Void result) {\n+                LOG.info(\"Recovering ledger {} completed : {}.\", lh.getId(), rc);\n+                success.set(BKException.Code.OK == rc);\n+                recoverLatch.countDown();\n+            }\n+        });\n+\n+        // clear the metadata latch\n+        tlm.setLatch(null);\n+\n+        if (updateMetadata) {\n+            if (close) {\n+                LOG.info(\"OpenLedger {} to close.\", lh.getId());\n+                LedgerHandle newRecoverLh = newBk.openLedger(lh.getId(), digestType, \"\".getBytes());\n+                newRecoverLh.close();\n+            } else {\n+                LOG.info(\"OpenLedgerNoRecovery {} again.\", lh.getId());\n+                LedgerHandle newRecoverLh = newBk.openLedgerNoRecovery(lh.getId(), digestType, \"\".getBytes());\n+                assertEquals(BookieProtocol.INVALID_ENTRY_ID, newRecoverLh.getLastAddPushed());\n+                assertEquals(BookieProtocol.INVALID_ENTRY_ID, newRecoverLh.getLastAddConfirmed());\n+                // mark the ledger as in recovery to update version.\n+                newRecoverLh.getLedgerMetadata().markLedgerInRecovery();\n+                final CountDownLatch updateLatch = new CountDownLatch(1);\n+                final AtomicInteger updateResult = new AtomicInteger(0x12345);\n+                newRecoverLh.writeLedgerConfig(new GenericCallback<Void>() {\n+                    @Override\n+                    public void operationComplete(int rc, Void result) {\n+                        updateResult.set(rc);\n+                        updateLatch.countDown();\n+                    }\n+                });\n+                updateLatch.await();\n+                assertEquals(BKException.Code.OK, updateResult.get());\n+                newRecoverLh.close();\n+                LOG.info(\"Updated ledger manager {}.\", newRecoverLh.getLedgerMetadata());\n+            }\n+        }\n+\n+        // resume metadata operation on recoverLh\n+        metadataLatch.countDown();\n+\n+        LOG.info(\"Resume metadata update.\");\n+\n+        // wait until recover completed\n+        recoverLatch.await(20, TimeUnit.SECONDS);\n+        assertTrue(success.get());\n+        assertEquals(numEntries - 1, recoverLh.getLastAddPushed());\n+        assertEquals(numEntries - 1, recoverLh.getLastAddConfirmed());\n+        assertEquals(ledgerLenth, recoverLh.getLength());\n+        assertTrue(recoverLh.getLedgerMetadata().isClosed());\n+\n+        Enumeration<LedgerEntry> enumeration = recoverLh.readEntries(0, numEntries - 1);\n+        int numReads = 0;\n+        while (enumeration.hasMoreElements()) {\n+            LedgerEntry entry = enumeration.nextElement();\n+            assertEquals((long) numReads, entry.getEntryId());\n+            assertEquals(numReads, Integer.parseInt(new String(entry.getEntry())));\n+            ++numReads;\n+        }\n+        assertEquals(numEntries, numReads);\n+\n+        recoverLh.close();\n+        newBk.close();\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testRecoveryOnEntryGap() throws Exception {\n+        byte[] passwd = \"recovery-on-entry-gap\".getBytes(UTF_8);\n+        LedgerHandle lh = bkc.createLedger(1, 1, 1, DigestType.CRC32, passwd);\n+        for (int i = 0; i < 10; i++) {\n+            lh.addEntry((\"recovery-on-entry-gap-\" + i).getBytes(UTF_8));\n+        }\n+\n+        // simulate ledger writer failure on concurrent writes causing gaps\n+\n+        long entryId = 14;\n+        long lac = 8;\n+        byte[] data = \"recovery-on-entry-gap-gap\".getBytes(UTF_8);\n+        ByteBuf toSend =\n+                lh.macManager.computeDigestAndPackageForSending(\n+                        entryId, lac, lh.getLength() + 100, Unpooled.wrappedBuffer(data, 0, data.length));\n+        final CountDownLatch addLatch = new CountDownLatch(1);\n+        final AtomicBoolean addSuccess = new AtomicBoolean(false);\n+        LOG.info(\"Add entry {} with lac = {}\", entryId, lac);\n+        lh.bk.bookieClient.addEntry(lh.metadata.currentEnsemble.get(0), lh.getId(), lh.ledgerKey, entryId, toSend,\n+            new WriteCallback() {\n+                @Override\n+                public void writeComplete(int rc, long ledgerId, long entryId, BookieSocketAddress addr, Object ctx) {\n+                    addSuccess.set(BKException.Code.OK == rc);\n+                    addLatch.countDown();\n+                }\n+            }, 0, BookieProtocol.FLAG_NONE);\n+        addLatch.await();\n+        assertTrue(\"add entry 14 should succeed\", addSuccess.get());\n+\n+        ClientConfiguration newConf = new ClientConfiguration();\n+        newConf.addConfiguration(baseClientConf);\n+        newConf.setEnableParallelRecoveryRead(true);\n+        newConf.setRecoveryReadBatchSize(10);\n+\n+        BookKeeper newBk = new BookKeeper(newConf);\n+\n+        final LedgerHandle recoverLh =\n+                newBk.openLedgerNoRecovery(lh.getId(), DigestType.CRC32, passwd);\n+\n+        assertEquals(\"wrong lac found\", 8L, recoverLh.getLastAddConfirmed());\n+\n+        final CountDownLatch recoverLatch = new CountDownLatch(1);\n+        final AtomicLong newLac = new AtomicLong(-1);\n+        final AtomicBoolean isMetadataClosed = new AtomicBoolean(false);\n+        final AtomicInteger numSuccessCalls = new AtomicInteger(0);\n+        final AtomicInteger numFailureCalls = new AtomicInteger(0);\n+        recoverLh.recover(new GenericCallback<Void>() {\n+            @Override\n+            public void operationComplete(int rc, Void result) {\n+                if (BKException.Code.OK == rc) {\n+                    newLac.set(recoverLh.getLastAddConfirmed());\n+                    isMetadataClosed.set(recoverLh.getLedgerMetadata().isClosed());\n+                    numSuccessCalls.incrementAndGet();\n+                } else {\n+                    numFailureCalls.incrementAndGet();\n+                }\n+                recoverLatch.countDown();\n+            }\n+        });\n+        recoverLatch.await();\n+        assertEquals(\"wrong lac found\", 9L, newLac.get());\n+        assertTrue(\"metadata isn't closed after recovery\", isMetadataClosed.get());\n+        Thread.sleep(5000);\n+        assertEquals(\"recovery callback should be triggered only once\", 1, numSuccessCalls.get());\n+        assertEquals(\"recovery callback should be triggered only once\", 0, numFailureCalls.get());\n+    }\n+\n+    static class DelayResponseBookie extends Bookie {\n+\n+        static final class WriteCallbackEntry {\n+\n+            private final WriteCallback cb;\n+            private final int rc;\n+            private final long ledgerId;\n+            private final long entryId;\n+            private final BookieSocketAddress addr;\n+            private final Object ctx;\n+\n+            WriteCallbackEntry(WriteCallback cb,\n+                               int rc, long ledgerId, long entryId,\n+                               BookieSocketAddress addr, Object ctx) {\n+                this.cb = cb;\n+                this.rc = rc;\n+                this.ledgerId = ledgerId;\n+                this.entryId = entryId;\n+                this.addr = addr;\n+                this.ctx = ctx;\n+            }\n+\n+            public void callback() {\n+                cb.writeComplete(rc, ledgerId, entryId, addr, ctx);\n+            }\n+        }\n+\n+        private final AtomicBoolean delayAddResponse = new AtomicBoolean(false);\n+        private final AtomicBoolean delayReadResponse = new AtomicBoolean(false);\n+        private final AtomicLong delayReadOnEntry = new AtomicLong(-1234L);\n+        private volatile CountDownLatch delayReadLatch = null;\n+        private final LinkedBlockingQueue<WriteCallbackEntry> delayQueue =\n+                new LinkedBlockingQueue<WriteCallbackEntry>();\n+\n+        public DelayResponseBookie(ServerConfiguration conf)\n+                throws IOException, KeeperException, InterruptedException, BookieException {\n+            super(conf);\n+        }\n+\n+        @Override\n+        public void addEntry(ByteBuf entry, final WriteCallback cb, Object ctx, byte[] masterKey)\n+                throws IOException, BookieException {\n+            super.addEntry(entry, new WriteCallback() {\n+                @Override\n+                public void writeComplete(int rc, long ledgerId, long entryId,\n+                                          BookieSocketAddress addr, Object ctx) {\n+                    if (delayAddResponse.get()) {\n+                        delayQueue.add(new WriteCallbackEntry(cb, rc, ledgerId, entryId, addr, ctx));\n+                    } else {\n+                        cb.writeComplete(rc, ledgerId, entryId, addr, ctx);\n+                    }\n+                }\n+            }, ctx, masterKey);\n+        }\n+\n+        @Override\n+        public ByteBuf readEntry(long ledgerId, long entryId) throws IOException, NoLedgerException {\n+            LOG.info(\"ReadEntry {} - {}\", ledgerId, entryId);\n+            if (delayReadResponse.get() && delayReadOnEntry.get() == entryId) {\n+                CountDownLatch latch = delayReadLatch;\n+                if (null != latch) {\n+                    try {\n+                        latch.await();\n+                    } catch (InterruptedException e) {\n+                        // no-op\n+                    }\n+                }\n+            }\n+            return super.readEntry(ledgerId, entryId);\n+        }\n+\n+        void delayAdd(boolean delayed) {\n+            this.delayAddResponse.set(delayed);\n+        }\n+\n+        void delayRead(boolean delayed, long entryId, CountDownLatch delayReadLatch) {\n+            this.delayReadResponse.set(delayed);\n+            this.delayReadOnEntry.set(entryId);\n+            this.delayReadLatch = delayReadLatch;\n+        }\n+\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testRecoveryWhenClosingLedgerHandle() throws Exception {\n+        byte[] passwd = \"recovery-when-closing-ledger-handle\".getBytes(UTF_8);\n+\n+        ClientConfiguration newConf = new ClientConfiguration();\n+        newConf.addConfiguration(baseClientConf);\n+        newConf.setEnableParallelRecoveryRead(true);\n+        newConf.setRecoveryReadBatchSize(1);\n+        newConf.setAddEntryTimeout(9999999);\n+        newConf.setReadEntryTimeout(9999999);\n+\n+        final BookKeeper newBk0 = new BookKeeper(newConf);\n+        final LedgerHandle lh0 = newBk0.createLedger(1, 1, 1, digestType, passwd);\n+\n+        final BookKeeper newBk1 = new BookKeeper(newConf);\n+        final LedgerHandle lh1 = newBk1.openLedgerNoRecovery(lh0.getId(), digestType, passwd);\n+        final TestLedgerManager tlm1 = (TestLedgerManager) newBk1.getUnderlyingLedgerManager();\n+\n+        final BookKeeper readBk = new BookKeeper(newConf);\n+        final LedgerHandle readLh = readBk.openLedgerNoRecovery(lh0.getId(), digestType, passwd);\n+\n+        LOG.info(\"Create ledger {}\", lh0.getId());\n+\n+        // 0) place the bookie with a fake bookie\n+        BookieSocketAddress address = lh0.getLedgerMetadata().currentEnsemble.get(0);\n+        ServerConfiguration conf = killBookie(address);\n+        conf.setLedgerStorageClass(InterleavedLedgerStorage.class.getName());\n+        DelayResponseBookie fakeBookie = new DelayResponseBookie(conf);\n+        bs.add(startBookie(conf, fakeBookie));\n+        bsConfs.add(conf);\n+\n+        // 1) bk0 write two entries\n+        lh0.addEntry(\"entry-0\".getBytes(UTF_8));\n+        lh0.addEntry(\"entry-1\".getBytes(UTF_8));\n+\n+        // 2) readBk read last add confirmed\n+        long lac = readLh.readLastConfirmed();\n+        assertEquals(0L, lac);\n+        lac = lh1.readLastConfirmed();\n+        assertEquals(0L, lac);\n+\n+        final CountDownLatch addLatch = new CountDownLatch(3);\n+        final AtomicInteger numAddFailures = new AtomicInteger(0);\n+        // 3) bk0 write more entries in parallel\n+        fakeBookie.delayAdd(true);\n+        for (int i = 2; i < 5; i++) {\n+            lh0.asyncAddEntry((\"entry-\" + i).getBytes(UTF_8), new AsyncCallback.AddCallback() {\n+                @Override\n+                public void addComplete(int rc, LedgerHandle lh, long entryId, Object ctx) {\n+                    if (BKException.Code.OK != rc) {\n+                        numAddFailures.incrementAndGet();\n+                    }\n+                    addLatch.countDown();\n+                }\n+            }, null);\n+        }\n+        while (fakeBookie.delayQueue.size() < 3) {\n+            // wait until all add requests are queued\n+            Thread.sleep(100);\n+        }\n+\n+        // 4) lac moved to 1L\n+        lac = readLh.readLastConfirmed();\n+        assertEquals(1L, lac);\n+        lac = lh1.readLastConfirmed();\n+        assertEquals(1L, lac);\n+\n+        // 5) bk1 is doing recovery, but the metadata update is delayed\n+        final CountDownLatch readLatch = new CountDownLatch(1);\n+        fakeBookie.delayAdd(false);\n+        fakeBookie.delayRead(true, 3L, readLatch);\n+        final CountDownLatch metadataLatch = new CountDownLatch(1);\n+        tlm1.setLatch(metadataLatch);\n+        final CountDownLatch recoverLatch = new CountDownLatch(1);\n+        final AtomicBoolean recoverSuccess = new AtomicBoolean(false);\n+        lh1.recover(new GenericCallback<Void>() {\n+            @Override\n+            public void operationComplete(int rc, Void result) {\n+                LOG.info(\"Recovering ledger {} completed : {}\", lh1.getId(), rc);\n+                recoverSuccess.set(BKException.Code.OK == rc);\n+                recoverLatch.countDown();\n+            }\n+        });\n+        Thread.sleep(2000);\n+        readLatch.countDown();\n+\n+        // we don't expected lac being updated before we successfully marked the ledger in recovery\n+        lac = readLh.readLastConfirmed();\n+        assertEquals(1L, lac);\n+\n+        // 6) bk0 closes ledger before bk1 marks in recovery\n+        lh0.close();\n+        assertEquals(1L, lh0.getLastAddConfirmed());\n+\n+        // 7) bk1 proceed recovery and succeed\n+        metadataLatch.countDown();\n+        recoverLatch.await();\n+        assertTrue(recoverSuccess.get());\n+        assertEquals(1L, lh1.getLastAddConfirmed());\n+\n+        // 8) make sure we won't see lac advanced during ledger is closed by bk0 and recovered by bk1\n+        final AtomicLong lacHolder = new AtomicLong(-1234L);\n+        final AtomicInteger rcHolder = new AtomicInteger(-1234);\n+        final CountDownLatch doneLatch = new CountDownLatch(1);\n+        new ReadLastConfirmedOp(readLh, new ReadLastConfirmedOp.LastConfirmedDataCallback() {\n+            @Override\n+            public void readLastConfirmedDataComplete(int rc, DigestManager.RecoveryData data) {\n+                rcHolder.set(rc);\n+                lacHolder.set(data.lastAddConfirmed);\n+                doneLatch.countDown();\n+            }\n+        }).initiate();\n+        doneLatch.await();\n+        assertEquals(BKException.Code.OK, rcHolder.get());\n+        assertEquals(1L, lacHolder.get());\n+\n+        newBk0.close();\n+        newBk1.close();\n+        readBk.close();\n+    }\n+\n+}"}]}