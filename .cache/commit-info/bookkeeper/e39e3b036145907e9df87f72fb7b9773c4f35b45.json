{"sha":"e39e3b036145907e9df87f72fb7b9773c4f35b45","node_id":"MDY6Q29tbWl0NDc4NTkyNTI2OmUzOWUzYjAzNjE0NTkwN2U5ZGY4N2Y3MmZiN2I5NzczYzRmMzViNDU=","commit":{"author":{"name":"Sijie Guo","email":"sijieg@twitter.com","date":"2016-08-23T01:05:39Z"},"committer":{"name":"Sijie Guo","email":"sijieg@twitter.com","date":"2016-08-23T01:05:39Z"},"message":"DL-31: Provide flag to disable zk based distributed lock\n\nDL doesn't enforce any leader election. However it still provides a zookeeper ephemeral znode based lock for leader election. It is unnecessary if applications use core library directly already have its own leader election mechanism.\n\nThis change is to provide a flag to allow disable the zk based lock.\n\nAuthor: Sijie Guo <sijieg@twitter.com>\n\nReviewers: Leigh Stewart <lstewart@apache.org>\n\nCloses #9 from sijie/sijie/flag_to_disable_lock","tree":{"sha":"4a4281f2d40e70b34d41d912a9fd4d357b8e4fef","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/trees/4a4281f2d40e70b34d41d912a9fd4d357b8e4fef"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/commits/e39e3b036145907e9df87f72fb7b9773c4f35b45","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/e39e3b036145907e9df87f72fb7b9773c4f35b45","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/e39e3b036145907e9df87f72fb7b9773c4f35b45","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/e39e3b036145907e9df87f72fb7b9773c4f35b45/comments","author":null,"committer":null,"parents":[{"sha":"55937e03ec9f9d9c9939af6dcaa7f420cd655924","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/55937e03ec9f9d9c9939af6dcaa7f420cd655924","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/55937e03ec9f9d9c9939af6dcaa7f420cd655924"}],"stats":{"total":1365,"additions":747,"deletions":618},"files":[{"sha":"a5be03c235b5c1d3cba01cc688bfc5a29b7cf224","filename":"src/main/java/com/twitter/distributedlog/BKDistributedLogManager.java","status":"modified","additions":16,"deletions":9,"changes":25,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/e39e3b036145907e9df87f72fb7b9773c4f35b45/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FBKDistributedLogManager.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/e39e3b036145907e9df87f72fb7b9773c4f35b45/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FBKDistributedLogManager.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FBKDistributedLogManager.java?ref=e39e3b036145907e9df87f72fb7b9773c4f35b45","patch":"@@ -36,8 +36,10 @@\n import com.twitter.distributedlog.impl.metadata.ZKLogMetadataForReader;\n import com.twitter.distributedlog.impl.metadata.ZKLogMetadataForWriter;\n import com.twitter.distributedlog.io.AsyncCloseable;\n-import com.twitter.distributedlog.lock.SessionLockFactory;\n import com.twitter.distributedlog.lock.DistributedLock;\n+import com.twitter.distributedlog.lock.NopDistributedLock;\n+import com.twitter.distributedlog.lock.SessionLockFactory;\n+import com.twitter.distributedlog.lock.ZKDistributedLock;\n import com.twitter.distributedlog.lock.ZKSessionLockFactory;\n import com.twitter.distributedlog.logsegment.LogSegmentMetadataStore;\n import com.twitter.distributedlog.metadata.BKDLConfig;\n@@ -100,9 +102,9 @@\n  * scope `writer_future_pool`. See {@link MonitoredFuturePool} for detail stats.\n  * <li> `reader_future_pool/*`: metrics about the future pools that used by readers are exposed under\n  * scope `reader_future_pool`. See {@link MonitoredFuturePool} for detail stats.\n- * <li> `lock/*`: metrics about the locks used by writers. See {@link DistributedLock} for detail\n+ * <li> `lock/*`: metrics about the locks used by writers. See {@link ZKDistributedLock} for detail\n  * stats.\n- * <li> `read_lock/*`: metrics about the locks used by readers. See {@link DistributedLock} for\n+ * <li> `read_lock/*`: metrics about the locks used by readers. See {@link ZKDistributedLock} for\n  * detail stats.\n  * <li> `logsegments/*`: metrics about basic operations on log segments. See {@link BKLogHandler} for details.\n  * <li> `segments/*`: metrics about write operations on log segments. See {@link BKLogWriteHandler} for details.\n@@ -604,12 +606,17 @@ private void createWriteHandler(ZKLogMetadataForWriter logMetadata,\n                                     final Promise<BKLogWriteHandler> createPromise) {\n         OrderedScheduler lockStateExecutor = getLockStateExecutor(true);\n         // Build the locks\n-        DistributedLock lock = new DistributedLock(\n-                lockStateExecutor,\n-                getLockFactory(true),\n-                logMetadata.getLockPath(),\n-                conf.getLockTimeoutMilliSeconds(),\n-                statsLogger);\n+        DistributedLock lock;\n+        if (conf.isWriteLockEnabled()) {\n+            lock = new ZKDistributedLock(\n+                    lockStateExecutor,\n+                    getLockFactory(true),\n+                    logMetadata.getLockPath(),\n+                    conf.getLockTimeoutMilliSeconds(),\n+                    statsLogger);\n+        } else {\n+            lock = NopDistributedLock.INSTANCE;\n+        }\n         // Build the ledger allocator\n         LedgerAllocator allocator;\n         try {"},{"sha":"0bf6b84372dd8ec0844ec0b349ba4b22159b7310","filename":"src/main/java/com/twitter/distributedlog/BKLogReadHandler.java","status":"modified","additions":5,"deletions":4,"changes":9,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/e39e3b036145907e9df87f72fb7b9773c4f35b45/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FBKLogReadHandler.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/e39e3b036145907e9df87f72fb7b9773c4f35b45/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FBKLogReadHandler.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FBKLogReadHandler.java?ref=e39e3b036145907e9df87f72fb7b9773c4f35b45","patch":"@@ -30,7 +30,9 @@\n import com.twitter.distributedlog.exceptions.LogNotFoundException;\n import com.twitter.distributedlog.impl.metadata.ZKLogMetadataForReader;\n import com.twitter.distributedlog.injector.AsyncFailureInjector;\n+import com.twitter.distributedlog.lock.DistributedLock;\n import com.twitter.distributedlog.lock.SessionLockFactory;\n+import com.twitter.distributedlog.lock.ZKDistributedLock;\n import com.twitter.distributedlog.lock.ZKSessionLockFactory;\n import com.twitter.distributedlog.logsegment.LogSegmentFilter;\n import com.twitter.distributedlog.logsegment.LogSegmentMetadataStore;\n@@ -39,7 +41,6 @@\n import com.twitter.distributedlog.stats.ReadAheadExceptionsLogger;\n import com.twitter.distributedlog.util.FutureUtils;\n import com.twitter.distributedlog.util.OrderedScheduler;\n-import com.twitter.distributedlog.lock.DistributedLock;\n import com.twitter.distributedlog.util.Utils;\n import com.twitter.util.ExceptionalFunction;\n import com.twitter.util.ExceptionalFunction0;\n@@ -98,7 +99,7 @@\n  * becoming idle.\n  * </ul>\n  * <h4>Read Lock</h4>\n- * All read lock related stats are exposed under scope `read_lock`. See {@link DistributedLock}\n+ * All read lock related stats are exposed under scope `read_lock`. See {@link ZKDistributedLock}\n  * for detail stats.\n  */\n class BKLogReadHandler extends BKLogHandler {\n@@ -216,7 +217,7 @@ synchronized Future<Void> lockStream() {\n                 public DistributedLock applyE() throws IOException {\n                     // Unfortunately this has a blocking call which we should not execute on the\n                     // ZK completion thread\n-                    BKLogReadHandler.this.readLock = new DistributedLock(\n+                    BKLogReadHandler.this.readLock = new ZKDistributedLock(\n                             lockStateExecutor,\n                             lockFactory,\n                             readLockPath,\n@@ -247,7 +248,7 @@ public Future<Void> applyE(DistributedLock lock) throws IOException {\n      * executor service thread.\n      */\n     Future<Void> acquireLockOnExecutorThread(DistributedLock lock) throws LockingException {\n-        final Future<DistributedLock> acquireFuture = lock.asyncAcquire();\n+        final Future<? extends DistributedLock> acquireFuture = lock.asyncAcquire();\n \n         // The future we return must be satisfied on an executor service thread. If we simply\n         // return the future returned by asyncAcquire, user callbacks may end up running in"},{"sha":"d73c5e29cffc18080c79fea425bcd1c084bc2e7d","filename":"src/main/java/com/twitter/distributedlog/BKLogWriteHandler.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/e39e3b036145907e9df87f72fb7b9773c4f35b45/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FBKLogWriteHandler.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/e39e3b036145907e9df87f72fb7b9773c4f35b45/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FBKLogWriteHandler.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FBKLogWriteHandler.java?ref=e39e3b036145907e9df87f72fb7b9773c4f35b45","patch":"@@ -110,7 +110,7 @@ class BKLogWriteHandler extends BKLogHandler {\n     protected final int regionId;\n     protected volatile boolean closed = false;\n     protected final RollingPolicy rollingPolicy;\n-    protected Future<DistributedLock> lockFuture = null;\n+    protected Future<? extends DistributedLock> lockFuture = null;\n     protected final PermitLimiter writeLimiter;\n     protected final FeatureProvider featureProvider;\n     protected final DynamicDistributedLogConfiguration dynConf;\n@@ -337,7 +337,7 @@ protected void abortOpResult(Throwable t, OpResult opResult) {\n      *\n      * @return future represents the lock result\n      */\n-    Future<DistributedLock> lockHandler() {\n+    Future<? extends DistributedLock> lockHandler() {\n         if (null != lockFuture) {\n             return lockFuture;\n         }"},{"sha":"d2af86276755cf27363c45038df305551fee9a4a","filename":"src/main/java/com/twitter/distributedlog/DistributedLogConfiguration.java","status":"modified","additions":26,"deletions":0,"changes":26,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/e39e3b036145907e9df87f72fb7b9773c4f35b45/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FDistributedLogConfiguration.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/e39e3b036145907e9df87f72fb7b9773c4f35b45/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FDistributedLogConfiguration.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FDistributedLogConfiguration.java?ref=e39e3b036145907e9df87f72fb7b9773c4f35b45","patch":"@@ -267,6 +267,8 @@ public class DistributedLogConfiguration extends CompositeConfiguration {\n     public static final int BKDL_LOGSEGMENT_ROLLING_CONCURRENCY_DEFAULT = 1;\n \n     // Lock Settings\n+    public static final String BKDL_WRITE_LOCK_ENABLED = \"writeLockEnabled\";\n+    public static final boolean BKDL_WRITE_LOCK_ENABLED_DEFAULT = true;\n     public static final String BKDL_LOCK_TIMEOUT = \"lockTimeoutSeconds\";\n     public static final long BKDL_LOCK_TIMEOUT_DEFAULT = 30;\n     public static final String BKDL_LOCK_REACQUIRE_TIMEOUT = \"lockReacquireTimeoutSeconds\";\n@@ -2038,6 +2040,30 @@ public DistributedLogConfiguration setLogSegmentRollingConcurrency(int concurren\n     // Lock Settings\n     //\n \n+    /**\n+     * Is lock enabled when opening a writer to write a stream?\n+     * <p> We don't generally require a lock to write a stream to guarantee correctness. The lock\n+     * is more on tracking ownerships. The built-in fencing mechanism is used guarantee correctness\n+     * during stream owner failover. It is okay to disable lock if your application knows which nodes\n+     * have to write which streams.\n+     *\n+     * @return true if lock is enabled, otherwise false.\n+     */\n+    public boolean isWriteLockEnabled() {\n+        return this.getBoolean(BKDL_WRITE_LOCK_ENABLED, BKDL_WRITE_LOCK_ENABLED_DEFAULT);\n+    }\n+\n+    /**\n+     * Enable lock for opening a writer to write a stream?\n+     *\n+     * @param enabled flag to enable or disable lock for opening a writer to write a stream.\n+     * @return distributedlog configuration.\n+     */\n+    public DistributedLogConfiguration setWriteLockEnabled(boolean enabled) {\n+        setProperty(BKDL_WRITE_LOCK_ENABLED, enabled);\n+        return this;\n+    }\n+\n     /**\n      * Get lock timeout in milliseconds. The default value is 30.\n      *"},{"sha":"85a370f09b8edf791843d3ce7991fb06094112a5","filename":"src/main/java/com/twitter/distributedlog/LocalDLMEmulator.java","status":"modified","additions":7,"deletions":27,"changes":34,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/e39e3b036145907e9df87f72fb7b9773c4f35b45/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FLocalDLMEmulator.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/e39e3b036145907e9df87f72fb7b9773c4f35b45/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FLocalDLMEmulator.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FLocalDLMEmulator.java?ref=e39e3b036145907e9df87f72fb7b9773c4f35b45","patch":"@@ -34,10 +34,8 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import java.io.BufferedReader;\n import java.io.File;\n import java.io.IOException;\n-import java.io.InputStreamReader;\n import java.net.BindException;\n import java.net.URI;\n import java.util.ArrayList;\n@@ -118,40 +116,19 @@ public LocalDLMEmulator build() throws Exception {\n                 conf = (ServerConfiguration) DEFAULT_SERVER_CONFIGURATION.clone();\n                 conf.setZkTimeout(zkTimeoutSec * 1000);\n             }\n+            ServerConfiguration newConf = new ServerConfiguration();\n+            newConf.loadConf(conf);\n+            newConf.setAllowLoopback(true);\n \n             return new LocalDLMEmulator(numBookies, shouldStartZK, zkHost, zkPort,\n-                initialBookiePort, zkTimeoutSec, conf);\n+                initialBookiePort, zkTimeoutSec, newConf);\n         }\n     }\n \n     public static Builder newBuilder() {\n         return new Builder();\n     }\n \n-    public LocalDLMEmulator(final int numBookies) throws Exception {\n-        this(numBookies, true, DEFAULT_ZK_HOST, DEFAULT_ZK_PORT, DEFAULT_BOOKIE_INITIAL_PORT);\n-    }\n-\n-    public LocalDLMEmulator(final int numBookies, final String zkHost, final int zkPort) throws Exception {\n-        this(numBookies, false, zkHost, zkPort, DEFAULT_BOOKIE_INITIAL_PORT);\n-    }\n-\n-    public LocalDLMEmulator(final int numBookies, final String zkHost, final int zkPort, final ServerConfiguration serverConf) throws Exception {\n-        this(numBookies, false, zkHost, zkPort, DEFAULT_BOOKIE_INITIAL_PORT, DEFAULT_ZK_TIMEOUT_SEC, serverConf);\n-    }\n-\n-    public LocalDLMEmulator(final int numBookies, final int initialBookiePort) throws Exception {\n-        this(numBookies, true, DEFAULT_ZK_HOST, DEFAULT_ZK_PORT, initialBookiePort);\n-    }\n-\n-    public LocalDLMEmulator(final int numBookies, final String zkHost, final int zkPort, final int initialBookiePort) throws Exception {\n-        this(numBookies, false, zkHost, zkPort, initialBookiePort);\n-    }\n-\n-    private LocalDLMEmulator(final int numBookies, final boolean shouldStartZK, final String zkHost, final int zkPort, final int initialBookiePort) throws Exception {\n-        this(numBookies, shouldStartZK, zkHost, zkPort, initialBookiePort, DEFAULT_ZK_TIMEOUT_SEC, new ServerConfiguration());\n-    }\n-\n     private LocalDLMEmulator(final int numBookies, final boolean shouldStartZK, final String zkHost, final int zkPort, final int initialBookiePort, final int zkTimeoutSec, final ServerConfiguration serverConf) throws Exception {\n         this.numBookies = numBookies;\n         this.zkHost = zkHost;\n@@ -162,7 +139,9 @@ private LocalDLMEmulator(final int numBookies, final boolean shouldStartZK, fina\n         this.bkStartupThread = new Thread() {\n             public void run() {\n                 try {\n+                    LOG.info(\"Starting {} bookies : allowLoopback = {}\", numBookies, serverConf.getAllowLoopback());\n                     LocalBookKeeper.startLocalBookies(zkHost, zkPort, numBookies, shouldStartZK, initialBookiePort, serverConf);\n+                    LOG.info(\"{} bookies are started.\");\n                 } catch (InterruptedException e) {\n                     // go away quietly\n                 } catch (Exception e) {\n@@ -205,6 +184,7 @@ public BookieServer newBookie() throws Exception {\n         ServerConfiguration bookieConf = new ServerConfiguration();\n         bookieConf.setZkTimeout(zkTimeoutSec * 1000);\n         bookieConf.setBookiePort(0);\n+        bookieConf.setAllowLoopback(true);\n         File tmpdir = File.createTempFile(\"bookie\" + UUID.randomUUID() + \"_\",\n             \"test\");\n         if (!tmpdir.delete()) {"},{"sha":"0369946d823de2829655d1d38082a3c07963cb62","filename":"src/main/java/com/twitter/distributedlog/lock/DistributedLock.java","status":"modified","additions":16,"deletions":498,"changes":514,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/e39e3b036145907e9df87f72fb7b9773c4f35b45/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Flock%2FDistributedLock.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/e39e3b036145907e9df87f72fb7b9773c4f35b45/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Flock%2FDistributedLock.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Flock%2FDistributedLock.java?ref=e39e3b036145907e9df87f72fb7b9773c4f35b45","patch":"@@ -1,519 +1,37 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n package com.twitter.distributedlog.lock;\n \n-import com.google.common.annotations.VisibleForTesting;\n-import com.google.common.base.Stopwatch;\n import com.twitter.distributedlog.exceptions.LockingException;\n-import com.twitter.distributedlog.exceptions.OwnershipAcquireFailedException;\n-import com.twitter.distributedlog.exceptions.UnexpectedException;\n import com.twitter.distributedlog.io.AsyncCloseable;\n-import com.twitter.distributedlog.util.FutureUtils;\n-import com.twitter.distributedlog.util.FutureUtils.OrderedFutureEventListener;\n-import com.twitter.distributedlog.util.OrderedScheduler;\n-import com.twitter.util.Function;\n import com.twitter.util.Future;\n-import com.twitter.util.FutureEventListener;\n-import com.twitter.util.Promise;\n-import org.apache.bookkeeper.stats.Counter;\n-import org.apache.bookkeeper.stats.OpStatsLogger;\n-import org.apache.bookkeeper.stats.StatsLogger;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-import scala.runtime.AbstractFunction0;\n-import scala.runtime.BoxedUnit;\n-\n-import java.io.IOException;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicInteger;\n \n /**\n- * Distributed lock, using ZooKeeper.\n- * <p/>\n- * The lock is vulnerable to timing issues. For example, the process could\n- * encounter a really long GC cycle between acquiring the lock, and writing to\n- * a ledger. This could have timed out the lock, and another process could have\n- * acquired the lock and started writing to bookkeeper. Therefore other\n- * mechanisms are required to ensure correctness (i.e. Fencing).\n- * <p/>\n- * The lock is only allowed to acquire once. If the lock is acquired successfully,\n- * the caller holds the ownership until it loses the ownership either because of\n- * others already acquired the lock when session expired or explicitly close it.\n- * <p>\n- * The caller could use {@link #checkOwnership()} or {@link #checkOwnershipAndReacquire()}\n- * to check if it still holds the lock. If it doesn't hold the lock, the caller should\n- * give up the ownership and close the lock.\n- * <h3>Metrics</h3>\n- * All the lock related stats are exposed under `lock`.\n- * <ul>\n- * <li>lock/acquire: opstats. latency spent on acquiring a lock.\n- * <li>lock/reacquire: opstats. latency spent on re-acquiring a lock.\n- * <li>lock/internalTryRetries: counter. the number of retries on re-creating internal locks.\n- * </ul>\n- * Other internal lock related stats are also exposed under `lock`. See {@link SessionLock}\n- * for details.\n+ * Interface for distributed locking\n  */\n-public class DistributedLock implements LockListener, AsyncCloseable {\n-\n-    static final Logger LOG = LoggerFactory.getLogger(DistributedLock.class);\n-\n-    private final SessionLockFactory lockFactory;\n-    private final OrderedScheduler lockStateExecutor;\n-    private final String lockPath;\n-    private final long lockTimeout;\n-    private final DistributedLockContext lockContext = new DistributedLockContext();\n-\n-    // We have two lock acquire futures:\n-    // 1. lock acquire future: for the initial acquire op\n-    // 2. lock reacquire future: for reacquire necessary when session expires, lock is closed\n-    private Future<DistributedLock> lockAcquireFuture = null;\n-    private Future<DistributedLock> lockReacquireFuture = null;\n-    // following variable tracking the status of acquire process\n-    //   => create (internalLock) => tryLock (tryLockFuture) => waitForAcquire (lockWaiter)\n-    private SessionLock internalLock = null;\n-    private Future<LockWaiter> tryLockFuture = null;\n-    private LockWaiter lockWaiter = null;\n-    // exception indicating if the reacquire failed\n-    private LockingException lockReacquireException = null;\n-    // closeFuture\n-    private volatile boolean closed = false;\n-    private Future<Void> closeFuture = null;\n-\n-    // A counter to track how many re-acquires happened during a lock's life cycle.\n-    private final AtomicInteger reacquireCount = new AtomicInteger(0);\n-    private final StatsLogger lockStatsLogger;\n-    private final OpStatsLogger acquireStats;\n-    private final OpStatsLogger reacquireStats;\n-    private final Counter internalTryRetries;\n-\n-    public DistributedLock(\n-            OrderedScheduler lockStateExecutor,\n-            SessionLockFactory lockFactory,\n-            String lockPath,\n-            long lockTimeout,\n-            StatsLogger statsLogger) {\n-        this.lockStateExecutor = lockStateExecutor;\n-        this.lockPath = lockPath;\n-        this.lockTimeout = lockTimeout;\n-        this.lockFactory = lockFactory;\n-\n-        lockStatsLogger = statsLogger.scope(\"lock\");\n-        acquireStats = lockStatsLogger.getOpStatsLogger(\"acquire\");\n-        reacquireStats = lockStatsLogger.getOpStatsLogger(\"reacquire\");\n-        internalTryRetries = lockStatsLogger.getCounter(\"internalTryRetries\");\n-    }\n-\n-    private LockClosedException newLockClosedException() {\n-        return new LockClosedException(lockPath, \"Lock is already closed\");\n-    }\n-\n-    private synchronized void checkLockState() throws LockingException {\n-        if (closed) {\n-            throw newLockClosedException();\n-        }\n-        if (null != lockReacquireException) {\n-            throw lockReacquireException;\n-        }\n-    }\n-\n-    /**\n-     * Asynchronously acquire the lock. Technically the try phase of this operation--which adds us to the waiter\n-     * list--is executed synchronously, but the lock wait itself doesn't block.\n-     */\n-    public synchronized Future<DistributedLock> asyncAcquire() {\n-        if (null != lockAcquireFuture) {\n-            return Future.exception(new UnexpectedException(\"Someone is already acquiring/acquired lock \" + lockPath));\n-        }\n-        final Promise<DistributedLock> promise =\n-                new Promise<DistributedLock>(new Function<Throwable, BoxedUnit>() {\n-            @Override\n-            public BoxedUnit apply(Throwable cause) {\n-                lockStateExecutor.submit(lockPath, new Runnable() {\n-                    @Override\n-                    public void run() {\n-                        asyncClose();\n-                    }\n-                });\n-                return BoxedUnit.UNIT;\n-            }\n-        });\n-        final Stopwatch stopwatch = Stopwatch.createStarted();\n-        promise.addEventListener(new FutureEventListener<DistributedLock>() {\n-            @Override\n-            public void onSuccess(DistributedLock lock) {\n-                acquireStats.registerSuccessfulEvent(stopwatch.stop().elapsed(TimeUnit.MICROSECONDS));\n-            }\n-            @Override\n-            public void onFailure(Throwable cause) {\n-                acquireStats.registerFailedEvent(stopwatch.stop().elapsed(TimeUnit.MICROSECONDS));\n-                // release the lock if fail to acquire\n-                asyncClose();\n-            }\n-        });\n-        this.lockAcquireFuture = promise;\n-        lockStateExecutor.submit(lockPath, new Runnable() {\n-            @Override\n-            public void run() {\n-                doAsyncAcquire(promise, lockTimeout);\n-            }\n-        });\n-        return promise;\n-    }\n-\n-    void doAsyncAcquire(final Promise<DistributedLock> acquirePromise,\n-                        final long lockTimeout) {\n-        LOG.trace(\"Async Lock Acquire {}\", lockPath);\n-        try {\n-            checkLockState();\n-        } catch (IOException ioe) {\n-            FutureUtils.setException(acquirePromise, ioe);\n-            return;\n-        }\n-\n-        lockFactory.createLock(lockPath, lockContext).addEventListener(OrderedFutureEventListener.of(\n-                new FutureEventListener<SessionLock>() {\n-            @Override\n-            public void onSuccess(SessionLock lock) {\n-                synchronized (DistributedLock.this) {\n-                    if (closed) {\n-                        LOG.info(\"Skipping tryLocking lock {} since it is already closed\", lockPath);\n-                        FutureUtils.setException(acquirePromise, newLockClosedException());\n-                        return;\n-                    }\n-                }\n-                synchronized (DistributedLock.this) {\n-                    internalLock = lock;\n-                    internalLock.setLockListener(DistributedLock.this);\n-                }\n-                asyncTryLock(lock, acquirePromise, lockTimeout);\n-            }\n-\n-            @Override\n-            public void onFailure(Throwable cause) {\n-                FutureUtils.setException(acquirePromise, cause);\n-            }\n-        }, lockStateExecutor, lockPath));\n-    }\n-\n-    void asyncTryLock(SessionLock lock,\n-                      final Promise<DistributedLock> acquirePromise,\n-                      final long lockTimeout) {\n-        if (null != tryLockFuture) {\n-            tryLockFuture.cancel();\n-        }\n-        tryLockFuture = lock.asyncTryLock(lockTimeout, TimeUnit.MILLISECONDS);\n-        tryLockFuture.addEventListener(OrderedFutureEventListener.of(\n-                new FutureEventListener<LockWaiter>() {\n-                    @Override\n-                    public void onSuccess(LockWaiter waiter) {\n-                        synchronized (DistributedLock.this) {\n-                            if (closed) {\n-                                LOG.info(\"Skipping acquiring lock {} since it is already closed\", lockPath);\n-                                waiter.getAcquireFuture().raise(new LockingException(lockPath, \"lock is already closed.\"));\n-                                FutureUtils.setException(acquirePromise, newLockClosedException());\n-                                return;\n-                            }\n-                        }\n-                        tryLockFuture = null;\n-                        lockWaiter = waiter;\n-                        waitForAcquire(waiter, acquirePromise);\n-                    }\n-\n-                    @Override\n-                    public void onFailure(Throwable cause) {\n-                        FutureUtils.setException(acquirePromise, cause);\n-                    }\n-                }, lockStateExecutor, lockPath));\n-    }\n-\n-    void waitForAcquire(final LockWaiter waiter,\n-                        final Promise<DistributedLock> acquirePromise) {\n-        waiter.getAcquireFuture().addEventListener(OrderedFutureEventListener.of(\n-                new FutureEventListener<Boolean>() {\n-                    @Override\n-                    public void onSuccess(Boolean acquired) {\n-                        LOG.info(\"{} acquired lock {}\", waiter, lockPath);\n-                        if (acquired) {\n-                            FutureUtils.setValue(acquirePromise, DistributedLock.this);\n-                        } else {\n-                            FutureUtils.setException(acquirePromise,\n-                                    new OwnershipAcquireFailedException(lockPath, waiter.getCurrentOwner()));\n-                        }\n-                    }\n-\n-                    @Override\n-                    public void onFailure(Throwable cause) {\n-                        FutureUtils.setException(acquirePromise, cause);\n-                    }\n-                }, lockStateExecutor, lockPath));\n-    }\n+public interface DistributedLock extends AsyncCloseable {\n \n     /**\n-     * NOTE: The {@link LockListener#onExpired()} is already executed in lock executor.\n+     * Asynchronously acquire the lock.\n+     *\n+     * @return future represents the acquire result.\n      */\n-    @Override\n-    public void onExpired() {\n-        try {\n-            reacquireLock(false);\n-        } catch (LockingException le) {\n-            // should not happen\n-            LOG.error(\"Locking exception on re-acquiring lock {} : \", lockPath, le);\n-        }\n-    }\n+    Future<? extends DistributedLock> asyncAcquire();\n \n     /**\n-     * Check if hold lock, if it doesn't, then re-acquire the lock.\n+     * Check if hold lock. If it doesn't, then re-acquire the lock.\n      *\n-     * @throws LockingException     if the lock attempt fails\n+     * @throws LockingException if the lock attempt fails\n+     * @see #checkOwnership()\n      */\n-    public synchronized void checkOwnershipAndReacquire() throws LockingException {\n-        if (null == lockAcquireFuture || !lockAcquireFuture.isDefined()) {\n-            throw new LockingException(lockPath, \"check ownership before acquiring\");\n-        }\n-\n-        if (haveLock()) {\n-            return;\n-        }\n-\n-        // We may have just lost the lock because of a ZK session timeout\n-        // not necessarily because someone else acquired the lock.\n-        // In such cases just try to reacquire. If that fails, it will throw\n-        reacquireLock(true);\n-    }\n+    void checkOwnershipAndReacquire() throws LockingException;\n \n     /**\n-     * Check if lock is held.\n-     * If not, error out and do not reacquire. Use this in cases where there are many waiters by default\n-     * and reacquire is unlikley to succeed.\n+     * Check if the lock is held. If not, error out and do not re-acquire.\n+     * Use this in cases where there are many waiters by default and re-acquire\n+     * is unlikely to succeed.\n      *\n-     * @throws LockingException     if the lock attempt fails\n+     * @throws LockingException if we lost the ownership\n+     * @see #checkOwnershipAndReacquire()\n      */\n-    public synchronized void checkOwnership() throws LockingException {\n-        if (null == lockAcquireFuture || !lockAcquireFuture.isDefined()) {\n-            throw new LockingException(lockPath, \"check ownership before acquiring\");\n-        }\n-        if (!haveLock()) {\n-            throw new LockingException(lockPath, \"Lost lock ownership\");\n-        }\n-    }\n-\n-    @VisibleForTesting\n-    int getReacquireCount() {\n-        return reacquireCount.get();\n-    }\n-\n-    @VisibleForTesting\n-    Future<DistributedLock> getLockReacquireFuture() {\n-        return lockReacquireFuture;\n-    }\n-\n-    @VisibleForTesting\n-    Future<DistributedLock> getLockAcquireFuture() {\n-        return lockAcquireFuture;\n-    }\n-\n-    @VisibleForTesting\n-    synchronized SessionLock getInternalLock() {\n-        return internalLock;\n-    }\n-\n-    @VisibleForTesting\n-    LockWaiter getLockWaiter() {\n-        return lockWaiter;\n-    }\n-\n-    synchronized boolean haveLock() {\n-        return !closed && internalLock != null && internalLock.isLockHeld();\n-    }\n-\n-    void closeWaiter(final LockWaiter waiter,\n-                     final Promise<Void> closePromise) {\n-        if (null == waiter) {\n-            interruptTryLock(tryLockFuture, closePromise);\n-        } else {\n-            waiter.getAcquireFuture().addEventListener(OrderedFutureEventListener.of(\n-                    new FutureEventListener<Boolean>() {\n-                        @Override\n-                        public void onSuccess(Boolean value) {\n-                            unlockInternalLock(closePromise);\n-                        }\n-                        @Override\n-                        public void onFailure(Throwable cause) {\n-                            unlockInternalLock(closePromise);\n-                        }\n-                    }, lockStateExecutor, lockPath));\n-            FutureUtils.cancel(waiter.getAcquireFuture());\n-        }\n-    }\n-\n-    void interruptTryLock(final Future<LockWaiter> tryLockFuture,\n-                          final Promise<Void> closePromise) {\n-        if (null == tryLockFuture) {\n-            unlockInternalLock(closePromise);\n-        } else {\n-            tryLockFuture.addEventListener(OrderedFutureEventListener.of(\n-                    new FutureEventListener<LockWaiter>() {\n-                        @Override\n-                        public void onSuccess(LockWaiter waiter) {\n-                            closeWaiter(waiter, closePromise);\n-                        }\n-                        @Override\n-                        public void onFailure(Throwable cause) {\n-                            unlockInternalLock(closePromise);\n-                        }\n-                    }, lockStateExecutor, lockPath));\n-            FutureUtils.cancel(tryLockFuture);\n-        }\n-    }\n-\n-    synchronized void unlockInternalLock(final Promise<Void> closePromise) {\n-        if (internalLock == null) {\n-            FutureUtils.setValue(closePromise, null);\n-        } else {\n-            internalLock.asyncUnlock().ensure(new AbstractFunction0<BoxedUnit>() {\n-                @Override\n-                public BoxedUnit apply() {\n-                    FutureUtils.setValue(closePromise, null);\n-                    return BoxedUnit.UNIT;\n-                }\n-            });\n-        }\n-    }\n-\n-    @Override\n-    public Future<Void> asyncClose() {\n-        final Promise<Void> closePromise;\n-        synchronized (this) {\n-            if (closed) {\n-                return closeFuture;\n-            }\n-            closed = true;\n-            closeFuture = closePromise = new Promise<Void>();\n-        }\n-        final Promise<Void> closeWaiterFuture = new Promise<Void>();\n-        closeWaiterFuture.addEventListener(OrderedFutureEventListener.of(new FutureEventListener<Void>() {\n-            @Override\n-            public void onSuccess(Void value) {\n-                complete();\n-            }\n-            @Override\n-            public void onFailure(Throwable cause) {\n-                complete();\n-            }\n-\n-            private void complete() {\n-                FutureUtils.setValue(closePromise, null);\n-            }\n-        }, lockStateExecutor, lockPath));\n-        lockStateExecutor.submit(lockPath, new Runnable() {\n-            @Override\n-            public void run() {\n-                closeWaiter(lockWaiter, closeWaiterFuture);\n-            }\n-        });\n-        return closePromise;\n-    }\n-\n-    void internalReacquireLock(final AtomicInteger numRetries,\n-                               final long lockTimeout,\n-                               final Promise<DistributedLock> reacquirePromise) {\n-        lockStateExecutor.submit(lockPath, new Runnable() {\n-            @Override\n-            public void run() {\n-                doInternalReacquireLock(numRetries, lockTimeout, reacquirePromise);\n-            }\n-        });\n-    }\n-\n-    void doInternalReacquireLock(final AtomicInteger numRetries,\n-                                 final long lockTimeout,\n-                                 final Promise<DistributedLock> reacquirePromise) {\n-        internalTryRetries.inc();\n-        Promise<DistributedLock> tryPromise = new Promise<DistributedLock>();\n-        tryPromise.addEventListener(new FutureEventListener<DistributedLock>() {\n-            @Override\n-            public void onSuccess(DistributedLock lock) {\n-                FutureUtils.setValue(reacquirePromise, lock);\n-            }\n-\n-            @Override\n-            public void onFailure(Throwable cause) {\n-                if (cause instanceof OwnershipAcquireFailedException) {\n-                    // the lock has been acquired by others\n-                    FutureUtils.setException(reacquirePromise, cause);\n-                } else {\n-                    if (numRetries.getAndDecrement() > 0 && !closed) {\n-                        internalReacquireLock(numRetries, lockTimeout, reacquirePromise);\n-                    } else {\n-                        FutureUtils.setException(reacquirePromise, cause);\n-                    }\n-                }\n-            }\n-        });\n-        doAsyncAcquire(tryPromise, 0);\n-    }\n-\n-    private Future<DistributedLock> reacquireLock(boolean throwLockAcquireException) throws LockingException {\n-        final Stopwatch stopwatch = Stopwatch.createStarted();\n-        Promise<DistributedLock> lockPromise;\n-        synchronized (this) {\n-            if (closed) {\n-                throw newLockClosedException();\n-            }\n-            if (null != lockReacquireException) {\n-                if (throwLockAcquireException) {\n-                    throw lockReacquireException;\n-                } else {\n-                    return null;\n-                }\n-            }\n-            if (null != lockReacquireFuture) {\n-                return lockReacquireFuture;\n-            }\n-            LOG.info(\"reacquiring lock at {}\", lockPath);\n-            lockReacquireFuture = lockPromise = new Promise<DistributedLock>();\n-            lockReacquireFuture.addEventListener(new FutureEventListener<DistributedLock>() {\n-                @Override\n-                public void onSuccess(DistributedLock lock) {\n-                    // if re-acquire successfully, clear the state.\n-                    synchronized (DistributedLock.this) {\n-                        lockReacquireFuture = null;\n-                    }\n-                    reacquireStats.registerSuccessfulEvent(stopwatch.elapsed(TimeUnit.MICROSECONDS));\n-                }\n-\n-                @Override\n-                public void onFailure(Throwable cause) {\n-                    synchronized (DistributedLock.this) {\n-                        if (cause instanceof LockingException) {\n-                            lockReacquireException = (LockingException) cause;\n-                        } else {\n-                            lockReacquireException = new LockingException(lockPath,\n-                                    \"Exception on re-acquiring lock\", cause);\n-                        }\n-                    }\n-                    reacquireStats.registerFailedEvent(stopwatch.elapsed(TimeUnit.MICROSECONDS));\n-                }\n-            });\n-        }\n-        reacquireCount.incrementAndGet();\n-        internalReacquireLock(new AtomicInteger(Integer.MAX_VALUE), 0, lockPromise);\n-        return lockPromise;\n-    }\n+    void checkOwnership() throws LockingException;\n \n }"},{"sha":"75e32deefa366da852d154836397463f89821d06","filename":"src/main/java/com/twitter/distributedlog/lock/NopDistributedLock.java","status":"added","additions":34,"deletions":0,"changes":34,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/e39e3b036145907e9df87f72fb7b9773c4f35b45/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Flock%2FNopDistributedLock.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/e39e3b036145907e9df87f72fb7b9773c4f35b45/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Flock%2FNopDistributedLock.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Flock%2FNopDistributedLock.java?ref=e39e3b036145907e9df87f72fb7b9773c4f35b45","patch":"@@ -0,0 +1,34 @@\n+package com.twitter.distributedlog.lock;\n+\n+import com.twitter.distributedlog.exceptions.LockingException;\n+import com.twitter.util.Future;\n+\n+/**\n+ * An implementation of {@link DistributedLock} which does nothing.\n+ */\n+public class NopDistributedLock implements DistributedLock {\n+\n+    public static final DistributedLock INSTANCE = new NopDistributedLock();\n+\n+    private NopDistributedLock() {}\n+\n+    @Override\n+    public Future<? extends DistributedLock> asyncAcquire() {\n+        return Future.value(this);\n+    }\n+\n+    @Override\n+    public void checkOwnershipAndReacquire() throws LockingException {\n+        // no-op\n+    }\n+\n+    @Override\n+    public void checkOwnership() throws LockingException {\n+        // no-op\n+    }\n+\n+    @Override\n+    public Future<Void> asyncClose() {\n+        return Future.Void();\n+    }\n+}"},{"sha":"95cd5939d2505677d36f4a6d49ba80f6de2487dd","filename":"src/main/java/com/twitter/distributedlog/lock/SessionLock.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/e39e3b036145907e9df87f72fb7b9773c4f35b45/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Flock%2FSessionLock.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/e39e3b036145907e9df87f72fb7b9773c4f35b45/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Flock%2FSessionLock.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Flock%2FSessionLock.java?ref=e39e3b036145907e9df87f72fb7b9773c4f35b45","patch":"@@ -70,7 +70,7 @@ public interface SessionLock {\n      * <p>\n      * <i>tryLock</i> here is effectively the combination of following asynchronous calls.\n      * <pre>\n-     *     DistributedLock lock = ...;\n+     *     ZKDistributedLock lock = ...;\n      *     Future<LockWaiter> attemptFuture = lock.asyncTryLock(...);\n      *\n      *     boolean acquired = waiter.waitForAcquireQuietly();"},{"sha":"7e9f35b81db0c2dc53d5fd513c7768015112be7c","filename":"src/main/java/com/twitter/distributedlog/lock/ZKDistributedLock.java","status":"added","additions":537,"deletions":0,"changes":537,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/e39e3b036145907e9df87f72fb7b9773c4f35b45/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Flock%2FZKDistributedLock.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/e39e3b036145907e9df87f72fb7b9773c4f35b45/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Flock%2FZKDistributedLock.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Flock%2FZKDistributedLock.java?ref=e39e3b036145907e9df87f72fb7b9773c4f35b45","patch":"@@ -0,0 +1,537 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.twitter.distributedlog.lock;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+import com.twitter.concurrent.AsyncSemaphore;\n+import com.twitter.distributedlog.exceptions.LockingException;\n+import com.twitter.distributedlog.exceptions.OwnershipAcquireFailedException;\n+import com.twitter.distributedlog.exceptions.UnexpectedException;\n+import com.twitter.distributedlog.util.FutureUtils;\n+import com.twitter.distributedlog.util.FutureUtils.OrderedFutureEventListener;\n+import com.twitter.distributedlog.util.OrderedScheduler;\n+import com.twitter.util.Function;\n+import com.twitter.util.Future;\n+import com.twitter.util.FutureEventListener;\n+import com.twitter.util.Promise;\n+import org.apache.bookkeeper.stats.Counter;\n+import org.apache.bookkeeper.stats.OpStatsLogger;\n+import org.apache.bookkeeper.stats.StatsLogger;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import scala.runtime.AbstractFunction0;\n+import scala.runtime.BoxedUnit;\n+\n+import java.io.IOException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+/**\n+ * Distributed lock, using ZooKeeper.\n+ * <p/>\n+ * The lock is vulnerable to timing issues. For example, the process could\n+ * encounter a really long GC cycle between acquiring the lock, and writing to\n+ * a ledger. This could have timed out the lock, and another process could have\n+ * acquired the lock and started writing to bookkeeper. Therefore other\n+ * mechanisms are required to ensure correctness (i.e. Fencing).\n+ * <p/>\n+ * The lock is only allowed to acquire once. If the lock is acquired successfully,\n+ * the caller holds the ownership until it loses the ownership either because of\n+ * others already acquired the lock when session expired or explicitly close it.\n+ * <p>\n+ * The caller could use {@link #checkOwnership()} or {@link #checkOwnershipAndReacquire()}\n+ * to check if it still holds the lock. If it doesn't hold the lock, the caller should\n+ * give up the ownership and close the lock.\n+ * <h3>Metrics</h3>\n+ * All the lock related stats are exposed under `lock`.\n+ * <ul>\n+ * <li>lock/acquire: opstats. latency spent on acquiring a lock.\n+ * <li>lock/reacquire: opstats. latency spent on re-acquiring a lock.\n+ * <li>lock/internalTryRetries: counter. the number of retries on re-creating internal locks.\n+ * </ul>\n+ * Other internal lock related stats are also exposed under `lock`. See {@link SessionLock}\n+ * for details.\n+ */\n+public class ZKDistributedLock implements LockListener, DistributedLock {\n+\n+    static final Logger LOG = LoggerFactory.getLogger(ZKDistributedLock.class);\n+\n+    private final SessionLockFactory lockFactory;\n+    private final OrderedScheduler lockStateExecutor;\n+    private final String lockPath;\n+    private final long lockTimeout;\n+    private final DistributedLockContext lockContext = new DistributedLockContext();\n+\n+    private final AsyncSemaphore lockSemaphore = new AsyncSemaphore(1);\n+    // We have two lock acquire futures:\n+    // 1. lock acquire future: for the initial acquire op\n+    // 2. lock reacquire future: for reacquire necessary when session expires, lock is closed\n+    private Future<ZKDistributedLock> lockAcquireFuture = null;\n+    private Future<ZKDistributedLock> lockReacquireFuture = null;\n+    // following variable tracking the status of acquire process\n+    //   => create (internalLock) => tryLock (tryLockFuture) => waitForAcquire (lockWaiter)\n+    private SessionLock internalLock = null;\n+    private Future<LockWaiter> tryLockFuture = null;\n+    private LockWaiter lockWaiter = null;\n+    // exception indicating if the reacquire failed\n+    private LockingException lockReacquireException = null;\n+    // closeFuture\n+    private volatile boolean closed = false;\n+    private Future<Void> closeFuture = null;\n+\n+    // A counter to track how many re-acquires happened during a lock's life cycle.\n+    private final AtomicInteger reacquireCount = new AtomicInteger(0);\n+    private final StatsLogger lockStatsLogger;\n+    private final OpStatsLogger acquireStats;\n+    private final OpStatsLogger reacquireStats;\n+    private final Counter internalTryRetries;\n+\n+    public ZKDistributedLock(\n+            OrderedScheduler lockStateExecutor,\n+            SessionLockFactory lockFactory,\n+            String lockPath,\n+            long lockTimeout,\n+            StatsLogger statsLogger) {\n+        this.lockStateExecutor = lockStateExecutor;\n+        this.lockPath = lockPath;\n+        this.lockTimeout = lockTimeout;\n+        this.lockFactory = lockFactory;\n+\n+        lockStatsLogger = statsLogger.scope(\"lock\");\n+        acquireStats = lockStatsLogger.getOpStatsLogger(\"acquire\");\n+        reacquireStats = lockStatsLogger.getOpStatsLogger(\"reacquire\");\n+        internalTryRetries = lockStatsLogger.getCounter(\"internalTryRetries\");\n+    }\n+\n+    private LockClosedException newLockClosedException() {\n+        return new LockClosedException(lockPath, \"Lock is already closed\");\n+    }\n+\n+    private synchronized void checkLockState() throws LockingException {\n+        if (closed) {\n+            throw newLockClosedException();\n+        }\n+        if (null != lockReacquireException) {\n+            throw lockReacquireException;\n+        }\n+    }\n+\n+    /**\n+     * Asynchronously acquire the lock. Technically the try phase of this operation--which adds us to the waiter\n+     * list--is executed synchronously, but the lock wait itself doesn't block.\n+     */\n+    public synchronized Future<ZKDistributedLock> asyncAcquire() {\n+        if (null != lockAcquireFuture) {\n+            return Future.exception(new UnexpectedException(\"Someone is already acquiring/acquired lock \" + lockPath));\n+        }\n+        final Promise<ZKDistributedLock> promise =\n+                new Promise<ZKDistributedLock>(new Function<Throwable, BoxedUnit>() {\n+            @Override\n+            public BoxedUnit apply(Throwable cause) {\n+                lockStateExecutor.submit(lockPath, new Runnable() {\n+                    @Override\n+                    public void run() {\n+                        asyncClose();\n+                    }\n+                });\n+                return BoxedUnit.UNIT;\n+            }\n+        });\n+        final Stopwatch stopwatch = Stopwatch.createStarted();\n+        promise.addEventListener(new FutureEventListener<ZKDistributedLock>() {\n+            @Override\n+            public void onSuccess(ZKDistributedLock lock) {\n+                acquireStats.registerSuccessfulEvent(stopwatch.stop().elapsed(TimeUnit.MICROSECONDS));\n+            }\n+            @Override\n+            public void onFailure(Throwable cause) {\n+                acquireStats.registerFailedEvent(stopwatch.stop().elapsed(TimeUnit.MICROSECONDS));\n+                // release the lock if fail to acquire\n+                asyncClose();\n+            }\n+        });\n+        this.lockAcquireFuture = promise;\n+        lockStateExecutor.submit(lockPath, new Runnable() {\n+            @Override\n+            public void run() {\n+                doAsyncAcquireWithSemaphore(promise, lockTimeout);\n+            }\n+        });\n+        return promise;\n+    }\n+\n+    void doAsyncAcquireWithSemaphore(final Promise<ZKDistributedLock> acquirePromise,\n+                                     final long lockTimeout) {\n+        lockSemaphore.acquireAndRun(new AbstractFunction0<Future<ZKDistributedLock>>() {\n+            @Override\n+            public Future<ZKDistributedLock> apply() {\n+                doAsyncAcquire(acquirePromise, lockTimeout);\n+                return acquirePromise;\n+            }\n+        });\n+    }\n+\n+    void doAsyncAcquire(final Promise<ZKDistributedLock> acquirePromise,\n+                        final long lockTimeout) {\n+        LOG.trace(\"Async Lock Acquire {}\", lockPath);\n+        try {\n+            checkLockState();\n+        } catch (IOException ioe) {\n+            FutureUtils.setException(acquirePromise, ioe);\n+            return;\n+        }\n+\n+        if (haveLock()) {\n+            // it already hold the lock\n+            FutureUtils.setValue(acquirePromise, this);\n+            return;\n+        }\n+\n+        lockFactory.createLock(lockPath, lockContext).addEventListener(OrderedFutureEventListener.of(\n+                new FutureEventListener<SessionLock>() {\n+            @Override\n+            public void onSuccess(SessionLock lock) {\n+                synchronized (ZKDistributedLock.this) {\n+                    if (closed) {\n+                        LOG.info(\"Skipping tryLocking lock {} since it is already closed\", lockPath);\n+                        FutureUtils.setException(acquirePromise, newLockClosedException());\n+                        return;\n+                    }\n+                }\n+                synchronized (ZKDistributedLock.this) {\n+                    internalLock = lock;\n+                    internalLock.setLockListener(ZKDistributedLock.this);\n+                }\n+                asyncTryLock(lock, acquirePromise, lockTimeout);\n+            }\n+\n+            @Override\n+            public void onFailure(Throwable cause) {\n+                FutureUtils.setException(acquirePromise, cause);\n+            }\n+        }, lockStateExecutor, lockPath));\n+    }\n+\n+    void asyncTryLock(SessionLock lock,\n+                      final Promise<ZKDistributedLock> acquirePromise,\n+                      final long lockTimeout) {\n+        if (null != tryLockFuture) {\n+            tryLockFuture.cancel();\n+        }\n+        tryLockFuture = lock.asyncTryLock(lockTimeout, TimeUnit.MILLISECONDS);\n+        tryLockFuture.addEventListener(OrderedFutureEventListener.of(\n+                new FutureEventListener<LockWaiter>() {\n+                    @Override\n+                    public void onSuccess(LockWaiter waiter) {\n+                        synchronized (ZKDistributedLock.this) {\n+                            if (closed) {\n+                                LOG.info(\"Skipping acquiring lock {} since it is already closed\", lockPath);\n+                                waiter.getAcquireFuture().raise(new LockingException(lockPath, \"lock is already closed.\"));\n+                                FutureUtils.setException(acquirePromise, newLockClosedException());\n+                                return;\n+                            }\n+                        }\n+                        tryLockFuture = null;\n+                        lockWaiter = waiter;\n+                        waitForAcquire(waiter, acquirePromise);\n+                    }\n+\n+                    @Override\n+                    public void onFailure(Throwable cause) {\n+                        FutureUtils.setException(acquirePromise, cause);\n+                    }\n+                }, lockStateExecutor, lockPath));\n+    }\n+\n+    void waitForAcquire(final LockWaiter waiter,\n+                        final Promise<ZKDistributedLock> acquirePromise) {\n+        waiter.getAcquireFuture().addEventListener(OrderedFutureEventListener.of(\n+                new FutureEventListener<Boolean>() {\n+                    @Override\n+                    public void onSuccess(Boolean acquired) {\n+                        LOG.info(\"{} acquired lock {}\", waiter, lockPath);\n+                        if (acquired) {\n+                            FutureUtils.setValue(acquirePromise, ZKDistributedLock.this);\n+                        } else {\n+                            FutureUtils.setException(acquirePromise,\n+                                    new OwnershipAcquireFailedException(lockPath, waiter.getCurrentOwner()));\n+                        }\n+                    }\n+\n+                    @Override\n+                    public void onFailure(Throwable cause) {\n+                        FutureUtils.setException(acquirePromise, cause);\n+                    }\n+                }, lockStateExecutor, lockPath));\n+    }\n+\n+    /**\n+     * NOTE: The {@link LockListener#onExpired()} is already executed in lock executor.\n+     */\n+    @Override\n+    public void onExpired() {\n+        try {\n+            reacquireLock(false);\n+        } catch (LockingException le) {\n+            // should not happen\n+            LOG.error(\"Locking exception on re-acquiring lock {} : \", lockPath, le);\n+        }\n+    }\n+\n+    /**\n+     * Check if hold lock, if it doesn't, then re-acquire the lock.\n+     *\n+     * @throws LockingException     if the lock attempt fails\n+     */\n+    public synchronized void checkOwnershipAndReacquire() throws LockingException {\n+        if (null == lockAcquireFuture || !lockAcquireFuture.isDefined()) {\n+            throw new LockingException(lockPath, \"check ownership before acquiring\");\n+        }\n+\n+        if (haveLock()) {\n+            return;\n+        }\n+\n+        // We may have just lost the lock because of a ZK session timeout\n+        // not necessarily because someone else acquired the lock.\n+        // In such cases just try to reacquire. If that fails, it will throw\n+        reacquireLock(true);\n+    }\n+\n+    /**\n+     * Check if lock is held.\n+     * If not, error out and do not reacquire. Use this in cases where there are many waiters by default\n+     * and reacquire is unlikley to succeed.\n+     *\n+     * @throws LockingException     if the lock attempt fails\n+     */\n+    public synchronized void checkOwnership() throws LockingException {\n+        if (null == lockAcquireFuture || !lockAcquireFuture.isDefined()) {\n+            throw new LockingException(lockPath, \"check ownership before acquiring\");\n+        }\n+        if (!haveLock()) {\n+            throw new LockingException(lockPath, \"Lost lock ownership\");\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    int getReacquireCount() {\n+        return reacquireCount.get();\n+    }\n+\n+    @VisibleForTesting\n+    Future<ZKDistributedLock> getLockReacquireFuture() {\n+        return lockReacquireFuture;\n+    }\n+\n+    @VisibleForTesting\n+    Future<ZKDistributedLock> getLockAcquireFuture() {\n+        return lockAcquireFuture;\n+    }\n+\n+    @VisibleForTesting\n+    synchronized SessionLock getInternalLock() {\n+        return internalLock;\n+    }\n+\n+    @VisibleForTesting\n+    LockWaiter getLockWaiter() {\n+        return lockWaiter;\n+    }\n+\n+    synchronized boolean haveLock() {\n+        return !closed && internalLock != null && internalLock.isLockHeld();\n+    }\n+\n+    void closeWaiter(final LockWaiter waiter,\n+                     final Promise<Void> closePromise) {\n+        if (null == waiter) {\n+            interruptTryLock(tryLockFuture, closePromise);\n+        } else {\n+            waiter.getAcquireFuture().addEventListener(OrderedFutureEventListener.of(\n+                    new FutureEventListener<Boolean>() {\n+                        @Override\n+                        public void onSuccess(Boolean value) {\n+                            unlockInternalLock(closePromise);\n+                        }\n+                        @Override\n+                        public void onFailure(Throwable cause) {\n+                            unlockInternalLock(closePromise);\n+                        }\n+                    }, lockStateExecutor, lockPath));\n+            FutureUtils.cancel(waiter.getAcquireFuture());\n+        }\n+    }\n+\n+    void interruptTryLock(final Future<LockWaiter> tryLockFuture,\n+                          final Promise<Void> closePromise) {\n+        if (null == tryLockFuture) {\n+            unlockInternalLock(closePromise);\n+        } else {\n+            tryLockFuture.addEventListener(OrderedFutureEventListener.of(\n+                    new FutureEventListener<LockWaiter>() {\n+                        @Override\n+                        public void onSuccess(LockWaiter waiter) {\n+                            closeWaiter(waiter, closePromise);\n+                        }\n+                        @Override\n+                        public void onFailure(Throwable cause) {\n+                            unlockInternalLock(closePromise);\n+                        }\n+                    }, lockStateExecutor, lockPath));\n+            FutureUtils.cancel(tryLockFuture);\n+        }\n+    }\n+\n+    synchronized void unlockInternalLock(final Promise<Void> closePromise) {\n+        if (internalLock == null) {\n+            FutureUtils.setValue(closePromise, null);\n+        } else {\n+            internalLock.asyncUnlock().ensure(new AbstractFunction0<BoxedUnit>() {\n+                @Override\n+                public BoxedUnit apply() {\n+                    FutureUtils.setValue(closePromise, null);\n+                    return BoxedUnit.UNIT;\n+                }\n+            });\n+        }\n+    }\n+\n+    @Override\n+    public Future<Void> asyncClose() {\n+        final Promise<Void> closePromise;\n+        synchronized (this) {\n+            if (closed) {\n+                return closeFuture;\n+            }\n+            closed = true;\n+            closeFuture = closePromise = new Promise<Void>();\n+        }\n+        final Promise<Void> closeWaiterFuture = new Promise<Void>();\n+        closeWaiterFuture.addEventListener(OrderedFutureEventListener.of(new FutureEventListener<Void>() {\n+            @Override\n+            public void onSuccess(Void value) {\n+                complete();\n+            }\n+            @Override\n+            public void onFailure(Throwable cause) {\n+                complete();\n+            }\n+\n+            private void complete() {\n+                FutureUtils.setValue(closePromise, null);\n+            }\n+        }, lockStateExecutor, lockPath));\n+        lockStateExecutor.submit(lockPath, new Runnable() {\n+            @Override\n+            public void run() {\n+                closeWaiter(lockWaiter, closeWaiterFuture);\n+            }\n+        });\n+        return closePromise;\n+    }\n+\n+    void internalReacquireLock(final AtomicInteger numRetries,\n+                               final long lockTimeout,\n+                               final Promise<ZKDistributedLock> reacquirePromise) {\n+        lockStateExecutor.submit(lockPath, new Runnable() {\n+            @Override\n+            public void run() {\n+                doInternalReacquireLock(numRetries, lockTimeout, reacquirePromise);\n+            }\n+        });\n+    }\n+\n+    void doInternalReacquireLock(final AtomicInteger numRetries,\n+                                 final long lockTimeout,\n+                                 final Promise<ZKDistributedLock> reacquirePromise) {\n+        internalTryRetries.inc();\n+        Promise<ZKDistributedLock> tryPromise = new Promise<ZKDistributedLock>();\n+        tryPromise.addEventListener(new FutureEventListener<ZKDistributedLock>() {\n+            @Override\n+            public void onSuccess(ZKDistributedLock lock) {\n+                FutureUtils.setValue(reacquirePromise, lock);\n+            }\n+\n+            @Override\n+            public void onFailure(Throwable cause) {\n+                if (cause instanceof OwnershipAcquireFailedException) {\n+                    // the lock has been acquired by others\n+                    FutureUtils.setException(reacquirePromise, cause);\n+                } else {\n+                    if (numRetries.getAndDecrement() > 0 && !closed) {\n+                        internalReacquireLock(numRetries, lockTimeout, reacquirePromise);\n+                    } else {\n+                        FutureUtils.setException(reacquirePromise, cause);\n+                    }\n+                }\n+            }\n+        });\n+        doAsyncAcquireWithSemaphore(tryPromise, 0);\n+    }\n+\n+    private Future<ZKDistributedLock> reacquireLock(boolean throwLockAcquireException) throws LockingException {\n+        final Stopwatch stopwatch = Stopwatch.createStarted();\n+        Promise<ZKDistributedLock> lockPromise;\n+        synchronized (this) {\n+            if (closed) {\n+                throw newLockClosedException();\n+            }\n+            if (null != lockReacquireException) {\n+                if (throwLockAcquireException) {\n+                    throw lockReacquireException;\n+                } else {\n+                    return null;\n+                }\n+            }\n+            if (null != lockReacquireFuture) {\n+                return lockReacquireFuture;\n+            }\n+            LOG.info(\"reacquiring lock at {}\", lockPath);\n+            lockReacquireFuture = lockPromise = new Promise<ZKDistributedLock>();\n+            lockReacquireFuture.addEventListener(new FutureEventListener<ZKDistributedLock>() {\n+                @Override\n+                public void onSuccess(ZKDistributedLock lock) {\n+                    // if re-acquire successfully, clear the state.\n+                    synchronized (ZKDistributedLock.this) {\n+                        lockReacquireFuture = null;\n+                    }\n+                    reacquireStats.registerSuccessfulEvent(stopwatch.elapsed(TimeUnit.MICROSECONDS));\n+                }\n+\n+                @Override\n+                public void onFailure(Throwable cause) {\n+                    synchronized (ZKDistributedLock.this) {\n+                        if (cause instanceof LockingException) {\n+                            lockReacquireException = (LockingException) cause;\n+                        } else {\n+                            lockReacquireException = new LockingException(lockPath,\n+                                    \"Exception on re-acquiring lock\", cause);\n+                        }\n+                    }\n+                    reacquireStats.registerFailedEvent(stopwatch.elapsed(TimeUnit.MICROSECONDS));\n+                }\n+            });\n+        }\n+        reacquireCount.incrementAndGet();\n+        internalReacquireLock(new AtomicInteger(Integer.MAX_VALUE), 0, lockPromise);\n+        return lockPromise;\n+    }\n+\n+}"},{"sha":"3355c9b7de39fe273e62e9c927d40b4c683f0579","filename":"src/test/java/com/twitter/distributedlog/DLMTestUtil.java","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/e39e3b036145907e9df87f72fb7b9773c4f35b45/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FDLMTestUtil.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/e39e3b036145907e9df87f72fb7b9773c4f35b45/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FDLMTestUtil.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FDLMTestUtil.java?ref=e39e3b036145907e9df87f72fb7b9773c4f35b45","patch":"@@ -536,6 +536,7 @@ public static ServerConfiguration loadTestBkConf() {\n         } catch (org.apache.commons.configuration.ConfigurationException ex) {\n             LOG.warn(\"loading conf failed\", ex);\n         }\n+        conf.setAllowLoopback(true);\n         return conf;\n     }\n "},{"sha":"787f74fc310319d3f6270255bc1d71d7e7361a47","filename":"src/test/java/com/twitter/distributedlog/TestAsyncReaderWriter.java","status":"modified","additions":0,"deletions":1,"changes":1,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/e39e3b036145907e9df87f72fb7b9773c4f35b45/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestAsyncReaderWriter.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/e39e3b036145907e9df87f72fb7b9773c4f35b45/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestAsyncReaderWriter.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestAsyncReaderWriter.java?ref=e39e3b036145907e9df87f72fb7b9773c4f35b45","patch":"@@ -51,7 +51,6 @@\n import org.slf4j.LoggerFactory;\n \n import com.google.common.base.Stopwatch;\n-import com.twitter.distributedlog.annotations.DistributedLogAnnotations;\n import com.twitter.distributedlog.exceptions.DLIllegalStateException;\n import com.twitter.distributedlog.exceptions.EndOfStreamException;\n import com.twitter.distributedlog.exceptions.IdleReaderException;"},{"sha":"3fa3e7dd72518f553c8589f27bd72dfc5f2ba88b","filename":"src/test/java/com/twitter/distributedlog/TestBKDistributedLogManager.java","status":"modified","additions":24,"deletions":0,"changes":24,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/e39e3b036145907e9df87f72fb7b9773c4f35b45/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestBKDistributedLogManager.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/e39e3b036145907e9df87f72fb7b9773c4f35b45/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestBKDistributedLogManager.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestBKDistributedLogManager.java?ref=e39e3b036145907e9df87f72fb7b9773c4f35b45","patch":"@@ -27,6 +27,7 @@\n import java.util.concurrent.atomic.AtomicReference;\n \n import com.twitter.distributedlog.exceptions.AlreadyTruncatedTransactionException;\n+import com.twitter.distributedlog.exceptions.BKTransmitException;\n import com.twitter.distributedlog.exceptions.LogEmptyException;\n import com.twitter.distributedlog.exceptions.LogNotFoundException;\n import com.twitter.distributedlog.exceptions.LogReadException;\n@@ -35,6 +36,7 @@\n import com.twitter.distributedlog.util.FutureUtils;\n import com.twitter.distributedlog.util.OrderedScheduler;\n import com.twitter.distributedlog.util.Utils;\n+import org.apache.bookkeeper.client.BKException;\n import org.junit.Assert;\n import org.junit.Rule;\n import org.junit.Test;\n@@ -321,6 +323,28 @@ public void testTwoWriters() throws Exception {\n         bkdlm1.close();\n     }\n \n+    @Test(timeout = 60000)\n+    public void testTwoWritersOnLockDisabled() throws Exception {\n+        DistributedLogConfiguration confLocal = new DistributedLogConfiguration();\n+        confLocal.addConfiguration(conf);\n+        confLocal.setOutputBufferSize(0);\n+        confLocal.setWriteLockEnabled(false);\n+        String name = \"distrlog-two-writers-lock-disabled\";\n+        DistributedLogManager manager = createNewDLM(confLocal, name);\n+        AsyncLogWriter writer1 = FutureUtils.result(manager.openAsyncLogWriter());\n+        FutureUtils.result(writer1.write(DLMTestUtil.getLogRecordInstance(1L)));\n+        AsyncLogWriter writer2 = FutureUtils.result(manager.openAsyncLogWriter());\n+        FutureUtils.result(writer2.write(DLMTestUtil.getLogRecordInstance(2L)));\n+\n+        // write a record to writer 1 again\n+        try {\n+            FutureUtils.result(writer1.write(DLMTestUtil.getLogRecordInstance(3L)));\n+            fail(\"Should fail writing record to writer 1 again as writer 2 took over the ownership\");\n+        } catch (BKTransmitException bkte) {\n+            assertEquals(BKException.Code.LedgerFencedException, bkte.getBKResultCode());\n+        }\n+    }\n+\n     @Test(timeout = 60000)\n     public void testSimpleRead() throws Exception {\n         String name = \"distrlog-simpleread\";"},{"sha":"43e55e460476ce348242f48967e4631d710a9471","filename":"src/test/java/com/twitter/distributedlog/TestBKLogSegmentWriter.java","status":"modified","additions":28,"deletions":28,"changes":56,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/e39e3b036145907e9df87f72fb7b9773c4f35b45/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestBKLogSegmentWriter.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/e39e3b036145907e9df87f72fb7b9773c4f35b45/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestBKLogSegmentWriter.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestBKLogSegmentWriter.java?ref=e39e3b036145907e9df87f72fb7b9773c4f35b45","patch":"@@ -24,7 +24,7 @@\n import com.twitter.distributedlog.impl.BKLogSegmentEntryWriter;\n import com.twitter.distributedlog.io.Abortables;\n import com.twitter.distributedlog.lock.SessionLockFactory;\n-import com.twitter.distributedlog.lock.DistributedLock;\n+import com.twitter.distributedlog.lock.ZKDistributedLock;\n import com.twitter.distributedlog.lock.ZKSessionLockFactory;\n import com.twitter.distributedlog.metadata.BKDLConfig;\n import com.twitter.distributedlog.util.ConfUtils;\n@@ -128,9 +128,9 @@ private DistributedLogConfiguration newLocalConf() {\n         return confLocal;\n     }\n \n-    private DistributedLock createLock(String path,\n-                                       ZooKeeperClient zkClient,\n-                                       boolean acquireLock)\n+    private ZKDistributedLock createLock(String path,\n+                                         ZooKeeperClient zkClient,\n+                                         boolean acquireLock)\n             throws Exception {\n         try {\n             Await.result(Utils.zkAsyncCreateFullPathOptimistic(zkClient, path, new byte[0],\n@@ -147,7 +147,7 @@ private DistributedLock createLock(String path,\n                 conf.getZKSessionTimeoutMilliseconds(),\n                 NullStatsLogger.INSTANCE\n         );\n-        DistributedLock lock = new DistributedLock(\n+        ZKDistributedLock lock = new ZKDistributedLock(\n                 lockStateExecutor,\n                 lockFactory,\n                 path,\n@@ -161,7 +161,7 @@ private DistributedLock createLock(String path,\n     }\n \n     private void closeWriterAndLock(BKLogSegmentWriter writer,\n-                                    DistributedLock lock)\n+                                    ZKDistributedLock lock)\n             throws IOException {\n         try {\n             FutureUtils.result(writer.asyncClose());\n@@ -171,7 +171,7 @@ private void closeWriterAndLock(BKLogSegmentWriter writer,\n     }\n \n     private void abortWriterAndLock(BKLogSegmentWriter writer,\n-                                    DistributedLock lock)\n+                                    ZKDistributedLock lock)\n             throws IOException {\n         try {\n             Abortables.abort(writer, false);\n@@ -183,7 +183,7 @@ private void abortWriterAndLock(BKLogSegmentWriter writer,\n     private BKLogSegmentWriter createLogSegmentWriter(DistributedLogConfiguration conf,\n                                                       long logSegmentSequenceNumber,\n                                                       long startTxId,\n-                                                      DistributedLock lock) throws Exception {\n+                                                      ZKDistributedLock lock) throws Exception {\n         LedgerHandle lh = bkc.get().createLedger(3, 2, 2,\n                 BookKeeper.DigestType.CRC32, conf.getBKDigestPW().getBytes(UTF_8));\n         return new BKLogSegmentWriter(\n@@ -230,12 +230,12 @@ public void testCloseShouldFlush() throws Exception {\n         confLocal.setImmediateFlushEnabled(false);\n         confLocal.setOutputBufferSize(Integer.MAX_VALUE);\n         confLocal.setPeriodicFlushFrequencyMilliSeconds(0);\n-        DistributedLock lock = createLock(\"/test/lock-\" + runtime.getMethodName(), zkc, true);\n+        ZKDistributedLock lock = createLock(\"/test/lock-\" + runtime.getMethodName(), zkc, true);\n         BKLogSegmentWriter writer =\n                 createLogSegmentWriter(confLocal, 0L, -1L, lock);\n         // Use another lock to wait for writer releasing lock\n-        DistributedLock lock0 = createLock(\"/test/lock-\" + runtime.getMethodName(), zkc0, false);\n-        Future<DistributedLock> lockFuture0 = lock0.asyncAcquire();\n+        ZKDistributedLock lock0 = createLock(\"/test/lock-\" + runtime.getMethodName(), zkc0, false);\n+        Future<ZKDistributedLock> lockFuture0 = lock0.asyncAcquire();\n         // add 10 records\n         int numRecords = 10;\n         List<Future<DLSN>> futureList = new ArrayList<Future<DLSN>>(numRecords);\n@@ -292,12 +292,12 @@ public void testAbortShouldNotFlush() throws Exception {\n         confLocal.setImmediateFlushEnabled(false);\n         confLocal.setOutputBufferSize(Integer.MAX_VALUE);\n         confLocal.setPeriodicFlushFrequencyMilliSeconds(0);\n-        DistributedLock lock = createLock(\"/test/lock-\" + runtime.getMethodName(), zkc, true);\n+        ZKDistributedLock lock = createLock(\"/test/lock-\" + runtime.getMethodName(), zkc, true);\n         BKLogSegmentWriter writer =\n                 createLogSegmentWriter(confLocal, 0L, -1L, lock);\n         // Use another lock to wait for writer releasing lock\n-        DistributedLock lock0 = createLock(\"/test/lock-\" + runtime.getMethodName(), zkc0, false);\n-        Future<DistributedLock> lockFuture0 = lock0.asyncAcquire();\n+        ZKDistributedLock lock0 = createLock(\"/test/lock-\" + runtime.getMethodName(), zkc0, false);\n+        Future<ZKDistributedLock> lockFuture0 = lock0.asyncAcquire();\n         // add 10 records\n         int numRecords = 10;\n         List<Future<DLSN>> futureList = new ArrayList<Future<DLSN>>(numRecords);\n@@ -368,12 +368,12 @@ void testCloseShouldNotFlushIfInErrorState(int rcToFailComplete) throws Exceptio\n         confLocal.setImmediateFlushEnabled(false);\n         confLocal.setOutputBufferSize(Integer.MAX_VALUE);\n         confLocal.setPeriodicFlushFrequencyMilliSeconds(0);\n-        DistributedLock lock = createLock(\"/test/lock-\" + runtime.getMethodName(), zkc, true);\n+        ZKDistributedLock lock = createLock(\"/test/lock-\" + runtime.getMethodName(), zkc, true);\n         BKLogSegmentWriter writer =\n                 createLogSegmentWriter(confLocal, 0L, -1L, lock);\n         // Use another lock to wait for writer releasing lock\n-        DistributedLock lock0 = createLock(\"/test/lock-\" + runtime.getMethodName(), zkc0, false);\n-        Future<DistributedLock> lockFuture0 = lock0.asyncAcquire();\n+        ZKDistributedLock lock0 = createLock(\"/test/lock-\" + runtime.getMethodName(), zkc0, false);\n+        Future<ZKDistributedLock> lockFuture0 = lock0.asyncAcquire();\n         // add 10 records\n         int numRecords = 10;\n         List<Future<DLSN>> futureList = new ArrayList<Future<DLSN>>(numRecords);\n@@ -440,12 +440,12 @@ public void testCloseShouldFailIfLedgerFenced() throws Exception {\n         confLocal.setImmediateFlushEnabled(false);\n         confLocal.setOutputBufferSize(Integer.MAX_VALUE);\n         confLocal.setPeriodicFlushFrequencyMilliSeconds(0);\n-        DistributedLock lock = createLock(\"/test/lock-\" + runtime.getMethodName(), zkc, true);\n+        ZKDistributedLock lock = createLock(\"/test/lock-\" + runtime.getMethodName(), zkc, true);\n         BKLogSegmentWriter writer =\n                 createLogSegmentWriter(confLocal, 0L, -1L, lock);\n         // Use another lock to wait for writer releasing lock\n-        DistributedLock lock0 = createLock(\"/test/lock-\" + runtime.getMethodName(), zkc0, false);\n-        Future<DistributedLock> lockFuture0 = lock0.asyncAcquire();\n+        ZKDistributedLock lock0 = createLock(\"/test/lock-\" + runtime.getMethodName(), zkc0, false);\n+        Future<ZKDistributedLock> lockFuture0 = lock0.asyncAcquire();\n         // add 10 records\n         int numRecords = 10;\n         List<Future<DLSN>> futureList = new ArrayList<Future<DLSN>>(numRecords);\n@@ -512,12 +512,12 @@ public void testAbortShouldFailAllWrites() throws Exception {\n         confLocal.setImmediateFlushEnabled(false);\n         confLocal.setOutputBufferSize(Integer.MAX_VALUE);\n         confLocal.setPeriodicFlushFrequencyMilliSeconds(0);\n-        DistributedLock lock = createLock(\"/test/lock-\" + runtime.getMethodName(), zkc, true);\n+        ZKDistributedLock lock = createLock(\"/test/lock-\" + runtime.getMethodName(), zkc, true);\n         BKLogSegmentWriter writer =\n                 createLogSegmentWriter(confLocal, 0L, -1L, lock);\n         // Use another lock to wait for writer releasing lock\n-        DistributedLock lock0 = createLock(\"/test/lock-\" + runtime.getMethodName(), zkc0, false);\n-        Future<DistributedLock> lockFuture0 = lock0.asyncAcquire();\n+        ZKDistributedLock lock0 = createLock(\"/test/lock-\" + runtime.getMethodName(), zkc0, false);\n+        Future<ZKDistributedLock> lockFuture0 = lock0.asyncAcquire();\n         // add 10 records\n         int numRecords = 10;\n         List<Future<DLSN>> futureList = new ArrayList<Future<DLSN>>(numRecords);\n@@ -621,7 +621,7 @@ public void testUpdateLastTxIdForUserRecords() throws Exception {\n         confLocal.setImmediateFlushEnabled(false);\n         confLocal.setOutputBufferSize(Integer.MAX_VALUE);\n         confLocal.setPeriodicFlushFrequencyMilliSeconds(0);\n-        DistributedLock lock = createLock(\"/test/lock-\" + runtime.getMethodName(), zkc, true);\n+        ZKDistributedLock lock = createLock(\"/test/lock-\" + runtime.getMethodName(), zkc, true);\n         BKLogSegmentWriter writer =\n                 createLogSegmentWriter(confLocal, 0L, -1L, lock);\n         // add 10 records\n@@ -685,7 +685,7 @@ public void testNondurableWriteAfterWriterIsClosed() throws Exception {\n         confLocal.setOutputBufferSize(Integer.MAX_VALUE);\n         confLocal.setPeriodicFlushFrequencyMilliSeconds(0);\n         confLocal.setDurableWriteEnabled(false);\n-        DistributedLock lock = createLock(\"/test/lock-\" + runtime.getMethodName(), zkc, true);\n+        ZKDistributedLock lock = createLock(\"/test/lock-\" + runtime.getMethodName(), zkc, true);\n         BKLogSegmentWriter writer =\n                 createLogSegmentWriter(confLocal, 0L, -1L, lock);\n \n@@ -713,7 +713,7 @@ public void testNondurableWriteAfterEndOfStream() throws Exception {\n         confLocal.setOutputBufferSize(Integer.MAX_VALUE);\n         confLocal.setPeriodicFlushFrequencyMilliSeconds(0);\n         confLocal.setDurableWriteEnabled(false);\n-        DistributedLock lock = createLock(\"/test/lock-\" + runtime.getMethodName(), zkc, true);\n+        ZKDistributedLock lock = createLock(\"/test/lock-\" + runtime.getMethodName(), zkc, true);\n         BKLogSegmentWriter writer =\n                 createLogSegmentWriter(confLocal, 0L, -1L, lock);\n \n@@ -741,7 +741,7 @@ public void testNondurableWriteAfterLedgerIsFenced() throws Exception {\n         confLocal.setOutputBufferSize(Integer.MAX_VALUE);\n         confLocal.setPeriodicFlushFrequencyMilliSeconds(0);\n         confLocal.setDurableWriteEnabled(false);\n-        DistributedLock lock = createLock(\"/test/lock-\" + runtime.getMethodName(), zkc, true);\n+        ZKDistributedLock lock = createLock(\"/test/lock-\" + runtime.getMethodName(), zkc, true);\n         BKLogSegmentWriter writer =\n                 createLogSegmentWriter(confLocal, 0L, -1L, lock);\n \n@@ -780,7 +780,7 @@ public void testNondurableWrite() throws Exception {\n         confLocal.setOutputBufferSize(Integer.MAX_VALUE);\n         confLocal.setPeriodicFlushFrequencyMilliSeconds(0);\n         confLocal.setDurableWriteEnabled(false);\n-        DistributedLock lock = createLock(\"/test/lock-\" + runtime.getMethodName(), zkc, true);\n+        ZKDistributedLock lock = createLock(\"/test/lock-\" + runtime.getMethodName(), zkc, true);\n         BKLogSegmentWriter writer =\n                 createLogSegmentWriter(confLocal, 0L, -1L, lock);\n "},{"sha":"74bafb302f1192747d5ce4346e1c3a9bef398a1b","filename":"src/test/java/com/twitter/distributedlog/TestDistributedLogBase.java","status":"modified","additions":7,"deletions":5,"changes":12,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/e39e3b036145907e9df87f72fb7b9773c4f35b45/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestDistributedLogBase.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/e39e3b036145907e9df87f72fb7b9773c4f35b45/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestDistributedLogBase.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestDistributedLogBase.java?ref=e39e3b036145907e9df87f72fb7b9773c4f35b45","patch":"@@ -37,7 +37,6 @@\n import org.junit.AfterClass;\n import org.junit.Before;\n import org.junit.BeforeClass;\n-\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -72,17 +71,20 @@ public class TestDistributedLogBase {\n \n     @BeforeClass\n     public static void setupCluster() throws Exception {\n-        boolean success = false;\n-        int retries = 0;\n         File zkTmpDir = IOUtils.createTempDir(\"zookeeper\", \"distrlog\");\n         tmpDirs.add(zkTmpDir);\n         Pair<ZooKeeperServerShim, Integer> serverAndPort = LocalDLMEmulator.runZookeeperOnAnyPort(zkTmpDir);\n         zks = serverAndPort.getLeft();\n         zkPort = serverAndPort.getRight();\n-        bkutil = new LocalDLMEmulator(numBookies, \"127.0.0.1\", zkPort, DLMTestUtil.loadTestBkConf());\n+        bkutil = LocalDLMEmulator.newBuilder()\n+                .numBookies(numBookies)\n+                .zkHost(\"127.0.0.1\")\n+                .zkPort(zkPort)\n+                .serverConf(DLMTestUtil.loadTestBkConf())\n+                .shouldStartZK(false)\n+                .build();\n         bkutil.start();\n         zkServers = \"127.0.0.1:\" + zkPort;\n-        success = true;\n     }\n \n     @AfterClass"},{"sha":"1be7fe3424d83e3bc65781d5a489858bc16c1c7c","filename":"src/test/java/com/twitter/distributedlog/lock/TestDistributedLock.java","status":"modified","additions":43,"deletions":43,"changes":86,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/e39e3b036145907e9df87f72fb7b9773c4f35b45/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Flock%2FTestDistributedLock.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/e39e3b036145907e9df87f72fb7b9773c4f35b45/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Flock%2FTestDistributedLock.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Flock%2FTestDistributedLock.java?ref=e39e3b036145907e9df87f72fb7b9773c4f35b45","patch":"@@ -127,7 +127,7 @@ public TestLockFactory(String name,\n             this.lockStateExecutor = lockStateExecutor;\n \n         }\n-        public DistributedLock createLock(int id, ZooKeeperClient zkc) throws Exception {\n+        public ZKDistributedLock createLock(int id, ZooKeeperClient zkc) throws Exception {\n             SessionLockFactory lockFactory = new ZKSessionLockFactory(\n                     zkc,\n                     clientId + id,\n@@ -136,7 +136,7 @@ public DistributedLock createLock(int id, ZooKeeperClient zkc) throws Exception\n                     Long.MAX_VALUE,\n                     sessionTimeoutMs,\n                     NullStatsLogger.INSTANCE);\n-            return new DistributedLock(\n+            return new ZKDistributedLock(\n                     this.lockStateExecutor,\n                     lockFactory,\n                     this.lockPath,\n@@ -190,9 +190,9 @@ private SessionLockFactory createLockFactory(String clientId,\n                 NullStatsLogger.INSTANCE);\n     }\n \n-    private static void checkLockAndReacquire(DistributedLock lock, boolean sync) throws Exception {\n+    private static void checkLockAndReacquire(ZKDistributedLock lock, boolean sync) throws Exception {\n         lock.checkOwnershipAndReacquire();\n-        Future<DistributedLock> reacquireFuture = lock.getLockReacquireFuture();\n+        Future<ZKDistributedLock> reacquireFuture = lock.getLockReacquireFuture();\n         if (null != reacquireFuture && sync) {\n             FutureUtils.result(reacquireFuture);\n         }\n@@ -210,7 +210,7 @@ public void testZooKeeperConnectionLossOnLockCreation() throws Exception {\n         SessionLockFactory lockFactory = createLockFactory(clientId, zkc, Long.MAX_VALUE, 0);\n         try {\n             try {\n-                DistributedLock lock = new DistributedLock(lockStateExecutor, lockFactory, lockPath,\n+                ZKDistributedLock lock = new ZKDistributedLock(lockStateExecutor, lockFactory, lockPath,\n                         Long.MAX_VALUE, NullStatsLogger.INSTANCE);\n                 FutureUtils.result(lock.asyncAcquire());\n                 fail(\"Should fail on creating lock if couldn't establishing connections to zookeeper\");\n@@ -226,7 +226,7 @@ public void testZooKeeperConnectionLossOnLockCreation() throws Exception {\n         lockFactory = createLockFactory(clientId, zkc, Long.MAX_VALUE, 3);\n         try {\n             try {\n-                DistributedLock lock = new DistributedLock(lockStateExecutor, lockFactory, lockPath,\n+                ZKDistributedLock lock = new ZKDistributedLock(lockStateExecutor, lockFactory, lockPath,\n                         Long.MAX_VALUE, NullStatsLogger.INSTANCE);\n                 FutureUtils.result(lock.asyncAcquire());\n                 fail(\"Should fail on creating lock if couldn't establishing connections to zookeeper after 3 retries\");\n@@ -241,7 +241,7 @@ public void testZooKeeperConnectionLossOnLockCreation() throws Exception {\n                 new CountDownThrowFailPointAction(0, 3));\n         lockFactory = createLockFactory(clientId, zkc, Long.MAX_VALUE, 5);\n         try {\n-            DistributedLock lock = new DistributedLock(lockStateExecutor, lockFactory, lockPath,\n+            ZKDistributedLock lock = new ZKDistributedLock(lockStateExecutor, lockFactory, lockPath,\n                 Long.MAX_VALUE, NullStatsLogger.INSTANCE);\n             FutureUtils.result(lock.asyncAcquire());\n \n@@ -266,7 +266,7 @@ public void testBasicAcquireRelease() throws Exception {\n         createLockPath(zkc.get(), lockPath);\n \n         SessionLockFactory lockFactory = createLockFactory(clientId, zkc);\n-        DistributedLock lock = new DistributedLock(lockStateExecutor, lockFactory, lockPath,\n+        ZKDistributedLock lock = new ZKDistributedLock(lockStateExecutor, lockFactory, lockPath,\n                 Long.MAX_VALUE, NullStatsLogger.INSTANCE);\n         FutureUtils.result(lock.asyncAcquire());\n \n@@ -283,7 +283,7 @@ public void testBasicAcquireRelease() throws Exception {\n         assertEquals(0, children.size());\n         assertFalse(lock.haveLock());\n \n-        lock = new DistributedLock(lockStateExecutor, lockFactory, lockPath,\n+        lock = new ZKDistributedLock(lockStateExecutor, lockFactory, lockPath,\n                 Long.MAX_VALUE, NullStatsLogger.INSTANCE);\n         FutureUtils.result(lock.asyncAcquire());\n \n@@ -321,8 +321,8 @@ public void testCheckWriteLockFailureWhenLockIsAcquiredByOthers() throws Excepti\n         createLockPath(zkc.get(), lockPath);\n \n         SessionLockFactory lockFactory0 = createLockFactory(clientId, zkc0);\n-        DistributedLock lock0 =\n-                new DistributedLock(lockStateExecutor, lockFactory0, lockPath,\n+        ZKDistributedLock lock0 =\n+                new ZKDistributedLock(lockStateExecutor, lockFactory0, lockPath,\n                         Long.MAX_VALUE, NullStatsLogger.INSTANCE);\n         FutureUtils.result(lock0.asyncAcquire());\n \n@@ -351,8 +351,8 @@ public void testCheckWriteLockFailureWhenLockIsAcquiredByOthers() throws Excepti\n \n \n         SessionLockFactory lockFactory = createLockFactory(clientId, zkc);\n-        final DistributedLock lock1 =\n-                new DistributedLock(lockStateExecutor, lockFactory, lockPath,\n+        final ZKDistributedLock lock1 =\n+                new ZKDistributedLock(lockStateExecutor, lockFactory, lockPath,\n                         Long.MAX_VALUE, NullStatsLogger.INSTANCE);\n         final CountDownLatch lockLatch = new CountDownLatch(1);\n         Thread lockThread = new Thread(new Runnable() {\n@@ -421,8 +421,8 @@ private void testLockReacquireSuccess(boolean checkOwnershipAndReacquire) throws\n         createLockPath(zkc.get(), lockPath);\n \n         SessionLockFactory lockFactory0 = createLockFactory(clientId, zkc0);\n-        DistributedLock lock0 =\n-                new DistributedLock(lockStateExecutor, lockFactory0, lockPath,\n+        ZKDistributedLock lock0 =\n+                new ZKDistributedLock(lockStateExecutor, lockFactory0, lockPath,\n                         Long.MAX_VALUE, NullStatsLogger.INSTANCE);\n         FutureUtils.result(lock0.asyncAcquire());\n \n@@ -441,7 +441,7 @@ private void testLockReacquireSuccess(boolean checkOwnershipAndReacquire) throws\n             checkLockAndReacquire(lock0, false);\n         } else {\n             // session expire will trigger lock re-acquisition\n-            Future<DistributedLock> asyncLockAcquireFuture;\n+            Future<ZKDistributedLock> asyncLockAcquireFuture;\n             do {\n                 Thread.sleep(1);\n                 asyncLockAcquireFuture = lock0.getLockReacquireFuture();\n@@ -492,15 +492,15 @@ private void testLockReacquireFailure(boolean checkOwnershipAndReacquire) throws\n         createLockPath(zkc.get(), lockPath);\n \n         SessionLockFactory lockFactory0 = createLockFactory(clientId, zkc0);\n-        DistributedLock lock0 =\n-                new DistributedLock(lockStateExecutor, lockFactory0, lockPath,\n+        ZKDistributedLock lock0 =\n+                new ZKDistributedLock(lockStateExecutor, lockFactory0, lockPath,\n                         Long.MAX_VALUE, NullStatsLogger.INSTANCE);\n         FutureUtils.result(lock0.asyncAcquire());\n \n         final CountDownLatch lock1DoneLatch = new CountDownLatch(1);\n         SessionLockFactory lockFactory1 = createLockFactory(clientId, zkc);\n-        final DistributedLock lock1 =\n-                new DistributedLock(lockStateExecutor, lockFactory1, lockPath,\n+        final ZKDistributedLock lock1 =\n+                new ZKDistributedLock(lockStateExecutor, lockFactory1, lockPath,\n                         Long.MAX_VALUE, NullStatsLogger.INSTANCE);\n         Thread lock1Thread = new Thread(new Runnable() {\n             @Override\n@@ -553,7 +553,7 @@ public void run() {\n         } else {\n             logger.info(\"Waiting lock0 to attempt acquisition after session expired\");\n             // session expire will trigger lock re-acquisition\n-            Future<DistributedLock> asyncLockAcquireFuture;\n+            Future<ZKDistributedLock> asyncLockAcquireFuture;\n             do {\n                 Thread.sleep(1);\n                 asyncLockAcquireFuture = lock0.getLockReacquireFuture();\n@@ -595,7 +595,7 @@ public void testLockReacquire() throws Exception {\n                 CreateMode.PERSISTENT);\n         String clientId = \"lockHolder\";\n         SessionLockFactory lockFactory = createLockFactory(clientId, zkc, conf.getLockTimeoutMilliSeconds(), 0);\n-        DistributedLock lock = new DistributedLock(lockStateExecutor, lockFactory, lockPath,\n+        ZKDistributedLock lock = new ZKDistributedLock(lockStateExecutor, lockFactory, lockPath,\n             conf.getLockTimeoutMilliSeconds(), NullStatsLogger.INSTANCE);\n         FutureUtils.result(lock.asyncAcquire());\n \n@@ -609,7 +609,7 @@ public void testLockReacquire() throws Exception {\n         assertEquals(true, lock.getInternalLock().isLockHeld());\n \n         lockFactory = createLockFactory(clientId + \"_2\", zkc, conf.getLockTimeoutMilliSeconds(), 0);\n-        DistributedLock lock2 = new DistributedLock(lockStateExecutor, lockFactory, lockPath,\n+        ZKDistributedLock lock2 = new ZKDistributedLock(lockStateExecutor, lockFactory, lockPath,\n             0, NullStatsLogger.INSTANCE);\n \n         boolean exceptionEncountered = false;\n@@ -631,7 +631,7 @@ public void testLockReacquireMultiple() throws Exception {\n             CreateMode.PERSISTENT);\n         String clientId = \"lockHolder\";\n         SessionLockFactory factory = createLockFactory(clientId, zkc, conf.getLockTimeoutMilliSeconds(), 0);\n-        DistributedLock lock = new DistributedLock(lockStateExecutor, factory, lockPath,\n+        ZKDistributedLock lock = new ZKDistributedLock(lockStateExecutor, factory, lockPath,\n             conf.getLockTimeoutMilliSeconds(), NullStatsLogger.INSTANCE);\n         FutureUtils.result(lock.asyncAcquire());\n \n@@ -645,7 +645,7 @@ public void testLockReacquireMultiple() throws Exception {\n         assertEquals(true, lock.getInternalLock().isLockHeld());\n \n         factory = createLockFactory(clientId + \"_2\", zkc, 0, 0);\n-        DistributedLock lock2 = new DistributedLock(lockStateExecutor, factory, lockPath,\n+        ZKDistributedLock lock2 = new ZKDistributedLock(lockStateExecutor, factory, lockPath,\n             0, NullStatsLogger.INSTANCE);\n \n         boolean exceptionEncountered = false;\n@@ -663,7 +663,7 @@ public void testLockReacquireMultiple() throws Exception {\n         assertEquals(false, lock.getInternalLock().isLockHeld());\n \n         factory = createLockFactory(clientId + \"_3\", zkc, 0, 0);\n-        DistributedLock lock3 = new DistributedLock(lockStateExecutor, factory, lockPath,\n+        ZKDistributedLock lock3 = new ZKDistributedLock(lockStateExecutor, factory, lockPath,\n             0, NullStatsLogger.INSTANCE);\n \n         FutureUtils.result(lock3.asyncAcquire());\n@@ -682,8 +682,8 @@ void assertLatchesSet(CountDownLatch[] latches, int endIndex) {\n     }\n \n     // Assert key lock state (is locked, is internal locked, lock count, etc.) for two dlocks.\n-    void assertLockState(DistributedLock lock0, boolean owned0, boolean intOwned0,\n-                         DistributedLock lock1, boolean owned1, boolean intOwned1,\n+    void assertLockState(ZKDistributedLock lock0, boolean owned0, boolean intOwned0,\n+                         ZKDistributedLock lock1, boolean owned1, boolean intOwned1,\n                          int waiters, String lockPath) throws Exception {\n         assertEquals(owned0, lock0.haveLock());\n         assertEquals(intOwned0, lock0.getInternalLock() != null && lock0.getInternalLock().isLockHeld());\n@@ -697,9 +697,9 @@ public void testAsyncAcquireBasics() throws Exception {\n         TestLockFactory locks = new TestLockFactory(runtime.getMethodName(), zkc, lockStateExecutor);\n \n         int count = 3;\n-        ArrayList<Future<DistributedLock>> results =\n-                new ArrayList<Future<DistributedLock>>(count);\n-        DistributedLock[] lockArray = new DistributedLock[count];\n+        ArrayList<Future<ZKDistributedLock>> results =\n+                new ArrayList<Future<ZKDistributedLock>>(count);\n+        ZKDistributedLock[] lockArray = new ZKDistributedLock[count];\n         final CountDownLatch[] latches = new CountDownLatch[count];\n \n         // Set up <count> waiters, save async results, count down a latch when lock is acquired in\n@@ -709,9 +709,9 @@ public void testAsyncAcquireBasics() throws Exception {\n             lockArray[i] = locks.createLock(i, zkc);\n             final int index = i;\n             results.add(lockArray[i].asyncAcquire().addEventListener(\n-                new FutureEventListener<DistributedLock>() {\n+                new FutureEventListener<ZKDistributedLock>() {\n                     @Override\n-                    public void onSuccess(DistributedLock lock) {\n+                    public void onSuccess(ZKDistributedLock lock) {\n                         latches[index].countDown();\n                     }\n                     @Override\n@@ -735,8 +735,8 @@ public void onFailure(Throwable cause) {\n     @Test(timeout = 60000)\n     public void testAsyncAcquireSyncThenAsyncOnSameLock() throws Exception {\n         TestLockFactory locks = new TestLockFactory(runtime.getMethodName(), zkc, lockStateExecutor);\n-        final DistributedLock lock0 = locks.createLock(0, zkc);\n-        final DistributedLock lock1 = locks.createLock(1, zkc0);\n+        final ZKDistributedLock lock0 = locks.createLock(0, zkc);\n+        final ZKDistributedLock lock1 = locks.createLock(1, zkc0);\n \n         FutureUtils.result(lock0.asyncAcquire());\n \n@@ -774,11 +774,11 @@ public void run() {\n     @Test(timeout = 60000)\n     public void testAsyncAcquireExpireDuringWait() throws Exception {\n         TestLockFactory locks = new TestLockFactory(runtime.getMethodName(), zkc, lockStateExecutor);\n-        final DistributedLock lock0 = locks.createLock(0, zkc);\n-        final DistributedLock lock1 = locks.createLock(1, zkc0);\n+        final ZKDistributedLock lock0 = locks.createLock(0, zkc);\n+        final ZKDistributedLock lock1 = locks.createLock(1, zkc0);\n \n         FutureUtils.result(lock0.asyncAcquire());\n-        Future<DistributedLock> result = lock1.asyncAcquire();\n+        Future<ZKDistributedLock> result = lock1.asyncAcquire();\n         // make sure we place a waiter for lock1\n         while (null == lock1.getLockWaiter()) {\n             TimeUnit.MILLISECONDS.sleep(20);\n@@ -800,11 +800,11 @@ public void testAsyncAcquireExpireDuringWait() throws Exception {\n     @Test(timeout = 60000)\n     public void testAsyncAcquireCloseDuringWait() throws Exception {\n         TestLockFactory locks = new TestLockFactory(runtime.getMethodName(), zkc, lockStateExecutor);\n-        final DistributedLock lock0 = locks.createLock(0, zkc);\n-        final DistributedLock lock1 = locks.createLock(1, zkc0);\n+        final ZKDistributedLock lock0 = locks.createLock(0, zkc);\n+        final ZKDistributedLock lock1 = locks.createLock(1, zkc0);\n \n         FutureUtils.result(lock0.asyncAcquire());\n-        Future<DistributedLock> result = lock1.asyncAcquire();\n+        Future<ZKDistributedLock> result = lock1.asyncAcquire();\n         FutureUtils.result(lock1.asyncClose());\n         try {\n             Await.result(result);\n@@ -819,9 +819,9 @@ public void testAsyncAcquireCloseDuringWait() throws Exception {\n     @Test(timeout = 60000)\n     public void testAsyncAcquireCloseAfterAcquire() throws Exception {\n         TestLockFactory locks = new TestLockFactory(runtime.getMethodName(), zkc, lockStateExecutor);\n-        final DistributedLock lock0 = locks.createLock(0, zkc);\n+        final ZKDistributedLock lock0 = locks.createLock(0, zkc);\n \n-        Future<DistributedLock> result = lock0.asyncAcquire();\n+        Future<ZKDistributedLock> result = lock0.asyncAcquire();\n         Await.result(result);\n         FutureUtils.result(lock0.asyncClose());\n "}]}