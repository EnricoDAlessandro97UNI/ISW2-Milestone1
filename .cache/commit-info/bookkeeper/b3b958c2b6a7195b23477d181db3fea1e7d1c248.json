{"sha":"b3b958c2b6a7195b23477d181db3fea1e7d1c248","node_id":"MDY6Q29tbWl0NDc4NTkyNTI2OmIzYjk1OGMyYjZhNzE5NWIyMzQ3N2QxODFkYjNmZWExZTdkMWMyNDg=","commit":{"author":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2017-06-05T19:48:33Z"},"committer":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2017-06-05T19:48:33Z"},"message":"BOOKKEEPER-1087: Ledger Recovery (part 2) - Add a parallel reading request in PendingReadOp\n\nTHIS CHANGE IS BASED ON #176 (you can review f0fb89c)\n\nbookkeeper recovery improvement (part-2): add a parallel reading request in PendingReadOp\n\n- add a parallel reading request in PendingReadOp\n- allow PendingReadOp to configure whether to do parallel reading or not\n- add flag in ClientConfiguration to allow configuring whether to do parallel reading in LedgerRecoveryOp or not.\n\nAuthor: Sijie Guo <sijie@apache.org>\nAuthor: Sijie Guo <sijieg@twitter.com>\n\nReviewers: Matteo Merli <mmerli@apache.org>\n\nCloses #177 from sijie/recovery_improvements_part2","tree":{"sha":"99920a485c05889f776ad872f3c4d29de386a534","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/trees/99920a485c05889f776ad872f3c4d29de386a534"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/commits/b3b958c2b6a7195b23477d181db3fea1e7d1c248","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/b3b958c2b6a7195b23477d181db3fea1e7d1c248","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/b3b958c2b6a7195b23477d181db3fea1e7d1c248","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/b3b958c2b6a7195b23477d181db3fea1e7d1c248/comments","author":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"committer":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"parents":[{"sha":"efd8ec26926d2e75f51d6d576543a0dcc116b83f","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/efd8ec26926d2e75f51d6d576543a0dcc116b83f","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/efd8ec26926d2e75f51d6d576543a0dcc116b83f"}],"stats":{"total":402,"additions":393,"deletions":9},"files":[{"sha":"7fa8c61cfaf6f2bcda08a6f073e3650e451afdaa","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","status":"modified","additions":4,"deletions":2,"changes":6,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b3b958c2b6a7195b23477d181db3fea1e7d1c248/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FLedgerHandle.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b3b958c2b6a7195b23477d181db3fea1e7d1c248/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FLedgerHandle.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FLedgerHandle.java?ref=b3b958c2b6a7195b23477d181db3fea1e7d1c248","patch":"@@ -1477,7 +1477,8 @@ void recover(final GenericCallback<Void> cb) {\n         if (wasInRecovery) {\n             // if metadata is already in recover, dont try to write again,\n             // just do the recovery from the starting point\n-            new LedgerRecoveryOp(LedgerHandle.this, cb).initiate();\n+            new LedgerRecoveryOp(LedgerHandle.this, cb)\n+                    .parallelRead(bk.getConf().getEnableParallelRecoveryRead()).initiate();\n             return;\n         }\n \n@@ -1503,7 +1504,8 @@ public String toString() {\n                         }\n                     });\n                 } else if (rc == BKException.Code.OK) {\n-                    new LedgerRecoveryOp(LedgerHandle.this, cb).initiate();\n+                    new LedgerRecoveryOp(LedgerHandle.this, cb)\n+                            .parallelRead(bk.getConf().getEnableParallelRecoveryRead()).initiate();\n                 } else {\n                     LOG.error(\"Error writing ledger config \" + rc + \" of ledger \" + ledgerId);\n                     cb.operationComplete(rc, null);"},{"sha":"666dbe849e3bd23f535b780f288abc2df72ec617","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerRecoveryOp.java","status":"modified","additions":7,"deletions":1,"changes":8,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b3b958c2b6a7195b23477d181db3fea1e7d1c248/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FLedgerRecoveryOp.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b3b958c2b6a7195b23477d181db3fea1e7d1c248/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FLedgerRecoveryOp.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FLedgerRecoveryOp.java?ref=b3b958c2b6a7195b23477d181db3fea1e7d1c248","patch":"@@ -49,6 +49,7 @@ class LedgerRecoveryOp implements ReadCallback, AddCallback {\n     long entryToRead;\n     // keep a copy of metadata for recovery.\n     LedgerMetadata metadataForRecovery;\n+    boolean parallelRead = false;\n \n     GenericCallback<Void> cb;\n \n@@ -75,6 +76,11 @@ public LedgerRecoveryOp(LedgerHandle lh, GenericCallback<Void> cb) {\n         this.lh = lh;\n     }\n \n+    LedgerRecoveryOp parallelRead(boolean enabled) {\n+        this.parallelRead = enabled;\n+        return this;\n+    }\n+\n     public void initiate() {\n         ReadLastConfirmedOp rlcop = new ReadLastConfirmedOp(lh,\n                 new ReadLastConfirmedOp.LastConfirmedDataCallback() {\n@@ -110,7 +116,7 @@ private void doRecoveryRead() {\n         if (!callbackDone.get()) {\n             entryToRead++;\n             try {\n-                new RecoveryReadOp(lh, lh.bk.scheduler, entryToRead, entryToRead, this, null).initiate();\n+                new RecoveryReadOp(lh, lh.bk.scheduler, entryToRead, entryToRead, this, null).parallelRead(parallelRead).initiate();\n             } catch (InterruptedException e) {\n                 readComplete(BKException.Code.InterruptedException, lh, null, null);\n             }"},{"sha":"7b01b7ff8ef3bc9a5882df59b47f9a03fec16b7e","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingReadOp.java","status":"modified","additions":84,"deletions":5,"changes":89,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b3b958c2b6a7195b23477d181db3fea1e7d1c248/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FPendingReadOp.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b3b958c2b6a7195b23477d181db3fea1e7d1c248/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FPendingReadOp.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FPendingReadOp.java?ref=b3b958c2b6a7195b23477d181db3fea1e7d1c248","patch":"@@ -71,6 +71,8 @@ class PendingReadOp implements Enumeration<LedgerEntry>, ReadEntryCallback {\n     OpStatsLogger readOpLogger;\n \n     final int maxMissedReadsAllowed;\n+    boolean parallelRead = false;\n+    final AtomicBoolean complete = new AtomicBoolean(false);\n \n     abstract class LedgerEntryRequest extends LedgerEntry {\n \n@@ -128,6 +130,22 @@ boolean complete(BookieSocketAddress host, final ByteBuf buffer) {\n             }\n         }\n \n+        /**\n+         * Fail the request with given result code <i>rc</i>.\n+         *\n+         * @param rc\n+         *          result code to fail the request.\n+         * @return true if we managed to fail the entry; otherwise return false if it already failed or completed.\n+         */\n+        boolean fail(int rc) {\n+            if (complete.compareAndSet(false, true)) {\n+                submitCallback(rc);\n+                return true;\n+            } else {\n+                return false;\n+            }\n+        }\n+\n         /**\n          * Log error <i>errMsg</i> and reattempt read from <i>host</i>.\n          *\n@@ -138,7 +156,7 @@ boolean complete(BookieSocketAddress host, final ByteBuf buffer) {\n          * @param rc\n          *          read result code\n          */\n-        void logErrorAndReattemptRead(BookieSocketAddress host, String errMsg, int rc) {\n+        synchronized void logErrorAndReattemptRead(BookieSocketAddress host, String errMsg, int rc) {\n             if (BKException.Code.OK == firstError ||\n                 BKException.Code.NoSuchEntryException == firstError ||\n                 BKException.Code.NoSuchLedgerExistsException == firstError) {\n@@ -191,6 +209,52 @@ public String toString() {\n         }\n     }\n \n+    class ParallelReadRequest extends LedgerEntryRequest {\n+\n+        int numPendings;\n+\n+        ParallelReadRequest(ArrayList<BookieSocketAddress> ensemble, long lId, long eId) {\n+            super(ensemble, lId, eId);\n+            numPendings = writeSet.size();\n+        }\n+\n+        @Override\n+        void read() {\n+            for (int bookieIndex : writeSet) {\n+                BookieSocketAddress to = ensemble.get(bookieIndex);\n+                try {\n+                    sendReadTo(to, this);\n+                } catch (InterruptedException ie) {\n+                    LOG.error(\"Interrupted reading entry {} : \", this, ie);\n+                    Thread.currentThread().interrupt();\n+                    fail(BKException.Code.InterruptedException);\n+                    return;\n+                }\n+            }\n+        }\n+\n+        @Override\n+        synchronized void logErrorAndReattemptRead(BookieSocketAddress host, String errMsg, int rc) {\n+            super.logErrorAndReattemptRead(host, errMsg, rc);\n+            --numPendings;\n+            // if received all responses or this entry doesn't meet quorum write, complete the request.\n+            if (numMissedEntryReads > maxMissedReadsAllowed || numPendings == 0) {\n+                if (BKException.Code.BookieHandleNotAvailableException == firstError &&\n+                    numMissedEntryReads > maxMissedReadsAllowed) {\n+                    firstError = BKException.Code.NoSuchEntryException;\n+                }\n+\n+                fail(firstError);\n+            }\n+        }\n+\n+        @Override\n+        BookieSocketAddress maybeSendSpeculativeRead(Set<BookieSocketAddress> heardFromHosts) {\n+            // no speculative read\n+            return null;\n+        }\n+    }\n+\n     class SequenceReadRequest extends LedgerEntryRequest {\n         final static int NOT_FOUND = -1;\n         int nextReplicaIndexToReadFrom = 0;\n@@ -280,7 +344,7 @@ synchronized BookieSocketAddress sendNextRead() {\n                     firstError = BKException.Code.NoSuchEntryException;\n                 }\n \n-                submitCallback(firstError);\n+                fail(firstError);\n                 return null;\n             }\n \n@@ -296,7 +360,7 @@ synchronized BookieSocketAddress sendNextRead() {\n             } catch (InterruptedException ie) {\n                 LOG.error(\"Interrupted reading entry \" + this, ie);\n                 Thread.currentThread().interrupt();\n-                submitCallback(BKException.Code.ReadException);\n+                fail(BKException.Code.InterruptedException);\n                 return null;\n             }\n         }\n@@ -347,12 +411,17 @@ private void cancelSpeculativeTask(boolean mayInterruptIfRunning) {\n         }\n     }\n \n+    PendingReadOp parallelRead(boolean enabled) {\n+        this.parallelRead = enabled;\n+        return this;\n+    }\n+\n     public void initiate() throws InterruptedException {\n         long nextEnsembleChange = startEntryId, i = startEntryId;\n         this.requestTimeNanos = MathUtils.nowInNano();\n         ArrayList<BookieSocketAddress> ensemble = null;\n \n-        if (speculativeReadTimeout > 0) {\n+        if (speculativeReadTimeout > 0 && !parallelRead) {\n             Runnable readTask = new Runnable() {\n                 public void run() {\n                     int x = 0;\n@@ -393,7 +462,12 @@ public void run() {\n                 ensemble = getLedgerMetadata().getEnsemble(i);\n                 nextEnsembleChange = getLedgerMetadata().getNextEnsembleChange(i);\n             }\n-            LedgerEntryRequest entry = new SequenceReadRequest(ensemble, lh.ledgerId, i);\n+            LedgerEntryRequest entry;\n+            if (parallelRead) {\n+                entry = new ParallelReadRequest(ensemble, lh.ledgerId, i);\n+            } else {\n+                entry = new SequenceReadRequest(ensemble, lh.ledgerId, i);\n+            }\n             seq.add(entry);\n             i++;\n \n@@ -449,6 +523,11 @@ private void submitCallback(int code) {\n             return;\n         }\n \n+        // ensure callback once\n+        if (!complete.compareAndSet(false, true)) {\n+            return;\n+        }\n+\n         long latencyNanos = MathUtils.elapsedNanos(requestTimeNanos);\n         if (code != BKException.Code.OK) {\n             long firstUnread = LedgerHandle.INVALID_ENTRY_ID;"},{"sha":"5d4bf03efcebc527411e45e740f8fa31ed922491","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ClientConfiguration.java","status":"modified","additions":22,"deletions":1,"changes":23,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b3b958c2b6a7195b23477d181db3fea1e7d1c248/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fconf%2FClientConfiguration.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b3b958c2b6a7195b23477d181db3fea1e7d1c248/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fconf%2FClientConfiguration.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fconf%2FClientConfiguration.java?ref=b3b958c2b6a7195b23477d181db3fea1e7d1c248","patch":"@@ -62,6 +62,7 @@ public class ClientConfiguration extends AbstractConfiguration {\n     // Read Parameters\n     protected final static String READ_TIMEOUT = \"readTimeout\";\n     protected final static String SPECULATIVE_READ_TIMEOUT = \"speculativeReadTimeout\";\n+    protected final static String ENABLE_PARALLEL_RECOVERY_READ = \"enableParallelRecoveryRead\";\n     // Timeout Setting\n     protected final static String ADD_ENTRY_TIMEOUT_SEC = \"addEntryTimeoutSec\";\n     protected final static String ADD_ENTRY_QUORUM_TIMEOUT_SEC = \"addEntryQuorumTimeoutSec\";\n@@ -792,6 +793,27 @@ public ClientConfiguration setSpeculativeReadTimeout(int timeout) {\n         return this;\n     }\n \n+    /**\n+     * Whether to enable parallel reading in recovery read.\n+     *\n+     * @return true if enable parallel reading in recovery read. otherwise, return false.\n+     */\n+    public boolean getEnableParallelRecoveryRead() {\n+        return getBoolean(ENABLE_PARALLEL_RECOVERY_READ, false);\n+    }\n+\n+    /**\n+     * Enable/Disable parallel reading in recovery read.\n+     *\n+     * @param enabled\n+     *          flag to enable/disable parallel reading in recovery read.\n+     * @return client configuration.\n+     */\n+    public ClientConfiguration setEnableParallelRecoveryRead(boolean enabled) {\n+        setProperty(ENABLE_PARALLEL_RECOVERY_READ, enabled);\n+        return this;\n+    }\n+\n     /**\n      * Get Ensemble Placement Policy Class.\n      *\n@@ -1096,5 +1118,4 @@ public ClientConfiguration setClientRole(String role) {\n     public String getClientRole() {\n         return getString(CLIENT_ROLE, CLIENT_ROLE_STANDARD);\n     }\n-\n }"},{"sha":"3b1ca19aa013e1e4a6ad9dea7033804321ce198f","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestParallelRead.java","status":"added","additions":276,"deletions":0,"changes":276,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/b3b958c2b6a7195b23477d181db3fea1e7d1c248/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FTestParallelRead.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/b3b958c2b6a7195b23477d181db3fea1e7d1c248/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FTestParallelRead.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FTestParallelRead.java?ref=b3b958c2b6a7195b23477d181db3fea1e7d1c248","patch":"@@ -0,0 +1,276 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.client;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import org.apache.bookkeeper.client.AsyncCallback.ReadCallback;\n+import org.apache.bookkeeper.client.BookKeeper.DigestType;\n+import org.apache.bookkeeper.conf.ClientConfiguration;\n+import org.apache.bookkeeper.net.BookieSocketAddress;\n+import org.apache.bookkeeper.test.BookKeeperClusterTestCase;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.Enumeration;\n+import java.util.concurrent.CountDownLatch;\n+\n+/**\n+ * Unit tests for parallel reading\n+ */\n+public class TestParallelRead extends BookKeeperClusterTestCase {\n+\n+    static Logger LOG = LoggerFactory.getLogger(TestParallelRead.class);\n+\n+    final DigestType digestType;\n+    final byte[] passwd = \"parallel-read\".getBytes();\n+\n+    public TestParallelRead() {\n+        super(6);\n+        this.digestType = DigestType.CRC32;\n+    }\n+\n+    long getLedgerToRead(int ensemble, int writeQuorum, int ackQuorum, int numEntries)\n+            throws Exception {\n+        LedgerHandle lh = bkc.createLedger(ensemble, writeQuorum, ackQuorum, digestType, passwd);\n+        for (int i = 0; i < numEntries; i++) {\n+            lh.addEntry((\"\" + i).getBytes());\n+        }\n+        lh.close();\n+        return lh.getId();\n+    }\n+\n+    static class LatchCallback implements ReadCallback {\n+\n+        final CountDownLatch l = new CountDownLatch(1);\n+        int rc = -0x1314;\n+        Enumeration<LedgerEntry> entries;\n+\n+        Enumeration<LedgerEntry> getEntries() {\n+            return entries;\n+        }\n+\n+        int getRc() {\n+            return rc;\n+        }\n+\n+        @Override\n+        public void readComplete(int rc, LedgerHandle lh, Enumeration<LedgerEntry> seq, Object ctx) {\n+            this.rc = rc;\n+            this.entries = seq;\n+            l.countDown();\n+        }\n+\n+        void expectSuccess() throws Exception {\n+            l.await();\n+            assertTrue(BKException.Code.OK == rc);\n+        }\n+\n+        void expectFail() throws Exception {\n+            l.await();\n+            assertFalse(BKException.Code.OK == rc);\n+        }\n+\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testNormalParallelRead() throws Exception {\n+        int numEntries = 10;\n+\n+        long id = getLedgerToRead(5, 2, 2, numEntries);\n+        LedgerHandle lh = bkc.openLedger(id, digestType, passwd);\n+\n+        // read single entry\n+        for (int i = 0; i < numEntries; i++) {\n+            LatchCallback latch = new LatchCallback();\n+            PendingReadOp readOp =\n+                    new PendingReadOp(lh, lh.bk.scheduler, i, i, latch, null);\n+            readOp.parallelRead(true).initiate();\n+            latch.expectSuccess();\n+            Enumeration<LedgerEntry> entries = latch.getEntries();\n+            assertNotNull(entries);\n+            assertTrue(entries.hasMoreElements());\n+            LedgerEntry entry = entries.nextElement();\n+            assertNotNull(entry);\n+            assertEquals(i, Integer.parseInt(new String(entry.getEntry())));\n+            assertFalse(entries.hasMoreElements());\n+        }\n+\n+        // read multiple entries\n+        LatchCallback latch = new LatchCallback();\n+        PendingReadOp readOp =\n+                new PendingReadOp(lh, lh.bk.scheduler, 0, numEntries - 1, latch, null);\n+        readOp.parallelRead(true).initiate();\n+        latch.expectSuccess();\n+        Enumeration<LedgerEntry> entries = latch.getEntries();\n+        assertNotNull(entries);\n+\n+        int numReads = 0;\n+        while (entries.hasMoreElements()) {\n+            LedgerEntry entry = entries.nextElement();\n+            assertNotNull(entry);\n+            assertEquals(numReads, Integer.parseInt(new String(entry.getEntry())));\n+            ++numReads;\n+        }\n+        assertEquals(numEntries, numReads);\n+\n+        lh.close();\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testParallelReadMissingEntries() throws Exception {\n+        int numEntries = 10;\n+\n+        long id = getLedgerToRead(5, 2, 2, numEntries);\n+        LedgerHandle lh = bkc.openLedger(id, digestType, passwd);\n+\n+        // read single entry\n+        LatchCallback latch = new LatchCallback();\n+        PendingReadOp readOp =\n+                new PendingReadOp(lh, lh.bk.scheduler, 11, 11, latch, null);\n+        readOp.parallelRead(true).initiate();\n+        latch.expectFail();\n+        assertEquals(BKException.Code.NoSuchEntryException, latch.getRc());\n+\n+        // read multiple entries\n+        latch = new LatchCallback();\n+        readOp = new PendingReadOp(lh, lh.bk.scheduler, 8, 11, latch, null);\n+        readOp.parallelRead(true).initiate();\n+        latch.expectFail();\n+        assertEquals(BKException.Code.NoSuchEntryException, latch.getRc());\n+\n+        lh.close();\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testFailParallelReadMissingEntryImmediately() throws Exception {\n+        int numEntries = 1;\n+\n+        long id = getLedgerToRead(5, 5, 3, numEntries);\n+\n+        ClientConfiguration newConf = new ClientConfiguration()\n+            .setReadEntryTimeout(30000);\n+        newConf.setZkServers(zkUtil.getZooKeeperConnectString());\n+        BookKeeper newBk = new BookKeeper(newConf);\n+\n+        LedgerHandle lh = bkc.openLedger(id, digestType, passwd);\n+\n+        ArrayList<BookieSocketAddress> ensemble =\n+                lh.getLedgerMetadata().getEnsemble(10);\n+        CountDownLatch latch1 = new CountDownLatch(1);\n+        CountDownLatch latch2 = new CountDownLatch(1);\n+        // sleep two bookie\n+        sleepBookie(ensemble.get(0), latch1);\n+        sleepBookie(ensemble.get(1), latch2);\n+\n+        LatchCallback latchCallback = new LatchCallback();\n+        PendingReadOp readOp =\n+                new PendingReadOp(lh, lh.bk.scheduler, 10, 10, latchCallback, null);\n+        readOp.parallelRead(true).initiate();\n+        // would fail immediately if found missing entries don't cover ack quorum\n+        latchCallback.expectFail();\n+        assertEquals(BKException.Code.NoSuchEntryException, latchCallback.getRc());\n+        latch1.countDown();\n+        latch2.countDown();\n+\n+        lh.close();\n+        newBk.close();\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testParallelReadWithFailedBookies() throws Exception {\n+        int numEntries = 10;\n+\n+        long id = getLedgerToRead(5, 3, 3, numEntries);\n+\n+        ClientConfiguration newConf = new ClientConfiguration()\n+            .setReadEntryTimeout(30000);\n+        newConf.setZkServers(zkUtil.getZooKeeperConnectString());\n+        BookKeeper newBk = new BookKeeper(newConf);\n+\n+        LedgerHandle lh = bkc.openLedger(id, digestType, passwd);\n+\n+        ArrayList<BookieSocketAddress> ensemble =\n+                lh.getLedgerMetadata().getEnsemble(5);\n+        // kill two bookies\n+        killBookie(ensemble.get(0));\n+        killBookie(ensemble.get(1));\n+\n+        // read multiple entries\n+        LatchCallback latch = new LatchCallback();\n+        PendingReadOp readOp =\n+                new PendingReadOp(lh, lh.bk.scheduler, 0, numEntries - 1, latch, null);\n+        readOp.parallelRead(true).initiate();\n+        latch.expectSuccess();\n+        Enumeration<LedgerEntry> entries = latch.getEntries();\n+        assertNotNull(entries);\n+\n+        int numReads = 0;\n+        while (entries.hasMoreElements()) {\n+            LedgerEntry entry = entries.nextElement();\n+            assertNotNull(entry);\n+            assertEquals(numReads, Integer.parseInt(new String(entry.getEntry())));\n+            ++numReads;\n+        }\n+        assertEquals(numEntries, numReads);\n+\n+        lh.close();\n+        newBk.close();\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testParallelReadFailureWithFailedBookies() throws Exception {\n+        int numEntries = 10;\n+\n+        long id = getLedgerToRead(5, 3, 3, numEntries);\n+\n+        ClientConfiguration newConf = new ClientConfiguration()\n+            .setReadEntryTimeout(30000);\n+        newConf.setZkServers(zkUtil.getZooKeeperConnectString());\n+        BookKeeper newBk = new BookKeeper(newConf);\n+\n+        LedgerHandle lh = bkc.openLedger(id, digestType, passwd);\n+\n+        ArrayList<BookieSocketAddress> ensemble =\n+                lh.getLedgerMetadata().getEnsemble(5);\n+        // kill two bookies\n+        killBookie(ensemble.get(0));\n+        killBookie(ensemble.get(1));\n+        killBookie(ensemble.get(2));\n+\n+        // read multiple entries\n+        LatchCallback latch = new LatchCallback();\n+        PendingReadOp readOp =\n+                new PendingReadOp(lh, lh.bk.scheduler, 0, numEntries - 1, latch, null);\n+        readOp.parallelRead(true).initiate();\n+        latch.expectFail();\n+        assertEquals(BKException.Code.BookieHandleNotAvailableException, latch.getRc());\n+\n+        lh.close();\n+        newBk.close();\n+    }\n+\n+}"}]}