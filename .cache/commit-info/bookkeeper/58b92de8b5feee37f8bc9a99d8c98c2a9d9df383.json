{"sha":"58b92de8b5feee37f8bc9a99d8c98c2a9d9df383","node_id":"MDY6Q29tbWl0NDc4NTkyNTI2OjU4YjkyZGU4YjVmZWVlMzdmOGJjOWE5OWQ4Yzk4YzJhOWQ5ZGYzODM=","commit":{"author":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2017-06-05T20:25:17Z"},"committer":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2017-06-05T20:25:17Z"},"message":"BOOKKEEPER-748: Move fence requests out of read threads\n\nThis change is moving the fence request out of current read threads and using callback to trigger scheduling read entry and also it refactors the ReadEntryProcessV3 to support long poll in the subsequent requests.\n\nMajor changes:\n\n- change fence request to use SettableFuture\n- refactor ReadEntryProcessV3: to support run fence request in callback and support long poll (in subsequent requests)\n- fix stats issue: requests stats measure the latency from bookie receives the request until it sends the response.\n- remove \"public static final\" for state fields. it is not needed for variables in Interface.\n\nAuthor: Sijie Guo <sijie@apache.org>\nAuthor: Robin Dhamankar <rdhamankar@twitter.com>\n\nReviewers: Enrico Olivelli <eolivelli@gmail.com>, Jia Zhai <None>\n\nCloses #174 from sijie/longpoll/part1_server_side_change","tree":{"sha":"03c42f4d681db1cd981519f25f32d171940bdb8a","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/trees/03c42f4d681db1cd981519f25f32d171940bdb8a"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/commits/58b92de8b5feee37f8bc9a99d8c98c2a9d9df383","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/58b92de8b5feee37f8bc9a99d8c98c2a9d9df383","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/58b92de8b5feee37f8bc9a99d8c98c2a9d9df383","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/58b92de8b5feee37f8bc9a99d8c98c2a9d9df383/comments","author":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"committer":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"parents":[{"sha":"5fe86525a9c823f79b3e97fd82ea4aa1c75c79eb","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/5fe86525a9c823f79b3e97fd82ea4aa1c75c79eb","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/5fe86525a9c823f79b3e97fd82ea4aa1c75c79eb"}],"stats":{"total":812,"additions":553,"deletions":259},"files":[{"sha":"dc16b524064bfbf989df88f5e2784f2131a5af57","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BookKeeperServerStats.java","status":"modified","additions":82,"deletions":59,"changes":141,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/58b92de8b5feee37f8bc9a99d8c98c2a9d9df383/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FBookKeeperServerStats.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/58b92de8b5feee37f8bc9a99d8c98c2a9d9df383/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FBookKeeperServerStats.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FBookKeeperServerStats.java?ref=58b92de8b5feee37f8bc9a99d8c98c2a9d9df383","patch":"@@ -22,78 +22,101 @@\n \n public interface BookKeeperServerStats {\n \n-    public final static String SERVER_SCOPE = \"bookkeeper_server\";\n-    public final static String BOOKIE_SCOPE = \"bookie\";\n+    String SERVER_SCOPE = \"bookkeeper_server\";\n+    String BOOKIE_SCOPE = \"bookie\";\n \n-    public final static String SERVER_STATUS = \"SERVER_STATUS\";\n+    String SERVER_STATUS = \"SERVER_STATUS\";\n \n+    //\n+    // Network Stats (scoped under SERVER_SCOPE)\n+    //\n+\n+    // Stats\n+    String CHANNEL_WRITE = \"CHANNEL_WRITE\";\n+\n+    //\n     // Server Operations\n-    public final static String ADD_ENTRY_REQUEST = \"ADD_ENTRY_REQUEST\";\n-    public final static String ADD_ENTRY = \"ADD_ENTRY\";\n-    public final static String READ_ENTRY_REQUEST = \"READ_ENTRY_REQUEST\";\n-    public final static String READ_ENTRY = \"READ_ENTRY\";\n-    public final static String READ_ENTRY_FENCE_REQUEST = \"READ_ENTRY_FENCE_REQUEST\";\n-    public final static String READ_ENTRY_FENCE_WAIT = \"READ_ENTRY_FENCE_WAIT\";\n-    public final static String READ_ENTRY_FENCE_READ = \"READ_ENTRY_FENCE_READ\";\n-    public final static String WRITE_LAC = \"WRITE_LAC\";\n-    public final static String READ_LAC = \"READ_LAC\";\n-    public final static String GET_BOOKIE_INFO = \"GET_BOOKIE_INFO\";\n+    //\n+\n+    // Stats\n+    String ADD_ENTRY_REQUEST = \"ADD_ENTRY_REQUEST\";\n+    String ADD_ENTRY = \"ADD_ENTRY\";\n+    String READ_ENTRY_REQUEST = \"READ_ENTRY_REQUEST\";\n+    String READ_ENTRY = \"READ_ENTRY\";\n+    String READ_ENTRY_SCHEDULING_DELAY = \"READ_ENTRY_SCHEDULING_DELAY\";\n+    String READ_ENTRY_FENCE_REQUEST = \"READ_ENTRY_FENCE_REQUEST\";\n+    String READ_ENTRY_FENCE_WAIT = \"READ_ENTRY_FENCE_WAIT\";\n+    String READ_ENTRY_FENCE_READ = \"READ_ENTRY_FENCE_READ\";\n+    String READ_ENTRY_LONG_POLL_REQUEST = \"READ_ENTRY_LONG_POLL_REQUEST\";\n+    String READ_ENTRY_LONG_POLL_PRE_WAIT = \"READ_ENTRY_LONG_POLL_PRE_WAIT\";\n+    String READ_ENTRY_LONG_POLL_WAIT = \"READ_ENTRY_LONG_POLL_WAIT\";\n+    String READ_ENTRY_LONG_POLL_READ = \"READ_ENTRY_LONG_POLL_READ\";\n+    String WRITE_LAC_REQUEST = \"WRITE_LAC_REQUEST\";\n+    String WRITE_LAC = \"WRITE_LAC\";\n+    String READ_LAC_REQUEST = \"READ_LAC_REQUEST\";\n+    String READ_LAC = \"READ_LAC\";\n+    String GET_BOOKIE_INFO_REQUEST = \"GET_BOOKIE_INFO_REQUEST\";\n+    String GET_BOOKIE_INFO = \"GET_BOOKIE_INFO\";\n \n     // Bookie Operations\n-    public final static String BOOKIE_ADD_ENTRY_BYTES = \"BOOKIE_ADD_ENTRY_BYTES\";\n-    public final static String BOOKIE_READ_ENTRY_BYTES = \"BOOKIE_READ_ENTRY_BYTES\";\n-    public final static String BOOKIE_ADD_ENTRY = \"BOOKIE_ADD_ENTRY\";\n-    public final static String BOOKIE_RECOVERY_ADD_ENTRY = \"BOOKIE_RECOVERY_ADD_ENTRY\";\n-    public final static String BOOKIE_READ_ENTRY = \"BOOKIE_READ_ENTRY\";\n+    String BOOKIE_ADD_ENTRY = \"BOOKIE_ADD_ENTRY\";\n+    String BOOKIE_RECOVERY_ADD_ENTRY = \"BOOKIE_RECOVERY_ADD_ENTRY\";\n+    String BOOKIE_READ_ENTRY = \"BOOKIE_READ_ENTRY\";\n+    String BOOKIE_READ_LAST_CONFIRMED = \"BOOKIE_READ_LAST_CONFIRMED\";\n+    String BOOKIE_ADD_ENTRY_BYTES = \"BOOKIE_ADD_ENTRY_BYTES\";\n+    String BOOKIE_READ_ENTRY_BYTES = \"BOOKIE_READ_ENTRY_BYTES\";\n+\n+    //\n+    // Journal Stats (scoped under SERVER_SCOPE)\n+    //\n \n-    // Journal Stats\n-    public final static String JOURNAL_SCOPE = \"journal\";\n-    public final static String JOURNAL_ADD_ENTRY = \"JOURNAL_ADD_ENTRY\";\n-    public final static String JOURNAL_SYNC = \"JOURNAL_SYNC\";\n-    public final static String JOURNAL_MEM_ADD_ENTRY = \"JOURNAL_MEM_ADD_ENTRY\";\n-    public final static String JOURNAL_PREALLOCATION = \"JOURNAL_PREALLOCATION\";\n-    public final static String JOURNAL_FORCE_WRITE_LATENCY = \"JOURNAL_FORCE_WRITE_LATENCY\";\n-    public final static String JOURNAL_FORCE_WRITE_BATCH_ENTRIES = \"JOURNAL_FORCE_WRITE_BATCH_ENTRIES\";\n-    public final static String JOURNAL_FORCE_WRITE_BATCH_BYTES = \"JOURNAL_FORCE_WRITE_BATCH_BYTES\";\n-    public final static String JOURNAL_FLUSH_LATENCY = \"JOURNAL_FLUSH_LATENCY\";\n-    public final static String JOURNAL_QUEUE_LATENCY = \"JOURNAL_QUEUE_LATENCY\";\n-    public final static String JOURNAL_PROCESS_TIME_LATENCY = \"JOURNAL_PROCESS_TIME_LATENCY\";\n-    public final static String JOURNAL_CREATION_LATENCY = \"JOURNAL_CREATION_LATENCY\";\n+    String JOURNAL_SCOPE = \"journal\";\n+    String JOURNAL_ADD_ENTRY = \"JOURNAL_ADD_ENTRY\";\n+    String JOURNAL_SYNC = \"JOURNAL_SYNC\";\n+    String JOURNAL_MEM_ADD_ENTRY = \"JOURNAL_MEM_ADD_ENTRY\";\n+    String JOURNAL_PREALLOCATION = \"JOURNAL_PREALLOCATION\";\n+    String JOURNAL_FORCE_WRITE_LATENCY = \"JOURNAL_FORCE_WRITE_LATENCY\";\n+    String JOURNAL_FORCE_WRITE_BATCH_ENTRIES = \"JOURNAL_FORCE_WRITE_BATCH_ENTRIES\";\n+    String JOURNAL_FORCE_WRITE_BATCH_BYTES = \"JOURNAL_FORCE_WRITE_BATCH_BYTES\";\n+    String JOURNAL_FLUSH_LATENCY = \"JOURNAL_FLUSH_LATENCY\";\n+    String JOURNAL_QUEUE_LATENCY = \"JOURNAL_QUEUE_LATENCY\";\n+    String JOURNAL_PROCESS_TIME_LATENCY = \"JOURNAL_PROCESS_TIME_LATENCY\";\n+    String JOURNAL_CREATION_LATENCY = \"JOURNAL_CREATION_LATENCY\";\n \n     // Ledger Storage Stats\n-    public final static String STORAGE_GET_OFFSET = \"STORAGE_GET_OFFSET\";\n-    public final static String STORAGE_GET_ENTRY = \"STORAGE_GET_ENTRY\";\n-    public final static String SKIP_LIST_GET_ENTRY = \"SKIP_LIST_GET_ENTRY\";\n-    public final static String SKIP_LIST_PUT_ENTRY = \"SKIP_LIST_PUT_ENTRY\";\n-    public final static String SKIP_LIST_SNAPSHOT = \"SKIP_LIST_SNAPSHOT\";\n+    String STORAGE_GET_OFFSET = \"STORAGE_GET_OFFSET\";\n+    String STORAGE_GET_ENTRY = \"STORAGE_GET_ENTRY\";\n+    String SKIP_LIST_GET_ENTRY = \"SKIP_LIST_GET_ENTRY\";\n+    String SKIP_LIST_PUT_ENTRY = \"SKIP_LIST_PUT_ENTRY\";\n+    String SKIP_LIST_SNAPSHOT = \"SKIP_LIST_SNAPSHOT\";\n \n     // Counters\n-    public final static String JOURNAL_WRITE_BYTES = \"JOURNAL_WRITE_BYTES\";\n-    public final static String JOURNAL_QUEUE_SIZE = \"JOURNAL_QUEUE_SIZE\";\n-    public final static String READ_BYTES = \"READ_BYTES\";\n-    public final static String WRITE_BYTES = \"WRITE_BYTES\";\n-    public final static String NUM_MINOR_COMP = \"NUM_MINOR_COMP\";\n-    public final static String NUM_MAJOR_COMP = \"NUM_MAJOR_COMP\";\n-    public final static String JOURNAL_FORCE_WRITE_QUEUE_SIZE = \"JOURNAL_FORCE_WRITE_QUEUE_SIZE\";\n-    public final static String JOURNAL_NUM_FORCE_WRITES = \"JOURNAL_NUM_FORCE_WRITES\";\n-    public final static String JOURNAL_NUM_FLUSH_EMPTY_QUEUE = \"JOURNAL_NUM_FLUSH_EMPTY_QUEUE\";\n-    public final static String JOURNAL_NUM_FLUSH_MAX_OUTSTANDING_BYTES = \"JOURNAL_NUM_FLUSH_MAX_OUTSTANDING_BYTES\";\n-    public final static String JOURNAL_NUM_FLUSH_MAX_WAIT = \"JOURNAL_NUM_FLUSH_MAX_WAIT\";\n-    public final static String SKIP_LIST_FLUSH_BYTES = \"SKIP_LIST_FLUSH_BYTES\";\n-    public final static String SKIP_LIST_THROTTLING = \"SKIP_LIST_THROTTLING\";\n-    public final static String READ_LAST_ENTRY_NOENTRY_ERROR = \"READ_LAST_ENTRY_NOENTRY_ERROR\";\n-    public final static String LEDGER_CACHE_NUM_EVICTED_LEDGERS = \"LEDGER_CACHE_NUM_EVICTED_LEDGERS\";\n+    String JOURNAL_WRITE_BYTES = \"JOURNAL_WRITE_BYTES\";\n+    String JOURNAL_QUEUE_SIZE = \"JOURNAL_QUEUE_SIZE\";\n+    String READ_BYTES = \"READ_BYTES\";\n+    String WRITE_BYTES = \"WRITE_BYTES\";\n+    String NUM_MINOR_COMP = \"NUM_MINOR_COMP\";\n+    String NUM_MAJOR_COMP = \"NUM_MAJOR_COMP\";\n+    String JOURNAL_FORCE_WRITE_QUEUE_SIZE = \"JOURNAL_FORCE_WRITE_QUEUE_SIZE\";\n+    String JOURNAL_NUM_FORCE_WRITES = \"JOURNAL_NUM_FORCE_WRITES\";\n+    String JOURNAL_NUM_FLUSH_EMPTY_QUEUE = \"JOURNAL_NUM_FLUSH_EMPTY_QUEUE\";\n+    String JOURNAL_NUM_FLUSH_MAX_OUTSTANDING_BYTES = \"JOURNAL_NUM_FLUSH_MAX_OUTSTANDING_BYTES\";\n+    String JOURNAL_NUM_FLUSH_MAX_WAIT = \"JOURNAL_NUM_FLUSH_MAX_WAIT\";\n+    String SKIP_LIST_FLUSH_BYTES = \"SKIP_LIST_FLUSH_BYTES\";\n+    String SKIP_LIST_THROTTLING = \"SKIP_LIST_THROTTLING\";\n+    String READ_LAST_ENTRY_NOENTRY_ERROR = \"READ_LAST_ENTRY_NOENTRY_ERROR\";\n+    String LEDGER_CACHE_NUM_EVICTED_LEDGERS = \"LEDGER_CACHE_NUM_EVICTED_LEDGERS\";\n \n     // Gauge\n-    public final static String NUM_INDEX_PAGES = \"NUM_INDEX_PAGES\";\n-    public final static String NUM_OPEN_LEDGERS = \"NUM_OPEN_LEDGERS\";\n-    public final static String JOURNAL_FORCE_WRITE_GROUPING_COUNT = \"JOURNAL_FORCE_WRITE_GROUPING_COUNT\";\n-    public final static String NUM_PENDING_READ = \"NUM_PENDING_READ\";\n-    public final static String NUM_PENDING_ADD = \"NUM_PENDING_ADD\";\n+    String NUM_INDEX_PAGES = \"NUM_INDEX_PAGES\";\n+    String NUM_OPEN_LEDGERS = \"NUM_OPEN_LEDGERS\";\n+    String JOURNAL_FORCE_WRITE_GROUPING_COUNT = \"JOURNAL_FORCE_WRITE_GROUPING_COUNT\";\n+    String NUM_PENDING_READ = \"NUM_PENDING_READ\";\n+    String NUM_PENDING_ADD = \"NUM_PENDING_ADD\";\n \n     // LedgerDirs Stats\n-    public final static String LD_LEDGER_SCOPE = \"ledger\";\n-    public final static String LD_INDEX_SCOPE = \"index\";\n-    public final static String LD_WRITABLE_DIRS = \"writable_dirs\";\n+    String LD_LEDGER_SCOPE = \"ledger\";\n+    String LD_INDEX_SCOPE = \"index\";\n+    String LD_WRITABLE_DIRS = \"writable_dirs\";\n \n }"},{"sha":"12f491d8454d06c335a1291896ead17868906f03","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/Bookie.java","status":"modified","additions":26,"deletions":74,"changes":100,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/58b92de8b5feee37f8bc9a99d8c98c2a9d9df383/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FBookie.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/58b92de8b5feee37f8bc9a99d8c98c2a9d9df383/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FBookie.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FBookie.java?ref=58b92de8b5feee37f8bc9a99d8c98c2a9d9df383","patch":"@@ -22,6 +22,8 @@\n package org.apache.bookkeeper.bookie;\n \n import static com.google.common.base.Charsets.UTF_8;\n+\n+import com.google.common.util.concurrent.SettableFuture;\n import io.netty.buffer.ByteBuf;\n import io.netty.buffer.Unpooled;\n \n@@ -207,78 +209,6 @@ public void writeComplete(int rc, long ledgerId, long entryId,\n         }\n     }\n \n-    final static Future<Boolean> SUCCESS_FUTURE = new Future<Boolean>() {\n-        @Override\n-        public boolean cancel(boolean mayInterruptIfRunning) { return false; }\n-        @Override\n-        public Boolean get() { return true; }\n-        @Override\n-        public Boolean get(long timeout, TimeUnit unit) { return true; }\n-        @Override\n-        public boolean isCancelled() { return false; }\n-        @Override\n-        public boolean isDone() {\n-            return true;\n-        }\n-    };\n-\n-    static class CountDownLatchFuture<T> implements Future<T> {\n-\n-        T value = null;\n-        volatile boolean done = false;\n-        CountDownLatch latch = new CountDownLatch(1);\n-\n-        @Override\n-        public boolean cancel(boolean mayInterruptIfRunning) { return false; }\n-        @Override\n-        public T get() throws InterruptedException {\n-            latch.await();\n-            return value;\n-        }\n-        @Override\n-        public T get(long timeout, TimeUnit unit)\n-            throws InterruptedException, TimeoutException {\n-            if (!latch.await(timeout, unit)) {\n-                throw new TimeoutException(\"Timed out waiting for latch\");\n-            }\n-            return value;\n-        }\n-\n-        @Override\n-        public boolean isCancelled() { return false; }\n-\n-        @Override\n-        public boolean isDone() {\n-            return done;\n-        }\n-\n-        void setDone(T value) {\n-            this.value = value;\n-            done = true;\n-            latch.countDown();\n-        }\n-    }\n-\n-    static class FutureWriteCallback implements WriteCallback {\n-\n-        CountDownLatchFuture<Boolean> result =\n-            new CountDownLatchFuture<Boolean>();\n-\n-        @Override\n-        public void writeComplete(int rc, long ledgerId, long entryId,\n-                                  BookieSocketAddress addr, Object ctx) {\n-            if (LOG.isDebugEnabled()) {\n-                LOG.debug(\"Finished writing entry {} @ ledger {} for {} : {}\",\n-                          new Object[] { entryId, ledgerId, addr, rc });\n-            }\n-            result.setDone(0 == rc);\n-        }\n-\n-        public Future<Boolean> getResult() {\n-            return result;\n-        }\n-    }\n-\n     public static void checkDirectoryStructure(File dir) throws IOException {\n         if (!dir.exists()) {\n             File parent = dir.getParentFile();\n@@ -1454,6 +1384,26 @@ public void addEntry(ByteBuf entry, WriteCallback cb, Object ctx, byte[] masterK\n             entry.release();\n         }\n     }\n+    \n+    static class FutureWriteCallback implements WriteCallback {\n+\n+        SettableFuture<Boolean> result = SettableFuture.create();\n+\n+        @Override\n+        public void writeComplete(int rc, long ledgerId, long entryId,\n+                                  BookieSocketAddress addr, Object ctx) {\n+            if (LOG.isDebugEnabled()) {\n+                LOG.debug(\"Finished writing entry {} @ ledger {} for {} : {}\",\n+                          new Object[] { entryId, ledgerId, addr, rc });\n+            }\n+\n+            result.set(0 == rc);\n+        }\n+\n+        public SettableFuture<Boolean> getResult() {\n+            return result;\n+        }\n+    }\n \n     /**\n      * Fences a ledger. From this point on, clients will be unable to\n@@ -1462,7 +1412,7 @@ public void addEntry(ByteBuf entry, WriteCallback cb, Object ctx, byte[] masterK\n      * This method is idempotent. Once a ledger is fenced, it can\n      * never be unfenced. Fencing a fenced ledger has no effect.\n      */\n-    public Future<Boolean> fenceLedger(long ledgerId, byte[] masterKey) throws IOException, BookieException {\n+    public SettableFuture<Boolean> fenceLedger(long ledgerId, byte[] masterKey) throws IOException, BookieException {\n         LedgerDescriptor handle = handles.getHandle(ledgerId, masterKey);\n         boolean success;\n         synchronized (handle) {\n@@ -1483,7 +1433,9 @@ public Future<Boolean> fenceLedger(long ledgerId, byte[] masterKey) throws IOExc\n             return fwc.getResult();\n         } else {\n             // already fenced\n-            return SUCCESS_FUTURE;\n+            SettableFuture<Boolean> successFuture = SettableFuture.create();\n+            successFuture.set(true);\n+            return successFuture;\n         }\n     }\n "},{"sha":"a1e0fc0b6f17e50901682e26b9e5bc47e390f86e","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/LedgerDescriptorImpl.java","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/58b92de8b5feee37f8bc9a99d8c98c2a9d9df383/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLedgerDescriptorImpl.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/58b92de8b5feee37f8bc9a99d8c98c2a9d9df383/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLedgerDescriptorImpl.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FLedgerDescriptorImpl.java?ref=58b92de8b5feee37f8bc9a99d8c98c2a9d9df383","patch":"@@ -81,6 +81,7 @@ ByteBuf getExplicitLac() {\n         return ledgerStorage.getExplicitLac(ledgerId);\n     }\n \n+    @Override\n     long addEntry(ByteBuf entry) throws IOException {\n         long ledgerId = entry.getLong(entry.readerIndex());\n "},{"sha":"e1ccabc4501efafda1054b98fe6b9a5b3df683f5","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieProtoEncoding.java","status":"modified","additions":2,"deletions":3,"changes":5,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/58b92de8b5feee37f8bc9a99d8c98c2a9d9df383/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookieProtoEncoding.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/58b92de8b5feee37f8bc9a99d8c98c2a9d9df383/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookieProtoEncoding.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookieProtoEncoding.java?ref=58b92de8b5feee37f8bc9a99d8c98c2a9d9df383","patch":"@@ -46,10 +46,9 @@\n import io.netty.handler.codec.MessageToMessageEncoder;\n \n public class BookieProtoEncoding {\n-    private final static Logger LOG = LoggerFactory.getLogger(BookieProtoEncoding.class);\n-\n-    static interface EnDecoder {\n+    private static final Logger LOG = LoggerFactory.getLogger(BookieProtoEncoding.class);\n \n+    public static interface EnDecoder {\n         /**\n          * Encode a <i>object</i> into channel buffer.\n          *"},{"sha":"4df404499526556dc51c22d14b41d86c66044b1a","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieProtocol.java","status":"modified","additions":7,"deletions":0,"changes":7,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/58b92de8b5feee37f8bc9a99d8c98c2a9d9df383/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookieProtocol.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/58b92de8b5feee37f8bc9a99d8c98c2a9d9df383/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookieProtocol.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookieProtocol.java?ref=58b92de8b5feee37f8bc9a99d8c98c2a9d9df383","patch":"@@ -355,6 +355,13 @@ static class AddResponse extends Response {\n             super(protocolVersion, ADDENTRY, errorCode, ledgerId, entryId);\n         }\n     }\n+    \n+    static class ErrorResponse extends Response {\n+        ErrorResponse(byte protocolVersion, byte opCode, int errorCode,\n+                      long ledgerId, long entryId) {\n+            super(protocolVersion, opCode, errorCode, ledgerId, entryId);\n+        }\n+    }\n \n     static class AuthResponse extends Response {\n         final AuthMessage authMessage;"},{"sha":"ce5972e4ac4276f021ea92881bf3bbc81a62c438","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieRequestProcessor.java","status":"modified","additions":42,"deletions":5,"changes":47,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/58b92de8b5feee37f8bc9a99d8c98c2a9d9df383/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookieRequestProcessor.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/58b92de8b5feee37f8bc9a99d8c98c2a9d9df383/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookieRequestProcessor.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookieRequestProcessor.java?ref=58b92de8b5feee37f8bc9a99d8c98c2a9d9df383","patch":"@@ -21,12 +21,10 @@\n package org.apache.bookkeeper.proto;\n \n import com.google.protobuf.ByteString;\n-\n import io.netty.channel.Channel;\n-\n+import java.util.concurrent.ExecutorService;\n import org.apache.bookkeeper.auth.AuthProviderFactoryFactory;\n import org.apache.bookkeeper.auth.AuthToken;\n-\n import org.apache.bookkeeper.bookie.Bookie;\n import org.apache.bookkeeper.conf.ServerConfiguration;\n import org.apache.bookkeeper.processor.RequestProcessor;\n@@ -38,15 +36,28 @@\n \n import static org.apache.bookkeeper.bookie.BookKeeperServerStats.ADD_ENTRY;\n import static org.apache.bookkeeper.bookie.BookKeeperServerStats.ADD_ENTRY_REQUEST;\n+import static org.apache.bookkeeper.bookie.BookKeeperServerStats.CHANNEL_WRITE;\n+import static org.apache.bookkeeper.bookie.BookKeeperServerStats.GET_BOOKIE_INFO_REQUEST;\n import static org.apache.bookkeeper.bookie.BookKeeperServerStats.READ_ENTRY;\n+import static org.apache.bookkeeper.bookie.BookKeeperServerStats.READ_ENTRY_FENCE_READ;\n+import static org.apache.bookkeeper.bookie.BookKeeperServerStats.READ_ENTRY_FENCE_REQUEST;\n+import static org.apache.bookkeeper.bookie.BookKeeperServerStats.READ_ENTRY_FENCE_WAIT;\n+import static org.apache.bookkeeper.bookie.BookKeeperServerStats.READ_ENTRY_LONG_POLL_PRE_WAIT;\n+import static org.apache.bookkeeper.bookie.BookKeeperServerStats.READ_ENTRY_LONG_POLL_READ;\n+import static org.apache.bookkeeper.bookie.BookKeeperServerStats.READ_ENTRY_LONG_POLL_REQUEST;\n+import static org.apache.bookkeeper.bookie.BookKeeperServerStats.READ_ENTRY_LONG_POLL_WAIT;\n import static org.apache.bookkeeper.bookie.BookKeeperServerStats.READ_ENTRY_REQUEST;\n+import static org.apache.bookkeeper.bookie.BookKeeperServerStats.READ_ENTRY_SCHEDULING_DELAY;\n+import static org.apache.bookkeeper.bookie.BookKeeperServerStats.READ_LAC_REQUEST;\n import static org.apache.bookkeeper.bookie.BookKeeperServerStats.WRITE_LAC;\n import static org.apache.bookkeeper.bookie.BookKeeperServerStats.READ_LAC;\n import static org.apache.bookkeeper.bookie.BookKeeperServerStats.GET_BOOKIE_INFO;\n+import static org.apache.bookkeeper.bookie.BookKeeperServerStats.WRITE_LAC_REQUEST;\n \n public class BookieRequestProcessor implements RequestProcessor {\n \n-    private final static Logger LOG = LoggerFactory.getLogger(BookieRequestProcessor.class);\n+    private static final Logger LOG = LoggerFactory.getLogger(BookieRequestProcessor.class);\n+\n     /**\n      * The server configuration. We use this for getting the number of add and read\n      * worker threads.\n@@ -75,9 +86,21 @@ public class BookieRequestProcessor implements RequestProcessor {\n     final OpStatsLogger addEntryStats;\n     final OpStatsLogger readRequestStats;\n     final OpStatsLogger readEntryStats;\n+    final OpStatsLogger fenceReadRequestStats;\n+    final OpStatsLogger fenceReadEntryStats;\n+    final OpStatsLogger fenceReadWaitStats;\n+    final OpStatsLogger readEntrySchedulingDelayStats;\n+    final OpStatsLogger longPollPreWaitStats;\n+    final OpStatsLogger longPollWaitStats;\n+    final OpStatsLogger longPollReadStats;\n+    final OpStatsLogger longPollReadRequestStats;\n+    final OpStatsLogger writeLacRequestStats;\n     final OpStatsLogger writeLacStats;\n+    final OpStatsLogger readLacRequestStats;\n     final OpStatsLogger readLacStats;\n+    final OpStatsLogger getBookieInfoRequestStats;\n     final OpStatsLogger getBookieInfoStats;\n+    final OpStatsLogger channelWriteStats;\n \n     public BookieRequestProcessor(ServerConfiguration serverCfg, Bookie bookie,\n                                   StatsLogger statsLogger) {\n@@ -91,9 +114,21 @@ public BookieRequestProcessor(ServerConfiguration serverCfg, Bookie bookie,\n         this.addRequestStats = statsLogger.getOpStatsLogger(ADD_ENTRY_REQUEST);\n         this.readEntryStats = statsLogger.getOpStatsLogger(READ_ENTRY);\n         this.readRequestStats = statsLogger.getOpStatsLogger(READ_ENTRY_REQUEST);\n+        this.fenceReadEntryStats = statsLogger.getOpStatsLogger(READ_ENTRY_FENCE_READ);\n+        this.fenceReadRequestStats = statsLogger.getOpStatsLogger(READ_ENTRY_FENCE_REQUEST);\n+        this.fenceReadWaitStats = statsLogger.getOpStatsLogger(READ_ENTRY_FENCE_WAIT);\n+        this.readEntrySchedulingDelayStats = statsLogger.getOpStatsLogger(READ_ENTRY_SCHEDULING_DELAY);\n+        this.longPollPreWaitStats = statsLogger.getOpStatsLogger(READ_ENTRY_LONG_POLL_PRE_WAIT);\n+        this.longPollWaitStats = statsLogger.getOpStatsLogger(READ_ENTRY_LONG_POLL_WAIT);\n+        this.longPollReadStats = statsLogger.getOpStatsLogger(READ_ENTRY_LONG_POLL_READ);\n+        this.longPollReadRequestStats = statsLogger.getOpStatsLogger(READ_ENTRY_LONG_POLL_REQUEST);\n         this.writeLacStats = statsLogger.getOpStatsLogger(WRITE_LAC);\n+        this.writeLacRequestStats = statsLogger.getOpStatsLogger(WRITE_LAC_REQUEST);\n         this.readLacStats = statsLogger.getOpStatsLogger(READ_LAC);\n+        this.readLacRequestStats = statsLogger.getOpStatsLogger(READ_LAC_REQUEST);\n         this.getBookieInfoStats = statsLogger.getOpStatsLogger(GET_BOOKIE_INFO);\n+        this.getBookieInfoRequestStats = statsLogger.getOpStatsLogger(GET_BOOKIE_INFO_REQUEST);\n+        this.channelWriteStats = statsLogger.getOpStatsLogger(CHANNEL_WRITE);\n     }\n \n     @Override\n@@ -194,7 +229,9 @@ private void processAddRequestV3(final BookkeeperProtocol.Request r, final Chann\n     }\n \n     private void processReadRequestV3(final BookkeeperProtocol.Request r, final Channel c) {\n-        ReadEntryProcessorV3 read = new ReadEntryProcessorV3(r, c, this);\n+        ExecutorService fenceThreadPool =\n+          null == readThreadPool ? null : readThreadPool.chooseThread(c);\n+        ReadEntryProcessorV3 read = new ReadEntryProcessorV3(r, c, this, fenceThreadPool);\n         if (null == readThreadPool) {\n             read.run();\n         } else {"},{"sha":"8de9783781eb7b4eef0fb48a228eb944a88e570b","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookkeeperInternalCallbacks.java","status":"modified","additions":76,"deletions":15,"changes":91,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/58b92de8b5feee37f8bc9a99d8c98c2a9d9df383/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookkeeperInternalCallbacks.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/58b92de8b5feee37f8bc9a99d8c98c2a9d9df383/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookkeeperInternalCallbacks.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookkeeperInternalCallbacks.java?ref=58b92de8b5feee37f8bc9a99d8c98c2a9d9df383","patch":"@@ -22,15 +22,18 @@\n package org.apache.bookkeeper.proto;\n \n import io.netty.buffer.ByteBuf;\n-\n+import java.util.concurrent.ExecutorService;\n import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.RejectedExecutionException;\n+import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicInteger;\n-\n import org.apache.bookkeeper.client.LedgerEntry;\n import org.apache.bookkeeper.client.LedgerHandle;\n import org.apache.bookkeeper.client.LedgerMetadata;\n import org.apache.bookkeeper.client.BookieInfoReader.BookieInfo;\n import org.apache.bookkeeper.net.BookieSocketAddress;\n+import org.apache.bookkeeper.stats.OpStatsLogger;\n+import org.apache.bookkeeper.util.MathUtils;\n import org.apache.zookeeper.AsyncCallback;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -39,7 +42,6 @@\n  * Declaration of a callback interfaces used in bookkeeper client library but\n  * not exposed to the client application.\n  */\n-\n public class BookkeeperInternalCallbacks {\n \n     static final Logger LOG = LoggerFactory.getLogger(BookkeeperInternalCallbacks.class);\n@@ -80,22 +82,47 @@ public interface WriteLacCallback {\n     public interface GenericCallback<T> {\n         void operationComplete(int rc, T result);\n     }\n+    \n+        public static class TimedGenericCallback<T> implements GenericCallback<T> {\n+\n+        final GenericCallback<T> cb;\n+        final int successRc;\n+        final OpStatsLogger statsLogger;\n+        final long startTime;\n+\n+        public TimedGenericCallback(GenericCallback<T> cb, int successRc, OpStatsLogger statsLogger) {\n+            this.cb = cb;\n+            this.successRc = successRc;\n+            this.statsLogger = statsLogger;\n+            this.startTime = MathUtils.nowInNano();\n+        }\n+\n+        @Override\n+        public void operationComplete(int rc, T result) {\n+            if (successRc == rc) {\n+                statsLogger.registerSuccessfulEvent(MathUtils.elapsedNanos(startTime), TimeUnit.NANOSECONDS);\n+            } else {\n+                statsLogger.registerFailedEvent(MathUtils.elapsedNanos(startTime), TimeUnit.NANOSECONDS);\n+            }\n+            cb.operationComplete(rc, result);\n+        }\n+    }\n+    \n+    public interface ReadEntryCallbackCtx {\n+        void setLastAddConfirmed(long lac);\n+        long getLastAddConfirmed();\n+    }\n \n     /**\n      * Declaration of a callback implementation for calls from BookieClient objects.\n      * Such calls are for replies of read operations (operations to read an entry\n      * from a ledger).\n      *\n      */\n-\n     public interface ReadEntryCallback {\n         void readEntryComplete(int rc, long ledgerId, long entryId, ByteBuf buffer, Object ctx);\n     }\n \n-    public interface GetBookieInfoCallback {\n-        void getBookieInfoComplete(int rc, BookieInfo bInfo, Object ctx);\n-    }\n-\n     /**\n      * Listener on entries responded.\n      */\n@@ -114,6 +141,10 @@ public interface ReadEntryListener {\n          */\n         void onEntryComplete(int rc, LedgerHandle lh, LedgerEntry entry, Object ctx);\n     }\n+    \n+    public interface GetBookieInfoCallback {\n+        void getBookieInfoComplete(int rc, BookieInfo bInfo, Object ctx);\n+    }\n \n     /**\n      * This is a multi callback object that waits for all of\n@@ -128,29 +159,59 @@ public static class MultiCallback implements AsyncCallback.VoidCallback {\n         // Final callback and the corresponding context to invoke\n         final AsyncCallback.VoidCallback cb;\n         final Object context;\n+        final ExecutorService callbackExecutor;\n         // This keeps track of how many operations have completed\n         final AtomicInteger done = new AtomicInteger();\n         // List of the exceptions from operations that completed unsuccessfully\n         final LinkedBlockingQueue<Integer> exceptions = new LinkedBlockingQueue<Integer>();\n \n-        public MultiCallback(int expected, AsyncCallback.VoidCallback cb, Object context, int successRc, int failureRc) {\n+        public MultiCallback(int expected, AsyncCallback.VoidCallback cb, Object context,\n+                             int successRc, int failureRc) {\n+            this(expected, cb, context, successRc, failureRc, null);\n+        }\n+\n+        public MultiCallback(int expected, AsyncCallback.VoidCallback cb, Object context,\n+                             int successRc, int failureRc, ExecutorService callbackExecutor) {\n             this.expected = expected;\n             this.cb = cb;\n             this.context = context;\n             this.failureRc = failureRc;\n             this.successRc = successRc;\n+            this.callbackExecutor = callbackExecutor;\n             if (expected == 0) {\n-                cb.processResult(successRc, null, context);\n+                callback();\n             }\n         }\n \n         private void tick() {\n             if (done.incrementAndGet() == expected) {\n-                if (exceptions.isEmpty()) {\n-                    cb.processResult(successRc, null, context);\n-                } else {\n-                    cb.processResult(failureRc, null, context);\n+                callback();\n+            }\n+        }\n+\n+        private void callback() {\n+            if (null != callbackExecutor) {\n+                try {\n+                    callbackExecutor.submit(new Runnable() {\n+                        @Override\n+                        public void run() {\n+                            doCallback();\n+                        }\n+                    });\n+                } catch (RejectedExecutionException ree) {\n+                    // if the callback executor is shutdown, do callback in same thread\n+                    doCallback();\n                 }\n+            } else {\n+                doCallback();\n+            }\n+        }\n+\n+        private void doCallback() {\n+            if (exceptions.isEmpty()) {\n+                cb.processResult(successRc, null, context);\n+            } else {\n+                cb.processResult(failureRc, null, context);\n             }\n         }\n \n@@ -174,7 +235,7 @@ public void processResult(int rc, String path, Object ctx) {\n          *\n          * @param data\n          *          data to process\n-         * @param iterationCallback\n+         * @param cb\n          *          Callback to invoke when process has been done.\n          */\n         public void process(T data, AsyncCallback.VoidCallback cb);"},{"sha":"6b825d978f699a5e7068f700de035ecdc0f8478f","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/GetBookieInfoProcessorV3.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/58b92de8b5feee37f8bc9a99d8c98c2a9d9df383/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FGetBookieInfoProcessorV3.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/58b92de8b5feee37f8bc9a99d8c98c2a9d9df383/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FGetBookieInfoProcessorV3.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FGetBookieInfoProcessorV3.java?ref=58b92de8b5feee37f8bc9a99d8c98c2a9d9df383","patch":"@@ -91,6 +91,6 @@ private void sendResponse(GetBookieInfoResponse getBookieInfoResponse) {\n                 .setGetBookieInfoResponse(getBookieInfoResponse);\n         sendResponse(response.getStatus(),\n                      response.build(),\n-                     requestProcessor.getBookieInfoStats);\n+                     requestProcessor.getBookieInfoRequestStats);\n     }\n }"},{"sha":"e398c4a194e29c36fc7583f3fcbbedc738179750","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PacketProcessorBaseV3.java","status":"modified","additions":20,"deletions":7,"changes":27,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/58b92de8b5feee37f8bc9a99d8c98c2a9d9df383/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FPacketProcessorBaseV3.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/58b92de8b5feee37f8bc9a99d8c98c2a9d9df383/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FPacketProcessorBaseV3.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FPacketProcessorBaseV3.java?ref=58b92de8b5feee37f8bc9a99d8c98c2a9d9df383","patch":"@@ -21,7 +21,8 @@\n package org.apache.bookkeeper.proto;\n \n import io.netty.channel.Channel;\n-\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n import java.util.concurrent.TimeUnit;\n \n import org.apache.bookkeeper.proto.BookkeeperProtocol.BKPacketHeader;\n@@ -48,12 +49,24 @@ public PacketProcessorBaseV3(Request request, Channel channel,\n     }\n \n     protected void sendResponse(StatusCode code, Object response, OpStatsLogger statsLogger) {\n-        channel.writeAndFlush(response);\n-        if (StatusCode.EOK == code) {\n-            statsLogger.registerSuccessfulEvent(MathUtils.elapsedNanos(enqueueNanos), TimeUnit.NANOSECONDS);\n-        } else {\n-            statsLogger.registerFailedEvent(MathUtils.elapsedNanos(enqueueNanos), TimeUnit.NANOSECONDS);\n-        }\n+        final long writeNanos = MathUtils.nowInNano();\n+        channel.writeAndFlush(response).addListener(new ChannelFutureListener() {\n+            @Override\n+            public void operationComplete(ChannelFuture future) throws Exception {\n+                long writeElapsedNanos = MathUtils.elapsedNanos(writeNanos);\n+                if (!future.isSuccess()) {\n+                    requestProcessor.channelWriteStats.registerFailedEvent(writeElapsedNanos, TimeUnit.NANOSECONDS);\n+                } else {\n+                    requestProcessor.channelWriteStats.registerSuccessfulEvent(writeElapsedNanos, TimeUnit.NANOSECONDS);\n+                }\n+                if (StatusCode.EOK == code) {\n+                    statsLogger.registerSuccessfulEvent(MathUtils.elapsedNanos(enqueueNanos), TimeUnit.NANOSECONDS);\n+                } else {\n+                    statsLogger.registerFailedEvent(MathUtils.elapsedNanos(enqueueNanos), TimeUnit.NANOSECONDS);\n+                }\n+            }\n+        });\n+\n     }\n \n     protected boolean isVersionCompatible() {"},{"sha":"e01a339e205ab4fa2bd5c4e6014d2fa6d3a38b4b","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/ReadEntryProcessorV3.java","status":"modified","additions":256,"deletions":93,"changes":349,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/58b92de8b5feee37f8bc9a99d8c98c2a9d9df383/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FReadEntryProcessorV3.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/58b92de8b5feee37f8bc9a99d8c98c2a9d9df383/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FReadEntryProcessorV3.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FReadEntryProcessorV3.java?ref=58b92de8b5feee37f8bc9a99d8c98c2a9d9df383","patch":"@@ -17,156 +17,319 @@\n  */\n package org.apache.bookkeeper.proto;\n \n+import com.google.common.base.Stopwatch;\n+import com.google.common.util.concurrent.FutureCallback;\n+import com.google.common.util.concurrent.Futures;\n+import com.google.common.util.concurrent.SettableFuture;\n+import com.google.protobuf.ByteString;\n import io.netty.buffer.ByteBuf;\n import io.netty.channel.Channel;\n import io.netty.util.ReferenceCountUtil;\n-\n import java.io.IOException;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.Future;\n+import java.util.concurrent.ExecutorService;\n import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.TimeoutException;\n-\n import org.apache.bookkeeper.bookie.Bookie;\n import org.apache.bookkeeper.bookie.BookieException;\n import org.apache.bookkeeper.proto.BookkeeperProtocol.ReadRequest;\n import org.apache.bookkeeper.proto.BookkeeperProtocol.ReadResponse;\n import org.apache.bookkeeper.proto.BookkeeperProtocol.Request;\n import org.apache.bookkeeper.proto.BookkeeperProtocol.Response;\n import org.apache.bookkeeper.proto.BookkeeperProtocol.StatusCode;\n+import org.apache.bookkeeper.stats.OpStatsLogger;\n import org.apache.bookkeeper.util.MathUtils;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import com.google.protobuf.ByteString;\n-\n class ReadEntryProcessorV3 extends PacketProcessorBaseV3 {\n \n     private final static Logger LOG = LoggerFactory.getLogger(ReadEntryProcessorV3.class);\n \n-    public ReadEntryProcessorV3(Request request, Channel channel,\n-                                BookieRequestProcessor requestProcessor) {\n+    protected Stopwatch lastPhaseStartTime;\n+    private final ExecutorService fenceThreadPool;\n+\n+    private SettableFuture<Boolean> fenceResult = null;\n+    \n+    protected final ReadRequest readRequest;\n+    protected final long ledgerId;\n+    protected final long entryId;\n+    \n+    // Stats\n+    protected final OpStatsLogger readStats;\n+    protected final OpStatsLogger reqStats;\n+\n+    public ReadEntryProcessorV3(Request request,\n+                                Channel channel,\n+                                BookieRequestProcessor requestProcessor,\n+                                ExecutorService fenceThreadPool) {\n         super(request, channel, requestProcessor);\n+        this.readRequest = request.getReadRequest();\n+        this.ledgerId = readRequest.getLedgerId();\n+        this.entryId = readRequest.getEntryId();\n+        if (RequestUtils.isFenceRequest(this.readRequest)) {\n+            this.readStats = requestProcessor.fenceReadEntryStats;\n+            this.reqStats = requestProcessor.fenceReadRequestStats;\n+        } else if (readRequest.hasPreviousLAC()) {\n+            this.readStats = requestProcessor.longPollReadStats;\n+            this.reqStats = requestProcessor.longPollReadRequestStats;\n+        } else {\n+            this.readStats = requestProcessor.readEntryStats;\n+            this.reqStats = requestProcessor.readRequestStats;\n+        }\n+        \n+        this.fenceThreadPool = fenceThreadPool;\n+        lastPhaseStartTime = Stopwatch.createStarted();\n     }\n \n-    private ReadResponse getReadResponse() {\n-        long startTimeNanos = MathUtils.nowInNano();\n-        ReadRequest readRequest = request.getReadRequest();\n-        long ledgerId = readRequest.getLedgerId();\n-        long entryId = readRequest.getEntryId();\n+    protected Long getPreviousLAC() {\n+        if (readRequest.hasPreviousLAC()) {\n+            return readRequest.getPreviousLAC();\n+        } else {\n+            return null;\n+        }\n+    }\n \n-        ReadResponse.Builder readResponse = ReadResponse.newBuilder()\n-                .setLedgerId(ledgerId)\n-                .setEntryId(entryId);\n+    /**\n+     * Handle read result for fence read.\n+     *\n+     * @param entryBody\n+     *          read result\n+     * @param readResponseBuilder\n+     *          read response builder\n+     * @param entryId\n+     *          entry id\n+     * @param startTimeSw\n+     *          timer for the read request\n+     */\n+    protected void handleReadResultForFenceRead(\n+        final ByteBuf entryBody,\n+        final ReadResponse.Builder readResponseBuilder,\n+        final long entryId,\n+        final Stopwatch startTimeSw) {\n+        // reset last phase start time to measure fence result waiting time\n+        lastPhaseStartTime.reset().start();\n+        if (null != fenceThreadPool) {\n+            Futures.addCallback(fenceResult, new FutureCallback<Boolean>() {\n+                @Override\n+                public void onSuccess(Boolean result) {\n+                    sendFenceResponse(readResponseBuilder, entryBody, result, startTimeSw);\n+                }\n \n-        if (!isVersionCompatible()) {\n-            readResponse.setStatus(StatusCode.EBADVERSION);\n-            return readResponse.build();\n+                @Override\n+                public void onFailure(Throwable t) {\n+                    LOG.error(\"Fence request for ledgerId {} entryId {} encountered exception\",\n+                        new Object[] { ledgerId, entryId, t });\n+                    sendFenceResponse(readResponseBuilder, entryBody, false, startTimeSw);\n+                }\n+            }, fenceThreadPool);\n+        } else {\n+            boolean success = false;\n+            try {\n+                success = fenceResult.get(1000, TimeUnit.MILLISECONDS);\n+            } catch (Throwable t) {\n+                LOG.error(\"Fence request for ledgerId {} entryId {} encountered exception : \",\n+                    new Object[]{ readRequest.getLedgerId(), readRequest.getEntryId(), t });\n+            }\n+            sendFenceResponse(readResponseBuilder, entryBody, success, startTimeSw);\n         }\n+    }\n+\n+    /**\n+     * Read a specific entry.\n+     *\n+     * @param readResponseBuilder\n+     *          read response builder.\n+     * @param entryId\n+     *          entry to read\n+     * @param startTimeSw\n+     *          stop watch to measure the read operation.\n+     * @return read response or null if it is a fence read operation.\n+     * @throws IOException\n+     */\n+    protected ReadResponse readEntry(ReadResponse.Builder readResponseBuilder,\n+                                     long entryId,\n+                                     Stopwatch startTimeSw)\n+        throws IOException {\n+        return readEntry(readResponseBuilder, entryId, false, startTimeSw);\n+    }\n \n-        if (LOG.isDebugEnabled()) {\n-            LOG.debug(\"Received new read request: {}\", request);\n+    /**\n+     * Read a specific entry.\n+     *\n+     * @param readResponseBuilder\n+     *          read response builder.\n+     * @param entryId\n+     *          entry to read\n+     * @param startTimeSw\n+     *          stop watch to measure the read operation.\n+     * @return read response or null if it is a fence read operation.\n+     * @throws IOException\n+     */\n+    protected ReadResponse readEntry(ReadResponse.Builder readResponseBuilder,\n+                                     long entryId,\n+                                     boolean readLACPiggyBack,\n+                                     Stopwatch startTimeSw)\n+        throws IOException {\n+        ByteBuf entryBody = requestProcessor.bookie.readEntry(ledgerId, entryId);\n+        if (null != fenceResult) {\n+            handleReadResultForFenceRead(entryBody, readResponseBuilder, entryId, startTimeSw);\n+            return null;\n+        } else {\n+            try {\n+                readResponseBuilder.setBody(ByteString.copyFrom(entryBody.nioBuffer()));\n+                if (readLACPiggyBack) {\n+                    readResponseBuilder.setEntryId(entryId);\n+                } else {\n+                    long knownLAC = requestProcessor.bookie.readLastAddConfirmed(ledgerId);\n+                    readResponseBuilder.setMaxLAC(knownLAC);\n+                }\n+                registerSuccessfulEvent(readStats, startTimeSw);\n+                readResponseBuilder.setStatus(StatusCode.EOK);\n+                return readResponseBuilder.build();\n+            } finally {\n+                ReferenceCountUtil.release(entryBody);\n+            }\n         }\n-        StatusCode status;\n-        ByteBuf entryBody = null;\n-        try {\n-            Future<Boolean> fenceResult = null;\n-            if (readRequest.hasFlag() && readRequest.getFlag().equals(ReadRequest.Flag.FENCE_LEDGER)) {\n-                LOG.warn(\"Ledger fence request received for ledger: {} from address: {}\", ledgerId,\n-                         channel.remoteAddress());\n+    }\n+\n+    protected ReadResponse getReadResponse() {\n+        final Stopwatch startTimeSw = Stopwatch.createStarted();\n \n-                if (readRequest.hasMasterKey()) {\n+        final ReadResponse.Builder readResponse = ReadResponse.newBuilder()\n+            .setLedgerId(ledgerId)\n+            .setEntryId(entryId);\n+        try {\n+            // handle fence reqest\n+            if (RequestUtils.isFenceRequest(readRequest)) {\n+                LOG.info(\"Ledger fence request received for ledger: {} from address: {}\", ledgerId,\n+                    channel.remoteAddress());\n+                if (!readRequest.hasMasterKey()) {\n+                    LOG.error(\n+                        \"Fence ledger request received without master key for ledger:{} from address: {}\",\n+                        ledgerId, channel.remoteAddress());\n+                    throw BookieException.create(BookieException.Code.UnauthorizedAccessException);\n+                } else {\n                     byte[] masterKey = readRequest.getMasterKey().toByteArray();\n                     fenceResult = requestProcessor.bookie.fenceLedger(ledgerId, masterKey);\n-                } else {\n-                    LOG.error(\"Fence ledger request received without master key for ledger:{} from address: {}\",\n-                              ledgerId, channel.remoteAddress());\n-                    throw BookieException.create(BookieException.Code.UnauthorizedAccessException);\n                 }\n             }\n-            entryBody = requestProcessor.bookie.readEntry(ledgerId, entryId);\n-            if (null != fenceResult) {\n-                // TODO:\n-                // currently we don't have readCallback to run in separated read\n-                // threads. after BOOKKEEPER-429 is complete, we could improve\n-                // following code to make it not wait here\n-                //\n-                // For now, since we only try to wait after read entry. so writing\n-                // to journal and read entry are executed in different thread\n-                // it would be fine.\n-                try {\n-                    Boolean fenced = fenceResult.get(1000, TimeUnit.MILLISECONDS);\n-                    if (null == fenced || !fenced) {\n-                        // if failed to fence, fail the read request to make it retry.\n-                        status = StatusCode.EIO;\n-                    } else {\n-                        status = StatusCode.EOK;\n-                        readResponse.setBody(ByteString.copyFrom(entryBody.nioBuffer()));\n-                    }\n-                } catch (InterruptedException ie) {\n-                    LOG.error(\"Interrupting fence read entry (lid: {}, eid: {})\",\n-                              new Object[] { ledgerId, entryId, ie });\n-                    status = StatusCode.EIO;\n-                } catch (ExecutionException ee) {\n-                    LOG.error(\"Failed to fence read entry (lid: {}, eid: {})\",\n-                              new Object[] { ledgerId, entryId, ee });\n-                    status = StatusCode.EIO;\n-                } catch (TimeoutException te) {\n-                    LOG.error(\"Timeout to fence read entry (lid: {}, eid: {})\",\n-                              new Object[] { ledgerId, entryId, te });\n-                    status = StatusCode.EIO;\n-                }\n+            return readEntry(readResponse, entryId, startTimeSw);\n+        } catch (Bookie.NoLedgerException e) {\n+            if (RequestUtils.isFenceRequest(readRequest)) {\n+                LOG.info(\"No ledger found reading entry {} when fencing ledger {}\", entryId, ledgerId);\n             } else {\n-                readResponse.setBody(ByteString.copyFrom(entryBody.nioBuffer()));\n-                status = StatusCode.EOK;\n+                LOG.info(\"No ledger found while reading entry: {} from ledger: {}\", entryId, ledgerId);\n             }\n-        } catch (Bookie.NoLedgerException e) {\n-            status = StatusCode.ENOLEDGER;\n-            LOG.error(\"No ledger found while reading entry:{} from ledger: {}\", entryId, ledgerId);\n+            return buildResponse(readResponse, StatusCode.ENOLEDGER, startTimeSw);\n         } catch (Bookie.NoEntryException e) {\n-            status = StatusCode.ENOENTRY;\n             if (LOG.isDebugEnabled()) {\n-                LOG.debug(\"No entry found while reading entry:{} from ledger:{}\", entryId, ledgerId);\n+                LOG.debug(\"No entry found while reading entry: {} from ledger: {}\", entryId, ledgerId);\n             }\n+            return buildResponse(readResponse, StatusCode.ENOENTRY, startTimeSw);\n         } catch (IOException e) {\n-            status = StatusCode.EIO;\n-            LOG.error(\"IOException while reading entry:{} from ledger:{}\", entryId, ledgerId);\n+            LOG.error(\"IOException while reading entry: {} from ledger {} \", new Object[] { entryId, ledgerId, e });\n+            return buildResponse(readResponse, StatusCode.EIO, startTimeSw);\n         } catch (BookieException e) {\n-            LOG.error(\"Unauthorized access to ledger:{} while reading entry:{} in request from address: {}\",\n-                    new Object[]{ledgerId, entryId, channel.remoteAddress()});\n-            status = StatusCode.EUA;\n+            LOG.error(\n+                \"Unauthorized access to ledger:{} while reading entry:{} in request from address: {}\",\n+                new Object[] { ledgerId, entryId, channel.remoteAddress() });\n+            return buildResponse(readResponse, StatusCode.EUA, startTimeSw);\n         }\n+    }\n+\n+    @Override\n+    public void safeRun() {\n+        requestProcessor.readEntrySchedulingDelayStats.registerSuccessfulEvent(\n+            MathUtils.elapsedNanos(enqueueNanos), TimeUnit.NANOSECONDS);\n+\n+        if (!isVersionCompatible()) {\n+            ReadResponse readResponse = ReadResponse.newBuilder()\n+                .setLedgerId(ledgerId)\n+                .setEntryId(entryId)\n+                .setStatus(StatusCode.EBADVERSION)\n+                .build();\n+            sendResponse(readResponse);\n+            return;\n+        }\n+\n+        executeOp();\n+    }\n+\n+    protected void executeOp() {\n+        ReadResponse readResponse = getReadResponse();\n+        if (null != readResponse) {\n+            sendResponse(readResponse);\n+        }\n+    }\n \n-        if (status == StatusCode.EOK) {\n-            requestProcessor.readEntryStats.registerSuccessfulEvent(MathUtils.elapsedNanos(startTimeNanos),\n-                    TimeUnit.NANOSECONDS);\n+    private void getFenceResponse(ReadResponse.Builder readResponse,\n+                                  ByteBuf entryBody,\n+                                  boolean fenceResult) {\n+        StatusCode status;\n+        if (!fenceResult) {\n+            status = StatusCode.EIO;\n+            registerFailedEvent(requestProcessor.fenceReadWaitStats, lastPhaseStartTime);\n         } else {\n-            requestProcessor.readEntryStats.registerFailedEvent(MathUtils.elapsedNanos(startTimeNanos),\n-                    TimeUnit.NANOSECONDS);\n+            status = StatusCode.EOK;\n+            readResponse.setBody(ByteString.copyFrom(entryBody.nioBuffer()));\n+            registerSuccessfulEvent(requestProcessor.fenceReadWaitStats, lastPhaseStartTime);\n         }\n \n-        ReferenceCountUtil.release(entryBody);\n+        if (null != entryBody) {\n+            ReferenceCountUtil.release(entryBody);\n+        }\n \n-        // Finally set status and return. The body would have been updated if\n-        // a read went through.\n         readResponse.setStatus(status);\n-        return readResponse.build();\n     }\n \n-    @Override\n-    public void safeRun() {\n-        ReadResponse readResponse = getReadResponse();\n-        sendResponse(readResponse);\n+    private void sendFenceResponse(ReadResponse.Builder readResponse,\n+                                   ByteBuf entryBody,\n+                                   boolean fenceResult,\n+                                   Stopwatch startTimeSw) {\n+        // build the fence read response\n+        getFenceResponse(readResponse, entryBody, fenceResult);\n+        // register fence read stat\n+        registerEvent(!fenceResult, requestProcessor.fenceReadEntryStats, startTimeSw);\n+        // send the fence read response\n+        sendResponse(readResponse.build());\n+    }\n+\n+    protected ReadResponse buildResponse(\n+            ReadResponse.Builder readResponseBuilder,\n+            StatusCode statusCode,\n+            Stopwatch startTimeSw) {\n+        registerEvent(!statusCode.equals(StatusCode.EOK), readStats, startTimeSw);\n+        readResponseBuilder.setStatus(statusCode);\n+        return readResponseBuilder.build();\n     }\n \n-    private void sendResponse(ReadResponse readResponse) {\n+    protected void sendResponse(ReadResponse readResponse) {\n         Response.Builder response = Response.newBuilder()\n                 .setHeader(getHeader())\n                 .setStatus(readResponse.getStatus())\n                 .setReadResponse(readResponse);\n         sendResponse(response.getStatus(),\n                      response.build(),\n-                     requestProcessor.readRequestStats);\n+                     reqStats);\n+    }\n+\n+    //\n+    // Stats Methods\n+    //\n+\n+    protected void registerSuccessfulEvent(OpStatsLogger statsLogger, Stopwatch startTime) {\n+        registerEvent(false, statsLogger, startTime);\n+    }\n+\n+    protected void registerFailedEvent(OpStatsLogger statsLogger, Stopwatch startTime) {\n+        registerEvent(true, statsLogger, startTime);\n+    }\n+\n+    protected void registerEvent(boolean failed, OpStatsLogger statsLogger, Stopwatch startTime) {\n+        if (failed) {\n+            statsLogger.registerFailedEvent(startTime.elapsed(TimeUnit.NANOSECONDS), TimeUnit.NANOSECONDS);\n+        } else {\n+            statsLogger.registerSuccessfulEvent(startTime.elapsed(TimeUnit.NANOSECONDS), TimeUnit.NANOSECONDS);\n+        }\n     }\n }\n "},{"sha":"01ebead32e7dd2d5d024ce774e1a08e974dd0413","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/ReadLacProcessorV3.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/58b92de8b5feee37f8bc9a99d8c98c2a9d9df383/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FReadLacProcessorV3.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/58b92de8b5feee37f8bc9a99d8c98c2a9d9df383/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FReadLacProcessorV3.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FReadLacProcessorV3.java?ref=58b92de8b5feee37f8bc9a99d8c98c2a9d9df383","patch":"@@ -109,6 +109,6 @@ private void sendResponse(ReadLacResponse readLacResponse) {\n             .setReadLacResponse(readLacResponse);\n         sendResponse(response.getStatus(),\n                 response.build(),\n-                requestProcessor.readRequestStats);\n+                requestProcessor.readLacRequestStats);\n     }\n }"},{"sha":"c735bef262bed301696ad7872519572242284cab","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/RequestUtils.java","status":"added","additions":38,"deletions":0,"changes":38,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/58b92de8b5feee37f8bc9a99d8c98c2a9d9df383/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FRequestUtils.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/58b92de8b5feee37f8bc9a99d8c98c2a9d9df383/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FRequestUtils.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FRequestUtils.java?ref=58b92de8b5feee37f8bc9a99d8c98c2a9d9df383","patch":"@@ -0,0 +1,38 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.bookkeeper.proto;\n+\n+import org.apache.bookkeeper.proto.BookkeeperProtocol.ReadRequest;\n+\n+/**\n+ * Utilities for requests.\n+ */\n+class RequestUtils {\n+\n+    public static boolean isFenceRequest(ReadRequest readRequest) {\n+        return readRequest.hasFlag() && readRequest.getFlag().equals(ReadRequest.Flag.FENCE_LEDGER);\n+    }\n+\n+    public static boolean isLongPollReadRequest(ReadRequest readRequest) {\n+        return !isFenceRequest(readRequest) && readRequest.hasPreviousLAC();\n+    }\n+\n+    public static boolean shouldPiggybackEntry(ReadRequest readRequest) {\n+        return readRequest.hasFlag() && readRequest.getFlag().equals(ReadRequest.Flag.ENTRY_PIGGYBACK);\n+    }\n+}"},{"sha":"d710102925df09ddc29f179cd419a9a8d8cd5cc9","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/WriteLacProcessorV3.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/58b92de8b5feee37f8bc9a99d8c98c2a9d9df383/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FWriteLacProcessorV3.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/58b92de8b5feee37f8bc9a99d8c98c2a9d9df383/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FWriteLacProcessorV3.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FWriteLacProcessorV3.java?ref=58b92de8b5feee37f8bc9a99d8c98c2a9d9df383","patch":"@@ -107,7 +107,7 @@ public void safeRun() {\n                     .setStatus(writeLacResponse.getStatus())\n                     .setWriteLacResponse(writeLacResponse);\n             Response resp = response.build();\n-            sendResponse(writeLacResponse.getStatus(), resp, requestProcessor.writeLacStats);\n+            sendResponse(writeLacResponse.getStatus(), resp, requestProcessor.writeLacRequestStats);\n         }\n     }\n }"}]}