{"sha":"29eb420f1cca07c1a3a7748ed7fbb8a5bc54f2fa","node_id":"MDY6Q29tbWl0NDc4NTkyNTI2OjI5ZWI0MjBmMWNjYTA3YzFhM2E3NzQ4ZWQ3ZmJiOGE1YmM1NGYyZmE=","commit":{"author":{"name":"cguttapalem","email":"cguttapalem@salesforce.com","date":"2017-07-07T03:11:25Z"},"committer":{"name":"cguttapalem","email":"cguttapalem@salesforce.com","date":"2017-07-07T03:11:25Z"},"message":"BOOKKEEPER-1028 and BOOKKEEPER-1029\n\n    BOOKKEEPER-1028: inc/excl opts listunderreplicated\n\n    - Introduce including and excluding BookieId options\n    for listunderreplicatedLedgers\n\n    - But there is limitation that, since replicaslist wont be\n    updated in underreplicatedledger zNode there is possibility\n    of stale information\n\n      ---------------------------------------------------------\n\n    BOOKKEEPER-1029: BookieDecommision Workflow\n\n    - LostBookieRecoveryDelay config param is stored in ZK\n    - if LostBookieRecoveryDelay is reset to same value then it force triggers audit immediately\n    - Added logic to trigger immediately or schedule pending audittask depending on the changed value in ZK\n    - good number of testcases validating focetrigger/reschedluing audittask\n    - added bookieshell command to get/set LostBookieRecoveryDelay from ZK\n    - added bookieshell command to triggeraudit by resetting LostBookieRecoveryDelay\n    - added decommissionbookie bkshell command, which validates the complete replication of ledgers stored in the bookie\n\nAuthor: cguttapalem <cguttapalem@salesforce.com>\nAuthor: Charan Reddy Guttapalem <cguttapalem@salesforce.com>\n\nReviewers: Enrico Olivelli <eolivelli@gmail.com>, Sijie Guo <guosijie@gmail.com>\n\nThis closes #127 from reddycharan/listunderreplicatedpredicate and squashes the following commits:\n\n34bacf3c [cguttapalem] BOOKKEEPER-1029: BookieDecommision Workflow\neb43ec49 [Charan Reddy Guttapalem] BOOKKEEPER-1029: BookieDecommision Workflow\nfcb399df [cguttapalem] BOOKKEEPER-1028: inc/excl opts listunderreplicated","tree":{"sha":"e98151a8e437c09a3c7815f472e7f4add1cfc2a3","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/trees/e98151a8e437c09a3c7815f472e7f4add1cfc2a3"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/commits/29eb420f1cca07c1a3a7748ed7fbb8a5bc54f2fa","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/29eb420f1cca07c1a3a7748ed7fbb8a5bc54f2fa","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/29eb420f1cca07c1a3a7748ed7fbb8a5bc54f2fa","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/29eb420f1cca07c1a3a7748ed7fbb8a5bc54f2fa/comments","author":{"login":"reddycharan","id":13989266,"node_id":"MDQ6VXNlcjEzOTg5MjY2","avatar_url":"https://avatars.githubusercontent.com/u/13989266?v=4","gravatar_id":"","url":"https://api.github.com/users/reddycharan","html_url":"https://github.com/reddycharan","followers_url":"https://api.github.com/users/reddycharan/followers","following_url":"https://api.github.com/users/reddycharan/following{/other_user}","gists_url":"https://api.github.com/users/reddycharan/gists{/gist_id}","starred_url":"https://api.github.com/users/reddycharan/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/reddycharan/subscriptions","organizations_url":"https://api.github.com/users/reddycharan/orgs","repos_url":"https://api.github.com/users/reddycharan/repos","events_url":"https://api.github.com/users/reddycharan/events{/privacy}","received_events_url":"https://api.github.com/users/reddycharan/received_events","type":"User","site_admin":false},"committer":{"login":"reddycharan","id":13989266,"node_id":"MDQ6VXNlcjEzOTg5MjY2","avatar_url":"https://avatars.githubusercontent.com/u/13989266?v=4","gravatar_id":"","url":"https://api.github.com/users/reddycharan","html_url":"https://github.com/reddycharan","followers_url":"https://api.github.com/users/reddycharan/followers","following_url":"https://api.github.com/users/reddycharan/following{/other_user}","gists_url":"https://api.github.com/users/reddycharan/gists{/gist_id}","starred_url":"https://api.github.com/users/reddycharan/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/reddycharan/subscriptions","organizations_url":"https://api.github.com/users/reddycharan/orgs","repos_url":"https://api.github.com/users/reddycharan/repos","events_url":"https://api.github.com/users/reddycharan/events{/privacy}","received_events_url":"https://api.github.com/users/reddycharan/received_events","type":"User","site_admin":false},"parents":[{"sha":"b59d63e8be237e80872f73d92a31b4213d9a649b","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/b59d63e8be237e80872f73d92a31b4213d9a649b","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/b59d63e8be237e80872f73d92a31b4213d9a649b"}],"stats":{"total":1311,"additions":1262,"deletions":49},"files":[{"sha":"58d6ea6891d9e931a65c418d40d04492066df226","filename":"bookkeeper-server/conf/log4j.shell.properties","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/29eb420f1cca07c1a3a7748ed7fbb8a5bc54f2fa/bookkeeper-server%2Fconf%2Flog4j.shell.properties","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/29eb420f1cca07c1a3a7748ed7fbb8a5bc54f2fa/bookkeeper-server%2Fconf%2Flog4j.shell.properties","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fconf%2Flog4j.shell.properties?ref=29eb420f1cca07c1a3a7748ed7fbb8a5bc54f2fa","patch":"@@ -39,3 +39,4 @@ log4j.appender.CONSOLE.layout.ConversionPattern=%d{ABSOLUTE} %-5p %m%n\n log4j.logger.org.apache.zookeeper=ERROR\n log4j.logger.org.apache.bookkeeper=ERROR\n log4j.logger.org.apache.bookkeeper.bookie.BookieShell=INFO\n+log4j.logger.org.apache.bookkeeper.client.BookKeeperAdmin=INFO"},{"sha":"42d4de4d10ffe217574e490581b84ef8c0a2840e","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BookieShell.java","status":"modified","additions":171,"deletions":5,"changes":176,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/29eb420f1cca07c1a3a7748ed7fbb8a5bc54f2fa/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FBookieShell.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/29eb420f1cca07c1a3a7748ed7fbb8a5bc54f2fa/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FBookieShell.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FBookieShell.java?ref=29eb420f1cca07c1a3a7748ed7fbb8a5bc54f2fa","patch":"@@ -44,15 +44,16 @@\n import java.util.List;\n import java.util.Map;\n import java.util.concurrent.TimeUnit;\n+import java.util.function.Predicate;\n \n import org.apache.bookkeeper.bookie.BookieException.InvalidCookieException;\n import org.apache.bookkeeper.bookie.EntryLogger.EntryLogScanner;\n import org.apache.bookkeeper.bookie.Journal.JournalScanner;\n import org.apache.bookkeeper.client.BKException;\n-import org.apache.bookkeeper.client.BookieInfoReader.BookieInfo;\n import org.apache.bookkeeper.client.BookKeeper;\n import org.apache.bookkeeper.client.BookKeeper.DigestType;\n import org.apache.bookkeeper.client.BookKeeperAdmin;\n+import org.apache.bookkeeper.client.BookieInfoReader.BookieInfo;\n import org.apache.bookkeeper.client.LedgerEntry;\n import org.apache.bookkeeper.client.LedgerHandle;\n import org.apache.bookkeeper.client.LedgerMetadata;\n@@ -94,7 +95,6 @@\n import com.google.common.collect.Lists;\n import com.google.common.util.concurrent.AbstractFuture;\n \n-\n /**\n  * Bookie Shell is to provide utilities for users to administer a bookkeeper cluster.\n  */\n@@ -126,6 +126,9 @@ public class BookieShell implements Tool {\n     static final String CMD_UPDATELEDGER = \"updateledgers\";\n     static final String CMD_DELETELEDGER = \"deleteledger\";\n     static final String CMD_BOOKIEINFO = \"bookieinfo\";\n+    static final String CMD_DECOMMISSIONBOOKIE = \"decommissionbookie\";\n+    static final String CMD_LOSTBOOKIERECOVERYDELAY = \"lostbookierecoverydelay\"; \n+    static final String CMD_TRIGGERAUDIT = \"triggeraudit\";\n     static final String CMD_HELP = \"help\";\n \n     final ServerConfiguration bkConf = new ServerConfiguration();\n@@ -498,6 +501,8 @@ class ListUnderreplicatedCmd extends MyCommand {\n \n         public ListUnderreplicatedCmd() {\n             super(CMD_LISTUNDERREPLICATED);\n+            opts.addOption(\"missingreplica\", true, \"Bookie Id of missing replica\");\n+            opts.addOption(\"excludingmissingreplica\", true, \"Bookie Id of missing replica to ignore\");\n         }\n \n         @Override\n@@ -507,16 +512,30 @@ Options getOptions() {\n \n         @Override\n         String getDescription() {\n-            return \"List ledgers marked as underreplicated\";\n+            return \"List ledgers marked as underreplicated, with optional options to specify missingreplica (BookieId) and to exclude missingreplica\";\n         }\n \n         @Override\n         String getUsage() {\n-            return \"listunderreplicated\";\n+            return \"listunderreplicated [[-missingreplica <bookieaddress>] [-excludingmissingreplica <bookieaddress>]]\";\n         }\n \n         @Override\n         int runCmd(CommandLine cmdLine) throws Exception {\n+\n+            final String includingBookieId = cmdLine.getOptionValue(\"missingreplica\");\n+            final String excludingBookieId = cmdLine.getOptionValue(\"excludingmissingreplica\");\n+\n+            Predicate<List<String>> predicate = null;\n+            if (!StringUtils.isBlank(includingBookieId) && !StringUtils.isBlank(excludingBookieId)) {\n+                predicate = replicasList -> (replicasList.contains(includingBookieId)\n+                        && !replicasList.contains(excludingBookieId));\n+            } else if (!StringUtils.isBlank(includingBookieId)) {\n+                predicate = replicasList -> replicasList.contains(includingBookieId);\n+            } else if (!StringUtils.isBlank(excludingBookieId)) {\n+                predicate = replicasList -> !replicasList.contains(excludingBookieId);\n+            }\n+\n             ZooKeeper zk = null;\n             try {\n                 zk = ZooKeeperClient.newBuilder()\n@@ -525,7 +544,7 @@ int runCmd(CommandLine cmdLine) throws Exception {\n                         .build();\n                 LedgerManagerFactory mFactory = LedgerManagerFactory.newLedgerManagerFactory(bkConf, zk);\n                 LedgerUnderreplicationManager underreplicationManager = mFactory.newLedgerUnderreplicationManager();\n-                Iterator<Long> iter = underreplicationManager.listLedgersToRereplicate();\n+                Iterator<Long> iter = underreplicationManager.listLedgersToRereplicate(predicate);\n                 while (iter.hasNext()) {\n                     System.out.println(iter.next());\n                 }\n@@ -1326,6 +1345,65 @@ int runCmd(CommandLine cmdLine) throws Exception {\n         }\n     }\n \n+    /**\n+     * Setter and Getter for LostBookieRecoveryDelay value (in seconds) in Zookeeper\n+     */\n+    class LostBookieRecoveryDelayCmd extends MyCommand {\n+        Options opts = new Options();\n+\n+        public LostBookieRecoveryDelayCmd() {\n+            super(CMD_LOSTBOOKIERECOVERYDELAY);\n+            opts.addOption(\"g\", \"get\", false, \"Get LostBookieRecoveryDelay value (in seconds)\");\n+            opts.addOption(\"s\", \"set\", true, \"Set LostBookieRecoveryDelay value (in seconds)\");\n+        }\n+\n+        @Override\n+        Options getOptions() {\n+            return opts;\n+        }\n+\n+        @Override\n+        String getDescription() {\n+            return \"Setter and Getter for LostBookieRecoveryDelay value (in seconds) in Zookeeper\";\n+        }\n+\n+        @Override\n+        String getUsage() {\n+            return \"lostbookierecoverydelay [-get|-set <value>]\";\n+        }\n+\n+        @Override\n+        int runCmd(CommandLine cmdLine) throws Exception {\n+            boolean getter = cmdLine.hasOption(\"g\");\n+            boolean setter = cmdLine.hasOption(\"s\");\n+\n+            if ((!getter && !setter) || (getter && setter)) {\n+                LOG.error(\"One and only one of -get and -set must be specified\");\n+                printUsage();\n+                return 1;\n+            }\n+            ClientConfiguration adminConf = new ClientConfiguration(bkConf);\n+            BookKeeperAdmin admin = new BookKeeperAdmin(adminConf);\n+            try {\n+                if (getter) {\n+                    int lostBookieRecoveryDelay = admin.getLostBookieRecoveryDelay();\n+                    LOG.info(\"LostBookieRecoveryDelay value in ZK: {}\", String.valueOf(lostBookieRecoveryDelay));\n+                } else {\n+                    int lostBookieRecoveryDelay = Integer.parseInt(cmdLine.getOptionValue(\"set\"));\n+                    admin.setLostBookieRecoveryDelay(lostBookieRecoveryDelay);\n+                    LOG.info(\"Successfully set LostBookieRecoveryDelay value in ZK: {}\",\n+                            String.valueOf(lostBookieRecoveryDelay));\n+                }\n+            } finally {\n+                if (admin != null) {\n+                    admin.close();\n+                }\n+            }\n+            return 0;\n+        }\n+    }\n+    \n+    \n     /**\n      * Print which node has the auditor lock\n      */\n@@ -1824,6 +1902,91 @@ public int runCmd(CommandLine cmdLine) throws Exception {\n         }\n     }\n \n+    /**\n+     * Command to trigger AuditTask by resetting lostBookieRecoveryDelay to its current value\n+     */\n+    class TriggerAuditCmd extends MyCommand {\n+        Options opts = new Options();\n+\n+        TriggerAuditCmd() {\n+            super(CMD_TRIGGERAUDIT);\n+        }\n+\n+        @Override\n+        String getDescription() {\n+            return \"Force trigger the Audit by resetting the lostBookieRecoveryDelay\";\n+        }\n+\n+        @Override\n+        String getUsage() {\n+            return CMD_TRIGGERAUDIT;\n+        }\n+\n+        @Override\n+        Options getOptions() {\n+            return opts;\n+        }\n+\n+        @Override\n+        public int runCmd(CommandLine cmdLine) throws Exception {\n+            ClientConfiguration adminConf = new ClientConfiguration(bkConf);\n+            BookKeeperAdmin admin = new BookKeeperAdmin(adminConf);\n+            try {\n+                admin.triggerAudit();\n+            } finally {\n+                if (admin != null) {\n+                    admin.close();\n+                }\n+            }\n+            return 0;\n+        }\n+    }\n+    \n+    /**\n+     * Command to trigger AuditTask by resetting lostBookieRecoveryDelay and then make sure the \n+     * ledgers stored in the bookie are properly replicated.\n+     */\n+    class DecommissionBookieCmd extends MyCommand {\n+        Options lOpts = new Options();\n+        \n+        DecommissionBookieCmd() {\n+            super(CMD_DECOMMISSIONBOOKIE);\n+        }\n+\n+        @Override\n+        String getDescription() {\n+            return \"Force trigger the Audittask and make sure all the ledgers stored in the decommissioning bookie are replicated\";\n+        }\n+\n+        @Override\n+        String getUsage() {\n+            return CMD_DECOMMISSIONBOOKIE;\n+        }\n+\n+        @Override\n+        Options getOptions() {\n+            return lOpts;\n+        }\n+\n+        @Override\n+        public int runCmd(CommandLine cmdLine) throws Exception {\n+            ClientConfiguration adminConf = new ClientConfiguration(bkConf);\n+            BookKeeperAdmin admin = new BookKeeperAdmin(adminConf);\n+            try {\n+                BookieSocketAddress thisBookieAddress = Bookie.getBookieAddress(bkConf);\n+                admin.decommissionBookie(thisBookieAddress);\n+                return 0;\n+            } catch (Exception e) {\n+                LOG.error(\"Received exception in DecommissionBookieCmd \", e);\n+                return -1;\n+            } finally {\n+                if (admin != null) {\n+                    admin.close();\n+                }\n+            }\n+        }\n+    }\n+    \n     /**\n      * A facility for reporting update ledger progress.\n      */\n@@ -1855,7 +2018,10 @@ public interface UpdateLedgerNotifier {\n         commands.put(CMD_UPDATELEDGER, new UpdateLedgerCmd());\n         commands.put(CMD_DELETELEDGER, new DeleteLedgerCmd());\n         commands.put(CMD_BOOKIEINFO, new BookieInfoCmd());\n+        commands.put(CMD_DECOMMISSIONBOOKIE, new DecommissionBookieCmd());\n         commands.put(CMD_HELP, new HelpCmd());\n+        commands.put(CMD_LOSTBOOKIERECOVERYDELAY, new LostBookieRecoveryDelayCmd());  \n+        commands.put(CMD_TRIGGERAUDIT, new TriggerAuditCmd());\n     }\n \n     @Override"},{"sha":"8cf8833e486d0546f7adf04b1726348cb97750fa","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeperAdmin.java","status":"modified","additions":309,"deletions":0,"changes":309,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/29eb420f1cca07c1a3a7748ed7fbb8a5bc54f2fa/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookKeeperAdmin.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/29eb420f1cca07c1a3a7748ed7fbb8a5bc54f2fa/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookKeeperAdmin.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookKeeperAdmin.java?ref=29eb420f1cca07c1a3a7748ed7fbb8a5bc54f2fa","patch":"@@ -35,19 +35,35 @@\n import java.util.Map;\n import java.util.NoSuchElementException;\n import java.util.Random;\n+import java.util.Set;\n import java.util.UUID;\n+import java.util.Map.Entry;\n import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Predicate;\n \n+import org.apache.bookkeeper.bookie.Bookie;\n import org.apache.bookkeeper.client.AsyncCallback.OpenCallback;\n import org.apache.bookkeeper.client.AsyncCallback.RecoverCallback;\n import org.apache.bookkeeper.client.BookKeeper.SyncOpenCallback;\n import org.apache.bookkeeper.client.LedgerFragmentReplicator.SingleFragmentCallback;\n import org.apache.bookkeeper.conf.ClientConfiguration;\n+import org.apache.bookkeeper.conf.ServerConfiguration;\n import org.apache.bookkeeper.meta.LedgerManager.LedgerRangeIterator;\n+import org.apache.bookkeeper.meta.LedgerManager;\n+import org.apache.bookkeeper.meta.LedgerManagerFactory;\n+import org.apache.bookkeeper.meta.LedgerUnderreplicationManager;\n import org.apache.bookkeeper.meta.ZkLedgerUnderreplicationManager;\n import org.apache.bookkeeper.net.BookieSocketAddress;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.MultiCallback;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.Processor;\n+import org.apache.bookkeeper.replication.AuditorElector;\n+import org.apache.bookkeeper.replication.BookieLedgerIndexer;\n+import org.apache.bookkeeper.replication.ReplicationException.BKAuditException;\n+import org.apache.bookkeeper.replication.ReplicationException.CompatibilityException;\n+import org.apache.bookkeeper.replication.ReplicationException.UnavailableException;\n import org.apache.bookkeeper.util.BookKeeperConstants;\n import org.apache.bookkeeper.util.IOUtils;\n import org.apache.bookkeeper.zookeeper.ZooKeeperClient;\n@@ -64,6 +80,8 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import com.google.common.util.concurrent.AbstractFuture;\n+\n /**\n  * Admin client for BookKeeper clusters\n  */\n@@ -89,6 +107,14 @@ public class BookKeeperAdmin implements AutoCloseable {\n      */\n     private Random rand = new Random();\n \n+    private LedgerManagerFactory mFactory;\n+\n+    /*\n+     * underreplicationManager is not initialized as part of constructor use its\n+     * getter (getUnderreplicationManager) so that it can be lazy-initialized\n+     */\n+    private LedgerUnderreplicationManager underreplicationManager;\n+    \n     /**\n      * Constructor that takes in a ZooKeeper servers connect string so we know\n      * how to connect to ZooKeeper to retrieve information about the BookKeeper\n@@ -144,6 +170,7 @@ public BookKeeperAdmin(ClientConfiguration conf) throws IOException, Interrupted\n         bkc = new BookKeeper(conf, zk);\n         ownsBK = true;\n         this.lfr = new LedgerFragmentReplicator(bkc, NullStatsLogger.INSTANCE);\n+        this.mFactory = bkc.ledgerManagerFactory;\n     }\n \n     /**\n@@ -162,6 +189,7 @@ public BookKeeperAdmin(final BookKeeper bkc, StatsLogger statsLogger) {\n         ownsZK = false;\n         this.bookiesPath = bkc.getConf().getZkAvailableBookiesPath();\n         this.lfr = new LedgerFragmentReplicator(bkc, statsLogger);\n+        this.mFactory = bkc.ledgerManagerFactory;\n     }\n \n     public BookKeeperAdmin(final BookKeeper bkc) {\n@@ -1064,4 +1092,285 @@ public void remove()\n     public LedgerMetadata getLedgerMetadata(LedgerHandle lh) {\n         return lh.getLedgerMetadata();\n     }\n+    \n+    private LedgerUnderreplicationManager getUnderreplicationManager()\n+            throws CompatibilityException, KeeperException, InterruptedException {\n+        if (underreplicationManager == null) {\n+            underreplicationManager = mFactory.newLedgerUnderreplicationManager();\n+        }\n+        return underreplicationManager;\n+    }\n+\n+    /**\n+     * Setter for LostBookieRecoveryDelay value (in seconds) in Zookeeper\n+     * \n+     * @param lostBookieRecoveryDelay\n+     *                              lostBookieRecoveryDelay value (in seconds) to set \n+     * @throws CompatibilityException\n+     * @throws KeeperException\n+     * @throws InterruptedException\n+     * @throws UnavailableException\n+     */\n+    public void setLostBookieRecoveryDelay(int lostBookieRecoveryDelay)\n+            throws CompatibilityException, KeeperException, InterruptedException, UnavailableException {\n+        LedgerUnderreplicationManager urlManager = getUnderreplicationManager();\n+        urlManager.setLostBookieRecoveryDelay(lostBookieRecoveryDelay);\n+    }\n+\n+    /**\n+     * returns the current LostBookieRecoveryDelay value (in seconds) in Zookeeper\n+     * \n+     * @return\n+     *          current lostBookieRecoveryDelay value (in seconds)\n+     * @throws CompatibilityException\n+     * @throws KeeperException\n+     * @throws InterruptedException\n+     * @throws UnavailableException\n+     */\n+    public int getLostBookieRecoveryDelay()\n+            throws CompatibilityException, KeeperException, InterruptedException, UnavailableException {\n+        LedgerUnderreplicationManager urlManager = getUnderreplicationManager();\n+        return urlManager.getLostBookieRecoveryDelay();\n+    }\n+\n+    /**\n+     * trigger AuditTask by resetting lostBookieRecoveryDelay to its current\n+     * value. If Autorecovery is not enabled or if there is no Auditor then this\n+     * method will throw UnavailableException.\n+     * \n+     * @throws CompatibilityException\n+     * @throws KeeperException\n+     * @throws InterruptedException\n+     * @throws UnavailableException\n+     * @throws IOException\n+     */\n+    public void triggerAudit()\n+            throws CompatibilityException, KeeperException, InterruptedException, UnavailableException, IOException {\n+        LedgerUnderreplicationManager urlManager = getUnderreplicationManager();\n+        if (!urlManager.isLedgerReplicationEnabled()) {\n+            LOG.error(\"Autorecovery is disabled. So giving up!\");\n+            throw new UnavailableException(\"Autorecovery is disabled. So giving up!\");\n+        }\n+        \n+        BookieSocketAddress auditorId = AuditorElector.getCurrentAuditor(new ServerConfiguration(bkc.conf), zk);\n+        if (auditorId == null) {\n+            LOG.error(\"No auditor elected, though Autorecovery is enabled. So giving up.\");\n+            throw new UnavailableException(\"No auditor elected, though Autorecovery is enabled. So giving up.\");\n+        }\n+\n+        int previousLostBookieRecoveryDelayValue = urlManager.getLostBookieRecoveryDelay();\n+        LOG.info(\"Resetting LostBookieRecoveryDelay value: {}, to kickstart audit task\",\n+                previousLostBookieRecoveryDelayValue);\n+        urlManager.setLostBookieRecoveryDelay(previousLostBookieRecoveryDelayValue);\n+    }\n+    \n+    /**\n+     * Triggers AuditTask by resetting lostBookieRecoveryDelay and then make\n+     * sure the ledgers stored in the given decommissioning bookie are properly\n+     * replicated and they are not underreplicated because of the given bookie.\n+     * This method waits untill there are no underreplicatedledgers because of this \n+     * bookie. If the given Bookie is not shutdown yet, then it will throw \n+     * BKIllegalOpException.\n+     * \n+     * @param bookieAddress\n+     *            address of the decommissioning bookie\n+     * @throws CompatibilityException\n+     * @throws UnavailableException\n+     * @throws KeeperException\n+     * @throws InterruptedException\n+     * @throws IOException\n+     * @throws BKAuditException\n+     * @throws TimeoutException\n+     * @throws BKException \n+     */\n+    public void decommissionBookie(BookieSocketAddress bookieAddress)\n+            throws CompatibilityException, UnavailableException, KeeperException, InterruptedException, IOException,\n+            BKAuditException, TimeoutException, BKException {\n+        if (getAvailableBookies().contains(bookieAddress) || getReadOnlyBookies().contains(bookieAddress)) {\n+            LOG.error(\"Bookie: {} is not shutdown yet\", bookieAddress);\n+            throw BKException.create(BKException.Code.IllegalOpException);\n+        }\n+        \n+        triggerAudit();\n+\n+        /*\n+         * Sleep for 30 secs, so that Auditor gets chance to trigger its\n+         * force audittask and let the underreplicationmanager process\n+         * to do its replication process\n+         */\n+        Thread.sleep(30 * 1000);\n+        \n+        /*\n+         * get the collection of the ledgers which are stored in this\n+         * bookie, by making a call to\n+         * bookieLedgerIndexer.getBookieToLedgerIndex.\n+         */\n+        \n+        BookieLedgerIndexer bookieLedgerIndexer = new BookieLedgerIndexer(bkc.ledgerManager);\n+        Map<String, Set<Long>> bookieToLedgersMap = bookieLedgerIndexer.getBookieToLedgerIndex();\n+        Set<Long> ledgersStoredInThisBookie = bookieToLedgersMap.get(bookieAddress.toString());\n+        if ((ledgersStoredInThisBookie != null) && (!ledgersStoredInThisBookie.isEmpty())) {\n+            /*\n+             * wait untill all the ledgers are replicated to other\n+             * bookies by making sure that these ledgers metadata don't\n+             * contain this bookie as part of their ensemble.\n+             */\n+            waitForLedgersToBeReplicated(ledgersStoredInThisBookie, bookieAddress, bkc.ledgerManager);\n+        }\n+\n+        // for double-checking, check if any ledgers are listed as underreplicated because of this bookie\n+        Predicate<List<String>> predicate = replicasList -> replicasList.contains(bookieAddress.toString());\n+        Iterator<Long> urLedgerIterator = underreplicationManager.listLedgersToRereplicate(predicate);\n+        if (urLedgerIterator.hasNext()) {\n+            //if there are any then wait and make sure those ledgers are replicated properly\n+            LOG.info(\"Still in some underreplicated ledgers metadata, this bookie is part of its ensemble. \"\n+                    + \"Have to make sure that those ledger fragments are rereplicated\");\n+            List<Long> urLedgers = new ArrayList<>();\n+            urLedgerIterator.forEachRemaining(urLedgers::add);\n+            waitForLedgersToBeReplicated(urLedgers, bookieAddress, bkc.ledgerManager);\n+        }\n+    }\n+\n+    private void waitForLedgersToBeReplicated(Collection<Long> ledgers, BookieSocketAddress thisBookieAddress,\n+            LedgerManager ledgerManager) throws InterruptedException, TimeoutException {\n+        int maxSleepTimeInBetweenChecks = 10 * 60 * 1000; // 10 minutes\n+        int sleepTimePerLedger = 10 * 1000; // 10 secs\n+        Predicate<Long> validateBookieIsNotPartOfEnsemble = ledgerId -> !areEntriesOfLedgerStoredInTheBookie(ledgerId,\n+                thisBookieAddress, ledgerManager);\n+        while (!ledgers.isEmpty()) {\n+            LOG.info(\"Count of Ledgers which need to be rereplicated: {}\", ledgers.size());\n+            int sleepTimeForThisCheck = ledgers.size() * sleepTimePerLedger > maxSleepTimeInBetweenChecks\n+                    ? maxSleepTimeInBetweenChecks : ledgers.size() * sleepTimePerLedger;\n+            Thread.sleep(sleepTimeForThisCheck);\n+            LOG.debug(\"Making sure following ledgers replication to be completed: {}\", ledgers);\n+            ledgers.removeIf(validateBookieIsNotPartOfEnsemble);\n+        }\n+    }\n+\n+    private boolean areEntriesOfLedgerStoredInTheBookie(long ledgerId, BookieSocketAddress bookieAddress,\n+            LedgerManager ledgerManager) {\n+        ReadMetadataCallback cb = new ReadMetadataCallback(ledgerId);\n+        ledgerManager.readLedgerMetadata(ledgerId, cb);\n+        try {\n+            LedgerMetadata ledgerMetadata = cb.get();\n+            Collection<ArrayList<BookieSocketAddress>> ensemblesOfSegments = ledgerMetadata.getEnsembles().values();\n+            Iterator<ArrayList<BookieSocketAddress>> ensemblesOfSegmentsIterator = ensemblesOfSegments.iterator();\n+            ArrayList<BookieSocketAddress> ensemble;\n+            int segmentNo = 0;\n+            while (ensemblesOfSegmentsIterator.hasNext()) {\n+                ensemble = ensemblesOfSegmentsIterator.next();\n+                if (ensemble.contains(bookieAddress)) {\n+                    if (areEntriesOfSegmentStoredInTheBookie(ledgerMetadata, bookieAddress, segmentNo++)) {\n+                        return true;\n+                    }\n+                }\n+            }\n+            return false;\n+        } catch (InterruptedException | ExecutionException e) {\n+            if (e.getCause() != null\n+                    && e.getCause().getClass().equals(BKException.BKNoSuchLedgerExistsException.class)) {\n+                LOG.debug(\"Ledger: {} has been deleted\", ledgerId);\n+                return false;\n+            } else {\n+                LOG.error(\"Got exception while trying to read LedgerMeatadata of \" + ledgerId, e);\n+                throw new RuntimeException(e);\n+            }\n+        }\n+    }\n+\n+    private boolean areEntriesOfSegmentStoredInTheBookie(LedgerMetadata ledgerMetadata,\n+            BookieSocketAddress bookieAddress, int segmentNo) {\n+        boolean isLedgerClosed = ledgerMetadata.isClosed();\n+        int ensembleSize = ledgerMetadata.getEnsembleSize();\n+        int writeQuorumSize = ledgerMetadata.getWriteQuorumSize();\n+\n+        List<Entry<Long, ArrayList<BookieSocketAddress>>> segments = new LinkedList<Entry<Long, ArrayList<BookieSocketAddress>>>(\n+                ledgerMetadata.getEnsembles().entrySet());\n+\n+        boolean lastSegment = (segmentNo == (segments.size() - 1));\n+        \n+        /*\n+         * Checking the last segment of the ledger can be complicated in\n+         * some cases. In the case that the ledger is closed, we can just\n+         * check the fragments of the segment as normal, except in the case\n+         * that no entry was ever written, to the ledger, in which case we\n+         * check no fragments.\n+         * \n+         * Following the same approach as in LedgerChecker.checkLedger\n+         */\n+        if (lastSegment && isLedgerClosed && (ledgerMetadata.getLastEntryId() < segments.get(segmentNo).getKey())) {\n+            return false;\n+        }\n+\n+        /*\n+         * if ensembleSize is equal to writeQuorumSize, then ofcourse all\n+         * the entries of this segment are supposed to be stored in this\n+         * bookie. If this is last segment of the ledger and if the ledger\n+         * is not closed (this is a corner case), then we have to return\n+         * true. For more info. Check BOOKKEEPER-237 and BOOKKEEPER-325.\n+         */\n+        if ((lastSegment && !isLedgerClosed) || (ensembleSize == writeQuorumSize)) {\n+            return true;\n+        }\n+\n+        /*\n+         * the following check is required because ensembleSize can be\n+         * greater than writeQuorumSize and in this case if there are only\n+         * couple of entries then based on RoundRobinDistributionSchedule\n+         * there might not be any entry copy in this bookie though this\n+         * bookie is part of the ensemble of this segment. If no entry is\n+         * stored in this bookie then we should return false, because\n+         * ReplicationWorker wont take care of fixing the ledgerMetadata of\n+         * this segment in this case.\n+         * \n+         * if ensembleSize > writeQuorumSize, then in LedgerFragment.java\n+         * firstEntryID may not be equal to firstStoredEntryId lastEntryId\n+         * may not be equalto lastStoredEntryId. firstStoredEntryId and\n+         * lastStoredEntryId will be LedgerHandle.INVALID_ENTRY_ID, if no\n+         * entry of this segment stored in this bookie. In this case\n+         * LedgerChecker.verifyLedgerFragment will not consider it as\n+         * unavailable/bad fragment though this bookie is part of the\n+         * ensemble of the segment and it is down.\n+         */\n+        DistributionSchedule distributionSchedule = new RoundRobinDistributionSchedule(\n+                ledgerMetadata.getWriteQuorumSize(), ledgerMetadata.getAckQuorumSize(),\n+                ledgerMetadata.getEnsembleSize());\n+        ArrayList<BookieSocketAddress> currentSegmentEnsemble = segments.get(segmentNo).getValue();\n+        int thisBookieIndexInCurrentEnsemble = currentSegmentEnsemble.indexOf(bookieAddress);\n+        long firstEntryId = segments.get(segmentNo).getKey();\n+        long lastEntryId = lastSegment ? ledgerMetadata.getLastEntryId() : segments.get(segmentNo + 1).getKey() - 1;\n+        long firstStoredEntryId = LedgerHandle.INVALID_ENTRY_ID;\n+        long firstEntryIter = firstEntryId;\n+        // following the same approach followed in LedgerFragment.getFirstStoredEntryId()\n+        for (int i = 0; i < ensembleSize && firstEntryIter <= lastEntryId; i++) {\n+            if (distributionSchedule.hasEntry(firstEntryIter, thisBookieIndexInCurrentEnsemble)) {\n+                firstStoredEntryId = firstEntryIter;\n+                break;\n+            } else {\n+                firstEntryIter++;\n+            }\n+        }\n+        return firstStoredEntryId != LedgerHandle.INVALID_ENTRY_ID;\n+    }\n+\n+    static class ReadMetadataCallback extends AbstractFuture<LedgerMetadata>\n+            implements GenericCallback<LedgerMetadata> {\n+        final long ledgerId;\n+\n+        ReadMetadataCallback(long ledgerId) {\n+            this.ledgerId = ledgerId;\n+        }\n+\n+        long getLedgerId() {\n+            return ledgerId;\n+        }\n+\n+        public void operationComplete(int rc, LedgerMetadata result) {\n+            if (rc != 0) {\n+                setException(BKException.create(rc));\n+            } else {\n+                set(result);\n+            }\n+        }\n+    }\n }"},{"sha":"7f5813143f8fb2afa6d07d7e6149ebd42f0fdcc9","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerChecker.java","status":"modified","additions":5,"deletions":0,"changes":5,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/29eb420f1cca07c1a3a7748ed7fbb8a5bc54f2fa/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FLedgerChecker.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/29eb420f1cca07c1a3a7748ed7fbb8a5bc54f2fa/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FLedgerChecker.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FLedgerChecker.java?ref=29eb420f1cca07c1a3a7748ed7fbb8a5bc54f2fa","patch":"@@ -88,6 +88,11 @@ private void verifyLedgerFragment(LedgerFragment fragment,\n         long firstStored = fragment.getFirstStoredEntryId();\n         long lastStored = fragment.getLastStoredEntryId();\n \n+        // because of this if block, even if the bookie of the fragment is \n+        // down, it considers Fragment is available/not-bad if firstStored\n+        // and lastStored are LedgerHandle.INVALID_ENTRY_ID.\n+        // So same logic is used in BookieShell.DecommissionBookieCmd.areEntriesOfSegmentStoredInTheBookie\n+        // if any change is made here, then the changes should be in BookieShell also\n         if (firstStored == LedgerHandle.INVALID_ENTRY_ID) {\n             if (lastStored != LedgerHandle.INVALID_ENTRY_ID) {\n                 throw new InvalidFragmentException();"},{"sha":"92fc63e741386ab207a88ca3e1bb925436eaf544","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerMetadata.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/29eb420f1cca07c1a3a7748ed7fbb8a5bc54f2fa/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FLedgerMetadata.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/29eb420f1cca07c1a3a7748ed7fbb8a5bc54f2fa/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FLedgerMetadata.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FLedgerMetadata.java?ref=29eb420f1cca07c1a3a7748ed7fbb8a5bc54f2fa","patch":"@@ -241,7 +241,7 @@ void close(long entryId) {\n         state = LedgerMetadataFormat.State.CLOSED;\n     }\n \n-    void addEnsemble(long startEntryId, ArrayList<BookieSocketAddress> ensemble) {\n+    public void addEnsemble(long startEntryId, ArrayList<BookieSocketAddress> ensemble) {\n         assert ensembles.isEmpty() || startEntryId >= ensembles.lastKey();\n \n         ensembles.put(startEntryId, ensemble);"},{"sha":"014c1a803ff84ad9bfdc516406d350fe6f3d9061","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/LedgerUnderreplicationManager.java","status":"modified","additions":49,"deletions":3,"changes":52,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/29eb420f1cca07c1a3a7748ed7fbb8a5bc54f2fa/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FLedgerUnderreplicationManager.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/29eb420f1cca07c1a3a7748ed7fbb8a5bc54f2fa/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FLedgerUnderreplicationManager.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FLedgerUnderreplicationManager.java?ref=29eb420f1cca07c1a3a7748ed7fbb8a5bc54f2fa","patch":"@@ -21,6 +21,8 @@\n import org.apache.bookkeeper.replication.ReplicationException;\n \n import java.util.Iterator;\n+import java.util.List;\n+import java.util.function.Predicate;\n \n /**\n  * Interface for marking ledgers which need to be rereplicated\n@@ -42,11 +44,18 @@ void markLedgerReplicated(long ledgerId)\n \n     /**\n      * Get a list of all the ledgers which have been\n-     * marked for rereplication.\n-     *\n+     * marked for rereplication, filtered by the predicate on the missing replicas list.\n+     * \n+     * Missing replicas list of an underreplicated ledger is the list of the bookies which are part of \n+     * the ensemble of this ledger and are currently unavailable/down.\n+     * \n+     * If filtering is not needed then it is suggested to pass null for predicate,\n+     * otherwise it will read the content of the ZNode to decide on filtering.\n+     * \n+     * @param predicate filter to use while listing under replicated ledgers. 'null' if filtering is not required\n      * @return an iterator which returns ledger ids\n      */\n-    Iterator<Long> listLedgersToRereplicate();\n+    Iterator<Long> listLedgersToRereplicate(Predicate<List<String>> predicate);\n \n     /**\n      * Acquire a underreplicated ledger for rereplication. The ledger\n@@ -116,4 +125,41 @@ boolean isLedgerReplicationEnabled()\n      */\n     void notifyLedgerReplicationEnabled(GenericCallback<Void> cb)\n             throws ReplicationException.UnavailableException;\n+\n+    /**\n+     * Creates the zNode for lostBookieRecoveryDelay with the specified value and returns true.\n+     * If the node is already existing, then it returns false   \n+     * \n+     * @param lostBookieRecoveryDelay\n+     * @return\n+     *      true if it succeeds in creating zNode for lostBookieRecoveryDelay, false if it is already existing\n+     * @throws ReplicationException.UnavailableException\n+     */\n+    boolean initializeLostBookieRecoveryDelay(int lostBookieRecoveryDelay)\n+            throws ReplicationException.UnavailableException;\n+\n+    /**\n+     * Setter for the lostBookieRecoveryDelay znode\n+     * \n+     * @param lostBookieRecoveryDelay\n+     * @throws ReplicationException.UnavailableException\n+     */\n+    void setLostBookieRecoveryDelay(int lostBookieRecoveryDelay) throws ReplicationException.UnavailableException;\n+\n+    /**\n+     * Getter for the lostBookieRecoveryDelay\n+     * \n+     * @return the int value of lostBookieRecoveryDelay\n+     * @throws ReplicationException.UnavailableException\n+     */\n+    int getLostBookieRecoveryDelay() throws ReplicationException.UnavailableException;\n+\n+    /**\n+     * Receive notification asynchronously when the lostBookieRecoveryDelay value is Changed\n+     * \n+     * @param cb\n+     * @throws ReplicationException.UnavailableException\n+     */\n+    void notifyLostBookieRecoveryDelayChanged(GenericCallback<Void> cb)\n+            throws ReplicationException.UnavailableException;\n }"},{"sha":"e56ee30205249af9107dd45cdaa1321bc9802399","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/meta/ZkLedgerUnderreplicationManager.java","status":"modified","additions":113,"deletions":9,"changes":122,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/29eb420f1cca07c1a3a7748ed7fbb8a5bc54f2fa/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FZkLedgerUnderreplicationManager.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/29eb420f1cca07c1a3a7748ed7fbb8a5bc54f2fa/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FZkLedgerUnderreplicationManager.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmeta%2FZkLedgerUnderreplicationManager.java?ref=29eb420f1cca07c1a3a7748ed7fbb8a5bc54f2fa","patch":"@@ -30,6 +30,7 @@\n import java.util.Queue;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.CountDownLatch;\n+import java.util.function.Predicate;\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n \n@@ -49,15 +50,16 @@\n import org.apache.zookeeper.KeeperException;\n import org.apache.zookeeper.WatchedEvent;\n import org.apache.zookeeper.Watcher;\n+import org.apache.zookeeper.ZooDefs.Ids;\n import org.apache.zookeeper.ZooKeeper;\n+import org.apache.zookeeper.data.ACL;\n import org.apache.zookeeper.data.Stat;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n import com.google.common.annotations.VisibleForTesting;\n import com.google.common.base.Joiner;\n import com.google.protobuf.TextFormat;\n-import org.apache.zookeeper.data.ACL;\n \n /**\n  * ZooKeeper implementation of underreplication manager.\n@@ -101,6 +103,7 @@ private static class Lock {\n     private final String urLockPath;\n     private final String layoutZNode;\n     private final AbstractConfiguration conf;\n+    private final String lostBookieRecoveryDelayZnode;\n     private final ZooKeeper zkc;\n     private final SubTreeCache subTreeCache;\n \n@@ -112,7 +115,8 @@ public ZkLedgerUnderreplicationManager(AbstractConfiguration conf, ZooKeeper zkc\n         urLedgerPath = basePath\n                 + BookKeeperConstants.DEFAULT_ZK_LEDGERS_ROOT_PATH;\n         urLockPath = basePath + '/' + BookKeeperConstants.UNDER_REPLICATION_LOCK;\n-\n+        lostBookieRecoveryDelayZnode = basePath + '/' + BookKeeperConstants.LOSTBOOKIERECOVERYDELAY_NODE;\n+        \n         idExtractionPattern = Pattern.compile(\"urL(\\\\d+)$\");\n         this.zkc = zkc;\n         this.subTreeCache = new SubTreeCache(new SubTreeCache.TreeProvider() {\n@@ -341,8 +345,21 @@ public void markLedgerReplicated(long ledgerId) throws ReplicationException.Unav\n         }\n     }\n \n+    /**\n+     * Get a list of all the ledgers which have been\n+     * marked for rereplication, filtered by the predicate on the replicas list.\n+     * \n+     * Replicas list of an underreplicated ledger is the list of the bookies which are part of \n+     * the ensemble of this ledger and are currently unavailable/down.\n+     * \n+     * If filtering is not needed then it is suggested to pass null for predicate,\n+     * otherwise it will read the content of the ZNode to decide on filtering.\n+     * \n+     * @param predicate filter to use while listing under replicated ledgers. 'null' if filtering is not required.\n+     * @return an iterator which returns ledger ids\n+     */\n     @Override\n-    public Iterator<Long> listLedgersToRereplicate() {\n+    public Iterator<Long> listLedgersToRereplicate(final Predicate<List<String>> predicate) {\n         final Queue<String> queue = new LinkedList<String>();\n         queue.add(urLedgerPath);\n \n@@ -363,12 +380,20 @@ public boolean hasNext() {\n                 while (queue.size() > 0 && curBatch.size() == 0) {\n                     String parent = queue.remove();\n                     try {\n-                        for (String c : zkc.getChildren(parent,false)) {\n-                            String child = parent + \"/\" + c;\n-                            if (c.startsWith(\"urL\")) {\n-                                curBatch.add(getLedgerId(child));\n-                            } else {\n-                                queue.add(child);\n+                        for (String c : zkc.getChildren(parent, false)) {\n+                            try {\n+                                String child = parent + \"/\" + c;\n+                                if (c.startsWith(\"urL\")) {\n+                                    long ledgerId = getLedgerId(child);\n+                                    if ((predicate == null)\n+                                            || predicate.test(getLedgerUnreplicationInfo(ledgerId).getReplicaList())) {\n+                                        curBatch.add(ledgerId);\n+                                    }\n+                                } else {\n+                                    queue.add(child);\n+                                }\n+                            } catch (KeeperException.NoNodeException nne) {\n+                                // ignore\n                             }\n                         }\n                     } catch (InterruptedException ie) {\n@@ -694,4 +719,83 @@ public static void releaseUnderreplicatedLedgerLock(ZooKeeper zkc, String zkLedg\n             zkc.delete(getUrLedgerLockZnode(getUrLockPath(zkLedgersRootPath), ledgerId), -1);\n         }\n     }\n+\n+    @Override\n+    public boolean initializeLostBookieRecoveryDelay(int lostBookieRecoveryDelay) throws UnavailableException {\n+        LOG.debug(\"initializeLostBookieRecoveryDelay()\");\n+        try {\n+            zkc.create(lostBookieRecoveryDelayZnode, Integer.toString(lostBookieRecoveryDelay).getBytes(UTF_8),\n+                    Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n+        } catch (KeeperException.NodeExistsException ke) {\n+            LOG.info(\n+                    \"lostBookieRecoveryDelay Znode is already present, so using existing lostBookieRecoveryDelay Znode value\");\n+            return false;\n+        } catch (KeeperException ke) {\n+            LOG.error(\"Error while initializing LostBookieRecoveryDelay\", ke);\n+            throw new ReplicationException.UnavailableException(\"Error contacting zookeeper\", ke);\n+        } catch (InterruptedException ie) {\n+            Thread.currentThread().interrupt();\n+            throw new ReplicationException.UnavailableException(\"Interrupted while contacting zookeeper\", ie);\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    public void setLostBookieRecoveryDelay(int lostBookieRecoveryDelay) throws UnavailableException {\n+        LOG.debug(\"setLostBookieRecoveryDelay()\");\n+        try {\n+            if (zkc.exists(lostBookieRecoveryDelayZnode, false) != null) {\n+                zkc.setData(lostBookieRecoveryDelayZnode, Integer.toString(lostBookieRecoveryDelay).getBytes(UTF_8),\n+                        -1);\n+            } else {\n+                zkc.create(lostBookieRecoveryDelayZnode, Integer.toString(lostBookieRecoveryDelay).getBytes(UTF_8),\n+                        Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n+            }\n+        } catch (KeeperException ke) {\n+            LOG.error(\"Error while setting LostBookieRecoveryDelay \", ke);\n+            throw new ReplicationException.UnavailableException(\"Error contacting zookeeper\", ke);\n+        } catch (InterruptedException ie) {\n+            Thread.currentThread().interrupt();\n+            throw new ReplicationException.UnavailableException(\"Interrupted while contacting zookeeper\", ie);\n+        }\n+    }\n+\n+    @Override\n+    public int getLostBookieRecoveryDelay() throws UnavailableException {\n+        LOG.debug(\"getLostBookieRecoveryDelay()\");\n+        try {\n+            byte[] data = zkc.getData(lostBookieRecoveryDelayZnode, false, null);\n+            return Integer.parseInt(new String(data, UTF_8));\n+        } catch (KeeperException ke) {\n+            LOG.error(\"Error while getting LostBookieRecoveryDelay \", ke);\n+            throw new ReplicationException.UnavailableException(\"Error contacting zookeeper\", ke);\n+        } catch (InterruptedException ie) {\n+            Thread.currentThread().interrupt();\n+            throw new ReplicationException.UnavailableException(\"Interrupted while contacting zookeeper\", ie);\n+        }\n+    }\n+\n+    @Override\n+    public void notifyLostBookieRecoveryDelayChanged(GenericCallback<Void> cb) throws UnavailableException {\n+        LOG.debug(\"notifyLostBookieRecoveryDelayChanged()\");\n+        Watcher w = new Watcher() {\n+            public void process(WatchedEvent e) {\n+                if (e.getType() == Watcher.Event.EventType.NodeDataChanged) {\n+                    cb.operationComplete(0, null);\n+                }\n+            }\n+        };\n+        try {\n+            if (null == zkc.exists(lostBookieRecoveryDelayZnode, w)) {\n+                cb.operationComplete(0, null);\n+                return;\n+            }\n+        } catch (KeeperException ke) {\n+            LOG.error(\"Error while checking the state of lostBookieRecoveryDelay\", ke);\n+            throw new ReplicationException.UnavailableException(\"Error contacting zookeeper\", ke);\n+        } catch (InterruptedException ie) {\n+            Thread.currentThread().interrupt();\n+            throw new ReplicationException.UnavailableException(\"Interrupted while contacting zookeeper\", ie);\n+        }\n+    }\n }"},{"sha":"054e09d42f31a258c69583de1601c76ce7db4375","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/Auditor.java","status":"modified","additions":119,"deletions":25,"changes":144,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/29eb420f1cca07c1a3a7748ed7fbb8a5bc54f2fa/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Freplication%2FAuditor.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/29eb420f1cca07c1a3a7748ed7fbb8a5bc54f2fa/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Freplication%2FAuditor.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Freplication%2FAuditor.java?ref=29eb420f1cca07c1a3a7748ed7fbb8a5bc54f2fa","patch":"@@ -20,8 +20,19 @@\n  */\n package org.apache.bookkeeper.replication;\n \n-import com.google.common.base.Stopwatch;\n-import com.google.common.collect.Sets;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n \n import org.apache.bookkeeper.client.BKException;\n import org.apache.bookkeeper.client.BookKeeper;\n@@ -41,35 +52,21 @@\n import org.apache.bookkeeper.replication.ReplicationException.BKAuditException;\n import org.apache.bookkeeper.replication.ReplicationException.CompatibilityException;\n import org.apache.bookkeeper.replication.ReplicationException.UnavailableException;\n-import org.apache.bookkeeper.replication.ReplicationStats;\n import org.apache.bookkeeper.stats.Counter;\n import org.apache.bookkeeper.stats.OpStatsLogger;\n import org.apache.bookkeeper.stats.StatsLogger;\n import org.apache.bookkeeper.zookeeper.ZooKeeperClient;\n import org.apache.commons.collections.CollectionUtils;\n import org.apache.zookeeper.AsyncCallback;\n-\n-import com.google.common.annotations.VisibleForTesting;\n-import com.google.common.util.concurrent.SettableFuture;\n-\n import org.apache.zookeeper.KeeperException;\n import org.apache.zookeeper.ZooKeeper;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import java.io.IOException;\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.concurrent.Future;\n-import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.ScheduledExecutorService;\n-import java.util.concurrent.ThreadFactory;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicInteger;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+import com.google.common.collect.Sets;\n+import com.google.common.util.concurrent.SettableFuture;\n \n /**\n  * Auditor is a single entity in the entire Bookie cluster and will be watching\n@@ -101,7 +98,8 @@ public class Auditor implements BookiesListener {\n     private final Counter numDelayedBookieAuditsCancelled;\n     private volatile Future<?> auditTask;\n     private Set<String> bookiesToBeAudited = Sets.newHashSet();\n-\n+    private volatile int lostBookieRecoveryDelayBeforeChange;\n+    \n     public Auditor(final String bookieIdentifier, ServerConfiguration conf,\n                    ZooKeeper zkc, StatsLogger statsLogger) throws UnavailableException {\n         this.conf = conf;\n@@ -149,6 +147,15 @@ private void initialize(ServerConfiguration conf, ZooKeeper zkc)\n             LOG.info(\"AuthProvider used by the Auditor is \"+clientConfiguration.getClientAuthProviderFactoryClass());\n             this.bkc = new BookKeeper(clientConfiguration, zkc);\n             this.admin = new BookKeeperAdmin(bkc, statsLogger);\n+            if (this.ledgerUnderreplicationManager\n+                    .initializeLostBookieRecoveryDelay(conf.getLostBookieRecoveryDelay())) {\n+                LOG.info(\"Initializing lostBookieRecoveryDelay zNode to the conif value: {}\",\n+                        conf.getLostBookieRecoveryDelay());\n+            } else {\n+                LOG.info(\n+                        \"Valid lostBookieRecoveryDelay zNode is available, so not creating lostBookieRecoveryDelay zNode as part of Auditor initialization \");\n+            }\n+            lostBookieRecoveryDelayBeforeChange = this.ledgerUnderreplicationManager.getLostBookieRecoveryDelay();\n         } catch (CompatibilityException ce) {\n             throw new UnavailableException(\n                     \"CompatibilityException while initializing Auditor\", ce);\n@@ -191,7 +198,8 @@ synchronized Future<?> submitAuditTask() {\n                 public void run() {\n                     try {\n                         waitIfLedgerReplicationDisabled();\n-\n+                        int lostBookieRecoveryDelay = Auditor.this.ledgerUnderreplicationManager\n+                                .getLostBookieRecoveryDelay();\n                         List<String> availableBookies = getAvailableBookies();\n \n                         // casting to String, as knownBookies and availableBookies\n@@ -220,7 +228,7 @@ public void run() {\n                         }\n \n                         knownBookies.removeAll(bookiesToBeAudited);\n-                        if (conf.getLostBookieRecoveryDelay() == 0) {\n+                        if (lostBookieRecoveryDelay == 0) {\n                             startAudit(false);\n                             bookiesToBeAudited.clear();\n                             return;\n@@ -246,9 +254,9 @@ public void run() {\n                                     auditTask = null;\n                                     bookiesToBeAudited.clear();\n                                 }\n-                            }, conf.getLostBookieRecoveryDelay(), TimeUnit.SECONDS);\n+                            }, lostBookieRecoveryDelay, TimeUnit.SECONDS);\n                             numBookieAuditsDelayed.inc();\n-                            LOG.info(\"Delaying bookie audit by \" + conf.getLostBookieRecoveryDelay()\n+                            LOG.info(\"Delaying bookie audit by \" + lostBookieRecoveryDelay\n                                      + \"secs for \" + bookiesToBeAudited.toString());\n                         }\n                     } catch (BKException bke) {\n@@ -263,6 +271,64 @@ public void run() {\n             });\n     }\n \n+    synchronized Future<?> submitLostBookieRecoveryDelayChangedEvent() {\n+        if (executor.isShutdown()) {\n+            SettableFuture<Void> f = SettableFuture.<Void> create();\n+            f.setException(new BKAuditException(\"Auditor shutting down\"));\n+            return f;\n+        }\n+        return executor.submit(new Runnable() {\n+            int lostBookieRecoveryDelay = -1;\n+            public void run() {\n+                try {\n+                    waitIfLedgerReplicationDisabled();\n+                    lostBookieRecoveryDelay = Auditor.this.ledgerUnderreplicationManager\n+                            .getLostBookieRecoveryDelay();\n+                    // if there is pending auditTask, cancel the task. So that it can be rescheduled\n+                    // after new lostBookieRecoveryDelay period\n+                    if (auditTask != null) {\n+                        LOG.info(\"lostBookieRecoveryDelay period has been changed so canceling the pending AuditTask\");\n+                        auditTask.cancel(false);                        \n+                        numDelayedBookieAuditsCancelled.inc();\n+                    }\n+\n+                    // if lostBookieRecoveryDelay is set to its previous value then consider it as\n+                    // signal to trigger the Audit immediately.\n+                    if ((lostBookieRecoveryDelay == 0)\n+                            || (lostBookieRecoveryDelay == lostBookieRecoveryDelayBeforeChange)) {\n+                        LOG.info(\n+                                \"lostBookieRecoveryDelay has been set to 0 or reset to its previos value, so starting AuditTask. \"\n+                                + \"Current lostBookieRecoveryDelay: {}, previous lostBookieRecoveryDelay: {}\",\n+                                lostBookieRecoveryDelay, lostBookieRecoveryDelayBeforeChange);\n+                        startAudit(false);\n+                        auditTask = null;\n+                        bookiesToBeAudited.clear();                        \n+                    } else if (auditTask != null) {\n+                        LOG.info(\"lostBookieRecoveryDelay has been set to {}, so rescheduling AuditTask accordingly\",\n+                                lostBookieRecoveryDelay);\n+                        auditTask = executor.schedule(new Runnable() {\n+                            public void run() {\n+                                startAudit(false);\n+                                auditTask = null;\n+                                bookiesToBeAudited.clear();\n+                            }\n+                        }, lostBookieRecoveryDelay, TimeUnit.SECONDS);\n+                        numBookieAuditsDelayed.inc();\n+                    }                    \n+                } catch (InterruptedException ie) {\n+                    Thread.currentThread().interrupt();\n+                    LOG.error(\"Interrupted while for LedgersReplication to be enabled \", ie);\n+                } catch (UnavailableException ue) {\n+                    LOG.error(\"Exception while reading from ZK\", ue);\n+                } finally{\n+                    if (lostBookieRecoveryDelay != -1) {\n+                        lostBookieRecoveryDelayBeforeChange = lostBookieRecoveryDelay;\n+                    }\n+                }\n+            }\n+        });\n+    }\n+\n     public void start() {\n         LOG.info(\"I'm starting as Auditor Bookie. ID: {}\", bookieIdentifier);\n         // on startup watching available bookie and based on the\n@@ -317,6 +383,14 @@ public void run() {\n                 LOG.error(\"Couldn't get bookie list, exiting\", bke);\n                 submitShutdownTask();\n             }\n+            \n+            try {\n+                this.ledgerUnderreplicationManager\n+                        .notifyLostBookieRecoveryDelayChanged(new LostBookieRecoveryDelayChangedCb());\n+            } catch (UnavailableException ue) {\n+                LOG.error(\"Exception while registering for LostBookieRecoveryDelay change notification\", ue);\n+                submitShutdownTask();\n+            }\n \n             long bookieCheckInterval = conf.getAuditorPeriodicBookieCheckInterval();\n             if (bookieCheckInterval == 0) {\n@@ -330,6 +404,19 @@ public void run() {\n         }\n     }\n \n+    private class LostBookieRecoveryDelayChangedCb implements GenericCallback<Void> {\n+        @Override\n+        public void operationComplete(int rc, Void result) {\n+            try {\n+                Auditor.this.ledgerUnderreplicationManager\n+                        .notifyLostBookieRecoveryDelayChanged(LostBookieRecoveryDelayChangedCb.this);\n+            } catch (UnavailableException ae) {\n+                LOG.error(\"Exception while registering for a LostBookieRecoveryDelay notification\", ae);\n+            }\n+            Auditor.this.submitLostBookieRecoveryDelayChangedEvent();\n+        }\n+    }\n+    \n     private void waitIfLedgerReplicationDisabled() throws UnavailableException,\n             InterruptedException {\n         ReplicationEnableCb cb = new ReplicationEnableCb();\n@@ -673,4 +760,11 @@ public void run() {\n             }\n         };\n \n+    int getLostBookieRecoveryDelayBeforeChange() {\n+        return lostBookieRecoveryDelayBeforeChange;\n+    }\n+\n+    Future<?> getAuditTask() {\n+        return auditTask;\n+    }\n }"},{"sha":"2ff7b9412bbb3bec8c52b2975d7ade4e9e31adea","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/ReplicationException.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/29eb420f1cca07c1a3a7748ed7fbb8a5bc54f2fa/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Freplication%2FReplicationException.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/29eb420f1cca07c1a3a7748ed7fbb8a5bc54f2fa/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Freplication%2FReplicationException.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Freplication%2FReplicationException.java?ref=29eb420f1cca07c1a3a7748ed7fbb8a5bc54f2fa","patch":"@@ -64,7 +64,7 @@ public CompatibilityException(String message) {\n     /**\n      * Exception while auditing bookie-ledgers\n     */\n-    static class BKAuditException extends ReplicationException {\n+    public static class BKAuditException extends ReplicationException {\n         private static final long serialVersionUID = 95551905L;\n \n         BKAuditException(String message, Throwable cause) {"},{"sha":"362e1e6dd7051d068ee4ec410dc4d76ae5187186","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/util/BookKeeperConstants.java","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/29eb420f1cca07c1a3a7748ed7fbb8a5bc54f2fa/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2FBookKeeperConstants.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/29eb420f1cca07c1a3a7748ed7fbb8a5bc54f2fa/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2FBookKeeperConstants.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Futil%2FBookKeeperConstants.java?ref=29eb420f1cca07c1a3a7748ed7fbb8a5bc54f2fa","patch":"@@ -40,6 +40,7 @@ public class BookKeeperConstants {\n     public static final String UNDER_REPLICATION_NODE = \"underreplication\";\r\n     public static final String UNDER_REPLICATION_LOCK = \"locks\";\r\n     public static final String DISABLE_NODE = \"disable\";\r\n+    public static final String LOSTBOOKIERECOVERYDELAY_NODE = \"lostBookieRecoveryDelay\";\r\n     public static final String DEFAULT_ZK_LEDGERS_ROOT_PATH = \"/ledgers\";\r\n     public static final String LAYOUT_ZNODE = \"LAYOUT\";\r\n     public static final String INSTANCEID = \"INSTANCEID\";\r"},{"sha":"b197353cc29f3565042f92b3e702318127c172da","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookKeeperAdminTest.java","status":"added","additions":230,"deletions":0,"changes":230,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/29eb420f1cca07c1a3a7748ed7fbb8a5bc54f2fa/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookKeeperAdminTest.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/29eb420f1cca07c1a3a7748ed7fbb8a5bc54f2fa/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookKeeperAdminTest.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookKeeperAdminTest.java?ref=29eb420f1cca07c1a3a7748ed7fbb8a5bc54f2fa","patch":"@@ -0,0 +1,230 @@\n+/**\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.client;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.util.Iterator;\n+\n+import org.apache.bookkeeper.bookie.Bookie;\n+import org.apache.bookkeeper.client.BKException.BKIllegalOpException;\n+import org.apache.bookkeeper.client.BookKeeper.DigestType;\n+import org.apache.bookkeeper.conf.ServerConfiguration;\n+import org.apache.bookkeeper.meta.ZkLedgerUnderreplicationManager;\n+import org.apache.bookkeeper.replication.ReplicationException.UnavailableException;\n+import org.apache.bookkeeper.test.BookKeeperClusterTestCase;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class BookKeeperAdminTest extends BookKeeperClusterTestCase {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(BookKeeperAdminTest.class);\n+    private DigestType digestType = DigestType.CRC32;\n+    private static final String PASSWORD = \"testPasswd\";\n+    private static final int numOfBookies = 6;\n+    private final int lostBookieRecoveryDelayInitValue = 1800;\n+\n+    public BookKeeperAdminTest() {\n+        super(numOfBookies);\n+        baseConf.setAutoRecoveryDaemonEnabled(true);\n+        baseConf.setLostBookieRecoveryDelay(lostBookieRecoveryDelayInitValue);\n+        baseConf.setOpenLedgerRereplicationGracePeriod(String.valueOf(30000));\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testLostBookieRecoveryDelayValue() throws Exception {\n+        BookKeeperAdmin bkAdmin = new BookKeeperAdmin(zkUtil.getZooKeeperConnectString());\n+        assertEquals(\"LostBookieRecoveryDelay\", lostBookieRecoveryDelayInitValue, bkAdmin.getLostBookieRecoveryDelay());\n+        int newLostBookieRecoveryDelayValue = 2400;\n+        bkAdmin.setLostBookieRecoveryDelay(newLostBookieRecoveryDelayValue);\n+        assertEquals(\"LostBookieRecoveryDelay\", newLostBookieRecoveryDelayValue, bkAdmin.getLostBookieRecoveryDelay());\n+        assertEquals(\"LostBookieRecoveryDelay\", newLostBookieRecoveryDelayValue, bkAdmin.getLostBookieRecoveryDelay());\n+        newLostBookieRecoveryDelayValue = 3000;\n+        bkAdmin.setLostBookieRecoveryDelay(newLostBookieRecoveryDelayValue);\n+        assertEquals(\"LostBookieRecoveryDelay\", newLostBookieRecoveryDelayValue, bkAdmin.getLostBookieRecoveryDelay());\n+        bkAdmin.close();\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testTriggerAudit() throws Exception {\n+        ZkLedgerUnderreplicationManager urLedgerMgr = new ZkLedgerUnderreplicationManager(baseClientConf, zkc);\n+        BookKeeperAdmin bkAdmin = new BookKeeperAdmin(zkUtil.getZooKeeperConnectString());\n+        int lostBookieRecoveryDelayValue = bkAdmin.getLostBookieRecoveryDelay();\n+        urLedgerMgr.disableLedgerReplication();\n+        try {\n+            bkAdmin.triggerAudit();\n+            Assert.fail(\"Trigger Audit should have failed because LedgerReplication is disabled\");\n+        } catch (UnavailableException une) {\n+            // expected\n+        }\n+        assertEquals(\"LostBookieRecoveryDelay\", lostBookieRecoveryDelayValue, bkAdmin.getLostBookieRecoveryDelay());\n+        urLedgerMgr.enableLedgerReplication();\n+        bkAdmin.triggerAudit();\n+        assertEquals(\"LostBookieRecoveryDelay\", lostBookieRecoveryDelayValue, bkAdmin.getLostBookieRecoveryDelay());\n+        long ledgerId = 1L;\n+        LedgerHandle ledgerHandle = bkc.createLedgerAdv(ledgerId, numBookies, numBookies, numBookies, digestType,\n+                PASSWORD.getBytes(), null);\n+        ledgerHandle.addEntry(0, \"data\".getBytes());\n+        ledgerHandle.close();\n+\n+        killBookie(1);\n+        /*\n+         * since lostBookieRecoveryDelay is set, when a bookie is died, it will\n+         * not start Audit process immediately. But when triggerAudit is called\n+         * it will force audit process.\n+         */\n+        bkAdmin.triggerAudit();\n+        Thread.sleep(500);\n+        Iterator<Long> ledgersToRereplicate = urLedgerMgr.listLedgersToRereplicate(null);\n+        assertTrue(\"There are supposed to be underreplicatedledgers\", ledgersToRereplicate.hasNext());\n+        assertEquals(\"Underreplicated ledgerId\", ledgerId, ledgersToRereplicate.next().longValue());\n+        bkAdmin.close();\n+    }\n+\n+    @Test(timeout = 480000)\n+    public void testDecommissionBookie() throws Exception {\n+        ZkLedgerUnderreplicationManager urLedgerMgr = new ZkLedgerUnderreplicationManager(baseClientConf, zkc);\n+        BookKeeperAdmin bkAdmin = new BookKeeperAdmin(zkUtil.getZooKeeperConnectString());\n+\n+        int numOfLedgers = 2 * numOfBookies;\n+        int numOfEntries = 2 * numOfBookies;\n+        for (int i = 0; i < numOfLedgers; i++) {\n+            LedgerHandle lh = bkc.createLedger(3, 2, digestType, PASSWORD.getBytes());\n+            for (int j = 0; j < numOfEntries; j++) {\n+                lh.addEntry(\"entry\".getBytes());\n+            }\n+            lh.close();\n+        }\n+        /*\n+         * create ledgers having empty segments (segment with no entries)\n+         */\n+        for (int i = 0; i < numOfLedgers; i++) {\n+            LedgerHandle emptylh = bkc.createLedger(3, 2, digestType, PASSWORD.getBytes());\n+            emptylh.close();\n+        }\n+        \n+        try {\n+            /*\n+             * if we try to call decommissionBookie for a bookie which is not\n+             * shutdown, then it should throw BKIllegalOpException\n+             */\n+            bkAdmin.decommissionBookie(bs.get(0).getLocalAddress());\n+            fail(\"Expected BKIllegalOpException because that bookie is not shutdown yet\");\n+        } catch (BKIllegalOpException bkioexc) {\n+            // expected IllegalException\n+        }\n+        \n+        ServerConfiguration killedBookieConf = killBookie(1);\n+        /*\n+         * this decommisionBookie should make sure that there are no\n+         * underreplicated ledgers because of this bookie\n+         */\n+        bkAdmin.decommissionBookie(Bookie.getBookieAddress(killedBookieConf));\n+        bkAdmin.triggerAudit();\n+        Thread.sleep(500);\n+        Iterator<Long> ledgersToRereplicate = urLedgerMgr.listLedgersToRereplicate(null);\n+        if (ledgersToRereplicate.hasNext()) {\n+            while (ledgersToRereplicate.hasNext()) {\n+                Long ledgerId = ledgersToRereplicate.next();\n+                LOG.error(\"Ledger: {} is underreplicated which is not expected\", ledgerId);\n+            }\n+            fail(\"There are not supposed to be any underreplicatedledgers\");\n+        }\n+        \n+        killedBookieConf = killBookie(0);\n+        bkAdmin.decommissionBookie(Bookie.getBookieAddress(killedBookieConf));\n+        bkAdmin.triggerAudit();\n+        Thread.sleep(500);\n+        ledgersToRereplicate = urLedgerMgr.listLedgersToRereplicate(null);\n+        if (ledgersToRereplicate.hasNext()) {\n+            while (ledgersToRereplicate.hasNext()) {\n+                Long ledgerId = ledgersToRereplicate.next();\n+                LOG.error(\"Ledger: {} is underreplicated which is not expected\", ledgerId);\n+            }\n+            fail(\"There are not supposed to be any underreplicatedledgers\");\n+        }\n+        bkAdmin.close();\n+    }\n+\n+    @Test(timeout = 240000)\n+    public void testDecommissionForLedgersWithMultipleSegmentsAndNotWriteClosed() throws Exception {\n+        ZkLedgerUnderreplicationManager urLedgerMgr = new ZkLedgerUnderreplicationManager(baseClientConf, zkc);\n+        BookKeeperAdmin bkAdmin = new BookKeeperAdmin(zkUtil.getZooKeeperConnectString());\n+        int numOfEntries = 2 * numOfBookies;\n+\n+        LedgerHandle lh1 = bkc.createLedgerAdv(1L, numBookies, 3, 3, digestType, PASSWORD.getBytes(), null);\n+        LedgerHandle lh2 = bkc.createLedgerAdv(2L, numBookies, 3, 3, digestType, PASSWORD.getBytes(), null);\n+        LedgerHandle lh3 = bkc.createLedgerAdv(3L, numBookies, 3, 3, digestType, PASSWORD.getBytes(), null);\n+        LedgerHandle lh4 = bkc.createLedgerAdv(4L, numBookies, 3, 3, digestType, PASSWORD.getBytes(), null);\n+        for (int j = 0; j < numOfEntries; j++) {\n+            lh1.addEntry(j, \"data\".getBytes());\n+            lh2.addEntry(j, \"data\".getBytes());\n+            lh3.addEntry(j, \"data\".getBytes());\n+            lh4.addEntry(j, \"data\".getBytes());\n+        }\n+\n+        startNewBookie();\n+\n+        assertEquals(\"Number of Available Bookies\", numOfBookies + 1, bkAdmin.getAvailableBookies().size());\n+\n+        ServerConfiguration killedBookieConf = killBookie(0);\n+\n+        /*\n+         * since one of the bookie is killed, ensemble change happens when next\n+         * write is made.So new segment will be created for those 2 ledgers.\n+         */\n+        for (int j = numOfEntries; j < 2 * numOfEntries; j++) {\n+            lh1.addEntry(j, \"data\".getBytes());\n+            lh2.addEntry(j, \"data\".getBytes());\n+        }\n+        \n+        /*\n+         * Here lh1 and lh2 have multiple segments and are writeclosed. But lh3 and lh4 are \n+         * not writeclosed and contains only one segment.\n+         */\n+        lh1.close();\n+        lh2.close();\n+        \n+        /*\n+         * If the last segment of the ledger is underreplicated and if the\n+         * ledger is not closed then it will remain underreplicated for\n+         * openLedgerRereplicationGracePeriod (by default 30 secs). For more\n+         * info. Check BOOKKEEPER-237 and BOOKKEEPER-325. But later\n+         * ReplicationWorker will fence the ledger.\n+         */\n+        bkAdmin.decommissionBookie(Bookie.getBookieAddress(killedBookieConf));\n+        bkAdmin.triggerAudit();\n+        Thread.sleep(500);\n+        Iterator<Long> ledgersToRereplicate = urLedgerMgr.listLedgersToRereplicate(null);\n+        if (ledgersToRereplicate.hasNext()) {\n+            while (ledgersToRereplicate.hasNext()) {\n+                Long ledgerId = ledgersToRereplicate.next();\n+                LOG.error(\"Ledger: {} is underreplicated which is not expected\", ledgerId);\n+            }\n+            fail(\"There are not supposed to be any underreplicatedledgers\");\n+        }\n+        bkAdmin.close();\n+    }\n+}"},{"sha":"f2a7316c4b8406e38102e1c6e2abe5a51f8edb23","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorLedgerCheckerTest.java","status":"modified","additions":262,"deletions":5,"changes":267,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/29eb420f1cca07c1a3a7748ed7fbb8a5bc54f2fa/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Freplication%2FAuditorLedgerCheckerTest.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/29eb420f1cca07c1a3a7748ed7fbb8a5bc54f2fa/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Freplication%2FAuditorLedgerCheckerTest.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Freplication%2FAuditorLedgerCheckerTest.java?ref=29eb420f1cca07c1a3a7748ed7fbb8a5bc54f2fa","patch":"@@ -20,6 +20,11 @@\n  */\n package org.apache.bookkeeper.replication;\n \n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n import java.io.IOException;\n import java.nio.ByteBuffer;\n import java.util.ArrayList;\n@@ -33,20 +38,27 @@\n import java.util.Set;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Future;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicInteger;\n \n import org.apache.bookkeeper.client.AsyncCallback.AddCallback;\n import org.apache.bookkeeper.client.BKException;\n import org.apache.bookkeeper.client.BookKeeper.DigestType;\n import org.apache.bookkeeper.client.LedgerHandle;\n+import org.apache.bookkeeper.client.LedgerMetadata;\n import org.apache.bookkeeper.conf.ServerConfiguration;\n+import org.apache.bookkeeper.meta.LedgerManager;\n+import org.apache.bookkeeper.meta.LedgerManagerFactory;\n import org.apache.bookkeeper.meta.ZkLedgerUnderreplicationManager;\n+import org.apache.bookkeeper.net.BookieSocketAddress;\n import org.apache.bookkeeper.proto.BookieServer;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks;\n import org.apache.bookkeeper.proto.DataFormats.UnderreplicatedLedgerFormat;\n import org.apache.bookkeeper.replication.ReplicationException.CompatibilityException;\n import org.apache.bookkeeper.replication.ReplicationException.UnavailableException;\n import org.apache.bookkeeper.test.MultiLedgerManagerTestCase;\n+import org.apache.commons.lang.mutable.MutableInt;\n import org.apache.zookeeper.KeeperException;\n import org.apache.zookeeper.WatchedEvent;\n import org.apache.zookeeper.Watcher;\n@@ -56,8 +68,6 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import static org.junit.Assert.*;\n-\n /**\n  * Tests publishing of under replicated ledgers by the Auditor bookie node when\n  * corresponding bookies identifes as not running\n@@ -337,7 +347,7 @@ public void _testDelayedAuditOfLostBookies() throws Exception {\n                 .size());\n \n         // wait for 5 seconds before starting the recovery work when a bookie fails\n-        baseConf.setLostBookieRecoveryDelay(5);\n+        urLedgerMgr.setLostBookieRecoveryDelay(5);\n \n         // shutdown a non auditor bookie; choosing non-auditor to avoid another election\n         String shutdownBookie = shutDownNonAuditorBookie();\n@@ -395,6 +405,247 @@ public void testDelayedAuditWithPeriodicBookieCheck() throws Exception {\n         _testDelayedAuditOfLostBookies();\n     }\n \n+    @Test(timeout=60000)\n+    public void testRescheduleOfDelayedAuditOfLostBookiesToStartImmediately() throws Exception {\n+     // wait for a second so that the initial periodic check finishes\n+        Thread.sleep(1000);\n+        \n+        LedgerHandle lh1 = createAndAddEntriesToLedger();\n+        Long ledgerId = lh1.getId();\n+        LOG.debug(\"Created ledger : \" + ledgerId);\n+        ledgerList.add(ledgerId);\n+        lh1.close();\n+\n+        final CountDownLatch underReplicaLatch = registerUrLedgerWatcher(ledgerList\n+                .size());\n+\n+        // wait for 50 seconds before starting the recovery work when a bookie fails\n+        urLedgerMgr.setLostBookieRecoveryDelay(50);\n+\n+        // shutdown a non auditor bookie; choosing non-auditor to avoid another election\n+        String shutdownBookie = shutDownNonAuditorBookie();\n+\n+        LOG.debug(\"Waiting for ledgers to be marked as under replicated\");\n+        assertFalse(\"audit of lost bookie isn't delayed\", underReplicaLatch.await(4, TimeUnit.SECONDS));\n+        assertEquals(\"under replicated ledgers identified when it was not expected\", 0,\n+                urLedgerList.size());\n+\n+        // set lostBookieRecoveryDelay to 0, so that it triggers AuditTask immediately\n+        urLedgerMgr.setLostBookieRecoveryDelay(0);\n+        \n+        // wait for 1 second for the ledger to get reported as under replicated\n+        assertTrue(\"audit of lost bookie isn't delayed\", underReplicaLatch.await(1, TimeUnit.SECONDS));\n+\n+        assertTrue(\"Ledger is not marked as underreplicated:\" + ledgerId,\n+                urLedgerList.contains(ledgerId));\n+        Map<Long, String> urLedgerData = getUrLedgerData(urLedgerList);\n+        String data = urLedgerData.get(ledgerId);\n+        assertTrue(\"Bookie \" + shutdownBookie\n+                + \"is not listed in the ledger as missing replica :\" + data,\n+                data.contains(shutdownBookie));\n+    }\n+    \n+    @Test(timeout=60000)\n+    public void testRescheduleOfDelayedAuditOfLostBookiesToStartLater() throws Exception {\n+     // wait for a second so that the initial periodic check finishes\n+        Thread.sleep(1000);\n+        \n+        LedgerHandle lh1 = createAndAddEntriesToLedger();\n+        Long ledgerId = lh1.getId();\n+        LOG.debug(\"Created ledger : \" + ledgerId);\n+        ledgerList.add(ledgerId);\n+        lh1.close();\n+\n+        final CountDownLatch underReplicaLatch = registerUrLedgerWatcher(ledgerList\n+                .size());\n+\n+        // wait for 3 seconds before starting the recovery work when a bookie fails\n+        urLedgerMgr.setLostBookieRecoveryDelay(3);\n+\n+        // shutdown a non auditor bookie; choosing non-auditor to avoid another election\n+        String shutdownBookie = shutDownNonAuditorBookie();\n+\n+        LOG.debug(\"Waiting for ledgers to be marked as under replicated\");\n+        assertFalse(\"audit of lost bookie isn't delayed\", underReplicaLatch.await(2, TimeUnit.SECONDS));\n+        assertEquals(\"under replicated ledgers identified when it was not expected\", 0,\n+                urLedgerList.size());\n+        \n+        // set lostBookieRecoveryDelay to 4, so the pending AuditTask is resheduled\n+        urLedgerMgr.setLostBookieRecoveryDelay(4);\n+        \n+        // since we changed the BookieRecoveryDelay period to 4, the audittask shouldn't have been executed\n+        LOG.debug(\"Waiting for ledgers to be marked as under replicated\");\n+        assertFalse(\"audit of lost bookie isn't delayed\", underReplicaLatch.await(2, TimeUnit.SECONDS));\n+        assertEquals(\"under replicated ledgers identified when it was not expected\", 0,\n+                urLedgerList.size());        \n+        \n+        // wait for 3 seconds (since we already waited for 2 secs) for the ledger to get reported as under replicated\n+        assertTrue(\"audit of lost bookie isn't delayed\", underReplicaLatch.await(3, TimeUnit.SECONDS));\n+        assertTrue(\"Ledger is not marked as underreplicated:\" + ledgerId,\n+                urLedgerList.contains(ledgerId));\n+        Map<Long, String> urLedgerData = getUrLedgerData(urLedgerList);\n+        String data = urLedgerData.get(ledgerId);\n+        assertTrue(\"Bookie \" + shutdownBookie\n+                + \"is not listed in the ledger as missing replica :\" + data,\n+                data.contains(shutdownBookie));\n+    }\n+    \n+    @Test(timeout=60000)\n+    public void testTriggerAuditorWithNoPendingAuditTask() throws Exception {\n+        // wait for a second so that the initial periodic check finishes\n+        Thread.sleep(1000);\n+        int lostBookieRecoveryDelayConfValue = baseConf.getLostBookieRecoveryDelay();\n+        Auditor auditorBookiesAuditor = getAuditorBookiesAuditor();\n+        Future<?> auditTask = auditorBookiesAuditor.getAuditTask();\n+        int lostBookieRecoveryDelayBeforeChange = auditorBookiesAuditor.getLostBookieRecoveryDelayBeforeChange();\n+        Assert.assertEquals(\"auditTask is supposed to be null\", null, auditTask);\n+        Assert.assertEquals(\n+                \"lostBookieRecoveryDelayBeforeChange of Auditor should be equal to BaseConf's lostBookieRecoveryDelay\",\n+                lostBookieRecoveryDelayConfValue, lostBookieRecoveryDelayBeforeChange);\n+        \n+        // there is no easy way to validate if the Auditor has executed Audit process (Auditor.startAudit), \n+        // without shuttingdown Bookie. To test if by resetting LostBookieRecoveryDelay it does Auditing\n+        // even when there is no pending AuditTask, following approach is needed.\n+        \n+        // Here we are creating few ledgers ledgermetadata with non-existing bookies as its ensemble.\n+        // When Auditor does audit it recognizes these ledgers as underreplicated and mark them as \n+        // under-replicated, since these bookies are not available. \n+        int numofledgers = 5;\n+        Random rand = new Random();\n+        for (int i = 0; i < numofledgers; i++) {\n+            LedgerMetadata metadata = new LedgerMetadata(3, 2, 2, DigestType.CRC32, \"passwd\".getBytes(), null);\n+            ArrayList<BookieSocketAddress> ensemble = new ArrayList<BookieSocketAddress>();\n+            ensemble.add(new BookieSocketAddress(\"99.99.99.99:9999\"));\n+            ensemble.add(new BookieSocketAddress(\"11.11.11.11:1111\"));\n+            ensemble.add(new BookieSocketAddress(\"88.88.88.88:8888\"));\n+            metadata.addEnsemble(0, ensemble);\n+            LedgerManager ledgerManager = LedgerManagerFactory.newLedgerManagerFactory(baseClientConf, zkc)\n+                    .newLedgerManager();\n+            MutableInt ledgerCreateRC = new MutableInt(-1);\n+            CountDownLatch latch = new CountDownLatch(1);\n+            long ledgerId = (Math.abs(rand.nextLong())) % 100000000;\n+            ledgerManager.createLedgerMetadata(ledgerId, metadata,\n+                    new BookkeeperInternalCallbacks.GenericCallback<Void>() {\n+                        @Override\n+                        public void operationComplete(int rc, Void result) {\n+                            ledgerCreateRC.setValue(rc);\n+                            latch.countDown();\n+                        }\n+                    });\n+            Assert.assertTrue(\"Ledger creation should complete within 2 secs\",\n+                    latch.await(2000, TimeUnit.MILLISECONDS));\n+            Assert.assertEquals(\"LedgerCreate should succeed and return OK rc value\", BKException.Code.OK,\n+                    ledgerCreateRC.getValue());\n+            ledgerList.add(ledgerId);\n+        }\n+        \n+        final CountDownLatch underReplicaLatch = registerUrLedgerWatcher(ledgerList.size());\n+        urLedgerMgr.setLostBookieRecoveryDelay(lostBookieRecoveryDelayBeforeChange);\n+        assertTrue(\"Audit should be triggered and created ledgers should be marked as underreplicated\",\n+                underReplicaLatch.await(2, TimeUnit.SECONDS));\n+        assertEquals(\"All the ledgers should be marked as underreplicated\", ledgerList.size(), urLedgerList.size());\n+        \n+        auditTask = auditorBookiesAuditor.getAuditTask();\n+        Assert.assertEquals(\"auditTask is supposed to be null\", null, auditTask);\n+        Assert.assertEquals(\n+                \"lostBookieRecoveryDelayBeforeChange of Auditor should be equal to BaseConf's lostBookieRecoveryDelay\",\n+                lostBookieRecoveryDelayBeforeChange, auditorBookiesAuditor.getLostBookieRecoveryDelayBeforeChange());\n+    }\n+    \n+    @Test(timeout=60000)\n+    public void testTriggerAuditorWithPendingAuditTask() throws Exception {\n+     // wait for a second so that the initial periodic check finishes\n+        Thread.sleep(1000);\n+        \n+        Auditor auditorBookiesAuditor = getAuditorBookiesAuditor();\n+        LedgerHandle lh1 = createAndAddEntriesToLedger();\n+        Long ledgerId = lh1.getId();\n+        LOG.debug(\"Created ledger : \" + ledgerId);\n+        ledgerList.add(ledgerId);\n+        lh1.close();\n+\n+        final CountDownLatch underReplicaLatch = registerUrLedgerWatcher(ledgerList\n+                .size());\n+\n+        int lostBookieRecoveryDelay = 5;\n+        // wait for 5 seconds before starting the recovery work when a bookie fails\n+        urLedgerMgr.setLostBookieRecoveryDelay(lostBookieRecoveryDelay);\n+\n+        // shutdown a non auditor bookie; choosing non-auditor to avoid another election\n+        String shutdownBookie = shutDownNonAuditorBookie();\n+\n+        LOG.debug(\"Waiting for ledgers to be marked as under replicated\");\n+        assertFalse(\"audit of lost bookie isn't delayed\", underReplicaLatch.await(2, TimeUnit.SECONDS));\n+        assertEquals(\"under replicated ledgers identified when it was not expected\", 0,\n+                urLedgerList.size());\n+        \n+        Future<?> auditTask = auditorBookiesAuditor.getAuditTask();\n+        Assert.assertNotEquals(\"auditTask is not supposed to be null\", null, auditTask);\n+        Assert.assertEquals(\n+                \"lostBookieRecoveryDelayBeforeChange of Auditor should be equal to what we set\",\n+                lostBookieRecoveryDelay, auditorBookiesAuditor.getLostBookieRecoveryDelayBeforeChange());\n+        \n+        // set lostBookieRecoveryDelay to 5 (previous value), so that Auditor is triggered immediately \n+        urLedgerMgr.setLostBookieRecoveryDelay(lostBookieRecoveryDelay);\n+        assertTrue(\"audit of lost bookie shouldn't be delayed\", underReplicaLatch.await(2, TimeUnit.SECONDS));\n+        assertEquals(\"all under replicated ledgers should be identified\", ledgerList.size(),\n+                urLedgerList.size());        \n+        \n+        Thread.sleep(100);\n+        auditTask = auditorBookiesAuditor.getAuditTask();\n+        Assert.assertEquals(\"auditTask is supposed to be null\", null, auditTask);\n+        Assert.assertEquals(\n+                \"lostBookieRecoveryDelayBeforeChange of Auditor should be equal to previously set value\",\n+                lostBookieRecoveryDelay, auditorBookiesAuditor.getLostBookieRecoveryDelayBeforeChange());\n+    }\n+    \n+    @Test(timeout=60000)\n+    public void testTriggerAuditorBySettingDelayToZeroWithPendingAuditTask() throws Exception {\n+     // wait for a second so that the initial periodic check finishes\n+        Thread.sleep(1000);\n+        \n+        Auditor auditorBookiesAuditor = getAuditorBookiesAuditor();\n+        LedgerHandle lh1 = createAndAddEntriesToLedger();\n+        Long ledgerId = lh1.getId();\n+        LOG.debug(\"Created ledger : \" + ledgerId);\n+        ledgerList.add(ledgerId);\n+        lh1.close();\n+\n+        final CountDownLatch underReplicaLatch = registerUrLedgerWatcher(ledgerList\n+                .size());\n+\n+        int lostBookieRecoveryDelay = 5;\n+        // wait for 5 seconds before starting the recovery work when a bookie fails\n+        urLedgerMgr.setLostBookieRecoveryDelay(lostBookieRecoveryDelay);\n+\n+        // shutdown a non auditor bookie; choosing non-auditor to avoid another election\n+        String shutdownBookie = shutDownNonAuditorBookie();\n+\n+        LOG.debug(\"Waiting for ledgers to be marked as under replicated\");\n+        assertFalse(\"audit of lost bookie isn't delayed\", underReplicaLatch.await(2, TimeUnit.SECONDS));\n+        assertEquals(\"under replicated ledgers identified when it was not expected\", 0,\n+                urLedgerList.size());\n+        \n+        Future<?> auditTask = auditorBookiesAuditor.getAuditTask();\n+        Assert.assertNotEquals(\"auditTask is not supposed to be null\", null, auditTask);\n+        Assert.assertEquals(\n+                \"lostBookieRecoveryDelayBeforeChange of Auditor should be equal to what we set\",\n+                lostBookieRecoveryDelay, auditorBookiesAuditor.getLostBookieRecoveryDelayBeforeChange());\n+        \n+        // set lostBookieRecoveryDelay to 0, so that Auditor is triggered immediately \n+        urLedgerMgr.setLostBookieRecoveryDelay(0);\n+        assertTrue(\"audit of lost bookie shouldn't be delayed\", underReplicaLatch.await(1, TimeUnit.SECONDS));\n+        assertEquals(\"all under replicated ledgers should be identified\", ledgerList.size(),\n+                urLedgerList.size());        \n+        \n+        Thread.sleep(100);\n+        auditTask = auditorBookiesAuditor.getAuditTask();\n+        Assert.assertEquals(\"auditTask is supposed to be null\", null, auditTask);\n+        Assert.assertEquals(\n+                \"lostBookieRecoveryDelayBeforeChange of Auditor should be equal to previously set value\",\n+                0, auditorBookiesAuditor.getLostBookieRecoveryDelayBeforeChange());\n+    }\n+    \n     /**\n      * Test audit of bookies is delayed when one bookie is down. But when\n      * another one goes down, the audit is started immediately.\n@@ -414,7 +665,7 @@ public void testDelayedAuditWithMultipleBookieFailures() throws Exception {\n         CountDownLatch underReplicaLatch = registerUrLedgerWatcher(ledgerList.size());\n \n         // wait for 10 seconds before starting the recovery work when a bookie fails\n-        baseConf.setLostBookieRecoveryDelay(10);\n+        urLedgerMgr.setLostBookieRecoveryDelay(10);\n \n         // shutdown a non auditor bookie to avoid an election\n         String shutdownBookie1 = shutDownNonAuditorBookie();\n@@ -467,7 +718,7 @@ public void testDelayedAuditWithRollingUpgrade() throws Exception {\n         CountDownLatch underReplicaLatch = registerUrLedgerWatcher(ledgerList.size());\n \n         // wait for 5 seconds before starting the recovery work when a bookie fails\n-        baseConf.setLostBookieRecoveryDelay(5);\n+        urLedgerMgr.setLostBookieRecoveryDelay(5);\n \n         // shutdown a non auditor bookie to avoid an election\n         int idx1 = getShutDownNonAuditorBookieIdx(\"\");\n@@ -647,6 +898,12 @@ private BookieServer getAuditorBookie() throws Exception {\n         return auditors.get(0);\n     }\n \n+    private Auditor getAuditorBookiesAuditor() throws Exception {\n+        BookieServer auditorBookieServer = getAuditorBookie();\n+        String bookieAddr = auditorBookieServer.getLocalAddress().toString();\n+        return auditorElectors.get(bookieAddr).auditor;\n+    }\n+\n     private String  shutDownNonAuditorBookie() throws Exception {\n         // shutdown bookie which is not an auditor\n         int indexOf = bs.indexOf(getAuditorBookie());"}]}