{"sha":"0abf37c64ced0fe49a6470bc0e2be632e47902d6","node_id":"MDY6Q29tbWl0NDc4NTkyNTI2OjBhYmYzN2M2NGNlZDBmZTQ5YTY0NzBiYzBlMmJlNjMyZTQ3OTAyZDY=","commit":{"author":{"name":"Rithin","email":"rithin.shetty@salesforce.com","date":"2016-11-09T02:02:34Z"},"committer":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2016-11-09T02:02:34Z"},"message":"BOOKKEEPER-946: Provide an option to delay auto recovery of lost bookies\n\nIf auto recovery is enabled, and a bookie goes down for upgrade or even if it looses zk connection\nintermittently, the auditor detects it as a lost bookie and starts under replication detection and\nthe replication workers on other bookie nodes start replicating the under replicated ledgers. All\nof this stops once the bookie comes up but by then a few ledgers would get replicated. Given the\nfact that we have multiple copies of data, it is probably not necessary to start the recovery as\nsoon as a bookie goes down. We can wait for an hour or so and then start recovery. This should\ncover cases like planned upgrade, intermittent network connectivity loss, etc.\n\nThis change:\n    1) Provides a bookie option 'lostBookieRecoveryDelay' in secs, which when set to a non zero value,\n       will delay the start of recovery by that number of seconds. By default, this option is set to 0;\n       which means the audit is not delayed.\n    2) If another bookie were to go down in this interval, the recovery is immediately started and the\n       one scheduled for future is canceled.\n    3) Adds counters to track how many audits were delayed(#1) and how many scheduled audits were\n       canceled due to multiple bookie failures(#2).\n    4) Three junit tests to verify the new feature.\n\nAuthor: Rithin <rithin.shetty@salesforce.com>\n\nReviewers: siddharth.boobna@gmail.com <siddharth.boobna@gmail.com>, Enrico Olivelli <eolivelli@gmail.com>\n\nCloses #58 from rithin-shetty/audit_delay","tree":{"sha":"1deaa3134f10ff69b99deb44863dc8de847af52a","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/trees/1deaa3134f10ff69b99deb44863dc8de847af52a"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/commits/0abf37c64ced0fe49a6470bc0e2be632e47902d6","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/0abf37c64ced0fe49a6470bc0e2be632e47902d6","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/0abf37c64ced0fe49a6470bc0e2be632e47902d6","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/0abf37c64ced0fe49a6470bc0e2be632e47902d6/comments","author":{"login":"rithin-shetty","id":19738357,"node_id":"MDQ6VXNlcjE5NzM4MzU3","avatar_url":"https://avatars.githubusercontent.com/u/19738357?v=4","gravatar_id":"","url":"https://api.github.com/users/rithin-shetty","html_url":"https://github.com/rithin-shetty","followers_url":"https://api.github.com/users/rithin-shetty/followers","following_url":"https://api.github.com/users/rithin-shetty/following{/other_user}","gists_url":"https://api.github.com/users/rithin-shetty/gists{/gist_id}","starred_url":"https://api.github.com/users/rithin-shetty/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/rithin-shetty/subscriptions","organizations_url":"https://api.github.com/users/rithin-shetty/orgs","repos_url":"https://api.github.com/users/rithin-shetty/repos","events_url":"https://api.github.com/users/rithin-shetty/events{/privacy}","received_events_url":"https://api.github.com/users/rithin-shetty/received_events","type":"User","site_admin":false},"committer":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"parents":[{"sha":"4383b0b171d5fdfcdfa55c196998bbc6b7fdc260","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/4383b0b171d5fdfcdfa55c196998bbc6b7fdc260","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/4383b0b171d5fdfcdfa55c196998bbc6b7fdc260"}],"stats":{"total":378,"additions":348,"deletions":30},"files":[{"sha":"678018c0ed06191b907f126dc0a63345b8308de4","filename":"bookkeeper-server/conf/bk_server.conf","status":"modified","additions":3,"deletions":0,"changes":3,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/0abf37c64ced0fe49a6470bc0e2be632e47902d6/bookkeeper-server%2Fconf%2Fbk_server.conf","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/0abf37c64ced0fe49a6470bc0e2be632e47902d6/bookkeeper-server%2Fconf%2Fbk_server.conf","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fconf%2Fbk_server.conf?ref=0abf37c64ced0fe49a6470bc0e2be632e47902d6","patch":"@@ -270,6 +270,9 @@ zkTimeout=10000\n # The interval is specified in seconds.\n #auditorPeriodicBookieCheckInterval=86400\n \n+# How long to wait, in seconds, before starting auto recovery of a lost bookie\n+#lostBookieRecoveryDelay=0\n+\n # number of threads that should handle write requests. if zero, the writes would\n # be handled by netty threads directly.\n # numAddWorkerThreads=1"},{"sha":"92644dace5083fe9f8738e4c6712d41003861962","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ServerConfiguration.java","status":"modified","additions":17,"deletions":0,"changes":17,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/0abf37c64ced0fe49a6470bc0e2be632e47902d6/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fconf%2FServerConfiguration.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/0abf37c64ced0fe49a6470bc0e2be632e47902d6/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fconf%2FServerConfiguration.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fconf%2FServerConfiguration.java?ref=0abf37c64ced0fe49a6470bc0e2be632e47902d6","patch":"@@ -103,6 +103,7 @@ public class ServerConfiguration extends AbstractConfiguration {\n     protected final static String AUDITOR_PERIODIC_CHECK_INTERVAL = \"auditorPeriodicCheckInterval\";\n     protected final static String AUDITOR_PERIODIC_BOOKIE_CHECK_INTERVAL = \"auditorPeriodicBookieCheckInterval\";\n     protected final static String AUTO_RECOVERY_DAEMON_ENABLED = \"autoRecoveryDaemonEnabled\";\n+    protected final static String LOST_BOOKIE_RECOVERY_DELAY = \"lostBookieRecoveryDelay\";\n \n     // Worker Thread parameters.\n     protected final static String NUM_ADD_WORKER_THREADS = \"numAddWorkerThreads\";\n@@ -1339,6 +1340,22 @@ public boolean isAutoRecoveryDaemonEnabled() {\n         return getBoolean(AUTO_RECOVERY_DAEMON_ENABLED, false);\n     }\n \n+    /**\n+     * Get how long to delay the recovery of ledgers of a lost bookie.\n+     *\n+     * @return delay interval in seconds\n+     */\n+    public int getLostBookieRecoveryDelay() {\n+        return getInt(LOST_BOOKIE_RECOVERY_DELAY, 0);\n+    }\n+\n+    /**\n+     * Set the delay interval for starting recovery of a lost bookie.\n+     */\n+    public void setLostBookieRecoveryDelay(int interval) {\n+        setProperty(LOST_BOOKIE_RECOVERY_DELAY, interval);\n+    }\n+\n     /**\n      * Sets that whether force start a bookie in readonly mode\n      *"},{"sha":"5a4bdccddb295ba3f37ea54746f3afbb0d63a5e6","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/Auditor.java","status":"modified","additions":95,"deletions":29,"changes":124,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/0abf37c64ced0fe49a6470bc0e2be632e47902d6/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Freplication%2FAuditor.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/0abf37c64ced0fe49a6470bc0e2be632e47902d6/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Freplication%2FAuditor.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Freplication%2FAuditor.java?ref=0abf37c64ced0fe49a6470bc0e2be632e47902d6","patch":"@@ -98,6 +98,10 @@ public class Auditor implements BookiesListener {\n     private final Counter numLedgersChecked;\n     private final OpStatsLogger numFragmentsPerLedger;\n     private final OpStatsLogger numBookiesPerLedger;\n+    private final Counter numBookieAuditsDelayed;\n+    private final Counter numDelayedBookieAuditsCancelled;\n+    private volatile Future<?> auditTask;\n+    private Set<String> bookiesToBeAudited = Sets.newHashSet();\n \n     public Auditor(final String bookieIdentifier, ServerConfiguration conf,\n                    ZooKeeper zkc, StatsLogger statsLogger) throws UnavailableException {\n@@ -106,12 +110,17 @@ public Auditor(final String bookieIdentifier, ServerConfiguration conf,\n         this.statsLogger = statsLogger;\n \n         numUnderReplicatedLedger = this.statsLogger.getOpStatsLogger(ReplicationStats.NUM_UNDER_REPLICATED_LEDGERS);\n-        uRLPublishTimeForLostBookies = this.statsLogger.getOpStatsLogger(ReplicationStats.URL_PUBLISH_TIME_FOR_LOST_BOOKIE);\n-        bookieToLedgersMapCreationTime = this.statsLogger.getOpStatsLogger(ReplicationStats.BOOKIE_TO_LEDGERS_MAP_CREATION_TIME);\n+        uRLPublishTimeForLostBookies = this.statsLogger\n+                .getOpStatsLogger(ReplicationStats.URL_PUBLISH_TIME_FOR_LOST_BOOKIE);\n+        bookieToLedgersMapCreationTime = this.statsLogger\n+                .getOpStatsLogger(ReplicationStats.BOOKIE_TO_LEDGERS_MAP_CREATION_TIME);\n         checkAllLedgersTime = this.statsLogger.getOpStatsLogger(ReplicationStats.CHECK_ALL_LEDGERS_TIME);\n         numLedgersChecked = this.statsLogger.getCounter(ReplicationStats.NUM_LEDGERS_CHECKED);\n         numFragmentsPerLedger = statsLogger.getOpStatsLogger(ReplicationStats.NUM_FRAGMENTS_PER_LEDGER);\n         numBookiesPerLedger = statsLogger.getOpStatsLogger(ReplicationStats.NUM_BOOKIES_PER_LEDGER);\n+        numBookieAuditsDelayed = this.statsLogger.getCounter(ReplicationStats.NUM_BOOKIE_AUDITS_DELAYED);\n+        numDelayedBookieAuditsCancelled = this.statsLogger\n+                .getCounter(ReplicationStats.NUM_DELAYED_BOOKIE_AUDITS_DELAYES_CANCELLED);\n \n         initialize(conf, zkc);\n \n@@ -189,27 +198,64 @@ public void run() {\n                         Collection<String> newBookies = CollectionUtils.subtract(\n                                 availableBookies, knownBookies);\n                         knownBookies.addAll(newBookies);\n+                        if (!bookiesToBeAudited.isEmpty() && knownBookies.containsAll(bookiesToBeAudited)) {\n+                            // the bookie, which went down earlier and had an audit scheduled for,\n+                            // has come up. So let us stop tracking it and cancel the audit. Since\n+                            // we allow delaying of audit when there is only one failed bookie,\n+                            // bookiesToBeAudited should just have 1 element and hence containsAll\n+                            // check should be ok\n+                            if (auditTask != null && auditTask.cancel(false)) {\n+                                auditTask = null;\n+                                numDelayedBookieAuditsCancelled.inc();\n+                            }\n+                            bookiesToBeAudited.clear();\n+                        }\n \n                         // find lost bookies(if any)\n-                        Collection<String> lostBookies = CollectionUtils.subtract(\n-                                knownBookies, availableBookies);\n-\n-                        if (lostBookies.size() > 0) {\n-                            knownBookies.removeAll(lostBookies);\n+                        bookiesToBeAudited.addAll(CollectionUtils.subtract(knownBookies, availableBookies));\n+                        if (bookiesToBeAudited.size() == 0) {\n+                            return;\n+                        }\n \n-                            auditBookies();\n+                        knownBookies.removeAll(bookiesToBeAudited);\n+                        if (conf.getLostBookieRecoveryDelay() == 0) {\n+                            startAudit(false);\n+                            bookiesToBeAudited.clear();\n+                            return;\n+                        }\n+                        if (bookiesToBeAudited.size() > 1) {\n+                            // if more than one bookie is down, start the audit immediately;\n+                            LOG.info(\"Multiple bookie failure; not delaying bookie audit. Bookies lost now: \"\n+                                     + CollectionUtils.subtract(knownBookies, availableBookies)\n+                                     +\"; All lost bookies: \" + bookiesToBeAudited.toString());\n+                            if (auditTask != null && auditTask.cancel(false)) {\n+                                auditTask = null;\n+                                numDelayedBookieAuditsCancelled.inc();\n+                            }\n+                            startAudit(false);\n+                            bookiesToBeAudited.clear();\n+                            return;\n+                        }\n+                        if (auditTask == null) {\n+                            // if there is no scheduled audit, schedule one\n+                            auditTask = executor.schedule( new Runnable() {\n+                                public void run() {\n+                                    startAudit(false);\n+                                    auditTask = null;\n+                                    bookiesToBeAudited.clear();\n+                                }\n+                            }, conf.getLostBookieRecoveryDelay(), TimeUnit.SECONDS);\n+                            numBookieAuditsDelayed.inc();\n+                            LOG.info(\"Delaying bookie audit by \" + conf.getLostBookieRecoveryDelay()\n+                                     + \"secs for \" + bookiesToBeAudited.toString());\n                         }\n                     } catch (BKException bke) {\n                         LOG.error(\"Exception getting bookie list\", bke);\n                     } catch (InterruptedException ie) {\n                         Thread.currentThread().interrupt();\n                         LOG.error(\"Interrupted while watching available bookies \", ie);\n-                    } catch (BKAuditException bke) {\n-                        LOG.error(\"Exception while watching available bookies\", bke);\n                     } catch (UnavailableException ue) {\n                         LOG.error(\"Exception while watching available bookies\", ue);\n-                    } catch (KeeperException ke) {\n-                        LOG.error(\"Exception reading bookie list\", ke);\n                     }\n                 }\n             });\n@@ -231,8 +277,6 @@ public void start() {\n                          + \" 'auditorPeriodicCheckInterval' {} seconds\", interval);\n                 executor.scheduleAtFixedRate(new Runnable() {\n                         public void run() {\n-                            LOG.info(\"Running periodic check\");\n-\n                             try {\n                                 if (!ledgerUnderreplicationManager.isLedgerReplicationEnabled()) {\n                                     LOG.info(\"Ledger replication disabled, skipping\");\n@@ -310,6 +354,35 @@ private void notifyBookieChanges() throws BKException {\n         admin.notifyReadOnlyBookiesChanged(this);\n     }\n \n+    /**\n+     * Start running the actual audit task\n+     *\n+     * @param shutDownTask\n+     *      A boolean that indicates whether or not to schedule shutdown task on any failure\n+     */\n+    private void startAudit(boolean shutDownTask) {\n+        try {\n+            auditBookies();\n+            shutDownTask = false;\n+        } catch (BKException bke) {\n+            LOG.error(\"Exception getting bookie list\", bke);\n+            shutDownTask &= true;\n+        } catch (InterruptedException ie) {\n+            Thread.currentThread().interrupt();\n+            LOG.error(\"Interrupted while watching available bookies \", ie);\n+            shutDownTask &= true;\n+        } catch (BKAuditException bke) {\n+            LOG.error(\"Exception while watching available bookies\", bke);\n+            shutDownTask &= true;\n+        } catch (KeeperException ke) {\n+            LOG.error(\"Exception reading bookie list\", ke);\n+            shutDownTask &= true;\n+        }\n+        if (shutDownTask) {\n+            submitShutdownTask();\n+        }\n+    }\n+\n     @SuppressWarnings(\"unchecked\")\n     private void auditBookies()\n             throws BKAuditException, KeeperException,\n@@ -585,21 +658,14 @@ public boolean isRunning() {\n \n     private final Runnable BOOKIE_CHECK = new Runnable() {\n             public void run() {\n-                try {\n-                    auditBookies();\n-                } catch (BKException bke) {\n-                    LOG.error(\"Couldn't get bookie list, exiting\", bke);\n-                    submitShutdownTask();\n-                } catch (KeeperException ke) {\n-                    LOG.error(\"Exception while watching available bookies\", ke);\n-                    submitShutdownTask();\n-                } catch (InterruptedException ie) {\n-                    Thread.currentThread().interrupt();\n-                    LOG.error(\"Interrupted while watching available bookies \", ie);\n-                    submitShutdownTask();\n-                } catch (BKAuditException bke) {\n-                    LOG.error(\"Exception while watching available bookies\", bke);\n-                    submitShutdownTask();\n+                if (auditTask == null) {\n+                    startAudit(true);\n+                } else {\n+                    // if due to a lost bookie an audit task was scheduled,\n+                    // let us not run this periodic bookie check now, if we\n+                    // went ahead, we'll report under replication and the user\n+                    // wanted to avoid that(with lostBookieRecoveryDelay option)\n+                    LOG.info(\"Audit already scheduled; skipping periodic bookie check\");\n                 }\n             }\n         };"},{"sha":"fb7de209344b6dfcbd9544a0a74848a94e2e60e8","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/replication/ReplicationStats.java","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/0abf37c64ced0fe49a6470bc0e2be632e47902d6/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Freplication%2FReplicationStats.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/0abf37c64ced0fe49a6470bc0e2be632e47902d6/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Freplication%2FReplicationStats.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Freplication%2FReplicationStats.java?ref=0abf37c64ced0fe49a6470bc0e2be632e47902d6","patch":"@@ -33,6 +33,8 @@ public interface ReplicationStats {\n     public final static String NUM_FRAGMENTS_PER_LEDGER = \"NUM_FRAGMENTS_PER_LEDGER\";\n     public final static String NUM_BOOKIES_PER_LEDGER = \"NUM_BOOKIES_PER_LEDGER\";\n     public final static String NUM_LEDGERS_CHECKED = \"NUM_LEDGERS_CHECKED\";\n+    public final static String NUM_BOOKIE_AUDITS_DELAYED = \"NUM_BOOKIE_AUDITS_DELAYED\";\n+    public final static String NUM_DELAYED_BOOKIE_AUDITS_DELAYES_CANCELLED = \"NUM_DELAYED_BOOKIE_AUDITS_CANCELLED\";\n \n     public final static String REPLICATION_WORKER_SCOPE = \"replication_worker\";\n     public final static String REREPLICATE_OP = \"rereplicate\";"},{"sha":"f0a4fedbde4396ec057c880ba050dd1219dc6e2f","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/replication/AuditorLedgerCheckerTest.java","status":"modified","additions":231,"deletions":1,"changes":232,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/0abf37c64ced0fe49a6470bc0e2be632e47902d6/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Freplication%2FAuditorLedgerCheckerTest.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/0abf37c64ced0fe49a6470bc0e2be632e47902d6/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Freplication%2FAuditorLedgerCheckerTest.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Freplication%2FAuditorLedgerCheckerTest.java?ref=0abf37c64ced0fe49a6470bc0e2be632e47902d6","patch":"@@ -26,6 +26,7 @@\n import java.util.Arrays;\n import java.util.HashMap;\n import java.util.HashSet;\n+import java.util.LinkedList;\n import java.util.List;\n import java.util.Map;\n import java.util.Random;\n@@ -39,7 +40,6 @@\n import org.apache.bookkeeper.client.BookKeeper.DigestType;\n import org.apache.bookkeeper.client.LedgerHandle;\n import org.apache.bookkeeper.conf.ServerConfiguration;\n-\n import org.apache.bookkeeper.meta.ZkLedgerUnderreplicationManager;\n import org.apache.bookkeeper.proto.BookieServer;\n import org.apache.bookkeeper.proto.DataFormats.UnderreplicatedLedgerFormat;\n@@ -49,6 +49,7 @@\n import org.apache.zookeeper.KeeperException;\n import org.apache.zookeeper.WatchedEvent;\n import org.apache.zookeeper.Watcher;\n+import org.junit.Assert;\n import org.junit.Before;\n import org.junit.Test;\n import org.slf4j.Logger;\n@@ -79,6 +80,7 @@ public class AuditorLedgerCheckerTest extends MultiLedgerManagerTestCase {\n     private HashMap<String, AuditorElector> auditorElectors = new HashMap<String, AuditorElector>();\n     private ZkLedgerUnderreplicationManager urLedgerMgr;\n     private Set<Long> urLedgerList;\n+    private String electionPath;\n \n     private List<Long> ledgerList;\n \n@@ -93,6 +95,8 @@ public AuditorLedgerCheckerTest(String ledgerManagerFactoryClass)\n         baseConf.setLedgerManagerFactoryClassName(ledgerManagerFactoryClass);\n         baseClientConf\n                 .setLedgerManagerFactoryClassName(ledgerManagerFactoryClass);\n+        electionPath = baseConf.getZkLedgersRootPath()\n+                + \"/underreplication/auditorelection\";\n     }\n \n     @Before\n@@ -321,6 +325,188 @@ public void testReadOnlyBookieShutdown() throws Exception {\n                 data.contains(shutdownBookie));\n     }\n \n+    public void _testDelayedAuditOfLostBookies() throws Exception {\n+        LedgerHandle lh1 = createAndAddEntriesToLedger();\n+        Long ledgerId = lh1.getId();\n+        LOG.debug(\"Created ledger : \" + ledgerId);\n+        ledgerList.add(ledgerId);\n+        lh1.close();\n+\n+        final CountDownLatch underReplicaLatch = registerUrLedgerWatcher(ledgerList\n+                .size());\n+\n+        // wait for 5 seconds before starting the recovery work when a bookie fails\n+        baseConf.setLostBookieRecoveryDelay(5);\n+\n+        // shutdown a non auditor bookie; choosing non-auditor to avoid another election\n+        String shutdownBookie = shutDownNonAuditorBookie();\n+\n+        LOG.debug(\"Waiting for ledgers to be marked as under replicated\");\n+        assertFalse(\"audit of lost bookie isn't delayed\", underReplicaLatch.await(4, TimeUnit.SECONDS));\n+        assertEquals(\"under replicated ledgers identified when it was not expected\", 0,\n+                urLedgerList.size());\n+\n+        // wait for another 5 seconds for the ledger to get reported as under replicated\n+        assertTrue(\"audit of lost bookie isn't delayed\", underReplicaLatch.await(2, TimeUnit.SECONDS));\n+\n+        assertTrue(\"Ledger is not marked as underreplicated:\" + ledgerId,\n+                urLedgerList.contains(ledgerId));\n+        Map<Long, String> urLedgerData = getUrLedgerData(urLedgerList);\n+        String data = urLedgerData.get(ledgerId);\n+        assertTrue(\"Bookie \" + shutdownBookie\n+                + \"is not listed in the ledger as missing replica :\" + data,\n+                data.contains(shutdownBookie));\n+    }\n+\n+    /**\n+     * Test publishing of under replicated ledgers by the auditor\n+     * bookie is delayed if LostBookieRecoveryDelay option is set\n+     */\n+    @Test(timeout=60000)\n+    public void testDelayedAuditOfLostBookies() throws Exception {\n+        _testDelayedAuditOfLostBookies();\n+    }\n+\n+    /**\n+     * Test publishing of under replicated ledgers by the auditor\n+     * bookie is delayed if LostBookieRecoveryDelay option is set\n+     * and it continues to be delayed even when periodic bookie check\n+     *  is set to run every 2 secs. I.e. periodic bookie check doesn't\n+     *  override the delay\n+     */\n+    @Test(timeout=60000)\n+    public void testDelayedAuditWithPeriodicBookieCheck() throws Exception {\n+        // enable periodic bookie check on a cadence of every 2 seconds.\n+        // this requires us to stop the auditor/auditorElectors, set the\n+        // periodic check interval and restart the auditorElectors\n+        stopAuditorElectors();\n+        baseConf.setAuditorPeriodicBookieCheckInterval(2);\n+        startAuditorElectors();\n+\n+        // wait for a second so that the initial periodic check finishes\n+        Thread.sleep(1000);\n+\n+        // the delaying of audit should just work despite the fact\n+        // we have enabled periodic bookie check\n+        _testDelayedAuditOfLostBookies();\n+    }\n+\n+    /**\n+     * Test audit of bookies is delayed when one bookie is down. But when\n+     * another one goes down, the audit is started immediately.\n+     */\n+    @Test(timeout=60000)\n+    public void testDelayedAuditWithMultipleBookieFailures() throws Exception {\n+        // wait for the periodic bookie check to finish\n+        Thread.sleep(1000);\n+\n+        // create a ledger with a bunch of entries\n+        LedgerHandle lh1 = createAndAddEntriesToLedger();\n+        Long ledgerId = lh1.getId();\n+        LOG.debug(\"Created ledger : \" + ledgerId);\n+        ledgerList.add(ledgerId);\n+        lh1.close();\n+\n+        CountDownLatch underReplicaLatch = registerUrLedgerWatcher(ledgerList.size());\n+\n+        // wait for 10 seconds before starting the recovery work when a bookie fails\n+        baseConf.setLostBookieRecoveryDelay(10);\n+\n+        // shutdown a non auditor bookie to avoid an election\n+        String shutdownBookie1 = shutDownNonAuditorBookie();\n+\n+        // wait for 3 seconds and there shouldn't be any under replicated ledgers\n+        // because we have delayed the start of audit by 10 seconds\n+        assertFalse(\"audit of lost bookie isn't delayed\", underReplicaLatch.await(3, TimeUnit.SECONDS));\n+        assertEquals(\"under replicated ledgers identified when it was not expected\", 0,\n+                urLedgerList.size());\n+\n+        // Now shutdown the second non auditor bookie; We want to make sure that\n+        // the history about having delayed recovery remains. Hence we make sure\n+        // we bring down a non auditor bookie. This should cause the audit to take\n+        // place immediately and not wait for the remaining 7 seconds to elapse\n+        String shutdownBookie2 = shutDownNonAuditorBookie();\n+\n+        // 2 second grace period for the ledgers to get reported as under replicated\n+        Thread.sleep(2000);\n+\n+        // If the following checks pass, it means that audit happened\n+        // within 2 seconds of second bookie going down and it didn't\n+        // wait for 7 more seconds. Hence the second bookie failure doesn't\n+        // delay the audit\n+        assertTrue(\"Ledger is not marked as underreplicated:\" + ledgerId,\n+                urLedgerList.contains(ledgerId));\n+        Map<Long, String> urLedgerData = getUrLedgerData(urLedgerList);\n+        String data = urLedgerData.get(ledgerId);\n+        assertTrue(\"Bookie \" + shutdownBookie1 + shutdownBookie2\n+                + \" are not listed in the ledger as missing replicas :\" + data,\n+                data.contains(shutdownBookie1) && data.contains(shutdownBookie2));\n+    }\n+\n+    /**\n+     * Test audit of bookies is delayed during rolling upgrade scenario:\n+     * a bookies goes down and comes up, the next bookie go down and up and so on.\n+     * At any time only one bookie is down.\n+     */\n+    @Test(timeout=60000)\n+    public void testDelayedAuditWithRollingUpgrade() throws Exception {\n+        // wait for the periodic bookie check to finish\n+        Thread.sleep(1000);\n+\n+        // create a ledger with a bunch of entries\n+        LedgerHandle lh1 = createAndAddEntriesToLedger();\n+        Long ledgerId = lh1.getId();\n+        LOG.debug(\"Created ledger : \" + ledgerId);\n+        ledgerList.add(ledgerId);\n+        lh1.close();\n+\n+        CountDownLatch underReplicaLatch = registerUrLedgerWatcher(ledgerList.size());\n+\n+        // wait for 5 seconds before starting the recovery work when a bookie fails\n+        baseConf.setLostBookieRecoveryDelay(5);\n+\n+        // shutdown a non auditor bookie to avoid an election\n+        int idx1 = getShutDownNonAuditorBookieIdx(\"\");\n+        ServerConfiguration conf1 = bsConfs.get(idx1);\n+        String shutdownBookie1 = shutdownBookie(idx1);\n+\n+        // wait for 2 seconds and there shouldn't be any under replicated ledgers\n+        // because we have delayed the start of audit by 5 seconds\n+        assertFalse(\"audit of lost bookie isn't delayed\", underReplicaLatch.await(2, TimeUnit.SECONDS));\n+        assertEquals(\"under replicated ledgers identified when it was not expected\", 0,\n+                urLedgerList.size());\n+\n+        // restart the bookie we shut down above\n+        bs.add(startBookie(conf1));\n+\n+        // Now to simulate the rolling upgrade, bring down a bookie different from\n+        // the one we brought down/up above.\n+        String shutdownBookie2 = shutDownNonAuditorBookie(shutdownBookie1);\n+\n+        // since the first bookie that was brought down/up has come up, there is only\n+        // one bookie down at this time. Hence the lost bookie check shouldn't start\n+        // immediately; it will start 5 seconds after the second bookie went down\n+        assertFalse(\"audit of lost bookie isn't delayed\", underReplicaLatch.await(2, TimeUnit.SECONDS));\n+        assertEquals(\"under replicated ledgers identified when it was not expected\", 0,\n+                urLedgerList.size());\n+\n+        // wait for a total of 6 seconds(2+4) for the ledgers to get reported as under replicated\n+        Thread.sleep(4000);\n+\n+        // If the following checks pass, it means that auditing happened\n+        // after lostBookieRecoveryDelay during rolling upgrade as expected\n+        assertTrue(\"Ledger is not marked as underreplicated:\" + ledgerId,\n+                urLedgerList.contains(ledgerId));\n+        Map<Long, String> urLedgerData = getUrLedgerData(urLedgerList);\n+        String data = urLedgerData.get(ledgerId);\n+        assertTrue(\"Bookie \" + shutdownBookie1 + \"wrongly listed as missing the ledger: \" + data,\n+                   !data.contains(shutdownBookie1));\n+        assertTrue(\"Bookie \" + shutdownBookie2\n+                   + \" is not listed in the ledger as missing replicas :\" + data,\n+                   data.contains(shutdownBookie2));\n+        LOG.info(\"*****************Test Complete\");\n+    }\n+\n     /**\n      * Wait for ledger to be underreplicated, and to be missing all replicas specified\n      */\n@@ -442,4 +628,48 @@ public void process(WatchedEvent event) {\n             underReplicaLatch.countDown();\n         }\n     }\n+\n+    private BookieServer getAuditorBookie() throws Exception {\n+        List<BookieServer> auditors = new LinkedList<BookieServer>();\n+        byte[] data = zkc.getData(electionPath, false, null);\n+        Assert.assertNotNull(\"Auditor election failed\", data);\n+        for (BookieServer bks : bs) {\n+            if (new String(data).contains(bks.getLocalAddress().getPort() + \"\")) {\n+                auditors.add(bks);\n+            }\n+        }\n+        Assert.assertEquals(\"Multiple Bookies acting as Auditor!\", 1, auditors\n+                .size());\n+        return auditors.get(0);\n+    }\n+\n+    private String  shutDownNonAuditorBookie() throws Exception {\n+        // shutdown bookie which is not an auditor\n+        int indexOf = bs.indexOf(getAuditorBookie());\n+        int bkIndexDownBookie;\n+        if (indexOf < bs.size() - 1) {\n+            bkIndexDownBookie = indexOf + 1;\n+        } else {\n+            bkIndexDownBookie = indexOf - 1;\n+        }\n+        return shutdownBookie(bkIndexDownBookie);\n+    }\n+\n+    private int getShutDownNonAuditorBookieIdx(String exclude) throws Exception {\n+        // shutdown bookie which is not an auditor\n+        int indexOf = bs.indexOf(getAuditorBookie());\n+        int bkIndexDownBookie = 0;\n+        for (int i = 0; i < bs.size(); i++) {\n+            if (i == indexOf || bs.get(i).getLocalAddress().toString().equals(exclude)) {\n+                continue;\n+            }\n+            bkIndexDownBookie = i;\n+            break;\n+        }\n+        return bkIndexDownBookie;\n+    }\n+\n+    private String shutDownNonAuditorBookie(String exclude) throws Exception {\n+        return shutdownBookie(getShutDownNonAuditorBookieIdx(exclude));\n+    }\n }"}]}