{"sha":"90a8f283999ddbfee818629e1be17102e63be22c","node_id":"MDY6Q29tbWl0NDc4NTkyNTI2OjkwYThmMjgzOTk5ZGRiZmVlODE4NjI5ZTFiZTE3MTAyZTYzYmUyMmM=","commit":{"author":{"name":"Sijie Guo","email":"sijieg@twitter.com","date":"2017-06-21T17:50:23Z"},"committer":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2017-06-21T17:50:23Z"},"message":"BOOKKEEPER-1089: Ledger Recovery (part-4) - allow batch reads in ledger recovery\n\nThis change is based on #178 - (you can review git sha 82f73ef)\n\nbookkeeper recovery improvement (part-4): allow batch reading in ledger recovery\n\n    - enable batch read in ledger recovery, so we could parallel reading to improve recovery time.\n\n    RB_ID=266145\n\nAuthor: Sijie Guo <sijieg@twitter.com>\nAuthor: Sijie Guo <sijie@apache.org>\n\nReviewers: Enrico Olivelli <eolivelli@gmail.com>, Jia Zhai <None>, Matteo Merli <mmerli@apache.org>\n\nThis closes #181 from sijie/recovery_improvements_part4","tree":{"sha":"5c706e13539ce1a64007f2cc50afa4ca66dbc394","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/trees/5c706e13539ce1a64007f2cc50afa4ca66dbc394"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/commits/90a8f283999ddbfee818629e1be17102e63be22c","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/90a8f283999ddbfee818629e1be17102e63be22c","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/90a8f283999ddbfee818629e1be17102e63be22c","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/90a8f283999ddbfee818629e1be17102e63be22c/comments","author":null,"committer":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"parents":[{"sha":"363c5d00b847b7eb2a93826b6d947fd3180a37dd","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/363c5d00b847b7eb2a93826b6d947fd3180a37dd","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/363c5d00b847b7eb2a93826b6d947fd3180a37dd"}],"stats":{"total":298,"additions":234,"deletions":64},"files":[{"sha":"acc9f0a4f3db6e9884dae3c73f39381616bb8f8d","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeper.java","status":"modified","additions":6,"deletions":1,"changes":7,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/90a8f283999ddbfee818629e1be17102e63be22c/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookKeeper.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/90a8f283999ddbfee818629e1be17102e63be22c/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookKeeper.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookKeeper.java?ref=90a8f283999ddbfee818629e1be17102e63be22c","patch":"@@ -102,7 +102,8 @@ public class BookKeeper implements AutoCloseable {\n     private OpStatsLogger addOpLogger;\n     private OpStatsLogger writeLacOpLogger;\n     private OpStatsLogger readLacOpLogger;\n-\n+    private OpStatsLogger recoverAddEntriesStats;\n+    private OpStatsLogger recoverReadEntriesStats;\n \n     // whether the event loop group is one we created, or is owned by whoever\n     // instantiated us\n@@ -1246,6 +1247,8 @@ private final void initOpLoggers(StatsLogger stats) {\n         addOpLogger = stats.getOpStatsLogger(BookKeeperClientStats.ADD_OP);\n         writeLacOpLogger = stats.getOpStatsLogger(BookKeeperClientStats.WRITE_LAC_OP);\n         readLacOpLogger = stats.getOpStatsLogger(BookKeeperClientStats.READ_LAC_OP);\n+        recoverAddEntriesStats = stats.getOpStatsLogger(BookKeeperClientStats.LEDGER_RECOVER_ADD_ENTRIES);\n+        recoverReadEntriesStats = stats.getOpStatsLogger(BookKeeperClientStats.LEDGER_RECOVER_READ_ENTRIES);\n     }\n \n     OpStatsLogger getCreateOpLogger() { return createOpLogger; }\n@@ -1255,6 +1258,8 @@ private final void initOpLoggers(StatsLogger stats) {\n     OpStatsLogger getAddOpLogger() { return addOpLogger; }\n     OpStatsLogger getWriteLacOpLogger() { return writeLacOpLogger; }\n     OpStatsLogger getReadLacOpLogger() { return readLacOpLogger; }\n+    OpStatsLogger getRecoverAddCountLogger() { return recoverAddEntriesStats; }\n+    OpStatsLogger getRecoverReadCountLogger() { return recoverReadEntriesStats; }\n \n     static EventLoopGroup getDefaultEventLoopGroup() {\n         ThreadFactory threadFactory = new ThreadFactoryBuilder().setNameFormat(\"bookkeeper-io-%s\").build();"},{"sha":"6166c9538b6635baf1efd23483d881d64f11ac38","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeperClientStats.java","status":"modified","additions":8,"deletions":0,"changes":8,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/90a8f283999ddbfee818629e1be17102e63be22c/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookKeeperClientStats.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/90a8f283999ddbfee818629e1be17102e63be22c/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookKeeperClientStats.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookKeeperClientStats.java?ref=90a8f283999ddbfee818629e1be17102e63be22c","patch":"@@ -23,9 +23,17 @@\n \n public interface BookKeeperClientStats {\n     public final static String CLIENT_SCOPE = \"bookkeeper_client\";\n+\n+    // Metadata Operations\n+\n     public final static String CREATE_OP = \"LEDGER_CREATE\";\n     public final static String DELETE_OP = \"LEDGER_DELETE\";\n     public final static String OPEN_OP = \"LEDGER_OPEN\";\n+    public final static String LEDGER_RECOVER_READ_ENTRIES = \"LEDGER_RECOVER_READ_ENTRIES\";\n+    public final static String LEDGER_RECOVER_ADD_ENTRIES = \"LEDGER_RECOVER_ADD_ENTRIES\";\n+\n+    // Data Operations\n+\n     public final static String ADD_OP = \"ADD_ENTRY\";\n     public final static String READ_OP = \"READ_ENTRY\";\n     public final static String WRITE_LAC_OP = \"WRITE_LAC\";"},{"sha":"7a9d81b879cc8a22bdd464dca354f3c2876dc280","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerHandle.java","status":"modified","additions":16,"deletions":20,"changes":36,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/90a8f283999ddbfee818629e1be17102e63be22c/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FLedgerHandle.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/90a8f283999ddbfee818629e1be17102e63be22c/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FLedgerHandle.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FLedgerHandle.java?ref=90a8f283999ddbfee818629e1be17102e63be22c","patch":"@@ -21,9 +21,11 @@\n package org.apache.bookkeeper.client;\n \n import static com.google.common.base.Charsets.UTF_8;\n+\n+import com.google.common.collect.Sets;\n+import com.google.common.util.concurrent.RateLimiter;\n import io.netty.buffer.ByteBuf;\n import io.netty.buffer.Unpooled;\n-\n import java.security.GeneralSecurityException;\n import java.security.NoSuchAlgorithmException;\n import java.util.ArrayList;\n@@ -39,7 +41,6 @@\n import java.util.concurrent.RejectedExecutionException;\n import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicInteger;\n-\n import org.apache.bookkeeper.client.AsyncCallback.AddCallback;\n import org.apache.bookkeeper.client.AsyncCallback.AddLacCallback;\n import org.apache.bookkeeper.client.AsyncCallback.CloseCallback;\n@@ -57,9 +58,6 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import com.google.common.collect.Sets;\n-import com.google.common.util.concurrent.RateLimiter;\n-\n /**\n  * Ledger handle contains ledger metadata and is used to access the read and\n  * write operations to a ledger.\n@@ -594,12 +592,8 @@ public void asyncReadUnconfirmedEntries(long firstEntry, long lastEntry, ReadCal\n     }\n \n     void asyncReadEntriesInternal(long firstEntry, long lastEntry, ReadCallback cb, Object ctx) {\n-        try {\n-            new PendingReadOp(this, bk.scheduler,\n-                              firstEntry, lastEntry, cb, ctx).initiate();\n-        } catch (InterruptedException e) {\n-            cb.readComplete(BKException.Code.InterruptedException, this, null, ctx);\n-        }\n+        new PendingReadOp(this, bk.scheduler,\n+                          firstEntry, lastEntry, cb, ctx).initiate();\n     }\n \n     /**\n@@ -1478,7 +1472,9 @@ void recover(final GenericCallback<Void> cb) {\n             // if metadata is already in recover, dont try to write again,\n             // just do the recovery from the starting point\n             new LedgerRecoveryOp(LedgerHandle.this, cb)\n-                    .parallelRead(bk.getConf().getEnableParallelRecoveryRead()).initiate();\n+                    .parallelRead(bk.getConf().getEnableParallelRecoveryRead())\n+                    .readBatchSize(bk.getConf().getRecoveryReadBatchSize())\n+                    .initiate();\n             return;\n         }\n \n@@ -1505,7 +1501,9 @@ public String toString() {\n                     });\n                 } else if (rc == BKException.Code.OK) {\n                     new LedgerRecoveryOp(LedgerHandle.this, cb)\n-                            .parallelRead(bk.getConf().getEnableParallelRecoveryRead()).initiate();\n+                            .parallelRead(bk.getConf().getEnableParallelRecoveryRead())\n+                            .readBatchSize(bk.getConf().getRecoveryReadBatchSize())\n+                            .initiate();\n                 } else {\n                     LOG.error(\"Error writing ledger config \" + rc + \" of ledger \" + ledgerId);\n                     cb.operationComplete(rc, null);\n@@ -1538,10 +1536,8 @@ static class LastAddConfirmedCallback implements AddLacCallback {\n          *\n          * @param rc\n          *          return code\n-         * @param leder\n+         * @param lh\n          *          ledger identifier\n-         * @param entry\n-         *          entry identifier\n          * @param ctx\n          *          control object\n          */\n@@ -1563,8 +1559,8 @@ static class SyncReadCallback implements ReadCallback {\n          *\n          * @param rc\n          *          return code\n-         * @param leder\n-         *          ledger identifier\n+         * @param lh\n+         *          ledger handle\n          * @param seq\n          *          sequence of entries\n          * @param ctx\n@@ -1585,8 +1581,8 @@ static class SyncAddCallback implements AddCallback {\n          *\n          * @param rc\n          *          return code\n-         * @param leder\n-         *          ledger identifier\n+         * @param lh\n+         *          ledger handle\n          * @param entry\n          *          entry identifier\n          * @param ctx"},{"sha":"cc19dc9d8aaf0164f3e36d278038b8c941beaadf","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerRecoveryOp.java","status":"modified","additions":95,"deletions":37,"changes":132,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/90a8f283999ddbfee818629e1be17102e63be22c/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FLedgerRecoveryOp.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/90a8f283999ddbfee818629e1be17102e63be22c/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FLedgerRecoveryOp.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FLedgerRecoveryOp.java?ref=90a8f283999ddbfee818629e1be17102e63be22c","patch":"@@ -1,5 +1,3 @@\n-package org.apache.bookkeeper.client;\n-\n /**\n  * Licensed to the Apache Software Foundation (ASF) under one\n  * or more contributor license agreements.  See the NOTICE file\n@@ -17,18 +15,18 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n+package org.apache.bookkeeper.client;\n \n-import java.util.Enumeration;\n+import com.google.common.annotations.VisibleForTesting;\n import java.util.concurrent.ScheduledExecutorService;\n import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicLong;\n \n import org.apache.bookkeeper.client.AsyncCallback.AddCallback;\n import org.apache.bookkeeper.client.AsyncCallback.CloseCallback;\n-import org.apache.bookkeeper.client.AsyncCallback.ReadCallback;\n import org.apache.bookkeeper.client.DigestManager.RecoveryData;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n-import org.apache.zookeeper.KeeperException;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ReadEntryListener;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -40,23 +38,31 @@\n  * the ledger at that entry.\n  *\n  */\n-class LedgerRecoveryOp implements ReadCallback, AddCallback {\n+class LedgerRecoveryOp implements ReadEntryListener, AddCallback {\n+\n     static final Logger LOG = LoggerFactory.getLogger(LedgerRecoveryOp.class);\n-    LedgerHandle lh;\n-    AtomicLong readCount, writeCount;\n-    AtomicBoolean readDone;\n-    AtomicBoolean callbackDone;\n-    long entryToRead;\n+\n+    final LedgerHandle lh;\n+    final AtomicLong readCount, writeCount;\n+    final AtomicBoolean readDone;\n+    final AtomicBoolean callbackDone;\n+    volatile long startEntryToRead;\n+    volatile long endEntryToRead;\n+    final GenericCallback<Void> cb;\n     // keep a copy of metadata for recovery.\n     LedgerMetadata metadataForRecovery;\n     boolean parallelRead = false;\n+    int readBatchSize = 1;\n \n-    GenericCallback<Void> cb;\n+    // EntryListener Hook\n+    @VisibleForTesting\n+    ReadEntryListener entryListener = null;\n \n-    class RecoveryReadOp extends PendingReadOp {\n+    class RecoveryReadOp extends ListenerBasedPendingReadOp {\n \n-        RecoveryReadOp(LedgerHandle lh, ScheduledExecutorService scheduler, long startEntryId,\n-                long endEntryId, ReadCallback cb, Object ctx) {\n+        RecoveryReadOp(LedgerHandle lh, ScheduledExecutorService scheduler,\n+                       long startEntryId, long endEntryId,\n+                       ReadEntryListener cb, Object ctx) {\n             super(lh, scheduler, startEntryId, endEntryId, cb, ctx);\n         }\n \n@@ -81,22 +87,40 @@ LedgerRecoveryOp parallelRead(boolean enabled) {\n         return this;\n     }\n \n+    LedgerRecoveryOp readBatchSize(int batchSize) {\n+        this.readBatchSize = batchSize;\n+        return this;\n+    }\n+\n+    /**\n+     * Set an entry listener to listen on individual recovery reads during recovery procedure.\n+     *\n+     * @param entryListener\n+     *          entry listener\n+     * @return ledger recovery operation\n+     */\n+    @VisibleForTesting\n+    LedgerRecoveryOp setEntryListener(ReadEntryListener entryListener) {\n+        this.entryListener = entryListener;\n+        return this;\n+    }\n+\n     public void initiate() {\n         ReadLastConfirmedOp rlcop = new ReadLastConfirmedOp(lh,\n                 new ReadLastConfirmedOp.LastConfirmedDataCallback() {\n                     public void readLastConfirmedDataComplete(int rc, RecoveryData data) {\n                         if (rc == BKException.Code.OK) {\n                             lh.lastAddPushed = lh.lastAddConfirmed = data.lastAddConfirmed;\n                             lh.length = data.length;\n-                            entryToRead = lh.lastAddConfirmed;\n+                            startEntryToRead = endEntryToRead = lh.lastAddConfirmed;\n                             // keep a copy of ledger metadata before proceeding\n                             // ledger recovery\n                             metadataForRecovery = new LedgerMetadata(lh.getLedgerMetadata());\n                             doRecoveryRead();\n                         } else if (rc == BKException.Code.UnauthorizedAccessException) {\n-                            cb.operationComplete(rc, null);\n+                            submitCallback(rc);\n                         } else {\n-                            cb.operationComplete(BKException.Code.ReadException, null);\n+                            submitCallback(BKException.Code.ReadException);\n                         }\n                     }\n                 });\n@@ -109,17 +133,26 @@ public void readLastConfirmedDataComplete(int rc, RecoveryData data) {\n         rlcop.initiateWithFencing();\n     }\n \n+    private void submitCallback(int rc) {\n+        if (BKException.Code.OK == rc) {\n+            lh.bk.getRecoverAddCountLogger().registerSuccessfulValue(writeCount.get());\n+            lh.bk.getRecoverReadCountLogger().registerSuccessfulValue(readCount.get());\n+        } else {\n+            lh.bk.getRecoverAddCountLogger().registerFailedValue(writeCount.get());\n+            lh.bk.getRecoverReadCountLogger().registerFailedValue(readCount.get());\n+        }\n+        cb.operationComplete(rc, null);\n+    }\n+\n     /**\n      * Try to read past the last confirmed.\n      */\n     private void doRecoveryRead() {\n         if (!callbackDone.get()) {\n-            entryToRead++;\n-            try {\n-                new RecoveryReadOp(lh, lh.bk.scheduler, entryToRead, entryToRead, this, null).parallelRead(parallelRead).initiate();\n-            } catch (InterruptedException e) {\n-                readComplete(BKException.Code.InterruptedException, lh, null, null);\n-            }\n+            startEntryToRead = endEntryToRead + 1;\n+            endEntryToRead = endEntryToRead + readBatchSize;\n+            new RecoveryReadOp(lh, lh.bk.scheduler, startEntryToRead, endEntryToRead, this, null)\n+                    .parallelRead(parallelRead).initiate();\n         }\n     }\n \n@@ -131,9 +164,9 @@ public void closeComplete(int rc, LedgerHandle lh, Object ctx) {\n                     if (rc != BKException.Code.OK) {\n                         LOG.warn(\"Close ledger {} failed during recovery: \",\n                             LedgerRecoveryOp.this.lh.getId(), BKException.getMessage(rc));\n-                        cb.operationComplete(rc, null);\n+                        submitCallback(rc);\n                     } else {\n-                        cb.operationComplete(BKException.Code.OK, null);\n+                        submitCallback(BKException.Code.OK);\n                         if (LOG.isDebugEnabled()) {\n                             LOG.debug(\"After closing length is: {}\", lh.getLength());\n                         }\n@@ -144,10 +177,16 @@ public void closeComplete(int rc, LedgerHandle lh, Object ctx) {\n     }\n \n     @Override\n-    public void readComplete(int rc, LedgerHandle lh, Enumeration<LedgerEntry> seq, Object ctx) {\n-        if (rc == BKException.Code.OK) {\n+    public void onEntryComplete(int rc, LedgerHandle lh, LedgerEntry entry, Object ctx) {\n+        // notify entry listener on individual entries being read during ledger recovery.\n+        ReadEntryListener listener = entryListener;\n+        if (null != listener) {\n+            listener.onEntryComplete(rc, lh, entry, ctx);\n+        }\n+\n+        // we only trigger recovery add an entry when readDone == false && callbackDone == false\n+        if (!callbackDone.get() && !readDone.get() && rc == BKException.Code.OK) {\n             readCount.incrementAndGet();\n-            LedgerEntry entry = seq.nextElement();\n             byte[] data = entry.getEntry();\n \n             /*\n@@ -157,12 +196,24 @@ public void readComplete(int rc, LedgerHandle lh, Enumeration<LedgerEntry> seq,\n              */\n             synchronized (lh) {\n                 lh.length = entry.getLength() - (long) data.length;\n+                // check whether entry id is expected, so we won't overwritten any entries by mistake\n+                if (entry.getEntryId() != lh.lastAddPushed + 1) {\n+                    LOG.error(\"Unexpected to recovery add entry {} as entry {} for ledger {}.\",\n+                              new Object[] { entry.getEntryId(), (lh.lastAddPushed + 1), lh.getId() });\n+                    rc = BKException.Code.UnexpectedConditionException;\n+                }\n+            }\n+            if (BKException.Code.OK == rc) {\n+                lh.asyncRecoveryAddEntry(data, 0, data.length, this, null);\n+                if (entry.getEntryId() == endEntryToRead) {\n+                    // trigger next batch read\n+                    doRecoveryRead();\n+                }\n+                return;\n             }\n-            lh.asyncRecoveryAddEntry(data, 0, data.length, this, null);\n-            doRecoveryRead();\n-            return;\n         }\n \n+        // no entry found. stop recovery procedure but wait until recovery add finished.\n         if (rc == BKException.Code.NoSuchEntryException || rc == BKException.Code.NoSuchLedgerExistsException) {\n             readDone.set(true);\n             if (readCount.get() == writeCount.get()) {\n@@ -172,20 +223,27 @@ public void readComplete(int rc, LedgerHandle lh, Enumeration<LedgerEntry> seq,\n         }\n \n         // otherwise, some other error, we can't handle\n-        LOG.error(\"Failure \" + BKException.getMessage(rc) + \" while reading entry: \" + entryToRead\n-                  + \" ledger: \" + lh.ledgerId + \" while recovering ledger\");\n-        cb.operationComplete(rc, null);\n+        if (BKException.Code.OK != rc && callbackDone.compareAndSet(false, true)) {\n+            LOG.error(\"Failure {} while reading entries: ({} - {}), ledger: {} while recovering ledger\",\n+                      new Object[] { BKException.getMessage(rc), startEntryToRead, endEntryToRead, lh.getId() });\n+            submitCallback(rc);\n+        } else if (BKException.Code.OK == rc) {\n+            // we are here is because we successfully read an entry but readDone was already set to true.\n+            // this would happen on recovery a ledger than has gaps in the tail.\n+            LOG.warn(\"Successfully read entry {} for ledger {}, but readDone is already {}\",\n+                     new Object[] { entry.getEntryId(), lh.getId(), readDone.get() });\n+        }\n         return;\n     }\n \n     @Override\n     public void addComplete(int rc, LedgerHandle lh, long entryId, Object ctx) {\n         if (rc != BKException.Code.OK) {\n-            LOG.error(\"Failure \" + BKException.getMessage(rc) + \" while writing entry: \" + (lh.lastAddConfirmed + 1)\n+            LOG.error(\"Failure \" + BKException.getMessage(rc) + \" while writing entry: \" + (entryId + 1)\n                       + \" ledger: \" + lh.ledgerId + \" while recovering ledger\");\n             if (callbackDone.compareAndSet(false, true)) {\n                 // Give up, we can't recover from this error\n-                cb.operationComplete(rc, null);\n+                submitCallback(rc);\n             }\n             return;\n         }"},{"sha":"01922968915283d702cbb3b749678544d27d15d9","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingReadOp.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/90a8f283999ddbfee818629e1be17102e63be22c/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FPendingReadOp.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/90a8f283999ddbfee818629e1be17102e63be22c/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FPendingReadOp.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FPendingReadOp.java?ref=90a8f283999ddbfee818629e1be17102e63be22c","patch":"@@ -428,7 +428,7 @@ PendingReadOp parallelRead(boolean enabled) {\n         return this;\n     }\n \n-    public void initiate() throws InterruptedException {\n+    public void initiate() {\n         long nextEnsembleChange = startEntryId, i = startEntryId;\n         this.requestTimeNanos = MathUtils.nowInNano();\n         ArrayList<BookieSocketAddress> ensemble = null;"},{"sha":"311fb82e90382f8300e0db2266982b3f50b929ec","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ClientConfiguration.java","status":"modified","additions":22,"deletions":0,"changes":22,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/90a8f283999ddbfee818629e1be17102e63be22c/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fconf%2FClientConfiguration.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/90a8f283999ddbfee818629e1be17102e63be22c/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fconf%2FClientConfiguration.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fconf%2FClientConfiguration.java?ref=90a8f283999ddbfee818629e1be17102e63be22c","patch":"@@ -63,6 +63,7 @@ public class ClientConfiguration extends AbstractConfiguration {\n     protected final static String READ_TIMEOUT = \"readTimeout\";\n     protected final static String SPECULATIVE_READ_TIMEOUT = \"speculativeReadTimeout\";\n     protected final static String ENABLE_PARALLEL_RECOVERY_READ = \"enableParallelRecoveryRead\";\n+    protected final static String RECOVERY_READ_BATCH_SIZE = \"recoveryReadBatchSize\";\n     // Timeout Setting\n     protected final static String ADD_ENTRY_TIMEOUT_SEC = \"addEntryTimeoutSec\";\n     protected final static String ADD_ENTRY_QUORUM_TIMEOUT_SEC = \"addEntryQuorumTimeoutSec\";\n@@ -814,6 +815,27 @@ public ClientConfiguration setEnableParallelRecoveryRead(boolean enabled) {\n         return this;\n     }\n \n+    /**\n+     * Get Recovery Read Batch Size.\n+     *\n+     * @return recovery read batch size.\n+     */\n+    public int getRecoveryReadBatchSize() {\n+        return getInt(RECOVERY_READ_BATCH_SIZE, 1);\n+    }\n+\n+    /**\n+     * Set Recovery Read Batch Size.\n+     *\n+     * @param batchSize\n+     *          recovery read batch size.\n+     * @return client configuration.\n+     */\n+    public ClientConfiguration setRecoveryReadBatchSize(int batchSize) {\n+        setProperty(RECOVERY_READ_BATCH_SIZE, batchSize);\n+        return this;\n+    }\n+\n     /**\n      * Get Ensemble Placement Policy Class.\n      *"},{"sha":"2b39eaf7825c27d8b663260e31e7f67f07f81f8a","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/LedgerRecoveryTest.java","status":"modified","additions":86,"deletions":5,"changes":91,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/90a8f283999ddbfee818629e1be17102e63be22c/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FLedgerRecoveryTest.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/90a8f283999ddbfee818629e1be17102e63be22c/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FLedgerRecoveryTest.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FLedgerRecoveryTest.java?ref=90a8f283999ddbfee818629e1be17102e63be22c","patch":"@@ -1,5 +1,3 @@\n-package org.apache.bookkeeper.client;\n-\n /*\n  *\n  * Licensed to the Apache Software Foundation (ASF) under one\n@@ -20,21 +18,26 @@\n  * under the License.\n  *\n  */\n+package org.apache.bookkeeper.client;\n \n import io.netty.buffer.ByteBuf;\n \n import java.io.IOException;\n-import java.nio.ByteBuffer;\n+import java.util.Enumeration;\n import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicInteger;\n \n import org.apache.bookkeeper.bookie.Bookie;\n import org.apache.bookkeeper.bookie.BookieException;\n import org.apache.bookkeeper.client.AsyncCallback.AddCallback;\n import org.apache.bookkeeper.client.BookKeeper.DigestType;\n+import org.apache.bookkeeper.conf.ClientConfiguration;\n import org.apache.bookkeeper.conf.ServerConfiguration;\n import org.apache.bookkeeper.net.BookieSocketAddress;\n+import org.apache.bookkeeper.proto.BookieProtocol;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteCallback;\n import org.apache.bookkeeper.test.BaseTestCase;\n import org.junit.Test;\n@@ -45,9 +48,7 @@\n \n /**\n  * This unit test tests ledger recovery.\n- *\n  */\n-\n public class LedgerRecoveryTest extends BaseTestCase {\n     private final static Logger LOG = LoggerFactory.getLogger(LedgerRecoveryTest.class);\n \n@@ -421,4 +422,84 @@ public void recoveryAddEntry(ByteBuf entry, WriteCallback cb, Object ctx, byte[]\n         bsConfs.add(conf);\n         bs.add(startBookie(conf, rBookie));\n     }\n+\n+    @Test(timeout = 60000)\n+    public void testBatchRecoverySize3() throws Exception {\n+        batchRecovery(3);\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testBatchRecoverySize13() throws Exception {\n+        batchRecovery(13);\n+    }\n+\n+    private void batchRecovery(int batchSize) throws Exception {\n+        ClientConfiguration newConf = new ClientConfiguration()\n+            .setReadEntryTimeout(60000)\n+            .setAddEntryTimeout(60000)\n+            .setRecoveryReadBatchSize(batchSize);\n+\n+        newConf.setZkServers(zkUtil.getZooKeeperConnectString());\n+        BookKeeper newBk = new BookKeeper(newConf);\n+\n+        LedgerHandle lh = newBk.createLedger(numBookies, 2, 2, digestType, \"\".getBytes());\n+\n+        CountDownLatch latch1 = new CountDownLatch(1);\n+        CountDownLatch latch2 = new CountDownLatch(1);\n+        sleepBookie(lh.getLedgerMetadata().currentEnsemble.get(0), latch1);\n+        sleepBookie(lh.getLedgerMetadata().currentEnsemble.get(1), latch2);\n+\n+        int numEntries = (numBookies * 3) + 1;\n+        final AtomicInteger numPendingAdds = new AtomicInteger(numEntries);\n+        final CountDownLatch addDone = new CountDownLatch(1);\n+        for (int i = 0; i < numEntries; i++) {\n+            lh.asyncAddEntry((\"\" + i).getBytes(), new AddCallback() {\n+                @Override\n+                public void addComplete(int rc, LedgerHandle lh, long entryId, Object ctx) {\n+                    if (BKException.Code.OK != rc) {\n+                        addDone.countDown();\n+                        return;\n+                    }\n+                    if (numPendingAdds.decrementAndGet() == 0) {\n+                        addDone.countDown();\n+                    }\n+                }\n+            }, null);\n+        }\n+        latch1.countDown();\n+        latch2.countDown();\n+        addDone.await(10, TimeUnit.SECONDS);\n+        assertEquals(0, numPendingAdds.get());\n+\n+        LedgerHandle recoverLh = newBk.openLedgerNoRecovery(lh.getId(), digestType, \"\".getBytes());\n+        assertEquals(BookieProtocol.INVALID_ENTRY_ID, recoverLh.getLastAddConfirmed());\n+\n+        final CountDownLatch recoverLatch = new CountDownLatch(1);\n+        final AtomicBoolean success = new AtomicBoolean(false);\n+        LedgerRecoveryOp recoveryOp = new LedgerRecoveryOp(recoverLh, new BookkeeperInternalCallbacks.GenericCallback<Void>() {\n+            @Override\n+            public void operationComplete(int rc, Void result) {\n+                success.set(BKException.Code.OK == rc);\n+                recoverLatch.countDown();\n+            }\n+        }).parallelRead(true).readBatchSize(newConf.getRecoveryReadBatchSize());\n+        recoveryOp.initiate();\n+        recoverLatch.await(10, TimeUnit.SECONDS);\n+        assertTrue(success.get());\n+        assertEquals(numEntries, recoveryOp.readCount.get());\n+        assertEquals(numEntries, recoveryOp.writeCount.get());\n+\n+        Enumeration<LedgerEntry> enumeration = recoverLh.readEntries(0, numEntries - 1);\n+\n+        int numReads = 0;\n+        while (enumeration.hasMoreElements()) {\n+            LedgerEntry entry = enumeration.nextElement();\n+            assertEquals((long) numReads, entry.getEntryId());\n+            assertEquals(numReads, Integer.parseInt(new String(entry.getEntry())));\n+            ++numReads;\n+        }\n+        assertEquals(numEntries, numReads);\n+\n+        newBk.close();\n+    }\n }"}]}