{"sha":"5c81acaccfb0cb1260acdfd7d0bb95ae84f85654","node_id":"MDY6Q29tbWl0NDc4NTkyNTI2OjVjODFhY2FjY2ZiMGNiMTI2MGFjZGZkN2QwYmI5NWFlODRmODU2NTQ=","commit":{"author":{"name":"Sijie Guo","email":"sijieg@twitter.com","date":"2017-06-01T20:39:28Z"},"committer":{"name":"Enrico Olivelli","email":"eolivelli@localhost.localdomain","date":"2017-06-01T20:39:28Z"},"message":"BOOKKEEPER-1086: Ledger Recovery - Refactor PendingReadOp\n\nthis change is the first part of improving ledger recovery. it is basically a refactor change, which:\n\n- abstract an interface for LedgerEntryRequest in PendingReadOp\n- rename current implementation to SequenceReadRequest, which read the entry in the sequence of quorum.\n\nAuthor: Sijie Guo <sijieg@twitter.com>\nAuthor: Sijie Guo <sijie@apache.org>\n\nReviewers: Enrico Olivelli <eolivelli@apache.org>\n\nCloses #176 from sijie/recovery_improvements","tree":{"sha":"a82a0e92480c40a970a7cd0eaf96874d5a32541a","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/trees/a82a0e92480c40a970a7cd0eaf96874d5a32541a"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/commits/5c81acaccfb0cb1260acdfd7d0bb95ae84f85654","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/5c81acaccfb0cb1260acdfd7d0bb95ae84f85654","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/5c81acaccfb0cb1260acdfd7d0bb95ae84f85654","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/5c81acaccfb0cb1260acdfd7d0bb95ae84f85654/comments","author":null,"committer":null,"parents":[{"sha":"a9fe7d94f1890f697633fdca8abdeff23903025f","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/a9fe7d94f1890f697633fdca8abdeff23903025f","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/a9fe7d94f1890f697633fdca8abdeff23903025f"}],"stats":{"total":197,"additions":130,"deletions":67},"files":[{"sha":"14051b08b0e3ef941b82ca9f368bd5653e7699d5","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/PendingReadOp.java","status":"modified","additions":127,"deletions":64,"changes":191,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/5c81acaccfb0cb1260acdfd7d0bb95ae84f85654/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FPendingReadOp.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/5c81acaccfb0cb1260acdfd7d0bb95ae84f85654/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FPendingReadOp.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FPendingReadOp.java?ref=5c81acaccfb0cb1260acdfd7d0bb95ae84f85654","patch":"@@ -72,24 +72,135 @@ class PendingReadOp implements Enumeration<LedgerEntry>, ReadEntryCallback {\n \n     final int maxMissedReadsAllowed;\n \n-    class LedgerEntryRequest extends LedgerEntry {\n-        final static int NOT_FOUND = -1;\n-        int nextReplicaIndexToReadFrom = 0;\n-        AtomicBoolean complete = new AtomicBoolean(false);\n+    abstract class LedgerEntryRequest extends LedgerEntry {\n+\n+        final AtomicBoolean complete = new AtomicBoolean(false);\n \n         int firstError = BKException.Code.OK;\n         int numMissedEntryReads = 0;\n \n         final ArrayList<BookieSocketAddress> ensemble;\n         final List<Integer> writeSet;\n-        final BitSet sentReplicas;\n-        final BitSet erroredReplicas;\n \n         LedgerEntryRequest(ArrayList<BookieSocketAddress> ensemble, long lId, long eId) {\n             super(lId, eId);\n \n             this.ensemble = ensemble;\n             this.writeSet = lh.distributionSchedule.getWriteSet(entryId);\n+        }\n+\n+        /**\n+         * Execute the read request.\n+         */\n+        abstract void read();\n+\n+        /**\n+         * Complete the read request from <i>host</i>.\n+         *\n+         * @param host\n+         *          host that respond the read\n+         * @param buffer\n+         *          the data buffer\n+         * @return return true if we managed to complete the entry;\n+         *         otherwise return false if the read entry is not complete or it is already completed before\n+         */\n+        boolean complete(BookieSocketAddress host, final ByteBuf buffer) {\n+            ByteBuf content;\n+            try {\n+                content = lh.macManager.verifyDigestAndReturnData(entryId, buffer);\n+            } catch (BKDigestMatchException e) {\n+                logErrorAndReattemptRead(host, \"Mac mismatch\", BKException.Code.DigestMatchException);\n+                buffer.release();\n+                return false;\n+            }\n+\n+            if (!complete.getAndSet(true)) {\n+                /*\n+                 * The length is a long and it is the last field of the metadata of an entry.\n+                 * Consequently, we have to subtract 8 from METADATA_LENGTH to get the length.\n+                 */\n+                length = buffer.getLong(DigestManager.METADATA_LENGTH - 8);\n+                data = content;\n+                return true;\n+            } else {\n+                buffer.release();\n+                return false;\n+            }\n+        }\n+\n+        /**\n+         * Log error <i>errMsg</i> and reattempt read from <i>host</i>.\n+         *\n+         * @param host\n+         *          host that just respond\n+         * @param errMsg\n+         *          error msg to log\n+         * @param rc\n+         *          read result code\n+         */\n+        void logErrorAndReattemptRead(BookieSocketAddress host, String errMsg, int rc) {\n+            if (BKException.Code.OK == firstError ||\n+                BKException.Code.NoSuchEntryException == firstError ||\n+                BKException.Code.NoSuchLedgerExistsException == firstError) {\n+                firstError = rc;\n+            } else if (BKException.Code.BookieHandleNotAvailableException == firstError &&\n+                       BKException.Code.NoSuchEntryException != rc &&\n+                       BKException.Code.NoSuchLedgerExistsException != rc) {\n+                // if other exception rather than NoSuchEntryException or NoSuchLedgerExistsException is\n+                // returned we need to update firstError to indicate that it might be a valid read but just\n+                // failed.\n+                firstError = rc;\n+            }\n+            if (BKException.Code.NoSuchEntryException == rc ||\n+                BKException.Code.NoSuchLedgerExistsException == rc) {\n+                ++numMissedEntryReads;\n+                if (LOG.isDebugEnabled()) {\n+                    LOG.debug(\"No such entry found on bookie.  L{} E{} bookie: {}\",\n+                        new Object[] { lh.ledgerId, entryId, host });\n+                }\n+            } else {\n+                if (LOG.isDebugEnabled()) {\n+                    LOG.debug(errMsg + \" while reading L{} E{} from bookie: {}\",\n+                        new Object[]{lh.ledgerId, entryId, host});\n+                }\n+            }\n+        }\n+\n+        /**\n+         * Send to next replica speculatively, if required and possible.\n+         * This returns the host we may have sent to for unit testing.\n+         *\n+         * @param heardFromHosts\n+         *      the set of hosts that we already received responses.\n+         * @return host we sent to if we sent. null otherwise.\n+         */\n+        abstract BookieSocketAddress maybeSendSpeculativeRead(Set<BookieSocketAddress> heardFromHosts);\n+\n+        /**\n+         * Whether the read request completed.\n+         *\n+         * @return true if the read request is completed.\n+         */\n+        boolean isComplete() {\n+            return complete.get();\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"L%d-E%d\", ledgerId, entryId);\n+        }\n+    }\n+\n+    class SequenceReadRequest extends LedgerEntryRequest {\n+        final static int NOT_FOUND = -1;\n+        int nextReplicaIndexToReadFrom = 0;\n+\n+        final BitSet sentReplicas;\n+        final BitSet erroredReplicas;\n+\n+        SequenceReadRequest(ArrayList<BookieSocketAddress> ensemble, long lId, long eId) {\n+            super(ensemble, lId, eId);\n+\n             this.sentReplicas = new BitSet(lh.getLedgerMetadata().getWriteQuorumSize());\n             this.erroredReplicas = new BitSet(lh.getLedgerMetadata().getWriteQuorumSize());\n         }\n@@ -133,6 +244,7 @@ private boolean readsOutstanding() {\n          * This returns the host we may have sent to for unit testing.\n          * @return host we sent to if we sent. null otherwise.\n          */\n+        @Override\n         synchronized BookieSocketAddress maybeSendSpeculativeRead(Set<BookieSocketAddress> heardFromHosts) {\n             if (nextReplicaIndexToReadFrom >= getLedgerMetadata().getWriteQuorumSize()) {\n                 return null;\n@@ -151,6 +263,11 @@ synchronized BookieSocketAddress maybeSendSpeculativeRead(Set<BookieSocketAddres\n             }\n         }\n \n+        @Override\n+        void read() {\n+            sendNextRead();\n+        }\n+\n         synchronized BookieSocketAddress sendNextRead() {\n             if (nextReplicaIndexToReadFrom >= getLedgerMetadata().getWriteQuorumSize()) {\n                 // we are done, the read has failed from all replicas, just fail the\n@@ -184,28 +301,9 @@ synchronized BookieSocketAddress sendNextRead() {\n             }\n         }\n \n+        @Override\n         synchronized void logErrorAndReattemptRead(BookieSocketAddress host, String errMsg, int rc) {\n-            if (BKException.Code.OK == firstError ||\n-                BKException.Code.NoSuchEntryException == firstError ||\n-                BKException.Code.NoSuchLedgerExistsException == firstError) {\n-                firstError = rc;\n-            } else if (BKException.Code.BookieHandleNotAvailableException == firstError &&\n-                       BKException.Code.NoSuchEntryException != rc &&\n-                       BKException.Code.NoSuchLedgerExistsException != rc) {\n-                // if other exception rather than NoSuchEntryException or NoSuchLedgerExistsException is\n-                // returned we need to update firstError to indicate that it might be a valid read but just\n-                // failed.\n-                firstError = rc;\n-            }\n-            if (BKException.Code.NoSuchEntryException == rc ||\n-                BKException.Code.NoSuchLedgerExistsException == rc) {\n-                ++numMissedEntryReads;\n-                LOG.debug(\"No such entry found on bookie.  L{} E{} bookie: {}\",\n-                        new Object[] { lh.ledgerId, entryId, host });\n-            } else {\n-                LOG.debug(errMsg + \" while reading L{} E{} from bookie: {}\",\n-                          new Object[] { lh.ledgerId, entryId, host });\n-            }\n+            super.logErrorAndReattemptRead(host, errMsg, rc);\n \n             int replica = getReplicaIndex(host);\n             if (replica == NOT_FOUND) {\n@@ -218,41 +316,6 @@ synchronized void logErrorAndReattemptRead(BookieSocketAddress host, String errM\n                 sendNextRead();\n             }\n         }\n-\n-        // return true if we managed to complete the entry\n-        // return false if the read entry is not complete or it is already completed before\n-        boolean complete(BookieSocketAddress host, final ByteBuf buffer) {\n-            ByteBuf content;\n-            try {\n-                content = lh.macManager.verifyDigestAndReturnData(entryId, buffer);\n-            } catch (BKDigestMatchException e) {\n-                logErrorAndReattemptRead(host, \"Mac mismatch\", BKException.Code.DigestMatchException);\n-                buffer.release();\n-                return false;\n-            }\n-\n-            if (!complete.getAndSet(true)) {\n-                /*\n-                 * The length is a long and it is the last field of the metadata of an entry.\n-                 * Consequently, we have to subtract 8 from METADATA_LENGTH to get the length.\n-                 */\n-                length = buffer.getLong(DigestManager.METADATA_LENGTH - 8);\n-                data = content;\n-                return true;\n-            } else {\n-                buffer.release();\n-                return false;\n-            }\n-        }\n-\n-        boolean isComplete() {\n-            return complete.get();\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return String.format(\"L%d-E%d\", ledgerId, entryId);\n-        }\n     }\n \n     PendingReadOp(LedgerHandle lh, ScheduledExecutorService scheduler,\n@@ -325,11 +388,11 @@ public void run() {\n                 ensemble = getLedgerMetadata().getEnsemble(i);\n                 nextEnsembleChange = getLedgerMetadata().getNextEnsembleChange(i);\n             }\n-            LedgerEntryRequest entry = new LedgerEntryRequest(ensemble, lh.ledgerId, i);\n+            LedgerEntryRequest entry = new SequenceReadRequest(ensemble, lh.ledgerId, i);\n             seq.add(entry);\n             i++;\n \n-            entry.sendNextRead();\n+            entry.read();\n         } while (i <= endEntryId);\n     }\n "},{"sha":"ee77d372c7e7853b70635bfd3c2afa18c433aadf","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestSpeculativeRead.java","status":"modified","additions":3,"deletions":3,"changes":6,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/5c81acaccfb0cb1260acdfd7d0bb95ae84f85654/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FTestSpeculativeRead.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/5c81acaccfb0cb1260acdfd7d0bb95ae84f85654/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FTestSpeculativeRead.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FTestSpeculativeRead.java?ref=5c81acaccfb0cb1260acdfd7d0bb95ae84f85654","patch":"@@ -298,23 +298,23 @@ public void testSpeculativeReadScheduling() throws Exception {\n \n             // if we've already heard from all hosts,\n             // we only send the initial read\n-            req0 = op.new LedgerEntryRequest(ensemble, l.getId(), 0);\n+            req0 = op.new SequenceReadRequest(ensemble, l.getId(), 0);\n             assertTrue(\"Should have sent to first\",\n                        req0.maybeSendSpeculativeRead(allHosts).equals(ensemble.get(0)));\n             assertNull(\"Should not have sent another\",\n                        req0.maybeSendSpeculativeRead(allHosts));\n \n             // if we have heard from some hosts, but not one we have sent to\n             // send again\n-            req2 = op.new LedgerEntryRequest(ensemble, l.getId(), 2);\n+            req2 = op.new SequenceReadRequest(ensemble, l.getId(), 2);\n             assertTrue(\"Should have sent to third\",\n                        req2.maybeSendSpeculativeRead(noHost).equals(ensemble.get(2)));\n             assertTrue(\"Should have sent to first\",\n                        req2.maybeSendSpeculativeRead(secondHostOnly).equals(ensemble.get(0)));\n \n             // if we have heard from some hosts, which includes one we sent to\n             // do not read again\n-            req4 = op.new LedgerEntryRequest(ensemble, l.getId(), 4);\n+            req4 = op.new SequenceReadRequest(ensemble, l.getId(), 4);\n             assertTrue(\"Should have sent to second\",\n                        req4.maybeSendSpeculativeRead(noHost).equals(ensemble.get(1)));\n             assertNull(\"Should not have sent another\","}]}