{"sha":"db17ed7b24abd2a938dc344a0bae4a703349c207","node_id":"MDY6Q29tbWl0NDc4NTkyNTI2OmRiMTdlZDdiMjRhYmQyYTkzOGRjMzQ0YTBiYWU0YTcwMzM0OWMyMDc=","commit":{"author":{"name":"Jordan Bull","email":"jbull@twitter.com","date":"2016-12-17T06:43:24Z"},"committer":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2016-12-17T06:43:24Z"},"message":"DL-87: Introduce periodic keepalive control record in writer\n\nmerge twitter's change from Leigh Stewart\n\nAuthor: Jordan Bull <jbull@twitter.com>\nAuthor: Sijie Guo <sijieg@twitter.com>\nAuthor: Leigh Stewart <lstewart@twitter.com>\n\nReviewers: Leigh Stewart <lstewart@apache.org>\n\nCloses #59 from sijie/merge/DL-87","tree":{"sha":"d8177bcdbf6a1bbef30bcab0b031b3aa1bbfb90d","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/trees/d8177bcdbf6a1bbef30bcab0b031b3aa1bbfb90d"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/commits/db17ed7b24abd2a938dc344a0bae4a703349c207","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/db17ed7b24abd2a938dc344a0bae4a703349c207","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/db17ed7b24abd2a938dc344a0bae4a703349c207","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/db17ed7b24abd2a938dc344a0bae4a703349c207/comments","author":{"login":"jordanbull","id":1355932,"node_id":"MDQ6VXNlcjEzNTU5MzI=","avatar_url":"https://avatars.githubusercontent.com/u/1355932?v=4","gravatar_id":"","url":"https://api.github.com/users/jordanbull","html_url":"https://github.com/jordanbull","followers_url":"https://api.github.com/users/jordanbull/followers","following_url":"https://api.github.com/users/jordanbull/following{/other_user}","gists_url":"https://api.github.com/users/jordanbull/gists{/gist_id}","starred_url":"https://api.github.com/users/jordanbull/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jordanbull/subscriptions","organizations_url":"https://api.github.com/users/jordanbull/orgs","repos_url":"https://api.github.com/users/jordanbull/repos","events_url":"https://api.github.com/users/jordanbull/events{/privacy}","received_events_url":"https://api.github.com/users/jordanbull/received_events","type":"User","site_admin":false},"committer":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"parents":[{"sha":"7b5dc6231e89d282fe00b95cb845ddaf15b034e8","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/7b5dc6231e89d282fe00b95cb845ddaf15b034e8","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/7b5dc6231e89d282fe00b95cb845ddaf15b034e8"}],"stats":{"total":126,"additions":125,"deletions":1},"files":[{"sha":"1b52951c53503d9ad0dcb4baa6d87cb416b9f94a","filename":"src/main/java/com/twitter/distributedlog/BKLogSegmentWriter.java","status":"modified","additions":46,"deletions":1,"changes":47,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/db17ed7b24abd2a938dc344a0bae4a703349c207/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FBKLogSegmentWriter.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/db17ed7b24abd2a938dc344a0bae4a703349c207/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FBKLogSegmentWriter.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FBKLogSegmentWriter.java?ref=db17ed7b24abd2a938dc344a0bae4a703349c207","patch":"@@ -72,6 +72,7 @@\n import org.apache.bookkeeper.stats.Gauge;\n import org.apache.bookkeeper.stats.OpStatsLogger;\n import org.apache.bookkeeper.stats.StatsLogger;\n+import org.apache.bookkeeper.util.MathUtils;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import scala.runtime.AbstractFunction1;\n@@ -128,6 +129,8 @@ class BKLogSegmentWriter implements LogSegmentWriter, AddCallback, Runnable, Siz\n     private long numFlushesSinceRestart = 0;\n     private long numBytes = 0;\n     private long lastEntryId = Long.MIN_VALUE;\n+    private long lastTransmitNanos = Long.MIN_VALUE;\n+    private final int periodicKeepAliveMs;\n \n     // Indicates whether there are writes that have been successfully transmitted that would need\n     // a control record to be transmitted to make them visible to the readers by updating the last\n@@ -137,7 +140,8 @@ class BKLogSegmentWriter implements LogSegmentWriter, AddCallback, Runnable, Siz\n     private int minDelayBetweenImmediateFlushMs = 0;\n     private Stopwatch lastTransmit;\n     private boolean streamEnded = false;\n-    private ScheduledFuture<?> periodicFlushSchedule = null;\n+    private final ScheduledFuture<?> periodicFlushSchedule;\n+    private final ScheduledFuture<?> periodicKeepAliveSchedule;\n     final private AtomicReference<ScheduledFuture<?>> transmitSchedFutureRef = new AtomicReference<ScheduledFuture<?>>(null);\n     final private AtomicReference<ScheduledFuture<?>> immFlushSchedFutureRef = new AtomicReference<ScheduledFuture<?>>(null);\n     final private AtomicReference<Exception> scheduledFlushException = new AtomicReference<Exception>(null);\n@@ -312,11 +316,25 @@ public Number getSample() {\n             if (periodicFlushFrequency > 0 && scheduler != null) {\n                 periodicFlushSchedule = scheduler.scheduleAtFixedRate(this,\n                         periodicFlushFrequency/2, periodicFlushFrequency/2, TimeUnit.MILLISECONDS);\n+            } else {\n+                periodicFlushSchedule = null;\n             }\n         } else {\n             // Min delay heuristic applies only when immediate flush is enabled\n             // and transmission threshold is zero\n             minDelayBetweenImmediateFlushMs = conf.getMinDelayBetweenImmediateFlushMs();\n+            periodicFlushSchedule = null;\n+        }\n+        this.periodicKeepAliveMs = conf.getPeriodicKeepAliveMilliSeconds();\n+        if (periodicKeepAliveMs > 0 && scheduler != null) {\n+            periodicKeepAliveSchedule = scheduler.scheduleAtFixedRate(new Runnable() {\n+                @Override\n+                public void run() {\n+                    keepAlive();\n+                }\n+            }, periodicKeepAliveMs, periodicKeepAliveMs, TimeUnit.MILLISECONDS);\n+        } else {\n+            periodicKeepAliveSchedule = null;\n         }\n \n         this.conf = conf;\n@@ -513,6 +531,13 @@ private Future<Void> closeInternal(boolean abort) {\n     private void closeInternal(final boolean abort,\n                                final AtomicReference<Throwable> throwExc,\n                                final Promise<Void> closePromise) {\n+        // Cancel the periodic keep alive schedule first\n+        if (null != periodicKeepAliveSchedule) {\n+            if (!periodicKeepAliveSchedule.cancel(false)) {\n+                LOG.info(\"Periodic keepalive for log segment {} isn't cancelled.\", getFullyQualifiedLogSegment());\n+            }\n+        }\n+\n         // Cancel the periodic flush schedule first\n         // The task is allowed to exit gracefully\n         if (null != periodicFlushSchedule) {\n@@ -1079,6 +1104,9 @@ private Future<Integer> transmit()\n             }\n \n             synchronized (this) {\n+                // update the transmit timestamp\n+                lastTransmitNanos = MathUtils.nowInNano();\n+\n                 BKTransmitPacket packet = new BKTransmitPacket(recordSetToTransmit);\n                 packetPrevious = packet;\n                 entryWriter.asyncAddEntry(toSend.getData(), 0, toSend.size(),\n@@ -1293,4 +1321,21 @@ synchronized private void backgroundFlush(boolean controlFlushOnly)  {\n         }\n     }\n \n+    synchronized private void keepAlive() {\n+        if (null != closeFuture) {\n+            // if the log segment is closing, skip sending any keep alive records.\n+            LOG.debug(\"Skip sending keepAlive control record since log segment {} is closing.\",\n+                    getFullyQualifiedLogSegment());\n+            return;\n+        }\n+\n+        if (MathUtils.elapsedMSec(lastTransmitNanos) < periodicKeepAliveMs) {\n+            return;\n+        }\n+\n+        LogRecord controlRec = new LogRecord(lastTxId, DistributedLogConstants.KEEPALIVE_RECORD_CONTENT);\n+        controlRec.setControl();\n+        asyncWrite(controlRec);\n+    }\n+\n }"},{"sha":"c2057df616cc5536dc5ee20f5794baba9c80c664","filename":"src/main/java/com/twitter/distributedlog/DistributedLogConfiguration.java","status":"modified","additions":25,"deletions":0,"changes":25,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/db17ed7b24abd2a938dc344a0bae4a703349c207/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FDistributedLogConfiguration.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/db17ed7b24abd2a938dc344a0bae4a703349c207/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FDistributedLogConfiguration.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FDistributedLogConfiguration.java?ref=db17ed7b24abd2a938dc344a0bae4a703349c207","patch":"@@ -249,6 +249,8 @@ public class DistributedLogConfiguration extends CompositeConfiguration {\n     public static final boolean BKDL_ENABLE_IMMEDIATE_FLUSH_DEFAULT = false;\n     public static final String BKDL_MINIMUM_DELAY_BETWEEN_IMMEDIATE_FLUSH_MILLISECONDS = \"minimumDelayBetweenImmediateFlushMilliSeconds\";\n     public static final int BKDL_MINIMUM_DELAY_BETWEEN_IMMEDIATE_FLUSH_MILLISECONDS_DEFAULT = 0;\n+    public static final String BKDL_PERIODIC_KEEP_ALIVE_MILLISECONDS = \"periodicKeepAliveMilliSeconds\";\n+    public static final int BKDL_PERIODIC_KEEP_ALIVE_MILLISECONDS_DEFAULT = 0;\n \n     // Retention/Truncation Settings\n     public static final String BKDL_RETENTION_PERIOD_IN_HOURS = \"logSegmentRetentionHours\";\n@@ -1893,6 +1895,29 @@ public DistributedLogConfiguration setMinDelayBetweenImmediateFlushMs(int minDel\n         return this;\n     }\n \n+    /**\n+     * Get Periodic Keep Alive Frequency in milliseconds.\n+     * <p>If the setting is set with a positive value, it would periodically write a control record\n+     * to keep the stream active. The default value is 0.\n+     *\n+     * @return periodic keep alive frequency in milliseconds.\n+     */\n+    public int getPeriodicKeepAliveMilliSeconds() {\n+        return this.getInt(BKDL_PERIODIC_KEEP_ALIVE_MILLISECONDS, BKDL_PERIODIC_KEEP_ALIVE_MILLISECONDS_DEFAULT);\n+    }\n+\n+    /**\n+     * Set Periodic Keep Alive Frequency in milliseconds.\n+     *\n+     * @param keepAliveMs keep alive frequency in milliseconds.\n+     * @return distributedlog configuration\n+     * @see #getPeriodicKeepAliveMilliSeconds()\n+     */\n+    public DistributedLogConfiguration setPeriodicKeepAliveMilliSeconds(int keepAliveMs) {\n+        setProperty(BKDL_PERIODIC_KEEP_ALIVE_MILLISECONDS, keepAliveMs);\n+        return this;\n+    }\n+\n     //\n     // DL Retention/Truncation Settings\n     //"},{"sha":"32def944aa790c7ae58d389b72008fd0f2e7a499","filename":"src/main/java/com/twitter/distributedlog/DistributedLogConstants.java","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/db17ed7b24abd2a938dc344a0bae4a703349c207/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FDistributedLogConstants.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/db17ed7b24abd2a938dc344a0bae4a703349c207/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FDistributedLogConstants.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FDistributedLogConstants.java?ref=db17ed7b24abd2a938dc344a0bae4a703349c207","patch":"@@ -58,6 +58,7 @@ public class DistributedLogConstants {\n     public static final String COMPLETED_LOGSEGMENT_PREFIX = \"logrecs\";\n     public static final String DISALLOW_PLACEMENT_IN_REGION_FEATURE_NAME = \"disallow_bookie_placement\";\n     static final byte[] CONTROL_RECORD_CONTENT = \"control\".getBytes(UTF_8);\n+    public static final byte[] KEEPALIVE_RECORD_CONTENT = \"keepalive\".getBytes(UTF_8);\n \n     // An ACL that gives all permissions to node creators and read permissions only to everyone else.\n     public static final List<ACL> EVERYONE_READ_CREATOR_ALL ="},{"sha":"a4832b0f03fc437ed2a27467987101b30b0469e2","filename":"src/test/java/com/twitter/distributedlog/TestAsyncReaderWriter.java","status":"modified","additions":53,"deletions":0,"changes":53,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/db17ed7b24abd2a938dc344a0bae4a703349c207/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestAsyncReaderWriter.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/db17ed7b24abd2a938dc344a0bae4a703349c207/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestAsyncReaderWriter.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestAsyncReaderWriter.java?ref=db17ed7b24abd2a938dc344a0bae4a703349c207","patch":"@@ -2115,4 +2115,57 @@ public void onFailure(Throwable cause) {\n             }\n         }\n     }\n+\n+    @Test(timeout = 60000)\n+    public void testIdleReaderExceptionWhenKeepAliveIsDisabled() throws Exception {\n+        String name = runtime.getMethodName();\n+        DistributedLogConfiguration confLocal = new DistributedLogConfiguration();\n+        confLocal.addConfiguration(testConf);\n+        confLocal.setOutputBufferSize(0);\n+        confLocal.setImmediateFlushEnabled(false);\n+        confLocal.setPeriodicFlushFrequencyMilliSeconds(0);\n+        confLocal.setPeriodicKeepAliveMilliSeconds(0);\n+        confLocal.setReaderIdleWarnThresholdMillis(20);\n+        confLocal.setReaderIdleErrorThresholdMillis(40);\n+\n+        URI uri = createDLMURI(\"/\" + name);\n+        ensureURICreated(uri);\n+\n+        DistributedLogManager dlm = createNewDLM(confLocal, name);\n+        BKAsyncLogWriter writer = (BKAsyncLogWriter) FutureUtils.result(dlm.openAsyncLogWriter());\n+        writer.write(DLMTestUtil.getLogRecordInstance(1L));\n+\n+        AsyncLogReader reader = FutureUtils.result(dlm.openAsyncLogReader(DLSN.InitialDLSN));\n+        try {\n+            FutureUtils.result(reader.readNext());\n+            fail(\"Should fail when stream is idle\");\n+        } catch (IdleReaderException ire) {\n+            // expected\n+        }\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testIdleReaderExceptionWhenKeepAliveIsEnabled() throws Exception {\n+        String name = runtime.getMethodName();\n+        DistributedLogConfiguration confLocal = new DistributedLogConfiguration();\n+        confLocal.addConfiguration(testConf);\n+        confLocal.setOutputBufferSize(0);\n+        confLocal.setImmediateFlushEnabled(false);\n+        confLocal.setPeriodicFlushFrequencyMilliSeconds(0);\n+        confLocal.setPeriodicKeepAliveMilliSeconds(1000);\n+        confLocal.setReaderIdleWarnThresholdMillis(2000);\n+        confLocal.setReaderIdleErrorThresholdMillis(4000);\n+\n+        URI uri = createDLMURI(\"/\" + name);\n+        ensureURICreated(uri);\n+\n+        DistributedLogManager dlm = createNewDLM(confLocal, name);\n+        BKAsyncLogWriter writer = (BKAsyncLogWriter) FutureUtils.result(dlm.openAsyncLogWriter());\n+        writer.write(DLMTestUtil.getLogRecordInstance(1L));\n+\n+        AsyncLogReader reader = FutureUtils.result(dlm.openAsyncLogReader(DLSN.InitialDLSN));\n+        LogRecordWithDLSN record = FutureUtils.result(reader.readNext());\n+        assertEquals(1L, record.getTransactionId());\n+        DLMTestUtil.verifyLogRecord(record);\n+    }\n }"}]}