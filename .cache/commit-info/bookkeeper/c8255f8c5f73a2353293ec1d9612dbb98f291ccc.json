{"sha":"c8255f8c5f73a2353293ec1d9612dbb98f291ccc","node_id":"MDY6Q29tbWl0NDc4NTkyNTI2OmM4MjU1ZjhjNWY3M2EyMzUzMjkzZWMxZDk2MTJkYmI5OGYyOTFjY2M=","commit":{"author":{"name":"Siddharth Boobna","email":"sboobna@yahoo-inc.com","date":"2016-03-08T06:06:40Z"},"committer":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2016-03-08T06:06:40Z"},"message":"BookKeeper client should try not to use bookies with errors/timeouts when forming a new ensemble\n\nâ€¦hen forming ensembles\n\nAuthor: Siddharth Boobna <sboobna@yahoo-inc.com>\n\nReviewers: Sijie Guo <sijie@apache.org>\n\nCloses #11 from sboobna/BOOKKEEPER-889","tree":{"sha":"e1ab94df31725d225deca78ae538dd4f7c737ddc","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/trees/e1ab94df31725d225deca78ae538dd4f7c737ddc"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/commits/c8255f8c5f73a2353293ec1d9612dbb98f291ccc","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/c8255f8c5f73a2353293ec1d9612dbb98f291ccc","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/c8255f8c5f73a2353293ec1d9612dbb98f291ccc","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/c8255f8c5f73a2353293ec1d9612dbb98f291ccc/comments","author":null,"committer":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"parents":[{"sha":"96adbf1d613a63602c8b1b4aad1b0a7d17e6eee3","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/96adbf1d613a63602c8b1b4aad1b0a7d17e6eee3","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/96adbf1d613a63602c8b1b4aad1b0a7d17e6eee3"}],"stats":{"total":538,"additions":497,"deletions":41},"files":[{"sha":"f2f150e097d9c88fc3d36e981a15dcd7d44e79e0","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BKException.java","status":"modified","additions":10,"deletions":0,"changes":10,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/c8255f8c5f73a2353293ec1d9612dbb98f291ccc/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBKException.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/c8255f8c5f73a2353293ec1d9612dbb98f291ccc/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBKException.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBKException.java?ref=c8255f8c5f73a2353293ec1d9612dbb98f291ccc","patch":"@@ -98,6 +98,8 @@ public static BKException create(int code) {\n             return new BKAddEntryQuorumTimeoutException();\n         case Code.DuplicateEntryIdException:\n             return new BKDuplicateEntryIdException();\n+        case Code.TimeoutException:\n+            return new BKTimeoutException();\n         default:\n             return new BKUnexpectedConditionException();\n         }\n@@ -131,6 +133,7 @@ public interface Code {\n         int LedgerExistException = -20;\n         int AddEntryQuorumTimeoutException = -21;\n         int DuplicateEntryIdException = -22;\n+        int TimeoutException = -23;\n \n         int IllegalOpException = -100;\n         int LedgerFencedException = -101;\n@@ -213,6 +216,8 @@ public static String getMessage(int code) {\n             return \"Invalid operation\";\n         case Code.AddEntryQuorumTimeoutException:\n             return \"Add entry quorum wait timed out\";\n+        case Code.TimeoutException:\n+            return \"Bookie operation timeout\";\n         default:\n             return \"Unexpected condition\";\n         }\n@@ -392,4 +397,9 @@ public BKClientClosedException() {\n         }\n     }\n \n+    public static class BKTimeoutException extends BKException {\n+        public BKTimeoutException() {\n+            super(Code.TimeoutException);\n+        }\n+    }\n }"},{"sha":"f354bef08512d69c60c1de920e696a4de3d2524c","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookKeeper.java","status":"modified","additions":26,"deletions":0,"changes":26,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/c8255f8c5f73a2353293ec1d9612dbb98f291ccc/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookKeeper.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/c8255f8c5f73a2353293ec1d9612dbb98f291ccc/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookKeeper.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookKeeper.java?ref=c8255f8c5f73a2353293ec1d9612dbb98f291ccc","patch":"@@ -21,13 +21,15 @@\n package org.apache.bookkeeper.client;\n \n import java.io.IOException;\n+import java.util.List;\n import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.Executors;\n import java.util.concurrent.ScheduledExecutorService;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.locks.ReentrantReadWriteLock;\n \n import com.google.common.base.Preconditions;\n+\n import org.apache.bookkeeper.client.AsyncCallback.CreateCallback;\n import org.apache.bookkeeper.client.AsyncCallback.DeleteCallback;\n import org.apache.bookkeeper.client.AsyncCallback.OpenCallback;\n@@ -37,13 +39,15 @@\n import org.apache.bookkeeper.meta.LedgerIdGenerator;\n import org.apache.bookkeeper.meta.LedgerManager;\n import org.apache.bookkeeper.meta.LedgerManagerFactory;\n+import org.apache.bookkeeper.net.BookieSocketAddress;\n import org.apache.bookkeeper.proto.BookieClient;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n import org.apache.bookkeeper.stats.NullStatsLogger;\n import org.apache.bookkeeper.stats.StatsLogger;\n import org.apache.bookkeeper.stats.OpStatsLogger;\n import org.apache.bookkeeper.util.OrderedSafeExecutor;\n import org.apache.bookkeeper.util.ReflectionUtils;\n+import org.apache.bookkeeper.util.SafeRunnable;\n import org.apache.bookkeeper.zookeeper.BoundExponentialBackoffRetryPolicy;\n import org.apache.bookkeeper.zookeeper.ZooKeeperClient;\n import org.apache.commons.configuration.ConfigurationException;\n@@ -312,6 +316,8 @@ private BookKeeper(ClientConfiguration conf,\n         this.ledgerManagerFactory = LedgerManagerFactory.newLedgerManagerFactory(conf, this.zk);\n         this.ledgerManager = new CleanupLedgerManager(ledgerManagerFactory.newLedgerManager());\n         this.ledgerIdGenerator = ledgerManagerFactory.newLedgerIdGenerator();\n+\n+        scheduleBookieHealthCheckIfEnabled();\n     }\n \n     private EnsemblePlacementPolicy initializeEnsemblePlacementPolicy(ClientConfiguration conf)\n@@ -336,6 +342,26 @@ int getReturnRc(int rc) {\n         }\n     }\n \n+    void scheduleBookieHealthCheckIfEnabled() {\n+        if (conf.isBookieHealthCheckEnabled()) {\n+            scheduler.scheduleAtFixedRate(new SafeRunnable() {\n+\n+                @Override\n+                public void safeRun() {\n+                    checkForFaultyBookies();\n+                }\n+                    }, conf.getBookieHealthCheckIntervalSeconds(), conf.getBookieHealthCheckIntervalSeconds(),\n+                    TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    void checkForFaultyBookies() {\n+        List<BookieSocketAddress> faultyBookies = bookieClient.getFaultyBookies();\n+        for (BookieSocketAddress faultyBookie : faultyBookies) {\n+            bookieWatcher.quarantineBookie(faultyBookie);\n+        }\n+    }\n+\n     LedgerManager getLedgerManager() {\n         return ledgerManager;\n     }"},{"sha":"cadec5db876ceb96482995381e19d7bb8ee11136","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BookieWatcher.java","status":"modified","additions":52,"deletions":2,"changes":54,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/c8255f8c5f73a2353293ec1d9612dbb98f291ccc/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookieWatcher.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/c8255f8c5f73a2353293ec1d9612dbb98f291ccc/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookieWatcher.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookieWatcher.java?ref=c8255f8c5f73a2353293ec1d9612dbb98f291ccc","patch":"@@ -45,6 +45,11 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import com.google.common.cache.Cache;\n+import com.google.common.cache.CacheBuilder;\n+import com.google.common.cache.RemovalListener;\n+import com.google.common.cache.RemovalNotification;\n+\n /**\n  * This class is responsible for maintaining a consistent view of what bookies\n  * are available by reading Zookeeper (and setting watches on the bookie nodes).\n@@ -57,6 +62,7 @@ class BookieWatcher implements Watcher, ChildrenCallback {\n \n     public static int ZK_CONNECT_BACKOFF_SEC = 1;\n     private static final Set<BookieSocketAddress> EMPTY_SET = new HashSet<BookieSocketAddress>();\n+    private static final Boolean BOOLEAN = new Boolean(true);\n \n     // Bookie registration path in ZK\n     private final String bookieRegistrationPath;\n@@ -65,6 +71,9 @@ class BookieWatcher implements Watcher, ChildrenCallback {\n     final ScheduledExecutorService scheduler;\n     final EnsemblePlacementPolicy placementPolicy;\n \n+    // Bookies that will not be preferred to be chosen in a new ensemble\n+    final Cache<BookieSocketAddress, Boolean> quarantinedBookies;\n+\n     SafeRunnable reReadTask = new SafeRunnable() {\n         @Override\n         public void safeRun() {\n@@ -83,6 +92,16 @@ public BookieWatcher(ClientConfiguration conf,\n         this.scheduler = scheduler;\n         this.placementPolicy = placementPolicy;\n         readOnlyBookieWatcher = new ReadOnlyBookieWatcher(conf, bk);\n+        this.quarantinedBookies = CacheBuilder.newBuilder()\n+                .expireAfterWrite(conf.getBookieQuarantineTimeSeconds(), TimeUnit.SECONDS)\n+                .removalListener(new RemovalListener<BookieSocketAddress, Boolean>() {\n+\n+                    @Override\n+                    public void onRemoval(RemovalNotification<BookieSocketAddress, Boolean> bookie) {\n+                        logger.info(\"Bookie {} is no longer quarantined\", bookie.getKey());\n+                    }\n+\n+                }).build();\n     }\n \n     void notifyBookiesChanged(final BookiesListener listener) throws BKException {\n@@ -235,7 +254,16 @@ public void processResult(int rc, String path, Object ctx, List<String> children\n      */\n     public ArrayList<BookieSocketAddress> newEnsemble(int ensembleSize, int writeQuorumSize)\n             throws BKNotEnoughBookiesException {\n-        return placementPolicy.newEnsemble(ensembleSize, writeQuorumSize, EMPTY_SET);\n+        try {\n+            // we try to only get from the healthy bookies first\n+            return placementPolicy.newEnsemble(ensembleSize, writeQuorumSize, new HashSet<BookieSocketAddress>(\n+                    quarantinedBookies.asMap().keySet()));\n+        } catch (BKNotEnoughBookiesException e) {\n+            if (logger.isDebugEnabled()) {\n+                logger.debug(\"Not enough healthy bookies available, using quarantined bookies\");\n+            }\n+            return placementPolicy.newEnsemble(ensembleSize, writeQuorumSize, EMPTY_SET);\n+        }\n     }\n \n     /**\n@@ -250,7 +278,29 @@ public ArrayList<BookieSocketAddress> newEnsemble(int ensembleSize, int writeQuo\n     public BookieSocketAddress replaceBookie(List<BookieSocketAddress> existingBookies, int bookieIdx)\n             throws BKNotEnoughBookiesException {\n         BookieSocketAddress addr = existingBookies.get(bookieIdx);\n-        return placementPolicy.replaceBookie(addr, new HashSet<BookieSocketAddress>(existingBookies));\n+        try {\n+            // we exclude the quarantined bookies also first\n+            Set<BookieSocketAddress> existingAndQuarantinedBookies = new HashSet<BookieSocketAddress>(existingBookies);\n+            existingAndQuarantinedBookies.addAll(quarantinedBookies.asMap().keySet());\n+            return placementPolicy.replaceBookie(addr, existingAndQuarantinedBookies);\n+        } catch (BKNotEnoughBookiesException e) {\n+            if (logger.isDebugEnabled()) {\n+                logger.debug(\"Not enough healthy bookies available, using quarantined bookies\");\n+            }\n+            return placementPolicy.replaceBookie(addr, new HashSet<BookieSocketAddress>(existingBookies));\n+        }\n+    }\n+\n+    /**\n+     * Quarantine <i>bookie</i> so it will not be preferred to be chosen for new ensembles.\n+     * @param bookie\n+     * @return\n+     */\n+    public void quarantineBookie(BookieSocketAddress bookie) {\n+        if (quarantinedBookies.getIfPresent(bookie) == null) {\n+            quarantinedBookies.put(bookie, BOOLEAN);\n+            logger.warn(\"Bookie {} has been quarantined because of read/write errors.\", bookie);\n+        }\n     }\n \n     /**"},{"sha":"d0750d39be43c021547b6f32be0245a8cf8c8272","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ClientConfiguration.java","status":"modified","additions":109,"deletions":0,"changes":109,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/c8255f8c5f73a2353293ec1d9612dbb98f291ccc/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fconf%2FClientConfiguration.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/c8255f8c5f73a2353293ec1d9612dbb98f291ccc/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fconf%2FClientConfiguration.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fconf%2FClientConfiguration.java?ref=c8255f8c5f73a2353293ec1d9612dbb98f291ccc","patch":"@@ -65,6 +65,12 @@ public class ClientConfiguration extends AbstractConfiguration {\n     protected final static String PCBC_TIMEOUT_TIMER_TICK_DURATION_MS = \"pcbcTimeoutTimerTickDurationMs\";\n     protected final static String PCBC_TIMEOUT_TIMER_NUM_TICKS = \"pcbcTimeoutTimerNumTicks\";\n \n+    // Bookie health check settings\n+    protected final static String BOOKIE_HEALTH_CHECK_ENABLED = \"bookieHealthCheckEnabled\";\n+    protected final static String BOOKIE_HEALTH_CHECK_INTERVAL_SECONDS = \"bookieHealthCheckIntervalSeconds\";\n+    protected final static String BOOKIE_ERROR_THRESHOLD_PER_INTERVAL = \"bookieErrorThresholdPerInterval\";\n+    protected final static String BOOKIE_QUARANTINE_TIME_SECONDS = \"bookieQuarantineTimeSeconds\";\n+\n     // Number Woker Threads\n     protected final static String NUM_WORKER_THREADS = \"numWorkerThreads\";\n \n@@ -691,4 +697,107 @@ public ClientConfiguration setTaskExecutionWarnTimeMicros(long warnTime) {\n         setProperty(TASK_EXECUTION_WARN_TIME_MICROS, warnTime);\n         return this;\n     }\n+\n+    /**\n+     * Check if bookie health check is enabled.\n+     * \n+     * @return\n+     */\n+    public boolean isBookieHealthCheckEnabled() {\n+        return getBoolean(BOOKIE_HEALTH_CHECK_ENABLED, false);\n+    }\n+\n+    /**\n+     * Enables the bookie health check.\n+     * \n+     * <p>\n+     * If the number of read/write errors for a bookie exceeds {@link #getBookieErrorThresholdPerInterval()} per\n+     * interval, that bookie is quarantined for {@link #getBookieQuarantineTimeSeconds()} seconds. During this\n+     * quarantined period, the client will try not to use this bookie when creating new ensembles.\n+     * </p>\n+     * \n+     * By default, the bookie health check is <b>disabled</b>.\n+     * \n+     * @return client configuration\n+     */\n+    public ClientConfiguration enableBookieHealthCheck() {\n+        setProperty(BOOKIE_HEALTH_CHECK_ENABLED, true);\n+        return this;\n+    }\n+\n+    /**\n+     * Get the bookie health check interval in seconds.\n+     * \n+     * @return\n+     */\n+    public int getBookieHealthCheckIntervalSeconds() {\n+        return getInt(BOOKIE_HEALTH_CHECK_INTERVAL_SECONDS, 60);\n+    }\n+\n+    /**\n+     * Set the bookie health check interval. Default is 60 seconds.\n+     * \n+     * <p>\n+     * Note: Please {@link #enableBookieHealthCheck()} to use this configuration.\n+     * </p>\n+     * \n+     * @param interval\n+     * @param unit\n+     * @return client configuration\n+     */\n+    public ClientConfiguration setBookieHealthCheckInterval(int interval, TimeUnit unit) {\n+        setProperty(BOOKIE_HEALTH_CHECK_INTERVAL_SECONDS, unit.toSeconds(interval));\n+        return this;\n+    }\n+\n+    /**\n+     * Get the error threshold for a bookie to be quarantined.\n+     * \n+     * @return\n+     */\n+    public long getBookieErrorThresholdPerInterval() {\n+        return getLong(BOOKIE_ERROR_THRESHOLD_PER_INTERVAL, 100);\n+    }\n+\n+    /**\n+     * Set the error threshold per interval ({@link #getBookieHealthCheckIntervalSeconds()}) for a bookie before it is\n+     * quarantined. Default is 100 errors per minute.\n+     * \n+     * <p>\n+     * Note: Please {@link #enableBookieHealthCheck()} to use this configuration.\n+     * </p>\n+     * \n+     * @param threshold\n+     * @param unit\n+     * @return client configuration\n+     */\n+    public ClientConfiguration setBookieErrorThresholdPerInterval(long thresholdPerInterval) {\n+        setProperty(BOOKIE_ERROR_THRESHOLD_PER_INTERVAL, thresholdPerInterval);\n+        return this;\n+    }\n+\n+    /**\n+     * Get the time for which a bookie will be quarantined.\n+     * \n+     * @return\n+     */\n+    public int getBookieQuarantineTimeSeconds() {\n+        return getInt(BOOKIE_QUARANTINE_TIME_SECONDS, 1800);\n+    }\n+\n+    /**\n+     * Set the time for which a bookie will be quarantined. Default is 30 minutes.\n+     * \n+     * <p>\n+     * Note: Please {@link #enableBookieHealthCheck()} to use this configuration.\n+     * </p>\n+     * \n+     * @param quarantineTime\n+     * @param unit\n+     * @return client configuration\n+     */\n+    public ClientConfiguration setBookieQuarantineTime(int quarantineTime, TimeUnit unit) {\n+        setProperty(BOOKIE_QUARANTINE_TIME_SECONDS, unit.toSeconds(quarantineTime));\n+        return this;\n+    }\n }"},{"sha":"8a79547551cb38c13e1d8c3d08d30bbdf2462078","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/BookieClient.java","status":"modified","additions":22,"deletions":5,"changes":27,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/c8255f8c5f73a2353293ec1d9612dbb98f291ccc/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookieClient.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/c8255f8c5f73a2353293ec1d9612dbb98f291ccc/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookieClient.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FBookieClient.java?ref=c8255f8c5f73a2353293ec1d9612dbb98f291ccc","patch":"@@ -23,15 +23,13 @@\n import static com.google.common.base.Charsets.UTF_8;\n \n import java.io.IOException;\n-import java.util.HashSet;\n-import java.util.Set;\n+import java.util.List;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.Executors;\n import java.util.concurrent.RejectedExecutionException;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.locks.ReentrantReadWriteLock;\n \n-import com.google.common.util.concurrent.ThreadFactoryBuilder;\n import org.apache.bookkeeper.client.BKException;\n import org.apache.bookkeeper.conf.ClientConfiguration;\n import org.apache.bookkeeper.net.BookieSocketAddress;\n@@ -52,6 +50,9 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import com.google.common.collect.Lists;\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+\n /**\n  * Implements the client-side part of the BookKeeper protocol.\n  *\n@@ -70,6 +71,8 @@ public class BookieClient implements PerChannelBookieClientFactory {\n     private final StatsLogger statsLogger;\n     private final int numConnectionsPerBookie;\n \n+    private final long bookieErrorThresholdPerInterval;\n+\n     public BookieClient(ClientConfiguration conf, ClientSocketChannelFactory channelFactory, OrderedSafeExecutor executor) {\n         this(conf, channelFactory, executor, NullStatsLogger.INSTANCE);\n     }\n@@ -87,6 +90,7 @@ public BookieClient(ClientConfiguration conf, ClientSocketChannelFactory channel\n                 new ThreadFactoryBuilder().setNameFormat(\"BookieClientTimer-%d\").build(),\n                 conf.getPCBCTimeoutTimerTickDurationMs(), TimeUnit.MILLISECONDS,\n                 conf.getPCBCTimeoutTimerNumTicks());\n+        this.bookieErrorThresholdPerInterval = conf.getBookieErrorThresholdPerInterval();\n     }\n \n     private int getRc(int rc) {\n@@ -101,10 +105,23 @@ private int getRc(int rc) {\n         }\n     }\n \n+    public List<BookieSocketAddress> getFaultyBookies() {\n+        List<BookieSocketAddress> faultyBookies = Lists.newArrayList();\n+        for (PerChannelBookieClientPool channelPool : channels.values()) {\n+            if (channelPool instanceof DefaultPerChannelBookieClientPool) {\n+                DefaultPerChannelBookieClientPool pool = (DefaultPerChannelBookieClientPool) channelPool;\n+                if (pool.errorCounter.getAndSet(0) >= bookieErrorThresholdPerInterval) {\n+                    faultyBookies.add(pool.address);\n+                }\n+            }\n+        }\n+        return faultyBookies;\n+    }\n+\n     @Override\n-    public PerChannelBookieClient create(BookieSocketAddress address) {\n+    public PerChannelBookieClient create(BookieSocketAddress address, PerChannelBookieClientPool pcbcPool) {\n         return new PerChannelBookieClient(conf, executor, channelFactory, address,\n-                                          requestTimer, statsLogger);\n+                                          requestTimer, statsLogger, pcbcPool);\n     }\n \n     private PerChannelBookieClientPool lookupClient(BookieSocketAddress addr, Object key) {"},{"sha":"2658634629712e6e8035eeb7c48664f9bfee1a7e","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/DefaultPerChannelBookieClientPool.java","status":"modified","additions":10,"deletions":2,"changes":12,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/c8255f8c5f73a2353293ec1d9612dbb98f291ccc/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FDefaultPerChannelBookieClientPool.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/c8255f8c5f73a2353293ec1d9612dbb98f291ccc/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FDefaultPerChannelBookieClientPool.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FDefaultPerChannelBookieClientPool.java?ref=c8255f8c5f73a2353293ec1d9612dbb98f291ccc","patch":"@@ -20,14 +20,16 @@\n  */\n package org.apache.bookkeeper.proto;\n \n-import com.google.common.base.Preconditions;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n import org.apache.bookkeeper.net.BookieSocketAddress;\n import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n import org.apache.bookkeeper.util.MathUtils;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n import java.util.concurrent.atomic.AtomicInteger;\n+import com.google.common.base.Preconditions;\n \n /**\n  *  Provide a simple round-robin style channel pool. We could improve it later to do more\n@@ -42,6 +44,7 @@ class DefaultPerChannelBookieClientPool implements PerChannelBookieClientPool,\n     final BookieSocketAddress address;\n     final PerChannelBookieClient[] clients;\n     final AtomicInteger counter = new AtomicInteger(0);\n+    final AtomicLong errorCounter = new AtomicLong(0);\n \n     DefaultPerChannelBookieClientPool(PerChannelBookieClientFactory factory,\n                                       BookieSocketAddress address,\n@@ -51,7 +54,7 @@ class DefaultPerChannelBookieClientPool implements PerChannelBookieClientPool,\n         this.address = address;\n         this.clients = new PerChannelBookieClient[coreSize];\n         for (int i = 0; i < coreSize; i++) {\n-            this.clients[i] = factory.create(address);\n+            this.clients[i] = factory.create(address, this);\n         }\n     }\n \n@@ -77,6 +80,11 @@ public void obtain(GenericCallback<PerChannelBookieClient> callback) {\n         clients[idx].connectIfNeededAndDoOp(callback);\n     }\n \n+    @Override\n+    public void recordError() {\n+        errorCounter.incrementAndGet();\n+    }\n+\n     @Override\n     public void disconnect(boolean wait) {\n         for (PerChannelBookieClient pcbc : clients) {"},{"sha":"2bd4e9ba5593efddd66140adfdc7e0dde1194426","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java","status":"modified","additions":68,"deletions":29,"changes":97,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/c8255f8c5f73a2353293ec1d9612dbb98f291ccc/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FPerChannelBookieClient.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/c8255f8c5f73a2353293ec1d9612dbb98f291ccc/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FPerChannelBookieClient.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FPerChannelBookieClient.java?ref=c8255f8c5f73a2353293ec1d9612dbb98f291ccc","patch":"@@ -20,17 +20,21 @@\n import java.io.IOException;\n import java.nio.channels.ClosedChannelException;\n import java.util.ArrayDeque;\n+import java.util.Collections;\n import java.util.Queue;\n+import java.util.Set;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicLong;\n import java.util.concurrent.locks.ReentrantReadWriteLock;\n \n-import com.google.protobuf.ByteString;\n import org.apache.bookkeeper.client.BKException;\n import org.apache.bookkeeper.client.BookKeeperClientStats;\n import org.apache.bookkeeper.conf.ClientConfiguration;\n import org.apache.bookkeeper.net.BookieSocketAddress;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ReadEntryCallback;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteCallback;\n import org.apache.bookkeeper.proto.BookkeeperProtocol.AddRequest;\n import org.apache.bookkeeper.proto.BookkeeperProtocol.AddResponse;\n import org.apache.bookkeeper.proto.BookkeeperProtocol.BKPacketHeader;\n@@ -41,12 +45,9 @@\n import org.apache.bookkeeper.proto.BookkeeperProtocol.Request;\n import org.apache.bookkeeper.proto.BookkeeperProtocol.Response;\n import org.apache.bookkeeper.proto.BookkeeperProtocol.StatusCode;\n-import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n-import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ReadEntryCallback;\n-import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteCallback;\n import org.apache.bookkeeper.stats.NullStatsLogger;\n-import org.apache.bookkeeper.stats.StatsLogger;\n import org.apache.bookkeeper.stats.OpStatsLogger;\n+import org.apache.bookkeeper.stats.StatsLogger;\n import org.apache.bookkeeper.util.MathUtils;\n import org.apache.bookkeeper.util.OrderedSafeExecutor;\n import org.apache.bookkeeper.util.SafeRunnable;\n@@ -76,6 +77,9 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import com.google.common.collect.Sets;\n+import com.google.protobuf.ByteString;\n+\n /**\n  * This class manages all details of connection to a particular bookie. It also\n  * has reconnect logic if a connection to a bookie fails.\n@@ -85,6 +89,16 @@ public class PerChannelBookieClient extends SimpleChannelHandler implements Chan\n \n     static final Logger LOG = LoggerFactory.getLogger(PerChannelBookieClient.class);\n \n+    // this set contains the bookie error return codes that we do not consider for a bookie to be \"faulty\"\n+    private static final Set<Integer> expectedBkOperationErrors = Collections.unmodifiableSet(Sets\n+            .newHashSet(BKException.Code.BookieHandleNotAvailableException,\n+                        BKException.Code.NoSuchEntryException,\n+                        BKException.Code.NoSuchLedgerExistsException,\n+                        BKException.Code.LedgerFencedException,\n+                        BKException.Code.LedgerExistException,\n+                        BKException.Code.DuplicateEntryIdException,\n+                        BKException.Code.WriteOnReadOnlyBookieException));\n+\n     public static final int MAX_FRAME_LENGTH = 2 * 1024 * 1024; // 2M\n     public static final AtomicLong txnIdGenerator = new AtomicLong(0);\n \n@@ -119,14 +133,17 @@ enum ConnectionState {\n     final ReentrantReadWriteLock closeLock = new ReentrantReadWriteLock();\n     private final ClientConfiguration conf;\n \n+    private final PerChannelBookieClientPool pcbcPool;\n+\n     public PerChannelBookieClient(OrderedSafeExecutor executor, ClientSocketChannelFactory channelFactory,\n                                   BookieSocketAddress addr) {\n-        this(new ClientConfiguration(), executor, channelFactory, addr, null, NullStatsLogger.INSTANCE);\n+        this(new ClientConfiguration(), executor, channelFactory, addr, null, NullStatsLogger.INSTANCE, null);\n     }\n \n     public PerChannelBookieClient(ClientConfiguration conf, OrderedSafeExecutor executor,\n                                   ClientSocketChannelFactory channelFactory, BookieSocketAddress addr,\n-                                  HashedWheelTimer requestTimer, StatsLogger parentStatsLogger) {\n+                                  HashedWheelTimer requestTimer, StatsLogger parentStatsLogger,\n+                                  PerChannelBookieClientPool pcbcPool) {\n         this.conf = conf;\n         this.addr = addr;\n         this.executor = executor;\n@@ -147,6 +164,8 @@ public PerChannelBookieClient(ClientConfiguration conf, OrderedSafeExecutor exec\n         addEntryOpLogger = statsLogger.getOpStatsLogger(BookKeeperClientStats.CHANNEL_ADD_OP);\n         readTimeoutOpLogger = statsLogger.getOpStatsLogger(BookKeeperClientStats.CHANNEL_TIMEOUT_READ);\n         addTimeoutOpLogger = statsLogger.getOpStatsLogger(BookKeeperClientStats.CHANNEL_TIMEOUT_ADD);\n+\n+        this.pcbcPool = pcbcPool;\n     }\n \n     private void completeOperation(GenericCallback<PerChannelBookieClient> op, int rc) {\n@@ -299,7 +318,7 @@ void addEntry(final long ledgerId, byte[] masterKey, final long entryId, Channel\n         final int entrySize = toSend.readableBytes();\n         final CompletionKey completionKey = new CompletionKey(txnId, OperationType.ADD_ENTRY);\n         completionObjects.put(completionKey,\n-                new AddCompletion(addEntryOpLogger, cb, ctx, ledgerId, entryId,\n+                new AddCompletion(this, addEntryOpLogger, cb, ctx, ledgerId, entryId,\n                                   scheduleTimeout(completionKey, addEntryTimeout)));\n \n         // Build the request and calculate the total size to be included in the packet.\n@@ -360,7 +379,7 @@ public void readEntryAndFenceLedger(final long ledgerId, byte[] masterKey,\n         final long txnId = getTxnId();\n         final CompletionKey completionKey = new CompletionKey(txnId, OperationType.READ_ENTRY);\n         completionObjects.put(completionKey,\n-                new ReadCompletion(readEntryOpLogger, cb, ctx, ledgerId, entryId,\n+                new ReadCompletion(this, readEntryOpLogger, cb, ctx, ledgerId, entryId,\n                                    scheduleTimeout(completionKey, readEntryTimeout)));\n \n         // Build the request and calculate the total size to be included in the packet.\n@@ -415,7 +434,7 @@ public void readEntry(final long ledgerId, final long entryId, ReadEntryCallback\n         final long txnId = getTxnId();\n         final CompletionKey completionKey = new CompletionKey(txnId, OperationType.READ_ENTRY);\n         completionObjects.put(completionKey,\n-                new ReadCompletion(readEntryOpLogger, cb, ctx, ledgerId, entryId,\n+                new ReadCompletion(this, readEntryOpLogger, cb, ctx, ledgerId, entryId,\n                                    scheduleTimeout(completionKey, readEntryTimeout)));\n \n         // Build the request and calculate the total size to be included in the packet.\n@@ -619,6 +638,12 @@ void errorOutOutstandingEntries(int rc) {\n         }\n     }\n \n+    void recordError() {\n+        if (pcbcPool != null) {\n+            pcbcPool.recordError();\n+        }\n+    }\n+\n     /**\n      * In the netty pipeline, we need to split packets based on length, so we\n      * use the {@link LengthFieldBasedFrameDecoder}. Other than that all actions\n@@ -832,27 +857,34 @@ void cancelTimeout() {\n     static class ReadCompletion extends CompletionValue {\n         final ReadEntryCallback cb;\n \n-        public ReadCompletion(ReadEntryCallback cb, Object ctx,\n+        public ReadCompletion(final PerChannelBookieClient pcbc, ReadEntryCallback cb, Object ctx,\n                               long ledgerId, long entryId) {\n-            this(null, cb, ctx, ledgerId, entryId, null);\n+            this(pcbc, null, cb, ctx, ledgerId, entryId, null);\n         }\n \n-        public ReadCompletion(final OpStatsLogger readEntryOpLogger,\n+        public ReadCompletion(final PerChannelBookieClient pcbc, final OpStatsLogger readEntryOpLogger,\n                               final ReadEntryCallback originalCallback,\n                               final Object originalCtx, final long ledgerId, final long entryId,\n                               final Timeout timeout) {\n             super(originalCtx, ledgerId, entryId, timeout);\n             final long startTime = MathUtils.nowInNano();\n-            this.cb = null == readEntryOpLogger ? originalCallback : new ReadEntryCallback() {\n+            this.cb = new ReadEntryCallback() {\n                 @Override\n                 public void readEntryComplete(int rc, long ledgerId, long entryId, ChannelBuffer buffer, Object ctx) {\n                     cancelTimeout();\n-                    long latency = MathUtils.elapsedNanos(startTime);\n-                    if (rc != BKException.Code.OK) {\n-                        readEntryOpLogger.registerFailedEvent(latency, TimeUnit.NANOSECONDS);\n-                    } else {\n-                        readEntryOpLogger.registerSuccessfulEvent(latency, TimeUnit.NANOSECONDS);\n+                    if (readEntryOpLogger != null) {\n+                        long latency = MathUtils.elapsedNanos(startTime);\n+                        if (rc != BKException.Code.OK) {\n+                            readEntryOpLogger.registerFailedEvent(latency, TimeUnit.NANOSECONDS);\n+                        } else {\n+                            readEntryOpLogger.registerSuccessfulEvent(latency, TimeUnit.NANOSECONDS);\n+                        }\n+                    }\n+\n+                    if (rc != BKException.Code.OK && !expectedBkOperationErrors.contains(rc)) {\n+                        pcbc.recordError();\n                     }\n+\n                     originalCallback.readEntryComplete(rc, ledgerId, entryId, buffer, originalCtx);\n                 }\n             };\n@@ -863,12 +895,12 @@ public void readEntryComplete(int rc, long ledgerId, long entryId, ChannelBuffer\n     static class AddCompletion extends CompletionValue {\n         final WriteCallback cb;\n \n-        public AddCompletion(WriteCallback cb, Object ctx,\n+        public AddCompletion(final PerChannelBookieClient pcbc, WriteCallback cb, Object ctx,\n                              long ledgerId, long entryId) {\n-            this(null, cb, ctx, ledgerId, entryId, null);\n+            this(pcbc, null, cb, ctx, ledgerId, entryId, null);\n         }\n \n-        public AddCompletion(final OpStatsLogger addEntryOpLogger,\n+        public AddCompletion(final PerChannelBookieClient pcbc, final OpStatsLogger addEntryOpLogger,\n                              final WriteCallback originalCallback,\n                              final Object originalCtx, final long ledgerId, final long entryId,\n                              final Timeout timeout) {\n@@ -878,12 +910,19 @@ public AddCompletion(final OpStatsLogger addEntryOpLogger,\n                 @Override\n                 public void writeComplete(int rc, long ledgerId, long entryId, BookieSocketAddress addr, Object ctx) {\n                     cancelTimeout();\n-                    long latency = MathUtils.elapsedNanos(startTime);\n-                    if (rc != BKException.Code.OK) {\n-                        addEntryOpLogger.registerFailedEvent(latency, TimeUnit.NANOSECONDS);\n-                    } else {\n-                        addEntryOpLogger.registerSuccessfulEvent(latency, TimeUnit.NANOSECONDS);\n+                    if (pcbc.addEntryOpLogger != null) {\n+                        long latency = MathUtils.elapsedNanos(startTime);\n+                        if (rc != BKException.Code.OK) {\n+                            pcbc.addEntryOpLogger.registerFailedEvent(latency, TimeUnit.NANOSECONDS);\n+                        } else {\n+                            pcbc.addEntryOpLogger.registerSuccessfulEvent(latency, TimeUnit.NANOSECONDS);\n+                        }\n                     }\n+\n+                    if (rc != BKException.Code.OK && !expectedBkOperationErrors.contains(rc)) {\n+                        pcbc.recordError();\n+                    }\n+\n                     originalCallback.writeComplete(rc, ledgerId, entryId, addr, originalCtx);\n                 }\n             };\n@@ -943,10 +982,10 @@ public void run(Timeout timeout) throws Exception {\n                 return;\n             }\n             if (OperationType.ADD_ENTRY == operationType) {\n-                errorOutAddKey(this);\n+                errorOutAddKey(this, BKException.Code.TimeoutException);\n                 addTimeoutOpLogger.registerSuccessfulEvent(elapsedTime(), TimeUnit.NANOSECONDS);\n             } else {\n-                errorOutReadKey(this);\n+                errorOutReadKey(this, BKException.Code.TimeoutException);\n                 readTimeoutOpLogger.registerSuccessfulEvent(elapsedTime(), TimeUnit.NANOSECONDS);\n             }\n         }"},{"sha":"69d559e333f5686c99587dc177808ba4f06a16a8","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClientFactory.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/c8255f8c5f73a2353293ec1d9612dbb98f291ccc/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FPerChannelBookieClientFactory.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/c8255f8c5f73a2353293ec1d9612dbb98f291ccc/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FPerChannelBookieClientFactory.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FPerChannelBookieClientFactory.java?ref=c8255f8c5f73a2353293ec1d9612dbb98f291ccc","patch":"@@ -33,5 +33,5 @@ interface PerChannelBookieClientFactory {\n      *\n      * @return the client connected to address.\n      */\n-    PerChannelBookieClient create(BookieSocketAddress address);\n+    PerChannelBookieClient create(BookieSocketAddress address, PerChannelBookieClientPool pcbcPool);\n }"},{"sha":"4a735f9514d886cde6c8550f67f8b01880289af0","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClientPool.java","status":"modified","additions":5,"deletions":0,"changes":5,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/c8255f8c5f73a2353293ec1d9612dbb98f291ccc/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FPerChannelBookieClientPool.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/c8255f8c5f73a2353293ec1d9612dbb98f291ccc/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FPerChannelBookieClientPool.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FPerChannelBookieClientPool.java?ref=c8255f8c5f73a2353293ec1d9612dbb98f291ccc","patch":"@@ -40,6 +40,11 @@ interface PerChannelBookieClientPool {\n      */\n     void obtain(GenericCallback<PerChannelBookieClient> callback);\n \n+    /**\n+     * record any read/write error on {@link PerChannelBookieClientPool}\n+     */\n+    void recordError();\n+\n     /**\n      * Disconnect the connections in the pool.\n      *"},{"sha":"33be97c0d120f11a6cba5431cd4be66c386eb99d","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/TestBookieHealthCheck.java","status":"added","additions":149,"deletions":0,"changes":149,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/c8255f8c5f73a2353293ec1d9612dbb98f291ccc/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FTestBookieHealthCheck.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/c8255f8c5f73a2353293ec1d9612dbb98f291ccc/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FTestBookieHealthCheck.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FTestBookieHealthCheck.java?ref=c8255f8c5f73a2353293ec1d9612dbb98f291ccc","patch":"@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+\n+package org.apache.bookkeeper.client;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.bookkeeper.client.AsyncCallback.AddCallback;\n+import org.apache.bookkeeper.net.BookieSocketAddress;\n+import org.apache.bookkeeper.test.BookKeeperClusterTestCase;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class TestBookieHealthCheck extends BookKeeperClusterTestCase {\n+    private final static Logger LOG = LoggerFactory.getLogger(TestBookieHealthCheck.class);\n+\n+    public TestBookieHealthCheck() {\n+        super(4);\n+        baseClientConf.setAddEntryTimeout(1);\n+        baseClientConf.enableBookieHealthCheck();\n+        baseClientConf.setBookieHealthCheckInterval(1, TimeUnit.SECONDS);\n+        baseClientConf.setBookieErrorThresholdPerInterval(1);\n+        baseClientConf.setBookieQuarantineTime(5, TimeUnit.SECONDS);\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testBkQuarantine() throws Exception {\n+        LedgerHandle lh = bkc.createLedger(2, 2, 2, BookKeeper.DigestType.CRC32, new byte[] {});\n+\n+        final int numEntries = 10;\n+        for (int i = 0; i < numEntries; i++) {\n+            byte[] msg = (\"msg-\" + i).getBytes();\n+            lh.addEntry(msg);\n+        }\n+\n+        BookieSocketAddress bookieToQuarantine = lh.getLedgerMetadata().getEnsemble(numEntries).get(0);\n+        sleepBookie(bookieToQuarantine, baseClientConf.getAddEntryTimeout() * 2).await();\n+\n+        byte[] tempMsg = \"temp-msg\".getBytes();\n+        lh.asyncAddEntry(tempMsg, new AddCallback() {\n+\n+            @Override\n+            public void addComplete(int rc, LedgerHandle lh, long entryId, Object ctx) {\n+                // no-op\n+            }\n+        }, null);\n+\n+        // make sure the add entry timeouts\n+        Thread.sleep(baseClientConf.getAddEntryTimeout() * 2 * 1000);\n+\n+        // make sure the health check runs once after the timeout\n+        Thread.sleep(baseClientConf.getBookieHealthCheckIntervalSeconds() * 2 * 1000);\n+\n+        // the bookie watcher should contain the bookieToQuarantine in the quarantine set\n+        Assert.assertTrue(bkc.bookieWatcher.quarantinedBookies.asMap().containsKey(bookieToQuarantine));\n+\n+        // the bookie to be left out of the ensemble should always be the quarantined bookie\n+        LedgerHandle lh1 = bkc.createLedger(2, 2, 2, BookKeeper.DigestType.CRC32, new byte[] {});\n+        LedgerHandle lh2 = bkc.createLedger(3, 3, 3, BookKeeper.DigestType.CRC32, new byte[] {});\n+        Assert.assertFalse(lh1.getLedgerMetadata().getEnsemble(0).contains(bookieToQuarantine));\n+        Assert.assertFalse(lh2.getLedgerMetadata().getEnsemble(0).contains(bookieToQuarantine));\n+\n+        // the quarantined bookie can still be in the ensemble if we do not have enough healthy bookies\n+        LedgerHandle lh3 = bkc.createLedger(4, 4, 4, BookKeeper.DigestType.CRC32, new byte[] {});\n+        Assert.assertTrue(lh3.getLedgerMetadata().getEnsemble(0).contains(bookieToQuarantine));\n+\n+        // make sure faulty bookie is out of quarantine\n+        Thread.sleep(baseClientConf.getBookieQuarantineTimeSeconds() * 1000);\n+\n+        // the bookie should not be quarantined anymore\n+        Assert.assertFalse(bkc.bookieWatcher.quarantinedBookies.asMap().containsKey(bookieToQuarantine));\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testNoQuarantineOnBkRestart() throws Exception {\n+        final LedgerHandle lh = bkc.createLedger(2, 2, 2, BookKeeper.DigestType.CRC32, new byte[] {});\n+        final int numEntries = 20;\n+        BookieSocketAddress bookieToRestart = lh.getLedgerMetadata().getEnsemble(0).get(0);\n+\n+        // we add entries on a separate thread so that we can restart a bookie on the current thread\n+        Thread addEntryThread = new Thread() {\n+            public void run() {\n+                for (int i = 0; i < numEntries; i++) {\n+                    byte[] msg = (\"msg-\" + i).getBytes();\n+                    try {\n+                        lh.addEntry(msg);\n+                        // we add sufficient sleep to make sure all entries are not added before we restart the bookie\n+                        Thread.sleep(100);\n+                    } catch (Exception e) {\n+                        LOG.error(\"Error sending msg\");\n+                    }\n+                }\n+            }\n+        };\n+        addEntryThread.start();\n+        restartBookie(bookieToRestart);\n+\n+        // make sure the health check runs once\n+        Thread.sleep(baseClientConf.getBookieHealthCheckIntervalSeconds() * 2 * 1000);\n+\n+        // the bookie watcher should not contain the bookieToRestart in the quarantine set\n+        Assert.assertFalse(bkc.bookieWatcher.quarantinedBookies.asMap().containsKey(bookieToRestart));\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testNoQuarantineOnExpectedBkErrors() throws Exception {\n+        final LedgerHandle lh = bkc.createLedger(2, 2, 2, BookKeeper.DigestType.CRC32, new byte[] {});\n+        final int numEntries = 10;\n+        for (int i = 0; i < numEntries; i++) {\n+            byte[] msg = (\"msg-\" + i).getBytes();\n+            lh.addEntry(msg);\n+        }\n+        BookieSocketAddress bookie1 = lh.getLedgerMetadata().getEnsemble(0).get(0);\n+        BookieSocketAddress bookie2 = lh.getLedgerMetadata().getEnsemble(0).get(1);\n+        try {\n+            // we read an entry that is not added\n+            lh.readEntries(10, 10);\n+        } catch (BKException e) {\n+            // ok\n+        }\n+\n+        // make sure the health check runs once\n+        Thread.sleep(baseClientConf.getBookieHealthCheckIntervalSeconds() * 2 * 1000);\n+\n+        // the bookie watcher should not contain the bookieToRestart in the quarantine set\n+        Assert.assertFalse(bkc.bookieWatcher.quarantinedBookies.asMap().containsKey(bookie1));\n+        Assert.assertFalse(bkc.bookieWatcher.quarantinedBookies.asMap().containsKey(bookie2));\n+    }\n+\n+}"},{"sha":"278dc8c2c6f1533fe77ae4d3eb26830c4f4e4453","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookKeeperClusterTestCase.java","status":"modified","additions":33,"deletions":0,"changes":33,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/c8255f8c5f73a2353293ec1d9612dbb98f291ccc/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Ftest%2FBookKeeperClusterTestCase.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/c8255f8c5f73a2353293ec1d9612dbb98f291ccc/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Ftest%2FBookKeeperClusterTestCase.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Ftest%2FBookKeeperClusterTestCase.java?ref=c8255f8c5f73a2353293ec1d9612dbb98f291ccc","patch":"@@ -350,6 +350,39 @@ public void restartBookies()\n         restartBookies(null);\n     }\n \n+    /**\n+     * Restart a bookie. Also restart the respective auto recovery process,\n+     * if isAutoRecoveryEnabled is true.\n+     * \n+     * @param addr\n+     * @throws InterruptedException\n+     * @throws IOException\n+     * @throws KeeperException\n+     * @throws BookieException\n+     */\n+    public void restartBookie(BookieSocketAddress addr) throws Exception {\n+        BookieServer toRemove = null;\n+        int toRemoveIndex = 0;\n+        for (BookieServer server : bs) {\n+            if (server.getLocalAddress().equals(addr)) {\n+                server.shutdown();\n+                toRemove = server;\n+                break;\n+            }\n+            ++toRemoveIndex;\n+        }\n+        if (toRemove != null) {\n+            stopAutoRecoveryService(toRemove);\n+            bs.remove(toRemove);\n+            ServerConfiguration newConfig = bsConfs.remove(toRemoveIndex);\n+            Thread.sleep(1000);\n+            bs.add(startBookie(newConfig));\n+            bsConfs.add(newConfig);\n+            return;\n+        }\n+        throw new IOException(\"Bookie not found\");\n+    }\n+\n     /**\n      * Restart bookie servers using new configuration settings. Also restart the\n      * respective auto recovery process, if isAutoRecoveryEnabled is true."},{"sha":"cf2b251302a15294b0879a7d12280c6789e10e7b","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/ReadOnlyBookieTest.java","status":"modified","additions":12,"deletions":2,"changes":14,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/c8255f8c5f73a2353293ec1d9612dbb98f291ccc/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Ftest%2FReadOnlyBookieTest.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/c8255f8c5f73a2353293ec1d9612dbb98f291ccc/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Ftest%2FReadOnlyBookieTest.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Ftest%2FReadOnlyBookieTest.java?ref=c8255f8c5f73a2353293ec1d9612dbb98f291ccc","patch":"@@ -20,6 +20,11 @@\n  */\n package org.apache.bookkeeper.test;\n \n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n import java.io.File;\n import java.util.Enumeration;\n \n@@ -33,8 +38,6 @@\n import org.apache.bookkeeper.conf.ServerConfiguration;\n import org.junit.Test;\n \n-import static org.junit.Assert.*;\n-\n /**\n  * Test to verify the readonly feature of bookies\n  */\n@@ -139,6 +142,13 @@ public void testBookieShouldTurnWritableFromReadOnly() throws Exception {\n         // Now add the current ledger dir back to writable dirs list\n         ledgerDirsManager.addToWritableDirs(testDir, true);\n \n+        // since the bookie transitions to write mode asynchronously, we need to wait for the bookie to be registered on\n+        // zk\n+        while (zkc.exists(baseConf.getZkAvailableBookiesPath() + \"/\"\n+                + Bookie.getBookieAddress(bsConfs.get(1)).toString(), false) == null) {\n+            Thread.sleep(100);\n+        }\n+\n         LOG.info(\"bookie is running {}, readonly {}.\", bookie.isRunning(), bookie.isReadOnly());\n         assertTrue(\"Bookie should be running and converted back to writable mode\", bookie.isRunning()\n                 && !bookie.isReadOnly());"}]}