{"sha":"99b40326fed855906b709cbe1f562f45bda79e5d","node_id":"MDY6Q29tbWl0NDc4NTkyNTI2Ojk5YjQwMzI2ZmVkODU1OTA2YjcwOWNiZTFmNTYyZjQ1YmRhNzllNWQ=","commit":{"author":{"name":"Ivan Kelly","email":"ivank@apache.org","date":"2015-01-13T12:06:18Z"},"committer":{"name":"Ivan Kelly","email":"ivank@apache.org","date":"2015-01-13T12:06:18Z"},"message":"BOOKKEEPER-634: Provide admin tool to rename bookie identifier in ledger metadata (rakeshr via ivank)","tree":{"sha":"3db6425ba6049cb5ac6e6c8870cc81f5d02dc937","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/trees/3db6425ba6049cb5ac6e6c8870cc81f5d02dc937"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/commits/99b40326fed855906b709cbe1f562f45bda79e5d","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/99b40326fed855906b709cbe1f562f45bda79e5d","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/99b40326fed855906b709cbe1f562f45bda79e5d","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/99b40326fed855906b709cbe1f562f45bda79e5d/comments","author":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"committer":{"login":"ivankelly","id":54955,"node_id":"MDQ6VXNlcjU0OTU1","avatar_url":"https://avatars.githubusercontent.com/u/54955?v=4","gravatar_id":"","url":"https://api.github.com/users/ivankelly","html_url":"https://github.com/ivankelly","followers_url":"https://api.github.com/users/ivankelly/followers","following_url":"https://api.github.com/users/ivankelly/following{/other_user}","gists_url":"https://api.github.com/users/ivankelly/gists{/gist_id}","starred_url":"https://api.github.com/users/ivankelly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ivankelly/subscriptions","organizations_url":"https://api.github.com/users/ivankelly/orgs","repos_url":"https://api.github.com/users/ivankelly/repos","events_url":"https://api.github.com/users/ivankelly/events{/privacy}","received_events_url":"https://api.github.com/users/ivankelly/received_events","type":"User","site_admin":false},"parents":[{"sha":"4050e79654704ebc0224cc024980e297fdc56473","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/4050e79654704ebc0224cc024980e297fdc56473","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/4050e79654704ebc0224cc024980e297fdc56473"}],"stats":{"total":829,"additions":821,"deletions":8},"files":[{"sha":"66df55baf37eed3c182da829a5c334e4fa49d99b","filename":"CHANGES.txt","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/99b40326fed855906b709cbe1f562f45bda79e5d/CHANGES.txt","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/99b40326fed855906b709cbe1f562f45bda79e5d/CHANGES.txt","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/CHANGES.txt?ref=99b40326fed855906b709cbe1f562f45bda79e5d","patch":"@@ -44,6 +44,8 @@ Trunk (unreleased changes)\n \n       BOOKKEEPER-832: Allow starting bookie in ReadOnly mode (zhaijia via ivank)\n \n+      BOOKKEEPER-634: Provide admin tool to rename bookie identifier in ledger metadata (rakeshr via ivank)\n+\n       bookkeeper-client:\n \n         BOOKKEEPER-810: Allow to configure TCP connect timeout (Charles Xie via sijie)"},{"sha":"48a76fb98880a60328a7844af4af589e6e61845d","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/bookie/BookieShell.java","status":"modified","additions":134,"deletions":7,"changes":141,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/99b40326fed855906b709cbe1f562f45bda79e5d/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FBookieShell.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/99b40326fed855906b709cbe1f562f45bda79e5d/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FBookieShell.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fbookie%2FBookieShell.java?ref=99b40326fed855906b709cbe1f562f45bda79e5d","patch":"@@ -41,6 +41,7 @@\n import org.apache.bookkeeper.client.BookKeeper;\n import org.apache.bookkeeper.client.LedgerHandle;\n import org.apache.bookkeeper.client.LedgerMetadata;\n+import org.apache.bookkeeper.client.UpdateLedgerOp;\n import org.apache.bookkeeper.conf.ClientConfiguration;\n import org.apache.bookkeeper.conf.ServerConfiguration;\n import org.apache.bookkeeper.meta.LedgerManager;\n@@ -50,6 +51,7 @@\n import org.apache.bookkeeper.meta.LedgerUnderreplicationManager;\n import org.apache.bookkeeper.net.BookieSocketAddress;\n import org.apache.bookkeeper.util.EntryFormatter;\n+import org.apache.bookkeeper.util.MathUtils;\n import org.apache.bookkeeper.util.Tool;\n import org.apache.bookkeeper.util.ZkUtils;\n import org.apache.bookkeeper.versioning.Version;\n@@ -101,6 +103,7 @@ public class BookieShell implements Tool {\n     static final String CMD_AUTORECOVERY = \"autorecovery\";\n     static final String CMD_LISTBOOKIES = \"listbookies\";\n     static final String CMD_UPDATECOOKIE = \"updatecookie\";\n+    static final String CMD_UPDATELEDGER = \"updateledgers\";\n     static final String CMD_HELP = \"help\";\n \n     final ServerConfiguration bkConf = new ServerConfiguration();\n@@ -1163,13 +1166,6 @@ private int updateBookieIdInCookie(final String bookieId, final boolean useHostn\n             return 0;\n         }\n \n-        private boolean getOptionalValue(String optValue, String optName) {\n-            if (StringUtils.equals(optValue, optName)) {\n-                return true;\n-            }\n-            return false;\n-        }\n-\n         private boolean verifyCookie(Cookie oldCookie, File dir) throws IOException {\n             try {\n                 Cookie cookie = Cookie.readFromDirectory(dir);\n@@ -1181,6 +1177,121 @@ private boolean verifyCookie(Cookie oldCookie, File dir) throws IOException {\n         }\n     }\n \n+    /**\n+     * Update ledger command\n+     */\n+    class UpdateLedgerCmd extends MyCommand {\n+        private final Options opts = new Options();\n+\n+        UpdateLedgerCmd() {\n+            super(CMD_UPDATELEDGER);\n+            opts.addOption(\"b\", \"bookieId\", true, \"Bookie Id\");\n+            opts.addOption(\"s\", \"updatespersec\", true, \"Number of ledgers updating per second (default: 5 per sec)\");\n+            opts.addOption(\"l\", \"limit\", true, \"Maximum number of ledgers to update (default: no limit)\");\n+            opts.addOption(\"v\", \"verbose\", true, \"Print status of the ledger updation (default: false)\");\n+            opts.addOption(\"p\", \"printprogress\", true,\n+                    \"Print messages on every configured seconds if verbose turned on (default: 10 secs)\");\n+        }\n+\n+        @Override\n+        Options getOptions() {\n+            return opts;\n+        }\n+\n+        @Override\n+        String getDescription() {\n+            return \"Update bookie id in ledgers (this may take a long time)\";\n+        }\n+\n+        @Override\n+        String getUsage() {\n+            return \"updateledger -bookieId <hostname|ip> [-updatespersec N] [-limit N] [-verbose true/false] [-printprogress N]\";\n+        }\n+\n+        @Override\n+        int runCmd(CommandLine cmdLine) throws Exception {\n+            final String bookieId = cmdLine.getOptionValue(\"bookieId\");\n+            if (StringUtils.isBlank(bookieId)) {\n+                LOG.error(\"Invalid argument list!\");\n+                this.printUsage();\n+                return -1;\n+            }\n+            if (!StringUtils.equals(bookieId, \"hostname\") && !StringUtils.equals(bookieId, \"ip\")) {\n+                LOG.error(\"Invalid option value {} for bookieId, expected hostname/ip\", bookieId);\n+                this.printUsage();\n+                return -1;\n+            }\n+            boolean useHostName = getOptionalValue(bookieId, \"hostname\");\n+            if (!bkConf.getUseHostNameAsBookieID() && useHostName) {\n+                LOG.error(\"Expects configuration useHostNameAsBookieID=true as the option value passed is 'hostname'\");\n+                return -1;\n+            } else if (bkConf.getUseHostNameAsBookieID() && !useHostName) {\n+                LOG.error(\"Expects configuration useHostNameAsBookieID=false as the option value passed is 'ip'\");\n+                return -1;\n+            }\n+            final int rate = getOptionIntValue(cmdLine, \"updatespersec\", 5);\n+            if (rate <= 0) {\n+                LOG.error(\"Invalid updatespersec {}, should be > 0\", rate);\n+                return -1;\n+            }\n+            final int limit = getOptionIntValue(cmdLine, \"limit\", Integer.MIN_VALUE);\n+            if (limit <= 0 && limit != Integer.MIN_VALUE) {\n+                LOG.error(\"Invalid limit {}, should be > 0\", limit);\n+                return -1;\n+            }\n+            final boolean verbose = getOptionBooleanValue(cmdLine, \"verbose\", false);\n+            final long printprogress;\n+            if (!verbose) {\n+                if (cmdLine.hasOption(\"printprogress\")) {\n+                    LOG.warn(\"Ignoring option 'printprogress', this is applicable when 'verbose' is true\");\n+                }\n+                printprogress = Integer.MIN_VALUE;\n+            } else {\n+                // defaulting to 10 seconds\n+                printprogress = getOptionLongValue(cmdLine, \"printprogress\", 10);\n+            }\n+            final ClientConfiguration conf = new ClientConfiguration();\n+            conf.addConfiguration(bkConf);\n+            final BookKeeper bk = new BookKeeper(conf);\n+            final BookKeeperAdmin admin = new BookKeeperAdmin(conf);\n+            final UpdateLedgerOp updateLedgerOp = new UpdateLedgerOp(bk, admin);\n+            final ServerConfiguration serverConf = new ServerConfiguration(bkConf);\n+            final BookieSocketAddress newBookieId = Bookie.getBookieAddress(serverConf);\n+            serverConf.setUseHostNameAsBookieID(!useHostName);\n+            final BookieSocketAddress oldBookieId = Bookie.getBookieAddress(serverConf);\n+\n+            UpdateLedgerNotifier progressable = new UpdateLedgerNotifier() {\n+                long lastReport = System.nanoTime();\n+\n+                @Override\n+                public void progress(long updated, long issued) {\n+                    if (printprogress <= 0) {\n+                        return; // disabled\n+                    }\n+                    if (TimeUnit.MILLISECONDS.toSeconds(MathUtils.elapsedMSec(lastReport)) >= printprogress) {\n+                        LOG.info(\"Number of ledgers issued={}, updated={}\", issued, updated);\n+                        lastReport = MathUtils.nowInNano();\n+                    }\n+                }\n+            };\n+            try {\n+                updateLedgerOp.updateBookieIdInLedgers(oldBookieId, newBookieId, rate, limit, progressable);\n+            } catch (BKException | IOException e) {\n+                LOG.error(\"Failed to update ledger metadata\", e);\n+                return -1;\n+            }\n+            return 0;\n+        }\n+\n+    }\n+\n+    /**\n+     * A facility for reporting update ledger progress.\n+     */\n+    public interface UpdateLedgerNotifier {\n+        void progress(long updated, long issued);\n+    }\n+\n     final Map<String, MyCommand> commands = new HashMap<String, MyCommand>();\n     {\n         commands.put(CMD_METAFORMAT, new MetaFormatCmd());\n@@ -1198,6 +1309,7 @@ private boolean verifyCookie(Cookie oldCookie, File dir) throws IOException {\n         commands.put(CMD_AUTORECOVERY, new AutoRecoveryCmd());\n         commands.put(CMD_LISTBOOKIES, new ListBookiesCmd());\n         commands.put(CMD_UPDATECOOKIE, new UpdateCookieCmd());\n+        commands.put(CMD_UPDATELEDGER, new UpdateLedgerCmd());\n         commands.put(CMD_HELP, new HelpCmd());\n     }\n \n@@ -1578,4 +1690,19 @@ private static long getOptionLongValue(CommandLine cmdLine, String option, long\n         }\n         return defaultVal;\n     }\n+\n+    private static boolean getOptionBooleanValue(CommandLine cmdLine, String option, boolean defaultVal) {\n+        if (cmdLine.hasOption(option)) {\n+            String val = cmdLine.getOptionValue(option);\n+            return Boolean.parseBoolean(val);\n+        }\n+        return defaultVal;\n+    }\n+\n+    private static boolean getOptionalValue(String optValue, String optName) {\n+        if (StringUtils.equals(optValue, optName)) {\n+            return true;\n+        }\n+        return false;\n+    }\n }"},{"sha":"9d9f3319dbf8405348b54d006d1b3692785d6c30","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/UpdateLedgerOp.java","status":"added","additions":246,"deletions":0,"changes":246,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/99b40326fed855906b709cbe1f562f45bda79e5d/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FUpdateLedgerOp.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/99b40326fed855906b709cbe1f562f45bda79e5d/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FUpdateLedgerOp.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FUpdateLedgerOp.java?ref=99b40326fed855906b709cbe1f562f45bda79e5d","patch":"@@ -0,0 +1,246 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.bookkeeper.client;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.apache.bookkeeper.bookie.BookieShell.UpdateLedgerNotifier;\n+import org.apache.bookkeeper.net.BookieSocketAddress;\n+import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.util.concurrent.AbstractFuture;\n+import com.google.common.util.concurrent.FutureCallback;\n+import com.google.common.util.concurrent.Futures;\n+import com.google.common.util.concurrent.RateLimiter;\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+\n+/**\n+ * Encapsulates updating the ledger metadata operation\n+ */\n+public class UpdateLedgerOp {\n+\n+    private final static Logger LOG = LoggerFactory.getLogger(UpdateLedgerOp.class);\n+    private final BookKeeper bkc;\n+    private final BookKeeperAdmin admin;\n+\n+    public UpdateLedgerOp(final BookKeeper bkc, final BookKeeperAdmin admin) {\n+        this.bkc = bkc;\n+        this.admin = admin;\n+    }\n+\n+    /**\n+     * Update the bookie id present in the ledger metadata.\n+     *\n+     * @param oldBookieId\n+     *            current bookie id\n+     * @param newBookieId\n+     *            new bookie id\n+     * @param rate\n+     *            number of ledgers updating per second (default 5 per sec)\n+     * @param limit\n+     *            maximum number of ledgers to update (default: no limit). Stop\n+     *            update if reaching limit\n+     * @param progressable\n+     *            report progress of the ledger updates\n+     * @throws IOException\n+     *             if there is an error when updating bookie id in ledger\n+     *             metadata\n+     * @throws InterruptedException\n+     *             interrupted exception when update ledger meta\n+     */\n+    public void updateBookieIdInLedgers(final BookieSocketAddress oldBookieId, final BookieSocketAddress newBookieId,\n+            final int rate, final int limit, final UpdateLedgerNotifier progressable) throws BKException, IOException {\n+\n+        final ThreadFactoryBuilder tfb = new ThreadFactoryBuilder().setNameFormat(\"UpdateLedgerThread\").setDaemon(true);\n+        final ExecutorService executor = Executors.newSingleThreadExecutor(tfb.build());\n+        final AtomicInteger issuedLedgerCnt = new AtomicInteger();\n+        final AtomicInteger updatedLedgerCnt = new AtomicInteger();\n+        final Future<?> updateBookieCb = executor.submit(new Runnable() {\n+\n+            @Override\n+            public void run() {\n+                updateLedgers(oldBookieId, newBookieId, rate, limit, progressable);\n+            }\n+\n+            private void updateLedgers(final BookieSocketAddress oldBookieId, final BookieSocketAddress newBookieId,\n+                    final int rate, final int limit, final UpdateLedgerNotifier progressable) {\n+                try {\n+                    final AtomicBoolean stop = new AtomicBoolean(false);\n+                    final Set<Long> outstandings = Collections.newSetFromMap(new ConcurrentHashMap<Long, Boolean>());\n+                    final RateLimiter throttler = RateLimiter.create(rate);\n+                    final Iterator<Long> ledgerItr = admin.listLedgers().iterator();\n+                    final CountDownLatch syncObj = new CountDownLatch(1);\n+\n+                    // iterate through all the ledgers\n+                    while (ledgerItr.hasNext() && !stop.get()) {\n+                        // throttler to control updates per second\n+                        throttler.acquire();\n+\n+                        final Long lId = ledgerItr.next();\n+                        final ReadLedgerMetadataCb readCb = new ReadLedgerMetadataCb(bkc, lId, oldBookieId, newBookieId);\n+                        outstandings.add(lId);\n+\n+                        FutureCallback<Void> updateLedgerCb = new UpdateLedgerCb(lId, stop, issuedLedgerCnt,\n+                                updatedLedgerCnt, outstandings, syncObj, progressable);\n+                        Futures.addCallback(readCb, updateLedgerCb);\n+\n+                        issuedLedgerCnt.incrementAndGet();\n+                        if (limit != Integer.MIN_VALUE && issuedLedgerCnt.get() >= limit || !ledgerItr.hasNext()) {\n+                            stop.set(true);\n+                        }\n+                        bkc.getLedgerManager().readLedgerMetadata(lId, readCb);\n+                    }\n+                    // waiting till all the issued ledgers are finished\n+                    syncObj.await();\n+                } catch (IOException ioe) {\n+                    LOG.error(\"Exception while updating ledger\", ioe);\n+                    throw new RuntimeException(\"Exception while updating ledger\", ioe.getCause());\n+                } catch (InterruptedException ie) {\n+                    LOG.error(\"Exception while updating ledger metadata\", ie);\n+                    Thread.currentThread().interrupt();\n+                    throw new RuntimeException(\"Exception while updating ledger\", ie.getCause());\n+                }\n+            }\n+        });\n+        try {\n+            // Wait to finish the issued ledgers.\n+            updateBookieCb.get();\n+        } catch (ExecutionException ee) {\n+            throw new IOException(\"Exception while updating ledger\", ee);\n+        } catch (InterruptedException ie) {\n+            Thread.currentThread().interrupt();\n+            throw new IOException(\"Exception while updating ledger\", ie);\n+        } finally {\n+            executor.shutdown();\n+        }\n+    }\n+\n+    private final static class UpdateLedgerCb implements FutureCallback<Void> {\n+        final long ledgerId;\n+        final AtomicBoolean stop;\n+        final AtomicInteger issuedLedgerCnt;\n+        final AtomicInteger updatedLedgerCnt;\n+        final Set<Long> outstandings;\n+        final CountDownLatch syncObj;\n+        final UpdateLedgerNotifier progressable;\n+\n+        public UpdateLedgerCb(long ledgerId, AtomicBoolean stop, AtomicInteger issuedLedgerCnt,\n+                AtomicInteger updatedLedgerCnt, Set<Long> outstandings, CountDownLatch syncObj,\n+                UpdateLedgerNotifier progressable) {\n+            this.ledgerId = ledgerId;\n+            this.stop = stop;\n+            this.issuedLedgerCnt = issuedLedgerCnt;\n+            this.updatedLedgerCnt = updatedLedgerCnt;\n+            this.outstandings = outstandings;\n+            this.syncObj = syncObj;\n+            this.progressable = progressable;\n+        }\n+\n+        @Override\n+        public void onFailure(Throwable th) {\n+            LOG.error(\"Error updating ledger {}\", ledgerId, th);\n+            stop.set(true);\n+            finishUpdateLedger();\n+        }\n+\n+        @Override\n+        public void onSuccess(Void obj) {\n+            updatedLedgerCnt.incrementAndGet();\n+            // may print progress\n+            progressable.progress(updatedLedgerCnt.get(), issuedLedgerCnt.get());\n+            finishUpdateLedger();\n+        }\n+\n+        private void finishUpdateLedger() {\n+            outstandings.remove(ledgerId);\n+            if (outstandings.isEmpty() && stop.get()) {\n+                LOG.info(\"Total number of ledgers issued={} updated={}\", issuedLedgerCnt.get(), updatedLedgerCnt.get());\n+                syncObj.countDown();\n+            }\n+        }\n+    }\n+\n+    private final static class ReadLedgerMetadataCb extends AbstractFuture<Void> implements\n+            GenericCallback<LedgerMetadata> {\n+        final BookKeeper bkc;\n+        final Long ledgerId;\n+        final BookieSocketAddress curBookieAddr;\n+        final BookieSocketAddress toBookieAddr;\n+\n+        public ReadLedgerMetadataCb(BookKeeper bkc, Long ledgerId, BookieSocketAddress curBookieAddr,\n+                BookieSocketAddress toBookieAddr) {\n+            this.bkc = bkc;\n+            this.ledgerId = ledgerId;\n+            this.curBookieAddr = curBookieAddr;\n+            this.toBookieAddr = toBookieAddr;\n+        }\n+\n+        @Override\n+        public void operationComplete(int rc, LedgerMetadata metadata) {\n+            if (BKException.Code.NoSuchLedgerExistsException == rc) {\n+                set(null);\n+                return; // this is OK\n+            } else if (BKException.Code.OK != rc) {\n+                // open ledger failed.\n+                LOG.error(\"Get ledger metadata {} failed. Error code {}\", ledgerId, rc);\n+                setException(BKException.create(rc));\n+                return;\n+            }\n+            boolean updateEnsemble = false;\n+            for (ArrayList<BookieSocketAddress> ensembles : metadata.getEnsembles().values()) {\n+                int index = ensembles.indexOf(curBookieAddr);\n+                if (-1 != index) {\n+                    ensembles.set(index, toBookieAddr);\n+                    updateEnsemble = true;\n+                }\n+            }\n+            if (!updateEnsemble) {\n+                set(null);\n+                return; // ledger doesn't contains the given curBookieId\n+            }\n+            final GenericCallback<Void> writeCb = new GenericCallback<Void>() {\n+                @Override\n+                public void operationComplete(int rc, Void result) {\n+                    if (rc != BKException.Code.OK) {\n+                        // metadata update failed\n+                        LOG.error(\"Ledger {} metadata update failed. Error code {}\", ledgerId, rc);\n+                        setException(BKException.create(rc));\n+                        return;\n+                    }\n+                    set(null);\n+                }\n+            };\n+            bkc.getLedgerManager().writeLedgerMetadata(ledgerId, metadata, writeCb);\n+        }\n+    }\n+}"},{"sha":"1d56a5663f6d8800ebb97558d148dc15b0310d15","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/UpdateLedgerCmdTest.java","status":"added","additions":133,"deletions":0,"changes":133,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/99b40326fed855906b709cbe1f562f45bda79e5d/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FUpdateLedgerCmdTest.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/99b40326fed855906b709cbe1f562f45bda79e5d/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FUpdateLedgerCmdTest.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FUpdateLedgerCmdTest.java?ref=99b40326fed855906b709cbe1f562f45bda79e5d","patch":"@@ -0,0 +1,133 @@\n+/**\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.client;\n+\n+import java.io.IOException;\n+import java.net.UnknownHostException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import junit.framework.Assert;\n+\n+import org.apache.bookkeeper.bookie.Bookie;\n+import org.apache.bookkeeper.bookie.BookieShell;\n+import org.apache.bookkeeper.client.AsyncCallback.AddCallback;\n+import org.apache.bookkeeper.client.BookKeeper.DigestType;\n+import org.apache.bookkeeper.conf.ServerConfiguration;\n+import org.apache.bookkeeper.net.BookieSocketAddress;\n+import org.apache.bookkeeper.test.BookKeeperClusterTestCase;\n+import org.apache.zookeeper.KeeperException;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class UpdateLedgerCmdTest extends BookKeeperClusterTestCase {\n+\n+    private final static Logger LOG = LoggerFactory.getLogger(UpdateLedgerCmdTest.class);\n+    private DigestType digestType = DigestType.CRC32;\n+    private static final String PASSWORD = \"testPasswd\";\n+\n+    public UpdateLedgerCmdTest() {\n+        super(3);\n+        baseConf.setAllowLoopback(true);\n+        baseConf.setGcWaitTime(100000);\n+    }\n+\n+    /**\n+     * updateledgers to hostname\n+     */\n+    @Test(timeout = 120000)\n+    public void testUpdateLedgersToHostname() throws Exception {\n+        BookKeeper bk = new BookKeeper(baseClientConf, zkc);\n+        LOG.info(\"Create ledger and add entries to it\");\n+        List<LedgerHandle> ledgers = new ArrayList<LedgerHandle>();\n+        LedgerHandle lh1 = createLedgerWithEntries(bk, 0);\n+        ledgers.add(lh1);\n+        for (int i = 1; i < 40; i++) {\n+            ledgers.add(createLedgerWithEntries(bk, 0));\n+        }\n+\n+        String[] argv = new String[] { \"updateledgers\", \"-b\", \"hostname\", \"-v\", \"true\", \"-p\", \"2\" };\n+        final ServerConfiguration conf = bsConfs.get(0);\n+        conf.setUseHostNameAsBookieID(true);\n+        BookieSocketAddress toBookieId = Bookie.getBookieAddress(conf);\n+        BookieSocketAddress toBookieAddr = new BookieSocketAddress(toBookieId.getHostname() + \":\"\n+                + conf.getBookiePort());\n+\n+        updateLedgerCmd(argv, 0, conf);\n+\n+        int updatedLedgersCount = getUpdatedLedgersCount(bk, ledgers, toBookieAddr);\n+        Assert.assertEquals(\"Failed to update the ledger metadata to use bookie host name\", 40, updatedLedgersCount);\n+    }\n+\n+    private void updateLedgerCmd(String[] argv, int exitCode, ServerConfiguration conf) throws KeeperException,\n+            InterruptedException, IOException, UnknownHostException, Exception {\n+        LOG.info(\"Perform updateledgers command\");\n+        BookieShell bkShell = new BookieShell();\n+        bkShell.setConf(conf);\n+\n+        Assert.assertEquals(\"Failed to return exit code!\", exitCode, bkShell.run(argv));\n+    }\n+\n+    private int getUpdatedLedgersCount(BookKeeper bk, List<LedgerHandle> ledgers, BookieSocketAddress toBookieAddr)\n+            throws InterruptedException, BKException {\n+        ArrayList<BookieSocketAddress> ensemble;\n+        int updatedLedgersCount = 0;\n+        for (LedgerHandle lh : ledgers) {\n+            // ledger#close() would hit BadVersion exception as rename\n+            // increments cversion. But LedgerMetadata#isConflictWith()\n+            // gracefully handles this conflicts.\n+            lh.close();\n+            LedgerHandle openLedger = bk.openLedger(lh.getId(), digestType, PASSWORD.getBytes());\n+            ensemble = openLedger.getLedgerMetadata().getEnsemble(0);\n+            if (ensemble.contains(toBookieAddr)) {\n+                updatedLedgersCount++;\n+            }\n+        }\n+        return updatedLedgersCount;\n+    }\n+\n+    private LedgerHandle createLedgerWithEntries(BookKeeper bk, int numOfEntries) throws Exception {\n+        LedgerHandle lh = bk.createLedger(3, 3, digestType, PASSWORD.getBytes());\n+        final AtomicInteger rc = new AtomicInteger(BKException.Code.OK);\n+        final CountDownLatch latch = new CountDownLatch(numOfEntries);\n+\n+        final AddCallback cb = new AddCallback() {\n+            public void addComplete(int rccb, LedgerHandle lh, long entryId, Object ctx) {\n+                rc.compareAndSet(BKException.Code.OK, rccb);\n+                latch.countDown();\n+            }\n+        };\n+        for (int i = 0; i < numOfEntries; i++) {\n+            lh.asyncAddEntry((\"foobar\" + i).getBytes(), cb, null);\n+        }\n+        if (!latch.await(30, TimeUnit.SECONDS)) {\n+            throw new Exception(\"Entries took too long to add\");\n+        }\n+        if (rc.get() != BKException.Code.OK) {\n+            throw BKException.create(rc.get());\n+        }\n+        return lh;\n+    }\n+}"},{"sha":"2ea094f6cf1f2a5dfd8b28aaeb6f76e6a0dcc4b2","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/UpdateLedgerOpTest.java","status":"added","additions":305,"deletions":0,"changes":305,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/99b40326fed855906b709cbe1f562f45bda79e5d/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FUpdateLedgerOpTest.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/99b40326fed855906b709cbe1f562f45bda79e5d/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FUpdateLedgerOpTest.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FUpdateLedgerOpTest.java?ref=99b40326fed855906b709cbe1f562f45bda79e5d","patch":"@@ -0,0 +1,305 @@\n+/**\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ */\n+package org.apache.bookkeeper.client;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.apache.bookkeeper.bookie.Bookie;\n+import org.apache.bookkeeper.bookie.BookieShell.UpdateLedgerNotifier;\n+import org.apache.bookkeeper.client.AsyncCallback.AddCallback;\n+import org.apache.bookkeeper.client.BookKeeper.DigestType;\n+import org.apache.bookkeeper.conf.ServerConfiguration;\n+import org.apache.bookkeeper.net.BookieSocketAddress;\n+import org.apache.bookkeeper.proto.BookieServer;\n+import org.apache.bookkeeper.test.BookKeeperClusterTestCase;\n+import org.apache.bookkeeper.util.MathUtils;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class UpdateLedgerOpTest extends BookKeeperClusterTestCase {\n+    private static final Logger LOG = LoggerFactory.getLogger(UpdateLedgerOpTest.class);\n+    private DigestType digestType = DigestType.CRC32;\n+    private static final String PASSWORD = \"testPasswd\";\n+    private static final int printprogress = 5;\n+\n+    public UpdateLedgerOpTest() {\n+        super(3);\n+        baseConf.setAllowLoopback(true);\n+        baseConf.setGcWaitTime(100000);\n+    }\n+\n+    UpdateLedgerNotifier progressable = new UpdateLedgerNotifier() {\n+        long lastReport = System.nanoTime();\n+\n+        @Override\n+        public void progress(long updated, long issued) {\n+            if (TimeUnit.MILLISECONDS.toSeconds(MathUtils.elapsedMSec(lastReport)) >= printprogress) {\n+                LOG.info(\"Number of ledgers issued={}, updated={}\", issued, updated);\n+                lastReport = MathUtils.nowInNano();\n+            }\n+        }\n+    };\n+\n+    /**\n+     * Tests verifies update bookie id when there are many ledgers.\n+     */\n+    @Test(timeout = 120000)\n+    public void testManyLedgers() throws Exception {\n+        BookKeeper bk = new BookKeeper(baseClientConf, zkc);\n+        BookKeeperAdmin bkadmin = new BookKeeperAdmin(bk);\n+\n+        LOG.info(\"Create ledger and add entries to it\");\n+        List<LedgerHandle> ledgers = new ArrayList<LedgerHandle>();\n+        LedgerHandle lh1 = createLedgerWithEntries(bk, 0);\n+        ledgers.add(lh1);\n+        for (int i = 0; i < 99; i++) {\n+            ledgers.add(createLedgerWithEntries(bk, 0));\n+        }\n+\n+        ArrayList<BookieSocketAddress> ensemble = lh1.getLedgerMetadata().getEnsemble(0);\n+\n+        BookieSocketAddress curBookieAddr = ensemble.get(0);\n+        baseConf.setUseHostNameAsBookieID(true);\n+        BookieSocketAddress curBookieId = Bookie.getBookieAddress(baseConf);\n+        BookieSocketAddress toBookieAddr = new BookieSocketAddress(curBookieId.getHostname() + \":\"\n+                + curBookieAddr.getPort());\n+        UpdateLedgerOp updateLedgerOp = new UpdateLedgerOp(bk, bkadmin);\n+        updateLedgerOp.updateBookieIdInLedgers(curBookieAddr, toBookieAddr, 5, Integer.MIN_VALUE, progressable);\n+\n+        for (LedgerHandle lh : ledgers) {\n+            // ledger#close() would hit BadVersion exception as rename\n+            // increments cversion. But LedgerMetadata#isConflictWith()\n+            // gracefully handles this conflicts.\n+            lh.close();\n+            LedgerHandle openLedger = bk.openLedger(lh.getId(), digestType, PASSWORD.getBytes());\n+            ensemble = openLedger.getLedgerMetadata().getEnsemble(0);\n+            Assert.assertTrue(\"Failed to update the ledger metadata to use bookie host name\",\n+                    ensemble.contains(toBookieAddr));\n+            Assert.assertFalse(\"Failed to update the ledger metadata to use bookie host name\",\n+                    ensemble.contains(curBookieAddr));\n+        }\n+    }\n+\n+    /**\n+     * Tests verifies with limit value lesser than the total number of ledgers.\n+     */\n+    @Test(timeout = 120000)\n+    public void testLimitLessThanTotalLedgers() throws Exception {\n+        BookKeeper bk = new BookKeeper(baseClientConf, zkc);\n+        BookKeeperAdmin bkadmin = new BookKeeperAdmin(bk);\n+\n+        LOG.info(\"Create ledger and add entries to it\");\n+        List<LedgerHandle> ledgers = new ArrayList<LedgerHandle>();\n+        LedgerHandle lh1 = createLedgerWithEntries(bk, 0);\n+        ledgers.add(lh1);\n+        for (int i = 1; i < 10; i++) {\n+            ledgers.add(createLedgerWithEntries(bk, 0));\n+        }\n+\n+        ArrayList<BookieSocketAddress> ensemble = lh1.getLedgerMetadata().getEnsemble(0);\n+\n+        BookieSocketAddress curBookieAddr = ensemble.get(0);\n+        baseConf.setUseHostNameAsBookieID(true);\n+        BookieSocketAddress toBookieId = Bookie.getBookieAddress(baseConf);\n+        BookieSocketAddress toBookieAddr = new BookieSocketAddress(toBookieId.getHostname() + \":\"\n+                + curBookieAddr.getPort());\n+        UpdateLedgerOp updateLedgerOp = new UpdateLedgerOp(bk, bkadmin);\n+        updateLedgerOp.updateBookieIdInLedgers(curBookieAddr, toBookieAddr, 7, 4, progressable);\n+        int updatedLedgersCount = getUpdatedLedgersCount(bk, ledgers, toBookieAddr);\n+        Assert.assertEquals(\"Failed to update the ledger metadata to use bookie host name\", 4, updatedLedgersCount);\n+\n+        // next execution\n+        updateLedgerOp.updateBookieIdInLedgers(curBookieAddr, toBookieAddr, 2, 10, progressable);\n+        updatedLedgersCount = getUpdatedLedgersCount(bk, ledgers, toBookieAddr);\n+        Assert.assertEquals(\"Failed to update the ledger metadata to use bookie host name\", 10, updatedLedgersCount);\n+\n+        // no ledgers\n+        updateLedgerOp.updateBookieIdInLedgers(curBookieAddr, toBookieAddr, 3, 20, progressable);\n+        updatedLedgersCount = getUpdatedLedgersCount(bk, ledgers, toBookieAddr);\n+        Assert.assertEquals(\"Failed to update the ledger metadata to use bookie host name\", 10, updatedLedgersCount);\n+\n+        // no ledgers\n+        updateLedgerOp.updateBookieIdInLedgers(curBookieAddr, toBookieAddr, 3, Integer.MIN_VALUE, progressable);\n+        updatedLedgersCount = getUpdatedLedgersCount(bk, ledgers, toBookieAddr);\n+        Assert.assertEquals(\"Failed to update the ledger metadata to use bookie host name\", 10, updatedLedgersCount);\n+    }\n+\n+    /**\n+     * Tests verifies the ensemble reformation after updating the bookie id in\n+     * the existing ensemble\n+     */\n+    @Test(timeout = 120000)\n+    public void testChangeEnsembleAfterRenaming() throws Exception {\n+\n+        BookKeeper bk = new BookKeeper(baseClientConf, zkc);\n+        BookKeeperAdmin bkadmin = new BookKeeperAdmin(bk);\n+\n+        LOG.info(\"Create ledger and add entries to it\");\n+        LedgerHandle lh = createLedgerWithEntries(bk, 100);\n+\n+        BookieServer bookieServer = bs.get(0);\n+        ArrayList<BookieSocketAddress> ensemble = lh.getLedgerMetadata().getEnsemble(0);\n+        BookieSocketAddress curBookieAddr = null;\n+        for (BookieSocketAddress bookieSocketAddress : ensemble) {\n+            if (bookieServer.getLocalAddress().equals(bookieSocketAddress)) {\n+                curBookieAddr = bookieSocketAddress;\n+            }\n+        }\n+        Assert.assertNotNull(\"Couldn't find the bookie in ledger metadata!\", curBookieAddr);\n+        baseConf.setUseHostNameAsBookieID(true);\n+        BookieSocketAddress toBookieId = Bookie.getBookieAddress(baseConf);\n+        BookieSocketAddress toBookieAddr = new BookieSocketAddress(toBookieId.getHostname() + \":\"\n+                + curBookieAddr.getPort());\n+        UpdateLedgerOp updateLedgerOp = new UpdateLedgerOp(bk, bkadmin);\n+        updateLedgerOp.updateBookieIdInLedgers(curBookieAddr, toBookieAddr, 5, 100, progressable);\n+\n+        bookieServer.shutdown();\n+\n+        ServerConfiguration serverConf1 = newServerConfiguration();\n+        bsConfs.add(serverConf1);\n+        bs.add(startBookie(serverConf1));\n+\n+        // ledger#asyncAddEntry() would hit BadVersion exception as rename incr\n+        // cversion. But LedgerMetadata#isConflictWith() gracefully handles\n+        // this conflicts.\n+        final CountDownLatch latch = new CountDownLatch(1);\n+        final AtomicInteger rc = new AtomicInteger(BKException.Code.OK);\n+        lh.asyncAddEntry(\"foobar\".getBytes(), new AddCallback() {\n+            @Override\n+            public void addComplete(int rccb, LedgerHandle lh, long entryId, Object ctx) {\n+                rc.compareAndSet(BKException.Code.OK, rccb);\n+                latch.countDown();\n+            }\n+        }, null);\n+        if (!latch.await(30, TimeUnit.SECONDS)) {\n+            throw new Exception(\"Entries took too long to add\");\n+        }\n+        if (rc.get() != BKException.Code.OK) {\n+            throw BKException.create(rc.get());\n+        }\n+        lh.close();\n+        LedgerHandle openLedger = bk.openLedger(lh.getId(), digestType, PASSWORD.getBytes());\n+        final LedgerMetadata ledgerMetadata = openLedger.getLedgerMetadata();\n+        Assert.assertEquals(\"Failed to reform ensemble!\", 2, ledgerMetadata.getEnsembles().size());\n+        ensemble = ledgerMetadata.getEnsemble(0);\n+        Assert.assertTrue(\"Failed to update the ledger metadata to use bookie host name\",\n+                ensemble.contains(toBookieAddr));\n+    }\n+\n+    /**\n+     * Tests verifies simultaneous flow between adding entries and rename of\n+     * bookie id\n+     */\n+    @Test(timeout = 120000)\n+    public void testRenameWhenAddEntryInProgress() throws Exception {\n+        final BookKeeper bk = new BookKeeper(baseClientConf, zkc);\n+        BookKeeperAdmin bkadmin = new BookKeeperAdmin(bk);\n+\n+        LOG.info(\"Create ledger and add entries to it\");\n+        final int numOfEntries = 5000;\n+        final CountDownLatch latch = new CountDownLatch(numOfEntries);\n+        final AtomicInteger rc = new AtomicInteger(BKException.Code.OK);\n+        final LedgerHandle lh = createLedgerWithEntries(bk, 1);\n+        latch.countDown();\n+        Thread th = new Thread() {\n+            public void run() {\n+                final AddCallback cb = new AddCallback() {\n+                    public void addComplete(int rccb, LedgerHandle lh, long entryId, Object ctx) {\n+                        rc.compareAndSet(BKException.Code.OK, rccb);\n+                        if (entryId % 100 == 0) {\n+                            LOG.info(\"Added entries till entryId:{}\", entryId);\n+                        }\n+                        latch.countDown();\n+                    }\n+                };\n+                for (int i = 1; i < numOfEntries; i++) {\n+                    lh.asyncAddEntry((\"foobar\" + i).getBytes(), cb, null);\n+                }\n+\n+            };\n+        };\n+        th.start();\n+        ArrayList<BookieSocketAddress> ensemble = lh.getLedgerMetadata().getEnsemble(0);\n+        BookieSocketAddress curBookieAddr = ensemble.get(0);\n+        BookieSocketAddress toBookieAddr = new BookieSocketAddress(\"localhost:\" + curBookieAddr.getPort());\n+        UpdateLedgerOp updateLedgerOp = new UpdateLedgerOp(bk, bkadmin);\n+        updateLedgerOp.updateBookieIdInLedgers(curBookieAddr, toBookieAddr, 5, 100, progressable);\n+\n+        if (!latch.await(120, TimeUnit.SECONDS)) {\n+            throw new Exception(\"Entries took too long to add\");\n+        }\n+        if (rc.get() != BKException.Code.OK) {\n+            throw BKException.create(rc.get());\n+        }\n+        lh.close();\n+        LedgerHandle openLedger = bk.openLedger(lh.getId(), digestType, PASSWORD.getBytes());\n+        ensemble = openLedger.getLedgerMetadata().getEnsemble(0);\n+        Assert.assertTrue(\"Failed to update the ledger metadata to use bookie host name\",\n+                ensemble.contains(toBookieAddr));\n+    }\n+\n+    private int getUpdatedLedgersCount(BookKeeper bk, List<LedgerHandle> ledgers, BookieSocketAddress toBookieAddr)\n+            throws InterruptedException, BKException {\n+        ArrayList<BookieSocketAddress> ensemble;\n+        int updatedLedgersCount = 0;\n+        for (LedgerHandle lh : ledgers) {\n+            // ledger#close() would hit BadVersion exception as rename\n+            // increments cversion. But LedgerMetadata#isConflictWith()\n+            // gracefully handles this conflicts.\n+            lh.close();\n+            LedgerHandle openLedger = bk.openLedger(lh.getId(), digestType, PASSWORD.getBytes());\n+            ensemble = openLedger.getLedgerMetadata().getEnsemble(0);\n+            if (ensemble.contains(toBookieAddr)) {\n+                updatedLedgersCount++;\n+            }\n+        }\n+        return updatedLedgersCount;\n+    }\n+\n+    private LedgerHandle createLedgerWithEntries(BookKeeper bk, int numOfEntries) throws Exception {\n+        LedgerHandle lh = bk.createLedger(3, 3, digestType, PASSWORD.getBytes());\n+        final AtomicInteger rc = new AtomicInteger(BKException.Code.OK);\n+        final CountDownLatch latch = new CountDownLatch(numOfEntries);\n+\n+        final AddCallback cb = new AddCallback() {\n+            public void addComplete(int rccb, LedgerHandle lh, long entryId, Object ctx) {\n+                rc.compareAndSet(BKException.Code.OK, rccb);\n+                latch.countDown();\n+            }\n+        };\n+        for (int i = 0; i < numOfEntries; i++) {\n+            lh.asyncAddEntry((\"foobar\" + i).getBytes(), cb, null);\n+        }\n+        if (!latch.await(30, TimeUnit.SECONDS)) {\n+            throw new Exception(\"Entries took too long to add\");\n+        }\n+        if (rc.get() != BKException.Code.OK) {\n+            throw BKException.create(rc.get());\n+        }\n+        return lh;\n+    }\n+}\n\\ No newline at end of file"},{"sha":"ced2c9fa2105f7d733abfa004f615ac8a7580659","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/test/BookKeeperClusterTestCase.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/99b40326fed855906b709cbe1f562f45bda79e5d/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Ftest%2FBookKeeperClusterTestCase.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/99b40326fed855906b709cbe1f562f45bda79e5d/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Ftest%2FBookKeeperClusterTestCase.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Ftest%2FBookKeeperClusterTestCase.java?ref=99b40326fed855906b709cbe1f562f45bda79e5d","patch":"@@ -82,6 +82,7 @@ public abstract class BookKeeperClusterTestCase {\n \n     public BookKeeperClusterTestCase(int numBookies) {\n         this.numBookies = numBookies;\n+        baseConf.setAllowLoopback(true);\n     }\n \n     @Before\n@@ -199,7 +200,6 @@ protected ServerConfiguration newServerConfiguration(int port, String zkServers,\n         conf.setBookiePort(port);\n         conf.setZkServers(zkServers);\n         conf.setJournalDirName(journalDir.getPath());\n-        conf.setAllowLoopback(true);\n         String[] ledgerDirNames = new String[ledgerDirs.length];\n         for (int i=0; i<ledgerDirs.length; i++) {\n             ledgerDirNames[i] = ledgerDirs[i].getPath();"}]}