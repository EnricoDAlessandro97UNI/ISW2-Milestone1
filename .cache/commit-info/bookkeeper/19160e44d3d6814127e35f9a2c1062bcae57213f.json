{"sha":"19160e44d3d6814127e35f9a2c1062bcae57213f","node_id":"MDY6Q29tbWl0NDc4NTkyNTI2OjE5MTYwZTQ0ZDNkNjgxNDEyN2UzNWY5YTJjMTA2MmJjYWU1NzIxM2Y=","commit":{"author":{"name":"Sijie Guo","email":"sijie@apache.org","date":"2016-01-24T17:39:50Z"},"committer":{"name":"Matteo Merli","email":"mmerli@apache.org","date":"2016-01-24T17:39:50Z"},"message":"BOOKKEEPER-885: Script to merge github pull request (sijie via mmerli)\n\nUtility for creating well-formed pull request merges and pushing them to Apache. A modified version based on Spark project (https://github.com/apache/spark/blob/master/dev/merge_spark_pr.py)\n\nAuthor: Sijie Guo <sijie@apache.org>\n\nReviewers: Matteo Merli <mmerli@apache.org>\n\nCloses #4 from sijie/sijie/BOOKKEEPER-885","tree":{"sha":"9ee3dd8ad9152cbc3425a38be42f2bde13c38ed6","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/trees/9ee3dd8ad9152cbc3425a38be42f2bde13c38ed6"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/commits/19160e44d3d6814127e35f9a2c1062bcae57213f","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/19160e44d3d6814127e35f9a2c1062bcae57213f","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/19160e44d3d6814127e35f9a2c1062bcae57213f","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/19160e44d3d6814127e35f9a2c1062bcae57213f/comments","author":{"login":"sijie","id":1217863,"node_id":"MDQ6VXNlcjEyMTc4NjM=","avatar_url":"https://avatars.githubusercontent.com/u/1217863?v=4","gravatar_id":"","url":"https://api.github.com/users/sijie","html_url":"https://github.com/sijie","followers_url":"https://api.github.com/users/sijie/followers","following_url":"https://api.github.com/users/sijie/following{/other_user}","gists_url":"https://api.github.com/users/sijie/gists{/gist_id}","starred_url":"https://api.github.com/users/sijie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sijie/subscriptions","organizations_url":"https://api.github.com/users/sijie/orgs","repos_url":"https://api.github.com/users/sijie/repos","events_url":"https://api.github.com/users/sijie/events{/privacy}","received_events_url":"https://api.github.com/users/sijie/received_events","type":"User","site_admin":false},"committer":{"login":"merlimat","id":62500,"node_id":"MDQ6VXNlcjYyNTAw","avatar_url":"https://avatars.githubusercontent.com/u/62500?v=4","gravatar_id":"","url":"https://api.github.com/users/merlimat","html_url":"https://github.com/merlimat","followers_url":"https://api.github.com/users/merlimat/followers","following_url":"https://api.github.com/users/merlimat/following{/other_user}","gists_url":"https://api.github.com/users/merlimat/gists{/gist_id}","starred_url":"https://api.github.com/users/merlimat/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/merlimat/subscriptions","organizations_url":"https://api.github.com/users/merlimat/orgs","repos_url":"https://api.github.com/users/merlimat/repos","events_url":"https://api.github.com/users/merlimat/events{/privacy}","received_events_url":"https://api.github.com/users/merlimat/received_events","type":"User","site_admin":false},"parents":[{"sha":"e42efa9a84d554c8c0cdc9faf39d5efb85fe01f0","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/e42efa9a84d554c8c0cdc9faf39d5efb85fe01f0","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/e42efa9a84d554c8c0cdc9faf39d5efb85fe01f0"}],"stats":{"total":468,"additions":468,"deletions":0},"files":[{"sha":"6b1db3f5d69a5ed7127434a18c6810ec73436adc","filename":"dev/bk-merge-pr.py","status":"added","additions":468,"deletions":0,"changes":468,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/19160e44d3d6814127e35f9a2c1062bcae57213f/dev%2Fbk-merge-pr.py","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/19160e44d3d6814127e35f9a2c1062bcae57213f/dev%2Fbk-merge-pr.py","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/dev%2Fbk-merge-pr.py?ref=19160e44d3d6814127e35f9a2c1062bcae57213f","patch":"@@ -0,0 +1,468 @@\n+#!/usr/bin/env python\n+\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+# Utility for creating well-formed pull request merges and pushing them to Apache. This script is a modified version\n+# of the one created by the Spark project (https://github.com/apache/spark/blob/master/dev/merge_spark_pr.py).\n+#\n+# Usage: ./bk-merge-pr.py (see config env vars below)\n+#\n+# This utility assumes you already have local a bookkeeper git folder and that you\n+# have added remotes corresponding to both:\n+# (i) the github apache bookkeeper mirror and\n+# (ii) the apache bookkeeper git repo.\n+\n+import json\n+import os\n+import re\n+import subprocess\n+import sys\n+import urllib2\n+\n+try:\n+    import jira.client\n+    JIRA_IMPORTED = True\n+except ImportError:\n+    JIRA_IMPORTED = False\n+\n+PROJECT_NAME = \"bookkeeper\"\n+\n+CAPITALIZED_PROJECT_NAME = \"bookkeeper\".upper()\n+\n+# Location of the local git repository\n+REPO_HOME = os.environ.get(\"%s_HOME\" % CAPITALIZED_PROJECT_NAME, os.getcwd())\n+# Remote name which points to the GitHub site\n+PR_REMOTE_NAME = os.environ.get(\"PR_REMOTE_NAME\", \"apache-github\")\n+# Remote name which points to Apache git\n+PUSH_REMOTE_NAME = os.environ.get(\"PUSH_REMOTE_NAME\", \"apache\")\n+# ASF JIRA username\n+JIRA_USERNAME = os.environ.get(\"JIRA_USERNAME\", \"\")\n+# ASF JIRA password\n+JIRA_PASSWORD = os.environ.get(\"JIRA_PASSWORD\", \"\")\n+# OAuth key used for issuing requests against the GitHub API. If this is not defined, then requests\n+# will be unauthenticated. You should only need to configure this if you find yourself regularly\n+# exceeding your IP's unauthenticated request rate limit. You can create an OAuth key at\n+# https://github.com/settings/tokens. This script only requires the \"public_repo\" scope.\n+GITHUB_OAUTH_KEY = os.environ.get(\"GITHUB_OAUTH_KEY\")\n+\n+GITHUB_USER = os.environ.get(\"GITHUB_USER\", \"apache\")\n+GITHUB_BASE = \"https://github.com/%s/%s/pull\" % (GITHUB_USER, PROJECT_NAME)\n+GITHUB_API_BASE = \"https://api.github.com/repos/%s/%s\" % (GITHUB_USER, PROJECT_NAME)\n+JIRA_BASE = \"https://issues.apache.org/jira/browse\"\n+JIRA_API_BASE = \"https://issues.apache.org/jira\"\n+# Prefix added to temporary branches\n+TEMP_BRANCH_PREFIX = \"PR_TOOL\"\n+RELEASE_BRANCH_PREFIX = \"branch-\"\n+\n+DEV_BRANCH_NAME = \"master\"\n+\n+DEFAULT_FIX_VERSION = os.environ.get(\"DEFAULT_FIX_VERSION\", \"0.9.1.0\")\n+\n+def get_json(url):\n+    try:\n+        request = urllib2.Request(url)\n+        if GITHUB_OAUTH_KEY:\n+            request.add_header('Authorization', 'token %s' % GITHUB_OAUTH_KEY)\n+        return json.load(urllib2.urlopen(request))\n+    except urllib2.HTTPError as e:\n+        if \"X-RateLimit-Remaining\" in e.headers and e.headers[\"X-RateLimit-Remaining\"] == '0':\n+            print \"Exceeded the GitHub API rate limit; see the instructions in \" + \\\n+                  \"bk-merge-pr.py to configure an OAuth token for making authenticated \" + \\\n+                  \"GitHub requests.\"\n+        else:\n+            print \"Unable to fetch URL, exiting: %s\" % url\n+        sys.exit(-1)\n+\n+\n+def fail(msg):\n+    print msg\n+    clean_up()\n+    sys.exit(-1)\n+\n+\n+def run_cmd(cmd):\n+    print cmd\n+    if isinstance(cmd, list):\n+        return subprocess.check_output(cmd)\n+    else:\n+        return subprocess.check_output(cmd.split(\" \"))\n+\n+\n+def continue_maybe(prompt):\n+    result = raw_input(\"\\n%s (y/n): \" % prompt)\n+    if result.lower() != \"y\":\n+        fail(\"Okay, exiting\")\n+\n+def clean_up():\n+    if original_head != get_current_branch():\n+        print \"Restoring head pointer to %s\" % original_head\n+        run_cmd(\"git checkout %s\" % original_head)\n+\n+    branches = run_cmd(\"git branch\").replace(\" \", \"\").split(\"\\n\")\n+\n+    for branch in filter(lambda x: x.startswith(TEMP_BRANCH_PREFIX), branches):\n+        print \"Deleting local branch %s\" % branch\n+        run_cmd(\"git branch -D %s\" % branch)\n+\n+def get_current_branch():\n+    return run_cmd(\"git rev-parse --abbrev-ref HEAD\").replace(\"\\n\", \"\")\n+\n+# merge the requested PR and return the merge hash\n+def merge_pr(pr_num, target_ref, title, body, pr_repo_desc):\n+    pr_branch_name = \"%s_MERGE_PR_%s\" % (TEMP_BRANCH_PREFIX, pr_num)\n+    target_branch_name = \"%s_MERGE_PR_%s_%s\" % (TEMP_BRANCH_PREFIX, pr_num, target_ref.upper())\n+    run_cmd(\"git fetch %s pull/%s/head:%s\" % (PR_REMOTE_NAME, pr_num, pr_branch_name))\n+    run_cmd(\"git fetch %s %s:%s\" % (PUSH_REMOTE_NAME, target_ref, target_branch_name))\n+    run_cmd(\"git checkout %s\" % target_branch_name)\n+\n+    had_conflicts = False\n+    try:\n+        run_cmd(['git', 'merge', pr_branch_name, '--squash'])\n+    except Exception as e:\n+        msg = \"Error merging: %s\\nWould you like to manually fix-up this merge?\" % e\n+        continue_maybe(msg)\n+        msg = \"Okay, please fix any conflicts and 'git add' conflicting files... Finished?\"\n+        continue_maybe(msg)\n+        had_conflicts = True\n+\n+    commit_authors = run_cmd(['git', 'log', 'HEAD..%s' % pr_branch_name,\n+                             '--pretty=format:%an <%ae>']).split(\"\\n\")\n+    distinct_authors = sorted(set(commit_authors),\n+                              key=lambda x: commit_authors.count(x), reverse=True)\n+    primary_author = raw_input(\n+        \"Enter primary author in the format of \\\"name <email>\\\" [%s]: \" %\n+        distinct_authors[0])\n+    if primary_author == \"\":\n+        primary_author = distinct_authors[0]\n+\n+    reviewers = raw_input(\n+        \"Enter reviewers in the format of \\\"name1 <email1>, name2 <email2>\\\": \").strip()\n+\n+    commits = run_cmd(['git', 'log', 'HEAD..%s' % pr_branch_name,\n+                      '--pretty=format:%h [%an] %s']).split(\"\\n\")\n+    \n+    if len(commits) > 1:\n+        result = raw_input(\"List pull request commits in squashed commit message? (y/n): \")\n+        if result.lower() == \"y\":\n+          should_list_commits = True\n+        else:\n+          should_list_commits = False\n+    else:\n+        should_list_commits = False\n+\n+    merge_message_flags = []\n+\n+    merge_message_flags += [\"-m\", title]\n+    if body is not None:\n+        # We remove @ symbols from the body to avoid triggering e-mails\n+        # to people every time someone creates a public fork of the project.\n+        merge_message_flags += [\"-m\", body.replace(\"@\", \"\")]\n+\n+    authors = \"\\n\".join([\"Author: %s\" % a for a in distinct_authors])\n+\n+    merge_message_flags += [\"-m\", authors]\n+\n+    if (reviewers != \"\"):\n+        merge_message_flags += [\"-m\", \"Reviewers: %s\" % reviewers]\n+\n+    if had_conflicts:\n+        committer_name = run_cmd(\"git config --get user.name\").strip()\n+        committer_email = run_cmd(\"git config --get user.email\").strip()\n+        message = \"This patch had conflicts when merged, resolved by\\nCommitter: %s <%s>\" % (\n+            committer_name, committer_email)\n+        merge_message_flags += [\"-m\", message]\n+\n+    # The string \"Closes #%s\" string is required for GitHub to correctly close the PR\n+    close_line = \"Closes #%s from %s\" % (pr_num, pr_repo_desc)\n+    if should_list_commits:\n+        close_line += \" and squashes the following commits:\"\n+    merge_message_flags += [\"-m\", close_line]\n+\n+    if should_list_commits:\n+        merge_message_flags += [\"-m\", \"\\n\".join(commits)]\n+\n+    run_cmd(['git', 'commit', '--author=\"%s\"' % primary_author] + merge_message_flags)\n+\n+    continue_maybe(\"Merge complete (local ref %s). Push to %s?\" % (\n+        target_branch_name, PUSH_REMOTE_NAME))\n+\n+    try:\n+        run_cmd('git push %s %s:%s' % (PUSH_REMOTE_NAME, target_branch_name, target_ref))\n+    except Exception as e:\n+        clean_up()\n+        fail(\"Exception while pushing: %s\" % e)\n+\n+    merge_hash = run_cmd(\"git rev-parse %s\" % target_branch_name)[:8]\n+    clean_up()\n+    print(\"Pull request #%s merged!\" % pr_num)\n+    print(\"Merge hash: %s\" % merge_hash)\n+    return merge_hash\n+\n+\n+def cherry_pick(pr_num, merge_hash, default_branch):\n+    pick_ref = raw_input(\"Enter a branch name [%s]: \" % default_branch)\n+    if pick_ref == \"\":\n+        pick_ref = default_branch\n+\n+    pick_branch_name = \"%s_PICK_PR_%s_%s\" % (TEMP_BRANCH_PREFIX, pr_num, pick_ref.upper())\n+\n+    run_cmd(\"git fetch %s %s:%s\" % (PUSH_REMOTE_NAME, pick_ref, pick_branch_name))\n+    run_cmd(\"git checkout %s\" % pick_branch_name)\n+\n+    try:\n+        run_cmd(\"git cherry-pick -sx %s\" % merge_hash)\n+    except Exception as e:\n+        msg = \"Error cherry-picking: %s\\nWould you like to manually fix-up this merge?\" % e\n+        continue_maybe(msg)\n+        msg = \"Okay, please fix any conflicts and finish the cherry-pick. Finished?\"\n+        continue_maybe(msg)\n+\n+    continue_maybe(\"Pick complete (local ref %s). Push to %s?\" % (\n+        pick_branch_name, PUSH_REMOTE_NAME))\n+\n+    try:\n+        run_cmd('git push %s %s:%s' % (PUSH_REMOTE_NAME, pick_branch_name, pick_ref))\n+    except Exception as e:\n+        clean_up()\n+        fail(\"Exception while pushing: %s\" % e)\n+\n+    pick_hash = run_cmd(\"git rev-parse %s\" % pick_branch_name)[:8]\n+    clean_up()\n+\n+    print(\"Pull request #%s picked into %s!\" % (pr_num, pick_ref))\n+    print(\"Pick hash: %s\" % pick_hash)\n+    return pick_ref\n+\n+\n+def fix_version_from_branch(branch, versions):\n+    # Note: Assumes this is a sorted (newest->oldest) list of un-released versions\n+    if branch == DEV_BRANCH_NAME:\n+        versions = filter(lambda x: x == DEFAULT_FIX_VERSION, versions)\n+        if len(versions) > 0:\n+            return versions[0]\n+        else:\n+            return None\n+    else:\n+        versions = filter(lambda x: x.startswith(branch), versions)\n+        if len(versions) > 0:\n+            return versions[-1]\n+        else:\n+            return None\n+\n+\n+def resolve_jira_issue(merge_branches, comment, default_jira_id=\"\"):\n+    asf_jira = jira.client.JIRA({'server': JIRA_API_BASE},\n+                                basic_auth=(JIRA_USERNAME, JIRA_PASSWORD))\n+\n+    jira_id = raw_input(\"Enter a JIRA id [%s]: \" % default_jira_id)\n+    if jira_id == \"\":\n+        jira_id = default_jira_id\n+\n+    try:\n+        issue = asf_jira.issue(jira_id)\n+    except Exception as e:\n+        fail(\"ASF JIRA could not find %s\\n%s\" % (jira_id, e))\n+\n+    cur_status = issue.fields.status.name\n+    cur_summary = issue.fields.summary\n+    cur_assignee = issue.fields.assignee\n+    if cur_assignee is None:\n+        cur_assignee = \"NOT ASSIGNED!!!\"\n+    else:\n+        cur_assignee = cur_assignee.displayName\n+\n+    if cur_status == \"Resolved\" or cur_status == \"Closed\":\n+        fail(\"JIRA issue %s already has status '%s'\" % (jira_id, cur_status))\n+    print (\"=== JIRA %s ===\" % jira_id)\n+    print (\"summary\\t\\t%s\\nassignee\\t%s\\nstatus\\t\\t%s\\nurl\\t\\t%s/%s\\n\" % (\n+        cur_summary, cur_assignee, cur_status, JIRA_BASE, jira_id))\n+\n+    versions = asf_jira.project_versions(CAPITALIZED_PROJECT_NAME)\n+    versions = sorted(versions, key=lambda x: x.name, reverse=True)\n+    versions = filter(lambda x: x.raw['released'] is False, versions)\n+\n+    version_names = map(lambda x: x.name, versions)\n+    default_fix_versions = map(lambda x: fix_version_from_branch(x, version_names), merge_branches)\n+    default_fix_versions = filter(lambda x: x != None, default_fix_versions)\n+    default_fix_versions = \",\".join(default_fix_versions)\n+\n+    fix_versions = raw_input(\"Enter comma-separated fix version(s) [%s]: \" % default_fix_versions)\n+    if fix_versions == \"\":\n+        fix_versions = default_fix_versions\n+    fix_versions = fix_versions.replace(\" \", \"\").split(\",\")\n+\n+    def get_version_json(version_str):\n+        return filter(lambda v: v.name == version_str, versions)[0].raw\n+\n+    jira_fix_versions = map(lambda v: get_version_json(v), fix_versions)\n+\n+    resolve = filter(lambda a: a['name'] == \"Resolve Issue\", asf_jira.transitions(jira_id))[0]\n+    resolution = filter(lambda r: r.raw['name'] == \"Fixed\", asf_jira.resolutions())[0]\n+    asf_jira.transition_issue(\n+        jira_id, resolve[\"id\"], fixVersions = jira_fix_versions,\n+        comment = comment, resolution = {'id': resolution.raw['id']})\n+\n+    print \"Successfully resolved %s with fixVersions=%s!\" % (jira_id, fix_versions)\n+\n+\n+def resolve_jira_issues(title, merge_branches, comment):\n+    jira_ids = re.findall(\"%s-[0-9]{4,5}\" % CAPITALIZED_PROJECT_NAME, title)\n+\n+    if len(jira_ids) == 0:\n+        resolve_jira_issue(merge_branches, comment)\n+    for jira_id in jira_ids:\n+        resolve_jira_issue(merge_branches, comment, jira_id)\n+\n+\n+def standardize_jira_ref(text):\n+    \"\"\"\n+    Standardize the jira reference commit message prefix to \"PROJECT_NAME-XXX: Issue\"\n+\n+    >>> standardize_jira_ref(\"%s-877: Script for generating patch for reviews\" % CAPITALIZED_PROJECT_NAME)\n+    'BOOKKEEPER-877: Script for generating patch for reviews'\n+    \"\"\"\n+    jira_refs = []\n+    components = []\n+\n+    # Extract JIRA ref(s):\n+    pattern = re.compile(r'(%s[-\\s]*[0-9]{3,6})+' % CAPITALIZED_PROJECT_NAME, re.IGNORECASE)\n+    for ref in pattern.findall(text):\n+        # Add brackets, replace spaces with a dash, & convert to uppercase\n+        jira_refs.append(re.sub(r'\\s+', '-', ref.upper()))\n+        text = text.replace(ref, '')\n+\n+    # Extract project name component(s):\n+    # Look for alphanumeric chars, spaces, dashes, periods, and/or commas\n+    pattern = re.compile(r'(\\[[\\w\\s,-\\.]+\\])', re.IGNORECASE)\n+    for component in pattern.findall(text):\n+        components.append(component.upper())\n+        text = text.replace(component, '')\n+\n+    # Cleanup any remaining symbols:\n+    pattern = re.compile(r'^\\W+(.*)', re.IGNORECASE)\n+    if (pattern.search(text) is not None):\n+        text = pattern.search(text).groups()[0]\n+\n+    # Assemble full text (JIRA ref(s), module(s), remaining text)\n+    jira_prefix = ' '.join(jira_refs).strip()\n+    if jira_prefix:\n+        jira_prefix = jira_prefix + \": \"\n+    clean_text = jira_prefix + ' '.join(components).strip() + \" \" + text.strip()\n+\n+    # Replace multiple spaces with a single space, e.g. if no jira refs and/or components were included\n+    clean_text = re.sub(r'\\s+', ' ', clean_text.strip())\n+\n+    return clean_text\n+\n+def main():\n+    global original_head\n+\n+    original_head = get_current_branch()\n+\n+    branches = get_json(\"%s/branches\" % GITHUB_API_BASE)\n+    branch_names = filter(lambda x: x.startswith(RELEASE_BRANCH_PREFIX), [x['name'] for x in branches])\n+    # Assumes branch names can be sorted lexicographically\n+    latest_branch = sorted(branch_names, reverse=True)[0]\n+\n+    pr_num = raw_input(\"Which pull request would you like to merge? (e.g. 34): \")\n+    pr = get_json(\"%s/pulls/%s\" % (GITHUB_API_BASE, pr_num))\n+    pr_events = get_json(\"%s/issues/%s/events\" % (GITHUB_API_BASE, pr_num))\n+\n+    url = pr[\"url\"]\n+\n+    pr_title = pr[\"title\"]\n+    commit_title = raw_input(\"Commit title [%s]: \" % pr_title.encode(\"utf-8\")).decode(\"utf-8\")\n+    if commit_title == \"\":\n+        commit_title = pr_title\n+\n+    # Decide whether to use the modified title or not\n+    modified_title = standardize_jira_ref(commit_title)\n+    if modified_title != commit_title:\n+        print \"I've re-written the title as follows to match the standard format:\"\n+        print \"Original: %s\" % commit_title\n+        print \"Modified: %s\" % modified_title\n+        result = raw_input(\"Would you like to use the modified title? (y/n): \")\n+        if result.lower() == \"y\":\n+            commit_title = modified_title\n+            print \"Using modified title:\"\n+        else:\n+            print \"Using original title:\"\n+        print commit_title\n+\n+    body = pr[\"body\"]\n+    target_ref = pr[\"base\"][\"ref\"]\n+    user_login = pr[\"user\"][\"login\"]\n+    base_ref = pr[\"head\"][\"ref\"]\n+    pr_repo_desc = \"%s/%s\" % (user_login, base_ref)\n+\n+    # Merged pull requests don't appear as merged in the GitHub API;\n+    # Instead, they're closed by asfgit.\n+    merge_commits = \\\n+        [e for e in pr_events if e[\"actor\"][\"login\"] == \"asfgit\" and e[\"event\"] == \"closed\"]\n+\n+    if merge_commits:\n+        merge_hash = merge_commits[0][\"commit_id\"]\n+        message = get_json(\"%s/commits/%s\" % (GITHUB_API_BASE, merge_hash))[\"commit\"][\"message\"]\n+\n+        print \"Pull request %s has already been merged, assuming you want to backport\" % pr_num\n+        commit_is_downloaded = run_cmd(['git', 'rev-parse', '--quiet', '--verify',\n+                                    \"%s^{commit}\" % merge_hash]).strip() != \"\"\n+        if not commit_is_downloaded:\n+            fail(\"Couldn't find any merge commit for #%s, you may need to update HEAD.\" % pr_num)\n+\n+        print \"Found commit %s:\\n%s\" % (merge_hash, message)\n+        cherry_pick(pr_num, merge_hash, latest_branch)\n+        sys.exit(0)\n+\n+    if not bool(pr[\"mergeable\"]):\n+        msg = \"Pull request %s is not mergeable in its current form.\\n\" % pr_num + \\\n+            \"Continue? (experts only!)\"\n+        continue_maybe(msg)\n+\n+    print (\"\\n=== Pull Request #%s ===\" % pr_num)\n+    print (\"PR title\\t%s\\nCommit title\\t%s\\nSource\\t\\t%s\\nTarget\\t\\t%s\\nURL\\t\\t%s\" % (\n+        pr_title, commit_title, pr_repo_desc, target_ref, url))\n+    continue_maybe(\"Proceed with merging pull request #%s?\" % pr_num)\n+\n+    merged_refs = [target_ref]\n+\n+    merge_hash = merge_pr(pr_num, target_ref, commit_title, body, pr_repo_desc)\n+\n+    pick_prompt = \"Would you like to pick %s into another branch?\" % merge_hash\n+    while raw_input(\"\\n%s (y/n): \" % pick_prompt).lower() == \"y\":\n+        merged_refs = merged_refs + [cherry_pick(pr_num, merge_hash, latest_branch)]\n+\n+    if JIRA_IMPORTED:\n+        if JIRA_USERNAME and JIRA_PASSWORD:\n+            continue_maybe(\"Would you like to update an associated JIRA?\")\n+            jira_comment = \"Issue resolved by pull request %s\\n[%s/%s]\" % (pr_num, GITHUB_BASE, pr_num)\n+            resolve_jira_issues(commit_title, merged_refs, jira_comment)\n+        else:\n+            print \"JIRA_USERNAME and JIRA_PASSWORD not set\"\n+            print \"Exiting without trying to close the associated JIRA.\"\n+    else:\n+        print \"Could not find jira-python library. Run 'sudo pip install jira' to install.\"\n+        print \"Exiting without trying to close the associated JIRA.\"\n+\n+if __name__ == \"__main__\":\n+    import doctest\n+    (failure_count, test_count) = doctest.testmod()\n+    if (failure_count):\n+        exit(-1)\n+\n+    main()"}]}