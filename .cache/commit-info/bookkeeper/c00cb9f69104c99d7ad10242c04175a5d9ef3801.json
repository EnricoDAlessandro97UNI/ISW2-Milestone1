{"sha":"c00cb9f69104c99d7ad10242c04175a5d9ef3801","node_id":"MDY6Q29tbWl0NDc4NTkyNTI2OmMwMGNiOWY2OTEwNGM5OWQ3YWQxMDI0MmMwNDE3NWE1ZDllZjM4MDE=","commit":{"author":{"name":"Enrico Olivelli","email":"eolivelli@apache.org","date":"2017-07-27T03:04:03Z"},"committer":{"name":"Enrico Olivelli","email":"eolivelli@apache.org","date":"2017-07-27T03:04:03Z"},"message":"ISSUE #271: LedgerHandle#readEntries leaks ByteBufs\n\nAdd a setNettyUsePooledBuffers() client configuration option to let the user decide to use Pooled vs Unpooled ByteBufs.\nUsing v2 wire protocol Application receives the original ByteBuf return from Channel and it is responsible for 'releasing' it.\n\nAdd assertions on LedgerEntry to prevent the user from accessing data more then once\n\nAuthor: Enrico Olivelli <eolivelli@apache.org>\n\nReviewers: Matteo Merli, Sijie Guo\n\nThis closes #276 from eolivelli/issue-271-leaks, closes #271","tree":{"sha":"05702eec1b5237582d955ff97cbbb19bb3b07231","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/trees/05702eec1b5237582d955ff97cbbb19bb3b07231"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/commits/c00cb9f69104c99d7ad10242c04175a5d9ef3801","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/c00cb9f69104c99d7ad10242c04175a5d9ef3801","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/c00cb9f69104c99d7ad10242c04175a5d9ef3801","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/c00cb9f69104c99d7ad10242c04175a5d9ef3801/comments","author":{"login":"eolivelli","id":9469110,"node_id":"MDQ6VXNlcjk0NjkxMTA=","avatar_url":"https://avatars.githubusercontent.com/u/9469110?v=4","gravatar_id":"","url":"https://api.github.com/users/eolivelli","html_url":"https://github.com/eolivelli","followers_url":"https://api.github.com/users/eolivelli/followers","following_url":"https://api.github.com/users/eolivelli/following{/other_user}","gists_url":"https://api.github.com/users/eolivelli/gists{/gist_id}","starred_url":"https://api.github.com/users/eolivelli/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/eolivelli/subscriptions","organizations_url":"https://api.github.com/users/eolivelli/orgs","repos_url":"https://api.github.com/users/eolivelli/repos","events_url":"https://api.github.com/users/eolivelli/events{/privacy}","received_events_url":"https://api.github.com/users/eolivelli/received_events","type":"User","site_admin":false},"committer":{"login":"eolivelli","id":9469110,"node_id":"MDQ6VXNlcjk0NjkxMTA=","avatar_url":"https://avatars.githubusercontent.com/u/9469110?v=4","gravatar_id":"","url":"https://api.github.com/users/eolivelli","html_url":"https://github.com/eolivelli","followers_url":"https://api.github.com/users/eolivelli/followers","following_url":"https://api.github.com/users/eolivelli/following{/other_user}","gists_url":"https://api.github.com/users/eolivelli/gists{/gist_id}","starred_url":"https://api.github.com/users/eolivelli/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/eolivelli/subscriptions","organizations_url":"https://api.github.com/users/eolivelli/orgs","repos_url":"https://api.github.com/users/eolivelli/repos","events_url":"https://api.github.com/users/eolivelli/events{/privacy}","received_events_url":"https://api.github.com/users/eolivelli/received_events","type":"User","site_admin":false},"parents":[{"sha":"671ec2b21d6e603f00abc8f92a04bbec7d5750b2","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/671ec2b21d6e603f00abc8f92a04bbec7d5750b2","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/671ec2b21d6e603f00abc8f92a04bbec7d5750b2"}],"stats":{"total":209,"additions":205,"deletions":4},"files":[{"sha":"3187127c458c6e0b53977682cd899b041ac9ca69","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/client/LedgerEntry.java","status":"modified","additions":28,"deletions":3,"changes":31,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/c00cb9f69104c99d7ad10242c04175a5d9ef3801/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FLedgerEntry.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/c00cb9f69104c99d7ad10242c04175a5d9ef3801/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FLedgerEntry.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FLedgerEntry.java?ref=c00cb9f69104c99d7ad10242c04175a5d9ef3801","patch":"@@ -20,10 +20,12 @@\n  */\n package org.apache.bookkeeper.client;\n \n+import com.google.common.base.Preconditions;\n import io.netty.buffer.ByteBuf;\n import io.netty.buffer.ByteBufInputStream;\n \n import java.io.InputStream;\n+import org.apache.bookkeeper.conf.ClientConfiguration;\n \n /**\n  * Ledger entry. Its a simple tuple containing the ledger id, the entry-id, and\n@@ -53,22 +55,45 @@ public long getLength() {\n         return length;\n     }\n \n+    /**\n+     * Returns the content of the entry.\n+     * This method can be called only once. While using v2 wire protocol this method will automatically release\n+     * the internal ByteBuf\n+     * \n+     * @return the content of the entry\n+     */\n     public byte[] getEntry() {\n+        Preconditions.checkNotNull(data, \"entry content can be accessed only once\");\n         byte[] entry = new byte[data.readableBytes()];\n         data.readBytes(entry);\n         data.release();\n+        data = null;\n         return entry;\n     }\n \n+    /**\n+     * Returns the content of the entry.\n+     * This method can be called only once. While using v2 wire protocol this method will automatically release\n+     * the internal ByteBuf when calling the close\n+     * method of the returned InputStream\n+     *\n+     * @return an InputStream which gives access to the content of the entry\n+     */\n     public InputStream getEntryInputStream() {\n-        return new ByteBufInputStream(data);\n+        Preconditions.checkNotNull(data, \"entry content can be accessed only once\");\n+        ByteBufInputStream res = new ByteBufInputStream(data);\n+        data = null;\n+        return res;\n     }\n \n     /**\n      * Return the internal buffer that contains the entry payload.\n-     * <p>\n      *\n-     * Note: It is responsibility of the caller to ensure to release the buffer after usage.\n+     * Note: Using v2 wire protocol it is responsibility of the caller to ensure to release the buffer after usage.\n+     *\n+     * @return a ByteBuf which contains the data\n+     *\n+     * @see ClientConfiguration#setNettyUsePooledBuffers(boolean)\n      */\n     public ByteBuf getEntryBuffer() {\n         return data;"},{"sha":"6252786d82d2abb9a42e7e8cfca207ac56bd839b","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/conf/ClientConfiguration.java","status":"modified","additions":30,"deletions":0,"changes":30,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/c00cb9f69104c99d7ad10242c04175a5d9ef3801/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fconf%2FClientConfiguration.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/c00cb9f69104c99d7ad10242c04175a5d9ef3801/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fconf%2FClientConfiguration.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fconf%2FClientConfiguration.java?ref=c00cb9f69104c99d7ad10242c04175a5d9ef3801","patch":"@@ -18,6 +18,7 @@\n package org.apache.bookkeeper.conf;\n \n import static com.google.common.base.Charsets.UTF_8;\n+import io.netty.buffer.ByteBuf;\n import static org.apache.bookkeeper.util.BookKeeperConstants.FEATURE_DISABLE_ENSEMBLE_CHANGE;\n \n import java.util.ArrayList;\n@@ -27,6 +28,7 @@\n \n import org.apache.bookkeeper.client.BookKeeper.DigestType;\n import org.apache.bookkeeper.client.EnsemblePlacementPolicy;\n+import org.apache.bookkeeper.client.LedgerHandle;\n import org.apache.bookkeeper.client.RackawareEnsemblePlacementPolicy;\n import org.apache.bookkeeper.replication.Auditor;\n import org.apache.bookkeeper.util.ReflectionUtils;\n@@ -62,6 +64,8 @@ public class ClientConfiguration extends AbstractConfiguration {\n     protected final static String CLIENT_CONNECT_TIMEOUT_MILLIS = \"clientConnectTimeoutMillis\";\n     protected final static String NUM_CHANNELS_PER_BOOKIE = \"numChannelsPerBookie\";\n     protected final static String USE_V2_WIRE_PROTOCOL = \"useV2WireProtocol\";\n+    protected final static String NETTY_USE_POOLED_BUFFERS = \"nettyUsePooledBuffers\";\n+\n     // Read Parameters\n     protected final static String READ_TIMEOUT = \"readTimeout\";\n     protected final static String SPECULATIVE_READ_TIMEOUT = \"speculativeReadTimeout\";\n@@ -1420,4 +1424,30 @@ public ClientConfiguration setDisableEnsembleChangeFeatureName(String disableEns\n         setProperty(DISABLE_ENSEMBLE_CHANGE_FEATURE_NAME, disableEnsembleChangeFeatureName);\n         return this;\n     }\n+\n+\n+    /**\n+     * Option to use Netty Pooled ByteBufs\n+     *\n+     * @return the value of the option\n+     */\n+    public boolean isNettyUsePooledBuffers() {\n+        return getBoolean(NETTY_USE_POOLED_BUFFERS, true);\n+    }\n+\n+    /**\n+     * Enable/Disable the usage of Pooled Netty buffers. While using v2 wire protocol the application will be\n+     * responsible for releasing ByteBufs returned by BookKeeper\n+     *\n+     * @param enabled\n+     *          if enabled BookKeeper will use default Pooled Netty Buffer allocator\n+     *\n+     * @see #setUseV2WireProtocol(boolean)\n+     * @see ByteBuf#release()\n+     * @see LedgerHandle#readEntries(long, long)\n+     */\n+    public ClientConfiguration setNettyUsePooledBuffers(boolean enabled) {\n+        setProperty(NETTY_USE_POOLED_BUFFERS, enabled);\n+        return this;\n+    }\n }"},{"sha":"9ba75d19641f95f769b2c0aee85f6f1b3ab9d3b5","filename":"bookkeeper-server/src/main/java/org/apache/bookkeeper/proto/PerChannelBookieClient.java","status":"modified","additions":10,"deletions":1,"changes":11,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/c00cb9f69104c99d7ad10242c04175a5d9ef3801/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FPerChannelBookieClient.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/c00cb9f69104c99d7ad10242c04175a5d9ef3801/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FPerChannelBookieClient.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fproto%2FPerChannelBookieClient.java?ref=c00cb9f69104c99d7ad10242c04175a5d9ef3801","patch":"@@ -103,6 +103,8 @@\n \n import com.google.common.collect.Sets;\n import com.google.protobuf.ExtensionRegistry;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.buffer.UnpooledByteBufAllocator;\n import java.net.SocketAddress;\n \n import org.apache.bookkeeper.auth.BookKeeperPrincipal;\n@@ -306,7 +308,14 @@ protected ChannelFuture connect() {\n             bootstrap.channel(NioSocketChannel.class);\n         }\n \n-        bootstrap.option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT);\n+        ByteBufAllocator allocator;\n+        if (this.conf.isNettyUsePooledBuffers()) {\n+            allocator = PooledByteBufAllocator.DEFAULT;\n+        } else {\n+            allocator = UnpooledByteBufAllocator.DEFAULT;\n+        }\n+\n+        bootstrap.option(ChannelOption.ALLOCATOR, allocator);\n         bootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, conf.getClientConnectTimeoutMillis());\n         bootstrap.option(ChannelOption.WRITE_BUFFER_WATER_MARK, new WriteBufferWaterMark(\n                 conf.getClientWriteBufferLowWaterMark(), conf.getClientWriteBufferHighWaterMark()));"},{"sha":"92ba0786f301ce8abf3942526a364d487105c890","filename":"bookkeeper-server/src/test/java/org/apache/bookkeeper/client/BookKeeperTest.java","status":"modified","additions":137,"deletions":0,"changes":137,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/c00cb9f69104c99d7ad10242c04175a5d9ef3801/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookKeeperTest.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/c00cb9f69104c99d7ad10242c04175a5d9ef3801/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookKeeperTest.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/bookkeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FBookKeeperTest.java?ref=c00cb9f69104c99d7ad10242c04175a5d9ef3801","patch":"@@ -1,5 +1,6 @@\n package org.apache.bookkeeper.client;\n \n+import io.netty.util.IllegalReferenceCountException;\n import java.util.Collections;\n import java.util.Enumeration;\n \n@@ -697,4 +698,140 @@ public void testReadWriteWithV2WireProtocol() throws Exception {\n             }\n         }\n     }\n+\n+    @Test(timeout = 60000)\n+    public void testReadEntryReleaseByteBufs() throws Exception {\n+        ClientConfiguration confWriter = new ClientConfiguration()\n+            .setZkServers(zkUtil.getZooKeeperConnectString());\n+        int numEntries = 10;\n+        byte[] data = \"foobar\".getBytes();\n+        long ledgerId;\n+        try (BookKeeper bkc = new BookKeeper(confWriter)) {\n+            try (LedgerHandle lh = bkc.createLedger(digestType, \"testPasswd\".getBytes())) {\n+                ledgerId = lh.getId();\n+                for (int i = 0; i < numEntries; i++) {\n+                    lh.addEntry(data);\n+                }\n+            }\n+        }\n+\n+        // v2 protocol, using pooled buffers\n+        ClientConfiguration confReader1 = new ClientConfiguration()\n+            .setZkServers(zkUtil.getZooKeeperConnectString())\n+            .setUseV2WireProtocol(true)\n+            .setNettyUsePooledBuffers(true);\n+        try (BookKeeper bkc = new BookKeeper(confReader1)) {\n+            try (LedgerHandle lh = bkc.openLedger(ledgerId, digestType, \"testPasswd\".getBytes())) {\n+                assertEquals(numEntries - 1, lh.readLastConfirmed());\n+                for (Enumeration<LedgerEntry> readEntries = lh.readEntries(0, numEntries - 1);\n+                    readEntries.hasMoreElements();) {\n+                    LedgerEntry entry = readEntries.nextElement();\n+                    assertTrue(entry.data.getClass().getName(),\n+                        entry.data.getClass().getName().contains(\"PooledNonRetainedSlicedByteBuf\"));\n+                    assertTrue(entry.data.release());\n+                    try {\n+                        entry.data.release();\n+                        fail(\"ByteBuf already released\");\n+                    } catch (IllegalReferenceCountException ok) {\n+                    }\n+                }\n+            }\n+        }\n+\n+        // v2 protocol, not using pooled buffers\n+        ClientConfiguration confReader2 = new ClientConfiguration()\n+            .setZkServers(zkUtil.getZooKeeperConnectString())\n+            .setUseV2WireProtocol(true)\n+            .setNettyUsePooledBuffers(false);\n+        try (BookKeeper bkc = new BookKeeper(confReader2)) {\n+            try (LedgerHandle lh = bkc.openLedger(ledgerId, digestType, \"testPasswd\".getBytes())) {\n+                assertEquals(numEntries - 1, lh.readLastConfirmed());\n+                for (Enumeration<LedgerEntry> readEntries = lh.readEntries(0, numEntries - 1);\n+                    readEntries.hasMoreElements();) {\n+                    LedgerEntry entry = readEntries.nextElement();\n+                    // ButeBufs no reference counter\n+                    assertTrue(entry.data.release());\n+                    assertTrue(entry.data.getClass().getName(),\n+                        entry.data.getClass().getName().contains(\"UnpooledSlicedByteBuf\"));\n+                    try {\n+                        entry.data.release();\n+                        fail(\"ByteBuf already released\");\n+                    } catch (IllegalReferenceCountException ok) {\n+                    }\n+                }\n+            }\n+        }\n+\n+        // v3 protocol, not using pooled buffers\n+        ClientConfiguration confReader3 = new ClientConfiguration()\n+            .setZkServers(zkUtil.getZooKeeperConnectString())\n+            .setUseV2WireProtocol(false)\n+            .setNettyUsePooledBuffers(false);\n+        try (BookKeeper bkc = new BookKeeper(confReader3)) {\n+            try (LedgerHandle lh = bkc.openLedger(ledgerId, digestType, \"testPasswd\".getBytes())) {\n+                assertEquals(numEntries - 1, lh.readLastConfirmed());\n+                for (Enumeration<LedgerEntry> readEntries = lh.readEntries(0, numEntries - 1);\n+                    readEntries.hasMoreElements();) {\n+                    LedgerEntry entry = readEntries.nextElement();\n+                    // ButeBufs not reference counter\n+                    assertTrue(entry.data.getClass().getName(),\n+                        entry.data.getClass().getName().contains(\"UnpooledSlicedByteBuf\"));\n+                    assertTrue(entry.data.release());\n+                    try {\n+                        entry.data.release();\n+                        fail(\"ByteBuf already released\");\n+                    } catch (IllegalReferenceCountException ok) {\n+                    }\n+                }\n+            }\n+        }\n+\n+        // v3 protocol, using pooled buffers\n+        // v3 protocol from 4.5 always \"wraps\" buffers returned by protobuf\n+        ClientConfiguration confReader4 = new ClientConfiguration()\n+            .setZkServers(zkUtil.getZooKeeperConnectString())\n+            .setUseV2WireProtocol(false)\n+            .setNettyUsePooledBuffers(true);\n+        try (BookKeeper bkc = new BookKeeper(confReader4)) {\n+            try (LedgerHandle lh = bkc.openLedger(ledgerId, digestType, \"testPasswd\".getBytes())) {\n+                assertEquals(numEntries - 1, lh.readLastConfirmed());\n+                for (Enumeration<LedgerEntry> readEntries = lh.readEntries(0, numEntries - 1);\n+                    readEntries.hasMoreElements();) {\n+                    LedgerEntry entry = readEntries.nextElement();\n+                    // ButeBufs not reference counter\n+                    assertTrue(entry.data.getClass().getName(),\n+                        entry.data.getClass().getName().contains(\"UnpooledSlicedByteBuf\"));\n+                    assertTrue(entry.data.release());\n+                    try {\n+                        entry.data.release();\n+                        fail(\"ByteBuf already released\");\n+                    } catch (IllegalReferenceCountException ok) {\n+                    }                }\n+            }\n+        }\n+\n+        // cannot read twice an entry\n+        ClientConfiguration confReader5 = new ClientConfiguration()\n+            .setZkServers(zkUtil.getZooKeeperConnectString());\n+        try (BookKeeper bkc = new BookKeeper(confReader5)) {\n+            try (LedgerHandle lh = bkc.openLedger(ledgerId, digestType, \"testPasswd\".getBytes())) {\n+                assertEquals(numEntries - 1, lh.readLastConfirmed());\n+                for (Enumeration<LedgerEntry> readEntries = lh.readEntries(0, numEntries - 1);\n+                    readEntries.hasMoreElements();) {\n+                    LedgerEntry entry = readEntries.nextElement();\n+                    entry.getEntry();\n+                    try {\n+                        entry.getEntry();\n+                        fail(\"entry data accessed twice\");\n+                    } catch (IllegalStateException ok){\n+                    }\n+                    try {\n+                        entry.getEntryInputStream();\n+                        fail(\"entry data accessed twice\");\n+                    } catch (IllegalStateException ok){\n+                    }\n+                }\n+            }\n+        }\n+    }\n }"}]}